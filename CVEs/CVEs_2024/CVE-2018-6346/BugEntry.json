{"buggy_code": ["/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/HTTP2Constants.h>\n#include <proxygen/lib/http/codec/CodecUtil.h>\n#include <proxygen/lib/utils/Logging.h>\n#include <proxygen/lib/utils/Base64.h>\n\n#include <folly/Conv.h>\n#include <folly/Random.h>\n#include <folly/ThreadLocal.h>\n#include <folly/io/Cursor.h>\n#include <folly/tracing/ScopedTraceSection.h>\n#include <type_traits>\n\nusing namespace proxygen::compress;\nusing namespace folly::io;\nusing namespace folly;\n\nusing std::string;\n\nnamespace {\nstd::string base64url_encode(ByteRange range) {\n  return proxygen::Base64::urlEncode(range);\n}\n\nstd::string base64url_decode(const std::string& str) {\n  return proxygen::Base64::urlDecode(str);\n}\n\n}\n\nnamespace proxygen {\n\n\nHTTP2Codec::HTTP2Codec(TransportDirection direction)\n    : HTTPParallelCodec(direction),\n      headerCodec_(direction),\n      frameState_(direction == TransportDirection::DOWNSTREAM\n                  ? FrameState::UPSTREAM_CONNECTION_PREFACE\n                  : FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n\n  const auto maxHeaderListSize = egressSettings_.getSetting(\n    SettingsId::MAX_HEADER_LIST_SIZE);\n  if (maxHeaderListSize) {\n    headerCodec_.setMaxUncompressed(maxHeaderListSize->value);\n  }\n\n  VLOG(4) << \"creating \" << getTransportDirectionString(direction)\n          << \" HTTP/2 codec\";\n}\n\nHTTP2Codec::~HTTP2Codec() {}\n\n// HTTPCodec API\n\nsize_t HTTP2Codec::onIngress(const folly::IOBuf& buf) {\n  // TODO: ensure only 1 parse at a time on stack.\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - onIngress\");\n\n  Cursor cursor(&buf);\n  size_t parsed = 0;\n  ErrorCode connError = ErrorCode::NO_ERROR;\n  for (auto bufLen = cursor.totalLength();\n       connError == ErrorCode::NO_ERROR;\n       bufLen = cursor.totalLength()) {\n    if (frameState_ == FrameState::UPSTREAM_CONNECTION_PREFACE) {\n      if (bufLen >= http2::kConnectionPreface.length()) {\n        auto test = cursor.readFixedString(http2::kConnectionPreface.length());\n        parsed += http2::kConnectionPreface.length();\n        if (test != http2::kConnectionPreface) {\n          goawayErrorMessage_ = \"missing connection preface\";\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::FRAME_HEADER ||\n               frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n      // Waiting to parse the common frame header\n      if (bufLen >= http2::kFrameHeaderSize) {\n        connError = parseFrameHeader(cursor, curHeader_);\n        parsed += http2::kFrameHeaderSize;\n        if (frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE &&\n            curHeader_.type != http2::FrameType::SETTINGS) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: got invalid connection preface frame type=\",\n              getFrameTypeString(curHeader_.type), \"(\", curHeader_.type, \")\",\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        if (curHeader_.length > maxRecvFrameSize()) {\n          VLOG(4) << \"Excessively large frame len=\" << curHeader_.length;\n          connError = ErrorCode::FRAME_SIZE_ERROR;\n        }\n\n        if (callback_) {\n          callback_->onFrameHeader(\n            curHeader_.stream,\n            curHeader_.flags,\n            curHeader_.length,\n            static_cast<uint8_t>(curHeader_.type));\n        }\n\n        frameState_ = (curHeader_.type == http2::FrameType::DATA) ?\n          FrameState::DATA_FRAME_DATA : FrameState::FRAME_DATA;\n        pendingDataFrameBytes_ = curHeader_.length;\n        pendingDataFramePaddingBytes_ = 0;\n#ifndef NDEBUG\n        receivedFrameCount_++;\n#endif\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::DATA_FRAME_DATA && bufLen > 0 &&\n               (bufLen < curHeader_.length ||\n                pendingDataFrameBytes_ < curHeader_.length)) {\n      // FrameState::DATA_FRAME_DATA with partial data only\n      size_t dataParsed = 0;\n      connError = parseDataFrameData(cursor, bufLen, dataParsed);\n      if (dataParsed == 0 && pendingDataFrameBytes_ > 0) {\n        // We received only the padding byte, we will wait for more\n        break;\n      } else {\n        parsed += dataParsed;\n        if (pendingDataFrameBytes_ == 0) {\n          frameState_ = FrameState::FRAME_HEADER;\n        }\n      }\n    } else { // FrameState::FRAME_DATA\n             // or FrameState::DATA_FRAME_DATA with all data available\n      // Already parsed the common frame header\n      const auto frameLen = curHeader_.length;\n      if (bufLen >= frameLen) {\n        connError = parseFrame(cursor);\n        parsed += curHeader_.length;\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    }\n  }\n  checkConnectionError(connError, &buf);\n  return parsed;\n}\n\nErrorCode HTTP2Codec::parseFrame(folly::io::Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseFrame\");\n  if (expectedContinuationStream_ != 0 &&\n       (curHeader_.type != http2::FrameType::CONTINUATION ||\n        expectedContinuationStream_ != curHeader_.stream)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: while expected CONTINUATION with stream=\",\n        expectedContinuationStream_, \", received streamID=\", curHeader_.stream,\n        \" of type=\", getFrameTypeString(curHeader_.type));\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (expectedContinuationStream_ == 0 &&\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: unexpected CONTINUATION received with streamID=\",\n        curHeader_.stream);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (frameAffectsCompression(curHeader_.type) &&\n      curHeaderBlock_.chainLength() + curHeader_.length >\n      egressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE, 0)) {\n    // this may be off by up to the padding length (max 255), but\n    // these numbers are already so generous, and we're comparing the\n    // max-uncompressed to the actual compressed size.  Let's fail\n    // before buffering.\n\n    // TODO(t6513634): it would be nicer to stream-process this header\n    // block to keep the connection state consistent without consuming\n    // memory, and fail just the request per the HTTP/2 spec (section\n    // 10.3)\n    goawayErrorMessage_ = folly::to<string>(\n      \"Failing connection due to excessively large headers\");\n    LOG(ERROR) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n\n  expectedContinuationStream_ =\n    (frameAffectsCompression(curHeader_.type) &&\n     !(curHeader_.flags & http2::END_HEADERS)) ? curHeader_.stream : 0;\n\n  switch (curHeader_.type) {\n    case http2::FrameType::DATA:\n      return parseAllData(cursor);\n    case http2::FrameType::HEADERS:\n      return parseHeaders(cursor);\n    case http2::FrameType::PRIORITY:\n      return parsePriority(cursor);\n    case http2::FrameType::RST_STREAM:\n      return parseRstStream(cursor);\n    case http2::FrameType::SETTINGS:\n      return parseSettings(cursor);\n    case http2::FrameType::PUSH_PROMISE:\n      return parsePushPromise(cursor);\n    case http2::FrameType::EX_HEADERS:\n      if (ingressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS, 0)) {\n        return parseExHeaders(cursor);\n      } else {\n        VLOG(2) << \"EX_HEADERS not enabled, ignoring the frame\";\n        break;\n      }\n    case http2::FrameType::PING:\n      return parsePing(cursor);\n    case http2::FrameType::GOAWAY:\n      return parseGoaway(cursor);\n    case http2::FrameType::WINDOW_UPDATE:\n      return parseWindowUpdate(cursor);\n    case http2::FrameType::CONTINUATION:\n      return parseContinuation(cursor);\n    case http2::FrameType::ALTSVC:\n      // fall through, unimplemented\n      break;\n    case http2::FrameType::CERTIFICATE_REQUEST:\n      return parseCertificateRequest(cursor);\n    case http2::FrameType::CERTIFICATE:\n      return parseCertificate(cursor);\n    default:\n      // Implementations MUST ignore and discard any frame that has a\n      // type that is unknown\n      break;\n  }\n\n  // Landing here means unknown, unimplemented or ignored frame.\n  VLOG(2) << \"Skipping frame (type=\" << (uint8_t)curHeader_.type << \")\";\n  cursor.skip(curHeader_.length);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::handleEndStream() {\n  if (curHeader_.type != http2::FrameType::HEADERS &&\n      curHeader_.type != http2::FrameType::EX_HEADERS &&\n      curHeader_.type != http2::FrameType::CONTINUATION &&\n      curHeader_.type != http2::FrameType::DATA) {\n    return ErrorCode::NO_ERROR;\n  }\n\n  // do we need to handle case where this stream has already aborted via\n  // another callback (onHeadersComplete/onBody)?\n  pendingEndStreamHandling_ |= (curHeader_.flags & http2::END_STREAM);\n\n  // with a websocket upgrade, we need to send message complete cb to\n  // mirror h1x codec's behavior. when the stream closes, we need to\n  // send another callback to clean up the stream's resources.\n  if (ingressWebsocketUpgrade_) {\n    ingressWebsocketUpgrade_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, true);\n  }\n\n  if (pendingEndStreamHandling_ && expectedContinuationStream_ == 0) {\n    pendingEndStreamHandling_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, false);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseAllData(Cursor& cursor) {\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing all frame DATA bytes for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto ret = http2::parseData(cursor, curHeader_, outData, padding);\n  RETURN_IF_ERROR(ret);\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return handleEndStream();\n}\n\nErrorCode HTTP2Codec::parseDataFrameData(Cursor& cursor,\n                                         size_t bufLen,\n                                         size_t& parsed) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseDataFrameData\");\n  if (bufLen == 0) {\n    VLOG(10) << \"No data to parse\";\n    return ErrorCode::NO_ERROR;\n  }\n\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing DATA frame data for stream=\" << curHeader_.stream <<\n    \" frame data length=\" << curHeader_.length << \" pendingDataFrameBytes_=\" <<\n    pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n    pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n    \" parsed=\" << parsed;\n  // Parse the padding information only the first time\n  if (pendingDataFrameBytes_ == curHeader_.length &&\n    pendingDataFramePaddingBytes_ == 0) {\n    if (frameHasPadding(curHeader_) && bufLen == 1) {\n      // We need to wait for more bytes otherwise we won't be able to pass\n      // the correct padding to the first onBody call\n      return ErrorCode::NO_ERROR;\n    }\n    const auto ret = http2::parseDataBegin(cursor, curHeader_, parsed, padding);\n    RETURN_IF_ERROR(ret);\n    if (padding > 0) {\n      pendingDataFramePaddingBytes_ = padding - 1;\n      pendingDataFrameBytes_--;\n      bufLen--;\n      parsed++;\n    }\n    VLOG(10) << \"out padding=\" << padding << \" pendingDataFrameBytes_=\" <<\n      pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n      pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n      \" parsed=\" << parsed;\n  }\n  if (bufLen > 0) {\n    // Check if we have application data to parse\n    if (pendingDataFrameBytes_ > pendingDataFramePaddingBytes_) {\n      const size_t pendingAppData =\n        pendingDataFrameBytes_ - pendingDataFramePaddingBytes_;\n      const size_t toClone = std::min(pendingAppData, bufLen);\n      cursor.clone(outData, toClone);\n      bufLen -= toClone;\n      pendingDataFrameBytes_ -= toClone;\n      parsed += toClone;\n      VLOG(10) << \"parsed some app data, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n    // Check if we have padding bytes to parse\n    if (bufLen > 0 && pendingDataFramePaddingBytes_ > 0) {\n      size_t toSkip = 0;\n      auto ret = http2::parseDataEnd(cursor, bufLen,\n                                     pendingDataFramePaddingBytes_, toSkip);\n      RETURN_IF_ERROR(ret);\n      pendingDataFrameBytes_ -= toSkip;\n      pendingDataFramePaddingBytes_ -= toSkip;\n      parsed += toSkip;\n      VLOG(10) << \"parsed some padding, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n  }\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return (pendingDataFrameBytes_ > 0) ? ErrorCode::NO_ERROR : handleEndStream();\n}\n\n\nErrorCode HTTP2Codec::parseHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseHeaders\");\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing HEADERS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseHeaders(cursor, curHeader_, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, true /* trailersAllowed */));\n  }\n  err = parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                         folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseExHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseExHeaders\");\n  HTTPCodec::ExAttributes exAttributes;\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing ExHEADERS frame for stream=\" << curHeader_.stream\n          << \" length=\" << curHeader_.length;\n  auto err = http2::parseExHeaders(\n      cursor, curHeader_, exAttributes, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (isRequest(curHeader_.stream)) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, false /* trailersAllowed */));\n  }\n  return parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                          exAttributes);\n}\n\nErrorCode HTTP2Codec::parseContinuation(Cursor& cursor) {\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing CONTINUATION frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseContinuation(cursor, curHeader_, headerBuf);\n  RETURN_IF_ERROR(err);\n  err = parseHeadersImpl(cursor, std::move(headerBuf),\n                         folly::none, folly::none, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseHeadersImpl(\n    Cursor& /*cursor*/,\n    std::unique_ptr<IOBuf> headerBuf,\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes) {\n  curHeaderBlock_.append(std::move(headerBuf));\n  std::unique_ptr<HTTPMessage> msg;\n  if (curHeader_.flags & http2::END_HEADERS) {\n    auto errorCode =\n        parseHeadersDecodeFrames(priority, promisedStream, exAttributes, msg);\n    if (errorCode.hasValue()) {\n      return errorCode.value();\n    }\n  }\n\n  // if we're not parsing CONTINUATION, then it's start of new header block\n  if (curHeader_.type != http2::FrameType::CONTINUATION) {\n    headerBlockFrameType_ = curHeader_.type;\n  }\n\n  // Report back what we've parsed\n  if (callback_) {\n    auto concurError = parseHeadersCheckConcurrentStreams(priority);\n    if (concurError.hasValue()) {\n      return concurError.value();\n    }\n    uint32_t headersCompleteStream = curHeader_.stream;\n    bool trailers = parsingTrailers();\n    bool allHeaderFramesReceived =\n        (curHeader_.flags & http2::END_HEADERS) &&\n        (headerBlockFrameType_ == http2::FrameType::HEADERS);\n    if (allHeaderFramesReceived && !trailers) {\n      // Only deliver onMessageBegin once per stream.\n      // For responses with CONTINUATION, this will be delayed until\n      // the frame with the END_HEADERS flag set.\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,\n                                    \"onMessageBegin\",\n                                    curHeader_.stream,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n   } else if (curHeader_.type == http2::FrameType::EX_HEADERS) {\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onExMessageBegin,\n                                    \"onExMessageBegin\",\n                                    curHeader_.stream,\n                                    exAttributes->controlStream,\n                                    exAttributes->unidirectional,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n    } else if (curHeader_.type == http2::FrameType::PUSH_PROMISE) {\n      DCHECK(promisedStream);\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onPushMessageBegin,\n                                    \"onPushMessageBegin\", *promisedStream,\n                                    curHeader_.stream, msg.get())) {\n        return handleEndStream();\n      }\n      headersCompleteStream = *promisedStream;\n    }\n\n    if (curHeader_.flags & http2::END_HEADERS && msg) {\n      if (!(curHeader_.flags & http2::END_STREAM)) {\n        // If it there are DATA frames coming, consider it chunked\n        msg->setIsChunked(true);\n      }\n      if (trailers) {\n        VLOG(4) << \"Trailers complete for streamId=\" << headersCompleteStream\n                << \" direction=\" << transportDirection_;\n        auto trailerHeaders =\n            std::make_unique<HTTPHeaders>(msg->extractHeaders());\n        msg.reset();\n        callback_->onTrailersComplete(headersCompleteStream,\n                                      std::move(trailerHeaders));\n      } else {\n        callback_->onHeadersComplete(headersCompleteStream, std::move(msg));\n      }\n    }\n    return handleEndStream();\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  // decompress headers\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    if (curHeader_.stream == priority->streamDependency) {\n      streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                    curHeader_.stream),\n                  ErrorCode::PROTOCOL_ERROR,\n                  curHeader_.type == http2::FrameType::HEADERS);\n      return ErrorCode::NO_ERROR;\n    }\n\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  // Saving this in case we need to log it on error\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  // Check decoding error\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    // Avoid logging header blocks that have failed decoding due to being\n    // excessively large.\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n\n    if (msg) {\n      // print the partial message\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n\n  // Check parsing error\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n\n  return folly::Optional<ErrorCode>();\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersCheckConcurrentStreams(\n    const folly::Optional<http2::PriorityUpdate>& priority) {\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::EX_HEADERS) {\n    if (curHeader_.flags & http2::PRIORITY) {\n      DCHECK(priority);\n      // callback_->onPriority(priority.get());\n    }\n\n    // callback checks total number of streams is smaller than settings max\n    if (callback_->numIncomingStreams() >=\n        egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,\n                                   std::numeric_limits<int32_t>::max())) {\n      streamError(folly::to<string>(\"Exceeded max_concurrent_streams\"),\n                  ErrorCode::REFUSED_STREAM, true);\n      return ErrorCode::NO_ERROR;\n    }\n  }\n  return folly::Optional<ErrorCode>();\n}\n\nvoid HTTP2Codec::onHeader(const folly::fbstring& name,\n                          const folly::fbstring& value) {\n  if (decodeInfo_.onHeader(name, value)) {\n    if (name == \"user-agent\" && userAgent_.empty()) {\n      userAgent_ = value.toStdString();\n    }\n  } else {\n    VLOG(4) << \"dir=\" << uint32_t(transportDirection_) <<\n      decodeInfo_.parsingError << \" codec=\" << headerCodec_;\n  }\n}\n\nvoid HTTP2Codec::onHeadersComplete(HTTPHeaderSize decodedSize,\n                                   bool /*acknowledge*/) {\n  decodeInfo_.onHeadersComplete(decodedSize);\n  decodeInfo_.msg->setAdvancedProtocolString(http2::kProtocolString);\n\n  HTTPMessage* msg = decodeInfo_.msg.get();\n  HTTPRequestVerifier& verifier = decodeInfo_.verifier;\n  if ((transportDirection_ == TransportDirection::DOWNSTREAM) &&\n      verifier.hasUpgradeProtocol() &&\n      (*msg->getUpgradeProtocol() == headers::kWebsocketString) &&\n      msg->getMethod() == HTTPMethod::CONNECT) {\n    msg->setIngressWebsocketUpgrade();\n    ingressWebsocketUpgrade_ = true;\n  } else {\n    auto it = upgradedStreams_.find(curHeader_.stream);\n    if (it != upgradedStreams_.end()) {\n      upgradedStreams_.erase(curHeader_.stream);\n      // a websocket upgrade was sent on this stream.\n      if (msg->getStatusCode() != 200) {\n        decodeInfo_.parsingError =\n          folly::to<string>(\"Invalid response code to a websocket upgrade: \",\n                            msg->getStatusCode());\n        return;\n      }\n      msg->setIngressWebsocketUpgrade();\n    }\n  }\n}\n\nvoid HTTP2Codec::onDecodeError(HPACK::DecodeError decodeError) {\n  decodeInfo_.decodeError = decodeError;\n}\n\nErrorCode HTTP2Codec::parsePriority(Cursor& cursor) {\n  VLOG(4) << \"parsing PRIORITY frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  http2::PriorityUpdate pri;\n  auto err = http2::parsePriority(cursor, curHeader_, pri);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.stream == pri.streamDependency) {\n    streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                  curHeader_.stream),\n                ErrorCode::PROTOCOL_ERROR, false);\n    return ErrorCode::NO_ERROR;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onPriority, \"onPriority\",\n                           curHeader_.stream,\n                           std::make_tuple(pri.streamDependency,\n                                           pri.exclusive,\n                                           pri.weight));\n  return ErrorCode::NO_ERROR;\n}\n\nsize_t HTTP2Codec::addPriorityNodes(\n    PriorityQueue& queue,\n    folly::IOBufQueue& writeBuf,\n    uint8_t maxLevel) {\n  HTTPCodec::StreamID parent = 0;\n  size_t bytes = 0;\n  while (maxLevel--) {\n    auto id = createStream();\n    virtualPriorityNodes_.push_back(id);\n    queue.addPriorityNode(id, parent);\n    bytes += generatePriority(writeBuf, id, std::make_tuple(parent, false, 0));\n    parent = id;\n  }\n  return bytes;\n}\n\nErrorCode HTTP2Codec::parseRstStream(Cursor& cursor) {\n  // rst for stream in idle state - protocol error\n  VLOG(4) << \"parsing RST_STREAM frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  upgradedStreams_.erase(curHeader_.stream);\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  auto err = http2::parseRstStream(cursor, curHeader_, statusCode);\n  RETURN_IF_ERROR(err);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: RST_STREAM with code=\", getErrorCodeString(statusCode),\n        \" for streamID=\", curHeader_.stream, \" user-agent=\", userAgent_);\n    VLOG(2) << goawayErrorMessage_;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onAbort, \"onAbort\",\n                           curHeader_.stream, statusCode);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseSettings(Cursor& cursor) {\n  VLOG(4) << \"parsing SETTINGS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  std::deque<SettingPair> settings;\n  auto err = http2::parseSettings(cursor, curHeader_, settings);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.flags & http2::ACK) {\n    handleSettingsAck();\n    return ErrorCode::NO_ERROR;\n  }\n  return handleSettings(settings);\n}\n\nvoid HTTP2Codec::handleSettingsAck() {\n  if (pendingTableMaxSize_) {\n    headerCodec_.setDecoderHeaderTableMaxSize(*pendingTableMaxSize_);\n    pendingTableMaxSize_ = folly::none;\n  }\n  if (callback_) {\n    callback_->onSettingsAck();\n  }\n}\n\nErrorCode HTTP2Codec::handleSettings(const std::deque<SettingPair>& settings) {\n  SettingsList settingsList;\n  for (auto& setting: settings) {\n    switch (setting.first) {\n      case SettingsId::HEADER_TABLE_SIZE:\n      {\n        uint32_t tableSize = setting.second;\n        if (setting.second > http2::kMaxHeaderTableSize) {\n          VLOG(2) << \"Limiting table size from \" << tableSize << \" to \" <<\n            http2::kMaxHeaderTableSize;\n          tableSize = http2::kMaxHeaderTableSize;\n        }\n        headerCodec_.setEncoderHeaderTableSize(tableSize);\n      }\n      break;\n      case SettingsId::ENABLE_PUSH:\n        if ((setting.second != 0 && setting.second != 1) ||\n            (setting.second == 1 &&\n             transportDirection_ == TransportDirection::UPSTREAM)) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_PUSH invalid setting=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n        break;\n      case SettingsId::INITIAL_WINDOW_SIZE:\n        if (setting.second > http2::kMaxWindowUpdateSize) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: INITIAL_WINDOW_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_FRAME_SIZE:\n        if (setting.second < http2::kMaxFramePayloadLengthMin ||\n            setting.second > http2::kMaxFramePayloadLength) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: MAX_FRAME_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        ingressSettings_.setSetting(SettingsId::MAX_FRAME_SIZE, setting.second);\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n      {\n        auto ptr = egressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS);\n        if (ptr && ptr->value > 0) {\n          VLOG(4) << getTransportDirectionString(getTransportDirection())\n                  << \" got ENABLE_EX_HEADERS=\" << setting.second;\n          if (setting.second != 0 && setting.second != 1) {\n            goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: invalid ENABLE_EX_HEADERS=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n            VLOG(4) << goawayErrorMessage_;\n            return ErrorCode::PROTOCOL_ERROR;\n          }\n          break;\n        } else {\n          // egress ENABLE_EX_HEADERS is disabled, consider the ingress\n          // ENABLE_EX_HEADERS as unknown setting, and ignore it.\n          continue;\n        }\n      }\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.second > 1) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_CONNECT_PROTOCOL invalid number=\",\n              setting.second, \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      case SettingsId::SETTINGS_HTTP_CERT_AUTH:\n        break;\n      default:\n        continue; // ignore unknown setting\n    }\n    ingressSettings_.setSetting(setting.first, setting.second);\n    settingsList.push_back(*ingressSettings_.getSetting(setting.first));\n  }\n  if (callback_) {\n    callback_->onSettings(settingsList);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parsePushPromise(Cursor& cursor) {\n  // stream id must be idle - protocol error\n  // assoc-stream-id=closed/unknown - protocol error, unless rst_stream sent\n\n  /*\n   * What does \"must handle\" mean in the following context?  I have to\n   * accept this as a valid pushed resource?\n\n    However, an endpoint that has sent RST_STREAM on the associated\n    stream MUST handle PUSH_PROMISE frames that might have been\n    created before the RST_STREAM frame is received and processed.\n  */\n  if (transportDirection_ != TransportDirection::UPSTREAM) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on DOWNSTREAM codec\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (egressSettings_.getSetting(SettingsId::ENABLE_PUSH, -1) != 1) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on codec with push disabled\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  VLOG(4) << \"parsing PUSH_PROMISE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t promisedStream;\n  std::unique_ptr<IOBuf> headerBlockFragment;\n  auto err = http2::parsePushPromise(cursor, curHeader_, promisedStream,\n                                     headerBlockFragment);\n  RETURN_IF_ERROR(err);\n  RETURN_IF_ERROR(checkNewStream(promisedStream, false /* trailersAllowed */));\n  err = parseHeadersImpl(cursor, std::move(headerBlockFragment), folly::none,\n                         promisedStream, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parsePing(Cursor& cursor) {\n  VLOG(4) << \"parsing PING frame length=\" << curHeader_.length;\n  uint64_t opaqueData = 0;\n  auto err = http2::parsePing(cursor, curHeader_, opaqueData);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    if (curHeader_.flags & http2::ACK) {\n      callback_->onPingReply(opaqueData);\n    } else {\n      callback_->onPingRequest(opaqueData);\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseGoaway(Cursor& cursor) {\n  VLOG(4) << \"parsing GOAWAY frame length=\" << curHeader_.length;\n  uint32_t lastGoodStream = 0;\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  std::unique_ptr<IOBuf> debugData;\n\n  auto err = http2::parseGoaway(cursor, curHeader_, lastGoodStream, statusCode,\n                                debugData);\n  if (statusCode != ErrorCode::NO_ERROR) {\n    VLOG(2) << \"Goaway error statusCode=\" << getErrorCodeString(statusCode)\n            << \" lastStream=\" << lastGoodStream\n            << \" user-agent=\" << userAgent_ <<  \" debugData=\" <<\n      ((debugData) ? string((char*)debugData->data(), debugData->length()):\n       empty_string);\n  }\n  RETURN_IF_ERROR(err);\n  if (lastGoodStream < ingressGoawayAck_) {\n    ingressGoawayAck_ = lastGoodStream;\n    // Drain all streams <= lastGoodStream\n    // and abort streams > lastGoodStream\n    if (callback_) {\n      callback_->onGoaway(lastGoodStream, statusCode, std::move(debugData));\n    }\n  } else {\n    LOG(WARNING) << \"Received multiple GOAWAY with increasing ack\";\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseWindowUpdate(Cursor& cursor) {\n  VLOG(4) << \"parsing WINDOW_UPDATE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t delta = 0;\n  auto err = http2::parseWindowUpdate(cursor, curHeader_, delta);\n  RETURN_IF_ERROR(err);\n  if (delta == 0) {\n    VLOG(4) << \"Invalid 0 length delta for stream=\" << curHeader_.stream;\n    if (curHeader_.stream == 0) {\n      goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid/0 length delta for streamID=\",\n        curHeader_.stream);\n      return ErrorCode::PROTOCOL_ERROR;\n    } else {\n      // Parsing a zero delta window update should cause a protocol error\n      // and send a rst stream\n      goawayErrorMessage_ = folly::to<string>(\n        \"parseWindowUpdate Invalid 0 length\");\n      VLOG(4) << goawayErrorMessage_;\n      streamError(folly::to<std::string>(\"streamID=\", curHeader_.stream,\n                                         \" with HTTP2Codec stream error: \",\n                                         \"window update delta=\", delta),\n                  ErrorCode::PROTOCOL_ERROR);\n      return ErrorCode::PROTOCOL_ERROR;\n    }\n  }\n  // if window exceeds 2^31-1, connection/stream error flow control error\n  // must be checked in session/txn\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onWindowUpdate,\n                           \"onWindowUpdate\", curHeader_.stream, delta);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificateRequest(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE_REQUEST frame length=\" << curHeader_.length;\n  uint16_t requestId = 0;\n  std::unique_ptr<IOBuf> authRequest;\n\n  auto err = http2::parseCertificateRequest(\n      cursor, curHeader_, requestId, authRequest);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    callback_->onCertificateRequest(requestId, std::move(authRequest));\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificate(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE frame length=\" << curHeader_.length;\n  uint16_t certId = 0;\n  std::unique_ptr<IOBuf> authData;\n  auto err = http2::parseCertificate(cursor, curHeader_, certId, authData);\n  RETURN_IF_ERROR(err);\n  if (curAuthenticatorBlock_.empty()) {\n    curCertId_ = certId;\n  } else if (certId != curCertId_) {\n    // Received CERTIFICATE frame with different Cert-ID.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  curAuthenticatorBlock_.append(std::move(authData));\n  if (curAuthenticatorBlock_.chainLength() > http2::kMaxAuthenticatorBufSize) {\n    // Received excessively long authenticator.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (!(curHeader_.flags & http2::TO_BE_CONTINUED)) {\n    auto authenticator = curAuthenticatorBlock_.move();\n    if (callback_) {\n      callback_->onCertificate(certId, std::move(authenticator));\n    } else {\n      curAuthenticatorBlock_.clear();\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n\n  if (isInitiatedStream(streamId)) {\n    // this stream should be initiated by us, not by peer\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}\n\nsize_t HTTP2Codec::generateConnectionPreface(folly::IOBufQueue& writeBuf) {\n  if (transportDirection_ == TransportDirection::UPSTREAM) {\n    VLOG(4) << \"generating connection preface\";\n    writeBuf.append(http2::kConnectionPreface);\n    return http2::kConnectionPreface.length();\n  }\n  return 0;\n}\n\nbool HTTP2Codec::onIngressUpgradeMessage(const HTTPMessage& msg) {\n  if (!HTTPParallelCodec::onIngressUpgradeMessage(msg)) {\n    return false;\n  }\n  if (msg.getHeaders().getNumberOfValues(http2::kProtocolSettingsHeader) != 1) {\n    VLOG(4) << __func__ << \" with no HTTP2-Settings\";\n    return false;\n  }\n\n  const auto& settingsHeader = msg.getHeaders().getSingleOrEmpty(\n    http2::kProtocolSettingsHeader);\n  if (settingsHeader.empty()) {\n    return true;\n  }\n\n  auto decoded = base64url_decode(settingsHeader);\n\n  // Must be well formed Base64Url and not too large\n  if (decoded.empty() || decoded.length() > http2::kMaxFramePayloadLength) {\n    VLOG(4) << __func__ << \" failed to decode HTTP2-Settings\";\n    return false;\n  }\n  std::unique_ptr<IOBuf> decodedBuf = IOBuf::wrapBuffer(decoded.data(),\n                                                        decoded.length());\n  IOBufQueue settingsQueue{IOBufQueue::cacheChainLength()};\n  settingsQueue.append(std::move(decodedBuf));\n  Cursor c(settingsQueue.front());\n  std::deque<SettingPair> settings;\n  // downcast is ok because of above length check\n  http2::FrameHeader frameHeader{\n    (uint32_t)settingsQueue.chainLength(), 0, http2::FrameType::SETTINGS, 0, 0};\n  auto err = http2::parseSettings(c, frameHeader, settings);\n  if (err != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" bad settings frame\";\n    return false;\n  }\n\n  if (handleSettings(settings) != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" handleSettings failed\";\n    return false;\n  }\n\n  return true;\n}\n\nvoid HTTP2Codec::generateHeader(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                const HTTPMessage& msg,\n                                bool eom,\n                                HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generatePushPromise(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     const HTTPMessage& msg,\n                                     StreamID assocStream,\n                                     bool eom,\n                                     HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     assocStream,\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateExHeader(folly::IOBufQueue& writeBuf,\n                                  StreamID stream,\n                                  const HTTPMessage& msg,\n                                  const HTTPCodec::ExAttributes& exAttributes,\n                                  bool eom,\n                                  HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     exAttributes,\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateHeaderImpl(\n    folly::IOBufQueue& writeBuf,\n    StreamID stream,\n    const HTTPMessage& msg,\n    const folly::Optional<StreamID>& assocStream,\n    const folly::Optional<HTTPCodec::ExAttributes>& exAttributes,\n    bool eom,\n    HTTPHeaderSize* size) {\n  if (assocStream) {\n    CHECK(!exAttributes);\n    VLOG(4) << \"generating PUSH_PROMISE for stream=\" << stream;\n  } else if (exAttributes) {\n    CHECK(!assocStream);\n    VLOG(4) << \"generating ExHEADERS for stream=\" << stream\n            << \" with control stream=\" << exAttributes->controlStream\n            << \" unidirectional=\" << exAttributes->unidirectional;\n  } else {\n    VLOG(4) << \"generating HEADERS for stream=\" << stream;\n  }\n\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing HEADERS/PROMISE for stream=\" << stream <<\n      \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    if (size) {\n      size->uncompressed = 0;\n      size->compressed = 0;\n    }\n    return;\n  }\n\n  if (msg.isRequest()) {\n    DCHECK(transportDirection_ == TransportDirection::UPSTREAM ||\n           assocStream || exAttributes);\n    if (msg.isEgressWebsocketUpgrade()) {\n      upgradedStreams_.insert(stream);\n    }\n  } else {\n    DCHECK(transportDirection_ == TransportDirection::DOWNSTREAM ||\n           exAttributes);\n  }\n\n  std::vector<std::string> temps;\n  auto allHeaders = CodecUtil::prepareMessageForCompression(msg, temps);\n  auto out = encodeHeaders(msg.getHeaders(), allHeaders, size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto res = msg.getHTTP2Priority();\n    auto remainingFrameSize = maxFrameSize;\n    if (res) {\n      pri = http2::PriorityUpdate{std::get<0>(*res), std::get<1>(*res),\n                                  std::get<2>(*res)};\n      DCHECK_GE(remainingFrameSize, http2::kFramePrioritySize)\n        << \"no enough space for priority? frameHeadroom=\" << remainingFrameSize;\n      remainingFrameSize -= http2::kFramePrioritySize;\n    }\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n\n    bool endHeaders = queue.chainLength() == 0;\n\n    if (assocStream) {\n      DCHECK_EQ(transportDirection_, TransportDirection::DOWNSTREAM);\n      DCHECK(!eom);\n      generateHeaderCallbackWrapper(stream, http2::FrameType::PUSH_PROMISE,\n                                    http2::writePushPromise(writeBuf,\n                                                            *assocStream,\n                                                            stream,\n                                                            std::move(chunk),\n                                                            http2::kNoPadding,\n                                                            endHeaders));\n    } else if (exAttributes) {\n      generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::EX_HEADERS,\n        http2::writeExHeaders(writeBuf,\n                              std::move(chunk),\n                              stream,\n                              *exAttributes,\n                              pri,\n                              http2::kNoPadding,\n                              eom,\n                              endHeaders));\n    } else {\n      generateHeaderCallbackWrapper(stream, http2::FrameType::HEADERS,\n                                    http2::writeHeaders(writeBuf,\n                                                        std::move(chunk),\n                                                        stream,\n                                                        pri,\n                                                        http2::kNoPadding,\n                                                        eom,\n                                                        endHeaders));\n    }\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n}\n\nvoid HTTP2Codec::generateContinuation(folly::IOBufQueue& writeBuf,\n                                      folly::IOBufQueue& queue,\n                                      StreamID stream,\n                                      size_t maxFrameSize) {\n  bool endHeaders = false;\n  while (!endHeaders) {\n    auto chunk = queue.split(std::min(maxFrameSize, queue.chainLength()));\n    endHeaders = (queue.chainLength() == 0);\n    VLOG(4) << \"generating CONTINUATION for stream=\" << stream;\n    generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::CONTINUATION,\n        http2::writeContinuation(\n            writeBuf, stream, endHeaders, std::move(chunk)));\n  }\n}\n\nstd::unique_ptr<folly::IOBuf> HTTP2Codec::encodeHeaders(\n    const HTTPHeaders& headers,\n    std::vector<compress::Header>& allHeaders,\n    HTTPHeaderSize* size) {\n  headerCodec_.setEncodeHeadroom(http2::kFrameHeaderSize +\n                                 http2::kFrameHeadersBaseMaxSize);\n  auto out = headerCodec_.encode(allHeaders);\n  if (size) {\n    *size = headerCodec_.getEncodedSize();\n  }\n\n  if (headerCodec_.getEncodedSize().uncompressed >\n      ingressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE,\n                                  std::numeric_limits<uint32_t>::max())) {\n    // The remote side told us they don't want headers this large...\n    // but this function has no mechanism to fail\n    string serializedHeaders;\n    headers.forEach(\n      [&serializedHeaders] (const string& name, const string& value) {\n        serializedHeaders = folly::to<string>(serializedHeaders, \"\\\\n\", name,\n                                              \":\", value);\n      });\n    LOG(ERROR) << \"generating HEADERS frame larger than peer maximum nHeaders=\"\n               << headers.size() << \" all headers=\"\n               << serializedHeaders;\n  }\n  return out;\n}\n\nsize_t HTTP2Codec::generateHeaderCallbackWrapper(StreamID stream,\n                                                 http2::FrameType type,\n                                                 size_t length) {\n  if (callback_) {\n    callback_->onGenerateFrameHeader(stream,\n                                     static_cast<uint8_t>(type),\n                                     length);\n  }\n  return length;\n}\n\nsize_t HTTP2Codec::generateBody(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                std::unique_ptr<folly::IOBuf> chain,\n                                folly::Optional<uint8_t> padding,\n                                bool eom) {\n  // todo: generate random padding for everything?\n  size_t written = 0;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing DATA for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(chain));\n  size_t maxFrameSize = maxSendFrameSize();\n  while (queue.chainLength() > maxFrameSize) {\n    auto chunk = queue.split(maxFrameSize);\n    written += generateHeaderCallbackWrapper(\n                  stream,\n                  http2::FrameType::DATA,\n                  http2::writeData(writeBuf,\n                                   std::move(chunk),\n                                   stream,\n                                   padding,\n                                   false,\n                                   reuseIOBufHeadroomForData_));\n  }\n\n  return written + generateHeaderCallbackWrapper(\n                      stream,\n                      http2::FrameType::DATA,\n                      http2::writeData(writeBuf,\n                                       queue.move(),\n                                       stream,\n                                       padding,\n                                       eom,\n                                       reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateChunkHeader(folly::IOBufQueue& /*writeBuf*/,\n                                       StreamID /*stream*/,\n                                       size_t /*length*/) {\n  // HTTP/2 has no chunk headers\n  return 0;\n}\n\nsize_t HTTP2Codec::generateChunkTerminator(folly::IOBufQueue& /*writeBuf*/,\n                                           StreamID /*stream*/) {\n  // HTTP/2 has no chunk terminators\n  return 0;\n}\n\nsize_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true /*eom*/,\n                                                      endHeaders));\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n\n  return size.compressed;\n}\n\nsize_t HTTP2Codec::generateEOM(folly::IOBufQueue& writeBuf,\n                               StreamID stream) {\n  VLOG(4) << \"sending EOM for stream=\" << stream;\n  upgradedStreams_.erase(stream);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed EOM for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::DATA,\n            http2::writeData(writeBuf,\n                             nullptr,\n                             stream,\n                             http2::kNoPadding,\n                             true,\n                             reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateRstStream(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     ErrorCode statusCode) {\n  VLOG(4) << \"sending RST_STREAM for stream=\" << stream\n          << \" with code=\" << getErrorCodeString(statusCode);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed RST_STREAM for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  // Suppress any EOM callback for the current frame.\n  if (stream == curHeader_.stream) {\n    curHeader_.flags &= ~http2::END_STREAM;\n    pendingEndStreamHandling_ = false;\n    ingressWebsocketUpgrade_ = false;\n  }\n  upgradedStreams_.erase(stream);\n\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending RST_STREAM with code=\" << getErrorCodeString(statusCode)\n            << \" for stream=\" << stream << \" user-agent=\" << userAgent_;\n  }\n  auto code = http2::errorCodeToReset(statusCode);\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::RST_STREAM,\n                                       http2::writeRstStream(writeBuf, stream, code));\n}\n\nsize_t HTTP2Codec::generateGoaway(folly::IOBufQueue& writeBuf,\n                                  StreamID lastStream,\n                                  ErrorCode statusCode,\n                                  std::unique_ptr<folly::IOBuf> debugData) {\n  DCHECK_LE(lastStream, egressGoawayAck_) << \"Cannot increase last good stream\";\n  egressGoawayAck_ = lastStream;\n  if (sessionClosing_ == ClosingState::CLOSED) {\n    VLOG(4) << \"Not sending GOAWAY for closed session\";\n    return 0;\n  }\n  switch (sessionClosing_) {\n    case ClosingState::OPEN:\n    case ClosingState::OPEN_WITH_GRACEFUL_DRAIN_ENABLED:\n      if (lastStream == std::numeric_limits<int32_t>::max() &&\n          statusCode == ErrorCode::NO_ERROR) {\n        sessionClosing_ = ClosingState::FIRST_GOAWAY_SENT;\n      } else {\n        // The user of this codec decided not to do the double goaway\n        // drain, or this is not a graceful shutdown\n        sessionClosing_ = ClosingState::CLOSED;\n      }\n      break;\n    case ClosingState::FIRST_GOAWAY_SENT:\n      sessionClosing_ = ClosingState::CLOSED;\n      break;\n    case ClosingState::CLOSING:\n    case ClosingState::CLOSED:\n      LOG(FATAL) << \"unreachable\";\n  }\n\n  VLOG(4) << \"Sending GOAWAY with last acknowledged stream=\"\n          << lastStream << \" with code=\" << getErrorCodeString(statusCode);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending GOAWAY with last acknowledged stream=\" << lastStream\n            << \" with code=\" << getErrorCodeString(statusCode)\n            << \" user-agent=\" << userAgent_;\n  }\n\n  auto code = http2::errorCodeToGoaway(statusCode);\n  return generateHeaderCallbackWrapper(\n            0,\n            http2::FrameType::GOAWAY,\n            http2::writeGoaway(writeBuf,\n                              lastStream,\n                              code,\n                              std::move(debugData)));\n}\n\nsize_t HTTP2Codec::generatePingRequest(folly::IOBufQueue& writeBuf) {\n  // should probably let the caller specify when integrating with session\n  // we know HTTPSession sets up events to track ping latency\n  uint64_t opaqueData = folly::Random::rand64();\n  VLOG(4) << \"Generating ping request with opaqueData=\" << opaqueData;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, opaqueData, false /* no ack */));\n}\n\nsize_t HTTP2Codec::generatePingReply(folly::IOBufQueue& writeBuf,\n                                     uint64_t uniqueID) {\n  VLOG(4) << \"Generating ping reply with opaqueData=\" << uniqueID;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, uniqueID, true /* ack */));\n}\n\nsize_t HTTP2Codec::generateSettings(folly::IOBufQueue& writeBuf) {\n  std::deque<SettingPair> settings;\n  for (auto& setting: egressSettings_.getAllSettings()) {\n    switch (setting.id) {\n      case SettingsId::HEADER_TABLE_SIZE:\n        if (pendingTableMaxSize_) {\n          LOG(ERROR) << \"Can't have more than one settings in flight, skipping\";\n          continue;\n        } else {\n          pendingTableMaxSize_ = setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_PUSH:\n        if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n          // HTTP/2 spec says downstream must not send this flag\n          // HTTP2Codec uses it to determine if push features are enabled\n          continue;\n        } else {\n          CHECK(setting.value == 0 || setting.value == 1);\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n      case SettingsId::INITIAL_WINDOW_SIZE:\n      case SettingsId::MAX_FRAME_SIZE:\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        headerCodec_.setMaxUncompressed(setting.value);\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n        CHECK(setting.value == 0 || setting.value == 1);\n        if (setting.value == 0) {\n          continue; // just skip the experimental setting if disabled\n        } else {\n          VLOG(4) << \"generating ENABLE_EX_HEADERS=\" << setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.value == 0) {\n          continue;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      default:\n        LOG(ERROR) << \"ignore unknown settingsId=\"\n                   << std::underlying_type<SettingsId>::type(setting.id)\n                   << \" value=\" << setting.value;\n        continue;\n    }\n\n    settings.push_back(SettingPair(setting.id, setting.value));\n  }\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating \" << (unsigned)settings.size() << \" settings\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettings(writeBuf, settings));\n}\n\nvoid HTTP2Codec::requestUpgrade(HTTPMessage& request) {\n  static folly::ThreadLocalPtr<HTTP2Codec> defaultCodec;\n  if (!defaultCodec.get()) {\n    defaultCodec.reset(new HTTP2Codec(TransportDirection::UPSTREAM));\n  }\n\n  auto& headers = request.getHeaders();\n  headers.set(HTTP_HEADER_UPGRADE, http2::kProtocolCleartextString);\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION, \"Upgrade\", false)) {\n    headers.add(HTTP_HEADER_CONNECTION, \"Upgrade\");\n  }\n  IOBufQueue writeBuf{IOBufQueue::cacheChainLength()};\n  defaultCodec->generateSettings(writeBuf);\n  // fake an ack since defaultCodec gets reused\n  defaultCodec->handleSettingsAck();\n  writeBuf.trimStart(http2::kFrameHeaderSize);\n  auto buf = writeBuf.move();\n  buf->coalesce();\n  headers.set(http2::kProtocolSettingsHeader,\n              base64url_encode(folly::ByteRange(buf->data(), buf->length())));\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                   http2::kProtocolSettingsHeader.c_str(),\n                                   false)) {\n    headers.add(HTTP_HEADER_CONNECTION, http2::kProtocolSettingsHeader);\n  }\n}\n\nsize_t HTTP2Codec::generateSettingsAck(folly::IOBufQueue& writeBuf) {\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating settings ack\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettingsAck(writeBuf));\n}\n\nsize_t HTTP2Codec::generateWindowUpdate(folly::IOBufQueue& writeBuf,\n                                        StreamID stream,\n                                        uint32_t delta) {\n  VLOG(4) << \"generating window update for stream=\" << stream\n          << \": Processed \" << delta << \" bytes\";\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed WINDOW_UPDATE for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::WINDOW_UPDATE,\n                                       http2::writeWindowUpdate(writeBuf, stream, delta));\n}\n\nsize_t HTTP2Codec::generatePriority(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPMessage::HTTPPriority& pri) {\n  VLOG(4) << \"generating priority for stream=\" << stream;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed PRIORITY for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::PRIORITY,\n            http2::writePriority(writeBuf, stream,\n                                 {std::get<0>(pri),\n                                   std::get<1>(pri),\n                                   std::get<2>(pri)}));\n}\n\nsize_t HTTP2Codec::generateCertificateRequest(\n    folly::IOBufQueue& writeBuf,\n    uint16_t requestId,\n    std::unique_ptr<folly::IOBuf> certificateRequestData) {\n  VLOG(4) << \"generating CERTIFICATE_REQUEST with Request-ID=\" << requestId;\n  return http2::writeCertificateRequest(\n      writeBuf, requestId, std::move(certificateRequestData));\n}\n\nsize_t HTTP2Codec::generateCertificate(folly::IOBufQueue& writeBuf,\n                                       uint16_t certId,\n                                       std::unique_ptr<folly::IOBuf> certData) {\n  size_t written = 0;\n  VLOG(4) << \"sending CERTIFICATE with Cert-ID=\" << certId << \"for stream=0\";\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(certData));\n  // The maximum size of an autenticator fragment, combined with the Cert-ID can\n  // not exceed the maximal allowable size of a sent frame.\n  size_t maxChunkSize = maxSendFrameSize() - sizeof(certId);\n  while (queue.chainLength() > maxChunkSize) {\n    auto chunk = queue.splitAtMost(maxChunkSize);\n    written +=\n        http2::writeCertificate(writeBuf, certId, std::move(chunk), true);\n  }\n  return written +\n         http2::writeCertificate(writeBuf, certId, queue.move(), false);\n}\n\nbool HTTP2Codec::checkConnectionError(ErrorCode err, const folly::IOBuf* buf) {\n  if (err != ErrorCode::NO_ERROR) {\n    LOG(ERROR) << \"Connection error \" << getErrorCodeString(err)\n               << \" with ingress=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(buf, true);\n    if (callback_) {\n      std::string errorDescription = goawayErrorMessage_.empty() ?\n        \"Connection error\" : goawayErrorMessage_;\n      HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,\n                       errorDescription);\n      ex.setCodecStatusCode(err);\n      callback_->onError(0, ex, false);\n    }\n    return true;\n  }\n  return false;\n}\n\nvoid HTTP2Codec::streamError(const std::string& msg, ErrorCode code,\n                             bool newTxn) {\n  HTTPException error(HTTPException::Direction::INGRESS_AND_EGRESS,\n                      msg);\n  error.setCodecStatusCode(code);\n  if (callback_) {\n    callback_->onError(curHeader_.stream, error, newTxn);\n  }\n}\n\nHTTPCodec::StreamID\nHTTP2Codec::mapPriorityToDependency(uint8_t priority) const {\n  // If the priority is out of the maximum index of virtual nodes array, we\n  // return the lowest level virtual node as a punishment of not setting\n  // priority correctly.\n  return virtualPriorityNodes_.empty()\n    ? 0\n    : virtualPriorityNodes_[\n        std::min(priority, uint8_t(virtualPriorityNodes_.size() - 1))];\n}\n\nbool HTTP2Codec::parsingTrailers() const {\n  // HEADERS frame is used for request/response headers and trailers.\n  // Per spec, specific role of HEADERS frame is determined by it's postion\n  // within the stream. We don't keep full stream state in this codec,\n  // thus using heuristics to distinguish between headers/trailers.\n  // For DOWNSTREAM case, request headers HEADERS frame would be creating\n  // new stream, thus HEADERS on existing stream ID are considered trailers\n  // (see checkNewStream).\n  // For UPSTREAM case, response headers are required to have status code,\n  // thus if no status code we consider that trailers.\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n      return parsingDownstreamTrailers_;\n    } else {\n      return !decodeInfo_.hasStatus();\n    }\n  }\n  return false;\n}\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/test/HTTPParallelCodecTest.h>\n#include <proxygen/lib/http/codec/test/MockHTTPCodec.h>\n#include <folly/io/Cursor.h>\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/test/HTTP2FramerTest.h>\n#include <proxygen/lib/http/HTTPHeaderSize.h>\n#include <proxygen/lib/http/HTTPMessage.h>\n\n#include <folly/portability/GTest.h>\n#include <folly/portability/GMock.h>\n#include <random>\n\nusing namespace proxygen;\nusing namespace proxygen::compress;\nusing namespace folly;\nusing namespace folly::io;\nusing namespace std;\nusing namespace testing;\n\nTEST(HTTP2CodecConstantsTest, HTTPContantsAreCommonHeaders) {\n  // The purpose of this test is to verify some basic assumptions that should\n  // never change but to make clear that the following http2 header constants\n  // map to the respective common headers.  Should this test ever fail, the\n  // H2Codec would need to be updated in the corresponding places when creating\n  // compress/Header objects.\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kMethod),\n            HTTP_HEADER_COLON_METHOD);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kScheme),\n            HTTP_HEADER_COLON_SCHEME);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kPath),\n            HTTP_HEADER_COLON_PATH);\n  EXPECT_EQ(\n    HTTPCommonHeaders::hash(headers::kAuthority),\n    HTTP_HEADER_COLON_AUTHORITY);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kStatus),\n            HTTP_HEADER_COLON_STATUS);\n}\n\nclass HTTP2CodecTest : public HTTPParallelCodecTest {\n public:\n\n  HTTP2CodecTest()\n    :HTTPParallelCodecTest(upstreamCodec_, downstreamCodec_) {}\n\n  void SetUp() override {\n    HTTPParallelCodecTest::SetUp();\n  }\n  void testHeaderListSize(bool oversized);\n  void testFrameSizeLimit(bool oversized);\n\n protected:\n  HTTP2Codec upstreamCodec_{TransportDirection::UPSTREAM};\n  HTTP2Codec downstreamCodec_{TransportDirection::DOWNSTREAM};\n};\n\nTEST_F(HTTP2CodecTest, IgnoreUnknownSettings) {\n  auto numSettings = downstreamCodec_.getIngressSettings()->getNumSettings();\n  std::deque<SettingPair> settings;\n  for (uint32_t i = 200; i < (200 + 1024); i++) {\n    settings.push_back(SettingPair(SettingsId(i), i));\n  }\n  http2::writeSettings(output_, settings);\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(numSettings,\n            downstreamCodec_.getIngressSettings()->getNumSettings());\n}\n\nTEST_F(HTTP2CodecTest, NoExHeaders) {\n  // do not emit ENABLE_EX_HEADERS setting, if disabled\n  SetUpUpstreamTest();\n\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.numSettings, 0);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  // only 3 standard settings: HEADER_TABLE_SIZE, ENABLE_PUSH, MAX_FRAME_SIZE.\n  EXPECT_EQ(callbacks_.numSettings, 3);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersSetting) {\n  // disable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, EnableExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n  EXPECT_EQ(true, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, InvalidExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  // attempt to set a invalid ENABLE_EX_HEADERS value\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 110)});\n  parse();\n\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicHeader) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, RequestFromServer) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP request initiated\n  // by server side\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  SetUpUpstreamTest();\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  upstreamCodec_.generateExHeader(output_, stream, req,\n                                  HTTPCodec::ExAttributes(controlStream, true),\n                                  true);\n\n  parseUpstream();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, ResponseFromClient) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP response replied by\n  // client side\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, resp,\n    HTTPCodec::ExAttributes(controlStream, true), true);\n\n  parse();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, ExHeadersWithPriority) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  auto req = getGetRequest();\n  auto pri = HTTPMessage::HTTPPriority(0, false, 7);\n  req.setHTTP2Priority(pri);\n  upstreamCodec_.generateExHeader(output_, 3, req,\n                                  HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.msg->getHTTP2Priority(), pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersIfNotEnabled) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  downstreamCodec_.generateExHeader(output_, 3, req,\n                                    HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaders) {\n  static const std::string v1(\"GET\");\n  static const std::string v2(\"/\");\n  static const std::string v3(\"http\");\n  static const std::string v4(\"foo.com\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 7);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPseudoHeaders) {\n  static const std::string v1(\"POST\");\n  static const std::string v2(\"http\");\n  static const std::string n3(\"foo\");\n  static const std::string v3(\"bar\");\n  static const std::string v4(\"/\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kScheme, v2),\n    Header::makeHeaderForTest(n3, v3),\n    Header::makeHeaderForTest(headers::kPath, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n  auto encodedHeaders = headerCodec.encode(allHeaders);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      stream,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderValues) {\n  static const std::string v1(\"--1\");\n  static const std::string v2(\"\\13\\10protocol-attack\");\n  static const std::string v3(\"\\13\");\n  static const std::string v4(\"abc.com\\\\13\\\\10\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders;\n    allHeaders.push_back(reqHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 4);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n/**\n * Ingress bytes with an empty header name\n */\nconst uint8_t kBufEmptyHeader[] = {\n  0x00, 0x00, 0x1d, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01, 0x82,\n  0x87, 0x44, 0x87, 0x62, 0x6b, 0x46, 0x41, 0xd2, 0x7a, 0x0b,\n  0x41, 0x89, 0xf1, 0xe3, 0xc2, 0xf2, 0x9c, 0xeb, 0x90, 0xf4,\n  0xff, 0x40, 0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7\n};\n\nTEST_F(HTTP2CodecTest, EmptyHeaderName) {\n  output_.append(IOBuf::copyBuffer(kBufEmptyHeader, sizeof(kBufEmptyHeader)));\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicConnect) {\n  std::string authority = \"myhost:1234\";\n  HTTPMessage request;\n  request.setMethod(HTTPMethod::CONNECT);\n  request.getHeaders().add(proxygen::HTTP_HEADER_HOST, authority);\n  upstreamCodec_.generateHeader(output_, 1, request, false /* eom */);\n\n  parse();\n  callbacks_.expectMessage(false, 1, \"\");\n  EXPECT_EQ(HTTPMethod::CONNECT, callbacks_.msg->getMethod());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(authority, headers.getSingleOrEmpty(proxygen::HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, BadConnect) {\n  std::string v1 = \"CONNECT\";\n  std::string v2 = \"somehost:576\";\n  std::vector<proxygen::compress::Header> goodHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kAuthority, v2),\n  };\n\n  // See https://tools.ietf.org/html/rfc7540#section-8.3\n  std::string v3 = \"/foobar\";\n  std::vector<proxygen::compress::Header> badHeaders = {\n    Header::makeHeaderForTest(headers::kScheme, headers::kHttp),\n    Header::makeHeaderForTest(headers::kPath, v3),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n\n  for (size_t i = 0; i < badHeaders.size(); i++, stream += 2) {\n    auto allHeaders = goodHeaders;\n    allHeaders.push_back(badHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, badHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nvoid HTTP2CodecTest::testHeaderListSize(bool oversized) {\n  if (oversized) {\n    auto settings = downstreamCodec_.getEgressSettings();\n    settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  }\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"x-long-long-header\",\n                       \"supercalafragalisticexpialadoshus\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nvoid HTTP2CodecTest::testFrameSizeLimit(bool oversized) {\n  HTTPMessage req = getBigGetRequest(\"/guacamole\");\n  auto settings = downstreamCodec_.getEgressSettings();\n\n  parse(); // consume preface\n  if (oversized) {\n    // trick upstream for sending a 2x bigger HEADERS frame\n    settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                         http2::kMaxFramePayloadLengthMin * 2);\n    downstreamCodec_.generateSettings(output_);\n    parseUpstream();\n  }\n\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                       http2::kMaxFramePayloadLengthMin);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeHeader) {\n  testHeaderListSize(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedHeader) {\n  testHeaderListSize(true);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeFrame) {\n  testFrameSizeLimit(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedFrame) {\n  testFrameSizeLimit(true);\n}\n\nTEST_F(HTTP2CodecTest, BigHeaderCompressed) {\n  SetUpUpstreamTest();\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  downstreamCodec_.generateSettings(output_);\n  parseUpstream();\n\n  SetUp();\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\n\nTEST_F(HTTP2CodecTest, BasicHeaderReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n\n  parseUpstream();\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  // HTTP/2 doesnt support serialization - instead you get the default\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadHeadersReply) {\n  static const std::string v1(\"200\");\n  static const vector<proxygen::compress::Header> respHeaders = {\n    Header::makeHeaderForTest(headers::kStatus, v1),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, Cookies) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(\"Cookie\", \"chocolate-chip=1\");\n  req.getHeaders().add(\"Cookie\", \"rainbow-chip=2\");\n  req.getHeaders().add(\"Cookie\", \"butterscotch=3\");\n  req.getHeaders().add(\"Cookie\", \"oatmeal-raisin=4\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"/guacamole\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"chocolate-chip\"), \"1\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"rainbow-chip\"), \"2\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"butterscotch\"), \"3\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"oatmeal-raisin\"), \"4\");\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuation) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuationEndStream) {\n  // CONTINUATION with END_STREAM flag set on the preceding HEADERS frame\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadContinuation) {\n  // CONTINUATION with no preceding HEADERS\n  auto fakeHeaders = makeBuf(5);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuation) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n\n  upstreamCodec_.generateHeader(output_, 1, req);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuationBadFrame) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert an invalid frame\n  auto frame = makeBuf(http2::kFrameHeaderSize + 4134);\n  *((uint32_t *)frame->writableData()) = 0xfa000000;\n  output_.append(std::move(frame));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, BadContinuationStream) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n  auto fakeHeaders = makeBuf(4134);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, FrameTooLarge) {\n  writeFrameHeaderManual(output_, 1 << 15, 0, 0, 1);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_TRUE(callbacks_.lastParseError->hasCodecStatusCode());\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n            ErrorCode::FRAME_SIZE_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, UnknownFrameType) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // unknown frame type 17\n  writeFrameHeaderManual(output_, 17, 37, 0, 1);\n  output_.append(\"wicked awesome!!!\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"\"); // + host\n}\n\nTEST_F(HTTP2CodecTest, JunkAfterConnError) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // write headers frame for stream 0\n  writeFrameHeaderManual(output_, 0, (uint8_t)http2::FrameType::HEADERS, 0, 0);\n  // now write a valid headers frame, should never be parsed\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicData) {\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), data);\n}\n\nTEST_F(HTTP2CodecTest, LongData) {\n  // Hack the max frame size artificially low\n  HTTPSettings* settings = (HTTPSettings*)upstreamCodec_.getIngressSettings();\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE, 16);\n  auto buf = makeBuf(100);\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), HTTPCodec::NoPadding,\n                              true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 7);\n  EXPECT_EQ(callbacks_.bodyLength, 100);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPaddingLength) {\n  const uint8_t badInput[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                              0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                              0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                              0x00, 0x00, 0x7e, 0x00, 0x6f, 0x6f, 0x6f, 0x6f,\n                              // The padding length byte below is 0x82 (130\n                              // in decimal) which is greater than the length\n                              // specified by the header's length field, 126\n                              0x01, 0x82, 0x87, 0x44, 0x87, 0x92, 0x97, 0x92,\n                              0x92, 0x92, 0x7a, 0x0b, 0x41, 0x89, 0xf1, 0xe3,\n                              0xc0, 0xf2, 0x9c, 0xdd, 0x90, 0xf4, 0xff, 0x40,\n                              0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7};\n  output_.clear();\n  output_.append(badInput, sizeof(badInput));\n  EXPECT_EQ(output_.chainLength(), sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPadding) {\n  const uint8_t badInput[] = {\n    0x00, 0x00, 0x0d, 0x01, 0xbe, 0x63, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x73,\n    0x00, 0x00, 0x06, 0x08, 0x72, 0x00, 0x24, 0x00, 0xfa, 0x4d, 0x0d\n  };\n  output_.append(badInput, sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, NoAppByte) {\n  const uint8_t noAppByte[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                               0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                               0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                               0x00, 0x00, 0x56, 0x00, 0x5d, 0x00, 0x00, 0x00,\n                               0x01, 0x55, 0x00};\n  output_.clear();\n  output_.append(noAppByte, sizeof(noAppByte));\n  EXPECT_EQ(output_.chainLength(), sizeof(noAppByte));\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataOnFrameHeaderCall) {\n  using namespace testing;\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  EXPECT_CALL(mockCallback, onFrameHeader(_, _, _, _, _));\n\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  downstreamCodec_.setCallback(&mockCallback);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy partial byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  downstreamCodec_.onIngress(*ingress1);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataWithNoAppByte) {\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy up to the padding length byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  size_t parsed = downstreamCodec_.onIngress(*ingress1);\n  // The 34th byte is the padding length byte which should not be parsed\n  EXPECT_EQ(parsed, 33);\n  // Copy from the padding length byte to the end\n  auto ingress2 = IOBuf::copyBuffer(ingress->data() + 33, 21);\n  parsed = downstreamCodec_.onIngress(*ingress2);\n  // The padding length byte should be parsed this time along with 10 bytes of\n  // application data and 10 bytes of padding\n  EXPECT_EQ(parsed, 21);\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, bufSize);\n  // Total padding is the padding length byte and the padding bytes\n  EXPECT_EQ(callbacks_.paddingBytes, padding + 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, BasicRst) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicRstInvalidCode) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::_SPDY_INVALID_STREAM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicPing) {\n  upstreamCodec_.generatePingRequest(output_);\n  upstreamCodec_.generatePingReply(output_, 17);\n\n  uint64_t pingReq;\n  parse([&] (IOBuf* ingress) {\n      folly::io::Cursor c(ingress);\n      c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n      pingReq = c.read<uint64_t>();\n    });\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.recvPingRequest, pingReq);\n  EXPECT_EQ(callbacks_.recvPingReply, 17);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicWindow) {\n  // This test would fail if the codec had window state\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  upstreamCodec_.generateWindowUpdate(output_, 0, http2::kMaxWindowUpdateSize);\n  upstreamCodec_.generateWindowUpdate(output_, 1, 12);\n  upstreamCodec_.generateWindowUpdate(output_, 1, http2::kMaxWindowUpdateSize);\n\n  parse();\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 4);\n  EXPECT_EQ(callbacks_.windowUpdates[0],\n            std::vector<uint32_t>({10, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.windowUpdates[1],\n            std::vector<uint32_t>({12, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, ZeroWindow) {\n  auto streamID = HTTPCodec::StreamID(1);\n  // First generate a frame with delta=1 so as to pass the checks, and then\n  // hack the frame so that delta=0 without modifying other checks\n  upstreamCodec_.generateWindowUpdate(output_, streamID, 1);\n  output_.trimEnd(http2::kFrameWindowUpdateSize);\n  QueueAppender appender(&output_, http2::kFrameWindowUpdateSize);\n  appender.writeBE<uint32_t>(0);\n\n  parse();\n  // This test doesn't ensure that RST_STREAM is generated\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n      ErrorCode::PROTOCOL_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, BasicGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n  EXPECT_DEATH_NO_CORE(upstreamCodec_.generateGoaway(\n                         output_, 27, ErrorCode::ENHANCE_YOUR_CALM), \".*\");\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoaway) {\n  parse();\n  SetUpUpstreamTest();\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::NO_ERROR);\n  EXPECT_TRUE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_TRUE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n  downstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parseUpstream();\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  EXPECT_EQ(callbacks_.goaways, 2);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parse();\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoawayWithError) {\n  SetUpUpstreamTest();\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::ENHANCE_YOUR_CALM,\n                                  std::move(debugData));\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  auto ret = downstreamCodec_.generateGoaway(output_, 0,\n                                             ErrorCode::NO_ERROR);\n  EXPECT_EQ(ret, 0);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, GoawayHandling) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n\n  // send request\n  HTTPMessage req = getGetRequest();\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  parse();\n  callbacks_.expectMessage(true, 1, \"/\");\n  callbacks_.reset();\n\n  SetUpUpstreamTest();\n  // drain after this message\n  downstreamCodec_.generateGoaway(output_, 1, ErrorCode::NO_ERROR);\n  parseUpstream();\n  // upstream cannot generate id > 1\n  upstreamCodec_.generateHeader(output_, 3, req, false, &size);\n  EXPECT_EQ(size.uncompressed, 0);\n  upstreamCodec_.generateWindowUpdate(output_, 3, 100);\n  upstreamCodec_.generateBody(output_, 3, makeBuf(10), HTTPCodec::NoPadding,\n                              false);\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateEOM(output_, 3);\n  upstreamCodec_.generateRstStream(output_, 3, ErrorCode::CANCEL);\n  EXPECT_EQ(output_.chainLength(), 0);\n\n  // send a push promise that will be rejected by downstream\n  req.getHeaders().add(\"foomonkey\", \"george\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1, false, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  // send a push response that will be ignored\n  downstreamCodec_.generateHeader(output_, 2, resp, false, &size);\n  // window update for push doesn't make any sense, but whatever\n  downstreamCodec_.generateWindowUpdate(output_, 2, 100);\n  downstreamCodec_.generateBody(output_, 2, makeBuf(10), HTTPCodec::NoPadding,\n                                false);\n  writeFrameHeaderManual(output_, 20, (uint8_t)http2::FrameType::DATA, 0, 2);\n  output_.append(makeBuf(10));\n\n  // tell the upstream no pushing, and parse the first batch\n  IOBufQueue dummy;\n  upstreamCodec_.generateGoaway(dummy, 0, ErrorCode::NO_ERROR);\n  parseUpstream();\n\n  output_.append(makeBuf(10));\n  downstreamCodec_.generatePriority(output_, 2,\n                                    HTTPMessage::HTTPPriority(0, true, 1));\n  downstreamCodec_.generateEOM(output_, 2);\n  downstreamCodec_.generateRstStream(output_, 2, ErrorCode::CANCEL);\n\n  // send a response that will be accepted, headers should be ok\n  downstreamCodec_.generateHeader(output_, 1, resp, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n\n  // parse the remainder\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n}\n\nTEST_F(HTTP2CodecTest, GoawayReply) {\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n}\n\nTEST_F(HTTP2CodecTest, BasicSetting) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_CONCURRENT_STREAMS, 37);\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 12345);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.maxStreams, 37);\n  EXPECT_EQ(callbacks_.windowSize, 12345);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsAck) {\n  upstreamCodec_.generateSettingsAck(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadSettings) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 0xffffffff);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BadPushSettings) {\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->clearSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 0);\n  SetUpUpstreamTest();\n\n  parseUpstream([&] (IOBuf* ingress) {\n      EXPECT_EQ(ingress->computeChainDataLength(), http2::kFrameHeaderSize);\n    });\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  // Only way to disable push for downstreamCodec_ is to read\n  // ENABLE_PUSH:0 from client\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n\nTEST_F(HTTP2CodecTest, SettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadSettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  // This sets the max decoder table size to 8k\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  callbacks_.reset();\n\n  // Attempt to set a new max table size.  This is a no-op because the first,\n  // setting is unacknowledged.  The upstream encoder will up the table size to\n  // 8k per the first settings frame and the HPACK codec will send a code to\n  // update the decoder.\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 4096);\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsTableSizeEarlyShrink) {\n  // Lower size to 2k\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 2048);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  // Parsing SETTINGS ack updates upstream decoder to 2k\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  // downstream encoder will send TSU/2k\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  // sets pending table size to 512, but doesn't update it yet\n  settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 512);\n  IOBufQueue tmp{IOBufQueue::cacheChainLength()};\n  upstreamCodec_.generateSettings(tmp);\n\n  // Previous code would barf here, since TSU/2k is a violation of the current\n  // max=512\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BasicPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.priority, pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderPriority) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nclass DummyQueue: public HTTPCodec::PriorityQueue {\n public:\n  DummyQueue() {}\n  ~DummyQueue() override {}\n  void addPriorityNode(HTTPCodec::StreamID id, HTTPCodec::StreamID) override {\n    nodes_.push_back(id);\n  }\n\n  std::vector<HTTPCodec::StreamID> nodes_;\n};\n\nTEST_F(HTTP2CodecTest, VirtualNodes) {\n  DummyQueue queue;\n  uint8_t level = 30;\n  upstreamCodec_.addPriorityNodes(queue, output_, level);\n\n  EXPECT_TRUE(parse());\n  for (int i = 0; i < level; i++) {\n    EXPECT_EQ(queue.nodes_[i], upstreamCodec_.mapPriorityToDependency(i));\n  }\n\n  // Out-of-range priorites are mapped to the lowest level of virtual nodes.\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level));\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level + 1));\n}\n\nTEST_F(HTTP2CodecTest, BasicPushPromise) {\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_FALSE(downstreamCodec_.supportsPushTransactions());\n\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_TRUE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n\n  SetUpUpstreamTest();\n\n  HTTPCodec::StreamID assocStream = 7;\n  for (auto i = 0; i < 2; i++) {\n    // Push promise\n    HTTPCodec::StreamID pushStream = downstreamCodec_.createStream();\n    HTTPMessage req = getGetRequest();\n    req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n    downstreamCodec_.generatePushPromise(output_, pushStream, req, assocStream);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, \"/\"); // + host\n    EXPECT_EQ(callbacks_.assocStreamId, assocStream);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    auto& headers = callbacks_.msg->getHeaders();\n    EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n    callbacks_.reset();\n\n    // Actual reply headers\n    HTTPMessage resp;\n    resp.setStatusCode(200);\n    resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"text/plain\");\n    downstreamCodec_.generateHeader(output_, pushStream, resp);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, 200);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    EXPECT_EQ(callbacks_.assocStreamId, 0);\n    EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n    EXPECT_EQ(\"text/plain\", callbacks_.msg->getHeaders().getSingleOrEmpty(\n                  HTTP_HEADER_CONTENT_TYPE));\n    callbacks_.reset();\n  }\n}\n\nTEST_F(HTTP2CodecTest, BadPushPromise) {\n  // ENABLE_PUSH is now 0 by default\n  SetUpUpstreamTest();\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificateRequest) {\n  uint16_t requestId = 17;\n  std::unique_ptr<folly::IOBuf> authRequest =\n      folly::IOBuf::copyBuffer(\"authRequestData\");\n  upstreamCodec_.generateCertificateRequest(\n      output_, requestId, std::move(authRequest));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificateRequests, 1);\n  EXPECT_EQ(callbacks_.lastCertRequestId, requestId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authRequestData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificate) {\n  uint16_t certId = 17;\n  std::unique_ptr<folly::IOBuf> authenticator =\n      folly::IOBuf::copyBuffer(\"authenticatorData\");\n  upstreamCodec_.generateCertificate(output_, certId, std::move(authenticator));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificates, 1);\n  EXPECT_EQ(callbacks_.lastCertId, certId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authenticatorData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadServerPreface) {\n  output_.move();\n  downstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, Normal1024Continuation) {\n  HTTPMessage req = getGetRequest();\n  string bigval(8691, '!');\n  bigval.append(8691, ' ');\n  req.getHeaders().add(\"x-headr\", bigval);\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(bigval, headers.getSingleOrEmpty(\"x-headr\"));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateSettingsAck(output_);\n  parse();\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n}\n\nTEST_F(HTTP2CodecTest, StreamIdOverflow) {\n  HTTP2Codec codec(TransportDirection::UPSTREAM);\n\n  HTTPCodec::StreamID streamId;\n  codec.setNextEgressStreamId(std::numeric_limits<int32_t>::max() - 10);\n  while (codec.isReusable()) {\n    streamId = codec.createStream();\n  }\n  EXPECT_EQ(streamId, std::numeric_limits<int32_t>::max() - 2);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleDifferentContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH, \"300\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(HTTP_HEADER_CONTENT_LENGTH), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the request fails before the codec finishes parsing the headers\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.lastParseError->getHttpStatusCode(), 400);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleIdenticalContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(\"content-length\", \"200\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(\"content-length\"), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the headers parsing completes correctly\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n}\n\nTEST_F(HTTP2CodecTest, CleartextUpgrade) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_EQ(req.getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE), \"h2c\");\n  EXPECT_TRUE(req.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                      \"Upgrade\", false));\n  EXPECT_TRUE(req.checkForHeaderToken(\n                HTTP_HEADER_CONNECTION,\n                http2::kProtocolSettingsHeader.c_str(), false));\n  EXPECT_GT(\n    req.getHeaders().getSingleOrEmpty(http2::kProtocolSettingsHeader).length(),\n    0);\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsSuccess) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n\n  // empty settings\n  req.getHeaders().add(http2::kProtocolSettingsHeader, \"\");\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // real settings (overwrites empty)\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsFailure) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  // no settings\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  HTTPHeaders& headers = req.getHeaders();\n\n  // Not base64_url settings\n  headers.set(http2::kProtocolSettingsHeader, \"????\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n  headers.set(http2::kProtocolSettingsHeader, \"AAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Too big\n  string bigSettings((http2::kMaxFramePayloadLength + 1) * 4 / 3, 'A');\n  headers.set(http2::kProtocolSettingsHeader, bigSettings);\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Malformed (not a multiple of 6)\n  headers.set(http2::kProtocolSettingsHeader, \"AAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Two headers\n  headers.set(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  headers.add(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2EnableConnect) {\n  SetUpUpstreamTest();\n  // egress settings have no connect settings.\n  auto ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  // enable connect settings, and check.\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL, 1);\n  ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  EXPECT_EQ(ws_enable->value, 1);\n  // generateSettings.\n  // pass the buffer to be parsed by the codec and check for ingress settings.\n  upstreamCodec_.generateSettings(output_);\n  parseUpstream();\n  EXPECT_EQ(1, upstreamCodec_.peerHasWebsockets());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketUpgrade) {\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  EXPECT_TRUE(callbacks_.msg->isIngressWebsocketUpgrade());\n  EXPECT_NE(nullptr, callbacks_.msg->getUpgradeProtocol());\n  EXPECT_EQ(headers::kWebsocketString, *callbacks_.msg->getUpgradeProtocol());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketBadHeader) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n  };\n  vector<proxygen::compress::Header> optionalHeaders = {\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  int stream = 1;\n  for (size_t i = 0; i < optionalHeaders.size(); ++i, stream += 2) {\n    auto headers = reqHeaders;\n    headers.push_back(optionalHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(headers);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        false,\n                        true);\n    parse();\n  }\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, optionalHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketDupProtocol) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> headers = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  auto encodedHeaders = headerCodec.encode(headers);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      false,\n                      true);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketIncorrectResponse) {\n  parse();\n  SetUpUpstreamTest();\n  parseUpstream();\n\n  output_.clear();\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  output_.clear();\n  HTTPMessage resp;\n  resp.setStatusCode(201);\n  resp.setStatusMessage(\"OK\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TestAllEgressFrameTypeCallbacks) {\n  class CallbackTypeTracker {\n    std::set<uint8_t> types;\n  public:\n    void add(uint8_t, uint8_t type, uint64_t, uint16_t) {\n      types.insert(type);\n    }\n\n    bool isAllFrameTypesReceived() {\n      http2::FrameType expectedTypes[] = {\n        http2::FrameType::DATA,\n        http2::FrameType::HEADERS,\n        http2::FrameType::PRIORITY,\n        http2::FrameType::RST_STREAM,\n        http2::FrameType::SETTINGS,\n        http2::FrameType::PUSH_PROMISE,\n        http2::FrameType::PING,\n        http2::FrameType::GOAWAY,\n        http2::FrameType::WINDOW_UPDATE,\n        http2::FrameType::CONTINUATION,\n        http2::FrameType::EX_HEADERS,\n      };\n\n      for(http2::FrameType type: expectedTypes) {\n        EXPECT_TRUE(types.find(static_cast<uint8_t>(type)) != types.end())\n          << \"callback missing for type \" << static_cast<uint8_t>(type);\n      }\n      return types.size() == (sizeof(expectedTypes)/sizeof(http2::FrameType));\n    }\n  };\n\n  CallbackTypeTracker callbackTypeTracker;\n\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  upstreamCodec_.setCallback(&mockCallback);\n  downstreamCodec_.setCallback(&mockCallback);\n  EXPECT_CALL(mockCallback, onGenerateFrameHeader(_, _, _, _)).\n    WillRepeatedly(Invoke(&callbackTypeTracker, &CallbackTypeTracker::add));\n\n  // DATA frame\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  HTTPMessage req = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  upstreamCodec_.generateSettings(output_);\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n  upstreamCodec_.generatePingRequest(output_);\n\n  std::unique_ptr<folly::IOBuf> debugData =\n      folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, req,\n    HTTPCodec::ExAttributes(controlStream, true));\n\n  // Tests the continuation frame\n  req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  EXPECT_TRUE(callbackTypeTracker.isAllFrameTypesReceived());\n}\n\nTEST_F(HTTP2CodecTest, Trailers) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersWithPseudoHeaders) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TrailersNoBody) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersContinuation) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(callbacks_.msg->getTrailers(), nullptr);\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-trailer-2\", \"chicken-kyiv\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(\"chicken-kyiv\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-2\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithNoData) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithPseudoHeaders) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.msg->getStatusCode(), 200);\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyMissingContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4132);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n"], "fixing_code": ["/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/HTTP2Constants.h>\n#include <proxygen/lib/http/codec/CodecUtil.h>\n#include <proxygen/lib/utils/Logging.h>\n#include <proxygen/lib/utils/Base64.h>\n\n#include <folly/Conv.h>\n#include <folly/Random.h>\n#include <folly/ThreadLocal.h>\n#include <folly/io/Cursor.h>\n#include <folly/tracing/ScopedTraceSection.h>\n#include <type_traits>\n\nusing namespace proxygen::compress;\nusing namespace folly::io;\nusing namespace folly;\n\nusing std::string;\n\nnamespace {\nstd::string base64url_encode(ByteRange range) {\n  return proxygen::Base64::urlEncode(range);\n}\n\nstd::string base64url_decode(const std::string& str) {\n  return proxygen::Base64::urlDecode(str);\n}\n\n}\n\nnamespace proxygen {\n\n\nHTTP2Codec::HTTP2Codec(TransportDirection direction)\n    : HTTPParallelCodec(direction),\n      headerCodec_(direction),\n      frameState_(direction == TransportDirection::DOWNSTREAM\n                  ? FrameState::UPSTREAM_CONNECTION_PREFACE\n                  : FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n\n  const auto maxHeaderListSize = egressSettings_.getSetting(\n    SettingsId::MAX_HEADER_LIST_SIZE);\n  if (maxHeaderListSize) {\n    headerCodec_.setMaxUncompressed(maxHeaderListSize->value);\n  }\n\n  VLOG(4) << \"creating \" << getTransportDirectionString(direction)\n          << \" HTTP/2 codec\";\n}\n\nHTTP2Codec::~HTTP2Codec() {}\n\n// HTTPCodec API\n\nsize_t HTTP2Codec::onIngress(const folly::IOBuf& buf) {\n  // TODO: ensure only 1 parse at a time on stack.\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - onIngress\");\n\n  Cursor cursor(&buf);\n  size_t parsed = 0;\n  ErrorCode connError = ErrorCode::NO_ERROR;\n  for (auto bufLen = cursor.totalLength();\n       connError == ErrorCode::NO_ERROR;\n       bufLen = cursor.totalLength()) {\n    if (frameState_ == FrameState::UPSTREAM_CONNECTION_PREFACE) {\n      if (bufLen >= http2::kConnectionPreface.length()) {\n        auto test = cursor.readFixedString(http2::kConnectionPreface.length());\n        parsed += http2::kConnectionPreface.length();\n        if (test != http2::kConnectionPreface) {\n          goawayErrorMessage_ = \"missing connection preface\";\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::FRAME_HEADER ||\n               frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE) {\n      // Waiting to parse the common frame header\n      if (bufLen >= http2::kFrameHeaderSize) {\n        connError = parseFrameHeader(cursor, curHeader_);\n        parsed += http2::kFrameHeaderSize;\n        if (frameState_ == FrameState::DOWNSTREAM_CONNECTION_PREFACE &&\n            curHeader_.type != http2::FrameType::SETTINGS) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: got invalid connection preface frame type=\",\n              getFrameTypeString(curHeader_.type), \"(\", curHeader_.type, \")\",\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          connError = ErrorCode::PROTOCOL_ERROR;\n        }\n        if (curHeader_.length > maxRecvFrameSize()) {\n          VLOG(4) << \"Excessively large frame len=\" << curHeader_.length;\n          connError = ErrorCode::FRAME_SIZE_ERROR;\n        }\n\n        if (callback_) {\n          callback_->onFrameHeader(\n            curHeader_.stream,\n            curHeader_.flags,\n            curHeader_.length,\n            static_cast<uint8_t>(curHeader_.type));\n        }\n\n        frameState_ = (curHeader_.type == http2::FrameType::DATA) ?\n          FrameState::DATA_FRAME_DATA : FrameState::FRAME_DATA;\n        pendingDataFrameBytes_ = curHeader_.length;\n        pendingDataFramePaddingBytes_ = 0;\n#ifndef NDEBUG\n        receivedFrameCount_++;\n#endif\n      } else {\n        break;\n      }\n    } else if (frameState_ == FrameState::DATA_FRAME_DATA && bufLen > 0 &&\n               (bufLen < curHeader_.length ||\n                pendingDataFrameBytes_ < curHeader_.length)) {\n      // FrameState::DATA_FRAME_DATA with partial data only\n      size_t dataParsed = 0;\n      connError = parseDataFrameData(cursor, bufLen, dataParsed);\n      if (dataParsed == 0 && pendingDataFrameBytes_ > 0) {\n        // We received only the padding byte, we will wait for more\n        break;\n      } else {\n        parsed += dataParsed;\n        if (pendingDataFrameBytes_ == 0) {\n          frameState_ = FrameState::FRAME_HEADER;\n        }\n      }\n    } else { // FrameState::FRAME_DATA\n             // or FrameState::DATA_FRAME_DATA with all data available\n      // Already parsed the common frame header\n      const auto frameLen = curHeader_.length;\n      if (bufLen >= frameLen) {\n        connError = parseFrame(cursor);\n        parsed += curHeader_.length;\n        frameState_ = FrameState::FRAME_HEADER;\n      } else {\n        break;\n      }\n    }\n  }\n  checkConnectionError(connError, &buf);\n  return parsed;\n}\n\nErrorCode HTTP2Codec::parseFrame(folly::io::Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseFrame\");\n  if (expectedContinuationStream_ != 0 &&\n       (curHeader_.type != http2::FrameType::CONTINUATION ||\n        expectedContinuationStream_ != curHeader_.stream)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: while expected CONTINUATION with stream=\",\n        expectedContinuationStream_, \", received streamID=\", curHeader_.stream,\n        \" of type=\", getFrameTypeString(curHeader_.type));\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (expectedContinuationStream_ == 0 &&\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: unexpected CONTINUATION received with streamID=\",\n        curHeader_.stream);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (frameAffectsCompression(curHeader_.type) &&\n      curHeaderBlock_.chainLength() + curHeader_.length >\n      egressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE, 0)) {\n    // this may be off by up to the padding length (max 255), but\n    // these numbers are already so generous, and we're comparing the\n    // max-uncompressed to the actual compressed size.  Let's fail\n    // before buffering.\n\n    // TODO(t6513634): it would be nicer to stream-process this header\n    // block to keep the connection state consistent without consuming\n    // memory, and fail just the request per the HTTP/2 spec (section\n    // 10.3)\n    goawayErrorMessage_ = folly::to<string>(\n      \"Failing connection due to excessively large headers\");\n    LOG(ERROR) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n\n  expectedContinuationStream_ =\n    (frameAffectsCompression(curHeader_.type) &&\n     !(curHeader_.flags & http2::END_HEADERS)) ? curHeader_.stream : 0;\n\n  switch (curHeader_.type) {\n    case http2::FrameType::DATA:\n      return parseAllData(cursor);\n    case http2::FrameType::HEADERS:\n      return parseHeaders(cursor);\n    case http2::FrameType::PRIORITY:\n      return parsePriority(cursor);\n    case http2::FrameType::RST_STREAM:\n      return parseRstStream(cursor);\n    case http2::FrameType::SETTINGS:\n      return parseSettings(cursor);\n    case http2::FrameType::PUSH_PROMISE:\n      return parsePushPromise(cursor);\n    case http2::FrameType::EX_HEADERS:\n      if (ingressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS, 0)) {\n        return parseExHeaders(cursor);\n      } else {\n        VLOG(2) << \"EX_HEADERS not enabled, ignoring the frame\";\n        break;\n      }\n    case http2::FrameType::PING:\n      return parsePing(cursor);\n    case http2::FrameType::GOAWAY:\n      return parseGoaway(cursor);\n    case http2::FrameType::WINDOW_UPDATE:\n      return parseWindowUpdate(cursor);\n    case http2::FrameType::CONTINUATION:\n      return parseContinuation(cursor);\n    case http2::FrameType::ALTSVC:\n      // fall through, unimplemented\n      break;\n    case http2::FrameType::CERTIFICATE_REQUEST:\n      return parseCertificateRequest(cursor);\n    case http2::FrameType::CERTIFICATE:\n      return parseCertificate(cursor);\n    default:\n      // Implementations MUST ignore and discard any frame that has a\n      // type that is unknown\n      break;\n  }\n\n  // Landing here means unknown, unimplemented or ignored frame.\n  VLOG(2) << \"Skipping frame (type=\" << (uint8_t)curHeader_.type << \")\";\n  cursor.skip(curHeader_.length);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::handleEndStream() {\n  if (curHeader_.type != http2::FrameType::HEADERS &&\n      curHeader_.type != http2::FrameType::EX_HEADERS &&\n      curHeader_.type != http2::FrameType::CONTINUATION &&\n      curHeader_.type != http2::FrameType::DATA) {\n    return ErrorCode::NO_ERROR;\n  }\n\n  // do we need to handle case where this stream has already aborted via\n  // another callback (onHeadersComplete/onBody)?\n  pendingEndStreamHandling_ |= (curHeader_.flags & http2::END_STREAM);\n\n  // with a websocket upgrade, we need to send message complete cb to\n  // mirror h1x codec's behavior. when the stream closes, we need to\n  // send another callback to clean up the stream's resources.\n  if (ingressWebsocketUpgrade_) {\n    ingressWebsocketUpgrade_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, true);\n  }\n\n  if (pendingEndStreamHandling_ && expectedContinuationStream_ == 0) {\n    pendingEndStreamHandling_ = false;\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,\n                             \"onMessageComplete\", curHeader_.stream, false);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseAllData(Cursor& cursor) {\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing all frame DATA bytes for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto ret = http2::parseData(cursor, curHeader_, outData, padding);\n  RETURN_IF_ERROR(ret);\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return handleEndStream();\n}\n\nErrorCode HTTP2Codec::parseDataFrameData(Cursor& cursor,\n                                         size_t bufLen,\n                                         size_t& parsed) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseDataFrameData\");\n  if (bufLen == 0) {\n    VLOG(10) << \"No data to parse\";\n    return ErrorCode::NO_ERROR;\n  }\n\n  std::unique_ptr<IOBuf> outData;\n  uint16_t padding = 0;\n  VLOG(10) << \"parsing DATA frame data for stream=\" << curHeader_.stream <<\n    \" frame data length=\" << curHeader_.length << \" pendingDataFrameBytes_=\" <<\n    pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n    pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n    \" parsed=\" << parsed;\n  // Parse the padding information only the first time\n  if (pendingDataFrameBytes_ == curHeader_.length &&\n    pendingDataFramePaddingBytes_ == 0) {\n    if (frameHasPadding(curHeader_) && bufLen == 1) {\n      // We need to wait for more bytes otherwise we won't be able to pass\n      // the correct padding to the first onBody call\n      return ErrorCode::NO_ERROR;\n    }\n    const auto ret = http2::parseDataBegin(cursor, curHeader_, parsed, padding);\n    RETURN_IF_ERROR(ret);\n    if (padding > 0) {\n      pendingDataFramePaddingBytes_ = padding - 1;\n      pendingDataFrameBytes_--;\n      bufLen--;\n      parsed++;\n    }\n    VLOG(10) << \"out padding=\" << padding << \" pendingDataFrameBytes_=\" <<\n      pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n      pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n      \" parsed=\" << parsed;\n  }\n  if (bufLen > 0) {\n    // Check if we have application data to parse\n    if (pendingDataFrameBytes_ > pendingDataFramePaddingBytes_) {\n      const size_t pendingAppData =\n        pendingDataFrameBytes_ - pendingDataFramePaddingBytes_;\n      const size_t toClone = std::min(pendingAppData, bufLen);\n      cursor.clone(outData, toClone);\n      bufLen -= toClone;\n      pendingDataFrameBytes_ -= toClone;\n      parsed += toClone;\n      VLOG(10) << \"parsed some app data, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n    // Check if we have padding bytes to parse\n    if (bufLen > 0 && pendingDataFramePaddingBytes_ > 0) {\n      size_t toSkip = 0;\n      auto ret = http2::parseDataEnd(cursor, bufLen,\n                                     pendingDataFramePaddingBytes_, toSkip);\n      RETURN_IF_ERROR(ret);\n      pendingDataFrameBytes_ -= toSkip;\n      pendingDataFramePaddingBytes_ -= toSkip;\n      parsed += toSkip;\n      VLOG(10) << \"parsed some padding, pendingDataFrameBytes_=\" <<\n        pendingDataFrameBytes_ << \" pendingDataFramePaddingBytes_=\" <<\n        pendingDataFramePaddingBytes_ << \" bufLen=\" << bufLen <<\n        \" parsed=\" << parsed;\n    }\n  }\n\n  if (callback_ && (padding > 0 || (outData && !outData->empty()))) {\n    if (!outData) {\n      outData = std::make_unique<IOBuf>();\n    }\n    deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \"onBody\",\n                             curHeader_.stream, std::move(outData), padding);\n  }\n  return (pendingDataFrameBytes_ > 0) ? ErrorCode::NO_ERROR : handleEndStream();\n}\n\n\nErrorCode HTTP2Codec::parseHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseHeaders\");\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing HEADERS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseHeaders(cursor, curHeader_, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, true /* trailersAllowed */));\n  }\n  err = parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                         folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseExHeaders(Cursor& cursor) {\n  FOLLY_SCOPED_TRACE_SECTION(\"HTTP2Codec - parseExHeaders\");\n  HTTPCodec::ExAttributes exAttributes;\n  folly::Optional<http2::PriorityUpdate> priority;\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing ExHEADERS frame for stream=\" << curHeader_.stream\n          << \" length=\" << curHeader_.length;\n  auto err = http2::parseExHeaders(\n      cursor, curHeader_, exAttributes, priority, headerBuf);\n  RETURN_IF_ERROR(err);\n  if (isRequest(curHeader_.stream)) {\n    RETURN_IF_ERROR(\n        checkNewStream(curHeader_.stream, false /* trailersAllowed */));\n  }\n  return parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,\n                          exAttributes);\n}\n\nErrorCode HTTP2Codec::parseContinuation(Cursor& cursor) {\n  std::unique_ptr<IOBuf> headerBuf;\n  VLOG(4) << \"parsing CONTINUATION frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  auto err = http2::parseContinuation(cursor, curHeader_, headerBuf);\n  RETURN_IF_ERROR(err);\n  err = parseHeadersImpl(cursor, std::move(headerBuf),\n                         folly::none, folly::none, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parseHeadersImpl(\n    Cursor& /*cursor*/,\n    std::unique_ptr<IOBuf> headerBuf,\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes) {\n  curHeaderBlock_.append(std::move(headerBuf));\n  std::unique_ptr<HTTPMessage> msg;\n  if (curHeader_.flags & http2::END_HEADERS) {\n    auto errorCode =\n        parseHeadersDecodeFrames(priority, promisedStream, exAttributes, msg);\n    if (errorCode.hasValue()) {\n      return errorCode.value();\n    }\n  }\n\n  // if we're not parsing CONTINUATION, then it's start of new header block\n  if (curHeader_.type != http2::FrameType::CONTINUATION) {\n    headerBlockFrameType_ = curHeader_.type;\n  }\n\n  // Report back what we've parsed\n  if (callback_) {\n    auto concurError = parseHeadersCheckConcurrentStreams(priority);\n    if (concurError.hasValue()) {\n      return concurError.value();\n    }\n    uint32_t headersCompleteStream = curHeader_.stream;\n    bool trailers = parsingTrailers();\n    bool allHeaderFramesReceived =\n        (curHeader_.flags & http2::END_HEADERS) &&\n        (headerBlockFrameType_ == http2::FrameType::HEADERS);\n    if (allHeaderFramesReceived && !trailers) {\n      // Only deliver onMessageBegin once per stream.\n      // For responses with CONTINUATION, this will be delayed until\n      // the frame with the END_HEADERS flag set.\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,\n                                    \"onMessageBegin\",\n                                    curHeader_.stream,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n   } else if (curHeader_.type == http2::FrameType::EX_HEADERS) {\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onExMessageBegin,\n                                    \"onExMessageBegin\",\n                                    curHeader_.stream,\n                                    exAttributes->controlStream,\n                                    exAttributes->unidirectional,\n                                    msg.get())) {\n        return handleEndStream();\n      }\n    } else if (curHeader_.type == http2::FrameType::PUSH_PROMISE) {\n      DCHECK(promisedStream);\n      if (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onPushMessageBegin,\n                                    \"onPushMessageBegin\", *promisedStream,\n                                    curHeader_.stream, msg.get())) {\n        return handleEndStream();\n      }\n      headersCompleteStream = *promisedStream;\n    }\n\n    if (curHeader_.flags & http2::END_HEADERS && msg) {\n      if (!(curHeader_.flags & http2::END_STREAM)) {\n        // If it there are DATA frames coming, consider it chunked\n        msg->setIsChunked(true);\n      }\n      if (trailers) {\n        VLOG(4) << \"Trailers complete for streamId=\" << headersCompleteStream\n                << \" direction=\" << transportDirection_;\n        auto trailerHeaders =\n            std::make_unique<HTTPHeaders>(msg->extractHeaders());\n        msg.reset();\n        callback_->onTrailersComplete(headersCompleteStream,\n                                      std::move(trailerHeaders));\n      } else {\n        callback_->onHeadersComplete(headersCompleteStream, std::move(msg));\n      }\n    }\n    return handleEndStream();\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  // decompress headers\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n\n  // Validate circular dependencies.\n  if (priority && (curHeader_.stream == priority->streamDependency)) {\n    streamError(\n        folly::to<string>(\"Circular dependency for txn=\", curHeader_.stream),\n        ErrorCode::PROTOCOL_ERROR,\n        curHeader_.type == http2::FrameType::HEADERS);\n    return ErrorCode::NO_ERROR;\n  }\n\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  // Saving this in case we need to log it on error\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  // Check decoding error\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    // Avoid logging header blocks that have failed decoding due to being\n    // excessively large.\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n\n    if (msg) {\n      // print the partial message\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n\n  // Check parsing error\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n\n  return folly::Optional<ErrorCode>();\n}\n\nfolly::Optional<ErrorCode> HTTP2Codec::parseHeadersCheckConcurrentStreams(\n    const folly::Optional<http2::PriorityUpdate>& priority) {\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::EX_HEADERS) {\n    if (curHeader_.flags & http2::PRIORITY) {\n      DCHECK(priority);\n      // callback_->onPriority(priority.get());\n    }\n\n    // callback checks total number of streams is smaller than settings max\n    if (callback_->numIncomingStreams() >=\n        egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,\n                                   std::numeric_limits<int32_t>::max())) {\n      streamError(folly::to<string>(\"Exceeded max_concurrent_streams\"),\n                  ErrorCode::REFUSED_STREAM, true);\n      return ErrorCode::NO_ERROR;\n    }\n  }\n  return folly::Optional<ErrorCode>();\n}\n\nvoid HTTP2Codec::onHeader(const folly::fbstring& name,\n                          const folly::fbstring& value) {\n  if (decodeInfo_.onHeader(name, value)) {\n    if (name == \"user-agent\" && userAgent_.empty()) {\n      userAgent_ = value.toStdString();\n    }\n  } else {\n    VLOG(4) << \"dir=\" << uint32_t(transportDirection_) <<\n      decodeInfo_.parsingError << \" codec=\" << headerCodec_;\n  }\n}\n\nvoid HTTP2Codec::onHeadersComplete(HTTPHeaderSize decodedSize,\n                                   bool /*acknowledge*/) {\n  decodeInfo_.onHeadersComplete(decodedSize);\n  decodeInfo_.msg->setAdvancedProtocolString(http2::kProtocolString);\n\n  HTTPMessage* msg = decodeInfo_.msg.get();\n  HTTPRequestVerifier& verifier = decodeInfo_.verifier;\n  if ((transportDirection_ == TransportDirection::DOWNSTREAM) &&\n      verifier.hasUpgradeProtocol() &&\n      (*msg->getUpgradeProtocol() == headers::kWebsocketString) &&\n      msg->getMethod() == HTTPMethod::CONNECT) {\n    msg->setIngressWebsocketUpgrade();\n    ingressWebsocketUpgrade_ = true;\n  } else {\n    auto it = upgradedStreams_.find(curHeader_.stream);\n    if (it != upgradedStreams_.end()) {\n      upgradedStreams_.erase(curHeader_.stream);\n      // a websocket upgrade was sent on this stream.\n      if (msg->getStatusCode() != 200) {\n        decodeInfo_.parsingError =\n          folly::to<string>(\"Invalid response code to a websocket upgrade: \",\n                            msg->getStatusCode());\n        return;\n      }\n      msg->setIngressWebsocketUpgrade();\n    }\n  }\n}\n\nvoid HTTP2Codec::onDecodeError(HPACK::DecodeError decodeError) {\n  decodeInfo_.decodeError = decodeError;\n}\n\nErrorCode HTTP2Codec::parsePriority(Cursor& cursor) {\n  VLOG(4) << \"parsing PRIORITY frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  http2::PriorityUpdate pri;\n  auto err = http2::parsePriority(cursor, curHeader_, pri);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.stream == pri.streamDependency) {\n    streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                  curHeader_.stream),\n                ErrorCode::PROTOCOL_ERROR, false);\n    return ErrorCode::NO_ERROR;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onPriority, \"onPriority\",\n                           curHeader_.stream,\n                           std::make_tuple(pri.streamDependency,\n                                           pri.exclusive,\n                                           pri.weight));\n  return ErrorCode::NO_ERROR;\n}\n\nsize_t HTTP2Codec::addPriorityNodes(\n    PriorityQueue& queue,\n    folly::IOBufQueue& writeBuf,\n    uint8_t maxLevel) {\n  HTTPCodec::StreamID parent = 0;\n  size_t bytes = 0;\n  while (maxLevel--) {\n    auto id = createStream();\n    virtualPriorityNodes_.push_back(id);\n    queue.addPriorityNode(id, parent);\n    bytes += generatePriority(writeBuf, id, std::make_tuple(parent, false, 0));\n    parent = id;\n  }\n  return bytes;\n}\n\nErrorCode HTTP2Codec::parseRstStream(Cursor& cursor) {\n  // rst for stream in idle state - protocol error\n  VLOG(4) << \"parsing RST_STREAM frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  upgradedStreams_.erase(curHeader_.stream);\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  auto err = http2::parseRstStream(cursor, curHeader_, statusCode);\n  RETURN_IF_ERROR(err);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: RST_STREAM with code=\", getErrorCodeString(statusCode),\n        \" for streamID=\", curHeader_.stream, \" user-agent=\", userAgent_);\n    VLOG(2) << goawayErrorMessage_;\n  }\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onAbort, \"onAbort\",\n                           curHeader_.stream, statusCode);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseSettings(Cursor& cursor) {\n  VLOG(4) << \"parsing SETTINGS frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  std::deque<SettingPair> settings;\n  auto err = http2::parseSettings(cursor, curHeader_, settings);\n  RETURN_IF_ERROR(err);\n  if (curHeader_.flags & http2::ACK) {\n    handleSettingsAck();\n    return ErrorCode::NO_ERROR;\n  }\n  return handleSettings(settings);\n}\n\nvoid HTTP2Codec::handleSettingsAck() {\n  if (pendingTableMaxSize_) {\n    headerCodec_.setDecoderHeaderTableMaxSize(*pendingTableMaxSize_);\n    pendingTableMaxSize_ = folly::none;\n  }\n  if (callback_) {\n    callback_->onSettingsAck();\n  }\n}\n\nErrorCode HTTP2Codec::handleSettings(const std::deque<SettingPair>& settings) {\n  SettingsList settingsList;\n  for (auto& setting: settings) {\n    switch (setting.first) {\n      case SettingsId::HEADER_TABLE_SIZE:\n      {\n        uint32_t tableSize = setting.second;\n        if (setting.second > http2::kMaxHeaderTableSize) {\n          VLOG(2) << \"Limiting table size from \" << tableSize << \" to \" <<\n            http2::kMaxHeaderTableSize;\n          tableSize = http2::kMaxHeaderTableSize;\n        }\n        headerCodec_.setEncoderHeaderTableSize(tableSize);\n      }\n      break;\n      case SettingsId::ENABLE_PUSH:\n        if ((setting.second != 0 && setting.second != 1) ||\n            (setting.second == 1 &&\n             transportDirection_ == TransportDirection::UPSTREAM)) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_PUSH invalid setting=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n        break;\n      case SettingsId::INITIAL_WINDOW_SIZE:\n        if (setting.second > http2::kMaxWindowUpdateSize) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: INITIAL_WINDOW_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::MAX_FRAME_SIZE:\n        if (setting.second < http2::kMaxFramePayloadLengthMin ||\n            setting.second > http2::kMaxFramePayloadLength) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: MAX_FRAME_SIZE invalid size=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        ingressSettings_.setSetting(SettingsId::MAX_FRAME_SIZE, setting.second);\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n      {\n        auto ptr = egressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS);\n        if (ptr && ptr->value > 0) {\n          VLOG(4) << getTransportDirectionString(getTransportDirection())\n                  << \" got ENABLE_EX_HEADERS=\" << setting.second;\n          if (setting.second != 0 && setting.second != 1) {\n            goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: invalid ENABLE_EX_HEADERS=\", setting.second,\n              \" for streamID=\", curHeader_.stream);\n            VLOG(4) << goawayErrorMessage_;\n            return ErrorCode::PROTOCOL_ERROR;\n          }\n          break;\n        } else {\n          // egress ENABLE_EX_HEADERS is disabled, consider the ingress\n          // ENABLE_EX_HEADERS as unknown setting, and ignore it.\n          continue;\n        }\n      }\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.second > 1) {\n          goawayErrorMessage_ = folly::to<string>(\n              \"GOAWAY error: ENABLE_CONNECT_PROTOCOL invalid number=\",\n              setting.second, \" for streamID=\", curHeader_.stream);\n          VLOG(4) << goawayErrorMessage_;\n          return ErrorCode::PROTOCOL_ERROR;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      case SettingsId::SETTINGS_HTTP_CERT_AUTH:\n        break;\n      default:\n        continue; // ignore unknown setting\n    }\n    ingressSettings_.setSetting(setting.first, setting.second);\n    settingsList.push_back(*ingressSettings_.getSetting(setting.first));\n  }\n  if (callback_) {\n    callback_->onSettings(settingsList);\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parsePushPromise(Cursor& cursor) {\n  // stream id must be idle - protocol error\n  // assoc-stream-id=closed/unknown - protocol error, unless rst_stream sent\n\n  /*\n   * What does \"must handle\" mean in the following context?  I have to\n   * accept this as a valid pushed resource?\n\n    However, an endpoint that has sent RST_STREAM on the associated\n    stream MUST handle PUSH_PROMISE frames that might have been\n    created before the RST_STREAM frame is received and processed.\n  */\n  if (transportDirection_ != TransportDirection::UPSTREAM) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on DOWNSTREAM codec\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (egressSettings_.getSetting(SettingsId::ENABLE_PUSH, -1) != 1) {\n    goawayErrorMessage_ = folly::to<string>(\n      \"Received PUSH_PROMISE on codec with push disabled\");\n    VLOG(2) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  VLOG(4) << \"parsing PUSH_PROMISE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t promisedStream;\n  std::unique_ptr<IOBuf> headerBlockFragment;\n  auto err = http2::parsePushPromise(cursor, curHeader_, promisedStream,\n                                     headerBlockFragment);\n  RETURN_IF_ERROR(err);\n  RETURN_IF_ERROR(checkNewStream(promisedStream, false /* trailersAllowed */));\n  err = parseHeadersImpl(cursor, std::move(headerBlockFragment), folly::none,\n                         promisedStream, folly::none);\n  return err;\n}\n\nErrorCode HTTP2Codec::parsePing(Cursor& cursor) {\n  VLOG(4) << \"parsing PING frame length=\" << curHeader_.length;\n  uint64_t opaqueData = 0;\n  auto err = http2::parsePing(cursor, curHeader_, opaqueData);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    if (curHeader_.flags & http2::ACK) {\n      callback_->onPingReply(opaqueData);\n    } else {\n      callback_->onPingRequest(opaqueData);\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseGoaway(Cursor& cursor) {\n  VLOG(4) << \"parsing GOAWAY frame length=\" << curHeader_.length;\n  uint32_t lastGoodStream = 0;\n  ErrorCode statusCode = ErrorCode::NO_ERROR;\n  std::unique_ptr<IOBuf> debugData;\n\n  auto err = http2::parseGoaway(cursor, curHeader_, lastGoodStream, statusCode,\n                                debugData);\n  if (statusCode != ErrorCode::NO_ERROR) {\n    VLOG(2) << \"Goaway error statusCode=\" << getErrorCodeString(statusCode)\n            << \" lastStream=\" << lastGoodStream\n            << \" user-agent=\" << userAgent_ <<  \" debugData=\" <<\n      ((debugData) ? string((char*)debugData->data(), debugData->length()):\n       empty_string);\n  }\n  RETURN_IF_ERROR(err);\n  if (lastGoodStream < ingressGoawayAck_) {\n    ingressGoawayAck_ = lastGoodStream;\n    // Drain all streams <= lastGoodStream\n    // and abort streams > lastGoodStream\n    if (callback_) {\n      callback_->onGoaway(lastGoodStream, statusCode, std::move(debugData));\n    }\n  } else {\n    LOG(WARNING) << \"Received multiple GOAWAY with increasing ack\";\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseWindowUpdate(Cursor& cursor) {\n  VLOG(4) << \"parsing WINDOW_UPDATE frame for stream=\" << curHeader_.stream <<\n    \" length=\" << curHeader_.length;\n  uint32_t delta = 0;\n  auto err = http2::parseWindowUpdate(cursor, curHeader_, delta);\n  RETURN_IF_ERROR(err);\n  if (delta == 0) {\n    VLOG(4) << \"Invalid 0 length delta for stream=\" << curHeader_.stream;\n    if (curHeader_.stream == 0) {\n      goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid/0 length delta for streamID=\",\n        curHeader_.stream);\n      return ErrorCode::PROTOCOL_ERROR;\n    } else {\n      // Parsing a zero delta window update should cause a protocol error\n      // and send a rst stream\n      goawayErrorMessage_ = folly::to<string>(\n        \"parseWindowUpdate Invalid 0 length\");\n      VLOG(4) << goawayErrorMessage_;\n      streamError(folly::to<std::string>(\"streamID=\", curHeader_.stream,\n                                         \" with HTTP2Codec stream error: \",\n                                         \"window update delta=\", delta),\n                  ErrorCode::PROTOCOL_ERROR);\n      return ErrorCode::PROTOCOL_ERROR;\n    }\n  }\n  // if window exceeds 2^31-1, connection/stream error flow control error\n  // must be checked in session/txn\n  deliverCallbackIfAllowed(&HTTPCodec::Callback::onWindowUpdate,\n                           \"onWindowUpdate\", curHeader_.stream, delta);\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificateRequest(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE_REQUEST frame length=\" << curHeader_.length;\n  uint16_t requestId = 0;\n  std::unique_ptr<IOBuf> authRequest;\n\n  auto err = http2::parseCertificateRequest(\n      cursor, curHeader_, requestId, authRequest);\n  RETURN_IF_ERROR(err);\n  if (callback_) {\n    callback_->onCertificateRequest(requestId, std::move(authRequest));\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::parseCertificate(Cursor& cursor) {\n  VLOG(4) << \"parsing CERTIFICATE frame length=\" << curHeader_.length;\n  uint16_t certId = 0;\n  std::unique_ptr<IOBuf> authData;\n  auto err = http2::parseCertificate(cursor, curHeader_, certId, authData);\n  RETURN_IF_ERROR(err);\n  if (curAuthenticatorBlock_.empty()) {\n    curCertId_ = certId;\n  } else if (certId != curCertId_) {\n    // Received CERTIFICATE frame with different Cert-ID.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  curAuthenticatorBlock_.append(std::move(authData));\n  if (curAuthenticatorBlock_.chainLength() > http2::kMaxAuthenticatorBufSize) {\n    // Received excessively long authenticator.\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  if (!(curHeader_.flags & http2::TO_BE_CONTINUED)) {\n    auto authenticator = curAuthenticatorBlock_.move();\n    if (callback_) {\n      callback_->onCertificate(certId, std::move(authenticator));\n    } else {\n      curAuthenticatorBlock_.clear();\n    }\n  }\n  return ErrorCode::NO_ERROR;\n}\n\nErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n\n  if (isInitiatedStream(streamId)) {\n    // this stream should be initiated by us, not by peer\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}\n\nsize_t HTTP2Codec::generateConnectionPreface(folly::IOBufQueue& writeBuf) {\n  if (transportDirection_ == TransportDirection::UPSTREAM) {\n    VLOG(4) << \"generating connection preface\";\n    writeBuf.append(http2::kConnectionPreface);\n    return http2::kConnectionPreface.length();\n  }\n  return 0;\n}\n\nbool HTTP2Codec::onIngressUpgradeMessage(const HTTPMessage& msg) {\n  if (!HTTPParallelCodec::onIngressUpgradeMessage(msg)) {\n    return false;\n  }\n  if (msg.getHeaders().getNumberOfValues(http2::kProtocolSettingsHeader) != 1) {\n    VLOG(4) << __func__ << \" with no HTTP2-Settings\";\n    return false;\n  }\n\n  const auto& settingsHeader = msg.getHeaders().getSingleOrEmpty(\n    http2::kProtocolSettingsHeader);\n  if (settingsHeader.empty()) {\n    return true;\n  }\n\n  auto decoded = base64url_decode(settingsHeader);\n\n  // Must be well formed Base64Url and not too large\n  if (decoded.empty() || decoded.length() > http2::kMaxFramePayloadLength) {\n    VLOG(4) << __func__ << \" failed to decode HTTP2-Settings\";\n    return false;\n  }\n  std::unique_ptr<IOBuf> decodedBuf = IOBuf::wrapBuffer(decoded.data(),\n                                                        decoded.length());\n  IOBufQueue settingsQueue{IOBufQueue::cacheChainLength()};\n  settingsQueue.append(std::move(decodedBuf));\n  Cursor c(settingsQueue.front());\n  std::deque<SettingPair> settings;\n  // downcast is ok because of above length check\n  http2::FrameHeader frameHeader{\n    (uint32_t)settingsQueue.chainLength(), 0, http2::FrameType::SETTINGS, 0, 0};\n  auto err = http2::parseSettings(c, frameHeader, settings);\n  if (err != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" bad settings frame\";\n    return false;\n  }\n\n  if (handleSettings(settings) != ErrorCode::NO_ERROR) {\n    VLOG(4) << __func__ << \" handleSettings failed\";\n    return false;\n  }\n\n  return true;\n}\n\nvoid HTTP2Codec::generateHeader(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                const HTTPMessage& msg,\n                                bool eom,\n                                HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generatePushPromise(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     const HTTPMessage& msg,\n                                     StreamID assocStream,\n                                     bool eom,\n                                     HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     assocStream,\n                     folly::none, /* controlStream */\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateExHeader(folly::IOBufQueue& writeBuf,\n                                  StreamID stream,\n                                  const HTTPMessage& msg,\n                                  const HTTPCodec::ExAttributes& exAttributes,\n                                  bool eom,\n                                  HTTPHeaderSize* size) {\n  generateHeaderImpl(writeBuf,\n                     stream,\n                     msg,\n                     folly::none, /* assocStream */\n                     exAttributes,\n                     eom,\n                     size);\n}\n\nvoid HTTP2Codec::generateHeaderImpl(\n    folly::IOBufQueue& writeBuf,\n    StreamID stream,\n    const HTTPMessage& msg,\n    const folly::Optional<StreamID>& assocStream,\n    const folly::Optional<HTTPCodec::ExAttributes>& exAttributes,\n    bool eom,\n    HTTPHeaderSize* size) {\n  if (assocStream) {\n    CHECK(!exAttributes);\n    VLOG(4) << \"generating PUSH_PROMISE for stream=\" << stream;\n  } else if (exAttributes) {\n    CHECK(!assocStream);\n    VLOG(4) << \"generating ExHEADERS for stream=\" << stream\n            << \" with control stream=\" << exAttributes->controlStream\n            << \" unidirectional=\" << exAttributes->unidirectional;\n  } else {\n    VLOG(4) << \"generating HEADERS for stream=\" << stream;\n  }\n\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing HEADERS/PROMISE for stream=\" << stream <<\n      \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    if (size) {\n      size->uncompressed = 0;\n      size->compressed = 0;\n    }\n    return;\n  }\n\n  if (msg.isRequest()) {\n    DCHECK(transportDirection_ == TransportDirection::UPSTREAM ||\n           assocStream || exAttributes);\n    if (msg.isEgressWebsocketUpgrade()) {\n      upgradedStreams_.insert(stream);\n    }\n  } else {\n    DCHECK(transportDirection_ == TransportDirection::DOWNSTREAM ||\n           exAttributes);\n  }\n\n  std::vector<std::string> temps;\n  auto allHeaders = CodecUtil::prepareMessageForCompression(msg, temps);\n  auto out = encodeHeaders(msg.getHeaders(), allHeaders, size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto res = msg.getHTTP2Priority();\n    auto remainingFrameSize = maxFrameSize;\n    if (res) {\n      pri = http2::PriorityUpdate{std::get<0>(*res), std::get<1>(*res),\n                                  std::get<2>(*res)};\n      DCHECK_GE(remainingFrameSize, http2::kFramePrioritySize)\n        << \"no enough space for priority? frameHeadroom=\" << remainingFrameSize;\n      remainingFrameSize -= http2::kFramePrioritySize;\n    }\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n\n    bool endHeaders = queue.chainLength() == 0;\n\n    if (assocStream) {\n      DCHECK_EQ(transportDirection_, TransportDirection::DOWNSTREAM);\n      DCHECK(!eom);\n      generateHeaderCallbackWrapper(stream, http2::FrameType::PUSH_PROMISE,\n                                    http2::writePushPromise(writeBuf,\n                                                            *assocStream,\n                                                            stream,\n                                                            std::move(chunk),\n                                                            http2::kNoPadding,\n                                                            endHeaders));\n    } else if (exAttributes) {\n      generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::EX_HEADERS,\n        http2::writeExHeaders(writeBuf,\n                              std::move(chunk),\n                              stream,\n                              *exAttributes,\n                              pri,\n                              http2::kNoPadding,\n                              eom,\n                              endHeaders));\n    } else {\n      generateHeaderCallbackWrapper(stream, http2::FrameType::HEADERS,\n                                    http2::writeHeaders(writeBuf,\n                                                        std::move(chunk),\n                                                        stream,\n                                                        pri,\n                                                        http2::kNoPadding,\n                                                        eom,\n                                                        endHeaders));\n    }\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n}\n\nvoid HTTP2Codec::generateContinuation(folly::IOBufQueue& writeBuf,\n                                      folly::IOBufQueue& queue,\n                                      StreamID stream,\n                                      size_t maxFrameSize) {\n  bool endHeaders = false;\n  while (!endHeaders) {\n    auto chunk = queue.split(std::min(maxFrameSize, queue.chainLength()));\n    endHeaders = (queue.chainLength() == 0);\n    VLOG(4) << \"generating CONTINUATION for stream=\" << stream;\n    generateHeaderCallbackWrapper(\n        stream,\n        http2::FrameType::CONTINUATION,\n        http2::writeContinuation(\n            writeBuf, stream, endHeaders, std::move(chunk)));\n  }\n}\n\nstd::unique_ptr<folly::IOBuf> HTTP2Codec::encodeHeaders(\n    const HTTPHeaders& headers,\n    std::vector<compress::Header>& allHeaders,\n    HTTPHeaderSize* size) {\n  headerCodec_.setEncodeHeadroom(http2::kFrameHeaderSize +\n                                 http2::kFrameHeadersBaseMaxSize);\n  auto out = headerCodec_.encode(allHeaders);\n  if (size) {\n    *size = headerCodec_.getEncodedSize();\n  }\n\n  if (headerCodec_.getEncodedSize().uncompressed >\n      ingressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE,\n                                  std::numeric_limits<uint32_t>::max())) {\n    // The remote side told us they don't want headers this large...\n    // but this function has no mechanism to fail\n    string serializedHeaders;\n    headers.forEach(\n      [&serializedHeaders] (const string& name, const string& value) {\n        serializedHeaders = folly::to<string>(serializedHeaders, \"\\\\n\", name,\n                                              \":\", value);\n      });\n    LOG(ERROR) << \"generating HEADERS frame larger than peer maximum nHeaders=\"\n               << headers.size() << \" all headers=\"\n               << serializedHeaders;\n  }\n  return out;\n}\n\nsize_t HTTP2Codec::generateHeaderCallbackWrapper(StreamID stream,\n                                                 http2::FrameType type,\n                                                 size_t length) {\n  if (callback_) {\n    callback_->onGenerateFrameHeader(stream,\n                                     static_cast<uint8_t>(type),\n                                     length);\n  }\n  return length;\n}\n\nsize_t HTTP2Codec::generateBody(folly::IOBufQueue& writeBuf,\n                                StreamID stream,\n                                std::unique_ptr<folly::IOBuf> chain,\n                                folly::Optional<uint8_t> padding,\n                                bool eom) {\n  // todo: generate random padding for everything?\n  size_t written = 0;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"Suppressing DATA for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(chain));\n  size_t maxFrameSize = maxSendFrameSize();\n  while (queue.chainLength() > maxFrameSize) {\n    auto chunk = queue.split(maxFrameSize);\n    written += generateHeaderCallbackWrapper(\n                  stream,\n                  http2::FrameType::DATA,\n                  http2::writeData(writeBuf,\n                                   std::move(chunk),\n                                   stream,\n                                   padding,\n                                   false,\n                                   reuseIOBufHeadroomForData_));\n  }\n\n  return written + generateHeaderCallbackWrapper(\n                      stream,\n                      http2::FrameType::DATA,\n                      http2::writeData(writeBuf,\n                                       queue.move(),\n                                       stream,\n                                       padding,\n                                       eom,\n                                       reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateChunkHeader(folly::IOBufQueue& /*writeBuf*/,\n                                       StreamID /*stream*/,\n                                       size_t /*length*/) {\n  // HTTP/2 has no chunk headers\n  return 0;\n}\n\nsize_t HTTP2Codec::generateChunkTerminator(folly::IOBufQueue& /*writeBuf*/,\n                                           StreamID /*stream*/) {\n  // HTTP/2 has no chunk terminators\n  return 0;\n}\n\nsize_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true /*eom*/,\n                                                      endHeaders));\n\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n\n  return size.compressed;\n}\n\nsize_t HTTP2Codec::generateEOM(folly::IOBufQueue& writeBuf,\n                               StreamID stream) {\n  VLOG(4) << \"sending EOM for stream=\" << stream;\n  upgradedStreams_.erase(stream);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed EOM for stream=\" << stream << \" ingressGoawayAck_=\"\n            << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::DATA,\n            http2::writeData(writeBuf,\n                             nullptr,\n                             stream,\n                             http2::kNoPadding,\n                             true,\n                             reuseIOBufHeadroomForData_));\n}\n\nsize_t HTTP2Codec::generateRstStream(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     ErrorCode statusCode) {\n  VLOG(4) << \"sending RST_STREAM for stream=\" << stream\n          << \" with code=\" << getErrorCodeString(statusCode);\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed RST_STREAM for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  // Suppress any EOM callback for the current frame.\n  if (stream == curHeader_.stream) {\n    curHeader_.flags &= ~http2::END_STREAM;\n    pendingEndStreamHandling_ = false;\n    ingressWebsocketUpgrade_ = false;\n  }\n  upgradedStreams_.erase(stream);\n\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending RST_STREAM with code=\" << getErrorCodeString(statusCode)\n            << \" for stream=\" << stream << \" user-agent=\" << userAgent_;\n  }\n  auto code = http2::errorCodeToReset(statusCode);\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::RST_STREAM,\n                                       http2::writeRstStream(writeBuf, stream, code));\n}\n\nsize_t HTTP2Codec::generateGoaway(folly::IOBufQueue& writeBuf,\n                                  StreamID lastStream,\n                                  ErrorCode statusCode,\n                                  std::unique_ptr<folly::IOBuf> debugData) {\n  DCHECK_LE(lastStream, egressGoawayAck_) << \"Cannot increase last good stream\";\n  egressGoawayAck_ = lastStream;\n  if (sessionClosing_ == ClosingState::CLOSED) {\n    VLOG(4) << \"Not sending GOAWAY for closed session\";\n    return 0;\n  }\n  switch (sessionClosing_) {\n    case ClosingState::OPEN:\n    case ClosingState::OPEN_WITH_GRACEFUL_DRAIN_ENABLED:\n      if (lastStream == std::numeric_limits<int32_t>::max() &&\n          statusCode == ErrorCode::NO_ERROR) {\n        sessionClosing_ = ClosingState::FIRST_GOAWAY_SENT;\n      } else {\n        // The user of this codec decided not to do the double goaway\n        // drain, or this is not a graceful shutdown\n        sessionClosing_ = ClosingState::CLOSED;\n      }\n      break;\n    case ClosingState::FIRST_GOAWAY_SENT:\n      sessionClosing_ = ClosingState::CLOSED;\n      break;\n    case ClosingState::CLOSING:\n    case ClosingState::CLOSED:\n      LOG(FATAL) << \"unreachable\";\n  }\n\n  VLOG(4) << \"Sending GOAWAY with last acknowledged stream=\"\n          << lastStream << \" with code=\" << getErrorCodeString(statusCode);\n  if (statusCode == ErrorCode::PROTOCOL_ERROR) {\n    VLOG(2) << \"sending GOAWAY with last acknowledged stream=\" << lastStream\n            << \" with code=\" << getErrorCodeString(statusCode)\n            << \" user-agent=\" << userAgent_;\n  }\n\n  auto code = http2::errorCodeToGoaway(statusCode);\n  return generateHeaderCallbackWrapper(\n            0,\n            http2::FrameType::GOAWAY,\n            http2::writeGoaway(writeBuf,\n                              lastStream,\n                              code,\n                              std::move(debugData)));\n}\n\nsize_t HTTP2Codec::generatePingRequest(folly::IOBufQueue& writeBuf) {\n  // should probably let the caller specify when integrating with session\n  // we know HTTPSession sets up events to track ping latency\n  uint64_t opaqueData = folly::Random::rand64();\n  VLOG(4) << \"Generating ping request with opaqueData=\" << opaqueData;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, opaqueData, false /* no ack */));\n}\n\nsize_t HTTP2Codec::generatePingReply(folly::IOBufQueue& writeBuf,\n                                     uint64_t uniqueID) {\n  VLOG(4) << \"Generating ping reply with opaqueData=\" << uniqueID;\n  return generateHeaderCallbackWrapper(0, http2::FrameType::PING,\n                                       http2::writePing(writeBuf, uniqueID, true /* ack */));\n}\n\nsize_t HTTP2Codec::generateSettings(folly::IOBufQueue& writeBuf) {\n  std::deque<SettingPair> settings;\n  for (auto& setting: egressSettings_.getAllSettings()) {\n    switch (setting.id) {\n      case SettingsId::HEADER_TABLE_SIZE:\n        if (pendingTableMaxSize_) {\n          LOG(ERROR) << \"Can't have more than one settings in flight, skipping\";\n          continue;\n        } else {\n          pendingTableMaxSize_ = setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_PUSH:\n        if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n          // HTTP/2 spec says downstream must not send this flag\n          // HTTP2Codec uses it to determine if push features are enabled\n          continue;\n        } else {\n          CHECK(setting.value == 0 || setting.value == 1);\n        }\n        break;\n      case SettingsId::MAX_CONCURRENT_STREAMS:\n      case SettingsId::INITIAL_WINDOW_SIZE:\n      case SettingsId::MAX_FRAME_SIZE:\n        break;\n      case SettingsId::MAX_HEADER_LIST_SIZE:\n        headerCodec_.setMaxUncompressed(setting.value);\n        break;\n      case SettingsId::ENABLE_EX_HEADERS:\n        CHECK(setting.value == 0 || setting.value == 1);\n        if (setting.value == 0) {\n          continue; // just skip the experimental setting if disabled\n        } else {\n          VLOG(4) << \"generating ENABLE_EX_HEADERS=\" << setting.value;\n        }\n        break;\n      case SettingsId::ENABLE_CONNECT_PROTOCOL:\n        if (setting.value == 0) {\n          continue;\n        }\n        break;\n      case SettingsId::THRIFT_CHANNEL_ID:\n      case SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:\n        break;\n      default:\n        LOG(ERROR) << \"ignore unknown settingsId=\"\n                   << std::underlying_type<SettingsId>::type(setting.id)\n                   << \" value=\" << setting.value;\n        continue;\n    }\n\n    settings.push_back(SettingPair(setting.id, setting.value));\n  }\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating \" << (unsigned)settings.size() << \" settings\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettings(writeBuf, settings));\n}\n\nvoid HTTP2Codec::requestUpgrade(HTTPMessage& request) {\n  static folly::ThreadLocalPtr<HTTP2Codec> defaultCodec;\n  if (!defaultCodec.get()) {\n    defaultCodec.reset(new HTTP2Codec(TransportDirection::UPSTREAM));\n  }\n\n  auto& headers = request.getHeaders();\n  headers.set(HTTP_HEADER_UPGRADE, http2::kProtocolCleartextString);\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION, \"Upgrade\", false)) {\n    headers.add(HTTP_HEADER_CONNECTION, \"Upgrade\");\n  }\n  IOBufQueue writeBuf{IOBufQueue::cacheChainLength()};\n  defaultCodec->generateSettings(writeBuf);\n  // fake an ack since defaultCodec gets reused\n  defaultCodec->handleSettingsAck();\n  writeBuf.trimStart(http2::kFrameHeaderSize);\n  auto buf = writeBuf.move();\n  buf->coalesce();\n  headers.set(http2::kProtocolSettingsHeader,\n              base64url_encode(folly::ByteRange(buf->data(), buf->length())));\n  if (!request.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                   http2::kProtocolSettingsHeader.c_str(),\n                                   false)) {\n    headers.add(HTTP_HEADER_CONNECTION, http2::kProtocolSettingsHeader);\n  }\n}\n\nsize_t HTTP2Codec::generateSettingsAck(folly::IOBufQueue& writeBuf) {\n  VLOG(4) << getTransportDirectionString(getTransportDirection())\n          << \" generating settings ack\";\n  return generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,\n                                       http2::writeSettingsAck(writeBuf));\n}\n\nsize_t HTTP2Codec::generateWindowUpdate(folly::IOBufQueue& writeBuf,\n                                        StreamID stream,\n                                        uint32_t delta) {\n  VLOG(4) << \"generating window update for stream=\" << stream\n          << \": Processed \" << delta << \" bytes\";\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed WINDOW_UPDATE for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(stream, http2::FrameType::WINDOW_UPDATE,\n                                       http2::writeWindowUpdate(writeBuf, stream, delta));\n}\n\nsize_t HTTP2Codec::generatePriority(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPMessage::HTTPPriority& pri) {\n  VLOG(4) << \"generating priority for stream=\" << stream;\n  if (!isStreamIngressEgressAllowed(stream)) {\n    VLOG(2) << \"suppressed PRIORITY for stream=\" << stream\n            << \" ingressGoawayAck_=\" << ingressGoawayAck_;\n    return 0;\n  }\n  return generateHeaderCallbackWrapper(\n            stream,\n            http2::FrameType::PRIORITY,\n            http2::writePriority(writeBuf, stream,\n                                 {std::get<0>(pri),\n                                   std::get<1>(pri),\n                                   std::get<2>(pri)}));\n}\n\nsize_t HTTP2Codec::generateCertificateRequest(\n    folly::IOBufQueue& writeBuf,\n    uint16_t requestId,\n    std::unique_ptr<folly::IOBuf> certificateRequestData) {\n  VLOG(4) << \"generating CERTIFICATE_REQUEST with Request-ID=\" << requestId;\n  return http2::writeCertificateRequest(\n      writeBuf, requestId, std::move(certificateRequestData));\n}\n\nsize_t HTTP2Codec::generateCertificate(folly::IOBufQueue& writeBuf,\n                                       uint16_t certId,\n                                       std::unique_ptr<folly::IOBuf> certData) {\n  size_t written = 0;\n  VLOG(4) << \"sending CERTIFICATE with Cert-ID=\" << certId << \"for stream=0\";\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(certData));\n  // The maximum size of an autenticator fragment, combined with the Cert-ID can\n  // not exceed the maximal allowable size of a sent frame.\n  size_t maxChunkSize = maxSendFrameSize() - sizeof(certId);\n  while (queue.chainLength() > maxChunkSize) {\n    auto chunk = queue.splitAtMost(maxChunkSize);\n    written +=\n        http2::writeCertificate(writeBuf, certId, std::move(chunk), true);\n  }\n  return written +\n         http2::writeCertificate(writeBuf, certId, queue.move(), false);\n}\n\nbool HTTP2Codec::checkConnectionError(ErrorCode err, const folly::IOBuf* buf) {\n  if (err != ErrorCode::NO_ERROR) {\n    LOG(ERROR) << \"Connection error \" << getErrorCodeString(err)\n               << \" with ingress=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(buf, true);\n    if (callback_) {\n      std::string errorDescription = goawayErrorMessage_.empty() ?\n        \"Connection error\" : goawayErrorMessage_;\n      HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,\n                       errorDescription);\n      ex.setCodecStatusCode(err);\n      callback_->onError(0, ex, false);\n    }\n    return true;\n  }\n  return false;\n}\n\nvoid HTTP2Codec::streamError(const std::string& msg, ErrorCode code,\n                             bool newTxn) {\n  HTTPException error(HTTPException::Direction::INGRESS_AND_EGRESS,\n                      msg);\n  error.setCodecStatusCode(code);\n  if (callback_) {\n    callback_->onError(curHeader_.stream, error, newTxn);\n  }\n}\n\nHTTPCodec::StreamID\nHTTP2Codec::mapPriorityToDependency(uint8_t priority) const {\n  // If the priority is out of the maximum index of virtual nodes array, we\n  // return the lowest level virtual node as a punishment of not setting\n  // priority correctly.\n  return virtualPriorityNodes_.empty()\n    ? 0\n    : virtualPriorityNodes_[\n        std::min(priority, uint8_t(virtualPriorityNodes_.size() - 1))];\n}\n\nbool HTTP2Codec::parsingTrailers() const {\n  // HEADERS frame is used for request/response headers and trailers.\n  // Per spec, specific role of HEADERS frame is determined by it's postion\n  // within the stream. We don't keep full stream state in this codec,\n  // thus using heuristics to distinguish between headers/trailers.\n  // For DOWNSTREAM case, request headers HEADERS frame would be creating\n  // new stream, thus HEADERS on existing stream ID are considered trailers\n  // (see checkNewStream).\n  // For UPSTREAM case, response headers are required to have status code,\n  // thus if no status code we consider that trailers.\n  if (curHeader_.type == http2::FrameType::HEADERS ||\n      curHeader_.type == http2::FrameType::CONTINUATION) {\n    if (transportDirection_ == TransportDirection::DOWNSTREAM) {\n      return parsingDownstreamTrailers_;\n    } else {\n      return !decodeInfo_.hasStatus();\n    }\n  }\n  return false;\n}\n}\n", "/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n#include <proxygen/lib/http/codec/test/HTTPParallelCodecTest.h>\n#include <proxygen/lib/http/codec/test/MockHTTPCodec.h>\n#include <folly/io/Cursor.h>\n#include <proxygen/lib/http/codec/HTTP2Codec.h>\n#include <proxygen/lib/http/codec/test/HTTP2FramerTest.h>\n#include <proxygen/lib/http/HTTPHeaderSize.h>\n#include <proxygen/lib/http/HTTPMessage.h>\n\n#include <folly/portability/GTest.h>\n#include <folly/portability/GMock.h>\n#include <random>\n\nusing namespace proxygen;\nusing namespace proxygen::compress;\nusing namespace folly;\nusing namespace folly::io;\nusing namespace std;\nusing namespace testing;\n\nTEST(HTTP2CodecConstantsTest, HTTPContantsAreCommonHeaders) {\n  // The purpose of this test is to verify some basic assumptions that should\n  // never change but to make clear that the following http2 header constants\n  // map to the respective common headers.  Should this test ever fail, the\n  // H2Codec would need to be updated in the corresponding places when creating\n  // compress/Header objects.\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kMethod),\n            HTTP_HEADER_COLON_METHOD);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kScheme),\n            HTTP_HEADER_COLON_SCHEME);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kPath),\n            HTTP_HEADER_COLON_PATH);\n  EXPECT_EQ(\n    HTTPCommonHeaders::hash(headers::kAuthority),\n    HTTP_HEADER_COLON_AUTHORITY);\n  EXPECT_EQ(HTTPCommonHeaders::hash(headers::kStatus),\n            HTTP_HEADER_COLON_STATUS);\n}\n\nclass HTTP2CodecTest : public HTTPParallelCodecTest {\n public:\n\n  HTTP2CodecTest()\n    :HTTPParallelCodecTest(upstreamCodec_, downstreamCodec_) {}\n\n  void SetUp() override {\n    HTTPParallelCodecTest::SetUp();\n  }\n  void testHeaderListSize(bool oversized);\n  void testFrameSizeLimit(bool oversized);\n\n protected:\n  HTTP2Codec upstreamCodec_{TransportDirection::UPSTREAM};\n  HTTP2Codec downstreamCodec_{TransportDirection::DOWNSTREAM};\n};\n\nTEST_F(HTTP2CodecTest, IgnoreUnknownSettings) {\n  auto numSettings = downstreamCodec_.getIngressSettings()->getNumSettings();\n  std::deque<SettingPair> settings;\n  for (uint32_t i = 200; i < (200 + 1024); i++) {\n    settings.push_back(SettingPair(SettingsId(i), i));\n  }\n  http2::writeSettings(output_, settings);\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(numSettings,\n            downstreamCodec_.getIngressSettings()->getNumSettings());\n}\n\nTEST_F(HTTP2CodecTest, NoExHeaders) {\n  // do not emit ENABLE_EX_HEADERS setting, if disabled\n  SetUpUpstreamTest();\n\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.numSettings, 0);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  // only 3 standard settings: HEADER_TABLE_SIZE, ENABLE_PUSH, MAX_FRAME_SIZE.\n  EXPECT_EQ(callbacks_.numSettings, 3);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersSetting) {\n  // disable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, EnableExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  auto ptr = downstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(nullptr, ptr);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n\n  // attempt to enable EX_HEADERS on ingress\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 1)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(1, ptr->value);\n  EXPECT_EQ(true, downstreamCodec_.supportsExTransactions());\n\n  // attempt to disable EX_HEADERS on ingress\n  callbacks_.reset();\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 0)});\n  parse();\n\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  ptr = downstreamCodec_.getIngressSettings()->getSetting(\n      SettingsId::ENABLE_EX_HEADERS);\n  EXPECT_EQ(0, ptr->value);\n  EXPECT_EQ(false, downstreamCodec_.supportsExTransactions());\n}\n\nTEST_F(HTTP2CodecTest, InvalidExHeadersSetting) {\n  // enable EX_HEADERS on egress\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n\n  // attempt to set a invalid ENABLE_EX_HEADERS value\n  http2::writeSettings(output_,\n                      {SettingPair(SettingsId::ENABLE_EX_HEADERS, 110)});\n  parse();\n\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicHeader) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, RequestFromServer) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP request initiated\n  // by server side\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  SetUpUpstreamTest();\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"tab-hdr\", \"coolio\\tv2\");\n  // Connection header will get dropped\n  req.getHeaders().add(HTTP_HEADER_CONNECTION, \"Love\");\n  req.setSecure(true);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  upstreamCodec_.generateExHeader(output_, stream, req,\n                                  HTTPCodec::ExAttributes(controlStream, true),\n                                  true);\n\n  parseUpstream();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  callbacks_.expectMessage(true, 3, \"/guacamole\");\n  EXPECT_TRUE(callbacks_.msg->isSecure());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(\"coolio\\tv2\", headers.getSingleOrEmpty(\"tab-hdr\"));\n  EXPECT_EQ(\"www.foo.com\", headers.getSingleOrEmpty(HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, ResponseFromClient) {\n  // this is to test EX_HEADERS frame, which carrys the HTTP response replied by\n  // client side\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, resp,\n    HTTPCodec::ExAttributes(controlStream, true), true);\n\n  parse();\n  EXPECT_EQ(controlStream, callbacks_.controlStreamId);\n  EXPECT_TRUE(callbacks_.isUnidirectional);\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, ExHeadersWithPriority) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 1);\n  proxygen::http2::writeSettings(\n      output_, {{proxygen::SettingsId::ENABLE_EX_HEADERS, 1}});\n\n  auto req = getGetRequest();\n  auto pri = HTTPMessage::HTTPPriority(0, false, 7);\n  req.setHTTP2Priority(pri);\n  upstreamCodec_.generateExHeader(output_, 3, req,\n                                  HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.msg->getHTTP2Priority(), pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, IgnoreExHeadersIfNotEnabled) {\n  downstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_EX_HEADERS, 0);\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  downstreamCodec_.generateExHeader(output_, 3, req,\n                                    HTTPCodec::ExAttributes(1, true));\n\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaders) {\n  static const std::string v1(\"GET\");\n  static const std::string v2(\"/\");\n  static const std::string v3(\"http\");\n  static const std::string v4(\"foo.com\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 7);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPseudoHeaders) {\n  static const std::string v1(\"POST\");\n  static const std::string v2(\"http\");\n  static const std::string n3(\"foo\");\n  static const std::string v3(\"bar\");\n  static const std::string v4(\"/\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kScheme, v2),\n    Header::makeHeaderForTest(n3, v3),\n    Header::makeHeaderForTest(headers::kPath, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  std::vector<proxygen::compress::Header> allHeaders = reqHeaders;\n  auto encodedHeaders = headerCodec.encode(allHeaders);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      stream,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderValues) {\n  static const std::string v1(\"--1\");\n  static const std::string v2(\"\\13\\10protocol-attack\");\n  static const std::string v3(\"\\13\");\n  static const std::string v4(\"abc.com\\\\13\\\\10\");\n  static const vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kPath, v2),\n    Header::makeHeaderForTest(headers::kScheme, v3),\n    Header::makeHeaderForTest(headers::kAuthority, v4),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  for (size_t i = 0; i < reqHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders;\n    allHeaders.push_back(reqHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 4);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n/**\n * Ingress bytes with an empty header name\n */\nconst uint8_t kBufEmptyHeader[] = {\n  0x00, 0x00, 0x1d, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01, 0x82,\n  0x87, 0x44, 0x87, 0x62, 0x6b, 0x46, 0x41, 0xd2, 0x7a, 0x0b,\n  0x41, 0x89, 0xf1, 0xe3, 0xc2, 0xf2, 0x9c, 0xeb, 0x90, 0xf4,\n  0xff, 0x40, 0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7\n};\n\nTEST_F(HTTP2CodecTest, EmptyHeaderName) {\n  output_.append(IOBuf::copyBuffer(kBufEmptyHeader, sizeof(kBufEmptyHeader)));\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicConnect) {\n  std::string authority = \"myhost:1234\";\n  HTTPMessage request;\n  request.setMethod(HTTPMethod::CONNECT);\n  request.getHeaders().add(proxygen::HTTP_HEADER_HOST, authority);\n  upstreamCodec_.generateHeader(output_, 1, request, false /* eom */);\n\n  parse();\n  callbacks_.expectMessage(false, 1, \"\");\n  EXPECT_EQ(HTTPMethod::CONNECT, callbacks_.msg->getMethod());\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(authority, headers.getSingleOrEmpty(proxygen::HTTP_HEADER_HOST));\n}\n\nTEST_F(HTTP2CodecTest, BadConnect) {\n  std::string v1 = \"CONNECT\";\n  std::string v2 = \"somehost:576\";\n  std::vector<proxygen::compress::Header> goodHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, v1),\n    Header::makeHeaderForTest(headers::kAuthority, v2),\n  };\n\n  // See https://tools.ietf.org/html/rfc7540#section-8.3\n  std::string v3 = \"/foobar\";\n  std::vector<proxygen::compress::Header> badHeaders = {\n    Header::makeHeaderForTest(headers::kScheme, headers::kHttp),\n    Header::makeHeaderForTest(headers::kPath, v3),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  HTTPCodec::StreamID stream = 1;\n\n  for (size_t i = 0; i < badHeaders.size(); i++, stream += 2) {\n    auto allHeaders = goodHeaders;\n    allHeaders.push_back(badHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, badHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nvoid HTTP2CodecTest::testHeaderListSize(bool oversized) {\n  if (oversized) {\n    auto settings = downstreamCodec_.getEgressSettings();\n    settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  }\n\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  req.getHeaders().add(\"x-long-long-header\",\n                       \"supercalafragalisticexpialadoshus\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nvoid HTTP2CodecTest::testFrameSizeLimit(bool oversized) {\n  HTTPMessage req = getBigGetRequest(\"/guacamole\");\n  auto settings = downstreamCodec_.getEgressSettings();\n\n  parse(); // consume preface\n  if (oversized) {\n    // trick upstream for sending a 2x bigger HEADERS frame\n    settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                         http2::kMaxFramePayloadLengthMin * 2);\n    downstreamCodec_.generateSettings(output_);\n    parseUpstream();\n  }\n\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE,\n                       http2::kMaxFramePayloadLengthMin);\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.headersComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.messageComplete, oversized ? 0 : 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, oversized ? 1 : 0);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeHeader) {\n  testHeaderListSize(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedHeader) {\n  testHeaderListSize(true);\n}\n\nTEST_F(HTTP2CodecTest, NormalSizeFrame) {\n  testFrameSizeLimit(false);\n}\n\nTEST_F(HTTP2CodecTest, OversizedFrame) {\n  testFrameSizeLimit(true);\n}\n\nTEST_F(HTTP2CodecTest, BigHeaderCompressed) {\n  SetUpUpstreamTest();\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_HEADER_LIST_SIZE, 37);\n  downstreamCodec_.generateSettings(output_);\n  parseUpstream();\n\n  SetUp();\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  // session error\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\n\nTEST_F(HTTP2CodecTest, BasicHeaderReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n\n  parseUpstream();\n  callbacks_.expectMessage(true, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  // HTTP/2 doesnt support serialization - instead you get the default\n  EXPECT_EQ(\"OK\", callbacks_.msg->getStatusMessage());\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadHeadersReply) {\n  static const std::string v1(\"200\");\n  static const vector<proxygen::compress::Header> respHeaders = {\n    Header::makeHeaderForTest(headers::kStatus, v1),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  HTTPCodec::StreamID stream = 1;\n  // missing fields (missing authority is OK)\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    allHeaders.erase(allHeaders.begin() + i);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n  // dup fields\n  std::string v(\"foomonkey\");\n  for (size_t i = 0; i < respHeaders.size(); i++, stream += 2) {\n    std::vector<proxygen::compress::Header> allHeaders = respHeaders;\n    auto h = allHeaders[i];\n    h.value = &v;\n    allHeaders.push_back(h);\n    auto encodedHeaders = headerCodec.encode(allHeaders);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        true,\n                        true);\n  }\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, Cookies) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(\"Cookie\", \"chocolate-chip=1\");\n  req.getHeaders().add(\"Cookie\", \"rainbow-chip=2\");\n  req.getHeaders().add(\"Cookie\", \"butterscotch=3\");\n  req.getHeaders().add(\"Cookie\", \"oatmeal-raisin=4\");\n  req.setSecure(true);\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"/guacamole\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"chocolate-chip\"), \"1\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"rainbow-chip\"), \"2\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"butterscotch\"), \"3\");\n  EXPECT_EQ(callbacks_.msg->getCookie(\"oatmeal-raisin\"), \"4\");\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuation) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicContinuationEndStream) {\n  // CONTINUATION with END_STREAM flag set on the preceding HEADERS frame\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  parse();\n  callbacks_.expectMessage(true, -1, \"/\");\n#ifndef NDEBUG\n  EXPECT_GT(downstreamCodec_.getReceivedFrameCount(), 1);\n#endif\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadContinuation) {\n  // CONTINUATION with no preceding HEADERS\n  auto fakeHeaders = makeBuf(5);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuation) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n\n  upstreamCodec_.generateHeader(output_, 1, req);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, MissingContinuationBadFrame) {\n  IOBufQueue output(IOBufQueue::cacheChainLength());\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n\n  // insert an invalid frame\n  auto frame = makeBuf(http2::kFrameHeaderSize + 4134);\n  *((uint32_t *)frame->writableData()) = 0xfa000000;\n  output_.append(std::move(frame));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, BadContinuationStream) {\n  HTTPMessage req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  // empirically determined the size of continuation frame, and fake it\n  output_.trimEnd(http2::kFrameHeaderSize + 4134);\n  auto fakeHeaders = makeBuf(4134);\n  http2::writeContinuation(output_, 3, true, std::move(fakeHeaders));\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, FrameTooLarge) {\n  writeFrameHeaderManual(output_, 1 << 15, 0, 0, 1);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_TRUE(callbacks_.lastParseError->hasCodecStatusCode());\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n            ErrorCode::FRAME_SIZE_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, UnknownFrameType) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // unknown frame type 17\n  writeFrameHeaderManual(output_, 17, 37, 0, 1);\n  output_.append(\"wicked awesome!!!\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, 2, \"\"); // + host\n}\n\nTEST_F(HTTP2CodecTest, JunkAfterConnError) {\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n\n  // write headers frame for stream 0\n  writeFrameHeaderManual(output_, 0, (uint8_t)http2::FrameType::HEADERS, 0, 0);\n  // now write a valid headers frame, should never be parsed\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicData) {\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), data);\n}\n\nTEST_F(HTTP2CodecTest, LongData) {\n  // Hack the max frame size artificially low\n  HTTPSettings* settings = (HTTPSettings*)upstreamCodec_.getIngressSettings();\n  settings->setSetting(SettingsId::MAX_FRAME_SIZE, 16);\n  auto buf = makeBuf(100);\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), HTTPCodec::NoPadding,\n                              true);\n\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 7);\n  EXPECT_EQ(callbacks_.bodyLength, 100);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPaddingLength) {\n  const uint8_t badInput[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                              0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                              0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                              0x00, 0x00, 0x7e, 0x00, 0x6f, 0x6f, 0x6f, 0x6f,\n                              // The padding length byte below is 0x82 (130\n                              // in decimal) which is greater than the length\n                              // specified by the header's length field, 126\n                              0x01, 0x82, 0x87, 0x44, 0x87, 0x92, 0x97, 0x92,\n                              0x92, 0x92, 0x7a, 0x0b, 0x41, 0x89, 0xf1, 0xe3,\n                              0xc0, 0xf2, 0x9c, 0xdd, 0x90, 0xf4, 0xff, 0x40,\n                              0x80, 0x84, 0x2d, 0x35, 0xa7, 0xd7};\n  output_.clear();\n  output_.append(badInput, sizeof(badInput));\n  EXPECT_EQ(output_.chainLength(), sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, MalformedPadding) {\n  const uint8_t badInput[] = {\n    0x00, 0x00, 0x0d, 0x01, 0xbe, 0x63, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x73,\n    0x00, 0x00, 0x06, 0x08, 0x72, 0x00, 0x24, 0x00, 0xfa, 0x4d, 0x0d\n  };\n  output_.append(badInput, sizeof(badInput));\n\n  EXPECT_FALSE(parse());\n}\n\nTEST_F(HTTP2CodecTest, NoAppByte) {\n  const uint8_t noAppByte[] = {0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,\n                               0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,\n                               0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a,\n                               0x00, 0x00, 0x56, 0x00, 0x5d, 0x00, 0x00, 0x00,\n                               0x01, 0x55, 0x00};\n  output_.clear();\n  output_.append(noAppByte, sizeof(noAppByte));\n  EXPECT_EQ(output_.chainLength(), sizeof(noAppByte));\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataOnFrameHeaderCall) {\n  using namespace testing;\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  EXPECT_CALL(mockCallback, onFrameHeader(_, _, _, _, _));\n\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  downstreamCodec_.setCallback(&mockCallback);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy partial byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  downstreamCodec_.onIngress(*ingress1);\n}\n\nTEST_F(HTTP2CodecTest, DataFramePartialDataWithNoAppByte) {\n  const size_t bufSize = 10;\n  auto buf = makeBuf(bufSize);\n  const size_t padding = 10;\n  upstreamCodec_.generateBody(output_, 1, buf->clone(), padding, true);\n  EXPECT_EQ(output_.chainLength(), 54);\n\n  auto ingress = output_.move();\n  ingress->coalesce();\n  // Copy up to the padding length byte to a new buffer\n  auto ingress1 = IOBuf::copyBuffer(ingress->data(), 34);\n  size_t parsed = downstreamCodec_.onIngress(*ingress1);\n  // The 34th byte is the padding length byte which should not be parsed\n  EXPECT_EQ(parsed, 33);\n  // Copy from the padding length byte to the end\n  auto ingress2 = IOBuf::copyBuffer(ingress->data() + 33, 21);\n  parsed = downstreamCodec_.onIngress(*ingress2);\n  // The padding length byte should be parsed this time along with 10 bytes of\n  // application data and 10 bytes of padding\n  EXPECT_EQ(parsed, 21);\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, bufSize);\n  // Total padding is the padding length byte and the padding bytes\n  EXPECT_EQ(callbacks_.paddingBytes, padding + 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), buf->moveToFbString());\n}\n\nTEST_F(HTTP2CodecTest, BasicRst) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicRstInvalidCode) {\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::_SPDY_INVALID_STREAM);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.aborts, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicPing) {\n  upstreamCodec_.generatePingRequest(output_);\n  upstreamCodec_.generatePingReply(output_, 17);\n\n  uint64_t pingReq;\n  parse([&] (IOBuf* ingress) {\n      folly::io::Cursor c(ingress);\n      c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n      pingReq = c.read<uint64_t>();\n    });\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.recvPingRequest, pingReq);\n  EXPECT_EQ(callbacks_.recvPingReply, 17);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicWindow) {\n  // This test would fail if the codec had window state\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  upstreamCodec_.generateWindowUpdate(output_, 0, http2::kMaxWindowUpdateSize);\n  upstreamCodec_.generateWindowUpdate(output_, 1, 12);\n  upstreamCodec_.generateWindowUpdate(output_, 1, http2::kMaxWindowUpdateSize);\n\n  parse();\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 4);\n  EXPECT_EQ(callbacks_.windowUpdates[0],\n            std::vector<uint32_t>({10, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.windowUpdates[1],\n            std::vector<uint32_t>({12, http2::kMaxWindowUpdateSize}));\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, ZeroWindow) {\n  auto streamID = HTTPCodec::StreamID(1);\n  // First generate a frame with delta=1 so as to pass the checks, and then\n  // hack the frame so that delta=0 without modifying other checks\n  upstreamCodec_.generateWindowUpdate(output_, streamID, 1);\n  output_.trimEnd(http2::kFrameWindowUpdateSize);\n  QueueAppender appender(&output_, http2::kFrameWindowUpdateSize);\n  appender.writeBE<uint32_t>(0);\n\n  parse();\n  // This test doesn't ensure that RST_STREAM is generated\n  EXPECT_EQ(callbacks_.windowUpdateCalls, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.lastParseError->getCodecStatusCode(),\n      ErrorCode::PROTOCOL_ERROR);\n}\n\nTEST_F(HTTP2CodecTest, BasicGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadGoaway) {\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n  EXPECT_DEATH_NO_CORE(upstreamCodec_.generateGoaway(\n                         output_, 27, ErrorCode::ENHANCE_YOUR_CALM), \".*\");\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoaway) {\n  parse();\n  SetUpUpstreamTest();\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::NO_ERROR);\n  EXPECT_TRUE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_TRUE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n  downstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parseUpstream();\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  EXPECT_EQ(callbacks_.goaways, 2);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n  EXPECT_TRUE(upstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(upstreamCodec_.isStreamIngressEgressAllowed(2));\n  parse();\n  EXPECT_TRUE(downstreamCodec_.isStreamIngressEgressAllowed(0));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(1));\n  EXPECT_FALSE(downstreamCodec_.isStreamIngressEgressAllowed(2));\n}\n\nTEST_F(HTTP2CodecTest, DoubleGoawayWithError) {\n  SetUpUpstreamTest();\n  std::unique_ptr<folly::IOBuf> debugData =\n    folly::IOBuf::copyBuffer(\"debugData\");\n  downstreamCodec_.generateGoaway(output_, std::numeric_limits<int32_t>::max(),\n                                  ErrorCode::ENHANCE_YOUR_CALM,\n                                  std::move(debugData));\n  EXPECT_FALSE(downstreamCodec_.isWaitingToDrain());\n  EXPECT_FALSE(downstreamCodec_.isReusable());\n  auto ret = downstreamCodec_.generateGoaway(output_, 0,\n                                             ErrorCode::NO_ERROR);\n  EXPECT_EQ(ret, 0);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"debugData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, GoawayHandling) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n\n  // send request\n  HTTPMessage req = getGetRequest();\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  parse();\n  callbacks_.expectMessage(true, 1, \"/\");\n  callbacks_.reset();\n\n  SetUpUpstreamTest();\n  // drain after this message\n  downstreamCodec_.generateGoaway(output_, 1, ErrorCode::NO_ERROR);\n  parseUpstream();\n  // upstream cannot generate id > 1\n  upstreamCodec_.generateHeader(output_, 3, req, false, &size);\n  EXPECT_EQ(size.uncompressed, 0);\n  upstreamCodec_.generateWindowUpdate(output_, 3, 100);\n  upstreamCodec_.generateBody(output_, 3, makeBuf(10), HTTPCodec::NoPadding,\n                              false);\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateEOM(output_, 3);\n  upstreamCodec_.generateRstStream(output_, 3, ErrorCode::CANCEL);\n  EXPECT_EQ(output_.chainLength(), 0);\n\n  // send a push promise that will be rejected by downstream\n  req.getHeaders().add(\"foomonkey\", \"george\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1, false, &size);\n  EXPECT_GT(size.uncompressed, 0);\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  // send a push response that will be ignored\n  downstreamCodec_.generateHeader(output_, 2, resp, false, &size);\n  // window update for push doesn't make any sense, but whatever\n  downstreamCodec_.generateWindowUpdate(output_, 2, 100);\n  downstreamCodec_.generateBody(output_, 2, makeBuf(10), HTTPCodec::NoPadding,\n                                false);\n  writeFrameHeaderManual(output_, 20, (uint8_t)http2::FrameType::DATA, 0, 2);\n  output_.append(makeBuf(10));\n\n  // tell the upstream no pushing, and parse the first batch\n  IOBufQueue dummy;\n  upstreamCodec_.generateGoaway(dummy, 0, ErrorCode::NO_ERROR);\n  parseUpstream();\n\n  output_.append(makeBuf(10));\n  downstreamCodec_.generatePriority(output_, 2,\n                                    HTTPMessage::HTTPPriority(0, true, 1));\n  downstreamCodec_.generateEOM(output_, 2);\n  downstreamCodec_.generateRstStream(output_, 2, ErrorCode::CANCEL);\n\n  // send a response that will be accepted, headers should be ok\n  downstreamCodec_.generateHeader(output_, 1, resp, true, &size);\n  EXPECT_GT(size.uncompressed, 0);\n\n  // parse the remainder\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n}\n\nTEST_F(HTTP2CodecTest, GoawayReply) {\n  upstreamCodec_.generateGoaway(output_, 0, ErrorCode::NO_ERROR);\n\n  parse();\n  EXPECT_EQ(callbacks_.goaways, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  downstreamCodec_.generateEOM(output_, 1);\n  parseUpstream();\n  callbacks_.expectMessage(true, 1, 200);\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n}\n\nTEST_F(HTTP2CodecTest, BasicSetting) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::MAX_CONCURRENT_STREAMS, 37);\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 12345);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.maxStreams, 37);\n  EXPECT_EQ(callbacks_.windowSize, 12345);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsAck) {\n  upstreamCodec_.generateSettingsAck(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadSettings) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE, 0xffffffff);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BadPushSettings) {\n  auto settings = downstreamCodec_.getEgressSettings();\n  settings->clearSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 0);\n  SetUpUpstreamTest();\n\n  parseUpstream([&] (IOBuf* ingress) {\n      EXPECT_EQ(ingress->computeChainDataLength(), http2::kFrameHeaderSize);\n    });\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  // Only way to disable push for downstreamCodec_ is to read\n  // ENABLE_PUSH:0 from client\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\n\nTEST_F(HTTP2CodecTest, SettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BadSettingsTableSize) {\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 8192);\n  // This sets the max decoder table size to 8k\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  callbacks_.reset();\n\n  // Attempt to set a new max table size.  This is a no-op because the first,\n  // setting is unacknowledged.  The upstream encoder will up the table size to\n  // 8k per the first settings frame and the HPACK codec will send a code to\n  // update the decoder.\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 4096);\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n}\n\nTEST_F(HTTP2CodecTest, SettingsTableSizeEarlyShrink) {\n  // Lower size to 2k\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 2048);\n  upstreamCodec_.generateSettings(output_);\n\n  parse();\n  EXPECT_EQ(callbacks_.settings, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  downstreamCodec_.generateSettingsAck(output_);\n  // Parsing SETTINGS ack updates upstream decoder to 2k\n  parseUpstream();\n\n  callbacks_.reset();\n\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  SetUpUpstreamTest();\n  // downstream encoder will send TSU/2k\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  // sets pending table size to 512, but doesn't update it yet\n  settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::HEADER_TABLE_SIZE, 512);\n  IOBufQueue tmp{IOBufQueue::cacheChainLength()};\n  upstreamCodec_.generateSettings(tmp);\n\n  // Previous code would barf here, since TSU/2k is a violation of the current\n  // max=512\n  parseUpstream();\n  callbacks_.expectMessage(false, 2, 200);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n}\n\nTEST_F(HTTP2CodecTest, BasicPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  EXPECT_TRUE(parse());\n  EXPECT_EQ(callbacks_.priority, pri);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadHeaderPriority) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, DuplicateBadHeaderPriority) {\n  // Sent an initial header with a circular dependency\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  // Hack ingress with circular dependency.\n  EXPECT_TRUE(parse([&](IOBuf* ingress) {\n    folly::io::RWPrivateCursor c(ingress);\n    c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n    c.writeBE<uint32_t>(1);\n  }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  // On the same stream, send another request.\n  HTTPMessage nextRequest = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, nextRequest, true /* eom */);\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadPriority) {\n  auto pri = HTTPMessage::HTTPPriority(0, true, 1);\n  upstreamCodec_.generatePriority(output_, 1, pri);\n\n  // hack ingress with cirular dep\n  EXPECT_TRUE(parse([&] (IOBuf* ingress) {\n        folly::io::RWPrivateCursor c(ingress);\n        c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n        c.writeBE<uint32_t>(1);\n      }));\n\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nclass DummyQueue: public HTTPCodec::PriorityQueue {\n public:\n  DummyQueue() {}\n  ~DummyQueue() override {}\n  void addPriorityNode(HTTPCodec::StreamID id, HTTPCodec::StreamID) override {\n    nodes_.push_back(id);\n  }\n\n  std::vector<HTTPCodec::StreamID> nodes_;\n};\n\nTEST_F(HTTP2CodecTest, VirtualNodes) {\n  DummyQueue queue;\n  uint8_t level = 30;\n  upstreamCodec_.addPriorityNodes(queue, output_, level);\n\n  EXPECT_TRUE(parse());\n  for (int i = 0; i < level; i++) {\n    EXPECT_EQ(queue.nodes_[i], upstreamCodec_.mapPriorityToDependency(i));\n  }\n\n  // Out-of-range priorites are mapped to the lowest level of virtual nodes.\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level));\n  EXPECT_EQ(queue.nodes_[level - 1],\n            upstreamCodec_.mapPriorityToDependency(level + 1));\n}\n\nTEST_F(HTTP2CodecTest, BasicPushPromise) {\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_FALSE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_FALSE(downstreamCodec_.supportsPushTransactions());\n\n  auto settings = upstreamCodec_.getEgressSettings();\n  settings->setSetting(SettingsId::ENABLE_PUSH, 1);\n  upstreamCodec_.generateSettings(output_);\n  parse();\n  EXPECT_TRUE(upstreamCodec_.supportsPushTransactions());\n  EXPECT_TRUE(downstreamCodec_.supportsPushTransactions());\n\n  SetUpUpstreamTest();\n\n  HTTPCodec::StreamID assocStream = 7;\n  for (auto i = 0; i < 2; i++) {\n    // Push promise\n    HTTPCodec::StreamID pushStream = downstreamCodec_.createStream();\n    HTTPMessage req = getGetRequest();\n    req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n    downstreamCodec_.generatePushPromise(output_, pushStream, req, assocStream);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, \"/\"); // + host\n    EXPECT_EQ(callbacks_.assocStreamId, assocStream);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    auto& headers = callbacks_.msg->getHeaders();\n    EXPECT_EQ(\"coolio\", headers.getSingleOrEmpty(HTTP_HEADER_USER_AGENT));\n    callbacks_.reset();\n\n    // Actual reply headers\n    HTTPMessage resp;\n    resp.setStatusCode(200);\n    resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"text/plain\");\n    downstreamCodec_.generateHeader(output_, pushStream, resp);\n\n    parseUpstream();\n    callbacks_.expectMessage(false, 2, 200);\n    EXPECT_EQ(callbacks_.headersCompleteId, pushStream);\n    EXPECT_EQ(callbacks_.assocStreamId, 0);\n    EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n    EXPECT_EQ(\"text/plain\", callbacks_.msg->getHeaders().getSingleOrEmpty(\n                  HTTP_HEADER_CONTENT_TYPE));\n    callbacks_.reset();\n  }\n}\n\nTEST_F(HTTP2CodecTest, BadPushPromise) {\n  // ENABLE_PUSH is now 0 by default\n  SetUpUpstreamTest();\n  HTTPMessage req = getGetRequest();\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificateRequest) {\n  uint16_t requestId = 17;\n  std::unique_ptr<folly::IOBuf> authRequest =\n      folly::IOBuf::copyBuffer(\"authRequestData\");\n  upstreamCodec_.generateCertificateRequest(\n      output_, requestId, std::move(authRequest));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificateRequests, 1);\n  EXPECT_EQ(callbacks_.lastCertRequestId, requestId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authRequestData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BasicCertificate) {\n  uint16_t certId = 17;\n  std::unique_ptr<folly::IOBuf> authenticator =\n      folly::IOBuf::copyBuffer(\"authenticatorData\");\n  upstreamCodec_.generateCertificate(output_, certId, std::move(authenticator));\n\n  parse();\n  EXPECT_EQ(callbacks_.certificates, 1);\n  EXPECT_EQ(callbacks_.lastCertId, certId);\n  EXPECT_EQ(callbacks_.data.move()->moveToFbString(), \"authenticatorData\");\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, BadServerPreface) {\n  output_.move();\n  downstreamCodec_.generateWindowUpdate(output_, 0, 10);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.assocStreamId, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, Normal1024Continuation) {\n  HTTPMessage req = getGetRequest();\n  string bigval(8691, '!');\n  bigval.append(8691, ' ');\n  req.getHeaders().add(\"x-headr\", bigval);\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  parse();\n  callbacks_.expectMessage(false, -1, \"/\");\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_EQ(bigval, headers.getSingleOrEmpty(\"x-headr\"));\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n\n  upstreamCodec_.generateSettingsAck(output_);\n  parse();\n  EXPECT_EQ(callbacks_.settingsAcks, 1);\n}\n\nTEST_F(HTTP2CodecTest, StreamIdOverflow) {\n  HTTP2Codec codec(TransportDirection::UPSTREAM);\n\n  HTTPCodec::StreamID streamId;\n  codec.setNextEgressStreamId(std::numeric_limits<int32_t>::max() - 10);\n  while (codec.isReusable()) {\n    streamId = codec.createStream();\n  }\n  EXPECT_EQ(streamId, std::numeric_limits<int32_t>::max() - 2);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleDifferentContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(HTTP_HEADER_CONTENT_LENGTH, \"300\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(HTTP_HEADER_CONTENT_LENGTH), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the request fails before the codec finishes parsing the headers\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.lastParseError->getHttpStatusCode(), 400);\n}\n\nTEST_F(HTTP2CodecTest, TestMultipleIdenticalContentLengthHeaders) {\n  // Generate a POST request with two Content-Length headers\n  // NOTE: getPostRequest already adds the content-length\n  HTTPMessage req = getPostRequest();\n  req.getHeaders().add(\"content-length\", \"200\");\n  EXPECT_EQ(req.getHeaders().getNumberOfValues(\"content-length\"), 2);\n\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n  parse();\n\n  // Check that the headers parsing completes correctly\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n}\n\nTEST_F(HTTP2CodecTest, CleartextUpgrade) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_EQ(req.getHeaders().getSingleOrEmpty(HTTP_HEADER_UPGRADE), \"h2c\");\n  EXPECT_TRUE(req.checkForHeaderToken(HTTP_HEADER_CONNECTION,\n                                      \"Upgrade\", false));\n  EXPECT_TRUE(req.checkForHeaderToken(\n                HTTP_HEADER_CONNECTION,\n                http2::kProtocolSettingsHeader.c_str(), false));\n  EXPECT_GT(\n    req.getHeaders().getSingleOrEmpty(http2::kProtocolSettingsHeader).length(),\n    0);\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsSuccess) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n\n  // empty settings\n  req.getHeaders().add(http2::kProtocolSettingsHeader, \"\");\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // real settings (overwrites empty)\n  HTTP2Codec::requestUpgrade(req);\n  EXPECT_TRUE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2SettingsFailure) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  // no settings\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  HTTPHeaders& headers = req.getHeaders();\n\n  // Not base64_url settings\n  headers.set(http2::kProtocolSettingsHeader, \"????\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n  headers.set(http2::kProtocolSettingsHeader, \"AAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Too big\n  string bigSettings((http2::kMaxFramePayloadLength + 1) * 4 / 3, 'A');\n  headers.set(http2::kProtocolSettingsHeader, bigSettings);\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Malformed (not a multiple of 6)\n  headers.set(http2::kProtocolSettingsHeader, \"AAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n\n  // Two headers\n  headers.set(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  headers.add(http2::kProtocolSettingsHeader, \"AAAAAAAA\");\n  EXPECT_FALSE(downstreamCodec_.onIngressUpgradeMessage(req));\n}\n\nTEST_F(HTTP2CodecTest, HTTP2EnableConnect) {\n  SetUpUpstreamTest();\n  // egress settings have no connect settings.\n  auto ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  // enable connect settings, and check.\n  upstreamCodec_.getEgressSettings()->setSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL, 1);\n  ws_enable = upstreamCodec_.getEgressSettings()->getSetting(\n      SettingsId::ENABLE_CONNECT_PROTOCOL);\n  EXPECT_EQ(ws_enable->value, 1);\n  // generateSettings.\n  // pass the buffer to be parsed by the codec and check for ingress settings.\n  upstreamCodec_.generateSettings(output_);\n  parseUpstream();\n  EXPECT_EQ(1, upstreamCodec_.peerHasWebsockets());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketUpgrade) {\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  EXPECT_TRUE(callbacks_.msg->isIngressWebsocketUpgrade());\n  EXPECT_NE(nullptr, callbacks_.msg->getUpgradeProtocol());\n  EXPECT_EQ(headers::kWebsocketString, *callbacks_.msg->getUpgradeProtocol());\n}\n\nTEST_F(HTTP2CodecTest, WebsocketBadHeader) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> reqHeaders = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n  };\n  vector<proxygen::compress::Header> optionalHeaders = {\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  int stream = 1;\n  for (size_t i = 0; i < optionalHeaders.size(); ++i, stream += 2) {\n    auto headers = reqHeaders;\n    headers.push_back(optionalHeaders[i]);\n    auto encodedHeaders = headerCodec.encode(headers);\n    http2::writeHeaders(output_,\n                        std::move(encodedHeaders),\n                        stream,\n                        folly::none,\n                        http2::kNoPadding,\n                        false,\n                        true);\n    parse();\n  }\n\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, optionalHeaders.size());\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketDupProtocol) {\n  const std::string kConnect{\"CONNECT\"};\n  const std::string kWebsocketPath{\"/websocket\"};\n  const std::string kSchemeHttps{\"https\"};\n  vector<proxygen::compress::Header> headers = {\n    Header::makeHeaderForTest(headers::kMethod, kConnect),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kProtocol, headers::kWebsocketString),\n    Header::makeHeaderForTest(headers::kPath, kWebsocketPath),\n    Header::makeHeaderForTest(headers::kScheme, kSchemeHttps),\n  };\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  auto encodedHeaders = headerCodec.encode(headers);\n  http2::writeHeaders(output_,\n                      std::move(encodedHeaders),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      false,\n                      true);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 0);\n  EXPECT_EQ(callbacks_.headersComplete, 0);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, WebsocketIncorrectResponse) {\n  parse();\n  SetUpUpstreamTest();\n  parseUpstream();\n\n  output_.clear();\n  HTTPMessage req = getGetRequest(\"/apples\");\n  req.setSecure(true);\n  req.setEgressWebsocketUpgrade();\n  upstreamCodec_.generateHeader(output_, 1, req, false);\n  parse();\n\n  output_.clear();\n  HTTPMessage resp;\n  resp.setStatusCode(201);\n  resp.setStatusMessage(\"OK\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n  parseUpstream();\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TestAllEgressFrameTypeCallbacks) {\n  class CallbackTypeTracker {\n    std::set<uint8_t> types;\n  public:\n    void add(uint8_t, uint8_t type, uint64_t, uint16_t) {\n      types.insert(type);\n    }\n\n    bool isAllFrameTypesReceived() {\n      http2::FrameType expectedTypes[] = {\n        http2::FrameType::DATA,\n        http2::FrameType::HEADERS,\n        http2::FrameType::PRIORITY,\n        http2::FrameType::RST_STREAM,\n        http2::FrameType::SETTINGS,\n        http2::FrameType::PUSH_PROMISE,\n        http2::FrameType::PING,\n        http2::FrameType::GOAWAY,\n        http2::FrameType::WINDOW_UPDATE,\n        http2::FrameType::CONTINUATION,\n        http2::FrameType::EX_HEADERS,\n      };\n\n      for(http2::FrameType type: expectedTypes) {\n        EXPECT_TRUE(types.find(static_cast<uint8_t>(type)) != types.end())\n          << \"callback missing for type \" << static_cast<uint8_t>(type);\n      }\n      return types.size() == (sizeof(expectedTypes)/sizeof(http2::FrameType));\n    }\n  };\n\n  CallbackTypeTracker callbackTypeTracker;\n\n  NiceMock<MockHTTPCodecCallback> mockCallback;\n  upstreamCodec_.setCallback(&mockCallback);\n  downstreamCodec_.setCallback(&mockCallback);\n  EXPECT_CALL(mockCallback, onGenerateFrameHeader(_, _, _, _)).\n    WillRepeatedly(Invoke(&callbackTypeTracker, &CallbackTypeTracker::add));\n\n  // DATA frame\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(output_, 2, std::move(buf),\n                              HTTPCodec::NoPadding, true);\n\n  HTTPHeaderSize size;\n  size.uncompressed = size.compressed = 0;\n  HTTPMessage req = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true, &size);\n\n  upstreamCodec_.generatePriority(output_, 3,\n                                  HTTPMessage::HTTPPriority(0, true, 1));\n  upstreamCodec_.generateRstStream(output_, 2, ErrorCode::ENHANCE_YOUR_CALM);\n  upstreamCodec_.generateSettings(output_);\n  downstreamCodec_.generatePushPromise(output_, 2, req, 1);\n  upstreamCodec_.generatePingRequest(output_);\n\n  std::unique_ptr<folly::IOBuf> debugData =\n      folly::IOBuf::copyBuffer(\"debugData\");\n  upstreamCodec_.generateGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM,\n                                std::move(debugData));\n\n  upstreamCodec_.generateWindowUpdate(output_, 0, 10);\n\n  HTTPCodec::StreamID stream = folly::Random::rand32(10, 1024) * 2;\n  HTTPCodec::StreamID controlStream = folly::Random::rand32(10, 1024) * 2 + 1;\n  downstreamCodec_.generateExHeader(output_, stream, req,\n    HTTPCodec::ExAttributes(controlStream, true));\n\n  // Tests the continuation frame\n  req = getBigGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, req, true /* eom */);\n\n  EXPECT_TRUE(callbackTypeTracker.isAllFrameTypesReceived());\n}\n\nTEST_F(HTTP2CodecTest, Trailers) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersWithPseudoHeaders) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  upstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false /* eom */);\n\n  HPACKCodec headerCodec(TransportDirection::UPSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n}\n\nTEST_F(HTTP2CodecTest, TrailersNoBody) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 2);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersContinuation) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parse();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(callbacks_.msg->getTrailers(), nullptr);\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(downstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReply) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-trailer-2\", \"chicken-kyiv\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 1);\n  EXPECT_EQ(callbacks_.bodyLength, 5);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(\"chicken-kyiv\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-2\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithNoData) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  callbacks_.expectMessage(true, 2, 200);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.bodyLength, 0);\n  const auto& headers = callbacks_.msg->getHeaders();\n  EXPECT_TRUE(callbacks_.msg->getHeaders().exists(HTTP_HEADER_DATE));\n  EXPECT_EQ(\"x-coolio\", headers.getSingleOrEmpty(HTTP_HEADER_CONTENT_TYPE));\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 3);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyWithPseudoHeaders) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  resp.setStatusMessage(\"nifty-nice\");\n  resp.getHeaders().add(HTTP_HEADER_CONTENT_TYPE, \"x-coolio\");\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  string data(\"abcde\");\n  auto buf = folly::IOBuf::copyBuffer(data.data(), data.length());\n  downstreamCodec_.generateBody(\n      output_, 1, std::move(buf), HTTPCodec::NoPadding, false);\n\n  HPACKCodec headerCodec(TransportDirection::DOWNSTREAM);\n  std::string post(\"POST\");\n  std::vector<proxygen::compress::Header> trailers = {\n      Header::makeHeaderForTest(headers::kMethod, post)};\n  auto encodedTrailers = headerCodec.encode(trailers);\n  http2::writeHeaders(output_,\n                      std::move(encodedTrailers),\n                      1,\n                      folly::none,\n                      http2::kNoPadding,\n                      true,\n                      true);\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.trailers, 0);\n  EXPECT_EQ(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  EXPECT_NE(callbacks_.msg, nullptr);\n  EXPECT_EQ(callbacks_.msg->getStatusCode(), 200);\n  EXPECT_EQ(1, callbacks_.trailers);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(std::string(http2::kMaxFramePayloadLengthMin, '!'),\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-huge-trailer\"));\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n\nTEST_F(HTTP2CodecTest, TrailersReplyMissingContinuation) {\n  SetUpUpstreamTest();\n  HTTPMessage resp;\n  resp.setStatusCode(200);\n  downstreamCodec_.generateHeader(output_, 1, resp);\n\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  trailers.add(\"x-huge-trailer\",\n               std::string(http2::kMaxFramePayloadLengthMin, '!'));\n  downstreamCodec_.generateTrailers(output_, 1, trailers);\n  // empirically determined the size of continuation frame, and strip it\n  output_.trimEnd(http2::kFrameHeaderSize + 4132);\n\n  // insert a non-continuation (but otherwise valid) frame\n  http2::writeGoaway(output_, 17, ErrorCode::ENHANCE_YOUR_CALM);\n\n  parseUpstream();\n\n  EXPECT_EQ(callbacks_.messageBegin, 1);\n  EXPECT_EQ(callbacks_.headersComplete, 1);\n  EXPECT_EQ(callbacks_.messageComplete, 0);\n  EXPECT_EQ(callbacks_.streamErrors, 0);\n  EXPECT_EQ(callbacks_.sessionErrors, 1);\n#ifndef NDEBUG\n  EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n#endif\n}\n"], "filenames": ["proxygen/lib/http/codec/HTTP2Codec.cpp", "proxygen/lib/http/codec/test/HTTP2CodecTest.cpp"], "buggy_code_start_loc": [516, 1379], "buggy_code_end_loc": [531, 1379], "fixing_code_start_loc": [517, 1380], "fixing_code_end_loc": [534, 1404], "type": "CWE-388", "message": "A potential denial-of-service issue in the Proxygen handling of invalid HTTP2 priority settings (specifically a circular dependency). This affects Proxygen prior to v2018.12.31.00.", "other": {"cve": {"id": "CVE-2018-6346", "sourceIdentifier": "cve-assign@fb.com", "published": "2018-12-31T22:29:00.637", "lastModified": "2019-10-09T23:41:47.767", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A potential denial-of-service issue in the Proxygen handling of invalid HTTP2 priority settings (specifically a circular dependency). This affects Proxygen prior to v2018.12.31.00."}, {"lang": "es", "value": "Un problema potencial de denegaci\u00f3n de servicio (DoS) en la manera en la que Proxygen maneja ajustes HTTP2 prioritarios inv\u00e1lidos (concretamente, una dependencia circular). Esto afecta a las versiones de Proxygen anteriores a la v2018.12.31.00."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-388"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:proxygen_project:proxygen:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018.12.31.00", "matchCriteriaId": "10DFD5FA-DC03-4C1A-A8F7-70BA5998141D"}]}]}], "references": [{"url": "https://github.com/facebook/proxygen/commit/52cf331743ebd74194d6343a6c2ec52bb917c982", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/proxygen/commit/52cf331743ebd74194d6343a6c2ec52bb917c982"}}