{"buggy_code": ["<?php\n\n/**\n +-----------------------------------------------------------------------+\n | This file is part of the Roundcube Webmail client                     |\n | Copyright (C) 2008-2012, The Roundcube Dev Team                       |\n | Copyright (C) 2011-2012, Kolab Systems AG                             |\n |                                                                       |\n | Licensed under the GNU General Public License version 3 or            |\n | any later version with exceptions for skins & plugins.                |\n | See the README file for a full license statement.                     |\n |                                                                       |\n | PURPOSE:                                                              |\n |   Utility class providing common functions                            |\n +-----------------------------------------------------------------------+\n | Author: Thomas Bruederli <roundcube@gmail.com>                        |\n | Author: Aleksander Machniak <alec@alec.pl>                            |\n +-----------------------------------------------------------------------+\n*/\n\n/**\n * Utility class providing common functions\n *\n * @package    Framework\n * @subpackage Utils\n */\nclass rcube_utils\n{\n    // define constants for input reading\n    const INPUT_GET  = 0x0101;\n    const INPUT_POST = 0x0102;\n    const INPUT_GPC  = 0x0103;\n\n    /**\n     * Helper method to set a cookie with the current path and host settings\n     *\n     * @param string Cookie name\n     * @param string Cookie value\n     * @param string Expiration time\n     */\n    public static function setcookie($name, $value, $exp = 0)\n    {\n        if (headers_sent()) {\n            return;\n        }\n\n        $cookie = session_get_cookie_params();\n        $secure = $cookie['secure'] || self::https_check();\n\n        setcookie($name, $value, $exp, $cookie['path'], $cookie['domain'], $secure, true);\n    }\n\n    /**\n     * E-mail address validation.\n     *\n     * @param string $email Email address\n     * @param boolean $dns_check True to check dns\n     *\n     * @return boolean True on success, False if address is invalid\n     */\n    public static function check_email($email, $dns_check=true)\n    {\n        // Check for invalid characters\n        if (preg_match('/[\\x00-\\x1F\\x7F-\\xFF]/', $email)) {\n            return false;\n        }\n\n        // Check for length limit specified by RFC 5321 (#1486453)\n        if (strlen($email) > 254) {\n            return false;\n        }\n\n        $email_array = explode('@', $email);\n\n        // Check that there's one @ symbol\n        if (count($email_array) < 2) {\n            return false;\n        }\n\n        $domain_part = array_pop($email_array);\n        $local_part  = implode('@', $email_array);\n\n        // from PEAR::Validate\n        $regexp = '&^(?:\n            (\"\\s*(?:[^\"\\f\\n\\r\\t\\v\\b\\s]+\\s*)+\")|                             #1 quoted name\n            ([-\\w!\\#\\$%\\&\\'*+~/^`|{}=]+(?:\\.[-\\w!\\#\\$%\\&\\'*+~/^`|{}=]+)*))  #2 OR dot-atom (RFC5322)\n            $&xi';\n\n        if (!preg_match($regexp, $local_part)) {\n            return false;\n        }\n\n        // Validate domain part\n        if (preg_match('/^\\[((IPv6:[0-9a-f:.]+)|([0-9.]+))\\]$/i', $domain_part, $matches)) {\n            return self::check_ip(preg_replace('/^IPv6:/i', '', $matches[1])); // valid IPv4 or IPv6 address\n        }\n        else {\n            // If not an IP address\n            $domain_array = explode('.', $domain_part);\n            // Not enough parts to be a valid domain\n            if (sizeof($domain_array) < 2) {\n                return false;\n            }\n\n            foreach ($domain_array as $part) {\n                if (!preg_match('/^((xn--)?([A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9])|([A-Za-z0-9]))$/', $part)) {\n                    return false;\n                }\n            }\n\n            // last domain part\n            $last_part = array_pop($domain_array);\n            if (strpos($last_part, 'xn--') !== 0 && preg_match('/[^a-zA-Z]/', $last_part)) {\n                return false;\n            }\n\n            $rcube = rcube::get_instance();\n\n            if (!$dns_check || !$rcube->config->get('email_dns_check')) {\n                return true;\n            }\n\n            // find MX record(s)\n            if (!function_exists('getmxrr') || getmxrr($domain_part, $mx_records)) {\n                return true;\n            }\n\n            // find any DNS record\n            if (!function_exists('checkdnsrr') || checkdnsrr($domain_part, 'ANY')) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Validates IPv4 or IPv6 address\n     *\n     * @param string $ip IP address in v4 or v6 format\n     *\n     * @return bool True if the address is valid\n     */\n    public static function check_ip($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP) !== false;\n    }\n\n    /**\n     * Check whether the HTTP referer matches the current request\n     *\n     * @return boolean True if referer is the same host+path, false if not\n     */\n    public static function check_referer()\n    {\n        $uri     = parse_url($_SERVER['REQUEST_URI']);\n        $referer = parse_url(self::request_header('Referer'));\n\n        return $referer['host'] == self::request_header('Host') && $referer['path'] == $uri['path'];\n    }\n\n    /**\n     * Replacing specials characters to a specific encoding type\n     *\n     * @param string  Input string\n     * @param string  Encoding type: text|html|xml|js|url\n     * @param string  Replace mode for tags: show|remove|strict\n     * @param boolean Convert newlines\n     *\n     * @return string The quoted string\n     */\n    public static function rep_specialchars_output($str, $enctype = '', $mode = '', $newlines = true)\n    {\n        static $html_encode_arr = false;\n        static $js_rep_table    = false;\n        static $xml_rep_table   = false;\n\n        if (!is_string($str)) {\n            $str = strval($str);\n        }\n\n        // encode for HTML output\n        if ($enctype == 'html') {\n            if (!$html_encode_arr) {\n                $html_encode_arr = get_html_translation_table(HTML_SPECIALCHARS);\n                unset($html_encode_arr['?']);\n            }\n\n            $encode_arr = $html_encode_arr;\n\n            if ($mode == 'remove') {\n                $str = strip_tags($str);\n            }\n            else if ($mode != 'strict') {\n                // don't replace quotes and html tags\n                $ltpos = strpos($str, '<');\n                if ($ltpos !== false && strpos($str, '>', $ltpos) !== false) {\n                    unset($encode_arr['\"']);\n                    unset($encode_arr['<']);\n                    unset($encode_arr['>']);\n                    unset($encode_arr['&']);\n                }\n            }\n\n            $out = strtr($str, $encode_arr);\n\n            return $newlines ? nl2br($out) : $out;\n        }\n\n        // if the replace tables for XML and JS are not yet defined\n        if ($js_rep_table === false) {\n            $js_rep_table = $xml_rep_table = array();\n            $xml_rep_table['&'] = '&amp;';\n\n            // can be increased to support more charsets\n            for ($c=160; $c<256; $c++) {\n                $xml_rep_table[chr($c)] = \"&#$c;\";\n            }\n\n            $xml_rep_table['\"'] = '&quot;';\n            $js_rep_table['\"']  = '\\\\\"';\n            $js_rep_table[\"'\"]  = \"\\\\'\";\n            $js_rep_table[\"\\\\\"] = \"\\\\\\\\\";\n            // Unicode line and paragraph separators (#1486310)\n            $js_rep_table[chr(hexdec('E2')).chr(hexdec('80')).chr(hexdec('A8'))] = '&#8232;';\n            $js_rep_table[chr(hexdec('E2')).chr(hexdec('80')).chr(hexdec('A9'))] = '&#8233;';\n        }\n\n        // encode for javascript use\n        if ($enctype == 'js') {\n            return preg_replace(array(\"/\\r?\\n/\", \"/\\r/\", '/<\\\\//'), array('\\n', '\\n', '<\\\\/'), strtr($str, $js_rep_table));\n        }\n\n        // encode for plaintext\n        if ($enctype == 'text') {\n            return str_replace(\"\\r\\n\", \"\\n\", $mode == 'remove' ? strip_tags($str) : $str);\n        }\n\n        if ($enctype == 'url') {\n            return rawurlencode($str);\n        }\n\n        // encode for XML\n        if ($enctype == 'xml') {\n            return strtr($str, $xml_rep_table);\n        }\n\n        // no encoding given -> return original string\n        return $str;\n    }\n\n    /**\n     * Read input value and convert it for internal use\n     * Performs stripslashes() and charset conversion if necessary\n     *\n     * @param string  Field name to read\n     * @param int     Source to get value from (GPC)\n     * @param boolean Allow HTML tags in field value\n     * @param string  Charset to convert into\n     *\n     * @return string Field value or NULL if not available\n     */\n    public static function get_input_value($fname, $source, $allow_html = false, $charset = null)\n    {\n        $value = null;\n\n        if ($source == self::INPUT_GET) {\n            if (isset($_GET[$fname])) {\n                $value = $_GET[$fname];\n            }\n        }\n        else if ($source == self::INPUT_POST) {\n            if (isset($_POST[$fname])) {\n                $value = $_POST[$fname];\n            }\n        }\n        else if ($source == self::INPUT_GPC) {\n            if (isset($_POST[$fname])) {\n                $value = $_POST[$fname];\n            }\n            else if (isset($_GET[$fname])) {\n                $value = $_GET[$fname];\n            }\n            else if (isset($_COOKIE[$fname])) {\n                $value = $_COOKIE[$fname];\n            }\n        }\n\n        return self::parse_input_value($value, $allow_html, $charset);\n    }\n\n    /**\n     * Parse/validate input value. See self::get_input_value()\n     * Performs stripslashes() and charset conversion if necessary\n     *\n     * @param string  Input value\n     * @param boolean Allow HTML tags in field value\n     * @param string  Charset to convert into\n     *\n     * @return string Parsed value\n     */\n    public static function parse_input_value($value, $allow_html = false, $charset = null)\n    {\n        global $OUTPUT;\n\n        if (empty($value)) {\n            return $value;\n        }\n\n        if (is_array($value)) {\n            foreach ($value as $idx => $val) {\n                $value[$idx] = self::parse_input_value($val, $allow_html, $charset);\n            }\n            return $value;\n        }\n\n        // strip slashes if magic_quotes enabled\n        if (get_magic_quotes_gpc() || get_magic_quotes_runtime()) {\n            $value = stripslashes($value);\n        }\n\n        // remove HTML tags if not allowed\n        if (!$allow_html) {\n            $value = strip_tags($value);\n        }\n\n        $output_charset = is_object($OUTPUT) ? $OUTPUT->get_charset() : null;\n\n        // remove invalid characters (#1488124)\n        if ($output_charset == 'UTF-8') {\n            $value = rcube_charset::clean($value);\n        }\n\n        // convert to internal charset\n        if ($charset && $output_charset) {\n            $value = rcube_charset::convert($value, $output_charset, $charset);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Convert array of request parameters (prefixed with _)\n     * to a regular array with non-prefixed keys.\n     *\n     * @param int     $mode       Source to get value from (GPC)\n     * @param string  $ignore     PCRE expression to skip parameters by name\n     * @param boolean $allow_html Allow HTML tags in field value\n     *\n     * @return array Hash array with all request parameters\n     */\n    public static function request2param($mode = null, $ignore = 'task|action', $allow_html = false)\n    {\n        $out = array();\n        $src = $mode == self::INPUT_GET ? $_GET : ($mode == self::INPUT_POST ? $_POST : $_REQUEST);\n\n        foreach (array_keys($src) as $key) {\n            $fname = $key[0] == '_' ? substr($key, 1) : $key;\n            if ($ignore && !preg_match('/^(' . $ignore . ')$/', $fname)) {\n                $out[$fname] = self::get_input_value($key, $mode, $allow_html);\n            }\n        }\n\n        return $out;\n    }\n\n    /**\n     * Convert the given string into a valid HTML identifier\n     * Same functionality as done in app.js with rcube_webmail.html_identifier()\n     */\n    public static function html_identifier($str, $encode=false)\n    {\n        if ($encode) {\n            return rtrim(strtr(base64_encode($str), '+/', '-_'), '=');\n        }\n        else {\n            return asciiwords($str, true, '_');\n        }\n    }\n\n    /**\n     * Replace all css definitions with #container [def]\n     * and remove css-inlined scripting, make position style safe\n     *\n     * @param string CSS source code\n     * @param string Container ID to use as prefix\n     * @param bool   Allow remote content\n     *\n     * @return string Modified CSS source\n     */\n    public static function mod_css_styles($source, $container_id, $allow_remote = false)\n    {\n        $last_pos     = 0;\n        $replacements = new rcube_string_replacer;\n\n        // ignore the whole block if evil styles are detected\n        $source   = self::xss_entity_decode($source);\n        $stripped = preg_replace('/[^a-z\\(:;]/i', '', $source);\n        $evilexpr = 'expression|behavior|javascript:|import[^a]' . (!$allow_remote ? '|url\\((?!data:image)' : '');\n\n        if (preg_match(\"/$evilexpr/i\", $stripped)) {\n            return '/* evil! */';\n        }\n\n        $strict_url_regexp = '!url\\s*\\([ \"\\'](https?:)//[a-z0-9/._+-]+[\"\\' ]\\)!Uims';\n\n        // cut out all contents between { and }\n        while (($pos = strpos($source, '{', $last_pos)) && ($pos2 = strpos($source, '}', $pos))) {\n            $nested = strpos($source, '{', $pos+1);\n            if ($nested && $nested < $pos2)  // when dealing with nested blocks (e.g. @media), take the inner one\n                $pos = $nested;\n            $length = $pos2 - $pos - 1;\n            $styles = substr($source, $pos+1, $length);\n\n            // Convert position:fixed to position:absolute (#5264)\n            $styles = preg_replace('/position:[\\s\\r\\n]*fixed/i', 'position: absolute', $styles);\n\n            // check every line of a style block...\n            if ($allow_remote) {\n                $a_styles = preg_split('/;[\\r\\n]*/', $styles, -1, PREG_SPLIT_NO_EMPTY);\n\n                foreach ($a_styles as $line) {\n                    $stripped = preg_replace('/[^a-z\\(:;]/i', '', $line);\n                    // ... and only allow strict url() values\n                    if (stripos($stripped, 'url(') && !preg_match($strict_url_regexp, $line)) {\n                        $a_styles = array('/* evil! */');\n                        break;\n                    }\n                }\n\n                $styles = join(\";\\n\", $a_styles);\n            }\n\n            $key      = $replacements->add($styles);\n            $repl     = $replacements->get_replacement($key);\n            $source   = substr_replace($source, $repl, $pos+1, $length);\n            $last_pos = $pos2 - ($length - strlen($repl));\n        }\n\n        // remove html comments and add #container to each tag selector.\n        // also replace body definition because we also stripped off the <body> tag\n        $source = preg_replace(\n            array(\n                '/(^\\s*<\\!--)|(-->\\s*$)/m',\n                '/(^\\s*|,\\s*|\\}\\s*)([a-z0-9\\._#\\*][a-z0-9\\.\\-_]*)/im',\n                '/'.preg_quote($container_id, '/').'\\s+body/i',\n            ),\n            array(\n                '',\n                \"\\\\1#$container_id \\\\2\",\n                $container_id,\n            ),\n            $source);\n\n        // put block contents back in\n        $source = $replacements->resolve($source);\n\n        return $source;\n    }\n\n    /**\n     * Generate CSS classes from mimetype and filename extension\n     *\n     * @param string $mimetype Mimetype\n     * @param string $filename Filename\n     *\n     * @return string CSS classes separated by space\n     */\n    public static function file2class($mimetype, $filename)\n    {\n        $mimetype = strtolower($mimetype);\n        $filename = strtolower($filename);\n\n        list($primary, $secondary) = explode('/', $mimetype);\n\n        $classes = array($primary ?: 'unknown');\n\n        if ($secondary) {\n            $classes[] = $secondary;\n        }\n\n        if (preg_match('/\\.([a-z0-9]+)$/', $filename, $m)) {\n            if (!in_array($m[1], $classes)) {\n                $classes[] = $m[1];\n            }\n        }\n\n        return join(\" \", $classes);\n    }\n\n    /**\n     * Decode escaped entities used by known XSS exploits.\n     * See http://downloads.securityfocus.com/vulnerabilities/exploits/26800.eml for examples\n     *\n     * @param string CSS content to decode\n     *\n     * @return string Decoded string\n     */\n    public static function xss_entity_decode($content)\n    {\n        $out = html_entity_decode(html_entity_decode($content));\n        $out = strip_tags($out);\n        $out = preg_replace_callback('/\\\\\\([0-9a-f]{4})/i',\n            array(self, 'xss_entity_decode_callback'), $out);\n        $out = preg_replace('#/\\*.*\\*/#Ums', '', $out);\n\n        return $out;\n    }\n\n    /**\n     * preg_replace_callback callback for xss_entity_decode\n     *\n     * @param array $matches Result from preg_replace_callback\n     *\n     * @return string Decoded entity\n     */\n    public static function xss_entity_decode_callback($matches)\n    {\n        return chr(hexdec($matches[1]));\n    }\n\n    /**\n     * Check if we can process not exceeding memory_limit\n     *\n     * @param integer Required amount of memory\n     *\n     * @return boolean True if memory won't be exceeded, False otherwise\n     */\n    public static function mem_check($need)\n    {\n        $mem_limit = parse_bytes(ini_get('memory_limit'));\n        $memory    = function_exists('memory_get_usage') ? memory_get_usage() : 16*1024*1024; // safe value: 16MB\n\n        return $mem_limit > 0 && $memory + $need > $mem_limit ? false : true;\n    }\n\n    /**\n     * Check if working in SSL mode\n     *\n     * @param integer $port      HTTPS port number\n     * @param boolean $use_https Enables 'use_https' option checking\n     *\n     * @return boolean\n     */\n    public static function https_check($port=null, $use_https=true)\n    {\n        if (!empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) != 'off') {\n            return true;\n        }\n        if (!empty($_SERVER['HTTP_X_FORWARDED_PROTO'])\n            && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) == 'https'\n            && in_array($_SERVER['REMOTE_ADDR'], rcube::get_instance()->config->get('proxy_whitelist', array()))\n        ) {\n            return true;\n        }\n        if ($port && $_SERVER['SERVER_PORT'] == $port) {\n            return true;\n        }\n        if ($use_https && rcube::get_instance()->config->get('use_https')) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Replaces hostname variables.\n     *\n     * @param string $name Hostname\n     * @param string $host Optional IMAP hostname\n     *\n     * @return string Hostname\n     */\n    public static function parse_host($name, $host = '')\n    {\n        if (!is_string($name)) {\n            return $name;\n        }\n\n        // %n - host\n        $n = preg_replace('/:\\d+$/', '', $_SERVER['SERVER_NAME']);\n        // %t - host name without first part, e.g. %n=mail.domain.tld, %t=domain.tld\n        $t = preg_replace('/^[^\\.]+\\./', '', $n);\n        // %d - domain name without first part\n        $d = preg_replace('/^[^\\.]+\\./', '', $_SERVER['HTTP_HOST']);\n        // %h - IMAP host\n        $h = $_SESSION['storage_host'] ?: $host;\n        // %z - IMAP domain without first part, e.g. %h=imap.domain.tld, %z=domain.tld\n        $z = preg_replace('/^[^\\.]+\\./', '', $h);\n        // %s - domain name after the '@' from e-mail address provided at login screen.\n        //      Returns FALSE if an invalid email is provided\n        if (strpos($name, '%s') !== false) {\n            $user_email = self::get_input_value('_user', self::INPUT_POST);\n            $user_email = self::idn_convert($user_email, true);\n            $matches    = preg_match('/(.*)@([a-z0-9\\.\\-\\[\\]\\:]+)/i', $user_email, $s);\n            if ($matches < 1 || filter_var($s[1].\"@\".$s[2], FILTER_VALIDATE_EMAIL) === false) {\n                return false;\n            }\n        }\n\n        return str_replace(array('%n', '%t', '%d', '%h', '%z', '%s'), array($n, $t, $d, $h, $z, $s[2]), $name);\n    }\n\n    /**\n     * Returns remote IP address and forwarded addresses if found\n     *\n     * @return string Remote IP address(es)\n     */\n    public static function remote_ip()\n    {\n        $address = $_SERVER['REMOTE_ADDR'];\n\n        // append the NGINX X-Real-IP header, if set\n        if (!empty($_SERVER['HTTP_X_REAL_IP'])) {\n            $remote_ip[] = 'X-Real-IP: ' . $_SERVER['HTTP_X_REAL_IP'];\n        }\n\n        // append the X-Forwarded-For header, if set\n        if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n            $remote_ip[] = 'X-Forwarded-For: ' . $_SERVER['HTTP_X_FORWARDED_FOR'];\n        }\n\n        if (!empty($remote_ip)) {\n            $address .= '(' . implode(',', $remote_ip) . ')';\n        }\n\n        return $address;\n    }\n\n    /**\n     * Returns the real remote IP address\n     *\n     * @return string Remote IP address\n     */\n    public static function remote_addr()\n    {\n        // Check if any of the headers are set first to improve performance\n        if (!empty($_SERVER['HTTP_X_FORWARDED_FOR']) || !empty($_SERVER['HTTP_X_REAL_IP'])) {\n            $proxy_whitelist = rcube::get_instance()->config->get('proxy_whitelist', array());\n            if (in_array($_SERVER['REMOTE_ADDR'], $proxy_whitelist)) {\n                if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n                    foreach(array_reverse(explode(',', $_SERVER['HTTP_X_FORWARDED_FOR'])) as $forwarded_ip) {\n                        if (!in_array($forwarded_ip, $proxy_whitelist)) {\n                            return $forwarded_ip;\n                        }\n                    }\n                }\n\n                if (!empty($_SERVER['HTTP_X_REAL_IP'])) {\n                    return $_SERVER['HTTP_X_REAL_IP'];\n                }\n            }\n        }\n\n        if (!empty($_SERVER['REMOTE_ADDR'])) {\n            return $_SERVER['REMOTE_ADDR'];\n        }\n\n        return '';\n    }\n\n    /**\n     * Read a specific HTTP request header.\n     *\n     * @param string $name Header name\n     *\n     * @return mixed Header value or null if not available\n     */\n    public static function request_header($name)\n    {\n        if (function_exists('getallheaders')) {\n            $hdrs = array_change_key_case(getallheaders(), CASE_UPPER);\n            $key  = strtoupper($name);\n        }\n        else {\n            $key  = 'HTTP_' . strtoupper(strtr($name, '-', '_'));\n            $hdrs = array_change_key_case($_SERVER, CASE_UPPER);\n        }\n\n        return $hdrs[$key];\n    }\n\n    /**\n     * Explode quoted string\n     *\n     * @param string Delimiter expression string for preg_match()\n     * @param string Input string\n     *\n     * @return array String items\n     */\n    public static function explode_quoted_string($delimiter, $string)\n    {\n        $result = array();\n        $strlen = strlen($string);\n\n        for ($q=$p=$i=0; $i < $strlen; $i++) {\n            if ($string[$i] == \"\\\"\" && $string[$i-1] != \"\\\\\") {\n                $q = $q ? false : true;\n            }\n            else if (!$q && preg_match(\"/$delimiter/\", $string[$i])) {\n                $result[] = substr($string, $p, $i - $p);\n                $p = $i + 1;\n            }\n        }\n\n        $result[] = (string) substr($string, $p);\n\n        return $result;\n    }\n\n    /**\n     * Improved equivalent to strtotime()\n     *\n     * @param string       $date     Date string\n     * @param DateTimeZone $timezone Timezone to use for DateTime object\n     *\n     * @return int Unix timestamp\n     */\n    public static function strtotime($date, $timezone = null)\n    {\n        $date   = self::clean_datestr($date);\n        $tzname = $timezone ? ' ' . $timezone->getName() : '';\n\n        // unix timestamp\n        if (is_numeric($date)) {\n            return (int) $date;\n        }\n\n        // if date parsing fails, we have a date in non-rfc format.\n        // remove token from the end and try again\n        while ((($ts = @strtotime($date . $tzname)) === false) || ($ts < 0)) {\n            $d = explode(' ', $date);\n            array_pop($d);\n            if (!$d) {\n                break;\n            }\n            $date = implode(' ', $d);\n        }\n\n        return (int) $ts;\n    }\n\n    /**\n     * Date parsing function that turns the given value into a DateTime object\n     *\n     * @param string       $date     Date string\n     * @param DateTimeZone $timezone Timezone to use for DateTime object\n     *\n     * @return DateTime instance or false on failure\n     */\n    public static function anytodatetime($date, $timezone = null)\n    {\n        if ($date instanceof DateTime) {\n            return $date;\n        }\n\n        $dt   = false;\n        $date = self::clean_datestr($date);\n\n        // try to parse string with DateTime first\n        if (!empty($date)) {\n            try {\n                $dt = $timezone ? new DateTime($date, $timezone) : new DateTime($date);\n            }\n            catch (Exception $e) {\n                // ignore\n            }\n        }\n\n        // try our advanced strtotime() method\n        if (!$dt && ($timestamp = self::strtotime($date, $timezone))) {\n            try {\n                $dt = new DateTime(\"@\".$timestamp);\n                if ($timezone) {\n                    $dt->setTimezone($timezone);\n                }\n            }\n            catch (Exception $e) {\n                // ignore\n            }\n        }\n\n        return $dt;\n    }\n\n    /**\n     * Clean up date string for strtotime() input\n     *\n     * @param string $date Date string\n     *\n     * @return string Date string\n     */\n    public static function clean_datestr($date)\n    {\n        $date = trim($date);\n\n        // check for MS Outlook vCard date format YYYYMMDD\n        if (preg_match('/^([12][90]\\d\\d)([01]\\d)([0123]\\d)$/', $date, $m)) {\n            return sprintf('%04d-%02d-%02d 00:00:00', intval($m[1]), intval($m[2]), intval($m[3]));\n        }\n\n        // Clean malformed data\n        $date = preg_replace(\n            array(\n                '/GMT\\s*([+-][0-9]+)/',                     // support non-standard \"GMTXXXX\" literal\n                '/[^a-z0-9\\x20\\x09:+-\\/]/i',                // remove any invalid characters\n                '/\\s*(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\\s*/i',   // remove weekday names\n            ),\n            array(\n                '\\\\1',\n                '',\n                '',\n            ), $date);\n\n        $date = trim($date);\n\n        // try to fix dd/mm vs. mm/dd discrepancy, we can't do more here\n        if (preg_match('/^(\\d{1,2})[.\\/-](\\d{1,2})[.\\/-](\\d{4})(\\s.*)?$/', $date, $m)) {\n            $mdy   = $m[2] > 12 && $m[1] <= 12;\n            $day   = $mdy ? $m[2] : $m[1];\n            $month = $mdy ? $m[1] : $m[2];\n            $date  = sprintf('%04d-%02d-%02d%s', $m[3], $month, $day, $m[4] ?: ' 00:00:00');\n        }\n        // I've found that YYYY.MM.DD is recognized wrong, so here's a fix\n        else if (preg_match('/^(\\d{4})\\.(\\d{1,2})\\.(\\d{1,2})(\\s.*)?$/', $date, $m)) {\n            $date  = sprintf('%04d-%02d-%02d%s', $m[1], $m[2], $m[3], $m[4] ?: ' 00:00:00');\n        }\n\n        return $date;\n    }\n\n    /**\n     * Turns the given date-only string in defined format into YYYY-MM-DD format.\n     *\n     * Supported formats: 'Y/m/d', 'Y.m.d', 'd-m-Y', 'd/m/Y', 'd.m.Y', 'j.n.Y'\n     *\n     * @param string $date   Date string\n     * @param string $format Input date format\n     *\n     * @return strin Date string in YYYY-MM-DD format, or the original string\n     *               if format is not supported\n     */\n    public static function format_datestr($date, $format)\n    {\n        $format_items = preg_split('/[.-\\/\\\\\\\\]/', $format);\n        $date_items   = preg_split('/[.-\\/\\\\\\\\]/', $date);\n        $iso_format   = '%04d-%02d-%02d';\n\n        if (count($format_items) == 3 && count($date_items) == 3) {\n            if ($format_items[0] == 'Y') {\n                $date = sprintf($iso_format, $date_items[0], $date_items[1], $date_items[2]);\n            }\n            else if (strpos('dj', $format_items[0]) !== false) {\n                $date = sprintf($iso_format, $date_items[2], $date_items[1], $date_items[0]);\n            }\n            else if (strpos('mn', $format_items[0]) !== false) {\n                $date = sprintf($iso_format, $date_items[2], $date_items[0], $date_items[1]);\n            }\n        }\n\n        return $date;\n    }\n\n    /*\n     * Idn_to_ascii wrapper.\n     * Intl/Idn modules version of this function doesn't work with e-mail address\n     */\n    public static function idn_to_ascii($str)\n    {\n        return self::idn_convert($str, true);\n    }\n\n    /*\n     * Idn_to_ascii wrapper.\n     * Intl/Idn modules version of this function doesn't work with e-mail address\n     */\n    public static function idn_to_utf8($str)\n    {\n        return self::idn_convert($str, false);\n    }\n\n    public static function idn_convert($input, $is_utf = false)\n    {\n        if ($at = strpos($input, '@')) {\n            $user   = substr($input, 0, $at);\n            $domain = substr($input, $at+1);\n        }\n        else {\n            $domain = $input;\n        }\n\n        $domain = $is_utf ? idn_to_ascii($domain) : idn_to_utf8($domain);\n\n        if ($domain === false) {\n            return '';\n        }\n\n        return $at ? $user . '@' . $domain : $domain;\n    }\n\n    /**\n     * Split the given string into word tokens\n     *\n     * @param string Input to tokenize\n     * @param integer Minimum length of a single token\n     * @return array List of tokens\n     */\n    public static function tokenize_string($str, $minlen = 2)\n    {\n        $expr = array('/[\\s;,\"\\'\\/+-]+/ui', '/(\\d)[-.\\s]+(\\d)/u');\n        $repl = array(' ', '\\\\1\\\\2');\n\n        if ($minlen > 1) {\n            $minlen--;\n            $expr[] = \"/(^|\\s+)\\w{1,$minlen}(\\s+|$)/u\";\n            $repl[] = ' ';\n        }\n\n        return array_filter(explode(\" \", preg_replace($expr, $repl, $str)));\n    }\n\n    /**\n     * Normalize the given string for fulltext search.\n     * Currently only optimized for ISO-8859-1 and ISO-8859-2 characters; to be extended\n     *\n     * @param string  Input string (UTF-8)\n     * @param boolean True to return list of words as array\n     * @param integer Minimum length of tokens\n     *\n     * @return mixed Normalized string or a list of normalized tokens\n     */\n    public static function normalize_string($str, $as_array = false, $minlen = 2)\n    {\n        // replace 4-byte unicode characters with '?' character,\n        // these are not supported in default utf-8 charset on mysql,\n        // the chance we'd need them in searching is very low\n        $str = preg_replace('/('\n            . '\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}'\n            . '|[\\xF1-\\xF3][\\x80-\\xBF]{3}'\n            . '|\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}'\n            . ')/', '?', $str);\n\n        // split by words\n        $arr = self::tokenize_string($str, $minlen);\n\n        // detect character set\n        if (utf8_encode(utf8_decode($str)) == $str) {\n            // ISO-8859-1 (or ASCII)\n            preg_match_all('/./u', '\u00e4\u00e2\u00e0\u00e5\u00e1\u00e3\u00e6\u00e7\u00e9\u00ea\u00eb\u00e8\u00ef\u00ee\u00ec\u00ed\u00f1\u00f6\u00f4\u00f2\u00f8\u00f5\u00f3\u00fc\u00fb\u00f9\u00fa\u00fd\u00ff', $keys);\n            preg_match_all('/./',  'aaaaaaaceeeeiiiinoooooouuuuyy', $values);\n\n            $mapping = array_combine($keys[0], $values[0]);\n            $mapping = array_merge($mapping, array('\u00df' => 'ss', 'ae' => 'a', 'oe' => 'o', 'ue' => 'u'));\n        }\n        else if (rcube_charset::convert(rcube_charset::convert($str, 'UTF-8', 'ISO-8859-2'), 'ISO-8859-2', 'UTF-8') == $str) {\n            // ISO-8859-2\n            preg_match_all('/./u', '\u0105\u00e1\u00e2\u00e4\u0107\u00e7\u010d\u00e9\u0119\u00eb\u011b\u00ed\u00ee\u0142\u013e\u013a\u0144\u0148\u00f3\u00f4\u00f6\u0155\u0159\u015b\u0161\u015f\u0165\u0163\u016f\u00fa\u0171\u00fc\u017a\u017e\u017c\u00fd', $keys);\n            preg_match_all('/./',  'aaaaccceeeeiilllnnooorrsssttuuuuzzzy', $values);\n\n            $mapping = array_combine($keys[0], $values[0]);\n            $mapping = array_merge($mapping, array('\u00df' => 'ss', 'ae' => 'a', 'oe' => 'o', 'ue' => 'u'));\n        }\n\n        foreach ($arr as $i => $part) {\n            $part = mb_strtolower($part);\n\n            if (!empty($mapping)) {\n                $part = strtr($part, $mapping);\n            }\n\n            $arr[$i] = $part;\n        }\n\n        return $as_array ? $arr : join(\" \", $arr);\n    }\n\n    /**\n     * Compare two strings for matching words (order not relevant)\n     *\n     * @param string Haystack\n     * @param string Needle\n     *\n     * @return boolean True if match, False otherwise\n     */\n    public static function words_match($haystack, $needle)\n    {\n        $a_needle  = self::tokenize_string($needle, 1);\n        $_haystack = join(\" \", self::tokenize_string($haystack, 1));\n        $valid     = strlen($_haystack) > 0;\n        $hits      = 0;\n\n        foreach ($a_needle as $w) {\n            if ($valid) {\n                if (stripos($_haystack, $w) !== false) {\n                    $hits++;\n                }\n            }\n            else if (stripos($haystack, $w) !== false) {\n                $hits++;\n            }\n        }\n\n        return $hits >= count($a_needle);\n    }\n\n    /**\n     * Parse commandline arguments into a hash array\n     *\n     * @param array $aliases Argument alias names\n     *\n     * @return array Argument values hash\n     */\n    public static function get_opt($aliases = array())\n    {\n        $args = array();\n        $bool = array();\n\n        // find boolean (no value) options\n        foreach ($aliases as $key => $alias) {\n            if ($pos = strpos($alias, ':')) {\n                $aliases[$key] = substr($alias, 0, $pos);\n                $bool[] = $key;\n                $bool[] = $aliases[$key];\n            }\n        }\n\n        for ($i=1; $i < count($_SERVER['argv']); $i++) {\n            $arg   = $_SERVER['argv'][$i];\n            $value = true;\n            $key   = null;\n\n            if ($arg[0] == '-') {\n                $key = preg_replace('/^-+/', '', $arg);\n                $sp  = strpos($arg, '=');\n\n                if ($sp > 0) {\n                    $key   = substr($key, 0, $sp - 2);\n                    $value = substr($arg, $sp+1);\n                }\n                else if (in_array($key, $bool)) {\n                    $value = true;\n                }\n                else if (strlen($_SERVER['argv'][$i+1]) && $_SERVER['argv'][$i+1][0] != '-') {\n                    $value = $_SERVER['argv'][++$i];\n                }\n\n                $args[$key] = is_string($value) ? preg_replace(array('/^[\"\\']/', '/[\"\\']$/'), '', $value) : $value;\n            }\n            else {\n                $args[] = $arg;\n            }\n\n            if ($alias = $aliases[$key]) {\n                $args[$alias] = $args[$key];\n            }\n        }\n\n        return $args;\n    }\n\n    /**\n     * Safe password prompt for command line\n     * from http://blogs.sitepoint.com/2009/05/01/interactive-cli-password-prompt-in-php/\n     *\n     * @return string Password\n     */\n    public static function prompt_silent($prompt = \"Password:\")\n    {\n        if (preg_match('/^win/i', PHP_OS)) {\n            $vbscript  = sys_get_temp_dir() . 'prompt_password.vbs';\n            $vbcontent = 'wscript.echo(InputBox(\"' . addslashes($prompt) . '\", \"\", \"password here\"))';\n            file_put_contents($vbscript, $vbcontent);\n\n            $command  = \"cscript //nologo \" . escapeshellarg($vbscript);\n            $password = rtrim(shell_exec($command));\n            unlink($vbscript);\n\n            return $password;\n        }\n        else {\n            $command = \"/usr/bin/env bash -c 'echo OK'\";\n            if (rtrim(shell_exec($command)) !== 'OK') {\n                echo $prompt;\n                $pass = trim(fgets(STDIN));\n                echo chr(8).\"\\r\" . $prompt . str_repeat(\"*\", strlen($pass)).\"\\n\";\n                return $pass;\n            }\n\n            $command = \"/usr/bin/env bash -c 'read -s -p \\\"\" . addslashes($prompt) . \"\\\" mypassword && echo \\$mypassword'\";\n            $password = rtrim(shell_exec($command));\n            echo \"\\n\";\n            return $password;\n        }\n    }\n\n    /**\n     * Find out if the string content means true or false\n     *\n     * @param string $str Input value\n     *\n     * @return boolean Boolean value\n     */\n    public static function get_boolean($str)\n    {\n        $str = strtolower($str);\n\n        return !in_array($str, array('false', '0', 'no', 'off', 'nein', ''), true);\n    }\n\n    /**\n     * OS-dependent absolute path detection\n     */\n    public static function is_absolute_path($path)\n    {\n        if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {\n            return (bool) preg_match('!^[a-z]:[\\\\\\\\/]!i', $path);\n        }\n        else {\n            return $path[0] == '/';\n        }\n    }\n\n    /**\n     * Resolve relative URL\n     *\n     * @param string $url Relative URL\n     *\n     * @return string Absolute URL\n     */\n    public static function resolve_url($url)\n    {\n        // prepend protocol://hostname:port\n        if (!preg_match('|^https?://|', $url)) {\n            $schema       = 'http';\n            $default_port = 80;\n\n            if (self::https_check()) {\n                $schema       = 'https';\n                $default_port = 443;\n            }\n\n            $prefix = $schema . '://' . preg_replace('/:\\d+$/', '', $_SERVER['HTTP_HOST']);\n            if ($_SERVER['SERVER_PORT'] != $default_port) {\n                $prefix .= ':' . $_SERVER['SERVER_PORT'];\n            }\n\n            $url = $prefix . ($url[0] == '/' ? '' : '/') . $url;\n        }\n\n        return $url;\n    }\n\n    /**\n     * Generate a random string\n     *\n     * @param int  $length String length\n     * @param bool $raw    Return RAW data instead of ascii\n     *\n     * @return string The generated random string\n     */\n    public static function random_bytes($length, $raw = false)\n    {\n        // Use PHP7 true random generator\n        if (function_exists('random_bytes')) {\n            // random_bytes() can throw an Error/TypeError/Exception in some cases\n            try {\n                $random = random_bytes($length);\n            }\n            catch (Throwable $e) {}\n        }\n\n        if (!$random) {\n            $random = openssl_random_pseudo_bytes($length);\n        }\n\n        if ($raw) {\n            return $random;\n        }\n\n        $random = self::bin2ascii($random);\n\n        // truncate to the specified size...\n        if ($length < strlen($random)) {\n            $random = substr($random, 0, $length);\n        }\n\n        return $random;\n    }\n\n    /**\n     * Convert binary data into readable form (containing a-zA-Z0-9 characters)\n     *\n     * @param string $input Binary input\n     *\n     * @return string Readable output\n     */\n    public static function bin2ascii($input)\n    {\n        // Above method returns \"hexits\".\n        // Based on bin_to_readable() function in ext/session/session.c.\n        // Note: removed \",-\" characters from hextab\n        $hextab = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        $nbits  = 6; // can be 4, 5 or 6\n        $length = strlen($input);\n        $result = '';\n        $char   = 0;\n        $i      = 0;\n        $have   = 0;\n        $mask   = (1 << $nbits) - 1;\n\n        while (true) {\n            if ($have < $nbits) {\n                if ($i < $length) {\n                    $char |= ord($input[$i++]) << $have;\n                    $have += 8;\n                }\n                else if (!$have) {\n                    break;\n                }\n                else {\n                    $have = $nbits;\n                }\n            }\n\n            // consume nbits\n            $result .= $hextab[$char & $mask];\n            $char  >>= $nbits;\n            $have   -= $nbits;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Format current date according to specified format.\n     * This method supports microseconds (u).\n     *\n     * @param string $format Date format (default: 'd-M-Y H:i:s O')\n     *\n     * @return string Formatted date\n     */\n    public static function date_format($format = null)\n    {\n        if (empty($format)) {\n            $format = 'd-M-Y H:i:s O';\n        }\n\n        if (strpos($format, 'u') !== false) {\n            $dt  = number_format(microtime(true), 6, '.', '');\n            $dt .=  '.' . date_default_timezone_get();\n\n            if ($date = date_create_from_format('U.u.e', $dt)) {\n                return $date->format($format);\n            }\n        }\n\n        return date($format);\n    }\n\n    /**\n     * Get maximum upload size\n     *\n     * @return int Maximum size in bytes\n     */\n    public static function max_upload_size()\n    {\n        // find max filesize value\n        $max_filesize = parse_bytes(ini_get('upload_max_filesize'));\n        $max_postsize = parse_bytes(ini_get('post_max_size'));\n\n        if ($max_postsize && $max_postsize < $max_filesize) {\n            $max_filesize = $max_postsize;\n        }\n\n        return $max_filesize;\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n +-----------------------------------------------------------------------+\n | This file is part of the Roundcube Webmail client                     |\n | Copyright (C) 2008-2012, The Roundcube Dev Team                       |\n | Copyright (C) 2011-2012, Kolab Systems AG                             |\n |                                                                       |\n | Licensed under the GNU General Public License version 3 or            |\n | any later version with exceptions for skins & plugins.                |\n | See the README file for a full license statement.                     |\n |                                                                       |\n | PURPOSE:                                                              |\n |   Utility class providing common functions                            |\n +-----------------------------------------------------------------------+\n | Author: Thomas Bruederli <roundcube@gmail.com>                        |\n | Author: Aleksander Machniak <alec@alec.pl>                            |\n +-----------------------------------------------------------------------+\n*/\n\n/**\n * Utility class providing common functions\n *\n * @package    Framework\n * @subpackage Utils\n */\nclass rcube_utils\n{\n    // define constants for input reading\n    const INPUT_GET  = 0x0101;\n    const INPUT_POST = 0x0102;\n    const INPUT_GPC  = 0x0103;\n\n    /**\n     * Helper method to set a cookie with the current path and host settings\n     *\n     * @param string Cookie name\n     * @param string Cookie value\n     * @param string Expiration time\n     */\n    public static function setcookie($name, $value, $exp = 0)\n    {\n        if (headers_sent()) {\n            return;\n        }\n\n        $cookie = session_get_cookie_params();\n        $secure = $cookie['secure'] || self::https_check();\n\n        setcookie($name, $value, $exp, $cookie['path'], $cookie['domain'], $secure, true);\n    }\n\n    /**\n     * E-mail address validation.\n     *\n     * @param string $email Email address\n     * @param boolean $dns_check True to check dns\n     *\n     * @return boolean True on success, False if address is invalid\n     */\n    public static function check_email($email, $dns_check=true)\n    {\n        // Check for invalid characters\n        if (preg_match('/[\\x00-\\x1F\\x7F-\\xFF]/', $email)) {\n            return false;\n        }\n\n        // Check for length limit specified by RFC 5321 (#1486453)\n        if (strlen($email) > 254) {\n            return false;\n        }\n\n        $email_array = explode('@', $email);\n\n        // Check that there's one @ symbol\n        if (count($email_array) < 2) {\n            return false;\n        }\n\n        $domain_part = array_pop($email_array);\n        $local_part  = implode('@', $email_array);\n\n        // from PEAR::Validate\n        $regexp = '&^(?:\n            (\"\\s*(?:[^\"\\f\\n\\r\\t\\v\\b\\s]+\\s*)+\")|                             #1 quoted name\n            ([-\\w!\\#\\$%\\&\\'*+~/^`|{}=]+(?:\\.[-\\w!\\#\\$%\\&\\'*+~/^`|{}=]+)*))  #2 OR dot-atom (RFC5322)\n            $&xi';\n\n        if (!preg_match($regexp, $local_part)) {\n            return false;\n        }\n\n        // Validate domain part\n        if (preg_match('/^\\[((IPv6:[0-9a-f:.]+)|([0-9.]+))\\]$/i', $domain_part, $matches)) {\n            return self::check_ip(preg_replace('/^IPv6:/i', '', $matches[1])); // valid IPv4 or IPv6 address\n        }\n        else {\n            // If not an IP address\n            $domain_array = explode('.', $domain_part);\n            // Not enough parts to be a valid domain\n            if (sizeof($domain_array) < 2) {\n                return false;\n            }\n\n            foreach ($domain_array as $part) {\n                if (!preg_match('/^((xn--)?([A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9])|([A-Za-z0-9]))$/', $part)) {\n                    return false;\n                }\n            }\n\n            // last domain part\n            $last_part = array_pop($domain_array);\n            if (strpos($last_part, 'xn--') !== 0 && preg_match('/[^a-zA-Z]/', $last_part)) {\n                return false;\n            }\n\n            $rcube = rcube::get_instance();\n\n            if (!$dns_check || !$rcube->config->get('email_dns_check')) {\n                return true;\n            }\n\n            // find MX record(s)\n            if (!function_exists('getmxrr') || getmxrr($domain_part, $mx_records)) {\n                return true;\n            }\n\n            // find any DNS record\n            if (!function_exists('checkdnsrr') || checkdnsrr($domain_part, 'ANY')) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Validates IPv4 or IPv6 address\n     *\n     * @param string $ip IP address in v4 or v6 format\n     *\n     * @return bool True if the address is valid\n     */\n    public static function check_ip($ip)\n    {\n        return filter_var($ip, FILTER_VALIDATE_IP) !== false;\n    }\n\n    /**\n     * Check whether the HTTP referer matches the current request\n     *\n     * @return boolean True if referer is the same host+path, false if not\n     */\n    public static function check_referer()\n    {\n        $uri     = parse_url($_SERVER['REQUEST_URI']);\n        $referer = parse_url(self::request_header('Referer'));\n\n        return $referer['host'] == self::request_header('Host') && $referer['path'] == $uri['path'];\n    }\n\n    /**\n     * Replacing specials characters to a specific encoding type\n     *\n     * @param string  Input string\n     * @param string  Encoding type: text|html|xml|js|url\n     * @param string  Replace mode for tags: show|remove|strict\n     * @param boolean Convert newlines\n     *\n     * @return string The quoted string\n     */\n    public static function rep_specialchars_output($str, $enctype = '', $mode = '', $newlines = true)\n    {\n        static $html_encode_arr = false;\n        static $js_rep_table    = false;\n        static $xml_rep_table   = false;\n\n        if (!is_string($str)) {\n            $str = strval($str);\n        }\n\n        // encode for HTML output\n        if ($enctype == 'html') {\n            if (!$html_encode_arr) {\n                $html_encode_arr = get_html_translation_table(HTML_SPECIALCHARS);\n                unset($html_encode_arr['?']);\n            }\n\n            $encode_arr = $html_encode_arr;\n\n            if ($mode == 'remove') {\n                $str = strip_tags($str);\n            }\n            else if ($mode != 'strict') {\n                // don't replace quotes and html tags\n                $ltpos = strpos($str, '<');\n                if ($ltpos !== false && strpos($str, '>', $ltpos) !== false) {\n                    unset($encode_arr['\"']);\n                    unset($encode_arr['<']);\n                    unset($encode_arr['>']);\n                    unset($encode_arr['&']);\n                }\n            }\n\n            $out = strtr($str, $encode_arr);\n\n            return $newlines ? nl2br($out) : $out;\n        }\n\n        // if the replace tables for XML and JS are not yet defined\n        if ($js_rep_table === false) {\n            $js_rep_table = $xml_rep_table = array();\n            $xml_rep_table['&'] = '&amp;';\n\n            // can be increased to support more charsets\n            for ($c=160; $c<256; $c++) {\n                $xml_rep_table[chr($c)] = \"&#$c;\";\n            }\n\n            $xml_rep_table['\"'] = '&quot;';\n            $js_rep_table['\"']  = '\\\\\"';\n            $js_rep_table[\"'\"]  = \"\\\\'\";\n            $js_rep_table[\"\\\\\"] = \"\\\\\\\\\";\n            // Unicode line and paragraph separators (#1486310)\n            $js_rep_table[chr(hexdec('E2')).chr(hexdec('80')).chr(hexdec('A8'))] = '&#8232;';\n            $js_rep_table[chr(hexdec('E2')).chr(hexdec('80')).chr(hexdec('A9'))] = '&#8233;';\n        }\n\n        // encode for javascript use\n        if ($enctype == 'js') {\n            return preg_replace(array(\"/\\r?\\n/\", \"/\\r/\", '/<\\\\//'), array('\\n', '\\n', '<\\\\/'), strtr($str, $js_rep_table));\n        }\n\n        // encode for plaintext\n        if ($enctype == 'text') {\n            return str_replace(\"\\r\\n\", \"\\n\", $mode == 'remove' ? strip_tags($str) : $str);\n        }\n\n        if ($enctype == 'url') {\n            return rawurlencode($str);\n        }\n\n        // encode for XML\n        if ($enctype == 'xml') {\n            return strtr($str, $xml_rep_table);\n        }\n\n        // no encoding given -> return original string\n        return $str;\n    }\n\n    /**\n     * Read input value and convert it for internal use\n     * Performs stripslashes() and charset conversion if necessary\n     *\n     * @param string  Field name to read\n     * @param int     Source to get value from (GPC)\n     * @param boolean Allow HTML tags in field value\n     * @param string  Charset to convert into\n     *\n     * @return string Field value or NULL if not available\n     */\n    public static function get_input_value($fname, $source, $allow_html = false, $charset = null)\n    {\n        $value = null;\n\n        if ($source == self::INPUT_GET) {\n            if (isset($_GET[$fname])) {\n                $value = $_GET[$fname];\n            }\n        }\n        else if ($source == self::INPUT_POST) {\n            if (isset($_POST[$fname])) {\n                $value = $_POST[$fname];\n            }\n        }\n        else if ($source == self::INPUT_GPC) {\n            if (isset($_POST[$fname])) {\n                $value = $_POST[$fname];\n            }\n            else if (isset($_GET[$fname])) {\n                $value = $_GET[$fname];\n            }\n            else if (isset($_COOKIE[$fname])) {\n                $value = $_COOKIE[$fname];\n            }\n        }\n\n        return self::parse_input_value($value, $allow_html, $charset);\n    }\n\n    /**\n     * Parse/validate input value. See self::get_input_value()\n     * Performs stripslashes() and charset conversion if necessary\n     *\n     * @param string  Input value\n     * @param boolean Allow HTML tags in field value\n     * @param string  Charset to convert into\n     *\n     * @return string Parsed value\n     */\n    public static function parse_input_value($value, $allow_html = false, $charset = null)\n    {\n        global $OUTPUT;\n\n        if (empty($value)) {\n            return $value;\n        }\n\n        if (is_array($value)) {\n            foreach ($value as $idx => $val) {\n                $value[$idx] = self::parse_input_value($val, $allow_html, $charset);\n            }\n            return $value;\n        }\n\n        // strip slashes if magic_quotes enabled\n        if (get_magic_quotes_gpc() || get_magic_quotes_runtime()) {\n            $value = stripslashes($value);\n        }\n\n        // remove HTML tags if not allowed\n        if (!$allow_html) {\n            $value = strip_tags($value);\n        }\n\n        $output_charset = is_object($OUTPUT) ? $OUTPUT->get_charset() : null;\n\n        // remove invalid characters (#1488124)\n        if ($output_charset == 'UTF-8') {\n            $value = rcube_charset::clean($value);\n        }\n\n        // convert to internal charset\n        if ($charset && $output_charset) {\n            $value = rcube_charset::convert($value, $output_charset, $charset);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Convert array of request parameters (prefixed with _)\n     * to a regular array with non-prefixed keys.\n     *\n     * @param int     $mode       Source to get value from (GPC)\n     * @param string  $ignore     PCRE expression to skip parameters by name\n     * @param boolean $allow_html Allow HTML tags in field value\n     *\n     * @return array Hash array with all request parameters\n     */\n    public static function request2param($mode = null, $ignore = 'task|action', $allow_html = false)\n    {\n        $out = array();\n        $src = $mode == self::INPUT_GET ? $_GET : ($mode == self::INPUT_POST ? $_POST : $_REQUEST);\n\n        foreach (array_keys($src) as $key) {\n            $fname = $key[0] == '_' ? substr($key, 1) : $key;\n            if ($ignore && !preg_match('/^(' . $ignore . ')$/', $fname)) {\n                $out[$fname] = self::get_input_value($key, $mode, $allow_html);\n            }\n        }\n\n        return $out;\n    }\n\n    /**\n     * Convert the given string into a valid HTML identifier\n     * Same functionality as done in app.js with rcube_webmail.html_identifier()\n     */\n    public static function html_identifier($str, $encode=false)\n    {\n        if ($encode) {\n            return rtrim(strtr(base64_encode($str), '+/', '-_'), '=');\n        }\n        else {\n            return asciiwords($str, true, '_');\n        }\n    }\n\n    /**\n     * Replace all css definitions with #container [def]\n     * and remove css-inlined scripting, make position style safe\n     *\n     * @param string CSS source code\n     * @param string Container ID to use as prefix\n     * @param bool   Allow remote content\n     *\n     * @return string Modified CSS source\n     */\n    public static function mod_css_styles($source, $container_id, $allow_remote = false)\n    {\n        $last_pos     = 0;\n        $replacements = new rcube_string_replacer;\n\n        // ignore the whole block if evil styles are detected\n        $source   = self::xss_entity_decode($source);\n        $stripped = preg_replace('/[^a-z\\(:;]/i', '', $source);\n        $evilexpr = 'expression|behavior|javascript:|import[^a]' . (!$allow_remote ? '|url\\((?!data:image)' : '');\n\n        if (preg_match(\"/$evilexpr/i\", $stripped)) {\n            return '/* evil! */';\n        }\n\n        $strict_url_regexp = '!url\\s*\\([ \"\\'](https?:)//[a-z0-9/._+-]+[\"\\' ]\\)!Uims';\n\n        // cut out all contents between { and }\n        while (($pos = strpos($source, '{', $last_pos)) && ($pos2 = strpos($source, '}', $pos))) {\n            $nested = strpos($source, '{', $pos+1);\n            if ($nested && $nested < $pos2)  // when dealing with nested blocks (e.g. @media), take the inner one\n                $pos = $nested;\n            $length = $pos2 - $pos - 1;\n            $styles = substr($source, $pos+1, $length);\n\n            // Convert position:fixed to position:absolute (#5264)\n            $styles = preg_replace('/position:[\\s\\r\\n]*fixed/i', 'position: absolute', $styles);\n\n            // check every line of a style block...\n            if ($allow_remote) {\n                $a_styles = preg_split('/;[\\r\\n]*/', $styles, -1, PREG_SPLIT_NO_EMPTY);\n\n                foreach ($a_styles as $line) {\n                    $stripped = preg_replace('/[^a-z\\(:;]/i', '', $line);\n                    // ... and only allow strict url() values\n                    if (stripos($stripped, 'url(') && !preg_match($strict_url_regexp, $line)) {\n                        $a_styles = array('/* evil! */');\n                        break;\n                    }\n                }\n\n                $styles = join(\";\\n\", $a_styles);\n            }\n\n            $key      = $replacements->add($styles);\n            $repl     = $replacements->get_replacement($key);\n            $source   = substr_replace($source, $repl, $pos+1, $length);\n            $last_pos = $pos2 - ($length - strlen($repl));\n        }\n\n        // remove html comments and add #container to each tag selector.\n        // also replace body definition because we also stripped off the <body> tag\n        $source = preg_replace(\n            array(\n                '/(^\\s*<\\!--)|(-->\\s*$)/m',\n                '/(^\\s*|,\\s*|\\}\\s*)([a-z0-9\\._#\\*][a-z0-9\\.\\-_]*)/im',\n                '/'.preg_quote($container_id, '/').'\\s+body/i',\n            ),\n            array(\n                '',\n                \"\\\\1#$container_id \\\\2\",\n                $container_id,\n            ),\n            $source);\n\n        // put block contents back in\n        $source = $replacements->resolve($source);\n\n        return $source;\n    }\n\n    /**\n     * Generate CSS classes from mimetype and filename extension\n     *\n     * @param string $mimetype Mimetype\n     * @param string $filename Filename\n     *\n     * @return string CSS classes separated by space\n     */\n    public static function file2class($mimetype, $filename)\n    {\n        $mimetype = strtolower($mimetype);\n        $filename = strtolower($filename);\n\n        list($primary, $secondary) = explode('/', $mimetype);\n\n        $classes = array($primary ?: 'unknown');\n\n        if ($secondary) {\n            $classes[] = $secondary;\n        }\n\n        if (preg_match('/\\.([a-z0-9]+)$/', $filename, $m)) {\n            if (!in_array($m[1], $classes)) {\n                $classes[] = $m[1];\n            }\n        }\n\n        return join(\" \", $classes);\n    }\n\n    /**\n     * Decode escaped entities used by known XSS exploits.\n     * See http://downloads.securityfocus.com/vulnerabilities/exploits/26800.eml for examples\n     *\n     * @param string CSS content to decode\n     *\n     * @return string Decoded string\n     */\n    public static function xss_entity_decode($content)\n    {\n        $out = html_entity_decode(html_entity_decode($content));\n        $out = preg_replace_callback('/\\\\\\([0-9a-f]{4})/i',\n            array(self, 'xss_entity_decode_callback'), $out);\n        $out = preg_replace('#/\\*.*\\*/#Ums', '', $out);\n        $out = strip_tags($out);\n\n        return $out;\n    }\n\n    /**\n     * preg_replace_callback callback for xss_entity_decode\n     *\n     * @param array $matches Result from preg_replace_callback\n     *\n     * @return string Decoded entity\n     */\n    public static function xss_entity_decode_callback($matches)\n    {\n        return chr(hexdec($matches[1]));\n    }\n\n    /**\n     * Check if we can process not exceeding memory_limit\n     *\n     * @param integer Required amount of memory\n     *\n     * @return boolean True if memory won't be exceeded, False otherwise\n     */\n    public static function mem_check($need)\n    {\n        $mem_limit = parse_bytes(ini_get('memory_limit'));\n        $memory    = function_exists('memory_get_usage') ? memory_get_usage() : 16*1024*1024; // safe value: 16MB\n\n        return $mem_limit > 0 && $memory + $need > $mem_limit ? false : true;\n    }\n\n    /**\n     * Check if working in SSL mode\n     *\n     * @param integer $port      HTTPS port number\n     * @param boolean $use_https Enables 'use_https' option checking\n     *\n     * @return boolean\n     */\n    public static function https_check($port=null, $use_https=true)\n    {\n        if (!empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) != 'off') {\n            return true;\n        }\n        if (!empty($_SERVER['HTTP_X_FORWARDED_PROTO'])\n            && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) == 'https'\n            && in_array($_SERVER['REMOTE_ADDR'], rcube::get_instance()->config->get('proxy_whitelist', array()))\n        ) {\n            return true;\n        }\n        if ($port && $_SERVER['SERVER_PORT'] == $port) {\n            return true;\n        }\n        if ($use_https && rcube::get_instance()->config->get('use_https')) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Replaces hostname variables.\n     *\n     * @param string $name Hostname\n     * @param string $host Optional IMAP hostname\n     *\n     * @return string Hostname\n     */\n    public static function parse_host($name, $host = '')\n    {\n        if (!is_string($name)) {\n            return $name;\n        }\n\n        // %n - host\n        $n = preg_replace('/:\\d+$/', '', $_SERVER['SERVER_NAME']);\n        // %t - host name without first part, e.g. %n=mail.domain.tld, %t=domain.tld\n        $t = preg_replace('/^[^\\.]+\\./', '', $n);\n        // %d - domain name without first part\n        $d = preg_replace('/^[^\\.]+\\./', '', $_SERVER['HTTP_HOST']);\n        // %h - IMAP host\n        $h = $_SESSION['storage_host'] ?: $host;\n        // %z - IMAP domain without first part, e.g. %h=imap.domain.tld, %z=domain.tld\n        $z = preg_replace('/^[^\\.]+\\./', '', $h);\n        // %s - domain name after the '@' from e-mail address provided at login screen.\n        //      Returns FALSE if an invalid email is provided\n        if (strpos($name, '%s') !== false) {\n            $user_email = self::get_input_value('_user', self::INPUT_POST);\n            $user_email = self::idn_convert($user_email, true);\n            $matches    = preg_match('/(.*)@([a-z0-9\\.\\-\\[\\]\\:]+)/i', $user_email, $s);\n            if ($matches < 1 || filter_var($s[1].\"@\".$s[2], FILTER_VALIDATE_EMAIL) === false) {\n                return false;\n            }\n        }\n\n        return str_replace(array('%n', '%t', '%d', '%h', '%z', '%s'), array($n, $t, $d, $h, $z, $s[2]), $name);\n    }\n\n    /**\n     * Returns remote IP address and forwarded addresses if found\n     *\n     * @return string Remote IP address(es)\n     */\n    public static function remote_ip()\n    {\n        $address = $_SERVER['REMOTE_ADDR'];\n\n        // append the NGINX X-Real-IP header, if set\n        if (!empty($_SERVER['HTTP_X_REAL_IP'])) {\n            $remote_ip[] = 'X-Real-IP: ' . $_SERVER['HTTP_X_REAL_IP'];\n        }\n\n        // append the X-Forwarded-For header, if set\n        if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n            $remote_ip[] = 'X-Forwarded-For: ' . $_SERVER['HTTP_X_FORWARDED_FOR'];\n        }\n\n        if (!empty($remote_ip)) {\n            $address .= '(' . implode(',', $remote_ip) . ')';\n        }\n\n        return $address;\n    }\n\n    /**\n     * Returns the real remote IP address\n     *\n     * @return string Remote IP address\n     */\n    public static function remote_addr()\n    {\n        // Check if any of the headers are set first to improve performance\n        if (!empty($_SERVER['HTTP_X_FORWARDED_FOR']) || !empty($_SERVER['HTTP_X_REAL_IP'])) {\n            $proxy_whitelist = rcube::get_instance()->config->get('proxy_whitelist', array());\n            if (in_array($_SERVER['REMOTE_ADDR'], $proxy_whitelist)) {\n                if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n                    foreach(array_reverse(explode(',', $_SERVER['HTTP_X_FORWARDED_FOR'])) as $forwarded_ip) {\n                        if (!in_array($forwarded_ip, $proxy_whitelist)) {\n                            return $forwarded_ip;\n                        }\n                    }\n                }\n\n                if (!empty($_SERVER['HTTP_X_REAL_IP'])) {\n                    return $_SERVER['HTTP_X_REAL_IP'];\n                }\n            }\n        }\n\n        if (!empty($_SERVER['REMOTE_ADDR'])) {\n            return $_SERVER['REMOTE_ADDR'];\n        }\n\n        return '';\n    }\n\n    /**\n     * Read a specific HTTP request header.\n     *\n     * @param string $name Header name\n     *\n     * @return mixed Header value or null if not available\n     */\n    public static function request_header($name)\n    {\n        if (function_exists('getallheaders')) {\n            $hdrs = array_change_key_case(getallheaders(), CASE_UPPER);\n            $key  = strtoupper($name);\n        }\n        else {\n            $key  = 'HTTP_' . strtoupper(strtr($name, '-', '_'));\n            $hdrs = array_change_key_case($_SERVER, CASE_UPPER);\n        }\n\n        return $hdrs[$key];\n    }\n\n    /**\n     * Explode quoted string\n     *\n     * @param string Delimiter expression string for preg_match()\n     * @param string Input string\n     *\n     * @return array String items\n     */\n    public static function explode_quoted_string($delimiter, $string)\n    {\n        $result = array();\n        $strlen = strlen($string);\n\n        for ($q=$p=$i=0; $i < $strlen; $i++) {\n            if ($string[$i] == \"\\\"\" && $string[$i-1] != \"\\\\\") {\n                $q = $q ? false : true;\n            }\n            else if (!$q && preg_match(\"/$delimiter/\", $string[$i])) {\n                $result[] = substr($string, $p, $i - $p);\n                $p = $i + 1;\n            }\n        }\n\n        $result[] = (string) substr($string, $p);\n\n        return $result;\n    }\n\n    /**\n     * Improved equivalent to strtotime()\n     *\n     * @param string       $date     Date string\n     * @param DateTimeZone $timezone Timezone to use for DateTime object\n     *\n     * @return int Unix timestamp\n     */\n    public static function strtotime($date, $timezone = null)\n    {\n        $date   = self::clean_datestr($date);\n        $tzname = $timezone ? ' ' . $timezone->getName() : '';\n\n        // unix timestamp\n        if (is_numeric($date)) {\n            return (int) $date;\n        }\n\n        // if date parsing fails, we have a date in non-rfc format.\n        // remove token from the end and try again\n        while ((($ts = @strtotime($date . $tzname)) === false) || ($ts < 0)) {\n            $d = explode(' ', $date);\n            array_pop($d);\n            if (!$d) {\n                break;\n            }\n            $date = implode(' ', $d);\n        }\n\n        return (int) $ts;\n    }\n\n    /**\n     * Date parsing function that turns the given value into a DateTime object\n     *\n     * @param string       $date     Date string\n     * @param DateTimeZone $timezone Timezone to use for DateTime object\n     *\n     * @return DateTime instance or false on failure\n     */\n    public static function anytodatetime($date, $timezone = null)\n    {\n        if ($date instanceof DateTime) {\n            return $date;\n        }\n\n        $dt   = false;\n        $date = self::clean_datestr($date);\n\n        // try to parse string with DateTime first\n        if (!empty($date)) {\n            try {\n                $dt = $timezone ? new DateTime($date, $timezone) : new DateTime($date);\n            }\n            catch (Exception $e) {\n                // ignore\n            }\n        }\n\n        // try our advanced strtotime() method\n        if (!$dt && ($timestamp = self::strtotime($date, $timezone))) {\n            try {\n                $dt = new DateTime(\"@\".$timestamp);\n                if ($timezone) {\n                    $dt->setTimezone($timezone);\n                }\n            }\n            catch (Exception $e) {\n                // ignore\n            }\n        }\n\n        return $dt;\n    }\n\n    /**\n     * Clean up date string for strtotime() input\n     *\n     * @param string $date Date string\n     *\n     * @return string Date string\n     */\n    public static function clean_datestr($date)\n    {\n        $date = trim($date);\n\n        // check for MS Outlook vCard date format YYYYMMDD\n        if (preg_match('/^([12][90]\\d\\d)([01]\\d)([0123]\\d)$/', $date, $m)) {\n            return sprintf('%04d-%02d-%02d 00:00:00', intval($m[1]), intval($m[2]), intval($m[3]));\n        }\n\n        // Clean malformed data\n        $date = preg_replace(\n            array(\n                '/GMT\\s*([+-][0-9]+)/',                     // support non-standard \"GMTXXXX\" literal\n                '/[^a-z0-9\\x20\\x09:+-\\/]/i',                // remove any invalid characters\n                '/\\s*(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\\s*/i',   // remove weekday names\n            ),\n            array(\n                '\\\\1',\n                '',\n                '',\n            ), $date);\n\n        $date = trim($date);\n\n        // try to fix dd/mm vs. mm/dd discrepancy, we can't do more here\n        if (preg_match('/^(\\d{1,2})[.\\/-](\\d{1,2})[.\\/-](\\d{4})(\\s.*)?$/', $date, $m)) {\n            $mdy   = $m[2] > 12 && $m[1] <= 12;\n            $day   = $mdy ? $m[2] : $m[1];\n            $month = $mdy ? $m[1] : $m[2];\n            $date  = sprintf('%04d-%02d-%02d%s', $m[3], $month, $day, $m[4] ?: ' 00:00:00');\n        }\n        // I've found that YYYY.MM.DD is recognized wrong, so here's a fix\n        else if (preg_match('/^(\\d{4})\\.(\\d{1,2})\\.(\\d{1,2})(\\s.*)?$/', $date, $m)) {\n            $date  = sprintf('%04d-%02d-%02d%s', $m[1], $m[2], $m[3], $m[4] ?: ' 00:00:00');\n        }\n\n        return $date;\n    }\n\n    /**\n     * Turns the given date-only string in defined format into YYYY-MM-DD format.\n     *\n     * Supported formats: 'Y/m/d', 'Y.m.d', 'd-m-Y', 'd/m/Y', 'd.m.Y', 'j.n.Y'\n     *\n     * @param string $date   Date string\n     * @param string $format Input date format\n     *\n     * @return strin Date string in YYYY-MM-DD format, or the original string\n     *               if format is not supported\n     */\n    public static function format_datestr($date, $format)\n    {\n        $format_items = preg_split('/[.-\\/\\\\\\\\]/', $format);\n        $date_items   = preg_split('/[.-\\/\\\\\\\\]/', $date);\n        $iso_format   = '%04d-%02d-%02d';\n\n        if (count($format_items) == 3 && count($date_items) == 3) {\n            if ($format_items[0] == 'Y') {\n                $date = sprintf($iso_format, $date_items[0], $date_items[1], $date_items[2]);\n            }\n            else if (strpos('dj', $format_items[0]) !== false) {\n                $date = sprintf($iso_format, $date_items[2], $date_items[1], $date_items[0]);\n            }\n            else if (strpos('mn', $format_items[0]) !== false) {\n                $date = sprintf($iso_format, $date_items[2], $date_items[0], $date_items[1]);\n            }\n        }\n\n        return $date;\n    }\n\n    /*\n     * Idn_to_ascii wrapper.\n     * Intl/Idn modules version of this function doesn't work with e-mail address\n     */\n    public static function idn_to_ascii($str)\n    {\n        return self::idn_convert($str, true);\n    }\n\n    /*\n     * Idn_to_ascii wrapper.\n     * Intl/Idn modules version of this function doesn't work with e-mail address\n     */\n    public static function idn_to_utf8($str)\n    {\n        return self::idn_convert($str, false);\n    }\n\n    public static function idn_convert($input, $is_utf = false)\n    {\n        if ($at = strpos($input, '@')) {\n            $user   = substr($input, 0, $at);\n            $domain = substr($input, $at+1);\n        }\n        else {\n            $domain = $input;\n        }\n\n        $domain = $is_utf ? idn_to_ascii($domain) : idn_to_utf8($domain);\n\n        if ($domain === false) {\n            return '';\n        }\n\n        return $at ? $user . '@' . $domain : $domain;\n    }\n\n    /**\n     * Split the given string into word tokens\n     *\n     * @param string Input to tokenize\n     * @param integer Minimum length of a single token\n     * @return array List of tokens\n     */\n    public static function tokenize_string($str, $minlen = 2)\n    {\n        $expr = array('/[\\s;,\"\\'\\/+-]+/ui', '/(\\d)[-.\\s]+(\\d)/u');\n        $repl = array(' ', '\\\\1\\\\2');\n\n        if ($minlen > 1) {\n            $minlen--;\n            $expr[] = \"/(^|\\s+)\\w{1,$minlen}(\\s+|$)/u\";\n            $repl[] = ' ';\n        }\n\n        return array_filter(explode(\" \", preg_replace($expr, $repl, $str)));\n    }\n\n    /**\n     * Normalize the given string for fulltext search.\n     * Currently only optimized for ISO-8859-1 and ISO-8859-2 characters; to be extended\n     *\n     * @param string  Input string (UTF-8)\n     * @param boolean True to return list of words as array\n     * @param integer Minimum length of tokens\n     *\n     * @return mixed Normalized string or a list of normalized tokens\n     */\n    public static function normalize_string($str, $as_array = false, $minlen = 2)\n    {\n        // replace 4-byte unicode characters with '?' character,\n        // these are not supported in default utf-8 charset on mysql,\n        // the chance we'd need them in searching is very low\n        $str = preg_replace('/('\n            . '\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}'\n            . '|[\\xF1-\\xF3][\\x80-\\xBF]{3}'\n            . '|\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}'\n            . ')/', '?', $str);\n\n        // split by words\n        $arr = self::tokenize_string($str, $minlen);\n\n        // detect character set\n        if (utf8_encode(utf8_decode($str)) == $str) {\n            // ISO-8859-1 (or ASCII)\n            preg_match_all('/./u', '\u00e4\u00e2\u00e0\u00e5\u00e1\u00e3\u00e6\u00e7\u00e9\u00ea\u00eb\u00e8\u00ef\u00ee\u00ec\u00ed\u00f1\u00f6\u00f4\u00f2\u00f8\u00f5\u00f3\u00fc\u00fb\u00f9\u00fa\u00fd\u00ff', $keys);\n            preg_match_all('/./',  'aaaaaaaceeeeiiiinoooooouuuuyy', $values);\n\n            $mapping = array_combine($keys[0], $values[0]);\n            $mapping = array_merge($mapping, array('\u00df' => 'ss', 'ae' => 'a', 'oe' => 'o', 'ue' => 'u'));\n        }\n        else if (rcube_charset::convert(rcube_charset::convert($str, 'UTF-8', 'ISO-8859-2'), 'ISO-8859-2', 'UTF-8') == $str) {\n            // ISO-8859-2\n            preg_match_all('/./u', '\u0105\u00e1\u00e2\u00e4\u0107\u00e7\u010d\u00e9\u0119\u00eb\u011b\u00ed\u00ee\u0142\u013e\u013a\u0144\u0148\u00f3\u00f4\u00f6\u0155\u0159\u015b\u0161\u015f\u0165\u0163\u016f\u00fa\u0171\u00fc\u017a\u017e\u017c\u00fd', $keys);\n            preg_match_all('/./',  'aaaaccceeeeiilllnnooorrsssttuuuuzzzy', $values);\n\n            $mapping = array_combine($keys[0], $values[0]);\n            $mapping = array_merge($mapping, array('\u00df' => 'ss', 'ae' => 'a', 'oe' => 'o', 'ue' => 'u'));\n        }\n\n        foreach ($arr as $i => $part) {\n            $part = mb_strtolower($part);\n\n            if (!empty($mapping)) {\n                $part = strtr($part, $mapping);\n            }\n\n            $arr[$i] = $part;\n        }\n\n        return $as_array ? $arr : join(\" \", $arr);\n    }\n\n    /**\n     * Compare two strings for matching words (order not relevant)\n     *\n     * @param string Haystack\n     * @param string Needle\n     *\n     * @return boolean True if match, False otherwise\n     */\n    public static function words_match($haystack, $needle)\n    {\n        $a_needle  = self::tokenize_string($needle, 1);\n        $_haystack = join(\" \", self::tokenize_string($haystack, 1));\n        $valid     = strlen($_haystack) > 0;\n        $hits      = 0;\n\n        foreach ($a_needle as $w) {\n            if ($valid) {\n                if (stripos($_haystack, $w) !== false) {\n                    $hits++;\n                }\n            }\n            else if (stripos($haystack, $w) !== false) {\n                $hits++;\n            }\n        }\n\n        return $hits >= count($a_needle);\n    }\n\n    /**\n     * Parse commandline arguments into a hash array\n     *\n     * @param array $aliases Argument alias names\n     *\n     * @return array Argument values hash\n     */\n    public static function get_opt($aliases = array())\n    {\n        $args = array();\n        $bool = array();\n\n        // find boolean (no value) options\n        foreach ($aliases as $key => $alias) {\n            if ($pos = strpos($alias, ':')) {\n                $aliases[$key] = substr($alias, 0, $pos);\n                $bool[] = $key;\n                $bool[] = $aliases[$key];\n            }\n        }\n\n        for ($i=1; $i < count($_SERVER['argv']); $i++) {\n            $arg   = $_SERVER['argv'][$i];\n            $value = true;\n            $key   = null;\n\n            if ($arg[0] == '-') {\n                $key = preg_replace('/^-+/', '', $arg);\n                $sp  = strpos($arg, '=');\n\n                if ($sp > 0) {\n                    $key   = substr($key, 0, $sp - 2);\n                    $value = substr($arg, $sp+1);\n                }\n                else if (in_array($key, $bool)) {\n                    $value = true;\n                }\n                else if (strlen($_SERVER['argv'][$i+1]) && $_SERVER['argv'][$i+1][0] != '-') {\n                    $value = $_SERVER['argv'][++$i];\n                }\n\n                $args[$key] = is_string($value) ? preg_replace(array('/^[\"\\']/', '/[\"\\']$/'), '', $value) : $value;\n            }\n            else {\n                $args[] = $arg;\n            }\n\n            if ($alias = $aliases[$key]) {\n                $args[$alias] = $args[$key];\n            }\n        }\n\n        return $args;\n    }\n\n    /**\n     * Safe password prompt for command line\n     * from http://blogs.sitepoint.com/2009/05/01/interactive-cli-password-prompt-in-php/\n     *\n     * @return string Password\n     */\n    public static function prompt_silent($prompt = \"Password:\")\n    {\n        if (preg_match('/^win/i', PHP_OS)) {\n            $vbscript  = sys_get_temp_dir() . 'prompt_password.vbs';\n            $vbcontent = 'wscript.echo(InputBox(\"' . addslashes($prompt) . '\", \"\", \"password here\"))';\n            file_put_contents($vbscript, $vbcontent);\n\n            $command  = \"cscript //nologo \" . escapeshellarg($vbscript);\n            $password = rtrim(shell_exec($command));\n            unlink($vbscript);\n\n            return $password;\n        }\n        else {\n            $command = \"/usr/bin/env bash -c 'echo OK'\";\n            if (rtrim(shell_exec($command)) !== 'OK') {\n                echo $prompt;\n                $pass = trim(fgets(STDIN));\n                echo chr(8).\"\\r\" . $prompt . str_repeat(\"*\", strlen($pass)).\"\\n\";\n                return $pass;\n            }\n\n            $command = \"/usr/bin/env bash -c 'read -s -p \\\"\" . addslashes($prompt) . \"\\\" mypassword && echo \\$mypassword'\";\n            $password = rtrim(shell_exec($command));\n            echo \"\\n\";\n            return $password;\n        }\n    }\n\n    /**\n     * Find out if the string content means true or false\n     *\n     * @param string $str Input value\n     *\n     * @return boolean Boolean value\n     */\n    public static function get_boolean($str)\n    {\n        $str = strtolower($str);\n\n        return !in_array($str, array('false', '0', 'no', 'off', 'nein', ''), true);\n    }\n\n    /**\n     * OS-dependent absolute path detection\n     */\n    public static function is_absolute_path($path)\n    {\n        if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {\n            return (bool) preg_match('!^[a-z]:[\\\\\\\\/]!i', $path);\n        }\n        else {\n            return $path[0] == '/';\n        }\n    }\n\n    /**\n     * Resolve relative URL\n     *\n     * @param string $url Relative URL\n     *\n     * @return string Absolute URL\n     */\n    public static function resolve_url($url)\n    {\n        // prepend protocol://hostname:port\n        if (!preg_match('|^https?://|', $url)) {\n            $schema       = 'http';\n            $default_port = 80;\n\n            if (self::https_check()) {\n                $schema       = 'https';\n                $default_port = 443;\n            }\n\n            $prefix = $schema . '://' . preg_replace('/:\\d+$/', '', $_SERVER['HTTP_HOST']);\n            if ($_SERVER['SERVER_PORT'] != $default_port) {\n                $prefix .= ':' . $_SERVER['SERVER_PORT'];\n            }\n\n            $url = $prefix . ($url[0] == '/' ? '' : '/') . $url;\n        }\n\n        return $url;\n    }\n\n    /**\n     * Generate a random string\n     *\n     * @param int  $length String length\n     * @param bool $raw    Return RAW data instead of ascii\n     *\n     * @return string The generated random string\n     */\n    public static function random_bytes($length, $raw = false)\n    {\n        // Use PHP7 true random generator\n        if (function_exists('random_bytes')) {\n            // random_bytes() can throw an Error/TypeError/Exception in some cases\n            try {\n                $random = random_bytes($length);\n            }\n            catch (Throwable $e) {}\n        }\n\n        if (!$random) {\n            $random = openssl_random_pseudo_bytes($length);\n        }\n\n        if ($raw) {\n            return $random;\n        }\n\n        $random = self::bin2ascii($random);\n\n        // truncate to the specified size...\n        if ($length < strlen($random)) {\n            $random = substr($random, 0, $length);\n        }\n\n        return $random;\n    }\n\n    /**\n     * Convert binary data into readable form (containing a-zA-Z0-9 characters)\n     *\n     * @param string $input Binary input\n     *\n     * @return string Readable output\n     */\n    public static function bin2ascii($input)\n    {\n        // Above method returns \"hexits\".\n        // Based on bin_to_readable() function in ext/session/session.c.\n        // Note: removed \",-\" characters from hextab\n        $hextab = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        $nbits  = 6; // can be 4, 5 or 6\n        $length = strlen($input);\n        $result = '';\n        $char   = 0;\n        $i      = 0;\n        $have   = 0;\n        $mask   = (1 << $nbits) - 1;\n\n        while (true) {\n            if ($have < $nbits) {\n                if ($i < $length) {\n                    $char |= ord($input[$i++]) << $have;\n                    $have += 8;\n                }\n                else if (!$have) {\n                    break;\n                }\n                else {\n                    $have = $nbits;\n                }\n            }\n\n            // consume nbits\n            $result .= $hextab[$char & $mask];\n            $char  >>= $nbits;\n            $have   -= $nbits;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Format current date according to specified format.\n     * This method supports microseconds (u).\n     *\n     * @param string $format Date format (default: 'd-M-Y H:i:s O')\n     *\n     * @return string Formatted date\n     */\n    public static function date_format($format = null)\n    {\n        if (empty($format)) {\n            $format = 'd-M-Y H:i:s O';\n        }\n\n        if (strpos($format, 'u') !== false) {\n            $dt  = number_format(microtime(true), 6, '.', '');\n            $dt .=  '.' . date_default_timezone_get();\n\n            if ($date = date_create_from_format('U.u.e', $dt)) {\n                return $date->format($format);\n            }\n        }\n\n        return date($format);\n    }\n\n    /**\n     * Get maximum upload size\n     *\n     * @return int Maximum size in bytes\n     */\n    public static function max_upload_size()\n    {\n        // find max filesize value\n        $max_filesize = parse_bytes(ini_get('upload_max_filesize'));\n        $max_postsize = parse_bytes(ini_get('post_max_size'));\n\n        if ($max_postsize && $max_postsize < $max_filesize) {\n            $max_filesize = $max_postsize;\n        }\n\n        return $max_filesize;\n    }\n}\n"], "filenames": ["program/lib/Roundcube/rcube_utils.php"], "buggy_code_start_loc": [502], "buggy_code_end_loc": [505], "fixing_code_start_loc": [501], "fixing_code_end_loc": [506], "type": "CWE-79", "message": "rcube_utils.php in Roundcube before 1.1.8 and 1.2.x before 1.2.4 is susceptible to a cross-site scripting vulnerability via a crafted Cascading Style Sheets (CSS) token sequence within an SVG element.", "other": {"cve": {"id": "CVE-2017-6820", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-12T05:59:00.277", "lastModified": "2018-10-30T16:27:29.530", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "rcube_utils.php in Roundcube before 1.1.8 and 1.2.x before 1.2.4 is susceptible to a cross-site scripting vulnerability via a crafted Cascading Style Sheets (CSS) token sequence within an SVG element."}, {"lang": "es", "value": "rcube_utils.php en Roundcube en versiones anteriores a 1.1.8 y 1.2.x en versiones anteriores a 1.2.4 es susceptible a una vulnerabilidad de XSS a trav\u00e9s una secuencia de tokens de CSS manipulada dentro de un elemento SVG."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:roundcube:webmail:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.7", "matchCriteriaId": "47063171-0D2F-4987-91BA-051FFD0D7B3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:roundcube:webmail:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "6556D4DF-FFF9-4EE0-91EA-84314D7CF071"}, {"vulnerable": true, "criteria": "cpe:2.3:a:roundcube:webmail:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "98A43C92-1266-47DB-B3D9-A12CFE271EEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:roundcube:webmail:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "BEFDA8E6-5BD6-4A20-8B67-C9597B67DABA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:roundcube:webmail:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "7DB074D9-E258-471F-9FF7-CABE43E763DC"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/96817", "source": "cve@mitre.org"}, {"url": "https://github.com/roundcube/roundcubemail/commit/cbd35626f7db7855f3b5e2db00d28ecc1554e9f4", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/roundcube/roundcubemail/commit/fa2824fdcd44af3f970b2797feb47652482c8305", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/roundcube/roundcubemail/releases/tag/1.1.8", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/roundcube/roundcubemail/releases/tag/1.2.4", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/roundcube/roundcubemail/wiki/Changelog#release-124", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://roundcube.net/news/2017/03/10/updates-1.2.4-and-1.1.8-released", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/roundcube/roundcubemail/commit/cbd35626f7db7855f3b5e2db00d28ecc1554e9f4"}}