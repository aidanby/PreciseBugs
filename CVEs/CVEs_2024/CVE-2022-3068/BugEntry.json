{"buggy_code": ["__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport copy\nimport logging\nimport os\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nfrom datetime import datetime\n\nimport filetype\nimport pkg_resources\nimport pylru\nimport requests\nimport sarge\nfrom flask import Response, abort, jsonify, request\nfrom flask_babel import gettext\n\nimport octoprint.plugin\nimport octoprint.plugin.core\nfrom octoprint.access import ADMIN_GROUP, READONLY_GROUP, USER_GROUP\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.events import Events\nfrom octoprint.server import safe_mode\nfrom octoprint.server.util.flask import (\n    check_etag,\n    no_firstrun_access,\n    with_revalidation_checking,\n)\nfrom octoprint.settings import valid_boolean_trues\nfrom octoprint.util import deprecated, to_bytes\nfrom octoprint.util.net import download_file\nfrom octoprint.util.pip import (\n    OUTPUT_SUCCESS,\n    create_pip_caller,\n    get_result_line,\n    is_already_installed,\n    is_python_mismatch,\n)\nfrom octoprint.util.platform import get_os, is_os_compatible\nfrom octoprint.util.version import (\n    get_octoprint_version,\n    get_octoprint_version_string,\n    is_octoprint_compatible,\n    is_python_compatible,\n)\n\nfrom . import exceptions\n\n_DATA_FORMAT_VERSION = \"v3\"\n\nDEFAULT_PLUGIN_REPOSITORY = \"https://plugins.octoprint.org/plugins.json\"\nDEFAULT_PLUGIN_NOTICES = \"https://plugins.octoprint.org/notices.json\"\n\n\ndef map_repository_entry(entry):\n    if not isinstance(entry, dict):\n        return None\n\n    result = copy.deepcopy(entry)\n\n    if \"follow_dependency_links\" not in result:\n        result[\"follow_dependency_links\"] = False\n\n    result[\"is_compatible\"] = {\"octoprint\": True, \"os\": True, \"python\": True}\n\n    if \"compatibility\" in entry:\n        if (\n            \"octoprint\" in entry[\"compatibility\"]\n            and entry[\"compatibility\"][\"octoprint\"] is not None\n            and isinstance(entry[\"compatibility\"][\"octoprint\"], (list, tuple))\n            and len(entry[\"compatibility\"][\"octoprint\"])\n        ):\n            result[\"is_compatible\"][\"octoprint\"] = is_octoprint_compatible(\n                *entry[\"compatibility\"][\"octoprint\"]\n            )\n\n        if (\n            \"os\" in entry[\"compatibility\"]\n            and entry[\"compatibility\"][\"os\"] is not None\n            and isinstance(entry[\"compatibility\"][\"os\"], (list, tuple))\n            and len(entry[\"compatibility\"][\"os\"])\n        ):\n            result[\"is_compatible\"][\"os\"] = is_os_compatible(entry[\"compatibility\"][\"os\"])\n\n        if (\n            \"python\" in entry[\"compatibility\"]\n            and entry[\"compatibility\"][\"python\"] is not None\n            and isinstance(entry[\"compatibility\"][\"python\"], str)\n        ):\n            result[\"is_compatible\"][\"python\"] = is_python_compatible(\n                entry[\"compatibility\"][\"python\"]\n            )\n        else:\n            # we default to only assume py2 compatiblity for now\n            result[\"is_compatible\"][\"python\"] = is_python_compatible(\">=2.7,<3\")\n\n    return result\n\n\nalready_installed_string = \"Requirement already satisfied (use --upgrade to upgrade)\"\nsuccess_string = \"Successfully installed\"\nfailure_string = \"Could not install\"\npython_mismatch_string = \"requires a different Python:\"\n\n\nclass PluginManagerPlugin(\n    octoprint.plugin.SimpleApiPlugin,\n    octoprint.plugin.TemplatePlugin,\n    octoprint.plugin.AssetPlugin,\n    octoprint.plugin.SettingsPlugin,\n    octoprint.plugin.StartupPlugin,\n    octoprint.plugin.BlueprintPlugin,\n    octoprint.plugin.EventHandlerPlugin,\n):\n\n    ARCHIVE_EXTENSIONS = (\".zip\", \".tar.gz\", \".tgz\", \".tar\", \".gz\", \".whl\")\n    PYTHON_EXTENSIONS = (\".py\",)\n\n    # valid pip install URL schemes according to https://pip.pypa.io/en/stable/reference/pip_install/\n    URL_SCHEMES = (\n        \"http\",\n        \"https\",\n        \"git\",\n        \"git+http\",\n        \"git+https\",\n        \"git+ssh\",\n        \"git+git\",\n        \"hg+http\",\n        \"hg+https\",\n        \"hg+static-http\",\n        \"hg+ssh\",\n        \"svn\",\n        \"svn+svn\",\n        \"svn+http\",\n        \"svn+https\",\n        \"svn+ssh\",\n        \"bzr+http\",\n        \"bzr+https\",\n        \"bzr+ssh\",\n        \"bzr+sftp\",\n        \"bzr+ftp\",\n        \"bzr+lp\",\n    )\n\n    OPERATING_SYSTEMS = {\n        \"windows\": [\"win32\"],\n        \"linux\": lambda x: x.startswith(\"linux\"),\n        \"macos\": [\"darwin\"],\n        \"freebsd\": lambda x: x.startswith(\"freebsd\"),\n    }\n\n    PIP_INAPPLICABLE_ARGUMENTS = {\"uninstall\": [\"--user\"]}\n\n    RECONNECT_HOOKS = [\n        \"octoprint.comm.protocol.*\",\n    ]\n\n    # noinspection PyMissingConstructor\n    def __init__(self):\n        self._pending_enable = set()\n        self._pending_disable = set()\n        self._pending_install = set()\n        self._pending_uninstall = set()\n\n        self._pip_caller = None\n\n        self._repository_available = False\n        self._repository_plugins = []\n        self._repository_cache_path = None\n        self._repository_cache_ttl = 0\n        self._repository_mtime = None\n\n        self._notices = {}\n        self._notices_available = False\n        self._notices_cache_path = None\n        self._notices_cache_ttl = 0\n        self._notices_mtime = None\n\n        self._orphans = None\n\n        self._console_logger = None\n\n        self._get_throttled = lambda: False\n\n        self._install_task = None\n        self._install_lock = threading.RLock()\n\n    def initialize(self):\n        self._console_logger = logging.getLogger(\n            \"octoprint.plugins.pluginmanager.console\"\n        )\n        self._repository_cache_path = os.path.join(\n            self.get_plugin_data_folder(), \"plugins.json\"\n        )\n        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60\n        self._notices_cache_path = os.path.join(\n            self.get_plugin_data_folder(), \"notices.json\"\n        )\n        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60\n        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])\n\n        self._pip_caller = create_pip_caller(\n            command=self._settings.global_get([\"server\", \"commands\", \"localPipCommand\"]),\n            force_user=self._settings.get_boolean([\"pip_force_user\"]),\n        )\n        self._pip_caller.on_log_call = self._log_call\n        self._pip_caller.on_log_stdout = self._log_stdout\n        self._pip_caller.on_log_stderr = self._log_stderr\n\n    ##~~ Body size hook\n\n    def increase_upload_bodysize(self, current_max_body_sizes, *args, **kwargs):\n        # set a maximum body size of 50 MB for plugin archive uploads\n        return [(\"POST\", r\"/upload_file\", 50 * 1024 * 1024)]\n\n    # Additional permissions hook\n\n    def get_additional_permissions(self):\n        return [\n            {\n                \"key\": \"LIST\",\n                \"name\": \"List plugins\",\n                \"description\": gettext(\"Allows to list installed plugins.\"),\n                \"default_groups\": [READONLY_GROUP, USER_GROUP, ADMIN_GROUP],\n                \"roles\": [\"manage\"],\n            },\n            {\n                \"key\": \"MANAGE\",\n                \"name\": \"Manage plugins\",\n                \"description\": gettext(\n                    \"Allows to enable, disable and uninstall installed plugins.\"\n                ),\n                \"default_groups\": [ADMIN_GROUP],\n                \"roles\": [\"manage\"],\n            },\n            {\n                \"key\": \"INSTALL\",\n                \"name\": \"Install new plugins\",\n                \"description\": gettext(\n                    'Allows to install new plugins. Includes the \"Manage plugins\" permission.'\n                ),\n                \"default_groups\": [ADMIN_GROUP],\n                \"roles\": [\"install\"],\n                \"permissions\": [\"PLUGIN_PLUGINMANAGER_MANAGE\"],\n                \"dangerous\": True,\n            },\n        ]\n\n    # Additional bundle contents\n\n    def get_additional_bundle_files(self, *args, **kwargs):\n        console_log = self._settings.get_plugin_logfile_path(postfix=\"console\")\n        return {os.path.basename(console_log): console_log}\n\n    ##~~ StartupPlugin\n\n    def on_after_startup(self):\n        from octoprint.logging.handlers import CleaningTimedRotatingFileHandler\n\n        console_logging_handler = CleaningTimedRotatingFileHandler(\n            self._settings.get_plugin_logfile_path(postfix=\"console\"),\n            when=\"D\",\n            backupCount=3,\n        )\n        console_logging_handler.setFormatter(logging.Formatter(\"%(asctime)s %(message)s\"))\n        console_logging_handler.setLevel(logging.DEBUG)\n\n        self._console_logger.addHandler(console_logging_handler)\n        self._console_logger.setLevel(logging.DEBUG)\n        self._console_logger.propagate = False\n\n        helpers = self._plugin_manager.get_helpers(\"pi_support\", \"get_throttled\")\n        if helpers and \"get_throttled\" in helpers:\n            self._get_throttled = helpers[\"get_throttled\"]\n            if self._settings.get_boolean([\"ignore_throttled\"]):\n                self._logger.warning(\n                    \"!!! THROTTLE STATE IGNORED !!! You have configured the Plugin Manager plugin to ignore an active throttle state of the underlying system. You might run into stability issues or outright corrupt your install. Consider fixing the throttling issue instead of suppressing it.\"\n                )\n\n        # decouple repository fetching from server startup\n        self._fetch_all_data(do_async=True)\n\n    ##~~ SettingsPlugin\n\n    def get_settings_defaults(self):\n        return {\n            \"repository\": DEFAULT_PLUGIN_REPOSITORY,\n            \"repository_ttl\": 24 * 60,\n            \"notices\": DEFAULT_PLUGIN_NOTICES,\n            \"notices_ttl\": 6 * 60,\n            \"pip_args\": None,\n            \"pip_force_user\": False,\n            \"confirm_disable\": False,\n            \"dependency_links\": False,\n            \"hidden\": [],\n            \"ignore_throttled\": False,\n        }\n\n    def on_settings_save(self, data):\n        octoprint.plugin.SettingsPlugin.on_settings_save(self, data)\n\n        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60\n        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60\n        self._pip_caller.force_user = self._settings.get_boolean([\"pip_force_user\"])\n        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])\n\n    ##~~ AssetPlugin\n\n    def get_assets(self):\n        return {\n            \"js\": [\"js/pluginmanager.js\"],\n            \"clientjs\": [\"clientjs/pluginmanager.js\"],\n            \"css\": [\"css/pluginmanager.css\"],\n            \"less\": [\"less/pluginmanager.less\"],\n        }\n\n    ##~~ TemplatePlugin\n\n    def get_template_configs(self):\n        return [\n            {\n                \"type\": \"settings\",\n                \"name\": gettext(\"Plugin Manager\"),\n                \"template\": \"pluginmanager_settings.jinja2\",\n                \"custom_bindings\": True,\n            },\n            {\n                \"type\": \"about\",\n                \"name\": \"Plugin Licenses\",\n                \"template\": \"pluginmanager_about.jinja2\",\n            },\n        ]\n\n    def get_template_vars(self):\n        plugins = sorted(self._get_plugins(), key=lambda x: x[\"name\"].lower())\n        return {\n            \"all\": plugins,\n            \"thirdparty\": list(filter(lambda p: not p[\"bundled\"], plugins)),\n            \"file_extensions\": self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,\n        }\n\n    def get_template_types(self, template_sorting, template_rules, *args, **kwargs):\n        return [\n            (\n                \"about_thirdparty\",\n                {},\n                {\"template\": lambda x: x + \"_about_thirdparty.jinja2\"},\n            )\n        ]\n\n    ##~~ BlueprintPlugin\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/upload_file\", methods=[\"POST\"])\n    @no_firstrun_access\n    @Permissions.PLUGIN_PLUGINMANAGER_INSTALL.require(403)\n    def upload_file(self):\n        import flask\n\n        input_name = \"file\"\n        input_upload_path = (\n            input_name\n            + \".\"\n            + self._settings.global_get([\"server\", \"uploads\", \"pathSuffix\"])\n        )\n        input_upload_name = (\n            input_name\n            + \".\"\n            + self._settings.global_get([\"server\", \"uploads\", \"nameSuffix\"])\n        )\n\n        if (\n            input_upload_path not in flask.request.values\n            or input_upload_name not in flask.request.values\n        ):\n            abort(400, description=\"No file included\")\n        upload_path = flask.request.values[input_upload_path]\n        upload_name = flask.request.values[input_upload_name]\n\n        exts = list(\n            filter(\n                lambda x: upload_name.lower().endswith(x),\n                self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,\n            )\n        )\n        if not len(exts):\n            abort(\n                400,\n                description=\"File doesn't have a valid extension for a plugin archive or a single file plugin\",\n            )\n\n        ext = exts[0]\n        archive = tempfile.NamedTemporaryFile(delete=False, suffix=ext)\n        archive.close()\n        shutil.copy(upload_path, archive.name)\n\n        def perform_install(source, name, force=False):\n            try:\n                self.command_install(\n                    path=source,\n                    name=name,\n                    force=force,\n                )\n            finally:\n                try:\n                    os.remove(archive.name)\n                except Exception as e:\n                    self._logger.warning(\n                        \"Could not remove temporary file {path} again: {message}\".format(\n                            path=archive.name, message=str(e)\n                        )\n                    )\n\n        with self._install_lock:\n            if self._install_task is not None:\n                abort(409, description=\"There's already a plugin being installed\")\n\n            self._install_task = threading.Thread(\n                target=perform_install,\n                args=(archive.name, upload_name),\n                kwargs={\n                    \"force\": \"force\" in flask.request.values\n                    and flask.request.values[\"force\"] in valid_boolean_trues\n                },\n            )\n            self._install_task.daemon = True\n            self._install_task.start()\n\n            return jsonify(in_progress=True)\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/export\", methods=[\"GET\"])\n    @no_firstrun_access\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def export_plugin_list(self):\n        import json\n\n        plugins = self.generate_plugins_json(self._settings, self._plugin_manager)\n\n        return Response(\n            json.dumps(plugins),\n            mimetype=\"text/plain\",\n            headers={\"Content-Disposition\": 'attachment; filename=\"plugin_list.json\"'},\n        )\n\n    def _plugin_response(self):\n        return {\n            \"plugins\": self._get_plugins(),\n            \"os\": get_os(),\n            \"octoprint\": get_octoprint_version_string(),\n            \"pip\": {\n                \"available\": self._pip_caller.available,\n                \"version\": self._pip_caller.version_string,\n                \"install_dir\": self._pip_caller.install_dir,\n                \"use_user\": self._pip_caller.use_user,\n                \"virtual_env\": self._pip_caller.virtual_env,\n                \"additional_args\": self._settings.get([\"pip_args\"]),\n                \"python\": sys.executable,\n            },\n            \"safe_mode\": safe_mode,\n            \"online\": self._connectivity_checker.online,\n            \"supported_extensions\": {\n                \"archive\": self.ARCHIVE_EXTENSIONS,\n                \"python\": self.PYTHON_EXTENSIONS,\n            },\n        }\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/plugins\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_plugins(self):\n        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues\n        if refresh or not self._is_notices_cache_valid():\n            self._notices_available = self._refresh_notices()\n\n        def view():\n            return jsonify(**self._plugin_response())\n\n        def etag():\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                value = value.encode(\"utf-8\")\n                hash.update(value)\n\n            hash_update(repr(self._get_plugins()))\n            hash_update(repr(self._pip_caller.version_string))\n            hash_update(str(self._notices_available))\n            hash_update(repr(self._notices))\n            hash_update(repr(safe_mode))\n            hash_update(repr(self._connectivity_checker.online))\n            hash_update(repr(self.ARCHIVE_EXTENSIONS))\n            hash_update(repr(self.PYTHON_EXTENSIONS))\n            hash_update(repr(_DATA_FORMAT_VERSION))\n            return hash.hexdigest()\n\n        def condition():\n            return check_etag(etag())\n\n        return with_revalidation_checking(\n            etag_factory=lambda *args, **kwargs: etag(),\n            condition=lambda *args, **kwargs: condition(),\n            unless=lambda: refresh,\n        )(view)()\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/plugins/versions\")\n    @Permissions.PLUGIN_PLUGINMANAGER_LIST.require(403)\n    def retrieve_plugin_list(self):\n        return jsonify(\n            {p[\"key\"]: p[\"version\"] for p in self._get_plugins() if p[\"enabled\"]}\n        )\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/plugins/<string:key>\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_specific_plugin(self, key):\n        plugin = self._plugin_manager.get_plugin_info(key, require_enabled=False)\n        if plugin is None:\n            return abort(404)\n\n        return jsonify(plugin=self._to_external_plugin(plugin))\n\n    def _orphan_response(self):\n        return {\"orphan_data\": self._get_orphans()}\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/orphans\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_plugin_orphans(self):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues\n        if refresh:\n            self._get_orphans(refresh=True)\n\n        def view():\n            return jsonify(**self._orphan_response())\n\n        def etag():\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                value = value.encode(\"utf-8\")\n                hash.update(value)\n\n            hash_update(repr(self._get_orphans()))\n            hash_update(repr(_DATA_FORMAT_VERSION))\n            return hash.hexdigest()\n\n        def condition():\n            return check_etag(etag())\n\n        return with_revalidation_checking(\n            etag_factory=lambda *args, **kwargs: etag(),\n            condition=lambda *args, **kwargs: condition(),\n            unless=lambda: refresh,\n        )(view)()\n\n    def _repository_response(self):\n        return {\n            \"repository\": {\n                \"available\": self._repository_available,\n                \"plugins\": self._repository_plugins,\n            }\n        }\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/repository\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_plugin_repository(self):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues\n        if refresh or not self._is_repository_cache_valid():\n            self._repository_available = self._refresh_repository()\n\n        def view():\n            return jsonify(**self._repository_response())\n\n        def etag():\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                value = value.encode(\"utf-8\")\n                hash.update(value)\n\n            hash_update(str(self._repository_available))\n            hash_update(repr(self._repository_plugins))\n            hash_update(repr(_DATA_FORMAT_VERSION))\n            return hash.hexdigest()\n\n        def condition():\n            return check_etag(etag())\n\n        return with_revalidation_checking(\n            etag_factory=lambda *args, **kwargs: etag(),\n            condition=lambda *args, **kwargs: condition(),\n            unless=lambda: refresh,\n        )(view)()\n\n    def is_blueprint_protected(self):\n        return False\n\n    ##~~ EventHandlerPlugin\n\n    def on_event(self, event, payload):\n        from octoprint.events import Events\n\n        if (\n            event != Events.CONNECTIVITY_CHANGED\n            or not payload\n            or not payload.get(\"new\", False)\n        ):\n            return\n        self._fetch_all_data(do_async=True)\n\n    ##~~ SimpleApiPlugin\n\n    def get_api_commands(self):\n        return {\n            \"install\": [\"url\"],\n            \"uninstall\": [\"plugin\"],\n            \"enable\": [\"plugin\"],\n            \"disable\": [\"plugin\"],\n            \"cleanup\": [\"plugin\"],\n            \"cleanup_all\": [],\n            \"refresh_repository\": [],\n        }\n\n    def on_api_command(self, command, data):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        if self._printer.is_printing() or self._printer.is_paused():\n            # do not update while a print job is running\n            abort(409, description=\"Printer is currently printing or paused\")\n\n        if command == \"install\":\n            if not Permissions.PLUGIN_PLUGINMANAGER_INSTALL.can():\n                abort(403)\n            url = data[\"url\"]\n            plugin_name = data[\"plugin\"] if \"plugin\" in data else None\n\n            with self._install_lock:\n                if self._install_task is not None:\n                    abort(409, description=\"There's already a plugin being installed\")\n\n                self._install_task = threading.Thread(\n                    target=self.command_install,\n                    kwargs={\n                        \"url\": url,\n                        \"force\": \"force\" in data and data[\"force\"] in valid_boolean_trues,\n                        \"dependency_links\": \"dependency_links\" in data\n                        and data[\"dependency_links\"] in valid_boolean_trues,\n                        \"reinstall\": plugin_name,\n                    },\n                )\n                self._install_task.daemon = True\n                self._install_task.start()\n\n                return jsonify(in_progress=True)\n\n        elif command == \"uninstall\":\n            plugin_name = data[\"plugin\"]\n            if plugin_name not in self._plugin_manager.plugins:\n                abort(404, description=\"Unknown plugin\")\n\n            plugin = self._plugin_manager.plugins[plugin_name]\n            return self.command_uninstall(plugin, cleanup=data.get(\"cleanup\", False))\n\n        elif command == \"cleanup\":\n            plugin = data[\"plugin\"]\n            try:\n                plugin = self._plugin_manager.plugins[plugin]\n            except KeyError:\n                # not installed, we are cleaning up left overs, that's ok\n                pass\n\n            return self.command_cleanup(plugin, include_disabled=True)\n\n        elif command == \"cleanup_all\":\n            return self.command_cleanup_all()\n\n        elif command == \"enable\" or command == \"disable\":\n            plugin_name = data[\"plugin\"]\n            if plugin_name not in self._plugin_manager.plugins:\n                abort(404, description=\"Unknown plugin\")\n\n            plugin = self._plugin_manager.plugins[plugin_name]\n            return self.command_toggle(plugin, command)\n\n    @deprecated(\n        \"Deprecated API endpoint api/plugin/pluginmanager used. \"\n        \"Please switch clients to plugin/pluginmanager/*\",\n        since=\"1.6.0\",\n    )\n    def on_api_get(self, r):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        refresh_repository = (\n            request.values.get(\"refresh_repository\", \"false\") in valid_boolean_trues\n        )\n        if refresh_repository or not self._is_repository_cache_valid():\n            self._repository_available = self._refresh_repository()\n\n        refresh_notices = (\n            request.values.get(\"refresh_notices\", \"false\") in valid_boolean_trues\n        )\n        if refresh_notices or not self._is_notices_cache_valid():\n            self._notices_available = self._refresh_notices()\n\n        refresh_orphan = (\n            request.values.get(\"refresh_orphans\", \"false\") in valid_boolean_trues\n        )\n        if refresh_orphan:\n            self._get_orphans(refresh=True)\n\n        result = {}\n        result.update(**self._plugin_response())\n        result.update(**self._orphan_response())\n        result.update(**self._repository_response())\n        return jsonify(**result)\n\n    # noinspection PyMethodMayBeStatic\n    def _is_archive(self, path):\n        _, ext = os.path.splitext(path)\n        if ext in PluginManagerPlugin.ARCHIVE_EXTENSIONS:\n            return True\n\n        kind = filetype.guess(path)\n        if kind:\n            return f\".{kind.extension}\" in PluginManagerPlugin.ARCHIVE_EXTENSIONS\n        return False\n\n    def _is_pythonfile(self, path):\n        _, ext = os.path.splitext(path)\n        if ext in PluginManagerPlugin.PYTHON_EXTENSIONS:\n            import ast\n\n            try:\n                with open(path, \"rb\") as f:\n                    ast.parse(f.read(), filename=path)\n                return True\n            except Exception as exc:\n                self._logger.exception(f\"Could not parse {path} as python file: {exc}\")\n\n        return False\n\n    def command_install(\n        self,\n        url=None,\n        path=None,\n        name=None,\n        force=False,\n        reinstall=None,\n        dependency_links=False,\n    ):\n        folder = None\n\n        with self._install_lock:\n            try:\n                source = path\n                source_type = \"path\"\n\n                if url is not None:\n                    # fetch URL\n                    folder = tempfile.TemporaryDirectory()\n                    path = download_file(url, folder.name)\n                    source = url\n                    source_type = \"url\"\n\n                # determine type of path\n                if self._is_archive(path):\n                    result = self._command_install_archive(\n                        path,\n                        source=source,\n                        source_type=source_type,\n                        force=force,\n                        reinstall=reinstall,\n                        dependency_links=dependency_links,\n                    )\n\n                elif self._is_pythonfile(path):\n                    result = self._command_install_pythonfile(\n                        path, source=source, source_type=source_type, name=name\n                    )\n\n                else:\n                    raise exceptions.InvalidPackageFormat()\n\n            except requests.exceptions.HTTPError as e:\n                self._logger.error(f\"Could not fetch plugin from server, got {e}\")\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": f\"Could not fetch plugin from server, got {e}\",\n                }\n                self._send_result_notification(\"install\", result)\n\n            except exceptions.InvalidPackageFormat:\n                self._logger.error(\n                    \"{} is neither an archive nor a python file, can't install that.\".format(\n                        source\n                    )\n                )\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": \"Could not install plugin from {}, was neither \"\n                    \"a plugin archive nor a single file plugin\".format(source),\n                }\n                self._send_result_notification(\"install\", result)\n\n            except Exception:\n                error_msg = (\n                    \"Unexpected error while trying to install plugin from {}\".format(\n                        source\n                    )\n                )\n                self._logger.exception(error_msg)\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": error_msg,\n                }\n                self._send_result_notification(\"install\", result)\n\n            finally:\n                if folder is not None:\n                    folder.cleanup()\n                self._install_task = None\n\n        return result\n\n    # noinspection DuplicatedCode\n    def _command_install_archive(\n        self,\n        path,\n        source=None,\n        source_type=None,\n        force=False,\n        reinstall=None,\n        dependency_links=False,\n    ):\n        throttled = self._get_throttled()\n        if (\n            throttled\n            and isinstance(throttled, dict)\n            and throttled.get(\"current_issue\", False)\n            and not self._settings.get_boolean([\"ignore_throttled\"])\n        ):\n            # currently throttled, we refuse to run\n            error_msg = (\n                \"System is currently throttled, refusing to install anything\"\n                \" due to possible stability issues\"\n            )\n            self._logger.error(error_msg)\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": error_msg,\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        from urllib.parse import quote as url_quote\n\n        path = os.path.abspath(path)\n        if os.sep != \"/\":\n            # windows gets special handling\n            drive, loc = os.path.splitdrive(path)\n            path_url = (\n                \"file:///\" + drive.lower() + url_quote(loc.replace(os.sep, \"/\").lower())\n            )\n            shell_quote = lambda x: x  # do not shell quote under windows, non posix shell\n        else:\n            path_url = \"file://\" + url_quote(path)\n            shell_quote = sarge.shell_quote\n\n        self._logger.info(f\"Installing plugin from {source}\")\n        pip_args = [\n            \"--disable-pip-version-check\",\n            \"install\",\n            shell_quote(path_url),\n            \"--no-cache-dir\",\n        ]\n\n        if dependency_links or self._settings.get_boolean([\"dependency_links\"]):\n            pip_args.append(\"--process-dependency-links\")\n\n        all_plugins_before = self._plugin_manager.find_plugins(existing={})\n\n        try:\n            _, stdout, stderr = self._call_pip(pip_args)\n\n            if not force and is_already_installed(stdout):\n                self._logger.info(\n                    \"Plugin to be installed from {} was already installed, forcing a reinstall\".format(\n                        source\n                    )\n                )\n                self._log_message(\n                    \"Looks like the plugin was already installed. Forcing a reinstall.\"\n                )\n                force = True\n        except Exception as e:\n            self._logger.exception(f\"Could not install plugin from {source}\")\n            self._logger.exception(f\"Reason: {repr(e)}\")\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Could not install plugin from {}, see the log for more details\".format(\n                    source\n                ),\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        if is_python_mismatch(stderr):\n            return self.handle_python_mismatch(source, source_type)\n\n        if force:\n            # We don't use --upgrade here because that will also happily update all our dependencies - we'd rather\n            # do that in a controlled manner\n            pip_args += [\"--ignore-installed\", \"--force-reinstall\", \"--no-deps\"]\n            try:\n                _, stdout, stderr = self._call_pip(pip_args)\n            except Exception as e:\n                self._logger.exception(f\"Could not install plugin from {source}\")\n                self._logger.exception(f\"Reason: {repr(e)}\")\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": \"Could not install plugin from source {}, see the log for more details\".format(\n                        source\n                    ),\n                }\n                self._send_result_notification(\"install\", result)\n                return result\n\n            if is_python_mismatch(stderr):\n                return self.handle_python_mismatch(source, source_type)\n\n        result_line = get_result_line(stdout)\n        if not result_line:\n            self._logger.error(\n                \"Installing the plugin from {} failed, could not parse output from pip. \"\n                \"See plugin_pluginmanager_console.log for generated output\".format(source)\n            )\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Could not parse output from pip, see plugin_pluginmanager_console.log \"\n                \"for generated output\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        # We'll need to fetch the \"Successfully installed\" line, strip the \"Successfully\" part, then split\n        # by whitespace and strip to get all installed packages.\n        #\n        # We then need to iterate over all known plugins and see if either the package name or the package name plus\n        # version number matches one of our installed packages. If it does, that's our installed plugin.\n        #\n        # Known issue: This might return the wrong plugin if more than one plugin was installed through this\n        # command (e.g. due to pulling in another plugin as dependency). It should be safe for now though to\n        # consider this a rare corner case. Once it becomes a real problem we'll just extend the plugin manager\n        # so that it can report on more than one installed plugin.\n\n        result_line = result_line.strip()\n        if not result_line.startswith(OUTPUT_SUCCESS):\n            self._logger.error(\n                \"Installing the plugin from {} failed, pip did not report successful installation\".format(\n                    source\n                )\n            )\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Pip did not report successful installation\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        installed = list(\n            map(lambda x: x.strip(), result_line[len(OUTPUT_SUCCESS) :].split(\" \"))\n        )\n        all_plugins_after = self._plugin_manager.find_plugins(\n            existing={}, ignore_uninstalled=False\n        )\n\n        new_plugin = self._find_installed_plugin(installed, plugins=all_plugins_after)\n\n        if new_plugin is None:\n            self._logger.warning(\n                \"The plugin was installed successfully, but couldn't be found afterwards to \"\n                \"initialize properly during runtime. Please restart OctoPrint.\"\n            )\n            result = {\n                \"result\": True,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"needs_restart\": True,\n                \"needs_refresh\": True,\n                \"needs_reconnect\": True,\n                \"was_reinstalled\": False,\n                \"plugin\": \"unknown\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        self._plugin_manager.reload_plugins()\n        needs_restart = (\n            self._plugin_manager.is_restart_needing_plugin(new_plugin)\n            or new_plugin.key in all_plugins_before\n            or reinstall is not None\n        )\n        needs_refresh = new_plugin.implementation and isinstance(\n            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        is_reinstall = self._plugin_manager.is_plugin_marked(\n            new_plugin.key, \"uninstalled\"\n        )\n        self._plugin_manager.mark_plugin(\n            new_plugin.key,\n            uninstalled=False,\n            installed=not is_reinstall and needs_restart,\n        )\n\n        self._plugin_manager.log_all_plugins()\n\n        self._logger.info(\n            \"The plugin was installed successfully: {}, version {}\".format(\n                new_plugin.name, new_plugin.version\n            )\n        )\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,\n            {\n                \"id\": new_plugin.key,\n                \"version\": new_plugin.version,\n                \"source\": source,\n                \"source_type\": source_type,\n            },\n        )\n\n        result = {\n            \"result\": True,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"needs_restart\": needs_restart,\n            \"needs_refresh\": needs_refresh,\n            \"needs_reconnect\": needs_reconnect,\n            \"was_reinstalled\": new_plugin.key in all_plugins_before\n            or reinstall is not None,\n            \"plugin\": self._to_external_plugin(new_plugin),\n        }\n        self._send_result_notification(\"install\", result)\n        return result\n\n    def _handle_python_mismatch(self, source, source_type):\n        self._logger.error(\n            \"Installing the plugin from {} failed, pip reported a Python version mismatch\".format(\n                source\n            )\n        )\n        result = {\n            \"result\": False,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"reason\": \"Pip reported a Python version mismatch\",\n            \"faq\": \"https://faq.octoprint.org/plugin-python-mismatch\",\n        }\n        self._send_result_notification(\"install\", result)\n        return result\n\n    # noinspection DuplicatedCode\n    def _command_install_pythonfile(self, path, source=None, source_type=None, name=None):\n        if name is None:\n            name = os.path.basename(path)\n\n        self._logger.info(f\"Installing single file plugin {name} from {source}\")\n\n        all_plugins_before = self._plugin_manager.find_plugins(existing={})\n\n        destination = os.path.join(self._settings.global_get_basefolder(\"plugins\"), name)\n        plugin_id, _ = os.path.splitext(name)\n\n        # check python compatibility\n        PYTHON_MISMATCH = {\n            \"result\": False,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"reason\": \"Plugin could not be installed\",\n            \"faq\": \"https://faq.octoprint.org/plugin-python-mismatch\",\n        }\n\n        try:\n            metadata = octoprint.plugin.core.parse_plugin_metadata(path)\n        except SyntaxError:\n            self._logger.exception(\n                \"Installing plugin from {} failed, there's a Python version mismatch\".format(\n                    source\n                )\n            )\n            result = PYTHON_MISMATCH\n            self._send_result_notification(\"install\", result)\n            return result\n\n        pythoncompat = metadata.get(\n            octoprint.plugin.core.ControlProperties.attr_pythoncompat,\n            octoprint.plugin.core.ControlProperties.default_pythoncompat,\n        )\n        if not is_python_compatible(pythoncompat):\n            self._logger.exception(\n                \"Installing plugin from {} failed, there's a Python version mismatch\".format(\n                    source\n                )\n            )\n            result = PYTHON_MISMATCH\n            self._send_result_notification(\"install\", result)\n            return result\n\n        # copy plugin\n        try:\n            self._log_call(f\"cp {path} {destination}\")\n            shutil.copy(path, destination)\n        except Exception:\n            self._logger.exception(f\"Installing plugin from {source} failed\")\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Plugin could not be copied\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        plugins = self._plugin_manager.find_plugins(existing={}, ignore_uninstalled=False)\n        new_plugin = plugins.get(plugin_id)\n        if new_plugin is None:\n            self._logger.warning(\n                \"The plugin was installed successfully, but couldn't be found afterwards to \"\n                \"initialize properly during runtime. Please restart OctoPrint.\"\n            )\n            result = {\n                \"result\": True,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"needs_restart\": True,\n                \"needs_refresh\": True,\n                \"needs_reconnect\": True,\n                \"was_reinstalled\": False,\n                \"plugin\": \"unknown\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        self._plugin_manager.reload_plugins()\n        needs_restart = (\n            self._plugin_manager.is_restart_needing_plugin(new_plugin)\n            or new_plugin.key in all_plugins_before\n        )\n        needs_refresh = new_plugin.implementation and isinstance(\n            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        self._logger.info(\n            \"The plugin was installed successfully: {}, version {}\".format(\n                new_plugin.name, new_plugin.version\n            )\n        )\n        self._plugin_manager.log_all_plugins()\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,\n            {\n                \"id\": new_plugin.key,\n                \"version\": new_plugin.version,\n                \"source\": source,\n                \"source_type\": source_type,\n            },\n        )\n\n        result = {\n            \"result\": True,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"needs_restart\": needs_restart,\n            \"needs_refresh\": needs_refresh,\n            \"needs_reconnect\": needs_reconnect,\n            \"was_reinstalled\": new_plugin.key in all_plugins_before,\n            \"plugin\": self._to_external_plugin(new_plugin),\n        }\n        self._send_result_notification(\"install\", result)\n        return result\n\n    def command_uninstall(self, plugin, cleanup=False):\n        if plugin.key == \"pluginmanager\":\n            abort(403, description=\"Can't uninstall Plugin Manager\")\n\n        if not plugin.managable:\n            abort(\n                403, description=\"Plugin is not managable and hence cannot be uninstalled\"\n            )\n\n        if plugin.bundled:\n            abort(403, description=\"Bundled plugins cannot be uninstalled\")\n\n        if plugin.origin is None:\n            self._logger.warning(\n                f\"Trying to uninstall plugin {plugin} but origin is unknown\"\n            )\n            abort(500, description=\"Could not uninstall plugin, its origin is unknown\")\n\n        if plugin.implementation:\n            try:\n                plugin.implementation.on_plugin_pending_uninstall()\n            except Exception:\n                self._logger.exception(\n                    \"Error while calling on_plugin_pending_uninstall on the plugin, proceeding regardless\"\n                )\n\n        if plugin.origin.type == \"entry_point\":\n            # plugin is installed through entry point, need to use pip to uninstall it\n            origin = plugin.origin[3]\n            if origin is None:\n                origin = plugin.origin[2]\n\n            pip_args = [\"--disable-pip-version-check\", \"uninstall\", \"--yes\", origin]\n            try:\n                self._call_pip(pip_args)\n            except Exception:\n                self._logger.exception(\"Could not uninstall plugin via pip\")\n                abort(\n                    500,\n                    description=\"Could not uninstall plugin via pip, see the log for more details\",\n                )\n\n        elif plugin.origin.type == \"folder\":\n            import os\n            import shutil\n\n            full_path = os.path.realpath(plugin.location)\n\n            if os.path.isdir(full_path):\n                # plugin is installed via a plugin folder, need to use rmtree to get rid of it\n                self._log_stdout(f\"Deleting plugin from {plugin.location}\")\n                shutil.rmtree(full_path)\n            elif os.path.isfile(full_path):\n                self._log_stdout(f\"Deleting plugin from {plugin.location}\")\n                os.remove(full_path)\n\n                if full_path.endswith(\".py\"):\n                    pyc_file = f\"{full_path}c\"\n                    if os.path.isfile(pyc_file):\n                        self._log_stdout(f\"Deleting plugin from {pyc_file}\")\n                        os.remove(pyc_file)\n\n        else:\n            self._logger.warning(\n                f\"Trying to uninstall plugin {plugin} but origin is unknown ({plugin.origin.type})\"\n            )\n            abort(500, description=\"Could not uninstall plugin, its origin is unknown\")\n\n        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin) or cleanup\n        needs_refresh = plugin.implementation and isinstance(\n            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        was_pending_install = self._plugin_manager.is_plugin_marked(\n            plugin.key, \"installed\"\n        )\n        self._plugin_manager.mark_plugin(\n            plugin.key,\n            uninstalled=not was_pending_install and needs_restart,\n            installed=False,\n        )\n\n        if not needs_restart:\n            try:\n                if plugin.enabled:\n                    self._plugin_manager.disable_plugin(plugin.key, plugin=plugin)\n            except octoprint.plugin.core.PluginLifecycleException as e:\n                self._logger.exception(f\"Problem disabling plugin {plugin.key}\")\n                result = {\n                    \"result\": False,\n                    \"uninstalled\": True,\n                    \"disabled\": False,\n                    \"unloaded\": False,\n                    \"reason\": e.reason,\n                }\n                self._send_result_notification(\"uninstall\", result)\n                return jsonify(result)\n\n            try:\n                if plugin.loaded:\n                    self._plugin_manager.unload_plugin(plugin.key)\n            except octoprint.plugin.core.PluginLifecycleException as e:\n                self._logger.exception(f\"Problem unloading plugin {plugin.key}\")\n                result = {\n                    \"result\": False,\n                    \"uninstalled\": True,\n                    \"disabled\": True,\n                    \"unloaded\": False,\n                    \"reason\": e.reason,\n                }\n                self._send_result_notification(\"uninstall\", result)\n                return jsonify(result)\n\n        self._plugin_manager.reload_plugins()\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_UNINSTALL_PLUGIN,\n            {\"id\": plugin.key, \"version\": plugin.version},\n        )\n\n        result = {\n            \"result\": True,\n            \"needs_restart\": needs_restart,\n            \"needs_refresh\": needs_refresh,\n            \"needs_reconnect\": needs_reconnect,\n            \"plugin\": self._to_external_plugin(plugin),\n        }\n        self._send_result_notification(\"uninstall\", result)\n        self._logger.info(f\"Plugin {plugin.key} uninstalled\")\n\n        self._cleanup_disabled(plugin.key)\n        if cleanup:\n            self.command_cleanup(plugin.key, result_notifications=False)\n\n        return jsonify(result)\n\n    def command_cleanup(\n        self,\n        plugin,\n        include_disabled=False,\n        result_notifications=True,\n        settings_save=True,\n    ):\n        if isinstance(plugin, str):\n            key = result_value = plugin\n        else:\n            key = plugin.key\n            result_value = self._to_external_plugin(plugin)\n\n        message = f\"Cleaning up plugin {key}...\"\n        self._logger.info(message)\n        self._log_stdout(message)\n\n        # delete plugin settings\n        self._cleanup_settings(key)\n\n        # delete plugin disabled entry\n        if include_disabled:\n            self._cleanup_disabled(key)\n\n        # delete plugin data folder\n        result_data = True\n        if not self._cleanup_data(key):\n            message = f\"Could not delete data folder of plugin {key}\"\n            self._logger.exception(message)\n            self._log_stderr(message)\n            result_data = False\n\n        if settings_save:\n            self._settings.save()\n\n        result = {\"result\": result_data, \"needs_restart\": True, \"plugin\": result_value}\n        if result_notifications:\n            self._send_result_notification(\"cleanup\", result)\n\n        # cleaning orphan cache\n        self._orphans = None\n\n        return jsonify(result)\n\n    def command_cleanup_all(self):\n        orphans = self._get_orphans()\n        cleaned_up = set()\n\n        for orphan in sorted(orphans.keys()):\n            self.command_cleanup(\n                orphan,\n                include_disabled=True,\n                result_notifications=False,\n                settings_save=False,\n            )\n            cleaned_up.add(orphan)\n\n        self._settings.save()\n\n        result = {\n            \"result\": True,\n            \"needs_restart\": len(cleaned_up) > 0,\n            \"cleaned_up\": sorted(list(cleaned_up)),\n        }\n        self._send_result_notification(\"cleanup_all\", result)\n        self._logger.info(f\"Cleaned up all data, {len(cleaned_up)} left overs removed\")\n\n        # cleaning orphan cache\n        self._orphans = None\n\n        return jsonify(result)\n\n    def _cleanup_disabled(self, plugin):\n        # delete from disabled list\n        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])\n        try:\n            disabled.remove(plugin)\n        except ValueError:\n            # not in list, ok\n            pass\n        self._settings.global_set([\"plugins\", \"_disabled\"], disabled)\n\n    def _cleanup_settings(self, plugin):\n        # delete plugin settings\n        self._settings.global_remove([\"plugins\", plugin])\n        self._settings.global_remove([\"server\", \"seenWizards\", plugin])\n        return True\n\n    def _cleanup_data(self, plugin):\n        import os\n        import shutil\n\n        data_folder = os.path.join(self._settings.getBaseFolder(\"data\"), plugin)\n        if os.path.exists(data_folder):\n            try:\n                shutil.rmtree(data_folder)\n                return True\n            except Exception:\n                self._logger.exception(\n                    f\"Could not delete plugin data folder at {data_folder}\"\n                )\n                return False\n        else:\n            return True\n\n    def command_toggle(self, plugin, command):\n        if plugin.key == \"pluginmanager\" or (plugin.hidden and plugin.bundled):\n            abort(400, description=\"Can't enable/disable Plugin Manager\")\n\n        pending = (command == \"disable\" and plugin.key in self._pending_enable) or (\n            command == \"enable\" and plugin.key in self._pending_disable\n        )\n        safe_mode_victim = getattr(plugin, \"safe_mode_victim\", False)\n\n        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin)\n        needs_refresh = plugin.implementation and isinstance(\n            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        needs_restart_api = (\n            needs_restart or safe_mode_victim or plugin.forced_disabled\n        ) and not pending\n        needs_refresh_api = needs_refresh and not pending\n        needs_reconnect_api = needs_reconnect and not pending\n\n        try:\n            if command == \"disable\":\n                self._mark_plugin_disabled(plugin, needs_restart=needs_restart)\n            elif command == \"enable\":\n                self._mark_plugin_enabled(plugin, needs_restart=needs_restart)\n        except octoprint.plugin.core.PluginLifecycleException as e:\n            self._logger.exception(\n                \"Problem toggling enabled state of {name}: {reason}\".format(\n                    name=plugin.key, reason=e.reason\n                )\n            )\n            result = {\"result\": False, \"reason\": e.reason}\n        except octoprint.plugin.core.PluginNeedsRestart:\n            result = {\n                \"result\": True,\n                \"needs_restart\": True,\n                \"needs_refresh\": True,\n                \"needs_reconnect\": True,\n                \"plugin\": self._to_external_plugin(plugin),\n            }\n        else:\n            result = {\n                \"result\": True,\n                \"needs_restart\": needs_restart_api,\n                \"needs_refresh\": needs_refresh_api,\n                \"needs_reconnect\": needs_reconnect_api,\n                \"plugin\": self._to_external_plugin(plugin),\n            }\n\n        self._send_result_notification(command, result)\n        return jsonify(result)\n\n    def _find_installed_plugin(self, packages, plugins=None):\n        if plugins is None:\n            plugins = self._plugin_manager.find_plugins(\n                existing={}, ignore_uninstalled=False\n            )\n\n        for plugin in plugins.values():\n            if plugin.origin is None or plugin.origin.type != \"entry_point\":\n                continue\n\n            package_name = plugin.origin.package_name\n            package_version = plugin.origin.package_version\n            versioned_package = f\"{package_name}-{package_version}\"\n\n            if package_name in packages or versioned_package in packages:\n                # exact match, we are done here\n                return plugin\n\n            else:\n                # it might still be a version that got stripped by python's package resources, e.g. 1.4.5a0 => 1.4.5a\n                found = False\n\n                for inst in packages:\n                    if inst.startswith(versioned_package):\n                        found = True\n                        break\n\n                if found:\n                    return plugin\n\n        return None\n\n    def _send_result_notification(self, action, result):\n        notification = {\"type\": \"result\", \"action\": action}\n        notification.update(result)\n        self._plugin_manager.send_plugin_message(self._identifier, notification)\n\n    def _call_pip(self, args):\n        if self._pip_caller is None or not self._pip_caller.available:\n            raise RuntimeError(\"No pip available, can't operate\")\n\n        if \"--process-dependency-links\" in args:\n            self._log_message(\n                \"Installation needs to process external dependencies, that might make it take a bit longer than usual depending on the pip version\"\n            )\n\n        additional_args = self._settings.get([\"pip_args\"])\n\n        if additional_args is not None:\n\n            inapplicable_arguments = self.__class__.PIP_INAPPLICABLE_ARGUMENTS.get(\n                args[0], list()\n            )\n            for inapplicable_argument in inapplicable_arguments:\n                additional_args = re.sub(\n                    r\"(^|\\s)\" + re.escape(inapplicable_argument) + r\"\\\\b\",\n                    \"\",\n                    additional_args,\n                )\n\n            if additional_args:\n                args.append(additional_args)\n\n        kwargs = {\n            \"env\": {\n                \"PYTHONWARNINGS\": \"ignore:DEPRECATION::pip._internal.cli.base_command\"\n            }\n        }\n\n        return self._pip_caller.execute(*args, **kwargs)\n\n    def _log_message(self, *lines):\n        self._log(lines, prefix=\"*\", stream=\"message\")\n\n    def _log_call(self, *lines):\n        self._log(lines, prefix=\" \", stream=\"call\")\n\n    def _log_stdout(self, *lines):\n        self._log(lines, prefix=\">\", stream=\"stdout\")\n\n    def _log_stderr(self, *lines):\n        self._log(lines, prefix=\"!\", stream=\"stderr\")\n\n    def _log(self, lines, prefix=None, stream=None, strip=True):\n        if strip:\n            lines = list(map(lambda x: x.strip(), lines))\n\n        self._plugin_manager.send_plugin_message(\n            self._identifier,\n            {\n                \"type\": \"loglines\",\n                \"loglines\": [{\"line\": line, \"stream\": stream} for line in lines],\n            },\n        )\n        for line in lines:  # noqa: B007\n            self._console_logger.debug(f\"{prefix} {line}\")\n\n    def _mark_plugin_enabled(self, plugin, needs_restart=False):\n        disabled_list = list(\n            self._settings.global_get(\n                [\"plugins\", \"_disabled\"],\n                validator=lambda x: isinstance(x, list),\n                fallback=[],\n            )\n        )\n        if plugin.key in disabled_list:\n            disabled_list.remove(plugin.key)\n            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)\n            self._settings.save(force=True)\n\n        if (\n            not needs_restart\n            and not plugin.forced_disabled\n            and not getattr(plugin, \"safe_mode_victim\", False)\n        ):\n            self._plugin_manager.enable_plugin(plugin.key)\n        else:\n            if plugin.key in self._pending_disable:\n                self._pending_disable.remove(plugin.key)\n            elif not plugin.enabled and plugin.key not in self._pending_enable:\n                self._pending_enable.add(plugin.key)\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_ENABLE_PLUGIN,\n            {\"id\": plugin.key, \"version\": plugin.version},\n        )\n\n    def _mark_plugin_disabled(self, plugin, needs_restart=False):\n        disabled_list = list(\n            self._settings.global_get(\n                [\"plugins\", \"_disabled\"],\n                validator=lambda x: isinstance(x, list),\n                fallback=[],\n            )\n        )\n        if plugin.key not in disabled_list:\n            disabled_list.append(plugin.key)\n            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)\n            self._settings.save(force=True)\n\n        if (\n            not needs_restart\n            and not plugin.forced_disabled\n            and not getattr(plugin, \"safe_mode_victim\", False)\n        ):\n            self._plugin_manager.disable_plugin(plugin.key)\n        else:\n            if plugin.key in self._pending_enable:\n                self._pending_enable.remove(plugin.key)\n            elif (\n                plugin.enabled\n                or plugin.forced_disabled\n                or getattr(plugin, \"safe_mode_victim\", False)\n            ) and plugin.key not in self._pending_disable:\n                self._pending_disable.add(plugin.key)\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_DISABLE_PLUGIN,\n            {\"id\": plugin.key, \"version\": plugin.version},\n        )\n\n    def _fetch_all_data(self, do_async=False):\n        def run():\n            self._repository_available = self._fetch_repository_from_disk()\n            self._notices_available = self._fetch_notices_from_disk()\n\n        if do_async:\n            thread = threading.Thread(target=run)\n            thread.daemon = True\n            thread.start()\n        else:\n            run()\n\n    def _is_repository_cache_valid(self, mtime=None):\n        import time\n\n        if mtime is None:\n            mtime = self._repository_mtime\n        if mtime is None:\n            return False\n        return mtime + self._repository_cache_ttl >= time.time() > mtime\n\n    def _fetch_repository_from_disk(self):\n        repo_data = None\n        if os.path.isfile(self._repository_cache_path):\n            mtime = os.path.getmtime(self._repository_cache_path)\n            if self._is_repository_cache_valid(mtime=mtime):\n                try:\n                    import json\n\n                    with open(self._repository_cache_path, encoding=\"utf-8\") as f:\n                        repo_data = json.load(f)\n                    self._repository_mtime = mtime\n                    self._logger.info(\n                        \"Loaded plugin repository data from disk, was still valid\"\n                    )\n                except Exception:\n                    self._logger.exception(\n                        \"Error while loading repository data from {}\".format(\n                            self._repository_cache_path\n                        )\n                    )\n\n        return self._refresh_repository(repo_data=repo_data)\n\n    def _fetch_repository_from_url(self):\n        if not self._connectivity_checker.online:\n            self._logger.info(\n                \"Looks like we are offline, can't fetch repository from network\"\n            )\n            return None\n\n        repository_url = self._settings.get([\"repository\"])\n        try:\n            r = requests.get(repository_url, timeout=30)\n            r.raise_for_status()\n            self._logger.info(f\"Loaded plugin repository data from {repository_url}\")\n        except Exception as e:\n            self._logger.exception(\n                \"Could not fetch plugins from repository at {repository_url}: {message}\".format(\n                    repository_url=repository_url, message=e\n                )\n            )\n            return None\n\n        try:\n            repo_data = r.json()\n        except Exception as e:\n            self._logger.exception(f\"Error while reading repository data: {e}\")\n            return None\n\n        # validation\n        if not isinstance(repo_data, (list, tuple)):\n            self._logger.warning(\n                f\"Invalid repository data: expected a list, got {repo_data!r}\"\n            )\n            return None\n\n        try:\n            import json\n\n            with octoprint.util.atomic_write(self._repository_cache_path, mode=\"wb\") as f:\n                f.write(to_bytes(json.dumps(repo_data)))\n            self._repository_mtime = os.path.getmtime(self._repository_cache_path)\n        except Exception as e:\n            self._logger.exception(\n                \"Error while saving repository data to {}: {}\".format(\n                    self._repository_cache_path, e\n                )\n            )\n\n        return repo_data\n\n    def _refresh_repository(self, repo_data=None):\n        if repo_data is None:\n            repo_data = self._fetch_repository_from_url()\n            if repo_data is None:\n                return False\n\n        self._repository_plugins = list(\n            filter(lambda x: x is not None, map(map_repository_entry, repo_data))\n        )\n        return True\n\n    def _is_notices_cache_valid(self, mtime=None):\n        import time\n\n        if mtime is None:\n            mtime = self._notices_mtime\n        if mtime is None:\n            return False\n        return mtime + self._notices_cache_ttl >= time.time() > mtime\n\n    def _fetch_notices_from_disk(self):\n        notice_data = None\n        if os.path.isfile(self._notices_cache_path):\n            mtime = os.path.getmtime(self._notices_cache_path)\n            if self._is_notices_cache_valid(mtime=mtime):\n                try:\n                    import json\n\n                    with open(self._notices_cache_path, encoding=\"utf-8\") as f:\n                        notice_data = json.load(f)\n                    self._notices_mtime = mtime\n                    self._logger.info(\"Loaded notice data from disk, was still valid\")\n                except Exception:\n                    self._logger.exception(\n                        \"Error while loading notices from {}\".format(\n                            self._notices_cache_path\n                        )\n                    )\n\n        return self._refresh_notices(notice_data=notice_data)\n\n    def _fetch_notices_from_url(self):\n        if not self._connectivity_checker.online:\n            self._logger.info(\n                \"Looks like we are offline, can't fetch notices from network\"\n            )\n            return None\n\n        notices_url = self._settings.get([\"notices\"])\n        try:\n            r = requests.get(notices_url, timeout=30)\n            r.raise_for_status()\n            self._logger.info(f\"Loaded plugin notices data from {notices_url}\")\n        except Exception as e:\n            self._logger.exception(\n                \"Could not fetch notices from {notices_url}: {message}\".format(\n                    notices_url=notices_url, message=str(e)\n                )\n            )\n            return None\n\n        notice_data = r.json()\n\n        try:\n            import json\n\n            with octoprint.util.atomic_write(self._notices_cache_path, mode=\"wb\") as f:\n                f.write(to_bytes(json.dumps(notice_data)))\n            self._notices_mtime = os.path.getmtime(self._notices_cache_path)\n        except Exception as e:\n            self._logger.exception(\n                \"Error while saving notices to {}: {}\".format(\n                    self._notices_cache_path, str(e)\n                )\n            )\n        return notice_data\n\n    def _refresh_notices(self, notice_data=None):\n        if notice_data is None:\n            notice_data = self._fetch_notices_from_url()\n            if notice_data is None:\n                return False\n\n        notices = {}\n        for notice in notice_data:\n            if \"plugin\" not in notice or \"text\" not in notice or \"date\" not in notice:\n                continue\n\n            key = notice[\"plugin\"]\n\n            try:\n                # Jekyll turns \"%Y-%m-%d %H:%M:%SZ\" into \"%Y-%m-%d %H:%M:%S +0000\", so be sure to ignore \"+0000\"\n                #\n                # Being able to use dateutil here would make things way easier but sadly that can no longer get\n                # installed (from source) under OctoPi 0.14 due to its setuptools-scm dependency, so we have to do\n                # without it for now until we can drop support for OctoPi 0.14.\n                parsed_date = datetime.strptime(notice[\"date\"], \"%Y-%m-%d %H:%M:%S +0000\")\n                notice[\"timestamp\"] = parsed_date.timetuple()\n            except Exception as e:\n                self._logger.warning(\n                    \"Error while parsing date {!r} for plugin notice \"\n                    \"of plugin {}, ignoring notice: {}\".format(\n                        notice[\"date\"], key, str(e)\n                    )\n                )\n                continue\n\n            if key not in notices:\n                notices[key] = []\n            notices[key].append(notice)\n\n        self._notices = notices\n        return True\n\n    def _get_orphans(self, refresh=False):\n        from collections import defaultdict\n\n        if self._orphans is not None and not refresh:\n            return self._orphans\n\n        installed_keys = self._plugin_manager.plugins.keys()\n        orphans = defaultdict(\n            lambda: {\"settings\": False, \"data\": False, \"disabled\": False}\n        )\n\n        # settings\n        for key in list(self._settings.global_get([\"plugins\"]).keys()):\n            if key.startswith(\"_\"):\n                # internal key, like _disabled\n                continue\n\n            if key not in installed_keys:\n                orphans[key][\"settings\"] = True\n\n        # data\n        for entry in os.scandir(self._settings.getBaseFolder(\"data\")):\n            if not entry.is_dir():\n                continue\n\n            if entry.name not in installed_keys:\n                orphans[entry.name][\"data\"] = True\n\n        # disabled\n        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])\n        for key in disabled:\n            if key not in installed_keys:\n                orphans[key][\"disabled\"] = True\n\n        self._orphans = dict(**orphans)\n        return self._orphans\n\n    @property\n    def _reconnect_hooks(self):\n        reconnect_hooks = self.__class__.RECONNECT_HOOKS\n\n        reconnect_hook_provider_hooks = self._plugin_manager.get_hooks(\n            \"octoprint.plugin.pluginmanager.reconnect_hooks\"\n        )\n        for name, hook in reconnect_hook_provider_hooks.items():\n            try:\n                result = hook()\n                if isinstance(result, (list, tuple)):\n                    reconnect_hooks.extend(filter(lambda x: isinstance(x, str), result))\n            except Exception:\n                self._logger.exception(\n                    f\"Error while retrieving additional hooks for which a \"\n                    f\"reconnect is required from plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        return reconnect_hooks\n\n    def _get_plugins(self):\n        plugins = self._plugin_manager.plugins\n\n        hidden = self._settings.get([\"hidden\"])\n        result = []\n        for key, plugin in plugins.items():\n            if key in hidden or (plugin.bundled and plugin.hidden):\n                continue\n            result.append(self._to_external_plugin(plugin))\n\n        return result\n\n    @staticmethod\n    def generate_plugins_json(\n        settings, plugin_manager, ignore_bundled=True, ignore_plugins_folder=True\n    ):\n        plugins = []\n        plugin_folder = settings.getBaseFolder(\"plugins\")\n        for plugin in plugin_manager.plugins.values():\n            if (ignore_bundled and plugin.bundled) or (\n                ignore_plugins_folder\n                and isinstance(plugin.origin, octoprint.plugin.core.FolderOrigin)\n                and plugin.origin.folder == plugin_folder\n            ):\n                # ignore bundled or from the plugins folder already included in the backup\n                continue\n\n            plugins.append({\"key\": plugin.key, \"name\": plugin.name, \"url\": plugin.url})\n        return plugins\n\n    def _to_external_plugin(self, plugin):\n        return {\n            \"key\": plugin.key,\n            \"name\": plugin.name,\n            \"description\": plugin.description,\n            \"disabling_discouraged\": gettext(plugin.disabling_discouraged)\n            if plugin.disabling_discouraged\n            else False,\n            \"author\": plugin.author,\n            \"version\": plugin.version,\n            \"url\": plugin.url,\n            \"license\": plugin.license,\n            \"python\": plugin.pythoncompat,\n            \"bundled\": plugin.bundled,\n            \"managable\": plugin.managable,\n            \"enabled\": plugin.enabled,\n            \"blacklisted\": plugin.blacklisted,\n            \"forced_disabled\": plugin.forced_disabled,\n            \"incompatible\": plugin.incompatible,\n            \"safe_mode_victim\": getattr(plugin, \"safe_mode_victim\", False),\n            \"pending_enable\": (\n                not plugin.enabled\n                and not getattr(plugin, \"safe_mode_victim\", False)\n                and plugin.key in self._pending_enable\n            ),\n            \"pending_disable\": (\n                (plugin.enabled or getattr(plugin, \"safe_mode_victim\", False))\n                and plugin.key in self._pending_disable\n            ),\n            \"pending_install\": (\n                self._plugin_manager.is_plugin_marked(plugin.key, \"installed\")\n            ),\n            \"pending_uninstall\": (\n                self._plugin_manager.is_plugin_marked(plugin.key, \"uninstalled\")\n            ),\n            \"origin\": plugin.origin.type,\n            \"notifications\": self._get_notifications(plugin),\n        }\n\n    def _get_notifications(self, plugin):\n        key = plugin.key\n        if not plugin.enabled:\n            return\n\n        if key not in self._notices:\n            return\n\n        octoprint_version = get_octoprint_version(base=True)\n        plugin_notifications = self._notices.get(key, [])\n\n        def map_notification(notification):\n            return self._to_external_notification(key, notification)\n\n        return list(\n            filter(\n                lambda x: x is not None,\n                map(\n                    map_notification,\n                    filter(\n                        lambda n: _filter_relevant_notification(\n                            n, plugin.version, octoprint_version\n                        ),\n                        plugin_notifications,\n                    ),\n                ),\n            )\n        )\n\n    def _to_external_notification(self, key, notification):\n        return {\n            \"key\": key,\n            \"date\": time.mktime(notification[\"timestamp\"]),\n            \"text\": notification[\"text\"],\n            \"link\": notification.get(\"link\"),\n            \"versions\": notification.get(\n                \"pluginversions\", notification.get(\"versions\", [])\n            ),\n            \"important\": notification.get(\"important\", False),\n        }\n\n\n@pylru.lrudecorator(size=127)\ndef parse_requirement(line):\n    return pkg_resources.Requirement.parse(line)\n\n\ndef _filter_relevant_notification(notification, plugin_version, octoprint_version):\n    if \"pluginversions\" in notification:\n        pluginversions = notification[\"pluginversions\"]\n\n        is_range = lambda x: \"=\" in x or \">\" in x or \"<\" in x\n        version_ranges = list(\n            map(\n                lambda x: parse_requirement(notification[\"plugin\"] + x),\n                filter(is_range, pluginversions),\n            )\n        )\n        versions = list(filter(lambda x: not is_range(x), pluginversions))\n    elif \"versions\" in notification:\n        version_ranges = []\n        versions = notification[\"versions\"]\n    else:\n        version_ranges = versions = None\n\n    return (\n        \"text\" in notification\n        and \"date\" in notification\n        and (\n            (version_ranges is None and versions is None)\n            or (\n                version_ranges\n                and (any(map(lambda v: plugin_version in v, version_ranges)))\n            )\n            or (versions and plugin_version in versions)\n        )\n        and (\n            \"octoversions\" not in notification\n            or is_octoprint_compatible(\n                *notification[\"octoversions\"], octoprint_version=octoprint_version\n            )\n        )\n    )\n\n\ndef _register_custom_events(*args, **kwargs):\n    return [\"install_plugin\", \"uninstall_plugin\", \"enable_plugin\", \"disable_plugin\"]\n\n\n__plugin_name__ = \"Plugin Manager\"\n__plugin_author__ = \"Gina H\u00e4u\u00dfge\"\n__plugin_url__ = \"https://docs.octoprint.org/en/master/bundledplugins/pluginmanager.html\"\n__plugin_description__ = \"Allows installing and managing OctoPrint plugins\"\n__plugin_license__ = \"AGPLv3\"\n__plugin_pythoncompat__ = \">=3.7,<4\"\n__plugin_hidden__ = True\n\n\ndef __plugin_load__():\n    global __plugin_implementation__\n    __plugin_implementation__ = PluginManagerPlugin()\n\n    global __plugin_hooks__\n    __plugin_hooks__ = {\n        \"octoprint.server.http.bodysize\": __plugin_implementation__.increase_upload_bodysize,\n        \"octoprint.ui.web.templatetypes\": __plugin_implementation__.get_template_types,\n        \"octoprint.events.register_custom_events\": _register_custom_events,\n        \"octoprint.access.permissions\": __plugin_implementation__.get_additional_permissions,\n        \"octoprint.systeminfo.additional_bundle_files\": __plugin_implementation__.get_additional_bundle_files,\n    }\n\n    global __plugin_helpers__\n    __plugin_helpers__ = {\n        \"generate_plugins_json\": __plugin_implementation__.generate_plugins_json,\n    }\n"], "fixing_code": ["__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport copy\nimport logging\nimport os\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nfrom datetime import datetime\n\nimport filetype\nimport pkg_resources\nimport pylru\nimport requests\nimport sarge\nfrom flask import Response, abort, jsonify, request\nfrom flask_babel import gettext\n\nimport octoprint.plugin\nimport octoprint.plugin.core\nfrom octoprint.access import ADMIN_GROUP, READONLY_GROUP, USER_GROUP\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.events import Events\nfrom octoprint.server import safe_mode\nfrom octoprint.server.util.flask import (\n    check_etag,\n    no_firstrun_access,\n    with_revalidation_checking,\n)\nfrom octoprint.settings import valid_boolean_trues\nfrom octoprint.util import deprecated, to_bytes\nfrom octoprint.util.net import download_file\nfrom octoprint.util.pip import (\n    OUTPUT_SUCCESS,\n    create_pip_caller,\n    get_result_line,\n    is_already_installed,\n    is_python_mismatch,\n)\nfrom octoprint.util.platform import get_os, is_os_compatible\nfrom octoprint.util.version import (\n    get_octoprint_version,\n    get_octoprint_version_string,\n    is_octoprint_compatible,\n    is_python_compatible,\n)\n\nfrom . import exceptions\n\n_DATA_FORMAT_VERSION = \"v3\"\n\nDEFAULT_PLUGIN_REPOSITORY = \"https://plugins.octoprint.org/plugins.json\"\nDEFAULT_PLUGIN_NOTICES = \"https://plugins.octoprint.org/notices.json\"\n\n\ndef map_repository_entry(entry):\n    if not isinstance(entry, dict):\n        return None\n\n    result = copy.deepcopy(entry)\n\n    if \"follow_dependency_links\" not in result:\n        result[\"follow_dependency_links\"] = False\n\n    result[\"is_compatible\"] = {\"octoprint\": True, \"os\": True, \"python\": True}\n\n    if \"compatibility\" in entry:\n        if (\n            \"octoprint\" in entry[\"compatibility\"]\n            and entry[\"compatibility\"][\"octoprint\"] is not None\n            and isinstance(entry[\"compatibility\"][\"octoprint\"], (list, tuple))\n            and len(entry[\"compatibility\"][\"octoprint\"])\n        ):\n            result[\"is_compatible\"][\"octoprint\"] = is_octoprint_compatible(\n                *entry[\"compatibility\"][\"octoprint\"]\n            )\n\n        if (\n            \"os\" in entry[\"compatibility\"]\n            and entry[\"compatibility\"][\"os\"] is not None\n            and isinstance(entry[\"compatibility\"][\"os\"], (list, tuple))\n            and len(entry[\"compatibility\"][\"os\"])\n        ):\n            result[\"is_compatible\"][\"os\"] = is_os_compatible(entry[\"compatibility\"][\"os\"])\n\n        if (\n            \"python\" in entry[\"compatibility\"]\n            and entry[\"compatibility\"][\"python\"] is not None\n            and isinstance(entry[\"compatibility\"][\"python\"], str)\n        ):\n            result[\"is_compatible\"][\"python\"] = is_python_compatible(\n                entry[\"compatibility\"][\"python\"]\n            )\n        else:\n            # we default to only assume py2 compatiblity for now\n            result[\"is_compatible\"][\"python\"] = is_python_compatible(\">=2.7,<3\")\n\n    return result\n\n\nalready_installed_string = \"Requirement already satisfied (use --upgrade to upgrade)\"\nsuccess_string = \"Successfully installed\"\nfailure_string = \"Could not install\"\npython_mismatch_string = \"requires a different Python:\"\n\n\nclass PluginManagerPlugin(\n    octoprint.plugin.SimpleApiPlugin,\n    octoprint.plugin.TemplatePlugin,\n    octoprint.plugin.AssetPlugin,\n    octoprint.plugin.SettingsPlugin,\n    octoprint.plugin.StartupPlugin,\n    octoprint.plugin.BlueprintPlugin,\n    octoprint.plugin.EventHandlerPlugin,\n):\n\n    ARCHIVE_EXTENSIONS = (\".zip\", \".tar.gz\", \".tgz\", \".tar\", \".gz\", \".whl\")\n    PYTHON_EXTENSIONS = (\".py\",)\n\n    # valid pip install URL schemes according to https://pip.pypa.io/en/stable/reference/pip_install/\n    URL_SCHEMES = (\n        \"http\",\n        \"https\",\n        \"git\",\n        \"git+http\",\n        \"git+https\",\n        \"git+ssh\",\n        \"git+git\",\n        \"hg+http\",\n        \"hg+https\",\n        \"hg+static-http\",\n        \"hg+ssh\",\n        \"svn\",\n        \"svn+svn\",\n        \"svn+http\",\n        \"svn+https\",\n        \"svn+ssh\",\n        \"bzr+http\",\n        \"bzr+https\",\n        \"bzr+ssh\",\n        \"bzr+sftp\",\n        \"bzr+ftp\",\n        \"bzr+lp\",\n    )\n\n    OPERATING_SYSTEMS = {\n        \"windows\": [\"win32\"],\n        \"linux\": lambda x: x.startswith(\"linux\"),\n        \"macos\": [\"darwin\"],\n        \"freebsd\": lambda x: x.startswith(\"freebsd\"),\n    }\n\n    PIP_INAPPLICABLE_ARGUMENTS = {\"uninstall\": [\"--user\"]}\n\n    RECONNECT_HOOKS = [\n        \"octoprint.comm.protocol.*\",\n    ]\n\n    # noinspection PyMissingConstructor\n    def __init__(self):\n        self._pending_enable = set()\n        self._pending_disable = set()\n        self._pending_install = set()\n        self._pending_uninstall = set()\n\n        self._pip_caller = None\n\n        self._repository_available = False\n        self._repository_plugins = []\n        self._repository_cache_path = None\n        self._repository_cache_ttl = 0\n        self._repository_mtime = None\n\n        self._notices = {}\n        self._notices_available = False\n        self._notices_cache_path = None\n        self._notices_cache_ttl = 0\n        self._notices_mtime = None\n\n        self._orphans = None\n\n        self._console_logger = None\n\n        self._get_throttled = lambda: False\n\n        self._install_task = None\n        self._install_lock = threading.RLock()\n\n    def initialize(self):\n        self._console_logger = logging.getLogger(\n            \"octoprint.plugins.pluginmanager.console\"\n        )\n        self._repository_cache_path = os.path.join(\n            self.get_plugin_data_folder(), \"plugins.json\"\n        )\n        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60\n        self._notices_cache_path = os.path.join(\n            self.get_plugin_data_folder(), \"notices.json\"\n        )\n        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60\n        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])\n\n        self._pip_caller = create_pip_caller(\n            command=self._settings.global_get([\"server\", \"commands\", \"localPipCommand\"]),\n            force_user=self._settings.get_boolean([\"pip_force_user\"]),\n        )\n        self._pip_caller.on_log_call = self._log_call\n        self._pip_caller.on_log_stdout = self._log_stdout\n        self._pip_caller.on_log_stderr = self._log_stderr\n\n    ##~~ Body size hook\n\n    def increase_upload_bodysize(self, current_max_body_sizes, *args, **kwargs):\n        # set a maximum body size of 50 MB for plugin archive uploads\n        return [(\"POST\", r\"/upload_file\", 50 * 1024 * 1024)]\n\n    # Additional permissions hook\n\n    def get_additional_permissions(self):\n        return [\n            {\n                \"key\": \"LIST\",\n                \"name\": \"List plugins\",\n                \"description\": gettext(\"Allows to list installed plugins.\"),\n                \"default_groups\": [READONLY_GROUP, USER_GROUP, ADMIN_GROUP],\n                \"roles\": [\"list\"],\n            },\n            {\n                \"key\": \"MANAGE\",\n                \"name\": \"Manage plugins\",\n                \"description\": gettext(\n                    \"Allows to enable, disable and uninstall installed plugins.\"\n                ),\n                \"default_groups\": [ADMIN_GROUP],\n                \"roles\": [\"manage\"],\n            },\n            {\n                \"key\": \"INSTALL\",\n                \"name\": \"Install new plugins\",\n                \"description\": gettext(\n                    'Allows to install new plugins. Includes the \"Manage plugins\" permission.'\n                ),\n                \"default_groups\": [ADMIN_GROUP],\n                \"roles\": [\"install\"],\n                \"permissions\": [\"PLUGIN_PLUGINMANAGER_MANAGE\"],\n                \"dangerous\": True,\n            },\n        ]\n\n    # Additional bundle contents\n\n    def get_additional_bundle_files(self, *args, **kwargs):\n        console_log = self._settings.get_plugin_logfile_path(postfix=\"console\")\n        return {os.path.basename(console_log): console_log}\n\n    ##~~ StartupPlugin\n\n    def on_after_startup(self):\n        from octoprint.logging.handlers import CleaningTimedRotatingFileHandler\n\n        console_logging_handler = CleaningTimedRotatingFileHandler(\n            self._settings.get_plugin_logfile_path(postfix=\"console\"),\n            when=\"D\",\n            backupCount=3,\n        )\n        console_logging_handler.setFormatter(logging.Formatter(\"%(asctime)s %(message)s\"))\n        console_logging_handler.setLevel(logging.DEBUG)\n\n        self._console_logger.addHandler(console_logging_handler)\n        self._console_logger.setLevel(logging.DEBUG)\n        self._console_logger.propagate = False\n\n        helpers = self._plugin_manager.get_helpers(\"pi_support\", \"get_throttled\")\n        if helpers and \"get_throttled\" in helpers:\n            self._get_throttled = helpers[\"get_throttled\"]\n            if self._settings.get_boolean([\"ignore_throttled\"]):\n                self._logger.warning(\n                    \"!!! THROTTLE STATE IGNORED !!! You have configured the Plugin Manager plugin to ignore an active throttle state of the underlying system. You might run into stability issues or outright corrupt your install. Consider fixing the throttling issue instead of suppressing it.\"\n                )\n\n        # decouple repository fetching from server startup\n        self._fetch_all_data(do_async=True)\n\n    ##~~ SettingsPlugin\n\n    def get_settings_defaults(self):\n        return {\n            \"repository\": DEFAULT_PLUGIN_REPOSITORY,\n            \"repository_ttl\": 24 * 60,\n            \"notices\": DEFAULT_PLUGIN_NOTICES,\n            \"notices_ttl\": 6 * 60,\n            \"pip_args\": None,\n            \"pip_force_user\": False,\n            \"confirm_disable\": False,\n            \"dependency_links\": False,\n            \"hidden\": [],\n            \"ignore_throttled\": False,\n        }\n\n    def on_settings_save(self, data):\n        octoprint.plugin.SettingsPlugin.on_settings_save(self, data)\n\n        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60\n        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60\n        self._pip_caller.force_user = self._settings.get_boolean([\"pip_force_user\"])\n        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])\n\n    ##~~ AssetPlugin\n\n    def get_assets(self):\n        return {\n            \"js\": [\"js/pluginmanager.js\"],\n            \"clientjs\": [\"clientjs/pluginmanager.js\"],\n            \"css\": [\"css/pluginmanager.css\"],\n            \"less\": [\"less/pluginmanager.less\"],\n        }\n\n    ##~~ TemplatePlugin\n\n    def get_template_configs(self):\n        return [\n            {\n                \"type\": \"settings\",\n                \"name\": gettext(\"Plugin Manager\"),\n                \"template\": \"pluginmanager_settings.jinja2\",\n                \"custom_bindings\": True,\n            },\n            {\n                \"type\": \"about\",\n                \"name\": \"Plugin Licenses\",\n                \"template\": \"pluginmanager_about.jinja2\",\n            },\n        ]\n\n    def get_template_vars(self):\n        plugins = sorted(self._get_plugins(), key=lambda x: x[\"name\"].lower())\n        return {\n            \"all\": plugins,\n            \"thirdparty\": list(filter(lambda p: not p[\"bundled\"], plugins)),\n            \"file_extensions\": self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,\n        }\n\n    def get_template_types(self, template_sorting, template_rules, *args, **kwargs):\n        return [\n            (\n                \"about_thirdparty\",\n                {},\n                {\"template\": lambda x: x + \"_about_thirdparty.jinja2\"},\n            )\n        ]\n\n    ##~~ BlueprintPlugin\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/upload_file\", methods=[\"POST\"])\n    @no_firstrun_access\n    @Permissions.PLUGIN_PLUGINMANAGER_INSTALL.require(403)\n    def upload_file(self):\n        import flask\n\n        input_name = \"file\"\n        input_upload_path = (\n            input_name\n            + \".\"\n            + self._settings.global_get([\"server\", \"uploads\", \"pathSuffix\"])\n        )\n        input_upload_name = (\n            input_name\n            + \".\"\n            + self._settings.global_get([\"server\", \"uploads\", \"nameSuffix\"])\n        )\n\n        if (\n            input_upload_path not in flask.request.values\n            or input_upload_name not in flask.request.values\n        ):\n            abort(400, description=\"No file included\")\n        upload_path = flask.request.values[input_upload_path]\n        upload_name = flask.request.values[input_upload_name]\n\n        exts = list(\n            filter(\n                lambda x: upload_name.lower().endswith(x),\n                self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,\n            )\n        )\n        if not len(exts):\n            abort(\n                400,\n                description=\"File doesn't have a valid extension for a plugin archive or a single file plugin\",\n            )\n\n        ext = exts[0]\n        archive = tempfile.NamedTemporaryFile(delete=False, suffix=ext)\n        archive.close()\n        shutil.copy(upload_path, archive.name)\n\n        def perform_install(source, name, force=False):\n            try:\n                self.command_install(\n                    path=source,\n                    name=name,\n                    force=force,\n                )\n            finally:\n                try:\n                    os.remove(archive.name)\n                except Exception as e:\n                    self._logger.warning(\n                        \"Could not remove temporary file {path} again: {message}\".format(\n                            path=archive.name, message=str(e)\n                        )\n                    )\n\n        with self._install_lock:\n            if self._install_task is not None:\n                abort(409, description=\"There's already a plugin being installed\")\n\n            self._install_task = threading.Thread(\n                target=perform_install,\n                args=(archive.name, upload_name),\n                kwargs={\n                    \"force\": \"force\" in flask.request.values\n                    and flask.request.values[\"force\"] in valid_boolean_trues\n                },\n            )\n            self._install_task.daemon = True\n            self._install_task.start()\n\n            return jsonify(in_progress=True)\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/export\", methods=[\"GET\"])\n    @no_firstrun_access\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def export_plugin_list(self):\n        import json\n\n        plugins = self.generate_plugins_json(self._settings, self._plugin_manager)\n\n        return Response(\n            json.dumps(plugins),\n            mimetype=\"text/plain\",\n            headers={\"Content-Disposition\": 'attachment; filename=\"plugin_list.json\"'},\n        )\n\n    def _plugin_response(self):\n        return {\n            \"plugins\": self._get_plugins(),\n            \"os\": get_os(),\n            \"octoprint\": get_octoprint_version_string(),\n            \"pip\": {\n                \"available\": self._pip_caller.available,\n                \"version\": self._pip_caller.version_string,\n                \"install_dir\": self._pip_caller.install_dir,\n                \"use_user\": self._pip_caller.use_user,\n                \"virtual_env\": self._pip_caller.virtual_env,\n                \"additional_args\": self._settings.get([\"pip_args\"]),\n                \"python\": sys.executable,\n            },\n            \"safe_mode\": safe_mode,\n            \"online\": self._connectivity_checker.online,\n            \"supported_extensions\": {\n                \"archive\": self.ARCHIVE_EXTENSIONS,\n                \"python\": self.PYTHON_EXTENSIONS,\n            },\n        }\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/plugins\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_plugins(self):\n        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues\n        if refresh or not self._is_notices_cache_valid():\n            self._notices_available = self._refresh_notices()\n\n        def view():\n            return jsonify(**self._plugin_response())\n\n        def etag():\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                value = value.encode(\"utf-8\")\n                hash.update(value)\n\n            hash_update(repr(self._get_plugins()))\n            hash_update(repr(self._pip_caller.version_string))\n            hash_update(str(self._notices_available))\n            hash_update(repr(self._notices))\n            hash_update(repr(safe_mode))\n            hash_update(repr(self._connectivity_checker.online))\n            hash_update(repr(self.ARCHIVE_EXTENSIONS))\n            hash_update(repr(self.PYTHON_EXTENSIONS))\n            hash_update(repr(_DATA_FORMAT_VERSION))\n            return hash.hexdigest()\n\n        def condition():\n            return check_etag(etag())\n\n        return with_revalidation_checking(\n            etag_factory=lambda *args, **kwargs: etag(),\n            condition=lambda *args, **kwargs: condition(),\n            unless=lambda: refresh,\n        )(view)()\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/plugins/versions\")\n    @Permissions.PLUGIN_PLUGINMANAGER_LIST.require(403)\n    def retrieve_plugin_list(self):\n        return jsonify(\n            {p[\"key\"]: p[\"version\"] for p in self._get_plugins() if p[\"enabled\"]}\n        )\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/plugins/<string:key>\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_specific_plugin(self, key):\n        plugin = self._plugin_manager.get_plugin_info(key, require_enabled=False)\n        if plugin is None:\n            return abort(404)\n\n        return jsonify(plugin=self._to_external_plugin(plugin))\n\n    def _orphan_response(self):\n        return {\"orphan_data\": self._get_orphans()}\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/orphans\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_plugin_orphans(self):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues\n        if refresh:\n            self._get_orphans(refresh=True)\n\n        def view():\n            return jsonify(**self._orphan_response())\n\n        def etag():\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                value = value.encode(\"utf-8\")\n                hash.update(value)\n\n            hash_update(repr(self._get_orphans()))\n            hash_update(repr(_DATA_FORMAT_VERSION))\n            return hash.hexdigest()\n\n        def condition():\n            return check_etag(etag())\n\n        return with_revalidation_checking(\n            etag_factory=lambda *args, **kwargs: etag(),\n            condition=lambda *args, **kwargs: condition(),\n            unless=lambda: refresh,\n        )(view)()\n\n    def _repository_response(self):\n        return {\n            \"repository\": {\n                \"available\": self._repository_available,\n                \"plugins\": self._repository_plugins,\n            }\n        }\n\n    @octoprint.plugin.BlueprintPlugin.route(\"/repository\")\n    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)\n    def retrieve_plugin_repository(self):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues\n        if refresh or not self._is_repository_cache_valid():\n            self._repository_available = self._refresh_repository()\n\n        def view():\n            return jsonify(**self._repository_response())\n\n        def etag():\n            import hashlib\n\n            hash = hashlib.sha1()\n\n            def hash_update(value):\n                value = value.encode(\"utf-8\")\n                hash.update(value)\n\n            hash_update(str(self._repository_available))\n            hash_update(repr(self._repository_plugins))\n            hash_update(repr(_DATA_FORMAT_VERSION))\n            return hash.hexdigest()\n\n        def condition():\n            return check_etag(etag())\n\n        return with_revalidation_checking(\n            etag_factory=lambda *args, **kwargs: etag(),\n            condition=lambda *args, **kwargs: condition(),\n            unless=lambda: refresh,\n        )(view)()\n\n    def is_blueprint_protected(self):\n        return False\n\n    ##~~ EventHandlerPlugin\n\n    def on_event(self, event, payload):\n        from octoprint.events import Events\n\n        if (\n            event != Events.CONNECTIVITY_CHANGED\n            or not payload\n            or not payload.get(\"new\", False)\n        ):\n            return\n        self._fetch_all_data(do_async=True)\n\n    ##~~ SimpleApiPlugin\n\n    def get_api_commands(self):\n        return {\n            \"install\": [\"url\"],\n            \"uninstall\": [\"plugin\"],\n            \"enable\": [\"plugin\"],\n            \"disable\": [\"plugin\"],\n            \"cleanup\": [\"plugin\"],\n            \"cleanup_all\": [],\n            \"refresh_repository\": [],\n        }\n\n    def on_api_command(self, command, data):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        if self._printer.is_printing() or self._printer.is_paused():\n            # do not update while a print job is running\n            abort(409, description=\"Printer is currently printing or paused\")\n\n        if command == \"install\":\n            if not Permissions.PLUGIN_PLUGINMANAGER_INSTALL.can():\n                abort(403)\n            url = data[\"url\"]\n            plugin_name = data[\"plugin\"] if \"plugin\" in data else None\n\n            with self._install_lock:\n                if self._install_task is not None:\n                    abort(409, description=\"There's already a plugin being installed\")\n\n                self._install_task = threading.Thread(\n                    target=self.command_install,\n                    kwargs={\n                        \"url\": url,\n                        \"force\": \"force\" in data and data[\"force\"] in valid_boolean_trues,\n                        \"dependency_links\": \"dependency_links\" in data\n                        and data[\"dependency_links\"] in valid_boolean_trues,\n                        \"reinstall\": plugin_name,\n                    },\n                )\n                self._install_task.daemon = True\n                self._install_task.start()\n\n                return jsonify(in_progress=True)\n\n        elif command == \"uninstall\":\n            plugin_name = data[\"plugin\"]\n            if plugin_name not in self._plugin_manager.plugins:\n                abort(404, description=\"Unknown plugin\")\n\n            plugin = self._plugin_manager.plugins[plugin_name]\n            return self.command_uninstall(plugin, cleanup=data.get(\"cleanup\", False))\n\n        elif command == \"cleanup\":\n            plugin = data[\"plugin\"]\n            try:\n                plugin = self._plugin_manager.plugins[plugin]\n            except KeyError:\n                # not installed, we are cleaning up left overs, that's ok\n                pass\n\n            return self.command_cleanup(plugin, include_disabled=True)\n\n        elif command == \"cleanup_all\":\n            return self.command_cleanup_all()\n\n        elif command == \"enable\" or command == \"disable\":\n            plugin_name = data[\"plugin\"]\n            if plugin_name not in self._plugin_manager.plugins:\n                abort(404, description=\"Unknown plugin\")\n\n            plugin = self._plugin_manager.plugins[plugin_name]\n            return self.command_toggle(plugin, command)\n\n    @deprecated(\n        \"Deprecated API endpoint api/plugin/pluginmanager used. \"\n        \"Please switch clients to plugin/pluginmanager/*\",\n        since=\"1.6.0\",\n    )\n    def on_api_get(self, r):\n        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():\n            abort(403)\n\n        refresh_repository = (\n            request.values.get(\"refresh_repository\", \"false\") in valid_boolean_trues\n        )\n        if refresh_repository or not self._is_repository_cache_valid():\n            self._repository_available = self._refresh_repository()\n\n        refresh_notices = (\n            request.values.get(\"refresh_notices\", \"false\") in valid_boolean_trues\n        )\n        if refresh_notices or not self._is_notices_cache_valid():\n            self._notices_available = self._refresh_notices()\n\n        refresh_orphan = (\n            request.values.get(\"refresh_orphans\", \"false\") in valid_boolean_trues\n        )\n        if refresh_orphan:\n            self._get_orphans(refresh=True)\n\n        result = {}\n        result.update(**self._plugin_response())\n        result.update(**self._orphan_response())\n        result.update(**self._repository_response())\n        return jsonify(**result)\n\n    # noinspection PyMethodMayBeStatic\n    def _is_archive(self, path):\n        _, ext = os.path.splitext(path)\n        if ext in PluginManagerPlugin.ARCHIVE_EXTENSIONS:\n            return True\n\n        kind = filetype.guess(path)\n        if kind:\n            return f\".{kind.extension}\" in PluginManagerPlugin.ARCHIVE_EXTENSIONS\n        return False\n\n    def _is_pythonfile(self, path):\n        _, ext = os.path.splitext(path)\n        if ext in PluginManagerPlugin.PYTHON_EXTENSIONS:\n            import ast\n\n            try:\n                with open(path, \"rb\") as f:\n                    ast.parse(f.read(), filename=path)\n                return True\n            except Exception as exc:\n                self._logger.exception(f\"Could not parse {path} as python file: {exc}\")\n\n        return False\n\n    def command_install(\n        self,\n        url=None,\n        path=None,\n        name=None,\n        force=False,\n        reinstall=None,\n        dependency_links=False,\n    ):\n        folder = None\n\n        with self._install_lock:\n            try:\n                source = path\n                source_type = \"path\"\n\n                if url is not None:\n                    # fetch URL\n                    folder = tempfile.TemporaryDirectory()\n                    path = download_file(url, folder.name)\n                    source = url\n                    source_type = \"url\"\n\n                # determine type of path\n                if self._is_archive(path):\n                    result = self._command_install_archive(\n                        path,\n                        source=source,\n                        source_type=source_type,\n                        force=force,\n                        reinstall=reinstall,\n                        dependency_links=dependency_links,\n                    )\n\n                elif self._is_pythonfile(path):\n                    result = self._command_install_pythonfile(\n                        path, source=source, source_type=source_type, name=name\n                    )\n\n                else:\n                    raise exceptions.InvalidPackageFormat()\n\n            except requests.exceptions.HTTPError as e:\n                self._logger.error(f\"Could not fetch plugin from server, got {e}\")\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": f\"Could not fetch plugin from server, got {e}\",\n                }\n                self._send_result_notification(\"install\", result)\n\n            except exceptions.InvalidPackageFormat:\n                self._logger.error(\n                    \"{} is neither an archive nor a python file, can't install that.\".format(\n                        source\n                    )\n                )\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": \"Could not install plugin from {}, was neither \"\n                    \"a plugin archive nor a single file plugin\".format(source),\n                }\n                self._send_result_notification(\"install\", result)\n\n            except Exception:\n                error_msg = (\n                    \"Unexpected error while trying to install plugin from {}\".format(\n                        source\n                    )\n                )\n                self._logger.exception(error_msg)\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": error_msg,\n                }\n                self._send_result_notification(\"install\", result)\n\n            finally:\n                if folder is not None:\n                    folder.cleanup()\n                self._install_task = None\n\n        return result\n\n    # noinspection DuplicatedCode\n    def _command_install_archive(\n        self,\n        path,\n        source=None,\n        source_type=None,\n        force=False,\n        reinstall=None,\n        dependency_links=False,\n    ):\n        throttled = self._get_throttled()\n        if (\n            throttled\n            and isinstance(throttled, dict)\n            and throttled.get(\"current_issue\", False)\n            and not self._settings.get_boolean([\"ignore_throttled\"])\n        ):\n            # currently throttled, we refuse to run\n            error_msg = (\n                \"System is currently throttled, refusing to install anything\"\n                \" due to possible stability issues\"\n            )\n            self._logger.error(error_msg)\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": error_msg,\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        from urllib.parse import quote as url_quote\n\n        path = os.path.abspath(path)\n        if os.sep != \"/\":\n            # windows gets special handling\n            drive, loc = os.path.splitdrive(path)\n            path_url = (\n                \"file:///\" + drive.lower() + url_quote(loc.replace(os.sep, \"/\").lower())\n            )\n            shell_quote = lambda x: x  # do not shell quote under windows, non posix shell\n        else:\n            path_url = \"file://\" + url_quote(path)\n            shell_quote = sarge.shell_quote\n\n        self._logger.info(f\"Installing plugin from {source}\")\n        pip_args = [\n            \"--disable-pip-version-check\",\n            \"install\",\n            shell_quote(path_url),\n            \"--no-cache-dir\",\n        ]\n\n        if dependency_links or self._settings.get_boolean([\"dependency_links\"]):\n            pip_args.append(\"--process-dependency-links\")\n\n        all_plugins_before = self._plugin_manager.find_plugins(existing={})\n\n        try:\n            _, stdout, stderr = self._call_pip(pip_args)\n\n            if not force and is_already_installed(stdout):\n                self._logger.info(\n                    \"Plugin to be installed from {} was already installed, forcing a reinstall\".format(\n                        source\n                    )\n                )\n                self._log_message(\n                    \"Looks like the plugin was already installed. Forcing a reinstall.\"\n                )\n                force = True\n        except Exception as e:\n            self._logger.exception(f\"Could not install plugin from {source}\")\n            self._logger.exception(f\"Reason: {repr(e)}\")\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Could not install plugin from {}, see the log for more details\".format(\n                    source\n                ),\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        if is_python_mismatch(stderr):\n            return self.handle_python_mismatch(source, source_type)\n\n        if force:\n            # We don't use --upgrade here because that will also happily update all our dependencies - we'd rather\n            # do that in a controlled manner\n            pip_args += [\"--ignore-installed\", \"--force-reinstall\", \"--no-deps\"]\n            try:\n                _, stdout, stderr = self._call_pip(pip_args)\n            except Exception as e:\n                self._logger.exception(f\"Could not install plugin from {source}\")\n                self._logger.exception(f\"Reason: {repr(e)}\")\n                result = {\n                    \"result\": False,\n                    \"source\": source,\n                    \"source_type\": source_type,\n                    \"reason\": \"Could not install plugin from source {}, see the log for more details\".format(\n                        source\n                    ),\n                }\n                self._send_result_notification(\"install\", result)\n                return result\n\n            if is_python_mismatch(stderr):\n                return self.handle_python_mismatch(source, source_type)\n\n        result_line = get_result_line(stdout)\n        if not result_line:\n            self._logger.error(\n                \"Installing the plugin from {} failed, could not parse output from pip. \"\n                \"See plugin_pluginmanager_console.log for generated output\".format(source)\n            )\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Could not parse output from pip, see plugin_pluginmanager_console.log \"\n                \"for generated output\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        # We'll need to fetch the \"Successfully installed\" line, strip the \"Successfully\" part, then split\n        # by whitespace and strip to get all installed packages.\n        #\n        # We then need to iterate over all known plugins and see if either the package name or the package name plus\n        # version number matches one of our installed packages. If it does, that's our installed plugin.\n        #\n        # Known issue: This might return the wrong plugin if more than one plugin was installed through this\n        # command (e.g. due to pulling in another plugin as dependency). It should be safe for now though to\n        # consider this a rare corner case. Once it becomes a real problem we'll just extend the plugin manager\n        # so that it can report on more than one installed plugin.\n\n        result_line = result_line.strip()\n        if not result_line.startswith(OUTPUT_SUCCESS):\n            self._logger.error(\n                \"Installing the plugin from {} failed, pip did not report successful installation\".format(\n                    source\n                )\n            )\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Pip did not report successful installation\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        installed = list(\n            map(lambda x: x.strip(), result_line[len(OUTPUT_SUCCESS) :].split(\" \"))\n        )\n        all_plugins_after = self._plugin_manager.find_plugins(\n            existing={}, ignore_uninstalled=False\n        )\n\n        new_plugin = self._find_installed_plugin(installed, plugins=all_plugins_after)\n\n        if new_plugin is None:\n            self._logger.warning(\n                \"The plugin was installed successfully, but couldn't be found afterwards to \"\n                \"initialize properly during runtime. Please restart OctoPrint.\"\n            )\n            result = {\n                \"result\": True,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"needs_restart\": True,\n                \"needs_refresh\": True,\n                \"needs_reconnect\": True,\n                \"was_reinstalled\": False,\n                \"plugin\": \"unknown\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        self._plugin_manager.reload_plugins()\n        needs_restart = (\n            self._plugin_manager.is_restart_needing_plugin(new_plugin)\n            or new_plugin.key in all_plugins_before\n            or reinstall is not None\n        )\n        needs_refresh = new_plugin.implementation and isinstance(\n            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        is_reinstall = self._plugin_manager.is_plugin_marked(\n            new_plugin.key, \"uninstalled\"\n        )\n        self._plugin_manager.mark_plugin(\n            new_plugin.key,\n            uninstalled=False,\n            installed=not is_reinstall and needs_restart,\n        )\n\n        self._plugin_manager.log_all_plugins()\n\n        self._logger.info(\n            \"The plugin was installed successfully: {}, version {}\".format(\n                new_plugin.name, new_plugin.version\n            )\n        )\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,\n            {\n                \"id\": new_plugin.key,\n                \"version\": new_plugin.version,\n                \"source\": source,\n                \"source_type\": source_type,\n            },\n        )\n\n        result = {\n            \"result\": True,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"needs_restart\": needs_restart,\n            \"needs_refresh\": needs_refresh,\n            \"needs_reconnect\": needs_reconnect,\n            \"was_reinstalled\": new_plugin.key in all_plugins_before\n            or reinstall is not None,\n            \"plugin\": self._to_external_plugin(new_plugin),\n        }\n        self._send_result_notification(\"install\", result)\n        return result\n\n    def _handle_python_mismatch(self, source, source_type):\n        self._logger.error(\n            \"Installing the plugin from {} failed, pip reported a Python version mismatch\".format(\n                source\n            )\n        )\n        result = {\n            \"result\": False,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"reason\": \"Pip reported a Python version mismatch\",\n            \"faq\": \"https://faq.octoprint.org/plugin-python-mismatch\",\n        }\n        self._send_result_notification(\"install\", result)\n        return result\n\n    # noinspection DuplicatedCode\n    def _command_install_pythonfile(self, path, source=None, source_type=None, name=None):\n        if name is None:\n            name = os.path.basename(path)\n\n        self._logger.info(f\"Installing single file plugin {name} from {source}\")\n\n        all_plugins_before = self._plugin_manager.find_plugins(existing={})\n\n        destination = os.path.join(self._settings.global_get_basefolder(\"plugins\"), name)\n        plugin_id, _ = os.path.splitext(name)\n\n        # check python compatibility\n        PYTHON_MISMATCH = {\n            \"result\": False,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"reason\": \"Plugin could not be installed\",\n            \"faq\": \"https://faq.octoprint.org/plugin-python-mismatch\",\n        }\n\n        try:\n            metadata = octoprint.plugin.core.parse_plugin_metadata(path)\n        except SyntaxError:\n            self._logger.exception(\n                \"Installing plugin from {} failed, there's a Python version mismatch\".format(\n                    source\n                )\n            )\n            result = PYTHON_MISMATCH\n            self._send_result_notification(\"install\", result)\n            return result\n\n        pythoncompat = metadata.get(\n            octoprint.plugin.core.ControlProperties.attr_pythoncompat,\n            octoprint.plugin.core.ControlProperties.default_pythoncompat,\n        )\n        if not is_python_compatible(pythoncompat):\n            self._logger.exception(\n                \"Installing plugin from {} failed, there's a Python version mismatch\".format(\n                    source\n                )\n            )\n            result = PYTHON_MISMATCH\n            self._send_result_notification(\"install\", result)\n            return result\n\n        # copy plugin\n        try:\n            self._log_call(f\"cp {path} {destination}\")\n            shutil.copy(path, destination)\n        except Exception:\n            self._logger.exception(f\"Installing plugin from {source} failed\")\n            result = {\n                \"result\": False,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"reason\": \"Plugin could not be copied\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        plugins = self._plugin_manager.find_plugins(existing={}, ignore_uninstalled=False)\n        new_plugin = plugins.get(plugin_id)\n        if new_plugin is None:\n            self._logger.warning(\n                \"The plugin was installed successfully, but couldn't be found afterwards to \"\n                \"initialize properly during runtime. Please restart OctoPrint.\"\n            )\n            result = {\n                \"result\": True,\n                \"source\": source,\n                \"source_type\": source_type,\n                \"needs_restart\": True,\n                \"needs_refresh\": True,\n                \"needs_reconnect\": True,\n                \"was_reinstalled\": False,\n                \"plugin\": \"unknown\",\n            }\n            self._send_result_notification(\"install\", result)\n            return result\n\n        self._plugin_manager.reload_plugins()\n        needs_restart = (\n            self._plugin_manager.is_restart_needing_plugin(new_plugin)\n            or new_plugin.key in all_plugins_before\n        )\n        needs_refresh = new_plugin.implementation and isinstance(\n            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        self._logger.info(\n            \"The plugin was installed successfully: {}, version {}\".format(\n                new_plugin.name, new_plugin.version\n            )\n        )\n        self._plugin_manager.log_all_plugins()\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,\n            {\n                \"id\": new_plugin.key,\n                \"version\": new_plugin.version,\n                \"source\": source,\n                \"source_type\": source_type,\n            },\n        )\n\n        result = {\n            \"result\": True,\n            \"source\": source,\n            \"source_type\": source_type,\n            \"needs_restart\": needs_restart,\n            \"needs_refresh\": needs_refresh,\n            \"needs_reconnect\": needs_reconnect,\n            \"was_reinstalled\": new_plugin.key in all_plugins_before,\n            \"plugin\": self._to_external_plugin(new_plugin),\n        }\n        self._send_result_notification(\"install\", result)\n        return result\n\n    def command_uninstall(self, plugin, cleanup=False):\n        if plugin.key == \"pluginmanager\":\n            abort(403, description=\"Can't uninstall Plugin Manager\")\n\n        if not plugin.managable:\n            abort(\n                403, description=\"Plugin is not managable and hence cannot be uninstalled\"\n            )\n\n        if plugin.bundled:\n            abort(403, description=\"Bundled plugins cannot be uninstalled\")\n\n        if plugin.origin is None:\n            self._logger.warning(\n                f\"Trying to uninstall plugin {plugin} but origin is unknown\"\n            )\n            abort(500, description=\"Could not uninstall plugin, its origin is unknown\")\n\n        if plugin.implementation:\n            try:\n                plugin.implementation.on_plugin_pending_uninstall()\n            except Exception:\n                self._logger.exception(\n                    \"Error while calling on_plugin_pending_uninstall on the plugin, proceeding regardless\"\n                )\n\n        if plugin.origin.type == \"entry_point\":\n            # plugin is installed through entry point, need to use pip to uninstall it\n            origin = plugin.origin[3]\n            if origin is None:\n                origin = plugin.origin[2]\n\n            pip_args = [\"--disable-pip-version-check\", \"uninstall\", \"--yes\", origin]\n            try:\n                self._call_pip(pip_args)\n            except Exception:\n                self._logger.exception(\"Could not uninstall plugin via pip\")\n                abort(\n                    500,\n                    description=\"Could not uninstall plugin via pip, see the log for more details\",\n                )\n\n        elif plugin.origin.type == \"folder\":\n            import os\n            import shutil\n\n            full_path = os.path.realpath(plugin.location)\n\n            if os.path.isdir(full_path):\n                # plugin is installed via a plugin folder, need to use rmtree to get rid of it\n                self._log_stdout(f\"Deleting plugin from {plugin.location}\")\n                shutil.rmtree(full_path)\n            elif os.path.isfile(full_path):\n                self._log_stdout(f\"Deleting plugin from {plugin.location}\")\n                os.remove(full_path)\n\n                if full_path.endswith(\".py\"):\n                    pyc_file = f\"{full_path}c\"\n                    if os.path.isfile(pyc_file):\n                        self._log_stdout(f\"Deleting plugin from {pyc_file}\")\n                        os.remove(pyc_file)\n\n        else:\n            self._logger.warning(\n                f\"Trying to uninstall plugin {plugin} but origin is unknown ({plugin.origin.type})\"\n            )\n            abort(500, description=\"Could not uninstall plugin, its origin is unknown\")\n\n        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin) or cleanup\n        needs_refresh = plugin.implementation and isinstance(\n            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        was_pending_install = self._plugin_manager.is_plugin_marked(\n            plugin.key, \"installed\"\n        )\n        self._plugin_manager.mark_plugin(\n            plugin.key,\n            uninstalled=not was_pending_install and needs_restart,\n            installed=False,\n        )\n\n        if not needs_restart:\n            try:\n                if plugin.enabled:\n                    self._plugin_manager.disable_plugin(plugin.key, plugin=plugin)\n            except octoprint.plugin.core.PluginLifecycleException as e:\n                self._logger.exception(f\"Problem disabling plugin {plugin.key}\")\n                result = {\n                    \"result\": False,\n                    \"uninstalled\": True,\n                    \"disabled\": False,\n                    \"unloaded\": False,\n                    \"reason\": e.reason,\n                }\n                self._send_result_notification(\"uninstall\", result)\n                return jsonify(result)\n\n            try:\n                if plugin.loaded:\n                    self._plugin_manager.unload_plugin(plugin.key)\n            except octoprint.plugin.core.PluginLifecycleException as e:\n                self._logger.exception(f\"Problem unloading plugin {plugin.key}\")\n                result = {\n                    \"result\": False,\n                    \"uninstalled\": True,\n                    \"disabled\": True,\n                    \"unloaded\": False,\n                    \"reason\": e.reason,\n                }\n                self._send_result_notification(\"uninstall\", result)\n                return jsonify(result)\n\n        self._plugin_manager.reload_plugins()\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_UNINSTALL_PLUGIN,\n            {\"id\": plugin.key, \"version\": plugin.version},\n        )\n\n        result = {\n            \"result\": True,\n            \"needs_restart\": needs_restart,\n            \"needs_refresh\": needs_refresh,\n            \"needs_reconnect\": needs_reconnect,\n            \"plugin\": self._to_external_plugin(plugin),\n        }\n        self._send_result_notification(\"uninstall\", result)\n        self._logger.info(f\"Plugin {plugin.key} uninstalled\")\n\n        self._cleanup_disabled(plugin.key)\n        if cleanup:\n            self.command_cleanup(plugin.key, result_notifications=False)\n\n        return jsonify(result)\n\n    def command_cleanup(\n        self,\n        plugin,\n        include_disabled=False,\n        result_notifications=True,\n        settings_save=True,\n    ):\n        if isinstance(plugin, str):\n            key = result_value = plugin\n        else:\n            key = plugin.key\n            result_value = self._to_external_plugin(plugin)\n\n        message = f\"Cleaning up plugin {key}...\"\n        self._logger.info(message)\n        self._log_stdout(message)\n\n        # delete plugin settings\n        self._cleanup_settings(key)\n\n        # delete plugin disabled entry\n        if include_disabled:\n            self._cleanup_disabled(key)\n\n        # delete plugin data folder\n        result_data = True\n        if not self._cleanup_data(key):\n            message = f\"Could not delete data folder of plugin {key}\"\n            self._logger.exception(message)\n            self._log_stderr(message)\n            result_data = False\n\n        if settings_save:\n            self._settings.save()\n\n        result = {\"result\": result_data, \"needs_restart\": True, \"plugin\": result_value}\n        if result_notifications:\n            self._send_result_notification(\"cleanup\", result)\n\n        # cleaning orphan cache\n        self._orphans = None\n\n        return jsonify(result)\n\n    def command_cleanup_all(self):\n        orphans = self._get_orphans()\n        cleaned_up = set()\n\n        for orphan in sorted(orphans.keys()):\n            self.command_cleanup(\n                orphan,\n                include_disabled=True,\n                result_notifications=False,\n                settings_save=False,\n            )\n            cleaned_up.add(orphan)\n\n        self._settings.save()\n\n        result = {\n            \"result\": True,\n            \"needs_restart\": len(cleaned_up) > 0,\n            \"cleaned_up\": sorted(list(cleaned_up)),\n        }\n        self._send_result_notification(\"cleanup_all\", result)\n        self._logger.info(f\"Cleaned up all data, {len(cleaned_up)} left overs removed\")\n\n        # cleaning orphan cache\n        self._orphans = None\n\n        return jsonify(result)\n\n    def _cleanup_disabled(self, plugin):\n        # delete from disabled list\n        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])\n        try:\n            disabled.remove(plugin)\n        except ValueError:\n            # not in list, ok\n            pass\n        self._settings.global_set([\"plugins\", \"_disabled\"], disabled)\n\n    def _cleanup_settings(self, plugin):\n        # delete plugin settings\n        self._settings.global_remove([\"plugins\", plugin])\n        self._settings.global_remove([\"server\", \"seenWizards\", plugin])\n        return True\n\n    def _cleanup_data(self, plugin):\n        import os\n        import shutil\n\n        data_folder = os.path.join(self._settings.getBaseFolder(\"data\"), plugin)\n        if os.path.exists(data_folder):\n            try:\n                shutil.rmtree(data_folder)\n                return True\n            except Exception:\n                self._logger.exception(\n                    f\"Could not delete plugin data folder at {data_folder}\"\n                )\n                return False\n        else:\n            return True\n\n    def command_toggle(self, plugin, command):\n        if plugin.key == \"pluginmanager\" or (plugin.hidden and plugin.bundled):\n            abort(400, description=\"Can't enable/disable Plugin Manager\")\n\n        pending = (command == \"disable\" and plugin.key in self._pending_enable) or (\n            command == \"enable\" and plugin.key in self._pending_disable\n        )\n        safe_mode_victim = getattr(plugin, \"safe_mode_victim\", False)\n\n        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin)\n        needs_refresh = plugin.implementation and isinstance(\n            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin\n        )\n        needs_reconnect = (\n            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)\n            and self._printer.is_operational()\n        )\n\n        needs_restart_api = (\n            needs_restart or safe_mode_victim or plugin.forced_disabled\n        ) and not pending\n        needs_refresh_api = needs_refresh and not pending\n        needs_reconnect_api = needs_reconnect and not pending\n\n        try:\n            if command == \"disable\":\n                self._mark_plugin_disabled(plugin, needs_restart=needs_restart)\n            elif command == \"enable\":\n                self._mark_plugin_enabled(plugin, needs_restart=needs_restart)\n        except octoprint.plugin.core.PluginLifecycleException as e:\n            self._logger.exception(\n                \"Problem toggling enabled state of {name}: {reason}\".format(\n                    name=plugin.key, reason=e.reason\n                )\n            )\n            result = {\"result\": False, \"reason\": e.reason}\n        except octoprint.plugin.core.PluginNeedsRestart:\n            result = {\n                \"result\": True,\n                \"needs_restart\": True,\n                \"needs_refresh\": True,\n                \"needs_reconnect\": True,\n                \"plugin\": self._to_external_plugin(plugin),\n            }\n        else:\n            result = {\n                \"result\": True,\n                \"needs_restart\": needs_restart_api,\n                \"needs_refresh\": needs_refresh_api,\n                \"needs_reconnect\": needs_reconnect_api,\n                \"plugin\": self._to_external_plugin(plugin),\n            }\n\n        self._send_result_notification(command, result)\n        return jsonify(result)\n\n    def _find_installed_plugin(self, packages, plugins=None):\n        if plugins is None:\n            plugins = self._plugin_manager.find_plugins(\n                existing={}, ignore_uninstalled=False\n            )\n\n        for plugin in plugins.values():\n            if plugin.origin is None or plugin.origin.type != \"entry_point\":\n                continue\n\n            package_name = plugin.origin.package_name\n            package_version = plugin.origin.package_version\n            versioned_package = f\"{package_name}-{package_version}\"\n\n            if package_name in packages or versioned_package in packages:\n                # exact match, we are done here\n                return plugin\n\n            else:\n                # it might still be a version that got stripped by python's package resources, e.g. 1.4.5a0 => 1.4.5a\n                found = False\n\n                for inst in packages:\n                    if inst.startswith(versioned_package):\n                        found = True\n                        break\n\n                if found:\n                    return plugin\n\n        return None\n\n    def _send_result_notification(self, action, result):\n        notification = {\"type\": \"result\", \"action\": action}\n        notification.update(result)\n        self._plugin_manager.send_plugin_message(self._identifier, notification)\n\n    def _call_pip(self, args):\n        if self._pip_caller is None or not self._pip_caller.available:\n            raise RuntimeError(\"No pip available, can't operate\")\n\n        if \"--process-dependency-links\" in args:\n            self._log_message(\n                \"Installation needs to process external dependencies, that might make it take a bit longer than usual depending on the pip version\"\n            )\n\n        additional_args = self._settings.get([\"pip_args\"])\n\n        if additional_args is not None:\n\n            inapplicable_arguments = self.__class__.PIP_INAPPLICABLE_ARGUMENTS.get(\n                args[0], list()\n            )\n            for inapplicable_argument in inapplicable_arguments:\n                additional_args = re.sub(\n                    r\"(^|\\s)\" + re.escape(inapplicable_argument) + r\"\\\\b\",\n                    \"\",\n                    additional_args,\n                )\n\n            if additional_args:\n                args.append(additional_args)\n\n        kwargs = {\n            \"env\": {\n                \"PYTHONWARNINGS\": \"ignore:DEPRECATION::pip._internal.cli.base_command\"\n            }\n        }\n\n        return self._pip_caller.execute(*args, **kwargs)\n\n    def _log_message(self, *lines):\n        self._log(lines, prefix=\"*\", stream=\"message\")\n\n    def _log_call(self, *lines):\n        self._log(lines, prefix=\" \", stream=\"call\")\n\n    def _log_stdout(self, *lines):\n        self._log(lines, prefix=\">\", stream=\"stdout\")\n\n    def _log_stderr(self, *lines):\n        self._log(lines, prefix=\"!\", stream=\"stderr\")\n\n    def _log(self, lines, prefix=None, stream=None, strip=True):\n        if strip:\n            lines = list(map(lambda x: x.strip(), lines))\n\n        self._plugin_manager.send_plugin_message(\n            self._identifier,\n            {\n                \"type\": \"loglines\",\n                \"loglines\": [{\"line\": line, \"stream\": stream} for line in lines],\n            },\n        )\n        for line in lines:  # noqa: B007\n            self._console_logger.debug(f\"{prefix} {line}\")\n\n    def _mark_plugin_enabled(self, plugin, needs_restart=False):\n        disabled_list = list(\n            self._settings.global_get(\n                [\"plugins\", \"_disabled\"],\n                validator=lambda x: isinstance(x, list),\n                fallback=[],\n            )\n        )\n        if plugin.key in disabled_list:\n            disabled_list.remove(plugin.key)\n            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)\n            self._settings.save(force=True)\n\n        if (\n            not needs_restart\n            and not plugin.forced_disabled\n            and not getattr(plugin, \"safe_mode_victim\", False)\n        ):\n            self._plugin_manager.enable_plugin(plugin.key)\n        else:\n            if plugin.key in self._pending_disable:\n                self._pending_disable.remove(plugin.key)\n            elif not plugin.enabled and plugin.key not in self._pending_enable:\n                self._pending_enable.add(plugin.key)\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_ENABLE_PLUGIN,\n            {\"id\": plugin.key, \"version\": plugin.version},\n        )\n\n    def _mark_plugin_disabled(self, plugin, needs_restart=False):\n        disabled_list = list(\n            self._settings.global_get(\n                [\"plugins\", \"_disabled\"],\n                validator=lambda x: isinstance(x, list),\n                fallback=[],\n            )\n        )\n        if plugin.key not in disabled_list:\n            disabled_list.append(plugin.key)\n            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)\n            self._settings.save(force=True)\n\n        if (\n            not needs_restart\n            and not plugin.forced_disabled\n            and not getattr(plugin, \"safe_mode_victim\", False)\n        ):\n            self._plugin_manager.disable_plugin(plugin.key)\n        else:\n            if plugin.key in self._pending_enable:\n                self._pending_enable.remove(plugin.key)\n            elif (\n                plugin.enabled\n                or plugin.forced_disabled\n                or getattr(plugin, \"safe_mode_victim\", False)\n            ) and plugin.key not in self._pending_disable:\n                self._pending_disable.add(plugin.key)\n\n        # noinspection PyUnresolvedReferences\n        self._event_bus.fire(\n            Events.PLUGIN_PLUGINMANAGER_DISABLE_PLUGIN,\n            {\"id\": plugin.key, \"version\": plugin.version},\n        )\n\n    def _fetch_all_data(self, do_async=False):\n        def run():\n            self._repository_available = self._fetch_repository_from_disk()\n            self._notices_available = self._fetch_notices_from_disk()\n\n        if do_async:\n            thread = threading.Thread(target=run)\n            thread.daemon = True\n            thread.start()\n        else:\n            run()\n\n    def _is_repository_cache_valid(self, mtime=None):\n        import time\n\n        if mtime is None:\n            mtime = self._repository_mtime\n        if mtime is None:\n            return False\n        return mtime + self._repository_cache_ttl >= time.time() > mtime\n\n    def _fetch_repository_from_disk(self):\n        repo_data = None\n        if os.path.isfile(self._repository_cache_path):\n            mtime = os.path.getmtime(self._repository_cache_path)\n            if self._is_repository_cache_valid(mtime=mtime):\n                try:\n                    import json\n\n                    with open(self._repository_cache_path, encoding=\"utf-8\") as f:\n                        repo_data = json.load(f)\n                    self._repository_mtime = mtime\n                    self._logger.info(\n                        \"Loaded plugin repository data from disk, was still valid\"\n                    )\n                except Exception:\n                    self._logger.exception(\n                        \"Error while loading repository data from {}\".format(\n                            self._repository_cache_path\n                        )\n                    )\n\n        return self._refresh_repository(repo_data=repo_data)\n\n    def _fetch_repository_from_url(self):\n        if not self._connectivity_checker.online:\n            self._logger.info(\n                \"Looks like we are offline, can't fetch repository from network\"\n            )\n            return None\n\n        repository_url = self._settings.get([\"repository\"])\n        try:\n            r = requests.get(repository_url, timeout=30)\n            r.raise_for_status()\n            self._logger.info(f\"Loaded plugin repository data from {repository_url}\")\n        except Exception as e:\n            self._logger.exception(\n                \"Could not fetch plugins from repository at {repository_url}: {message}\".format(\n                    repository_url=repository_url, message=e\n                )\n            )\n            return None\n\n        try:\n            repo_data = r.json()\n        except Exception as e:\n            self._logger.exception(f\"Error while reading repository data: {e}\")\n            return None\n\n        # validation\n        if not isinstance(repo_data, (list, tuple)):\n            self._logger.warning(\n                f\"Invalid repository data: expected a list, got {repo_data!r}\"\n            )\n            return None\n\n        try:\n            import json\n\n            with octoprint.util.atomic_write(self._repository_cache_path, mode=\"wb\") as f:\n                f.write(to_bytes(json.dumps(repo_data)))\n            self._repository_mtime = os.path.getmtime(self._repository_cache_path)\n        except Exception as e:\n            self._logger.exception(\n                \"Error while saving repository data to {}: {}\".format(\n                    self._repository_cache_path, e\n                )\n            )\n\n        return repo_data\n\n    def _refresh_repository(self, repo_data=None):\n        if repo_data is None:\n            repo_data = self._fetch_repository_from_url()\n            if repo_data is None:\n                return False\n\n        self._repository_plugins = list(\n            filter(lambda x: x is not None, map(map_repository_entry, repo_data))\n        )\n        return True\n\n    def _is_notices_cache_valid(self, mtime=None):\n        import time\n\n        if mtime is None:\n            mtime = self._notices_mtime\n        if mtime is None:\n            return False\n        return mtime + self._notices_cache_ttl >= time.time() > mtime\n\n    def _fetch_notices_from_disk(self):\n        notice_data = None\n        if os.path.isfile(self._notices_cache_path):\n            mtime = os.path.getmtime(self._notices_cache_path)\n            if self._is_notices_cache_valid(mtime=mtime):\n                try:\n                    import json\n\n                    with open(self._notices_cache_path, encoding=\"utf-8\") as f:\n                        notice_data = json.load(f)\n                    self._notices_mtime = mtime\n                    self._logger.info(\"Loaded notice data from disk, was still valid\")\n                except Exception:\n                    self._logger.exception(\n                        \"Error while loading notices from {}\".format(\n                            self._notices_cache_path\n                        )\n                    )\n\n        return self._refresh_notices(notice_data=notice_data)\n\n    def _fetch_notices_from_url(self):\n        if not self._connectivity_checker.online:\n            self._logger.info(\n                \"Looks like we are offline, can't fetch notices from network\"\n            )\n            return None\n\n        notices_url = self._settings.get([\"notices\"])\n        try:\n            r = requests.get(notices_url, timeout=30)\n            r.raise_for_status()\n            self._logger.info(f\"Loaded plugin notices data from {notices_url}\")\n        except Exception as e:\n            self._logger.exception(\n                \"Could not fetch notices from {notices_url}: {message}\".format(\n                    notices_url=notices_url, message=str(e)\n                )\n            )\n            return None\n\n        notice_data = r.json()\n\n        try:\n            import json\n\n            with octoprint.util.atomic_write(self._notices_cache_path, mode=\"wb\") as f:\n                f.write(to_bytes(json.dumps(notice_data)))\n            self._notices_mtime = os.path.getmtime(self._notices_cache_path)\n        except Exception as e:\n            self._logger.exception(\n                \"Error while saving notices to {}: {}\".format(\n                    self._notices_cache_path, str(e)\n                )\n            )\n        return notice_data\n\n    def _refresh_notices(self, notice_data=None):\n        if notice_data is None:\n            notice_data = self._fetch_notices_from_url()\n            if notice_data is None:\n                return False\n\n        notices = {}\n        for notice in notice_data:\n            if \"plugin\" not in notice or \"text\" not in notice or \"date\" not in notice:\n                continue\n\n            key = notice[\"plugin\"]\n\n            try:\n                # Jekyll turns \"%Y-%m-%d %H:%M:%SZ\" into \"%Y-%m-%d %H:%M:%S +0000\", so be sure to ignore \"+0000\"\n                #\n                # Being able to use dateutil here would make things way easier but sadly that can no longer get\n                # installed (from source) under OctoPi 0.14 due to its setuptools-scm dependency, so we have to do\n                # without it for now until we can drop support for OctoPi 0.14.\n                parsed_date = datetime.strptime(notice[\"date\"], \"%Y-%m-%d %H:%M:%S +0000\")\n                notice[\"timestamp\"] = parsed_date.timetuple()\n            except Exception as e:\n                self._logger.warning(\n                    \"Error while parsing date {!r} for plugin notice \"\n                    \"of plugin {}, ignoring notice: {}\".format(\n                        notice[\"date\"], key, str(e)\n                    )\n                )\n                continue\n\n            if key not in notices:\n                notices[key] = []\n            notices[key].append(notice)\n\n        self._notices = notices\n        return True\n\n    def _get_orphans(self, refresh=False):\n        from collections import defaultdict\n\n        if self._orphans is not None and not refresh:\n            return self._orphans\n\n        installed_keys = self._plugin_manager.plugins.keys()\n        orphans = defaultdict(\n            lambda: {\"settings\": False, \"data\": False, \"disabled\": False}\n        )\n\n        # settings\n        for key in list(self._settings.global_get([\"plugins\"]).keys()):\n            if key.startswith(\"_\"):\n                # internal key, like _disabled\n                continue\n\n            if key not in installed_keys:\n                orphans[key][\"settings\"] = True\n\n        # data\n        for entry in os.scandir(self._settings.getBaseFolder(\"data\")):\n            if not entry.is_dir():\n                continue\n\n            if entry.name not in installed_keys:\n                orphans[entry.name][\"data\"] = True\n\n        # disabled\n        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])\n        for key in disabled:\n            if key not in installed_keys:\n                orphans[key][\"disabled\"] = True\n\n        self._orphans = dict(**orphans)\n        return self._orphans\n\n    @property\n    def _reconnect_hooks(self):\n        reconnect_hooks = self.__class__.RECONNECT_HOOKS\n\n        reconnect_hook_provider_hooks = self._plugin_manager.get_hooks(\n            \"octoprint.plugin.pluginmanager.reconnect_hooks\"\n        )\n        for name, hook in reconnect_hook_provider_hooks.items():\n            try:\n                result = hook()\n                if isinstance(result, (list, tuple)):\n                    reconnect_hooks.extend(filter(lambda x: isinstance(x, str), result))\n            except Exception:\n                self._logger.exception(\n                    f\"Error while retrieving additional hooks for which a \"\n                    f\"reconnect is required from plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        return reconnect_hooks\n\n    def _get_plugins(self):\n        plugins = self._plugin_manager.plugins\n\n        hidden = self._settings.get([\"hidden\"])\n        result = []\n        for key, plugin in plugins.items():\n            if key in hidden or (plugin.bundled and plugin.hidden):\n                continue\n            result.append(self._to_external_plugin(plugin))\n\n        return result\n\n    @staticmethod\n    def generate_plugins_json(\n        settings, plugin_manager, ignore_bundled=True, ignore_plugins_folder=True\n    ):\n        plugins = []\n        plugin_folder = settings.getBaseFolder(\"plugins\")\n        for plugin in plugin_manager.plugins.values():\n            if (ignore_bundled and plugin.bundled) or (\n                ignore_plugins_folder\n                and isinstance(plugin.origin, octoprint.plugin.core.FolderOrigin)\n                and plugin.origin.folder == plugin_folder\n            ):\n                # ignore bundled or from the plugins folder already included in the backup\n                continue\n\n            plugins.append({\"key\": plugin.key, \"name\": plugin.name, \"url\": plugin.url})\n        return plugins\n\n    def _to_external_plugin(self, plugin):\n        return {\n            \"key\": plugin.key,\n            \"name\": plugin.name,\n            \"description\": plugin.description,\n            \"disabling_discouraged\": gettext(plugin.disabling_discouraged)\n            if plugin.disabling_discouraged\n            else False,\n            \"author\": plugin.author,\n            \"version\": plugin.version,\n            \"url\": plugin.url,\n            \"license\": plugin.license,\n            \"python\": plugin.pythoncompat,\n            \"bundled\": plugin.bundled,\n            \"managable\": plugin.managable,\n            \"enabled\": plugin.enabled,\n            \"blacklisted\": plugin.blacklisted,\n            \"forced_disabled\": plugin.forced_disabled,\n            \"incompatible\": plugin.incompatible,\n            \"safe_mode_victim\": getattr(plugin, \"safe_mode_victim\", False),\n            \"pending_enable\": (\n                not plugin.enabled\n                and not getattr(plugin, \"safe_mode_victim\", False)\n                and plugin.key in self._pending_enable\n            ),\n            \"pending_disable\": (\n                (plugin.enabled or getattr(plugin, \"safe_mode_victim\", False))\n                and plugin.key in self._pending_disable\n            ),\n            \"pending_install\": (\n                self._plugin_manager.is_plugin_marked(plugin.key, \"installed\")\n            ),\n            \"pending_uninstall\": (\n                self._plugin_manager.is_plugin_marked(plugin.key, \"uninstalled\")\n            ),\n            \"origin\": plugin.origin.type,\n            \"notifications\": self._get_notifications(plugin),\n        }\n\n    def _get_notifications(self, plugin):\n        key = plugin.key\n        if not plugin.enabled:\n            return\n\n        if key not in self._notices:\n            return\n\n        octoprint_version = get_octoprint_version(base=True)\n        plugin_notifications = self._notices.get(key, [])\n\n        def map_notification(notification):\n            return self._to_external_notification(key, notification)\n\n        return list(\n            filter(\n                lambda x: x is not None,\n                map(\n                    map_notification,\n                    filter(\n                        lambda n: _filter_relevant_notification(\n                            n, plugin.version, octoprint_version\n                        ),\n                        plugin_notifications,\n                    ),\n                ),\n            )\n        )\n\n    def _to_external_notification(self, key, notification):\n        return {\n            \"key\": key,\n            \"date\": time.mktime(notification[\"timestamp\"]),\n            \"text\": notification[\"text\"],\n            \"link\": notification.get(\"link\"),\n            \"versions\": notification.get(\n                \"pluginversions\", notification.get(\"versions\", [])\n            ),\n            \"important\": notification.get(\"important\", False),\n        }\n\n\n@pylru.lrudecorator(size=127)\ndef parse_requirement(line):\n    return pkg_resources.Requirement.parse(line)\n\n\ndef _filter_relevant_notification(notification, plugin_version, octoprint_version):\n    if \"pluginversions\" in notification:\n        pluginversions = notification[\"pluginversions\"]\n\n        is_range = lambda x: \"=\" in x or \">\" in x or \"<\" in x\n        version_ranges = list(\n            map(\n                lambda x: parse_requirement(notification[\"plugin\"] + x),\n                filter(is_range, pluginversions),\n            )\n        )\n        versions = list(filter(lambda x: not is_range(x), pluginversions))\n    elif \"versions\" in notification:\n        version_ranges = []\n        versions = notification[\"versions\"]\n    else:\n        version_ranges = versions = None\n\n    return (\n        \"text\" in notification\n        and \"date\" in notification\n        and (\n            (version_ranges is None and versions is None)\n            or (\n                version_ranges\n                and (any(map(lambda v: plugin_version in v, version_ranges)))\n            )\n            or (versions and plugin_version in versions)\n        )\n        and (\n            \"octoversions\" not in notification\n            or is_octoprint_compatible(\n                *notification[\"octoversions\"], octoprint_version=octoprint_version\n            )\n        )\n    )\n\n\ndef _register_custom_events(*args, **kwargs):\n    return [\"install_plugin\", \"uninstall_plugin\", \"enable_plugin\", \"disable_plugin\"]\n\n\n__plugin_name__ = \"Plugin Manager\"\n__plugin_author__ = \"Gina H\u00e4u\u00dfge\"\n__plugin_url__ = \"https://docs.octoprint.org/en/master/bundledplugins/pluginmanager.html\"\n__plugin_description__ = \"Allows installing and managing OctoPrint plugins\"\n__plugin_license__ = \"AGPLv3\"\n__plugin_pythoncompat__ = \">=3.7,<4\"\n__plugin_hidden__ = True\n\n\ndef __plugin_load__():\n    global __plugin_implementation__\n    __plugin_implementation__ = PluginManagerPlugin()\n\n    global __plugin_hooks__\n    __plugin_hooks__ = {\n        \"octoprint.server.http.bodysize\": __plugin_implementation__.increase_upload_bodysize,\n        \"octoprint.ui.web.templatetypes\": __plugin_implementation__.get_template_types,\n        \"octoprint.events.register_custom_events\": _register_custom_events,\n        \"octoprint.access.permissions\": __plugin_implementation__.get_additional_permissions,\n        \"octoprint.systeminfo.additional_bundle_files\": __plugin_implementation__.get_additional_bundle_files,\n    }\n\n    global __plugin_helpers__\n    __plugin_helpers__ = {\n        \"generate_plugins_json\": __plugin_implementation__.generate_plugins_json,\n    }\n"], "filenames": ["src/octoprint/plugins/pluginmanager/__init__.py"], "buggy_code_start_loc": [231], "buggy_code_end_loc": [232], "fixing_code_start_loc": [231], "fixing_code_end_loc": [232], "type": "CWE-269", "message": "Improper Privilege Management in GitHub repository octoprint/octoprint prior to 1.8.3.", "other": {"cve": {"id": "CVE-2022-3068", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-21T12:15:10.280", "lastModified": "2022-09-22T15:36:39.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Privilege Management in GitHub repository octoprint/octoprint prior to 1.8.3."}, {"lang": "es", "value": "Una Administraci\u00f3n Inapropiada de Privilegios en el repositorio de GitHub octoprint/octoprint versiones anteriores a 1.8.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octoprint:octoprint:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.3", "matchCriteriaId": "900F81F7-9FC4-44CE-ABD6-1E82DC120B4B"}]}]}], "references": [{"url": "https://github.com/octoprint/octoprint/commit/ef95ef1c101b79394f134e8fce000e6bae046571", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f45c24cb-9104-4c6e-a9e1-5c7e75e83884", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octoprint/octoprint/commit/ef95ef1c101b79394f134e8fce000e6bae046571"}}