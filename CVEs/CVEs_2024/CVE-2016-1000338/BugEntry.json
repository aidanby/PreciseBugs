{"buggy_code": ["package org.bouncycastle.jcajce.provider.asymmetric.dsa;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.SignatureException;\nimport java.security.SignatureSpi;\nimport java.security.interfaces.DSAKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x509.X509ObjectIdentifiers;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.digests.NullDigest;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA384Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.HMacDSAKCalculator;\n\npublic class DSASigner\n    extends SignatureSpi\n    implements PKCSObjectIdentifiers, X509ObjectIdentifiers\n{\n    private Digest                  digest;\n    private DSA                     signer;\n    private SecureRandom            random;\n\n    protected DSASigner(\n        Digest digest,\n        DSA signer)\n    {\n        this.digest = digest;\n        this.signer = signer;\n    }\n\n    protected void engineInitVerify(\n        PublicKey   publicKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePublicKeyParameter(publicKey);\n\n        digest.reset();\n        signer.init(false, param);\n    }\n\n    protected void engineInitSign(\n        PrivateKey      privateKey,\n        SecureRandom    random)\n        throws InvalidKeyException\n    {\n        this.random = random;\n        engineInitSign(privateKey);\n    }\n\n    protected void engineInitSign(\n        PrivateKey  privateKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePrivateKeyParameter(privateKey);\n\n        if (random != null)\n        {\n            param = new ParametersWithRandom(param, random);\n        }\n\n        digest.reset();\n        signer.init(true, param);\n    }\n\n    protected void engineUpdate(\n        byte    b)\n        throws SignatureException\n    {\n        digest.update(b);\n    }\n\n    protected void engineUpdate(\n        byte[]  b,\n        int     off,\n        int     len) \n        throws SignatureException\n    {\n        digest.update(b, off, len);\n    }\n\n    protected byte[] engineSign()\n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        try\n        {\n            BigInteger[]    sig = signer.generateSignature(hash);\n\n            return derEncode(sig[0], sig[1]);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(e.toString());\n        }\n    }\n\n    protected boolean engineVerify(\n        byte[]  sigBytes) \n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        BigInteger[]    sig;\n\n        try\n        {\n            sig = derDecode(sigBytes);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(\"error decoding signature bytes.\");\n        }\n\n        return signer.verifySignature(hash, sig[0], sig[1]);\n    }\n\n    protected void engineSetParameter(\n        AlgorithmParameterSpec params)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated replaced with <a href = \"#engineSetParameter(java.security.spec.AlgorithmParameterSpec)\">\n     */\n    protected void engineSetParameter(\n        String  param,\n        Object  value)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated\n     */\n    protected Object engineGetParameter(\n        String      param)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    private byte[] derEncode(\n        BigInteger  r,\n        BigInteger  s)\n        throws IOException\n    {\n        ASN1Integer[] rs = new ASN1Integer[]{ new ASN1Integer(r), new ASN1Integer(s) };\n        return new DERSequence(rs).getEncoded(ASN1Encoding.DER);\n    }\n\n    private BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n        return new BigInteger[]{\n            ((ASN1Integer)s.getObjectAt(0)).getValue(),\n            ((ASN1Integer)s.getObjectAt(1)).getValue()\n        };\n    }\n\n    static public class stdDSA\n        extends DSASigner\n    {\n        public stdDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA\n        extends DSASigner\n    {\n        public detDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA1Digest())));\n        }\n    }\n\n    static public class dsa224\n        extends DSASigner\n    {\n        public dsa224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA224\n        extends DSASigner\n    {\n        public detDSA224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA224Digest())));\n        }\n    }\n\n    static public class dsa256\n        extends DSASigner\n    {\n        public dsa256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA256\n        extends DSASigner\n    {\n        public detDSA256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA256Digest())));\n        }\n    }\n\n    static public class dsa384\n        extends DSASigner\n    {\n        public dsa384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA384\n        extends DSASigner\n    {\n        public detDSA384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA384Digest())));\n        }\n    }\n\n    static public class dsa512\n        extends DSASigner\n    {\n        public dsa512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA512\n        extends DSASigner\n    {\n        public detDSA512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA512Digest())));\n        }\n    }\n\n    static public class dsaSha3_224\n        extends DSASigner\n    {\n        public dsaSha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_224\n        extends DSASigner\n    {\n        public detDSASha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(224))));\n        }\n    }\n\n    static public class dsaSha3_256\n        extends DSASigner\n    {\n        public dsaSha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_256\n        extends DSASigner\n    {\n        public detDSASha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(256))));\n        }\n    }\n\n    static public class dsaSha3_384\n        extends DSASigner\n    {\n        public dsaSha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_384\n        extends DSASigner\n    {\n        public detDSASha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(384))));\n        }\n    }\n\n    static public class dsaSha3_512\n        extends DSASigner\n    {\n        public dsaSha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_512\n        extends DSASigner\n    {\n        public detDSASha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(512))));\n        }\n    }\n\n    static public class noneDSA\n        extends DSASigner\n    {\n        public noneDSA()\n        {\n            super(new NullDigest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.spec.DSAParameterSpec;\nimport java.security.spec.DSAPrivateKeySpec;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveGenParameterSpec;\nimport org.bouncycastle.jce.spec.ECParameterSpec;\nimport org.bouncycastle.jce.spec.ECPrivateKeySpec;\nimport org.bouncycastle.jce.spec.ECPublicKeySpec;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(new byte[][] { k1, k2 });\n\n    private void testCompat()\n        throws Exception\n    {\n        if (Security.getProvider(\"SUN\") == null)\n        {\n            return;\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"SUN\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"SUN\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        g.initialize(512, new SecureRandom());\n        \n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        //\n        // sign SUN - verify with BC \n        //\n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"SUN -> BC verification failed\");\n        }\n        \n        //\n        // sign BC - verify with SUN\n        //\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"SUN\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"BC -> SUN verification failed\");\n        }\n\n        //\n        // key encoding test - BC decoding Sun keys\n        //\n        KeyFactory          f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec  x509s = new X509EncodedKeySpec(vKey.getEncoded());\n\n        DSAPublicKey        k1 = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        PKCS8EncodedKeySpec  pkcs8 = new PKCS8EncodedKeySpec(sKey.getEncoded());\n\n        DSAPrivateKey        k2 = (DSAPrivateKey)f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n        \n        //\n        // key decoding test - SUN decoding BC keys\n        // \n        f = KeyFactory.getInstance(\"DSA\", \"SUN\");\n        x509s = new X509EncodedKeySpec(k1.getEncoded());\n        \n        vKey = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        pkcs8 = new PKCS8EncodedKeySpec(k2.getEncoded());\n        sKey = f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n    }\n\n    private void testNullParameters()\n        throws Exception\n    {\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec x509s = new X509EncodedKeySpec(new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa), new ASN1Integer(10001)).getEncoded());\n\n        DSAPublicKey key1 = (DSAPublicKey)f.generatePublic(x509s);\n        DSAPublicKey key2 = (DSAPublicKey)f.generatePublic(x509s);\n\n        isTrue(\"parameters not absent\", key1.getParams() == null && key2.getParams() == null);\n        isTrue(\"hashCode mismatch\", key1.hashCode() == key2.hashCode());\n        isTrue(\"not equal\", key1.equals(key2));\n        isTrue(\"encoding mismatch\", Arrays.areEqual(x509s.getEncoded(), key1.getEncoded()));\n    }\n\n    private void testValidate()\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        try\n        {\n            f.generatePublic(new DSAPublicKeySpec(BigInteger.valueOf(1), dsaParams.getP(), dsaParams.getG(), dsaParams.getQ()));\n\n            fail(\"no exception\");\n        }\n        catch (Exception e)\n        {\n            isTrue(\"mismatch\", \"invalid KeySpec: y value does not appear to be in correct group\".equals(e.getMessage()));\n        }\n    }\n\n    private void testNONEwithDSA()\n        throws Exception\n    {\n        byte[] dummySha1 = Hex.decode(\"01020304050607080910111213141516\");\n\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        KeyPair          kp = kpGen.generateKeyPair();\n\n        Signature        sig = Signature.getInstance(\"NONEwithDSA\", \"BC\");\n\n        sig.initSign(kp.getPrivate());\n\n        sig.update(dummySha1);\n\n        byte[] sigBytes = sig.sign();\n\n        sig.initVerify(kp.getPublic());\n\n        sig.update(dummySha1);\n\n        sig.verify(sigBytes);\n\n        // reset test\n\n        sig.update(dummySha1);\n\n        if (!sig.verify(sigBytes))\n        {\n            fail(\"NONEwithDSA failed to reset\");\n        }\n\n        // lightweight test\n        DSAPublicKey  key = (DSAPublicKey)kp.getPublic();\n        DSAParameters params = new DSAParameters(key.getParams().getP(), key.getParams().getQ(), key.getParams().getG());\n        DSAPublicKeyParameters keyParams = new DSAPublicKeyParameters(key.getY(), params);\n        DSASigner signer = new DSASigner();\n        ASN1Sequence derSig = ASN1Sequence.getInstance(ASN1Primitive.fromByteArray(sigBytes));\n\n        signer.init(false, keyParams);\n\n        if (!signer.verifySignature(dummySha1, ASN1Integer.getInstance(derSig.getObjectAt(0)).getValue(), ASN1Integer.getInstance(derSig.getObjectAt(1)).getValue()))\n        {\n            fail(\"NONEwithDSA not really NONE!\");\n        }\n    }\n\n    private void checkPublic(DSAPublicKey k1, PublicKey vKey)\n    {\n        if (!k1.getY().equals(((DSAPublicKey)vKey).getY()))\n        {\n            fail(\"public number not decoded properly\");\n        }\n\n        if (!k1.getParams().getG().equals(((DSAPublicKey)vKey).getParams().getG()))\n        {\n            fail(\"public generator not decoded properly\");\n        }\n\n        if (!k1.getParams().getP().equals(((DSAPublicKey)vKey).getParams().getP()))\n        {\n            fail(\"public p value not decoded properly\");\n        }\n\n        if (!k1.getParams().getQ().equals(((DSAPublicKey)vKey).getParams().getQ()))\n        {\n            fail(\"public q value not decoded properly\");\n        }\n    }\n\n    private void checkPrivateKey(DSAPrivateKey k2, PrivateKey sKey)\n    {\n        if (!k2.getX().equals(((DSAPrivateKey)sKey).getX()))\n        {\n            fail(\"private number not decoded properly\");\n        }\n\n        if (!k2.getParams().getG().equals(((DSAPrivateKey)sKey).getParams().getG()))\n        {\n            fail(\"private generator not decoded properly\");\n        }\n\n        if (!k2.getParams().getP().equals(((DSAPrivateKey)sKey).getParams().getP()))\n        {\n            fail(\"private p value not decoded properly\");\n        }\n\n        if (!k2.getParams().getQ().equals(((DSAPrivateKey)sKey).getParams().getQ()))\n        {\n            fail(\"private q value not decoded properly\");\n        }\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n        \n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n        \n        \n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n        \n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n        \n        Signature           sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n        \n        sgr.initSign(sKey, k);\n        \n        byte[] message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n        \n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n        \n        sgr.initVerify(vKey);\n        \n        sgr.update(message);\n        \n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n        \n        BigInteger[]  sig = derDecode(sigBytes);\n        \n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + r + Strings.lineSeparator()\n                    + \" got      : \" + sig[0]);\n        }\n        \n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + s + Strings.lineSeparator()\n                    + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testNONEwithECDSA239bitPrime()\n        throws Exception\n    {\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n\n        Signature           sgr = Signature.getInstance(\"NONEwithECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n\n        byte[] message = \"abc\".getBytes();\n        byte[] sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e64cb19604be06c57e761b3de5518f71de0f6e0cd2df677cec8a6ffcb690d\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"abcdefghijklmnopqrstuvwxyz\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e43fd65b3363d76aabef8630572257dbb67c82818ad9fad31256539b1b02c\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"a very very long message gauranteed to cause an overflow\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e7d5be84b22937a1691859a3c6fe45ed30b108574431d01b34025825ec17a\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n    }\n\n    private void testECDSAP256sha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        X9ECParameters p = NISTNamedCurves.getByName(\"P-256\");\n        KeyFactory ecKeyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECDomainParameters params = new ECDomainParameters(p.getCurve(), p.getG(), p.getN(), p.getH());\n\n        ECCurve curve = p.getCurve();\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                p.getG(), // G\n                p.getN()); // n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"20186677036482506117540275567393538695075300175221296989956723148347484984008\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            params.getCurve().decodePoint(Hex.decode(\"03596375E6CE57E0F20294FC46BDFCFD19A39F8161B58695B3EC5B3D16427C274D\")), // Q\n            spec);\n\n        doEcDsaTest(\"SHA3-\" + size + \"withECDSA\", s, ecKeyFact, pubKey, priKey);\n        doEcDsaTest(sigOid.getId(), s, ecKeyFact, pubKey, priKey);\n    }\n\n    private void doEcDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, ECPublicKeySpec pubKey, ECPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"97354732615802252173078420023658453040116611318111190383344590814578738210384\");\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void testDSAsha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeySpec priKey = new DSAPrivateKeySpec(\n                x, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        DSAPublicKeySpec pubKey = new DSAPublicKeySpec(\n            y, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        KeyFactory dsaKeyFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        doDsaTest(\"SHA3-\" + size + \"withDSA\", s, dsaKeyFact, pubKey, priKey);\n        doDsaTest(sigOid.getId(), s, dsaKeyFact, pubKey, priKey);\n    }\n\n    private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void checkMessage(Signature sgr, PrivateKey sKey, PublicKey vKey, byte[] message, byte[] sig)\n        throws InvalidKeyException, SignatureException\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        if (!Arrays.areEqual(sigBytes, sig))\n        {\n            fail(new String(message) + \" signature incorrect\");\n        }\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(new String(message) + \" verification failed\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n    \n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n    \n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n    \n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n        \n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n    \n        Signature   sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n       \n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testECDSA239bitBinary(String algorithm, ASN1ObjectIdentifier oid)\n        throws Exception\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n\n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n\n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n\n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n\n        Signature   sgr = Signature.getInstance(algorithm, \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        sgr = Signature.getInstance(oid.getId(), \"BC\");\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC RIPEMD160 verification failed\");\n        }\n    }\n\n    private void testGeneration()\n        throws Exception\n    {\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n\n        // test exception\n        //\n        try\n        {\n            g.initialize(513, new SecureRandom());\n\n            fail(\"illegal parameter 513 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(510, new SecureRandom());\n\n            fail(\"illegal parameter 510 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(1025, new SecureRandom());\n\n            fail(\"illegal parameter 1025 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        g.initialize(512, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        DSAPublicKey k1 = (DSAPublicKey)serializeDeserialize(vKey);\n\n        checkPublic(k1, vKey);\n\n        checkEquals(k1, vKey);\n\n        DSAPrivateKey k2 = (DSAPrivateKey)serializeDeserialize(sKey);\n\n        checkPrivateKey(k2, sKey);\n\n        checkEquals(k2, sKey);\n\n        if (!(k2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // ECDSA Fp generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        ECCurve curve = new ECCurve.Fp(\n            new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        PublicKey eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        PrivateKey eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        // Named curve parameter\n        g.initialize(new ECNamedCurveGenParameterSpec(\"P-256\"), new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        //\n        // ECDSA F2m generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        curve = new ECCurve.F2m(\n                239, // m\n                36, // k\n                new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n                new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n        \n        ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n        \n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        if (!(eck2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n    }\n\n    private void checkEquals(Object o1, Object o2)\n    {\n        if (!o1.equals(o2))\n        {\n            fail(\"comparison test failed\");\n        }\n\n        if (o1.hashCode() != o2.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n    }\n    \n    private void testParameters()\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(512, random);\n        AlgorithmParameters params = a.generateParameters();\n        \n        byte[] encodeParams = params.getEncoded();\n        \n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n        \n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n        \n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n        \n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n        \n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new SecureRandom());\n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    private void testDSA2Parameters()\n        throws Exception\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(2048, new DSATestSecureRandom(seed));\n        AlgorithmParameters params = a.generateParameters();\n\n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n\n        if (!dsaP.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!dsaP.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!dsaP.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new TestRandomBigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")));\n        KeyPair p = g.generateKeyPair();\n\n        DSAPrivateKey  sKey = (DSAPrivateKey)p.getPrivate();\n        DSAPublicKey   vKey = (DSAPublicKey)p.getPublic();\n\n        if (!vKey.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!sKey.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testCompat();\n        testNONEwithDSA();\n\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_224, 224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_256, 256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_384, 384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_512, 512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n\n        testECDSA239bitPrime();\n        testNONEwithECDSA239bitPrime();\n        testECDSA239bitBinary();\n        testECDSA239bitBinary(\"RIPEMD160withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n        testECDSA239bitBinary(\"SHA1withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithSha1);\n        testECDSA239bitBinary(\"SHA224withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n        testECDSA239bitBinary(\"SHA256withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n        testECDSA239bitBinary(\"SHA384withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n        testECDSA239bitBinary(\"SHA512withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n        testECDSA239bitBinary(\"SHA1withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n        testECDSA239bitBinary(\"SHA224withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n        testECDSA239bitBinary(\"SHA256withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n        testECDSA239bitBinary(\"SHA384withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n        testECDSA239bitBinary(\"SHA512withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_224, 224, new BigInteger(\"84d7d8e68e405064109cd9fc3e3026d74d278aada14ce6b7a9dd0380c154dc94\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_256, 256, new BigInteger(\"99a43bdab4af989aaf2899079375642f2bae2dce05bcd8b72ec8c4a8d9a143f\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_384, 384, new BigInteger(\"aa27726509c37aaf601de6f7e01e11c19add99530c9848381c23365dc505b11a\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_512, 512, new BigInteger(\"f8306b57a1f5068bf12e53aabaae39e2658db39bc56747eaefb479995130ad16\", 16));\n\n        testGeneration();\n        testParameters();\n        testDSA2Parameters();\n        testNullParameters();\n        testValidate();\n    }\n\n    protected BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ByteArrayInputStream    bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream         aIn = new ASN1InputStream(bIn);\n        ASN1Sequence            s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[]            sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"DSA/ECDSA\";\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.jcajce.provider.asymmetric.dsa;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.SignatureException;\nimport java.security.SignatureSpi;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.X509ObjectIdentifiers;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.digests.NullDigest;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA384Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.HMacDSAKCalculator;\n\npublic class DSASigner\n    extends SignatureSpi\n    implements PKCSObjectIdentifiers, X509ObjectIdentifiers\n{\n    private Digest                  digest;\n    private DSA                     signer;\n    private SecureRandom            random;\n\n    protected DSASigner(\n        Digest digest,\n        DSA signer)\n    {\n        this.digest = digest;\n        this.signer = signer;\n    }\n\n    protected void engineInitVerify(\n        PublicKey   publicKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePublicKeyParameter(publicKey);\n\n        digest.reset();\n        signer.init(false, param);\n    }\n\n    protected void engineInitSign(\n        PrivateKey      privateKey,\n        SecureRandom    random)\n        throws InvalidKeyException\n    {\n        this.random = random;\n        engineInitSign(privateKey);\n    }\n\n    protected void engineInitSign(\n        PrivateKey  privateKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePrivateKeyParameter(privateKey);\n\n        if (random != null)\n        {\n            param = new ParametersWithRandom(param, random);\n        }\n\n        digest.reset();\n        signer.init(true, param);\n    }\n\n    protected void engineUpdate(\n        byte    b)\n        throws SignatureException\n    {\n        digest.update(b);\n    }\n\n    protected void engineUpdate(\n        byte[]  b,\n        int     off,\n        int     len) \n        throws SignatureException\n    {\n        digest.update(b, off, len);\n    }\n\n    protected byte[] engineSign()\n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        try\n        {\n            BigInteger[]    sig = signer.generateSignature(hash);\n\n            return derEncode(sig[0], sig[1]);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(e.toString());\n        }\n    }\n\n    protected boolean engineVerify(\n        byte[]  sigBytes) \n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        BigInteger[]    sig;\n\n        try\n        {\n            sig = derDecode(sigBytes);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(\"error decoding signature bytes.\");\n        }\n\n        return signer.verifySignature(hash, sig[0], sig[1]);\n    }\n\n    protected void engineSetParameter(\n        AlgorithmParameterSpec params)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated replaced with <a href = \"#engineSetParameter(java.security.spec.AlgorithmParameterSpec)\">\n     */\n    protected void engineSetParameter(\n        String  param,\n        Object  value)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated\n     */\n    protected Object engineGetParameter(\n        String      param)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    private byte[] derEncode(\n        BigInteger  r,\n        BigInteger  s)\n        throws IOException\n    {\n        ASN1Integer[] rs = new ASN1Integer[]{ new ASN1Integer(r), new ASN1Integer(s) };\n        return new DERSequence(rs).getEncoded(ASN1Encoding.DER);\n    }\n\n    private BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n        if (s.size() != 2)\n        {\n            throw new IOException(\"malformed signature\");\n        }\n\n        return new BigInteger[]{\n            ((ASN1Integer)s.getObjectAt(0)).getValue(),\n            ((ASN1Integer)s.getObjectAt(1)).getValue()\n        };\n    }\n\n    static public class stdDSA\n        extends DSASigner\n    {\n        public stdDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA\n        extends DSASigner\n    {\n        public detDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA1Digest())));\n        }\n    }\n\n    static public class dsa224\n        extends DSASigner\n    {\n        public dsa224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA224\n        extends DSASigner\n    {\n        public detDSA224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA224Digest())));\n        }\n    }\n\n    static public class dsa256\n        extends DSASigner\n    {\n        public dsa256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA256\n        extends DSASigner\n    {\n        public detDSA256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA256Digest())));\n        }\n    }\n\n    static public class dsa384\n        extends DSASigner\n    {\n        public dsa384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA384\n        extends DSASigner\n    {\n        public detDSA384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA384Digest())));\n        }\n    }\n\n    static public class dsa512\n        extends DSASigner\n    {\n        public dsa512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA512\n        extends DSASigner\n    {\n        public detDSA512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA512Digest())));\n        }\n    }\n\n    static public class dsaSha3_224\n        extends DSASigner\n    {\n        public dsaSha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_224\n        extends DSASigner\n    {\n        public detDSASha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(224))));\n        }\n    }\n\n    static public class dsaSha3_256\n        extends DSASigner\n    {\n        public dsaSha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_256\n        extends DSASigner\n    {\n        public detDSASha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(256))));\n        }\n    }\n\n    static public class dsaSha3_384\n        extends DSASigner\n    {\n        public dsaSha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_384\n        extends DSASigner\n    {\n        public detDSASha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(384))));\n        }\n    }\n\n    static public class dsaSha3_512\n        extends DSASigner\n    {\n        public dsaSha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_512\n        extends DSASigner\n    {\n        public detDSASha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(512))));\n        }\n    }\n\n    static public class noneDSA\n        extends DSASigner\n    {\n        public noneDSA()\n        {\n            super(new NullDigest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.spec.DSAParameterSpec;\nimport java.security.spec.DSAPrivateKeySpec;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveGenParameterSpec;\nimport org.bouncycastle.jce.spec.ECParameterSpec;\nimport org.bouncycastle.jce.spec.ECPrivateKeySpec;\nimport org.bouncycastle.jce.spec.ECPublicKeySpec;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(new byte[][] { k1, k2 });\n\n    // DSA modified signatures, courtesy of the Google security team\n    static final DSAPrivateKeySpec PRIVATE_KEY = new DSAPrivateKeySpec(\n        // x\n        new BigInteger(\n            \"15382583218386677486843706921635237927801862255437148328980464126979\"),\n        // p\n        new BigInteger(\n            \"181118486631420055711787706248812146965913392568235070235446058914\"\n            + \"1170708161715231951918020125044061516370042605439640379530343556\"\n            + \"4101919053459832890139496933938670005799610981765220283775567361\"\n            + \"4836626483403394052203488713085936276470766894079318754834062443\"\n            + \"1033792580942743268186462355159813630244169054658542719322425431\"\n            + \"4088256212718983105131138772434658820375111735710449331518776858\"\n            + \"7867938758654181244292694091187568128410190746310049564097068770\"\n            + \"8161261634790060655580211122402292101772553741704724263582994973\"\n            + \"9109274666495826205002104010355456981211025738812433088757102520\"\n            + \"562459649777989718122219159982614304359\"),\n        // q\n        new BigInteger(\n            \"19689526866605154788513693571065914024068069442724893395618704484701\"),\n        // g\n        new BigInteger(\n            \"2859278237642201956931085611015389087970918161297522023542900348\"\n            + \"0877180630984239764282523693409675060100542360520959501692726128\"\n            + \"3149190229583566074777557293475747419473934711587072321756053067\"\n            + \"2532404847508798651915566434553729839971841903983916294692452760\"\n            + \"2490198571084091890169933809199002313226100830607842692992570749\"\n            + \"0504363602970812128803790973955960534785317485341020833424202774\"\n            + \"0275688698461842637641566056165699733710043802697192696426360843\"\n            + \"1736206792141319514001488556117408586108219135730880594044593648\"\n            + \"9237302749293603778933701187571075920849848690861126195402696457\"\n            + \"4111219599568903257472567764789616958430\"));\n\n    static final DSAPublicKeySpec PUBLIC_KEY = new DSAPublicKeySpec(\n        new BigInteger(\n            \"3846308446317351758462473207111709291533523711306097971550086650\"\n            + \"2577333637930103311673872185522385807498738696446063139653693222\"\n            + \"3528823234976869516765207838304932337200968476150071617737755913\"\n            + \"3181601169463467065599372409821150709457431511200322947508290005\"\n            + \"1780020974429072640276810306302799924668893998032630777409440831\"\n            + \"4314588994475223696460940116068336991199969153649625334724122468\"\n            + \"7497038281983541563359385775312520539189474547346202842754393945\"\n            + \"8755803223951078082197762886933401284142487322057236814878262166\"\n            + \"5072306622943221607031324846468109901964841479558565694763440972\"\n            + \"5447389416166053148132419345627682740529\"),\n         PRIVATE_KEY.getP(),\n         PRIVATE_KEY.getQ(),\n         PRIVATE_KEY.getG());\n\n    // The following test vectors check for signature malleability and bugs. That means the test\n    // vectors are derived from a valid signature by modifying the ASN encoding. A correct\n    // implementation of DSA should only accept correct DER encoding and properly handle the others.\n    // Allowing alternative BER encodings is in many cases benign. An example where this kind of\n    // signature malleability was a problem: https://en.bitcoin.it/wiki/Transaction_Malleability\n    static final String[] MODIFIED_SIGNATURES  = {\n        \"303e02811c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f0282001c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021d001e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd02811d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd0282001d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021e0000ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"30813d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"3082003d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9ef4\"\n        + \"1dd424a4e1c8f16967cf3365813fe87862360000\",\n        \"3040021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca8021d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3040100\"\n    };\n\n    private void testModified()\n        throws Exception\n    {\n        KeyFactory kFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n        PublicKey pubKey = kFact.generatePublic(PUBLIC_KEY);\n        Signature sig = Signature.getInstance(\"DSA\", \"BC\");\n\n        for (int i = 0; i != MODIFIED_SIGNATURES.length; i++)\n        {\n            sig.initVerify(pubKey);\n\n            sig.update(Strings.toByteArray(\"Hello\"));\n\n            boolean failed;\n\n            try\n            {\n                failed = !sig.verify(Hex.decode(MODIFIED_SIGNATURES[i]));\n            }\n            catch (SignatureException e)\n            {\n                failed = true;\n            }\n\n            isTrue(\"sig verified when shouldn't\", failed);\n        }\n    }\n\n    private void testCompat()\n        throws Exception\n    {\n        if (Security.getProvider(\"SUN\") == null)\n        {\n            return;\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"SUN\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"SUN\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        g.initialize(512, new SecureRandom());\n        \n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        //\n        // sign SUN - verify with BC \n        //\n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"SUN -> BC verification failed\");\n        }\n        \n        //\n        // sign BC - verify with SUN\n        //\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"SUN\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"BC -> SUN verification failed\");\n        }\n\n        //\n        // key encoding test - BC decoding Sun keys\n        //\n        KeyFactory          f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec  x509s = new X509EncodedKeySpec(vKey.getEncoded());\n\n        DSAPublicKey        k1 = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        PKCS8EncodedKeySpec  pkcs8 = new PKCS8EncodedKeySpec(sKey.getEncoded());\n\n        DSAPrivateKey        k2 = (DSAPrivateKey)f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n        \n        //\n        // key decoding test - SUN decoding BC keys\n        // \n        f = KeyFactory.getInstance(\"DSA\", \"SUN\");\n        x509s = new X509EncodedKeySpec(k1.getEncoded());\n        \n        vKey = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        pkcs8 = new PKCS8EncodedKeySpec(k2.getEncoded());\n        sKey = f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n    }\n\n    private void testNullParameters()\n        throws Exception\n    {\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec x509s = new X509EncodedKeySpec(new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa), new ASN1Integer(10001)).getEncoded());\n\n        DSAPublicKey key1 = (DSAPublicKey)f.generatePublic(x509s);\n        DSAPublicKey key2 = (DSAPublicKey)f.generatePublic(x509s);\n\n        isTrue(\"parameters not absent\", key1.getParams() == null && key2.getParams() == null);\n        isTrue(\"hashCode mismatch\", key1.hashCode() == key2.hashCode());\n        isTrue(\"not equal\", key1.equals(key2));\n        isTrue(\"encoding mismatch\", Arrays.areEqual(x509s.getEncoded(), key1.getEncoded()));\n    }\n\n    private void testValidate()\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        try\n        {\n            f.generatePublic(new DSAPublicKeySpec(BigInteger.valueOf(1), dsaParams.getP(), dsaParams.getG(), dsaParams.getQ()));\n\n            fail(\"no exception\");\n        }\n        catch (Exception e)\n        {\n            isTrue(\"mismatch\", \"invalid KeySpec: y value does not appear to be in correct group\".equals(e.getMessage()));\n        }\n    }\n\n    private void testNONEwithDSA()\n        throws Exception\n    {\n        byte[] dummySha1 = Hex.decode(\"01020304050607080910111213141516\");\n\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        KeyPair          kp = kpGen.generateKeyPair();\n\n        Signature        sig = Signature.getInstance(\"NONEwithDSA\", \"BC\");\n\n        sig.initSign(kp.getPrivate());\n\n        sig.update(dummySha1);\n\n        byte[] sigBytes = sig.sign();\n\n        sig.initVerify(kp.getPublic());\n\n        sig.update(dummySha1);\n\n        sig.verify(sigBytes);\n\n        // reset test\n\n        sig.update(dummySha1);\n\n        if (!sig.verify(sigBytes))\n        {\n            fail(\"NONEwithDSA failed to reset\");\n        }\n\n        // lightweight test\n        DSAPublicKey  key = (DSAPublicKey)kp.getPublic();\n        DSAParameters params = new DSAParameters(key.getParams().getP(), key.getParams().getQ(), key.getParams().getG());\n        DSAPublicKeyParameters keyParams = new DSAPublicKeyParameters(key.getY(), params);\n        DSASigner signer = new DSASigner();\n        ASN1Sequence derSig = ASN1Sequence.getInstance(ASN1Primitive.fromByteArray(sigBytes));\n\n        signer.init(false, keyParams);\n\n        if (!signer.verifySignature(dummySha1, ASN1Integer.getInstance(derSig.getObjectAt(0)).getValue(), ASN1Integer.getInstance(derSig.getObjectAt(1)).getValue()))\n        {\n            fail(\"NONEwithDSA not really NONE!\");\n        }\n    }\n\n    private void checkPublic(DSAPublicKey k1, PublicKey vKey)\n    {\n        if (!k1.getY().equals(((DSAPublicKey)vKey).getY()))\n        {\n            fail(\"public number not decoded properly\");\n        }\n\n        if (!k1.getParams().getG().equals(((DSAPublicKey)vKey).getParams().getG()))\n        {\n            fail(\"public generator not decoded properly\");\n        }\n\n        if (!k1.getParams().getP().equals(((DSAPublicKey)vKey).getParams().getP()))\n        {\n            fail(\"public p value not decoded properly\");\n        }\n\n        if (!k1.getParams().getQ().equals(((DSAPublicKey)vKey).getParams().getQ()))\n        {\n            fail(\"public q value not decoded properly\");\n        }\n    }\n\n    private void checkPrivateKey(DSAPrivateKey k2, PrivateKey sKey)\n    {\n        if (!k2.getX().equals(((DSAPrivateKey)sKey).getX()))\n        {\n            fail(\"private number not decoded properly\");\n        }\n\n        if (!k2.getParams().getG().equals(((DSAPrivateKey)sKey).getParams().getG()))\n        {\n            fail(\"private generator not decoded properly\");\n        }\n\n        if (!k2.getParams().getP().equals(((DSAPrivateKey)sKey).getParams().getP()))\n        {\n            fail(\"private p value not decoded properly\");\n        }\n\n        if (!k2.getParams().getQ().equals(((DSAPrivateKey)sKey).getParams().getQ()))\n        {\n            fail(\"private q value not decoded properly\");\n        }\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n        \n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n        \n        \n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n        \n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n        \n        Signature           sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n        \n        sgr.initSign(sKey, k);\n        \n        byte[] message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n        \n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n        \n        sgr.initVerify(vKey);\n        \n        sgr.update(message);\n        \n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n        \n        BigInteger[]  sig = derDecode(sigBytes);\n        \n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + r + Strings.lineSeparator()\n                    + \" got      : \" + sig[0]);\n        }\n        \n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + s + Strings.lineSeparator()\n                    + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testNONEwithECDSA239bitPrime()\n        throws Exception\n    {\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n\n        Signature           sgr = Signature.getInstance(\"NONEwithECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n\n        byte[] message = \"abc\".getBytes();\n        byte[] sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e64cb19604be06c57e761b3de5518f71de0f6e0cd2df677cec8a6ffcb690d\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"abcdefghijklmnopqrstuvwxyz\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e43fd65b3363d76aabef8630572257dbb67c82818ad9fad31256539b1b02c\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"a very very long message gauranteed to cause an overflow\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e7d5be84b22937a1691859a3c6fe45ed30b108574431d01b34025825ec17a\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n    }\n\n    private void testECDSAP256sha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        X9ECParameters p = NISTNamedCurves.getByName(\"P-256\");\n        KeyFactory ecKeyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECDomainParameters params = new ECDomainParameters(p.getCurve(), p.getG(), p.getN(), p.getH());\n\n        ECCurve curve = p.getCurve();\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                p.getG(), // G\n                p.getN()); // n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"20186677036482506117540275567393538695075300175221296989956723148347484984008\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            params.getCurve().decodePoint(Hex.decode(\"03596375E6CE57E0F20294FC46BDFCFD19A39F8161B58695B3EC5B3D16427C274D\")), // Q\n            spec);\n\n        doEcDsaTest(\"SHA3-\" + size + \"withECDSA\", s, ecKeyFact, pubKey, priKey);\n        doEcDsaTest(sigOid.getId(), s, ecKeyFact, pubKey, priKey);\n    }\n\n    private void doEcDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, ECPublicKeySpec pubKey, ECPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"97354732615802252173078420023658453040116611318111190383344590814578738210384\");\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void testDSAsha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeySpec priKey = new DSAPrivateKeySpec(\n                x, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        DSAPublicKeySpec pubKey = new DSAPublicKeySpec(\n            y, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        KeyFactory dsaKeyFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        doDsaTest(\"SHA3-\" + size + \"withDSA\", s, dsaKeyFact, pubKey, priKey);\n        doDsaTest(sigOid.getId(), s, dsaKeyFact, pubKey, priKey);\n    }\n\n    private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void checkMessage(Signature sgr, PrivateKey sKey, PublicKey vKey, byte[] message, byte[] sig)\n        throws InvalidKeyException, SignatureException\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        if (!Arrays.areEqual(sigBytes, sig))\n        {\n            fail(new String(message) + \" signature incorrect\");\n        }\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(new String(message) + \" verification failed\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n    \n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n    \n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n    \n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n        \n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n    \n        Signature   sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n       \n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testECDSA239bitBinary(String algorithm, ASN1ObjectIdentifier oid)\n        throws Exception\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n\n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n\n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n\n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n\n        Signature   sgr = Signature.getInstance(algorithm, \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        sgr = Signature.getInstance(oid.getId(), \"BC\");\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC RIPEMD160 verification failed\");\n        }\n    }\n\n    private void testGeneration()\n        throws Exception\n    {\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n\n        // test exception\n        //\n        try\n        {\n            g.initialize(513, new SecureRandom());\n\n            fail(\"illegal parameter 513 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(510, new SecureRandom());\n\n            fail(\"illegal parameter 510 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(1025, new SecureRandom());\n\n            fail(\"illegal parameter 1025 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        g.initialize(512, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        DSAPublicKey k1 = (DSAPublicKey)serializeDeserialize(vKey);\n\n        checkPublic(k1, vKey);\n\n        checkEquals(k1, vKey);\n\n        DSAPrivateKey k2 = (DSAPrivateKey)serializeDeserialize(sKey);\n\n        checkPrivateKey(k2, sKey);\n\n        checkEquals(k2, sKey);\n\n        if (!(k2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // ECDSA Fp generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        ECCurve curve = new ECCurve.Fp(\n            new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        PublicKey eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        PrivateKey eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        // Named curve parameter\n        g.initialize(new ECNamedCurveGenParameterSpec(\"P-256\"), new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        //\n        // ECDSA F2m generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        curve = new ECCurve.F2m(\n                239, // m\n                36, // k\n                new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n                new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n        \n        ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n        \n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        if (!(eck2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n    }\n\n    private void checkEquals(Object o1, Object o2)\n    {\n        if (!o1.equals(o2))\n        {\n            fail(\"comparison test failed\");\n        }\n\n        if (o1.hashCode() != o2.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n    }\n    \n    private void testParameters()\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(512, random);\n        AlgorithmParameters params = a.generateParameters();\n        \n        byte[] encodeParams = params.getEncoded();\n        \n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n        \n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n        \n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n        \n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n        \n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new SecureRandom());\n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    private void testDSA2Parameters()\n        throws Exception\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(2048, new DSATestSecureRandom(seed));\n        AlgorithmParameters params = a.generateParameters();\n\n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n\n        if (!dsaP.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!dsaP.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!dsaP.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new TestRandomBigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")));\n        KeyPair p = g.generateKeyPair();\n\n        DSAPrivateKey  sKey = (DSAPrivateKey)p.getPrivate();\n        DSAPublicKey   vKey = (DSAPublicKey)p.getPublic();\n\n        if (!vKey.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!sKey.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testCompat();\n        testNONEwithDSA();\n\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_224, 224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_256, 256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_384, 384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_512, 512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n\n        testECDSA239bitPrime();\n        testNONEwithECDSA239bitPrime();\n        testECDSA239bitBinary();\n        testECDSA239bitBinary(\"RIPEMD160withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n        testECDSA239bitBinary(\"SHA1withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithSha1);\n        testECDSA239bitBinary(\"SHA224withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n        testECDSA239bitBinary(\"SHA256withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n        testECDSA239bitBinary(\"SHA384withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n        testECDSA239bitBinary(\"SHA512withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n        testECDSA239bitBinary(\"SHA1withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n        testECDSA239bitBinary(\"SHA224withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n        testECDSA239bitBinary(\"SHA256withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n        testECDSA239bitBinary(\"SHA384withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n        testECDSA239bitBinary(\"SHA512withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_224, 224, new BigInteger(\"84d7d8e68e405064109cd9fc3e3026d74d278aada14ce6b7a9dd0380c154dc94\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_256, 256, new BigInteger(\"99a43bdab4af989aaf2899079375642f2bae2dce05bcd8b72ec8c4a8d9a143f\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_384, 384, new BigInteger(\"aa27726509c37aaf601de6f7e01e11c19add99530c9848381c23365dc505b11a\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_512, 512, new BigInteger(\"f8306b57a1f5068bf12e53aabaae39e2658db39bc56747eaefb479995130ad16\", 16));\n\n        testGeneration();\n        testParameters();\n        testDSA2Parameters();\n        testNullParameters();\n        testValidate();\n        testModified();\n    }\n\n    protected BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ByteArrayInputStream    bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream         aIn = new ASN1InputStream(bIn);\n        ASN1Sequence            s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[]            sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"DSA/ECDSA\";\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n"], "filenames": ["prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dsa/DSASigner.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/DSATest.java"], "buggy_code_start_loc": [11, 72], "buggy_code_end_loc": [181, 1225], "fixing_code_start_loc": [10, 73], "fixing_code_end_loc": [184, 1331], "type": "CWE-347", "message": "In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure.", "other": {"cve": {"id": "CVE-2016-1000338", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-01T20:29:00.217", "lastModified": "2020-10-20T22:15:16.873", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure."}, {"lang": "es", "value": "En Bouncy Castle JCE Provider en versiones 1.55 y anteriores, el DSA no valida completamente el cifrado ASN.1 de la firma en verificaci\u00f3n. Es posible inyectar elementos extra en la secuencia que forma la firma y, a\u00fan as\u00ed, validarla. En algunos casos, esto podr\u00eda permitir la introducci\u00f3n de datos \"invisibles\" en una estructura firmada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.55", "matchCriteriaId": "946393A6-EEE2-4502-9309-81514DB5755B"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2669", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2927", "source": "cve@mitre.org"}, {"url": "https://github.com/bcgit/bc-java/commit/b0c3ce99d43d73a096268831d0d120ffc89eac7f#diff-3679f5a9d2b939d0d3ee1601a7774fb0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/708d94141126eac03011144a971a6411fcac16d9c248d1d535a39451@%3Csolr-user.lucene.apache.org%3E", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3727-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/b0c3ce99d43d73a096268831d0d120ffc89eac7f#diff-3679f5a9d2b939d0d3ee1601a7774fb0"}}