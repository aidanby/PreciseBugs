{"buggy_code": ["// Package builder defines interfaces for any Docker builder to implement.\n//\n// Historically, only server-side Dockerfile interpreters existed.\n// This package allows for other implementations of Docker builders.\npackage builder // import \"github.com/docker/docker/builder\"\n\nimport (\n\t\"context\"\n\t\"io\"\n\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\tcontainerpkg \"github.com/docker/docker/container\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/opencontainers/go-digest\"\n)\n\nconst (\n\t// DefaultDockerfileName is the Default filename with Docker commands, read by docker build\n\tDefaultDockerfileName = \"Dockerfile\"\n)\n\n// Source defines a location that can be used as a source for the ADD/COPY\n// instructions in the builder.\ntype Source interface {\n\t// Root returns root path for accessing source\n\tRoot() string\n\t// Close allows to signal that the filesystem tree won't be used anymore.\n\t// For Context implementations using a temporary directory, it is recommended to\n\t// delete the temporary directory in Close().\n\tClose() error\n\t// Hash returns a checksum for a file\n\tHash(path string) (string, error)\n}\n\n// Backend abstracts calls to a Docker Daemon.\ntype Backend interface {\n\tImageBackend\n\tExecBackend\n\n\t// CommitBuildStep creates a new Docker image from the config generated by\n\t// a build step.\n\tCommitBuildStep(context.Context, backend.CommitConfig) (image.ID, error)\n\t// ContainerCreateWorkdir creates the workdir\n\tContainerCreateWorkdir(containerID string) error\n\tCreateImage(ctx context.Context, config []byte, parent string, contentStoreDigest digest.Digest) (Image, error)\n\n\tImageCacheBuilder\n}\n\n// ImageBackend are the interface methods required from an image component\ntype ImageBackend interface {\n\tGetImageAndReleasableLayer(ctx context.Context, refOrID string, opts backend.GetImageAndLayerOptions) (Image, ROLayer, error)\n}\n\n// ExecBackend contains the interface methods required for executing containers\ntype ExecBackend interface {\n\t// ContainerAttachRaw attaches to container.\n\tContainerAttachRaw(cID string, stdin io.ReadCloser, stdout, stderr io.Writer, stream bool, attached chan struct{}) error\n\t// ContainerCreateIgnoreImagesArgsEscaped creates a new Docker container and returns potential warnings\n\tContainerCreateIgnoreImagesArgsEscaped(ctx context.Context, config backend.ContainerCreateConfig) (container.CreateResponse, error)\n\t// ContainerRm removes a container specified by `id`.\n\tContainerRm(name string, config *backend.ContainerRmConfig) error\n\t// ContainerStart starts a new container\n\tContainerStart(ctx context.Context, containerID string, hostConfig *container.HostConfig, checkpoint string, checkpointDir string) error\n\t// ContainerWait stops processing until the given container is stopped.\n\tContainerWait(ctx context.Context, name string, condition containerpkg.WaitCondition) (<-chan containerpkg.StateStatus, error)\n}\n\n// Result is the output produced by a Builder\ntype Result struct {\n\tImageID   string\n\tFromImage Image\n}\n\n// ImageCacheBuilder represents a generator for stateful image cache.\ntype ImageCacheBuilder interface {\n\t// MakeImageCache creates a stateful image cache.\n\tMakeImageCache(ctx context.Context, cacheFrom []string) (ImageCache, error)\n}\n\n// ImageCache abstracts an image cache.\n// (parent image, child runconfig) -> child image\ntype ImageCache interface {\n\t// GetCache returns a reference to a cached image whose parent equals `parent`\n\t// and runconfig equals `cfg`. A cache miss is expected to return an empty ID and a nil error.\n\tGetCache(parentID string, cfg *container.Config) (imageID string, err error)\n}\n\n// Image represents a Docker image used by the builder.\ntype Image interface {\n\tImageID() string\n\tRunConfig() *container.Config\n\tMarshalJSON() ([]byte, error)\n\tOperatingSystem() string\n}\n\n// ROLayer is a reference to image rootfs layer\ntype ROLayer interface {\n\tRelease() error\n\tNewRWLayer() (RWLayer, error)\n\tDiffID() layer.DiffID\n\tContentStoreDigest() digest.Digest\n}\n\n// RWLayer is active layer that can be read/modified\ntype RWLayer interface {\n\tRelease() error\n\tRoot() string\n\tCommit() (ROLayer, error)\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/builder/remotecontext\"\n\t\"github.com/docker/docker/builder/remotecontext/urlutil\"\n\t\"github.com/docker/docker/pkg/archive\"\n\t\"github.com/docker/docker/pkg/idtools\"\n\t\"github.com/docker/docker/pkg/longpath\"\n\t\"github.com/docker/docker/pkg/progress\"\n\t\"github.com/docker/docker/pkg/streamformatter\"\n\t\"github.com/docker/docker/pkg/system\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/instructions\"\n\t\"github.com/moby/sys/symlink\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\nconst unnamedFilename = \"__unnamed__\"\n\ntype pathCache interface {\n\tLoad(key interface{}) (value interface{}, ok bool)\n\tStore(key, value interface{})\n}\n\n// copyInfo is a data object which stores the metadata about each source file in\n// a copyInstruction\ntype copyInfo struct {\n\troot         string\n\tpath         string\n\thash         string\n\tnoDecompress bool\n}\n\nfunc (c copyInfo) fullPath() (string, error) {\n\treturn symlink.FollowSymlinkInScope(filepath.Join(c.root, c.path), c.root)\n}\n\nfunc newCopyInfoFromSource(source builder.Source, path string, hash string) copyInfo {\n\treturn copyInfo{root: source.Root(), path: path, hash: hash}\n}\n\nfunc newCopyInfos(copyInfos ...copyInfo) []copyInfo {\n\treturn copyInfos\n}\n\n// copyInstruction is a fully parsed COPY or ADD command that is passed to\n// Builder.performCopy to copy files into the image filesystem\ntype copyInstruction struct {\n\tcmdName                 string\n\tinfos                   []copyInfo\n\tdest                    string\n\tchownStr                string\n\tallowLocalDecompression bool\n\tpreserveOwnership       bool\n}\n\n// copier reads a raw COPY or ADD command, fetches remote sources using a downloader,\n// and creates a copyInstruction\ntype copier struct {\n\timageSource *imageMount\n\tsource      builder.Source\n\tpathCache   pathCache\n\tdownload    sourceDownloader\n\tplatform    *ocispec.Platform\n\t// for cleanup. TODO: having copier.cleanup() is error prone and hard to\n\t// follow. Code calling performCopy should manage the lifecycle of its params.\n\t// Copier should take override source as input, not imageMount.\n\tactiveLayer builder.RWLayer\n\ttmpPaths    []string\n}\n\nfunc copierFromDispatchRequest(req dispatchRequest, download sourceDownloader, imageSource *imageMount) copier {\n\tplatform := req.builder.platform\n\tif platform == nil {\n\t\t// May be nil if not explicitly set in API/dockerfile\n\t\tplatform = &ocispec.Platform{}\n\t}\n\tif platform.OS == \"\" {\n\t\t// Default to the dispatch requests operating system if not explicit in API/dockerfile\n\t\tplatform.OS = req.state.operatingSystem\n\t}\n\tif platform.OS == \"\" {\n\t\t// This is a failsafe just in case. Shouldn't be hit.\n\t\tplatform.OS = runtime.GOOS\n\t}\n\n\treturn copier{\n\t\tsource:      req.source,\n\t\tpathCache:   req.builder.pathCache,\n\t\tdownload:    download,\n\t\timageSource: imageSource,\n\t\tplatform:    platform,\n\t}\n}\n\nfunc (o *copier) createCopyInstruction(sourcesAndDest instructions.SourcesAndDest, cmdName string) (copyInstruction, error) {\n\tinst := copyInstruction{\n\t\tcmdName: cmdName,\n\t\tdest:    filepath.FromSlash(sourcesAndDest.DestPath),\n\t}\n\tinfos, err := o.getCopyInfosForSourcePaths(sourcesAndDest.SourcePaths, inst.dest)\n\tif err != nil {\n\t\treturn inst, errors.Wrapf(err, \"%s failed\", cmdName)\n\t}\n\tif len(infos) > 1 && !strings.HasSuffix(inst.dest, string(os.PathSeparator)) {\n\t\treturn inst, errors.Errorf(\"When using %s with more than one source file, the destination must be a directory and end with a /\", cmdName)\n\t}\n\tinst.infos = infos\n\treturn inst, nil\n}\n\n// getCopyInfosForSourcePaths iterates over the source files and calculate the info\n// needed to copy (e.g. hash value if cached)\n// The dest is used in case source is URL (and ends with \"/\")\nfunc (o *copier) getCopyInfosForSourcePaths(sources []string, dest string) ([]copyInfo, error) {\n\tvar infos []copyInfo\n\tfor _, orig := range sources {\n\t\tsubinfos, err := o.getCopyInfoForSourcePath(orig, dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tinfos = append(infos, subinfos...)\n\t}\n\n\tif len(infos) == 0 {\n\t\treturn nil, errors.New(\"no source files were specified\")\n\t}\n\treturn infos, nil\n}\n\nfunc (o *copier) getCopyInfoForSourcePath(orig, dest string) ([]copyInfo, error) {\n\tif !urlutil.IsURL(orig) {\n\t\treturn o.calcCopyInfo(orig, true)\n\t}\n\n\tremote, path, err := o.download(orig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// If path == \"\" then we are unable to determine filename from src\n\t// We have to make sure dest is available\n\tif path == \"\" {\n\t\tif strings.HasSuffix(dest, \"/\") {\n\t\t\treturn nil, errors.Errorf(\"cannot determine filename for source %s\", orig)\n\t\t}\n\t\tpath = unnamedFilename\n\t}\n\to.tmpPaths = append(o.tmpPaths, remote.Root())\n\n\thash, err := remote.Hash(path)\n\tci := newCopyInfoFromSource(remote, path, hash)\n\tci.noDecompress = true // data from http shouldn't be extracted even on ADD\n\treturn newCopyInfos(ci), err\n}\n\n// Cleanup removes any temporary directories created as part of downloading\n// remote files.\nfunc (o *copier) Cleanup() {\n\tfor _, path := range o.tmpPaths {\n\t\tos.RemoveAll(path)\n\t}\n\to.tmpPaths = []string{}\n\tif o.activeLayer != nil {\n\t\to.activeLayer.Release()\n\t\to.activeLayer = nil\n\t}\n}\n\n// TODO: allowWildcards can probably be removed by refactoring this function further.\nfunc (o *copier) calcCopyInfo(origPath string, allowWildcards bool) ([]copyInfo, error) {\n\timageSource := o.imageSource\n\tif err := validateCopySourcePath(imageSource, origPath); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// TODO: do this when creating copier. Requires validateCopySourcePath\n\t// (and other below) to be aware of the difference sources. Why is it only\n\t// done on image Source?\n\tif imageSource != nil && o.activeLayer == nil {\n\t\t// this needs to be protected against repeated calls as wildcard copy\n\t\t// will call it multiple times for a single COPY\n\t\tvar err error\n\t\trwLayer, err := imageSource.NewRWLayer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\to.activeLayer = rwLayer\n\n\t\to.source, err = remotecontext.NewLazySource(rwLayer.Root())\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"failed to create context for copy from %s\", rwLayer.Root())\n\t\t}\n\t}\n\n\tif o.source == nil {\n\t\treturn nil, errors.Errorf(\"missing build context\")\n\t}\n\n\t// Work in daemon-specific OS filepath semantics\n\torigPath = filepath.FromSlash(origPath)\n\torigPath = strings.TrimPrefix(origPath, string(os.PathSeparator))\n\torigPath = strings.TrimPrefix(origPath, \".\"+string(os.PathSeparator))\n\n\t// Deal with wildcards\n\tif allowWildcards && containsWildcards(origPath) {\n\t\treturn o.copyWithWildcards(origPath)\n\t}\n\n\tif imageSource != nil && imageSource.ImageID() != \"\" {\n\t\t// return a cached copy if one exists\n\t\tif h, ok := o.pathCache.Load(imageSource.ImageID() + origPath); ok {\n\t\t\treturn newCopyInfos(newCopyInfoFromSource(o.source, origPath, h.(string))), nil\n\t\t}\n\t}\n\n\t// Deal with the single file case\n\tcopyInfo, err := copyInfoForFile(o.source, origPath)\n\tswitch {\n\tcase imageSource == nil && errors.Is(err, os.ErrNotExist):\n\t\treturn nil, errors.Wrapf(err, \"file not found in build context or excluded by .dockerignore\")\n\tcase err != nil:\n\t\treturn nil, err\n\tcase copyInfo.hash != \"\":\n\t\to.storeInPathCache(imageSource, origPath, copyInfo.hash)\n\t\treturn newCopyInfos(copyInfo), err\n\t}\n\n\t// TODO: remove, handle dirs in Hash()\n\tsubfiles, err := walkSource(o.source, origPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thash := hashStringSlice(\"dir\", subfiles)\n\to.storeInPathCache(imageSource, origPath, hash)\n\treturn newCopyInfos(newCopyInfoFromSource(o.source, origPath, hash)), nil\n}\n\nfunc (o *copier) storeInPathCache(im *imageMount, path string, hash string) {\n\tif im != nil {\n\t\to.pathCache.Store(im.ImageID()+path, hash)\n\t}\n}\n\nfunc (o *copier) copyWithWildcards(origPath string) ([]copyInfo, error) {\n\troot := o.source.Root()\n\tvar copyInfos []copyInfo\n\tif err := filepath.WalkDir(root, func(path string, _ os.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trel, err := remotecontext.Rel(root, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif rel == \".\" {\n\t\t\treturn nil\n\t\t}\n\t\tif match, _ := filepath.Match(origPath, rel); !match {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Note we set allowWildcards to false in case the name has\n\t\t// a * in it\n\t\tsubInfos, err := o.calcCopyInfo(rel, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcopyInfos = append(copyInfos, subInfos...)\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn copyInfos, nil\n}\n\nfunc copyInfoForFile(source builder.Source, path string) (copyInfo, error) {\n\tfi, err := remotecontext.StatAt(source, path)\n\tif err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t// return the relative path in the error, which is more user-friendly than the full path to the tmp-dir\n\t\t\treturn copyInfo{}, errors.WithStack(&os.PathError{Op: \"stat\", Path: path, Err: os.ErrNotExist})\n\t\t}\n\t\treturn copyInfo{}, err\n\t}\n\n\tif fi.IsDir() {\n\t\treturn copyInfo{}, nil\n\t}\n\thash, err := source.Hash(path)\n\tif err != nil {\n\t\treturn copyInfo{}, err\n\t}\n\treturn newCopyInfoFromSource(source, path, \"file:\"+hash), nil\n}\n\n// TODO: dedupe with copyWithWildcards()\nfunc walkSource(source builder.Source, origPath string) ([]string, error) {\n\tfp, err := remotecontext.FullPath(source, origPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Must be a dir\n\tvar subfiles []string\n\terr = filepath.WalkDir(fp, func(path string, _ os.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trel, err := remotecontext.Rel(source.Root(), path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rel == \".\" {\n\t\t\treturn nil\n\t\t}\n\t\thash, err := source.Hash(rel)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\t// we already checked handleHash above\n\t\tsubfiles = append(subfiles, hash)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsort.Strings(subfiles)\n\treturn subfiles, nil\n}\n\ntype sourceDownloader func(string) (builder.Source, string, error)\n\nfunc newRemoteSourceDownloader(output, stdout io.Writer) sourceDownloader {\n\treturn func(url string) (builder.Source, string, error) {\n\t\treturn downloadSource(output, stdout, url)\n\t}\n}\n\nfunc errOnSourceDownload(_ string) (builder.Source, string, error) {\n\treturn nil, \"\", errors.New(\"source can't be a URL for COPY\")\n}\n\nfunc getFilenameForDownload(path string, resp *http.Response) string {\n\t// Guess filename based on source\n\tif path != \"\" && !strings.HasSuffix(path, \"/\") {\n\t\tif filename := filepath.Base(filepath.FromSlash(path)); filename != \"\" {\n\t\t\treturn filename\n\t\t}\n\t}\n\n\t// Guess filename based on Content-Disposition\n\tif contentDisposition := resp.Header.Get(\"Content-Disposition\"); contentDisposition != \"\" {\n\t\tif _, params, err := mime.ParseMediaType(contentDisposition); err == nil {\n\t\t\tif params[\"filename\"] != \"\" && !strings.HasSuffix(params[\"filename\"], \"/\") {\n\t\t\t\tif filename := filepath.Base(filepath.FromSlash(params[\"filename\"])); filename != \"\" {\n\t\t\t\t\treturn filename\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc downloadSource(output io.Writer, stdout io.Writer, srcURL string) (remote builder.Source, p string, err error) {\n\tu, err := url.Parse(srcURL)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresp, err := remotecontext.GetWithStatusError(srcURL)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfilename := getFilenameForDownload(u.Path, resp)\n\n\t// Prepare file in a tmp dir\n\ttmpDir, err := longpath.MkdirTemp(\"\", \"docker-remote\")\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tos.RemoveAll(tmpDir)\n\t\t}\n\t}()\n\t// If filename is empty, the returned filename will be \"\" but\n\t// the tmp filename will be created as \"__unnamed__\"\n\ttmpFileName := filename\n\tif filename == \"\" {\n\t\ttmpFileName = unnamedFilename\n\t}\n\ttmpFileName = filepath.Join(tmpDir, tmpFileName)\n\ttmpFile, err := os.OpenFile(tmpFileName, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0o600)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tprogressOutput := streamformatter.NewJSONProgressOutput(output, true)\n\tprogressReader := progress.NewProgressReader(resp.Body, progressOutput, resp.ContentLength, \"\", \"Downloading\")\n\t// Download and dump result to tmp file\n\t// TODO: add filehash directly\n\tif _, err = io.Copy(tmpFile, progressReader); err != nil {\n\t\ttmpFile.Close()\n\t\treturn\n\t}\n\t// TODO: how important is this random blank line to the output?\n\tfmt.Fprintln(stdout)\n\n\t// Set the mtime to the Last-Modified header value if present\n\t// Otherwise just remove atime and mtime\n\tmTime := time.Time{}\n\n\tlastMod := resp.Header.Get(\"Last-Modified\")\n\tif lastMod != \"\" {\n\t\t// If we can't parse it then just let it default to 'zero'\n\t\t// otherwise use the parsed time value\n\t\tif parsedMTime, err := http.ParseTime(lastMod); err == nil {\n\t\t\tmTime = parsedMTime\n\t\t}\n\t}\n\n\ttmpFile.Close()\n\n\tif err = system.Chtimes(tmpFileName, mTime, mTime); err != nil {\n\t\treturn\n\t}\n\n\tlc, err := remotecontext.NewLazySource(tmpDir)\n\treturn lc, filename, err\n}\n\ntype copyFileOptions struct {\n\tdecompress bool\n\tidentity   *idtools.Identity\n\tarchiver   *archive.Archiver\n}\n\nfunc performCopyForInfo(dest copyInfo, source copyInfo, options copyFileOptions) error {\n\tsrcPath, err := source.fullPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdestPath, err := dest.fullPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tarchiver := options.archiver\n\n\tsrc, err := os.Stat(srcPath)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"source path not found\")\n\t}\n\tif src.IsDir() {\n\t\treturn copyDirectory(archiver, srcPath, destPath, options.identity)\n\t}\n\tif options.decompress && archive.IsArchivePath(srcPath) && !source.noDecompress {\n\t\treturn archiver.UntarPath(srcPath, destPath)\n\t}\n\n\tdestExistsAsDir, err := isExistingDirectory(destPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// dest.path must be used because destPath has already been cleaned of any\n\t// trailing slash\n\tif endsInSlash(dest.path) || destExistsAsDir {\n\t\t// source.path must be used to get the correct filename when the source\n\t\t// is a symlink\n\t\tdestPath = filepath.Join(destPath, filepath.Base(source.path))\n\t}\n\treturn copyFile(archiver, srcPath, destPath, options.identity)\n}\n\nfunc copyDirectory(archiver *archive.Archiver, source, dest string, identity *idtools.Identity) error {\n\tdestExists, err := isExistingDirectory(dest)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to query destination path\")\n\t}\n\n\tif err := archiver.CopyWithTar(source, dest); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to copy directory\")\n\t}\n\tif identity != nil {\n\t\treturn fixPermissions(source, dest, *identity, !destExists)\n\t}\n\treturn nil\n}\n\nfunc copyFile(archiver *archive.Archiver, source, dest string, identity *idtools.Identity) error {\n\tif identity == nil {\n\t\t// Use system.MkdirAll here, which is a custom version of os.MkdirAll\n\t\t// modified for use on Windows to handle volume GUID paths. These paths\n\t\t// are of the form \\\\?\\Volume{<GUID>}\\<path>. An example would be:\n\t\t// \\\\?\\Volume{dae8d3ac-b9a1-11e9-88eb-e8554b2ba1db}\\bin\\busybox.exe\n\t\tif err := system.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := idtools.MkdirAllAndChownNew(filepath.Dir(dest), 0o755, *identity); err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to create new directory\")\n\t\t}\n\t}\n\n\tif err := archiver.CopyFileWithTar(source, dest); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to copy file\")\n\t}\n\tif identity != nil {\n\t\treturn fixPermissions(source, dest, *identity, false)\n\t}\n\treturn nil\n}\n\nfunc endsInSlash(path string) bool {\n\treturn strings.HasSuffix(path, string(filepath.Separator))\n}\n\n// isExistingDirectory returns true if the path exists and is a directory\nfunc isExistingDirectory(path string) (bool, error) {\n\tdestStat, err := os.Stat(path)\n\tswitch {\n\tcase errors.Is(err, os.ErrNotExist):\n\t\treturn false, nil\n\tcase err != nil:\n\t\treturn false, err\n\t}\n\treturn destStat.IsDir(), nil\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\n// This file contains the dispatchers for each command. Note that\n// `nullDispatch` is not actually a command, but support for commands we parse\n// but do nothing with.\n//\n// See evaluator.go for a higher level discussion of the whole evaluator\n// package.\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/docker/docker/api\"\n\t\"github.com/docker/docker/api/types/strslice\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/pkg/jsonmessage\"\n\t\"github.com/docker/go-connections/nat\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/instructions\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/parser\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/shell\"\n\t\"github.com/moby/sys/signal\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\n// ENV foo bar\n//\n// Sets the environment variable foo to bar, also makes interpolation\n// in the dockerfile available from the next statement on via ${foo}.\nfunc dispatchEnv(ctx context.Context, d dispatchRequest, c *instructions.EnvCommand) error {\n\trunConfig := d.state.runConfig\n\tcommitMessage := bytes.NewBufferString(\"ENV\")\n\tfor _, e := range c.Env {\n\t\tname := e.Key\n\t\tnewVar := e.String()\n\n\t\tcommitMessage.WriteString(\" \" + newVar)\n\t\tgotOne := false\n\t\tfor i, envVar := range runConfig.Env {\n\t\t\tcompareFrom, _, _ := strings.Cut(envVar, \"=\")\n\t\t\tif shell.EqualEnvKeys(compareFrom, name) {\n\t\t\t\trunConfig.Env[i] = newVar\n\t\t\t\tgotOne = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !gotOne {\n\t\t\trunConfig.Env = append(runConfig.Env, newVar)\n\t\t}\n\t}\n\treturn d.builder.commit(ctx, d.state, commitMessage.String())\n}\n\n// MAINTAINER some text <maybe@an.email.address>\n//\n// Sets the maintainer metadata.\nfunc dispatchMaintainer(ctx context.Context, d dispatchRequest, c *instructions.MaintainerCommand) error {\n\td.state.maintainer = c.Maintainer\n\treturn d.builder.commit(ctx, d.state, \"MAINTAINER \"+c.Maintainer)\n}\n\n// LABEL some json data describing the image\n//\n// Sets the Label variable foo to bar,\nfunc dispatchLabel(ctx context.Context, d dispatchRequest, c *instructions.LabelCommand) error {\n\tif d.state.runConfig.Labels == nil {\n\t\td.state.runConfig.Labels = make(map[string]string)\n\t}\n\tcommitStr := \"LABEL\"\n\tfor _, v := range c.Labels {\n\t\td.state.runConfig.Labels[v.Key] = v.Value\n\t\tcommitStr += \" \" + v.String()\n\t}\n\treturn d.builder.commit(ctx, d.state, commitStr)\n}\n\n// ADD foo /path\n//\n// Add the file 'foo' to '/path'. Tarball and Remote URL (http, https) handling\n// exist here. If you do not wish to have this automatic handling, use COPY.\nfunc dispatchAdd(ctx context.Context, d dispatchRequest, c *instructions.AddCommand) error {\n\tif c.Chmod != \"\" {\n\t\treturn errors.New(\"the --chmod option requires BuildKit. Refer to https://docs.docker.com/go/buildkit/ to learn how to build images with BuildKit enabled\")\n\t}\n\tdownloader := newRemoteSourceDownloader(d.builder.Output, d.builder.Stdout)\n\tcopier := copierFromDispatchRequest(d, downloader, nil)\n\tdefer copier.Cleanup()\n\n\tcopyInstruction, err := copier.createCopyInstruction(c.SourcesAndDest, \"ADD\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcopyInstruction.chownStr = c.Chown\n\tcopyInstruction.allowLocalDecompression = true\n\n\treturn d.builder.performCopy(ctx, d, copyInstruction)\n}\n\n// COPY foo /path\n//\n// Same as 'ADD' but without the tar and remote url handling.\nfunc dispatchCopy(ctx context.Context, d dispatchRequest, c *instructions.CopyCommand) error {\n\tif c.Chmod != \"\" {\n\t\treturn errors.New(\"the --chmod option requires BuildKit. Refer to https://docs.docker.com/go/buildkit/ to learn how to build images with BuildKit enabled\")\n\t}\n\tvar im *imageMount\n\tvar err error\n\tif c.From != \"\" {\n\t\tim, err = d.getImageMount(ctx, c.From)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"invalid from flag value %s\", c.From)\n\t\t}\n\t}\n\tcopier := copierFromDispatchRequest(d, errOnSourceDownload, im)\n\tdefer copier.Cleanup()\n\tcopyInstruction, err := copier.createCopyInstruction(c.SourcesAndDest, \"COPY\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcopyInstruction.chownStr = c.Chown\n\tif c.From != \"\" && copyInstruction.chownStr == \"\" {\n\t\tcopyInstruction.preserveOwnership = true\n\t}\n\treturn d.builder.performCopy(ctx, d, copyInstruction)\n}\n\nfunc (d *dispatchRequest) getImageMount(ctx context.Context, imageRefOrID string) (*imageMount, error) {\n\tif imageRefOrID == \"\" {\n\t\t// TODO: this could return the source in the default case as well?\n\t\treturn nil, nil\n\t}\n\n\tvar localOnly bool\n\tstage, err := d.stages.get(imageRefOrID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif stage != nil {\n\t\timageRefOrID = stage.Image\n\t\tlocalOnly = true\n\t}\n\treturn d.builder.imageSources.Get(ctx, imageRefOrID, localOnly, d.builder.platform)\n}\n\n// FROM [--platform=platform] imagename[:tag | @digest] [AS build-stage-name]\nfunc initializeStage(ctx context.Context, d dispatchRequest, cmd *instructions.Stage) error {\n\terr := d.builder.imageProber.Reset(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar platform *ocispec.Platform\n\tif v := cmd.Platform; v != \"\" {\n\t\tv, err := d.getExpandedString(d.shlex, v)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to process arguments for platform %s\", v)\n\t\t}\n\n\t\tp, err := platforms.Parse(v)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to parse platform %s\", v)\n\t\t}\n\t\tplatform = &p\n\t}\n\n\timage, err := d.getFromImage(ctx, d.shlex, cmd.BaseName, platform)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstate := d.state\n\tif err := state.beginStage(cmd.Name, image); err != nil {\n\t\treturn err\n\t}\n\tif len(state.runConfig.OnBuild) > 0 {\n\t\ttriggers := state.runConfig.OnBuild\n\t\tstate.runConfig.OnBuild = nil\n\t\treturn dispatchTriggeredOnBuild(ctx, d, triggers)\n\t}\n\treturn nil\n}\n\nfunc dispatchTriggeredOnBuild(ctx context.Context, d dispatchRequest, triggers []string) error {\n\tfmt.Fprintf(d.builder.Stdout, \"# Executing %d build trigger\", len(triggers))\n\tif len(triggers) > 1 {\n\t\tfmt.Fprint(d.builder.Stdout, \"s\")\n\t}\n\tfmt.Fprintln(d.builder.Stdout)\n\tfor _, trigger := range triggers {\n\t\td.state.updateRunConfig()\n\t\tast, err := parser.Parse(strings.NewReader(trigger))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(ast.AST.Children) != 1 {\n\t\t\treturn errors.New(\"onbuild trigger should be a single expression\")\n\t\t}\n\t\tcmd, err := instructions.ParseCommand(ast.AST.Children[0])\n\t\tif err != nil {\n\t\t\tvar uiErr *instructions.UnknownInstructionError\n\t\t\tif errors.As(err, &uiErr) {\n\t\t\t\tbuildsFailed.WithValues(metricsUnknownInstructionError).Inc()\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\terr = dispatch(ctx, d, cmd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (d *dispatchRequest) getExpandedString(shlex *shell.Lex, str string) (string, error) {\n\tsubstitutionArgs := []string{}\n\tfor key, value := range d.state.buildArgs.GetAllMeta() {\n\t\tsubstitutionArgs = append(substitutionArgs, key+\"=\"+value)\n\t}\n\n\tname, err := shlex.ProcessWord(str, substitutionArgs)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn name, nil\n}\n\nfunc (d *dispatchRequest) getImageOrStage(ctx context.Context, name string, platform *ocispec.Platform) (builder.Image, error) {\n\tvar localOnly bool\n\tif im, ok := d.stages.getByName(name); ok {\n\t\tname = im.Image\n\t\tlocalOnly = true\n\t}\n\n\tif platform == nil {\n\t\tplatform = d.builder.platform\n\t}\n\n\t// Windows cannot support a container with no base image.\n\tif name == api.NoBaseImageSpecifier {\n\t\t// Windows supports scratch. What is not supported is running containers from it.\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\treturn nil, errors.New(\"Windows does not support FROM scratch\")\n\t\t}\n\n\t\t// TODO: scratch should not have an os. It should be nil image.\n\t\timageImage := &image.Image{}\n\t\tif platform != nil {\n\t\t\timageImage.OS = platform.OS\n\t\t} else {\n\t\t\timageImage.OS = runtime.GOOS\n\t\t}\n\t\treturn builder.Image(imageImage), nil\n\t}\n\timageMount, err := d.builder.imageSources.Get(ctx, name, localOnly, platform)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn imageMount.Image(), nil\n}\n\nfunc (d *dispatchRequest) getFromImage(ctx context.Context, shlex *shell.Lex, basename string, platform *ocispec.Platform) (builder.Image, error) {\n\tname, err := d.getExpandedString(shlex, basename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Empty string is interpreted to FROM scratch by images.GetImageAndReleasableLayer,\n\t// so validate expanded result is not empty.\n\tif name == \"\" {\n\t\treturn nil, errors.Errorf(\"base name (%s) should not be blank\", basename)\n\t}\n\n\treturn d.getImageOrStage(ctx, name, platform)\n}\n\nfunc dispatchOnbuild(ctx context.Context, d dispatchRequest, c *instructions.OnbuildCommand) error {\n\td.state.runConfig.OnBuild = append(d.state.runConfig.OnBuild, c.Expression)\n\treturn d.builder.commit(ctx, d.state, \"ONBUILD \"+c.Expression)\n}\n\n// WORKDIR /tmp\n//\n// Set the working directory for future RUN/CMD/etc statements.\nfunc dispatchWorkdir(ctx context.Context, d dispatchRequest, c *instructions.WorkdirCommand) error {\n\trunConfig := d.state.runConfig\n\tvar err error\n\trunConfig.WorkingDir, err = normalizeWorkdir(d.state.operatingSystem, runConfig.WorkingDir, c.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// For performance reasons, we explicitly do a create/mkdir now\n\t// This avoids having an unnecessary expensive mount/unmount calls\n\t// (on Windows in particular) during each container create.\n\t// Prior to 1.13, the mkdir was deferred and not executed at this step.\n\tif d.builder.disableCommit {\n\t\t// Don't call back into the daemon if we're going through docker commit --change \"WORKDIR /foo\".\n\t\t// We've already updated the runConfig and that's enough.\n\t\treturn nil\n\t}\n\n\tcomment := \"WORKDIR \" + runConfig.WorkingDir\n\trunConfigWithCommentCmd := copyRunConfig(runConfig, withCmdCommentString(comment, d.state.operatingSystem))\n\n\tcontainerID, err := d.builder.probeAndCreate(ctx, d.state, runConfigWithCommentCmd)\n\tif err != nil || containerID == \"\" {\n\t\treturn err\n\t}\n\n\tif err := d.builder.docker.ContainerCreateWorkdir(containerID); err != nil {\n\t\treturn err\n\t}\n\n\treturn d.builder.commitContainer(ctx, d.state, containerID, runConfigWithCommentCmd)\n}\n\n// RUN some command yo\n//\n// run a command and commit the image. Args are automatically prepended with\n// the current SHELL which defaults to 'sh -c' under linux or 'cmd /S /C' under\n// Windows, in the event there is only one argument The difference in processing:\n//\n// RUN echo hi          # sh -c echo hi       (Linux and LCOW)\n// RUN echo hi          # cmd /S /C echo hi   (Windows)\n// RUN [ \"echo\", \"hi\" ] # echo hi\nfunc dispatchRun(ctx context.Context, d dispatchRequest, c *instructions.RunCommand) error {\n\tif err := image.CheckOS(d.state.operatingSystem); err != nil {\n\t\treturn err\n\t}\n\n\tif len(c.FlagsUsed) > 0 {\n\t\t// classic builder RUN currently does not support any flags, so fail on the first one\n\t\treturn errors.Errorf(\"the --%s option requires BuildKit. Refer to https://docs.docker.com/go/buildkit/ to learn how to build images with BuildKit enabled\", c.FlagsUsed[0])\n\t}\n\n\tstateRunConfig := d.state.runConfig\n\tcmdFromArgs, argsEscaped := resolveCmdLine(c.ShellDependantCmdLine, stateRunConfig, d.state.operatingSystem, c.Name(), c.String())\n\tbuildArgs := d.state.buildArgs.FilterAllowed(stateRunConfig.Env)\n\n\tsaveCmd := cmdFromArgs\n\tif len(buildArgs) > 0 {\n\t\tsaveCmd = prependEnvOnCmd(d.state.buildArgs, buildArgs, cmdFromArgs)\n\t}\n\n\trunConfigForCacheProbe := copyRunConfig(stateRunConfig,\n\t\twithCmd(saveCmd),\n\t\twithArgsEscaped(argsEscaped),\n\t\twithEntrypointOverride(saveCmd, nil))\n\tif hit, err := d.builder.probeCache(d.state, runConfigForCacheProbe); err != nil || hit {\n\t\treturn err\n\t}\n\n\trunConfig := copyRunConfig(stateRunConfig,\n\t\twithCmd(cmdFromArgs),\n\t\twithArgsEscaped(argsEscaped),\n\t\twithEnv(append(stateRunConfig.Env, buildArgs...)),\n\t\twithEntrypointOverride(saveCmd, strslice.StrSlice{\"\"}),\n\t\twithoutHealthcheck())\n\n\tcID, err := d.builder.create(ctx, runConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := d.builder.containerManager.Run(ctx, cID, d.builder.Stdout, d.builder.Stderr); err != nil {\n\t\tif err, ok := err.(*statusCodeError); ok {\n\t\t\t// TODO: change error type, because jsonmessage.JSONError assumes HTTP\n\t\t\tmsg := fmt.Sprintf(\n\t\t\t\t\"The command '%s' returned a non-zero code: %d\",\n\t\t\t\tstrings.Join(runConfig.Cmd, \" \"), err.StatusCode())\n\t\t\tif err.Error() != \"\" {\n\t\t\t\tmsg = fmt.Sprintf(\"%s: %s\", msg, err.Error())\n\t\t\t}\n\t\t\treturn &jsonmessage.JSONError{\n\t\t\t\tMessage: msg,\n\t\t\t\tCode:    err.StatusCode(),\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\t// Don't persist the argsEscaped value in the committed image. Use the original\n\t// from previous build steps (only CMD and ENTRYPOINT persist this).\n\tif d.state.operatingSystem == \"windows\" {\n\t\trunConfigForCacheProbe.ArgsEscaped = stateRunConfig.ArgsEscaped\n\t}\n\n\treturn d.builder.commitContainer(ctx, d.state, cID, runConfigForCacheProbe)\n}\n\n// Derive the command to use for probeCache() and to commit in this container.\n// Note that we only do this if there are any build-time env vars.  Also, we\n// use the special argument \"|#\" at the start of the args array. This will\n// avoid conflicts with any RUN command since commands can not\n// start with | (vertical bar). The \"#\" (number of build envs) is there to\n// help ensure proper cache matches. We don't want a RUN command\n// that starts with \"foo=abc\" to be considered part of a build-time env var.\n//\n// remove any unreferenced built-in args from the environment variables.\n// These args are transparent so resulting image should be the same regardless\n// of the value.\nfunc prependEnvOnCmd(buildArgs *BuildArgs, buildArgVars []string, cmd strslice.StrSlice) strslice.StrSlice {\n\ttmpBuildEnv := make([]string, 0, len(buildArgVars))\n\tfor _, env := range buildArgVars {\n\t\tkey, _, _ := strings.Cut(env, \"=\")\n\t\tif buildArgs.IsReferencedOrNotBuiltin(key) {\n\t\t\ttmpBuildEnv = append(tmpBuildEnv, env)\n\t\t}\n\t}\n\n\tsort.Strings(tmpBuildEnv)\n\ttmpEnv := append([]string{fmt.Sprintf(\"|%d\", len(tmpBuildEnv))}, tmpBuildEnv...)\n\treturn append(tmpEnv, cmd...)\n}\n\n// CMD foo\n//\n// Set the default command to run in the container (which may be empty).\n// Argument handling is the same as RUN.\nfunc dispatchCmd(ctx context.Context, d dispatchRequest, c *instructions.CmdCommand) error {\n\trunConfig := d.state.runConfig\n\tcmd, argsEscaped := resolveCmdLine(c.ShellDependantCmdLine, runConfig, d.state.operatingSystem, c.Name(), c.String())\n\n\t// We warn here as Windows shell processing operates differently to Linux.\n\t// Linux:   /bin/sh -c \"echo hello\" world\t--> hello\n\t// Windows: cmd /s /c \"echo hello\" world\t--> hello world\n\tif d.state.operatingSystem == \"windows\" &&\n\t\tlen(runConfig.Entrypoint) > 0 &&\n\t\td.state.runConfig.ArgsEscaped != argsEscaped {\n\t\tfmt.Fprintf(d.builder.Stderr, \" ---> [Warning] Shell-form ENTRYPOINT and exec-form CMD may have unexpected results\\n\")\n\t}\n\n\trunConfig.Cmd = cmd\n\trunConfig.ArgsEscaped = argsEscaped\n\n\tif err := d.builder.commit(ctx, d.state, fmt.Sprintf(\"CMD %q\", cmd)); err != nil {\n\t\treturn err\n\t}\n\tif len(c.ShellDependantCmdLine.CmdLine) != 0 {\n\t\td.state.cmdSet = true\n\t}\n\n\treturn nil\n}\n\n// HEALTHCHECK foo\n//\n// Set the default healthcheck command to run in the container (which may be empty).\n// Argument handling is the same as RUN.\nfunc dispatchHealthcheck(ctx context.Context, d dispatchRequest, c *instructions.HealthCheckCommand) error {\n\trunConfig := d.state.runConfig\n\tif runConfig.Healthcheck != nil {\n\t\toldCmd := runConfig.Healthcheck.Test\n\t\tif len(oldCmd) > 0 && oldCmd[0] != \"NONE\" {\n\t\t\tfmt.Fprintf(d.builder.Stdout, \"Note: overriding previous HEALTHCHECK: %v\\n\", oldCmd)\n\t\t}\n\t}\n\trunConfig.Healthcheck = c.Health\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"HEALTHCHECK %q\", runConfig.Healthcheck))\n}\n\n// ENTRYPOINT /usr/sbin/nginx\n//\n// Set the entrypoint to /usr/sbin/nginx. Will accept the CMD as the arguments\n// to /usr/sbin/nginx. Uses the default shell if not in JSON format.\n//\n// Handles command processing similar to CMD and RUN, only req.runConfig.Entrypoint\n// is initialized at newBuilder time instead of through argument parsing.\nfunc dispatchEntrypoint(ctx context.Context, d dispatchRequest, c *instructions.EntrypointCommand) error {\n\trunConfig := d.state.runConfig\n\tcmd, argsEscaped := resolveCmdLine(c.ShellDependantCmdLine, runConfig, d.state.operatingSystem, c.Name(), c.String())\n\n\t// This warning is a little more complex than in dispatchCmd(), as the Windows base images (similar\n\t// universally to almost every Linux image out there) have a single .Cmd field populated so that\n\t// `docker run --rm image` starts the default shell which would typically be sh on Linux,\n\t// or cmd on Windows. The catch to this is that if a dockerfile had `CMD [\"c:\\\\windows\\\\system32\\\\cmd.exe\"]`,\n\t// we wouldn't be able to tell the difference. However, that would be highly unlikely, and besides, this\n\t// is only trying to give a helpful warning of possibly unexpected results.\n\tif d.state.operatingSystem == \"windows\" &&\n\t\td.state.runConfig.ArgsEscaped != argsEscaped &&\n\t\t((len(runConfig.Cmd) == 1 && strings.ToLower(runConfig.Cmd[0]) != `c:\\windows\\system32\\cmd.exe` && len(runConfig.Shell) == 0) || (len(runConfig.Cmd) > 1)) {\n\t\tfmt.Fprintf(d.builder.Stderr, \" ---> [Warning] Shell-form CMD and exec-form ENTRYPOINT may have unexpected results\\n\")\n\t}\n\n\trunConfig.Entrypoint = cmd\n\trunConfig.ArgsEscaped = argsEscaped\n\tif !d.state.cmdSet {\n\t\trunConfig.Cmd = nil\n\t}\n\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"ENTRYPOINT %q\", runConfig.Entrypoint))\n}\n\n// EXPOSE 6667/tcp 7000/tcp\n//\n// Expose ports for links and port mappings. This all ends up in\n// req.runConfig.ExposedPorts for runconfig.\nfunc dispatchExpose(ctx context.Context, d dispatchRequest, c *instructions.ExposeCommand, envs []string) error {\n\t// custom multi word expansion\n\t// expose $FOO with FOO=\"80 443\" is expanded as EXPOSE [80,443]. This is the only command supporting word to words expansion\n\t// so the word processing has been de-generalized\n\tports := []string{}\n\tfor _, p := range c.Ports {\n\t\tps, err := d.shlex.ProcessWords(p, envs)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tports = append(ports, ps...)\n\t}\n\tc.Ports = ports\n\n\tps, _, err := nat.ParsePortSpecs(ports)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.state.runConfig.ExposedPorts == nil {\n\t\td.state.runConfig.ExposedPorts = make(nat.PortSet)\n\t}\n\tfor p := range ps {\n\t\td.state.runConfig.ExposedPorts[p] = struct{}{}\n\t}\n\n\treturn d.builder.commit(ctx, d.state, \"EXPOSE \"+strings.Join(c.Ports, \" \"))\n}\n\n// USER foo\n//\n// Set the user to 'foo' for future commands and when running the\n// ENTRYPOINT/CMD at container run time.\nfunc dispatchUser(ctx context.Context, d dispatchRequest, c *instructions.UserCommand) error {\n\td.state.runConfig.User = c.User\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"USER %v\", c.User))\n}\n\n// VOLUME /foo\n//\n// Expose the volume /foo for use. Will also accept the JSON array form.\nfunc dispatchVolume(ctx context.Context, d dispatchRequest, c *instructions.VolumeCommand) error {\n\tif d.state.runConfig.Volumes == nil {\n\t\td.state.runConfig.Volumes = map[string]struct{}{}\n\t}\n\tfor _, v := range c.Volumes {\n\t\tif v == \"\" {\n\t\t\treturn errors.New(\"VOLUME specified can not be an empty string\")\n\t\t}\n\t\td.state.runConfig.Volumes[v] = struct{}{}\n\t}\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"VOLUME %v\", c.Volumes))\n}\n\n// STOPSIGNAL signal\n//\n// Set the signal that will be used to kill the container.\nfunc dispatchStopSignal(ctx context.Context, d dispatchRequest, c *instructions.StopSignalCommand) error {\n\t_, err := signal.ParseSignal(c.Signal)\n\tif err != nil {\n\t\treturn errdefs.InvalidParameter(err)\n\t}\n\td.state.runConfig.StopSignal = c.Signal\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"STOPSIGNAL %v\", c.Signal))\n}\n\n// ARG name[=value]\n//\n// Adds the variable foo to the trusted list of variables that can be passed\n// to builder using the --build-arg flag for expansion/substitution or passing to 'run'.\n// Dockerfile author may optionally set a default value of this variable.\nfunc dispatchArg(ctx context.Context, d dispatchRequest, c *instructions.ArgCommand) error {\n\tvar commitStr strings.Builder\n\tcommitStr.WriteString(\"ARG \")\n\tfor i, arg := range c.Args {\n\t\tif i > 0 {\n\t\t\tcommitStr.WriteString(\" \")\n\t\t}\n\t\tcommitStr.WriteString(arg.Key)\n\t\tif arg.Value != nil {\n\t\t\tcommitStr.WriteString(\"=\")\n\t\t\tcommitStr.WriteString(*arg.Value)\n\t\t}\n\t\td.state.buildArgs.AddArg(arg.Key, arg.Value)\n\t}\n\n\treturn d.builder.commit(ctx, d.state, commitStr.String())\n}\n\n// SHELL powershell -command\n//\n// Set the non-default shell to use.\nfunc dispatchShell(ctx context.Context, d dispatchRequest, c *instructions.ShellCommand) error {\n\td.state.runConfig.Shell = c.Shell\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"SHELL %v\", d.state.runConfig.Shell))\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\nimport (\n\t\"context\"\n\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n)\n\n// ImageProber exposes an Image cache to the Builder. It supports resetting a\n// cache.\ntype ImageProber interface {\n\tReset(ctx context.Context) error\n\tProbe(parentID string, runConfig *container.Config) (string, error)\n}\n\ntype resetFunc func(context.Context) (builder.ImageCache, error)\n\ntype imageProber struct {\n\tcache       builder.ImageCache\n\treset       resetFunc\n\tcacheBusted bool\n}\n\nfunc newImageProber(ctx context.Context, cacheBuilder builder.ImageCacheBuilder, cacheFrom []string, noCache bool) (ImageProber, error) {\n\tif noCache {\n\t\treturn &nopProber{}, nil\n\t}\n\n\treset := func(ctx context.Context) (builder.ImageCache, error) {\n\t\treturn cacheBuilder.MakeImageCache(ctx, cacheFrom)\n\t}\n\n\tcache, err := reset(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &imageProber{cache: cache, reset: reset}, nil\n}\n\nfunc (c *imageProber) Reset(ctx context.Context) error {\n\tnewCache, err := c.reset(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.cache = newCache\n\tc.cacheBusted = false\n\treturn nil\n}\n\n// Probe checks if cache match can be found for current build instruction.\n// It returns the cachedID if there is a hit, and the empty string on miss\nfunc (c *imageProber) Probe(parentID string, runConfig *container.Config) (string, error) {\n\tif c.cacheBusted {\n\t\treturn \"\", nil\n\t}\n\tcacheID, err := c.cache.GetCache(parentID, runConfig)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(cacheID) == 0 {\n\t\tlog.G(context.TODO()).Debugf(\"[BUILDER] Cache miss: %s\", runConfig.Cmd)\n\t\tc.cacheBusted = true\n\t\treturn \"\", nil\n\t}\n\tlog.G(context.TODO()).Debugf(\"[BUILDER] Use cached version: %s\", runConfig.Cmd)\n\treturn cacheID, nil\n}\n\ntype nopProber struct{}\n\nfunc (c *nopProber) Reset(ctx context.Context) error {\n\treturn nil\n}\n\nfunc (c *nopProber) Probe(_ string, _ *container.Config) (string, error) {\n\treturn \"\", nil\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\n// internals for handling commands. Covers many areas and a lot of\n// non-contiguous functionality. Please read the comments.\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/pkg/archive\"\n\t\"github.com/docker/docker/pkg/chrootarchive\"\n\t\"github.com/docker/docker/pkg/stringid\"\n\t\"github.com/docker/go-connections/nat\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\nfunc (b *Builder) getArchiver() *archive.Archiver {\n\treturn chrootarchive.NewArchiver(b.idMapping)\n}\n\nfunc (b *Builder) commit(ctx context.Context, dispatchState *dispatchState, comment string) error {\n\tif b.disableCommit {\n\t\treturn nil\n\t}\n\tif !dispatchState.hasFromImage() {\n\t\treturn errors.New(\"Please provide a source image with `from` prior to commit\")\n\t}\n\n\trunConfigWithCommentCmd := copyRunConfig(dispatchState.runConfig, withCmdComment(comment, dispatchState.operatingSystem))\n\tid, err := b.probeAndCreate(ctx, dispatchState, runConfigWithCommentCmd)\n\tif err != nil || id == \"\" {\n\t\treturn err\n\t}\n\n\treturn b.commitContainer(ctx, dispatchState, id, runConfigWithCommentCmd)\n}\n\nfunc (b *Builder) commitContainer(ctx context.Context, dispatchState *dispatchState, id string, containerConfig *container.Config) error {\n\tif b.disableCommit {\n\t\treturn nil\n\t}\n\n\tcommitCfg := backend.CommitConfig{\n\t\tAuthor: dispatchState.maintainer,\n\t\t// TODO: this copy should be done by Commit()\n\t\tConfig:          copyRunConfig(dispatchState.runConfig),\n\t\tContainerConfig: containerConfig,\n\t\tContainerID:     id,\n\t}\n\n\timageID, err := b.docker.CommitBuildStep(ctx, commitCfg)\n\tdispatchState.imageID = string(imageID)\n\treturn err\n}\n\nfunc (b *Builder) exportImage(ctx context.Context, state *dispatchState, layer builder.RWLayer, parent builder.Image, runConfig *container.Config) error {\n\tnewLayer, err := layer.Commit()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tparentImage, ok := parent.(*image.Image)\n\tif !ok {\n\t\treturn errors.Errorf(\"unexpected image type\")\n\t}\n\n\tplatform := &ocispec.Platform{\n\t\tOS:           parentImage.OS,\n\t\tArchitecture: parentImage.Architecture,\n\t\tVariant:      parentImage.Variant,\n\t}\n\n\t// add an image mount without an image so the layer is properly unmounted\n\t// if there is an error before we can add the full mount with image\n\tb.imageSources.Add(newImageMount(nil, newLayer), platform)\n\n\tnewImage := image.NewChildImage(parentImage, image.ChildConfig{\n\t\tAuthor:          state.maintainer,\n\t\tContainerConfig: runConfig,\n\t\tDiffID:          newLayer.DiffID(),\n\t\tConfig:          copyRunConfig(state.runConfig),\n\t}, parentImage.OS)\n\n\t// TODO: it seems strange to marshal this here instead of just passing in the\n\t// image struct\n\tconfig, err := newImage.MarshalJSON()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to encode image config\")\n\t}\n\n\t// when writing the new image's manifest, we now need to pass in the new layer's digest.\n\t// before the containerd store work this was unnecessary since we get the layer id\n\t// from the image's RootFS ChainID -- see:\n\t// https://github.com/moby/moby/blob/8cf66ed7322fa885ef99c4c044fa23e1727301dc/image/store.go#L162\n\t// however, with the containerd store we can't do this. An alternative implementation here\n\t// without changing the signature would be to get the layer digest by walking the content store\n\t// and filtering the objects to find the layer with the DiffID we want, but that has performance\n\t// implications that should be called out/investigated\n\texportedImage, err := b.docker.CreateImage(ctx, config, state.imageID, newLayer.ContentStoreDigest())\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to export image\")\n\t}\n\n\tstate.imageID = exportedImage.ImageID()\n\tb.imageSources.Add(newImageMount(exportedImage, newLayer), platform)\n\treturn nil\n}\n\nfunc (b *Builder) performCopy(ctx context.Context, req dispatchRequest, inst copyInstruction) error {\n\tstate := req.state\n\tsrcHash := getSourceHashFromInfos(inst.infos)\n\n\tvar chownComment string\n\tif inst.chownStr != \"\" {\n\t\tchownComment = fmt.Sprintf(\"--chown=%s \", inst.chownStr)\n\t}\n\tcommentStr := fmt.Sprintf(\"%s %s%s in %s \", inst.cmdName, chownComment, srcHash, inst.dest)\n\n\t// TODO: should this have been using origPaths instead of srcHash in the comment?\n\trunConfigWithCommentCmd := copyRunConfig(\n\t\tstate.runConfig,\n\t\twithCmdCommentString(commentStr, state.operatingSystem))\n\thit, err := b.probeCache(state, runConfigWithCommentCmd)\n\tif err != nil || hit {\n\t\treturn err\n\t}\n\n\timageMount, err := b.imageSources.Get(ctx, state.imageID, true, req.builder.platform)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to get destination image %q\", state.imageID)\n\t}\n\n\trwLayer, err := imageMount.NewRWLayer()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rwLayer.Release()\n\n\tdestInfo, err := createDestInfo(state.runConfig.WorkingDir, inst, rwLayer, state.operatingSystem)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tidentity := b.idMapping.RootPair()\n\t// if a chown was requested, perform the steps to get the uid, gid\n\t// translated (if necessary because of user namespaces), and replace\n\t// the root pair with the chown pair for copy operations\n\tif inst.chownStr != \"\" {\n\t\tidentity, err = parseChownFlag(ctx, b, state, inst.chownStr, destInfo.root, b.idMapping)\n\t\tif err != nil {\n\t\t\tif b.options.Platform != \"windows\" {\n\t\t\t\treturn errors.Wrapf(err, \"unable to convert uid/gid chown string to host mapping\")\n\t\t\t}\n\n\t\t\treturn errors.Wrapf(err, \"unable to map container user account name to SID\")\n\t\t}\n\t}\n\n\tfor _, info := range inst.infos {\n\t\topts := copyFileOptions{\n\t\t\tdecompress: inst.allowLocalDecompression,\n\t\t\tarchiver:   b.getArchiver(),\n\t\t}\n\t\tif !inst.preserveOwnership {\n\t\t\topts.identity = &identity\n\t\t}\n\t\tif err := performCopyForInfo(destInfo, info, opts); err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to copy files\")\n\t\t}\n\t}\n\treturn b.exportImage(ctx, state, rwLayer, imageMount.Image(), runConfigWithCommentCmd)\n}\n\nfunc createDestInfo(workingDir string, inst copyInstruction, rwLayer builder.RWLayer, platform string) (copyInfo, error) {\n\t// Twiddle the destination when it's a relative path - meaning, make it\n\t// relative to the WORKINGDIR\n\tdest, err := normalizeDest(workingDir, inst.dest)\n\tif err != nil {\n\t\treturn copyInfo{}, errors.Wrapf(err, \"invalid %s\", inst.cmdName)\n\t}\n\n\treturn copyInfo{root: rwLayer.Root(), path: dest}, nil\n}\n\n// For backwards compat, if there's just one info then use it as the\n// cache look-up string, otherwise hash 'em all into one\nfunc getSourceHashFromInfos(infos []copyInfo) string {\n\tif len(infos) == 1 {\n\t\treturn infos[0].hash\n\t}\n\tvar hashs []string\n\tfor _, info := range infos {\n\t\thashs = append(hashs, info.hash)\n\t}\n\treturn hashStringSlice(\"multi\", hashs)\n}\n\nfunc hashStringSlice(prefix string, slice []string) string {\n\thasher := sha256.New()\n\thasher.Write([]byte(strings.Join(slice, \",\")))\n\treturn prefix + \":\" + hex.EncodeToString(hasher.Sum(nil))\n}\n\ntype runConfigModifier func(*container.Config)\n\nfunc withCmd(cmd []string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Cmd = cmd\n\t}\n}\n\nfunc withArgsEscaped(argsEscaped bool) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.ArgsEscaped = argsEscaped\n\t}\n}\n\n// withCmdComment sets Cmd to a nop comment string. See withCmdCommentString for\n// why there are two almost identical versions of this.\nfunc withCmdComment(comment string, platform string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Cmd = append(getShell(runConfig, platform), \"#(nop) \", comment)\n\t}\n}\n\n// withCmdCommentString exists to maintain compatibility with older versions.\n// A few instructions (workdir, copy, add) used a nop comment that is a single arg\n// where as all the other instructions used a two arg comment string. This\n// function implements the single arg version.\nfunc withCmdCommentString(comment string, platform string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Cmd = append(getShell(runConfig, platform), \"#(nop) \"+comment)\n\t}\n}\n\nfunc withEnv(env []string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Env = env\n\t}\n}\n\n// withEntrypointOverride sets an entrypoint on runConfig if the command is\n// not empty. The entrypoint is left unmodified if command is empty.\n//\n// The dockerfile RUN instruction expect to run without an entrypoint\n// so the runConfig entrypoint needs to be modified accordingly. ContainerCreate\n// will change a []string{\"\"} entrypoint to nil, so we probe the cache with the\n// nil entrypoint.\nfunc withEntrypointOverride(cmd []string, entrypoint []string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\tif len(cmd) > 0 {\n\t\t\trunConfig.Entrypoint = entrypoint\n\t\t}\n\t}\n}\n\n// withoutHealthcheck disables healthcheck.\n//\n// The dockerfile RUN instruction expect to run without healthcheck\n// so the runConfig Healthcheck needs to be disabled.\nfunc withoutHealthcheck() runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Healthcheck = &container.HealthConfig{\n\t\t\tTest: []string{\"NONE\"},\n\t\t}\n\t}\n}\n\nfunc copyRunConfig(runConfig *container.Config, modifiers ...runConfigModifier) *container.Config {\n\tcopy := *runConfig\n\tcopy.Cmd = copyStringSlice(runConfig.Cmd)\n\tcopy.Env = copyStringSlice(runConfig.Env)\n\tcopy.Entrypoint = copyStringSlice(runConfig.Entrypoint)\n\tcopy.OnBuild = copyStringSlice(runConfig.OnBuild)\n\tcopy.Shell = copyStringSlice(runConfig.Shell)\n\n\tif copy.Volumes != nil {\n\t\tcopy.Volumes = make(map[string]struct{}, len(runConfig.Volumes))\n\t\tfor k, v := range runConfig.Volumes {\n\t\t\tcopy.Volumes[k] = v\n\t\t}\n\t}\n\n\tif copy.ExposedPorts != nil {\n\t\tcopy.ExposedPorts = make(nat.PortSet, len(runConfig.ExposedPorts))\n\t\tfor k, v := range runConfig.ExposedPorts {\n\t\t\tcopy.ExposedPorts[k] = v\n\t\t}\n\t}\n\n\tif copy.Labels != nil {\n\t\tcopy.Labels = make(map[string]string, len(runConfig.Labels))\n\t\tfor k, v := range runConfig.Labels {\n\t\t\tcopy.Labels[k] = v\n\t\t}\n\t}\n\n\tfor _, modifier := range modifiers {\n\t\tmodifier(&copy)\n\t}\n\treturn &copy\n}\n\nfunc copyStringSlice(orig []string) []string {\n\tif orig == nil {\n\t\treturn nil\n\t}\n\treturn append([]string{}, orig...)\n}\n\n// getShell is a helper function which gets the right shell for prefixing the\n// shell-form of RUN, ENTRYPOINT and CMD instructions\nfunc getShell(c *container.Config, os string) []string {\n\tif 0 == len(c.Shell) {\n\t\treturn append([]string{}, defaultShellForOS(os)[:]...)\n\t}\n\treturn append([]string{}, c.Shell[:]...)\n}\n\nfunc (b *Builder) probeCache(dispatchState *dispatchState, runConfig *container.Config) (bool, error) {\n\tcachedID, err := b.imageProber.Probe(dispatchState.imageID, runConfig)\n\tif cachedID == \"\" || err != nil {\n\t\treturn false, err\n\t}\n\tfmt.Fprint(b.Stdout, \" ---> Using cache\\n\")\n\n\tdispatchState.imageID = cachedID\n\treturn true, nil\n}\n\nvar defaultLogConfig = container.LogConfig{Type: \"none\"}\n\nfunc (b *Builder) probeAndCreate(ctx context.Context, dispatchState *dispatchState, runConfig *container.Config) (string, error) {\n\tif hit, err := b.probeCache(dispatchState, runConfig); err != nil || hit {\n\t\treturn \"\", err\n\t}\n\treturn b.create(ctx, runConfig)\n}\n\nfunc (b *Builder) create(ctx context.Context, runConfig *container.Config) (string, error) {\n\tlog.G(ctx).Debugf(\"[BUILDER] Command to be executed: %v\", runConfig.Cmd)\n\n\thostConfig := hostConfigFromOptions(b.options)\n\tcontainer, err := b.containerManager.Create(ctx, runConfig, hostConfig)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// TODO: could this be moved into containerManager.Create() ?\n\tfor _, warning := range container.Warnings {\n\t\tfmt.Fprintf(b.Stdout, \" ---> [Warning] %s\\n\", warning)\n\t}\n\tfmt.Fprintf(b.Stdout, \" ---> Running in %s\\n\", stringid.TruncateID(container.ID))\n\treturn container.ID, nil\n}\n\nfunc hostConfigFromOptions(options *types.ImageBuildOptions) *container.HostConfig {\n\tresources := container.Resources{\n\t\tCgroupParent: options.CgroupParent,\n\t\tCPUShares:    options.CPUShares,\n\t\tCPUPeriod:    options.CPUPeriod,\n\t\tCPUQuota:     options.CPUQuota,\n\t\tCpusetCpus:   options.CPUSetCPUs,\n\t\tCpusetMems:   options.CPUSetMems,\n\t\tMemory:       options.Memory,\n\t\tMemorySwap:   options.MemorySwap,\n\t\tUlimits:      options.Ulimits,\n\t}\n\n\thc := &container.HostConfig{\n\t\tSecurityOpt: options.SecurityOpt,\n\t\tIsolation:   options.Isolation,\n\t\tShmSize:     options.ShmSize,\n\t\tResources:   resources,\n\t\tNetworkMode: container.NetworkMode(options.NetworkMode),\n\t\t// Set a log config to override any default value set on the daemon\n\t\tLogConfig:  defaultLogConfig,\n\t\tExtraHosts: options.ExtraHosts,\n\t}\n\treturn hc\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"runtime\"\n\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n\tcontainerpkg \"github.com/docker/docker/container\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/opencontainers/go-digest\"\n)\n\n// MockBackend implements the builder.Backend interface for unit testing\ntype MockBackend struct {\n\tcontainerCreateFunc func(config backend.ContainerCreateConfig) (container.CreateResponse, error)\n\tcommitFunc          func(backend.CommitConfig) (image.ID, error)\n\tgetImageFunc        func(string) (builder.Image, builder.ROLayer, error)\n\tmakeImageCacheFunc  func(cacheFrom []string) builder.ImageCache\n}\n\nfunc (m *MockBackend) ContainerAttachRaw(cID string, stdin io.ReadCloser, stdout, stderr io.Writer, stream bool, attached chan struct{}) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) ContainerCreateIgnoreImagesArgsEscaped(ctx context.Context, config backend.ContainerCreateConfig) (container.CreateResponse, error) {\n\tif m.containerCreateFunc != nil {\n\t\treturn m.containerCreateFunc(config)\n\t}\n\treturn container.CreateResponse{}, nil\n}\n\nfunc (m *MockBackend) ContainerRm(name string, config *backend.ContainerRmConfig) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) CommitBuildStep(ctx context.Context, c backend.CommitConfig) (image.ID, error) {\n\tif m.commitFunc != nil {\n\t\treturn m.commitFunc(c)\n\t}\n\treturn \"\", nil\n}\n\nfunc (m *MockBackend) ContainerStart(ctx context.Context, containerID string, hostConfig *container.HostConfig, checkpoint string, checkpointDir string) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) ContainerWait(ctx context.Context, containerID string, condition containerpkg.WaitCondition) (<-chan containerpkg.StateStatus, error) {\n\treturn nil, nil\n}\n\nfunc (m *MockBackend) ContainerCreateWorkdir(containerID string) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) CopyOnBuild(containerID string, destPath string, srcRoot string, srcPath string, decompress bool) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) GetImageAndReleasableLayer(ctx context.Context, refOrID string, opts backend.GetImageAndLayerOptions) (builder.Image, builder.ROLayer, error) {\n\tif m.getImageFunc != nil {\n\t\treturn m.getImageFunc(refOrID)\n\t}\n\n\treturn &mockImage{id: \"theid\"}, &mockLayer{}, nil\n}\n\nfunc (m *MockBackend) MakeImageCache(ctx context.Context, cacheFrom []string) (builder.ImageCache, error) {\n\tif m.makeImageCacheFunc != nil {\n\t\treturn m.makeImageCacheFunc(cacheFrom), nil\n\t}\n\treturn nil, nil\n}\n\nfunc (m *MockBackend) CreateImage(ctx context.Context, config []byte, parent string, layerDigest digest.Digest) (builder.Image, error) {\n\treturn &mockImage{id: \"test\"}, nil\n}\n\ntype mockImage struct {\n\tid     string\n\tconfig *container.Config\n}\n\nfunc (i *mockImage) ImageID() string {\n\treturn i.id\n}\n\nfunc (i *mockImage) RunConfig() *container.Config {\n\treturn i.config\n}\n\nfunc (i *mockImage) OperatingSystem() string {\n\treturn runtime.GOOS\n}\n\nfunc (i *mockImage) MarshalJSON() ([]byte, error) {\n\ttype rawImage mockImage\n\treturn json.Marshal(rawImage(*i)) //nolint:staticcheck\n}\n\ntype mockImageCache struct {\n\tgetCacheFunc func(parentID string, cfg *container.Config) (string, error)\n}\n\nfunc (mic *mockImageCache) GetCache(parentID string, cfg *container.Config) (string, error) {\n\tif mic.getCacheFunc != nil {\n\t\treturn mic.getCacheFunc(parentID, cfg)\n\t}\n\treturn \"\", nil\n}\n\ntype mockLayer struct{}\n\nfunc (l *mockLayer) ContentStoreDigest() digest.Digest {\n\treturn \"\"\n}\n\nfunc (l *mockLayer) Release() error {\n\treturn nil\n}\n\nfunc (l *mockLayer) NewRWLayer() (builder.RWLayer, error) {\n\treturn &mockRWLayer{}, nil\n}\n\nfunc (l *mockLayer) DiffID() layer.DiffID {\n\treturn \"abcdef\"\n}\n\ntype mockRWLayer struct{}\n\nfunc (l *mockRWLayer) Release() error {\n\treturn nil\n}\n\nfunc (l *mockRWLayer) Commit() (builder.ROLayer, error) {\n\treturn nil, nil\n}\n\nfunc (l *mockRWLayer) Root() string {\n\treturn \"\"\n}\n", "package containerd\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\n// MakeImageCache creates a stateful image cache.\nfunc (i *ImageService) MakeImageCache(ctx context.Context, cacheFrom []string) (builder.ImageCache, error) {\n\timages := []*image.Image{}\n\tif len(cacheFrom) == 0 {\n\t\treturn &localCache{\n\t\t\timageService: i,\n\t\t}, nil\n\t}\n\n\tfor _, c := range cacheFrom {\n\t\th, err := i.ImageHistory(ctx, c)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, hi := range h {\n\t\t\tif hi.ID != \"<missing>\" {\n\t\t\t\tim, err := i.GetImage(ctx, hi.ID, backend.GetImageOpts{})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\timages = append(images, im)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &imageCache{\n\t\tlc: &localCache{\n\t\t\timageService: i,\n\t\t},\n\t\timages:       images,\n\t\timageService: i,\n\t}, nil\n}\n\ntype localCache struct {\n\timageService *ImageService\n}\n\nfunc (ic *localCache) GetCache(parentID string, cfg *container.Config) (imageID string, err error) {\n\tctx := context.TODO()\n\n\tvar children []image.ID\n\n\t// FROM scratch\n\tif parentID == \"\" {\n\t\tc, err := ic.imageService.getImagesWithLabel(ctx, imageLabelClassicBuilderFromScratch, \"1\")\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tchildren = c\n\t} else {\n\t\tc, err := ic.imageService.Children(ctx, image.ID(parentID))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tchildren = c\n\t}\n\n\tvar match *image.Image\n\tfor _, child := range children {\n\t\tccDigestStr, err := ic.imageService.getImageLabelByDigest(ctx, child.Digest(), imageLabelClassicBuilderContainerConfig)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif ccDigestStr == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tdgst, err := digest.Parse(ccDigestStr)\n\t\tif err != nil {\n\t\t\tlog.G(ctx).WithError(err).Warnf(\"invalid container config digest: %q\", ccDigestStr)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar cc container.Config\n\t\tif err := readConfig(ctx, ic.imageService.content, ocispec.Descriptor{Digest: dgst}, &cc); err != nil {\n\t\t\tif errdefs.IsNotFound(err) {\n\t\t\t\tlog.G(ctx).WithError(err).WithField(\"image\", child).Warnf(\"missing container config: %q\", ccDigestStr)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif isMatch(&cc, cfg) {\n\t\t\tchildImage, err := ic.imageService.GetImage(ctx, child.String(), backend.GetImageOpts{})\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tif childImage.Created != nil && (match == nil || match.Created.Before(*childImage.Created)) {\n\t\t\t\tmatch = childImage\n\t\t\t}\n\t\t}\n\t}\n\n\tif match == nil {\n\t\treturn \"\", nil\n\t}\n\n\treturn match.ID().String(), nil\n}\n\ntype imageCache struct {\n\timages       []*image.Image\n\timageService *ImageService\n\tlc           *localCache\n}\n\nfunc (ic *imageCache) GetCache(parentID string, cfg *container.Config) (imageID string, err error) {\n\tctx := context.TODO()\n\n\timgID, err := ic.lc.GetCache(parentID, cfg)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif imgID != \"\" {\n\t\tfor _, s := range ic.images {\n\t\t\tif ic.isParent(ctx, s, image.ID(imgID)) {\n\t\t\t\treturn imgID, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tvar parent *image.Image\n\tlenHistory := 0\n\n\tif parentID != \"\" {\n\t\tparent, err = ic.imageService.GetImage(ctx, parentID, backend.GetImageOpts{})\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tlenHistory = len(parent.History)\n\t}\n\tfor _, target := range ic.images {\n\t\tif !isValidParent(target, parent) || !isValidConfig(cfg, target.History[lenHistory]) {\n\t\t\tcontinue\n\t\t}\n\t\treturn target.ID().String(), nil\n\t}\n\n\treturn \"\", nil\n}\n\nfunc isValidConfig(cfg *container.Config, h image.History) bool {\n\t// todo: make this format better than join that loses data\n\treturn strings.Join(cfg.Cmd, \" \") == h.CreatedBy\n}\n\nfunc isValidParent(img, parent *image.Image) bool {\n\tif len(img.History) == 0 {\n\t\treturn false\n\t}\n\tif parent == nil || len(parent.History) == 0 && len(parent.RootFS.DiffIDs) == 0 {\n\t\treturn true\n\t}\n\tif len(parent.History) >= len(img.History) {\n\t\treturn false\n\t}\n\tif len(parent.RootFS.DiffIDs) > len(img.RootFS.DiffIDs) {\n\t\treturn false\n\t}\n\n\tfor i, h := range parent.History {\n\t\tif !reflect.DeepEqual(h, img.History[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, d := range parent.RootFS.DiffIDs {\n\t\tif d != img.RootFS.DiffIDs[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (ic *imageCache) isParent(ctx context.Context, img *image.Image, parentID image.ID) bool {\n\tii, err := ic.imageService.resolveImage(ctx, img.ImageID())\n\tif err != nil {\n\t\treturn false\n\t}\n\tparent, ok := ii.Labels[imageLabelClassicBuilderParent]\n\tif ok {\n\t\treturn parent == parentID.String()\n\t}\n\n\tp, err := ic.imageService.GetImage(ctx, parentID.String(), backend.GetImageOpts{})\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn ic.isParent(ctx, p, parentID)\n}\n\n// compare two Config struct. Do not compare the \"Image\" nor \"Hostname\" fields\n// If OpenStdin is set, then it differs\nfunc isMatch(a, b *container.Config) bool {\n\tif a == nil || b == nil ||\n\t\ta.OpenStdin || b.OpenStdin {\n\t\treturn false\n\t}\n\tif a.AttachStdout != b.AttachStdout ||\n\t\ta.AttachStderr != b.AttachStderr ||\n\t\ta.User != b.User ||\n\t\ta.OpenStdin != b.OpenStdin ||\n\t\ta.Tty != b.Tty {\n\t\treturn false\n\t}\n\n\tif len(a.Cmd) != len(b.Cmd) ||\n\t\tlen(a.Env) != len(b.Env) ||\n\t\tlen(a.Labels) != len(b.Labels) ||\n\t\tlen(a.ExposedPorts) != len(b.ExposedPorts) ||\n\t\tlen(a.Entrypoint) != len(b.Entrypoint) ||\n\t\tlen(a.Volumes) != len(b.Volumes) {\n\t\treturn false\n\t}\n\n\tfor i := 0; i < len(a.Cmd); i++ {\n\t\tif a.Cmd[i] != b.Cmd[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := 0; i < len(a.Env); i++ {\n\t\tif a.Env[i] != b.Env[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor k, v := range a.Labels {\n\t\tif v != b.Labels[k] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor k := range a.ExposedPorts {\n\t\tif _, exists := b.ExposedPorts[k]; !exists {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor i := 0; i < len(a.Entrypoint); i++ {\n\t\tif a.Entrypoint[i] != b.Entrypoint[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor key := range a.Volumes {\n\t\tif _, exists := b.Volumes[key]; !exists {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "package images // import \"github.com/docker/docker/daemon/images\"\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"runtime\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/log\"\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/registry\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/docker/docker/pkg/progress\"\n\t\"github.com/docker/docker/pkg/streamformatter\"\n\t\"github.com/docker/docker/pkg/stringid\"\n\tregistrypkg \"github.com/docker/docker/registry\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\ntype roLayer struct {\n\treleased   bool\n\tlayerStore layer.Store\n\troLayer    layer.Layer\n}\n\nfunc (l *roLayer) ContentStoreDigest() digest.Digest {\n\treturn \"\"\n}\n\nfunc (l *roLayer) DiffID() layer.DiffID {\n\tif l.roLayer == nil {\n\t\treturn layer.DigestSHA256EmptyTar\n\t}\n\treturn l.roLayer.DiffID()\n}\n\nfunc (l *roLayer) Release() error {\n\tif l.released {\n\t\treturn nil\n\t}\n\tif l.roLayer != nil {\n\t\tmetadata, err := l.layerStore.Release(l.roLayer)\n\t\tlayer.LogReleaseMetadata(metadata)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to release ROLayer\")\n\t\t}\n\t}\n\tl.roLayer = nil\n\tl.released = true\n\treturn nil\n}\n\nfunc (l *roLayer) NewRWLayer() (builder.RWLayer, error) {\n\tvar chainID layer.ChainID\n\tif l.roLayer != nil {\n\t\tchainID = l.roLayer.ChainID()\n\t}\n\n\tmountID := stringid.GenerateRandomID()\n\tnewLayer, err := l.layerStore.CreateRWLayer(mountID, chainID, nil)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to create rwlayer\")\n\t}\n\n\trwLayer := &rwLayer{layerStore: l.layerStore, rwLayer: newLayer}\n\n\tfs, err := newLayer.Mount(\"\")\n\tif err != nil {\n\t\trwLayer.Release()\n\t\treturn nil, err\n\t}\n\n\trwLayer.fs = fs\n\n\treturn rwLayer, nil\n}\n\ntype rwLayer struct {\n\treleased   bool\n\tlayerStore layer.Store\n\trwLayer    layer.RWLayer\n\tfs         string\n}\n\nfunc (l *rwLayer) Root() string {\n\treturn l.fs\n}\n\nfunc (l *rwLayer) Commit() (builder.ROLayer, error) {\n\tstream, err := l.rwLayer.TarStream()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stream.Close()\n\n\tvar chainID layer.ChainID\n\tif parent := l.rwLayer.Parent(); parent != nil {\n\t\tchainID = parent.ChainID()\n\t}\n\n\tnewLayer, err := l.layerStore.Register(stream, chainID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// TODO: An optimization would be to handle empty layers before returning\n\treturn &roLayer{layerStore: l.layerStore, roLayer: newLayer}, nil\n}\n\nfunc (l *rwLayer) Release() error {\n\tif l.released {\n\t\treturn nil\n\t}\n\n\tif l.fs != \"\" {\n\t\tif err := l.rwLayer.Unmount(); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to unmount RWLayer\")\n\t\t}\n\t\tl.fs = \"\"\n\t}\n\n\tmetadata, err := l.layerStore.ReleaseRWLayer(l.rwLayer)\n\tlayer.LogReleaseMetadata(metadata)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to release RWLayer\")\n\t}\n\tl.released = true\n\treturn nil\n}\n\nfunc newROLayerForImage(img *image.Image, layerStore layer.Store) (builder.ROLayer, error) {\n\tif img == nil || img.RootFS.ChainID() == \"\" {\n\t\treturn &roLayer{layerStore: layerStore}, nil\n\t}\n\t// Hold a reference to the image layer so that it can't be removed before\n\t// it is released\n\tlyr, err := layerStore.Get(img.RootFS.ChainID())\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to get layer for image %s\", img.ImageID())\n\t}\n\treturn &roLayer{layerStore: layerStore, roLayer: lyr}, nil\n}\n\n// TODO: could this use the regular daemon PullImage ?\nfunc (i *ImageService) pullForBuilder(ctx context.Context, name string, authConfigs map[string]registry.AuthConfig, output io.Writer, platform *ocispec.Platform) (*image.Image, error) {\n\tref, err := reference.ParseNormalizedNamed(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tref = reference.TagNameOnly(ref)\n\n\tpullRegistryAuth := &registry.AuthConfig{}\n\tif len(authConfigs) > 0 {\n\t\t// The request came with a full auth config, use it\n\t\trepoInfo, err := i.registryService.ResolveRepository(ref)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresolvedConfig := registrypkg.ResolveAuthConfig(authConfigs, repoInfo.Index)\n\t\tpullRegistryAuth = &resolvedConfig\n\t}\n\n\tif err := i.pullImageWithReference(ctx, ref, platform, nil, pullRegistryAuth, output); err != nil {\n\t\treturn nil, err\n\t}\n\n\timg, err := i.GetImage(ctx, name, backend.GetImageOpts{Platform: platform})\n\tif errdefs.IsNotFound(err) && img != nil && platform != nil {\n\t\timgPlat := ocispec.Platform{\n\t\t\tOS:           img.OS,\n\t\t\tArchitecture: img.BaseImgArch(),\n\t\t\tVariant:      img.BaseImgVariant(),\n\t\t}\n\n\t\tp := *platform\n\t\tif !platforms.Only(p).Match(imgPlat) {\n\t\t\tpo := streamformatter.NewJSONProgressOutput(output, false)\n\t\t\tprogress.Messagef(po, \"\", `\nWARNING: Pulled image with specified platform (%s), but the resulting image's configured platform (%s) does not match.\nThis is most likely caused by a bug in the build system that created the fetched image (%s).\nPlease notify the image author to correct the configuration.`,\n\t\t\t\tplatforms.Format(p), platforms.Format(imgPlat), name,\n\t\t\t)\n\t\t\tlog.G(ctx).WithError(err).WithField(\"image\", name).Warn(\"Ignoring error about platform mismatch where the manifest list points to an image whose configuration does not match the platform in the manifest.\")\n\t\t\terr = nil\n\t\t}\n\t}\n\treturn img, err\n}\n\n// GetImageAndReleasableLayer returns an image and releaseable layer for a reference or ID.\n// Every call to GetImageAndReleasableLayer MUST call releasableLayer.Release() to prevent\n// leaking of layers.\nfunc (i *ImageService) GetImageAndReleasableLayer(ctx context.Context, refOrID string, opts backend.GetImageAndLayerOptions) (builder.Image, builder.ROLayer, error) {\n\tif refOrID == \"\" { // FROM scratch\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\treturn nil, nil, fmt.Errorf(`\"FROM scratch\" is not supported on Windows`)\n\t\t}\n\t\tif opts.Platform != nil {\n\t\t\tif err := image.CheckOS(opts.Platform.OS); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\t\tlyr, err := newROLayerForImage(nil, i.layerStore)\n\t\treturn nil, lyr, err\n\t}\n\n\tif opts.PullOption != backend.PullOptionForcePull {\n\t\timg, err := i.GetImage(ctx, refOrID, backend.GetImageOpts{Platform: opts.Platform})\n\t\tif err != nil && opts.PullOption == backend.PullOptionNoPull {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif err != nil && !errdefs.IsNotFound(err) {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif img != nil {\n\t\t\tif err := image.CheckOS(img.OperatingSystem()); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tlyr, err := newROLayerForImage(img, i.layerStore)\n\t\t\treturn img, lyr, err\n\t\t}\n\t}\n\n\timg, err := i.pullForBuilder(ctx, refOrID, opts.AuthConfig, opts.Output, opts.Platform)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif err := image.CheckOS(img.OperatingSystem()); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlyr, err := newROLayerForImage(img, i.layerStore)\n\treturn img, lyr, err\n}\n\n// CreateImage creates a new image by adding a config and ID to the image store.\n// This is similar to LoadImage() except that it receives JSON encoded bytes of\n// an image instead of a tar archive.\nfunc (i *ImageService) CreateImage(ctx context.Context, config []byte, parent string, _ digest.Digest) (builder.Image, error) {\n\tid, err := i.imageStore.Create(config)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to create image\")\n\t}\n\n\tif parent != \"\" {\n\t\tif err := i.imageStore.SetParent(id, image.ID(parent)); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"failed to set parent %s\", parent)\n\t\t}\n\t}\n\n\treturn i.imageStore.Get(id)\n}\n", "package images // import \"github.com/docker/docker/daemon/images\"\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/docker/docker/pkg/ioutils\"\n\t\"github.com/pkg/errors\"\n)\n\n// CommitImage creates a new image from a commit config\nfunc (i *ImageService) CommitImage(ctx context.Context, c backend.CommitConfig) (image.ID, error) {\n\tif err := ctx.Err(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\trwTar, err := exportContainerRw(i.layerStore, c.ContainerID, c.ContainerMountLabel)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() {\n\t\tif rwTar != nil {\n\t\t\trwTar.Close()\n\t\t}\n\t}()\n\n\tvar parent *image.Image\n\tif c.ParentImageID == \"\" {\n\t\tparent = new(image.Image)\n\t\tparent.RootFS = image.NewRootFS()\n\t} else {\n\t\tparent, err = i.imageStore.Get(image.ID(c.ParentImageID))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tl, err := i.layerStore.Register(rwTar, parent.RootFS.ChainID())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer layer.ReleaseAndLog(i.layerStore, l)\n\n\tcc := image.ChildConfig{\n\t\tContainerID:     c.ContainerID,\n\t\tAuthor:          c.Author,\n\t\tComment:         c.Comment,\n\t\tContainerConfig: c.ContainerConfig,\n\t\tConfig:          c.Config,\n\t\tDiffID:          l.DiffID(),\n\t}\n\tconfig, err := json.Marshal(image.NewChildImage(parent, cc, c.ContainerOS))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tid, err := i.imageStore.Create(config)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif c.ParentImageID != \"\" {\n\t\tif err := i.imageStore.SetParent(id, image.ID(c.ParentImageID)); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn id, nil\n}\n\nfunc exportContainerRw(layerStore layer.Store, id, mountLabel string) (arch io.ReadCloser, err error) {\n\trwlayer, err := layerStore.GetRWLayer(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tlayerStore.ReleaseRWLayer(rwlayer)\n\t\t}\n\t}()\n\n\t// TODO: this mount call is not necessary as we assume that TarStream() should\n\t// mount the layer if needed. But the Diff() function for windows requests that\n\t// the layer should be mounted when calling it. So we reserve this mount call\n\t// until windows driver can implement Diff() interface correctly.\n\t_, err = rwlayer.Mount(mountLabel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tarchive, err := rwlayer.TarStream()\n\tif err != nil {\n\t\trwlayer.Unmount()\n\t\treturn nil, err\n\t}\n\treturn ioutils.NewReadCloserWrapper(archive, func() error {\n\t\t\tarchive.Close()\n\t\t\terr = rwlayer.Unmount()\n\t\t\tlayerStore.ReleaseRWLayer(rwlayer)\n\t\t\treturn err\n\t\t}),\n\t\tnil\n}\n\n// CommitBuildStep is used by the builder to create an image for each step in\n// the build.\n//\n// This method is different from CreateImageFromContainer:\n//   - it doesn't attempt to validate container state\n//   - it doesn't send a commit action to metrics\n//   - it doesn't log a container commit event\n//\n// This is a temporary shim. Should be removed when builder stops using commit.\nfunc (i *ImageService) CommitBuildStep(ctx context.Context, c backend.CommitConfig) (image.ID, error) {\n\tctr := i.containers.Get(c.ContainerID)\n\tif ctr == nil {\n\t\t// TODO: use typed error\n\t\treturn \"\", errors.Errorf(\"container not found: %s\", c.ContainerID)\n\t}\n\tc.ContainerMountLabel = ctr.MountLabel\n\tc.ContainerOS = ctr.OS\n\tc.ParentImageID = string(ctr.ImageID)\n\treturn i.CommitImage(ctx, c)\n}\n", "package cache // import \"github.com/docker/docker/image/cache\"\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\tcontainertypes \"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/dockerversion\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/pkg/errors\"\n)\n\n// NewLocal returns a local image cache, based on parent chain\nfunc NewLocal(store image.Store) *LocalImageCache {\n\treturn &LocalImageCache{\n\t\tstore: store,\n\t}\n}\n\n// LocalImageCache is cache based on parent chain.\ntype LocalImageCache struct {\n\tstore image.Store\n}\n\n// GetCache returns the image id found in the cache\nfunc (lic *LocalImageCache) GetCache(imgID string, config *containertypes.Config) (string, error) {\n\treturn getImageIDAndError(getLocalCachedImage(lic.store, image.ID(imgID), config))\n}\n\n// New returns an image cache, based on history objects\nfunc New(store image.Store) *ImageCache {\n\treturn &ImageCache{\n\t\tstore:           store,\n\t\tlocalImageCache: NewLocal(store),\n\t}\n}\n\n// ImageCache is cache based on history objects. Requires initial set of images.\ntype ImageCache struct {\n\tsources         []*image.Image\n\tstore           image.Store\n\tlocalImageCache *LocalImageCache\n}\n\n// Populate adds an image to the cache (to be queried later)\nfunc (ic *ImageCache) Populate(image *image.Image) {\n\tic.sources = append(ic.sources, image)\n}\n\n// GetCache returns the image id found in the cache\nfunc (ic *ImageCache) GetCache(parentID string, cfg *containertypes.Config) (string, error) {\n\timgID, err := ic.localImageCache.GetCache(parentID, cfg)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif imgID != \"\" {\n\t\tfor _, s := range ic.sources {\n\t\t\tif ic.isParent(s.ID(), image.ID(imgID)) {\n\t\t\t\treturn imgID, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tvar parent *image.Image\n\tlenHistory := 0\n\tif parentID != \"\" {\n\t\tparent, err = ic.store.Get(image.ID(parentID))\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"unable to find image %v\", parentID)\n\t\t}\n\t\tlenHistory = len(parent.History)\n\t}\n\n\tfor _, target := range ic.sources {\n\t\tif !isValidParent(target, parent) || !isValidConfig(cfg, target.History[lenHistory]) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(target.History)-1 == lenHistory { // last\n\t\t\tif parent != nil {\n\t\t\t\tif err := ic.store.SetParent(target.ID(), parent.ID()); err != nil {\n\t\t\t\t\treturn \"\", errors.Wrapf(err, \"failed to set parent for %v to %v\", target.ID(), parent.ID())\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target.ID().String(), nil\n\t\t}\n\n\t\timgID, err := ic.restoreCachedImage(parent, target, cfg)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"failed to restore cached image from %q to %v\", parentID, target.ID())\n\t\t}\n\n\t\tic.sources = []*image.Image{target} // avoid jumping to different target, tuned for safety atm\n\t\treturn imgID.String(), nil\n\t}\n\n\treturn \"\", nil\n}\n\nfunc (ic *ImageCache) restoreCachedImage(parent, target *image.Image, cfg *containertypes.Config) (image.ID, error) {\n\tvar history []image.History\n\trootFS := image.NewRootFS()\n\tlenHistory := 0\n\tif parent != nil {\n\t\thistory = parent.History\n\t\trootFS = parent.RootFS\n\t\tlenHistory = len(parent.History)\n\t}\n\thistory = append(history, target.History[lenHistory])\n\tif layer := getLayerForHistoryIndex(target, lenHistory); layer != \"\" {\n\t\trootFS.Append(layer)\n\t}\n\n\tconfig, err := json.Marshal(&image.Image{\n\t\tV1Image: image.V1Image{\n\t\t\tDockerVersion: dockerversion.Version,\n\t\t\tConfig:        cfg,\n\t\t\tArchitecture:  target.Architecture,\n\t\t\tOS:            target.OS,\n\t\t\tAuthor:        target.Author,\n\t\t\tCreated:       history[len(history)-1].Created,\n\t\t},\n\t\tRootFS:     rootFS,\n\t\tHistory:    history,\n\t\tOSFeatures: target.OSFeatures,\n\t\tOSVersion:  target.OSVersion,\n\t})\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"failed to marshal image config\")\n\t}\n\n\timgID, err := ic.store.Create(config)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"failed to create cache image\")\n\t}\n\n\tif parent != nil {\n\t\tif err := ic.store.SetParent(imgID, parent.ID()); err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"failed to set parent for %v to %v\", target.ID(), parent.ID())\n\t\t}\n\t}\n\treturn imgID, nil\n}\n\nfunc (ic *ImageCache) isParent(imgID, parentID image.ID) bool {\n\tnextParent, err := ic.store.GetParent(imgID)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif nextParent == parentID {\n\t\treturn true\n\t}\n\treturn ic.isParent(nextParent, parentID)\n}\n\nfunc getLayerForHistoryIndex(image *image.Image, index int) layer.DiffID {\n\tlayerIndex := 0\n\tfor i, h := range image.History {\n\t\tif i == index {\n\t\t\tif h.EmptyLayer {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif !h.EmptyLayer {\n\t\t\tlayerIndex++\n\t\t}\n\t}\n\treturn image.RootFS.DiffIDs[layerIndex] // validate?\n}\n\nfunc isValidConfig(cfg *containertypes.Config, h image.History) bool {\n\t// todo: make this format better than join that loses data\n\treturn strings.Join(cfg.Cmd, \" \") == h.CreatedBy\n}\n\nfunc isValidParent(img, parent *image.Image) bool {\n\tif len(img.History) == 0 {\n\t\treturn false\n\t}\n\tif parent == nil || len(parent.History) == 0 && len(parent.RootFS.DiffIDs) == 0 {\n\t\treturn true\n\t}\n\tif len(parent.History) >= len(img.History) {\n\t\treturn false\n\t}\n\tif len(parent.RootFS.DiffIDs) > len(img.RootFS.DiffIDs) {\n\t\treturn false\n\t}\n\n\tfor i, h := range parent.History {\n\t\tif !reflect.DeepEqual(h, img.History[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, d := range parent.RootFS.DiffIDs {\n\t\tif d != img.RootFS.DiffIDs[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc getImageIDAndError(img *image.Image, err error) (string, error) {\n\tif img == nil || err != nil {\n\t\treturn \"\", err\n\t}\n\treturn img.ID().String(), nil\n}\n\n// getLocalCachedImage returns the most recent created image that is a child\n// of the image with imgID, that had the same config when it was\n// created. nil is returned if a child cannot be found. An error is\n// returned if the parent image cannot be found.\nfunc getLocalCachedImage(imageStore image.Store, imgID image.ID, config *containertypes.Config) (*image.Image, error) {\n\t// Loop on the children of the given image and check the config\n\tgetMatch := func(siblings []image.ID) (*image.Image, error) {\n\t\tvar match *image.Image\n\t\tfor _, id := range siblings {\n\t\t\timg, err := imageStore.Get(id)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to find image %q\", id)\n\t\t\t}\n\n\t\t\tif compare(&img.ContainerConfig, config) {\n\t\t\t\t// check for the most up to date match\n\t\t\t\tif img.Created != nil && (match == nil || match.Created.Before(*img.Created)) {\n\t\t\t\t\tmatch = img\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match, nil\n\t}\n\n\t// In this case, this is `FROM scratch`, which isn't an actual image.\n\tif imgID == \"\" {\n\t\timages := imageStore.Map()\n\t\tvar siblings []image.ID\n\t\tfor id, img := range images {\n\t\t\tif img.Parent == imgID {\n\t\t\t\tsiblings = append(siblings, id)\n\t\t\t}\n\t\t}\n\t\treturn getMatch(siblings)\n\t}\n\n\t// find match from child images\n\tsiblings := imageStore.Children(imgID)\n\treturn getMatch(siblings)\n}\n", "package cache // import \"github.com/docker/docker/image/cache\"\n\nimport (\n\t\"github.com/docker/docker/api/types/container\"\n)\n\n// compare two Config struct. Do not compare the \"Image\" nor \"Hostname\" fields\n// If OpenStdin is set, then it differs\nfunc compare(a, b *container.Config) bool {\n\tif a == nil || b == nil ||\n\t\ta.OpenStdin || b.OpenStdin {\n\t\treturn false\n\t}\n\tif a.AttachStdout != b.AttachStdout ||\n\t\ta.AttachStderr != b.AttachStderr ||\n\t\ta.User != b.User ||\n\t\ta.OpenStdin != b.OpenStdin ||\n\t\ta.Tty != b.Tty {\n\t\treturn false\n\t}\n\n\tif len(a.Cmd) != len(b.Cmd) ||\n\t\tlen(a.Env) != len(b.Env) ||\n\t\tlen(a.Labels) != len(b.Labels) ||\n\t\tlen(a.ExposedPorts) != len(b.ExposedPorts) ||\n\t\tlen(a.Entrypoint) != len(b.Entrypoint) ||\n\t\tlen(a.Volumes) != len(b.Volumes) {\n\t\treturn false\n\t}\n\n\tfor i := 0; i < len(a.Cmd); i++ {\n\t\tif a.Cmd[i] != b.Cmd[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := 0; i < len(a.Env); i++ {\n\t\tif a.Env[i] != b.Env[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor k, v := range a.Labels {\n\t\tif v != b.Labels[k] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor k := range a.ExposedPorts {\n\t\tif _, exists := b.ExposedPorts[k]; !exists {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor i := 0; i < len(a.Entrypoint); i++ {\n\t\tif a.Entrypoint[i] != b.Entrypoint[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor key := range a.Volumes {\n\t\tif _, exists := b.Volumes[key]; !exists {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "package image // import \"github.com/docker/docker/image\"\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/go-digest/digestset\"\n\t\"github.com/pkg/errors\"\n)\n\n// Store is an interface for creating and accessing images\ntype Store interface {\n\tCreate(config []byte) (ID, error)\n\tGet(id ID) (*Image, error)\n\tDelete(id ID) ([]layer.Metadata, error)\n\tSearch(partialID string) (ID, error)\n\tSetParent(id ID, parent ID) error\n\tGetParent(id ID) (ID, error)\n\tSetLastUpdated(id ID) error\n\tGetLastUpdated(id ID) (time.Time, error)\n\tChildren(id ID) []ID\n\tMap() map[ID]*Image\n\tHeads() map[ID]*Image\n\tLen() int\n}\n\n// LayerGetReleaser is a minimal interface for getting and releasing images.\ntype LayerGetReleaser interface {\n\tGet(layer.ChainID) (layer.Layer, error)\n\tRelease(layer.Layer) ([]layer.Metadata, error)\n}\n\ntype imageMeta struct {\n\tlayer    layer.Layer\n\tchildren map[ID]struct{}\n}\n\ntype store struct {\n\tsync.RWMutex\n\tlss       LayerGetReleaser\n\timages    map[ID]*imageMeta\n\tfs        StoreBackend\n\tdigestSet *digestset.Set\n}\n\n// NewImageStore returns new store object for given set of layer stores\nfunc NewImageStore(fs StoreBackend, lss LayerGetReleaser) (Store, error) {\n\tis := &store{\n\t\tlss:       lss,\n\t\timages:    make(map[ID]*imageMeta),\n\t\tfs:        fs,\n\t\tdigestSet: digestset.NewSet(),\n\t}\n\n\t// load all current images and retain layers\n\tif err := is.restore(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn is, nil\n}\n\nfunc (is *store) restore() error {\n\t// As the code below is run when restoring all images (which can be \"many\"),\n\t// constructing the \"log.G(ctx).WithFields\" is deliberately not \"DRY\", as the\n\t// logger is only used for error-cases, and we don't want to do allocations\n\t// if we don't need it. The \"f\" type alias is here is just for convenience,\n\t// and to make the code _slightly_ more DRY. See the discussion on GitHub;\n\t// https://github.com/moby/moby/pull/44426#discussion_r1059519071\n\ttype f = log.Fields\n\terr := is.fs.Walk(func(dgst digest.Digest) error {\n\t\timg, err := is.Get(ID(dgst))\n\t\tif err != nil {\n\t\t\tlog.G(context.TODO()).WithFields(f{\"digest\": dgst, \"err\": err}).Error(\"invalid image\")\n\t\t\treturn nil\n\t\t}\n\t\tvar l layer.Layer\n\t\tif chainID := img.RootFS.ChainID(); chainID != \"\" {\n\t\t\tif err := CheckOS(img.OperatingSystem()); err != nil {\n\t\t\t\tlog.G(context.TODO()).WithFields(f{\"chainID\": chainID, \"os\": img.OperatingSystem()}).Error(\"not restoring image with unsupported operating system\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tl, err = is.lss.Get(chainID)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, layer.ErrLayerDoesNotExist) {\n\t\t\t\t\tlog.G(context.TODO()).WithFields(f{\"chainID\": chainID, \"os\": img.OperatingSystem(), \"err\": err}).Error(\"not restoring image\")\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := is.digestSet.Add(dgst); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tis.images[ID(dgst)] = &imageMeta{\n\t\t\tlayer:    l,\n\t\t\tchildren: make(map[ID]struct{}),\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Second pass to fill in children maps\n\tfor id := range is.images {\n\t\tif parent, err := is.GetParent(id); err == nil {\n\t\t\tif parentMeta := is.images[parent]; parentMeta != nil {\n\t\t\t\tparentMeta.children[id] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (is *store) Create(config []byte) (ID, error) {\n\tvar img *Image\n\timg, err := NewFromJSON(config)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Must reject any config that references diffIDs from the history\n\t// which aren't among the rootfs layers.\n\trootFSLayers := make(map[layer.DiffID]struct{})\n\tfor _, diffID := range img.RootFS.DiffIDs {\n\t\trootFSLayers[diffID] = struct{}{}\n\t}\n\n\tlayerCounter := 0\n\tfor _, h := range img.History {\n\t\tif !h.EmptyLayer {\n\t\t\tlayerCounter++\n\t\t}\n\t}\n\tif layerCounter > len(img.RootFS.DiffIDs) {\n\t\treturn \"\", errdefs.InvalidParameter(errors.New(\"too many non-empty layers in History section\"))\n\t}\n\n\timageDigest, err := is.fs.Set(config)\n\tif err != nil {\n\t\treturn \"\", errdefs.InvalidParameter(err)\n\t}\n\n\tis.Lock()\n\tdefer is.Unlock()\n\n\timageID := ID(imageDigest)\n\tif _, exists := is.images[imageID]; exists {\n\t\treturn imageID, nil\n\t}\n\n\tlayerID := img.RootFS.ChainID()\n\n\tvar l layer.Layer\n\tif layerID != \"\" {\n\t\tif err := CheckOS(img.OperatingSystem()); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tl, err = is.lss.Get(layerID)\n\t\tif err != nil {\n\t\t\treturn \"\", errdefs.InvalidParameter(errors.Wrapf(err, \"failed to get layer %s\", layerID))\n\t\t}\n\t}\n\n\tis.images[imageID] = &imageMeta{\n\t\tlayer:    l,\n\t\tchildren: make(map[ID]struct{}),\n\t}\n\n\tif err = is.digestSet.Add(imageDigest); err != nil {\n\t\tdelete(is.images, imageID)\n\t\treturn \"\", errdefs.InvalidParameter(err)\n\t}\n\n\treturn imageID, nil\n}\n\ntype imageNotFoundError string\n\nfunc (e imageNotFoundError) Error() string {\n\treturn \"No such image: \" + string(e)\n}\n\nfunc (imageNotFoundError) NotFound() {}\n\nfunc (is *store) Search(term string) (ID, error) {\n\tdgst, err := is.digestSet.Lookup(term)\n\tif err != nil {\n\t\tif err == digestset.ErrDigestNotFound {\n\t\t\terr = imageNotFoundError(term)\n\t\t}\n\t\treturn \"\", errors.WithStack(err)\n\t}\n\treturn ID(dgst), nil\n}\n\nfunc (is *store) Get(id ID) (*Image, error) {\n\t// todo: Check if image is in images\n\t// todo: Detect manual insertions and start using them\n\tconfig, err := is.fs.Get(id.Digest())\n\tif err != nil {\n\t\treturn nil, errdefs.NotFound(err)\n\t}\n\n\timg, err := NewFromJSON(config)\n\tif err != nil {\n\t\treturn nil, errdefs.InvalidParameter(err)\n\t}\n\timg.computedID = id\n\n\timg.Parent, err = is.GetParent(id)\n\tif err != nil {\n\t\timg.Parent = \"\"\n\t}\n\n\treturn img, nil\n}\n\nfunc (is *store) Delete(id ID) ([]layer.Metadata, error) {\n\tis.Lock()\n\tdefer is.Unlock()\n\n\timgMeta := is.images[id]\n\tif imgMeta == nil {\n\t\treturn nil, errdefs.NotFound(fmt.Errorf(\"unrecognized image ID %s\", id.String()))\n\t}\n\t_, err := is.Get(id)\n\tif err != nil {\n\t\treturn nil, errdefs.NotFound(fmt.Errorf(\"unrecognized image %s, %v\", id.String(), err))\n\t}\n\tfor cID := range imgMeta.children {\n\t\tis.fs.DeleteMetadata(cID.Digest(), \"parent\")\n\t}\n\tif parent, err := is.GetParent(id); err == nil && is.images[parent] != nil {\n\t\tdelete(is.images[parent].children, id)\n\t}\n\n\tif err := is.digestSet.Remove(id.Digest()); err != nil {\n\t\tlog.G(context.TODO()).Errorf(\"error removing %s from digest set: %q\", id, err)\n\t}\n\tdelete(is.images, id)\n\tis.fs.Delete(id.Digest())\n\n\tif imgMeta.layer != nil {\n\t\treturn is.lss.Release(imgMeta.layer)\n\t}\n\treturn nil, nil\n}\n\nfunc (is *store) SetParent(id, parentID ID) error {\n\tis.Lock()\n\tdefer is.Unlock()\n\tparentMeta := is.images[parentID]\n\tif parentMeta == nil {\n\t\treturn errdefs.NotFound(fmt.Errorf(\"unknown parent image ID %s\", parentID.String()))\n\t}\n\tif parent, err := is.GetParent(id); err == nil && is.images[parent] != nil {\n\t\tdelete(is.images[parent].children, id)\n\t}\n\tparentMeta.children[id] = struct{}{}\n\treturn is.fs.SetMetadata(id.Digest(), \"parent\", []byte(parentID))\n}\n\nfunc (is *store) GetParent(id ID) (ID, error) {\n\td, err := is.fs.GetMetadata(id.Digest(), \"parent\")\n\tif err != nil {\n\t\treturn \"\", errdefs.NotFound(err)\n\t}\n\treturn ID(d), nil // todo: validate?\n}\n\n// SetLastUpdated time for the image ID to the current time\nfunc (is *store) SetLastUpdated(id ID) error {\n\tlastUpdated := []byte(time.Now().Format(time.RFC3339Nano))\n\treturn is.fs.SetMetadata(id.Digest(), \"lastUpdated\", lastUpdated)\n}\n\n// GetLastUpdated time for the image ID\nfunc (is *store) GetLastUpdated(id ID) (time.Time, error) {\n\tbytes, err := is.fs.GetMetadata(id.Digest(), \"lastUpdated\")\n\tif err != nil || len(bytes) == 0 {\n\t\t// No lastUpdated time\n\t\treturn time.Time{}, nil\n\t}\n\treturn time.Parse(time.RFC3339Nano, string(bytes))\n}\n\nfunc (is *store) Children(id ID) []ID {\n\tis.RLock()\n\tdefer is.RUnlock()\n\n\treturn is.children(id)\n}\n\nfunc (is *store) children(id ID) []ID {\n\tvar ids []ID\n\tif is.images[id] != nil {\n\t\tfor id := range is.images[id].children {\n\t\t\tids = append(ids, id)\n\t\t}\n\t}\n\treturn ids\n}\n\nfunc (is *store) Heads() map[ID]*Image {\n\treturn is.imagesMap(false)\n}\n\nfunc (is *store) Map() map[ID]*Image {\n\treturn is.imagesMap(true)\n}\n\nfunc (is *store) imagesMap(all bool) map[ID]*Image {\n\tis.RLock()\n\tdefer is.RUnlock()\n\n\timages := make(map[ID]*Image)\n\n\tfor id := range is.images {\n\t\tif !all && len(is.children(id)) > 0 {\n\t\t\tcontinue\n\t\t}\n\t\timg, err := is.Get(id)\n\t\tif err != nil {\n\t\t\tlog.G(context.TODO()).Errorf(\"invalid image access: %q, error: %q\", id, err)\n\t\t\tcontinue\n\t\t}\n\t\timages[id] = img\n\t}\n\treturn images\n}\n\nfunc (is *store) Len() int {\n\tis.RLock()\n\tdefer is.RUnlock()\n\treturn len(is.images)\n}\n"], "fixing_code": ["// Package builder defines interfaces for any Docker builder to implement.\n//\n// Historically, only server-side Dockerfile interpreters existed.\n// This package allows for other implementations of Docker builders.\npackage builder // import \"github.com/docker/docker/builder\"\n\nimport (\n\t\"context\"\n\t\"io\"\n\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\tcontainerpkg \"github.com/docker/docker/container\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\nconst (\n\t// DefaultDockerfileName is the Default filename with Docker commands, read by docker build\n\tDefaultDockerfileName = \"Dockerfile\"\n)\n\n// Source defines a location that can be used as a source for the ADD/COPY\n// instructions in the builder.\ntype Source interface {\n\t// Root returns root path for accessing source\n\tRoot() string\n\t// Close allows to signal that the filesystem tree won't be used anymore.\n\t// For Context implementations using a temporary directory, it is recommended to\n\t// delete the temporary directory in Close().\n\tClose() error\n\t// Hash returns a checksum for a file\n\tHash(path string) (string, error)\n}\n\n// Backend abstracts calls to a Docker Daemon.\ntype Backend interface {\n\tImageBackend\n\tExecBackend\n\n\t// CommitBuildStep creates a new Docker image from the config generated by\n\t// a build step.\n\tCommitBuildStep(context.Context, backend.CommitConfig) (image.ID, error)\n\t// ContainerCreateWorkdir creates the workdir\n\tContainerCreateWorkdir(containerID string) error\n\tCreateImage(ctx context.Context, config []byte, parent string, contentStoreDigest digest.Digest) (Image, error)\n\n\tImageCacheBuilder\n}\n\n// ImageBackend are the interface methods required from an image component\ntype ImageBackend interface {\n\tGetImageAndReleasableLayer(ctx context.Context, refOrID string, opts backend.GetImageAndLayerOptions) (Image, ROLayer, error)\n}\n\n// ExecBackend contains the interface methods required for executing containers\ntype ExecBackend interface {\n\t// ContainerAttachRaw attaches to container.\n\tContainerAttachRaw(cID string, stdin io.ReadCloser, stdout, stderr io.Writer, stream bool, attached chan struct{}) error\n\t// ContainerCreateIgnoreImagesArgsEscaped creates a new Docker container and returns potential warnings\n\tContainerCreateIgnoreImagesArgsEscaped(ctx context.Context, config backend.ContainerCreateConfig) (container.CreateResponse, error)\n\t// ContainerRm removes a container specified by `id`.\n\tContainerRm(name string, config *backend.ContainerRmConfig) error\n\t// ContainerStart starts a new container\n\tContainerStart(ctx context.Context, containerID string, hostConfig *container.HostConfig, checkpoint string, checkpointDir string) error\n\t// ContainerWait stops processing until the given container is stopped.\n\tContainerWait(ctx context.Context, name string, condition containerpkg.WaitCondition) (<-chan containerpkg.StateStatus, error)\n}\n\n// Result is the output produced by a Builder\ntype Result struct {\n\tImageID   string\n\tFromImage Image\n}\n\n// ImageCacheBuilder represents a generator for stateful image cache.\ntype ImageCacheBuilder interface {\n\t// MakeImageCache creates a stateful image cache.\n\tMakeImageCache(ctx context.Context, cacheFrom []string) (ImageCache, error)\n}\n\n// ImageCache abstracts an image cache.\n// (parent image, child runconfig) -> child image\ntype ImageCache interface {\n\t// GetCache returns a reference to a cached image whose parent equals `parent`\n\t// and runconfig equals `cfg`. A cache miss is expected to return an empty ID and a nil error.\n\tGetCache(parentID string, cfg *container.Config, platform ocispec.Platform) (imageID string, err error)\n}\n\n// Image represents a Docker image used by the builder.\ntype Image interface {\n\tImageID() string\n\tRunConfig() *container.Config\n\tMarshalJSON() ([]byte, error)\n\tOperatingSystem() string\n}\n\n// ROLayer is a reference to image rootfs layer\ntype ROLayer interface {\n\tRelease() error\n\tNewRWLayer() (RWLayer, error)\n\tDiffID() layer.DiffID\n\tContentStoreDigest() digest.Digest\n}\n\n// RWLayer is active layer that can be read/modified\ntype RWLayer interface {\n\tRelease() error\n\tRoot() string\n\tCommit() (ROLayer, error)\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/builder/remotecontext\"\n\t\"github.com/docker/docker/builder/remotecontext/urlutil\"\n\t\"github.com/docker/docker/pkg/archive\"\n\t\"github.com/docker/docker/pkg/idtools\"\n\t\"github.com/docker/docker/pkg/longpath\"\n\t\"github.com/docker/docker/pkg/progress\"\n\t\"github.com/docker/docker/pkg/streamformatter\"\n\t\"github.com/docker/docker/pkg/system\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/instructions\"\n\t\"github.com/moby/sys/symlink\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\nconst unnamedFilename = \"__unnamed__\"\n\ntype pathCache interface {\n\tLoad(key interface{}) (value interface{}, ok bool)\n\tStore(key, value interface{})\n}\n\n// copyInfo is a data object which stores the metadata about each source file in\n// a copyInstruction\ntype copyInfo struct {\n\troot         string\n\tpath         string\n\thash         string\n\tnoDecompress bool\n}\n\nfunc (c copyInfo) fullPath() (string, error) {\n\treturn symlink.FollowSymlinkInScope(filepath.Join(c.root, c.path), c.root)\n}\n\nfunc newCopyInfoFromSource(source builder.Source, path string, hash string) copyInfo {\n\treturn copyInfo{root: source.Root(), path: path, hash: hash}\n}\n\nfunc newCopyInfos(copyInfos ...copyInfo) []copyInfo {\n\treturn copyInfos\n}\n\n// copyInstruction is a fully parsed COPY or ADD command that is passed to\n// Builder.performCopy to copy files into the image filesystem\ntype copyInstruction struct {\n\tcmdName                 string\n\tinfos                   []copyInfo\n\tdest                    string\n\tchownStr                string\n\tallowLocalDecompression bool\n\tpreserveOwnership       bool\n}\n\n// copier reads a raw COPY or ADD command, fetches remote sources using a downloader,\n// and creates a copyInstruction\ntype copier struct {\n\timageSource *imageMount\n\tsource      builder.Source\n\tpathCache   pathCache\n\tdownload    sourceDownloader\n\tplatform    ocispec.Platform\n\t// for cleanup. TODO: having copier.cleanup() is error prone and hard to\n\t// follow. Code calling performCopy should manage the lifecycle of its params.\n\t// Copier should take override source as input, not imageMount.\n\tactiveLayer builder.RWLayer\n\ttmpPaths    []string\n}\n\nfunc copierFromDispatchRequest(req dispatchRequest, download sourceDownloader, imageSource *imageMount) copier {\n\tplatform := req.builder.getPlatform(req.state)\n\n\treturn copier{\n\t\tsource:      req.source,\n\t\tpathCache:   req.builder.pathCache,\n\t\tdownload:    download,\n\t\timageSource: imageSource,\n\t\tplatform:    platform,\n\t}\n}\n\nfunc (o *copier) createCopyInstruction(sourcesAndDest instructions.SourcesAndDest, cmdName string) (copyInstruction, error) {\n\tinst := copyInstruction{\n\t\tcmdName: cmdName,\n\t\tdest:    filepath.FromSlash(sourcesAndDest.DestPath),\n\t}\n\tinfos, err := o.getCopyInfosForSourcePaths(sourcesAndDest.SourcePaths, inst.dest)\n\tif err != nil {\n\t\treturn inst, errors.Wrapf(err, \"%s failed\", cmdName)\n\t}\n\tif len(infos) > 1 && !strings.HasSuffix(inst.dest, string(os.PathSeparator)) {\n\t\treturn inst, errors.Errorf(\"When using %s with more than one source file, the destination must be a directory and end with a /\", cmdName)\n\t}\n\tinst.infos = infos\n\treturn inst, nil\n}\n\n// getCopyInfosForSourcePaths iterates over the source files and calculate the info\n// needed to copy (e.g. hash value if cached)\n// The dest is used in case source is URL (and ends with \"/\")\nfunc (o *copier) getCopyInfosForSourcePaths(sources []string, dest string) ([]copyInfo, error) {\n\tvar infos []copyInfo\n\tfor _, orig := range sources {\n\t\tsubinfos, err := o.getCopyInfoForSourcePath(orig, dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tinfos = append(infos, subinfos...)\n\t}\n\n\tif len(infos) == 0 {\n\t\treturn nil, errors.New(\"no source files were specified\")\n\t}\n\treturn infos, nil\n}\n\nfunc (o *copier) getCopyInfoForSourcePath(orig, dest string) ([]copyInfo, error) {\n\tif !urlutil.IsURL(orig) {\n\t\treturn o.calcCopyInfo(orig, true)\n\t}\n\n\tremote, path, err := o.download(orig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// If path == \"\" then we are unable to determine filename from src\n\t// We have to make sure dest is available\n\tif path == \"\" {\n\t\tif strings.HasSuffix(dest, \"/\") {\n\t\t\treturn nil, errors.Errorf(\"cannot determine filename for source %s\", orig)\n\t\t}\n\t\tpath = unnamedFilename\n\t}\n\to.tmpPaths = append(o.tmpPaths, remote.Root())\n\n\thash, err := remote.Hash(path)\n\tci := newCopyInfoFromSource(remote, path, hash)\n\tci.noDecompress = true // data from http shouldn't be extracted even on ADD\n\treturn newCopyInfos(ci), err\n}\n\n// Cleanup removes any temporary directories created as part of downloading\n// remote files.\nfunc (o *copier) Cleanup() {\n\tfor _, path := range o.tmpPaths {\n\t\tos.RemoveAll(path)\n\t}\n\to.tmpPaths = []string{}\n\tif o.activeLayer != nil {\n\t\to.activeLayer.Release()\n\t\to.activeLayer = nil\n\t}\n}\n\n// TODO: allowWildcards can probably be removed by refactoring this function further.\nfunc (o *copier) calcCopyInfo(origPath string, allowWildcards bool) ([]copyInfo, error) {\n\timageSource := o.imageSource\n\tif err := validateCopySourcePath(imageSource, origPath); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// TODO: do this when creating copier. Requires validateCopySourcePath\n\t// (and other below) to be aware of the difference sources. Why is it only\n\t// done on image Source?\n\tif imageSource != nil && o.activeLayer == nil {\n\t\t// this needs to be protected against repeated calls as wildcard copy\n\t\t// will call it multiple times for a single COPY\n\t\tvar err error\n\t\trwLayer, err := imageSource.NewRWLayer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\to.activeLayer = rwLayer\n\n\t\to.source, err = remotecontext.NewLazySource(rwLayer.Root())\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"failed to create context for copy from %s\", rwLayer.Root())\n\t\t}\n\t}\n\n\tif o.source == nil {\n\t\treturn nil, errors.Errorf(\"missing build context\")\n\t}\n\n\t// Work in daemon-specific OS filepath semantics\n\torigPath = filepath.FromSlash(origPath)\n\torigPath = strings.TrimPrefix(origPath, string(os.PathSeparator))\n\torigPath = strings.TrimPrefix(origPath, \".\"+string(os.PathSeparator))\n\n\t// Deal with wildcards\n\tif allowWildcards && containsWildcards(origPath) {\n\t\treturn o.copyWithWildcards(origPath)\n\t}\n\n\tif imageSource != nil && imageSource.ImageID() != \"\" {\n\t\t// return a cached copy if one exists\n\t\tif h, ok := o.pathCache.Load(imageSource.ImageID() + origPath); ok {\n\t\t\treturn newCopyInfos(newCopyInfoFromSource(o.source, origPath, h.(string))), nil\n\t\t}\n\t}\n\n\t// Deal with the single file case\n\tcopyInfo, err := copyInfoForFile(o.source, origPath)\n\tswitch {\n\tcase imageSource == nil && errors.Is(err, os.ErrNotExist):\n\t\treturn nil, errors.Wrapf(err, \"file not found in build context or excluded by .dockerignore\")\n\tcase err != nil:\n\t\treturn nil, err\n\tcase copyInfo.hash != \"\":\n\t\to.storeInPathCache(imageSource, origPath, copyInfo.hash)\n\t\treturn newCopyInfos(copyInfo), err\n\t}\n\n\t// TODO: remove, handle dirs in Hash()\n\tsubfiles, err := walkSource(o.source, origPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thash := hashStringSlice(\"dir\", subfiles)\n\to.storeInPathCache(imageSource, origPath, hash)\n\treturn newCopyInfos(newCopyInfoFromSource(o.source, origPath, hash)), nil\n}\n\nfunc (o *copier) storeInPathCache(im *imageMount, path string, hash string) {\n\tif im != nil {\n\t\to.pathCache.Store(im.ImageID()+path, hash)\n\t}\n}\n\nfunc (o *copier) copyWithWildcards(origPath string) ([]copyInfo, error) {\n\troot := o.source.Root()\n\tvar copyInfos []copyInfo\n\tif err := filepath.WalkDir(root, func(path string, _ os.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trel, err := remotecontext.Rel(root, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif rel == \".\" {\n\t\t\treturn nil\n\t\t}\n\t\tif match, _ := filepath.Match(origPath, rel); !match {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Note we set allowWildcards to false in case the name has\n\t\t// a * in it\n\t\tsubInfos, err := o.calcCopyInfo(rel, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcopyInfos = append(copyInfos, subInfos...)\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\treturn copyInfos, nil\n}\n\nfunc copyInfoForFile(source builder.Source, path string) (copyInfo, error) {\n\tfi, err := remotecontext.StatAt(source, path)\n\tif err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t// return the relative path in the error, which is more user-friendly than the full path to the tmp-dir\n\t\t\treturn copyInfo{}, errors.WithStack(&os.PathError{Op: \"stat\", Path: path, Err: os.ErrNotExist})\n\t\t}\n\t\treturn copyInfo{}, err\n\t}\n\n\tif fi.IsDir() {\n\t\treturn copyInfo{}, nil\n\t}\n\thash, err := source.Hash(path)\n\tif err != nil {\n\t\treturn copyInfo{}, err\n\t}\n\treturn newCopyInfoFromSource(source, path, \"file:\"+hash), nil\n}\n\n// TODO: dedupe with copyWithWildcards()\nfunc walkSource(source builder.Source, origPath string) ([]string, error) {\n\tfp, err := remotecontext.FullPath(source, origPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Must be a dir\n\tvar subfiles []string\n\terr = filepath.WalkDir(fp, func(path string, _ os.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trel, err := remotecontext.Rel(source.Root(), path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rel == \".\" {\n\t\t\treturn nil\n\t\t}\n\t\thash, err := source.Hash(rel)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\t// we already checked handleHash above\n\t\tsubfiles = append(subfiles, hash)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsort.Strings(subfiles)\n\treturn subfiles, nil\n}\n\ntype sourceDownloader func(string) (builder.Source, string, error)\n\nfunc newRemoteSourceDownloader(output, stdout io.Writer) sourceDownloader {\n\treturn func(url string) (builder.Source, string, error) {\n\t\treturn downloadSource(output, stdout, url)\n\t}\n}\n\nfunc errOnSourceDownload(_ string) (builder.Source, string, error) {\n\treturn nil, \"\", errors.New(\"source can't be a URL for COPY\")\n}\n\nfunc getFilenameForDownload(path string, resp *http.Response) string {\n\t// Guess filename based on source\n\tif path != \"\" && !strings.HasSuffix(path, \"/\") {\n\t\tif filename := filepath.Base(filepath.FromSlash(path)); filename != \"\" {\n\t\t\treturn filename\n\t\t}\n\t}\n\n\t// Guess filename based on Content-Disposition\n\tif contentDisposition := resp.Header.Get(\"Content-Disposition\"); contentDisposition != \"\" {\n\t\tif _, params, err := mime.ParseMediaType(contentDisposition); err == nil {\n\t\t\tif params[\"filename\"] != \"\" && !strings.HasSuffix(params[\"filename\"], \"/\") {\n\t\t\t\tif filename := filepath.Base(filepath.FromSlash(params[\"filename\"])); filename != \"\" {\n\t\t\t\t\treturn filename\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc downloadSource(output io.Writer, stdout io.Writer, srcURL string) (remote builder.Source, p string, err error) {\n\tu, err := url.Parse(srcURL)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresp, err := remotecontext.GetWithStatusError(srcURL)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfilename := getFilenameForDownload(u.Path, resp)\n\n\t// Prepare file in a tmp dir\n\ttmpDir, err := longpath.MkdirTemp(\"\", \"docker-remote\")\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tos.RemoveAll(tmpDir)\n\t\t}\n\t}()\n\t// If filename is empty, the returned filename will be \"\" but\n\t// the tmp filename will be created as \"__unnamed__\"\n\ttmpFileName := filename\n\tif filename == \"\" {\n\t\ttmpFileName = unnamedFilename\n\t}\n\ttmpFileName = filepath.Join(tmpDir, tmpFileName)\n\ttmpFile, err := os.OpenFile(tmpFileName, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0o600)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tprogressOutput := streamformatter.NewJSONProgressOutput(output, true)\n\tprogressReader := progress.NewProgressReader(resp.Body, progressOutput, resp.ContentLength, \"\", \"Downloading\")\n\t// Download and dump result to tmp file\n\t// TODO: add filehash directly\n\tif _, err = io.Copy(tmpFile, progressReader); err != nil {\n\t\ttmpFile.Close()\n\t\treturn\n\t}\n\t// TODO: how important is this random blank line to the output?\n\tfmt.Fprintln(stdout)\n\n\t// Set the mtime to the Last-Modified header value if present\n\t// Otherwise just remove atime and mtime\n\tmTime := time.Time{}\n\n\tlastMod := resp.Header.Get(\"Last-Modified\")\n\tif lastMod != \"\" {\n\t\t// If we can't parse it then just let it default to 'zero'\n\t\t// otherwise use the parsed time value\n\t\tif parsedMTime, err := http.ParseTime(lastMod); err == nil {\n\t\t\tmTime = parsedMTime\n\t\t}\n\t}\n\n\ttmpFile.Close()\n\n\tif err = system.Chtimes(tmpFileName, mTime, mTime); err != nil {\n\t\treturn\n\t}\n\n\tlc, err := remotecontext.NewLazySource(tmpDir)\n\treturn lc, filename, err\n}\n\ntype copyFileOptions struct {\n\tdecompress bool\n\tidentity   *idtools.Identity\n\tarchiver   *archive.Archiver\n}\n\nfunc performCopyForInfo(dest copyInfo, source copyInfo, options copyFileOptions) error {\n\tsrcPath, err := source.fullPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdestPath, err := dest.fullPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tarchiver := options.archiver\n\n\tsrc, err := os.Stat(srcPath)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"source path not found\")\n\t}\n\tif src.IsDir() {\n\t\treturn copyDirectory(archiver, srcPath, destPath, options.identity)\n\t}\n\tif options.decompress && archive.IsArchivePath(srcPath) && !source.noDecompress {\n\t\treturn archiver.UntarPath(srcPath, destPath)\n\t}\n\n\tdestExistsAsDir, err := isExistingDirectory(destPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// dest.path must be used because destPath has already been cleaned of any\n\t// trailing slash\n\tif endsInSlash(dest.path) || destExistsAsDir {\n\t\t// source.path must be used to get the correct filename when the source\n\t\t// is a symlink\n\t\tdestPath = filepath.Join(destPath, filepath.Base(source.path))\n\t}\n\treturn copyFile(archiver, srcPath, destPath, options.identity)\n}\n\nfunc copyDirectory(archiver *archive.Archiver, source, dest string, identity *idtools.Identity) error {\n\tdestExists, err := isExistingDirectory(dest)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to query destination path\")\n\t}\n\n\tif err := archiver.CopyWithTar(source, dest); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to copy directory\")\n\t}\n\tif identity != nil {\n\t\treturn fixPermissions(source, dest, *identity, !destExists)\n\t}\n\treturn nil\n}\n\nfunc copyFile(archiver *archive.Archiver, source, dest string, identity *idtools.Identity) error {\n\tif identity == nil {\n\t\t// Use system.MkdirAll here, which is a custom version of os.MkdirAll\n\t\t// modified for use on Windows to handle volume GUID paths. These paths\n\t\t// are of the form \\\\?\\Volume{<GUID>}\\<path>. An example would be:\n\t\t// \\\\?\\Volume{dae8d3ac-b9a1-11e9-88eb-e8554b2ba1db}\\bin\\busybox.exe\n\t\tif err := system.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := idtools.MkdirAllAndChownNew(filepath.Dir(dest), 0o755, *identity); err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to create new directory\")\n\t\t}\n\t}\n\n\tif err := archiver.CopyFileWithTar(source, dest); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to copy file\")\n\t}\n\tif identity != nil {\n\t\treturn fixPermissions(source, dest, *identity, false)\n\t}\n\treturn nil\n}\n\nfunc endsInSlash(path string) bool {\n\treturn strings.HasSuffix(path, string(filepath.Separator))\n}\n\n// isExistingDirectory returns true if the path exists and is a directory\nfunc isExistingDirectory(path string) (bool, error) {\n\tdestStat, err := os.Stat(path)\n\tswitch {\n\tcase errors.Is(err, os.ErrNotExist):\n\t\treturn false, nil\n\tcase err != nil:\n\t\treturn false, err\n\t}\n\treturn destStat.IsDir(), nil\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\n// This file contains the dispatchers for each command. Note that\n// `nullDispatch` is not actually a command, but support for commands we parse\n// but do nothing with.\n//\n// See evaluator.go for a higher level discussion of the whole evaluator\n// package.\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/docker/docker/api\"\n\t\"github.com/docker/docker/api/types/strslice\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/pkg/jsonmessage\"\n\t\"github.com/docker/go-connections/nat\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/instructions\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/parser\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/shell\"\n\t\"github.com/moby/sys/signal\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\n// ENV foo bar\n//\n// Sets the environment variable foo to bar, also makes interpolation\n// in the dockerfile available from the next statement on via ${foo}.\nfunc dispatchEnv(ctx context.Context, d dispatchRequest, c *instructions.EnvCommand) error {\n\trunConfig := d.state.runConfig\n\tcommitMessage := bytes.NewBufferString(\"ENV\")\n\tfor _, e := range c.Env {\n\t\tname := e.Key\n\t\tnewVar := e.String()\n\n\t\tcommitMessage.WriteString(\" \" + newVar)\n\t\tgotOne := false\n\t\tfor i, envVar := range runConfig.Env {\n\t\t\tcompareFrom, _, _ := strings.Cut(envVar, \"=\")\n\t\t\tif shell.EqualEnvKeys(compareFrom, name) {\n\t\t\t\trunConfig.Env[i] = newVar\n\t\t\t\tgotOne = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !gotOne {\n\t\t\trunConfig.Env = append(runConfig.Env, newVar)\n\t\t}\n\t}\n\treturn d.builder.commit(ctx, d.state, commitMessage.String())\n}\n\n// MAINTAINER some text <maybe@an.email.address>\n//\n// Sets the maintainer metadata.\nfunc dispatchMaintainer(ctx context.Context, d dispatchRequest, c *instructions.MaintainerCommand) error {\n\td.state.maintainer = c.Maintainer\n\treturn d.builder.commit(ctx, d.state, \"MAINTAINER \"+c.Maintainer)\n}\n\n// LABEL some json data describing the image\n//\n// Sets the Label variable foo to bar,\nfunc dispatchLabel(ctx context.Context, d dispatchRequest, c *instructions.LabelCommand) error {\n\tif d.state.runConfig.Labels == nil {\n\t\td.state.runConfig.Labels = make(map[string]string)\n\t}\n\tcommitStr := \"LABEL\"\n\tfor _, v := range c.Labels {\n\t\td.state.runConfig.Labels[v.Key] = v.Value\n\t\tcommitStr += \" \" + v.String()\n\t}\n\treturn d.builder.commit(ctx, d.state, commitStr)\n}\n\n// ADD foo /path\n//\n// Add the file 'foo' to '/path'. Tarball and Remote URL (http, https) handling\n// exist here. If you do not wish to have this automatic handling, use COPY.\nfunc dispatchAdd(ctx context.Context, d dispatchRequest, c *instructions.AddCommand) error {\n\tif c.Chmod != \"\" {\n\t\treturn errors.New(\"the --chmod option requires BuildKit. Refer to https://docs.docker.com/go/buildkit/ to learn how to build images with BuildKit enabled\")\n\t}\n\tdownloader := newRemoteSourceDownloader(d.builder.Output, d.builder.Stdout)\n\tcopier := copierFromDispatchRequest(d, downloader, nil)\n\tdefer copier.Cleanup()\n\n\tcopyInstruction, err := copier.createCopyInstruction(c.SourcesAndDest, \"ADD\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcopyInstruction.chownStr = c.Chown\n\tcopyInstruction.allowLocalDecompression = true\n\n\treturn d.builder.performCopy(ctx, d, copyInstruction)\n}\n\n// COPY foo /path\n//\n// Same as 'ADD' but without the tar and remote url handling.\nfunc dispatchCopy(ctx context.Context, d dispatchRequest, c *instructions.CopyCommand) error {\n\tif c.Chmod != \"\" {\n\t\treturn errors.New(\"the --chmod option requires BuildKit. Refer to https://docs.docker.com/go/buildkit/ to learn how to build images with BuildKit enabled\")\n\t}\n\tvar im *imageMount\n\tvar err error\n\tif c.From != \"\" {\n\t\tim, err = d.getImageMount(ctx, c.From)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"invalid from flag value %s\", c.From)\n\t\t}\n\t}\n\tcopier := copierFromDispatchRequest(d, errOnSourceDownload, im)\n\tdefer copier.Cleanup()\n\tcopyInstruction, err := copier.createCopyInstruction(c.SourcesAndDest, \"COPY\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tcopyInstruction.chownStr = c.Chown\n\tif c.From != \"\" && copyInstruction.chownStr == \"\" {\n\t\tcopyInstruction.preserveOwnership = true\n\t}\n\treturn d.builder.performCopy(ctx, d, copyInstruction)\n}\n\nfunc (d *dispatchRequest) getImageMount(ctx context.Context, imageRefOrID string) (*imageMount, error) {\n\tif imageRefOrID == \"\" {\n\t\t// TODO: this could return the source in the default case as well?\n\t\treturn nil, nil\n\t}\n\n\tvar localOnly bool\n\tstage, err := d.stages.get(imageRefOrID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif stage != nil {\n\t\timageRefOrID = stage.Image\n\t\tlocalOnly = true\n\t}\n\treturn d.builder.imageSources.Get(ctx, imageRefOrID, localOnly, d.builder.platform)\n}\n\n// FROM [--platform=platform] imagename[:tag | @digest] [AS build-stage-name]\nfunc initializeStage(ctx context.Context, d dispatchRequest, cmd *instructions.Stage) error {\n\terr := d.builder.imageProber.Reset(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar platform *ocispec.Platform\n\tif v := cmd.Platform; v != \"\" {\n\t\tv, err := d.getExpandedString(d.shlex, v)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to process arguments for platform %s\", v)\n\t\t}\n\n\t\tp, err := platforms.Parse(v)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to parse platform %s\", v)\n\t\t}\n\t\tplatform = &p\n\t}\n\n\timage, err := d.getFromImage(ctx, d.shlex, cmd.BaseName, platform)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstate := d.state\n\tif err := state.beginStage(cmd.Name, image); err != nil {\n\t\treturn err\n\t}\n\tif len(state.runConfig.OnBuild) > 0 {\n\t\ttriggers := state.runConfig.OnBuild\n\t\tstate.runConfig.OnBuild = nil\n\t\treturn dispatchTriggeredOnBuild(ctx, d, triggers)\n\t}\n\treturn nil\n}\n\nfunc dispatchTriggeredOnBuild(ctx context.Context, d dispatchRequest, triggers []string) error {\n\tfmt.Fprintf(d.builder.Stdout, \"# Executing %d build trigger\", len(triggers))\n\tif len(triggers) > 1 {\n\t\tfmt.Fprint(d.builder.Stdout, \"s\")\n\t}\n\tfmt.Fprintln(d.builder.Stdout)\n\tfor _, trigger := range triggers {\n\t\td.state.updateRunConfig()\n\t\tast, err := parser.Parse(strings.NewReader(trigger))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(ast.AST.Children) != 1 {\n\t\t\treturn errors.New(\"onbuild trigger should be a single expression\")\n\t\t}\n\t\tcmd, err := instructions.ParseCommand(ast.AST.Children[0])\n\t\tif err != nil {\n\t\t\tvar uiErr *instructions.UnknownInstructionError\n\t\t\tif errors.As(err, &uiErr) {\n\t\t\t\tbuildsFailed.WithValues(metricsUnknownInstructionError).Inc()\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\terr = dispatch(ctx, d, cmd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (d *dispatchRequest) getExpandedString(shlex *shell.Lex, str string) (string, error) {\n\tsubstitutionArgs := []string{}\n\tfor key, value := range d.state.buildArgs.GetAllMeta() {\n\t\tsubstitutionArgs = append(substitutionArgs, key+\"=\"+value)\n\t}\n\n\tname, err := shlex.ProcessWord(str, substitutionArgs)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn name, nil\n}\n\nfunc (d *dispatchRequest) getImageOrStage(ctx context.Context, name string, platform *ocispec.Platform) (builder.Image, error) {\n\tvar localOnly bool\n\tif im, ok := d.stages.getByName(name); ok {\n\t\tname = im.Image\n\t\tlocalOnly = true\n\t}\n\n\tif platform == nil {\n\t\tplatform = d.builder.platform\n\t}\n\n\t// Windows cannot support a container with no base image.\n\tif name == api.NoBaseImageSpecifier {\n\t\t// Windows supports scratch. What is not supported is running containers from it.\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\treturn nil, errors.New(\"Windows does not support FROM scratch\")\n\t\t}\n\n\t\t// TODO: scratch should not have an os. It should be nil image.\n\t\timageImage := &image.Image{}\n\t\tif platform != nil {\n\t\t\timageImage.OS = platform.OS\n\t\t} else {\n\t\t\timageImage.OS = runtime.GOOS\n\t\t}\n\t\treturn builder.Image(imageImage), nil\n\t}\n\timageMount, err := d.builder.imageSources.Get(ctx, name, localOnly, platform)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn imageMount.Image(), nil\n}\n\nfunc (d *dispatchRequest) getFromImage(ctx context.Context, shlex *shell.Lex, basename string, platform *ocispec.Platform) (builder.Image, error) {\n\tname, err := d.getExpandedString(shlex, basename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Empty string is interpreted to FROM scratch by images.GetImageAndReleasableLayer,\n\t// so validate expanded result is not empty.\n\tif name == \"\" {\n\t\treturn nil, errors.Errorf(\"base name (%s) should not be blank\", basename)\n\t}\n\n\treturn d.getImageOrStage(ctx, name, platform)\n}\n\nfunc dispatchOnbuild(ctx context.Context, d dispatchRequest, c *instructions.OnbuildCommand) error {\n\td.state.runConfig.OnBuild = append(d.state.runConfig.OnBuild, c.Expression)\n\treturn d.builder.commit(ctx, d.state, \"ONBUILD \"+c.Expression)\n}\n\n// WORKDIR /tmp\n//\n// Set the working directory for future RUN/CMD/etc statements.\nfunc dispatchWorkdir(ctx context.Context, d dispatchRequest, c *instructions.WorkdirCommand) error {\n\trunConfig := d.state.runConfig\n\tvar err error\n\trunConfig.WorkingDir, err = normalizeWorkdir(d.state.operatingSystem, runConfig.WorkingDir, c.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// For performance reasons, we explicitly do a create/mkdir now\n\t// This avoids having an unnecessary expensive mount/unmount calls\n\t// (on Windows in particular) during each container create.\n\t// Prior to 1.13, the mkdir was deferred and not executed at this step.\n\tif d.builder.disableCommit {\n\t\t// Don't call back into the daemon if we're going through docker commit --change \"WORKDIR /foo\".\n\t\t// We've already updated the runConfig and that's enough.\n\t\treturn nil\n\t}\n\n\tcomment := \"WORKDIR \" + runConfig.WorkingDir\n\trunConfigWithCommentCmd := copyRunConfig(runConfig, withCmdCommentString(comment, d.state.operatingSystem))\n\n\tcontainerID, err := d.builder.probeAndCreate(ctx, d.state, runConfigWithCommentCmd)\n\tif err != nil || containerID == \"\" {\n\t\treturn err\n\t}\n\n\tif err := d.builder.docker.ContainerCreateWorkdir(containerID); err != nil {\n\t\treturn err\n\t}\n\n\treturn d.builder.commitContainer(ctx, d.state, containerID, runConfigWithCommentCmd)\n}\n\n// RUN some command yo\n//\n// run a command and commit the image. Args are automatically prepended with\n// the current SHELL which defaults to 'sh -c' under linux or 'cmd /S /C' under\n// Windows, in the event there is only one argument The difference in processing:\n//\n// RUN echo hi          # sh -c echo hi       (Linux and LCOW)\n// RUN echo hi          # cmd /S /C echo hi   (Windows)\n// RUN [ \"echo\", \"hi\" ] # echo hi\nfunc dispatchRun(ctx context.Context, d dispatchRequest, c *instructions.RunCommand) error {\n\tif err := image.CheckOS(d.state.operatingSystem); err != nil {\n\t\treturn err\n\t}\n\n\tif len(c.FlagsUsed) > 0 {\n\t\t// classic builder RUN currently does not support any flags, so fail on the first one\n\t\treturn errors.Errorf(\"the --%s option requires BuildKit. Refer to https://docs.docker.com/go/buildkit/ to learn how to build images with BuildKit enabled\", c.FlagsUsed[0])\n\t}\n\n\tstateRunConfig := d.state.runConfig\n\tcmdFromArgs, argsEscaped := resolveCmdLine(c.ShellDependantCmdLine, stateRunConfig, d.state.operatingSystem, c.Name(), c.String())\n\tbuildArgs := d.state.buildArgs.FilterAllowed(stateRunConfig.Env)\n\n\tsaveCmd := cmdFromArgs\n\tif len(buildArgs) > 0 {\n\t\tsaveCmd = prependEnvOnCmd(d.state.buildArgs, buildArgs, cmdFromArgs)\n\t}\n\n\tcacheArgsEscaped := argsEscaped\n\t// ArgsEscaped is not persisted in the committed image on Windows.\n\t// Use the original from previous build steps for cache probing.\n\tif d.state.operatingSystem == \"windows\" {\n\t\tcacheArgsEscaped = stateRunConfig.ArgsEscaped\n\t}\n\n\trunConfigForCacheProbe := copyRunConfig(stateRunConfig,\n\t\twithCmd(saveCmd),\n\t\twithArgsEscaped(cacheArgsEscaped),\n\t\twithEntrypointOverride(saveCmd, nil))\n\tif hit, err := d.builder.probeCache(d.state, runConfigForCacheProbe); err != nil || hit {\n\t\treturn err\n\t}\n\n\trunConfig := copyRunConfig(stateRunConfig,\n\t\twithCmd(cmdFromArgs),\n\t\twithArgsEscaped(argsEscaped),\n\t\twithEnv(append(stateRunConfig.Env, buildArgs...)),\n\t\twithEntrypointOverride(saveCmd, strslice.StrSlice{\"\"}),\n\t\twithoutHealthcheck())\n\n\tcID, err := d.builder.create(ctx, runConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := d.builder.containerManager.Run(ctx, cID, d.builder.Stdout, d.builder.Stderr); err != nil {\n\t\tif err, ok := err.(*statusCodeError); ok {\n\t\t\t// TODO: change error type, because jsonmessage.JSONError assumes HTTP\n\t\t\tmsg := fmt.Sprintf(\n\t\t\t\t\"The command '%s' returned a non-zero code: %d\",\n\t\t\t\tstrings.Join(runConfig.Cmd, \" \"), err.StatusCode())\n\t\t\tif err.Error() != \"\" {\n\t\t\t\tmsg = fmt.Sprintf(\"%s: %s\", msg, err.Error())\n\t\t\t}\n\t\t\treturn &jsonmessage.JSONError{\n\t\t\t\tMessage: msg,\n\t\t\t\tCode:    err.StatusCode(),\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\t// Don't persist the argsEscaped value in the committed image. Use the original\n\t// from previous build steps (only CMD and ENTRYPOINT persist this).\n\tif d.state.operatingSystem == \"windows\" {\n\t\trunConfigForCacheProbe.ArgsEscaped = stateRunConfig.ArgsEscaped\n\t}\n\n\treturn d.builder.commitContainer(ctx, d.state, cID, runConfigForCacheProbe)\n}\n\n// Derive the command to use for probeCache() and to commit in this container.\n// Note that we only do this if there are any build-time env vars.  Also, we\n// use the special argument \"|#\" at the start of the args array. This will\n// avoid conflicts with any RUN command since commands can not\n// start with | (vertical bar). The \"#\" (number of build envs) is there to\n// help ensure proper cache matches. We don't want a RUN command\n// that starts with \"foo=abc\" to be considered part of a build-time env var.\n//\n// remove any unreferenced built-in args from the environment variables.\n// These args are transparent so resulting image should be the same regardless\n// of the value.\nfunc prependEnvOnCmd(buildArgs *BuildArgs, buildArgVars []string, cmd strslice.StrSlice) strslice.StrSlice {\n\ttmpBuildEnv := make([]string, 0, len(buildArgVars))\n\tfor _, env := range buildArgVars {\n\t\tkey, _, _ := strings.Cut(env, \"=\")\n\t\tif buildArgs.IsReferencedOrNotBuiltin(key) {\n\t\t\ttmpBuildEnv = append(tmpBuildEnv, env)\n\t\t}\n\t}\n\n\tsort.Strings(tmpBuildEnv)\n\ttmpEnv := append([]string{fmt.Sprintf(\"|%d\", len(tmpBuildEnv))}, tmpBuildEnv...)\n\treturn append(tmpEnv, cmd...)\n}\n\n// CMD foo\n//\n// Set the default command to run in the container (which may be empty).\n// Argument handling is the same as RUN.\nfunc dispatchCmd(ctx context.Context, d dispatchRequest, c *instructions.CmdCommand) error {\n\trunConfig := d.state.runConfig\n\tcmd, argsEscaped := resolveCmdLine(c.ShellDependantCmdLine, runConfig, d.state.operatingSystem, c.Name(), c.String())\n\n\t// We warn here as Windows shell processing operates differently to Linux.\n\t// Linux:   /bin/sh -c \"echo hello\" world\t--> hello\n\t// Windows: cmd /s /c \"echo hello\" world\t--> hello world\n\tif d.state.operatingSystem == \"windows\" &&\n\t\tlen(runConfig.Entrypoint) > 0 &&\n\t\td.state.runConfig.ArgsEscaped != argsEscaped {\n\t\tfmt.Fprintf(d.builder.Stderr, \" ---> [Warning] Shell-form ENTRYPOINT and exec-form CMD may have unexpected results\\n\")\n\t}\n\n\trunConfig.Cmd = cmd\n\trunConfig.ArgsEscaped = argsEscaped\n\n\tif err := d.builder.commit(ctx, d.state, fmt.Sprintf(\"CMD %q\", cmd)); err != nil {\n\t\treturn err\n\t}\n\tif len(c.ShellDependantCmdLine.CmdLine) != 0 {\n\t\td.state.cmdSet = true\n\t}\n\n\treturn nil\n}\n\n// HEALTHCHECK foo\n//\n// Set the default healthcheck command to run in the container (which may be empty).\n// Argument handling is the same as RUN.\nfunc dispatchHealthcheck(ctx context.Context, d dispatchRequest, c *instructions.HealthCheckCommand) error {\n\trunConfig := d.state.runConfig\n\tif runConfig.Healthcheck != nil {\n\t\toldCmd := runConfig.Healthcheck.Test\n\t\tif len(oldCmd) > 0 && oldCmd[0] != \"NONE\" {\n\t\t\tfmt.Fprintf(d.builder.Stdout, \"Note: overriding previous HEALTHCHECK: %v\\n\", oldCmd)\n\t\t}\n\t}\n\trunConfig.Healthcheck = c.Health\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"HEALTHCHECK %q\", runConfig.Healthcheck))\n}\n\n// ENTRYPOINT /usr/sbin/nginx\n//\n// Set the entrypoint to /usr/sbin/nginx. Will accept the CMD as the arguments\n// to /usr/sbin/nginx. Uses the default shell if not in JSON format.\n//\n// Handles command processing similar to CMD and RUN, only req.runConfig.Entrypoint\n// is initialized at newBuilder time instead of through argument parsing.\nfunc dispatchEntrypoint(ctx context.Context, d dispatchRequest, c *instructions.EntrypointCommand) error {\n\trunConfig := d.state.runConfig\n\tcmd, argsEscaped := resolveCmdLine(c.ShellDependantCmdLine, runConfig, d.state.operatingSystem, c.Name(), c.String())\n\n\t// This warning is a little more complex than in dispatchCmd(), as the Windows base images (similar\n\t// universally to almost every Linux image out there) have a single .Cmd field populated so that\n\t// `docker run --rm image` starts the default shell which would typically be sh on Linux,\n\t// or cmd on Windows. The catch to this is that if a dockerfile had `CMD [\"c:\\\\windows\\\\system32\\\\cmd.exe\"]`,\n\t// we wouldn't be able to tell the difference. However, that would be highly unlikely, and besides, this\n\t// is only trying to give a helpful warning of possibly unexpected results.\n\tif d.state.operatingSystem == \"windows\" &&\n\t\td.state.runConfig.ArgsEscaped != argsEscaped &&\n\t\t((len(runConfig.Cmd) == 1 && strings.ToLower(runConfig.Cmd[0]) != `c:\\windows\\system32\\cmd.exe` && len(runConfig.Shell) == 0) || (len(runConfig.Cmd) > 1)) {\n\t\tfmt.Fprintf(d.builder.Stderr, \" ---> [Warning] Shell-form CMD and exec-form ENTRYPOINT may have unexpected results\\n\")\n\t}\n\n\trunConfig.Entrypoint = cmd\n\trunConfig.ArgsEscaped = argsEscaped\n\tif !d.state.cmdSet {\n\t\trunConfig.Cmd = nil\n\t}\n\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"ENTRYPOINT %q\", runConfig.Entrypoint))\n}\n\n// EXPOSE 6667/tcp 7000/tcp\n//\n// Expose ports for links and port mappings. This all ends up in\n// req.runConfig.ExposedPorts for runconfig.\nfunc dispatchExpose(ctx context.Context, d dispatchRequest, c *instructions.ExposeCommand, envs []string) error {\n\t// custom multi word expansion\n\t// expose $FOO with FOO=\"80 443\" is expanded as EXPOSE [80,443]. This is the only command supporting word to words expansion\n\t// so the word processing has been de-generalized\n\tports := []string{}\n\tfor _, p := range c.Ports {\n\t\tps, err := d.shlex.ProcessWords(p, envs)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tports = append(ports, ps...)\n\t}\n\tc.Ports = ports\n\n\tps, _, err := nat.ParsePortSpecs(ports)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.state.runConfig.ExposedPorts == nil {\n\t\td.state.runConfig.ExposedPorts = make(nat.PortSet)\n\t}\n\tfor p := range ps {\n\t\td.state.runConfig.ExposedPorts[p] = struct{}{}\n\t}\n\n\treturn d.builder.commit(ctx, d.state, \"EXPOSE \"+strings.Join(c.Ports, \" \"))\n}\n\n// USER foo\n//\n// Set the user to 'foo' for future commands and when running the\n// ENTRYPOINT/CMD at container run time.\nfunc dispatchUser(ctx context.Context, d dispatchRequest, c *instructions.UserCommand) error {\n\td.state.runConfig.User = c.User\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"USER %v\", c.User))\n}\n\n// VOLUME /foo\n//\n// Expose the volume /foo for use. Will also accept the JSON array form.\nfunc dispatchVolume(ctx context.Context, d dispatchRequest, c *instructions.VolumeCommand) error {\n\tif d.state.runConfig.Volumes == nil {\n\t\td.state.runConfig.Volumes = map[string]struct{}{}\n\t}\n\tfor _, v := range c.Volumes {\n\t\tif v == \"\" {\n\t\t\treturn errors.New(\"VOLUME specified can not be an empty string\")\n\t\t}\n\t\td.state.runConfig.Volumes[v] = struct{}{}\n\t}\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"VOLUME %v\", c.Volumes))\n}\n\n// STOPSIGNAL signal\n//\n// Set the signal that will be used to kill the container.\nfunc dispatchStopSignal(ctx context.Context, d dispatchRequest, c *instructions.StopSignalCommand) error {\n\t_, err := signal.ParseSignal(c.Signal)\n\tif err != nil {\n\t\treturn errdefs.InvalidParameter(err)\n\t}\n\td.state.runConfig.StopSignal = c.Signal\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"STOPSIGNAL %v\", c.Signal))\n}\n\n// ARG name[=value]\n//\n// Adds the variable foo to the trusted list of variables that can be passed\n// to builder using the --build-arg flag for expansion/substitution or passing to 'run'.\n// Dockerfile author may optionally set a default value of this variable.\nfunc dispatchArg(ctx context.Context, d dispatchRequest, c *instructions.ArgCommand) error {\n\tvar commitStr strings.Builder\n\tcommitStr.WriteString(\"ARG \")\n\tfor i, arg := range c.Args {\n\t\tif i > 0 {\n\t\t\tcommitStr.WriteString(\" \")\n\t\t}\n\t\tcommitStr.WriteString(arg.Key)\n\t\tif arg.Value != nil {\n\t\t\tcommitStr.WriteString(\"=\")\n\t\t\tcommitStr.WriteString(*arg.Value)\n\t\t}\n\t\td.state.buildArgs.AddArg(arg.Key, arg.Value)\n\t}\n\n\treturn d.builder.commit(ctx, d.state, commitStr.String())\n}\n\n// SHELL powershell -command\n//\n// Set the non-default shell to use.\nfunc dispatchShell(ctx context.Context, d dispatchRequest, c *instructions.ShellCommand) error {\n\td.state.runConfig.Shell = c.Shell\n\treturn d.builder.commit(ctx, d.state, fmt.Sprintf(\"SHELL %v\", d.state.runConfig.Shell))\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\nimport (\n\t\"context\"\n\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\n// ImageProber exposes an Image cache to the Builder. It supports resetting a\n// cache.\ntype ImageProber interface {\n\tReset(ctx context.Context) error\n\tProbe(parentID string, runConfig *container.Config, platform ocispec.Platform) (string, error)\n}\n\ntype resetFunc func(context.Context) (builder.ImageCache, error)\n\ntype imageProber struct {\n\tcache       builder.ImageCache\n\treset       resetFunc\n\tcacheBusted bool\n}\n\nfunc newImageProber(ctx context.Context, cacheBuilder builder.ImageCacheBuilder, cacheFrom []string, noCache bool) (ImageProber, error) {\n\tif noCache {\n\t\treturn &nopProber{}, nil\n\t}\n\n\treset := func(ctx context.Context) (builder.ImageCache, error) {\n\t\treturn cacheBuilder.MakeImageCache(ctx, cacheFrom)\n\t}\n\n\tcache, err := reset(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &imageProber{cache: cache, reset: reset}, nil\n}\n\nfunc (c *imageProber) Reset(ctx context.Context) error {\n\tnewCache, err := c.reset(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.cache = newCache\n\tc.cacheBusted = false\n\treturn nil\n}\n\n// Probe checks if cache match can be found for current build instruction.\n// It returns the cachedID if there is a hit, and the empty string on miss\nfunc (c *imageProber) Probe(parentID string, runConfig *container.Config, platform ocispec.Platform) (string, error) {\n\tif c.cacheBusted {\n\t\treturn \"\", nil\n\t}\n\tcacheID, err := c.cache.GetCache(parentID, runConfig, platform)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif len(cacheID) == 0 {\n\t\tlog.G(context.TODO()).Debugf(\"[BUILDER] Cache miss: %s\", runConfig.Cmd)\n\t\tc.cacheBusted = true\n\t\treturn \"\", nil\n\t}\n\tlog.G(context.TODO()).Debugf(\"[BUILDER] Use cached version: %s\", runConfig.Cmd)\n\treturn cacheID, nil\n}\n\ntype nopProber struct{}\n\nfunc (c *nopProber) Reset(ctx context.Context) error {\n\treturn nil\n}\n\nfunc (c *nopProber) Probe(_ string, _ *container.Config, _ ocispec.Platform) (string, error) {\n\treturn \"\", nil\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\n// internals for handling commands. Covers many areas and a lot of\n// non-contiguous functionality. Please read the comments.\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/pkg/archive\"\n\t\"github.com/docker/docker/pkg/chrootarchive\"\n\t\"github.com/docker/docker/pkg/stringid\"\n\t\"github.com/docker/go-connections/nat\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\nfunc (b *Builder) getArchiver() *archive.Archiver {\n\treturn chrootarchive.NewArchiver(b.idMapping)\n}\n\nfunc (b *Builder) commit(ctx context.Context, dispatchState *dispatchState, comment string) error {\n\tif b.disableCommit {\n\t\treturn nil\n\t}\n\tif !dispatchState.hasFromImage() {\n\t\treturn errors.New(\"Please provide a source image with `from` prior to commit\")\n\t}\n\n\trunConfigWithCommentCmd := copyRunConfig(dispatchState.runConfig, withCmdComment(comment, dispatchState.operatingSystem))\n\tid, err := b.probeAndCreate(ctx, dispatchState, runConfigWithCommentCmd)\n\tif err != nil || id == \"\" {\n\t\treturn err\n\t}\n\n\treturn b.commitContainer(ctx, dispatchState, id, runConfigWithCommentCmd)\n}\n\nfunc (b *Builder) commitContainer(ctx context.Context, dispatchState *dispatchState, id string, containerConfig *container.Config) error {\n\tif b.disableCommit {\n\t\treturn nil\n\t}\n\n\tcommitCfg := backend.CommitConfig{\n\t\tAuthor: dispatchState.maintainer,\n\t\t// TODO: this copy should be done by Commit()\n\t\tConfig:          copyRunConfig(dispatchState.runConfig),\n\t\tContainerConfig: containerConfig,\n\t\tContainerID:     id,\n\t}\n\n\timageID, err := b.docker.CommitBuildStep(ctx, commitCfg)\n\tdispatchState.imageID = string(imageID)\n\treturn err\n}\n\nfunc (b *Builder) exportImage(ctx context.Context, state *dispatchState, layer builder.RWLayer, parent builder.Image, runConfig *container.Config) error {\n\tnewLayer, err := layer.Commit()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tparentImage, ok := parent.(*image.Image)\n\tif !ok {\n\t\treturn errors.Errorf(\"unexpected image type\")\n\t}\n\n\tplatform := &ocispec.Platform{\n\t\tOS:           parentImage.OS,\n\t\tArchitecture: parentImage.Architecture,\n\t\tVariant:      parentImage.Variant,\n\t}\n\n\t// add an image mount without an image so the layer is properly unmounted\n\t// if there is an error before we can add the full mount with image\n\tb.imageSources.Add(newImageMount(nil, newLayer), platform)\n\n\tnewImage := image.NewChildImage(parentImage, image.ChildConfig{\n\t\tAuthor:          state.maintainer,\n\t\tContainerConfig: runConfig,\n\t\tDiffID:          newLayer.DiffID(),\n\t\tConfig:          copyRunConfig(state.runConfig),\n\t}, parentImage.OS)\n\n\t// TODO: it seems strange to marshal this here instead of just passing in the\n\t// image struct\n\tconfig, err := newImage.MarshalJSON()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to encode image config\")\n\t}\n\n\t// when writing the new image's manifest, we now need to pass in the new layer's digest.\n\t// before the containerd store work this was unnecessary since we get the layer id\n\t// from the image's RootFS ChainID -- see:\n\t// https://github.com/moby/moby/blob/8cf66ed7322fa885ef99c4c044fa23e1727301dc/image/store.go#L162\n\t// however, with the containerd store we can't do this. An alternative implementation here\n\t// without changing the signature would be to get the layer digest by walking the content store\n\t// and filtering the objects to find the layer with the DiffID we want, but that has performance\n\t// implications that should be called out/investigated\n\texportedImage, err := b.docker.CreateImage(ctx, config, state.imageID, newLayer.ContentStoreDigest())\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to export image\")\n\t}\n\n\tstate.imageID = exportedImage.ImageID()\n\tb.imageSources.Add(newImageMount(exportedImage, newLayer), platform)\n\treturn nil\n}\n\nfunc (b *Builder) performCopy(ctx context.Context, req dispatchRequest, inst copyInstruction) error {\n\tstate := req.state\n\tsrcHash := getSourceHashFromInfos(inst.infos)\n\n\tvar chownComment string\n\tif inst.chownStr != \"\" {\n\t\tchownComment = fmt.Sprintf(\"--chown=%s \", inst.chownStr)\n\t}\n\tcommentStr := fmt.Sprintf(\"%s %s%s in %s \", inst.cmdName, chownComment, srcHash, inst.dest)\n\n\t// TODO: should this have been using origPaths instead of srcHash in the comment?\n\trunConfigWithCommentCmd := copyRunConfig(\n\t\tstate.runConfig,\n\t\twithCmdCommentString(commentStr, state.operatingSystem))\n\thit, err := b.probeCache(state, runConfigWithCommentCmd)\n\tif err != nil || hit {\n\t\treturn err\n\t}\n\n\timageMount, err := b.imageSources.Get(ctx, state.imageID, true, req.builder.platform)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to get destination image %q\", state.imageID)\n\t}\n\n\trwLayer, err := imageMount.NewRWLayer()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rwLayer.Release()\n\n\tdestInfo, err := createDestInfo(state.runConfig.WorkingDir, inst, rwLayer, state.operatingSystem)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tidentity := b.idMapping.RootPair()\n\t// if a chown was requested, perform the steps to get the uid, gid\n\t// translated (if necessary because of user namespaces), and replace\n\t// the root pair with the chown pair for copy operations\n\tif inst.chownStr != \"\" {\n\t\tidentity, err = parseChownFlag(ctx, b, state, inst.chownStr, destInfo.root, b.idMapping)\n\t\tif err != nil {\n\t\t\tif b.options.Platform != \"windows\" {\n\t\t\t\treturn errors.Wrapf(err, \"unable to convert uid/gid chown string to host mapping\")\n\t\t\t}\n\n\t\t\treturn errors.Wrapf(err, \"unable to map container user account name to SID\")\n\t\t}\n\t}\n\n\tfor _, info := range inst.infos {\n\t\topts := copyFileOptions{\n\t\t\tdecompress: inst.allowLocalDecompression,\n\t\t\tarchiver:   b.getArchiver(),\n\t\t}\n\t\tif !inst.preserveOwnership {\n\t\t\topts.identity = &identity\n\t\t}\n\t\tif err := performCopyForInfo(destInfo, info, opts); err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to copy files\")\n\t\t}\n\t}\n\treturn b.exportImage(ctx, state, rwLayer, imageMount.Image(), runConfigWithCommentCmd)\n}\n\nfunc createDestInfo(workingDir string, inst copyInstruction, rwLayer builder.RWLayer, platform string) (copyInfo, error) {\n\t// Twiddle the destination when it's a relative path - meaning, make it\n\t// relative to the WORKINGDIR\n\tdest, err := normalizeDest(workingDir, inst.dest)\n\tif err != nil {\n\t\treturn copyInfo{}, errors.Wrapf(err, \"invalid %s\", inst.cmdName)\n\t}\n\n\treturn copyInfo{root: rwLayer.Root(), path: dest}, nil\n}\n\n// For backwards compat, if there's just one info then use it as the\n// cache look-up string, otherwise hash 'em all into one\nfunc getSourceHashFromInfos(infos []copyInfo) string {\n\tif len(infos) == 1 {\n\t\treturn infos[0].hash\n\t}\n\tvar hashs []string\n\tfor _, info := range infos {\n\t\thashs = append(hashs, info.hash)\n\t}\n\treturn hashStringSlice(\"multi\", hashs)\n}\n\nfunc hashStringSlice(prefix string, slice []string) string {\n\thasher := sha256.New()\n\thasher.Write([]byte(strings.Join(slice, \",\")))\n\treturn prefix + \":\" + hex.EncodeToString(hasher.Sum(nil))\n}\n\ntype runConfigModifier func(*container.Config)\n\nfunc withCmd(cmd []string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Cmd = cmd\n\t}\n}\n\nfunc withArgsEscaped(argsEscaped bool) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.ArgsEscaped = argsEscaped\n\t}\n}\n\n// withCmdComment sets Cmd to a nop comment string. See withCmdCommentString for\n// why there are two almost identical versions of this.\nfunc withCmdComment(comment string, platform string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Cmd = append(getShell(runConfig, platform), \"#(nop) \", comment)\n\t}\n}\n\n// withCmdCommentString exists to maintain compatibility with older versions.\n// A few instructions (workdir, copy, add) used a nop comment that is a single arg\n// where as all the other instructions used a two arg comment string. This\n// function implements the single arg version.\nfunc withCmdCommentString(comment string, platform string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Cmd = append(getShell(runConfig, platform), \"#(nop) \"+comment)\n\t}\n}\n\nfunc withEnv(env []string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Env = env\n\t}\n}\n\n// withEntrypointOverride sets an entrypoint on runConfig if the command is\n// not empty. The entrypoint is left unmodified if command is empty.\n//\n// The dockerfile RUN instruction expect to run without an entrypoint\n// so the runConfig entrypoint needs to be modified accordingly. ContainerCreate\n// will change a []string{\"\"} entrypoint to nil, so we probe the cache with the\n// nil entrypoint.\nfunc withEntrypointOverride(cmd []string, entrypoint []string) runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\tif len(cmd) > 0 {\n\t\t\trunConfig.Entrypoint = entrypoint\n\t\t}\n\t}\n}\n\n// withoutHealthcheck disables healthcheck.\n//\n// The dockerfile RUN instruction expect to run without healthcheck\n// so the runConfig Healthcheck needs to be disabled.\nfunc withoutHealthcheck() runConfigModifier {\n\treturn func(runConfig *container.Config) {\n\t\trunConfig.Healthcheck = &container.HealthConfig{\n\t\t\tTest: []string{\"NONE\"},\n\t\t}\n\t}\n}\n\nfunc copyRunConfig(runConfig *container.Config, modifiers ...runConfigModifier) *container.Config {\n\tcopy := *runConfig\n\tcopy.Cmd = copyStringSlice(runConfig.Cmd)\n\tcopy.Env = copyStringSlice(runConfig.Env)\n\tcopy.Entrypoint = copyStringSlice(runConfig.Entrypoint)\n\tcopy.OnBuild = copyStringSlice(runConfig.OnBuild)\n\tcopy.Shell = copyStringSlice(runConfig.Shell)\n\n\tif copy.Volumes != nil {\n\t\tcopy.Volumes = make(map[string]struct{}, len(runConfig.Volumes))\n\t\tfor k, v := range runConfig.Volumes {\n\t\t\tcopy.Volumes[k] = v\n\t\t}\n\t}\n\n\tif copy.ExposedPorts != nil {\n\t\tcopy.ExposedPorts = make(nat.PortSet, len(runConfig.ExposedPorts))\n\t\tfor k, v := range runConfig.ExposedPorts {\n\t\t\tcopy.ExposedPorts[k] = v\n\t\t}\n\t}\n\n\tif copy.Labels != nil {\n\t\tcopy.Labels = make(map[string]string, len(runConfig.Labels))\n\t\tfor k, v := range runConfig.Labels {\n\t\t\tcopy.Labels[k] = v\n\t\t}\n\t}\n\n\tfor _, modifier := range modifiers {\n\t\tmodifier(&copy)\n\t}\n\treturn &copy\n}\n\nfunc copyStringSlice(orig []string) []string {\n\tif orig == nil {\n\t\treturn nil\n\t}\n\treturn append([]string{}, orig...)\n}\n\n// getShell is a helper function which gets the right shell for prefixing the\n// shell-form of RUN, ENTRYPOINT and CMD instructions\nfunc getShell(c *container.Config, os string) []string {\n\tif 0 == len(c.Shell) {\n\t\treturn append([]string{}, defaultShellForOS(os)[:]...)\n\t}\n\treturn append([]string{}, c.Shell[:]...)\n}\n\nfunc (b *Builder) probeCache(dispatchState *dispatchState, runConfig *container.Config) (bool, error) {\n\tcachedID, err := b.imageProber.Probe(dispatchState.imageID, runConfig, b.getPlatform(dispatchState))\n\tif cachedID == \"\" || err != nil {\n\t\treturn false, err\n\t}\n\tfmt.Fprint(b.Stdout, \" ---> Using cache\\n\")\n\n\tdispatchState.imageID = cachedID\n\treturn true, nil\n}\n\nvar defaultLogConfig = container.LogConfig{Type: \"none\"}\n\nfunc (b *Builder) probeAndCreate(ctx context.Context, dispatchState *dispatchState, runConfig *container.Config) (string, error) {\n\tif hit, err := b.probeCache(dispatchState, runConfig); err != nil || hit {\n\t\treturn \"\", err\n\t}\n\treturn b.create(ctx, runConfig)\n}\n\nfunc (b *Builder) create(ctx context.Context, runConfig *container.Config) (string, error) {\n\tlog.G(ctx).Debugf(\"[BUILDER] Command to be executed: %v\", runConfig.Cmd)\n\n\thostConfig := hostConfigFromOptions(b.options)\n\tcontainer, err := b.containerManager.Create(ctx, runConfig, hostConfig)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// TODO: could this be moved into containerManager.Create() ?\n\tfor _, warning := range container.Warnings {\n\t\tfmt.Fprintf(b.Stdout, \" ---> [Warning] %s\\n\", warning)\n\t}\n\tfmt.Fprintf(b.Stdout, \" ---> Running in %s\\n\", stringid.TruncateID(container.ID))\n\treturn container.ID, nil\n}\n\nfunc hostConfigFromOptions(options *types.ImageBuildOptions) *container.HostConfig {\n\tresources := container.Resources{\n\t\tCgroupParent: options.CgroupParent,\n\t\tCPUShares:    options.CPUShares,\n\t\tCPUPeriod:    options.CPUPeriod,\n\t\tCPUQuota:     options.CPUQuota,\n\t\tCpusetCpus:   options.CPUSetCPUs,\n\t\tCpusetMems:   options.CPUSetMems,\n\t\tMemory:       options.Memory,\n\t\tMemorySwap:   options.MemorySwap,\n\t\tUlimits:      options.Ulimits,\n\t}\n\n\thc := &container.HostConfig{\n\t\tSecurityOpt: options.SecurityOpt,\n\t\tIsolation:   options.Isolation,\n\t\tShmSize:     options.ShmSize,\n\t\tResources:   resources,\n\t\tNetworkMode: container.NetworkMode(options.NetworkMode),\n\t\t// Set a log config to override any default value set on the daemon\n\t\tLogConfig:  defaultLogConfig,\n\t\tExtraHosts: options.ExtraHosts,\n\t}\n\treturn hc\n}\n\nfunc (b *Builder) getPlatform(state *dispatchState) ocispec.Platform {\n\t// May be nil if not explicitly set in API/dockerfile\n\tout := platforms.DefaultSpec()\n\tif b.platform != nil {\n\t\tout = *b.platform\n\t}\n\n\tif state.operatingSystem != \"\" {\n\t\tout.OS = state.operatingSystem\n\t}\n\n\treturn out\n}\n", "package dockerfile // import \"github.com/docker/docker/builder/dockerfile\"\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"runtime\"\n\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n\tcontainerpkg \"github.com/docker/docker/container\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\n// MockBackend implements the builder.Backend interface for unit testing\ntype MockBackend struct {\n\tcontainerCreateFunc func(config backend.ContainerCreateConfig) (container.CreateResponse, error)\n\tcommitFunc          func(backend.CommitConfig) (image.ID, error)\n\tgetImageFunc        func(string) (builder.Image, builder.ROLayer, error)\n\tmakeImageCacheFunc  func(cacheFrom []string) builder.ImageCache\n}\n\nfunc (m *MockBackend) ContainerAttachRaw(cID string, stdin io.ReadCloser, stdout, stderr io.Writer, stream bool, attached chan struct{}) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) ContainerCreateIgnoreImagesArgsEscaped(ctx context.Context, config backend.ContainerCreateConfig) (container.CreateResponse, error) {\n\tif m.containerCreateFunc != nil {\n\t\treturn m.containerCreateFunc(config)\n\t}\n\treturn container.CreateResponse{}, nil\n}\n\nfunc (m *MockBackend) ContainerRm(name string, config *backend.ContainerRmConfig) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) CommitBuildStep(ctx context.Context, c backend.CommitConfig) (image.ID, error) {\n\tif m.commitFunc != nil {\n\t\treturn m.commitFunc(c)\n\t}\n\treturn \"\", nil\n}\n\nfunc (m *MockBackend) ContainerStart(ctx context.Context, containerID string, hostConfig *container.HostConfig, checkpoint string, checkpointDir string) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) ContainerWait(ctx context.Context, containerID string, condition containerpkg.WaitCondition) (<-chan containerpkg.StateStatus, error) {\n\treturn nil, nil\n}\n\nfunc (m *MockBackend) ContainerCreateWorkdir(containerID string) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) CopyOnBuild(containerID string, destPath string, srcRoot string, srcPath string, decompress bool) error {\n\treturn nil\n}\n\nfunc (m *MockBackend) GetImageAndReleasableLayer(ctx context.Context, refOrID string, opts backend.GetImageAndLayerOptions) (builder.Image, builder.ROLayer, error) {\n\tif m.getImageFunc != nil {\n\t\treturn m.getImageFunc(refOrID)\n\t}\n\n\treturn &mockImage{id: \"theid\"}, &mockLayer{}, nil\n}\n\nfunc (m *MockBackend) MakeImageCache(ctx context.Context, cacheFrom []string) (builder.ImageCache, error) {\n\tif m.makeImageCacheFunc != nil {\n\t\treturn m.makeImageCacheFunc(cacheFrom), nil\n\t}\n\treturn nil, nil\n}\n\nfunc (m *MockBackend) CreateImage(ctx context.Context, config []byte, parent string, layerDigest digest.Digest) (builder.Image, error) {\n\treturn &mockImage{id: \"test\"}, nil\n}\n\ntype mockImage struct {\n\tid     string\n\tconfig *container.Config\n}\n\nfunc (i *mockImage) ImageID() string {\n\treturn i.id\n}\n\nfunc (i *mockImage) RunConfig() *container.Config {\n\treturn i.config\n}\n\nfunc (i *mockImage) OperatingSystem() string {\n\treturn runtime.GOOS\n}\n\nfunc (i *mockImage) MarshalJSON() ([]byte, error) {\n\ttype rawImage mockImage\n\treturn json.Marshal(rawImage(*i)) //nolint:staticcheck\n}\n\ntype mockImageCache struct {\n\tgetCacheFunc func(parentID string, cfg *container.Config) (string, error)\n}\n\nfunc (mic *mockImageCache) GetCache(parentID string, cfg *container.Config, _ ocispec.Platform) (string, error) {\n\tif mic.getCacheFunc != nil {\n\t\treturn mic.getCacheFunc(parentID, cfg)\n\t}\n\treturn \"\", nil\n}\n\ntype mockLayer struct{}\n\nfunc (l *mockLayer) ContentStoreDigest() digest.Digest {\n\treturn \"\"\n}\n\nfunc (l *mockLayer) Release() error {\n\treturn nil\n}\n\nfunc (l *mockLayer) NewRWLayer() (builder.RWLayer, error) {\n\treturn &mockRWLayer{}, nil\n}\n\nfunc (l *mockLayer) DiffID() layer.DiffID {\n\treturn \"abcdef\"\n}\n\ntype mockRWLayer struct{}\n\nfunc (l *mockRWLayer) Release() error {\n\treturn nil\n}\n\nfunc (l *mockRWLayer) Commit() (builder.ROLayer, error) {\n\treturn nil, nil\n}\n\nfunc (l *mockRWLayer) Root() string {\n\treturn \"\"\n}\n", "package containerd\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/image/cache\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\n// MakeImageCache creates a stateful image cache.\nfunc (i *ImageService) MakeImageCache(ctx context.Context, cacheFrom []string) (builder.ImageCache, error) {\n\timages := []*image.Image{}\n\tif len(cacheFrom) == 0 {\n\t\treturn &localCache{\n\t\t\timageService: i,\n\t\t}, nil\n\t}\n\n\tfor _, c := range cacheFrom {\n\t\th, err := i.ImageHistory(ctx, c)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, hi := range h {\n\t\t\tif hi.ID != \"<missing>\" {\n\t\t\t\tim, err := i.GetImage(ctx, hi.ID, backend.GetImageOpts{})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\timages = append(images, im)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &imageCache{\n\t\tlc: &localCache{\n\t\t\timageService: i,\n\t\t},\n\t\timages:       images,\n\t\timageService: i,\n\t}, nil\n}\n\ntype localCache struct {\n\timageService *ImageService\n}\n\nfunc (ic *localCache) GetCache(parentID string, cfg *container.Config, platform ocispec.Platform) (imageID string, err error) {\n\tctx := context.TODO()\n\n\tvar children []image.ID\n\n\t// FROM scratch\n\tif parentID == \"\" {\n\t\tc, err := ic.imageService.getImagesWithLabel(ctx, imageLabelClassicBuilderFromScratch, \"1\")\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tchildren = c\n\t} else {\n\t\tc, err := ic.imageService.Children(ctx, image.ID(parentID))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tchildren = c\n\t}\n\n\tvar match *image.Image\n\tfor _, child := range children {\n\t\tccDigestStr, err := ic.imageService.getImageLabelByDigest(ctx, child.Digest(), imageLabelClassicBuilderContainerConfig)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif ccDigestStr == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tdgst, err := digest.Parse(ccDigestStr)\n\t\tif err != nil {\n\t\t\tlog.G(ctx).WithError(err).Warnf(\"invalid container config digest: %q\", ccDigestStr)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar cc container.Config\n\t\tif err := readConfig(ctx, ic.imageService.content, ocispec.Descriptor{Digest: dgst}, &cc); err != nil {\n\t\t\tif errdefs.IsNotFound(err) {\n\t\t\t\tlog.G(ctx).WithError(err).WithField(\"image\", child).Warnf(\"missing container config: %q\", ccDigestStr)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tif cache.CompareConfig(&cc, cfg) {\n\t\t\tchildImage, err := ic.imageService.GetImage(ctx, child.String(), backend.GetImageOpts{Platform: &platform})\n\t\t\tif err != nil {\n\t\t\t\tif errdefs.IsNotFound(err) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tif childImage.Created != nil && (match == nil || match.Created.Before(*childImage.Created)) {\n\t\t\t\tmatch = childImage\n\t\t\t}\n\t\t}\n\t}\n\n\tif match == nil {\n\t\treturn \"\", nil\n\t}\n\n\treturn match.ID().String(), nil\n}\n\ntype imageCache struct {\n\timages       []*image.Image\n\timageService *ImageService\n\tlc           *localCache\n}\n\nfunc (ic *imageCache) GetCache(parentID string, cfg *container.Config, platform ocispec.Platform) (imageID string, err error) {\n\tctx := context.TODO()\n\n\timgID, err := ic.lc.GetCache(parentID, cfg, platform)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif imgID != \"\" {\n\t\tfor _, s := range ic.images {\n\t\t\tif ic.isParent(ctx, s, image.ID(imgID)) {\n\t\t\t\treturn imgID, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tvar parent *image.Image\n\tlenHistory := 0\n\n\tif parentID != \"\" {\n\t\tparent, err = ic.imageService.GetImage(ctx, parentID, backend.GetImageOpts{Platform: &platform})\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tlenHistory = len(parent.History)\n\t}\n\tfor _, target := range ic.images {\n\t\tif !isValidParent(target, parent) || !isValidConfig(cfg, target.History[lenHistory]) {\n\t\t\tcontinue\n\t\t}\n\t\treturn target.ID().String(), nil\n\t}\n\n\treturn \"\", nil\n}\n\nfunc isValidConfig(cfg *container.Config, h image.History) bool {\n\t// todo: make this format better than join that loses data\n\treturn strings.Join(cfg.Cmd, \" \") == h.CreatedBy\n}\n\nfunc isValidParent(img, parent *image.Image) bool {\n\tif len(img.History) == 0 {\n\t\treturn false\n\t}\n\tif parent == nil || len(parent.History) == 0 && len(parent.RootFS.DiffIDs) == 0 {\n\t\treturn true\n\t}\n\tif len(parent.History) >= len(img.History) {\n\t\treturn false\n\t}\n\tif len(parent.RootFS.DiffIDs) > len(img.RootFS.DiffIDs) {\n\t\treturn false\n\t}\n\n\tfor i, h := range parent.History {\n\t\tif !reflect.DeepEqual(h, img.History[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, d := range parent.RootFS.DiffIDs {\n\t\tif d != img.RootFS.DiffIDs[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (ic *imageCache) isParent(ctx context.Context, img *image.Image, parentID image.ID) bool {\n\tii, err := ic.imageService.resolveImage(ctx, img.ImageID())\n\tif err != nil {\n\t\treturn false\n\t}\n\tparent, ok := ii.Labels[imageLabelClassicBuilderParent]\n\tif ok {\n\t\treturn parent == parentID.String()\n\t}\n\n\tp, err := ic.imageService.GetImage(ctx, parentID.String(), backend.GetImageOpts{})\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn ic.isParent(ctx, p, parentID)\n}\n", "package images // import \"github.com/docker/docker/daemon/images\"\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"runtime\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/log\"\n\t\"github.com/distribution/reference\"\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/api/types/registry\"\n\t\"github.com/docker/docker/builder\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/docker/docker/pkg/progress\"\n\t\"github.com/docker/docker/pkg/streamformatter\"\n\t\"github.com/docker/docker/pkg/stringid\"\n\tregistrypkg \"github.com/docker/docker/registry\"\n\t\"github.com/opencontainers/go-digest\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\ntype roLayer struct {\n\treleased   bool\n\tlayerStore layer.Store\n\troLayer    layer.Layer\n}\n\nfunc (l *roLayer) ContentStoreDigest() digest.Digest {\n\treturn \"\"\n}\n\nfunc (l *roLayer) DiffID() layer.DiffID {\n\tif l.roLayer == nil {\n\t\treturn layer.DigestSHA256EmptyTar\n\t}\n\treturn l.roLayer.DiffID()\n}\n\nfunc (l *roLayer) Release() error {\n\tif l.released {\n\t\treturn nil\n\t}\n\tif l.roLayer != nil {\n\t\tmetadata, err := l.layerStore.Release(l.roLayer)\n\t\tlayer.LogReleaseMetadata(metadata)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to release ROLayer\")\n\t\t}\n\t}\n\tl.roLayer = nil\n\tl.released = true\n\treturn nil\n}\n\nfunc (l *roLayer) NewRWLayer() (builder.RWLayer, error) {\n\tvar chainID layer.ChainID\n\tif l.roLayer != nil {\n\t\tchainID = l.roLayer.ChainID()\n\t}\n\n\tmountID := stringid.GenerateRandomID()\n\tnewLayer, err := l.layerStore.CreateRWLayer(mountID, chainID, nil)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to create rwlayer\")\n\t}\n\n\trwLayer := &rwLayer{layerStore: l.layerStore, rwLayer: newLayer}\n\n\tfs, err := newLayer.Mount(\"\")\n\tif err != nil {\n\t\trwLayer.Release()\n\t\treturn nil, err\n\t}\n\n\trwLayer.fs = fs\n\n\treturn rwLayer, nil\n}\n\ntype rwLayer struct {\n\treleased   bool\n\tlayerStore layer.Store\n\trwLayer    layer.RWLayer\n\tfs         string\n}\n\nfunc (l *rwLayer) Root() string {\n\treturn l.fs\n}\n\nfunc (l *rwLayer) Commit() (builder.ROLayer, error) {\n\tstream, err := l.rwLayer.TarStream()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stream.Close()\n\n\tvar chainID layer.ChainID\n\tif parent := l.rwLayer.Parent(); parent != nil {\n\t\tchainID = parent.ChainID()\n\t}\n\n\tnewLayer, err := l.layerStore.Register(stream, chainID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// TODO: An optimization would be to handle empty layers before returning\n\treturn &roLayer{layerStore: l.layerStore, roLayer: newLayer}, nil\n}\n\nfunc (l *rwLayer) Release() error {\n\tif l.released {\n\t\treturn nil\n\t}\n\n\tif l.fs != \"\" {\n\t\tif err := l.rwLayer.Unmount(); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to unmount RWLayer\")\n\t\t}\n\t\tl.fs = \"\"\n\t}\n\n\tmetadata, err := l.layerStore.ReleaseRWLayer(l.rwLayer)\n\tlayer.LogReleaseMetadata(metadata)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to release RWLayer\")\n\t}\n\tl.released = true\n\treturn nil\n}\n\nfunc newROLayerForImage(img *image.Image, layerStore layer.Store) (builder.ROLayer, error) {\n\tif img == nil || img.RootFS.ChainID() == \"\" {\n\t\treturn &roLayer{layerStore: layerStore}, nil\n\t}\n\t// Hold a reference to the image layer so that it can't be removed before\n\t// it is released\n\tlyr, err := layerStore.Get(img.RootFS.ChainID())\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to get layer for image %s\", img.ImageID())\n\t}\n\treturn &roLayer{layerStore: layerStore, roLayer: lyr}, nil\n}\n\n// TODO: could this use the regular daemon PullImage ?\nfunc (i *ImageService) pullForBuilder(ctx context.Context, name string, authConfigs map[string]registry.AuthConfig, output io.Writer, platform *ocispec.Platform) (*image.Image, error) {\n\tref, err := reference.ParseNormalizedNamed(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tref = reference.TagNameOnly(ref)\n\n\tpullRegistryAuth := &registry.AuthConfig{}\n\tif len(authConfigs) > 0 {\n\t\t// The request came with a full auth config, use it\n\t\trepoInfo, err := i.registryService.ResolveRepository(ref)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresolvedConfig := registrypkg.ResolveAuthConfig(authConfigs, repoInfo.Index)\n\t\tpullRegistryAuth = &resolvedConfig\n\t}\n\n\tif err := i.pullImageWithReference(ctx, ref, platform, nil, pullRegistryAuth, output); err != nil {\n\t\treturn nil, err\n\t}\n\n\timg, err := i.GetImage(ctx, name, backend.GetImageOpts{Platform: platform})\n\tif errdefs.IsNotFound(err) && img != nil && platform != nil {\n\t\timgPlat := ocispec.Platform{\n\t\t\tOS:           img.OS,\n\t\t\tArchitecture: img.BaseImgArch(),\n\t\t\tVariant:      img.BaseImgVariant(),\n\t\t}\n\n\t\tp := *platform\n\t\tif !platforms.Only(p).Match(imgPlat) {\n\t\t\tpo := streamformatter.NewJSONProgressOutput(output, false)\n\t\t\tprogress.Messagef(po, \"\", `\nWARNING: Pulled image with specified platform (%s), but the resulting image's configured platform (%s) does not match.\nThis is most likely caused by a bug in the build system that created the fetched image (%s).\nPlease notify the image author to correct the configuration.`,\n\t\t\t\tplatforms.Format(p), platforms.Format(imgPlat), name,\n\t\t\t)\n\t\t\tlog.G(ctx).WithError(err).WithField(\"image\", name).Warn(\"Ignoring error about platform mismatch where the manifest list points to an image whose configuration does not match the platform in the manifest.\")\n\t\t\terr = nil\n\t\t}\n\t}\n\treturn img, err\n}\n\n// GetImageAndReleasableLayer returns an image and releaseable layer for a reference or ID.\n// Every call to GetImageAndReleasableLayer MUST call releasableLayer.Release() to prevent\n// leaking of layers.\nfunc (i *ImageService) GetImageAndReleasableLayer(ctx context.Context, refOrID string, opts backend.GetImageAndLayerOptions) (builder.Image, builder.ROLayer, error) {\n\tif refOrID == \"\" { // FROM scratch\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\treturn nil, nil, fmt.Errorf(`\"FROM scratch\" is not supported on Windows`)\n\t\t}\n\t\tif opts.Platform != nil {\n\t\t\tif err := image.CheckOS(opts.Platform.OS); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\t\tlyr, err := newROLayerForImage(nil, i.layerStore)\n\t\treturn nil, lyr, err\n\t}\n\n\tif opts.PullOption != backend.PullOptionForcePull {\n\t\timg, err := i.GetImage(ctx, refOrID, backend.GetImageOpts{Platform: opts.Platform})\n\t\tif err != nil && opts.PullOption == backend.PullOptionNoPull {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif err != nil && !errdefs.IsNotFound(err) {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif img != nil {\n\t\t\tif err := image.CheckOS(img.OperatingSystem()); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tlyr, err := newROLayerForImage(img, i.layerStore)\n\t\t\treturn img, lyr, err\n\t\t}\n\t}\n\n\timg, err := i.pullForBuilder(ctx, refOrID, opts.AuthConfig, opts.Output, opts.Platform)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif err := image.CheckOS(img.OperatingSystem()); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlyr, err := newROLayerForImage(img, i.layerStore)\n\treturn img, lyr, err\n}\n\n// CreateImage creates a new image by adding a config and ID to the image store.\n// This is similar to LoadImage() except that it receives JSON encoded bytes of\n// an image instead of a tar archive.\nfunc (i *ImageService) CreateImage(ctx context.Context, config []byte, parent string, _ digest.Digest) (builder.Image, error) {\n\tid, err := i.imageStore.Create(config)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to create image\")\n\t}\n\n\tif parent != \"\" {\n\t\tif err := i.imageStore.SetParent(id, image.ID(parent)); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"failed to set parent %s\", parent)\n\t\t}\n\t}\n\tif err := i.imageStore.SetBuiltLocally(id); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to mark image %s as built locally\", id)\n\t}\n\n\treturn i.imageStore.Get(id)\n}\n", "package images // import \"github.com/docker/docker/daemon/images\"\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\n\t\"github.com/docker/docker/api/types/backend\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/docker/docker/pkg/ioutils\"\n\t\"github.com/pkg/errors\"\n)\n\n// CommitImage creates a new image from a commit config\nfunc (i *ImageService) CommitImage(ctx context.Context, c backend.CommitConfig) (image.ID, error) {\n\tif err := ctx.Err(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\trwTar, err := exportContainerRw(i.layerStore, c.ContainerID, c.ContainerMountLabel)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() {\n\t\tif rwTar != nil {\n\t\t\trwTar.Close()\n\t\t}\n\t}()\n\n\tvar parent *image.Image\n\tif c.ParentImageID == \"\" {\n\t\tparent = new(image.Image)\n\t\tparent.RootFS = image.NewRootFS()\n\t} else {\n\t\tparent, err = i.imageStore.Get(image.ID(c.ParentImageID))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tl, err := i.layerStore.Register(rwTar, parent.RootFS.ChainID())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer layer.ReleaseAndLog(i.layerStore, l)\n\n\tcc := image.ChildConfig{\n\t\tContainerID:     c.ContainerID,\n\t\tAuthor:          c.Author,\n\t\tComment:         c.Comment,\n\t\tContainerConfig: c.ContainerConfig,\n\t\tConfig:          c.Config,\n\t\tDiffID:          l.DiffID(),\n\t}\n\tconfig, err := json.Marshal(image.NewChildImage(parent, cc, c.ContainerOS))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tid, err := i.imageStore.Create(config)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := i.imageStore.SetBuiltLocally(id); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif c.ParentImageID != \"\" {\n\t\tif err := i.imageStore.SetParent(id, image.ID(c.ParentImageID)); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn id, nil\n}\n\nfunc exportContainerRw(layerStore layer.Store, id, mountLabel string) (arch io.ReadCloser, err error) {\n\trwlayer, err := layerStore.GetRWLayer(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tlayerStore.ReleaseRWLayer(rwlayer)\n\t\t}\n\t}()\n\n\t// TODO: this mount call is not necessary as we assume that TarStream() should\n\t// mount the layer if needed. But the Diff() function for windows requests that\n\t// the layer should be mounted when calling it. So we reserve this mount call\n\t// until windows driver can implement Diff() interface correctly.\n\t_, err = rwlayer.Mount(mountLabel)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tarchive, err := rwlayer.TarStream()\n\tif err != nil {\n\t\trwlayer.Unmount()\n\t\treturn nil, err\n\t}\n\treturn ioutils.NewReadCloserWrapper(archive, func() error {\n\t\t\tarchive.Close()\n\t\t\terr = rwlayer.Unmount()\n\t\t\tlayerStore.ReleaseRWLayer(rwlayer)\n\t\t\treturn err\n\t\t}),\n\t\tnil\n}\n\n// CommitBuildStep is used by the builder to create an image for each step in\n// the build.\n//\n// This method is different from CreateImageFromContainer:\n//   - it doesn't attempt to validate container state\n//   - it doesn't send a commit action to metrics\n//   - it doesn't log a container commit event\n//\n// This is a temporary shim. Should be removed when builder stops using commit.\nfunc (i *ImageService) CommitBuildStep(ctx context.Context, c backend.CommitConfig) (image.ID, error) {\n\tctr := i.containers.Get(c.ContainerID)\n\tif ctr == nil {\n\t\t// TODO: use typed error\n\t\treturn \"\", errors.Errorf(\"container not found: %s\", c.ContainerID)\n\t}\n\tc.ContainerMountLabel = ctr.MountLabel\n\tc.ContainerOS = ctr.OS\n\tc.ParentImageID = string(ctr.ImageID)\n\treturn i.CommitImage(ctx, c)\n}\n", "package cache // import \"github.com/docker/docker/image/cache\"\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/log\"\n\tcontainertypes \"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/dockerversion\"\n\t\"github.com/docker/docker/image\"\n\t\"github.com/docker/docker/layer\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/pkg/errors\"\n)\n\n// NewLocal returns a local image cache, based on parent chain\nfunc NewLocal(store image.Store) *LocalImageCache {\n\treturn &LocalImageCache{\n\t\tstore: store,\n\t}\n}\n\n// LocalImageCache is cache based on parent chain.\ntype LocalImageCache struct {\n\tstore image.Store\n}\n\n// GetCache returns the image id found in the cache\nfunc (lic *LocalImageCache) GetCache(imgID string, config *containertypes.Config, platform ocispec.Platform) (string, error) {\n\treturn getImageIDAndError(getLocalCachedImage(lic.store, image.ID(imgID), config, platform))\n}\n\n// New returns an image cache, based on history objects\nfunc New(store image.Store) *ImageCache {\n\treturn &ImageCache{\n\t\tstore:           store,\n\t\tlocalImageCache: NewLocal(store),\n\t}\n}\n\n// ImageCache is cache based on history objects. Requires initial set of images.\ntype ImageCache struct {\n\tsources         []*image.Image\n\tstore           image.Store\n\tlocalImageCache *LocalImageCache\n}\n\n// Populate adds an image to the cache (to be queried later)\nfunc (ic *ImageCache) Populate(image *image.Image) {\n\tic.sources = append(ic.sources, image)\n}\n\n// GetCache returns the image id found in the cache\nfunc (ic *ImageCache) GetCache(parentID string, cfg *containertypes.Config, platform ocispec.Platform) (string, error) {\n\timgID, err := ic.localImageCache.GetCache(parentID, cfg, platform)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif imgID != \"\" {\n\t\tfor _, s := range ic.sources {\n\t\t\tif ic.isParent(s.ID(), image.ID(imgID)) {\n\t\t\t\treturn imgID, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tvar parent *image.Image\n\tlenHistory := 0\n\tif parentID != \"\" {\n\t\tparent, err = ic.store.Get(image.ID(parentID))\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"unable to find image %v\", parentID)\n\t\t}\n\t\tlenHistory = len(parent.History)\n\t}\n\n\tfor _, target := range ic.sources {\n\t\tif !isValidParent(target, parent) || !isValidConfig(cfg, target.History[lenHistory]) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(target.History)-1 == lenHistory { // last\n\t\t\tif parent != nil {\n\t\t\t\tif err := ic.store.SetParent(target.ID(), parent.ID()); err != nil {\n\t\t\t\t\treturn \"\", errors.Wrapf(err, \"failed to set parent for %v to %v\", target.ID(), parent.ID())\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target.ID().String(), nil\n\t\t}\n\n\t\timgID, err := ic.restoreCachedImage(parent, target, cfg)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"failed to restore cached image from %q to %v\", parentID, target.ID())\n\t\t}\n\n\t\tic.sources = []*image.Image{target} // avoid jumping to different target, tuned for safety atm\n\t\treturn imgID.String(), nil\n\t}\n\n\treturn \"\", nil\n}\n\nfunc (ic *ImageCache) restoreCachedImage(parent, target *image.Image, cfg *containertypes.Config) (image.ID, error) {\n\tvar history []image.History\n\trootFS := image.NewRootFS()\n\tlenHistory := 0\n\tif parent != nil {\n\t\thistory = parent.History\n\t\trootFS = parent.RootFS\n\t\tlenHistory = len(parent.History)\n\t}\n\thistory = append(history, target.History[lenHistory])\n\tif layer := getLayerForHistoryIndex(target, lenHistory); layer != \"\" {\n\t\trootFS.Append(layer)\n\t}\n\n\tconfig, err := json.Marshal(&image.Image{\n\t\tV1Image: image.V1Image{\n\t\t\tDockerVersion: dockerversion.Version,\n\t\t\tConfig:        cfg,\n\t\t\tArchitecture:  target.Architecture,\n\t\t\tOS:            target.OS,\n\t\t\tAuthor:        target.Author,\n\t\t\tCreated:       history[len(history)-1].Created,\n\t\t},\n\t\tRootFS:     rootFS,\n\t\tHistory:    history,\n\t\tOSFeatures: target.OSFeatures,\n\t\tOSVersion:  target.OSVersion,\n\t})\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"failed to marshal image config\")\n\t}\n\n\timgID, err := ic.store.Create(config)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"failed to create cache image\")\n\t}\n\n\tif parent != nil {\n\t\tif err := ic.store.SetParent(imgID, parent.ID()); err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"failed to set parent for %v to %v\", target.ID(), parent.ID())\n\t\t}\n\t}\n\treturn imgID, nil\n}\n\nfunc (ic *ImageCache) isParent(imgID, parentID image.ID) bool {\n\tnextParent, err := ic.store.GetParent(imgID)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif nextParent == parentID {\n\t\treturn true\n\t}\n\treturn ic.isParent(nextParent, parentID)\n}\n\nfunc getLayerForHistoryIndex(image *image.Image, index int) layer.DiffID {\n\tlayerIndex := 0\n\tfor i, h := range image.History {\n\t\tif i == index {\n\t\t\tif h.EmptyLayer {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif !h.EmptyLayer {\n\t\t\tlayerIndex++\n\t\t}\n\t}\n\treturn image.RootFS.DiffIDs[layerIndex] // validate?\n}\n\nfunc isValidConfig(cfg *containertypes.Config, h image.History) bool {\n\t// todo: make this format better than join that loses data\n\treturn strings.Join(cfg.Cmd, \" \") == h.CreatedBy\n}\n\nfunc isValidParent(img, parent *image.Image) bool {\n\tif len(img.History) == 0 {\n\t\treturn false\n\t}\n\tif parent == nil || len(parent.History) == 0 && len(parent.RootFS.DiffIDs) == 0 {\n\t\treturn true\n\t}\n\tif len(parent.History) >= len(img.History) {\n\t\treturn false\n\t}\n\tif len(parent.RootFS.DiffIDs) > len(img.RootFS.DiffIDs) {\n\t\treturn false\n\t}\n\n\tfor i, h := range parent.History {\n\t\tif !reflect.DeepEqual(h, img.History[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, d := range parent.RootFS.DiffIDs {\n\t\tif d != img.RootFS.DiffIDs[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc getImageIDAndError(img *image.Image, err error) (string, error) {\n\tif img == nil || err != nil {\n\t\treturn \"\", err\n\t}\n\treturn img.ID().String(), nil\n}\n\n// getLocalCachedImage returns the most recent created image that is a child\n// of the image with imgID, that had the same config when it was\n// created. nil is returned if a child cannot be found. An error is\n// returned if the parent image cannot be found.\nfunc getLocalCachedImage(imageStore image.Store, imgID image.ID, config *containertypes.Config, platform ocispec.Platform) (*image.Image, error) {\n\tif config == nil {\n\t\treturn nil, nil\n\t}\n\n\tisBuiltLocally := func(id image.ID) bool {\n\t\tbuiltLocally, err := imageStore.IsBuiltLocally(id)\n\t\tif err != nil {\n\t\t\tlog.G(context.TODO()).WithFields(log.Fields{\n\t\t\t\t\"error\": err,\n\t\t\t\t\"id\":    id,\n\t\t\t}).Warn(\"failed to check if image was built locally\")\n\t\t\treturn false\n\t\t}\n\t\treturn builtLocally\n\t}\n\n\t// Loop on the children of the given image and check the config\n\tgetMatch := func(siblings []image.ID) (*image.Image, error) {\n\t\tvar match *image.Image\n\t\tfor _, id := range siblings {\n\t\t\timg, err := imageStore.Get(id)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to find image %q\", id)\n\t\t\t}\n\n\t\t\tif !isBuiltLocally(id) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\timgPlatform := img.Platform()\n\t\t\t// Discard old linux/amd64 images with empty platform.\n\t\t\tif imgPlatform.OS == \"\" && imgPlatform.Architecture == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !platforms.OnlyStrict(platform).Match(imgPlatform) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif compare(&img.ContainerConfig, config) {\n\t\t\t\t// check for the most up to date match\n\t\t\t\tif img.Created != nil && (match == nil || match.Created.Before(*img.Created)) {\n\t\t\t\t\tmatch = img\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn match, nil\n\t}\n\n\t// In this case, this is `FROM scratch`, which isn't an actual image.\n\tif imgID == \"\" {\n\t\timages := imageStore.Map()\n\n\t\tvar siblings []image.ID\n\t\tfor id, img := range images {\n\t\t\tif img.Parent != \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !isBuiltLocally(id) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Do a quick initial filter on the Cmd to avoid adding all\n\t\t\t// non-local images with empty parent to the siblings slice and\n\t\t\t// performing a full config compare.\n\t\t\t//\n\t\t\t// config.Cmd is set to the current Dockerfile instruction so we\n\t\t\t// check it against the img.ContainerConfig.Cmd which is the\n\t\t\t// command of the last layer.\n\t\t\tif !strSliceEqual(img.ContainerConfig.Cmd, config.Cmd) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsiblings = append(siblings, id)\n\t\t}\n\t\treturn getMatch(siblings)\n\t}\n\n\t// find match from child images\n\tsiblings := imageStore.Children(imgID)\n\treturn getMatch(siblings)\n}\n\nfunc strSliceEqual(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "package cache // import \"github.com/docker/docker/image/cache\"\n\nimport (\n\t\"github.com/docker/docker/api/types/container\"\n)\n\n// TODO: Remove once containerd image service directly uses the ImageCache and\n// LocalImageCache structs.\nfunc CompareConfig(a, b *container.Config) bool {\n\treturn compare(a, b)\n}\n\n// compare two Config struct. Do not container-specific fields:\n// - Image\n// - Hostname\n// - Domainname\n// - MacAddress\nfunc compare(a, b *container.Config) bool {\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\n\tif len(a.Env) != len(b.Env) {\n\t\treturn false\n\t}\n\tif len(a.Cmd) != len(b.Cmd) {\n\t\treturn false\n\t}\n\tif len(a.Entrypoint) != len(b.Entrypoint) {\n\t\treturn false\n\t}\n\tif len(a.Shell) != len(b.Shell) {\n\t\treturn false\n\t}\n\tif len(a.ExposedPorts) != len(b.ExposedPorts) {\n\t\treturn false\n\t}\n\tif len(a.Volumes) != len(b.Volumes) {\n\t\treturn false\n\t}\n\tif len(a.Labels) != len(b.Labels) {\n\t\treturn false\n\t}\n\tif len(a.OnBuild) != len(b.OnBuild) {\n\t\treturn false\n\t}\n\n\tfor i := 0; i < len(a.Env); i++ {\n\t\tif a.Env[i] != b.Env[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := 0; i < len(a.OnBuild); i++ {\n\t\tif a.OnBuild[i] != b.OnBuild[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := 0; i < len(a.Cmd); i++ {\n\t\tif a.Cmd[i] != b.Cmd[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := 0; i < len(a.Entrypoint); i++ {\n\t\tif a.Entrypoint[i] != b.Entrypoint[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i := 0; i < len(a.Shell); i++ {\n\t\tif a.Shell[i] != b.Shell[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor k := range a.ExposedPorts {\n\t\tif _, exists := b.ExposedPorts[k]; !exists {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor key := range a.Volumes {\n\t\tif _, exists := b.Volumes[key]; !exists {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor k, v := range a.Labels {\n\t\tif v != b.Labels[k] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif a.AttachStdin != b.AttachStdin {\n\t\treturn false\n\t}\n\tif a.AttachStdout != b.AttachStdout {\n\t\treturn false\n\t}\n\tif a.AttachStderr != b.AttachStderr {\n\t\treturn false\n\t}\n\tif a.NetworkDisabled != b.NetworkDisabled {\n\t\treturn false\n\t}\n\tif a.Tty != b.Tty {\n\t\treturn false\n\t}\n\tif a.OpenStdin != b.OpenStdin {\n\t\treturn false\n\t}\n\tif a.StdinOnce != b.StdinOnce {\n\t\treturn false\n\t}\n\tif a.ArgsEscaped != b.ArgsEscaped {\n\t\treturn false\n\t}\n\tif a.User != b.User {\n\t\treturn false\n\t}\n\tif a.WorkingDir != b.WorkingDir {\n\t\treturn false\n\t}\n\tif a.StopSignal != b.StopSignal {\n\t\treturn false\n\t}\n\n\tif (a.StopTimeout == nil) != (b.StopTimeout == nil) {\n\t\treturn false\n\t}\n\tif a.StopTimeout != nil && b.StopTimeout != nil {\n\t\tif *a.StopTimeout != *b.StopTimeout {\n\t\t\treturn false\n\t\t}\n\t}\n\tif (a.Healthcheck == nil) != (b.Healthcheck == nil) {\n\t\treturn false\n\t}\n\tif a.Healthcheck != nil && b.Healthcheck != nil {\n\t\tif a.Healthcheck.Interval != b.Healthcheck.Interval {\n\t\t\treturn false\n\t\t}\n\t\tif a.Healthcheck.StartInterval != b.Healthcheck.StartInterval {\n\t\t\treturn false\n\t\t}\n\t\tif a.Healthcheck.StartPeriod != b.Healthcheck.StartPeriod {\n\t\t\treturn false\n\t\t}\n\t\tif a.Healthcheck.Timeout != b.Healthcheck.Timeout {\n\t\t\treturn false\n\t\t}\n\t\tif a.Healthcheck.Retries != b.Healthcheck.Retries {\n\t\t\treturn false\n\t\t}\n\t\tif len(a.Healthcheck.Test) != len(b.Healthcheck.Test) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i < len(a.Healthcheck.Test); i++ {\n\t\t\tif a.Healthcheck.Test[i] != b.Healthcheck.Test[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n", "package image // import \"github.com/docker/docker/image\"\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/containerd/log\"\n\t\"github.com/docker/docker/errdefs\"\n\t\"github.com/docker/docker/layer\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/go-digest/digestset\"\n\t\"github.com/pkg/errors\"\n)\n\n// Store is an interface for creating and accessing images\ntype Store interface {\n\tCreate(config []byte) (ID, error)\n\tGet(id ID) (*Image, error)\n\tDelete(id ID) ([]layer.Metadata, error)\n\tSearch(partialID string) (ID, error)\n\tSetParent(id ID, parent ID) error\n\tGetParent(id ID) (ID, error)\n\tSetLastUpdated(id ID) error\n\tGetLastUpdated(id ID) (time.Time, error)\n\tSetBuiltLocally(id ID) error\n\tIsBuiltLocally(id ID) (bool, error)\n\tChildren(id ID) []ID\n\tMap() map[ID]*Image\n\tHeads() map[ID]*Image\n\tLen() int\n}\n\n// LayerGetReleaser is a minimal interface for getting and releasing images.\ntype LayerGetReleaser interface {\n\tGet(layer.ChainID) (layer.Layer, error)\n\tRelease(layer.Layer) ([]layer.Metadata, error)\n}\n\ntype imageMeta struct {\n\tlayer    layer.Layer\n\tchildren map[ID]struct{}\n}\n\ntype store struct {\n\tsync.RWMutex\n\tlss       LayerGetReleaser\n\timages    map[ID]*imageMeta\n\tfs        StoreBackend\n\tdigestSet *digestset.Set\n}\n\n// NewImageStore returns new store object for given set of layer stores\nfunc NewImageStore(fs StoreBackend, lss LayerGetReleaser) (Store, error) {\n\tis := &store{\n\t\tlss:       lss,\n\t\timages:    make(map[ID]*imageMeta),\n\t\tfs:        fs,\n\t\tdigestSet: digestset.NewSet(),\n\t}\n\n\t// load all current images and retain layers\n\tif err := is.restore(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn is, nil\n}\n\nfunc (is *store) restore() error {\n\t// As the code below is run when restoring all images (which can be \"many\"),\n\t// constructing the \"log.G(ctx).WithFields\" is deliberately not \"DRY\", as the\n\t// logger is only used for error-cases, and we don't want to do allocations\n\t// if we don't need it. The \"f\" type alias is here is just for convenience,\n\t// and to make the code _slightly_ more DRY. See the discussion on GitHub;\n\t// https://github.com/moby/moby/pull/44426#discussion_r1059519071\n\ttype f = log.Fields\n\terr := is.fs.Walk(func(dgst digest.Digest) error {\n\t\timg, err := is.Get(ID(dgst))\n\t\tif err != nil {\n\t\t\tlog.G(context.TODO()).WithFields(f{\"digest\": dgst, \"err\": err}).Error(\"invalid image\")\n\t\t\treturn nil\n\t\t}\n\t\tvar l layer.Layer\n\t\tif chainID := img.RootFS.ChainID(); chainID != \"\" {\n\t\t\tif err := CheckOS(img.OperatingSystem()); err != nil {\n\t\t\t\tlog.G(context.TODO()).WithFields(f{\"chainID\": chainID, \"os\": img.OperatingSystem()}).Error(\"not restoring image with unsupported operating system\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tl, err = is.lss.Get(chainID)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, layer.ErrLayerDoesNotExist) {\n\t\t\t\t\tlog.G(context.TODO()).WithFields(f{\"chainID\": chainID, \"os\": img.OperatingSystem(), \"err\": err}).Error(\"not restoring image\")\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := is.digestSet.Add(dgst); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tis.images[ID(dgst)] = &imageMeta{\n\t\t\tlayer:    l,\n\t\t\tchildren: make(map[ID]struct{}),\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Second pass to fill in children maps\n\tfor id := range is.images {\n\t\tif parent, err := is.GetParent(id); err == nil {\n\t\t\tif parentMeta := is.images[parent]; parentMeta != nil {\n\t\t\t\tparentMeta.children[id] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (is *store) Create(config []byte) (ID, error) {\n\tvar img *Image\n\timg, err := NewFromJSON(config)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Must reject any config that references diffIDs from the history\n\t// which aren't among the rootfs layers.\n\trootFSLayers := make(map[layer.DiffID]struct{})\n\tfor _, diffID := range img.RootFS.DiffIDs {\n\t\trootFSLayers[diffID] = struct{}{}\n\t}\n\n\tlayerCounter := 0\n\tfor _, h := range img.History {\n\t\tif !h.EmptyLayer {\n\t\t\tlayerCounter++\n\t\t}\n\t}\n\tif layerCounter > len(img.RootFS.DiffIDs) {\n\t\treturn \"\", errdefs.InvalidParameter(errors.New(\"too many non-empty layers in History section\"))\n\t}\n\n\timageDigest, err := is.fs.Set(config)\n\tif err != nil {\n\t\treturn \"\", errdefs.InvalidParameter(err)\n\t}\n\n\tis.Lock()\n\tdefer is.Unlock()\n\n\timageID := ID(imageDigest)\n\tif _, exists := is.images[imageID]; exists {\n\t\treturn imageID, nil\n\t}\n\n\tlayerID := img.RootFS.ChainID()\n\n\tvar l layer.Layer\n\tif layerID != \"\" {\n\t\tif err := CheckOS(img.OperatingSystem()); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tl, err = is.lss.Get(layerID)\n\t\tif err != nil {\n\t\t\treturn \"\", errdefs.InvalidParameter(errors.Wrapf(err, \"failed to get layer %s\", layerID))\n\t\t}\n\t}\n\n\tis.images[imageID] = &imageMeta{\n\t\tlayer:    l,\n\t\tchildren: make(map[ID]struct{}),\n\t}\n\n\tif err = is.digestSet.Add(imageDigest); err != nil {\n\t\tdelete(is.images, imageID)\n\t\treturn \"\", errdefs.InvalidParameter(err)\n\t}\n\n\treturn imageID, nil\n}\n\ntype imageNotFoundError string\n\nfunc (e imageNotFoundError) Error() string {\n\treturn \"No such image: \" + string(e)\n}\n\nfunc (imageNotFoundError) NotFound() {}\n\nfunc (is *store) Search(term string) (ID, error) {\n\tdgst, err := is.digestSet.Lookup(term)\n\tif err != nil {\n\t\tif err == digestset.ErrDigestNotFound {\n\t\t\terr = imageNotFoundError(term)\n\t\t}\n\t\treturn \"\", errors.WithStack(err)\n\t}\n\treturn ID(dgst), nil\n}\n\nfunc (is *store) Get(id ID) (*Image, error) {\n\t// todo: Check if image is in images\n\t// todo: Detect manual insertions and start using them\n\tconfig, err := is.fs.Get(id.Digest())\n\tif err != nil {\n\t\treturn nil, errdefs.NotFound(err)\n\t}\n\n\timg, err := NewFromJSON(config)\n\tif err != nil {\n\t\treturn nil, errdefs.InvalidParameter(err)\n\t}\n\timg.computedID = id\n\n\timg.Parent, err = is.GetParent(id)\n\tif err != nil {\n\t\timg.Parent = \"\"\n\t}\n\n\treturn img, nil\n}\n\nfunc (is *store) Delete(id ID) ([]layer.Metadata, error) {\n\tis.Lock()\n\tdefer is.Unlock()\n\n\timgMeta := is.images[id]\n\tif imgMeta == nil {\n\t\treturn nil, errdefs.NotFound(fmt.Errorf(\"unrecognized image ID %s\", id.String()))\n\t}\n\t_, err := is.Get(id)\n\tif err != nil {\n\t\treturn nil, errdefs.NotFound(fmt.Errorf(\"unrecognized image %s, %v\", id.String(), err))\n\t}\n\tfor cID := range imgMeta.children {\n\t\tis.fs.DeleteMetadata(cID.Digest(), \"parent\")\n\t}\n\tif parent, err := is.GetParent(id); err == nil && is.images[parent] != nil {\n\t\tdelete(is.images[parent].children, id)\n\t}\n\n\tif err := is.digestSet.Remove(id.Digest()); err != nil {\n\t\tlog.G(context.TODO()).Errorf(\"error removing %s from digest set: %q\", id, err)\n\t}\n\tdelete(is.images, id)\n\tis.fs.Delete(id.Digest())\n\n\tif imgMeta.layer != nil {\n\t\treturn is.lss.Release(imgMeta.layer)\n\t}\n\treturn nil, nil\n}\n\nfunc (is *store) SetParent(id, parentID ID) error {\n\tis.Lock()\n\tdefer is.Unlock()\n\tparentMeta := is.images[parentID]\n\tif parentMeta == nil {\n\t\treturn errdefs.NotFound(fmt.Errorf(\"unknown parent image ID %s\", parentID.String()))\n\t}\n\tif parent, err := is.GetParent(id); err == nil && is.images[parent] != nil {\n\t\tdelete(is.images[parent].children, id)\n\t}\n\tparentMeta.children[id] = struct{}{}\n\treturn is.fs.SetMetadata(id.Digest(), \"parent\", []byte(parentID))\n}\n\nfunc (is *store) GetParent(id ID) (ID, error) {\n\td, err := is.fs.GetMetadata(id.Digest(), \"parent\")\n\tif err != nil {\n\t\treturn \"\", errdefs.NotFound(err)\n\t}\n\treturn ID(d), nil // todo: validate?\n}\n\n// SetLastUpdated time for the image ID to the current time\nfunc (is *store) SetLastUpdated(id ID) error {\n\tlastUpdated := []byte(time.Now().Format(time.RFC3339Nano))\n\treturn is.fs.SetMetadata(id.Digest(), \"lastUpdated\", lastUpdated)\n}\n\n// GetLastUpdated time for the image ID\nfunc (is *store) GetLastUpdated(id ID) (time.Time, error) {\n\tbytes, err := is.fs.GetMetadata(id.Digest(), \"lastUpdated\")\n\tif err != nil || len(bytes) == 0 {\n\t\t// No lastUpdated time\n\t\treturn time.Time{}, nil\n\t}\n\treturn time.Parse(time.RFC3339Nano, string(bytes))\n}\n\n// SetBuiltLocally sets whether image can be used as a builder cache\nfunc (is *store) SetBuiltLocally(id ID) error {\n\treturn is.fs.SetMetadata(id.Digest(), \"builtLocally\", []byte{1})\n}\n\n// IsBuiltLocally returns whether image can be used as a builder cache\nfunc (is *store) IsBuiltLocally(id ID) (bool, error) {\n\tbytes, err := is.fs.GetMetadata(id.Digest(), \"builtLocally\")\n\tif err != nil || len(bytes) == 0 {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\terr = nil\n\t\t}\n\t\treturn false, err\n\t}\n\treturn bytes[0] == 1, nil\n}\n\nfunc (is *store) Children(id ID) []ID {\n\tis.RLock()\n\tdefer is.RUnlock()\n\n\treturn is.children(id)\n}\n\nfunc (is *store) children(id ID) []ID {\n\tvar ids []ID\n\tif is.images[id] != nil {\n\t\tfor id := range is.images[id].children {\n\t\t\tids = append(ids, id)\n\t\t}\n\t}\n\treturn ids\n}\n\nfunc (is *store) Heads() map[ID]*Image {\n\treturn is.imagesMap(false)\n}\n\nfunc (is *store) Map() map[ID]*Image {\n\treturn is.imagesMap(true)\n}\n\nfunc (is *store) imagesMap(all bool) map[ID]*Image {\n\tis.RLock()\n\tdefer is.RUnlock()\n\n\timages := make(map[ID]*Image)\n\n\tfor id := range is.images {\n\t\tif !all && len(is.children(id)) > 0 {\n\t\t\tcontinue\n\t\t}\n\t\timg, err := is.Get(id)\n\t\tif err != nil {\n\t\t\tlog.G(context.TODO()).Errorf(\"invalid image access: %q, error: %q\", id, err)\n\t\t\tcontinue\n\t\t}\n\t\timages[id] = img\n\t}\n\treturn images\n}\n\nfunc (is *store) Len() int {\n\tis.RLock()\n\tdefer is.RUnlock()\n\treturn len(is.images)\n}\n"], "filenames": ["builder/builder.go", "builder/dockerfile/copy.go", "builder/dockerfile/dispatchers.go", "builder/dockerfile/imageprobe.go", "builder/dockerfile/internals.go", "builder/dockerfile/mockbackend_test.go", "daemon/containerd/cache.go", "daemon/images/image_builder.go", "daemon/images/image_commit.go", "image/cache/cache.go", "image/cache/compare.go", "image/store.go"], "buggy_code_start_loc": [16, 11, 350, 8, 12, 15, 13, 256, 62, 3, 7, 5], "buggy_code_end_loc": [89, 99, 354, 78, 390, 110, 267, 256, 62, 253, 61, 297], "fixing_code_start_loc": [17, 10, 351, 9, 13, 16, 14, 257, 63, 4, 7, 6], "fixing_code_end_loc": [90, 86, 361, 79, 406, 111, 212, 260, 66, 317, 160, 318], "type": "CWE-346", "message": "Moby is an open-source project created by Docker to enable software containerization. The classic builder cache system is prone to cache poisoning if the image is built FROM scratch. Also, changes to some instructions (most important being HEALTHCHECK and ONBUILD) would not cause a cache miss. An attacker with the knowledge of the Dockerfile someone is using could poison their cache by making them pull a specially crafted image that would be considered as a valid cache candidate for some build steps. 23.0+ users are only affected if they explicitly opted out of Buildkit (DOCKER_BUILDKIT=0 environment variable) or are using the /build API endpoint. All users on versions older than 23.0 could be impacted. Image build API endpoint (/build) and ImageBuild function from github.com/docker/docker/client is also affected as it the uses classic builder by default. Patches are included in 24.0.9 and 25.0.2 releases.", "other": {"cve": {"id": "CVE-2024-24557", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-01T17:15:10.953", "lastModified": "2024-02-09T20:21:32.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Moby is an open-source project created by Docker to enable software containerization. The classic builder cache system is prone to cache poisoning if the image is built FROM scratch. Also, changes to some instructions (most important being HEALTHCHECK and ONBUILD) would not cause a cache miss. An attacker with the knowledge of the Dockerfile someone is using could poison their cache by making them pull a specially crafted image that would be considered as a valid cache candidate for some build steps. 23.0+ users are only affected if they explicitly opted out of Buildkit (DOCKER_BUILDKIT=0 environment variable) or are using the /build API endpoint. All users on versions older than 23.0 could be impacted. Image build API endpoint (/build) and ImageBuild function from github.com/docker/docker/client is also affected as it the uses classic builder by default. Patches are included in 24.0.9 and 25.0.2 releases."}, {"lang": "es", "value": "Moby es un proyecto de c\u00f3digo abierto creado por Docker para permitir la contenedorizaci\u00f3n de software. El sistema de cach\u00e9 del constructor cl\u00e1sico es propenso a envenenar el cach\u00e9 si la imagen se crea DESDE scratch. Adem\u00e1s, los cambios en algunas instrucciones (las m\u00e1s importantes son HEALTHCHECK y ONBUILD) no provocar\u00edan una p\u00e9rdida de cach\u00e9. Un atacante con conocimiento del Dockerfile que alguien est\u00e1 usando podr\u00eda envenenar su cach\u00e9 al obligarlo a extraer una imagen especialmente manipulada que se considerar\u00eda como un candidato de cach\u00e9 v\u00e1lido para algunos pasos de compilaci\u00f3n. Los usuarios de 23.0+ solo se ven afectados si optaron expl\u00edcitamente por no participar en Buildkit (variable de entorno DOCKER_BUILDKIT=0) o si est\u00e1n usando el endpoint API /build. Todos los usuarios con versiones anteriores a la 23.0 podr\u00edan verse afectados. El punto final de la API de creaci\u00f3n de im\u00e1genes (/build) y la funci\u00f3n ImageBuild de github.com/docker/docker/client tambi\u00e9n se ven afectados ya que utiliza el generador cl\u00e1sico de forma predeterminada. Los parches se incluyen en las versiones 24.0.9 y 25.0.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:L/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 6.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.3}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-345"}, {"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:moby:*:*:*:*:*:*:*:*", "versionEndExcluding": "24.0.9", "matchCriteriaId": "8334C2EE-69C4-42D5-89C3-00C77A880F08"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:moby:*:*:*:*:*:*:*:*", "versionStartIncluding": "25.0.0", "versionEndExcluding": "25.0.2", "matchCriteriaId": "D9331CA9-E92E-4D37-8C87-92F6D4418C4A"}]}]}], "references": [{"url": "https://github.com/moby/moby/commit/3e230cfdcc989dc524882f6579f9e0dac77400ae", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moby/moby/security/advisories/GHSA-xw73-rw38-6vjc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/moby/moby/commit/3e230cfdcc989dc524882f6579f9e0dac77400ae"}}