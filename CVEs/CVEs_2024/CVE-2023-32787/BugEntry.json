{"buggy_code": ["/* Copyright (c) 1996-2015, OPC Foundation. All rights reserved.\r\n   The source code in this file is covered under a dual-license scenario:\r\n     - RCL: for OPC Foundation members in good-standing\r\n     - GPL V2: everybody else\r\n   RCL license terms accompanied with this source code. See http://opcfoundation.org/License/RCL/1.00/\r\n   GNU General Public License as published by the Free Software Foundation;\r\n   version 2 of the License are accompanied with this source code. See http://opcfoundation.org/License/GPLv2\r\n   This source code is distributed in the hope that it will be useful,\r\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n*/\r\n\r\npackage org.opcfoundation.ua.transport.tcp.nio;\r\n\r\nimport java.io.IOException;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.SocketAddress;\r\nimport java.net.SocketException;\r\nimport java.nio.channels.ServerSocketChannel;\r\nimport java.nio.channels.SocketChannel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nimport org.opcfoundation.ua.application.Application;\r\nimport org.opcfoundation.ua.application.Server;\r\nimport org.opcfoundation.ua.common.ServiceResultException;\r\nimport org.opcfoundation.ua.core.StatusCodes;\r\nimport org.opcfoundation.ua.encoding.EncoderContext;\r\nimport org.opcfoundation.ua.transport.CloseableObjectState;\r\nimport org.opcfoundation.ua.transport.Endpoint;\r\nimport org.opcfoundation.ua.transport.EndpointBinding;\r\nimport org.opcfoundation.ua.transport.EndpointServer;\r\nimport org.opcfoundation.ua.transport.IConnectionListener;\r\nimport org.opcfoundation.ua.transport.ServerConnection;\r\nimport org.opcfoundation.ua.transport.UriUtil;\r\nimport org.opcfoundation.ua.transport.endpoint.EndpointBindingCollection;\r\nimport org.opcfoundation.ua.transport.impl.ConnectionCollection;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ReverseHello;\r\nimport org.opcfoundation.ua.utils.AbstractState;\r\nimport org.opcfoundation.ua.utils.StackUtils;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncSocketImpl;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n * EndpointOpcTcp hosts an endpoint for opc.tcp socket.\r\n *\r\n * Endpoint discovery is provided if endpoint url is unknown.\r\n *\r\n * @see Executors for creating executor instances\r\n */\r\npublic class OpcTcpServer extends AbstractState<CloseableObjectState, ServiceResultException> implements EndpointServer {\r\n\r\n\t/** Logger */\r\n\tstatic Logger logger = LoggerFactory.getLogger(OpcTcpServer.class);\r\n\t/** Application */\r\n\tApplication application;\r\n\t/** Secure channel counter */\r\n\tAtomicInteger secureChannelCounter = new AtomicInteger();\r\n\t/** Endpoint bindings */\r\n\tEndpointBindingCollection endpointBindings = new EndpointBindingCollection(); \r\n\r\n\t/** Service server used when client connects with \"\" url for endpoint discovery */\r\n\tpublic Server discoveryServer;\r\n\tpublic EndpointBinding discoveryEndpointBinding;\r\n\t\r\n\tprivate int receiveBufferSize = 0;\r\n\r\n\tprivate boolean initialized = false;\r\n\t\r\n\t/** Endpoint handles */\r\n\tMap<SocketAddress, SocketHandle> socketHandles = new HashMap<SocketAddress, SocketHandle>();\r\n\t\r\n\t/**\r\n\t * <p>getEncoderContext.</p>\r\n\t *\r\n\t * @return a {@link org.opcfoundation.ua.encoding.EncoderContext} object.\r\n\t */\r\n\tpublic EncoderContext getEncoderContext() {\r\n\t\treturn application.getEncoderContext();\r\n\t}\r\n\r\n\t/**\r\n\t * <p>Getter for the field <code>receiveBufferSize</code>.</p>\r\n\t *\r\n\t * @return the receiveBufferSize to use for the connection socket of the server.\r\n\t */\r\n\tpublic int getReceiveBufferSize() {\r\n\t\treturn receiveBufferSize;\r\n\t}\r\n\r\n\t/**\r\n\t * Define the receiveBufferSize to use for the connection socket of the server.\r\n\t * <p>\r\n\t * Default value: 0, which omits the parameter and the default value for the\r\n\t * socket (depending on the operating system) is used.\r\n\t *\r\n\t * @param receiveBufferSize the new size in bytes\r\n\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t * @see \"http://fasterdata.es.net/host-tuning/background/\"\r\n\t */\r\n\tpublic void setReceiveBufferSize(int receiveBufferSize) throws ServiceResultException {\r\n\t\tthis.receiveBufferSize = receiveBufferSize;\r\n\t\tif (receiveBufferSize > 0) {\r\n\t\t\tfor (SocketHandle sh : socketHandleSnapshot()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tAsyncServerSocket ass = sh.socket;\r\n\t\t\t\t\tif ( ass!=null ) {\r\n\t\t\t\t\t\tass.socket().setReceiveBufferSize(receiveBufferSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (SocketException e) {\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_InternalError, e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/** AsyncServerSocket Connect listener */\r\n\torg.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket.ConnectListener connectListener = new org.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket.ConnectListener() {\t\t\r\n\t\tpublic void onConnected(AsyncServerSocket sender, AsyncSocketImpl newConnection) {\r\n\t\t\tlogger.info(\"{}: {} connected\", OpcTcpServer.this, newConnection.socket().getRemoteSocketAddress());\r\n\t\t\tfinal OpcTcpServerConnection conn = new OpcTcpServerConnection(OpcTcpServer.this, newConnection);\r\n\t\t\tconnections.addConnection(conn);\r\n\t\t\t\r\n\t\t\tconn.addConnectionListener(new IConnectionListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClosed(ServiceResultException closeError) {\t\t\t\t\t\t\r\n\t\t\t\t\t\tconnections.removeConnection(conn);\r\n\t\t\t\t}\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onOpen() {\r\n\t\t\t\t}});\r\n\t\t\t\r\n\t          // Check for connection count limits\r\n\t          // Per 1.05 Part 4 section 5.5.2, To protect against misbehaving Clients and denial of\r\n\t          // service attacks, the Server shall close the oldest unused SecureChannelthat has no\r\n\t          // Session assigned before reaching the maximum number of supported SecureChannels.\r\n\r\n\r\n\t          List<ServerConnection> conns = new ArrayList<ServerConnection>();\r\n\t          connections.getConnections(conns);\r\n\r\n\t          logger.trace(\"Checking maximum number of connections, limit: {}, current: {}\", maxConnections, conns.size());\r\n\r\n\t          // at limit is enough per the 5.5.2\r\n\t          if (conns.size() >= maxConnections) {\r\n\t            int delta = maxConnections - conns.size() + 1;\r\n\t            logger.trace(\"We are at max or over limit, number of connections to purge if possible: {}\", delta);\r\n\t            // TODO ordering based on timestamps of creation\r\n\t            int purged = 0;\r\n\t            for (ServerConnection tmp : conns) {\r\n\t              if (tmp instanceof OpcTcpServerConnection) {\r\n\t                // Every connection should be of this type in this OpcTcpServer)\r\n\t                OpcTcpServerConnection opcTcpTmp = (OpcTcpServerConnection) tmp;\r\n\r\n\t                // We are itself part of the connections as well. Skip ourselves here (that is\r\n\t                // handled at the end of this method). If we remove ourselves here, and would be the\r\n\t                // \"final legit\" connection (and then we would be at max capacity), we would be\r\n\t                // closed before we can ActivateSession.\r\n\t                if (conn == opcTcpTmp) {\r\n\t                  continue;\r\n\t                }\r\n\r\n\t                if (opcTcpTmp.isPurgeEligible()) {\r\n\t                  opcTcpTmp.close();\r\n\t                  purged++;\r\n\t                  if (purged >= delta) {\r\n\t                    break;\r\n\t                  }\r\n\t                }\r\n\t              }\r\n\t            }\r\n\t            logger.trace(\"We are at max or over limit, purged {} old connections\", purged);\r\n\t          }\r\n\t          // It is possible that we were not able to purge anything, if we happen to be at max\r\n\t          // connections that all have activated sessions, in this case, close this connection\r\n\t          // instead.\r\n\t          List<ServerConnection> tmp = new ArrayList<ServerConnection>();\r\n\t          connections.getConnections(tmp);\r\n\t          /*\r\n\t           * But! This connection itself is within the connections, if we are exactly at max, that\r\n\t           * is still OK here. But if we are over (i.e. we already had at max and none cannot be\r\n\t           * removed), then remove this connection.\r\n\t           */\r\n\t          if (tmp.size() > maxConnections) {\r\n\t            logger.trace(\"We are at over limit, unable to purge enough old connections, closing this connection\");\r\n\t            conn.close();\r\n\t          } else if (tmp.size() == maxConnections) {\r\n\t            logger.trace(\"We are exactly at maximum connections (including this connection). \"\r\n\t                + \"No older connections could be purged. Keeping this connection open.\");\r\n\t          }\r\n\t    }};\r\n\tConnectionCollection connections = new ConnectionCollection(this);\t\r\n\t\r\n\tint maxConnections;\r\n\tint maxSecureChannelsPerConnection;\t\r\n\t\r\n\t/**\r\n\t * <p>Constructor for OpcTcpServer.</p>\r\n\t *\r\n\t * @param application a {@link org.opcfoundation.ua.application.Application} object.\r\n\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t */\r\n\tpublic OpcTcpServer(Application application) throws ServiceResultException\r\n\t{\r\n\t\tsuper(CloseableObjectState.Closed, CloseableObjectState.Closed);\r\n\t\tthis.application = application;\r\n\t\ttry {\r\n\t\t\tServerSocketChannel channel = ServerSocketChannel.open();\r\n\t\t\tchannel.configureBlocking(false);\r\n\t\t\t\r\n\t\t\t// Create a service server for connections that query endpoints (url = \"\")\r\n\t\t\tdiscoveryServer = new Server( application );\r\n\t\t\tdiscoveryServer.setEndpointBindings( endpointBindings );\r\n\t\t\tdiscoveryEndpointBinding = new EndpointBinding(this, discoveryEndpoint, discoveryServer);\t\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new ServiceResultException(StatusCodes.Bad_InternalError, e);\r\n\t\t}\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic EndpointHandle bind(SocketAddress socketAddress, EndpointBinding endpointBinding) throws ServiceResultException {\r\n\t\tif ( endpointBinding == null || socketAddress == null || endpointBinding.endpointServer!=this )\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t\r\n\t\tinit();\r\n\t\t\r\n\t\tString scheme = UriUtil.getTransportProtocol( endpointBinding.endpointAddress.getEndpointUrl() );\r\n\t\tif ( !\"opc.tcp\".equals(scheme) ) throw new ServiceResultException(StatusCodes.Bad_UnexpectedError, \"Cannot bind \"+scheme+\" to opc.tcp server\");\r\n\t\tSocketHandle socketHandle = getOrCreateSocketHandle(socketAddress);\r\n\t\t\r\n\t\tif ( socketHandle.socket == null ) {\r\n\t\t\ttry {\r\n\t\t\t\tsocketHandle.setChannel(ServerSocketChannel.open());\r\n\t\t\t\tsocketHandle.getChannel().configureBlocking(false);\r\n\t\t\t\r\n\t\t\t\tsocketHandle.socket = new AsyncServerSocket(\r\n\t\t\t\t\t\tsocketHandle.getChannel(),\r\n\t\t\t\t\t\tStackUtils.getNonBlockingWorkExecutor()//,\r\n\t\t\t\t\t\t//new AsyncSelector(Selector.open())\r\n\t\t\t\t\t\t,StackUtils.getSelector()\r\n\t\t\t\t\t\t);\r\n\t\t\t\tsocketHandle.socket.bind(socketHandle.socketAddress, 0);\r\n\t\t\t\tsocketHandle.socket.addListener(connectListener);\r\n\t\t\t\tlogger.info(\"TCP/IP Socket bound to {}\", socketAddress);\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tlogger.error(\"Failed to bind address \"+ socketHandle.socketAddress, e);\r\n\t\t\t\tsocketHandle.close();\r\n\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_InternalError, e);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tOpcTcpEndpointHandle endpointHandle = socketHandle.getOrCreate(endpointBinding);\r\n\t\treturn endpointHandle;\r\n\t}\r\n\t\r\n\r\n\t@Override\r\n\tpublic void bindReverse(final SocketAddress addressToConnect,\r\n\t\t\tfinal String endpointUrl) {\r\n\t\tif(addressToConnect == null || endpointUrl == null) {\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t}\r\n\t\tinit();\r\n\t\t\r\n\t\tReverseSocketHandle socketHandle = new ReverseSocketHandle(addressToConnect);\r\n\t\tif(socketHandle.socket == null) {\r\n\t\t\ttry {\r\n\t\t\t\tsocketHandle.setChannel(SocketChannel.open());\r\n\t\t\t\tsocketHandle.getChannel().configureBlocking(false);\r\n\t\t\t\t\r\n\t\t\t\tsocketHandle.socket = new AsyncSocketImpl(socketHandle.getChannel(), StackUtils.getNonBlockingWorkExecutor(), StackUtils.getSelector());\r\n\r\n\t\t\t\tReverseHello rh = new ReverseHello();\r\n\t\t\t\trh.setEndpointUrl(endpointUrl);\r\n\t\t\t\trh.setServerUri(application.getApplicationDescription().getApplicationUri());\r\n\t\t\t\tfinal OpcTcpServerConnection conn = new OpcTcpServerConnection(OpcTcpServer.this, socketHandle.socket, rh); \r\n\t\t\t\tconnections.addConnection(conn);\r\n\t\t\t\t\r\n\t\t\t\tconn.addConnectionListener(new IConnectionListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onClosed(ServiceResultException closeError) {\t\t\t\t\t\t\r\n\t\t\t\t\t\tconnections.removeConnection(conn);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t//1.04 Part 6 section 7.1.3 when closed, server must restart the process\r\n\t\t\t\t\t\tlogger.debug(\"ReverseHello connection closed, rescheduling connection process\");\r\n\t\t\t\t\t\tbindReverse(addressToConnect, endpointUrl);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onOpen() {\r\n\t\t\t\t\t}});\r\n\t\t\t\t//async, do last, others listen on socket state.\r\n\t\t\t\tsocketHandle.socket.connect(socketHandle.socketAddress);\r\n\t\t\t}catch(IOException e) {\r\n\t\t\t\tlogger.error(\"Failed to create a ReverseSocketHandle\", e);\r\n\t\t\t\tsocketHandle.close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic List<SocketAddress> getBoundSocketAddresses() {\r\n\t\tArrayList<SocketAddress> result = new ArrayList<SocketAddress>();\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot()) result.add( sh.socketAddress );\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * <p>getBoundAddress.</p>\r\n\t *\r\n\t * @return a {@link java.net.SocketAddress} object.\r\n\t */\r\n\tpublic SocketAddress getBoundAddress() {\r\n\t\tSocketHandle[] shs = socketHandleSnapshot();\r\n\t\tfor (SocketHandle sh: shs) {\r\n\t\t\tif ( sh.socket!=null) return sh.socketAddress;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Disconnect all existing connections.\r\n\t */\r\n\tpublic void disconnectAll()\r\n\t{\r\n\t\tList<ServerConnection> list = new ArrayList<ServerConnection>();\r\n\t\tgetConnections(list);\r\n\t\tfor (ServerConnection connection : list) {\r\n\t\t\tOpcTcpServerConnection c = (OpcTcpServerConnection) connection;\r\n\t\t\tc.close();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * Closes server socket. Does not disconnect existing connections.\r\n\t */\r\n\t@Override\r\n\tpublic synchronized OpcTcpServer close() {\r\n\t\tlogger.info(\"{} closed\", getBoundAddress());\r\n\t\tif (!getState().isClosed()) { \r\n\t\t\tsetState(CloseableObjectState.Closing);\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tfor (SocketHandle sh : socketHandleSnapshot())\r\n\t\t\t\tsh.close();\r\n\t\t} finally {\r\n\t\t\tsetState(CloseableObjectState.Closed);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic void addConnectionListener(org.opcfoundation.ua.transport.ConnectionMonitor.ConnectListener l) {\r\n\t\tconnections.addConnectionListener(l);\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic void getConnections(Collection<ServerConnection> result) {\r\n\t\tconnections.getConnections(result);\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic void removeConnectionListener(org.opcfoundation.ua.transport.ConnectionMonitor.ConnectListener l) {\r\n\t\tconnections.removeConnectionListener(l);\r\n\t}\t\r\n\t\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic EndpointBindingCollection getEndpointBindings() {\r\n\t\treturn endpointBindings;\r\n\t}\t\r\n\t\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tsb.append(\"OpcTcpServer\");\r\n\t\tsb.append(\"(\");\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot()) sb.append( sh.toString() );\r\n\t\tsb.append(\")\");\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tsynchronized SocketHandle getOrCreateSocketHandle(SocketAddress socketAddress)\r\n\tthrows ServiceResultException\r\n\t{\r\n\t\tSocketHandle handle = socketHandles.get(socketAddress);\r\n\t\tif ( handle == null ) {\r\n\t\t\thandle = new SocketHandle(socketAddress);\r\n\t\t\tsocketHandles.put(socketAddress, handle);\r\n\t\t}\r\n\t\treturn handle;\r\n\t}\r\n\t\r\n\t/**\r\n\t * <p>socketHandleSnapshot.</p>\r\n\t *\r\n\t * @return an array of {@link org.opcfoundation.ua.transport.tcp.nio.OpcTcpServer.SocketHandle} objects.\r\n\t */\r\n\tpublic SocketHandle[] socketHandleSnapshot() {\r\n\t\treturn socketHandles.values().toArray( new SocketHandle[ socketHandles.size()] );\t\t\r\n\t}\r\n\t\r\n\tpublic static class ReverseSocketHandle{\r\n\t\t\r\n\t\tprivate SocketAddress socketAddress;\r\n\t\tprivate SocketChannel channel;\r\n\t\tprivate AsyncSocketImpl socket;\r\n\t\t\r\n\t\tpublic ReverseSocketHandle(SocketAddress socketAddress) {\r\n\t\t\tthis.socketAddress = socketAddress;\r\n\t\t}\r\n\r\n\t\tpublic SocketChannel getChannel() {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\r\n\t\tpublic void setChannel(SocketChannel channel) {\r\n\t\t\tthis.channel = channel;\r\n\t\t}\r\n\r\n\t\tpublic SocketAddress getSocketAddress() {\r\n\t\t\treturn socketAddress;\r\n\t\t}\r\n\t\t\r\n\t\tpublic AsyncSocketImpl getSocket() {\r\n\t\t\treturn socket;\r\n\t\t}\r\n\r\n\t\tpublic void setSocket(AsyncSocketImpl socket) {\r\n\t\t\tthis.socket = socket;\r\n\t\t}\r\n\r\n\t\tvoid close() {\r\n\t\t\tSocketChannel c = channel;\r\n\t\t\tif(c != null) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tc.close();\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tlogger.error(\"Failure in closing ReverseSockeHandle\", e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic class SocketHandle {\r\n\t\tSocketAddress socketAddress;\r\n\t\t/** Server Socket */\r\n\t\tAsyncServerSocket socket;\r\n\t\tprivate ServerSocketChannel channel;\r\n\t\tint port;\r\n\t\tMap<Endpoint, OpcTcpEndpointHandle> endpoints = new HashMap<Endpoint, OpcTcpEndpointHandle>();\r\n\t\tSocketHandle(SocketAddress socketAddress)\r\n\t\t{\r\n\t\t\tthis.socketAddress = socketAddress;\r\n\t\t}\r\n\t\t\r\n\t\tpublic synchronized OpcTcpEndpointHandle[] endpointHandleSnapshot() {\r\n\t\t\treturn endpoints.values().toArray( new OpcTcpEndpointHandle[ endpoints.size()] );\r\n\t\t}\r\n\t\t\r\n\t\tsynchronized void endpointHandleSnapshot(Collection<OpcTcpEndpointHandle> handles) {\r\n\t\t\thandles.addAll( endpoints.values() );\r\n\t\t}\r\n\t\t\r\n\t\tsynchronized OpcTcpEndpointHandle getOrCreate(EndpointBinding endpointBinding) throws ServiceResultException {\r\n\t\t\tOpcTcpEndpointHandle handle = endpoints.get(endpointBinding.endpointAddress);\r\n\t\t\tif ( handle == null ) {\r\n\t\t\t\thandle = new OpcTcpEndpointHandle(this, endpointBinding);\r\n\t\t\t\t// Add endpointBinding to SocketHandle\r\n\t\t\t\tendpoints.put(endpointBinding.endpointAddress, handle);\r\n\t\t\t\t// Add endpointBinding to EndpointServer\r\n\t\t\t\tendpointBindings.add(endpointBinding);\r\n\t\t\t\t// Add endpointBinding to Server\r\n\t\t\t\tendpointBinding.serviceServer.getEndpointBindings().add(endpointBinding);\r\n\t\t\t} else {\r\n\t\t\t\tif ( !handle.endpointBinding.equals( endpointBinding ) ) {\r\n\t\t\t\t\tthrow new ServiceResultException( StatusCodes.Bad_UnexpectedError, \"Cannot bind an endpoint address to two different servers.\" );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn handle;\r\n\t\t}\r\n\t\tint getPort() {\r\n\t\t\treturn ((InetSocketAddress)socketAddress).getPort();\r\n\t\t}\r\n\r\n\t\tvoid close() {\r\n\t\t\tfor ( OpcTcpEndpointHandle eph : endpoints.values() ) eph.close__();\r\n\t\t\tsocketHandles.remove(socketAddress);\r\n\t\t\tif ( socket!=null ) {\r\n\t\t\t\tAsyncServerSocket ass = socket;\r\n\t\t\t\tsocket = null;\r\n\t\t\t\tass.close();\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append( \"opc.tcp(\"+socketAddress+\", \");\r\n\t\t\tfor (OpcTcpEndpointHandle ep : endpoints.values()) {\r\n\t\t\t\tsb.append( ep.toString() );\r\n\t\t\t}\r\n\t\t\tsb.append( \")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @return the channel\r\n\t\t */\r\n\t\tpublic ServerSocketChannel getChannel() {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @param channel the channel to set\r\n\t\t */\r\n\t\tpublic void setChannel(ServerSocketChannel channel) {\r\n\t\t\tthis.channel = channel;\r\n\t\t}\r\n\r\n\t\tpublic SocketAddress getSocketAddress() {\r\n\t\t\treturn socketAddress;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic class OpcTcpEndpointHandle implements EndpointHandle {\r\n\t\tEndpointBinding endpointBinding;\r\n\t\tSocketHandle socketHandle;\r\n\t\tOpcTcpEndpointHandle(SocketHandle socketHandle, EndpointBinding endpointBinding) {\r\n\t\t\tthis.socketHandle = socketHandle;\r\n\t\t\tthis.endpointBinding = endpointBinding;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic SocketAddress socketAddress() {\r\n\t\t\treturn socketHandle.socketAddress;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic EndpointBinding endpointBinding() {\r\n\t\t\treturn endpointBinding;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic void close() {\r\n\t\t\tclose_();\r\n\t\t\tclose__();\r\n\t\t}\r\n\t\tvoid close_() {\r\n\t\t\t// Remove endpointBinding from SocketHandle\r\n\t\t\tsocketHandle.endpoints.remove(endpointBinding.endpointAddress);\r\n\t\t\t// Close socket if this was the last\r\n\t\t\tif ( socketHandle.endpoints.isEmpty() ) {\r\n\t\t\t\tsocketHandle.close();\r\n\t\t\t}\r\n\t\t}\r\n\t\tvoid close__() {\r\n\t\t\t// Close endpointHandler if this was the last\r\n\t\t\tint count = countEndpoints(endpointBinding.endpointAddress);\r\n\t\t\tif ( count == 0 ) {\r\n\t\t\t\t// Remove endpointBinding from EndpointServer\r\n\t\t\t\tendpointBindings.remove(endpointBinding);\r\n\t\t\t\t// Remove endpointBinding from Server\r\n\t\t\t\tendpointBinding.serviceServer.getEndpointBindings().remove(endpointBinding);\r\n\t\t\t}\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn \"(\"+endpointBinding.endpointAddress.toString()+\")\";\r\n\t\t}\r\n\t}\r\n\r\n\tprivate void init() {\r\n\t\tif (!initialized) {\r\n\t\t\tint maxConnections = application.getOpctcpSettings().getMaxConnections();\r\n\t\t\tif (maxConnections <= 0) {\r\n\t\t\t\tthrow new IllegalStateException(\"Maximum number of connections was not configured; must be greater than 0\");\r\n\t\t\t}\r\n\t\t\tthis.maxConnections = maxConnections;\r\n\r\n\t\t\tint maxSecureChannelsPerConnection = application.getOpctcpSettings().getMaxSecureChannelsPerConnection();\r\n\t\t\tif (maxSecureChannelsPerConnection <= 0) {\r\n\t\t\t\tthrow new IllegalStateException(\r\n\t\t            \"Maximum number of secure channels per connection was not configured; must be greater than 0\");\r\n\t\t\t}\r\n\t\t\tthis.maxSecureChannelsPerConnection = maxSecureChannelsPerConnection;\r\n\t\t\tinitialized = true;\r\n\t\t}\r\n\t}\r\n\t  \r\n\tList<OpcTcpEndpointHandle> findEndpoints(String forUri) {\r\n\t\tList<OpcTcpEndpointHandle> result = new ArrayList<OpcTcpEndpointHandle>();\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot() ) sh.endpointHandleSnapshot(result);\r\n\t\treturn result;\r\n\t}\r\n\tint countEndpoints(Endpoint endpointAddress) {\r\n\t\tint count = 0;\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot() ) {\r\n\t\t\tfor (OpcTcpEndpointHandle eh : sh.endpointHandleSnapshot()) {\r\n\t\t\t\tif (eh.endpointBinding.endpointAddress.equals(endpointAddress)) count++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n}\r\n", "/* Copyright (c) 1996-2015, OPC Foundation. All rights reserved.\r\n   The source code in this file is covered under a dual-license scenario:\r\n     - RCL: for OPC Foundation members in good-standing\r\n     - GPL V2: everybody else\r\n   RCL license terms accompanied with this source code. See http://opcfoundation.org/License/RCL/1.00/\r\n   GNU General Public License as published by the Free Software Foundation;\r\n   version 2 of the License are accompanied with this source code. See http://opcfoundation.org/License/GPLv2\r\n   This source code is distributed in the hope that it will be useful,\r\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n */\r\npackage org.opcfoundation.ua.transport.tcp.nio;\r\n\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_SecureChannelIdInvalid;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_SecurityChecksFailed;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_SecurityPolicyRejected;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_TcpInternalError;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_Timeout;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_UnexpectedError;\r\n\r\nimport java.io.IOException;\r\nimport java.net.Socket;\r\nimport java.net.SocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.ByteOrder;\r\nimport java.security.cert.CertificateException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nimport org.opcfoundation.ua.builtintypes.StatusCode;\r\nimport org.opcfoundation.ua.builtintypes.UnsignedInteger;\r\nimport org.opcfoundation.ua.common.ServiceResultException;\r\nimport org.opcfoundation.ua.core.ActivateSessionResponse;\r\nimport org.opcfoundation.ua.core.CloseSecureChannelRequest;\r\nimport org.opcfoundation.ua.core.EndpointConfiguration;\r\nimport org.opcfoundation.ua.core.MessageSecurityMode;\r\nimport org.opcfoundation.ua.core.OpenSecureChannelRequest;\r\nimport org.opcfoundation.ua.core.SecurityTokenRequestType;\r\nimport org.opcfoundation.ua.core.StatusCodes;\r\nimport org.opcfoundation.ua.encoding.EncoderContext;\r\nimport org.opcfoundation.ua.encoding.IEncodeable;\r\nimport org.opcfoundation.ua.encoding.binary.BinaryEncoder;\r\nimport org.opcfoundation.ua.transport.AsyncWrite;\r\nimport org.opcfoundation.ua.transport.CloseableObject;\r\nimport org.opcfoundation.ua.transport.CloseableObjectState;\r\nimport org.opcfoundation.ua.transport.Endpoint;\r\nimport org.opcfoundation.ua.transport.EndpointBinding;\r\nimport org.opcfoundation.ua.transport.IConnectionListener;\r\nimport org.opcfoundation.ua.transport.ServerSecureChannel;\r\nimport org.opcfoundation.ua.transport.endpoint.AbstractServerSecureChannel;\r\nimport org.opcfoundation.ua.transport.endpoint.EndpointBindingCollection;\r\nimport org.opcfoundation.ua.transport.security.CertificateValidator;\r\nimport org.opcfoundation.ua.transport.security.KeyPair;\r\nimport org.opcfoundation.ua.transport.security.SecurityAlgorithm;\r\nimport org.opcfoundation.ua.transport.security.SecurityConfiguration;\r\nimport org.opcfoundation.ua.transport.security.SecurityMode;\r\nimport org.opcfoundation.ua.transport.security.SecurityPolicy;\r\nimport org.opcfoundation.ua.transport.tcp.impl.Acknowledge;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkAsymmEncryptSigner;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkFactory;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkFactory.AcknowledgeChunkFactory;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkFactory.ErrorMessageChunkFactory;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkSymmEncryptSigner;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkUtils;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ErrorMessage;\r\nimport org.opcfoundation.ua.transport.tcp.impl.Hello;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ReverseHello;\r\nimport org.opcfoundation.ua.transport.tcp.impl.SecurityToken;\r\nimport org.opcfoundation.ua.transport.tcp.impl.TcpMessageType;\r\nimport org.opcfoundation.ua.transport.tcp.nio.Channel.ChannelListener;\r\nimport org.opcfoundation.ua.transport.tcp.nio.SecureInputMessageBuilder.MessageListener;\r\nimport org.opcfoundation.ua.utils.CertificateUtils;\r\nimport org.opcfoundation.ua.utils.CryptoUtil;\r\nimport org.opcfoundation.ua.utils.IStatefulObject;\r\nimport org.opcfoundation.ua.utils.ObjectUtils;\r\nimport org.opcfoundation.ua.utils.SizeCalculationOutputStream;\r\nimport org.opcfoundation.ua.utils.StackUtils;\r\nimport org.opcfoundation.ua.utils.StateListener;\r\nimport org.opcfoundation.ua.utils.TimerUtil;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncInputStream;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncSocket;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncSocketImpl;\r\nimport org.opcfoundation.ua.utils.asyncsocket.BufferMonitorState;\r\nimport org.opcfoundation.ua.utils.asyncsocket.MonitorListener;\r\nimport org.opcfoundation.ua.utils.asyncsocket.SocketState;\r\nimport org.opcfoundation.ua.utils.bytebuffer.ByteBufferArrayWriteable2;\r\nimport org.opcfoundation.ua.utils.bytebuffer.ByteBufferArrayWriteable2.ChunkListener;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n * <p>OpcTcpServerConnection class.</p>\r\n *\r\n * @author jaro\r\n */\r\npublic class OpcTcpServerConnection extends AbstractServerConnection {\r\n\r\n\t/** Logger */\r\n\tprivate final static Logger logger = LoggerFactory.getLogger(OpcTcpServerConnection.class);\r\n\r\n\t// Give client 10 minutes to handshake\r\n\tprivate static long handshakeTimeout = 10 * 60 * 1000; // 10 minutes\r\n\t/**\r\n\t * <p>Getter for the field <code>handshakeTimeout</code>.</p>\r\n\t *\r\n\t * @return the handshakeTimeout\r\n\t */\r\n\tpublic static long getHandshakeTimeout() {\r\n\t\treturn handshakeTimeout;\r\n\t}\r\n\t/**\r\n\t * Define the handshake timeout for new connections. If the client does not\r\n\t * establish a connection during the timeout, the socket is released.\r\n\t * A smaller value might be usable to avoid DNS attacks.\r\n\t *\r\n\t * @param handshakeTimeout\r\n\t *            the handshakeTimeout to set. Default 600000 = 10 minutes.\r\n\t */\r\n\tpublic static void setHandshakeTimeout(long handshakeTimeout) {\r\n\t\tOpcTcpServerConnection.handshakeTimeout = handshakeTimeout;\r\n\t}\r\n\t/** Agreed protocol version */\r\n\tint agreedProtocolVersion;\r\n\t/**  Request id - Pending Request mapping */\r\n\tMap<Integer, PendingRequest> pendingRequests  = new ConcurrentHashMap<Integer, PendingRequest>();\r\n\r\n\t/** An endpoint binding associated with this connection. Set after hello */\r\n\tEndpointBinding binding;\r\n\r\n\t/** Endpoint Server */\r\n\tOpcTcpServer endpointServer;\r\n\r\n\t/** Event based asynchronous socket */\r\n\tAsyncSocket s;\r\n\r\n\t/** Optional ReverseHello message, if operating in ReverseHello-mode */\r\n\tReverseHello rh;\r\n\t\r\n\t/**\r\n\t * Tracks if this connection has ever been successfully SessionActivated at least once. Impl note:\r\n\t * once set to true, shall be never set to false.\r\n\t */\r\n\tAtomicBoolean hasBeenSuccessfullySessionActivated = new AtomicBoolean(false);\r\n\t  \r\n\t/** Timer used for handshake timing */\r\n\tTimer timer = TimerUtil.getTimer();\r\n\r\n\tTimerTask timeoutTimer;\r\n\tRunnable timeout = new Runnable() {\r\n\t\t@Override\r\n\t\tpublic void run() {\r\n\t\t\tsetError(Bad_Timeout);\r\n\t\t}};\r\n\r\n\t\tEncoderContext encoderCtx;\r\n\t\tEndpointConfiguration endpointConfiguration;\r\n\r\n\t\t/// ??? ///\r\n\t\t// Handles incoming data //\r\n\t\tMonitorListener inputListener =\r\n\t\t\t\tnew MonitorListener() {\r\n\t\t\t@Override\r\n\t\t\tpublic void onStateTransition(IStatefulObject<BufferMonitorState, ?> sender,\r\n\t\t\t\t\tBufferMonitorState oldState, BufferMonitorState newState) {\r\n\r\n\t\t\t\t// Trigger is unreachable\r\n\t\t\t\tif (newState.isUnreachable()) {\r\n\t\t\t\t\tif (secureMessageBuilder!=null) {\r\n\t\t\t\t\t\tsecureMessageBuilder.close();\r\n\t\t\t\t\t\tsecureMessageBuilder = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (newState != BufferMonitorState.Triggered)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogger.error(\"Unexpected trigger state {}\", newState);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// -- assert -- atleast 8 bytes are available --\r\n\r\n\t\t\t\tAsyncInputStream is = s.getInputStream();\r\n\t\t\t\tByteBuffer hdr = is.peek(8);\r\n\t\t\t\thdr.order(ByteOrder.LITTLE_ENDIAN);\r\n\t\t\t\thdr.getInt();\r\n\t\t\t\tint chunkSize = hdr.getInt();\r\n\r\n\t\t\t\tif (chunkSize<12) {\r\n\t\t\t\t\tsetError(StatusCodes.Bad_TcpInternalError);\r\n\t\t\t\t\tif (secureMessageBuilder!=null)\r\n\t\t\t\t\t\tsecureMessageBuilder.close();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (chunkSize > ctx.maxRecvChunkSize)\r\n\t\t\t\t{\r\n\t\t\t\t\tsetError(new ServiceResultException(StatusCodes.Bad_TcpMessageTooLarge, \"Chunk size (\"+chunkSize+\") exceeded maximum (\"+ctx.maxRecvChunkSize+\")\"));\r\n\t\t\t\t\tif (secureMessageBuilder!=null)\r\n\t\t\t\t\t\tsecureMessageBuilder.close();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (is.available()>=chunkSize) {\r\n\t\t\t\t\t// Chunk is readable\r\n\t\t\t\t\tByteBuffer chunk = is.read(chunkSize);\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\thandleChunk(chunk);\r\n\t\t\t\t\t\t} catch (RuntimeException e) {\r\n\t\t\t\t\t\t\tlogger.warn(\"Error in handleChunk\", e);\r\n\t\t\t\t\t\t\tthrow StackUtils.toServiceResultException(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (ServiceResultException se) {\r\n\t\t\t\t\t\tlogger.info(\"Error in handleChunk\", se);\r\n\t\t\t\t\t\tsetError(se);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Wait for next chunk header\r\n\t\t\t\t\tis.createMonitor(is.getPosition()+8, this);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Wake me up when the chunk is fully readable\r\n\t\t\t\t\tis.createMonitor(is.getPosition()+chunkSize, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t/// ??? ///\r\n\r\n\t\t// Handle incoming messages, ran in BlockingWorkExecutor //\r\n\t\tMessageListener messageListener = new MessageListener() {\r\n\t\t\t@Override\r\n\t\t\tpublic void onMessageComplete(InputMessage sender) {\r\n\t\t\t\tIEncodeable msg = sender.getMessage();\r\n\r\n\t\t\t\tfor (ChannelListener cl : channelListeners)\r\n\t\t\t\t\tif (cl.handleMessage(sender)) return;\r\n\r\n\t\t\t\t// Handler error\r\n\t\t\t\tif (msg==null)\r\n\t\t\t\t\tsynchronized (this) {\r\n\t\t\t\t\t\tException error = sender.getError();\r\n\t\t\t\t\t\tif (error == null)\r\n\t\t\t\t\t\t\treturn; // aborted;\r\n\t\t\t\t\t\tsetError(StackUtils.toServiceResultException(error));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// Handle message\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (sender.getMessageType() == TcpMessageType.MESSAGE) {\r\n\t\t\t\t\t\thandleSecureMessage(sender);\r\n\t\t\t\t\t} else if (sender.getMessageType() == TcpMessageType.CLOSE) {\r\n\t\t\t\t\t\thandleCloseSecureChannelRequest(sender);\r\n\t\t\t\t\t} else if (sender.getMessageType() == TcpMessageType.OPEN) {\r\n\t\t\t\t\t\thandleOpenSecureChannelRequest(sender);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (ServiceResultException e) {\r\n\t\t\t\t\tsetError(e);\r\n\t\t\t\t}\r\n\t\t\t}};\r\n\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Creates a new OpcTcpConnection with the given parameters. \r\n\t\t\t * \r\n\t\t\t * @param endpointServer EndpointServer for opc.tcp\r\n\t\t\t * @param s socket\r\n\t\t\t */\r\n\t\t\tOpcTcpServerConnection(OpcTcpServer endpointServer, AsyncSocketImpl s) {\r\n\t\t\t\tthis(endpointServer, s, null);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Creates a new OpcTcpConnection with the given parameters.\r\n\t\t\t * \r\n\t\t\t * @param endpointServer EndpointServer for opc.tcp\r\n\t\t\t * @param s socket\r\n\t\t\t * @param rh, if null, assumes normal connection, if non-null assumes ReverseHello connection.\r\n\t\t\t */\r\n\t\t\tOpcTcpServerConnection(OpcTcpServer endpointServer, AsyncSocketImpl s, final ReverseHello rh) {\r\n\t\t\t\tsuper();\r\n\t\t\t\tthis.endpointServer = endpointServer;\r\n\t\t\t\tthis.s = s;\r\n\t\t\t\tthis.rh = rh;\r\n\r\n\t\t\t\tthis.encoderCtx = endpointServer.getEncoderContext();\r\n\r\n\t\t\t\t// Monitor the state of the socket, make changes reflect to the state of the UATcpConnection\r\n\t\t\t\tsocketListener =\r\n\t\t\t\t\t\tnew StateListener<SocketState>() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onStateTransition(IStatefulObject<SocketState, ?> monitor, SocketState oldState, SocketState newState) {\r\n\t\t\t\t\t\tif (newState==SocketState.Error)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsetError( StackUtils.toServiceResultException( OpcTcpServerConnection.this.s.getStateMonitor().getError() ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (newState==SocketState.Closed)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tclose();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tsetState(CloseableObjectState.Opening);\r\n\r\n\t\t\t\ts.getStateMonitor().addStateListener(socketListener);\r\n\t\t\t\ts.getInputStream().createMonitor(8, inputListener);\r\n\t\t\t\t\r\n\t\t\t\tif(rh == null) {\r\n\t\t\t\t\ttimeoutTimer = TimerUtil.schedule(\r\n\t\t\t\t\t\t\ttimer, timeout,\r\n\t\t\t\t\t\t\tStackUtils.getBlockingWorkExecutor(),\r\n\t\t\t\t\t\t\tSystem.currentTimeMillis() + handshakeTimeout);\r\n\t\t\t\t}\r\n\t\t\t\tif(rh != null) {\r\n\t\t\t\t\ts.getStateMonitor().addStateListener(new StateListener<SocketState>() {\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onStateTransition(\r\n\t\t\t\t\t\t\t\tIStatefulObject<SocketState, ?> sender,\r\n\t\t\t\t\t\t\t\tSocketState oldState, SocketState newState) {\r\n\t\t\t\t\t\t\tif(oldState == SocketState.Connecting && newState == SocketState.Connected) {\r\n\t\t\t\t\t\t\t\ttimeoutTimer = TimerUtil.schedule(\r\n\t\t\t\t\t\t\t\t\t\ttimer, timeout,\r\n\t\t\t\t\t\t\t\t\t\tStackUtils.getBlockingWorkExecutor(),\r\n\t\t\t\t\t\t\t\t\t\tSystem.currentTimeMillis() + handshakeTimeout);\r\n\t\t\t\t\t\t\t\tsendReverseHello(rh);\r\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic void addConnectionListener(IConnectionListener listener) {\r\n\t\t\t\tlogger.debug(\"addConnectionListener: listener={}\", listener);\r\n\t\t\t\tsuper.addConnectionListener(listener);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic synchronized CloseableObject close() {\r\n\t\t\t    // clear timeout timer, if exist, otherwise it will keep this object alive GC-wise.\r\n\t\t\t    cancelTimeoutTimer();\r\n\t\t\t    try {\r\n\t\t\t\t\tsetState(CloseableObjectState.Closing);\r\n\t\t\t\t} finally {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\ts.close();\r\n\t\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsetState(CloseableObjectState.Closed);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic SocketAddress getLocalAddress() {\r\n\t\t\t\tSocket socket = s.socket();\r\n\t\t\t\tif (socket==null) return null;\r\n\t\t\t\treturn socket.getLocalSocketAddress();\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic SocketAddress getRemoteAddress() {\r\n\t\t\t\tSocket socket = s.socket();\r\n\t\t\t\tif (socket==null) return null;\r\n\t\t\t\treturn socket.getRemoteSocketAddress();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Returns true if this connection has (or had) a Session that was successfully Activated at least\r\n\t\t\t * once. Returns false in other cases.\r\n\t\t\t */\r\n\t\t\tpublic boolean hasBeenSuccessfullySessionActivated() {\r\n\t\t\t\treturn hasBeenSuccessfullySessionActivated.get();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns true if this connection is eligble to be purged if we approach max number of\r\n\t\t\t * connections, false if this connection is valid and should not be purged. Per 1.05 Part 4\r\n\t\t\t * section 5.5.2 \"To protect against misbehaving Clientsand denial of service attacks, the\r\n\t\t\t * Servershall close the oldest unused SecureChannelthat has no Sessionassigned before reaching\r\n\t\t\t * the maximum number of supported SecureChannels.\". However, in addition if the connection was\r\n\t\t\t * formed via a ReverseHello, it is not considered to be eligible as server was the one initiating\r\n\t\t\t * the connection. Thus this returns true, if this connection is neither a reverse connection and\r\n\t\t\t * also has not yet been activated by a Session.\r\n\t\t\t */\r\n\t\t\tpublic boolean isPurgeEligible() {\r\n\t\t\t\treturn !isReverse() && !hasBeenSuccessfullySessionActivated();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Return true if this connection is a reverse connection i.e. where the server send a\r\n\t\t\t * ReverseHello to a Client to initiate the connection.\r\n\t\t\t */\r\n\t\t\tpublic boolean isReverse() {\r\n\t\t\t\treturn rh != null;\r\n\t\t\t}\t\t\t\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic void removeConnectionListener(IConnectionListener listener) {\r\n\t\t\t\tlogger.debug(\"removeConnectionListener: listener={}\", listener);\r\n\t\t\t\tsuper.removeConnectionListener(listener);\r\n\t\t\t\tcancelTimeoutTimer();\r\n\t\t\t}\r\n\r\n\t\t\tprivate void checkSecureChannelLimit() throws ServiceResultException {\r\n\t\t\t\tif (secureChannels.size() >= endpointServer.maxSecureChannelsPerConnection) {\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpNotEnoughResources);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * @param uri\r\n\t\t\t * @return\r\n\t\t\t */\r\n\t\t\tprivate String trimUrl(String uri) {\r\n\t\t\t\tif ( uri==null ) return null;\r\n\t\t\t\t// Also remove an optional '/' from the end, since it is not significant\r\n\t\t\t\tif (uri.endsWith(\"/\"))\r\n\t\t\t\t\turi = uri.substring(0, uri.length()-1);\r\n\t\t\t\treturn uri;\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>cancelTimeoutTimer.</p>\r\n\t\t\t */\r\n\t\t\tprotected void cancelTimeoutTimer() {\r\n\t\t\t    // Cancel hand-shake time-out, note that this can never be started again, thus it wont hurt if\r\n\t\t\t    // this happens multiple times\r\n\t\t\t    final TimerTask tmp = timeoutTimer; // multithread-guard\r\n\t\t\t    if (tmp != null) {\r\n\t\t\t    \ttmp.cancel();\r\n\t\t\t    \ttimeoutTimer = null;\r\n\t\t\t\t\ttimeout = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Flushes queued chunks (see startChunkSend())\r\n\t\t\t *\r\n\t\t\t * @param chunk chunk to send\r\n\t\t\t */\r\n\t\t\tprotected void endChunkSend(ByteBuffer chunk)\r\n\t\t\t{\r\n\t\t\t\tchunkIncubator.hatch(chunk);\r\n\t\t\t\tsynchronized(this) {\r\n\t\t\t\t\twhile (chunkIncubator.nextIsHatched()) {\r\n\t\t\t\t\t\tByteBuffer c = chunkIncubator.removeNextHatchedIfAvailable();\r\n\t\t\t\t\t\tc.rewind();\r\n\t\t\t\t\t\ts.getOutputStream().offer(c);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>flush.</p>\r\n\t\t\t *\r\n\t\t\t * @param position a long.\r\n\t\t\t * @return a {@link org.opcfoundation.ua.utils.asyncsocket.BufferMonitorState} object.\r\n\t\t\t * @throws java.lang.InterruptedException if any.\r\n\t\t\t * @throws java.io.IOException if any.\r\n\t\t\t */\r\n\t\t\tprotected BufferMonitorState flush(long position)\r\n\t\t\t\t\tthrows InterruptedException, IOException\r\n\t\t\t{\r\n\t\t\t\treturn s.getOutputStream().createMonitor(position, null).waitForState(BufferMonitorState.FINAL_STATES);\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tprotected CertificateValidator getRemoteCertificateValidator() {\r\n\t\t\t\treturn binding==null ? null: binding.serviceServer.getApplication().getOpctcpSettings().getCertificateValidator();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleAcknowledgeMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param a a {@link org.opcfoundation.ua.transport.tcp.impl.Acknowledge} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleAcknowledgeMessage(Acknowledge a) throws ServiceResultException {\r\n\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleAsymmChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleAsymmChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tchunk.rewind();\r\n\t\t\t\tif (secureMessageBuilder!=null && !secureMessageBuilder.moreChunksRequired()) secureMessageBuilder = null;\r\n\r\n\t\t\t\t// First chunk of the message\r\n\t\t\t\tif (secureMessageBuilder==null) {\r\n\t\t\t\t\t// Read remote certificate and thumbprint of the expected local certificate\r\n\t\t\t\t\t//\t\t\tchunk.position(8);\r\n\t\t\t\t\t//\t\t\tint secureChannelId = chunk.getInt();\r\n\t\t\t\t\tint secureChannelId = ChunkUtils.getSecureChannelId(chunk);\r\n\t\t\t\t\tOpcTcpServerSecureChannel secureChannel =(OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\t\tString securityPolicyUri = ChunkUtils.getString(chunk);\r\n\t\t\t\t\tSecurityPolicy securityPolicy = SecurityPolicy.getSecurityPolicy(securityPolicyUri);\r\n\t\t\t\t\tif (securityPolicy==null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlogger.warn(\"Security policy \\\"{}\\\" is not supported by the stack\", securityPolicyUri);\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_SecurityPolicyRejected, \"Security policy \\\"\"+securityPolicyUri+\"\\\" is not supported by the stack\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\t\t\tif (!binding.endpointAddress.supportsSecurityPolicy(securityPolicy))\r\n\t\t\t\t\t//\t\t\t{\r\n\t\t\t\t\t//\t\t\t\tlogger.warn(\"Security policy \\\"\"+securityPolicyUri+\"\\\" is not supported by the endpoint\");\r\n\t\t\t\t\t//\t\t\t\tthrow new ServiceResultException(Bad_SecurityPolicyRejected, \"Security policy \\\"\"+securityPolicyUri+\"\\\" is not supported by the endpoint\");\r\n\t\t\t\t\t//\t\t\t}\r\n\r\n\t\t\t\t\tbyte[] encodedRemoteCertificate = ChunkUtils.getByteString(chunk);\r\n\t\t\t\t\tbyte[] encodedLocalCertificateThumbprint = ChunkUtils.getByteString(chunk);\r\n\t\t\t\t\tlogger.debug(\"secureChannelId={}\", secureChannelId);\r\n\t\t\t\t\tlogger.debug(\"secureChannel={}\", secureChannel);\r\n\t\t\t\t\tlogger.debug(\"securityPolicyUri={}\", securityPolicyUri);\r\n\t\t\t\t\tlogger.debug(\"securityPolicy={}\", securityPolicy);\r\n\t\t\t\t\tlogger.debug(\"encodedRemoteCertificate={}\", encodedRemoteCertificate);\r\n\t\t\t\t\tlogger.debug(\"encodedLocalCertificateThumbprint={}\", encodedLocalCertificateThumbprint);\r\n\r\n\r\n\t\t\t\t\tKeyPair localCertificate = binding.serviceServer.getApplication().getApplicationInstanceCertificate(encodedLocalCertificateThumbprint);\r\n\r\n\t\t\t\t\tif (localCertificate==null && securityPolicy != SecurityPolicy.NONE) {\r\n\t\t\t\t\t\tlogger.warn(\"Requested Application Instance Certificate is not found in the server\");\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_SecurityChecksFailed, \"Requested Application Instance Certificate is not found in the server\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Decode remote certificate\r\n\t\t\t\t\torg.opcfoundation.ua.transport.security.Cert remoteCertificate;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tremoteCertificate =\r\n\t\t\t\t\t\t\t\tencodedRemoteCertificate==null ?\r\n\t\t\t\t\t\t\t\t\t\tnull :\r\n\t\t\t\t\t\t\t\t\t\t\tnew org.opcfoundation.ua.transport.security.Cert( CertificateUtils.decodeX509Certificate(encodedRemoteCertificate) );\r\n\t\t\t\t\t} catch (CertificateException e) {\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_SecurityChecksFailed); //see 1.02.2 errdata\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Validate Client's Certificate\r\n\t\t\t\t\tCertificateValidator validator = getRemoteCertificateValidator();\r\n\t\t\t\t\tif (validator != null) {\r\n\t\t\t\t\t\tStatusCode code = validator.validateCertificate(remoteCertificate);\r\n\t\t\t\t\t\tif (code != null && !code.isGood()) {\r\n\t\t\t\t\t\t\tlogger.warn(\"Remote certificate not accepted: {}\", code.toString());\r\n\t\t\t\t\t\t\tthrow new ServiceResultException(code);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// MessageMode is unknown at this time. It is fixed in UATcpServerSecureChannel.onOpenChannel\r\n\t\t\t\t\tMessageSecurityMode msm = securityPolicy == SecurityPolicy.NONE ? MessageSecurityMode.None : MessageSecurityMode.SignAndEncrypt;\r\n\t\t\t\t\tSecurityMode mode = new SecurityMode(securityPolicy, msm);\r\n\t\t\t\t\tsecurityConfiguration = new SecurityConfiguration(mode, localCertificate, remoteCertificate);\r\n\r\n\t\t\t\t\tAtomicInteger recvSequenceNumber = secureChannel==null ? null : secureChannel.recvSequenceNumber;\r\n\r\n\t\t\t\t\tsecureMessageBuilder = new SecureInputMessageBuilder(securityConfiguration, messageListener, ctx, encoderCtx, recvSequenceNumber);\r\n\t\t\t\t}\r\n\t\t\t\tlogger.debug(\"onAsymmSecureChunk: {}\", chunk);\r\n\t\t\t\tsecureMessageBuilder.addChunk(chunk);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tint type = ChunkUtils.getMessageType(chunk);\r\n\t\t\t\tint messageType = type & TcpMessageType.MESSAGE_TYPE_MASK;\r\n\t\t\t\t// Secure message\r\n\t\t\t\tif (messageType == TcpMessageType.MESSAGE) {\r\n\t\t\t\t\thandleSymmChunk(chunk);\r\n\t\t\t\t} else if (messageType == TcpMessageType.CLOSE) {\r\n\t\t\t\t\thandleCloseChunk(chunk);\r\n\t\t\t\t} else if (messageType == TcpMessageType.OPEN) {\r\n\t\t\t\t\thandleAsymmChunk(chunk);\r\n\t\t\t\t} else if (messageType == TcpMessageType.HELLO || messageType == TcpMessageType.ACKNOWLEDGE || messageType == TcpMessageType.ERROR) {\r\n\t\t\t\t\thandleRawChunk(chunk);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Unknown chunk\r\n\t\t\t\t\tclose();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleCloseChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleCloseChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tclose();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleCloseSecureChannelRequest.</p>\r\n\t\t\t *\r\n\t\t\t * @param mb a {@link org.opcfoundation.ua.transport.tcp.nio.InputMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleCloseSecureChannelRequest(InputMessage mb) throws ServiceResultException {\r\n\t\t\t\tlogger.debug(\"onCloseChannel\");\r\n\t\t\t\tIEncodeable msg = mb.getMessage();\r\n\t\t\t\tif (!(msg instanceof CloseSecureChannelRequest))\r\n\t\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\tCloseSecureChannelRequest req = (CloseSecureChannelRequest) msg;\r\n\t\t\t\tint secureChannelId = mb.getSecureChannelId();\r\n\t\t\t\tOpcTcpServerSecureChannel chan = (OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\tif (chan==null) throw new ServiceResultException( Bad_SecureChannelIdInvalid );\r\n\t\t\t\tchan.handleCloseSecureChannelRequest(mb, req);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleErrorMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param e a {@link org.opcfoundation.ua.transport.tcp.impl.ErrorMessage} object.\r\n\t\t\t */\r\n\t\t\tprotected void handleErrorMessage(ErrorMessage e) {\r\n\t\t\t\tlogger.debug(\"onError: {}\", e);\r\n\t\t\t\tsetError(e.getError());\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleHelloMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param h a {@link org.opcfoundation.ua.transport.tcp.impl.Hello} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleHelloMessage(Hello h) throws ServiceResultException {\r\n\t\t\t\tcancelTimeoutTimer();\r\n\r\n\t\t\t\tEndpointBindingCollection c = endpointServer.getEndpointBindings();\r\n\t\t\t\tif (c==null) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t    checkSecureChannelLimit();\r\n\t\t\t    \r\n\t\t\t    String url = trimUrl(h.getEndpointUrl());\r\n\r\n\t\t\t\tlogger.debug(\"onHello: url={}\", url);\r\n\r\n\t\t\t\tif ( url==null || url.equals(\"\") ) {\r\n\t\t\t\t\tbinding = endpointServer.discoveryEndpointBinding;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tList<EndpointBinding> bindingsForUrl = c.get( url );\r\n\t\t\t\t\tif (bindingsForUrl.isEmpty()) {\r\n\t\t\t\t\t\tbinding = c.getDefault(url);\r\n\t\t\t\t\t\tif(binding == null){\r\n\t\t\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpEndpointUrlInvalid);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbinding = bindingsForUrl.get(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Makes sense to check isDebugEnabled because Arrays.toString method probably takes longer than this check.\r\n\t\t\t\tif(logger.isDebugEnabled()){\r\n\t\t\t\t\tlogger.debug(\" endpoints={}\", Arrays.toString(c.getEndpointAddresses().toArray(new Endpoint[0])));\r\n\t\t\t\t\tlogger.debug(\" endpoint=\" + (binding==null?\"binding is null\":binding.endpointAddress));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (getState()!=CloseableObjectState.Opening) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\tAcknowledge a = new Acknowledge();\r\n\r\n\t\t\t\t// Assert sane values from client\r\n\t\t\t\tif (h.getSendBufferSize().longValue()<8192)\r\n\t\t\t\t\tsetError(new ServiceResultException(Bad_TcpInternalError, \"Peer send buffer size <  8192\"));\r\n\t\t\t\tif (h.getReceiveBufferSize().longValue()<8192)\r\n\t\t\t\t\tsetError(new ServiceResultException(Bad_TcpInternalError, \"Peer recv buffer size <  8192\"));\r\n\t\t\t\tif (getError() != null)\r\n\t\t\t\t\tlogger.warn(\"onHello: \" + getError());\r\n\r\n\t\t\t\t// Determine communication protocol version\r\n\t\t\t\tagreedProtocolVersion = Math.min(StackUtils.TCP_PROTOCOL_VERSION, h.getProtocolVersion().intValue());\r\n\t\t\t\ta.setProtocolVersion( UnsignedInteger.getFromBits(agreedProtocolVersion) );\r\n\r\n\t\t\t\t// Message size\r\n\t\t\t\tif (h.getMaxMessageSize()!=null && h.getMaxMessageSize().intValue()!=0) {\r\n\t\t\t\t\tif (ctx.maxSendMessageSize==0)\r\n\t\t\t\t\t\tctx.maxSendMessageSize = h.getMaxMessageSize().intValue();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tctx.maxSendMessageSize = Math.min(ctx.maxSendMessageSize, h.getMaxMessageSize().intValue());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( binding != null ) {\r\n\t\t\t\t\tint maxMsgSize = binding.endpointAddress.getEndpointConfiguration().getMaxMessageSize();\r\n\t\t\t\t\tctx.maxSendMessageSize = ctx.maxSendMessageSize == 0 ? maxMsgSize : Math.min(ctx.maxSendMessageSize, maxMsgSize);\r\n\t\t\t\t\tctx.maxRecvMessageSize = ctx.maxRecvMessageSize == 0 ? maxMsgSize : Math.min(ctx.maxRecvMessageSize, maxMsgSize);\r\n\t\t\t\t\tencoderCtx.maxMessageSize = maxMsgSize;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tencoderCtx.maxMessageSize = ctx.maxSendMessageSize;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Chunk count\r\n\t\t\t\tif (h.getMaxChunkCount().intValue()!=0)\r\n\t\t\t\t\tctx.maxSendChunkCount = Math.min(ctx.maxSendChunkCount, h.getMaxChunkCount().intValue());\r\n\t\t\t\ta.setMaxChunkCount( UnsignedInteger.getFromBits( ctx.maxRecvChunkCount ) );\r\n\r\n\t\t\t\t// Chunk sizes\r\n\t\t\t\tctx.maxSendChunkSize = Math.min(h.getReceiveBufferSize().intValue(), ctx.maxSendChunkSize);\r\n\t\t\t\tctx.maxRecvChunkSize = Math.min(h.getSendBufferSize().intValue(), ctx.maxRecvChunkSize);\r\n\t\t\t\ta.setSendBufferSize(UnsignedInteger.getFromBits(ctx.maxSendChunkSize));\r\n\t\t\t\ta.setReceiveBufferSize(UnsignedInteger.getFromBits(ctx.maxRecvChunkSize));\r\n\r\n\t\t\t\t// Send buffer (chunk) size\r\n\t\t\t\tctx.maxRecvChunkSize = Math.min(ctx.maxRecvChunkSize, h.getReceiveBufferSize().intValue());\r\n\t\t\t\tctx.maxSendChunkSize = Math.min(ctx.maxSendChunkSize, h.getSendBufferSize().intValue());\r\n\t\t\t\tsetState(CloseableObjectState.Opening);\r\n\r\n\t\t\t\tctx.endpointUrl = h.getEndpointUrl();\r\n\r\n\t\t\t\tsendAcknowledge(a);\r\n\t\t\t\tsetState(CloseableObjectState.Open);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleOpenSecureChannelRequest.</p>\r\n\t\t\t *\r\n\t\t\t * @param mb a {@link org.opcfoundation.ua.transport.tcp.nio.InputMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleOpenSecureChannelRequest(InputMessage mb) throws ServiceResultException {\r\n\t\t\t\tIEncodeable msg = mb.getMessage();\r\n\t\t\t\tif (msg == null)\r\n\t\t\t\t\tsynchronized (this) {\r\n\t\t\t\t\t\tException e = mb.getError();\r\n\t\t\t\t\t\tlogger.warn(\"InputMessage has error\", e);\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError, e);\r\n\t\t\t\t\t}\r\n\t\t\t\tif (!(msg instanceof OpenSecureChannelRequest))\r\n\t\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\tOpenSecureChannelRequest req\t\t= (OpenSecureChannelRequest) msg;\r\n\r\n\t\t\t\tif (req.getRequestType() == SecurityTokenRequestType.Issue)\r\n\t\t\t\t{\r\n\t\t\t\t\tcheckSecureChannelLimit();\r\n\t\t\t\t      \r\n\t\t\t\t\tOpcTcpServerSecureChannel channel = new OpcTcpServerSecureChannel( this, endpointServer.secureChannelCounter.incrementAndGet() );\r\n\t\t\t\t\tlogger.debug(\"handleOpenSecureChannelRequest: endpointServer={} SecureChannelId={}\", endpointServer, channel.getSecureChannelId());\r\n\t\t\t\t\tchannel.handleOpenChannel(mb, req);\r\n\t\t\t\t} else if (req.getRequestType() == SecurityTokenRequestType.Renew) {\r\n\t\t\t\t\tOpcTcpServerSecureChannel channel = (OpcTcpServerSecureChannel) secureChannels.get(mb.getSecureChannelId());\r\n\t\t\t\t\tif (channel==null)\r\n\t\t\t\t\t\tthrow new ServiceResultException( Bad_SecureChannelIdInvalid );\r\n\r\n\t\t\t\t\tif (!ObjectUtils.objectEquals(req.getRequestType(), SecurityTokenRequestType.Renew)) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\t\tchannel.handleRenewSecureChannelRequest(mb, req);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove closed channels, should maybe be based on timestamps TODO\r\n\t\t\t\tObject[] channelArray = secureChannels.values().toArray();\r\n\t\t\t\tfor (Object channel : channelArray)\r\n\t\t\t\t\tif(((AbstractServerSecureChannel)channel).getState().equals(CloseableObjectState.Closed))\r\n\t\t\t\t\t\tsecureChannels.remove(((AbstractServerSecureChannel)channel).getSecureChannelId());\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleRawChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t */\r\n\t\t\tprotected void handleRawChunk(ByteBuffer chunk) {\r\n\t\t\t\tint type = ChunkUtils.getMessageType(chunk);\r\n\t\t\t\tint messageType = type & TcpMessageType.MESSAGE_TYPE_MASK;\r\n\t\t\t\tint chunkType = type & TcpMessageType.CHUNK_TYPE_MASK;\r\n\t\t\t\tif (chunkType != TcpMessageType.FINAL) {\r\n\t\t\t\t\tclose();\r\n\t\t\t\t}\r\n\t\t\t\tchunk.position(8);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (messageType == TcpMessageType.HELLO) {\r\n\t\t\t\t\t\tChunksToMessage c2m = new ChunksToMessage(ctx, encoderCtx, Hello.class, chunk);\r\n\t\t\t\t\t\thandleHelloMessage( (Hello) c2m.call() );\r\n\t\t\t\t\t} else if (messageType == TcpMessageType.ACKNOWLEDGE) {\r\n\t\t\t\t\t\tChunksToMessage c2m = new ChunksToMessage(ctx, encoderCtx, Acknowledge.class, chunk);\r\n\t\t\t\t\t\thandleAcknowledgeMessage( (Acknowledge) c2m.call() );\r\n\t\t\t\t\t} else if (messageType == TcpMessageType.ERROR) {\r\n\t\t\t\t\t\tChunksToMessage c2m = new ChunksToMessage(ctx, encoderCtx, ErrorMessage.class, chunk);\r\n\t\t\t\t\t\thandleErrorMessage( (ErrorMessage) c2m.call() );\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tsetError( StackUtils.toServiceResultException(e) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleSecureMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param mb a {@link org.opcfoundation.ua.transport.tcp.nio.InputMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleSecureMessage(InputMessage mb) throws ServiceResultException {\r\n\t\t\t\tIEncodeable msg = mb.getMessage();\r\n\t\t\t\tint secureChannelId = mb.getSecureChannelId();\r\n\t\t\t\tif (logger.isDebugEnabled())\r\n\t\t\t\t\tlogger.debug(\"handleSecureMessage: secureChannelId=\" + secureChannelId + \"msg=\" + (msg == null ? \"null\" : msg.getClass().getSimpleName()));\r\n\r\n\t\t\t\tOpcTcpServerSecureChannel chan = (OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\tif (chan==null)\r\n\t\t\t\t\tthrow new ServiceResultException( Bad_SecureChannelIdInvalid );\r\n\r\n\t\t\t\tif (msg instanceof OpenSecureChannelRequest) {\r\n\t\t\t\t\tOpenSecureChannelRequest req = (OpenSecureChannelRequest) msg;\r\n\r\n\t\t\t\t\tif (!ObjectUtils.objectEquals(req.getRequestType(), SecurityTokenRequestType.Renew)) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\t\tchan.handleRenewSecureChannelRequest(mb, req);\r\n\t\t\t\t} else if (msg instanceof CloseSecureChannelRequest) {\r\n\t\t\t\t\tchan.handleCloseSecureChannelRequest(mb, (CloseSecureChannelRequest)msg);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchan.handleSecureMessage(mb, msg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleSymmChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleSymmChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tint secureChannelId = ChunkUtils.getSecureChannelId(chunk);\r\n\t\t\t\tint tokenId = ChunkUtils.getTokenId(chunk);\r\n\t\t\t\tchunk.rewind();\r\n\r\n\t\t\t\tOpcTcpServerSecureChannel channel = (OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\tif (channel==null)\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpSecureChannelUnknown);\r\n\t\t\t\tif (channel.getState().equals(CloseableObjectState.Closed))\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_SecureChannelIdInvalid);\r\n\t\t\t\tSecurityToken token = channel.getSecurityToken(tokenId);\r\n\t\t\t\tif (token==null)\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_SecureChannelTokenUnknown);\r\n\t\t\t\tif (!token.isValid())\r\n\t\t\t\t\ttoken = channel.getLatestNonExpiredToken();\r\n\t\t\t\tif (token==null || !token.isValid()) {\r\n\t\t\t\t\tSystem.err.println(\"Token expired\");\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_SecureChannelClosed);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tSecurityToken activeToken = channel.getActiveSecurityToken();\r\n\t\t\t\tif (token!=activeToken) {\r\n\t\t\t\t\tlogger.debug(\"handleSymmChunk: activeToken={}, token={}\", activeToken, token);\r\n\t\t\t\t\tif (activeToken.getCreationTime() < token.getCreationTime()) {\r\n\t\t\t\t\t\tchannel.setActiveSecurityToken(token);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tlogger.debug(\"handleSymmChunk: {}\", secureMessageBuilder);\r\n\t\t\t\tif (secureMessageBuilder!=null && !secureMessageBuilder.moreChunksRequired()) {\r\n\t\t\t\t      // Ensures streams eventually close by putting a \"poison pill\" there\r\n\t\t\t\t      secureMessageBuilder.softClose();\r\n\t\t\t\t      secureMessageBuilder = null;\r\n\t\t\t\t}\r\n\t\t\t\tif (secureMessageBuilder==null) {\r\n\t\t\t\t\tsecureMessageBuilder = new SecureInputMessageBuilder(token/*channel*/, messageListener, ctx, encoderCtx, channel.recvSequenceNumber);\r\n\t\t\t\t\tlogger.debug(\"handleSymmChunk: secureMessageBuilder={}\", secureMessageBuilder);\r\n\t\t\t\t\t//\t\t\t\tonSecureMessageBegin(secureMessageBuilder, chunk);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsecureMessageBuilder.addChunk(chunk);\r\n\t\t\t}\r\n\r\n\t\t\t// Propagate connection closed/error to channels\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tprotected synchronized void onStateTransition(CloseableObjectState oldState,\r\n\t\t\t\t\tCloseableObjectState newState) {\r\n\t\t\t\tsuper.onStateTransition(oldState, newState);\r\n\t\t\t\tlogger.debug(\"onStateTransition: {}->{}\", oldState, newState);\r\n\r\n\t\t\t\tif (newState == CloseableObjectState.Closing)\r\n\t\t\t\t{\r\n\t\t\t\t\tServiceResultException err = getError();\r\n\t\t\t\t\tList<ServerSecureChannel> list = new ArrayList<ServerSecureChannel>();\r\n\t\t\t\t\tOpcTcpServerConnection.this.getSecureChannels(list);\r\n\t\t\t\t\tfor (ServerSecureChannel c : list)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tOpcTcpServerSecureChannel cc = (OpcTcpServerSecureChannel) c;\r\n\t\t\t\t\t\tif (cc != null && err!=null) cc.setError(err);\r\n\t\t\t\t\t\tc.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>sendAcknowledge.</p>\r\n\t\t\t *\r\n\t\t\t * @param a a {@link org.opcfoundation.ua.transport.tcp.impl.Acknowledge} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void sendAcknowledge(Acknowledge a)\r\n\t\t\t\t\tthrows ServiceResultException\r\n\t\t\t{\r\n\t\t\t\tChunkFactory rawChunkFactory = new AcknowledgeChunkFactory();\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(a, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tassert(chunks.length==1);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.ACKNOWLEDGE | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * {@inheritDoc}\r\n\t\t\t *\r\n\t\t\t * Send asymmetric secure message.\r\n\t\t\t */\r\n\t\t\t@Override\r\n\t\t\tprotected int sendAsymmSecureMessage(\r\n\t\t\t\t\tfinal AsyncWrite msg,\r\n\t\t\t\t\tfinal SecurityConfiguration securityConfiguration,\r\n\t\t\t\t\tint secureChannelId,\r\n\t\t\t\t\tint requestNumber,\r\n\t\t\t\t\tAtomicInteger sendSequenceNumber)\r\n\t\t\t\t\t\t\tthrows ServiceResultException\r\n\t\t\t{\r\n\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\tif (msg.isCanceled()) return -1;\r\n\t\t\t\t\tmsg.setQueued();\r\n\t\t\t\t}\r\n\t\t\t\tChunkFactory cf = new ChunkFactory.AsymmMsgChunkFactory(ctx.maxSendChunkSize, securityConfiguration);\r\n\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(msg.getMessage(), ctx, encoderCtx, cf, MessageType.Message);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = cf.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\tif (msg.isCanceled()) return -1;\r\n\t\t\t\t\tmsg.setWriting();\r\n\t\t\t\t}\r\n\t\t\t\tSecurityPolicy policy = securityConfiguration.getSecurityPolicy();\r\n\r\n\t\t\t\tstartChunkSend(chunks);\r\n\t\t\t\tfor (int i=0; i<chunks.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tByteBuffer chunk = chunks[i];\r\n\t\t\t\t\tByteBuffer plaintext = plaintexts[i];\r\n\t\t\t\t\tboolean finalChunk = chunk == chunks[chunks.length-1];\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\tchunk.putInt( TcpMessageType.OPEN | (finalChunk ? TcpMessageType.FINAL : TcpMessageType.CONTINUE) );\r\n\t\t\t\t\tchunk.position(8);\r\n\t\t\t\t\tchunk.putInt(secureChannelId);\r\n\r\n\t\t\t\t\t// -- Security Header --\r\n\t\t\t\t\t// Policy URI\r\n\t\t\t\t\tbyte[] data = policy.getEncodedPolicyUri();\r\n\t\t\t\t\tchunk.putInt(data.length);\r\n\t\t\t\t\tchunk.put(data);\r\n\r\n\t\t\t\t\t// Sender Certificate\r\n\t\t\t\t\tdata = securityConfiguration.getEncodedLocalCertificate();\r\n\t\t\t\t\tchunk.putInt( data==null ? -1 : data.length);\r\n\t\t\t\t\tif (data!=null)\tchunk.put(data);\r\n\r\n\t\t\t\t\t// Recv Certificate Thumbprint\r\n\t\t\t\t\tdata = securityConfiguration.getEncodedRemoteCertificateThumbprint();\r\n\t\t\t\t\tchunk.putInt( data == null ? -1 : data.length);\r\n\t\t\t\t\tif (data!=null)\tchunk.put(data);\r\n\r\n\t\t\t\t\t// -- Sequence header --\r\n\t\t\t\t\tchunk.putInt(sendSequenceNumber.getAndIncrement());\r\n\t\t\t\t\tchunk.putInt(requestNumber); // Request number\r\n\r\n\t\t\t\t\tnew ChunkAsymmEncryptSigner(chunk, plaintext, securityConfiguration).run();\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\tendChunkSend(chunk);\r\n\t\t\t\t}\r\n\t\t\t\tmsg.setWritten();\r\n\t\t\t\treturn chunks.length;\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Send chunks.\r\n\t\t\t *\r\n\t\t\t * @param chunks a {@link java.nio.ByteBuffer} object.\r\n\t\t\t */\r\n\t\t\tprotected synchronized void sendChunks(ByteBuffer...chunks)\r\n\t\t\t{\r\n\t\t\t\tstartChunkSend(chunks);\r\n\t\t\t\tfor (ByteBuffer chunk : chunks)\r\n\t\t\t\t\tendChunkSend(chunk);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>sendError.</p>\r\n\t\t\t *\r\n\t\t\t * @param e a {@link org.opcfoundation.ua.transport.tcp.impl.ErrorMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void sendError(ErrorMessage e)\r\n\t\t\t\t\tthrows ServiceResultException\r\n\t\t\t{\r\n\t\t\t\tChunkFactory rawChunkFactory = new ErrorMessageChunkFactory();\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(e, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tassert(chunks.length==1);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.ERROR | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>sendHello.</p>\r\n\t\t\t *\r\n\t\t\t * @param h a {@link org.opcfoundation.ua.transport.tcp.impl.Hello} object.\r\n\t\t\t */\r\n\t\t\tprotected void sendHello(Hello h)\r\n\t\t\t{\r\n\t\t\t\tctx.endpointUrl = h.getEndpointUrl();\r\n\t\t\t\tChunkFactory rawChunkFactory = new ChunkFactory(ctx.maxSendChunkSize, 8, 0, 0, 0, 1, MessageSecurityMode.None, 0);\r\n\t\t\t\t//ChunkFactory rawChunkFactory = new HelloChunkFactory();\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(h, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tassert(chunks.length==1);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.HELLO | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t}\r\n\r\n\t\t\tprotected void sendReverseHello(ReverseHello rh) {\r\n\t\t\t\tChunkFactory rawChunkFactory = new ChunkFactory(ctx.maxSendChunkSize, 8, 0, 0, 0, 1, MessageSecurityMode.None, 0);\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(rh, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.REVERSE_HELLO | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t\t\r\n\t\t\t\tlogger.debug(\"Sent ReverseHello: {}\", rh);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * {@inheritDoc}\r\n\t\t\t *\r\n\t\t\t * Send symmetric secure message\r\n\t\t\t */\r\n\t\t\t@Override\r\n\t\t\tprotected void sendSecureMessage(\r\n\t\t\t\t\tfinal AsyncWrite msg,\r\n\t\t\t\t\tfinal SecurityToken token,\r\n\t\t\t\t\tfinal int requestId,\r\n\t\t\t\t\tfinal int messageType,\r\n\t\t\t\t\tfinal AtomicInteger sendSequenceNumber\r\n\t\t\t\t\t)\r\n\t\t\t{\r\n\t\t\t\tassert(token!=null);\r\n\t\t\t\tByteBuffer chunks[], plaintexts[];\r\n\t\t\t\tboolean concurrent;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\t\tif (msg.isCanceled()) return;\r\n\t\t\t\t\t\tmsg.setQueued();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Probably more efficient to check isTraceEnabled before executing ObjectUtils.printFieldsDeep\r\n\t\t\t\t\tif (logger.isTraceEnabled())\r\n\t\t\t\t\t\tlogger.trace(\"sendSecureMessage: \" + ObjectUtils.printFieldsDeep(msg.getMessage()));\r\n\t\t\t\t\tSizeCalculationOutputStream calcBuf = new SizeCalculationOutputStream();\r\n\t\t\t\t\tBinaryEncoder calc = new BinaryEncoder(calcBuf);\r\n\t\t\t\t\tcalc.setEncoderContext(encoderCtx);\r\n\t\t\t\t\tcalc.putMessage(msg.getMessage());\r\n\t\t\t\t\tint len = calcBuf.getLength();\r\n\r\n\t\t\t\t\tif (len>ctx.maxSendMessageSize && ctx.maxSendMessageSize!=0)\r\n\t\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpMessageTooLarge);\r\n\r\n\t\t\t\t\tSecurityPolicy policy = token.getSecurityPolicy();\r\n\t\t\t\t\tMessageSecurityMode mode = token.getMessageSecurityMode();\r\n\t\t\t\t\tSecurityAlgorithm symmEncryptAlgo = policy.getSymmetricEncryptionAlgorithm();\r\n\t\t\t\t\tSecurityAlgorithm symmSignAlgo = policy.getSymmetricSignatureAlgorithm();\r\n\t\t\t\t\tint cipherBlockSize = CryptoUtil.getCipherBlockSize(symmEncryptAlgo, null);\r\n\t\t\t\t\tint signatureSize = CryptoUtil.getSignatureSize(symmSignAlgo, null);\r\n\t\t\t\t\tint keySize = mode == MessageSecurityMode.SignAndEncrypt ? token.getRemoteEncryptingKey().length : 0;\r\n\t\t\t\t\tint paddingSize = mode == MessageSecurityMode.SignAndEncrypt ? keySize > 2048 ? 2 : 1 : 0;\r\n\r\n\t\t\t\t\tint maxPlaintextSize = ctx.maxSendChunkSize - 24 - paddingSize - signatureSize;\r\n\t\t\t\t\tmaxPlaintextSize -= (maxPlaintextSize + paddingSize + signatureSize + 8) % cipherBlockSize;\r\n\t\t\t\t\tfinal int CORES = StackUtils.cores();\r\n\r\n\t\t\t\t\tint optimalPayloadSize = (len+CORES-1) / CORES;\r\n\t\t\t\t\tif (optimalPayloadSize > maxPlaintextSize)\r\n\t\t\t\t\t\toptimalPayloadSize = maxPlaintextSize;\r\n\t\t\t\t\tif (optimalPayloadSize < 4096)\r\n\t\t\t\t\t\toptimalPayloadSize = 4096;\r\n\t\t\t\t\tint optimalChunkSize = optimalPayloadSize + 24 + paddingSize + signatureSize;\r\n\r\n\t\t\t\t\tChunkFactory cf = new ChunkFactory(\r\n\t\t\t\t\t\t\toptimalChunkSize,\r\n\t\t\t\t\t\t\t8,\r\n\t\t\t\t\t\t\t8,\r\n\t\t\t\t\t\t\t8,\r\n\t\t\t\t\t\t\tsignatureSize,\r\n\t\t\t\t\t\t\tcipherBlockSize,\r\n\t\t\t\t\t\t\tmode,\r\n\t\t\t\t\t\t\tkeySize);\r\n\r\n\t\t\t\t\t// Calculate chunk count\r\n\t\t\t\t\tfinal int count = (len + cf.maxPlaintextSize-1) / cf.maxPlaintextSize;\r\n\t\t\t\t\tif (count>ctx.maxSendChunkCount && ctx.maxSendChunkCount!=0)\r\n\t\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpMessageTooLarge);\r\n\t\t\t\t\tconcurrent = (count > 1) && (CORES>0) && (mode != MessageSecurityMode.None);\r\n\r\n\t\t\t\t\t// Allocate chunks\r\n\t\t\t\t\tint bytesLeft = len;\r\n\t\t\t\t\tplaintexts = new ByteBuffer[count];\r\n\t\t\t\t\tchunks = new ByteBuffer[count];\r\n\t\t\t\t\tfor (int i=0; i<count; i++) {\r\n\t\t\t\t\t\tplaintexts[i] = cf.allocate(bytesLeft);\r\n\t\t\t\t\t\tchunks[i] = cf.expandToCompleteChunk(plaintexts[i]);\r\n\t\t\t\t\t\tbytesLeft -= plaintexts[i].remaining();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tassert(bytesLeft==0);\r\n\r\n\t\t\t\t\t// Start write\r\n\t\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\t\tif (msg.isCanceled()) return;\r\n\t\t\t\t\t\tmsg.setWriting();\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (ServiceResultException se) {\r\n\t\t\t\t\tmsg.setError(se);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfinal ByteBuffer _chunks[] = chunks;\r\n\t\t\t\tfinal ByteBuffer _plaintexts[] = plaintexts;\r\n\t\t\t\tfinal int count = chunks.length;\r\n\t\t\t\tfinal boolean parallel = concurrent;\r\n\r\n\t\t\t\tint sequenceNumber = 0;\r\n\t\t\t\tsynchronized(this) {\r\n\t\t\t\t\tsequenceNumber = sendSequenceNumber.getAndAdd(chunks.length);\r\n\t\t\t\t\tstartChunkSend(chunks);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add chunk headers\r\n\t\t\t\tfor (ByteBuffer chunk : chunks) {\r\n\t\t\t\t\tboolean finalChunk = chunk == chunks[chunks.length-1];\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\tchunk.putInt( messageType | (finalChunk ? TcpMessageType.FINAL : TcpMessageType.CONTINUE) );\r\n\t\t\t\t\tchunk.position(8);\r\n\t\t\t\t\tchunk.putInt(token.getSecureChannelId());\r\n\r\n\t\t\t\t\t// -- Security Header --\r\n\t\t\t\t\tchunk.putInt(token.getTokenId());\r\n\r\n\t\t\t\t\t// -- Sequence Header --\r\n\t\t\t\t\tchunk.putInt(sequenceNumber++);\r\n\t\t\t\t\tchunk.putInt(requestId);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// a Chunk-has-been-encoded handler\r\n\t\t\t\tfinal AtomicInteger chunksComplete = new AtomicInteger();\r\n\t\t\t\tChunkListener completitionListener = new ChunkListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onChunkComplete(ByteBuffer[] bufs, final int index) {\r\n\t\t\t\t\t\tRunnable action = new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run() {\r\n\t\t\t\t\t\t\t\t// Chunk contains message data, it needs to be encrypted and signed\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t// Encrypt & sign\r\n\t\t\t\t\t\t\t\tnew ChunkSymmEncryptSigner(_chunks[index], _plaintexts[index], token).run();\r\n\t\t\t\t\t\t\t\t_chunks[index].rewind();\r\n\r\n\t\t\t\t\t\t\t\t// Write chunk\r\n\t\t\t\t\t\t\t\tendChunkSend(_chunks[index]);\r\n\r\n\t\t\t\t\t\t\t\t// All chunks are completed\r\n\t\t\t\t\t\t\t\tif (chunksComplete.incrementAndGet()==count)\r\n\t\t\t\t\t\t\t\t\tmsg.setWritten();\r\n\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t} catch (ServiceResultException se) {\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\tmsg.setError(se);\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}};\r\n\t\t\t\t\t\t\tif (parallel && count>1) {\r\n\t\t\t\t\t\t\t\tStackUtils.getNonBlockingWorkExecutor().execute(action);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\taction.run();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Create encoder\r\n\t\t\t\tByteBufferArrayWriteable2 out = new ByteBufferArrayWriteable2(plaintexts, completitionListener);\r\n\t\t\t\tout.order(ByteOrder.LITTLE_ENDIAN);\r\n\r\n\t\t\t\tfinal BinaryEncoder enc = new BinaryEncoder(out);\r\n\t\t\t\tenc.setEncoderContext(encoderCtx);\r\n\r\n\t\t\t\tRunnable encoder = new Runnable() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void run() {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tenc.putMessage(msg.getMessage());\r\n\r\n\t\t\t\t\t\t\t// If the message was ActivateSessionResponse, which was Good, then mark that this\r\n\t\t\t\t\t\t\t// connection has a successful activated session (and thus is not removed when we are at\r\n\t\t\t\t\t\t\t// max connections. If we are at max connections, per 1.05 Part 4 5.5.2: \"To protect\r\n\t\t\t\t\t\t\t// against misbehaving Clients and denial of service attacks, the Server shall close the\r\n\t\t\t\t\t\t\t// oldest unused SecureChannelthat has no Session assigned before reaching the maximum\r\n\t\t\t\t\t\t\t// number of supported SecureChannels. \")\r\n\t\t\t\t\t\t\tif (msg.getMessage() instanceof ActivateSessionResponse) {\r\n\t\t\t\t\t\t\t\tActivateSessionResponse res = (ActivateSessionResponse) msg.getMessage();\r\n\t\t\t\t\t\t\t\tif (res.getResponseHeader().getServiceResult().isGood()) {\r\n\t\t\t\t\t\t\t\t\thasBeenSuccessfullySessionActivated.set(true);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} catch (ServiceResultException e) {\r\n\t\t\t\t\t\t\tmsg.setError( StackUtils.toServiceResultException(e) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}};\r\n\t\t\t\t\tStackUtils.getBlockingWorkExecutor().execute(encoder);\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tprotected synchronized void setError(ServiceResultException e) {\r\n\t\t\t\tif(!hasError()){\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tsendError(new ErrorMessage(e.getStatusCode(), e.getMessage()));\r\n\t\t\t\t\t} catch (ServiceResultException e1) {\r\n\t\t\t\t\t\tlogger.warn(\"Could not send error message\",e1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsuper.setError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Put chunks into send queue. Chunks will be given a sequence number\r\n\t\t\t * but will be flushed in endChunkSend().\r\n\t\t\t *\r\n\t\t\t * @param chunks a {@link java.nio.ByteBuffer} object.\r\n\t\t\t */\r\n\t\t\tprotected void startChunkSend(ByteBuffer...chunks)\r\n\t\t\t{\r\n\t\t\t\tsynchronized(chunkIncubator) {\r\n\t\t\t\t\tfor (ByteBuffer chunk : chunks)\r\n\t\t\t\t\t\tchunkIncubator.incubate(chunk);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n}\r\n"], "fixing_code": ["/* Copyright (c) 1996-2015, OPC Foundation. All rights reserved.\r\n   The source code in this file is covered under a dual-license scenario:\r\n     - RCL: for OPC Foundation members in good-standing\r\n     - GPL V2: everybody else\r\n   RCL license terms accompanied with this source code. See http://opcfoundation.org/License/RCL/1.00/\r\n   GNU General Public License as published by the Free Software Foundation;\r\n   version 2 of the License are accompanied with this source code. See http://opcfoundation.org/License/GPLv2\r\n   This source code is distributed in the hope that it will be useful,\r\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n*/\r\n\r\npackage org.opcfoundation.ua.transport.tcp.nio;\r\n\r\nimport java.io.IOException;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.SocketAddress;\r\nimport java.net.SocketException;\r\nimport java.nio.channels.ServerSocketChannel;\r\nimport java.nio.channels.SocketChannel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nimport org.opcfoundation.ua.application.Application;\r\nimport org.opcfoundation.ua.application.Server;\r\nimport org.opcfoundation.ua.common.ServiceResultException;\r\nimport org.opcfoundation.ua.core.StatusCodes;\r\nimport org.opcfoundation.ua.encoding.EncoderContext;\r\nimport org.opcfoundation.ua.transport.CloseableObjectState;\r\nimport org.opcfoundation.ua.transport.Endpoint;\r\nimport org.opcfoundation.ua.transport.EndpointBinding;\r\nimport org.opcfoundation.ua.transport.EndpointServer;\r\nimport org.opcfoundation.ua.transport.IConnectionListener;\r\nimport org.opcfoundation.ua.transport.ServerConnection;\r\nimport org.opcfoundation.ua.transport.UriUtil;\r\nimport org.opcfoundation.ua.transport.endpoint.EndpointBindingCollection;\r\nimport org.opcfoundation.ua.transport.impl.ConnectionCollection;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ReverseHello;\r\nimport org.opcfoundation.ua.utils.AbstractState;\r\nimport org.opcfoundation.ua.utils.StackUtils;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncSocketImpl;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n * EndpointOpcTcp hosts an endpoint for opc.tcp socket.\r\n *\r\n * Endpoint discovery is provided if endpoint url is unknown.\r\n *\r\n * @see Executors for creating executor instances\r\n */\r\npublic class OpcTcpServer extends AbstractState<CloseableObjectState, ServiceResultException> implements EndpointServer {\r\n\r\n\t/** Logger */\r\n\tstatic Logger logger = LoggerFactory.getLogger(OpcTcpServer.class);\r\n\t/** Application */\r\n\tApplication application;\r\n\t/** Secure channel counter */\r\n\tAtomicInteger secureChannelCounter = new AtomicInteger();\r\n\t/** Endpoint bindings */\r\n\tEndpointBindingCollection endpointBindings = new EndpointBindingCollection(); \r\n\r\n\t/** Service server used when client connects with \"\" url for endpoint discovery */\r\n\tpublic Server discoveryServer;\r\n\tpublic EndpointBinding discoveryEndpointBinding;\r\n\t\r\n\tprivate int receiveBufferSize = 0;\r\n\r\n\tprivate boolean initialized = false;\r\n\t\r\n\t/** Endpoint handles */\r\n\tMap<SocketAddress, SocketHandle> socketHandles = new HashMap<SocketAddress, SocketHandle>();\r\n\t\r\n\t/**\r\n\t * <p>getEncoderContext.</p>\r\n\t *\r\n\t * @return a {@link org.opcfoundation.ua.encoding.EncoderContext} object.\r\n\t */\r\n\tpublic EncoderContext getEncoderContext() {\r\n\t\treturn application.getEncoderContext();\r\n\t}\r\n\r\n\t/**\r\n\t * <p>Getter for the field <code>receiveBufferSize</code>.</p>\r\n\t *\r\n\t * @return the receiveBufferSize to use for the connection socket of the server.\r\n\t */\r\n\tpublic int getReceiveBufferSize() {\r\n\t\treturn receiveBufferSize;\r\n\t}\r\n\r\n\t/**\r\n\t * Define the receiveBufferSize to use for the connection socket of the server.\r\n\t * <p>\r\n\t * Default value: 0, which omits the parameter and the default value for the\r\n\t * socket (depending on the operating system) is used.\r\n\t *\r\n\t * @param receiveBufferSize the new size in bytes\r\n\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t * @see \"http://fasterdata.es.net/host-tuning/background/\"\r\n\t */\r\n\tpublic void setReceiveBufferSize(int receiveBufferSize) throws ServiceResultException {\r\n\t\tthis.receiveBufferSize = receiveBufferSize;\r\n\t\tif (receiveBufferSize > 0) {\r\n\t\t\tfor (SocketHandle sh : socketHandleSnapshot()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tAsyncServerSocket ass = sh.socket;\r\n\t\t\t\t\tif ( ass!=null ) {\r\n\t\t\t\t\t\tass.socket().setReceiveBufferSize(receiveBufferSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (SocketException e) {\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_InternalError, e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/** AsyncServerSocket Connect listener */\r\n\torg.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket.ConnectListener connectListener = new org.opcfoundation.ua.utils.asyncsocket.AsyncServerSocket.ConnectListener() {\t\t\r\n\t\tpublic void onConnected(AsyncServerSocket sender, AsyncSocketImpl newConnection) {\r\n\t\t\tlogger.info(\"{}: {} connected\", OpcTcpServer.this, newConnection.socket().getRemoteSocketAddress());\r\n\t\t\tfinal OpcTcpServerConnection conn = new OpcTcpServerConnection(OpcTcpServer.this, newConnection);\r\n\t\t\tconnections.addConnection(conn);\r\n\t\t\t\r\n\t\t\tconn.addConnectionListener(new IConnectionListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClosed(ServiceResultException closeError) {\t\t\t\t\t\t\r\n\t\t\t\t\t\tconnections.removeConnection(conn);\r\n\t\t\t\t}\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onOpen() {\r\n\t\t\t\t}});\r\n\t\t\t\r\n\t          // Check for connection count limits\r\n\t          // Per 1.05 Part 4 section 5.5.2, To protect against misbehaving Clients and denial of\r\n\t          // service attacks, the Server shall close the oldest unused SecureChannelthat has no\r\n\t          // Session assigned before reaching the maximum number of supported SecureChannels.\r\n\r\n\r\n\t          List<ServerConnection> conns = new ArrayList<ServerConnection>();\r\n\t          connections.getConnections(conns);\r\n\r\n\t          logger.trace(\"Checking maximum number of connections, limit: {}, current: {}\", maxConnections, conns.size());\r\n\r\n\t          // at limit is enough per the 5.5.2\r\n\t          if (conns.size() >= maxConnections) {\r\n\t            int delta = maxConnections - conns.size() + 1;\r\n\t            logger.trace(\"We are at max or over limit, number of connections to purge if possible: {}\", delta);\r\n\t            // TODO ordering based on timestamps of creation\r\n\t            int purged = 0;\r\n\t            for (ServerConnection tmp : conns) {\r\n\t              if (tmp instanceof OpcTcpServerConnection) {\r\n\t                // Every connection should be of this type in this OpcTcpServer)\r\n\t                OpcTcpServerConnection opcTcpTmp = (OpcTcpServerConnection) tmp;\r\n\r\n\t                // We are itself part of the connections as well. Skip ourselves here (that is\r\n\t                // handled at the end of this method). If we remove ourselves here, and would be the\r\n\t                // \"final legit\" connection (and then we would be at max capacity), we would be\r\n\t                // closed before we can ActivateSession.\r\n\t                if (conn == opcTcpTmp) {\r\n\t                  continue;\r\n\t                }\r\n\r\n\t                if (opcTcpTmp.isPurgeEligible()) {\r\n\t                  opcTcpTmp.close();\r\n\t                  purged++;\r\n\t                  if (purged >= delta) {\r\n\t                    break;\r\n\t                  }\r\n\t                }\r\n\t              }\r\n\t            }\r\n\t            logger.trace(\"We are at max or over limit, purged {} old connections\", purged);\r\n\t          }\r\n\t          // It is possible that we were not able to purge anything, if we happen to be at max\r\n\t          // connections that all have activated sessions, in this case, close this connection\r\n\t          // instead.\r\n\t          List<ServerConnection> tmp = new ArrayList<ServerConnection>();\r\n\t          connections.getConnections(tmp);\r\n\t          /*\r\n\t           * But! This connection itself is within the connections, if we are exactly at max, that\r\n\t           * is still OK here. But if we are over (i.e. we already had at max and none cannot be\r\n\t           * removed), then remove this connection.\r\n\t           */\r\n\t          if (tmp.size() > maxConnections) {\r\n\t            logger.trace(\"We are at over limit, unable to purge enough old connections, closing this connection\");\r\n\t            conn.close();\r\n\t          } else {\r\n\t        \t  if (tmp.size() == maxConnections) {\r\n\t        \t\tlogger.trace(\"We are exactly at maximum connections (including this connection). \")\t;\r\n\t        \t  } else {\r\n\t        \t\tlogger.trace(\"We are below maximum connection limit\");\r\n\t        \t  }\r\n\t              conn.init();\t        \t  \r\n\t          }\r\n\t    }};\r\n\tConnectionCollection connections = new ConnectionCollection(this);\t\r\n\t\r\n\tint maxConnections;\r\n\tint maxSecureChannelsPerConnection;\t\r\n\t\r\n\t/**\r\n\t * <p>Constructor for OpcTcpServer.</p>\r\n\t *\r\n\t * @param application a {@link org.opcfoundation.ua.application.Application} object.\r\n\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t */\r\n\tpublic OpcTcpServer(Application application) throws ServiceResultException\r\n\t{\r\n\t\tsuper(CloseableObjectState.Closed, CloseableObjectState.Closed);\r\n\t\tthis.application = application;\r\n\t\ttry {\r\n\t\t\tServerSocketChannel channel = ServerSocketChannel.open();\r\n\t\t\tchannel.configureBlocking(false);\r\n\t\t\t\r\n\t\t\t// Create a service server for connections that query endpoints (url = \"\")\r\n\t\t\tdiscoveryServer = new Server( application );\r\n\t\t\tdiscoveryServer.setEndpointBindings( endpointBindings );\r\n\t\t\tdiscoveryEndpointBinding = new EndpointBinding(this, discoveryEndpoint, discoveryServer);\t\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new ServiceResultException(StatusCodes.Bad_InternalError, e);\r\n\t\t}\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic EndpointHandle bind(SocketAddress socketAddress, EndpointBinding endpointBinding) throws ServiceResultException {\r\n\t\tif ( endpointBinding == null || socketAddress == null || endpointBinding.endpointServer!=this )\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t\r\n\t\tinit();\r\n\t\t\r\n\t\tString scheme = UriUtil.getTransportProtocol( endpointBinding.endpointAddress.getEndpointUrl() );\r\n\t\tif ( !\"opc.tcp\".equals(scheme) ) throw new ServiceResultException(StatusCodes.Bad_UnexpectedError, \"Cannot bind \"+scheme+\" to opc.tcp server\");\r\n\t\tSocketHandle socketHandle = getOrCreateSocketHandle(socketAddress);\r\n\t\t\r\n\t\tif ( socketHandle.socket == null ) {\r\n\t\t\ttry {\r\n\t\t\t\tsocketHandle.setChannel(ServerSocketChannel.open());\r\n\t\t\t\tsocketHandle.getChannel().configureBlocking(false);\r\n\t\t\t\r\n\t\t\t\tsocketHandle.socket = new AsyncServerSocket(\r\n\t\t\t\t\t\tsocketHandle.getChannel(),\r\n\t\t\t\t\t\tStackUtils.getNonBlockingWorkExecutor()//,\r\n\t\t\t\t\t\t//new AsyncSelector(Selector.open())\r\n\t\t\t\t\t\t,StackUtils.getSelector()\r\n\t\t\t\t\t\t);\r\n\t\t\t\tsocketHandle.socket.bind(socketHandle.socketAddress, 0);\r\n\t\t\t\tsocketHandle.socket.addListener(connectListener);\r\n\t\t\t\tlogger.info(\"TCP/IP Socket bound to {}\", socketAddress);\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tlogger.error(\"Failed to bind address \"+ socketHandle.socketAddress, e);\r\n\t\t\t\tsocketHandle.close();\r\n\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_InternalError, e);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tOpcTcpEndpointHandle endpointHandle = socketHandle.getOrCreate(endpointBinding);\r\n\t\treturn endpointHandle;\r\n\t}\r\n\t\r\n\r\n\t@Override\r\n\tpublic void bindReverse(final SocketAddress addressToConnect,\r\n\t\t\tfinal String endpointUrl) {\r\n\t\tif(addressToConnect == null || endpointUrl == null) {\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t}\r\n\t\tinit();\r\n\t\t\r\n\t\tReverseSocketHandle socketHandle = new ReverseSocketHandle(addressToConnect);\r\n\t\tif(socketHandle.socket == null) {\r\n\t\t\ttry {\r\n\t\t\t\tsocketHandle.setChannel(SocketChannel.open());\r\n\t\t\t\tsocketHandle.getChannel().configureBlocking(false);\r\n\t\t\t\t\r\n\t\t\t\tsocketHandle.socket = new AsyncSocketImpl(socketHandle.getChannel(), StackUtils.getNonBlockingWorkExecutor(), StackUtils.getSelector());\r\n\r\n\t\t\t\tReverseHello rh = new ReverseHello();\r\n\t\t\t\trh.setEndpointUrl(endpointUrl);\r\n\t\t\t\trh.setServerUri(application.getApplicationDescription().getApplicationUri());\r\n\t\t\t\tfinal OpcTcpServerConnection conn = new OpcTcpServerConnection(OpcTcpServer.this, socketHandle.socket, rh); \r\n\t\t\t\tconnections.addConnection(conn);\r\n\t\t\t\t\r\n\t\t\t\tconn.addConnectionListener(new IConnectionListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onClosed(ServiceResultException closeError) {\t\t\t\t\t\t\r\n\t\t\t\t\t\tconnections.removeConnection(conn);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t//1.04 Part 6 section 7.1.3 when closed, server must restart the process\r\n\t\t\t\t\t\tlogger.debug(\"ReverseHello connection closed, rescheduling connection process\");\r\n\t\t\t\t\t\tbindReverse(addressToConnect, endpointUrl);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onOpen() {\r\n\t\t\t\t\t}});\r\n\t\t        // start listening to messages\r\n\t\t\t\tconn.init();\r\n\t\t\t\t//async, do last, others listen on socket state.\r\n\t\t\t\tsocketHandle.socket.connect(socketHandle.socketAddress);\r\n\t\t\t}catch(IOException e) {\r\n\t\t\t\tlogger.error(\"Failed to create a ReverseSocketHandle\", e);\r\n\t\t\t\tsocketHandle.close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic List<SocketAddress> getBoundSocketAddresses() {\r\n\t\tArrayList<SocketAddress> result = new ArrayList<SocketAddress>();\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot()) result.add( sh.socketAddress );\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * <p>getBoundAddress.</p>\r\n\t *\r\n\t * @return a {@link java.net.SocketAddress} object.\r\n\t */\r\n\tpublic SocketAddress getBoundAddress() {\r\n\t\tSocketHandle[] shs = socketHandleSnapshot();\r\n\t\tfor (SocketHandle sh: shs) {\r\n\t\t\tif ( sh.socket!=null) return sh.socketAddress;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Disconnect all existing connections.\r\n\t */\r\n\tpublic void disconnectAll()\r\n\t{\r\n\t\tList<ServerConnection> list = new ArrayList<ServerConnection>();\r\n\t\tgetConnections(list);\r\n\t\tfor (ServerConnection connection : list) {\r\n\t\t\tOpcTcpServerConnection c = (OpcTcpServerConnection) connection;\r\n\t\t\tc.close();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * Closes server socket. Does not disconnect existing connections.\r\n\t */\r\n\t@Override\r\n\tpublic synchronized OpcTcpServer close() {\r\n\t\tlogger.info(\"{} closed\", getBoundAddress());\r\n\t\tif (!getState().isClosed()) { \r\n\t\t\tsetState(CloseableObjectState.Closing);\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tfor (SocketHandle sh : socketHandleSnapshot())\r\n\t\t\t\tsh.close();\r\n\t\t} finally {\r\n\t\t\tsetState(CloseableObjectState.Closed);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic void addConnectionListener(org.opcfoundation.ua.transport.ConnectionMonitor.ConnectListener l) {\r\n\t\tconnections.addConnectionListener(l);\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic void getConnections(Collection<ServerConnection> result) {\r\n\t\tconnections.getConnections(result);\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic void removeConnectionListener(org.opcfoundation.ua.transport.ConnectionMonitor.ConnectListener l) {\r\n\t\tconnections.removeConnectionListener(l);\r\n\t}\t\r\n\t\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic EndpointBindingCollection getEndpointBindings() {\r\n\t\treturn endpointBindings;\r\n\t}\t\r\n\t\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tsb.append(\"OpcTcpServer\");\r\n\t\tsb.append(\"(\");\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot()) sb.append( sh.toString() );\r\n\t\tsb.append(\")\");\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tsynchronized SocketHandle getOrCreateSocketHandle(SocketAddress socketAddress)\r\n\tthrows ServiceResultException\r\n\t{\r\n\t\tSocketHandle handle = socketHandles.get(socketAddress);\r\n\t\tif ( handle == null ) {\r\n\t\t\thandle = new SocketHandle(socketAddress);\r\n\t\t\tsocketHandles.put(socketAddress, handle);\r\n\t\t}\r\n\t\treturn handle;\r\n\t}\r\n\t\r\n\t/**\r\n\t * <p>socketHandleSnapshot.</p>\r\n\t *\r\n\t * @return an array of {@link org.opcfoundation.ua.transport.tcp.nio.OpcTcpServer.SocketHandle} objects.\r\n\t */\r\n\tpublic SocketHandle[] socketHandleSnapshot() {\r\n\t\treturn socketHandles.values().toArray( new SocketHandle[ socketHandles.size()] );\t\t\r\n\t}\r\n\t\r\n\tpublic static class ReverseSocketHandle{\r\n\t\t\r\n\t\tprivate SocketAddress socketAddress;\r\n\t\tprivate SocketChannel channel;\r\n\t\tprivate AsyncSocketImpl socket;\r\n\t\t\r\n\t\tpublic ReverseSocketHandle(SocketAddress socketAddress) {\r\n\t\t\tthis.socketAddress = socketAddress;\r\n\t\t}\r\n\r\n\t\tpublic SocketChannel getChannel() {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\r\n\t\tpublic void setChannel(SocketChannel channel) {\r\n\t\t\tthis.channel = channel;\r\n\t\t}\r\n\r\n\t\tpublic SocketAddress getSocketAddress() {\r\n\t\t\treturn socketAddress;\r\n\t\t}\r\n\t\t\r\n\t\tpublic AsyncSocketImpl getSocket() {\r\n\t\t\treturn socket;\r\n\t\t}\r\n\r\n\t\tpublic void setSocket(AsyncSocketImpl socket) {\r\n\t\t\tthis.socket = socket;\r\n\t\t}\r\n\r\n\t\tvoid close() {\r\n\t\t\tSocketChannel c = channel;\r\n\t\t\tif(c != null) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tc.close();\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tlogger.error(\"Failure in closing ReverseSockeHandle\", e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic class SocketHandle {\r\n\t\tSocketAddress socketAddress;\r\n\t\t/** Server Socket */\r\n\t\tAsyncServerSocket socket;\r\n\t\tprivate ServerSocketChannel channel;\r\n\t\tint port;\r\n\t\tMap<Endpoint, OpcTcpEndpointHandle> endpoints = new HashMap<Endpoint, OpcTcpEndpointHandle>();\r\n\t\tSocketHandle(SocketAddress socketAddress)\r\n\t\t{\r\n\t\t\tthis.socketAddress = socketAddress;\r\n\t\t}\r\n\t\t\r\n\t\tpublic synchronized OpcTcpEndpointHandle[] endpointHandleSnapshot() {\r\n\t\t\treturn endpoints.values().toArray( new OpcTcpEndpointHandle[ endpoints.size()] );\r\n\t\t}\r\n\t\t\r\n\t\tsynchronized void endpointHandleSnapshot(Collection<OpcTcpEndpointHandle> handles) {\r\n\t\t\thandles.addAll( endpoints.values() );\r\n\t\t}\r\n\t\t\r\n\t\tsynchronized OpcTcpEndpointHandle getOrCreate(EndpointBinding endpointBinding) throws ServiceResultException {\r\n\t\t\tOpcTcpEndpointHandle handle = endpoints.get(endpointBinding.endpointAddress);\r\n\t\t\tif ( handle == null ) {\r\n\t\t\t\thandle = new OpcTcpEndpointHandle(this, endpointBinding);\r\n\t\t\t\t// Add endpointBinding to SocketHandle\r\n\t\t\t\tendpoints.put(endpointBinding.endpointAddress, handle);\r\n\t\t\t\t// Add endpointBinding to EndpointServer\r\n\t\t\t\tendpointBindings.add(endpointBinding);\r\n\t\t\t\t// Add endpointBinding to Server\r\n\t\t\t\tendpointBinding.serviceServer.getEndpointBindings().add(endpointBinding);\r\n\t\t\t} else {\r\n\t\t\t\tif ( !handle.endpointBinding.equals( endpointBinding ) ) {\r\n\t\t\t\t\tthrow new ServiceResultException( StatusCodes.Bad_UnexpectedError, \"Cannot bind an endpoint address to two different servers.\" );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn handle;\r\n\t\t}\r\n\t\tint getPort() {\r\n\t\t\treturn ((InetSocketAddress)socketAddress).getPort();\r\n\t\t}\r\n\r\n\t\tvoid close() {\r\n\t\t\tfor ( OpcTcpEndpointHandle eph : endpoints.values() ) eph.close__();\r\n\t\t\tsocketHandles.remove(socketAddress);\r\n\t\t\tif ( socket!=null ) {\r\n\t\t\t\tAsyncServerSocket ass = socket;\r\n\t\t\t\tsocket = null;\r\n\t\t\t\tass.close();\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append( \"opc.tcp(\"+socketAddress+\", \");\r\n\t\t\tfor (OpcTcpEndpointHandle ep : endpoints.values()) {\r\n\t\t\t\tsb.append( ep.toString() );\r\n\t\t\t}\r\n\t\t\tsb.append( \")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @return the channel\r\n\t\t */\r\n\t\tpublic ServerSocketChannel getChannel() {\r\n\t\t\treturn channel;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @param channel the channel to set\r\n\t\t */\r\n\t\tpublic void setChannel(ServerSocketChannel channel) {\r\n\t\t\tthis.channel = channel;\r\n\t\t}\r\n\r\n\t\tpublic SocketAddress getSocketAddress() {\r\n\t\t\treturn socketAddress;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic class OpcTcpEndpointHandle implements EndpointHandle {\r\n\t\tEndpointBinding endpointBinding;\r\n\t\tSocketHandle socketHandle;\r\n\t\tOpcTcpEndpointHandle(SocketHandle socketHandle, EndpointBinding endpointBinding) {\r\n\t\t\tthis.socketHandle = socketHandle;\r\n\t\t\tthis.endpointBinding = endpointBinding;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic SocketAddress socketAddress() {\r\n\t\t\treturn socketHandle.socketAddress;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic EndpointBinding endpointBinding() {\r\n\t\t\treturn endpointBinding;\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic void close() {\r\n\t\t\tclose_();\r\n\t\t\tclose__();\r\n\t\t}\r\n\t\tvoid close_() {\r\n\t\t\t// Remove endpointBinding from SocketHandle\r\n\t\t\tsocketHandle.endpoints.remove(endpointBinding.endpointAddress);\r\n\t\t\t// Close socket if this was the last\r\n\t\t\tif ( socketHandle.endpoints.isEmpty() ) {\r\n\t\t\t\tsocketHandle.close();\r\n\t\t\t}\r\n\t\t}\r\n\t\tvoid close__() {\r\n\t\t\t// Close endpointHandler if this was the last\r\n\t\t\tint count = countEndpoints(endpointBinding.endpointAddress);\r\n\t\t\tif ( count == 0 ) {\r\n\t\t\t\t// Remove endpointBinding from EndpointServer\r\n\t\t\t\tendpointBindings.remove(endpointBinding);\r\n\t\t\t\t// Remove endpointBinding from Server\r\n\t\t\t\tendpointBinding.serviceServer.getEndpointBindings().remove(endpointBinding);\r\n\t\t\t}\r\n\t\t}\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn \"(\"+endpointBinding.endpointAddress.toString()+\")\";\r\n\t\t}\r\n\t}\r\n\r\n\tprivate void init() {\r\n\t\tif (!initialized) {\r\n\t\t\tint maxConnections = application.getOpctcpSettings().getMaxConnections();\r\n\t\t\tif (maxConnections <= 0) {\r\n\t\t\t\tthrow new IllegalStateException(\"Maximum number of connections was not configured; must be greater than 0\");\r\n\t\t\t}\r\n\t\t\tthis.maxConnections = maxConnections;\r\n\r\n\t\t\tint maxSecureChannelsPerConnection = application.getOpctcpSettings().getMaxSecureChannelsPerConnection();\r\n\t\t\tif (maxSecureChannelsPerConnection <= 0) {\r\n\t\t\t\tthrow new IllegalStateException(\r\n\t\t            \"Maximum number of secure channels per connection was not configured; must be greater than 0\");\r\n\t\t\t}\r\n\t\t\tthis.maxSecureChannelsPerConnection = maxSecureChannelsPerConnection;\r\n\t\t\tinitialized = true;\r\n\t\t}\r\n\t}\r\n\t  \r\n\tList<OpcTcpEndpointHandle> findEndpoints(String forUri) {\r\n\t\tList<OpcTcpEndpointHandle> result = new ArrayList<OpcTcpEndpointHandle>();\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot() ) sh.endpointHandleSnapshot(result);\r\n\t\treturn result;\r\n\t}\r\n\tint countEndpoints(Endpoint endpointAddress) {\r\n\t\tint count = 0;\r\n\t\tfor (SocketHandle sh : socketHandleSnapshot() ) {\r\n\t\t\tfor (OpcTcpEndpointHandle eh : sh.endpointHandleSnapshot()) {\r\n\t\t\t\tif (eh.endpointBinding.endpointAddress.equals(endpointAddress)) count++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n}\r\n", "/* Copyright (c) 1996-2015, OPC Foundation. All rights reserved.\r\n   The source code in this file is covered under a dual-license scenario:\r\n     - RCL: for OPC Foundation members in good-standing\r\n     - GPL V2: everybody else\r\n   RCL license terms accompanied with this source code. See http://opcfoundation.org/License/RCL/1.00/\r\n   GNU General Public License as published by the Free Software Foundation;\r\n   version 2 of the License are accompanied with this source code. See http://opcfoundation.org/License/GPLv2\r\n   This source code is distributed in the hope that it will be useful,\r\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n */\r\npackage org.opcfoundation.ua.transport.tcp.nio;\r\n\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_SecureChannelIdInvalid;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_SecurityChecksFailed;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_SecurityPolicyRejected;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_TcpInternalError;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_Timeout;\r\nimport static org.opcfoundation.ua.core.StatusCodes.Bad_UnexpectedError;\r\n\r\nimport java.io.IOException;\r\nimport java.net.Socket;\r\nimport java.net.SocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.ByteOrder;\r\nimport java.security.cert.CertificateException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\nimport org.opcfoundation.ua.builtintypes.StatusCode;\r\nimport org.opcfoundation.ua.builtintypes.UnsignedInteger;\r\nimport org.opcfoundation.ua.common.ServiceResultException;\r\nimport org.opcfoundation.ua.core.ActivateSessionResponse;\r\nimport org.opcfoundation.ua.core.CloseSecureChannelRequest;\r\nimport org.opcfoundation.ua.core.EndpointConfiguration;\r\nimport org.opcfoundation.ua.core.MessageSecurityMode;\r\nimport org.opcfoundation.ua.core.OpenSecureChannelRequest;\r\nimport org.opcfoundation.ua.core.SecurityTokenRequestType;\r\nimport org.opcfoundation.ua.core.StatusCodes;\r\nimport org.opcfoundation.ua.encoding.EncoderContext;\r\nimport org.opcfoundation.ua.encoding.IEncodeable;\r\nimport org.opcfoundation.ua.encoding.binary.BinaryEncoder;\r\nimport org.opcfoundation.ua.transport.AsyncWrite;\r\nimport org.opcfoundation.ua.transport.CloseableObject;\r\nimport org.opcfoundation.ua.transport.CloseableObjectState;\r\nimport org.opcfoundation.ua.transport.Endpoint;\r\nimport org.opcfoundation.ua.transport.EndpointBinding;\r\nimport org.opcfoundation.ua.transport.IConnectionListener;\r\nimport org.opcfoundation.ua.transport.ServerSecureChannel;\r\nimport org.opcfoundation.ua.transport.endpoint.AbstractServerSecureChannel;\r\nimport org.opcfoundation.ua.transport.endpoint.EndpointBindingCollection;\r\nimport org.opcfoundation.ua.transport.security.CertificateValidator;\r\nimport org.opcfoundation.ua.transport.security.KeyPair;\r\nimport org.opcfoundation.ua.transport.security.SecurityAlgorithm;\r\nimport org.opcfoundation.ua.transport.security.SecurityConfiguration;\r\nimport org.opcfoundation.ua.transport.security.SecurityMode;\r\nimport org.opcfoundation.ua.transport.security.SecurityPolicy;\r\nimport org.opcfoundation.ua.transport.tcp.impl.Acknowledge;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkAsymmEncryptSigner;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkFactory;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkFactory.AcknowledgeChunkFactory;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkFactory.ErrorMessageChunkFactory;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkSymmEncryptSigner;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ChunkUtils;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ErrorMessage;\r\nimport org.opcfoundation.ua.transport.tcp.impl.Hello;\r\nimport org.opcfoundation.ua.transport.tcp.impl.ReverseHello;\r\nimport org.opcfoundation.ua.transport.tcp.impl.SecurityToken;\r\nimport org.opcfoundation.ua.transport.tcp.impl.TcpMessageType;\r\nimport org.opcfoundation.ua.transport.tcp.nio.Channel.ChannelListener;\r\nimport org.opcfoundation.ua.transport.tcp.nio.SecureInputMessageBuilder.MessageListener;\r\nimport org.opcfoundation.ua.utils.CertificateUtils;\r\nimport org.opcfoundation.ua.utils.CryptoUtil;\r\nimport org.opcfoundation.ua.utils.IStatefulObject;\r\nimport org.opcfoundation.ua.utils.ObjectUtils;\r\nimport org.opcfoundation.ua.utils.SizeCalculationOutputStream;\r\nimport org.opcfoundation.ua.utils.StackUtils;\r\nimport org.opcfoundation.ua.utils.StateListener;\r\nimport org.opcfoundation.ua.utils.TimerUtil;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncInputStream;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncSocket;\r\nimport org.opcfoundation.ua.utils.asyncsocket.AsyncSocketImpl;\r\nimport org.opcfoundation.ua.utils.asyncsocket.BufferMonitorState;\r\nimport org.opcfoundation.ua.utils.asyncsocket.MonitorListener;\r\nimport org.opcfoundation.ua.utils.asyncsocket.SocketState;\r\nimport org.opcfoundation.ua.utils.bytebuffer.ByteBufferArrayWriteable2;\r\nimport org.opcfoundation.ua.utils.bytebuffer.ByteBufferArrayWriteable2.ChunkListener;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/**\r\n * <p>OpcTcpServerConnection class.</p>\r\n *\r\n * @author jaro\r\n */\r\npublic class OpcTcpServerConnection extends AbstractServerConnection {\r\n\r\n\t/** Logger */\r\n\tprivate final static Logger logger = LoggerFactory.getLogger(OpcTcpServerConnection.class);\r\n\r\n\t// Give client 10 minutes to handshake\r\n\tprivate static long handshakeTimeout = 10 * 60 * 1000; // 10 minutes\r\n\t/**\r\n\t * <p>Getter for the field <code>handshakeTimeout</code>.</p>\r\n\t *\r\n\t * @return the handshakeTimeout\r\n\t */\r\n\tpublic static long getHandshakeTimeout() {\r\n\t\treturn handshakeTimeout;\r\n\t}\r\n\t/**\r\n\t * Define the handshake timeout for new connections. If the client does not\r\n\t * establish a connection during the timeout, the socket is released.\r\n\t * A smaller value might be usable to avoid DNS attacks.\r\n\t *\r\n\t * @param handshakeTimeout\r\n\t *            the handshakeTimeout to set. Default 600000 = 10 minutes.\r\n\t */\r\n\tpublic static void setHandshakeTimeout(long handshakeTimeout) {\r\n\t\tOpcTcpServerConnection.handshakeTimeout = handshakeTimeout;\r\n\t}\r\n\t/** Agreed protocol version */\r\n\tint agreedProtocolVersion;\r\n\t/**  Request id - Pending Request mapping */\r\n\tMap<Integer, PendingRequest> pendingRequests  = new ConcurrentHashMap<Integer, PendingRequest>();\r\n\r\n\t/** An endpoint binding associated with this connection. Set after hello */\r\n\tEndpointBinding binding;\r\n\r\n\t/** Endpoint Server */\r\n\tOpcTcpServer endpointServer;\r\n\r\n\t/** Event based asynchronous socket */\r\n\tAsyncSocket s;\r\n\r\n\t/** Optional ReverseHello message, if operating in ReverseHello-mode */\r\n\tReverseHello rh;\r\n\t\r\n\t/**\r\n\t * Tracks if this connection has ever been successfully SessionActivated at least once. Impl note:\r\n\t * once set to true, shall be never set to false.\r\n\t */\r\n\tAtomicBoolean hasBeenSuccessfullySessionActivated = new AtomicBoolean(false);\r\n\t  \r\n\t/** Timer used for handshake timing */\r\n\tTimer timer = TimerUtil.getTimer();\r\n\r\n\tTimerTask timeoutTimer;\r\n\tRunnable timeout = new Runnable() {\r\n\t\t@Override\r\n\t\tpublic void run() {\r\n\t\t\tsetError(Bad_Timeout);\r\n\t\t}};\r\n\r\n\t\tEncoderContext encoderCtx;\r\n\t\tEndpointConfiguration endpointConfiguration;\r\n\r\n\t\t/// ??? ///\r\n\t\t// Handles incoming data //\r\n\t\tMonitorListener inputListener =\r\n\t\t\t\tnew MonitorListener() {\r\n\t\t\t@Override\r\n\t\t\tpublic void onStateTransition(IStatefulObject<BufferMonitorState, ?> sender,\r\n\t\t\t\t\tBufferMonitorState oldState, BufferMonitorState newState) {\r\n\r\n\t\t\t\t// Trigger is unreachable\r\n\t\t\t\tif (newState.isUnreachable()) {\r\n\t\t\t\t\tif (secureMessageBuilder!=null) {\r\n\t\t\t\t\t\tsecureMessageBuilder.close();\r\n\t\t\t\t\t\tsecureMessageBuilder = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (newState != BufferMonitorState.Triggered)\r\n\t\t\t\t{\r\n\t\t\t\t\tlogger.error(\"Unexpected trigger state {}\", newState);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// -- assert -- atleast 8 bytes are available --\r\n\r\n\t\t\t\tAsyncInputStream is = s.getInputStream();\r\n\t\t\t\tByteBuffer hdr = is.peek(8);\r\n\t\t\t\thdr.order(ByteOrder.LITTLE_ENDIAN);\r\n\t\t\t\thdr.getInt();\r\n\t\t\t\tint chunkSize = hdr.getInt();\r\n\r\n\t\t\t\tif (chunkSize<12) {\r\n\t\t\t\t\tsetError(StatusCodes.Bad_TcpInternalError);\r\n\t\t\t\t\tif (secureMessageBuilder!=null)\r\n\t\t\t\t\t\tsecureMessageBuilder.close();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (chunkSize > ctx.maxRecvChunkSize)\r\n\t\t\t\t{\r\n\t\t\t\t\tsetError(new ServiceResultException(StatusCodes.Bad_TcpMessageTooLarge, \"Chunk size (\"+chunkSize+\") exceeded maximum (\"+ctx.maxRecvChunkSize+\")\"));\r\n\t\t\t\t\tif (secureMessageBuilder!=null)\r\n\t\t\t\t\t\tsecureMessageBuilder.close();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (is.available()>=chunkSize) {\r\n\t\t\t\t\t// Chunk is readable\r\n\t\t\t\t\tByteBuffer chunk = is.read(chunkSize);\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\thandleChunk(chunk);\r\n\t\t\t\t\t\t} catch (RuntimeException e) {\r\n\t\t\t\t\t\t\tlogger.warn(\"Error in handleChunk\", e);\r\n\t\t\t\t\t\t\tthrow StackUtils.toServiceResultException(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (ServiceResultException se) {\r\n\t\t\t\t\t\tlogger.info(\"Error in handleChunk\", se);\r\n\t\t\t\t\t\tsetError(se);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Wait for next chunk header\r\n\t\t\t\t\tis.createMonitor(is.getPosition()+8, this);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Wake me up when the chunk is fully readable\r\n\t\t\t\t\tis.createMonitor(is.getPosition()+chunkSize, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t/// ??? ///\r\n\r\n\t\t// Handle incoming messages, ran in BlockingWorkExecutor //\r\n\t\tMessageListener messageListener = new MessageListener() {\r\n\t\t\t@Override\r\n\t\t\tpublic void onMessageComplete(InputMessage sender) {\r\n\t\t\t\tIEncodeable msg = sender.getMessage();\r\n\r\n\t\t\t\tfor (ChannelListener cl : channelListeners)\r\n\t\t\t\t\tif (cl.handleMessage(sender)) return;\r\n\r\n\t\t\t\t// Handler error\r\n\t\t\t\tif (msg==null)\r\n\t\t\t\t\tsynchronized (this) {\r\n\t\t\t\t\t\tException error = sender.getError();\r\n\t\t\t\t\t\tif (error == null)\r\n\t\t\t\t\t\t\treturn; // aborted;\r\n\t\t\t\t\t\tsetError(StackUtils.toServiceResultException(error));\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// Handle message\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (sender.getMessageType() == TcpMessageType.MESSAGE) {\r\n\t\t\t\t\t\thandleSecureMessage(sender);\r\n\t\t\t\t\t} else if (sender.getMessageType() == TcpMessageType.CLOSE) {\r\n\t\t\t\t\t\thandleCloseSecureChannelRequest(sender);\r\n\t\t\t\t\t} else if (sender.getMessageType() == TcpMessageType.OPEN) {\r\n\t\t\t\t\t\thandleOpenSecureChannelRequest(sender);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (ServiceResultException e) {\r\n\t\t\t\t\tsetError(e);\r\n\t\t\t\t}\r\n\t\t\t}};\r\n\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Creates a new OpcTcpConnection with the given parameters. \r\n\t\t\t * \r\n\t\t\t * @param endpointServer EndpointServer for opc.tcp\r\n\t\t\t * @param s socket\r\n\t\t\t */\r\n\t\t\tOpcTcpServerConnection(OpcTcpServer endpointServer, AsyncSocketImpl s) {\r\n\t\t\t\tthis(endpointServer, s, null);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Creates a new OpcTcpConnection with the given parameters.\r\n\t\t\t * \r\n\t\t\t * @param endpointServer EndpointServer for opc.tcp\r\n\t\t\t * @param s socket\r\n\t\t\t * @param rh, if null, assumes normal connection, if non-null assumes ReverseHello connection.\r\n\t\t\t */\r\n\t\t\tOpcTcpServerConnection(OpcTcpServer endpointServer, AsyncSocketImpl s, final ReverseHello rh) {\r\n\t\t\t\tsuper();\r\n\t\t\t\tthis.endpointServer = endpointServer;\r\n\t\t\t\tthis.s = s;\r\n\t\t\t\tthis.rh = rh;\r\n\r\n\t\t\t\tthis.encoderCtx = endpointServer.getEncoderContext();\r\n\r\n\t\t\t\t// Monitor the state of the socket, make changes reflect to the state of the UATcpConnection\r\n\t\t\t\tsocketListener =\r\n\t\t\t\t\t\tnew StateListener<SocketState>() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onStateTransition(IStatefulObject<SocketState, ?> monitor, SocketState oldState, SocketState newState) {\r\n\t\t\t\t\t\tif (newState==SocketState.Error)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsetError( StackUtils.toServiceResultException( OpcTcpServerConnection.this.s.getStateMonitor().getError() ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (newState==SocketState.Closed)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tclose();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tsetState(CloseableObjectState.Opening);\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Start listening for data from the connection, note that data might be processed already before\r\n\t\t\t * this method returns.\r\n\t\t\t */\r\n\t\t\tpublic void init() {\r\n\t\t\t\ts.getStateMonitor().addStateListener(socketListener);\r\n\t\t\t\t\r\n\t\t\t    // must set timeout timer here, because it might be canceled before the below monitor\r\n\t\t\t    // is triggered\r\n\t\t\t\tif(rh == null) {\r\n\t\t\t\t\ttimeoutTimer = TimerUtil.schedule(\r\n\t\t\t\t\t\t\ttimer, timeout,\r\n\t\t\t\t\t\t\tStackUtils.getBlockingWorkExecutor(),\r\n\t\t\t\t\t\t\tSystem.currentTimeMillis() + handshakeTimeout);\r\n\t\t\t\t}\r\n\r\n\t\t\t    // Start listening for the Hello (the inputListener will schedule itself again)\r\n\t\t\t\ts.getInputStream().createMonitor(8, inputListener);\r\n\r\n\t\t\t\tif(rh != null) {\r\n\t\t\t\t\ts.getStateMonitor().addStateListener(new StateListener<SocketState>() {\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onStateTransition(\r\n\t\t\t\t\t\t\t\tIStatefulObject<SocketState, ?> sender,\r\n\t\t\t\t\t\t\t\tSocketState oldState, SocketState newState) {\r\n\t\t\t\t\t\t\tif(oldState == SocketState.Connecting && newState == SocketState.Connected) {\r\n\t\t\t\t\t\t\t\ttimeoutTimer = TimerUtil.schedule(\r\n\t\t\t\t\t\t\t\t\t\ttimer, timeout,\r\n\t\t\t\t\t\t\t\t\t\tStackUtils.getBlockingWorkExecutor(),\r\n\t\t\t\t\t\t\t\t\t\tSystem.currentTimeMillis() + handshakeTimeout);\r\n\t\t\t\t\t\t\t\tsendReverseHello(rh);\r\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\t\r\n\t\t\t  }\t\t\t\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic void addConnectionListener(IConnectionListener listener) {\r\n\t\t\t\tlogger.debug(\"addConnectionListener: listener={}\", listener);\r\n\t\t\t\tsuper.addConnectionListener(listener);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic synchronized CloseableObject close() {\r\n\t\t\t    // clear timeout timer, if exist, otherwise it will keep this object alive GC-wise.\r\n\t\t\t    cancelTimeoutTimer();\r\n\t\t\t    try {\r\n\t\t\t\t\tsetState(CloseableObjectState.Closing);\r\n\t\t\t\t} finally {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\ts.close();\r\n\t\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsetState(CloseableObjectState.Closed);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic SocketAddress getLocalAddress() {\r\n\t\t\t\tSocket socket = s.socket();\r\n\t\t\t\tif (socket==null) return null;\r\n\t\t\t\treturn socket.getLocalSocketAddress();\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic SocketAddress getRemoteAddress() {\r\n\t\t\t\tSocket socket = s.socket();\r\n\t\t\t\tif (socket==null) return null;\r\n\t\t\t\treturn socket.getRemoteSocketAddress();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Returns true if this connection has (or had) a Session that was successfully Activated at least\r\n\t\t\t * once. Returns false in other cases.\r\n\t\t\t */\r\n\t\t\tpublic boolean hasBeenSuccessfullySessionActivated() {\r\n\t\t\t\treturn hasBeenSuccessfullySessionActivated.get();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns true if this connection is eligble to be purged if we approach max number of\r\n\t\t\t * connections, false if this connection is valid and should not be purged. Per 1.05 Part 4\r\n\t\t\t * section 5.5.2 \"To protect against misbehaving Clientsand denial of service attacks, the\r\n\t\t\t * Servershall close the oldest unused SecureChannelthat has no Sessionassigned before reaching\r\n\t\t\t * the maximum number of supported SecureChannels.\". However, in addition if the connection was\r\n\t\t\t * formed via a ReverseHello, it is not considered to be eligible as server was the one initiating\r\n\t\t\t * the connection. Thus this returns true, if this connection is neither a reverse connection and\r\n\t\t\t * also has not yet been activated by a Session.\r\n\t\t\t */\r\n\t\t\tpublic boolean isPurgeEligible() {\r\n\t\t\t\treturn !isReverse() && !hasBeenSuccessfullySessionActivated();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Return true if this connection is a reverse connection i.e. where the server send a\r\n\t\t\t * ReverseHello to a Client to initiate the connection.\r\n\t\t\t */\r\n\t\t\tpublic boolean isReverse() {\r\n\t\t\t\treturn rh != null;\r\n\t\t\t}\t\t\t\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tpublic void removeConnectionListener(IConnectionListener listener) {\r\n\t\t\t\tlogger.debug(\"removeConnectionListener: listener={}\", listener);\r\n\t\t\t\tsuper.removeConnectionListener(listener);\r\n\t\t\t\tcancelTimeoutTimer();\r\n\t\t\t}\r\n\r\n\t\t\tprivate void checkSecureChannelLimit() throws ServiceResultException {\r\n\t\t\t\tif (secureChannels.size() >= endpointServer.maxSecureChannelsPerConnection) {\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpNotEnoughResources);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * @param uri\r\n\t\t\t * @return\r\n\t\t\t */\r\n\t\t\tprivate String trimUrl(String uri) {\r\n\t\t\t\tif ( uri==null ) return null;\r\n\t\t\t\t// Also remove an optional '/' from the end, since it is not significant\r\n\t\t\t\tif (uri.endsWith(\"/\"))\r\n\t\t\t\t\turi = uri.substring(0, uri.length()-1);\r\n\t\t\t\treturn uri;\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>cancelTimeoutTimer.</p>\r\n\t\t\t */\r\n\t\t\tprotected void cancelTimeoutTimer() {\r\n\t\t\t    // Cancel hand-shake time-out, note that this can never be started again, thus it wont hurt if\r\n\t\t\t    // this happens multiple times\r\n\t\t\t    final TimerTask tmp = timeoutTimer; // multithread-guard\r\n\t\t\t    if (tmp != null) {\r\n\t\t\t    \ttmp.cancel();\r\n\t\t\t    \ttimeoutTimer = null;\r\n\t\t\t\t\ttimeout = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Flushes queued chunks (see startChunkSend())\r\n\t\t\t *\r\n\t\t\t * @param chunk chunk to send\r\n\t\t\t */\r\n\t\t\tprotected void endChunkSend(ByteBuffer chunk)\r\n\t\t\t{\r\n\t\t\t\tchunkIncubator.hatch(chunk);\r\n\t\t\t\tsynchronized(this) {\r\n\t\t\t\t\twhile (chunkIncubator.nextIsHatched()) {\r\n\t\t\t\t\t\tByteBuffer c = chunkIncubator.removeNextHatchedIfAvailable();\r\n\t\t\t\t\t\tc.rewind();\r\n\t\t\t\t\t\ts.getOutputStream().offer(c);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>flush.</p>\r\n\t\t\t *\r\n\t\t\t * @param position a long.\r\n\t\t\t * @return a {@link org.opcfoundation.ua.utils.asyncsocket.BufferMonitorState} object.\r\n\t\t\t * @throws java.lang.InterruptedException if any.\r\n\t\t\t * @throws java.io.IOException if any.\r\n\t\t\t */\r\n\t\t\tprotected BufferMonitorState flush(long position)\r\n\t\t\t\t\tthrows InterruptedException, IOException\r\n\t\t\t{\r\n\t\t\t\treturn s.getOutputStream().createMonitor(position, null).waitForState(BufferMonitorState.FINAL_STATES);\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tprotected CertificateValidator getRemoteCertificateValidator() {\r\n\t\t\t\treturn binding==null ? null: binding.serviceServer.getApplication().getOpctcpSettings().getCertificateValidator();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleAcknowledgeMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param a a {@link org.opcfoundation.ua.transport.tcp.impl.Acknowledge} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleAcknowledgeMessage(Acknowledge a) throws ServiceResultException {\r\n\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleAsymmChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleAsymmChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tchunk.rewind();\r\n\t\t\t\tif (secureMessageBuilder!=null && !secureMessageBuilder.moreChunksRequired()) secureMessageBuilder = null;\r\n\r\n\t\t\t\t// First chunk of the message\r\n\t\t\t\tif (secureMessageBuilder==null) {\r\n\t\t\t\t\t// Read remote certificate and thumbprint of the expected local certificate\r\n\t\t\t\t\t//\t\t\tchunk.position(8);\r\n\t\t\t\t\t//\t\t\tint secureChannelId = chunk.getInt();\r\n\t\t\t\t\tint secureChannelId = ChunkUtils.getSecureChannelId(chunk);\r\n\t\t\t\t\tOpcTcpServerSecureChannel secureChannel =(OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\t\tString securityPolicyUri = ChunkUtils.getString(chunk);\r\n\t\t\t\t\tSecurityPolicy securityPolicy = SecurityPolicy.getSecurityPolicy(securityPolicyUri);\r\n\t\t\t\t\tif (securityPolicy==null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlogger.warn(\"Security policy \\\"{}\\\" is not supported by the stack\", securityPolicyUri);\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_SecurityPolicyRejected, \"Security policy \\\"\"+securityPolicyUri+\"\\\" is not supported by the stack\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\t\t\tif (!binding.endpointAddress.supportsSecurityPolicy(securityPolicy))\r\n\t\t\t\t\t//\t\t\t{\r\n\t\t\t\t\t//\t\t\t\tlogger.warn(\"Security policy \\\"\"+securityPolicyUri+\"\\\" is not supported by the endpoint\");\r\n\t\t\t\t\t//\t\t\t\tthrow new ServiceResultException(Bad_SecurityPolicyRejected, \"Security policy \\\"\"+securityPolicyUri+\"\\\" is not supported by the endpoint\");\r\n\t\t\t\t\t//\t\t\t}\r\n\r\n\t\t\t\t\tbyte[] encodedRemoteCertificate = ChunkUtils.getByteString(chunk);\r\n\t\t\t\t\tbyte[] encodedLocalCertificateThumbprint = ChunkUtils.getByteString(chunk);\r\n\t\t\t\t\tlogger.debug(\"secureChannelId={}\", secureChannelId);\r\n\t\t\t\t\tlogger.debug(\"secureChannel={}\", secureChannel);\r\n\t\t\t\t\tlogger.debug(\"securityPolicyUri={}\", securityPolicyUri);\r\n\t\t\t\t\tlogger.debug(\"securityPolicy={}\", securityPolicy);\r\n\t\t\t\t\tlogger.debug(\"encodedRemoteCertificate={}\", encodedRemoteCertificate);\r\n\t\t\t\t\tlogger.debug(\"encodedLocalCertificateThumbprint={}\", encodedLocalCertificateThumbprint);\r\n\r\n\r\n\t\t\t\t\tKeyPair localCertificate = binding.serviceServer.getApplication().getApplicationInstanceCertificate(encodedLocalCertificateThumbprint);\r\n\r\n\t\t\t\t\tif (localCertificate==null && securityPolicy != SecurityPolicy.NONE) {\r\n\t\t\t\t\t\tlogger.warn(\"Requested Application Instance Certificate is not found in the server\");\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_SecurityChecksFailed, \"Requested Application Instance Certificate is not found in the server\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Decode remote certificate\r\n\t\t\t\t\torg.opcfoundation.ua.transport.security.Cert remoteCertificate;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tremoteCertificate =\r\n\t\t\t\t\t\t\t\tencodedRemoteCertificate==null ?\r\n\t\t\t\t\t\t\t\t\t\tnull :\r\n\t\t\t\t\t\t\t\t\t\t\tnew org.opcfoundation.ua.transport.security.Cert( CertificateUtils.decodeX509Certificate(encodedRemoteCertificate) );\r\n\t\t\t\t\t} catch (CertificateException e) {\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_SecurityChecksFailed); //see 1.02.2 errdata\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Validate Client's Certificate\r\n\t\t\t\t\tCertificateValidator validator = getRemoteCertificateValidator();\r\n\t\t\t\t\tif (validator != null) {\r\n\t\t\t\t\t\tStatusCode code = validator.validateCertificate(remoteCertificate);\r\n\t\t\t\t\t\tif (code != null && !code.isGood()) {\r\n\t\t\t\t\t\t\tlogger.warn(\"Remote certificate not accepted: {}\", code.toString());\r\n\t\t\t\t\t\t\tthrow new ServiceResultException(code);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// MessageMode is unknown at this time. It is fixed in UATcpServerSecureChannel.onOpenChannel\r\n\t\t\t\t\tMessageSecurityMode msm = securityPolicy == SecurityPolicy.NONE ? MessageSecurityMode.None : MessageSecurityMode.SignAndEncrypt;\r\n\t\t\t\t\tSecurityMode mode = new SecurityMode(securityPolicy, msm);\r\n\t\t\t\t\tsecurityConfiguration = new SecurityConfiguration(mode, localCertificate, remoteCertificate);\r\n\r\n\t\t\t\t\tAtomicInteger recvSequenceNumber = secureChannel==null ? null : secureChannel.recvSequenceNumber;\r\n\r\n\t\t\t\t\tsecureMessageBuilder = new SecureInputMessageBuilder(securityConfiguration, messageListener, ctx, encoderCtx, recvSequenceNumber);\r\n\t\t\t\t}\r\n\t\t\t\tlogger.debug(\"onAsymmSecureChunk: {}\", chunk);\r\n\t\t\t\tsecureMessageBuilder.addChunk(chunk);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tint type = ChunkUtils.getMessageType(chunk);\r\n\t\t\t\tint messageType = type & TcpMessageType.MESSAGE_TYPE_MASK;\r\n\t\t\t\t// Secure message\r\n\t\t\t\tif (messageType == TcpMessageType.MESSAGE) {\r\n\t\t\t\t\thandleSymmChunk(chunk);\r\n\t\t\t\t} else if (messageType == TcpMessageType.CLOSE) {\r\n\t\t\t\t\thandleCloseChunk(chunk);\r\n\t\t\t\t} else if (messageType == TcpMessageType.OPEN) {\r\n\t\t\t\t\thandleAsymmChunk(chunk);\r\n\t\t\t\t} else if (messageType == TcpMessageType.HELLO || messageType == TcpMessageType.ACKNOWLEDGE || messageType == TcpMessageType.ERROR) {\r\n\t\t\t\t\thandleRawChunk(chunk);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Unknown chunk\r\n\t\t\t\t\tclose();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleCloseChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleCloseChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tclose();\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleCloseSecureChannelRequest.</p>\r\n\t\t\t *\r\n\t\t\t * @param mb a {@link org.opcfoundation.ua.transport.tcp.nio.InputMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleCloseSecureChannelRequest(InputMessage mb) throws ServiceResultException {\r\n\t\t\t\tlogger.debug(\"onCloseChannel\");\r\n\t\t\t\tIEncodeable msg = mb.getMessage();\r\n\t\t\t\tif (!(msg instanceof CloseSecureChannelRequest))\r\n\t\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\tCloseSecureChannelRequest req = (CloseSecureChannelRequest) msg;\r\n\t\t\t\tint secureChannelId = mb.getSecureChannelId();\r\n\t\t\t\tOpcTcpServerSecureChannel chan = (OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\tif (chan==null) throw new ServiceResultException( Bad_SecureChannelIdInvalid );\r\n\t\t\t\tchan.handleCloseSecureChannelRequest(mb, req);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleErrorMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param e a {@link org.opcfoundation.ua.transport.tcp.impl.ErrorMessage} object.\r\n\t\t\t */\r\n\t\t\tprotected void handleErrorMessage(ErrorMessage e) {\r\n\t\t\t\tlogger.debug(\"onError: {}\", e);\r\n\t\t\t\tsetError(e.getError());\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleHelloMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param h a {@link org.opcfoundation.ua.transport.tcp.impl.Hello} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleHelloMessage(Hello h) throws ServiceResultException {\r\n\t\t\t\tcancelTimeoutTimer();\r\n\r\n\t\t\t\tEndpointBindingCollection c = endpointServer.getEndpointBindings();\r\n\t\t\t\tif (c==null) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t    checkSecureChannelLimit();\r\n\t\t\t    \r\n\t\t\t    String url = trimUrl(h.getEndpointUrl());\r\n\r\n\t\t\t\tlogger.debug(\"onHello: url={}\", url);\r\n\r\n\t\t\t\tif ( url==null || url.equals(\"\") ) {\r\n\t\t\t\t\tbinding = endpointServer.discoveryEndpointBinding;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tList<EndpointBinding> bindingsForUrl = c.get( url );\r\n\t\t\t\t\tif (bindingsForUrl.isEmpty()) {\r\n\t\t\t\t\t\tbinding = c.getDefault(url);\r\n\t\t\t\t\t\tif(binding == null){\r\n\t\t\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpEndpointUrlInvalid);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbinding = bindingsForUrl.get(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Makes sense to check isDebugEnabled because Arrays.toString method probably takes longer than this check.\r\n\t\t\t\tif(logger.isDebugEnabled()){\r\n\t\t\t\t\tlogger.debug(\" endpoints={}\", Arrays.toString(c.getEndpointAddresses().toArray(new Endpoint[0])));\r\n\t\t\t\t\tlogger.debug(\" endpoint=\" + (binding==null?\"binding is null\":binding.endpointAddress));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (getState()!=CloseableObjectState.Opening) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\tAcknowledge a = new Acknowledge();\r\n\r\n\t\t\t\t// Assert sane values from client\r\n\t\t\t\tif (h.getSendBufferSize().longValue()<8192)\r\n\t\t\t\t\tsetError(new ServiceResultException(Bad_TcpInternalError, \"Peer send buffer size <  8192\"));\r\n\t\t\t\tif (h.getReceiveBufferSize().longValue()<8192)\r\n\t\t\t\t\tsetError(new ServiceResultException(Bad_TcpInternalError, \"Peer recv buffer size <  8192\"));\r\n\t\t\t\tif (getError() != null)\r\n\t\t\t\t\tlogger.warn(\"onHello: \" + getError());\r\n\r\n\t\t\t\t// Determine communication protocol version\r\n\t\t\t\tagreedProtocolVersion = Math.min(StackUtils.TCP_PROTOCOL_VERSION, h.getProtocolVersion().intValue());\r\n\t\t\t\ta.setProtocolVersion( UnsignedInteger.getFromBits(agreedProtocolVersion) );\r\n\r\n\t\t\t\t// Message size\r\n\t\t\t\tif (h.getMaxMessageSize()!=null && h.getMaxMessageSize().intValue()!=0) {\r\n\t\t\t\t\tif (ctx.maxSendMessageSize==0)\r\n\t\t\t\t\t\tctx.maxSendMessageSize = h.getMaxMessageSize().intValue();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tctx.maxSendMessageSize = Math.min(ctx.maxSendMessageSize, h.getMaxMessageSize().intValue());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( binding != null ) {\r\n\t\t\t\t\tint maxMsgSize = binding.endpointAddress.getEndpointConfiguration().getMaxMessageSize();\r\n\t\t\t\t\tctx.maxSendMessageSize = ctx.maxSendMessageSize == 0 ? maxMsgSize : Math.min(ctx.maxSendMessageSize, maxMsgSize);\r\n\t\t\t\t\tctx.maxRecvMessageSize = ctx.maxRecvMessageSize == 0 ? maxMsgSize : Math.min(ctx.maxRecvMessageSize, maxMsgSize);\r\n\t\t\t\t\tencoderCtx.maxMessageSize = maxMsgSize;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tencoderCtx.maxMessageSize = ctx.maxSendMessageSize;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Chunk count\r\n\t\t\t\tif (h.getMaxChunkCount().intValue()!=0)\r\n\t\t\t\t\tctx.maxSendChunkCount = Math.min(ctx.maxSendChunkCount, h.getMaxChunkCount().intValue());\r\n\t\t\t\ta.setMaxChunkCount( UnsignedInteger.getFromBits( ctx.maxRecvChunkCount ) );\r\n\r\n\t\t\t\t// Chunk sizes\r\n\t\t\t\tctx.maxSendChunkSize = Math.min(h.getReceiveBufferSize().intValue(), ctx.maxSendChunkSize);\r\n\t\t\t\tctx.maxRecvChunkSize = Math.min(h.getSendBufferSize().intValue(), ctx.maxRecvChunkSize);\r\n\t\t\t\ta.setSendBufferSize(UnsignedInteger.getFromBits(ctx.maxSendChunkSize));\r\n\t\t\t\ta.setReceiveBufferSize(UnsignedInteger.getFromBits(ctx.maxRecvChunkSize));\r\n\r\n\t\t\t\t// Send buffer (chunk) size\r\n\t\t\t\tctx.maxRecvChunkSize = Math.min(ctx.maxRecvChunkSize, h.getReceiveBufferSize().intValue());\r\n\t\t\t\tctx.maxSendChunkSize = Math.min(ctx.maxSendChunkSize, h.getSendBufferSize().intValue());\r\n\t\t\t\tsetState(CloseableObjectState.Opening);\r\n\r\n\t\t\t\tctx.endpointUrl = h.getEndpointUrl();\r\n\r\n\t\t\t\tsendAcknowledge(a);\r\n\t\t\t\tsetState(CloseableObjectState.Open);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleOpenSecureChannelRequest.</p>\r\n\t\t\t *\r\n\t\t\t * @param mb a {@link org.opcfoundation.ua.transport.tcp.nio.InputMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleOpenSecureChannelRequest(InputMessage mb) throws ServiceResultException {\r\n\t\t\t\tIEncodeable msg = mb.getMessage();\r\n\t\t\t\tif (msg == null)\r\n\t\t\t\t\tsynchronized (this) {\r\n\t\t\t\t\t\tException e = mb.getError();\r\n\t\t\t\t\t\tlogger.warn(\"InputMessage has error\", e);\r\n\t\t\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError, e);\r\n\t\t\t\t\t}\r\n\t\t\t\tif (!(msg instanceof OpenSecureChannelRequest))\r\n\t\t\t\t\tthrow new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\tOpenSecureChannelRequest req\t\t= (OpenSecureChannelRequest) msg;\r\n\r\n\t\t\t\tif (req.getRequestType() == SecurityTokenRequestType.Issue)\r\n\t\t\t\t{\r\n\t\t\t\t\tcheckSecureChannelLimit();\r\n\t\t\t\t      \r\n\t\t\t\t\tOpcTcpServerSecureChannel channel = new OpcTcpServerSecureChannel( this, endpointServer.secureChannelCounter.incrementAndGet() );\r\n\t\t\t\t\tlogger.debug(\"handleOpenSecureChannelRequest: endpointServer={} SecureChannelId={}\", endpointServer, channel.getSecureChannelId());\r\n\t\t\t\t\tchannel.handleOpenChannel(mb, req);\r\n\t\t\t\t} else if (req.getRequestType() == SecurityTokenRequestType.Renew) {\r\n\t\t\t\t\tOpcTcpServerSecureChannel channel = (OpcTcpServerSecureChannel) secureChannels.get(mb.getSecureChannelId());\r\n\t\t\t\t\tif (channel==null)\r\n\t\t\t\t\t\tthrow new ServiceResultException( Bad_SecureChannelIdInvalid );\r\n\r\n\t\t\t\t\tif (!ObjectUtils.objectEquals(req.getRequestType(), SecurityTokenRequestType.Renew)) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\t\tchannel.handleRenewSecureChannelRequest(mb, req);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove closed channels, should maybe be based on timestamps TODO\r\n\t\t\t\tObject[] channelArray = secureChannels.values().toArray();\r\n\t\t\t\tfor (Object channel : channelArray)\r\n\t\t\t\t\tif(((AbstractServerSecureChannel)channel).getState().equals(CloseableObjectState.Closed))\r\n\t\t\t\t\t\tsecureChannels.remove(((AbstractServerSecureChannel)channel).getSecureChannelId());\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleRawChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t */\r\n\t\t\tprotected void handleRawChunk(ByteBuffer chunk) {\r\n\t\t\t\tint type = ChunkUtils.getMessageType(chunk);\r\n\t\t\t\tint messageType = type & TcpMessageType.MESSAGE_TYPE_MASK;\r\n\t\t\t\tint chunkType = type & TcpMessageType.CHUNK_TYPE_MASK;\r\n\t\t\t\tif (chunkType != TcpMessageType.FINAL) {\r\n\t\t\t\t\tclose();\r\n\t\t\t\t}\r\n\t\t\t\tchunk.position(8);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (messageType == TcpMessageType.HELLO) {\r\n\t\t\t\t\t\tChunksToMessage c2m = new ChunksToMessage(ctx, encoderCtx, Hello.class, chunk);\r\n\t\t\t\t\t\thandleHelloMessage( (Hello) c2m.call() );\r\n\t\t\t\t\t} else if (messageType == TcpMessageType.ACKNOWLEDGE) {\r\n\t\t\t\t\t\tChunksToMessage c2m = new ChunksToMessage(ctx, encoderCtx, Acknowledge.class, chunk);\r\n\t\t\t\t\t\thandleAcknowledgeMessage( (Acknowledge) c2m.call() );\r\n\t\t\t\t\t} else if (messageType == TcpMessageType.ERROR) {\r\n\t\t\t\t\t\tChunksToMessage c2m = new ChunksToMessage(ctx, encoderCtx, ErrorMessage.class, chunk);\r\n\t\t\t\t\t\thandleErrorMessage( (ErrorMessage) c2m.call() );\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tsetError( StackUtils.toServiceResultException(e) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleSecureMessage.</p>\r\n\t\t\t *\r\n\t\t\t * @param mb a {@link org.opcfoundation.ua.transport.tcp.nio.InputMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleSecureMessage(InputMessage mb) throws ServiceResultException {\r\n\t\t\t\tIEncodeable msg = mb.getMessage();\r\n\t\t\t\tint secureChannelId = mb.getSecureChannelId();\r\n\t\t\t\tif (logger.isDebugEnabled())\r\n\t\t\t\t\tlogger.debug(\"handleSecureMessage: secureChannelId=\" + secureChannelId + \"msg=\" + (msg == null ? \"null\" : msg.getClass().getSimpleName()));\r\n\r\n\t\t\t\tOpcTcpServerSecureChannel chan = (OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\tif (chan==null)\r\n\t\t\t\t\tthrow new ServiceResultException( Bad_SecureChannelIdInvalid );\r\n\r\n\t\t\t\tif (msg instanceof OpenSecureChannelRequest) {\r\n\t\t\t\t\tOpenSecureChannelRequest req = (OpenSecureChannelRequest) msg;\r\n\r\n\t\t\t\t\tif (!ObjectUtils.objectEquals(req.getRequestType(), SecurityTokenRequestType.Renew)) throw new ServiceResultException(Bad_UnexpectedError);\r\n\r\n\t\t\t\t\tchan.handleRenewSecureChannelRequest(mb, req);\r\n\t\t\t\t} else if (msg instanceof CloseSecureChannelRequest) {\r\n\t\t\t\t\tchan.handleCloseSecureChannelRequest(mb, (CloseSecureChannelRequest)msg);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchan.handleSecureMessage(mb, msg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>handleSymmChunk.</p>\r\n\t\t\t *\r\n\t\t\t * @param chunk a {@link java.nio.ByteBuffer} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void handleSymmChunk(ByteBuffer chunk) throws ServiceResultException {\r\n\t\t\t\tint secureChannelId = ChunkUtils.getSecureChannelId(chunk);\r\n\t\t\t\tint tokenId = ChunkUtils.getTokenId(chunk);\r\n\t\t\t\tchunk.rewind();\r\n\r\n\t\t\t\tOpcTcpServerSecureChannel channel = (OpcTcpServerSecureChannel) secureChannels.get(secureChannelId);\r\n\t\t\t\tif (channel==null)\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpSecureChannelUnknown);\r\n\t\t\t\tif (channel.getState().equals(CloseableObjectState.Closed))\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_SecureChannelIdInvalid);\r\n\t\t\t\tSecurityToken token = channel.getSecurityToken(tokenId);\r\n\t\t\t\tif (token==null)\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_SecureChannelTokenUnknown);\r\n\t\t\t\tif (!token.isValid())\r\n\t\t\t\t\ttoken = channel.getLatestNonExpiredToken();\r\n\t\t\t\tif (token==null || !token.isValid()) {\r\n\t\t\t\t\tSystem.err.println(\"Token expired\");\r\n\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_SecureChannelClosed);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tSecurityToken activeToken = channel.getActiveSecurityToken();\r\n\t\t\t\tif (token!=activeToken) {\r\n\t\t\t\t\tlogger.debug(\"handleSymmChunk: activeToken={}, token={}\", activeToken, token);\r\n\t\t\t\t\tif (activeToken.getCreationTime() < token.getCreationTime()) {\r\n\t\t\t\t\t\tchannel.setActiveSecurityToken(token);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tlogger.debug(\"handleSymmChunk: {}\", secureMessageBuilder);\r\n\t\t\t\tif (secureMessageBuilder!=null && !secureMessageBuilder.moreChunksRequired()) {\r\n\t\t\t\t      // Ensures streams eventually close by putting a \"poison pill\" there\r\n\t\t\t\t      secureMessageBuilder.softClose();\r\n\t\t\t\t      secureMessageBuilder = null;\r\n\t\t\t\t}\r\n\t\t\t\tif (secureMessageBuilder==null) {\r\n\t\t\t\t\tsecureMessageBuilder = new SecureInputMessageBuilder(token/*channel*/, messageListener, ctx, encoderCtx, channel.recvSequenceNumber);\r\n\t\t\t\t\tlogger.debug(\"handleSymmChunk: secureMessageBuilder={}\", secureMessageBuilder);\r\n\t\t\t\t\t//\t\t\t\tonSecureMessageBegin(secureMessageBuilder, chunk);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsecureMessageBuilder.addChunk(chunk);\r\n\t\t\t}\r\n\r\n\t\t\t// Propagate connection closed/error to channels\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tprotected synchronized void onStateTransition(CloseableObjectState oldState,\r\n\t\t\t\t\tCloseableObjectState newState) {\r\n\t\t\t\tsuper.onStateTransition(oldState, newState);\r\n\t\t\t\tlogger.debug(\"onStateTransition: {}->{}\", oldState, newState);\r\n\r\n\t\t\t\tif (newState == CloseableObjectState.Closing)\r\n\t\t\t\t{\r\n\t\t\t\t\tServiceResultException err = getError();\r\n\t\t\t\t\tList<ServerSecureChannel> list = new ArrayList<ServerSecureChannel>();\r\n\t\t\t\t\tOpcTcpServerConnection.this.getSecureChannels(list);\r\n\t\t\t\t\tfor (ServerSecureChannel c : list)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tOpcTcpServerSecureChannel cc = (OpcTcpServerSecureChannel) c;\r\n\t\t\t\t\t\tif (cc != null && err!=null) cc.setError(err);\r\n\t\t\t\t\t\tc.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>sendAcknowledge.</p>\r\n\t\t\t *\r\n\t\t\t * @param a a {@link org.opcfoundation.ua.transport.tcp.impl.Acknowledge} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void sendAcknowledge(Acknowledge a)\r\n\t\t\t\t\tthrows ServiceResultException\r\n\t\t\t{\r\n\t\t\t\tChunkFactory rawChunkFactory = new AcknowledgeChunkFactory();\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(a, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tassert(chunks.length==1);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.ACKNOWLEDGE | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * {@inheritDoc}\r\n\t\t\t *\r\n\t\t\t * Send asymmetric secure message.\r\n\t\t\t */\r\n\t\t\t@Override\r\n\t\t\tprotected int sendAsymmSecureMessage(\r\n\t\t\t\t\tfinal AsyncWrite msg,\r\n\t\t\t\t\tfinal SecurityConfiguration securityConfiguration,\r\n\t\t\t\t\tint secureChannelId,\r\n\t\t\t\t\tint requestNumber,\r\n\t\t\t\t\tAtomicInteger sendSequenceNumber)\r\n\t\t\t\t\t\t\tthrows ServiceResultException\r\n\t\t\t{\r\n\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\tif (msg.isCanceled()) return -1;\r\n\t\t\t\t\tmsg.setQueued();\r\n\t\t\t\t}\r\n\t\t\t\tChunkFactory cf = new ChunkFactory.AsymmMsgChunkFactory(ctx.maxSendChunkSize, securityConfiguration);\r\n\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(msg.getMessage(), ctx, encoderCtx, cf, MessageType.Message);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = cf.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\tif (msg.isCanceled()) return -1;\r\n\t\t\t\t\tmsg.setWriting();\r\n\t\t\t\t}\r\n\t\t\t\tSecurityPolicy policy = securityConfiguration.getSecurityPolicy();\r\n\r\n\t\t\t\tstartChunkSend(chunks);\r\n\t\t\t\tfor (int i=0; i<chunks.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tByteBuffer chunk = chunks[i];\r\n\t\t\t\t\tByteBuffer plaintext = plaintexts[i];\r\n\t\t\t\t\tboolean finalChunk = chunk == chunks[chunks.length-1];\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\tchunk.putInt( TcpMessageType.OPEN | (finalChunk ? TcpMessageType.FINAL : TcpMessageType.CONTINUE) );\r\n\t\t\t\t\tchunk.position(8);\r\n\t\t\t\t\tchunk.putInt(secureChannelId);\r\n\r\n\t\t\t\t\t// -- Security Header --\r\n\t\t\t\t\t// Policy URI\r\n\t\t\t\t\tbyte[] data = policy.getEncodedPolicyUri();\r\n\t\t\t\t\tchunk.putInt(data.length);\r\n\t\t\t\t\tchunk.put(data);\r\n\r\n\t\t\t\t\t// Sender Certificate\r\n\t\t\t\t\tdata = securityConfiguration.getEncodedLocalCertificate();\r\n\t\t\t\t\tchunk.putInt( data==null ? -1 : data.length);\r\n\t\t\t\t\tif (data!=null)\tchunk.put(data);\r\n\r\n\t\t\t\t\t// Recv Certificate Thumbprint\r\n\t\t\t\t\tdata = securityConfiguration.getEncodedRemoteCertificateThumbprint();\r\n\t\t\t\t\tchunk.putInt( data == null ? -1 : data.length);\r\n\t\t\t\t\tif (data!=null)\tchunk.put(data);\r\n\r\n\t\t\t\t\t// -- Sequence header --\r\n\t\t\t\t\tchunk.putInt(sendSequenceNumber.getAndIncrement());\r\n\t\t\t\t\tchunk.putInt(requestNumber); // Request number\r\n\r\n\t\t\t\t\tnew ChunkAsymmEncryptSigner(chunk, plaintext, securityConfiguration).run();\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\tendChunkSend(chunk);\r\n\t\t\t\t}\r\n\t\t\t\tmsg.setWritten();\r\n\t\t\t\treturn chunks.length;\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Send chunks.\r\n\t\t\t *\r\n\t\t\t * @param chunks a {@link java.nio.ByteBuffer} object.\r\n\t\t\t */\r\n\t\t\tprotected synchronized void sendChunks(ByteBuffer...chunks)\r\n\t\t\t{\r\n\t\t\t\tstartChunkSend(chunks);\r\n\t\t\t\tfor (ByteBuffer chunk : chunks)\r\n\t\t\t\t\tendChunkSend(chunk);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>sendError.</p>\r\n\t\t\t *\r\n\t\t\t * @param e a {@link org.opcfoundation.ua.transport.tcp.impl.ErrorMessage} object.\r\n\t\t\t * @throws org.opcfoundation.ua.common.ServiceResultException if any.\r\n\t\t\t */\r\n\t\t\tprotected void sendError(ErrorMessage e)\r\n\t\t\t\t\tthrows ServiceResultException\r\n\t\t\t{\r\n\t\t\t\tChunkFactory rawChunkFactory = new ErrorMessageChunkFactory();\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(e, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tassert(chunks.length==1);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.ERROR | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * <p>sendHello.</p>\r\n\t\t\t *\r\n\t\t\t * @param h a {@link org.opcfoundation.ua.transport.tcp.impl.Hello} object.\r\n\t\t\t */\r\n\t\t\tprotected void sendHello(Hello h)\r\n\t\t\t{\r\n\t\t\t\tctx.endpointUrl = h.getEndpointUrl();\r\n\t\t\t\tChunkFactory rawChunkFactory = new ChunkFactory(ctx.maxSendChunkSize, 8, 0, 0, 0, 1, MessageSecurityMode.None, 0);\r\n\t\t\t\t//ChunkFactory rawChunkFactory = new HelloChunkFactory();\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(h, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\t\t\t\tassert(chunks.length==1);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.HELLO | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t}\r\n\r\n\t\t\tprotected void sendReverseHello(ReverseHello rh) {\r\n\t\t\t\tChunkFactory rawChunkFactory = new ChunkFactory(ctx.maxSendChunkSize, 8, 0, 0, 0, 1, MessageSecurityMode.None, 0);\r\n\t\t\t\tMessageToChunks mc = new MessageToChunks(rh, ctx, encoderCtx, rawChunkFactory, MessageType.Encodeable);\r\n\t\t\t\tfinal ByteBuffer[] plaintexts = mc.call();\r\n\t\t\t\tfinal ByteBuffer[] chunks = rawChunkFactory.expandToCompleteChunk(plaintexts);\r\n\r\n\t\t\t\t// Set header and write\r\n\t\t\t\tchunks[0].putInt(TcpMessageType.REVERSE_HELLO | TcpMessageType.FINAL);\r\n\t\t\t\tchunks[0].rewind();\r\n\t\t\t\tsendChunks(chunks);\r\n\t\t\t\t\r\n\t\t\t\tlogger.debug(\"Sent ReverseHello: {}\", rh);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * {@inheritDoc}\r\n\t\t\t *\r\n\t\t\t * Send symmetric secure message\r\n\t\t\t */\r\n\t\t\t@Override\r\n\t\t\tprotected void sendSecureMessage(\r\n\t\t\t\t\tfinal AsyncWrite msg,\r\n\t\t\t\t\tfinal SecurityToken token,\r\n\t\t\t\t\tfinal int requestId,\r\n\t\t\t\t\tfinal int messageType,\r\n\t\t\t\t\tfinal AtomicInteger sendSequenceNumber\r\n\t\t\t\t\t)\r\n\t\t\t{\r\n\t\t\t\tassert(token!=null);\r\n\t\t\t\tByteBuffer chunks[], plaintexts[];\r\n\t\t\t\tboolean concurrent;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\t\tif (msg.isCanceled()) return;\r\n\t\t\t\t\t\tmsg.setQueued();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Probably more efficient to check isTraceEnabled before executing ObjectUtils.printFieldsDeep\r\n\t\t\t\t\tif (logger.isTraceEnabled())\r\n\t\t\t\t\t\tlogger.trace(\"sendSecureMessage: \" + ObjectUtils.printFieldsDeep(msg.getMessage()));\r\n\t\t\t\t\tSizeCalculationOutputStream calcBuf = new SizeCalculationOutputStream();\r\n\t\t\t\t\tBinaryEncoder calc = new BinaryEncoder(calcBuf);\r\n\t\t\t\t\tcalc.setEncoderContext(encoderCtx);\r\n\t\t\t\t\tcalc.putMessage(msg.getMessage());\r\n\t\t\t\t\tint len = calcBuf.getLength();\r\n\r\n\t\t\t\t\tif (len>ctx.maxSendMessageSize && ctx.maxSendMessageSize!=0)\r\n\t\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpMessageTooLarge);\r\n\r\n\t\t\t\t\tSecurityPolicy policy = token.getSecurityPolicy();\r\n\t\t\t\t\tMessageSecurityMode mode = token.getMessageSecurityMode();\r\n\t\t\t\t\tSecurityAlgorithm symmEncryptAlgo = policy.getSymmetricEncryptionAlgorithm();\r\n\t\t\t\t\tSecurityAlgorithm symmSignAlgo = policy.getSymmetricSignatureAlgorithm();\r\n\t\t\t\t\tint cipherBlockSize = CryptoUtil.getCipherBlockSize(symmEncryptAlgo, null);\r\n\t\t\t\t\tint signatureSize = CryptoUtil.getSignatureSize(symmSignAlgo, null);\r\n\t\t\t\t\tint keySize = mode == MessageSecurityMode.SignAndEncrypt ? token.getRemoteEncryptingKey().length : 0;\r\n\t\t\t\t\tint paddingSize = mode == MessageSecurityMode.SignAndEncrypt ? keySize > 2048 ? 2 : 1 : 0;\r\n\r\n\t\t\t\t\tint maxPlaintextSize = ctx.maxSendChunkSize - 24 - paddingSize - signatureSize;\r\n\t\t\t\t\tmaxPlaintextSize -= (maxPlaintextSize + paddingSize + signatureSize + 8) % cipherBlockSize;\r\n\t\t\t\t\tfinal int CORES = StackUtils.cores();\r\n\r\n\t\t\t\t\tint optimalPayloadSize = (len+CORES-1) / CORES;\r\n\t\t\t\t\tif (optimalPayloadSize > maxPlaintextSize)\r\n\t\t\t\t\t\toptimalPayloadSize = maxPlaintextSize;\r\n\t\t\t\t\tif (optimalPayloadSize < 4096)\r\n\t\t\t\t\t\toptimalPayloadSize = 4096;\r\n\t\t\t\t\tint optimalChunkSize = optimalPayloadSize + 24 + paddingSize + signatureSize;\r\n\r\n\t\t\t\t\tChunkFactory cf = new ChunkFactory(\r\n\t\t\t\t\t\t\toptimalChunkSize,\r\n\t\t\t\t\t\t\t8,\r\n\t\t\t\t\t\t\t8,\r\n\t\t\t\t\t\t\t8,\r\n\t\t\t\t\t\t\tsignatureSize,\r\n\t\t\t\t\t\t\tcipherBlockSize,\r\n\t\t\t\t\t\t\tmode,\r\n\t\t\t\t\t\t\tkeySize);\r\n\r\n\t\t\t\t\t// Calculate chunk count\r\n\t\t\t\t\tfinal int count = (len + cf.maxPlaintextSize-1) / cf.maxPlaintextSize;\r\n\t\t\t\t\tif (count>ctx.maxSendChunkCount && ctx.maxSendChunkCount!=0)\r\n\t\t\t\t\t\tthrow new ServiceResultException(StatusCodes.Bad_TcpMessageTooLarge);\r\n\t\t\t\t\tconcurrent = (count > 1) && (CORES>0) && (mode != MessageSecurityMode.None);\r\n\r\n\t\t\t\t\t// Allocate chunks\r\n\t\t\t\t\tint bytesLeft = len;\r\n\t\t\t\t\tplaintexts = new ByteBuffer[count];\r\n\t\t\t\t\tchunks = new ByteBuffer[count];\r\n\t\t\t\t\tfor (int i=0; i<count; i++) {\r\n\t\t\t\t\t\tplaintexts[i] = cf.allocate(bytesLeft);\r\n\t\t\t\t\t\tchunks[i] = cf.expandToCompleteChunk(plaintexts[i]);\r\n\t\t\t\t\t\tbytesLeft -= plaintexts[i].remaining();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tassert(bytesLeft==0);\r\n\r\n\t\t\t\t\t// Start write\r\n\t\t\t\t\tsynchronized(msg) {\r\n\t\t\t\t\t\tif (msg.isCanceled()) return;\r\n\t\t\t\t\t\tmsg.setWriting();\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (ServiceResultException se) {\r\n\t\t\t\t\tmsg.setError(se);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfinal ByteBuffer _chunks[] = chunks;\r\n\t\t\t\tfinal ByteBuffer _plaintexts[] = plaintexts;\r\n\t\t\t\tfinal int count = chunks.length;\r\n\t\t\t\tfinal boolean parallel = concurrent;\r\n\r\n\t\t\t\tint sequenceNumber = 0;\r\n\t\t\t\tsynchronized(this) {\r\n\t\t\t\t\tsequenceNumber = sendSequenceNumber.getAndAdd(chunks.length);\r\n\t\t\t\t\tstartChunkSend(chunks);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add chunk headers\r\n\t\t\t\tfor (ByteBuffer chunk : chunks) {\r\n\t\t\t\t\tboolean finalChunk = chunk == chunks[chunks.length-1];\r\n\t\t\t\t\tchunk.rewind();\r\n\t\t\t\t\tchunk.putInt( messageType | (finalChunk ? TcpMessageType.FINAL : TcpMessageType.CONTINUE) );\r\n\t\t\t\t\tchunk.position(8);\r\n\t\t\t\t\tchunk.putInt(token.getSecureChannelId());\r\n\r\n\t\t\t\t\t// -- Security Header --\r\n\t\t\t\t\tchunk.putInt(token.getTokenId());\r\n\r\n\t\t\t\t\t// -- Sequence Header --\r\n\t\t\t\t\tchunk.putInt(sequenceNumber++);\r\n\t\t\t\t\tchunk.putInt(requestId);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// a Chunk-has-been-encoded handler\r\n\t\t\t\tfinal AtomicInteger chunksComplete = new AtomicInteger();\r\n\t\t\t\tChunkListener completitionListener = new ChunkListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onChunkComplete(ByteBuffer[] bufs, final int index) {\r\n\t\t\t\t\t\tRunnable action = new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run() {\r\n\t\t\t\t\t\t\t\t// Chunk contains message data, it needs to be encrypted and signed\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t// Encrypt & sign\r\n\t\t\t\t\t\t\t\tnew ChunkSymmEncryptSigner(_chunks[index], _plaintexts[index], token).run();\r\n\t\t\t\t\t\t\t\t_chunks[index].rewind();\r\n\r\n\t\t\t\t\t\t\t\t// Write chunk\r\n\t\t\t\t\t\t\t\tendChunkSend(_chunks[index]);\r\n\r\n\t\t\t\t\t\t\t\t// All chunks are completed\r\n\t\t\t\t\t\t\t\tif (chunksComplete.incrementAndGet()==count)\r\n\t\t\t\t\t\t\t\t\tmsg.setWritten();\r\n\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t} catch (ServiceResultException se) {\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\tmsg.setError(se);\r\n\t\t\t\t\t\t\t\t//\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}};\r\n\t\t\t\t\t\t\tif (parallel && count>1) {\r\n\t\t\t\t\t\t\t\tStackUtils.getNonBlockingWorkExecutor().execute(action);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\taction.run();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Create encoder\r\n\t\t\t\tByteBufferArrayWriteable2 out = new ByteBufferArrayWriteable2(plaintexts, completitionListener);\r\n\t\t\t\tout.order(ByteOrder.LITTLE_ENDIAN);\r\n\r\n\t\t\t\tfinal BinaryEncoder enc = new BinaryEncoder(out);\r\n\t\t\t\tenc.setEncoderContext(encoderCtx);\r\n\r\n\t\t\t\tRunnable encoder = new Runnable() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void run() {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tenc.putMessage(msg.getMessage());\r\n\r\n\t\t\t\t\t\t\t// If the message was ActivateSessionResponse, which was Good, then mark that this\r\n\t\t\t\t\t\t\t// connection has a successful activated session (and thus is not removed when we are at\r\n\t\t\t\t\t\t\t// max connections. If we are at max connections, per 1.05 Part 4 5.5.2: \"To protect\r\n\t\t\t\t\t\t\t// against misbehaving Clients and denial of service attacks, the Server shall close the\r\n\t\t\t\t\t\t\t// oldest unused SecureChannelthat has no Session assigned before reaching the maximum\r\n\t\t\t\t\t\t\t// number of supported SecureChannels. \")\r\n\t\t\t\t\t\t\tif (msg.getMessage() instanceof ActivateSessionResponse) {\r\n\t\t\t\t\t\t\t\tActivateSessionResponse res = (ActivateSessionResponse) msg.getMessage();\r\n\t\t\t\t\t\t\t\tif ((res.getResponseHeader() != null) && (res.getResponseHeader().getServiceResult() != null) && \r\n\t\t\t\t\t\t\t\t\t\t(res.getResponseHeader().getServiceResult().isGood())) {\r\n\t\t\t\t\t\t\t\t\thasBeenSuccessfullySessionActivated.set(true);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} catch (ServiceResultException e) {\r\n\t\t\t\t\t\t\tmsg.setError( StackUtils.toServiceResultException(e) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}};\r\n\t\t\t\t\tStackUtils.getBlockingWorkExecutor().execute(encoder);\r\n\t\t\t}\r\n\r\n\t\t\t/** {@inheritDoc} */\r\n\t\t\t@Override\r\n\t\t\tprotected synchronized void setError(ServiceResultException e) {\r\n\t\t\t\tif(!hasError()){\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tsendError(new ErrorMessage(e.getStatusCode(), e.getMessage()));\r\n\t\t\t\t\t} catch (ServiceResultException e1) {\r\n\t\t\t\t\t\tlogger.warn(\"Could not send error message\",e1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsuper.setError(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * Put chunks into send queue. Chunks will be given a sequence number\r\n\t\t\t * but will be flushed in endChunkSend().\r\n\t\t\t *\r\n\t\t\t * @param chunks a {@link java.nio.ByteBuffer} object.\r\n\t\t\t */\r\n\t\t\tprotected void startChunkSend(ByteBuffer...chunks)\r\n\t\t\t{\r\n\t\t\t\tsynchronized(chunkIncubator) {\r\n\t\t\t\t\tfor (ByteBuffer chunk : chunks)\r\n\t\t\t\t\t\tchunkIncubator.incubate(chunk);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n}\r\n"], "filenames": ["src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServer.java", "src/main/java/org/opcfoundation/ua/transport/tcp/nio/OpcTcpServerConnection.java"], "buggy_code_start_loc": [194, 313], "buggy_code_end_loc": [299, 1238], "fixing_code_start_loc": [194, 314], "fixing_code_end_loc": [306, 1251], "type": "CWE-400", "message": "The OPC UA Legacy Java Stack before 6f176f2 enables an attacker to block OPC UA server applications via uncontrolled resource consumption so that they can no longer serve client applications.", "other": {"cve": {"id": "CVE-2023-32787", "sourceIdentifier": "cve@mitre.org", "published": "2023-05-15T15:15:12.823", "lastModified": "2023-05-24T20:41:17.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The OPC UA Legacy Java Stack before 6f176f2 enables an attacker to block OPC UA server applications via uncontrolled resource consumption so that they can no longer serve client applications."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opcfoundation:ua_java_legacy:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-04-28", "matchCriteriaId": "A87006B3-496C-4A85-A1BE-4F2B18C5438C"}]}]}], "references": [{"url": "https://files.opcfoundation.org/SecurityBulletins/OPC%20Foundation%20Security%20Bulletin%20CVE-2023-32787.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/OPCFoundation/UA-Java-Legacy", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/OPCFoundation/UA-Java-Legacy/commit/6f176f2b445a27c157f1a32f225accc9ce8873c0", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/OPCFoundation/UA-Java-Legacy/commit/6f176f2b445a27c157f1a32f225accc9ce8873c0"}}