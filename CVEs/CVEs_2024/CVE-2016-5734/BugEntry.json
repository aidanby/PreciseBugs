{"buggy_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Core script for import, this is just the glue around all other stuff\n *\n * @package PhpMyAdmin\n */\nuse PMA\\libraries\\plugins\\ImportPlugin;\n\n/**\n * Get the variables sent or posted to this script and a core script\n */\nrequire_once 'libraries/common.inc.php';\nrequire_once 'libraries/sql.lib.php';\nrequire_once 'libraries/bookmark.lib.php';\n//require_once 'libraries/display_import_functions.lib.php';\n\nif (isset($_REQUEST['show_as_php'])) {\n    $GLOBALS['show_as_php'] = $_REQUEST['show_as_php'];\n}\n\n// Import functions.\nrequire_once 'libraries/import.lib.php';\n\n// If there is a request to 'Simulate DML'.\nif (isset($_REQUEST['simulate_dml'])) {\n    PMA_handleSimulateDMLRequest();\n    exit;\n}\n\n// If it's a refresh console bookmarks request\nif (isset($_REQUEST['console_bookmark_refresh'])) {\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->addJSON(\n        'console_message_bookmark', PMA\\libraries\\Console::getBookmarkContent()\n    );\n    exit;\n}\n// If it's a console bookmark add request\nif (isset($_REQUEST['console_bookmark_add'])) {\n    $response = PMA\\libraries\\Response::getInstance();\n    if (isset($_REQUEST['label']) && isset($_REQUEST['db'])\n        && isset($_REQUEST['bookmark_query']) && isset($_REQUEST['shared'])\n    ) {\n        $cfgBookmark = PMA_Bookmark_getParams();\n        $bookmarkFields = array(\n            'bkm_database' => $_REQUEST['db'],\n            'bkm_user'  => $cfgBookmark['user'],\n            'bkm_sql_query' => $_REQUEST['bookmark_query'],\n            'bkm_label' => $_REQUEST['label']\n        );\n        $isShared = ($_REQUEST['shared'] == 'true' ? true : false);\n        if (PMA_Bookmark_save($bookmarkFields, $isShared)) {\n            $response->addJSON('message', __('Succeeded'));\n            $response->addJSON('data', $bookmarkFields);\n            $response->addJSON('isShared', $isShared);\n        } else {\n            $response->addJSON('message', __('Failed'));\n        }\n        die();\n    } else {\n        $response->addJSON('message', __('Incomplete params'));\n        die();\n    }\n}\n\n$format = '';\n\n/**\n * Sets globals from $_POST\n */\n$post_params = array(\n    'charset_of_file',\n    'format',\n    'import_type',\n    'is_js_confirmed',\n    'MAX_FILE_SIZE',\n    'message_to_show',\n    'noplugin',\n    'skip_queries',\n    'local_import_file'\n);\n\n// TODO: adapt full list of allowed parameters, as in export.php\nforeach ($post_params as $one_post_param) {\n    if (isset($_POST[$one_post_param])) {\n        $GLOBALS[$one_post_param] = $_POST[$one_post_param];\n    }\n}\n\n// reset import messages for ajax request\n$_SESSION['Import_message']['message'] = null;\n$_SESSION['Import_message']['go_back_url'] = null;\n// default values\n$GLOBALS['reload'] = false;\n\n// Use to identify current cycle is executing\n// a multiquery statement or stored routine\nif (!isset($_SESSION['is_multi_query'])) {\n    $_SESSION['is_multi_query'] = false;\n}\n\n$ajax_reload = array();\n// Are we just executing plain query or sql file?\n// (eg. non import, but query box/window run)\nif (! empty($sql_query)) {\n\n    // apply values for parameters\n    if (! empty($_REQUEST['parameterized'])\n        && ! empty($_REQUEST['parameters'])\n        && is_array($_REQUEST['parameters'])) {\n        $parameters = $_REQUEST['parameters'];\n        foreach ($parameters as $parameter => $replacement) {\n            $quoted = preg_quote($parameter);\n            // making sure that :param does not apply values to :param1\n            $sql_query = preg_replace(\n                '/' . $quoted . '([^a-zA-Z0-9_])/',\n                PMA\\libraries\\Util::sqlAddSlashes($replacement) . '${1}',\n                $sql_query\n            );\n            // for parameters the appear at the end of the string\n            $sql_query = preg_replace(\n                '/' . $quoted . '$/',\n                PMA\\libraries\\Util::sqlAddSlashes($replacement),\n                $sql_query\n            );\n        }\n    }\n\n    // run SQL query\n    $import_text = $sql_query;\n    $import_type = 'query';\n    $format = 'sql';\n    $_SESSION['sql_from_query_box'] = true;\n\n    // If there is a request to ROLLBACK when finished.\n    if (isset($_REQUEST['rollback_query'])) {\n        PMA_handleRollbackRequest($import_text);\n    }\n\n    // refresh navigation and main panels\n    if (preg_match('/^(DROP)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i', $sql_query)) {\n        $GLOBALS['reload'] = true;\n        $ajax_reload['reload'] = true;\n    }\n\n    // refresh navigation panel only\n    if (preg_match(\n        '/^(CREATE|ALTER)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i',\n        $sql_query\n    )) {\n        $ajax_reload['reload'] = true;\n    }\n\n    // do a dynamic reload if table is RENAMED\n    // (by sending the instruction to the AJAX response handler)\n    if (preg_match(\n        '/^RENAME\\s+TABLE\\s+(.*?)\\s+TO\\s+(.*?)($|;|\\s)/i',\n        $sql_query,\n        $rename_table_names\n    )) {\n        $ajax_reload['reload'] = true;\n        $ajax_reload['table_name'] = PMA\\libraries\\Util::unQuote(\n            $rename_table_names[2]\n        );\n    }\n\n    $sql_query = '';\n} elseif (! empty($sql_file)) {\n    // run uploaded SQL file\n    $import_file = $sql_file;\n    $import_type = 'queryfile';\n    $format = 'sql';\n    unset($sql_file);\n} elseif (! empty($_REQUEST['id_bookmark'])) {\n    // run bookmark\n    $import_type = 'query';\n    $format = 'sql';\n}\n\n// If we didn't get any parameters, either user called this directly, or\n// upload limit has been reached, let's assume the second possibility.\nif ($_POST == array() && $_GET == array()) {\n    $message = PMA\\libraries\\Message::error(\n        __(\n            'You probably tried to upload a file that is too large. Please refer ' .\n            'to %sdocumentation%s for a workaround for this limit.'\n        )\n    );\n    $message->addParam('[doc@faq1-16]');\n    $message->addParam('[/doc]');\n\n    // so we can obtain the message\n    $_SESSION['Import_message']['message'] = $message->getDisplay();\n    $_SESSION['Import_message']['go_back_url'] = $GLOBALS['goto'];\n\n    $message->display();\n    exit; // the footer is displayed automatically\n}\n\n// Add console message id to response output\nif (isset($_POST['console_message_id'])) {\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->addJSON('console_message_id', $_POST['console_message_id']);\n}\n\n/**\n * Sets globals from $_POST patterns, for import plugins\n * We only need to load the selected plugin\n */\n\nif (! in_array(\n    $format,\n    array(\n        'csv',\n        'ldi',\n        'mediawiki',\n        'ods',\n        'shp',\n        'sql',\n        'xml'\n    )\n)\n) {\n    // this should not happen for a normal user\n    // but only during an attack\n    PMA_fatalError('Incorrect format parameter');\n}\n\n$post_patterns = array(\n    '/^force_file_/',\n    '/^' . $format . '_/'\n);\n\nPMA_setPostAsGlobal($post_patterns);\n\n// Check needed parameters\nPMA\\libraries\\Util::checkParameters(array('import_type', 'format'));\n\n// We don't want anything special in format\n$format = PMA_securePath($format);\n\n// Create error and goto url\nif ($import_type == 'table') {\n    $err_url = 'tbl_import.php' . PMA_URL_getCommon(\n        array(\n            'db' => $db, 'table' => $table\n        )\n    );\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n    $goto = 'tbl_import.php';\n} elseif ($import_type == 'database') {\n    $err_url = 'db_import.php' . PMA_URL_getCommon(array('db' => $db));\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n    $goto = 'db_import.php';\n} elseif ($import_type == 'server') {\n    $err_url = 'server_import.php' . PMA_URL_getCommon();\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n    $goto = 'server_import.php';\n} else {\n    if (empty($goto) || !preg_match('@^(server|db|tbl)(_[a-z]*)*\\.php$@i', $goto)) {\n        if (mb_strlen($table) && mb_strlen($db)) {\n            $goto = 'tbl_structure.php';\n        } elseif (mb_strlen($db)) {\n            $goto = 'db_structure.php';\n        } else {\n            $goto = 'server_sql.php';\n        }\n    }\n    if (mb_strlen($table) && mb_strlen($db)) {\n        $common = PMA_URL_getCommon(array('db' => $db, 'table' => $table));\n    } elseif (mb_strlen($db)) {\n        $common = PMA_URL_getCommon(array('db' => $db));\n    } else {\n        $common = PMA_URL_getCommon();\n    }\n    $err_url  = $goto . $common\n        . (preg_match('@^tbl_[a-z]*\\.php$@', $goto)\n            ? '&amp;table=' . htmlspecialchars($table)\n            : '');\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n}\n// Avoid setting selflink to 'import.php'\n// problem similar to bug 4276\nif (basename($_SERVER['SCRIPT_NAME']) === 'import.php') {\n    $_SERVER['SCRIPT_NAME'] = $goto;\n}\n\n\nif (mb_strlen($db)) {\n    $GLOBALS['dbi']->selectDb($db);\n}\n\n@set_time_limit($cfg['ExecTimeLimit']);\nif (! empty($cfg['MemoryLimit'])) {\n    @ini_set('memory_limit', $cfg['MemoryLimit']);\n}\n\n$timestamp = time();\nif (isset($_REQUEST['allow_interrupt'])) {\n    $maximum_time = ini_get('max_execution_time');\n} else {\n    $maximum_time = 0;\n}\n\n// set default values\n$timeout_passed = false;\n$error = false;\n$read_multiply = 1;\n$finished = false;\n$offset = 0;\n$max_sql_len = 0;\n$file_to_unlink = '';\n$sql_query = '';\n$sql_query_disabled = false;\n$go_sql = false;\n$executed_queries = 0;\n$run_query = true;\n$charset_conversion = false;\n$reset_charset = false;\n$bookmark_created = false;\n\n// Bookmark Support: get a query back from bookmark if required\nif (! empty($_REQUEST['id_bookmark'])) {\n    $id_bookmark = (int)$_REQUEST['id_bookmark'];\n    include_once 'libraries/bookmark.lib.php';\n    switch ($_REQUEST['action_bookmark']) {\n    case 0: // bookmarked query that have to be run\n        $import_text = PMA_Bookmark_get(\n            $db,\n            $id_bookmark,\n            'id',\n            isset($_REQUEST['action_bookmark_all'])\n        );\n        if (! empty($_REQUEST['bookmark_variable'])) {\n            $import_text = PMA_Bookmark_applyVariables(\n                $import_text\n            );\n        }\n\n        // refresh navigation and main panels\n        if (preg_match(\n            '/^(DROP)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i',\n            $import_text\n        )) {\n            $GLOBALS['reload'] = true;\n            $ajax_reload['reload'] = true;\n        }\n\n        // refresh navigation panel only\n        if (preg_match(\n            '/^(CREATE|ALTER)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i',\n            $import_text\n        )\n        ) {\n            $ajax_reload['reload'] = true;\n        }\n        break;\n    case 1: // bookmarked query that have to be displayed\n        $import_text = PMA_Bookmark_get($db, $id_bookmark);\n        if ($GLOBALS['is_ajax_request'] == true) {\n            $message = PMA\\libraries\\Message::success(__('Showing bookmark'));\n            $response = PMA\\libraries\\Response::getInstance();\n            $response->setRequestStatus($message->isSuccess());\n            $response->addJSON('message', $message);\n            $response->addJSON('sql_query', $import_text);\n            $response->addJSON('action_bookmark', $_REQUEST['action_bookmark']);\n            exit;\n        } else {\n            $run_query = false;\n        }\n        break;\n    case 2: // bookmarked query that have to be deleted\n        $import_text = PMA_Bookmark_get($db, $id_bookmark);\n        PMA_Bookmark_delete($id_bookmark);\n        if ($GLOBALS['is_ajax_request'] == true) {\n            $message = PMA\\libraries\\Message::success(\n                __('The bookmark has been deleted.')\n            );\n            $response = PMA\\libraries\\Response::getInstance();\n            $response->setRequestStatus($message->isSuccess());\n            $response->addJSON('message', $message);\n            $response->addJSON('action_bookmark', $_REQUEST['action_bookmark']);\n            $response->addJSON('id_bookmark', $id_bookmark);\n            exit;\n        } else {\n            $run_query = false;\n            $error = true; // this is kind of hack to skip processing the query\n        }\n        break;\n    }\n} // end bookmarks reading\n\n// Do no run query if we show PHP code\nif (isset($GLOBALS['show_as_php'])) {\n    $run_query = false;\n    $go_sql = true;\n}\n\n// We can not read all at once, otherwise we can run out of memory\n$memory_limit = trim(@ini_get('memory_limit'));\n// 2 MB as default\nif (empty($memory_limit)) {\n    $memory_limit = 2 * 1024 * 1024;\n}\n// In case no memory limit we work on 10MB chunks\nif ($memory_limit == -1) {\n    $memory_limit = 10 * 1024 * 1024;\n}\n\n// Calculate value of the limit\n$memoryUnit = mb_strtolower(substr($memory_limit, -1));\nif ('m' == $memoryUnit) {\n    $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024;\n} elseif ('k' == $memoryUnit) {\n    $memory_limit = (int)substr($memory_limit, 0, -1) * 1024;\n} elseif ('g' == $memoryUnit) {\n    $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024 * 1024;\n} else {\n    $memory_limit = (int)$memory_limit;\n}\n\n// Just to be sure, there might be lot of memory needed for uncompression\n$read_limit = $memory_limit / 8;\n\n// handle filenames\nif (isset($_FILES['import_file'])) {\n    $import_file = $_FILES['import_file']['tmp_name'];\n}\nif (! empty($local_import_file) && ! empty($cfg['UploadDir'])) {\n\n    // sanitize $local_import_file as it comes from a POST\n    $local_import_file = PMA_securePath($local_import_file);\n\n    $import_file = PMA\\libraries\\Util::userDir($cfg['UploadDir'])\n        . $local_import_file;\n\n} elseif (empty($import_file) || ! is_uploaded_file($import_file)) {\n    $import_file  = 'none';\n}\n\n// Do we have file to import?\n\nif ($import_file != 'none' && ! $error) {\n    // work around open_basedir and other limitations\n    $open_basedir = @ini_get('open_basedir');\n\n    // If we are on a server with open_basedir, we must move the file\n    // before opening it.\n\n    if (! empty($open_basedir)) {\n        $tmp_subdir = ini_get('upload_tmp_dir');\n        if (empty($tmp_subdir)) {\n            $tmp_subdir = sys_get_temp_dir();\n        }\n        $tmp_subdir = rtrim($tmp_subdir, DIRECTORY_SEPARATOR);\n        if (@is_writable($tmp_subdir)) {\n            $import_file_new = $tmp_subdir . DIRECTORY_SEPARATOR\n                . basename($import_file) . uniqid();\n            if (move_uploaded_file($import_file, $import_file_new)) {\n                $import_file = $import_file_new;\n                $file_to_unlink = $import_file_new;\n            }\n\n            $size = filesize($import_file);\n        } else {\n\n            // If the php.ini is misconfigured (eg. there is no /tmp access defined\n            // with open_basedir), $tmp_subdir won't be writable and the user gets\n            // a 'File could not be read!' error (at PMA_detectCompression), which\n            // is not too meaningful. Show a meaningful error message to the user\n            // instead.\n\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'Uploaded file cannot be moved, because the server has ' .\n                    'open_basedir enabled without access to the %s directory ' .\n                    '(for temporary files).'\n                )\n            );\n            $message->addParam($tmp_subdir);\n            PMA_stopImport($message);\n        }\n    }\n\n    /**\n     *  Handle file compression\n     * @todo duplicate code exists in File.php\n     */\n    $compression = PMA_detectCompression($import_file);\n    if ($compression === false) {\n        $message = PMA\\libraries\\Message::error(__('File could not be read!'));\n        PMA_stopImport($message); //Contains an 'exit'\n    }\n\n    switch ($compression) {\n    case 'application/bzip2':\n        if ($cfg['BZipDump'] && @function_exists('bzopen')) {\n            $import_handle = @bzopen($import_file, 'r');\n        } else {\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'You attempted to load file with unsupported compression ' .\n                    '(%s). Either support for it is not implemented or disabled ' .\n                    'by your configuration.'\n                )\n            );\n            $message->addParam($compression);\n            PMA_stopImport($message);\n        }\n        break;\n    case 'application/gzip':\n        if ($cfg['GZipDump'] && @function_exists('gzopen')) {\n            $import_handle = @gzopen($import_file, 'r');\n        } else {\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'You attempted to load file with unsupported compression ' .\n                    '(%s). Either support for it is not implemented or disabled ' .\n                    'by your configuration.'\n                )\n            );\n            $message->addParam($compression);\n            PMA_stopImport($message);\n        }\n        break;\n    case 'application/zip':\n        if ($cfg['ZipDump'] && @function_exists('zip_open')) {\n            /**\n             * Load interface for zip extension.\n             */\n            include_once 'libraries/zip_extension.lib.php';\n            $zipResult = PMA_getZipContents($import_file);\n            if (! empty($zipResult['error'])) {\n                $message = PMA\\libraries\\Message::rawError($zipResult['error']);\n                PMA_stopImport($message);\n            } else {\n                $import_text = $zipResult['data'];\n            }\n        } else {\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'You attempted to load file with unsupported compression ' .\n                    '(%s). Either support for it is not implemented or disabled ' .\n                    'by your configuration.'\n                )\n            );\n            $message->addParam($compression);\n            PMA_stopImport($message);\n        }\n        break;\n    case 'none':\n        $import_handle = @fopen($import_file, 'r');\n        break;\n    default:\n        $message = PMA\\libraries\\Message::error(\n            __(\n                'You attempted to load file with unsupported compression (%s). ' .\n                'Either support for it is not implemented or disabled by your ' .\n                'configuration.'\n            )\n        );\n        $message->addParam($compression);\n        PMA_stopImport($message);\n        // the previous function exits\n    }\n    // use isset() because zip compression type does not use a handle\n    if (! $error && isset($import_handle) && $import_handle === false) {\n        $message = PMA\\libraries\\Message::error(__('File could not be read!'));\n        PMA_stopImport($message);\n    }\n} elseif (! $error) {\n    if (! isset($import_text) || empty($import_text)) {\n        $message = PMA\\libraries\\Message::error(\n            __(\n                'No data was received to import. Either no file name was ' .\n                'submitted, or the file size exceeded the maximum size permitted ' .\n                'by your PHP configuration. See [doc@faq1-16]FAQ 1.16[/doc].'\n            )\n        );\n        PMA_stopImport($message);\n    }\n}\n\n// so we can obtain the message\n//$_SESSION['Import_message'] = $message->getDisplay();\n\n// Convert the file's charset if necessary\nif ($GLOBALS['PMA_recoding_engine'] != PMA_CHARSET_NONE && isset($charset_of_file)) {\n    if ($charset_of_file != 'utf-8') {\n        $charset_conversion = true;\n    }\n} elseif (isset($charset_of_file) && $charset_of_file != 'utf-8') {\n    $GLOBALS['dbi']->query('SET NAMES \\'' . $charset_of_file . '\\'');\n    // We can not show query in this case, it is in different charset\n    $sql_query_disabled = true;\n    $reset_charset = true;\n}\n\n// Something to skip? (because timeout has passed)\nif (! $error && isset($_POST['skip'])) {\n    $original_skip = $skip = $_POST['skip'];\n    while ($skip > 0) {\n        PMA_importGetNextChunk($skip < $read_limit ? $skip : $read_limit);\n        // Disable read progressivity, otherwise we eat all memory!\n        $read_multiply = 1;\n        $skip -= $read_limit;\n    }\n    unset($skip);\n}\n\n// This array contain the data like numberof valid sql queries in the statement\n// and complete valid sql statement (which affected for rows)\n$sql_data = array('valid_sql' => array(), 'valid_queries' => 0);\n\nif (! $error) {\n    // Check for file existence\n    include_once \"libraries/plugin_interface.lib.php\";\n    /* @var $import_plugin ImportPlugin */\n    $import_plugin = PMA_getPlugin(\n        \"import\",\n        $format,\n        'libraries/plugins/import/',\n        $import_type\n    );\n    if ($import_plugin == null) {\n        $message = PMA\\libraries\\Message::error(\n            __('Could not load import plugins, please check your installation!')\n        );\n        PMA_stopImport($message);\n    } else {\n        // Do the real import\n        try {\n            $default_fk_check = PMA\\libraries\\Util::handleDisableFKCheckInit();\n            $import_plugin->doImport($sql_data);\n            PMA\\libraries\\Util::handleDisableFKCheckCleanup($default_fk_check);\n        } catch (Exception $e) {\n            PMA\\libraries\\Util::handleDisableFKCheckCleanup($default_fk_check);\n            throw $e;\n        }\n    }\n}\n\nif (! empty($import_handle)) {\n    fclose($import_handle);\n}\n\n// Cleanup temporary file\nif ($file_to_unlink != '') {\n    unlink($file_to_unlink);\n}\n\n// Reset charset back, if we did some changes\nif ($reset_charset) {\n    $GLOBALS['dbi']->query('SET CHARACTER SET utf8');\n    $GLOBALS['dbi']->query(\n        'SET SESSION collation_connection =\\'' . $collation_connection . '\\''\n    );\n}\n\n// Show correct message\nif (! empty($id_bookmark) && $_REQUEST['action_bookmark'] == 2) {\n    $message = PMA\\libraries\\Message::success(__('The bookmark has been deleted.'));\n    $display_query = $import_text;\n    $error = false; // unset error marker, it was used just to skip processing\n} elseif (! empty($id_bookmark) && $_REQUEST['action_bookmark'] == 1) {\n    $message = PMA\\libraries\\Message::notice(__('Showing bookmark'));\n} elseif ($bookmark_created) {\n    $special_message = '[br]'  . sprintf(\n        __('Bookmark %s has been created.'),\n        htmlspecialchars($_POST['bkm_label'])\n    );\n} elseif ($finished && ! $error) {\n    // Do not display the query with message, we do it separately\n    $display_query = ';';\n    if ($import_type != 'query') {\n        $message = PMA\\libraries\\Message::success(\n            '<em>'\n            . _ngettext(\n                'Import has been successfully finished, %d query executed.',\n                'Import has been successfully finished, %d queries executed.',\n                $executed_queries\n            )\n            . '</em>'\n        );\n        $message->addParam($executed_queries);\n\n        if ($import_notice) {\n            $message->addString($import_notice);\n        }\n        if (! empty($local_import_file)) {\n            $message->addString('(' . htmlspecialchars($local_import_file) . ')');\n        } else {\n            $message->addString(\n                '(' . htmlspecialchars($_FILES['import_file']['name']) . ')'\n            );\n        }\n    }\n}\n\n// Did we hit timeout? Tell it user.\nif ($timeout_passed) {\n    $importUrl = $err_url .= '&timeout_passed=1&offset=' . urlencode(\n        $GLOBALS['offset']\n    );\n    if (isset($local_import_file)) {\n        $importUrl .= '&local_import_file=' . urlencode($local_import_file);\n    }\n    $message = PMA\\libraries\\Message::error(\n        __(\n            'Script timeout passed, if you want to finish import,'\n            . ' please %sresubmit the same file%s and import will resume.'\n        )\n    );\n    $message->addParam('<a href=\"' . $importUrl . '\">', false);\n    $message->addParam('</a>', false);\n\n    if ($offset == 0 || (isset($original_skip) && $original_skip == $offset)) {\n        $message->addString(\n            __(\n                'However on last run no data has been parsed,'\n                . ' this usually means phpMyAdmin won\\'t be able to'\n                . ' finish this import unless you increase php time limits.'\n            )\n        );\n    }\n}\n\n// if there is any message, copy it into $_SESSION as well,\n// so we can obtain it by AJAX call\nif (isset($message)) {\n    $_SESSION['Import_message']['message'] = $message->getDisplay();\n}\n// Parse and analyze the query, for correct db and table name\n// in case of a query typed in the query window\n// (but if the query is too large, in case of an imported file, the parser\n//  can choke on it so avoid parsing)\n$sqlLength = mb_strlen($sql_query);\nif ($sqlLength <= $GLOBALS['cfg']['MaxCharactersInDisplayedSQL']) {\n    include_once 'libraries/parse_analyze.lib.php';\n\n    list(\n        $analyzed_sql_results,\n        $db,\n        $table\n    ) = PMA_parseAnalyze($sql_query, $db);\n    // @todo: possibly refactor\n    extract($analyzed_sql_results);\n}\n\n// There was an error?\nif (isset($my_die)) {\n    foreach ($my_die as $key => $die) {\n        PMA\\libraries\\Util::mysqlDie(\n            $die['error'], $die['sql'], false, $err_url, $error\n        );\n    }\n}\n\nif ($go_sql) {\n\n    if (! empty($sql_data) && ($sql_data['valid_queries'] > 1)) {\n        $_SESSION['is_multi_query'] = true;\n        $sql_queries = $sql_data['valid_sql'];\n    } else {\n        $sql_queries = array($sql_query);\n    }\n\n    $html_output = '';\n    foreach ($sql_queries as $sql_query) {\n\n        // parse sql query\n        include_once 'libraries/parse_analyze.lib.php';\n        list(\n            $analyzed_sql_results,\n            $db,\n            $table\n        ) = PMA_parseAnalyze($sql_query, $db);\n        // @todo: possibly refactor\n        extract($analyzed_sql_results);\n\n        $html_output .= PMA_executeQueryAndGetQueryResponse(\n            $analyzed_sql_results, // analyzed_sql_results\n            false, // is_gotofile\n            $db, // db\n            $table, // table\n            null, // find_real_end\n            $_REQUEST['sql_query'], // sql_query_for_bookmark\n            null, // extra_data\n            null, // message_to_show\n            null, // message\n            null, // sql_data\n            $goto, // goto\n            $pmaThemeImage, // pmaThemeImage\n            null, // disp_query\n            null, // disp_message\n            null, // query_type\n            $sql_query, // sql_query\n            null, // selectedTables\n            null // complete_query\n        );\n    }\n\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->addJSON('ajax_reload', $ajax_reload);\n    $response->addHTML($html_output);\n    exit();\n\n} else if ($result) {\n    // Save a Bookmark with more than one queries (if Bookmark label given).\n    if (! empty($_POST['bkm_label']) && ! empty($import_text)) {\n        $cfgBookmark = PMA_Bookmark_getParams();\n        PMA_storeTheQueryAsBookmark(\n            $db, $cfgBookmark['user'],\n            $_REQUEST['sql_query'], $_POST['bkm_label'],\n            isset($_POST['bkm_replace']) ? $_POST['bkm_replace'] : null\n        );\n    }\n\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->setRequestStatus(true);\n    $response->addJSON('message', PMA\\libraries\\Message::success($msg));\n    $response->addJSON(\n        'sql_query',\n        PMA\\libraries\\Util::getMessage($msg, $sql_query, 'success')\n    );\n} else if ($result == false) {\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->setRequestStatus(false);\n    $response->addJSON('message', PMA\\libraries\\Message::error($msg));\n} else {\n    $active_page = $goto;\n    include '' . $goto;\n}\n\n// If there is request for ROLLBACK in the end.\nif (isset($_REQUEST['rollback_query'])) {\n    $GLOBALS['dbi']->query('ROLLBACK');\n}\n", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Tracking changes on databases, tables and views\n *\n * @package PhpMyAdmin\n */\nnamespace PMA\\libraries;\n\nuse PMA\\libraries\\plugins\\export\\ExportSql;\n\n/**\n * This class tracks changes on databases, tables and views.\n *\n * @package PhpMyAdmin\n *\n * @todo use stristr instead of strstr\n */\nclass Tracker\n{\n    /**\n     * Whether tracking is ready.\n     */\n    static protected $enabled = false;\n\n    /**\n     * Actually enables tracking. This needs to be done after all\n     * underlaying code is initialized.\n     *\n     * @static\n     *\n     * @return void\n     */\n    static public function enable()\n    {\n        self::$enabled = true;\n    }\n\n    /**\n     * Gets the on/off value of the Tracker module, starts initialization.\n     *\n     * @static\n     *\n     * @return boolean (true=on|false=off)\n     */\n    static public function isActive()\n    {\n        if (! self::$enabled) {\n            return false;\n        }\n        /* We need to avoid attempt to track any queries\n         * from PMA_getRelationsParam\n         */\n        self::$enabled = false;\n        $cfgRelation = PMA_getRelationsParam();\n        /* Restore original state */\n        self::$enabled = true;\n        if (! $cfgRelation['trackingwork']) {\n            return false;\n        }\n\n        $pma_table = self::_getTrackingTable();\n        if (isset($pma_table)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Parses the name of a table from a SQL statement substring.\n     *\n     * @param string $string part of SQL statement\n     *\n     * @static\n     *\n     * @return string the name of table\n     */\n    static protected function getTableName($string)\n    {\n        if (mb_strstr($string, '.')) {\n            $temp = explode('.', $string);\n            $tablename = $temp[1];\n        } else {\n            $tablename = $string;\n        }\n\n        $str = explode(\"\\n\", $tablename);\n        $tablename = $str[0];\n\n        $tablename = str_replace(';', '', $tablename);\n        $tablename = str_replace('`', '', $tablename);\n        $tablename = trim($tablename);\n\n        return $tablename;\n    }\n\n\n    /**\n     * Gets the tracking status of a table, is it active or deactive ?\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     *\n     * @static\n     *\n     * @return boolean true or false\n     */\n    static public function isTracked($dbname, $tablename)\n    {\n        if (! self::$enabled) {\n            return false;\n        }\n        /* We need to avoid attempt to track any queries\n         * from PMA_getRelationsParam\n         */\n        self::$enabled = false;\n        $cfgRelation = PMA_getRelationsParam();\n        /* Restore original state */\n        self::$enabled = true;\n        if (! $cfgRelation['trackingwork']) {\n            return false;\n        }\n\n        $sql_query = \" SELECT tracking_active FROM \" . self::_getTrackingTable() .\n        \" WHERE db_name = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND table_name = '\" . Util::sqlAddSlashes($tablename) . \"' \" .\n        \" ORDER BY version DESC\";\n\n        $row = $GLOBALS['dbi']->fetchArray(PMA_queryAsControlUser($sql_query));\n\n        if (isset($row['tracking_active']) && $row['tracking_active'] == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns the comment line for the log.\n     *\n     * @return string Comment, contains date and username\n     */\n    static public function getLogComment()\n    {\n        $date = date('Y-m-d H:i:s');\n\n        return \"# log \" . $date . \" \" . $GLOBALS['cfg']['Server']['user'] . \"\\n\";\n    }\n\n    /**\n     * Creates tracking version of a table / view\n     * (in other words: create a job to track future changes on the table).\n     *\n     * @param string $dbname       name of database\n     * @param string $tablename    name of table\n     * @param string $version      version\n     * @param string $tracking_set set of tracking statements\n     * @param bool   $is_view      if table is a view\n     *\n     * @static\n     *\n     * @return int result of version insertion\n     */\n    static public function createVersion($dbname, $tablename, $version,\n        $tracking_set = '', $is_view = false\n    ) {\n        global $sql_backquotes, $export_type;\n\n        if ($tracking_set == '') {\n            $tracking_set\n                = $GLOBALS['cfg']['Server']['tracking_default_statements'];\n        }\n\n        // get Export SQL instance\n        include_once \"libraries/plugin_interface.lib.php\";\n        /* @var $export_sql_plugin \\PMA\\libraries\\plugins\\export\\ExportSql */\n        $export_sql_plugin = PMA_getPlugin(\n            \"export\",\n            \"sql\",\n            'libraries/plugins/export/',\n            array(\n                'export_type' => $export_type,\n                'single_table' => false,\n            )\n        );\n\n        $sql_backquotes = true;\n\n        $date = date('Y-m-d H:i:s');\n\n        // Get data definition snapshot of table\n\n        $columns = $GLOBALS['dbi']->getColumns($dbname, $tablename, null, true);\n        // int indices to reduce size\n        $columns = array_values($columns);\n        // remove Privileges to reduce size\n        for ($i = 0, $nb = count($columns); $i < $nb; $i++) {\n            unset($columns[$i]['Privileges']);\n        }\n\n        $indexes = $GLOBALS['dbi']->getTableIndexes($dbname, $tablename);\n\n        $snapshot = array('COLUMNS' => $columns, 'INDEXES' => $indexes);\n        $snapshot = serialize($snapshot);\n\n        // Get DROP TABLE / DROP VIEW and CREATE TABLE SQL statements\n        $sql_backquotes = true;\n\n        $create_sql  = \"\";\n\n        if ($GLOBALS['cfg']['Server']['tracking_add_drop_table'] == true\n            && $is_view == false\n        ) {\n            $create_sql .= self::getLogComment()\n                . 'DROP TABLE IF EXISTS ' . Util::backquote($tablename) . \";\\n\";\n\n        }\n\n        if ($GLOBALS['cfg']['Server']['tracking_add_drop_view'] == true\n            && $is_view == true\n        ) {\n            $create_sql .= self::getLogComment()\n                . 'DROP VIEW IF EXISTS ' . Util::backquote($tablename) . \";\\n\";\n        }\n\n        $create_sql .= self::getLogComment() .\n            $export_sql_plugin->getTableDef($dbname, $tablename, \"\\n\", \"\");\n\n        // Save version\n\n        $sql_query = \"/*NOTRACK*/\\n\" .\n        \"INSERT INTO \" . self::_getTrackingTable() . \" (\" .\n        \"db_name, \" .\n        \"table_name, \" .\n        \"version, \" .\n        \"date_created, \" .\n        \"date_updated, \" .\n        \"schema_snapshot, \" .\n        \"schema_sql, \" .\n        \"data_sql, \" .\n        \"tracking \" .\n        \") \" .\n        \"values (\n        '\" . Util::sqlAddSlashes($dbname) . \"',\n        '\" . Util::sqlAddSlashes($tablename) . \"',\n        '\" . Util::sqlAddSlashes($version) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes($snapshot) . \"',\n        '\" . Util::sqlAddSlashes($create_sql) . \"',\n        '\" . Util::sqlAddSlashes(\"\\n\") . \"',\n        '\" . Util::sqlAddSlashes($tracking_set)\n        . \"' )\";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        if ($result) {\n            // Deactivate previous version\n            self::deactivateTracking($dbname, $tablename, ($version - 1));\n        }\n\n        return $result;\n    }\n\n\n    /**\n     * Removes all tracking data for a table or a version of a table\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version\n     *\n     * @static\n     *\n     * @return int result of version insertion\n     */\n    static public function deleteTracking($dbname, $tablename, $version = '')\n    {\n        $sql_query = \"/*NOTRACK*/\\n\"\n            . \"DELETE FROM \" . self::_getTrackingTable()\n            . \" WHERE `db_name` = '\"\n            . Util::sqlAddSlashes($dbname) . \"'\"\n            . \" AND `table_name` = '\"\n            . Util::sqlAddSlashes($tablename) . \"'\";\n        if ($version) {\n            $sql_query .= \" AND `version` = '\"\n                . Util::sqlAddSlashes($version) . \"'\";\n        }\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return $result;\n    }\n\n    /**\n     * Creates tracking version of a database\n     * (in other words: create a job to track future changes on the database).\n     *\n     * @param string $dbname       name of database\n     * @param string $version      version\n     * @param string $query        query\n     * @param string $tracking_set set of tracking statements\n     *\n     * @static\n     *\n     * @return int result of version insertion\n     */\n    static public function createDatabaseVersion($dbname, $version, $query,\n        $tracking_set = 'CREATE DATABASE,ALTER DATABASE,DROP DATABASE'\n    ) {\n        $date = date('Y-m-d H:i:s');\n\n        if ($tracking_set == '') {\n            $tracking_set\n                = $GLOBALS['cfg']['Server']['tracking_default_statements'];\n        }\n\n        $create_sql  = \"\";\n\n        if ($GLOBALS['cfg']['Server']['tracking_add_drop_database'] == true) {\n            $create_sql .= self::getLogComment()\n                . 'DROP DATABASE IF EXISTS ' . Util::backquote($dbname) . \";\\n\";\n        }\n\n        $create_sql .= self::getLogComment() . $query;\n\n        // Save version\n        $sql_query = \"/*NOTRACK*/\\n\" .\n        \"INSERT INTO \" . self::_getTrackingTable() . \" (\" .\n        \"db_name, \" .\n        \"table_name, \" .\n        \"version, \" .\n        \"date_created, \" .\n        \"date_updated, \" .\n        \"schema_snapshot, \" .\n        \"schema_sql, \" .\n        \"data_sql, \" .\n        \"tracking \" .\n        \") \" .\n        \"values (\n        '\" . Util::sqlAddSlashes($dbname) . \"',\n        '\" . Util::sqlAddSlashes('') . \"',\n        '\" . Util::sqlAddSlashes($version) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes('') . \"',\n        '\" . Util::sqlAddSlashes($create_sql) . \"',\n        '\" . Util::sqlAddSlashes(\"\\n\") . \"',\n        '\" . Util::sqlAddSlashes($tracking_set)\n        . \"' )\";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return $result;\n    }\n\n\n\n    /**\n     * Changes tracking of a table.\n     *\n     * @param string  $dbname    name of database\n     * @param string  $tablename name of table\n     * @param string  $version   version\n     * @param integer $new_state the new state of tracking\n     *\n     * @static\n     *\n     * @return int result of SQL query\n     */\n    static private function _changeTracking($dbname, $tablename,\n        $version, $new_state\n    ) {\n\n        $sql_query = \" UPDATE \" . self::_getTrackingTable() .\n        \" SET `tracking_active` = '\" . $new_state . \"' \" .\n        \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND `table_name` = '\" . Util::sqlAddSlashes($tablename) . \"' \" .\n        \" AND `version` = '\" . Util::sqlAddSlashes($version) . \"' \";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return $result;\n    }\n\n    /**\n     * Changes tracking data of a table.\n     *\n     * @param string       $dbname    name of database\n     * @param string       $tablename name of table\n     * @param string       $version   version\n     * @param string       $type      type of data(DDL || DML)\n     * @param string|array $new_data  the new tracking data\n     *\n     * @static\n     *\n     * @return bool result of change\n     */\n    static public function changeTrackingData($dbname, $tablename,\n        $version, $type, $new_data\n    ) {\n        if ($type == 'DDL') {\n            $save_to = 'schema_sql';\n        } elseif ($type == 'DML') {\n            $save_to = 'data_sql';\n        } else {\n            return false;\n        }\n        $date  = date('Y-m-d H:i:s');\n\n        $new_data_processed = '';\n        if (is_array($new_data)) {\n            foreach ($new_data as $data) {\n                $new_data_processed .= '# log ' . $date . ' ' . $data['username']\n                    . Util::sqlAddSlashes($data['statement']) . \"\\n\";\n            }\n        } else {\n            $new_data_processed = $new_data;\n        }\n\n        $sql_query = \" UPDATE \" . self::_getTrackingTable() .\n        \" SET `\" . $save_to . \"` = '\" . $new_data_processed . \"' \" .\n        \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND `table_name` = '\" . Util::sqlAddSlashes($tablename) . \"' \" .\n        \" AND `version` = '\" . Util::sqlAddSlashes($version) . \"' \";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return (boolean) $result;\n    }\n\n    /**\n     * Activates tracking of a table.\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version\n     *\n     * @static\n     *\n     * @return int result of SQL query\n     */\n    static public function activateTracking($dbname, $tablename, $version)\n    {\n        return self::_changeTracking($dbname, $tablename, $version, 1);\n    }\n\n\n    /**\n     * Deactivates tracking of a table.\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version\n     *\n     * @static\n     *\n     * @return int result of SQL query\n     */\n    static public function deactivateTracking($dbname, $tablename, $version)\n    {\n        return self::_changeTracking($dbname, $tablename, $version, 0);\n    }\n\n\n    /**\n     * Gets the newest version of a tracking job\n     * (in other words: gets the HEAD version).\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $statement tracked statement\n     *\n     * @static\n     *\n     * @return int (-1 if no version exists | >  0 if a version exists)\n     */\n    static public function getVersion($dbname, $tablename, $statement = null)\n    {\n        $sql_query = \" SELECT MAX(version) FROM \" . self::_getTrackingTable() .\n        \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND `table_name` = '\" . Util::sqlAddSlashes($tablename) . \"' \";\n\n        if ($statement != \"\") {\n            $sql_query .= \" AND FIND_IN_SET('\"\n                . $statement . \"',tracking) > 0\" ;\n        }\n        $row = $GLOBALS['dbi']->fetchArray(PMA_queryAsControlUser($sql_query));\n        return isset($row[0])\n            ? $row[0]\n            : -1;\n    }\n\n\n    /**\n     * Gets the record of a tracking job.\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version number\n     *\n     * @static\n     *\n     * @return mixed record DDM log, DDL log, structure snapshot, tracked\n     *         statements.\n     */\n    static public function getTrackedData($dbname, $tablename, $version)\n    {\n        $sql_query = \" SELECT * FROM \" . self::_getTrackingTable() .\n            \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \";\n        if (! empty($tablename)) {\n            $sql_query .= \" AND `table_name` = '\"\n                . Util::sqlAddSlashes($tablename) . \"' \";\n        }\n        $sql_query .= \" AND `version` = '\" . Util::sqlAddSlashes($version)\n            . \"' \" . \" ORDER BY `version` DESC LIMIT 1\";\n\n        $mixed = $GLOBALS['dbi']->fetchAssoc(PMA_queryAsControlUser($sql_query));\n\n        // Parse log\n        $log_schema_entries = explode('# log ',  $mixed['schema_sql']);\n        $log_data_entries   = explode('# log ',  $mixed['data_sql']);\n\n        $ddl_date_from = $date = date('Y-m-d H:i:s');\n\n        $ddlog = array();\n        $first_iteration = true;\n\n        // Iterate tracked data definition statements\n        // For each log entry we want to get date, username and statement\n        foreach ($log_schema_entries as $log_entry) {\n            if (trim($log_entry) != '') {\n                $date      = mb_substr($log_entry, 0, 19);\n                $username  = mb_substr(\n                    $log_entry, 20, mb_strpos($log_entry, \"\\n\") - 20\n                );\n                if ($first_iteration) {\n                    $ddl_date_from = $date;\n                    $first_iteration = false;\n                }\n                $statement = rtrim(mb_strstr($log_entry, \"\\n\"));\n\n                $ddlog[] = array( 'date' => $date,\n                                  'username'=> $username,\n                                  'statement' => $statement );\n            }\n        }\n\n        $date_from = $ddl_date_from;\n        $ddl_date_to = $date;\n\n        $dml_date_from = $date_from;\n\n        $dmlog = array();\n        $first_iteration = true;\n\n        // Iterate tracked data manipulation statements\n        // For each log entry we want to get date, username and statement\n        foreach ($log_data_entries as $log_entry) {\n            if (trim($log_entry) != '') {\n                $date      = mb_substr($log_entry, 0, 19);\n                $username  = mb_substr(\n                    $log_entry, 20, mb_strpos($log_entry, \"\\n\") - 20\n                );\n                if ($first_iteration) {\n                    $dml_date_from = $date;\n                    $first_iteration = false;\n                }\n                $statement = rtrim(mb_strstr($log_entry, \"\\n\"));\n\n                $dmlog[] = array( 'date' => $date,\n                                  'username' => $username,\n                                  'statement' => $statement );\n            }\n        }\n\n        $dml_date_to = $date;\n\n        // Define begin and end of date range for both logs\n        $data = array();\n        if (strtotime($ddl_date_from) <= strtotime($dml_date_from)) {\n            $data['date_from'] = $ddl_date_from;\n        } else {\n            $data['date_from'] = $dml_date_from;\n        }\n        if (strtotime($ddl_date_to) >= strtotime($dml_date_to)) {\n            $data['date_to'] = $ddl_date_to;\n        } else {\n            $data['date_to'] = $dml_date_to;\n        }\n        $data['ddlog']           = $ddlog;\n        $data['dmlog']           = $dmlog;\n        $data['tracking']        = $mixed['tracking'];\n        $data['schema_snapshot'] = $mixed['schema_snapshot'];\n\n        return $data;\n    }\n\n\n    /**\n     * Parses a query. Gets\n     *  - statement identifier (UPDATE, ALTER TABLE, ...)\n     *  - type of statement, is it part of DDL or DML ?\n     *  - tablename\n     *\n     * @param string $query query\n     *\n     * @static\n     * @todo: using PMA SQL Parser when possible\n     * @todo: support multi-table/view drops\n     *\n     * @return mixed Array containing identifier, type and tablename.\n     *\n     */\n    static public function parseQuery($query)\n    {\n        // Usage of PMA_SQP does not work here\n        //\n        // require_once(\"libraries/sqlparser.lib.php\");\n        // $parsed_sql = PMA_SQP_parse($query);\n        // $sql_info = PMA_SQP_analyze($parsed_sql);\n\n        $query = str_replace(\"\\n\", \" \", $query);\n        $query = str_replace(\"\\r\", \" \", $query);\n\n        $query = trim($query);\n        $query = trim($query, ' -');\n\n        $tokens = explode(\" \", $query);\n        foreach ($tokens as $key => $value) {\n            $tokens[$key] = mb_strtoupper($value);\n        }\n\n        // Parse USE statement, need it for SQL dump imports\n        if (mb_substr($query, 0, 4) == 'USE ') {\n            $prefix = explode('USE ', $query);\n            $GLOBALS['db'] = self::getTableName($prefix[1]);\n        }\n\n        /*\n         * DDL statements\n         */\n\n        $result         = array();\n        $result['type'] = 'DDL';\n\n        // Parse CREATE VIEW statement\n        if (in_array('CREATE', $tokens) == true\n            && in_array('VIEW', $tokens) == true\n            && in_array('AS', $tokens) == true\n        ) {\n            $result['identifier'] = 'CREATE VIEW';\n\n            $index = array_search('VIEW', $tokens);\n\n            $result['tablename'] = mb_strtolower(\n                self::getTableName($tokens[$index + 1])\n            );\n        }\n\n        // Parse ALTER VIEW statement\n        if (in_array('ALTER', $tokens) == true\n            && in_array('VIEW', $tokens) == true\n            && in_array('AS', $tokens) == true\n            && ! isset($result['identifier'])\n        ) {\n            $result['identifier'] = 'ALTER VIEW';\n\n            $index = array_search('VIEW', $tokens);\n\n            $result['tablename'] = mb_strtolower(\n                self::getTableName($tokens[$index + 1])\n            );\n        }\n\n        // Parse DROP VIEW statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 10) == 'DROP VIEW '\n        ) {\n            $result['identifier'] = 'DROP VIEW';\n\n            $prefix  = explode('DROP VIEW ', $query);\n            $str = str_replace('IF EXISTS', '', $prefix[1]);\n            $result['tablename'] = self::getTableName($str);\n        }\n\n        // Parse CREATE DATABASE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 15) == 'CREATE DATABASE'\n        ) {\n            $result['identifier'] = 'CREATE DATABASE';\n            $str = str_replace('CREATE DATABASE', '', $query);\n            $str = str_replace('IF NOT EXISTS', '', $str);\n\n            $prefix = explode('DEFAULT ', $str);\n\n            $result['tablename'] = '';\n            $GLOBALS['db'] = self::getTableName($prefix[0]);\n        }\n\n        // Parse ALTER DATABASE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 14) == 'ALTER DATABASE'\n        ) {\n            $result['identifier'] = 'ALTER DATABASE';\n            $result['tablename'] = '';\n        }\n\n        // Parse DROP DATABASE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 13) == 'DROP DATABASE'\n        ) {\n            $result['identifier'] = 'DROP DATABASE';\n            $str = str_replace('DROP DATABASE', '', $query);\n            $str = str_replace('IF EXISTS', '', $str);\n            $GLOBALS['db'] = self::getTableName($str);\n            $result['tablename'] = '';\n        }\n\n        // Parse CREATE TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 12) == 'CREATE TABLE'\n        ) {\n            $result['identifier'] = 'CREATE TABLE';\n            $query   = str_replace('IF NOT EXISTS', '', $query);\n            $prefix  = explode('CREATE TABLE ', $query);\n            $suffix  = explode('(', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse ALTER TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 12) == 'ALTER TABLE '\n        ) {\n            $result['identifier'] = 'ALTER TABLE';\n\n            $prefix  = explode('ALTER TABLE ', $query);\n            $suffix  = explode(' ', $prefix[1]);\n            $result['tablename']  = self::getTableName($suffix[0]);\n        }\n\n        // Parse DROP TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 11) == 'DROP TABLE '\n        ) {\n            $result['identifier'] = 'DROP TABLE';\n\n            $prefix  = explode('DROP TABLE ', $query);\n            $str = str_replace('IF EXISTS', '', $prefix[1]);\n            $result['tablename'] = self::getTableName($str);\n        }\n\n        // Parse CREATE INDEX statement\n        if (! isset($result['identifier'])\n            && (substr($query, 0, 12) == 'CREATE INDEX'\n            || substr($query, 0, 19) == 'CREATE UNIQUE INDEX'\n            || substr($query, 0, 20) == 'CREATE SPATIAL INDEX')\n        ) {\n             $result['identifier'] = 'CREATE INDEX';\n             $prefix = explode('ON ', $query);\n             $suffix = explode('(', $prefix[1]);\n             $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse DROP INDEX statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 10) == 'DROP INDEX'\n        ) {\n             $result['identifier'] = 'DROP INDEX';\n             $prefix = explode('ON ', $query);\n             $result['tablename'] = self::getTableName($prefix[1]);\n        }\n\n        // Parse RENAME TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 13) == 'RENAME TABLE '\n        ) {\n            $result['identifier'] = 'RENAME TABLE';\n            $prefix = explode('RENAME TABLE ', $query);\n            $names  = explode(' TO ', $prefix[1]);\n            $result['tablename']      = self::getTableName($names[0]);\n            $result[\"tablename_after_rename\"]  = self::getTableName($names[1]);\n        }\n\n        /*\n         * DML statements\n         */\n\n        if (! isset($result['identifier'])) {\n            $result[\"type\"]       = 'DML';\n        }\n        // Parse UPDATE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 6) == 'UPDATE'\n        ) {\n            $result['identifier'] = 'UPDATE';\n            $prefix  = explode('UPDATE ', $query);\n            $suffix  = explode(' ', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse INSERT INTO statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 11) == 'INSERT INTO'\n        ) {\n            $result['identifier'] = 'INSERT';\n            $prefix  = explode('INSERT INTO', $query);\n            $suffix  = explode('(', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse DELETE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 6) == 'DELETE'\n        ) {\n            $result['identifier'] = 'DELETE';\n            $prefix  = explode('FROM ', $query);\n            $suffix  = explode(' ', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse TRUNCATE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 8) == 'TRUNCATE'\n        ) {\n            $result['identifier'] = 'TRUNCATE';\n            $prefix  = explode('TRUNCATE', $query);\n            $result['tablename'] = self::getTableName($prefix[1]);\n        }\n\n        return $result;\n    }\n\n\n    /**\n     * Analyzes a given SQL statement and saves tracking data.\n     *\n     * @param string $query a SQL query\n     *\n     * @static\n     *\n     * @return void\n     */\n    static public function handleQuery($query)\n    {\n        // If query is marked as untouchable, leave\n        if (mb_strstr($query, \"/*NOTRACK*/\")) {\n            return;\n        }\n\n        if (! (substr($query, -1) == ';')) {\n            $query = $query . \";\\n\";\n        }\n        // Get some information about query\n        $result = self::parseQuery($query);\n\n        // Get database name\n        $dbname = trim(isset($GLOBALS['db']) ? $GLOBALS['db'] : '', '`');\n        // $dbname can be empty, for example when coming from Synchronize\n        // and this is a query for the remote server\n        if (empty($dbname)) {\n            return;\n        }\n\n        // If we found a valid statement\n        if (isset($result['identifier'])) {\n            $version = self::getVersion(\n                $dbname, $result['tablename'], $result['identifier']\n            );\n\n            // If version not exists and auto-creation is enabled\n            if ($GLOBALS['cfg']['Server']['tracking_version_auto_create'] == true\n                && self::isTracked($dbname, $result['tablename']) == false\n                && $version == -1\n            ) {\n                // Create the version\n\n                switch ($result['identifier']) {\n                case 'CREATE TABLE':\n                    self::createVersion($dbname, $result['tablename'], '1');\n                    break;\n                case 'CREATE VIEW':\n                    self::createVersion(\n                        $dbname, $result['tablename'], '1', '', true\n                    );\n                    break;\n                case 'CREATE DATABASE':\n                    self::createDatabaseVersion($dbname, '1', $query);\n                    break;\n                } // end switch\n            }\n\n            // If version exists\n            if (self::isTracked($dbname, $result['tablename']) && $version != -1) {\n                if ($result['type'] == 'DDL') {\n                    $save_to = 'schema_sql';\n                } elseif ($result['type'] == 'DML') {\n                    $save_to = 'data_sql';\n                } else {\n                    $save_to = '';\n                }\n                $date  = date('Y-m-d H:i:s');\n\n                // Cut off `dbname`. from query\n                $query = preg_replace(\n                    '/`' . preg_quote($dbname) . '`\\s?\\./',\n                    '',\n                    $query\n                );\n\n                // Add log information\n                $query = self::getLogComment() . $query ;\n\n                // Mark it as untouchable\n                $sql_query = \" /*NOTRACK*/\\n\"\n                    . \" UPDATE \" . self::_getTrackingTable()\n                    . \" SET \" . Util::backquote($save_to)\n                    . \" = CONCAT( \" . Util::backquote($save_to) . \",'\\n\"\n                    . Util::sqlAddSlashes($query) . \"') ,\"\n                    . \" `date_updated` = '\" . $date . \"' \";\n\n                // If table was renamed we have to change\n                // the tablename attribute in pma_tracking too\n                if ($result['identifier'] == 'RENAME TABLE') {\n                    $sql_query .= ', `table_name` = \\''\n                        . Util::sqlAddSlashes($result['tablename_after_rename'])\n                        . '\\' ';\n                }\n\n                // Save the tracking information only for\n                //     1. the database\n                //     2. the table / view\n                //     3. the statements\n                // we want to track\n                $sql_query .=\n                \" WHERE FIND_IN_SET('\" . $result['identifier'] . \"',tracking) > 0\" .\n                \" AND `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n                \" AND `table_name` = '\"\n                . Util::sqlAddSlashes($result['tablename']) . \"' \" .\n                \" AND `version` = '\" . Util::sqlAddSlashes($version) . \"' \";\n\n                PMA_queryAsControlUser($sql_query);\n            }\n        }\n    }\n\n    /**\n     * Returns the tracking table\n     *\n     * @return string tracking table\n     */\n    private static function _getTrackingTable()\n    {\n        $cfgRelation = PMA_getRelationsParam();\n        return Util::backquote($cfgRelation['db'])\n            . '.' . Util::backquote($cfgRelation['tracking']);\n    }\n}\n", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Set of functions used to build SQL dumps of tables\n *\n * @package    PhpMyAdmin-Export\n * @subpackage SQL\n */\nnamespace PMA\\libraries\\plugins\\export;\n\nuse PMA\\libraries\\properties\\options\\items\\BoolPropertyItem;\nuse PMA\\libraries\\properties\\plugins\\ExportPluginProperties;\nuse PMA\\libraries\\properties\\options\\items\\MessageOnlyPropertyItem;\nuse PMA\\libraries\\properties\\options\\items\\NumberPropertyItem;\nuse PMA\\libraries\\properties\\options\\groups\\OptionsPropertyMainGroup;\nuse PMA\\libraries\\properties\\options\\groups\\OptionsPropertyRootGroup;\nuse PMA\\libraries\\properties\\options\\groups\\OptionsPropertySubgroup;\nuse PMA\\libraries\\DatabaseInterface;\nuse PMA\\libraries\\plugins\\ExportPlugin;\nuse PMA\\libraries\\Util;\nuse PMA\\libraries\\properties\\options\\items\\RadioPropertyItem;\nuse PMA\\libraries\\properties\\options\\items\\SelectPropertyItem;\nuse SqlParser\\Components\\CreateDefinition;\nuse SqlParser\\Context;\nuse SqlParser\\Parser;\nuse SqlParser\\Statements\\SelectStatement;\nuse SqlParser\\Token;\nuse PMA\\libraries\\properties\\options\\items\\TextPropertyItem;\n\n/**\n * Handles the export for the SQL class\n *\n * @package    PhpMyAdmin-Export\n * @subpackage SQL\n */\nclass ExportSql extends ExportPlugin\n{\n    /**\n     * Whether charset header was sent.\n     *\n     * @var boolean\n     */\n    private $_sent_charset = false;\n\n    /**\n     * Constructor\n     */\n    public function __construct()\n    {\n        $this->setProperties();\n\n        // Avoids undefined variables, use NULL so isset() returns false\n        if (!isset($GLOBALS['sql_backquotes'])) {\n            $GLOBALS['sql_backquotes'] = null;\n        }\n    }\n\n    /**\n     * Sets the export SQL properties\n     *\n     * @return void\n     */\n    protected function setProperties()\n    {\n        global $plugin_param;\n\n        $hide_sql = false;\n        $hide_structure = false;\n        if ($plugin_param['export_type'] == 'table'\n            && !$plugin_param['single_table']\n        ) {\n            $hide_structure = true;\n            $hide_sql = true;\n        }\n\n        if (!$hide_sql) {\n            $exportPluginProperties = new ExportPluginProperties();\n            $exportPluginProperties->setText('SQL');\n            $exportPluginProperties->setExtension('sql');\n            $exportPluginProperties->setMimeType('text/x-sql');\n            $exportPluginProperties->setOptionsText(__('Options'));\n\n            // create the root group that will be the options field for\n            // $exportPluginProperties\n            // this will be shown as \"Format specific options\"\n            $exportSpecificOptions = new OptionsPropertyRootGroup(\n                \"Format Specific Options\"\n            );\n\n            // general options main group\n            $generalOptions = new OptionsPropertyMainGroup(\"general_opts\");\n\n            // comments\n            $subgroup = new OptionsPropertySubgroup(\"include_comments\");\n            $leaf = new BoolPropertyItem(\n                'include_comments',\n                __(\n                    'Display comments <i>(includes info such as export'\n                    . ' timestamp, PHP version, and server version)</i>'\n                )\n            );\n            $subgroup->setSubgroupHeader($leaf);\n\n            $leaf = new TextPropertyItem(\n                'header_comment',\n                __('Additional custom header comment (\\n splits lines):')\n            );\n            $subgroup->addProperty($leaf);\n            $leaf = new BoolPropertyItem(\n                'dates',\n                __(\n                    'Include a timestamp of when databases were created, last'\n                    . ' updated, and last checked'\n                )\n            );\n            $subgroup->addProperty($leaf);\n            if (!empty($GLOBALS['cfgRelation']['relation'])) {\n                $leaf = new BoolPropertyItem(\n                    'relation',\n                    __('Display foreign key relationships')\n                );\n                $subgroup->addProperty($leaf);\n            }\n            if (!empty($GLOBALS['cfgRelation']['mimework'])) {\n                $leaf = new BoolPropertyItem(\n                    'mime',\n                    __('Display MIME types')\n                );\n                $subgroup->addProperty($leaf);\n            }\n            $generalOptions->addProperty($subgroup);\n\n            // enclose in a transaction\n            $leaf = new BoolPropertyItem(\n                \"use_transaction\",\n                __('Enclose export in a transaction')\n            );\n            $leaf->setDoc(\n                array(\n                    'programs',\n                    'mysqldump',\n                    'option_mysqldump_single-transaction',\n                )\n            );\n            $generalOptions->addProperty($leaf);\n\n            // disable foreign key checks\n            $leaf = new BoolPropertyItem(\n                \"disable_fk\",\n                __('Disable foreign key checks')\n            );\n            $leaf->setDoc(\n                array(\n                    'manual_MySQL_Database_Administration',\n                    'server-system-variables',\n                    'sysvar_foreign_key_checks',\n                )\n            );\n            $generalOptions->addProperty($leaf);\n\n            // export views as tables\n            $leaf = new BoolPropertyItem(\n                \"views_as_tables\",\n                __('Export views as tables')\n            );\n            $generalOptions->addProperty($leaf);\n\n            // export metadata\n            $leaf = new BoolPropertyItem(\n                \"metadata\",\n                __('Export metadata')\n            );\n            $generalOptions->addProperty($leaf);\n\n            // compatibility maximization\n            $compats = $GLOBALS['dbi']->getCompatibilities();\n            if (count($compats) > 0) {\n                $values = array();\n                foreach ($compats as $val) {\n                    $values[$val] = $val;\n                }\n\n                $leaf = new SelectPropertyItem(\n                    \"compatibility\",\n                    __(\n                        'Database system or older MySQL server to maximize output'\n                        . ' compatibility with:'\n                    )\n                );\n                $leaf->setValues($values);\n                $leaf->setDoc(\n                    array(\n                        'manual_MySQL_Database_Administration',\n                        'Server_SQL_mode',\n                    )\n                );\n                $generalOptions->addProperty($leaf);\n\n                unset($values);\n            }\n\n            // what to dump (structure/data/both)\n            $subgroup = new OptionsPropertySubgroup(\n                \"dump_table\", __(\"Dump table\")\n            );\n            $leaf = new RadioPropertyItem('structure_or_data');\n            $leaf->setValues(\n                array(\n                    'structure'          => __('structure'),\n                    'data'               => __('data'),\n                    'structure_and_data' => __('structure and data'),\n                )\n            );\n            $subgroup->setSubgroupHeader($leaf);\n            $generalOptions->addProperty($subgroup);\n\n            // add the main group to the root group\n            $exportSpecificOptions->addProperty($generalOptions);\n\n            // structure options main group\n            if (!$hide_structure) {\n                $structureOptions = new OptionsPropertyMainGroup(\n                    \"structure\", __('Object creation options')\n                );\n                $structureOptions->setForce('data');\n\n                // begin SQL Statements\n                $subgroup = new OptionsPropertySubgroup();\n                $leaf = new MessageOnlyPropertyItem(\n                    'add_statements',\n                    __('Add statements:')\n                );\n                $subgroup->setSubgroupHeader($leaf);\n\n                // server export options\n                if ($plugin_param['export_type'] == 'server') {\n                    $leaf = new BoolPropertyItem(\n                        \"drop_database\",\n                        sprintf(__('Add %s statement'), '<code>DROP DATABASE</code>')\n                    );\n                    $subgroup->addProperty($leaf);\n                }\n\n                if ($plugin_param['export_type'] == 'database') {\n                    $create_clause = '<code>CREATE DATABASE / USE</code>';\n                    $leaf = new BoolPropertyItem(\n                        'create_database',\n                        sprintf(__('Add %s statement'), $create_clause)\n                    );\n                    $subgroup->addProperty($leaf);\n                }\n\n                if ($plugin_param['export_type'] == 'table') {\n                    $drop_clause = $GLOBALS['dbi']->getTable(\n                        $GLOBALS['db'],\n                        $GLOBALS['table']\n                    )->isView()\n                        ? '<code>DROP VIEW</code>'\n                        : '<code>DROP TABLE</code>';\n                } else {\n                    $drop_clause = '<code>DROP TABLE / VIEW / PROCEDURE'\n                        . ' / FUNCTION / EVENT</code>';\n                }\n\n                $drop_clause .= '<code> / TRIGGER</code>';\n\n                $leaf = new BoolPropertyItem(\n                    'drop_table',\n                    sprintf(__('Add %s statement'), $drop_clause)\n                );\n                $subgroup->addProperty($leaf);\n\n                $subgroup_create_table = new OptionsPropertySubgroup();\n\n                // Add table structure option\n                $leaf = new BoolPropertyItem(\n                    'create_table',\n                    sprintf(__('Add %s statement'), '<code>CREATE TABLE</code>')\n                );\n                $subgroup_create_table->setSubgroupHeader($leaf);\n\n                $leaf = new BoolPropertyItem(\n                    'if_not_exists',\n                    '<code>IF NOT EXISTS</code> ' . __(\n                        '(less efficient as indexes will be generated during table '\n                        . 'creation)'\n                    )\n                );\n                $subgroup_create_table->addProperty($leaf);\n\n                $leaf = new BoolPropertyItem(\n                    'auto_increment',\n                    sprintf(__('%s value'), '<code>AUTO_INCREMENT</code>')\n                );\n                $subgroup_create_table->addProperty($leaf);\n\n                $subgroup->addProperty($subgroup_create_table);\n\n                // Add view option\n                $leaf = new BoolPropertyItem(\n                    'create_view',\n                    sprintf(__('Add %s statement'), '<code>CREATE VIEW</code>')\n                );\n                $subgroup->addProperty($leaf);\n\n                $leaf = new BoolPropertyItem(\n                    'procedure_function',\n                    sprintf(\n                        __('Add %s statement'),\n                        '<code>CREATE PROCEDURE / FUNCTION / EVENT</code>'\n                    )\n                );\n                $subgroup->addProperty($leaf);\n\n                // Add triggers option\n                $leaf = new BoolPropertyItem(\n                    'create_trigger',\n                    sprintf(__('Add %s statement'), '<code>CREATE TRIGGER</code>')\n                );\n                $subgroup->addProperty($leaf);\n\n                $structureOptions->addProperty($subgroup);\n\n                $leaf = new BoolPropertyItem(\n                    \"backquotes\",\n                    __(\n                        'Enclose table and column names with backquotes '\n                        . '<i>(Protects column and table names formed with'\n                        . ' special characters or keywords)</i>'\n                    )\n                );\n\n                $structureOptions->addProperty($leaf);\n\n                // add the main group to the root group\n                $exportSpecificOptions->addProperty($structureOptions);\n            }\n\n            // begin Data options\n            $dataOptions = new OptionsPropertyMainGroup(\n                \"data\", __('Data creation options')\n            );\n            $dataOptions->setForce('structure');\n            $leaf = new BoolPropertyItem(\n                \"truncate\",\n                __('Truncate table before insert')\n            );\n            $dataOptions->addProperty($leaf);\n\n            // begin SQL Statements\n            $subgroup = new OptionsPropertySubgroup();\n            $leaf = new MessageOnlyPropertyItem(\n                __('Instead of <code>INSERT</code> statements, use:')\n            );\n            $subgroup->setSubgroupHeader($leaf);\n\n            $leaf = new BoolPropertyItem(\n                \"delayed\",\n                __('<code>INSERT DELAYED</code> statements')\n            );\n            $leaf->setDoc(\n                array(\n                    'manual_MySQL_Database_Administration',\n                    'insert_delayed'\n                )\n            );\n            $subgroup->addProperty($leaf);\n\n            $leaf = new BoolPropertyItem(\n                \"ignore\",\n                __('<code>INSERT IGNORE</code> statements')\n            );\n            $leaf->setDoc(\n                array(\n                    'manual_MySQL_Database_Administration',\n                    'insert',\n                )\n            );\n            $subgroup->addProperty($leaf);\n            $dataOptions->addProperty($subgroup);\n\n            // Function to use when dumping dat\n            $leaf = new SelectPropertyItem(\n                \"type\",\n                __('Function to use when dumping data:')\n            );\n            $leaf->setValues(\n                array(\n                    'INSERT'  => 'INSERT',\n                    'UPDATE'  => 'UPDATE',\n                    'REPLACE' => 'REPLACE',\n                )\n            );\n            $dataOptions->addProperty($leaf);\n\n            /* Syntax to use when inserting data */\n            $subgroup = new OptionsPropertySubgroup();\n            $leaf = new MessageOnlyPropertyItem(\n                null,\n                __('Syntax to use when inserting data:')\n            );\n            $subgroup->setSubgroupHeader($leaf);\n            $leaf = new RadioPropertyItem(\n                \"insert_syntax\",\n                __('<code>INSERT IGNORE</code> statements')\n            );\n            $leaf->setValues(\n                array(\n                    'complete' => __(\n                        'include column names in every <code>INSERT</code> statement'\n                        . ' <br /> &nbsp; &nbsp; &nbsp; Example: <code>INSERT INTO'\n                        . ' tbl_name (col_A,col_B,col_C) VALUES (1,2,3)</code>'\n                    ),\n                    'extended' => __(\n                        'insert multiple rows in every <code>INSERT</code> statement'\n                        . '<br /> &nbsp; &nbsp; &nbsp; Example: <code>INSERT INTO'\n                        . ' tbl_name VALUES (1,2,3), (4,5,6), (7,8,9)</code>'\n                    ),\n                    'both'     => __(\n                        'both of the above<br /> &nbsp; &nbsp; &nbsp; Example:'\n                        . ' <code>INSERT INTO tbl_name (col_A,col_B,col_C) VALUES'\n                        . ' (1,2,3), (4,5,6), (7,8,9)</code>'\n                    ),\n                    'none'     => __(\n                        'neither of the above<br /> &nbsp; &nbsp; &nbsp; Example:'\n                        . ' <code>INSERT INTO tbl_name VALUES (1,2,3)</code>'\n                    ),\n                )\n            );\n            $subgroup->addProperty($leaf);\n            $dataOptions->addProperty($subgroup);\n\n            // Max length of query\n            $leaf = new NumberPropertyItem(\n                \"max_query_size\",\n                __('Maximal length of created query')\n            );\n            $dataOptions->addProperty($leaf);\n\n            // Dump binary columns in hexadecimal\n            $leaf = new BoolPropertyItem(\n                \"hex_for_binary\",\n                __(\n                    'Dump binary columns in hexadecimal notation'\n                    . ' <i>(for example, \"abc\" becomes 0x616263)</i>'\n                )\n            );\n            $dataOptions->addProperty($leaf);\n\n            // Dump time in UTC\n            $leaf = new BoolPropertyItem(\n                \"utc_time\",\n                __(\n                    'Dump TIMESTAMP columns in UTC <i>(enables TIMESTAMP columns'\n                    . ' to be dumped and reloaded between servers in different'\n                    . ' time zones)</i>'\n                )\n            );\n            $dataOptions->addProperty($leaf);\n\n            // add the main group to the root group\n            $exportSpecificOptions->addProperty($dataOptions);\n\n            // set the options for the export plugin property item\n            $exportPluginProperties->setOptions($exportSpecificOptions);\n            $this->properties = $exportPluginProperties;\n        }\n    }\n\n    /**\n     * Generates SQL for routines export\n     *\n     * @param string $db        Database\n     * @param array  $aliases   Aliases of db/table/columns\n     * @param string $type      Type of exported routine\n     * @param string $name      Verbose name of exported routine\n     * @param array  $routines  List of routines to export\n     * @param string $delimiter Delimiter to use in SQL\n     *\n     * @return string SQL query\n     */\n    protected function _exportRoutineSQL(\n        $db, $aliases, $type, $name, $routines, $delimiter\n    ) {\n        global $crlf;\n\n        $text = $this->_exportComment()\n            . $this->_exportComment($name)\n            . $this->_exportComment();\n\n        $used_alias = false;\n        $proc_query = '';\n\n        foreach ($routines as $routine) {\n            if (!empty($GLOBALS['sql_drop_table'])) {\n                $proc_query .= 'DROP ' . $type . ' IF EXISTS '\n                    . Util::backquote($routine)\n                    . $delimiter . $crlf;\n            }\n            $create_query = $this->replaceWithAliases(\n                $GLOBALS['dbi']->getDefinition($db, $type, $routine),\n                $aliases,\n                $db,\n                '',\n                $flag\n            );\n            // One warning per database\n            if ($flag) {\n                $used_alias = true;\n            }\n            $proc_query .= $create_query . $delimiter . $crlf . $crlf;\n        }\n        if ($used_alias) {\n            $text .= $this->_exportComment(\n                __('It appears your database uses routines;')\n            )\n            . $this->_exportComment(\n                __('alias export may not work reliably in all cases.')\n            )\n            . $this->_exportComment();\n        }\n        $text .= $proc_query;\n\n        return $text;\n    }\n\n    /**\n     * Exports routines (procedures and functions)\n     *\n     * @param string $db      Database\n     * @param array  $aliases Aliases of db/table/columns\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportRoutines($db, $aliases = array())\n    {\n        global $crlf;\n\n        $db_alias = $db;\n        $this->initAlias($aliases, $db_alias);\n\n        $text = '';\n        $delimiter = '$$';\n\n        $procedure_names = $GLOBALS['dbi']\n            ->getProceduresOrFunctions($db, 'PROCEDURE');\n        $function_names = $GLOBALS['dbi']->getProceduresOrFunctions($db, 'FUNCTION');\n\n        if ($procedure_names || $function_names) {\n            $text .= $crlf\n                . 'DELIMITER ' . $delimiter . $crlf;\n\n            if ($procedure_names) {\n                $text .= $this->_exportRoutineSQL(\n                    $db,\n                    $aliases,\n                    'PROCEDURE',\n                    __('Procedures'),\n                    $procedure_names,\n                    $delimiter\n                );\n            }\n\n            if ($function_names) {\n                $text .= $this->_exportRoutineSQL(\n                    $db,\n                    $aliases,\n                    'FUNCTION',\n                    __('Functions'),\n                    $function_names,\n                    $delimiter\n                );\n            }\n\n            $text .= 'DELIMITER ;' . $crlf;\n        }\n\n        if (!empty($text)) {\n            return PMA_exportOutputHandler($text);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Possibly outputs comment\n     *\n     * @param string $text Text of comment\n     *\n     * @return string The formatted comment\n     */\n    private function _exportComment($text = '')\n    {\n        if (isset($GLOBALS['sql_include_comments'])\n            && $GLOBALS['sql_include_comments']\n        ) {\n            // see https://dev.mysql.com/doc/refman/5.0/en/ansi-diff-comments.html\n            return '--' . (empty($text) ? '' : ' ') . $text . $GLOBALS['crlf'];\n        } else {\n            return '';\n        }\n    }\n\n    /**\n     * Possibly outputs CRLF\n     *\n     * @return string $crlf or nothing\n     */\n    private function _possibleCRLF()\n    {\n        if (isset($GLOBALS['sql_include_comments'])\n            && $GLOBALS['sql_include_comments']\n        ) {\n            return $GLOBALS['crlf'];\n        } else {\n            return '';\n        }\n    }\n\n    /**\n     * Outputs export footer\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportFooter()\n    {\n        global $crlf, $mysql_charset_map;\n\n        $foot = '';\n\n        if (isset($GLOBALS['sql_disable_fk'])) {\n            $foot .= 'SET FOREIGN_KEY_CHECKS=1;' . $crlf;\n        }\n\n        if (isset($GLOBALS['sql_use_transaction'])) {\n            $foot .= 'COMMIT;' . $crlf;\n        }\n\n        // restore connection settings\n        if ($this->_sent_charset) {\n            $foot .= $crlf\n                . '/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;'\n                . $crlf\n                . '/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;'\n                . $crlf\n                . '/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;'\n                . $crlf;\n            $this->_sent_charset = false;\n        }\n\n        /* Restore timezone */\n        if (isset($GLOBALS['sql_utc_time']) && $GLOBALS['sql_utc_time']) {\n            $GLOBALS['dbi']->query('SET time_zone = \"' . $GLOBALS['old_tz'] . '\"');\n        }\n\n        return PMA_exportOutputHandler($foot);\n    }\n\n    /**\n     * Outputs export header. It is the first method to be called, so all\n     * the required variables are initialized here.\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportHeader()\n    {\n        global $crlf, $cfg;\n        global $mysql_charset_map;\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $tmp_compat = $GLOBALS['sql_compatibility'];\n            if ($tmp_compat == 'NONE') {\n                $tmp_compat = '';\n            }\n            $GLOBALS['dbi']->tryQuery('SET SQL_MODE=\"' . $tmp_compat . '\"');\n            unset($tmp_compat);\n        }\n        $head = $this->_exportComment('phpMyAdmin SQL Dump')\n            . $this->_exportComment('version ' . PMA_VERSION)\n            . $this->_exportComment('https://www.phpmyadmin.net/')\n            . $this->_exportComment();\n        $host_string = __('Host:') . ' ' . $cfg['Server']['host'];\n        if (!empty($cfg['Server']['port'])) {\n            $host_string .= ':' . $cfg['Server']['port'];\n        }\n        $head .= $this->_exportComment($host_string);\n        $head .= $this->_exportComment(\n            __('Generation Time:') . ' '\n            . Util::localisedDate()\n        )\n        . $this->_exportComment(\n            __('Server version:') . ' ' . PMA_MYSQL_STR_VERSION\n        )\n        . $this->_exportComment(__('PHP Version:') . ' ' . phpversion())\n        . $this->_possibleCRLF();\n\n        if (isset($GLOBALS['sql_header_comment'])\n            && !empty($GLOBALS['sql_header_comment'])\n        ) {\n            // '\\n' is not a newline (like \"\\n\" would be), it's the characters\n            // backslash and n, as explained on the export interface\n            $lines = explode('\\n', $GLOBALS['sql_header_comment']);\n            $head .= $this->_exportComment();\n            foreach ($lines as $one_line) {\n                $head .= $this->_exportComment($one_line);\n            }\n            $head .= $this->_exportComment();\n        }\n\n        if (isset($GLOBALS['sql_disable_fk'])) {\n            $head .= 'SET FOREIGN_KEY_CHECKS=0;' . $crlf;\n        }\n\n        // We want exported AUTO_INCREMENT columns to have still same value,\n        // do this only for recent MySQL exports\n        if ((! isset($GLOBALS['sql_compatibility'])\n            || $GLOBALS['sql_compatibility'] == 'NONE')\n        ) {\n            $head .= 'SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";' . $crlf;\n        }\n\n        if (isset($GLOBALS['sql_use_transaction'])) {\n            $head .= 'SET AUTOCOMMIT = 0;' . $crlf\n                . 'START TRANSACTION;' . $crlf;\n        }\n\n        /* Change timezone if we should export timestamps in UTC */\n        if (isset($GLOBALS['sql_utc_time']) && $GLOBALS['sql_utc_time']) {\n            $head .= 'SET time_zone = \"+00:00\";' . $crlf;\n            $GLOBALS['old_tz'] = $GLOBALS['dbi']\n                ->fetchValue('SELECT @@session.time_zone');\n            $GLOBALS['dbi']->query('SET time_zone = \"+00:00\"');\n        }\n\n        $head .= $this->_possibleCRLF();\n\n        if (! empty($GLOBALS['asfile'])) {\n            // we are saving as file, therefore we provide charset information\n            // so that a utility like the mysql client can interpret\n            // the file correctly\n            if (isset($GLOBALS['charset'])\n                && isset($mysql_charset_map[$GLOBALS['charset']])\n            ) {\n                // we got a charset from the export dialog\n                $set_names = $mysql_charset_map[$GLOBALS['charset']];\n            } else {\n                // by default we use the connection charset\n                $set_names = $mysql_charset_map['utf-8'];\n            }\n            if ($set_names == 'utf8' && PMA_MYSQL_INT_VERSION > 50503) {\n                $set_names = 'utf8mb4';\n            }\n            $head .= $crlf\n                . '/*!40101 SET @OLD_CHARACTER_SET_CLIENT='\n                . '@@CHARACTER_SET_CLIENT */;' . $crlf\n                . '/*!40101 SET @OLD_CHARACTER_SET_RESULTS='\n                . '@@CHARACTER_SET_RESULTS */;' . $crlf\n                . '/*!40101 SET @OLD_COLLATION_CONNECTION='\n                . '@@COLLATION_CONNECTION */;' . $crlf\n                . '/*!40101 SET NAMES ' . $set_names . ' */;' . $crlf . $crlf;\n            $this->_sent_charset = true;\n        }\n\n        return PMA_exportOutputHandler($head);\n    }\n\n    /**\n     * Outputs CREATE DATABASE statement\n     *\n     * @param string $db          Database name\n     * @param string $export_type 'server', 'database', 'table'\n     * @param string $db_alias    Aliases of db\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportDBCreate($db, $export_type, $db_alias = '')\n    {\n        global $crlf;\n\n        if (empty($db_alias)) {\n            $db_alias = $db;\n        }\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n        if (isset($GLOBALS['sql_drop_database'])) {\n            if (!PMA_exportOutputHandler(\n                'DROP DATABASE '\n                . Util::backquoteCompat(\n                    $db_alias,\n                    $compat,\n                    isset($GLOBALS['sql_backquotes'])\n                )\n                . ';' . $crlf\n            )\n            ) {\n                return false;\n            }\n        }\n        if ($export_type == 'database' && !isset($GLOBALS['sql_create_database'])) {\n            return true;\n        }\n\n        $create_query = 'CREATE DATABASE IF NOT EXISTS '\n            . Util::backquoteCompat(\n                $db_alias,\n                $compat,\n                isset($GLOBALS['sql_backquotes'])\n            );\n        $collation = PMA_getDbCollation($db);\n        if (mb_strpos($collation, '_')) {\n            $create_query .= ' DEFAULT CHARACTER SET '\n                . mb_substr(\n                    $collation,\n                    0,\n                    mb_strpos($collation, '_')\n                )\n                . ' COLLATE ' . $collation;\n        } else {\n            $create_query .= ' DEFAULT CHARACTER SET ' . $collation;\n        }\n        $create_query .= ';' . $crlf;\n        if (!PMA_exportOutputHandler($create_query)) {\n            return false;\n        }\n\n        return $this->_exportUseStatement($db_alias, $compat);\n    }\n\n    /**\n     * Outputs USE statement\n     *\n     * @param string $db     db to use\n     * @param string $compat sql compatibility\n     *\n     * @return bool Whether it succeeded\n     */\n    private function _exportUseStatement($db, $compat)\n    {\n        global $crlf;\n\n        if (isset($GLOBALS['sql_compatibility'])\n            && $GLOBALS['sql_compatibility'] == 'NONE'\n        ) {\n            $result = PMA_exportOutputHandler(\n                'USE '\n                . Util::backquoteCompat(\n                    $db,\n                    $compat,\n                    isset($GLOBALS['sql_backquotes'])\n                )\n                . ';' . $crlf\n            );\n        } else {\n            $result = PMA_exportOutputHandler('USE ' . $db . ';' . $crlf);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Outputs database header\n     *\n     * @param string $db       Database name\n     * @param string $db_alias Alias of db\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportDBHeader($db, $db_alias = '')\n    {\n        if (empty($db_alias)) {\n            $db_alias = $db;\n        }\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n        $head = $this->_exportComment()\n            . $this->_exportComment(\n                __('Database:') . ' '\n                . Util::backquoteCompat(\n                    $db_alias,\n                    $compat,\n                    isset($GLOBALS['sql_backquotes'])\n                )\n            )\n            . $this->_exportComment();\n\n        return PMA_exportOutputHandler($head);\n    }\n\n    /**\n     * Outputs database footer\n     *\n     * @param string $db Database name\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportDBFooter($db)\n    {\n        global $crlf;\n\n        $result = true;\n\n        //add indexes to the sql dump file\n        if (isset($GLOBALS['sql_indexes'])) {\n            $result = PMA_exportOutputHandler($GLOBALS['sql_indexes']);\n            unset($GLOBALS['sql_indexes']);\n        }\n        //add auto increments to the sql dump file\n        if (isset($GLOBALS['sql_auto_increments'])) {\n            $result = PMA_exportOutputHandler($GLOBALS['sql_auto_increments']);\n            unset($GLOBALS['sql_auto_increments']);\n        }\n        //add constraints to the sql dump file\n        if (isset($GLOBALS['sql_constraints'])) {\n            $result = PMA_exportOutputHandler($GLOBALS['sql_constraints']);\n            unset($GLOBALS['sql_constraints']);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Exports events\n     *\n     * @param string $db Database\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportEvents($db)\n    {\n        global $crlf;\n\n        $text = '';\n        $delimiter = '$$';\n\n        $event_names = $GLOBALS['dbi']->fetchResult(\n            \"SELECT EVENT_NAME FROM information_schema.EVENTS WHERE\"\n            . \" EVENT_SCHEMA= '\" . Util::sqlAddSlashes($db, true)\n            . \"';\"\n        );\n\n        if ($event_names) {\n            $text .= $crlf\n                . \"DELIMITER \" . $delimiter . $crlf;\n\n            $text .= $this->_exportComment()\n                . $this->_exportComment(__('Events'))\n                . $this->_exportComment();\n\n            foreach ($event_names as $event_name) {\n                if (!empty($GLOBALS['sql_drop_table'])) {\n                    $text .= \"DROP EVENT \"\n                        . Util::backquote($event_name)\n                        . $delimiter . $crlf;\n                }\n                $text .= $GLOBALS['dbi']->getDefinition($db, 'EVENT', $event_name)\n                    . $delimiter . $crlf . $crlf;\n            }\n\n            $text .= \"DELIMITER ;\" . $crlf;\n        }\n\n        if (!empty($text)) {\n            return PMA_exportOutputHandler($text);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Exports metadata from Configuration Storage\n     *\n     * @param string       $db            database being exported\n     * @param string|array $tables        table(s) being exported\n     * @param array        $metadataTypes types of metadata to export\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportMetadata(\n        $db,\n        $tables,\n        $metadataTypes\n    ) {\n        $cfgRelation = PMA_getRelationsParam();\n        if (!isset($cfgRelation['db'])) {\n            return true;\n        }\n\n        $comment = $this->_possibleCRLF()\n            . $this->_possibleCRLF()\n            . $this->_exportComment()\n            . $this->_exportComment(__('Metadata'))\n            . $this->_exportComment();\n        if (!PMA_exportOutputHandler($comment)) {\n            return false;\n        }\n\n        if (!$this->_exportUseStatement(\n            $cfgRelation['db'],\n            $GLOBALS['sql_compatibility']\n        )\n        ) {\n            return false;\n        }\n\n        $r = true;\n        if (is_array($tables)) {\n            // export metadata for each table\n            foreach ($tables as $table) {\n                $r &= $this->_exportMetadata($db, $table, $metadataTypes);\n            }\n            // export metadata for the database\n            $r &= $this->_exportMetadata($db, null, $metadataTypes);\n        } else {\n            // export metadata for single table\n            $r &= $this->_exportMetadata($db, $tables, $metadataTypes);\n        }\n\n        return $r;\n    }\n\n    /**\n     * Exports metadata from Configuration Storage\n     *\n     * @param string $db            database being exported\n     * @param string $table         table being exported\n     * @param array  $metadataTypes types of metadata to export\n     *\n     * @return bool Whether it succeeded\n     */\n    private function _exportMetadata(\n        $db,\n        $table,\n        $metadataTypes\n    ) {\n        $cfgRelation = PMA_getRelationsParam();\n\n        if (isset($table)) {\n            $types = array(\n                'column_info'   => 'db_name',\n                'table_uiprefs' => 'db_name',\n                'tracking'      => 'db_name',\n            );\n        } else {\n            $types = array(\n                'bookmark'        => 'dbase',\n                'relation'        => 'master_db',\n                'pdf_pages'       => 'db_name',\n                'savedsearches'   => 'db_name',\n                'central_columns' => 'db_name',\n            );\n        }\n\n        $aliases = array();\n\n        $comment = $this->_possibleCRLF()\n            . $this->_exportComment();\n\n        if (isset($table)) {\n            $comment .= $this->_exportComment(\n                sprintf(\n                    __('Metadata for table %s'),\n                    $table\n                )\n            );\n        } else {\n            $comment .= $this->_exportComment(\n                sprintf(\n                    __('Metadata for database %s'),\n                    $db\n                )\n            );\n        }\n\n        $comment .= $this->_exportComment();\n\n        if (!PMA_exportOutputHandler($comment)) {\n            return false;\n        }\n\n        foreach ($types as $type => $dbNameColumn) {\n            if (in_array($type, $metadataTypes) && isset($cfgRelation[$type])) {\n\n                // special case, designer pages and their coordinates\n                if ($type == 'pdf_pages') {\n\n                    $sql_query = \"SELECT `page_nr`, `page_descr` FROM \"\n                        . Util::backquote($cfgRelation['db'])\n                        . \".\" . Util::backquote($cfgRelation[$type])\n                        . \" WHERE \" . Util::backquote($dbNameColumn)\n                        . \" = '\" . Util::sqlAddSlashes($db) . \"'\";\n\n                    $result = $GLOBALS['dbi']->fetchResult(\n                        $sql_query,\n                        'page_nr',\n                        'page_descr'\n                    );\n\n                    foreach ($result as $page => $name) {\n                        // insert row for pdf_page\n                        $sql_query_row = \"SELECT `db_name`, `page_descr` FROM \"\n                            . Util::backquote($cfgRelation['db'])\n                            . \".\" . Util::backquote(\n                                $cfgRelation[$type]\n                            )\n                            . \" WHERE \" . Util::backquote(\n                                $dbNameColumn\n                            )\n                            . \" = '\" . Util::sqlAddSlashes($db) . \"'\"\n                            . \" AND `page_nr` = '\" . $page . \"'\";\n\n                        if (!$this->exportData(\n                            $cfgRelation['db'],\n                            $cfgRelation[$type],\n                            $GLOBALS['crlf'],\n                            '',\n                            $sql_query_row,\n                            $aliases\n                        )\n                        ) {\n                            return false;\n                        }\n\n                        $lastPage = $GLOBALS['crlf']\n                            . \"SET @LAST_PAGE = LAST_INSERT_ID();\"\n                            . $GLOBALS['crlf'];\n                        if (!PMA_exportOutputHandler($lastPage)) {\n                            return false;\n                        }\n\n                        $sql_query_coords = \"SELECT `db_name`, `table_name`, \"\n                            . \"'@LAST_PAGE' AS `pdf_page_number`, `x`, `y` FROM \"\n                            . Util::backquote($cfgRelation['db'])\n                            . \".\" . Util::backquote(\n                                $cfgRelation['table_coords']\n                            )\n                            . \" WHERE `pdf_page_number` = '\" . $page . \"'\";\n\n                        $GLOBALS['exporting_metadata'] = true;\n                        if (!$this->exportData(\n                            $cfgRelation['db'],\n                            $cfgRelation['table_coords'],\n                            $GLOBALS['crlf'],\n                            '',\n                            $sql_query_coords,\n                            $aliases\n                        )\n                        ) {\n                            $GLOBALS['exporting_metadata'] = false;\n\n                            return false;\n                        }\n                        $GLOBALS['exporting_metadata'] = false;\n                    }\n                    continue;\n                }\n\n                // remove auto_incrementing id field for some tables\n                if ($type == 'bookmark') {\n                    $sql_query = \"SELECT `dbase`, `user`, `label`, `query` FROM \";\n                } elseif ($type == 'column_info') {\n                    $sql_query = \"SELECT `db_name`, `table_name`, `column_name`,\"\n                        . \" `comment`, `mimetype`, `transformation`,\"\n                        . \" `transformation_options`, `input_transformation`,\"\n                        . \" `input_transformation_options` FROM\";\n                } elseif ($type == 'savedsearches') {\n                    $sql_query = \"SELECT `username`, `db_name`, `search_name`,\"\n                        . \" `search_data` FROM\";\n                } else {\n                    $sql_query = \"SELECT * FROM \";\n                }\n                $sql_query .= Util::backquote($cfgRelation['db'])\n                    . '.' . Util::backquote($cfgRelation[$type])\n                    . \" WHERE \" . Util::backquote($dbNameColumn)\n                    . \" = '\" . Util::sqlAddSlashes($db) . \"'\";\n                if (isset($table)) {\n                    $sql_query .= \" AND `table_name` = '\"\n                        . Util::sqlAddSlashes($table) . \"'\";\n                }\n\n                if (!$this->exportData(\n                    $cfgRelation['db'],\n                    $cfgRelation[$type],\n                    $GLOBALS['crlf'],\n                    '',\n                    $sql_query,\n                    $aliases\n                )\n                ) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns a stand-in CREATE definition to resolve view dependencies\n     *\n     * @param string $db      the database name\n     * @param string $view    the view name\n     * @param string $crlf    the end of line sequence\n     * @param array  $aliases Aliases of db/table/columns\n     *\n     * @return string resulting definition\n     */\n    public function getTableDefStandIn($db, $view, $crlf, $aliases = array())\n    {\n        $db_alias = $db;\n        $view_alias = $view;\n        $this->initAlias($aliases, $db_alias, $view_alias);\n        $create_query = '';\n        if (!empty($GLOBALS['sql_drop_table'])) {\n            $create_query .= 'DROP VIEW IF EXISTS '\n                . Util::backquote($view_alias)\n                . ';' . $crlf;\n        }\n\n        $create_query .= 'CREATE TABLE ';\n\n        if (isset($GLOBALS['sql_if_not_exists'])\n            && $GLOBALS['sql_if_not_exists']\n        ) {\n            $create_query .= 'IF NOT EXISTS ';\n        }\n        $create_query .= Util::backquote($view_alias) . ' (' . $crlf;\n        $tmp = array();\n        $columns = $GLOBALS['dbi']->getColumnsFull($db, $view);\n        foreach ($columns as $column_name => $definition) {\n            $col_alias = $column_name;\n            if (!empty($aliases[$db]['tables'][$view]['columns'][$col_alias])) {\n                $col_alias = $aliases[$db]['tables'][$view]['columns'][$col_alias];\n            }\n            $tmp[] = Util::backquote($col_alias) . ' ' .\n                $definition['Type'] . $crlf;\n        }\n        $create_query .= implode(',', $tmp) . ');' . $crlf;\n\n        return ($create_query);\n    }\n\n    /**\n     * Returns CREATE definition that matches $view's structure\n     *\n     * @param string $db            the database name\n     * @param string $view          the view name\n     * @param string $crlf          the end of line sequence\n     * @param bool   $add_semicolon whether to add semicolon and end-of-line at\n     *                              the end\n     * @param array  $aliases       Aliases of db/table/columns\n     *\n     * @return string resulting schema\n     */\n    private function _getTableDefForView(\n        $db,\n        $view,\n        $crlf,\n        $add_semicolon = true,\n        $aliases = array()\n    ) {\n        $db_alias = $db;\n        $view_alias = $view;\n        $this->initAlias($aliases, $db_alias, $view_alias);\n        $create_query = \"CREATE TABLE\";\n        if (isset($GLOBALS['sql_if_not_exists'])) {\n            $create_query .= \" IF NOT EXISTS \";\n        }\n        $create_query .= Util::backquote($view_alias) . \"(\" . $crlf;\n\n        $columns = $GLOBALS['dbi']->getColumns($db, $view, null, true);\n\n        $firstCol = true;\n        foreach ($columns as $column) {\n            $col_alias = $column['Field'];\n            if (!empty($aliases[$db]['tables'][$view]['columns'][$col_alias])) {\n                $col_alias = $aliases[$db]['tables'][$view]['columns'][$col_alias];\n            }\n            $extracted_columnspec = Util::extractColumnSpec(\n                $column['Type']\n            );\n\n            if (!$firstCol) {\n                $create_query .= \",\" . $crlf;\n            }\n            $create_query .= \"    \" . Util::backquote($col_alias);\n            $create_query .= \" \" . $column['Type'];\n            if ($extracted_columnspec['can_contain_collation']\n                && !empty($column['Collation'])\n            ) {\n                $create_query .= \" COLLATE \" . $column['Collation'];\n            }\n            if ($column['Null'] == 'NO') {\n                $create_query .= \" NOT NULL\";\n            }\n            if (isset($column['Default'])) {\n                $create_query .= \" DEFAULT '\"\n                    . Util::sqlAddSlashes($column['Default']) . \"'\";\n            } else {\n                if ($column['Null'] == 'YES') {\n                    $create_query .= \" DEFAULT NULL\";\n                }\n            }\n            if (!empty($column['Comment'])) {\n                $create_query .= \" COMMENT '\"\n                    . Util::sqlAddSlashes($column['Comment']) . \"'\";\n            }\n            $firstCol = false;\n        }\n        $create_query .= $crlf . \")\" . ($add_semicolon ? ';' : '') . $crlf;\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n        if ($compat == 'MSSQL') {\n            $create_query = $this->_makeCreateTableMSSQLCompatible(\n                $create_query\n            );\n        }\n\n        return $create_query;\n    }\n\n    /**\n     * Returns $table's CREATE definition\n     *\n     * @param string $db                        the database name\n     * @param string $table                     the table name\n     * @param string $crlf                      the end of line sequence\n     * @param string $error_url                 the url to go back in case\n     *                                          of error\n     * @param bool   $show_dates                whether to include creation/\n     *                                          update/check dates\n     * @param bool   $add_semicolon             whether to add semicolon and\n     *                                          end-of-line at the end\n     * @param bool   $view                      whether we're handling a view\n     * @param bool   $update_indexes_increments whether we need to update\n     *                                          two global variables\n     * @param array  $aliases                   Aliases of db/table/columns\n     *\n     * @return string resulting schema\n     */\n    public function getTableDef(\n        $db,\n        $table,\n        $crlf,\n        $error_url,\n        $show_dates = false,\n        $add_semicolon = true,\n        $view = false,\n        $update_indexes_increments = true,\n        $aliases = array()\n    ) {\n        global $sql_drop_table, $sql_backquotes, $sql_constraints,\n               $sql_constraints_query, $sql_indexes, $sql_indexes_query,\n               $sql_auto_increments, $sql_drop_foreign_keys;\n\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n\n        $schema_create = '';\n        $auto_increment = '';\n        $new_crlf = $crlf;\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n\n        // need to use PMA\\libraries\\DatabaseInterface::QUERY_STORE\n        // with $GLOBALS['dbi']->numRows() in mysqli\n        $result = $GLOBALS['dbi']->query(\n            'SHOW TABLE STATUS FROM ' . Util::backquote($db)\n            . ' WHERE Name = \\'' . Util::sqlAddSlashes($table) . '\\'',\n            null,\n            DatabaseInterface::QUERY_STORE\n        );\n        if ($result != false) {\n            if ($GLOBALS['dbi']->numRows($result) > 0) {\n                $tmpres = $GLOBALS['dbi']->fetchAssoc($result);\n\n                // Here we optionally add the AUTO_INCREMENT next value,\n                // but starting with MySQL 5.0.24, the clause is already included\n                // in SHOW CREATE TABLE so we'll remove it below\n                if (isset($GLOBALS['sql_auto_increment'])\n                    && !empty($tmpres['Auto_increment'])\n                ) {\n                    $auto_increment .= ' AUTO_INCREMENT='\n                        . $tmpres['Auto_increment'] . ' ';\n                }\n\n                if ($show_dates\n                    && isset($tmpres['Create_time'])\n                    && !empty($tmpres['Create_time'])\n                ) {\n                    $schema_create .= $this->_exportComment(\n                        __('Creation:') . ' '\n                        . Util::localisedDate(\n                            strtotime($tmpres['Create_time'])\n                        )\n                    );\n                    $new_crlf = $this->_exportComment() . $crlf;\n                }\n\n                if ($show_dates\n                    && isset($tmpres['Update_time'])\n                    && !empty($tmpres['Update_time'])\n                ) {\n                    $schema_create .= $this->_exportComment(\n                        __('Last update:') . ' '\n                        . Util::localisedDate(\n                            strtotime($tmpres['Update_time'])\n                        )\n                    );\n                    $new_crlf = $this->_exportComment() . $crlf;\n                }\n\n                if ($show_dates\n                    && isset($tmpres['Check_time'])\n                    && !empty($tmpres['Check_time'])\n                ) {\n                    $schema_create .= $this->_exportComment(\n                        __('Last check:') . ' '\n                        . Util::localisedDate(\n                            strtotime($tmpres['Check_time'])\n                        )\n                    );\n                    $new_crlf = $this->_exportComment() . $crlf;\n                }\n            }\n            $GLOBALS['dbi']->freeResult($result);\n        }\n\n        $schema_create .= $new_crlf;\n\n        // no need to generate a DROP VIEW here, it was done earlier\n        if (!empty($sql_drop_table)\n            && !$GLOBALS['dbi']->getTable($db, $table)->isView()\n        ) {\n            $schema_create .= 'DROP TABLE IF EXISTS '\n                . Util::backquote($table_alias, $sql_backquotes) . ';'\n                . $crlf;\n        }\n\n        // Complete table dump,\n        // Whether to quote table and column names or not\n        if ($sql_backquotes) {\n            $GLOBALS['dbi']->query('SET SQL_QUOTE_SHOW_CREATE = 1');\n        } else {\n            $GLOBALS['dbi']->query('SET SQL_QUOTE_SHOW_CREATE = 0');\n        }\n\n        // I don't see the reason why this unbuffered query could cause problems,\n        // because SHOW CREATE TABLE returns only one row, and we free the\n        // results below. Nonetheless, we got 2 user reports about this\n        // (see bug 1562533) so I removed the unbuffered mode.\n        // $result = $GLOBALS['dbi']->query('SHOW CREATE TABLE ' . backquote($db)\n        // . '.' . backquote($table), null, DatabaseInterface::QUERY_UNBUFFERED);\n        //\n        // Note: SHOW CREATE TABLE, at least in MySQL 5.1.23, does not\n        // produce a displayable result for the default value of a BIT\n        // column, nor does the mysqldump command. See MySQL bug 35796\n        $result = $GLOBALS['dbi']->tryQuery(\n            'SHOW CREATE TABLE ' . Util::backquote($db) . '.'\n            . Util::backquote($table)\n        );\n        // an error can happen, for example the table is crashed\n        $tmp_error = $GLOBALS['dbi']->getError();\n        if ($tmp_error) {\n            return $this->_exportComment(__('in use') . '(' . $tmp_error . ')');\n        }\n\n        // Old mode is stored so it can be restored once exporting is done.\n        $old_mode = Context::$MODE;\n\n        $warning = '';\n        if ($result != false && ($row = $GLOBALS['dbi']->fetchRow($result))) {\n            $create_query = $row[1];\n            unset($row);\n\n            // Convert end of line chars to one that we want (note that MySQL\n            // doesn't return query it will accept in all cases)\n            if (mb_strpos($create_query, \"(\\r\\n \")) {\n                $create_query = str_replace(\"\\r\\n\", $crlf, $create_query);\n            } elseif (mb_strpos($create_query, \"(\\n \")) {\n                $create_query = str_replace(\"\\n\", $crlf, $create_query);\n            } elseif (mb_strpos($create_query, \"(\\r \")) {\n                $create_query = str_replace(\"\\r\", $crlf, $create_query);\n            }\n\n            /*\n             * Drop database name from VIEW creation.\n             *\n             * This is a bit tricky, but we need to issue SHOW CREATE TABLE with\n             * database name, but we don't want name to show up in CREATE VIEW\n             * statement.\n             */\n            if ($view) {\n                $create_query = preg_replace(\n                    '/' . preg_quote(Util::backquote($db)) . '\\./',\n                    '',\n                    $create_query\n                );\n            }\n\n            // Substitute aliases in `CREATE` query.\n            $create_query = $this->replaceWithAliases(\n                $create_query,\n                $aliases,\n                $db,\n                $table,\n                $flag\n            );\n\n            // One warning per view.\n            if ($flag && $view) {\n                $warning = $this->_exportComment()\n                    . $this->_exportComment(\n                        __('It appears your database uses views;')\n                    )\n                    . $this->_exportComment(\n                        __('alias export may not work reliably in all cases.')\n                    )\n                    . $this->_exportComment();\n            }\n\n            // Adding IF NOT EXISTS, if required.\n            if (isset($GLOBALS['sql_if_not_exists'])) {\n                $create_query = preg_replace(\n                    '/^CREATE TABLE/',\n                    'CREATE TABLE IF NOT EXISTS',\n                    $create_query\n                );\n            }\n\n            // Making the query MSSQL compatible.\n            if ($compat == 'MSSQL') {\n                $create_query = $this->_makeCreateTableMSSQLCompatible(\n                    $create_query\n                );\n            }\n\n            // Views have no constraints, indexes, etc. They do not require any\n            // analysis.\n            if (!$view) {\n\n                if (empty($sql_backquotes)) {\n                    // Option \"Enclose table and column names with backquotes\"\n                    // was checked.\n                    Context::$MODE |= Context::NO_ENCLOSING_QUOTES;\n                }\n\n                // Using appropriate quotes.\n                if (($compat === 'MSSQL') || ($sql_backquotes === '\"')) {\n                    Context::$MODE |= Context::ANSI_QUOTES;\n                }\n            }\n\n            /**\n             * Parser used for analysis.\n             *\n             * @var Parser\n             */\n            $parser = new Parser($create_query);\n\n            /**\n             * `CREATE TABLE` statement.\n             *\n             * @var SelectStatement\n             */\n            $statement = $parser->statements[0];\n\n            if (!empty($statement->entityOptions)) {\n                $engine = $statement->entityOptions->has('ENGINE');\n            } else {\n                $engine = '';\n            }\n\n            /* Avoid operation on ARCHIVE tables as those can not be altered */\n            if (!empty($statement->fields) && (empty($engine) || strtoupper($engine) != 'ARCHIVE')) {\n\n                /**\n                 * Fragments containining definition of each constraint.\n                 *\n                 * @var array\n                 */\n                $constraints = array();\n\n                /**\n                 * Fragments containining definition of each index.\n                 *\n                 * @var array\n                 */\n                $indexes = array();\n\n                /**\n                 * Fragments containining definition of each FULLTEXT index.\n                 *\n                 * @var array\n                 */\n                $indexes_fulltext = array();\n\n                /**\n                 * Fragments containining definition of each foreign key that will\n                 * be dropped.\n                 *\n                 * @var array\n                 */\n                $dropped = array();\n\n                /**\n                 * Fragment containining definition of the `AUTO_INCREMENT`.\n                 *\n                 * @var array\n                 */\n                $auto_increment = array();\n\n                // Scanning each field of the `CREATE` statement to fill the arrays\n                // above.\n                // If the field is used in any of the arrays above, it is removed\n                // from the original definition.\n                // Also, AUTO_INCREMENT attribute is removed.\n                /** @var CreateDefinition $field */\n                foreach ($statement->fields as $key => $field) {\n\n                    if ($field->isConstraint) {\n                        // Creating the parts that add constraints.\n                        $constraints[] = $field::build($field);\n                        unset($statement->fields[$key]);\n                    } elseif (!empty($field->key)) {\n                        // Creating the parts that add indexes (must not be\n                        // constraints).\n                        if ($field->key->type === 'FULLTEXT KEY') {\n                            $indexes_fulltext[] = $field->build($field);\n                            unset($statement->fields[$key]);\n                        } else {\n                            if (empty($GLOBALS['sql_if_not_exists'])) {\n                                $indexes[] = str_replace(\n                                    'COMMENT=\\'', 'COMMENT \\'', $field::build($field)\n                                );\n                                unset($statement->fields[$key]);\n                            }\n                        }\n                    }\n\n                    // Creating the parts that drop foreign keys.\n                    if (!empty($field->key)) {\n                        if ($field->key->type === 'FOREIGN KEY') {\n                            $dropped[] = 'FOREIGN KEY ' . Context::escape(\n                                $field->name\n                            );\n                            unset($statement->fields[$key]);\n                        }\n                    }\n\n                    // Dropping AUTO_INCREMENT.\n                    if (!empty($field->options)) {\n                        if ($field->options->has('AUTO_INCREMENT')\n                            && empty($GLOBALS['sql_if_not_exists'])\n                        ) {\n\n                            $auto_increment[] = $field::build($field);\n                            $field->options->remove('AUTO_INCREMENT');\n                        }\n                    }\n                }\n\n                /**\n                 * The header of the `ALTER` statement (`ALTER TABLE tbl`).\n                 *\n                 * @var string\n                 */\n                $alter_header = 'ALTER TABLE ' .\n                    Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    );\n\n                /**\n                 * The footer of the `ALTER` statement (usually ';')\n                 *\n                 * @var string\n                 */\n                $alter_footer = ';' . $crlf;\n\n                // Generating constraints-related query.\n                if (!empty($constraints)) {\n                    $sql_constraints_query = $alter_header . $crlf . '  ADD '\n                        . implode(',' . $crlf . '  ADD ', $constraints)\n                        . $alter_footer;\n\n                    $sql_constraints = $this->generateComment(\n                        $crlf,\n                        $sql_constraints,\n                        __('Constraints for dumped tables'),\n                        __('Constraints for table'),\n                        $table_alias,\n                        $compat\n                    ) . $sql_constraints_query;\n                }\n\n                // Generating indexes-related query.\n                $sql_indexes_query = '';\n\n                if (!empty($indexes)) {\n                    $sql_indexes_query .= $alter_header . $crlf . '  ADD '\n                        . implode(',' . $crlf . '  ADD ', $indexes)\n                        . $alter_footer;\n                }\n\n                if (!empty($indexes_fulltext)) {\n                    // InnoDB supports one FULLTEXT index creation at a time.\n                    // So FULLTEXT indexes are created one-by-one after other\n                    // indexes where created.\n                    $sql_indexes_query .= $alter_header .\n                        ' ADD ' . implode(\n                            $alter_footer . $alter_header . ' ADD ',\n                            $indexes_fulltext\n                        ) . $alter_footer;\n                }\n\n                if ((!empty($indexes)) || (!empty($indexes_fulltext))) {\n                    $sql_indexes = $this->generateComment(\n                        $crlf,\n                        $sql_indexes,\n                        __('Indexes for dumped tables'),\n                        __('Indexes for table'),\n                        $table_alias,\n                        $compat\n                    ) . $sql_indexes_query;\n                }\n\n                // Generating drop foreign keys-related query.\n                if (!empty($dropped)) {\n                    $sql_drop_foreign_keys = $alter_header . $crlf . '  DROP '\n                        . implode(',' . $crlf . '  DROP ', $dropped)\n                        . $alter_footer;\n                }\n\n                // Generating auto-increment-related query.\n                if ((! empty($auto_increment)) && ($update_indexes_increments)) {\n                    $sql_auto_increments_query = $alter_header . $crlf . '  MODIFY '\n                        . implode(',' . $crlf . '  MODIFY ', $auto_increment);\n                    if (isset($GLOBALS['sql_auto_increment'])\n                        && ($statement->entityOptions->has('AUTO_INCREMENT') !== false)\n                    ) {\n                        $sql_auto_increments_query .= ', AUTO_INCREMENT='\n                            . $statement->entityOptions->has('AUTO_INCREMENT');\n                    }\n                    $sql_auto_increments_query .= ';';\n\n                    $sql_auto_increments = $this->generateComment(\n                        $crlf,\n                        $sql_auto_increments,\n                        __('AUTO_INCREMENT for dumped tables'),\n                        __('AUTO_INCREMENT for table'),\n                        $table_alias,\n                        $compat\n                    ) . $sql_auto_increments_query;\n                }\n\n                // Removing the `AUTO_INCREMENT` attribute from the `CREATE TABLE`\n                // too.\n                if (!empty($statement->entityOptions)\n                    && (empty($GLOBALS['sql_if_not_exists'])\n                    || empty($GLOBALS['sql_auto_increment']))\n                ) {\n                    $statement->entityOptions->remove('AUTO_INCREMENT');\n                }\n\n                // Rebuilding the query.\n                $create_query = $statement->build();\n            }\n\n            $schema_create .= $create_query;\n        }\n\n        $GLOBALS['dbi']->freeResult($result);\n\n        // Restoring old mode.\n        Context::$MODE = $old_mode;\n\n        return $warning . $schema_create . ($add_semicolon ? ';' . $crlf : '');\n    } // end of the 'getTableDef()' function\n\n    /**\n     * Returns $table's comments, relations etc.\n     *\n     * @param string $db          database name\n     * @param string $table       table name\n     * @param string $crlf        end of line sequence\n     * @param bool   $do_relation whether to include relation comments\n     * @param bool   $do_mime     whether to include mime comments\n     * @param array  $aliases     Aliases of db/table/columns\n     *\n     * @return string resulting comments\n     */\n    private function _getTableComments(\n        $db,\n        $table,\n        $crlf,\n        $do_relation = false,\n        $do_mime = false,\n        $aliases = array()\n    ) {\n        global $cfgRelation, $sql_backquotes;\n\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n\n        $schema_create = '';\n\n        // Check if we can use Relations\n        list($res_rel, $have_rel) = PMA_getRelationsAndStatus(\n            $do_relation && !empty($cfgRelation['relation']),\n            $db,\n            $table\n        );\n\n        if ($do_mime && $cfgRelation['mimework']) {\n            if (!($mime_map = PMA_getMIME($db, $table, true))) {\n                unset($mime_map);\n            }\n        }\n\n        if (isset($mime_map) && count($mime_map) > 0) {\n            $schema_create .= $this->_possibleCRLF()\n                . $this->_exportComment()\n                . $this->_exportComment(\n                    __('MIME TYPES FOR TABLE') . ' '\n                    . Util::backquote($table, $sql_backquotes) . ':'\n                );\n            foreach ($mime_map as $mime_field => $mime) {\n                $schema_create .= $this->_exportComment(\n                    '  '\n                    . Util::backquote($mime_field, $sql_backquotes)\n                )\n                . $this->_exportComment(\n                    '      '\n                    . Util::backquote(\n                        $mime['mimetype'],\n                        $sql_backquotes\n                    )\n                );\n            }\n            $schema_create .= $this->_exportComment();\n        }\n\n        if ($have_rel) {\n            $schema_create .= $this->_possibleCRLF()\n                . $this->_exportComment()\n                . $this->_exportComment(\n                    __('RELATIONS FOR TABLE') . ' '\n                    . Util::backquote($table_alias, $sql_backquotes)\n                    . ':'\n                );\n\n            foreach ($res_rel as $rel_field => $rel) {\n                if ($rel_field != 'foreign_keys_data') {\n                    $rel_field_alias = !empty(\n                        $aliases[$db]['tables'][$table]['columns'][$rel_field]\n                    ) ? $aliases[$db]['tables'][$table]['columns'][$rel_field]\n                        : $rel_field;\n                    $schema_create .= $this->_exportComment(\n                        '  '\n                        . Util::backquote(\n                            $rel_field_alias,\n                            $sql_backquotes\n                        )\n                    )\n                    . $this->_exportComment(\n                        '      '\n                        . Util::backquote(\n                            $rel['foreign_table'],\n                            $sql_backquotes\n                        )\n                        . ' -> '\n                        . Util::backquote(\n                            $rel['foreign_field'],\n                            $sql_backquotes\n                        )\n                    );\n                } else {\n                    foreach ($rel as $one_key) {\n                        foreach ($one_key['index_list'] as $index => $field) {\n                            $rel_field_alias = !empty(\n                                $aliases[$db]['tables'][$table]['columns'][$field]\n                            ) ? $aliases[$db]['tables'][$table]['columns'][$field]\n                                : $field;\n                            $schema_create .= $this->_exportComment(\n                                '  '\n                                . Util::backquote(\n                                    $rel_field_alias,\n                                    $sql_backquotes\n                                )\n                            )\n                            . $this->_exportComment(\n                                '      '\n                                . Util::backquote(\n                                    $one_key['ref_table_name'],\n                                    $sql_backquotes\n                                )\n                                . ' -> '\n                                . Util::backquote(\n                                    $one_key['ref_index_list'][$index],\n                                    $sql_backquotes\n                                )\n                            );\n                        }\n                    }\n                }\n            }\n            $schema_create .= $this->_exportComment();\n        }\n\n        return $schema_create;\n    } // end of the '_getTableComments()' function\n\n    /**\n     * Outputs table's structure\n     *\n     * @param string $db          database name\n     * @param string $table       table name\n     * @param string $crlf        the end of line sequence\n     * @param string $error_url   the url to go back in case of error\n     * @param string $export_mode 'create_table','triggers','create_view',\n     *                            'stand_in'\n     * @param string $export_type 'server', 'database', 'table'\n     * @param bool   $relation    whether to include relation comments\n     * @param bool   $comments    whether to include the pmadb-style column\n     *                            comments as comments in the structure; this is\n     *                            deprecated but the parameter is left here\n     *                            because export.php calls exportStructure()\n     *                            also for other export types which use this\n     *                            parameter\n     * @param bool   $mime        whether to include mime comments\n     * @param bool   $dates       whether to include creation/update/check dates\n     * @param array  $aliases     Aliases of db/table/columns\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportStructure(\n        $db,\n        $table,\n        $crlf,\n        $error_url,\n        $export_mode,\n        $export_type,\n        $relation = false,\n        $comments = false,\n        $mime = false,\n        $dates = false,\n        $aliases = array()\n    ) {\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n\n        $formatted_table_name = Util::backquoteCompat(\n            $table_alias,\n            $compat,\n            isset($GLOBALS['sql_backquotes'])\n        );\n        $dump = $this->_possibleCRLF()\n            . $this->_exportComment(str_repeat('-', 56))\n            . $this->_possibleCRLF()\n            . $this->_exportComment();\n\n        switch ($export_mode) {\n        case 'create_table':\n            $dump .= $this->_exportComment(\n                __('Table structure for table') . ' ' . $formatted_table_name\n            );\n            $dump .= $this->_exportComment();\n            $dump .= $this->getTableDef(\n                $db,\n                $table,\n                $crlf,\n                $error_url,\n                $dates,\n                true,\n                false,\n                true,\n                $aliases\n            );\n            $dump .= $this->_getTableComments(\n                $db,\n                $table,\n                $crlf,\n                $relation,\n                $mime,\n                $aliases\n            );\n            break;\n        case 'triggers':\n            $dump = '';\n            $delimiter = '$$';\n            $triggers = $GLOBALS['dbi']->getTriggers($db, $table, $delimiter);\n            if ($triggers) {\n                $dump .= $this->_possibleCRLF()\n                    . $this->_exportComment()\n                    . $this->_exportComment(\n                        __('Triggers') . ' ' . $formatted_table_name\n                    )\n                    . $this->_exportComment();\n                $used_alias = false;\n                $trigger_query = '';\n                foreach ($triggers as $trigger) {\n                    if (!empty($GLOBALS['sql_drop_table'])) {\n                        $trigger_query .= $trigger['drop'] . ';' . $crlf;\n                    }\n\n                    $trigger_query .= 'DELIMITER ' . $delimiter . $crlf;\n                    $trigger_query .= $this->replaceWithAliases(\n                        $trigger['create'],\n                        $aliases,\n                        $db,\n                        $table,\n                        $flag\n                    );\n                    if ($flag) {\n                        $used_alias = true;\n                    }\n                    $trigger_query .= 'DELIMITER ;' . $crlf;\n                }\n                // One warning per table.\n                if ($used_alias) {\n                    $dump .= $this->_exportComment(\n                        __('It appears your table uses triggers;')\n                    )\n                    . $this->_exportComment(\n                        __('alias export may not work reliably in all cases.')\n                    )\n                    . $this->_exportComment();\n                }\n                $dump .= $trigger_query;\n            }\n            break;\n        case 'create_view':\n            if (empty($GLOBALS['sql_views_as_tables'])) {\n                $dump .= $this->_exportComment(\n                    __('Structure for view')\n                    . ' '\n                    . $formatted_table_name\n                )\n                . $this->_exportComment();\n                // delete the stand-in table previously created (if any)\n                if ($export_type != 'table') {\n                    $dump .= 'DROP TABLE IF EXISTS '\n                        . Util::backquote($table_alias) . ';' . $crlf;\n                }\n                $dump .= $this->getTableDef(\n                    $db,\n                    $table,\n                    $crlf,\n                    $error_url,\n                    $dates,\n                    true,\n                    true,\n                    true,\n                    $aliases\n                );\n            } else {\n                $dump .= $this->_exportComment(\n                    sprintf(\n                        __('Structure for view %s exported as a table'),\n                        $formatted_table_name\n                    )\n                )\n                . $this->_exportComment();\n                // delete the stand-in table previously created (if any)\n                if ($export_type != 'table') {\n                    $dump .= 'DROP TABLE IF EXISTS '\n                        . Util::backquote($table_alias) . ';' . $crlf;\n                }\n                $dump .= $this->_getTableDefForView(\n                    $db,\n                    $table,\n                    $crlf,\n                    true,\n                    $aliases\n                );\n            }\n            break;\n        case 'stand_in':\n            $dump .= $this->_exportComment(\n                __('Stand-in structure for view') . ' ' . $formatted_table_name\n            )\n                . $this->_exportComment(\n                __('(See below for the actual view)')\n            )\n                . $this->_exportComment();\n            // export a stand-in definition to resolve view dependencies\n            $dump .= $this->getTableDefStandIn($db, $table, $crlf, $aliases);\n        } // end switch\n\n        // this one is built by getTableDef() to use in table copy/move\n        // but not in the case of export\n        unset($GLOBALS['sql_constraints_query']);\n\n        return PMA_exportOutputHandler($dump);\n    }\n\n    /**\n     * Outputs the content of a table in SQL format\n     *\n     * @param string $db        database name\n     * @param string $table     table name\n     * @param string $crlf      the end of line sequence\n     * @param string $error_url the url to go back in case of error\n     * @param string $sql_query SQL query for obtaining data\n     * @param array  $aliases   Aliases of db/table/columns\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportData(\n        $db,\n        $table,\n        $crlf,\n        $error_url,\n        $sql_query,\n        $aliases = array()\n    ) {\n        global $current_row, $sql_backquotes;\n\n        // Do not export data for merge tables\n        if ($GLOBALS['dbi']->getTable($db, $table)->isMerge()) {\n            return true;\n        }\n\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n\n        $formatted_table_name = Util::backquoteCompat(\n            $table_alias,\n            $compat,\n            $sql_backquotes\n        );\n\n        // Do not export data for a VIEW, unless asked to export the view as a table\n        // (For a VIEW, this is called only when exporting a single VIEW)\n        if ($GLOBALS['dbi']->getTable($db, $table)->isView()\n            && empty($GLOBALS['sql_views_as_tables'])\n        ) {\n            $head = $this->_possibleCRLF()\n                . $this->_exportComment()\n                . $this->_exportComment('VIEW ' . ' ' . $formatted_table_name)\n                . $this->_exportComment(__('Data:') . ' ' . __('None'))\n                . $this->_exportComment()\n                . $this->_possibleCRLF();\n\n            if (!PMA_exportOutputHandler($head)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        $result = $GLOBALS['dbi']->tryQuery(\n            $sql_query,\n            null,\n            DatabaseInterface::QUERY_UNBUFFERED\n        );\n        // a possible error: the table has crashed\n        $tmp_error = $GLOBALS['dbi']->getError();\n        if ($tmp_error) {\n            return PMA_exportOutputHandler(\n                $this->_exportComment(\n                    __('Error reading data:') . ' (' . $tmp_error . ')'\n                )\n            );\n        }\n\n        if ($result == false) {\n            $GLOBALS['dbi']->freeResult($result);\n\n            return true;\n        }\n\n        $fields_cnt = $GLOBALS['dbi']->numFields($result);\n\n        // Get field information\n        $fields_meta = $GLOBALS['dbi']->getFieldsMeta($result);\n        $field_flags = array();\n        for ($j = 0; $j < $fields_cnt; $j++) {\n            $field_flags[$j] = $GLOBALS['dbi']->fieldFlags($result, $j);\n        }\n\n        $field_set = array();\n        for ($j = 0; $j < $fields_cnt; $j++) {\n            $col_as = $fields_meta[$j]->name;\n            if (!empty($aliases[$db]['tables'][$table]['columns'][$col_as])) {\n                $col_as = $aliases[$db]['tables'][$table]['columns'][$col_as];\n            }\n            $field_set[$j] = Util::backquoteCompat(\n                $col_as,\n                $compat,\n                $sql_backquotes\n            );\n        }\n\n        if (isset($GLOBALS['sql_type'])\n            && $GLOBALS['sql_type'] == 'UPDATE'\n        ) {\n            // update\n            $schema_insert = 'UPDATE ';\n            if (isset($GLOBALS['sql_ignore'])) {\n                $schema_insert .= 'IGNORE ';\n            }\n            // avoid EOL blank\n            $schema_insert .= Util::backquoteCompat(\n                $table_alias,\n                $compat,\n                $sql_backquotes\n            ) . ' SET';\n        } else {\n            // insert or replace\n            if (isset($GLOBALS['sql_type'])\n                && $GLOBALS['sql_type'] == 'REPLACE'\n            ) {\n                $sql_command = 'REPLACE';\n            } else {\n                $sql_command = 'INSERT';\n            }\n\n            // delayed inserts?\n            if (isset($GLOBALS['sql_delayed'])) {\n                $insert_delayed = ' DELAYED';\n            } else {\n                $insert_delayed = '';\n            }\n\n            // insert ignore?\n            if (isset($GLOBALS['sql_type'])\n                && $GLOBALS['sql_type'] == 'INSERT'\n                && isset($GLOBALS['sql_ignore'])\n            ) {\n                $insert_delayed .= ' IGNORE';\n            }\n            //truncate table before insert\n            if (isset($GLOBALS['sql_truncate'])\n                && $GLOBALS['sql_truncate']\n                && $sql_command == 'INSERT'\n            ) {\n                $truncate = 'TRUNCATE TABLE '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    ) . \";\";\n                $truncatehead = $this->_possibleCRLF()\n                    . $this->_exportComment()\n                    . $this->_exportComment(\n                        __('Truncate table before insert') . ' '\n                        . $formatted_table_name\n                    )\n                    . $this->_exportComment()\n                    . $crlf;\n                PMA_exportOutputHandler($truncatehead);\n                PMA_exportOutputHandler($truncate);\n            }\n\n            // scheme for inserting fields\n            if ($GLOBALS['sql_insert_syntax'] == 'complete'\n                || $GLOBALS['sql_insert_syntax'] == 'both'\n            ) {\n                $fields = implode(', ', $field_set);\n                $schema_insert = $sql_command . $insert_delayed . ' INTO '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    )\n                    // avoid EOL blank\n                    . ' (' . $fields . ') VALUES';\n            } else {\n                $schema_insert = $sql_command . $insert_delayed . ' INTO '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    )\n                    . ' VALUES';\n            }\n        }\n\n        //\\x08\\\\x09, not required\n        $search = array(\"\\x00\", \"\\x0a\", \"\\x0d\", \"\\x1a\");\n        $replace = array('\\0', '\\n', '\\r', '\\Z');\n        $current_row = 0;\n        $query_size = 0;\n        if (($GLOBALS['sql_insert_syntax'] == 'extended'\n            || $GLOBALS['sql_insert_syntax'] == 'both')\n            && (!isset($GLOBALS['sql_type'])\n            || $GLOBALS['sql_type'] != 'UPDATE')\n        ) {\n            $separator = ',';\n            $schema_insert .= $crlf;\n        } else {\n            $separator = ';';\n        }\n\n        while ($row = $GLOBALS['dbi']->fetchRow($result)) {\n            if ($current_row == 0) {\n                $head = $this->_possibleCRLF()\n                    . $this->_exportComment()\n                    . $this->_exportComment(\n                        __('Dumping data for table') . ' '\n                        . $formatted_table_name\n                    )\n                    . $this->_exportComment()\n                    . $crlf;\n                if (!PMA_exportOutputHandler($head)) {\n                    return false;\n                }\n            }\n            // We need to SET IDENTITY_INSERT ON for MSSQL\n            if (isset($GLOBALS['sql_compatibility'])\n                && $GLOBALS['sql_compatibility'] == 'MSSQL'\n                && $current_row == 0\n            ) {\n                if (!PMA_exportOutputHandler(\n                    'SET IDENTITY_INSERT '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    )\n                    . ' ON ;' . $crlf\n                )\n                ) {\n                    return false;\n                }\n            }\n            $current_row++;\n            $values = array();\n            for ($j = 0; $j < $fields_cnt; $j++) {\n                // NULL\n                if (!isset($row[$j]) || is_null($row[$j])) {\n                    $values[] = 'NULL';\n                } elseif ($fields_meta[$j]->numeric\n                    && $fields_meta[$j]->type != 'timestamp'\n                    && !$fields_meta[$j]->blob\n                ) {\n                    // a number\n                    // timestamp is numeric on some MySQL 4.1, BLOBs are\n                    // sometimes numeric\n                    $values[] = $row[$j];\n                } elseif (stristr($field_flags[$j], 'BINARY') !== false\n                    && isset($GLOBALS['sql_hex_for_binary'])\n                ) {\n                    // a true BLOB\n                    // - mysqldump only generates hex data when the --hex-blob\n                    //   option is used, for fields having the binary attribute\n                    //   no hex is generated\n                    // - a TEXT field returns type blob but a real blob\n                    //   returns also the 'binary' flag\n\n                    // empty blobs need to be different, but '0' is also empty\n                    // :-(\n                    if (empty($row[$j]) && $row[$j] != '0') {\n                        $values[] = '\\'\\'';\n                    } else {\n                        $values[] = '0x' . bin2hex($row[$j]);\n                    }\n                } elseif ($fields_meta[$j]->type == 'bit') {\n                    // detection of 'bit' works only on mysqli extension\n                    $values[] = \"b'\" . Util::sqlAddSlashes(\n                        Util::printableBitValue(\n                            $row[$j],\n                            $fields_meta[$j]->length\n                        )\n                    )\n                    . \"'\";\n                } elseif (!empty($GLOBALS['exporting_metadata'])\n                    && $row[$j] == '@LAST_PAGE'\n                ) {\n                    $values[] = '@LAST_PAGE';\n                } else {\n                    // something else -> treat as a string\n                    $values[] = '\\''\n                        . str_replace(\n                            $search,\n                            $replace,\n                            Util::sqlAddSlashes($row[$j])\n                        )\n                        . '\\'';\n                } // end if\n            } // end for\n\n            // should we make update?\n            if (isset($GLOBALS['sql_type'])\n                && $GLOBALS['sql_type'] == 'UPDATE'\n            ) {\n\n                $insert_line = $schema_insert;\n                for ($i = 0; $i < $fields_cnt; $i++) {\n                    if (0 == $i) {\n                        $insert_line .= ' ';\n                    }\n                    if ($i > 0) {\n                        // avoid EOL blank\n                        $insert_line .= ',';\n                    }\n                    $insert_line .= $field_set[$i] . ' = ' . $values[$i];\n                }\n\n                list($tmp_unique_condition, $tmp_clause_is_unique)\n                    = Util::getUniqueCondition(\n                        $result, // handle\n                        $fields_cnt, // fields_cnt\n                        $fields_meta, // fields_meta\n                        $row, // row\n                        false, // force_unique\n                        false, // restrict_to_table\n                        null // analyzed_sql_results\n                    );\n                $insert_line .= ' WHERE ' . $tmp_unique_condition;\n                unset($tmp_unique_condition, $tmp_clause_is_unique);\n            } else {\n\n                // Extended inserts case\n                if ($GLOBALS['sql_insert_syntax'] == 'extended'\n                    || $GLOBALS['sql_insert_syntax'] == 'both'\n                ) {\n                    if ($current_row == 1) {\n                        $insert_line = $schema_insert . '('\n                            . implode(', ', $values) . ')';\n                    } else {\n                        $insert_line = '(' . implode(', ', $values) . ')';\n                        $insertLineSize = mb_strlen($insert_line);\n                        $sql_max_size = $GLOBALS['sql_max_query_size'];\n                        if (isset($sql_max_size)\n                            && $sql_max_size > 0\n                            && $query_size + $insertLineSize > $sql_max_size\n                        ) {\n                            if (!PMA_exportOutputHandler(';' . $crlf)) {\n                                return false;\n                            }\n                            $query_size = 0;\n                            $current_row = 1;\n                            $insert_line = $schema_insert . $insert_line;\n                        }\n                    }\n                    $query_size += mb_strlen($insert_line);\n                    // Other inserts case\n                } else {\n                    $insert_line = $schema_insert\n                        . '(' . implode(', ', $values) . ')';\n                }\n            }\n            unset($values);\n\n            if (!PMA_exportOutputHandler(\n                ($current_row == 1 ? '' : $separator . $crlf)\n                . $insert_line\n            )\n            ) {\n                return false;\n            }\n        } // end while\n\n        if ($current_row > 0) {\n            if (!PMA_exportOutputHandler(';' . $crlf)) {\n                return false;\n            }\n        }\n\n        // We need to SET IDENTITY_INSERT OFF for MSSQL\n        if (isset($GLOBALS['sql_compatibility'])\n            && $GLOBALS['sql_compatibility'] == 'MSSQL'\n            && $current_row > 0\n        ) {\n            $outputSucceeded = PMA_exportOutputHandler(\n                $crlf . 'SET IDENTITY_INSERT '\n                . Util::backquoteCompat(\n                    $table_alias,\n                    $compat,\n                    $sql_backquotes\n                )\n                . ' OFF;' . $crlf\n            );\n            if (!$outputSucceeded) {\n                return false;\n            }\n        }\n\n        $GLOBALS['dbi']->freeResult($result);\n\n        return true;\n    } // end of the 'exportData()' function\n\n    /**\n     * Make a create table statement compatible with MSSQL\n     *\n     * @param string $create_query MySQL create table statement\n     *\n     * @return string MSSQL compatible create table statement\n     */\n    private function _makeCreateTableMSSQLCompatible($create_query)\n    {\n        // In MSSQL\n        // 1. No 'IF NOT EXISTS' in CREATE TABLE\n        // 2. DATE field doesn't exists, we will use DATETIME instead\n        // 3. UNSIGNED attribute doesn't exist\n        // 4. No length on INT, TINYINT, SMALLINT, BIGINT and no precision on\n        //    FLOAT fields\n        // 5. No KEY and INDEX inside CREATE TABLE\n        // 6. DOUBLE field doesn't exists, we will use FLOAT instead\n\n        $create_query = preg_replace(\n            \"/^CREATE TABLE IF NOT EXISTS/\",\n            'CREATE TABLE',\n            $create_query\n        );\n        // first we need  to replace all lines ended with '\" DATE ...,\\n'\n        // last preg_replace preserve us from situation with date text\n        // inside DEFAULT field value\n        $create_query = preg_replace(\n            \"/\\\" date DEFAULT NULL(,)?\\n/\",\n            '\" datetime DEFAULT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            \"/\\\" date NOT NULL(,)?\\n/\",\n            '\" datetime NOT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" date NOT NULL DEFAULT \\'([^\\'])/',\n            '\" datetime NOT NULL DEFAULT \\'$1',\n            $create_query\n        );\n\n        // next we need to replace all lines ended with ') UNSIGNED ...,'\n        // last preg_replace preserve us from situation with unsigned text\n        // inside DEFAULT field value\n        $create_query = preg_replace(\n            \"/\\) unsigned NOT NULL(,)?\\n/\",\n            ') NOT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            \"/\\) unsigned DEFAULT NULL(,)?\\n/\",\n            ') DEFAULT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\\) unsigned NOT NULL DEFAULT \\'([^\\'])/',\n            ') NOT NULL DEFAULT \\'$1',\n            $create_query\n        );\n\n        // we need to replace all lines ended with\n        // '\" INT|TINYINT([0-9]{1,}) ...,' last preg_replace preserve us\n        // from situation with int([0-9]{1,}) text inside DEFAULT field\n        // value\n        $create_query = preg_replace(\n            '/\" (int|tinyint|smallint|bigint)\\([0-9]+\\) DEFAULT NULL(,)?\\n/',\n            '\" $1 DEFAULT NULL$2' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (int|tinyint|smallint|bigint)\\([0-9]+\\) NOT NULL(,)?\\n/',\n            '\" $1 NOT NULL$2' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (int|tinyint|smallint|bigint)\\([0-9]+\\) NOT NULL DEFAULT \\'([^\\'])/',\n            '\" $1 NOT NULL DEFAULT \\'$2',\n            $create_query\n        );\n\n        // we need to replace all lines ended with\n        // '\" FLOAT|DOUBLE([0-9,]{1,}) ...,'\n        // last preg_replace preserve us from situation with\n        // float([0-9,]{1,}) text inside DEFAULT field value\n        $create_query = preg_replace(\n            '/\" (float|double)(\\([0-9]+,[0-9,]+\\))? DEFAULT NULL(,)?\\n/',\n            '\" float DEFAULT NULL$3' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (float|double)(\\([0-9,]+,[0-9,]+\\))? NOT NULL(,)?\\n/',\n            '\" float NOT NULL$3' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (float|double)(\\([0-9,]+,[0-9,]+\\))? NOT NULL DEFAULT \\'([^\\'])/',\n            '\" float NOT NULL DEFAULT \\'$3',\n            $create_query\n        );\n\n        // @todo remove indexes from CREATE TABLE\n\n        return $create_query;\n    }\n\n    /**\n     * replaces db/table/column names with their aliases\n     *\n     * @param string $sql_query SQL query in which aliases are to be substituted\n     * @param array  $aliases   Alias information for db/table/column\n     * @param string $db        the database name\n     * @param string $table     the tablename\n     * @param string &$flag     the flag denoting whether any replacement was done\n     *\n     * @return string query replaced with aliases\n     */\n    public function replaceWithAliases(\n        $sql_query,\n        $aliases,\n        $db,\n        $table = '',\n        &$flag = null\n    ) {\n        $flag = false;\n\n        /**\n         * The parser of this query.\n         *\n         * @var Parser $parser\n         */\n        $parser = new Parser($sql_query);\n\n        if (empty($parser->statements[0])) {\n            return $sql_query;\n        }\n\n        /**\n         * The statement that represents the query.\n         *\n         * @var \\SqlParser\\Statements\\CreateStatement $statement\n         */\n        $statement = $parser->statements[0];\n\n        /**\n         * Old database name.\n         *\n         * @var string $old_database\n         */\n        $old_database = $db;\n\n        // Replacing aliases in `CREATE TABLE` statement.\n        if ($statement->options->has('TABLE')) {\n\n            // Extracting the name of the old database and table from the\n            // statement to make sure the parameters are corect.\n            if (!empty($statement->name->database)) {\n                $old_database = $statement->name->database;\n            }\n\n            /**\n             * Old table name.\n             *\n             * @var string $old_table\n             */\n            $old_table = $statement->name->table;\n\n            // Finding the aliased database name.\n            // The database might be empty so we have to add a few checks.\n            $new_database = null;\n            if (!empty($statement->name->database)) {\n                $new_database = $statement->name->database;\n                if (!empty($aliases[$old_database]['alias'])) {\n                    $new_database = $aliases[$old_database]['alias'];\n                }\n            }\n\n            // Finding the aliases table name.\n            $new_table = $old_table;\n            if (!empty($aliases[$old_database]['tables'][$old_table]['alias'])) {\n                $new_table = $aliases[$old_database]['tables'][$old_table]['alias'];\n            }\n\n            // Replacing new values.\n            if (($statement->name->database !== $new_database)\n                || ($statement->name->table !== $new_table)\n            ) {\n                $statement->name->database = $new_database;\n                $statement->name->table = $new_table;\n                $statement->name->expr = null; // Force rebuild.\n                $flag = true;\n            }\n\n            foreach ($statement->fields as $field) {\n\n                // Column name.\n                if (!empty($field->type)) {\n                    if (!empty($aliases[$old_database]['tables'][$old_table]['columns'][$field->name])) {\n                        $field->name = $aliases[$old_database]['tables']\n                        [$old_table]['columns'][$field->name];\n                        $flag = true;\n                    }\n                }\n\n                // Key's columns.\n                if (!empty($field->key)) {\n                    foreach ($field->key->columns as $key => $column) {\n                        if (!empty($aliases[$old_database]['tables'][$old_table]['columns'][$column['name']])) {\n                            $field->key->columns[$key]['name'] = $aliases[$old_database]\n                                ['tables'][$old_table]['columns'][$column['name']];\n                            $flag = true;\n                        }\n                    }\n                }\n\n                // References.\n                if (!empty($field->references)) {\n                    $ref_table = $field->references->table->table;\n                    // Replacing table.\n                    if (!empty($aliases[$old_database]['tables'][$ref_table]['alias'])) {\n                        $field->references->table->table\n                            = $aliases[$old_database]['tables'][$ref_table]['alias'];\n                        $field->references->table->expr = null;\n                        $flag = true;\n                    }\n                    // Replacing column names.\n                    foreach ($field->references->columns as $key => $column) {\n                        if (!empty($aliases[$old_database]['tables'][$ref_table]['columns'][$column])) {\n                            $field->references->columns[$key]\n                                = $aliases[$old_database]['tables'][$ref_table]['columns'][$column];\n                            $flag = true;\n                        }\n                    }\n                }\n            }\n        } elseif ($statement->options->has('TRIGGER')) {\n\n            // Extracting the name of the old database and table from the\n            // statement to make sure the parameters are corect.\n            if (!empty($statement->table->database)) {\n                $old_database = $statement->table->database;\n            }\n\n            /**\n             * Old table name.\n             *\n             * @var string $old_table\n             */\n            $old_table = $statement->table->table;\n\n            if (!empty($aliases[$old_database]['tables'][$old_table]['alias'])) {\n                $statement->table->table\n                    = $aliases[$old_database]['tables'][$old_table]['alias'];\n                $statement->table->expr = null; // Force rebuild.\n                $flag = true;\n            }\n        }\n\n        if (($statement->options->has('TRIGGER'))\n            || ($statement->options->has('PROCEDURE'))\n            || ($statement->options->has('FUNCTION'))\n            || ($statement->options->has('VIEW'))\n        ) {\n\n            // Repalcing the body.\n            for ($i = 0, $count = count($statement->body); $i < $count; ++$i) {\n\n                /**\n                 * Token parsed at this moment.\n                 *\n                 * @var Token $token\n                 */\n                $token = $statement->body[$i];\n\n                // Replacing only symbols (that are not variables) and unknown\n                // identifiers.\n                if ((($token->type === Token::TYPE_SYMBOL)\n                    && (!($token->flags & Token::FLAG_SYMBOL_VARIABLE)))\n                    || ((($token->type === Token::TYPE_KEYWORD)\n                    && (!($token->flags & Token::FLAG_KEYWORD_RESERVED)))\n                    || ($token->type === Token::TYPE_NONE))\n                ) {\n                    $alias = $this->getAlias($aliases, $token->value);\n                    if (!empty($alias)) {\n                        // Replacing the token.\n                        $token->token = Context::escape($alias);\n                        $flag = true;\n                    }\n                }\n            }\n        }\n\n        return $statement->build();\n    }\n\n    /**\n     * Generate comment\n     *\n     * @param string $crlf          Carriage return character\n     * @param string $sql_statement SQL statement\n     * @param string $comment1      Comment for dumped table\n     * @param string $comment2      Comment for current table\n     * @param string $table_alias   Table alias\n     * @param string $compat        Compatibility mode\n     *\n     * @return string\n     */\n    protected function generateComment(\n        $crlf,\n        $sql_statement,\n        $comment1,\n        $comment2,\n        $table_alias,\n        $compat\n    ) {\n        if (!isset($sql_statement)) {\n            if (isset($GLOBALS['no_constraints_comments'])) {\n                $sql_statement = '';\n            } else {\n                $sql_statement = $crlf\n                    . $this->_exportComment()\n                    . $this->_exportComment($comment1)\n                    . $this->_exportComment();\n            }\n        }\n\n        // comments for current table\n        if (!isset($GLOBALS['no_constraints_comments'])) {\n            $sql_statement .= $crlf\n                . $this->_exportComment()\n                . $this->_exportComment(\n                    $comment2 . ' ' . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        isset($GLOBALS['sql_backquotes'])\n                    )\n                )\n                . $this->_exportComment();\n        }\n\n        return $sql_statement;\n    }\n}\n", "<select id=\"field_<?= $columnNumber; ?>_<?= ($ci - $ci_offset); ?>\"\n        size=\"1\"\n        name=\"field_<?= $type;?>[<?= $columnNumber;?>]\">\n    <option value=\"\" title=\"<?= __('None'); ?>\"></option>\n    <?php if (isset($available_mime[$type]) && is_array($available_mime[$type])): ?>\n        <?php foreach ($available_mime[$type] as $mimekey => $transform): ?>\n            <?php\n                $checked = isset($columnMeta['Field'])\n                         && isset($mime_map[$columnMeta['Field']][$type])\n                         && preg_match('@' . preg_quote($available_mime[$type . '_file'][$mimekey]) . '3?@i',\n                                        $mime_map[$columnMeta['Field']][$type]) ? 'selected ' : '';\n                $tooltip = PMA_getTransformationDescription(\n                    $available_mime[$type . '_file'][$mimekey]\n                );\n                $parts = explode(\":\", $transform);\n                $name = PMA_getTransformationName(\n                    $available_mime[$type . '_file'][$mimekey]\n                ) . ' (' . strtolower($parts[0]) . \":\" . $parts[1] . ')';\n            ?>\n            <option value=\"<?= $available_mime[$type . '_file'][$mimekey]; ?>\"\n                    <?= $checked; ?>\n                    title=\"<?= htmlspecialchars($tooltip); ?>\">\n                <?= htmlspecialchars($name); ?>\n            </option>\n        <?php endforeach; ?>\n    <?php endif; ?>\n</select>", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * PMA_warnMissingExtension warns or fails on missing extension.\n *\n * @package PhpMyAdmin-test\n */\n\n/*\n * Include to test.\n */\nuse PMA\\libraries\\Theme;\n\n\nrequire_once 'libraries/js_escape.lib.php';\nrequire_once 'libraries/sanitizing.lib.php';\n\n/**\n * PMA_warnMissingExtension warns or fails on missing extension.\n *\n * @package PhpMyAdmin-test\n */\nclass PMA_WarnMissingExtension_Test extends PHPUnit_Framework_TestCase\n{\n    /**\n     * Set up\n     *\n     * @return void\n     */\n    public function setUp()\n    {\n        $GLOBALS['PMA_Config'] = new PMA\\libraries\\Config();\n        $GLOBALS['PMA_Config']->enableBc();\n        $GLOBALS['cfg']['Server'] = array(\n            'host' => 'host',\n            'verbose' => 'verbose',\n        );\n        $GLOBALS['cfg']['OBGzip'] = false;\n        $_SESSION['PMA_Theme'] = new Theme();\n        $GLOBALS['pmaThemeImage'] = 'theme/';\n        $GLOBALS['pmaThemePath'] = $_SESSION['PMA_Theme']->getPath();\n        $GLOBALS['server'] = 1;\n        $GLOBALS['db'] = '';\n        $GLOBALS['table'] = '';\n\n        include_once './libraries/ErrorHandler.php';\n        $GLOBALS['error_handler'] = new PMA\\libraries\\ErrorHandler();\n    }\n\n    /**\n     * Test for PMA_warnMissingExtension\n     *\n     * @return void\n     */\n    function testMissingExtensionFatal()\n    {\n        $ext = 'php_ext';\n        $warn = 'The <a href=\"' . PMA_getPHPDocLink('book.' . $ext . '.php')\n            . '\" target=\"Documentation\"><em>' . $ext\n            . '</em></a> extension is missing. Please check your PHP configuration.';\n\n        $this->expectOutputRegex('@' . preg_quote($warn) . '@');\n\n        PMA_warnMissingExtension($ext, true);\n    }\n\n    /**\n     * Test for PMA_warnMissingExtension\n     *\n     * @return void\n     */\n    function testMissingExtensionFatalWithExtra()\n    {\n        $ext = 'php_ext';\n        $extra = 'Appended Extra String';\n\n        $warn = 'The <a href=\"' . PMA_getPHPDocLink('book.' . $ext . '.php')\n            . '\" target=\"Documentation\"><em>' . $ext\n            . '</em></a> extension is missing. Please check your PHP configuration.'\n            . ' ' . $extra;\n\n        ob_start();\n        PMA_warnMissingExtension($ext, true, $extra);\n        $printed = ob_get_contents();\n        ob_end_clean();\n\n        $this->assertGreaterThan(0, mb_strpos($printed, $warn));\n    }\n}\n"], "fixing_code": ["<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Core script for import, this is just the glue around all other stuff\n *\n * @package PhpMyAdmin\n */\nuse PMA\\libraries\\plugins\\ImportPlugin;\n\n/**\n * Get the variables sent or posted to this script and a core script\n */\nrequire_once 'libraries/common.inc.php';\nrequire_once 'libraries/sql.lib.php';\nrequire_once 'libraries/bookmark.lib.php';\n//require_once 'libraries/display_import_functions.lib.php';\n\nif (isset($_REQUEST['show_as_php'])) {\n    $GLOBALS['show_as_php'] = $_REQUEST['show_as_php'];\n}\n\n// Import functions.\nrequire_once 'libraries/import.lib.php';\n\n// If there is a request to 'Simulate DML'.\nif (isset($_REQUEST['simulate_dml'])) {\n    PMA_handleSimulateDMLRequest();\n    exit;\n}\n\n// If it's a refresh console bookmarks request\nif (isset($_REQUEST['console_bookmark_refresh'])) {\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->addJSON(\n        'console_message_bookmark', PMA\\libraries\\Console::getBookmarkContent()\n    );\n    exit;\n}\n// If it's a console bookmark add request\nif (isset($_REQUEST['console_bookmark_add'])) {\n    $response = PMA\\libraries\\Response::getInstance();\n    if (isset($_REQUEST['label']) && isset($_REQUEST['db'])\n        && isset($_REQUEST['bookmark_query']) && isset($_REQUEST['shared'])\n    ) {\n        $cfgBookmark = PMA_Bookmark_getParams();\n        $bookmarkFields = array(\n            'bkm_database' => $_REQUEST['db'],\n            'bkm_user'  => $cfgBookmark['user'],\n            'bkm_sql_query' => $_REQUEST['bookmark_query'],\n            'bkm_label' => $_REQUEST['label']\n        );\n        $isShared = ($_REQUEST['shared'] == 'true' ? true : false);\n        if (PMA_Bookmark_save($bookmarkFields, $isShared)) {\n            $response->addJSON('message', __('Succeeded'));\n            $response->addJSON('data', $bookmarkFields);\n            $response->addJSON('isShared', $isShared);\n        } else {\n            $response->addJSON('message', __('Failed'));\n        }\n        die();\n    } else {\n        $response->addJSON('message', __('Incomplete params'));\n        die();\n    }\n}\n\n$format = '';\n\n/**\n * Sets globals from $_POST\n */\n$post_params = array(\n    'charset_of_file',\n    'format',\n    'import_type',\n    'is_js_confirmed',\n    'MAX_FILE_SIZE',\n    'message_to_show',\n    'noplugin',\n    'skip_queries',\n    'local_import_file'\n);\n\n// TODO: adapt full list of allowed parameters, as in export.php\nforeach ($post_params as $one_post_param) {\n    if (isset($_POST[$one_post_param])) {\n        $GLOBALS[$one_post_param] = $_POST[$one_post_param];\n    }\n}\n\n// reset import messages for ajax request\n$_SESSION['Import_message']['message'] = null;\n$_SESSION['Import_message']['go_back_url'] = null;\n// default values\n$GLOBALS['reload'] = false;\n\n// Use to identify current cycle is executing\n// a multiquery statement or stored routine\nif (!isset($_SESSION['is_multi_query'])) {\n    $_SESSION['is_multi_query'] = false;\n}\n\n$ajax_reload = array();\n// Are we just executing plain query or sql file?\n// (eg. non import, but query box/window run)\nif (! empty($sql_query)) {\n\n    // apply values for parameters\n    if (! empty($_REQUEST['parameterized'])\n        && ! empty($_REQUEST['parameters'])\n        && is_array($_REQUEST['parameters'])) {\n        $parameters = $_REQUEST['parameters'];\n        foreach ($parameters as $parameter => $replacement) {\n            $quoted = preg_quote($parameter, '/');\n            // making sure that :param does not apply values to :param1\n            $sql_query = preg_replace(\n                '/' . $quoted . '([^a-zA-Z0-9_])/',\n                PMA\\libraries\\Util::sqlAddSlashes($replacement) . '${1}',\n                $sql_query\n            );\n            // for parameters the appear at the end of the string\n            $sql_query = preg_replace(\n                '/' . $quoted . '$/',\n                PMA\\libraries\\Util::sqlAddSlashes($replacement),\n                $sql_query\n            );\n        }\n    }\n\n    // run SQL query\n    $import_text = $sql_query;\n    $import_type = 'query';\n    $format = 'sql';\n    $_SESSION['sql_from_query_box'] = true;\n\n    // If there is a request to ROLLBACK when finished.\n    if (isset($_REQUEST['rollback_query'])) {\n        PMA_handleRollbackRequest($import_text);\n    }\n\n    // refresh navigation and main panels\n    if (preg_match('/^(DROP)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i', $sql_query)) {\n        $GLOBALS['reload'] = true;\n        $ajax_reload['reload'] = true;\n    }\n\n    // refresh navigation panel only\n    if (preg_match(\n        '/^(CREATE|ALTER)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i',\n        $sql_query\n    )) {\n        $ajax_reload['reload'] = true;\n    }\n\n    // do a dynamic reload if table is RENAMED\n    // (by sending the instruction to the AJAX response handler)\n    if (preg_match(\n        '/^RENAME\\s+TABLE\\s+(.*?)\\s+TO\\s+(.*?)($|;|\\s)/i',\n        $sql_query,\n        $rename_table_names\n    )) {\n        $ajax_reload['reload'] = true;\n        $ajax_reload['table_name'] = PMA\\libraries\\Util::unQuote(\n            $rename_table_names[2]\n        );\n    }\n\n    $sql_query = '';\n} elseif (! empty($sql_file)) {\n    // run uploaded SQL file\n    $import_file = $sql_file;\n    $import_type = 'queryfile';\n    $format = 'sql';\n    unset($sql_file);\n} elseif (! empty($_REQUEST['id_bookmark'])) {\n    // run bookmark\n    $import_type = 'query';\n    $format = 'sql';\n}\n\n// If we didn't get any parameters, either user called this directly, or\n// upload limit has been reached, let's assume the second possibility.\nif ($_POST == array() && $_GET == array()) {\n    $message = PMA\\libraries\\Message::error(\n        __(\n            'You probably tried to upload a file that is too large. Please refer ' .\n            'to %sdocumentation%s for a workaround for this limit.'\n        )\n    );\n    $message->addParam('[doc@faq1-16]');\n    $message->addParam('[/doc]');\n\n    // so we can obtain the message\n    $_SESSION['Import_message']['message'] = $message->getDisplay();\n    $_SESSION['Import_message']['go_back_url'] = $GLOBALS['goto'];\n\n    $message->display();\n    exit; // the footer is displayed automatically\n}\n\n// Add console message id to response output\nif (isset($_POST['console_message_id'])) {\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->addJSON('console_message_id', $_POST['console_message_id']);\n}\n\n/**\n * Sets globals from $_POST patterns, for import plugins\n * We only need to load the selected plugin\n */\n\nif (! in_array(\n    $format,\n    array(\n        'csv',\n        'ldi',\n        'mediawiki',\n        'ods',\n        'shp',\n        'sql',\n        'xml'\n    )\n)\n) {\n    // this should not happen for a normal user\n    // but only during an attack\n    PMA_fatalError('Incorrect format parameter');\n}\n\n$post_patterns = array(\n    '/^force_file_/',\n    '/^' . $format . '_/'\n);\n\nPMA_setPostAsGlobal($post_patterns);\n\n// Check needed parameters\nPMA\\libraries\\Util::checkParameters(array('import_type', 'format'));\n\n// We don't want anything special in format\n$format = PMA_securePath($format);\n\n// Create error and goto url\nif ($import_type == 'table') {\n    $err_url = 'tbl_import.php' . PMA_URL_getCommon(\n        array(\n            'db' => $db, 'table' => $table\n        )\n    );\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n    $goto = 'tbl_import.php';\n} elseif ($import_type == 'database') {\n    $err_url = 'db_import.php' . PMA_URL_getCommon(array('db' => $db));\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n    $goto = 'db_import.php';\n} elseif ($import_type == 'server') {\n    $err_url = 'server_import.php' . PMA_URL_getCommon();\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n    $goto = 'server_import.php';\n} else {\n    if (empty($goto) || !preg_match('@^(server|db|tbl)(_[a-z]*)*\\.php$@i', $goto)) {\n        if (mb_strlen($table) && mb_strlen($db)) {\n            $goto = 'tbl_structure.php';\n        } elseif (mb_strlen($db)) {\n            $goto = 'db_structure.php';\n        } else {\n            $goto = 'server_sql.php';\n        }\n    }\n    if (mb_strlen($table) && mb_strlen($db)) {\n        $common = PMA_URL_getCommon(array('db' => $db, 'table' => $table));\n    } elseif (mb_strlen($db)) {\n        $common = PMA_URL_getCommon(array('db' => $db));\n    } else {\n        $common = PMA_URL_getCommon();\n    }\n    $err_url  = $goto . $common\n        . (preg_match('@^tbl_[a-z]*\\.php$@', $goto)\n            ? '&amp;table=' . htmlspecialchars($table)\n            : '');\n    $_SESSION['Import_message']['go_back_url'] = $err_url;\n}\n// Avoid setting selflink to 'import.php'\n// problem similar to bug 4276\nif (basename($_SERVER['SCRIPT_NAME']) === 'import.php') {\n    $_SERVER['SCRIPT_NAME'] = $goto;\n}\n\n\nif (mb_strlen($db)) {\n    $GLOBALS['dbi']->selectDb($db);\n}\n\n@set_time_limit($cfg['ExecTimeLimit']);\nif (! empty($cfg['MemoryLimit'])) {\n    @ini_set('memory_limit', $cfg['MemoryLimit']);\n}\n\n$timestamp = time();\nif (isset($_REQUEST['allow_interrupt'])) {\n    $maximum_time = ini_get('max_execution_time');\n} else {\n    $maximum_time = 0;\n}\n\n// set default values\n$timeout_passed = false;\n$error = false;\n$read_multiply = 1;\n$finished = false;\n$offset = 0;\n$max_sql_len = 0;\n$file_to_unlink = '';\n$sql_query = '';\n$sql_query_disabled = false;\n$go_sql = false;\n$executed_queries = 0;\n$run_query = true;\n$charset_conversion = false;\n$reset_charset = false;\n$bookmark_created = false;\n\n// Bookmark Support: get a query back from bookmark if required\nif (! empty($_REQUEST['id_bookmark'])) {\n    $id_bookmark = (int)$_REQUEST['id_bookmark'];\n    include_once 'libraries/bookmark.lib.php';\n    switch ($_REQUEST['action_bookmark']) {\n    case 0: // bookmarked query that have to be run\n        $import_text = PMA_Bookmark_get(\n            $db,\n            $id_bookmark,\n            'id',\n            isset($_REQUEST['action_bookmark_all'])\n        );\n        if (! empty($_REQUEST['bookmark_variable'])) {\n            $import_text = PMA_Bookmark_applyVariables(\n                $import_text\n            );\n        }\n\n        // refresh navigation and main panels\n        if (preg_match(\n            '/^(DROP)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i',\n            $import_text\n        )) {\n            $GLOBALS['reload'] = true;\n            $ajax_reload['reload'] = true;\n        }\n\n        // refresh navigation panel only\n        if (preg_match(\n            '/^(CREATE|ALTER)\\s+(VIEW|TABLE|DATABASE|SCHEMA)\\s+/i',\n            $import_text\n        )\n        ) {\n            $ajax_reload['reload'] = true;\n        }\n        break;\n    case 1: // bookmarked query that have to be displayed\n        $import_text = PMA_Bookmark_get($db, $id_bookmark);\n        if ($GLOBALS['is_ajax_request'] == true) {\n            $message = PMA\\libraries\\Message::success(__('Showing bookmark'));\n            $response = PMA\\libraries\\Response::getInstance();\n            $response->setRequestStatus($message->isSuccess());\n            $response->addJSON('message', $message);\n            $response->addJSON('sql_query', $import_text);\n            $response->addJSON('action_bookmark', $_REQUEST['action_bookmark']);\n            exit;\n        } else {\n            $run_query = false;\n        }\n        break;\n    case 2: // bookmarked query that have to be deleted\n        $import_text = PMA_Bookmark_get($db, $id_bookmark);\n        PMA_Bookmark_delete($id_bookmark);\n        if ($GLOBALS['is_ajax_request'] == true) {\n            $message = PMA\\libraries\\Message::success(\n                __('The bookmark has been deleted.')\n            );\n            $response = PMA\\libraries\\Response::getInstance();\n            $response->setRequestStatus($message->isSuccess());\n            $response->addJSON('message', $message);\n            $response->addJSON('action_bookmark', $_REQUEST['action_bookmark']);\n            $response->addJSON('id_bookmark', $id_bookmark);\n            exit;\n        } else {\n            $run_query = false;\n            $error = true; // this is kind of hack to skip processing the query\n        }\n        break;\n    }\n} // end bookmarks reading\n\n// Do no run query if we show PHP code\nif (isset($GLOBALS['show_as_php'])) {\n    $run_query = false;\n    $go_sql = true;\n}\n\n// We can not read all at once, otherwise we can run out of memory\n$memory_limit = trim(@ini_get('memory_limit'));\n// 2 MB as default\nif (empty($memory_limit)) {\n    $memory_limit = 2 * 1024 * 1024;\n}\n// In case no memory limit we work on 10MB chunks\nif ($memory_limit == -1) {\n    $memory_limit = 10 * 1024 * 1024;\n}\n\n// Calculate value of the limit\n$memoryUnit = mb_strtolower(substr($memory_limit, -1));\nif ('m' == $memoryUnit) {\n    $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024;\n} elseif ('k' == $memoryUnit) {\n    $memory_limit = (int)substr($memory_limit, 0, -1) * 1024;\n} elseif ('g' == $memoryUnit) {\n    $memory_limit = (int)substr($memory_limit, 0, -1) * 1024 * 1024 * 1024;\n} else {\n    $memory_limit = (int)$memory_limit;\n}\n\n// Just to be sure, there might be lot of memory needed for uncompression\n$read_limit = $memory_limit / 8;\n\n// handle filenames\nif (isset($_FILES['import_file'])) {\n    $import_file = $_FILES['import_file']['tmp_name'];\n}\nif (! empty($local_import_file) && ! empty($cfg['UploadDir'])) {\n\n    // sanitize $local_import_file as it comes from a POST\n    $local_import_file = PMA_securePath($local_import_file);\n\n    $import_file = PMA\\libraries\\Util::userDir($cfg['UploadDir'])\n        . $local_import_file;\n\n} elseif (empty($import_file) || ! is_uploaded_file($import_file)) {\n    $import_file  = 'none';\n}\n\n// Do we have file to import?\n\nif ($import_file != 'none' && ! $error) {\n    // work around open_basedir and other limitations\n    $open_basedir = @ini_get('open_basedir');\n\n    // If we are on a server with open_basedir, we must move the file\n    // before opening it.\n\n    if (! empty($open_basedir)) {\n        $tmp_subdir = ini_get('upload_tmp_dir');\n        if (empty($tmp_subdir)) {\n            $tmp_subdir = sys_get_temp_dir();\n        }\n        $tmp_subdir = rtrim($tmp_subdir, DIRECTORY_SEPARATOR);\n        if (@is_writable($tmp_subdir)) {\n            $import_file_new = $tmp_subdir . DIRECTORY_SEPARATOR\n                . basename($import_file) . uniqid();\n            if (move_uploaded_file($import_file, $import_file_new)) {\n                $import_file = $import_file_new;\n                $file_to_unlink = $import_file_new;\n            }\n\n            $size = filesize($import_file);\n        } else {\n\n            // If the php.ini is misconfigured (eg. there is no /tmp access defined\n            // with open_basedir), $tmp_subdir won't be writable and the user gets\n            // a 'File could not be read!' error (at PMA_detectCompression), which\n            // is not too meaningful. Show a meaningful error message to the user\n            // instead.\n\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'Uploaded file cannot be moved, because the server has ' .\n                    'open_basedir enabled without access to the %s directory ' .\n                    '(for temporary files).'\n                )\n            );\n            $message->addParam($tmp_subdir);\n            PMA_stopImport($message);\n        }\n    }\n\n    /**\n     *  Handle file compression\n     * @todo duplicate code exists in File.php\n     */\n    $compression = PMA_detectCompression($import_file);\n    if ($compression === false) {\n        $message = PMA\\libraries\\Message::error(__('File could not be read!'));\n        PMA_stopImport($message); //Contains an 'exit'\n    }\n\n    switch ($compression) {\n    case 'application/bzip2':\n        if ($cfg['BZipDump'] && @function_exists('bzopen')) {\n            $import_handle = @bzopen($import_file, 'r');\n        } else {\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'You attempted to load file with unsupported compression ' .\n                    '(%s). Either support for it is not implemented or disabled ' .\n                    'by your configuration.'\n                )\n            );\n            $message->addParam($compression);\n            PMA_stopImport($message);\n        }\n        break;\n    case 'application/gzip':\n        if ($cfg['GZipDump'] && @function_exists('gzopen')) {\n            $import_handle = @gzopen($import_file, 'r');\n        } else {\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'You attempted to load file with unsupported compression ' .\n                    '(%s). Either support for it is not implemented or disabled ' .\n                    'by your configuration.'\n                )\n            );\n            $message->addParam($compression);\n            PMA_stopImport($message);\n        }\n        break;\n    case 'application/zip':\n        if ($cfg['ZipDump'] && @function_exists('zip_open')) {\n            /**\n             * Load interface for zip extension.\n             */\n            include_once 'libraries/zip_extension.lib.php';\n            $zipResult = PMA_getZipContents($import_file);\n            if (! empty($zipResult['error'])) {\n                $message = PMA\\libraries\\Message::rawError($zipResult['error']);\n                PMA_stopImport($message);\n            } else {\n                $import_text = $zipResult['data'];\n            }\n        } else {\n            $message = PMA\\libraries\\Message::error(\n                __(\n                    'You attempted to load file with unsupported compression ' .\n                    '(%s). Either support for it is not implemented or disabled ' .\n                    'by your configuration.'\n                )\n            );\n            $message->addParam($compression);\n            PMA_stopImport($message);\n        }\n        break;\n    case 'none':\n        $import_handle = @fopen($import_file, 'r');\n        break;\n    default:\n        $message = PMA\\libraries\\Message::error(\n            __(\n                'You attempted to load file with unsupported compression (%s). ' .\n                'Either support for it is not implemented or disabled by your ' .\n                'configuration.'\n            )\n        );\n        $message->addParam($compression);\n        PMA_stopImport($message);\n        // the previous function exits\n    }\n    // use isset() because zip compression type does not use a handle\n    if (! $error && isset($import_handle) && $import_handle === false) {\n        $message = PMA\\libraries\\Message::error(__('File could not be read!'));\n        PMA_stopImport($message);\n    }\n} elseif (! $error) {\n    if (! isset($import_text) || empty($import_text)) {\n        $message = PMA\\libraries\\Message::error(\n            __(\n                'No data was received to import. Either no file name was ' .\n                'submitted, or the file size exceeded the maximum size permitted ' .\n                'by your PHP configuration. See [doc@faq1-16]FAQ 1.16[/doc].'\n            )\n        );\n        PMA_stopImport($message);\n    }\n}\n\n// so we can obtain the message\n//$_SESSION['Import_message'] = $message->getDisplay();\n\n// Convert the file's charset if necessary\nif ($GLOBALS['PMA_recoding_engine'] != PMA_CHARSET_NONE && isset($charset_of_file)) {\n    if ($charset_of_file != 'utf-8') {\n        $charset_conversion = true;\n    }\n} elseif (isset($charset_of_file) && $charset_of_file != 'utf-8') {\n    $GLOBALS['dbi']->query('SET NAMES \\'' . $charset_of_file . '\\'');\n    // We can not show query in this case, it is in different charset\n    $sql_query_disabled = true;\n    $reset_charset = true;\n}\n\n// Something to skip? (because timeout has passed)\nif (! $error && isset($_POST['skip'])) {\n    $original_skip = $skip = $_POST['skip'];\n    while ($skip > 0) {\n        PMA_importGetNextChunk($skip < $read_limit ? $skip : $read_limit);\n        // Disable read progressivity, otherwise we eat all memory!\n        $read_multiply = 1;\n        $skip -= $read_limit;\n    }\n    unset($skip);\n}\n\n// This array contain the data like numberof valid sql queries in the statement\n// and complete valid sql statement (which affected for rows)\n$sql_data = array('valid_sql' => array(), 'valid_queries' => 0);\n\nif (! $error) {\n    // Check for file existence\n    include_once \"libraries/plugin_interface.lib.php\";\n    /* @var $import_plugin ImportPlugin */\n    $import_plugin = PMA_getPlugin(\n        \"import\",\n        $format,\n        'libraries/plugins/import/',\n        $import_type\n    );\n    if ($import_plugin == null) {\n        $message = PMA\\libraries\\Message::error(\n            __('Could not load import plugins, please check your installation!')\n        );\n        PMA_stopImport($message);\n    } else {\n        // Do the real import\n        try {\n            $default_fk_check = PMA\\libraries\\Util::handleDisableFKCheckInit();\n            $import_plugin->doImport($sql_data);\n            PMA\\libraries\\Util::handleDisableFKCheckCleanup($default_fk_check);\n        } catch (Exception $e) {\n            PMA\\libraries\\Util::handleDisableFKCheckCleanup($default_fk_check);\n            throw $e;\n        }\n    }\n}\n\nif (! empty($import_handle)) {\n    fclose($import_handle);\n}\n\n// Cleanup temporary file\nif ($file_to_unlink != '') {\n    unlink($file_to_unlink);\n}\n\n// Reset charset back, if we did some changes\nif ($reset_charset) {\n    $GLOBALS['dbi']->query('SET CHARACTER SET utf8');\n    $GLOBALS['dbi']->query(\n        'SET SESSION collation_connection =\\'' . $collation_connection . '\\''\n    );\n}\n\n// Show correct message\nif (! empty($id_bookmark) && $_REQUEST['action_bookmark'] == 2) {\n    $message = PMA\\libraries\\Message::success(__('The bookmark has been deleted.'));\n    $display_query = $import_text;\n    $error = false; // unset error marker, it was used just to skip processing\n} elseif (! empty($id_bookmark) && $_REQUEST['action_bookmark'] == 1) {\n    $message = PMA\\libraries\\Message::notice(__('Showing bookmark'));\n} elseif ($bookmark_created) {\n    $special_message = '[br]'  . sprintf(\n        __('Bookmark %s has been created.'),\n        htmlspecialchars($_POST['bkm_label'])\n    );\n} elseif ($finished && ! $error) {\n    // Do not display the query with message, we do it separately\n    $display_query = ';';\n    if ($import_type != 'query') {\n        $message = PMA\\libraries\\Message::success(\n            '<em>'\n            . _ngettext(\n                'Import has been successfully finished, %d query executed.',\n                'Import has been successfully finished, %d queries executed.',\n                $executed_queries\n            )\n            . '</em>'\n        );\n        $message->addParam($executed_queries);\n\n        if ($import_notice) {\n            $message->addString($import_notice);\n        }\n        if (! empty($local_import_file)) {\n            $message->addString('(' . htmlspecialchars($local_import_file) . ')');\n        } else {\n            $message->addString(\n                '(' . htmlspecialchars($_FILES['import_file']['name']) . ')'\n            );\n        }\n    }\n}\n\n// Did we hit timeout? Tell it user.\nif ($timeout_passed) {\n    $importUrl = $err_url .= '&timeout_passed=1&offset=' . urlencode(\n        $GLOBALS['offset']\n    );\n    if (isset($local_import_file)) {\n        $importUrl .= '&local_import_file=' . urlencode($local_import_file);\n    }\n    $message = PMA\\libraries\\Message::error(\n        __(\n            'Script timeout passed, if you want to finish import,'\n            . ' please %sresubmit the same file%s and import will resume.'\n        )\n    );\n    $message->addParam('<a href=\"' . $importUrl . '\">', false);\n    $message->addParam('</a>', false);\n\n    if ($offset == 0 || (isset($original_skip) && $original_skip == $offset)) {\n        $message->addString(\n            __(\n                'However on last run no data has been parsed,'\n                . ' this usually means phpMyAdmin won\\'t be able to'\n                . ' finish this import unless you increase php time limits.'\n            )\n        );\n    }\n}\n\n// if there is any message, copy it into $_SESSION as well,\n// so we can obtain it by AJAX call\nif (isset($message)) {\n    $_SESSION['Import_message']['message'] = $message->getDisplay();\n}\n// Parse and analyze the query, for correct db and table name\n// in case of a query typed in the query window\n// (but if the query is too large, in case of an imported file, the parser\n//  can choke on it so avoid parsing)\n$sqlLength = mb_strlen($sql_query);\nif ($sqlLength <= $GLOBALS['cfg']['MaxCharactersInDisplayedSQL']) {\n    include_once 'libraries/parse_analyze.lib.php';\n\n    list(\n        $analyzed_sql_results,\n        $db,\n        $table\n    ) = PMA_parseAnalyze($sql_query, $db);\n    // @todo: possibly refactor\n    extract($analyzed_sql_results);\n}\n\n// There was an error?\nif (isset($my_die)) {\n    foreach ($my_die as $key => $die) {\n        PMA\\libraries\\Util::mysqlDie(\n            $die['error'], $die['sql'], false, $err_url, $error\n        );\n    }\n}\n\nif ($go_sql) {\n\n    if (! empty($sql_data) && ($sql_data['valid_queries'] > 1)) {\n        $_SESSION['is_multi_query'] = true;\n        $sql_queries = $sql_data['valid_sql'];\n    } else {\n        $sql_queries = array($sql_query);\n    }\n\n    $html_output = '';\n    foreach ($sql_queries as $sql_query) {\n\n        // parse sql query\n        include_once 'libraries/parse_analyze.lib.php';\n        list(\n            $analyzed_sql_results,\n            $db,\n            $table\n        ) = PMA_parseAnalyze($sql_query, $db);\n        // @todo: possibly refactor\n        extract($analyzed_sql_results);\n\n        $html_output .= PMA_executeQueryAndGetQueryResponse(\n            $analyzed_sql_results, // analyzed_sql_results\n            false, // is_gotofile\n            $db, // db\n            $table, // table\n            null, // find_real_end\n            $_REQUEST['sql_query'], // sql_query_for_bookmark\n            null, // extra_data\n            null, // message_to_show\n            null, // message\n            null, // sql_data\n            $goto, // goto\n            $pmaThemeImage, // pmaThemeImage\n            null, // disp_query\n            null, // disp_message\n            null, // query_type\n            $sql_query, // sql_query\n            null, // selectedTables\n            null // complete_query\n        );\n    }\n\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->addJSON('ajax_reload', $ajax_reload);\n    $response->addHTML($html_output);\n    exit();\n\n} else if ($result) {\n    // Save a Bookmark with more than one queries (if Bookmark label given).\n    if (! empty($_POST['bkm_label']) && ! empty($import_text)) {\n        $cfgBookmark = PMA_Bookmark_getParams();\n        PMA_storeTheQueryAsBookmark(\n            $db, $cfgBookmark['user'],\n            $_REQUEST['sql_query'], $_POST['bkm_label'],\n            isset($_POST['bkm_replace']) ? $_POST['bkm_replace'] : null\n        );\n    }\n\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->setRequestStatus(true);\n    $response->addJSON('message', PMA\\libraries\\Message::success($msg));\n    $response->addJSON(\n        'sql_query',\n        PMA\\libraries\\Util::getMessage($msg, $sql_query, 'success')\n    );\n} else if ($result == false) {\n    $response = PMA\\libraries\\Response::getInstance();\n    $response->setRequestStatus(false);\n    $response->addJSON('message', PMA\\libraries\\Message::error($msg));\n} else {\n    $active_page = $goto;\n    include '' . $goto;\n}\n\n// If there is request for ROLLBACK in the end.\nif (isset($_REQUEST['rollback_query'])) {\n    $GLOBALS['dbi']->query('ROLLBACK');\n}\n", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Tracking changes on databases, tables and views\n *\n * @package PhpMyAdmin\n */\nnamespace PMA\\libraries;\n\nuse PMA\\libraries\\plugins\\export\\ExportSql;\n\n/**\n * This class tracks changes on databases, tables and views.\n *\n * @package PhpMyAdmin\n *\n * @todo use stristr instead of strstr\n */\nclass Tracker\n{\n    /**\n     * Whether tracking is ready.\n     */\n    static protected $enabled = false;\n\n    /**\n     * Actually enables tracking. This needs to be done after all\n     * underlaying code is initialized.\n     *\n     * @static\n     *\n     * @return void\n     */\n    static public function enable()\n    {\n        self::$enabled = true;\n    }\n\n    /**\n     * Gets the on/off value of the Tracker module, starts initialization.\n     *\n     * @static\n     *\n     * @return boolean (true=on|false=off)\n     */\n    static public function isActive()\n    {\n        if (! self::$enabled) {\n            return false;\n        }\n        /* We need to avoid attempt to track any queries\n         * from PMA_getRelationsParam\n         */\n        self::$enabled = false;\n        $cfgRelation = PMA_getRelationsParam();\n        /* Restore original state */\n        self::$enabled = true;\n        if (! $cfgRelation['trackingwork']) {\n            return false;\n        }\n\n        $pma_table = self::_getTrackingTable();\n        if (isset($pma_table)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Parses the name of a table from a SQL statement substring.\n     *\n     * @param string $string part of SQL statement\n     *\n     * @static\n     *\n     * @return string the name of table\n     */\n    static protected function getTableName($string)\n    {\n        if (mb_strstr($string, '.')) {\n            $temp = explode('.', $string);\n            $tablename = $temp[1];\n        } else {\n            $tablename = $string;\n        }\n\n        $str = explode(\"\\n\", $tablename);\n        $tablename = $str[0];\n\n        $tablename = str_replace(';', '', $tablename);\n        $tablename = str_replace('`', '', $tablename);\n        $tablename = trim($tablename);\n\n        return $tablename;\n    }\n\n\n    /**\n     * Gets the tracking status of a table, is it active or deactive ?\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     *\n     * @static\n     *\n     * @return boolean true or false\n     */\n    static public function isTracked($dbname, $tablename)\n    {\n        if (! self::$enabled) {\n            return false;\n        }\n        /* We need to avoid attempt to track any queries\n         * from PMA_getRelationsParam\n         */\n        self::$enabled = false;\n        $cfgRelation = PMA_getRelationsParam();\n        /* Restore original state */\n        self::$enabled = true;\n        if (! $cfgRelation['trackingwork']) {\n            return false;\n        }\n\n        $sql_query = \" SELECT tracking_active FROM \" . self::_getTrackingTable() .\n        \" WHERE db_name = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND table_name = '\" . Util::sqlAddSlashes($tablename) . \"' \" .\n        \" ORDER BY version DESC\";\n\n        $row = $GLOBALS['dbi']->fetchArray(PMA_queryAsControlUser($sql_query));\n\n        if (isset($row['tracking_active']) && $row['tracking_active'] == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Returns the comment line for the log.\n     *\n     * @return string Comment, contains date and username\n     */\n    static public function getLogComment()\n    {\n        $date = date('Y-m-d H:i:s');\n\n        return \"# log \" . $date . \" \" . $GLOBALS['cfg']['Server']['user'] . \"\\n\";\n    }\n\n    /**\n     * Creates tracking version of a table / view\n     * (in other words: create a job to track future changes on the table).\n     *\n     * @param string $dbname       name of database\n     * @param string $tablename    name of table\n     * @param string $version      version\n     * @param string $tracking_set set of tracking statements\n     * @param bool   $is_view      if table is a view\n     *\n     * @static\n     *\n     * @return int result of version insertion\n     */\n    static public function createVersion($dbname, $tablename, $version,\n        $tracking_set = '', $is_view = false\n    ) {\n        global $sql_backquotes, $export_type;\n\n        if ($tracking_set == '') {\n            $tracking_set\n                = $GLOBALS['cfg']['Server']['tracking_default_statements'];\n        }\n\n        // get Export SQL instance\n        include_once \"libraries/plugin_interface.lib.php\";\n        /* @var $export_sql_plugin \\PMA\\libraries\\plugins\\export\\ExportSql */\n        $export_sql_plugin = PMA_getPlugin(\n            \"export\",\n            \"sql\",\n            'libraries/plugins/export/',\n            array(\n                'export_type' => $export_type,\n                'single_table' => false,\n            )\n        );\n\n        $sql_backquotes = true;\n\n        $date = date('Y-m-d H:i:s');\n\n        // Get data definition snapshot of table\n\n        $columns = $GLOBALS['dbi']->getColumns($dbname, $tablename, null, true);\n        // int indices to reduce size\n        $columns = array_values($columns);\n        // remove Privileges to reduce size\n        for ($i = 0, $nb = count($columns); $i < $nb; $i++) {\n            unset($columns[$i]['Privileges']);\n        }\n\n        $indexes = $GLOBALS['dbi']->getTableIndexes($dbname, $tablename);\n\n        $snapshot = array('COLUMNS' => $columns, 'INDEXES' => $indexes);\n        $snapshot = serialize($snapshot);\n\n        // Get DROP TABLE / DROP VIEW and CREATE TABLE SQL statements\n        $sql_backquotes = true;\n\n        $create_sql  = \"\";\n\n        if ($GLOBALS['cfg']['Server']['tracking_add_drop_table'] == true\n            && $is_view == false\n        ) {\n            $create_sql .= self::getLogComment()\n                . 'DROP TABLE IF EXISTS ' . Util::backquote($tablename) . \";\\n\";\n\n        }\n\n        if ($GLOBALS['cfg']['Server']['tracking_add_drop_view'] == true\n            && $is_view == true\n        ) {\n            $create_sql .= self::getLogComment()\n                . 'DROP VIEW IF EXISTS ' . Util::backquote($tablename) . \";\\n\";\n        }\n\n        $create_sql .= self::getLogComment() .\n            $export_sql_plugin->getTableDef($dbname, $tablename, \"\\n\", \"\");\n\n        // Save version\n\n        $sql_query = \"/*NOTRACK*/\\n\" .\n        \"INSERT INTO \" . self::_getTrackingTable() . \" (\" .\n        \"db_name, \" .\n        \"table_name, \" .\n        \"version, \" .\n        \"date_created, \" .\n        \"date_updated, \" .\n        \"schema_snapshot, \" .\n        \"schema_sql, \" .\n        \"data_sql, \" .\n        \"tracking \" .\n        \") \" .\n        \"values (\n        '\" . Util::sqlAddSlashes($dbname) . \"',\n        '\" . Util::sqlAddSlashes($tablename) . \"',\n        '\" . Util::sqlAddSlashes($version) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes($snapshot) . \"',\n        '\" . Util::sqlAddSlashes($create_sql) . \"',\n        '\" . Util::sqlAddSlashes(\"\\n\") . \"',\n        '\" . Util::sqlAddSlashes($tracking_set)\n        . \"' )\";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        if ($result) {\n            // Deactivate previous version\n            self::deactivateTracking($dbname, $tablename, ($version - 1));\n        }\n\n        return $result;\n    }\n\n\n    /**\n     * Removes all tracking data for a table or a version of a table\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version\n     *\n     * @static\n     *\n     * @return int result of version insertion\n     */\n    static public function deleteTracking($dbname, $tablename, $version = '')\n    {\n        $sql_query = \"/*NOTRACK*/\\n\"\n            . \"DELETE FROM \" . self::_getTrackingTable()\n            . \" WHERE `db_name` = '\"\n            . Util::sqlAddSlashes($dbname) . \"'\"\n            . \" AND `table_name` = '\"\n            . Util::sqlAddSlashes($tablename) . \"'\";\n        if ($version) {\n            $sql_query .= \" AND `version` = '\"\n                . Util::sqlAddSlashes($version) . \"'\";\n        }\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return $result;\n    }\n\n    /**\n     * Creates tracking version of a database\n     * (in other words: create a job to track future changes on the database).\n     *\n     * @param string $dbname       name of database\n     * @param string $version      version\n     * @param string $query        query\n     * @param string $tracking_set set of tracking statements\n     *\n     * @static\n     *\n     * @return int result of version insertion\n     */\n    static public function createDatabaseVersion($dbname, $version, $query,\n        $tracking_set = 'CREATE DATABASE,ALTER DATABASE,DROP DATABASE'\n    ) {\n        $date = date('Y-m-d H:i:s');\n\n        if ($tracking_set == '') {\n            $tracking_set\n                = $GLOBALS['cfg']['Server']['tracking_default_statements'];\n        }\n\n        $create_sql  = \"\";\n\n        if ($GLOBALS['cfg']['Server']['tracking_add_drop_database'] == true) {\n            $create_sql .= self::getLogComment()\n                . 'DROP DATABASE IF EXISTS ' . Util::backquote($dbname) . \";\\n\";\n        }\n\n        $create_sql .= self::getLogComment() . $query;\n\n        // Save version\n        $sql_query = \"/*NOTRACK*/\\n\" .\n        \"INSERT INTO \" . self::_getTrackingTable() . \" (\" .\n        \"db_name, \" .\n        \"table_name, \" .\n        \"version, \" .\n        \"date_created, \" .\n        \"date_updated, \" .\n        \"schema_snapshot, \" .\n        \"schema_sql, \" .\n        \"data_sql, \" .\n        \"tracking \" .\n        \") \" .\n        \"values (\n        '\" . Util::sqlAddSlashes($dbname) . \"',\n        '\" . Util::sqlAddSlashes('') . \"',\n        '\" . Util::sqlAddSlashes($version) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes($date) . \"',\n        '\" . Util::sqlAddSlashes('') . \"',\n        '\" . Util::sqlAddSlashes($create_sql) . \"',\n        '\" . Util::sqlAddSlashes(\"\\n\") . \"',\n        '\" . Util::sqlAddSlashes($tracking_set)\n        . \"' )\";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return $result;\n    }\n\n\n\n    /**\n     * Changes tracking of a table.\n     *\n     * @param string  $dbname    name of database\n     * @param string  $tablename name of table\n     * @param string  $version   version\n     * @param integer $new_state the new state of tracking\n     *\n     * @static\n     *\n     * @return int result of SQL query\n     */\n    static private function _changeTracking($dbname, $tablename,\n        $version, $new_state\n    ) {\n\n        $sql_query = \" UPDATE \" . self::_getTrackingTable() .\n        \" SET `tracking_active` = '\" . $new_state . \"' \" .\n        \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND `table_name` = '\" . Util::sqlAddSlashes($tablename) . \"' \" .\n        \" AND `version` = '\" . Util::sqlAddSlashes($version) . \"' \";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return $result;\n    }\n\n    /**\n     * Changes tracking data of a table.\n     *\n     * @param string       $dbname    name of database\n     * @param string       $tablename name of table\n     * @param string       $version   version\n     * @param string       $type      type of data(DDL || DML)\n     * @param string|array $new_data  the new tracking data\n     *\n     * @static\n     *\n     * @return bool result of change\n     */\n    static public function changeTrackingData($dbname, $tablename,\n        $version, $type, $new_data\n    ) {\n        if ($type == 'DDL') {\n            $save_to = 'schema_sql';\n        } elseif ($type == 'DML') {\n            $save_to = 'data_sql';\n        } else {\n            return false;\n        }\n        $date  = date('Y-m-d H:i:s');\n\n        $new_data_processed = '';\n        if (is_array($new_data)) {\n            foreach ($new_data as $data) {\n                $new_data_processed .= '# log ' . $date . ' ' . $data['username']\n                    . Util::sqlAddSlashes($data['statement']) . \"\\n\";\n            }\n        } else {\n            $new_data_processed = $new_data;\n        }\n\n        $sql_query = \" UPDATE \" . self::_getTrackingTable() .\n        \" SET `\" . $save_to . \"` = '\" . $new_data_processed . \"' \" .\n        \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND `table_name` = '\" . Util::sqlAddSlashes($tablename) . \"' \" .\n        \" AND `version` = '\" . Util::sqlAddSlashes($version) . \"' \";\n\n        $result = PMA_queryAsControlUser($sql_query);\n\n        return (boolean) $result;\n    }\n\n    /**\n     * Activates tracking of a table.\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version\n     *\n     * @static\n     *\n     * @return int result of SQL query\n     */\n    static public function activateTracking($dbname, $tablename, $version)\n    {\n        return self::_changeTracking($dbname, $tablename, $version, 1);\n    }\n\n\n    /**\n     * Deactivates tracking of a table.\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version\n     *\n     * @static\n     *\n     * @return int result of SQL query\n     */\n    static public function deactivateTracking($dbname, $tablename, $version)\n    {\n        return self::_changeTracking($dbname, $tablename, $version, 0);\n    }\n\n\n    /**\n     * Gets the newest version of a tracking job\n     * (in other words: gets the HEAD version).\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $statement tracked statement\n     *\n     * @static\n     *\n     * @return int (-1 if no version exists | >  0 if a version exists)\n     */\n    static public function getVersion($dbname, $tablename, $statement = null)\n    {\n        $sql_query = \" SELECT MAX(version) FROM \" . self::_getTrackingTable() .\n        \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n        \" AND `table_name` = '\" . Util::sqlAddSlashes($tablename) . \"' \";\n\n        if ($statement != \"\") {\n            $sql_query .= \" AND FIND_IN_SET('\"\n                . $statement . \"',tracking) > 0\" ;\n        }\n        $row = $GLOBALS['dbi']->fetchArray(PMA_queryAsControlUser($sql_query));\n        return isset($row[0])\n            ? $row[0]\n            : -1;\n    }\n\n\n    /**\n     * Gets the record of a tracking job.\n     *\n     * @param string $dbname    name of database\n     * @param string $tablename name of table\n     * @param string $version   version number\n     *\n     * @static\n     *\n     * @return mixed record DDM log, DDL log, structure snapshot, tracked\n     *         statements.\n     */\n    static public function getTrackedData($dbname, $tablename, $version)\n    {\n        $sql_query = \" SELECT * FROM \" . self::_getTrackingTable() .\n            \" WHERE `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \";\n        if (! empty($tablename)) {\n            $sql_query .= \" AND `table_name` = '\"\n                . Util::sqlAddSlashes($tablename) . \"' \";\n        }\n        $sql_query .= \" AND `version` = '\" . Util::sqlAddSlashes($version)\n            . \"' \" . \" ORDER BY `version` DESC LIMIT 1\";\n\n        $mixed = $GLOBALS['dbi']->fetchAssoc(PMA_queryAsControlUser($sql_query));\n\n        // Parse log\n        $log_schema_entries = explode('# log ',  $mixed['schema_sql']);\n        $log_data_entries   = explode('# log ',  $mixed['data_sql']);\n\n        $ddl_date_from = $date = date('Y-m-d H:i:s');\n\n        $ddlog = array();\n        $first_iteration = true;\n\n        // Iterate tracked data definition statements\n        // For each log entry we want to get date, username and statement\n        foreach ($log_schema_entries as $log_entry) {\n            if (trim($log_entry) != '') {\n                $date      = mb_substr($log_entry, 0, 19);\n                $username  = mb_substr(\n                    $log_entry, 20, mb_strpos($log_entry, \"\\n\") - 20\n                );\n                if ($first_iteration) {\n                    $ddl_date_from = $date;\n                    $first_iteration = false;\n                }\n                $statement = rtrim(mb_strstr($log_entry, \"\\n\"));\n\n                $ddlog[] = array( 'date' => $date,\n                                  'username'=> $username,\n                                  'statement' => $statement );\n            }\n        }\n\n        $date_from = $ddl_date_from;\n        $ddl_date_to = $date;\n\n        $dml_date_from = $date_from;\n\n        $dmlog = array();\n        $first_iteration = true;\n\n        // Iterate tracked data manipulation statements\n        // For each log entry we want to get date, username and statement\n        foreach ($log_data_entries as $log_entry) {\n            if (trim($log_entry) != '') {\n                $date      = mb_substr($log_entry, 0, 19);\n                $username  = mb_substr(\n                    $log_entry, 20, mb_strpos($log_entry, \"\\n\") - 20\n                );\n                if ($first_iteration) {\n                    $dml_date_from = $date;\n                    $first_iteration = false;\n                }\n                $statement = rtrim(mb_strstr($log_entry, \"\\n\"));\n\n                $dmlog[] = array( 'date' => $date,\n                                  'username' => $username,\n                                  'statement' => $statement );\n            }\n        }\n\n        $dml_date_to = $date;\n\n        // Define begin and end of date range for both logs\n        $data = array();\n        if (strtotime($ddl_date_from) <= strtotime($dml_date_from)) {\n            $data['date_from'] = $ddl_date_from;\n        } else {\n            $data['date_from'] = $dml_date_from;\n        }\n        if (strtotime($ddl_date_to) >= strtotime($dml_date_to)) {\n            $data['date_to'] = $ddl_date_to;\n        } else {\n            $data['date_to'] = $dml_date_to;\n        }\n        $data['ddlog']           = $ddlog;\n        $data['dmlog']           = $dmlog;\n        $data['tracking']        = $mixed['tracking'];\n        $data['schema_snapshot'] = $mixed['schema_snapshot'];\n\n        return $data;\n    }\n\n\n    /**\n     * Parses a query. Gets\n     *  - statement identifier (UPDATE, ALTER TABLE, ...)\n     *  - type of statement, is it part of DDL or DML ?\n     *  - tablename\n     *\n     * @param string $query query\n     *\n     * @static\n     * @todo: using PMA SQL Parser when possible\n     * @todo: support multi-table/view drops\n     *\n     * @return mixed Array containing identifier, type and tablename.\n     *\n     */\n    static public function parseQuery($query)\n    {\n        // Usage of PMA_SQP does not work here\n        //\n        // require_once(\"libraries/sqlparser.lib.php\");\n        // $parsed_sql = PMA_SQP_parse($query);\n        // $sql_info = PMA_SQP_analyze($parsed_sql);\n\n        $query = str_replace(\"\\n\", \" \", $query);\n        $query = str_replace(\"\\r\", \" \", $query);\n\n        $query = trim($query);\n        $query = trim($query, ' -');\n\n        $tokens = explode(\" \", $query);\n        foreach ($tokens as $key => $value) {\n            $tokens[$key] = mb_strtoupper($value);\n        }\n\n        // Parse USE statement, need it for SQL dump imports\n        if (mb_substr($query, 0, 4) == 'USE ') {\n            $prefix = explode('USE ', $query);\n            $GLOBALS['db'] = self::getTableName($prefix[1]);\n        }\n\n        /*\n         * DDL statements\n         */\n\n        $result         = array();\n        $result['type'] = 'DDL';\n\n        // Parse CREATE VIEW statement\n        if (in_array('CREATE', $tokens) == true\n            && in_array('VIEW', $tokens) == true\n            && in_array('AS', $tokens) == true\n        ) {\n            $result['identifier'] = 'CREATE VIEW';\n\n            $index = array_search('VIEW', $tokens);\n\n            $result['tablename'] = mb_strtolower(\n                self::getTableName($tokens[$index + 1])\n            );\n        }\n\n        // Parse ALTER VIEW statement\n        if (in_array('ALTER', $tokens) == true\n            && in_array('VIEW', $tokens) == true\n            && in_array('AS', $tokens) == true\n            && ! isset($result['identifier'])\n        ) {\n            $result['identifier'] = 'ALTER VIEW';\n\n            $index = array_search('VIEW', $tokens);\n\n            $result['tablename'] = mb_strtolower(\n                self::getTableName($tokens[$index + 1])\n            );\n        }\n\n        // Parse DROP VIEW statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 10) == 'DROP VIEW '\n        ) {\n            $result['identifier'] = 'DROP VIEW';\n\n            $prefix  = explode('DROP VIEW ', $query);\n            $str = str_replace('IF EXISTS', '', $prefix[1]);\n            $result['tablename'] = self::getTableName($str);\n        }\n\n        // Parse CREATE DATABASE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 15) == 'CREATE DATABASE'\n        ) {\n            $result['identifier'] = 'CREATE DATABASE';\n            $str = str_replace('CREATE DATABASE', '', $query);\n            $str = str_replace('IF NOT EXISTS', '', $str);\n\n            $prefix = explode('DEFAULT ', $str);\n\n            $result['tablename'] = '';\n            $GLOBALS['db'] = self::getTableName($prefix[0]);\n        }\n\n        // Parse ALTER DATABASE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 14) == 'ALTER DATABASE'\n        ) {\n            $result['identifier'] = 'ALTER DATABASE';\n            $result['tablename'] = '';\n        }\n\n        // Parse DROP DATABASE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 13) == 'DROP DATABASE'\n        ) {\n            $result['identifier'] = 'DROP DATABASE';\n            $str = str_replace('DROP DATABASE', '', $query);\n            $str = str_replace('IF EXISTS', '', $str);\n            $GLOBALS['db'] = self::getTableName($str);\n            $result['tablename'] = '';\n        }\n\n        // Parse CREATE TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 12) == 'CREATE TABLE'\n        ) {\n            $result['identifier'] = 'CREATE TABLE';\n            $query   = str_replace('IF NOT EXISTS', '', $query);\n            $prefix  = explode('CREATE TABLE ', $query);\n            $suffix  = explode('(', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse ALTER TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 12) == 'ALTER TABLE '\n        ) {\n            $result['identifier'] = 'ALTER TABLE';\n\n            $prefix  = explode('ALTER TABLE ', $query);\n            $suffix  = explode(' ', $prefix[1]);\n            $result['tablename']  = self::getTableName($suffix[0]);\n        }\n\n        // Parse DROP TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 11) == 'DROP TABLE '\n        ) {\n            $result['identifier'] = 'DROP TABLE';\n\n            $prefix  = explode('DROP TABLE ', $query);\n            $str = str_replace('IF EXISTS', '', $prefix[1]);\n            $result['tablename'] = self::getTableName($str);\n        }\n\n        // Parse CREATE INDEX statement\n        if (! isset($result['identifier'])\n            && (substr($query, 0, 12) == 'CREATE INDEX'\n            || substr($query, 0, 19) == 'CREATE UNIQUE INDEX'\n            || substr($query, 0, 20) == 'CREATE SPATIAL INDEX')\n        ) {\n             $result['identifier'] = 'CREATE INDEX';\n             $prefix = explode('ON ', $query);\n             $suffix = explode('(', $prefix[1]);\n             $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse DROP INDEX statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 10) == 'DROP INDEX'\n        ) {\n             $result['identifier'] = 'DROP INDEX';\n             $prefix = explode('ON ', $query);\n             $result['tablename'] = self::getTableName($prefix[1]);\n        }\n\n        // Parse RENAME TABLE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 13) == 'RENAME TABLE '\n        ) {\n            $result['identifier'] = 'RENAME TABLE';\n            $prefix = explode('RENAME TABLE ', $query);\n            $names  = explode(' TO ', $prefix[1]);\n            $result['tablename']      = self::getTableName($names[0]);\n            $result[\"tablename_after_rename\"]  = self::getTableName($names[1]);\n        }\n\n        /*\n         * DML statements\n         */\n\n        if (! isset($result['identifier'])) {\n            $result[\"type\"]       = 'DML';\n        }\n        // Parse UPDATE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 6) == 'UPDATE'\n        ) {\n            $result['identifier'] = 'UPDATE';\n            $prefix  = explode('UPDATE ', $query);\n            $suffix  = explode(' ', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse INSERT INTO statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 11) == 'INSERT INTO'\n        ) {\n            $result['identifier'] = 'INSERT';\n            $prefix  = explode('INSERT INTO', $query);\n            $suffix  = explode('(', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse DELETE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 6) == 'DELETE'\n        ) {\n            $result['identifier'] = 'DELETE';\n            $prefix  = explode('FROM ', $query);\n            $suffix  = explode(' ', $prefix[1]);\n            $result['tablename'] = self::getTableName($suffix[0]);\n        }\n\n        // Parse TRUNCATE statement\n        if (! isset($result['identifier'])\n            && substr($query, 0, 8) == 'TRUNCATE'\n        ) {\n            $result['identifier'] = 'TRUNCATE';\n            $prefix  = explode('TRUNCATE', $query);\n            $result['tablename'] = self::getTableName($prefix[1]);\n        }\n\n        return $result;\n    }\n\n\n    /**\n     * Analyzes a given SQL statement and saves tracking data.\n     *\n     * @param string $query a SQL query\n     *\n     * @static\n     *\n     * @return void\n     */\n    static public function handleQuery($query)\n    {\n        // If query is marked as untouchable, leave\n        if (mb_strstr($query, \"/*NOTRACK*/\")) {\n            return;\n        }\n\n        if (! (substr($query, -1) == ';')) {\n            $query = $query . \";\\n\";\n        }\n        // Get some information about query\n        $result = self::parseQuery($query);\n\n        // Get database name\n        $dbname = trim(isset($GLOBALS['db']) ? $GLOBALS['db'] : '', '`');\n        // $dbname can be empty, for example when coming from Synchronize\n        // and this is a query for the remote server\n        if (empty($dbname)) {\n            return;\n        }\n\n        // If we found a valid statement\n        if (isset($result['identifier'])) {\n            $version = self::getVersion(\n                $dbname, $result['tablename'], $result['identifier']\n            );\n\n            // If version not exists and auto-creation is enabled\n            if ($GLOBALS['cfg']['Server']['tracking_version_auto_create'] == true\n                && self::isTracked($dbname, $result['tablename']) == false\n                && $version == -1\n            ) {\n                // Create the version\n\n                switch ($result['identifier']) {\n                case 'CREATE TABLE':\n                    self::createVersion($dbname, $result['tablename'], '1');\n                    break;\n                case 'CREATE VIEW':\n                    self::createVersion(\n                        $dbname, $result['tablename'], '1', '', true\n                    );\n                    break;\n                case 'CREATE DATABASE':\n                    self::createDatabaseVersion($dbname, '1', $query);\n                    break;\n                } // end switch\n            }\n\n            // If version exists\n            if (self::isTracked($dbname, $result['tablename']) && $version != -1) {\n                if ($result['type'] == 'DDL') {\n                    $save_to = 'schema_sql';\n                } elseif ($result['type'] == 'DML') {\n                    $save_to = 'data_sql';\n                } else {\n                    $save_to = '';\n                }\n                $date  = date('Y-m-d H:i:s');\n\n                // Cut off `dbname`. from query\n                $query = preg_replace(\n                    '/`' . preg_quote($dbname, '/') . '`\\s?\\./',\n                    '',\n                    $query\n                );\n\n                // Add log information\n                $query = self::getLogComment() . $query ;\n\n                // Mark it as untouchable\n                $sql_query = \" /*NOTRACK*/\\n\"\n                    . \" UPDATE \" . self::_getTrackingTable()\n                    . \" SET \" . Util::backquote($save_to)\n                    . \" = CONCAT( \" . Util::backquote($save_to) . \",'\\n\"\n                    . Util::sqlAddSlashes($query) . \"') ,\"\n                    . \" `date_updated` = '\" . $date . \"' \";\n\n                // If table was renamed we have to change\n                // the tablename attribute in pma_tracking too\n                if ($result['identifier'] == 'RENAME TABLE') {\n                    $sql_query .= ', `table_name` = \\''\n                        . Util::sqlAddSlashes($result['tablename_after_rename'])\n                        . '\\' ';\n                }\n\n                // Save the tracking information only for\n                //     1. the database\n                //     2. the table / view\n                //     3. the statements\n                // we want to track\n                $sql_query .=\n                \" WHERE FIND_IN_SET('\" . $result['identifier'] . \"',tracking) > 0\" .\n                \" AND `db_name` = '\" . Util::sqlAddSlashes($dbname) . \"' \" .\n                \" AND `table_name` = '\"\n                . Util::sqlAddSlashes($result['tablename']) . \"' \" .\n                \" AND `version` = '\" . Util::sqlAddSlashes($version) . \"' \";\n\n                PMA_queryAsControlUser($sql_query);\n            }\n        }\n    }\n\n    /**\n     * Returns the tracking table\n     *\n     * @return string tracking table\n     */\n    private static function _getTrackingTable()\n    {\n        $cfgRelation = PMA_getRelationsParam();\n        return Util::backquote($cfgRelation['db'])\n            . '.' . Util::backquote($cfgRelation['tracking']);\n    }\n}\n", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * Set of functions used to build SQL dumps of tables\n *\n * @package    PhpMyAdmin-Export\n * @subpackage SQL\n */\nnamespace PMA\\libraries\\plugins\\export;\n\nuse PMA\\libraries\\properties\\options\\items\\BoolPropertyItem;\nuse PMA\\libraries\\properties\\plugins\\ExportPluginProperties;\nuse PMA\\libraries\\properties\\options\\items\\MessageOnlyPropertyItem;\nuse PMA\\libraries\\properties\\options\\items\\NumberPropertyItem;\nuse PMA\\libraries\\properties\\options\\groups\\OptionsPropertyMainGroup;\nuse PMA\\libraries\\properties\\options\\groups\\OptionsPropertyRootGroup;\nuse PMA\\libraries\\properties\\options\\groups\\OptionsPropertySubgroup;\nuse PMA\\libraries\\DatabaseInterface;\nuse PMA\\libraries\\plugins\\ExportPlugin;\nuse PMA\\libraries\\Util;\nuse PMA\\libraries\\properties\\options\\items\\RadioPropertyItem;\nuse PMA\\libraries\\properties\\options\\items\\SelectPropertyItem;\nuse SqlParser\\Components\\CreateDefinition;\nuse SqlParser\\Context;\nuse SqlParser\\Parser;\nuse SqlParser\\Statements\\SelectStatement;\nuse SqlParser\\Token;\nuse PMA\\libraries\\properties\\options\\items\\TextPropertyItem;\n\n/**\n * Handles the export for the SQL class\n *\n * @package    PhpMyAdmin-Export\n * @subpackage SQL\n */\nclass ExportSql extends ExportPlugin\n{\n    /**\n     * Whether charset header was sent.\n     *\n     * @var boolean\n     */\n    private $_sent_charset = false;\n\n    /**\n     * Constructor\n     */\n    public function __construct()\n    {\n        $this->setProperties();\n\n        // Avoids undefined variables, use NULL so isset() returns false\n        if (!isset($GLOBALS['sql_backquotes'])) {\n            $GLOBALS['sql_backquotes'] = null;\n        }\n    }\n\n    /**\n     * Sets the export SQL properties\n     *\n     * @return void\n     */\n    protected function setProperties()\n    {\n        global $plugin_param;\n\n        $hide_sql = false;\n        $hide_structure = false;\n        if ($plugin_param['export_type'] == 'table'\n            && !$plugin_param['single_table']\n        ) {\n            $hide_structure = true;\n            $hide_sql = true;\n        }\n\n        if (!$hide_sql) {\n            $exportPluginProperties = new ExportPluginProperties();\n            $exportPluginProperties->setText('SQL');\n            $exportPluginProperties->setExtension('sql');\n            $exportPluginProperties->setMimeType('text/x-sql');\n            $exportPluginProperties->setOptionsText(__('Options'));\n\n            // create the root group that will be the options field for\n            // $exportPluginProperties\n            // this will be shown as \"Format specific options\"\n            $exportSpecificOptions = new OptionsPropertyRootGroup(\n                \"Format Specific Options\"\n            );\n\n            // general options main group\n            $generalOptions = new OptionsPropertyMainGroup(\"general_opts\");\n\n            // comments\n            $subgroup = new OptionsPropertySubgroup(\"include_comments\");\n            $leaf = new BoolPropertyItem(\n                'include_comments',\n                __(\n                    'Display comments <i>(includes info such as export'\n                    . ' timestamp, PHP version, and server version)</i>'\n                )\n            );\n            $subgroup->setSubgroupHeader($leaf);\n\n            $leaf = new TextPropertyItem(\n                'header_comment',\n                __('Additional custom header comment (\\n splits lines):')\n            );\n            $subgroup->addProperty($leaf);\n            $leaf = new BoolPropertyItem(\n                'dates',\n                __(\n                    'Include a timestamp of when databases were created, last'\n                    . ' updated, and last checked'\n                )\n            );\n            $subgroup->addProperty($leaf);\n            if (!empty($GLOBALS['cfgRelation']['relation'])) {\n                $leaf = new BoolPropertyItem(\n                    'relation',\n                    __('Display foreign key relationships')\n                );\n                $subgroup->addProperty($leaf);\n            }\n            if (!empty($GLOBALS['cfgRelation']['mimework'])) {\n                $leaf = new BoolPropertyItem(\n                    'mime',\n                    __('Display MIME types')\n                );\n                $subgroup->addProperty($leaf);\n            }\n            $generalOptions->addProperty($subgroup);\n\n            // enclose in a transaction\n            $leaf = new BoolPropertyItem(\n                \"use_transaction\",\n                __('Enclose export in a transaction')\n            );\n            $leaf->setDoc(\n                array(\n                    'programs',\n                    'mysqldump',\n                    'option_mysqldump_single-transaction',\n                )\n            );\n            $generalOptions->addProperty($leaf);\n\n            // disable foreign key checks\n            $leaf = new BoolPropertyItem(\n                \"disable_fk\",\n                __('Disable foreign key checks')\n            );\n            $leaf->setDoc(\n                array(\n                    'manual_MySQL_Database_Administration',\n                    'server-system-variables',\n                    'sysvar_foreign_key_checks',\n                )\n            );\n            $generalOptions->addProperty($leaf);\n\n            // export views as tables\n            $leaf = new BoolPropertyItem(\n                \"views_as_tables\",\n                __('Export views as tables')\n            );\n            $generalOptions->addProperty($leaf);\n\n            // export metadata\n            $leaf = new BoolPropertyItem(\n                \"metadata\",\n                __('Export metadata')\n            );\n            $generalOptions->addProperty($leaf);\n\n            // compatibility maximization\n            $compats = $GLOBALS['dbi']->getCompatibilities();\n            if (count($compats) > 0) {\n                $values = array();\n                foreach ($compats as $val) {\n                    $values[$val] = $val;\n                }\n\n                $leaf = new SelectPropertyItem(\n                    \"compatibility\",\n                    __(\n                        'Database system or older MySQL server to maximize output'\n                        . ' compatibility with:'\n                    )\n                );\n                $leaf->setValues($values);\n                $leaf->setDoc(\n                    array(\n                        'manual_MySQL_Database_Administration',\n                        'Server_SQL_mode',\n                    )\n                );\n                $generalOptions->addProperty($leaf);\n\n                unset($values);\n            }\n\n            // what to dump (structure/data/both)\n            $subgroup = new OptionsPropertySubgroup(\n                \"dump_table\", __(\"Dump table\")\n            );\n            $leaf = new RadioPropertyItem('structure_or_data');\n            $leaf->setValues(\n                array(\n                    'structure'          => __('structure'),\n                    'data'               => __('data'),\n                    'structure_and_data' => __('structure and data'),\n                )\n            );\n            $subgroup->setSubgroupHeader($leaf);\n            $generalOptions->addProperty($subgroup);\n\n            // add the main group to the root group\n            $exportSpecificOptions->addProperty($generalOptions);\n\n            // structure options main group\n            if (!$hide_structure) {\n                $structureOptions = new OptionsPropertyMainGroup(\n                    \"structure\", __('Object creation options')\n                );\n                $structureOptions->setForce('data');\n\n                // begin SQL Statements\n                $subgroup = new OptionsPropertySubgroup();\n                $leaf = new MessageOnlyPropertyItem(\n                    'add_statements',\n                    __('Add statements:')\n                );\n                $subgroup->setSubgroupHeader($leaf);\n\n                // server export options\n                if ($plugin_param['export_type'] == 'server') {\n                    $leaf = new BoolPropertyItem(\n                        \"drop_database\",\n                        sprintf(__('Add %s statement'), '<code>DROP DATABASE</code>')\n                    );\n                    $subgroup->addProperty($leaf);\n                }\n\n                if ($plugin_param['export_type'] == 'database') {\n                    $create_clause = '<code>CREATE DATABASE / USE</code>';\n                    $leaf = new BoolPropertyItem(\n                        'create_database',\n                        sprintf(__('Add %s statement'), $create_clause)\n                    );\n                    $subgroup->addProperty($leaf);\n                }\n\n                if ($plugin_param['export_type'] == 'table') {\n                    $drop_clause = $GLOBALS['dbi']->getTable(\n                        $GLOBALS['db'],\n                        $GLOBALS['table']\n                    )->isView()\n                        ? '<code>DROP VIEW</code>'\n                        : '<code>DROP TABLE</code>';\n                } else {\n                    $drop_clause = '<code>DROP TABLE / VIEW / PROCEDURE'\n                        . ' / FUNCTION / EVENT</code>';\n                }\n\n                $drop_clause .= '<code> / TRIGGER</code>';\n\n                $leaf = new BoolPropertyItem(\n                    'drop_table',\n                    sprintf(__('Add %s statement'), $drop_clause)\n                );\n                $subgroup->addProperty($leaf);\n\n                $subgroup_create_table = new OptionsPropertySubgroup();\n\n                // Add table structure option\n                $leaf = new BoolPropertyItem(\n                    'create_table',\n                    sprintf(__('Add %s statement'), '<code>CREATE TABLE</code>')\n                );\n                $subgroup_create_table->setSubgroupHeader($leaf);\n\n                $leaf = new BoolPropertyItem(\n                    'if_not_exists',\n                    '<code>IF NOT EXISTS</code> ' . __(\n                        '(less efficient as indexes will be generated during table '\n                        . 'creation)'\n                    )\n                );\n                $subgroup_create_table->addProperty($leaf);\n\n                $leaf = new BoolPropertyItem(\n                    'auto_increment',\n                    sprintf(__('%s value'), '<code>AUTO_INCREMENT</code>')\n                );\n                $subgroup_create_table->addProperty($leaf);\n\n                $subgroup->addProperty($subgroup_create_table);\n\n                // Add view option\n                $leaf = new BoolPropertyItem(\n                    'create_view',\n                    sprintf(__('Add %s statement'), '<code>CREATE VIEW</code>')\n                );\n                $subgroup->addProperty($leaf);\n\n                $leaf = new BoolPropertyItem(\n                    'procedure_function',\n                    sprintf(\n                        __('Add %s statement'),\n                        '<code>CREATE PROCEDURE / FUNCTION / EVENT</code>'\n                    )\n                );\n                $subgroup->addProperty($leaf);\n\n                // Add triggers option\n                $leaf = new BoolPropertyItem(\n                    'create_trigger',\n                    sprintf(__('Add %s statement'), '<code>CREATE TRIGGER</code>')\n                );\n                $subgroup->addProperty($leaf);\n\n                $structureOptions->addProperty($subgroup);\n\n                $leaf = new BoolPropertyItem(\n                    \"backquotes\",\n                    __(\n                        'Enclose table and column names with backquotes '\n                        . '<i>(Protects column and table names formed with'\n                        . ' special characters or keywords)</i>'\n                    )\n                );\n\n                $structureOptions->addProperty($leaf);\n\n                // add the main group to the root group\n                $exportSpecificOptions->addProperty($structureOptions);\n            }\n\n            // begin Data options\n            $dataOptions = new OptionsPropertyMainGroup(\n                \"data\", __('Data creation options')\n            );\n            $dataOptions->setForce('structure');\n            $leaf = new BoolPropertyItem(\n                \"truncate\",\n                __('Truncate table before insert')\n            );\n            $dataOptions->addProperty($leaf);\n\n            // begin SQL Statements\n            $subgroup = new OptionsPropertySubgroup();\n            $leaf = new MessageOnlyPropertyItem(\n                __('Instead of <code>INSERT</code> statements, use:')\n            );\n            $subgroup->setSubgroupHeader($leaf);\n\n            $leaf = new BoolPropertyItem(\n                \"delayed\",\n                __('<code>INSERT DELAYED</code> statements')\n            );\n            $leaf->setDoc(\n                array(\n                    'manual_MySQL_Database_Administration',\n                    'insert_delayed'\n                )\n            );\n            $subgroup->addProperty($leaf);\n\n            $leaf = new BoolPropertyItem(\n                \"ignore\",\n                __('<code>INSERT IGNORE</code> statements')\n            );\n            $leaf->setDoc(\n                array(\n                    'manual_MySQL_Database_Administration',\n                    'insert',\n                )\n            );\n            $subgroup->addProperty($leaf);\n            $dataOptions->addProperty($subgroup);\n\n            // Function to use when dumping dat\n            $leaf = new SelectPropertyItem(\n                \"type\",\n                __('Function to use when dumping data:')\n            );\n            $leaf->setValues(\n                array(\n                    'INSERT'  => 'INSERT',\n                    'UPDATE'  => 'UPDATE',\n                    'REPLACE' => 'REPLACE',\n                )\n            );\n            $dataOptions->addProperty($leaf);\n\n            /* Syntax to use when inserting data */\n            $subgroup = new OptionsPropertySubgroup();\n            $leaf = new MessageOnlyPropertyItem(\n                null,\n                __('Syntax to use when inserting data:')\n            );\n            $subgroup->setSubgroupHeader($leaf);\n            $leaf = new RadioPropertyItem(\n                \"insert_syntax\",\n                __('<code>INSERT IGNORE</code> statements')\n            );\n            $leaf->setValues(\n                array(\n                    'complete' => __(\n                        'include column names in every <code>INSERT</code> statement'\n                        . ' <br /> &nbsp; &nbsp; &nbsp; Example: <code>INSERT INTO'\n                        . ' tbl_name (col_A,col_B,col_C) VALUES (1,2,3)</code>'\n                    ),\n                    'extended' => __(\n                        'insert multiple rows in every <code>INSERT</code> statement'\n                        . '<br /> &nbsp; &nbsp; &nbsp; Example: <code>INSERT INTO'\n                        . ' tbl_name VALUES (1,2,3), (4,5,6), (7,8,9)</code>'\n                    ),\n                    'both'     => __(\n                        'both of the above<br /> &nbsp; &nbsp; &nbsp; Example:'\n                        . ' <code>INSERT INTO tbl_name (col_A,col_B,col_C) VALUES'\n                        . ' (1,2,3), (4,5,6), (7,8,9)</code>'\n                    ),\n                    'none'     => __(\n                        'neither of the above<br /> &nbsp; &nbsp; &nbsp; Example:'\n                        . ' <code>INSERT INTO tbl_name VALUES (1,2,3)</code>'\n                    ),\n                )\n            );\n            $subgroup->addProperty($leaf);\n            $dataOptions->addProperty($subgroup);\n\n            // Max length of query\n            $leaf = new NumberPropertyItem(\n                \"max_query_size\",\n                __('Maximal length of created query')\n            );\n            $dataOptions->addProperty($leaf);\n\n            // Dump binary columns in hexadecimal\n            $leaf = new BoolPropertyItem(\n                \"hex_for_binary\",\n                __(\n                    'Dump binary columns in hexadecimal notation'\n                    . ' <i>(for example, \"abc\" becomes 0x616263)</i>'\n                )\n            );\n            $dataOptions->addProperty($leaf);\n\n            // Dump time in UTC\n            $leaf = new BoolPropertyItem(\n                \"utc_time\",\n                __(\n                    'Dump TIMESTAMP columns in UTC <i>(enables TIMESTAMP columns'\n                    . ' to be dumped and reloaded between servers in different'\n                    . ' time zones)</i>'\n                )\n            );\n            $dataOptions->addProperty($leaf);\n\n            // add the main group to the root group\n            $exportSpecificOptions->addProperty($dataOptions);\n\n            // set the options for the export plugin property item\n            $exportPluginProperties->setOptions($exportSpecificOptions);\n            $this->properties = $exportPluginProperties;\n        }\n    }\n\n    /**\n     * Generates SQL for routines export\n     *\n     * @param string $db        Database\n     * @param array  $aliases   Aliases of db/table/columns\n     * @param string $type      Type of exported routine\n     * @param string $name      Verbose name of exported routine\n     * @param array  $routines  List of routines to export\n     * @param string $delimiter Delimiter to use in SQL\n     *\n     * @return string SQL query\n     */\n    protected function _exportRoutineSQL(\n        $db, $aliases, $type, $name, $routines, $delimiter\n    ) {\n        global $crlf;\n\n        $text = $this->_exportComment()\n            . $this->_exportComment($name)\n            . $this->_exportComment();\n\n        $used_alias = false;\n        $proc_query = '';\n\n        foreach ($routines as $routine) {\n            if (!empty($GLOBALS['sql_drop_table'])) {\n                $proc_query .= 'DROP ' . $type . ' IF EXISTS '\n                    . Util::backquote($routine)\n                    . $delimiter . $crlf;\n            }\n            $create_query = $this->replaceWithAliases(\n                $GLOBALS['dbi']->getDefinition($db, $type, $routine),\n                $aliases,\n                $db,\n                '',\n                $flag\n            );\n            // One warning per database\n            if ($flag) {\n                $used_alias = true;\n            }\n            $proc_query .= $create_query . $delimiter . $crlf . $crlf;\n        }\n        if ($used_alias) {\n            $text .= $this->_exportComment(\n                __('It appears your database uses routines;')\n            )\n            . $this->_exportComment(\n                __('alias export may not work reliably in all cases.')\n            )\n            . $this->_exportComment();\n        }\n        $text .= $proc_query;\n\n        return $text;\n    }\n\n    /**\n     * Exports routines (procedures and functions)\n     *\n     * @param string $db      Database\n     * @param array  $aliases Aliases of db/table/columns\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportRoutines($db, $aliases = array())\n    {\n        global $crlf;\n\n        $db_alias = $db;\n        $this->initAlias($aliases, $db_alias);\n\n        $text = '';\n        $delimiter = '$$';\n\n        $procedure_names = $GLOBALS['dbi']\n            ->getProceduresOrFunctions($db, 'PROCEDURE');\n        $function_names = $GLOBALS['dbi']->getProceduresOrFunctions($db, 'FUNCTION');\n\n        if ($procedure_names || $function_names) {\n            $text .= $crlf\n                . 'DELIMITER ' . $delimiter . $crlf;\n\n            if ($procedure_names) {\n                $text .= $this->_exportRoutineSQL(\n                    $db,\n                    $aliases,\n                    'PROCEDURE',\n                    __('Procedures'),\n                    $procedure_names,\n                    $delimiter\n                );\n            }\n\n            if ($function_names) {\n                $text .= $this->_exportRoutineSQL(\n                    $db,\n                    $aliases,\n                    'FUNCTION',\n                    __('Functions'),\n                    $function_names,\n                    $delimiter\n                );\n            }\n\n            $text .= 'DELIMITER ;' . $crlf;\n        }\n\n        if (!empty($text)) {\n            return PMA_exportOutputHandler($text);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Possibly outputs comment\n     *\n     * @param string $text Text of comment\n     *\n     * @return string The formatted comment\n     */\n    private function _exportComment($text = '')\n    {\n        if (isset($GLOBALS['sql_include_comments'])\n            && $GLOBALS['sql_include_comments']\n        ) {\n            // see https://dev.mysql.com/doc/refman/5.0/en/ansi-diff-comments.html\n            return '--' . (empty($text) ? '' : ' ') . $text . $GLOBALS['crlf'];\n        } else {\n            return '';\n        }\n    }\n\n    /**\n     * Possibly outputs CRLF\n     *\n     * @return string $crlf or nothing\n     */\n    private function _possibleCRLF()\n    {\n        if (isset($GLOBALS['sql_include_comments'])\n            && $GLOBALS['sql_include_comments']\n        ) {\n            return $GLOBALS['crlf'];\n        } else {\n            return '';\n        }\n    }\n\n    /**\n     * Outputs export footer\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportFooter()\n    {\n        global $crlf, $mysql_charset_map;\n\n        $foot = '';\n\n        if (isset($GLOBALS['sql_disable_fk'])) {\n            $foot .= 'SET FOREIGN_KEY_CHECKS=1;' . $crlf;\n        }\n\n        if (isset($GLOBALS['sql_use_transaction'])) {\n            $foot .= 'COMMIT;' . $crlf;\n        }\n\n        // restore connection settings\n        if ($this->_sent_charset) {\n            $foot .= $crlf\n                . '/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;'\n                . $crlf\n                . '/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;'\n                . $crlf\n                . '/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;'\n                . $crlf;\n            $this->_sent_charset = false;\n        }\n\n        /* Restore timezone */\n        if (isset($GLOBALS['sql_utc_time']) && $GLOBALS['sql_utc_time']) {\n            $GLOBALS['dbi']->query('SET time_zone = \"' . $GLOBALS['old_tz'] . '\"');\n        }\n\n        return PMA_exportOutputHandler($foot);\n    }\n\n    /**\n     * Outputs export header. It is the first method to be called, so all\n     * the required variables are initialized here.\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportHeader()\n    {\n        global $crlf, $cfg;\n        global $mysql_charset_map;\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $tmp_compat = $GLOBALS['sql_compatibility'];\n            if ($tmp_compat == 'NONE') {\n                $tmp_compat = '';\n            }\n            $GLOBALS['dbi']->tryQuery('SET SQL_MODE=\"' . $tmp_compat . '\"');\n            unset($tmp_compat);\n        }\n        $head = $this->_exportComment('phpMyAdmin SQL Dump')\n            . $this->_exportComment('version ' . PMA_VERSION)\n            . $this->_exportComment('https://www.phpmyadmin.net/')\n            . $this->_exportComment();\n        $host_string = __('Host:') . ' ' . $cfg['Server']['host'];\n        if (!empty($cfg['Server']['port'])) {\n            $host_string .= ':' . $cfg['Server']['port'];\n        }\n        $head .= $this->_exportComment($host_string);\n        $head .= $this->_exportComment(\n            __('Generation Time:') . ' '\n            . Util::localisedDate()\n        )\n        . $this->_exportComment(\n            __('Server version:') . ' ' . PMA_MYSQL_STR_VERSION\n        )\n        . $this->_exportComment(__('PHP Version:') . ' ' . phpversion())\n        . $this->_possibleCRLF();\n\n        if (isset($GLOBALS['sql_header_comment'])\n            && !empty($GLOBALS['sql_header_comment'])\n        ) {\n            // '\\n' is not a newline (like \"\\n\" would be), it's the characters\n            // backslash and n, as explained on the export interface\n            $lines = explode('\\n', $GLOBALS['sql_header_comment']);\n            $head .= $this->_exportComment();\n            foreach ($lines as $one_line) {\n                $head .= $this->_exportComment($one_line);\n            }\n            $head .= $this->_exportComment();\n        }\n\n        if (isset($GLOBALS['sql_disable_fk'])) {\n            $head .= 'SET FOREIGN_KEY_CHECKS=0;' . $crlf;\n        }\n\n        // We want exported AUTO_INCREMENT columns to have still same value,\n        // do this only for recent MySQL exports\n        if ((! isset($GLOBALS['sql_compatibility'])\n            || $GLOBALS['sql_compatibility'] == 'NONE')\n        ) {\n            $head .= 'SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";' . $crlf;\n        }\n\n        if (isset($GLOBALS['sql_use_transaction'])) {\n            $head .= 'SET AUTOCOMMIT = 0;' . $crlf\n                . 'START TRANSACTION;' . $crlf;\n        }\n\n        /* Change timezone if we should export timestamps in UTC */\n        if (isset($GLOBALS['sql_utc_time']) && $GLOBALS['sql_utc_time']) {\n            $head .= 'SET time_zone = \"+00:00\";' . $crlf;\n            $GLOBALS['old_tz'] = $GLOBALS['dbi']\n                ->fetchValue('SELECT @@session.time_zone');\n            $GLOBALS['dbi']->query('SET time_zone = \"+00:00\"');\n        }\n\n        $head .= $this->_possibleCRLF();\n\n        if (! empty($GLOBALS['asfile'])) {\n            // we are saving as file, therefore we provide charset information\n            // so that a utility like the mysql client can interpret\n            // the file correctly\n            if (isset($GLOBALS['charset'])\n                && isset($mysql_charset_map[$GLOBALS['charset']])\n            ) {\n                // we got a charset from the export dialog\n                $set_names = $mysql_charset_map[$GLOBALS['charset']];\n            } else {\n                // by default we use the connection charset\n                $set_names = $mysql_charset_map['utf-8'];\n            }\n            if ($set_names == 'utf8' && PMA_MYSQL_INT_VERSION > 50503) {\n                $set_names = 'utf8mb4';\n            }\n            $head .= $crlf\n                . '/*!40101 SET @OLD_CHARACTER_SET_CLIENT='\n                . '@@CHARACTER_SET_CLIENT */;' . $crlf\n                . '/*!40101 SET @OLD_CHARACTER_SET_RESULTS='\n                . '@@CHARACTER_SET_RESULTS */;' . $crlf\n                . '/*!40101 SET @OLD_COLLATION_CONNECTION='\n                . '@@COLLATION_CONNECTION */;' . $crlf\n                . '/*!40101 SET NAMES ' . $set_names . ' */;' . $crlf . $crlf;\n            $this->_sent_charset = true;\n        }\n\n        return PMA_exportOutputHandler($head);\n    }\n\n    /**\n     * Outputs CREATE DATABASE statement\n     *\n     * @param string $db          Database name\n     * @param string $export_type 'server', 'database', 'table'\n     * @param string $db_alias    Aliases of db\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportDBCreate($db, $export_type, $db_alias = '')\n    {\n        global $crlf;\n\n        if (empty($db_alias)) {\n            $db_alias = $db;\n        }\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n        if (isset($GLOBALS['sql_drop_database'])) {\n            if (!PMA_exportOutputHandler(\n                'DROP DATABASE '\n                . Util::backquoteCompat(\n                    $db_alias,\n                    $compat,\n                    isset($GLOBALS['sql_backquotes'])\n                )\n                . ';' . $crlf\n            )\n            ) {\n                return false;\n            }\n        }\n        if ($export_type == 'database' && !isset($GLOBALS['sql_create_database'])) {\n            return true;\n        }\n\n        $create_query = 'CREATE DATABASE IF NOT EXISTS '\n            . Util::backquoteCompat(\n                $db_alias,\n                $compat,\n                isset($GLOBALS['sql_backquotes'])\n            );\n        $collation = PMA_getDbCollation($db);\n        if (mb_strpos($collation, '_')) {\n            $create_query .= ' DEFAULT CHARACTER SET '\n                . mb_substr(\n                    $collation,\n                    0,\n                    mb_strpos($collation, '_')\n                )\n                . ' COLLATE ' . $collation;\n        } else {\n            $create_query .= ' DEFAULT CHARACTER SET ' . $collation;\n        }\n        $create_query .= ';' . $crlf;\n        if (!PMA_exportOutputHandler($create_query)) {\n            return false;\n        }\n\n        return $this->_exportUseStatement($db_alias, $compat);\n    }\n\n    /**\n     * Outputs USE statement\n     *\n     * @param string $db     db to use\n     * @param string $compat sql compatibility\n     *\n     * @return bool Whether it succeeded\n     */\n    private function _exportUseStatement($db, $compat)\n    {\n        global $crlf;\n\n        if (isset($GLOBALS['sql_compatibility'])\n            && $GLOBALS['sql_compatibility'] == 'NONE'\n        ) {\n            $result = PMA_exportOutputHandler(\n                'USE '\n                . Util::backquoteCompat(\n                    $db,\n                    $compat,\n                    isset($GLOBALS['sql_backquotes'])\n                )\n                . ';' . $crlf\n            );\n        } else {\n            $result = PMA_exportOutputHandler('USE ' . $db . ';' . $crlf);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Outputs database header\n     *\n     * @param string $db       Database name\n     * @param string $db_alias Alias of db\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportDBHeader($db, $db_alias = '')\n    {\n        if (empty($db_alias)) {\n            $db_alias = $db;\n        }\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n        $head = $this->_exportComment()\n            . $this->_exportComment(\n                __('Database:') . ' '\n                . Util::backquoteCompat(\n                    $db_alias,\n                    $compat,\n                    isset($GLOBALS['sql_backquotes'])\n                )\n            )\n            . $this->_exportComment();\n\n        return PMA_exportOutputHandler($head);\n    }\n\n    /**\n     * Outputs database footer\n     *\n     * @param string $db Database name\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportDBFooter($db)\n    {\n        global $crlf;\n\n        $result = true;\n\n        //add indexes to the sql dump file\n        if (isset($GLOBALS['sql_indexes'])) {\n            $result = PMA_exportOutputHandler($GLOBALS['sql_indexes']);\n            unset($GLOBALS['sql_indexes']);\n        }\n        //add auto increments to the sql dump file\n        if (isset($GLOBALS['sql_auto_increments'])) {\n            $result = PMA_exportOutputHandler($GLOBALS['sql_auto_increments']);\n            unset($GLOBALS['sql_auto_increments']);\n        }\n        //add constraints to the sql dump file\n        if (isset($GLOBALS['sql_constraints'])) {\n            $result = PMA_exportOutputHandler($GLOBALS['sql_constraints']);\n            unset($GLOBALS['sql_constraints']);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Exports events\n     *\n     * @param string $db Database\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportEvents($db)\n    {\n        global $crlf;\n\n        $text = '';\n        $delimiter = '$$';\n\n        $event_names = $GLOBALS['dbi']->fetchResult(\n            \"SELECT EVENT_NAME FROM information_schema.EVENTS WHERE\"\n            . \" EVENT_SCHEMA= '\" . Util::sqlAddSlashes($db, true)\n            . \"';\"\n        );\n\n        if ($event_names) {\n            $text .= $crlf\n                . \"DELIMITER \" . $delimiter . $crlf;\n\n            $text .= $this->_exportComment()\n                . $this->_exportComment(__('Events'))\n                . $this->_exportComment();\n\n            foreach ($event_names as $event_name) {\n                if (!empty($GLOBALS['sql_drop_table'])) {\n                    $text .= \"DROP EVENT \"\n                        . Util::backquote($event_name)\n                        . $delimiter . $crlf;\n                }\n                $text .= $GLOBALS['dbi']->getDefinition($db, 'EVENT', $event_name)\n                    . $delimiter . $crlf . $crlf;\n            }\n\n            $text .= \"DELIMITER ;\" . $crlf;\n        }\n\n        if (!empty($text)) {\n            return PMA_exportOutputHandler($text);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Exports metadata from Configuration Storage\n     *\n     * @param string       $db            database being exported\n     * @param string|array $tables        table(s) being exported\n     * @param array        $metadataTypes types of metadata to export\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportMetadata(\n        $db,\n        $tables,\n        $metadataTypes\n    ) {\n        $cfgRelation = PMA_getRelationsParam();\n        if (!isset($cfgRelation['db'])) {\n            return true;\n        }\n\n        $comment = $this->_possibleCRLF()\n            . $this->_possibleCRLF()\n            . $this->_exportComment()\n            . $this->_exportComment(__('Metadata'))\n            . $this->_exportComment();\n        if (!PMA_exportOutputHandler($comment)) {\n            return false;\n        }\n\n        if (!$this->_exportUseStatement(\n            $cfgRelation['db'],\n            $GLOBALS['sql_compatibility']\n        )\n        ) {\n            return false;\n        }\n\n        $r = true;\n        if (is_array($tables)) {\n            // export metadata for each table\n            foreach ($tables as $table) {\n                $r &= $this->_exportMetadata($db, $table, $metadataTypes);\n            }\n            // export metadata for the database\n            $r &= $this->_exportMetadata($db, null, $metadataTypes);\n        } else {\n            // export metadata for single table\n            $r &= $this->_exportMetadata($db, $tables, $metadataTypes);\n        }\n\n        return $r;\n    }\n\n    /**\n     * Exports metadata from Configuration Storage\n     *\n     * @param string $db            database being exported\n     * @param string $table         table being exported\n     * @param array  $metadataTypes types of metadata to export\n     *\n     * @return bool Whether it succeeded\n     */\n    private function _exportMetadata(\n        $db,\n        $table,\n        $metadataTypes\n    ) {\n        $cfgRelation = PMA_getRelationsParam();\n\n        if (isset($table)) {\n            $types = array(\n                'column_info'   => 'db_name',\n                'table_uiprefs' => 'db_name',\n                'tracking'      => 'db_name',\n            );\n        } else {\n            $types = array(\n                'bookmark'        => 'dbase',\n                'relation'        => 'master_db',\n                'pdf_pages'       => 'db_name',\n                'savedsearches'   => 'db_name',\n                'central_columns' => 'db_name',\n            );\n        }\n\n        $aliases = array();\n\n        $comment = $this->_possibleCRLF()\n            . $this->_exportComment();\n\n        if (isset($table)) {\n            $comment .= $this->_exportComment(\n                sprintf(\n                    __('Metadata for table %s'),\n                    $table\n                )\n            );\n        } else {\n            $comment .= $this->_exportComment(\n                sprintf(\n                    __('Metadata for database %s'),\n                    $db\n                )\n            );\n        }\n\n        $comment .= $this->_exportComment();\n\n        if (!PMA_exportOutputHandler($comment)) {\n            return false;\n        }\n\n        foreach ($types as $type => $dbNameColumn) {\n            if (in_array($type, $metadataTypes) && isset($cfgRelation[$type])) {\n\n                // special case, designer pages and their coordinates\n                if ($type == 'pdf_pages') {\n\n                    $sql_query = \"SELECT `page_nr`, `page_descr` FROM \"\n                        . Util::backquote($cfgRelation['db'])\n                        . \".\" . Util::backquote($cfgRelation[$type])\n                        . \" WHERE \" . Util::backquote($dbNameColumn)\n                        . \" = '\" . Util::sqlAddSlashes($db) . \"'\";\n\n                    $result = $GLOBALS['dbi']->fetchResult(\n                        $sql_query,\n                        'page_nr',\n                        'page_descr'\n                    );\n\n                    foreach ($result as $page => $name) {\n                        // insert row for pdf_page\n                        $sql_query_row = \"SELECT `db_name`, `page_descr` FROM \"\n                            . Util::backquote($cfgRelation['db'])\n                            . \".\" . Util::backquote(\n                                $cfgRelation[$type]\n                            )\n                            . \" WHERE \" . Util::backquote(\n                                $dbNameColumn\n                            )\n                            . \" = '\" . Util::sqlAddSlashes($db) . \"'\"\n                            . \" AND `page_nr` = '\" . $page . \"'\";\n\n                        if (!$this->exportData(\n                            $cfgRelation['db'],\n                            $cfgRelation[$type],\n                            $GLOBALS['crlf'],\n                            '',\n                            $sql_query_row,\n                            $aliases\n                        )\n                        ) {\n                            return false;\n                        }\n\n                        $lastPage = $GLOBALS['crlf']\n                            . \"SET @LAST_PAGE = LAST_INSERT_ID();\"\n                            . $GLOBALS['crlf'];\n                        if (!PMA_exportOutputHandler($lastPage)) {\n                            return false;\n                        }\n\n                        $sql_query_coords = \"SELECT `db_name`, `table_name`, \"\n                            . \"'@LAST_PAGE' AS `pdf_page_number`, `x`, `y` FROM \"\n                            . Util::backquote($cfgRelation['db'])\n                            . \".\" . Util::backquote(\n                                $cfgRelation['table_coords']\n                            )\n                            . \" WHERE `pdf_page_number` = '\" . $page . \"'\";\n\n                        $GLOBALS['exporting_metadata'] = true;\n                        if (!$this->exportData(\n                            $cfgRelation['db'],\n                            $cfgRelation['table_coords'],\n                            $GLOBALS['crlf'],\n                            '',\n                            $sql_query_coords,\n                            $aliases\n                        )\n                        ) {\n                            $GLOBALS['exporting_metadata'] = false;\n\n                            return false;\n                        }\n                        $GLOBALS['exporting_metadata'] = false;\n                    }\n                    continue;\n                }\n\n                // remove auto_incrementing id field for some tables\n                if ($type == 'bookmark') {\n                    $sql_query = \"SELECT `dbase`, `user`, `label`, `query` FROM \";\n                } elseif ($type == 'column_info') {\n                    $sql_query = \"SELECT `db_name`, `table_name`, `column_name`,\"\n                        . \" `comment`, `mimetype`, `transformation`,\"\n                        . \" `transformation_options`, `input_transformation`,\"\n                        . \" `input_transformation_options` FROM\";\n                } elseif ($type == 'savedsearches') {\n                    $sql_query = \"SELECT `username`, `db_name`, `search_name`,\"\n                        . \" `search_data` FROM\";\n                } else {\n                    $sql_query = \"SELECT * FROM \";\n                }\n                $sql_query .= Util::backquote($cfgRelation['db'])\n                    . '.' . Util::backquote($cfgRelation[$type])\n                    . \" WHERE \" . Util::backquote($dbNameColumn)\n                    . \" = '\" . Util::sqlAddSlashes($db) . \"'\";\n                if (isset($table)) {\n                    $sql_query .= \" AND `table_name` = '\"\n                        . Util::sqlAddSlashes($table) . \"'\";\n                }\n\n                if (!$this->exportData(\n                    $cfgRelation['db'],\n                    $cfgRelation[$type],\n                    $GLOBALS['crlf'],\n                    '',\n                    $sql_query,\n                    $aliases\n                )\n                ) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns a stand-in CREATE definition to resolve view dependencies\n     *\n     * @param string $db      the database name\n     * @param string $view    the view name\n     * @param string $crlf    the end of line sequence\n     * @param array  $aliases Aliases of db/table/columns\n     *\n     * @return string resulting definition\n     */\n    public function getTableDefStandIn($db, $view, $crlf, $aliases = array())\n    {\n        $db_alias = $db;\n        $view_alias = $view;\n        $this->initAlias($aliases, $db_alias, $view_alias);\n        $create_query = '';\n        if (!empty($GLOBALS['sql_drop_table'])) {\n            $create_query .= 'DROP VIEW IF EXISTS '\n                . Util::backquote($view_alias)\n                . ';' . $crlf;\n        }\n\n        $create_query .= 'CREATE TABLE ';\n\n        if (isset($GLOBALS['sql_if_not_exists'])\n            && $GLOBALS['sql_if_not_exists']\n        ) {\n            $create_query .= 'IF NOT EXISTS ';\n        }\n        $create_query .= Util::backquote($view_alias) . ' (' . $crlf;\n        $tmp = array();\n        $columns = $GLOBALS['dbi']->getColumnsFull($db, $view);\n        foreach ($columns as $column_name => $definition) {\n            $col_alias = $column_name;\n            if (!empty($aliases[$db]['tables'][$view]['columns'][$col_alias])) {\n                $col_alias = $aliases[$db]['tables'][$view]['columns'][$col_alias];\n            }\n            $tmp[] = Util::backquote($col_alias) . ' ' .\n                $definition['Type'] . $crlf;\n        }\n        $create_query .= implode(',', $tmp) . ');' . $crlf;\n\n        return ($create_query);\n    }\n\n    /**\n     * Returns CREATE definition that matches $view's structure\n     *\n     * @param string $db            the database name\n     * @param string $view          the view name\n     * @param string $crlf          the end of line sequence\n     * @param bool   $add_semicolon whether to add semicolon and end-of-line at\n     *                              the end\n     * @param array  $aliases       Aliases of db/table/columns\n     *\n     * @return string resulting schema\n     */\n    private function _getTableDefForView(\n        $db,\n        $view,\n        $crlf,\n        $add_semicolon = true,\n        $aliases = array()\n    ) {\n        $db_alias = $db;\n        $view_alias = $view;\n        $this->initAlias($aliases, $db_alias, $view_alias);\n        $create_query = \"CREATE TABLE\";\n        if (isset($GLOBALS['sql_if_not_exists'])) {\n            $create_query .= \" IF NOT EXISTS \";\n        }\n        $create_query .= Util::backquote($view_alias) . \"(\" . $crlf;\n\n        $columns = $GLOBALS['dbi']->getColumns($db, $view, null, true);\n\n        $firstCol = true;\n        foreach ($columns as $column) {\n            $col_alias = $column['Field'];\n            if (!empty($aliases[$db]['tables'][$view]['columns'][$col_alias])) {\n                $col_alias = $aliases[$db]['tables'][$view]['columns'][$col_alias];\n            }\n            $extracted_columnspec = Util::extractColumnSpec(\n                $column['Type']\n            );\n\n            if (!$firstCol) {\n                $create_query .= \",\" . $crlf;\n            }\n            $create_query .= \"    \" . Util::backquote($col_alias);\n            $create_query .= \" \" . $column['Type'];\n            if ($extracted_columnspec['can_contain_collation']\n                && !empty($column['Collation'])\n            ) {\n                $create_query .= \" COLLATE \" . $column['Collation'];\n            }\n            if ($column['Null'] == 'NO') {\n                $create_query .= \" NOT NULL\";\n            }\n            if (isset($column['Default'])) {\n                $create_query .= \" DEFAULT '\"\n                    . Util::sqlAddSlashes($column['Default']) . \"'\";\n            } else {\n                if ($column['Null'] == 'YES') {\n                    $create_query .= \" DEFAULT NULL\";\n                }\n            }\n            if (!empty($column['Comment'])) {\n                $create_query .= \" COMMENT '\"\n                    . Util::sqlAddSlashes($column['Comment']) . \"'\";\n            }\n            $firstCol = false;\n        }\n        $create_query .= $crlf . \")\" . ($add_semicolon ? ';' : '') . $crlf;\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n        if ($compat == 'MSSQL') {\n            $create_query = $this->_makeCreateTableMSSQLCompatible(\n                $create_query\n            );\n        }\n\n        return $create_query;\n    }\n\n    /**\n     * Returns $table's CREATE definition\n     *\n     * @param string $db                        the database name\n     * @param string $table                     the table name\n     * @param string $crlf                      the end of line sequence\n     * @param string $error_url                 the url to go back in case\n     *                                          of error\n     * @param bool   $show_dates                whether to include creation/\n     *                                          update/check dates\n     * @param bool   $add_semicolon             whether to add semicolon and\n     *                                          end-of-line at the end\n     * @param bool   $view                      whether we're handling a view\n     * @param bool   $update_indexes_increments whether we need to update\n     *                                          two global variables\n     * @param array  $aliases                   Aliases of db/table/columns\n     *\n     * @return string resulting schema\n     */\n    public function getTableDef(\n        $db,\n        $table,\n        $crlf,\n        $error_url,\n        $show_dates = false,\n        $add_semicolon = true,\n        $view = false,\n        $update_indexes_increments = true,\n        $aliases = array()\n    ) {\n        global $sql_drop_table, $sql_backquotes, $sql_constraints,\n               $sql_constraints_query, $sql_indexes, $sql_indexes_query,\n               $sql_auto_increments, $sql_drop_foreign_keys;\n\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n\n        $schema_create = '';\n        $auto_increment = '';\n        $new_crlf = $crlf;\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n\n        // need to use PMA\\libraries\\DatabaseInterface::QUERY_STORE\n        // with $GLOBALS['dbi']->numRows() in mysqli\n        $result = $GLOBALS['dbi']->query(\n            'SHOW TABLE STATUS FROM ' . Util::backquote($db)\n            . ' WHERE Name = \\'' . Util::sqlAddSlashes($table) . '\\'',\n            null,\n            DatabaseInterface::QUERY_STORE\n        );\n        if ($result != false) {\n            if ($GLOBALS['dbi']->numRows($result) > 0) {\n                $tmpres = $GLOBALS['dbi']->fetchAssoc($result);\n\n                // Here we optionally add the AUTO_INCREMENT next value,\n                // but starting with MySQL 5.0.24, the clause is already included\n                // in SHOW CREATE TABLE so we'll remove it below\n                if (isset($GLOBALS['sql_auto_increment'])\n                    && !empty($tmpres['Auto_increment'])\n                ) {\n                    $auto_increment .= ' AUTO_INCREMENT='\n                        . $tmpres['Auto_increment'] . ' ';\n                }\n\n                if ($show_dates\n                    && isset($tmpres['Create_time'])\n                    && !empty($tmpres['Create_time'])\n                ) {\n                    $schema_create .= $this->_exportComment(\n                        __('Creation:') . ' '\n                        . Util::localisedDate(\n                            strtotime($tmpres['Create_time'])\n                        )\n                    );\n                    $new_crlf = $this->_exportComment() . $crlf;\n                }\n\n                if ($show_dates\n                    && isset($tmpres['Update_time'])\n                    && !empty($tmpres['Update_time'])\n                ) {\n                    $schema_create .= $this->_exportComment(\n                        __('Last update:') . ' '\n                        . Util::localisedDate(\n                            strtotime($tmpres['Update_time'])\n                        )\n                    );\n                    $new_crlf = $this->_exportComment() . $crlf;\n                }\n\n                if ($show_dates\n                    && isset($tmpres['Check_time'])\n                    && !empty($tmpres['Check_time'])\n                ) {\n                    $schema_create .= $this->_exportComment(\n                        __('Last check:') . ' '\n                        . Util::localisedDate(\n                            strtotime($tmpres['Check_time'])\n                        )\n                    );\n                    $new_crlf = $this->_exportComment() . $crlf;\n                }\n            }\n            $GLOBALS['dbi']->freeResult($result);\n        }\n\n        $schema_create .= $new_crlf;\n\n        // no need to generate a DROP VIEW here, it was done earlier\n        if (!empty($sql_drop_table)\n            && !$GLOBALS['dbi']->getTable($db, $table)->isView()\n        ) {\n            $schema_create .= 'DROP TABLE IF EXISTS '\n                . Util::backquote($table_alias, $sql_backquotes) . ';'\n                . $crlf;\n        }\n\n        // Complete table dump,\n        // Whether to quote table and column names or not\n        if ($sql_backquotes) {\n            $GLOBALS['dbi']->query('SET SQL_QUOTE_SHOW_CREATE = 1');\n        } else {\n            $GLOBALS['dbi']->query('SET SQL_QUOTE_SHOW_CREATE = 0');\n        }\n\n        // I don't see the reason why this unbuffered query could cause problems,\n        // because SHOW CREATE TABLE returns only one row, and we free the\n        // results below. Nonetheless, we got 2 user reports about this\n        // (see bug 1562533) so I removed the unbuffered mode.\n        // $result = $GLOBALS['dbi']->query('SHOW CREATE TABLE ' . backquote($db)\n        // . '.' . backquote($table), null, DatabaseInterface::QUERY_UNBUFFERED);\n        //\n        // Note: SHOW CREATE TABLE, at least in MySQL 5.1.23, does not\n        // produce a displayable result for the default value of a BIT\n        // column, nor does the mysqldump command. See MySQL bug 35796\n        $result = $GLOBALS['dbi']->tryQuery(\n            'SHOW CREATE TABLE ' . Util::backquote($db) . '.'\n            . Util::backquote($table)\n        );\n        // an error can happen, for example the table is crashed\n        $tmp_error = $GLOBALS['dbi']->getError();\n        if ($tmp_error) {\n            return $this->_exportComment(__('in use') . '(' . $tmp_error . ')');\n        }\n\n        // Old mode is stored so it can be restored once exporting is done.\n        $old_mode = Context::$MODE;\n\n        $warning = '';\n        if ($result != false && ($row = $GLOBALS['dbi']->fetchRow($result))) {\n            $create_query = $row[1];\n            unset($row);\n\n            // Convert end of line chars to one that we want (note that MySQL\n            // doesn't return query it will accept in all cases)\n            if (mb_strpos($create_query, \"(\\r\\n \")) {\n                $create_query = str_replace(\"\\r\\n\", $crlf, $create_query);\n            } elseif (mb_strpos($create_query, \"(\\n \")) {\n                $create_query = str_replace(\"\\n\", $crlf, $create_query);\n            } elseif (mb_strpos($create_query, \"(\\r \")) {\n                $create_query = str_replace(\"\\r\", $crlf, $create_query);\n            }\n\n            /*\n             * Drop database name from VIEW creation.\n             *\n             * This is a bit tricky, but we need to issue SHOW CREATE TABLE with\n             * database name, but we don't want name to show up in CREATE VIEW\n             * statement.\n             */\n            if ($view) {\n                $create_query = preg_replace(\n                    '/' . preg_quote(Util::backquote($db), '/') . '\\./',\n                    '',\n                    $create_query\n                );\n            }\n\n            // Substitute aliases in `CREATE` query.\n            $create_query = $this->replaceWithAliases(\n                $create_query,\n                $aliases,\n                $db,\n                $table,\n                $flag\n            );\n\n            // One warning per view.\n            if ($flag && $view) {\n                $warning = $this->_exportComment()\n                    . $this->_exportComment(\n                        __('It appears your database uses views;')\n                    )\n                    . $this->_exportComment(\n                        __('alias export may not work reliably in all cases.')\n                    )\n                    . $this->_exportComment();\n            }\n\n            // Adding IF NOT EXISTS, if required.\n            if (isset($GLOBALS['sql_if_not_exists'])) {\n                $create_query = preg_replace(\n                    '/^CREATE TABLE/',\n                    'CREATE TABLE IF NOT EXISTS',\n                    $create_query\n                );\n            }\n\n            // Making the query MSSQL compatible.\n            if ($compat == 'MSSQL') {\n                $create_query = $this->_makeCreateTableMSSQLCompatible(\n                    $create_query\n                );\n            }\n\n            // Views have no constraints, indexes, etc. They do not require any\n            // analysis.\n            if (!$view) {\n\n                if (empty($sql_backquotes)) {\n                    // Option \"Enclose table and column names with backquotes\"\n                    // was checked.\n                    Context::$MODE |= Context::NO_ENCLOSING_QUOTES;\n                }\n\n                // Using appropriate quotes.\n                if (($compat === 'MSSQL') || ($sql_backquotes === '\"')) {\n                    Context::$MODE |= Context::ANSI_QUOTES;\n                }\n            }\n\n            /**\n             * Parser used for analysis.\n             *\n             * @var Parser\n             */\n            $parser = new Parser($create_query);\n\n            /**\n             * `CREATE TABLE` statement.\n             *\n             * @var SelectStatement\n             */\n            $statement = $parser->statements[0];\n\n            if (!empty($statement->entityOptions)) {\n                $engine = $statement->entityOptions->has('ENGINE');\n            } else {\n                $engine = '';\n            }\n\n            /* Avoid operation on ARCHIVE tables as those can not be altered */\n            if (!empty($statement->fields) && (empty($engine) || strtoupper($engine) != 'ARCHIVE')) {\n\n                /**\n                 * Fragments containining definition of each constraint.\n                 *\n                 * @var array\n                 */\n                $constraints = array();\n\n                /**\n                 * Fragments containining definition of each index.\n                 *\n                 * @var array\n                 */\n                $indexes = array();\n\n                /**\n                 * Fragments containining definition of each FULLTEXT index.\n                 *\n                 * @var array\n                 */\n                $indexes_fulltext = array();\n\n                /**\n                 * Fragments containining definition of each foreign key that will\n                 * be dropped.\n                 *\n                 * @var array\n                 */\n                $dropped = array();\n\n                /**\n                 * Fragment containining definition of the `AUTO_INCREMENT`.\n                 *\n                 * @var array\n                 */\n                $auto_increment = array();\n\n                // Scanning each field of the `CREATE` statement to fill the arrays\n                // above.\n                // If the field is used in any of the arrays above, it is removed\n                // from the original definition.\n                // Also, AUTO_INCREMENT attribute is removed.\n                /** @var CreateDefinition $field */\n                foreach ($statement->fields as $key => $field) {\n\n                    if ($field->isConstraint) {\n                        // Creating the parts that add constraints.\n                        $constraints[] = $field::build($field);\n                        unset($statement->fields[$key]);\n                    } elseif (!empty($field->key)) {\n                        // Creating the parts that add indexes (must not be\n                        // constraints).\n                        if ($field->key->type === 'FULLTEXT KEY') {\n                            $indexes_fulltext[] = $field->build($field);\n                            unset($statement->fields[$key]);\n                        } else {\n                            if (empty($GLOBALS['sql_if_not_exists'])) {\n                                $indexes[] = str_replace(\n                                    'COMMENT=\\'', 'COMMENT \\'', $field::build($field)\n                                );\n                                unset($statement->fields[$key]);\n                            }\n                        }\n                    }\n\n                    // Creating the parts that drop foreign keys.\n                    if (!empty($field->key)) {\n                        if ($field->key->type === 'FOREIGN KEY') {\n                            $dropped[] = 'FOREIGN KEY ' . Context::escape(\n                                $field->name\n                            );\n                            unset($statement->fields[$key]);\n                        }\n                    }\n\n                    // Dropping AUTO_INCREMENT.\n                    if (!empty($field->options)) {\n                        if ($field->options->has('AUTO_INCREMENT')\n                            && empty($GLOBALS['sql_if_not_exists'])\n                        ) {\n\n                            $auto_increment[] = $field::build($field);\n                            $field->options->remove('AUTO_INCREMENT');\n                        }\n                    }\n                }\n\n                /**\n                 * The header of the `ALTER` statement (`ALTER TABLE tbl`).\n                 *\n                 * @var string\n                 */\n                $alter_header = 'ALTER TABLE ' .\n                    Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    );\n\n                /**\n                 * The footer of the `ALTER` statement (usually ';')\n                 *\n                 * @var string\n                 */\n                $alter_footer = ';' . $crlf;\n\n                // Generating constraints-related query.\n                if (!empty($constraints)) {\n                    $sql_constraints_query = $alter_header . $crlf . '  ADD '\n                        . implode(',' . $crlf . '  ADD ', $constraints)\n                        . $alter_footer;\n\n                    $sql_constraints = $this->generateComment(\n                        $crlf,\n                        $sql_constraints,\n                        __('Constraints for dumped tables'),\n                        __('Constraints for table'),\n                        $table_alias,\n                        $compat\n                    ) . $sql_constraints_query;\n                }\n\n                // Generating indexes-related query.\n                $sql_indexes_query = '';\n\n                if (!empty($indexes)) {\n                    $sql_indexes_query .= $alter_header . $crlf . '  ADD '\n                        . implode(',' . $crlf . '  ADD ', $indexes)\n                        . $alter_footer;\n                }\n\n                if (!empty($indexes_fulltext)) {\n                    // InnoDB supports one FULLTEXT index creation at a time.\n                    // So FULLTEXT indexes are created one-by-one after other\n                    // indexes where created.\n                    $sql_indexes_query .= $alter_header .\n                        ' ADD ' . implode(\n                            $alter_footer . $alter_header . ' ADD ',\n                            $indexes_fulltext\n                        ) . $alter_footer;\n                }\n\n                if ((!empty($indexes)) || (!empty($indexes_fulltext))) {\n                    $sql_indexes = $this->generateComment(\n                        $crlf,\n                        $sql_indexes,\n                        __('Indexes for dumped tables'),\n                        __('Indexes for table'),\n                        $table_alias,\n                        $compat\n                    ) . $sql_indexes_query;\n                }\n\n                // Generating drop foreign keys-related query.\n                if (!empty($dropped)) {\n                    $sql_drop_foreign_keys = $alter_header . $crlf . '  DROP '\n                        . implode(',' . $crlf . '  DROP ', $dropped)\n                        . $alter_footer;\n                }\n\n                // Generating auto-increment-related query.\n                if ((! empty($auto_increment)) && ($update_indexes_increments)) {\n                    $sql_auto_increments_query = $alter_header . $crlf . '  MODIFY '\n                        . implode(',' . $crlf . '  MODIFY ', $auto_increment);\n                    if (isset($GLOBALS['sql_auto_increment'])\n                        && ($statement->entityOptions->has('AUTO_INCREMENT') !== false)\n                    ) {\n                        $sql_auto_increments_query .= ', AUTO_INCREMENT='\n                            . $statement->entityOptions->has('AUTO_INCREMENT');\n                    }\n                    $sql_auto_increments_query .= ';';\n\n                    $sql_auto_increments = $this->generateComment(\n                        $crlf,\n                        $sql_auto_increments,\n                        __('AUTO_INCREMENT for dumped tables'),\n                        __('AUTO_INCREMENT for table'),\n                        $table_alias,\n                        $compat\n                    ) . $sql_auto_increments_query;\n                }\n\n                // Removing the `AUTO_INCREMENT` attribute from the `CREATE TABLE`\n                // too.\n                if (!empty($statement->entityOptions)\n                    && (empty($GLOBALS['sql_if_not_exists'])\n                    || empty($GLOBALS['sql_auto_increment']))\n                ) {\n                    $statement->entityOptions->remove('AUTO_INCREMENT');\n                }\n\n                // Rebuilding the query.\n                $create_query = $statement->build();\n            }\n\n            $schema_create .= $create_query;\n        }\n\n        $GLOBALS['dbi']->freeResult($result);\n\n        // Restoring old mode.\n        Context::$MODE = $old_mode;\n\n        return $warning . $schema_create . ($add_semicolon ? ';' . $crlf : '');\n    } // end of the 'getTableDef()' function\n\n    /**\n     * Returns $table's comments, relations etc.\n     *\n     * @param string $db          database name\n     * @param string $table       table name\n     * @param string $crlf        end of line sequence\n     * @param bool   $do_relation whether to include relation comments\n     * @param bool   $do_mime     whether to include mime comments\n     * @param array  $aliases     Aliases of db/table/columns\n     *\n     * @return string resulting comments\n     */\n    private function _getTableComments(\n        $db,\n        $table,\n        $crlf,\n        $do_relation = false,\n        $do_mime = false,\n        $aliases = array()\n    ) {\n        global $cfgRelation, $sql_backquotes;\n\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n\n        $schema_create = '';\n\n        // Check if we can use Relations\n        list($res_rel, $have_rel) = PMA_getRelationsAndStatus(\n            $do_relation && !empty($cfgRelation['relation']),\n            $db,\n            $table\n        );\n\n        if ($do_mime && $cfgRelation['mimework']) {\n            if (!($mime_map = PMA_getMIME($db, $table, true))) {\n                unset($mime_map);\n            }\n        }\n\n        if (isset($mime_map) && count($mime_map) > 0) {\n            $schema_create .= $this->_possibleCRLF()\n                . $this->_exportComment()\n                . $this->_exportComment(\n                    __('MIME TYPES FOR TABLE') . ' '\n                    . Util::backquote($table, $sql_backquotes) . ':'\n                );\n            foreach ($mime_map as $mime_field => $mime) {\n                $schema_create .= $this->_exportComment(\n                    '  '\n                    . Util::backquote($mime_field, $sql_backquotes)\n                )\n                . $this->_exportComment(\n                    '      '\n                    . Util::backquote(\n                        $mime['mimetype'],\n                        $sql_backquotes\n                    )\n                );\n            }\n            $schema_create .= $this->_exportComment();\n        }\n\n        if ($have_rel) {\n            $schema_create .= $this->_possibleCRLF()\n                . $this->_exportComment()\n                . $this->_exportComment(\n                    __('RELATIONS FOR TABLE') . ' '\n                    . Util::backquote($table_alias, $sql_backquotes)\n                    . ':'\n                );\n\n            foreach ($res_rel as $rel_field => $rel) {\n                if ($rel_field != 'foreign_keys_data') {\n                    $rel_field_alias = !empty(\n                        $aliases[$db]['tables'][$table]['columns'][$rel_field]\n                    ) ? $aliases[$db]['tables'][$table]['columns'][$rel_field]\n                        : $rel_field;\n                    $schema_create .= $this->_exportComment(\n                        '  '\n                        . Util::backquote(\n                            $rel_field_alias,\n                            $sql_backquotes\n                        )\n                    )\n                    . $this->_exportComment(\n                        '      '\n                        . Util::backquote(\n                            $rel['foreign_table'],\n                            $sql_backquotes\n                        )\n                        . ' -> '\n                        . Util::backquote(\n                            $rel['foreign_field'],\n                            $sql_backquotes\n                        )\n                    );\n                } else {\n                    foreach ($rel as $one_key) {\n                        foreach ($one_key['index_list'] as $index => $field) {\n                            $rel_field_alias = !empty(\n                                $aliases[$db]['tables'][$table]['columns'][$field]\n                            ) ? $aliases[$db]['tables'][$table]['columns'][$field]\n                                : $field;\n                            $schema_create .= $this->_exportComment(\n                                '  '\n                                . Util::backquote(\n                                    $rel_field_alias,\n                                    $sql_backquotes\n                                )\n                            )\n                            . $this->_exportComment(\n                                '      '\n                                . Util::backquote(\n                                    $one_key['ref_table_name'],\n                                    $sql_backquotes\n                                )\n                                . ' -> '\n                                . Util::backquote(\n                                    $one_key['ref_index_list'][$index],\n                                    $sql_backquotes\n                                )\n                            );\n                        }\n                    }\n                }\n            }\n            $schema_create .= $this->_exportComment();\n        }\n\n        return $schema_create;\n    } // end of the '_getTableComments()' function\n\n    /**\n     * Outputs table's structure\n     *\n     * @param string $db          database name\n     * @param string $table       table name\n     * @param string $crlf        the end of line sequence\n     * @param string $error_url   the url to go back in case of error\n     * @param string $export_mode 'create_table','triggers','create_view',\n     *                            'stand_in'\n     * @param string $export_type 'server', 'database', 'table'\n     * @param bool   $relation    whether to include relation comments\n     * @param bool   $comments    whether to include the pmadb-style column\n     *                            comments as comments in the structure; this is\n     *                            deprecated but the parameter is left here\n     *                            because export.php calls exportStructure()\n     *                            also for other export types which use this\n     *                            parameter\n     * @param bool   $mime        whether to include mime comments\n     * @param bool   $dates       whether to include creation/update/check dates\n     * @param array  $aliases     Aliases of db/table/columns\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportStructure(\n        $db,\n        $table,\n        $crlf,\n        $error_url,\n        $export_mode,\n        $export_type,\n        $relation = false,\n        $comments = false,\n        $mime = false,\n        $dates = false,\n        $aliases = array()\n    ) {\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n\n        $formatted_table_name = Util::backquoteCompat(\n            $table_alias,\n            $compat,\n            isset($GLOBALS['sql_backquotes'])\n        );\n        $dump = $this->_possibleCRLF()\n            . $this->_exportComment(str_repeat('-', 56))\n            . $this->_possibleCRLF()\n            . $this->_exportComment();\n\n        switch ($export_mode) {\n        case 'create_table':\n            $dump .= $this->_exportComment(\n                __('Table structure for table') . ' ' . $formatted_table_name\n            );\n            $dump .= $this->_exportComment();\n            $dump .= $this->getTableDef(\n                $db,\n                $table,\n                $crlf,\n                $error_url,\n                $dates,\n                true,\n                false,\n                true,\n                $aliases\n            );\n            $dump .= $this->_getTableComments(\n                $db,\n                $table,\n                $crlf,\n                $relation,\n                $mime,\n                $aliases\n            );\n            break;\n        case 'triggers':\n            $dump = '';\n            $delimiter = '$$';\n            $triggers = $GLOBALS['dbi']->getTriggers($db, $table, $delimiter);\n            if ($triggers) {\n                $dump .= $this->_possibleCRLF()\n                    . $this->_exportComment()\n                    . $this->_exportComment(\n                        __('Triggers') . ' ' . $formatted_table_name\n                    )\n                    . $this->_exportComment();\n                $used_alias = false;\n                $trigger_query = '';\n                foreach ($triggers as $trigger) {\n                    if (!empty($GLOBALS['sql_drop_table'])) {\n                        $trigger_query .= $trigger['drop'] . ';' . $crlf;\n                    }\n\n                    $trigger_query .= 'DELIMITER ' . $delimiter . $crlf;\n                    $trigger_query .= $this->replaceWithAliases(\n                        $trigger['create'],\n                        $aliases,\n                        $db,\n                        $table,\n                        $flag\n                    );\n                    if ($flag) {\n                        $used_alias = true;\n                    }\n                    $trigger_query .= 'DELIMITER ;' . $crlf;\n                }\n                // One warning per table.\n                if ($used_alias) {\n                    $dump .= $this->_exportComment(\n                        __('It appears your table uses triggers;')\n                    )\n                    . $this->_exportComment(\n                        __('alias export may not work reliably in all cases.')\n                    )\n                    . $this->_exportComment();\n                }\n                $dump .= $trigger_query;\n            }\n            break;\n        case 'create_view':\n            if (empty($GLOBALS['sql_views_as_tables'])) {\n                $dump .= $this->_exportComment(\n                    __('Structure for view')\n                    . ' '\n                    . $formatted_table_name\n                )\n                . $this->_exportComment();\n                // delete the stand-in table previously created (if any)\n                if ($export_type != 'table') {\n                    $dump .= 'DROP TABLE IF EXISTS '\n                        . Util::backquote($table_alias) . ';' . $crlf;\n                }\n                $dump .= $this->getTableDef(\n                    $db,\n                    $table,\n                    $crlf,\n                    $error_url,\n                    $dates,\n                    true,\n                    true,\n                    true,\n                    $aliases\n                );\n            } else {\n                $dump .= $this->_exportComment(\n                    sprintf(\n                        __('Structure for view %s exported as a table'),\n                        $formatted_table_name\n                    )\n                )\n                . $this->_exportComment();\n                // delete the stand-in table previously created (if any)\n                if ($export_type != 'table') {\n                    $dump .= 'DROP TABLE IF EXISTS '\n                        . Util::backquote($table_alias) . ';' . $crlf;\n                }\n                $dump .= $this->_getTableDefForView(\n                    $db,\n                    $table,\n                    $crlf,\n                    true,\n                    $aliases\n                );\n            }\n            break;\n        case 'stand_in':\n            $dump .= $this->_exportComment(\n                __('Stand-in structure for view') . ' ' . $formatted_table_name\n            )\n                . $this->_exportComment(\n                __('(See below for the actual view)')\n            )\n                . $this->_exportComment();\n            // export a stand-in definition to resolve view dependencies\n            $dump .= $this->getTableDefStandIn($db, $table, $crlf, $aliases);\n        } // end switch\n\n        // this one is built by getTableDef() to use in table copy/move\n        // but not in the case of export\n        unset($GLOBALS['sql_constraints_query']);\n\n        return PMA_exportOutputHandler($dump);\n    }\n\n    /**\n     * Outputs the content of a table in SQL format\n     *\n     * @param string $db        database name\n     * @param string $table     table name\n     * @param string $crlf      the end of line sequence\n     * @param string $error_url the url to go back in case of error\n     * @param string $sql_query SQL query for obtaining data\n     * @param array  $aliases   Aliases of db/table/columns\n     *\n     * @return bool Whether it succeeded\n     */\n    public function exportData(\n        $db,\n        $table,\n        $crlf,\n        $error_url,\n        $sql_query,\n        $aliases = array()\n    ) {\n        global $current_row, $sql_backquotes;\n\n        // Do not export data for merge tables\n        if ($GLOBALS['dbi']->getTable($db, $table)->isMerge()) {\n            return true;\n        }\n\n        $db_alias = $db;\n        $table_alias = $table;\n        $this->initAlias($aliases, $db_alias, $table_alias);\n\n        if (isset($GLOBALS['sql_compatibility'])) {\n            $compat = $GLOBALS['sql_compatibility'];\n        } else {\n            $compat = 'NONE';\n        }\n\n        $formatted_table_name = Util::backquoteCompat(\n            $table_alias,\n            $compat,\n            $sql_backquotes\n        );\n\n        // Do not export data for a VIEW, unless asked to export the view as a table\n        // (For a VIEW, this is called only when exporting a single VIEW)\n        if ($GLOBALS['dbi']->getTable($db, $table)->isView()\n            && empty($GLOBALS['sql_views_as_tables'])\n        ) {\n            $head = $this->_possibleCRLF()\n                . $this->_exportComment()\n                . $this->_exportComment('VIEW ' . ' ' . $formatted_table_name)\n                . $this->_exportComment(__('Data:') . ' ' . __('None'))\n                . $this->_exportComment()\n                . $this->_possibleCRLF();\n\n            if (!PMA_exportOutputHandler($head)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        $result = $GLOBALS['dbi']->tryQuery(\n            $sql_query,\n            null,\n            DatabaseInterface::QUERY_UNBUFFERED\n        );\n        // a possible error: the table has crashed\n        $tmp_error = $GLOBALS['dbi']->getError();\n        if ($tmp_error) {\n            return PMA_exportOutputHandler(\n                $this->_exportComment(\n                    __('Error reading data:') . ' (' . $tmp_error . ')'\n                )\n            );\n        }\n\n        if ($result == false) {\n            $GLOBALS['dbi']->freeResult($result);\n\n            return true;\n        }\n\n        $fields_cnt = $GLOBALS['dbi']->numFields($result);\n\n        // Get field information\n        $fields_meta = $GLOBALS['dbi']->getFieldsMeta($result);\n        $field_flags = array();\n        for ($j = 0; $j < $fields_cnt; $j++) {\n            $field_flags[$j] = $GLOBALS['dbi']->fieldFlags($result, $j);\n        }\n\n        $field_set = array();\n        for ($j = 0; $j < $fields_cnt; $j++) {\n            $col_as = $fields_meta[$j]->name;\n            if (!empty($aliases[$db]['tables'][$table]['columns'][$col_as])) {\n                $col_as = $aliases[$db]['tables'][$table]['columns'][$col_as];\n            }\n            $field_set[$j] = Util::backquoteCompat(\n                $col_as,\n                $compat,\n                $sql_backquotes\n            );\n        }\n\n        if (isset($GLOBALS['sql_type'])\n            && $GLOBALS['sql_type'] == 'UPDATE'\n        ) {\n            // update\n            $schema_insert = 'UPDATE ';\n            if (isset($GLOBALS['sql_ignore'])) {\n                $schema_insert .= 'IGNORE ';\n            }\n            // avoid EOL blank\n            $schema_insert .= Util::backquoteCompat(\n                $table_alias,\n                $compat,\n                $sql_backquotes\n            ) . ' SET';\n        } else {\n            // insert or replace\n            if (isset($GLOBALS['sql_type'])\n                && $GLOBALS['sql_type'] == 'REPLACE'\n            ) {\n                $sql_command = 'REPLACE';\n            } else {\n                $sql_command = 'INSERT';\n            }\n\n            // delayed inserts?\n            if (isset($GLOBALS['sql_delayed'])) {\n                $insert_delayed = ' DELAYED';\n            } else {\n                $insert_delayed = '';\n            }\n\n            // insert ignore?\n            if (isset($GLOBALS['sql_type'])\n                && $GLOBALS['sql_type'] == 'INSERT'\n                && isset($GLOBALS['sql_ignore'])\n            ) {\n                $insert_delayed .= ' IGNORE';\n            }\n            //truncate table before insert\n            if (isset($GLOBALS['sql_truncate'])\n                && $GLOBALS['sql_truncate']\n                && $sql_command == 'INSERT'\n            ) {\n                $truncate = 'TRUNCATE TABLE '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    ) . \";\";\n                $truncatehead = $this->_possibleCRLF()\n                    . $this->_exportComment()\n                    . $this->_exportComment(\n                        __('Truncate table before insert') . ' '\n                        . $formatted_table_name\n                    )\n                    . $this->_exportComment()\n                    . $crlf;\n                PMA_exportOutputHandler($truncatehead);\n                PMA_exportOutputHandler($truncate);\n            }\n\n            // scheme for inserting fields\n            if ($GLOBALS['sql_insert_syntax'] == 'complete'\n                || $GLOBALS['sql_insert_syntax'] == 'both'\n            ) {\n                $fields = implode(', ', $field_set);\n                $schema_insert = $sql_command . $insert_delayed . ' INTO '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    )\n                    // avoid EOL blank\n                    . ' (' . $fields . ') VALUES';\n            } else {\n                $schema_insert = $sql_command . $insert_delayed . ' INTO '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    )\n                    . ' VALUES';\n            }\n        }\n\n        //\\x08\\\\x09, not required\n        $search = array(\"\\x00\", \"\\x0a\", \"\\x0d\", \"\\x1a\");\n        $replace = array('\\0', '\\n', '\\r', '\\Z');\n        $current_row = 0;\n        $query_size = 0;\n        if (($GLOBALS['sql_insert_syntax'] == 'extended'\n            || $GLOBALS['sql_insert_syntax'] == 'both')\n            && (!isset($GLOBALS['sql_type'])\n            || $GLOBALS['sql_type'] != 'UPDATE')\n        ) {\n            $separator = ',';\n            $schema_insert .= $crlf;\n        } else {\n            $separator = ';';\n        }\n\n        while ($row = $GLOBALS['dbi']->fetchRow($result)) {\n            if ($current_row == 0) {\n                $head = $this->_possibleCRLF()\n                    . $this->_exportComment()\n                    . $this->_exportComment(\n                        __('Dumping data for table') . ' '\n                        . $formatted_table_name\n                    )\n                    . $this->_exportComment()\n                    . $crlf;\n                if (!PMA_exportOutputHandler($head)) {\n                    return false;\n                }\n            }\n            // We need to SET IDENTITY_INSERT ON for MSSQL\n            if (isset($GLOBALS['sql_compatibility'])\n                && $GLOBALS['sql_compatibility'] == 'MSSQL'\n                && $current_row == 0\n            ) {\n                if (!PMA_exportOutputHandler(\n                    'SET IDENTITY_INSERT '\n                    . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        $sql_backquotes\n                    )\n                    . ' ON ;' . $crlf\n                )\n                ) {\n                    return false;\n                }\n            }\n            $current_row++;\n            $values = array();\n            for ($j = 0; $j < $fields_cnt; $j++) {\n                // NULL\n                if (!isset($row[$j]) || is_null($row[$j])) {\n                    $values[] = 'NULL';\n                } elseif ($fields_meta[$j]->numeric\n                    && $fields_meta[$j]->type != 'timestamp'\n                    && !$fields_meta[$j]->blob\n                ) {\n                    // a number\n                    // timestamp is numeric on some MySQL 4.1, BLOBs are\n                    // sometimes numeric\n                    $values[] = $row[$j];\n                } elseif (stristr($field_flags[$j], 'BINARY') !== false\n                    && isset($GLOBALS['sql_hex_for_binary'])\n                ) {\n                    // a true BLOB\n                    // - mysqldump only generates hex data when the --hex-blob\n                    //   option is used, for fields having the binary attribute\n                    //   no hex is generated\n                    // - a TEXT field returns type blob but a real blob\n                    //   returns also the 'binary' flag\n\n                    // empty blobs need to be different, but '0' is also empty\n                    // :-(\n                    if (empty($row[$j]) && $row[$j] != '0') {\n                        $values[] = '\\'\\'';\n                    } else {\n                        $values[] = '0x' . bin2hex($row[$j]);\n                    }\n                } elseif ($fields_meta[$j]->type == 'bit') {\n                    // detection of 'bit' works only on mysqli extension\n                    $values[] = \"b'\" . Util::sqlAddSlashes(\n                        Util::printableBitValue(\n                            $row[$j],\n                            $fields_meta[$j]->length\n                        )\n                    )\n                    . \"'\";\n                } elseif (!empty($GLOBALS['exporting_metadata'])\n                    && $row[$j] == '@LAST_PAGE'\n                ) {\n                    $values[] = '@LAST_PAGE';\n                } else {\n                    // something else -> treat as a string\n                    $values[] = '\\''\n                        . str_replace(\n                            $search,\n                            $replace,\n                            Util::sqlAddSlashes($row[$j])\n                        )\n                        . '\\'';\n                } // end if\n            } // end for\n\n            // should we make update?\n            if (isset($GLOBALS['sql_type'])\n                && $GLOBALS['sql_type'] == 'UPDATE'\n            ) {\n\n                $insert_line = $schema_insert;\n                for ($i = 0; $i < $fields_cnt; $i++) {\n                    if (0 == $i) {\n                        $insert_line .= ' ';\n                    }\n                    if ($i > 0) {\n                        // avoid EOL blank\n                        $insert_line .= ',';\n                    }\n                    $insert_line .= $field_set[$i] . ' = ' . $values[$i];\n                }\n\n                list($tmp_unique_condition, $tmp_clause_is_unique)\n                    = Util::getUniqueCondition(\n                        $result, // handle\n                        $fields_cnt, // fields_cnt\n                        $fields_meta, // fields_meta\n                        $row, // row\n                        false, // force_unique\n                        false, // restrict_to_table\n                        null // analyzed_sql_results\n                    );\n                $insert_line .= ' WHERE ' . $tmp_unique_condition;\n                unset($tmp_unique_condition, $tmp_clause_is_unique);\n            } else {\n\n                // Extended inserts case\n                if ($GLOBALS['sql_insert_syntax'] == 'extended'\n                    || $GLOBALS['sql_insert_syntax'] == 'both'\n                ) {\n                    if ($current_row == 1) {\n                        $insert_line = $schema_insert . '('\n                            . implode(', ', $values) . ')';\n                    } else {\n                        $insert_line = '(' . implode(', ', $values) . ')';\n                        $insertLineSize = mb_strlen($insert_line);\n                        $sql_max_size = $GLOBALS['sql_max_query_size'];\n                        if (isset($sql_max_size)\n                            && $sql_max_size > 0\n                            && $query_size + $insertLineSize > $sql_max_size\n                        ) {\n                            if (!PMA_exportOutputHandler(';' . $crlf)) {\n                                return false;\n                            }\n                            $query_size = 0;\n                            $current_row = 1;\n                            $insert_line = $schema_insert . $insert_line;\n                        }\n                    }\n                    $query_size += mb_strlen($insert_line);\n                    // Other inserts case\n                } else {\n                    $insert_line = $schema_insert\n                        . '(' . implode(', ', $values) . ')';\n                }\n            }\n            unset($values);\n\n            if (!PMA_exportOutputHandler(\n                ($current_row == 1 ? '' : $separator . $crlf)\n                . $insert_line\n            )\n            ) {\n                return false;\n            }\n        } // end while\n\n        if ($current_row > 0) {\n            if (!PMA_exportOutputHandler(';' . $crlf)) {\n                return false;\n            }\n        }\n\n        // We need to SET IDENTITY_INSERT OFF for MSSQL\n        if (isset($GLOBALS['sql_compatibility'])\n            && $GLOBALS['sql_compatibility'] == 'MSSQL'\n            && $current_row > 0\n        ) {\n            $outputSucceeded = PMA_exportOutputHandler(\n                $crlf . 'SET IDENTITY_INSERT '\n                . Util::backquoteCompat(\n                    $table_alias,\n                    $compat,\n                    $sql_backquotes\n                )\n                . ' OFF;' . $crlf\n            );\n            if (!$outputSucceeded) {\n                return false;\n            }\n        }\n\n        $GLOBALS['dbi']->freeResult($result);\n\n        return true;\n    } // end of the 'exportData()' function\n\n    /**\n     * Make a create table statement compatible with MSSQL\n     *\n     * @param string $create_query MySQL create table statement\n     *\n     * @return string MSSQL compatible create table statement\n     */\n    private function _makeCreateTableMSSQLCompatible($create_query)\n    {\n        // In MSSQL\n        // 1. No 'IF NOT EXISTS' in CREATE TABLE\n        // 2. DATE field doesn't exists, we will use DATETIME instead\n        // 3. UNSIGNED attribute doesn't exist\n        // 4. No length on INT, TINYINT, SMALLINT, BIGINT and no precision on\n        //    FLOAT fields\n        // 5. No KEY and INDEX inside CREATE TABLE\n        // 6. DOUBLE field doesn't exists, we will use FLOAT instead\n\n        $create_query = preg_replace(\n            \"/^CREATE TABLE IF NOT EXISTS/\",\n            'CREATE TABLE',\n            $create_query\n        );\n        // first we need  to replace all lines ended with '\" DATE ...,\\n'\n        // last preg_replace preserve us from situation with date text\n        // inside DEFAULT field value\n        $create_query = preg_replace(\n            \"/\\\" date DEFAULT NULL(,)?\\n/\",\n            '\" datetime DEFAULT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            \"/\\\" date NOT NULL(,)?\\n/\",\n            '\" datetime NOT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" date NOT NULL DEFAULT \\'([^\\'])/',\n            '\" datetime NOT NULL DEFAULT \\'$1',\n            $create_query\n        );\n\n        // next we need to replace all lines ended with ') UNSIGNED ...,'\n        // last preg_replace preserve us from situation with unsigned text\n        // inside DEFAULT field value\n        $create_query = preg_replace(\n            \"/\\) unsigned NOT NULL(,)?\\n/\",\n            ') NOT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            \"/\\) unsigned DEFAULT NULL(,)?\\n/\",\n            ') DEFAULT NULL$1' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\\) unsigned NOT NULL DEFAULT \\'([^\\'])/',\n            ') NOT NULL DEFAULT \\'$1',\n            $create_query\n        );\n\n        // we need to replace all lines ended with\n        // '\" INT|TINYINT([0-9]{1,}) ...,' last preg_replace preserve us\n        // from situation with int([0-9]{1,}) text inside DEFAULT field\n        // value\n        $create_query = preg_replace(\n            '/\" (int|tinyint|smallint|bigint)\\([0-9]+\\) DEFAULT NULL(,)?\\n/',\n            '\" $1 DEFAULT NULL$2' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (int|tinyint|smallint|bigint)\\([0-9]+\\) NOT NULL(,)?\\n/',\n            '\" $1 NOT NULL$2' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (int|tinyint|smallint|bigint)\\([0-9]+\\) NOT NULL DEFAULT \\'([^\\'])/',\n            '\" $1 NOT NULL DEFAULT \\'$2',\n            $create_query\n        );\n\n        // we need to replace all lines ended with\n        // '\" FLOAT|DOUBLE([0-9,]{1,}) ...,'\n        // last preg_replace preserve us from situation with\n        // float([0-9,]{1,}) text inside DEFAULT field value\n        $create_query = preg_replace(\n            '/\" (float|double)(\\([0-9]+,[0-9,]+\\))? DEFAULT NULL(,)?\\n/',\n            '\" float DEFAULT NULL$3' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (float|double)(\\([0-9,]+,[0-9,]+\\))? NOT NULL(,)?\\n/',\n            '\" float NOT NULL$3' . \"\\n\",\n            $create_query\n        );\n        $create_query = preg_replace(\n            '/\" (float|double)(\\([0-9,]+,[0-9,]+\\))? NOT NULL DEFAULT \\'([^\\'])/',\n            '\" float NOT NULL DEFAULT \\'$3',\n            $create_query\n        );\n\n        // @todo remove indexes from CREATE TABLE\n\n        return $create_query;\n    }\n\n    /**\n     * replaces db/table/column names with their aliases\n     *\n     * @param string $sql_query SQL query in which aliases are to be substituted\n     * @param array  $aliases   Alias information for db/table/column\n     * @param string $db        the database name\n     * @param string $table     the tablename\n     * @param string &$flag     the flag denoting whether any replacement was done\n     *\n     * @return string query replaced with aliases\n     */\n    public function replaceWithAliases(\n        $sql_query,\n        $aliases,\n        $db,\n        $table = '',\n        &$flag = null\n    ) {\n        $flag = false;\n\n        /**\n         * The parser of this query.\n         *\n         * @var Parser $parser\n         */\n        $parser = new Parser($sql_query);\n\n        if (empty($parser->statements[0])) {\n            return $sql_query;\n        }\n\n        /**\n         * The statement that represents the query.\n         *\n         * @var \\SqlParser\\Statements\\CreateStatement $statement\n         */\n        $statement = $parser->statements[0];\n\n        /**\n         * Old database name.\n         *\n         * @var string $old_database\n         */\n        $old_database = $db;\n\n        // Replacing aliases in `CREATE TABLE` statement.\n        if ($statement->options->has('TABLE')) {\n\n            // Extracting the name of the old database and table from the\n            // statement to make sure the parameters are corect.\n            if (!empty($statement->name->database)) {\n                $old_database = $statement->name->database;\n            }\n\n            /**\n             * Old table name.\n             *\n             * @var string $old_table\n             */\n            $old_table = $statement->name->table;\n\n            // Finding the aliased database name.\n            // The database might be empty so we have to add a few checks.\n            $new_database = null;\n            if (!empty($statement->name->database)) {\n                $new_database = $statement->name->database;\n                if (!empty($aliases[$old_database]['alias'])) {\n                    $new_database = $aliases[$old_database]['alias'];\n                }\n            }\n\n            // Finding the aliases table name.\n            $new_table = $old_table;\n            if (!empty($aliases[$old_database]['tables'][$old_table]['alias'])) {\n                $new_table = $aliases[$old_database]['tables'][$old_table]['alias'];\n            }\n\n            // Replacing new values.\n            if (($statement->name->database !== $new_database)\n                || ($statement->name->table !== $new_table)\n            ) {\n                $statement->name->database = $new_database;\n                $statement->name->table = $new_table;\n                $statement->name->expr = null; // Force rebuild.\n                $flag = true;\n            }\n\n            foreach ($statement->fields as $field) {\n\n                // Column name.\n                if (!empty($field->type)) {\n                    if (!empty($aliases[$old_database]['tables'][$old_table]['columns'][$field->name])) {\n                        $field->name = $aliases[$old_database]['tables']\n                        [$old_table]['columns'][$field->name];\n                        $flag = true;\n                    }\n                }\n\n                // Key's columns.\n                if (!empty($field->key)) {\n                    foreach ($field->key->columns as $key => $column) {\n                        if (!empty($aliases[$old_database]['tables'][$old_table]['columns'][$column['name']])) {\n                            $field->key->columns[$key]['name'] = $aliases[$old_database]\n                                ['tables'][$old_table]['columns'][$column['name']];\n                            $flag = true;\n                        }\n                    }\n                }\n\n                // References.\n                if (!empty($field->references)) {\n                    $ref_table = $field->references->table->table;\n                    // Replacing table.\n                    if (!empty($aliases[$old_database]['tables'][$ref_table]['alias'])) {\n                        $field->references->table->table\n                            = $aliases[$old_database]['tables'][$ref_table]['alias'];\n                        $field->references->table->expr = null;\n                        $flag = true;\n                    }\n                    // Replacing column names.\n                    foreach ($field->references->columns as $key => $column) {\n                        if (!empty($aliases[$old_database]['tables'][$ref_table]['columns'][$column])) {\n                            $field->references->columns[$key]\n                                = $aliases[$old_database]['tables'][$ref_table]['columns'][$column];\n                            $flag = true;\n                        }\n                    }\n                }\n            }\n        } elseif ($statement->options->has('TRIGGER')) {\n\n            // Extracting the name of the old database and table from the\n            // statement to make sure the parameters are corect.\n            if (!empty($statement->table->database)) {\n                $old_database = $statement->table->database;\n            }\n\n            /**\n             * Old table name.\n             *\n             * @var string $old_table\n             */\n            $old_table = $statement->table->table;\n\n            if (!empty($aliases[$old_database]['tables'][$old_table]['alias'])) {\n                $statement->table->table\n                    = $aliases[$old_database]['tables'][$old_table]['alias'];\n                $statement->table->expr = null; // Force rebuild.\n                $flag = true;\n            }\n        }\n\n        if (($statement->options->has('TRIGGER'))\n            || ($statement->options->has('PROCEDURE'))\n            || ($statement->options->has('FUNCTION'))\n            || ($statement->options->has('VIEW'))\n        ) {\n\n            // Repalcing the body.\n            for ($i = 0, $count = count($statement->body); $i < $count; ++$i) {\n\n                /**\n                 * Token parsed at this moment.\n                 *\n                 * @var Token $token\n                 */\n                $token = $statement->body[$i];\n\n                // Replacing only symbols (that are not variables) and unknown\n                // identifiers.\n                if ((($token->type === Token::TYPE_SYMBOL)\n                    && (!($token->flags & Token::FLAG_SYMBOL_VARIABLE)))\n                    || ((($token->type === Token::TYPE_KEYWORD)\n                    && (!($token->flags & Token::FLAG_KEYWORD_RESERVED)))\n                    || ($token->type === Token::TYPE_NONE))\n                ) {\n                    $alias = $this->getAlias($aliases, $token->value);\n                    if (!empty($alias)) {\n                        // Replacing the token.\n                        $token->token = Context::escape($alias);\n                        $flag = true;\n                    }\n                }\n            }\n        }\n\n        return $statement->build();\n    }\n\n    /**\n     * Generate comment\n     *\n     * @param string $crlf          Carriage return character\n     * @param string $sql_statement SQL statement\n     * @param string $comment1      Comment for dumped table\n     * @param string $comment2      Comment for current table\n     * @param string $table_alias   Table alias\n     * @param string $compat        Compatibility mode\n     *\n     * @return string\n     */\n    protected function generateComment(\n        $crlf,\n        $sql_statement,\n        $comment1,\n        $comment2,\n        $table_alias,\n        $compat\n    ) {\n        if (!isset($sql_statement)) {\n            if (isset($GLOBALS['no_constraints_comments'])) {\n                $sql_statement = '';\n            } else {\n                $sql_statement = $crlf\n                    . $this->_exportComment()\n                    . $this->_exportComment($comment1)\n                    . $this->_exportComment();\n            }\n        }\n\n        // comments for current table\n        if (!isset($GLOBALS['no_constraints_comments'])) {\n            $sql_statement .= $crlf\n                . $this->_exportComment()\n                . $this->_exportComment(\n                    $comment2 . ' ' . Util::backquoteCompat(\n                        $table_alias,\n                        $compat,\n                        isset($GLOBALS['sql_backquotes'])\n                    )\n                )\n                . $this->_exportComment();\n        }\n\n        return $sql_statement;\n    }\n}\n", "<select id=\"field_<?= $columnNumber; ?>_<?= ($ci - $ci_offset); ?>\"\n        size=\"1\"\n        name=\"field_<?= $type;?>[<?= $columnNumber;?>]\">\n    <option value=\"\" title=\"<?= __('None'); ?>\"></option>\n    <?php if (isset($available_mime[$type]) && is_array($available_mime[$type])): ?>\n        <?php foreach ($available_mime[$type] as $mimekey => $transform): ?>\n            <?php\n                $checked = isset($columnMeta['Field'])\n                         && isset($mime_map[$columnMeta['Field']][$type])\n                         && preg_match('@' . preg_quote($available_mime[$type . '_file'][$mimekey], '@') . '3?@i',\n                                        $mime_map[$columnMeta['Field']][$type]) ? 'selected ' : '';\n                $tooltip = PMA_getTransformationDescription(\n                    $available_mime[$type . '_file'][$mimekey]\n                );\n                $parts = explode(\":\", $transform);\n                $name = PMA_getTransformationName(\n                    $available_mime[$type . '_file'][$mimekey]\n                ) . ' (' . strtolower($parts[0]) . \":\" . $parts[1] . ')';\n            ?>\n            <option value=\"<?= $available_mime[$type . '_file'][$mimekey]; ?>\"\n                    <?= $checked; ?>\n                    title=\"<?= htmlspecialchars($tooltip); ?>\">\n                <?= htmlspecialchars($name); ?>\n            </option>\n        <?php endforeach; ?>\n    <?php endif; ?>\n</select>\n", "<?php\n/* vim: set expandtab sw=4 ts=4 sts=4: */\n/**\n * PMA_warnMissingExtension warns or fails on missing extension.\n *\n * @package PhpMyAdmin-test\n */\n\n/*\n * Include to test.\n */\nuse PMA\\libraries\\Theme;\n\n\nrequire_once 'libraries/js_escape.lib.php';\nrequire_once 'libraries/sanitizing.lib.php';\n\n/**\n * PMA_warnMissingExtension warns or fails on missing extension.\n *\n * @package PhpMyAdmin-test\n */\nclass PMA_WarnMissingExtension_Test extends PHPUnit_Framework_TestCase\n{\n    /**\n     * Set up\n     *\n     * @return void\n     */\n    public function setUp()\n    {\n        $GLOBALS['PMA_Config'] = new PMA\\libraries\\Config();\n        $GLOBALS['PMA_Config']->enableBc();\n        $GLOBALS['cfg']['Server'] = array(\n            'host' => 'host',\n            'verbose' => 'verbose',\n        );\n        $GLOBALS['cfg']['OBGzip'] = false;\n        $_SESSION['PMA_Theme'] = new Theme();\n        $GLOBALS['pmaThemeImage'] = 'theme/';\n        $GLOBALS['pmaThemePath'] = $_SESSION['PMA_Theme']->getPath();\n        $GLOBALS['server'] = 1;\n        $GLOBALS['db'] = '';\n        $GLOBALS['table'] = '';\n\n        include_once './libraries/ErrorHandler.php';\n        $GLOBALS['error_handler'] = new PMA\\libraries\\ErrorHandler();\n    }\n\n    /**\n     * Test for PMA_warnMissingExtension\n     *\n     * @return void\n     */\n    function testMissingExtensionFatal()\n    {\n        $ext = 'php_ext';\n        $warn = 'The <a href=\"' . PMA_getPHPDocLink('book.' . $ext . '.php')\n            . '\" target=\"Documentation\"><em>' . $ext\n            . '</em></a> extension is missing. Please check your PHP configuration.';\n\n        $this->expectOutputRegex('@' . preg_quote($warn, '@') . '@');\n\n        PMA_warnMissingExtension($ext, true);\n    }\n\n    /**\n     * Test for PMA_warnMissingExtension\n     *\n     * @return void\n     */\n    function testMissingExtensionFatalWithExtra()\n    {\n        $ext = 'php_ext';\n        $extra = 'Appended Extra String';\n\n        $warn = 'The <a href=\"' . PMA_getPHPDocLink('book.' . $ext . '.php')\n            . '\" target=\"Documentation\"><em>' . $ext\n            . '</em></a> extension is missing. Please check your PHP configuration.'\n            . ' ' . $extra;\n\n        ob_start();\n        PMA_warnMissingExtension($ext, true, $extra);\n        $printed = ob_get_contents();\n        ob_end_clean();\n\n        $this->assertGreaterThan(0, mb_strpos($printed, $warn));\n    }\n}\n"], "filenames": ["import.php", "libraries/Tracker.php", "libraries/plugins/export/ExportSql.php", "templates/columns_definitions/transformation.phtml", "test/libraries/core/PMA_warnMissingExtension_test.php"], "buggy_code_start_loc": [114, 906, 1509, 10, 62], "buggy_code_end_loc": [115, 907, 1510, 28, 63], "fixing_code_start_loc": [114, 906, 1509, 10, 62], "fixing_code_end_loc": [115, 907, 1510, 28, 63], "type": "CWE-94", "message": "phpMyAdmin 4.0.x before 4.0.10.16, 4.4.x before 4.4.15.7, and 4.6.x before 4.6.3 does not properly choose delimiters to prevent use of the preg_replace e (aka eval) modifier, which might allow remote attackers to execute arbitrary PHP code via a crafted string, as demonstrated by the table search-and-replace implementation.", "other": {"cve": {"id": "CVE-2016-5734", "sourceIdentifier": "cve@mitre.org", "published": "2016-07-03T01:59:24.753", "lastModified": "2017-07-01T01:29:58.877", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "phpMyAdmin 4.0.x before 4.0.10.16, 4.4.x before 4.4.15.7, and 4.6.x before 4.6.3 does not properly choose delimiters to prevent use of the preg_replace e (aka eval) modifier, which might allow remote attackers to execute arbitrary PHP code via a crafted string, as demonstrated by the table search-and-replace implementation."}, {"lang": "es", "value": "phpMyAdmin 4.0.x en versiones anteriores a 4.0.10.16, 4.4.x en versiones anteriores a 4.4.15.7 y 4.6.x en versiones anteriores a 4.6.3 no elige correctamente delimitadores para prevenir el uso del modificador preg_replace e (tambi\u00e9n conocido como eval), lo que podr\u00eda permitir a atacantes remotos ejecutar un c\u00f3digo PHP arbitrario a trav\u00e9s de una cadena manipulada, como es demostrado por la implementaci\u00f3n de la tabla search-and-replace."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F06DC95-76B1-4E24-A55F-1358A25ED0E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "2CA76CB4-6167-446A-8D4F-6D5B38046334"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "B8D28655-7F37-474D-A4E2-772AF24B94E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "1FA1951E-BD85-42BF-BF7F-79A14D165914"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "0D08BEE8-5ACF-438D-9F06-86C6227C9A5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "58DD0910-DBBA-4858-B9B1-FA93D08323D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "50DA8EBE-52AA-45A5-A5FB-75AF84E415E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "DC8D93A3-8997-4EB9-A411-74B296D1341F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "6E5A81B2-E16F-4AE2-9691-92D3E8A25CCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "0245AF2D-F856-4CAA-A830-36D43026D1E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "00BD9E52-A6BB-48BB-9FEE-D0272AD9B6DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "C69E253E-157D-45BA-A977-079A49F74A72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "6325E2AE-BB86-4953-AA9E-0433C00B096E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "3C54B828-8B23-4C62-907E-8EE7E757B721"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "02DD18C8-172B-41CD-87DD-58BDEC0D9418"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "10666E30-D98A-47A9-881A-B281066F0EC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "3993826B-CA66-4BC2-8E1B-06CF9230B214"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "14928F51-761E-4FCA-B13C-A11530C7FC46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "DB761644-20F5-4E0D-B301-7809EAECA813"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "896439D0-6C98-44A6-8C9D-0D57D57782D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "978B828C-1FCB-4386-B685-5BEE5A8A500C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "51A3261B-23BE-42D7-8A52-AE2E8C274A3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "F0B7EA51-27EC-4884-8D60-FB9477D2B91A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "D6C9F2CC-778B-4604-B463-7A1D3FB8B9C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "4B20C44D-0EF1-48F2-B0AA-C8FF0BD9E252"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "40F85FEC-427E-487D-997E-7EE359475876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "2C825978-7E00-4C20-A806-0B968AA589AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "34986C36-1C93-4DA8-A4C2-0CB8B24BAD3E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "C641F362-D37D-47CB-BE6C-36E5F116F844"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.6.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "A0EA8819-70F8-48DC-8667-6CF25E7D9C53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "DD2796DA-3E74-4765-90D1-783849C7A44C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "4024DA77-BFE4-48C6-A2AF-46003071BDE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "85631B69-7060-42D1-AE24-466BA10EB390"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E62EDC79-47AA-4CED-AB7F-1E4D158EB653"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "13CD0228-728B-437A-84C1-BD7AFA52FFB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "DFF55485-9892-4E7B-AEE0-017E61EAA7C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "6100FE3E-0A31-4B55-90F2-90AF765A8EB7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "FBAAC8D9-AAA5-487C-B4AA-84BAE5DB109E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "5E06B1D3-29B4-45B7-B81F-C864AF579011"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "6B2E3923-0E2B-411A-B091-088E6FF050D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "1848C748-804D-4FE4-AB9C-B1BF9E58A19C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "12296322-DFAD-4B36-83EC-D01BF5DF7F2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA321C14-C8F4-41FC-B601-2F646064ABBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "54DBCF86-0CE8-46C4-B2E7-E3224765CCFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "1BF3DBC5-7020-48D0-ADEA-E71776DB2285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "317F952E-5F12-4ED3-8FA3-FC1106B50F85"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "87B97F98-C0A7-4D9E-8333-7EE9EC456A12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "7A1E753D-5653-4D7A-8E41-6C02511EBFCE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "417230C7-0EC2-49F4-B810-A8AE84A302AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "103FEAB1-194E-4CEF-935A-4DBCCA298205"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "C5814003-9FF8-4F8E-9D90-A2BBB80B8451"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "16D28B77-9353-4259-9299-30638A78CCD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "C022292B-6E06-4328-842F-135A872D22AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "F15F00FB-BB9B-4D54-B198-0A74D418B8DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.2:*:*:*:*:*:*:*", "matchCriteriaId": "DC10AF20-7B65-4FAE-A2AD-783867D60A8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.3:*:*:*:*:*:*:*", "matchCriteriaId": "4EB7190C-0401-4E2E-B15F-4CFC79D5A4E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.4:*:*:*:*:*:*:*", "matchCriteriaId": "4BED20D9-C571-4BC5-9A54-450A364C6E43"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.5:*:*:*:*:*:*:*", "matchCriteriaId": "2A2B646D-DDFC-4CB2-B7F4-0C33AF18D14F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.6:*:*:*:*:*:*:*", "matchCriteriaId": "9CBF68B2-2BCF-4EEB-8A7C-D83DCAF1AFB4"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/91387", "source": "cve@mitre.org"}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/1cc7466db3a05e95fe57a6702f41773e6829d54b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/4bcc606225f15bac0b07780e74f667f6ac283da7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.gentoo.org/glsa/201701-32", "source": "cve@mitre.org"}, {"url": "https://www.exploit-db.com/exploits/40185/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.phpmyadmin.net/security/PMASA-2016-27/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/phpmyadmin/phpmyadmin/commit/1cc7466db3a05e95fe57a6702f41773e6829d54b"}}