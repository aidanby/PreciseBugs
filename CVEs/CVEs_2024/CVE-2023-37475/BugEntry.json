{"buggy_code": ["<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"http://svg.wiersma.co.za/hamba/project?title=avro&tag=A%20fast%20Go%20avro%20codec&mode=dark\">\n  <source media=\"(prefers-color-scheme: light)\" srcset=\"http://svg.wiersma.co.za/hamba/project?title=avro&tag=A%20fast%20Go%20avro%20codec\">\n  <img alt=\"Logo\" src=\"http://svg.wiersma.co.za/hamba/project?title=avro&tag=A%20fast%20Go%20avro%20codec\">\n</picture>\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/hamba/avro/v2)](https://goreportcard.com/report/github.com/hamba/avro/v2)\n[![Build Status](https://github.com/hamba/avro/actions/workflows/test.yml/badge.svg)](https://github.com/hamba/avro/actions)\n[![Coverage Status](https://coveralls.io/repos/github/hamba/avro/badge.svg?branch=main)](https://coveralls.io/github/hamba/avro?branch=main)\n[![Go Reference](https://pkg.go.dev/badge/github.com/hamba/avro/v2.svg)](https://pkg.go.dev/github.com/hamba/avro/v2)\n[![GitHub release](https://img.shields.io/github/release/hamba/avro.svg)](https://github.com/hamba/avro/releases)\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/hamba/avro/master/LICENSE)\n\nA fast Go avro codec\n\n## Overview\n\nInstall with:\n\n```shell\ngo get github.com/hamba/avro/v2\n```\n\n**Note:** This project has renamed the default branch from `master` to `main`. You will need to update your local environment.\n\n## Usage\n\n```go\ntype SimpleRecord struct {\n\tA int64  `avro:\"a\"`\n\tB string `avro:\"b\"`\n}\n\nschema, err := avro.Parse(`{\n    \"type\": \"record\",\n    \"name\": \"simple\",\n    \"namespace\": \"org.hamba.avro\",\n    \"fields\" : [\n        {\"name\": \"a\", \"type\": \"long\"},\n        {\"name\": \"b\", \"type\": \"string\"}\n    ]\n}`)\nif err != nil {\n\tlog.Fatal(err)\n}\n\nin := SimpleRecord{A: 27, B: \"foo\"}\n\ndata, err := avro.Marshal(schema, in)\nif err != nil {\n\tlog.Fatal(err)\n}\n\nfmt.Println(data)\n// Outputs: [54 6 102 111 111]\n\nout := SimpleRecord{}\nerr = avro.Unmarshal(schema, data, &out)\nif err != nil {\n\tlog.Fatal(err)\n}\n\nfmt.Println(out)\n// Outputs: {27 foo}\n```\n\nMore examples in the [godoc](https://godoc.org/github.com/hamba/avro).\n\n#### Types Conversions\n\n| Avro                    | Go Struct                                              | Go Interface             |\n|-------------------------|--------------------------------------------------------|--------------------------|\n| `null`                  | `nil`                                                  | `nil`                    |\n| `boolean`               | `bool`                                                 | `bool`                   |\n| `bytes`                 | `[]byte`                                               | `[]byte`                 |\n| `float`                 | `float32`                                              | `float32`                |\n| `double`                | `float64`                                              | `float64`                |\n| `long`                  | `int64`, `uint32`\\*                                    | `int64`, `uint32`        |\n| `int`                   | `int`, `int32`, `int16`, `int8`, `uint8`\\*, `uint16`\\* | `int`, `uint8`, `uint16` |\n| `string`                | `string`                                               | `string`                 |\n| `array`                 | `[]T`                                                  | `[]any`          |\n| `enum`                  | `string`                                               | `string`                 |\n| `fixed`                 | `[n]byte`                                              | `[]byte`                 |\n| `map`                   | `map[string]T{}`                                       | `map[string]any` |\n| `record`                | `struct`                                               | `map[string]any` |\n| `union`                 | *see below*                                            | *see below*              |\n| `int.date`              | `time.Time`                                            | `time.Time`              |\n| `int.time-millis`       | `time.Duration`                                        | `time.Duration`          |\n| `long.time-micros`      | `time.Duration`                                        | `time.Duration`          |\n| `long.timestamp-millis` | `time.Time`                                            | `time.Time`              |\n| `long.timestamp-micros` | `time.Time`                                            | `time.Time`              |\n| `bytes.decimal`         | `*big.Rat`                                             | `*big.Rat`               |\n| `fixed.decimal`         | `*big.Rat`                                             | `*big.Rat`               |\n\n\\* Please note that when the Go type is an unsigned integer care must be taken to ensure that information is not lost \nwhen converting between the Avro type and Go type. For example, storing a *negative* number in Avro of `int = -100`\nwould be interpreted as `uint16 = 65,436` in Go. Another example would be storing numbers in Avro `int = 256` that \nare larger than the Go type `uint8 = 0`. \n\n##### Unions\n\nThe following union types are accepted: `map[string]any`, `*T` and `any`.\n\n* **map[string]any:** If the union value is `nil`, a `nil` map will be en/decoded. \nWhen a non-`nil` union value is encountered, a single key is en/decoded. The key is the avro\ntype name, or scheam full name in the case of a named schema (enum, fixed or record).\n* ***T:** This is allowed in a \"nullable\" union. A nullable union is defined as a two schema union, \nwith one of the types being `null` (ie. `[\"null\", \"string\"]` or `[\"string\", \"null\"]`), in this case \na `*T` is allowed, with `T` matching the conversion table above.\n* **any:** An `interface` can be provided and the type or name resolved. Primitive types\nare pre-registered, but named types, maps and slices will need to be registered with the `Register` function. \nIn the case of arrays and maps the enclosed schema type or name is postfix to the type with a `:` separator, \ne.g `\"map:string\"`. Behavior when a type cannot be resolved will depend on your chosen configuation options:\n\t* !Config.UnionResolutionError && !Config.PartialUnionTypeResolution: the map type above is used\n\t* Config.UnionResolutionError && !Config.PartialUnionTypeResolution: an error is returned\n\t* !Config.UnionResolutionError && Config.PartialUnionTypeResolution: any registered type will get resolved while any unregistered type will fallback to the map type above.\n\t* Config.UnionResolutionError && !Config.PartialUnionTypeResolution: any registered type will get resolved while any unregistered type will return an error.\n\n##### TextMarshaler and TextUnmarshaler\n\nThe interfaces `TextMarshaler` and `TextUnmarshaler` are supported for a `string` schema type. The object will\nbe tested first for implementation of these interfaces, in the case of a `string` schema, before trying regular\nencoding and decoding.\n\nEnums may also implement `TextMarshaler` and `TextUnmarshaler`, and must resolve to valid symbols in the given enum schema.\n\n##### Identical Underlying Types\nOne type can be [ConvertibleTo](https://go.dev/ref/spec#Conversions) another type if they have identical underlying types. \nA non-native type is allowed be used if it can be convertible to *time.Time*, *big.Rat* or *avro.LogicalDuration* for the particular of *LogicalTypes*.\n\nEx.: `type Timestamp time.Time`\n\n### Recursive Structs\n\nAt this moment recursive structs are not supported. It is planned for the future.\n\n## Benchmark\n\nBenchmark source code can be found at: [https://github.com/nrwiersma/avro-benchmarks](https://github.com/nrwiersma/avro-benchmarks)\n\n```\nBenchmarkGoAvroDecode-8      \t  788455\t      1505 ns/op\t     418 B/op\t      27 allocs/op\nBenchmarkGoAvroEncode-8      \t  624343\t      1908 ns/op\t     806 B/op\t      63 allocs/op\nBenchmarkGoGenAvroDecode-8   \t 1360375\t       876.4 ns/op\t     320 B/op\t      11 allocs/op\nBenchmarkGoGenAvroEncode-8   \t 2801583\t       425.9 ns/op\t     240 B/op\t       3 allocs/op\nBenchmarkHambaDecode-8       \t 5046832\t       238.7 ns/op\t      47 B/op\t       0 allocs/op\nBenchmarkHambaEncode-8       \t 6017635\t       196.2 ns/op\t     112 B/op\t       1 allocs/op\nBenchmarkLinkedinDecode-8    \t 1000000\t      1003 ns/op\t    1688 B/op\t      35 allocs/op\nBenchmarkLinkedinEncode-8    \t 3170553\t       381.5 ns/op\t     248 B/op\t       5 allocs/op\n```\n\nAlways benchmark with your own workload. The result depends heavily on the data input.\n\n## Go structs generation\n\nGo structs can be generated for you from the schema. The types generated follow the same logic in [types conversions](#types-conversions)\n\nInstall the struct generator with:\n\n```shell\ngo install github.com/hamba/avro/v2/cmd/avrogen@<version>\n```\n\nExample usage assuming there's a valid schema in `in.avsc`:\n\n```shell\navrogen -pkg avro -o bla.go -tags json:snake,yaml:upper-camel in.avsc\n```\n\nCheck the options and usage with `-h`:\n\n```shell\navrogen -h\n```\n\nOr use it as a lib in internal commands, it's the `gen` package\n\n## Avro schema validation\n\nA small Avro schema validation command-line utility is also available. This simple tool leverages the\nschema parsing functionality of the library, showing validation errors or optionally dumping parsed\nschemas to the console. It can be used in CI/CD pipelines to validate schema changes in a repository.\n\nInstall the Avro schema validator with:\n\n```shell\ngo install github.com/hamba/avro/v2/cmd/avrosv@<version>\n```\n\nExample usage assuming there's a valid schema in `in.avsc` (exit status code is `0`):\n\n```shell\navrosv in.avsc\n```\n\nAn invalid schema will result in a diagnostic output and a non-zero exit status code:\n\n```shell\navrosv bad-default-schema.avsc; echo $?\nError: avro: invalid default for field someString. <nil> not a string\n2\n```\n\nSchemas referencing other schemas can also be validated by providing all of them (schemas are parsed in order):\n\n```shell\navrosv base-schema.avsc schema-withref.avsc\n```\n\nCheck the options and usage with `-h`:\n\n```shell\navrosv -h\n```\n\n## Go Version Support\n\nThis library supports the last two versions of Go. While the minimum Go version is\nnot guarantee to increase along side Go, it may jump from time to time to support \nadditional features. This will be not be considered a breaking change.\n", "package avro\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"sync\"\n\n\t\"github.com/modern-go/reflect2\"\n)\n\n// DefaultConfig is the default API.\nvar DefaultConfig = Config{}.Freeze()\n\n// Config customises how the codec should behave.\ntype Config struct {\n\t// TagKey is the struct tag key used when en/decoding structs.\n\t// This defaults to \"avro\".\n\tTagKey string\n\n\t// BlockLength is the length of blocks for maps and arrays.\n\t// This defaults to 100.\n\tBlockLength int\n\n\t// DisableBlockSizeHeader disables encoding of an array/map size in bytes.\n\t// Encoded array/map will be prefixed with only the number of elements in\n\t// contrast with default behavior which prefixes them with the number of elements\n\t// and the total number of bytes in the array/map. Both approaches are valid according to the\n\t// Avro specification, however not all decoders support the latter.\n\tDisableBlockSizeHeader bool\n\n\t// UnionResolutionError determines if an error will be returned\n\t// when a type cannot be resolved while decoding a union.\n\tUnionResolutionError bool\n\n\t// PartialUnionTypeResolution dictates if the union type resolution\n\t// should be attempted even when not all union types are registered.\n\t// When enabled, the underlying type will get resolved if it is registered\n\t// even if other types of the union are not. If resolution fails, logic\n\t// falls back to default union resolution behavior based on the value of\n\t// UnionResolutionError.\n\tPartialUnionTypeResolution bool\n\n\t// Disable caching layer for encoders and decoders, forcing them to get rebuilt on every\n\t// call to Marshal() and Unmarshal()\n\tDisableCaching bool\n}\n\n// Freeze makes the configuration immutable.\nfunc (c Config) Freeze() API {\n\tapi := &frozenConfig{\n\t\tconfig:   c,\n\t\tresolver: NewTypeResolver(),\n\t}\n\n\tapi.readerPool = &sync.Pool{\n\t\tNew: func() any {\n\t\t\treturn &Reader{\n\t\t\t\tcfg:    api,\n\t\t\t\treader: nil,\n\t\t\t\tbuf:    nil,\n\t\t\t\thead:   0,\n\t\t\t\ttail:   0,\n\t\t\t}\n\t\t},\n\t}\n\tapi.writerPool = &sync.Pool{\n\t\tNew: func() any {\n\t\t\treturn &Writer{\n\t\t\t\tcfg:   api,\n\t\t\t\tout:   nil,\n\t\t\t\tbuf:   make([]byte, 0, 512),\n\t\t\t\tError: nil,\n\t\t\t}\n\t\t},\n\t}\n\n\treturn api\n}\n\n// API represents a frozen Config.\ntype API interface {\n\t// Marshal returns the Avro encoding of v.\n\tMarshal(schema Schema, v any) ([]byte, error)\n\n\t// Unmarshal parses the Avro encoded data and stores the result in the value pointed to by v.\n\t// If v is nil or not a pointer, Unmarshal returns an error.\n\tUnmarshal(schema Schema, data []byte, v any) error\n\n\t// NewEncoder returns a new encoder that writes to w using schema.\n\tNewEncoder(schema Schema, w io.Writer) *Encoder\n\n\t// NewDecoder returns a new decoder that reads from reader r using schema.\n\tNewDecoder(schema Schema, r io.Reader) *Decoder\n\n\t// DecoderOf returns the value decoder for a given schema and type.\n\tDecoderOf(schema Schema, typ reflect2.Type) ValDecoder\n\n\t// EncoderOf returns the value encoder for a given schema and type.\n\tEncoderOf(schema Schema, tpy reflect2.Type) ValEncoder\n\n\t// Register registers names to their types for resolution. All primitive types are pre-registered.\n\tRegister(name string, obj any)\n}\n\ntype frozenConfig struct {\n\tconfig Config\n\n\tdecoderCache sync.Map // map[cacheKey]ValDecoder\n\tencoderCache sync.Map // map[cacheKey]ValEncoder\n\n\treaderPool *sync.Pool\n\twriterPool *sync.Pool\n\n\tresolver *TypeResolver\n}\n\nfunc (c *frozenConfig) Marshal(schema Schema, v any) ([]byte, error) {\n\twriter := c.borrowWriter()\n\n\twriter.WriteVal(schema, v)\n\tif err := writer.Error; err != nil {\n\t\tc.returnWriter(writer)\n\t\treturn nil, err\n\t}\n\n\tresult := writer.Buffer()\n\tcopied := make([]byte, len(result))\n\tcopy(copied, result)\n\n\tc.returnWriter(writer)\n\treturn copied, nil\n}\n\nfunc (c *frozenConfig) borrowWriter() *Writer {\n\twriter := c.writerPool.Get().(*Writer)\n\twriter.Reset(nil)\n\treturn writer\n}\n\nfunc (c *frozenConfig) returnWriter(writer *Writer) {\n\twriter.out = nil\n\twriter.Error = nil\n\n\tc.writerPool.Put(writer)\n}\n\nfunc (c *frozenConfig) Unmarshal(schema Schema, data []byte, v any) error {\n\treader := c.borrowReader(data)\n\n\treader.ReadVal(schema, v)\n\terr := reader.Error\n\tc.returnReader(reader)\n\n\tif errors.Is(err, io.EOF) {\n\t\treturn nil\n\t}\n\n\treturn err\n}\n\nfunc (c *frozenConfig) borrowReader(data []byte) *Reader {\n\treader := c.readerPool.Get().(*Reader)\n\treader.Reset(data)\n\treturn reader\n}\n\nfunc (c *frozenConfig) returnReader(reader *Reader) {\n\treader.Error = nil\n\tc.readerPool.Put(reader)\n}\n\nfunc (c *frozenConfig) NewEncoder(schema Schema, w io.Writer) *Encoder {\n\twriter, ok := w.(*Writer)\n\tif !ok {\n\t\twriter = NewWriter(w, 512, WithWriterConfig(c))\n\t}\n\treturn &Encoder{\n\t\ts: schema,\n\t\tw: writer,\n\t}\n}\n\nfunc (c *frozenConfig) NewDecoder(schema Schema, r io.Reader) *Decoder {\n\treader := NewReader(r, 512, WithReaderConfig(c))\n\treturn &Decoder{\n\t\ts: schema,\n\t\tr: reader,\n\t}\n}\n\nfunc (c *frozenConfig) Register(name string, obj any) {\n\tc.resolver.Register(name, obj)\n}\n\ntype cacheKey struct {\n\tfingerprint [32]byte\n\trtype       uintptr\n}\n\nfunc (c *frozenConfig) addDecoderToCache(fingerprint [32]byte, rtype uintptr, dec ValDecoder) {\n\tif c.config.DisableCaching {\n\t\treturn\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tc.decoderCache.Store(key, dec)\n}\n\nfunc (c *frozenConfig) getDecoderFromCache(fingerprint [32]byte, rtype uintptr) ValDecoder {\n\tif c.config.DisableCaching {\n\t\treturn nil\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tif dec, ok := c.decoderCache.Load(key); ok {\n\t\treturn dec.(ValDecoder)\n\t}\n\n\treturn nil\n}\n\nfunc (c *frozenConfig) addEncoderToCache(fingerprint [32]byte, rtype uintptr, enc ValEncoder) {\n\tif c.config.DisableCaching {\n\t\treturn\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tc.encoderCache.Store(key, enc)\n}\n\nfunc (c *frozenConfig) getEncoderFromCache(fingerprint [32]byte, rtype uintptr) ValEncoder {\n\tif c.config.DisableCaching {\n\t\treturn nil\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tif enc, ok := c.encoderCache.Load(key); ok {\n\t\treturn enc.(ValEncoder)\n\t}\n\n\treturn nil\n}\n\nfunc (c *frozenConfig) getTagKey() string {\n\ttagKey := c.config.TagKey\n\tif tagKey == \"\" {\n\t\treturn \"avro\"\n\t}\n\treturn tagKey\n}\n\nfunc (c *frozenConfig) getBlockLength() int {\n\tblockSize := c.config.BlockLength\n\tif blockSize <= 0 {\n\t\treturn 100\n\t}\n\treturn blockSize\n}\n", "package avro\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"unsafe\"\n)\n\nconst (\n\tmaxIntBufSize  = 5\n\tmaxLongBufSize = 10\n)\n\n// ReaderFunc is a function used to customize the Reader.\ntype ReaderFunc func(r *Reader)\n\n// WithReaderConfig specifies the configuration to use with a reader.\nfunc WithReaderConfig(cfg API) ReaderFunc {\n\treturn func(r *Reader) {\n\t\tr.cfg = cfg.(*frozenConfig)\n\t}\n}\n\n// Reader is an Avro specific io.Reader.\ntype Reader struct {\n\tcfg    *frozenConfig\n\treader io.Reader\n\tslab   []byte\n\tbuf    []byte\n\thead   int\n\ttail   int\n\tError  error\n}\n\n// NewReader creates a new Reader.\nfunc NewReader(r io.Reader, bufSize int, opts ...ReaderFunc) *Reader {\n\treader := &Reader{\n\t\tcfg:    DefaultConfig.(*frozenConfig),\n\t\treader: r,\n\t\tbuf:    make([]byte, bufSize),\n\t\thead:   0,\n\t\ttail:   0,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(reader)\n\t}\n\n\treturn reader\n}\n\n// Reset resets a Reader with a new byte array attached.\nfunc (r *Reader) Reset(b []byte) *Reader {\n\tr.reader = nil\n\tr.buf = b\n\tr.head = 0\n\tr.tail = len(b)\n\treturn r\n}\n\n// ReportError record a error in iterator instance with current position.\nfunc (r *Reader) ReportError(operation, msg string) {\n\tif r.Error != nil && !errors.Is(r.Error, io.EOF) {\n\t\treturn\n\t}\n\n\tr.Error = fmt.Errorf(\"avro: %s: %s\", operation, msg)\n}\n\nfunc (r *Reader) loadMore() bool {\n\tif r.reader == nil {\n\t\tif r.Error == nil {\n\t\t\tr.head = r.tail\n\t\t\tr.Error = io.EOF\n\t\t}\n\t\treturn false\n\t}\n\n\tfor {\n\t\tn, err := r.reader.Read(r.buf)\n\t\tif n == 0 {\n\t\t\tif err != nil {\n\t\t\t\tif r.Error == nil {\n\t\t\t\t\tr.Error = err\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tr.head = 0\n\t\tr.tail = n\n\t\treturn true\n\t}\n}\n\nfunc (r *Reader) readByte() byte {\n\tif r.head == r.tail {\n\t\tif !r.loadMore() {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tb := r.buf[r.head]\n\tr.head++\n\n\treturn b\n}\n\n// Read reads data into the given bytes.\nfunc (r *Reader) Read(b []byte) {\n\tsize := len(b)\n\tread := 0\n\n\tfor read < size {\n\t\tif r.head == r.tail {\n\t\t\tif !r.loadMore() {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tn := copy(b[read:], r.buf[r.head:r.tail])\n\t\tr.head += n\n\t\tread += n\n\t}\n}\n\n// ReadBool reads a Bool from the Reader.\nfunc (r *Reader) ReadBool() bool {\n\tb := r.readByte()\n\n\tif b != 0 && b != 1 {\n\t\tr.ReportError(\"ReadBool\", \"invalid bool\")\n\t}\n\treturn b == 1\n}\n\n// ReadInt reads an Int from the Reader.\nfunc (r *Reader) ReadInt() int32 {\n\tvar val uint32\n\tvar offset int8\n\n\tfor r.Error == nil {\n\t\tif offset == maxIntBufSize {\n\t\t\tr.ReportError(\"ReadInt\", \"int overflow\")\n\t\t\treturn 0\n\t\t}\n\n\t\tb := r.readByte()\n\t\tval |= uint32(b&0x7F) << uint(7*offset)\n\t\tif b&0x80 == 0 {\n\t\t\tbreak\n\t\t}\n\t\toffset++\n\t}\n\n\treturn int32((val >> 1) ^ -(val & 1))\n}\n\n// ReadLong reads a Long from the Reader.\nfunc (r *Reader) ReadLong() int64 {\n\tvar val uint64\n\tvar offset int8\n\n\tfor r.Error == nil {\n\t\tif offset == maxLongBufSize {\n\t\t\tr.ReportError(\"ReadLong\", \"long overflow\")\n\t\t\treturn 0\n\t\t}\n\n\t\tb := r.readByte()\n\t\tval |= uint64(b&0x7F) << uint(7*offset)\n\t\tif b&0x80 == 0 {\n\t\t\tbreak\n\t\t}\n\t\toffset++\n\t}\n\n\treturn int64((val >> 1) ^ -(val & 1))\n}\n\n// ReadFloat reads a Float from the Reader.\nfunc (r *Reader) ReadFloat() float32 {\n\tvar buf [4]byte\n\tr.Read(buf[:])\n\n\tfloat := *(*float32)(unsafe.Pointer(&buf[0]))\n\treturn float\n}\n\n// ReadDouble reads a Double from the Reader.\nfunc (r *Reader) ReadDouble() float64 {\n\tvar buf [8]byte\n\tr.Read(buf[:])\n\n\tfloat := *(*float64)(unsafe.Pointer(&buf[0]))\n\treturn float\n}\n\n// ReadBytes reads Bytes from the Reader.\nfunc (r *Reader) ReadBytes() []byte {\n\treturn r.readBytes(\"bytes\")\n}\n\n// ReadString reads a String from the Reader.\nfunc (r *Reader) ReadString() string {\n\tb := r.readBytes(\"string\")\n\tif len(b) == 0 {\n\t\treturn \"\"\n\t}\n\n\treturn *(*string)(unsafe.Pointer(&b))\n}\n\nfunc (r *Reader) readBytes(op string) []byte {\n\tsize := int(r.ReadLong())\n\tif size < 0 {\n\t\tr.ReportError(\"ReadString\", \"invalid \"+op+\" length\")\n\t\treturn nil\n\t}\n\tif size == 0 {\n\t\treturn []byte{}\n\t}\n\n\t// The bytes are entirely in the buffer and of a reasonable size.\n\t// Use the byte slab.\n\tif r.head+size <= r.tail && size <= 1024 {\n\t\tif cap(r.slab) < size {\n\t\t\tr.slab = make([]byte, 1024)\n\t\t}\n\t\tdst := r.slab[:size]\n\t\tr.slab = r.slab[size:]\n\t\tcopy(dst, r.buf[r.head:r.head+size])\n\t\tr.head += size\n\t\treturn dst\n\t}\n\n\tbuf := make([]byte, size)\n\tr.Read(buf)\n\treturn buf\n}\n\n// ReadBlockHeader reads a Block Header from the Reader.\nfunc (r *Reader) ReadBlockHeader() (int64, int64) {\n\tlength := r.ReadLong()\n\tif length < 0 {\n\t\tsize := r.ReadLong()\n\n\t\treturn -length, size\n\t}\n\n\treturn length, 0\n}\n", "package avro_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/hamba/avro/v2\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewReader(t *testing.T) {\n\tr := avro.NewReader(bytes.NewBuffer([]byte{}), 10)\n\n\tassert.IsType(t, &avro.Reader{}, r)\n}\n\nfunc TestReader_Reset(t *testing.T) {\n\tr := &avro.Reader{}\n\n\tr.Reset([]byte{0x01})\n\n\tassert.True(t, r.ReadBool())\n}\n\nfunc TestReader_ReportError(t *testing.T) {\n\tr := &avro.Reader{}\n\n\tr.ReportError(\"test\", \"bar\")\n\n\tassert.EqualError(t, r.Error, \"avro: test: bar\")\n}\n\nfunc TestReader_ReportErrorExistingError(t *testing.T) {\n\terr := errors.New(\"test\")\n\n\tr := &avro.Reader{}\n\tr.Error = err\n\n\tr.ReportError(\"test\", \"bar\")\n\n\tassert.Equal(t, err, r.Error)\n}\n\nfunc TestReader_ReadPastBuffer(t *testing.T) {\n\tr := (&avro.Reader{}).Reset([]byte{0xE2})\n\n\tr.ReadInt()\n\n\tassert.Error(t, r.Error)\n}\n\nfunc TestReader_ReadDelayedReader(t *testing.T) {\n\trdr := &delayedReader{b: []byte{0x36}}\n\tr := avro.NewReader(rdr, 10)\n\n\ti := r.ReadInt()\n\n\trequire.NoError(t, r.Error)\n\tassert.Equal(t, int32(27), i)\n}\n\nfunc TestReader_Read(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdata    []byte\n\t\twant    []byte\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tname:    \"valid\",\n\t\t\tdata:    []byte{0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twant:    []byte{0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"eof\",\n\t\t\tdata:    []byte{0xAC}, // io.EOF\n\t\t\twant:    []byte{0xAC, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 2)\n\n\t\t\tgot := make([]byte, 6)\n\t\t\tr.Read(got)\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadBool(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdata    []byte\n\t\twant    bool\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tname:    \"false\",\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    false,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"true\",\n\t\t\tdata:    []byte{0x01},\n\t\t\twant:    true,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid bool\",\n\t\t\tdata:    []byte{0x02},\n\t\t\twant:    false,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tname:    \"eof\",\n\t\t\tdata:    []byte(nil), // io.EOF\n\t\t\twant:    false,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadBool()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadInt(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdata    []byte\n\t\twant    int32\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tname:    \"positive int\",\n\t\t\tdata:    []byte{0x36},\n\t\t\twant:    27,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative int\",\n\t\t\tdata:    []byte{0x0F},\n\t\t\twant:    -8,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative int\",\n\t\t\tdata:    []byte{0x01},\n\t\t\twant:    -1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"zero\",\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"one\",\n\t\t\tdata:    []byte{0x02},\n\t\t\twant:    1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative 64\",\n\t\t\tdata:    []byte{0x7F},\n\t\t\twant:    -64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"multi byte int\",\n\t\t\tdata:    []byte{0x80, 0x01},\n\t\t\twant:    64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"large int\",\n\t\t\tdata:    []byte{0xAA, 0xB4, 0xDE, 0x75},\n\t\t\twant:    123456789,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"larger int\",\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0x07},\n\t\t\twant:    987654321,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"overflow\",\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0xAD, 0xAD},\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tname:    \"eof\",\n\t\t\tdata:    []byte{0xE2},\n\t\t\twant:    49,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadInt()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadLong(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    int64\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x36},\n\t\t\twant:    27,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0F},\n\t\t\twant:    -8,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x01},\n\t\t\twant:    -1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x02},\n\t\t\twant:    1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x7F},\n\t\t\twant:    -64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x80, 0x01},\n\t\t\twant:    64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xAA, 0xB4, 0xDE, 0x75},\n\t\t\twant:    123456789,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0x07},\n\t\t\twant:    987654321,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01},\n\t\t\twant:    -9223372036854775808,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xBD, 0xB1, 0xAE, 0xD4, 0xD2, 0xCD, 0xBD, 0xE4, 0x97, 0x01},\n\t\t\twant:    -5468631321897454687,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0xAD, 0xAD, 0xE2, 0xA2, 0xF3, 0xAD, 0xAD}, // Overflow\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xE2}, // io.EOF\n\t\t\twant:    49,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadLong()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadFloat(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    float32\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00},\n\t\t\twant:    0.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x80, 0x3F},\n\t\t\twant:    1.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x33, 0x33, 0x93, 0x3F},\n\t\t\twant:    1.15,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x23, 0xDB, 0x57, 0xC2},\n\t\t\twant:    -53.964,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xA3, 0x79, 0xEB, 0xCC},\n\t\t\twant:    -123456789.123,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x62, 0x20, 0x71, 0x49},\n\t\t\twant:    987654.111115,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tr := avro.NewReader(bytes.NewReader(test.data), 2)\n\n\t\tgot := r.ReadFloat()\n\n\t\ttest.wantErr(t, r.Error)\n\t\tassert.Equal(t, test.want, got)\n\t}\n}\n\nfunc TestReader_ReadDouble(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    float64\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\twant:    0.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F},\n\t\t\twant:    1.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xF2, 0x3F},\n\t\t\twant:    1.15,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0xAC, 0x1C, 0x5A, 0x64, 0xFB, 0x4A, 0xC0},\n\t\t\twant:    -53.964,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xB6, 0xF3, 0x7D, 0x54, 0x34, 0x6F, 0x9D, 0xC1},\n\t\t\twant:    -123456789.123,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xB6, 0x10, 0xE4, 0x38, 0x0C, 0x24, 0x2E, 0x41},\n\t\t\twant:    987654.111115,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x75, 0x6B, 0x7E, 0x54, 0x34, 0x6F, 0x9D, 0x41},\n\t\t\twant:    123456789.123456789,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00, 0xD0, 0x12, 0x63, 0x41},\n\t\t\twant:    9999999.99999999999999999999999,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x18, 0xFC, 0x1A, 0xDD, 0x1F, 0x0E, 0x0A, 0x43},\n\t\t\twant:    916734926348163.01973408746523,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0A, 0x8F, 0xA6, 0x40, 0xAC, 0xAD, 0x8D, 0xC3},\n\t\t\twant:    -267319348967891263.1928357138913857,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := avro.NewReader(bytes.NewReader(test.data), 4)\n\n\t\tgot := r.ReadDouble()\n\n\t\ttest.wantErr(t, r.Error)\n\t\tassert.Equal(t, test.want, got)\n\t}\n}\n\nfunc TestReader_ReadBytes(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    []byte\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x02, 0x02},\n\t\t\twant:    []byte{0x02},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x04, 0x03, 0xFF},\n\t\t\twant:    []byte{0x03, 0xFF},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0xEC, 0xAB, 0x44, 0x00},\n\t\t\twant:    []byte{0xEC, 0xAB, 0x44, 0x00},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0C, 0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twant:    []byte{0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF no length\n\t\t\twant:    []byte{},\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x05, 0x03, 0xFF, 0x0A}, // Invalid bytes length\n\t\t\twant:    nil,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0xFF}, // io.EOF length greater then data\n\t\t\twant:    []byte{0xFF, 0x0, 0x0, 0x0},\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadBytes()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadString(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    string\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    \"\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x06, 0x66, 0x6F, 0x6F},\n\t\t\twant:    \"foo\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0x61, 0x76, 0x72, 0x6F},\n\t\t\twant:    \"avro\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0C, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65},\n\t\t\twant:    \"apache\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x28, 0x6F, 0x70, 0x70, 0x61, 0x6E, 0x20, 0x67, 0x61, 0x6E, 0x67, 0x6E, 0x61, 0x6D, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x21},\n\t\t\twant:    \"oppan gangnam style!\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x36, 0xD1, 0x87, 0xD0, 0xB5, 0x2D, 0xD1, 0x82, 0xD0, 0xBE, 0x20, 0xD0, 0xBF, 0xD0, 0xBE, 0x20, 0xD1, 0x80, 0xD1, 0x83, 0xD1, 0x81, 0xD1, 0x81, 0xD0, 0xBA, 0xD0, 0xB8},\n\t\t\twant:    \"\u0447\u0435-\u0442\u043e \u043f\u043e \u0440\u0443\u0441\u0441\u043a\u0438\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0C, 0xE4, 0xB8, 0x96, 0xE7, 0x95, 0x8C},\n\t\t\twant:    \"\u4e16\u754c\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x22, 0x21, 0xE2, 0x84, 0x96, 0x3B, 0x25, 0x3A, 0x3F, 0x2A, 0x22, 0x28, 0x29, 0x40, 0x23, 0x24, 0x5E, 0x26},\n\t\t\twant:    \"!\u2116;%:?*\\\"()@#$^&\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF no length\n\t\t\twant:    \"\",\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x05, 0x66, 0x6F, 0x6F, 0x6F}, // Invalid string length\n\t\t\twant:    \"\",\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0x66}, // io.EOF length greater then data\n\t\t\twant:    \"\\x66\\x00\\x00\\x00\",\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadString()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadStringFastPathIsntBoundToBuffer(t *testing.T) {\n\tdata := []byte{0x06, 0x66, 0x6F, 0x6F, 0x08, 0x61, 0x76, 0x72, 0x6F}\n\tr := avro.NewReader(bytes.NewReader(data), 4)\n\n\tgot1 := r.ReadString()\n\tgot2 := r.ReadString()\n\n\trequire.NoError(t, r.Error)\n\tassert.Equal(t, \"foo\", got1)\n\tassert.Equal(t, \"avro\", got2)\n}\n\nfunc TestReader_ReadBlockHeader(t *testing.T) {\n\ttests := []struct {\n\t\tdata []byte\n\t\tlen  int64\n\t\tsize int64\n\t}{\n\t\t{\n\t\t\tdata: []byte{0x80, 0x01},\n\t\t\tlen:  64,\n\t\t\tsize: 0,\n\t\t},\n\t\t{\n\t\t\tdata: []byte{0x7F, 0x80, 0x01},\n\t\t\tlen:  64,\n\t\t\tsize: 64,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\tgotLen, gotSize := r.ReadBlockHeader()\n\n\t\trequire.NoError(t, r.Error)\n\t\tassert.Equal(t, test.len, gotLen)\n\t\tassert.Equal(t, test.size, gotSize)\n\t}\n}\n\ntype delayedReader struct {\n\tcount int\n\tb     []byte\n}\n\nfunc (r *delayedReader) Read(p []byte) (n int, err error) {\n\tif r.count == 0 {\n\t\tr.count++\n\t\treturn 0, nil\n\t}\n\n\treturn copy(p, r.b), nil\n}\n"], "fixing_code": ["<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"http://svg.wiersma.co.za/hamba/project?title=avro&tag=A%20fast%20Go%20avro%20codec&mode=dark\">\n  <source media=\"(prefers-color-scheme: light)\" srcset=\"http://svg.wiersma.co.za/hamba/project?title=avro&tag=A%20fast%20Go%20avro%20codec\">\n  <img alt=\"Logo\" src=\"http://svg.wiersma.co.za/hamba/project?title=avro&tag=A%20fast%20Go%20avro%20codec\">\n</picture>\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/hamba/avro/v2)](https://goreportcard.com/report/github.com/hamba/avro/v2)\n[![Build Status](https://github.com/hamba/avro/actions/workflows/test.yml/badge.svg)](https://github.com/hamba/avro/actions)\n[![Coverage Status](https://coveralls.io/repos/github/hamba/avro/badge.svg?branch=main)](https://coveralls.io/github/hamba/avro?branch=main)\n[![Go Reference](https://pkg.go.dev/badge/github.com/hamba/avro/v2.svg)](https://pkg.go.dev/github.com/hamba/avro/v2)\n[![GitHub release](https://img.shields.io/github/release/hamba/avro.svg)](https://github.com/hamba/avro/releases)\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/hamba/avro/master/LICENSE)\n\nA fast Go avro codec\n\n## Overview\n\nInstall with:\n\n```shell\ngo get github.com/hamba/avro/v2\n```\n\n**Note:** This project has renamed the default branch from `master` to `main`. You will need to update your local environment.\n\n## Usage\n\n```go\ntype SimpleRecord struct {\n\tA int64  `avro:\"a\"`\n\tB string `avro:\"b\"`\n}\n\nschema, err := avro.Parse(`{\n    \"type\": \"record\",\n    \"name\": \"simple\",\n    \"namespace\": \"org.hamba.avro\",\n    \"fields\" : [\n        {\"name\": \"a\", \"type\": \"long\"},\n        {\"name\": \"b\", \"type\": \"string\"}\n    ]\n}`)\nif err != nil {\n\tlog.Fatal(err)\n}\n\nin := SimpleRecord{A: 27, B: \"foo\"}\n\ndata, err := avro.Marshal(schema, in)\nif err != nil {\n\tlog.Fatal(err)\n}\n\nfmt.Println(data)\n// Outputs: [54 6 102 111 111]\n\nout := SimpleRecord{}\nerr = avro.Unmarshal(schema, data, &out)\nif err != nil {\n\tlog.Fatal(err)\n}\n\nfmt.Println(out)\n// Outputs: {27 foo}\n```\n\nMore examples in the [godoc](https://godoc.org/github.com/hamba/avro).\n\n#### Types Conversions\n\n| Avro                    | Go Struct                                              | Go Interface             |\n|-------------------------|--------------------------------------------------------|--------------------------|\n| `null`                  | `nil`                                                  | `nil`                    |\n| `boolean`               | `bool`                                                 | `bool`                   |\n| `bytes`                 | `[]byte`                                               | `[]byte`                 |\n| `float`                 | `float32`                                              | `float32`                |\n| `double`                | `float64`                                              | `float64`                |\n| `long`                  | `int64`, `uint32`\\*                                    | `int64`, `uint32`        |\n| `int`                   | `int`, `int32`, `int16`, `int8`, `uint8`\\*, `uint16`\\* | `int`, `uint8`, `uint16` |\n| `string`                | `string`                                               | `string`                 |\n| `array`                 | `[]T`                                                  | `[]any`          |\n| `enum`                  | `string`                                               | `string`                 |\n| `fixed`                 | `[n]byte`                                              | `[]byte`                 |\n| `map`                   | `map[string]T{}`                                       | `map[string]any` |\n| `record`                | `struct`                                               | `map[string]any` |\n| `union`                 | *see below*                                            | *see below*              |\n| `int.date`              | `time.Time`                                            | `time.Time`              |\n| `int.time-millis`       | `time.Duration`                                        | `time.Duration`          |\n| `long.time-micros`      | `time.Duration`                                        | `time.Duration`          |\n| `long.timestamp-millis` | `time.Time`                                            | `time.Time`              |\n| `long.timestamp-micros` | `time.Time`                                            | `time.Time`              |\n| `bytes.decimal`         | `*big.Rat`                                             | `*big.Rat`               |\n| `fixed.decimal`         | `*big.Rat`                                             | `*big.Rat`               |\n\n\\* Please note that when the Go type is an unsigned integer care must be taken to ensure that information is not lost \nwhen converting between the Avro type and Go type. For example, storing a *negative* number in Avro of `int = -100`\nwould be interpreted as `uint16 = 65,436` in Go. Another example would be storing numbers in Avro `int = 256` that \nare larger than the Go type `uint8 = 0`. \n\n##### Unions\n\nThe following union types are accepted: `map[string]any`, `*T` and `any`.\n\n* **map[string]any:** If the union value is `nil`, a `nil` map will be en/decoded. \nWhen a non-`nil` union value is encountered, a single key is en/decoded. The key is the avro\ntype name, or scheam full name in the case of a named schema (enum, fixed or record).\n* ***T:** This is allowed in a \"nullable\" union. A nullable union is defined as a two schema union, \nwith one of the types being `null` (ie. `[\"null\", \"string\"]` or `[\"string\", \"null\"]`), in this case \na `*T` is allowed, with `T` matching the conversion table above.\n* **any:** An `interface` can be provided and the type or name resolved. Primitive types\nare pre-registered, but named types, maps and slices will need to be registered with the `Register` function. \nIn the case of arrays and maps the enclosed schema type or name is postfix to the type with a `:` separator, \ne.g `\"map:string\"`. Behavior when a type cannot be resolved will depend on your chosen configuation options:\n\t* !Config.UnionResolutionError && !Config.PartialUnionTypeResolution: the map type above is used\n\t* Config.UnionResolutionError && !Config.PartialUnionTypeResolution: an error is returned\n\t* !Config.UnionResolutionError && Config.PartialUnionTypeResolution: any registered type will get resolved while any unregistered type will fallback to the map type above.\n\t* Config.UnionResolutionError && !Config.PartialUnionTypeResolution: any registered type will get resolved while any unregistered type will return an error.\n\n##### TextMarshaler and TextUnmarshaler\n\nThe interfaces `TextMarshaler` and `TextUnmarshaler` are supported for a `string` schema type. The object will\nbe tested first for implementation of these interfaces, in the case of a `string` schema, before trying regular\nencoding and decoding.\n\nEnums may also implement `TextMarshaler` and `TextUnmarshaler`, and must resolve to valid symbols in the given enum schema.\n\n##### Identical Underlying Types\n\nOne type can be [ConvertibleTo](https://go.dev/ref/spec#Conversions) another type if they have identical underlying types. \nA non-native type is allowed be used if it can be convertible to *time.Time*, *big.Rat* or *avro.LogicalDuration* for the particular of *LogicalTypes*.\n\nEx.: `type Timestamp time.Time`\n\n##### Untrusted Input With Bytes and Strings\n\nFor security reasons, the configuration `Config.MaxByteSliceSize` restricts the maximum size of `bytes` and `string` types created\nby the `Reader`. The default maximum size is `1MiB` and is configurable. This is required to stop untrusted input from consuming all memory and\ncrashing the application. Should this not be need, setting a negative number will disable the behaviour.\n\n### Recursive Structs\n\nAt this moment recursive structs are not supported. It is planned for the future.\n\n## Benchmark\n\nBenchmark source code can be found at: [https://github.com/nrwiersma/avro-benchmarks](https://github.com/nrwiersma/avro-benchmarks)\n\n```\nBenchmarkGoAvroDecode-8      \t  788455\t      1505 ns/op\t     418 B/op\t      27 allocs/op\nBenchmarkGoAvroEncode-8      \t  624343\t      1908 ns/op\t     806 B/op\t      63 allocs/op\nBenchmarkGoGenAvroDecode-8   \t 1360375\t       876.4 ns/op\t     320 B/op\t      11 allocs/op\nBenchmarkGoGenAvroEncode-8   \t 2801583\t       425.9 ns/op\t     240 B/op\t       3 allocs/op\nBenchmarkHambaDecode-8       \t 5046832\t       238.7 ns/op\t      47 B/op\t       0 allocs/op\nBenchmarkHambaEncode-8       \t 6017635\t       196.2 ns/op\t     112 B/op\t       1 allocs/op\nBenchmarkLinkedinDecode-8    \t 1000000\t      1003 ns/op\t    1688 B/op\t      35 allocs/op\nBenchmarkLinkedinEncode-8    \t 3170553\t       381.5 ns/op\t     248 B/op\t       5 allocs/op\n```\n\nAlways benchmark with your own workload. The result depends heavily on the data input.\n\n## Go structs generation\n\nGo structs can be generated for you from the schema. The types generated follow the same logic in [types conversions](#types-conversions)\n\nInstall the struct generator with:\n\n```shell\ngo install github.com/hamba/avro/v2/cmd/avrogen@<version>\n```\n\nExample usage assuming there's a valid schema in `in.avsc`:\n\n```shell\navrogen -pkg avro -o bla.go -tags json:snake,yaml:upper-camel in.avsc\n```\n\nCheck the options and usage with `-h`:\n\n```shell\navrogen -h\n```\n\nOr use it as a lib in internal commands, it's the `gen` package\n\n## Avro schema validation\n\nA small Avro schema validation command-line utility is also available. This simple tool leverages the\nschema parsing functionality of the library, showing validation errors or optionally dumping parsed\nschemas to the console. It can be used in CI/CD pipelines to validate schema changes in a repository.\n\nInstall the Avro schema validator with:\n\n```shell\ngo install github.com/hamba/avro/v2/cmd/avrosv@<version>\n```\n\nExample usage assuming there's a valid schema in `in.avsc` (exit status code is `0`):\n\n```shell\navrosv in.avsc\n```\n\nAn invalid schema will result in a diagnostic output and a non-zero exit status code:\n\n```shell\navrosv bad-default-schema.avsc; echo $?\nError: avro: invalid default for field someString. <nil> not a string\n2\n```\n\nSchemas referencing other schemas can also be validated by providing all of them (schemas are parsed in order):\n\n```shell\navrosv base-schema.avsc schema-withref.avsc\n```\n\nCheck the options and usage with `-h`:\n\n```shell\navrosv -h\n```\n\n## Go Version Support\n\nThis library supports the last two versions of Go. While the minimum Go version is\nnot guarantee to increase along side Go, it may jump from time to time to support \nadditional features. This will be not be considered a breaking change.\n", "package avro\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"sync\"\n\n\t\"github.com/modern-go/reflect2\"\n)\n\nconst maxByteSliceSize = 1024 * 1024\n\n// DefaultConfig is the default API.\nvar DefaultConfig = Config{}.Freeze()\n\n// Config customises how the codec should behave.\ntype Config struct {\n\t// TagKey is the struct tag key used when en/decoding structs.\n\t// This defaults to \"avro\".\n\tTagKey string\n\n\t// BlockLength is the length of blocks for maps and arrays.\n\t// This defaults to 100.\n\tBlockLength int\n\n\t// DisableBlockSizeHeader disables encoding of an array/map size in bytes.\n\t// Encoded array/map will be prefixed with only the number of elements in\n\t// contrast with default behavior which prefixes them with the number of elements\n\t// and the total number of bytes in the array/map. Both approaches are valid according to the\n\t// Avro specification, however not all decoders support the latter.\n\tDisableBlockSizeHeader bool\n\n\t// UnionResolutionError determines if an error will be returned\n\t// when a type cannot be resolved while decoding a union.\n\tUnionResolutionError bool\n\n\t// PartialUnionTypeResolution dictates if the union type resolution\n\t// should be attempted even when not all union types are registered.\n\t// When enabled, the underlying type will get resolved if it is registered\n\t// even if other types of the union are not. If resolution fails, logic\n\t// falls back to default union resolution behavior based on the value of\n\t// UnionResolutionError.\n\tPartialUnionTypeResolution bool\n\n\t// Disable caching layer for encoders and decoders, forcing them to get rebuilt on every\n\t// call to Marshal() and Unmarshal()\n\tDisableCaching bool\n\n\t// MaxByteSliceSize is the maximum size of `bytes` or `string` types the Reader will create, defaulting to 1MiB.\n\t// If this size is exceeded, the Reader returns an error. This can be disabled by setting a negative number.\n\tMaxByteSliceSize int\n}\n\n// Freeze makes the configuration immutable.\nfunc (c Config) Freeze() API {\n\tapi := &frozenConfig{\n\t\tconfig:   c,\n\t\tresolver: NewTypeResolver(),\n\t}\n\n\tapi.readerPool = &sync.Pool{\n\t\tNew: func() any {\n\t\t\treturn &Reader{\n\t\t\t\tcfg:    api,\n\t\t\t\treader: nil,\n\t\t\t\tbuf:    nil,\n\t\t\t\thead:   0,\n\t\t\t\ttail:   0,\n\t\t\t}\n\t\t},\n\t}\n\tapi.writerPool = &sync.Pool{\n\t\tNew: func() any {\n\t\t\treturn &Writer{\n\t\t\t\tcfg:   api,\n\t\t\t\tout:   nil,\n\t\t\t\tbuf:   make([]byte, 0, 512),\n\t\t\t\tError: nil,\n\t\t\t}\n\t\t},\n\t}\n\n\treturn api\n}\n\n// API represents a frozen Config.\ntype API interface {\n\t// Marshal returns the Avro encoding of v.\n\tMarshal(schema Schema, v any) ([]byte, error)\n\n\t// Unmarshal parses the Avro encoded data and stores the result in the value pointed to by v.\n\t// If v is nil or not a pointer, Unmarshal returns an error.\n\tUnmarshal(schema Schema, data []byte, v any) error\n\n\t// NewEncoder returns a new encoder that writes to w using schema.\n\tNewEncoder(schema Schema, w io.Writer) *Encoder\n\n\t// NewDecoder returns a new decoder that reads from reader r using schema.\n\tNewDecoder(schema Schema, r io.Reader) *Decoder\n\n\t// DecoderOf returns the value decoder for a given schema and type.\n\tDecoderOf(schema Schema, typ reflect2.Type) ValDecoder\n\n\t// EncoderOf returns the value encoder for a given schema and type.\n\tEncoderOf(schema Schema, tpy reflect2.Type) ValEncoder\n\n\t// Register registers names to their types for resolution. All primitive types are pre-registered.\n\tRegister(name string, obj any)\n}\n\ntype frozenConfig struct {\n\tconfig Config\n\n\tdecoderCache sync.Map // map[cacheKey]ValDecoder\n\tencoderCache sync.Map // map[cacheKey]ValEncoder\n\n\treaderPool *sync.Pool\n\twriterPool *sync.Pool\n\n\tresolver *TypeResolver\n}\n\nfunc (c *frozenConfig) Marshal(schema Schema, v any) ([]byte, error) {\n\twriter := c.borrowWriter()\n\n\twriter.WriteVal(schema, v)\n\tif err := writer.Error; err != nil {\n\t\tc.returnWriter(writer)\n\t\treturn nil, err\n\t}\n\n\tresult := writer.Buffer()\n\tcopied := make([]byte, len(result))\n\tcopy(copied, result)\n\n\tc.returnWriter(writer)\n\treturn copied, nil\n}\n\nfunc (c *frozenConfig) borrowWriter() *Writer {\n\twriter := c.writerPool.Get().(*Writer)\n\twriter.Reset(nil)\n\treturn writer\n}\n\nfunc (c *frozenConfig) returnWriter(writer *Writer) {\n\twriter.out = nil\n\twriter.Error = nil\n\n\tc.writerPool.Put(writer)\n}\n\nfunc (c *frozenConfig) Unmarshal(schema Schema, data []byte, v any) error {\n\treader := c.borrowReader(data)\n\n\treader.ReadVal(schema, v)\n\terr := reader.Error\n\tc.returnReader(reader)\n\n\tif errors.Is(err, io.EOF) {\n\t\treturn nil\n\t}\n\n\treturn err\n}\n\nfunc (c *frozenConfig) borrowReader(data []byte) *Reader {\n\treader := c.readerPool.Get().(*Reader)\n\treader.Reset(data)\n\treturn reader\n}\n\nfunc (c *frozenConfig) returnReader(reader *Reader) {\n\treader.Error = nil\n\tc.readerPool.Put(reader)\n}\n\nfunc (c *frozenConfig) NewEncoder(schema Schema, w io.Writer) *Encoder {\n\twriter, ok := w.(*Writer)\n\tif !ok {\n\t\twriter = NewWriter(w, 512, WithWriterConfig(c))\n\t}\n\treturn &Encoder{\n\t\ts: schema,\n\t\tw: writer,\n\t}\n}\n\nfunc (c *frozenConfig) NewDecoder(schema Schema, r io.Reader) *Decoder {\n\treader := NewReader(r, 512, WithReaderConfig(c))\n\treturn &Decoder{\n\t\ts: schema,\n\t\tr: reader,\n\t}\n}\n\nfunc (c *frozenConfig) Register(name string, obj any) {\n\tc.resolver.Register(name, obj)\n}\n\ntype cacheKey struct {\n\tfingerprint [32]byte\n\trtype       uintptr\n}\n\nfunc (c *frozenConfig) addDecoderToCache(fingerprint [32]byte, rtype uintptr, dec ValDecoder) {\n\tif c.config.DisableCaching {\n\t\treturn\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tc.decoderCache.Store(key, dec)\n}\n\nfunc (c *frozenConfig) getDecoderFromCache(fingerprint [32]byte, rtype uintptr) ValDecoder {\n\tif c.config.DisableCaching {\n\t\treturn nil\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tif dec, ok := c.decoderCache.Load(key); ok {\n\t\treturn dec.(ValDecoder)\n\t}\n\n\treturn nil\n}\n\nfunc (c *frozenConfig) addEncoderToCache(fingerprint [32]byte, rtype uintptr, enc ValEncoder) {\n\tif c.config.DisableCaching {\n\t\treturn\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tc.encoderCache.Store(key, enc)\n}\n\nfunc (c *frozenConfig) getEncoderFromCache(fingerprint [32]byte, rtype uintptr) ValEncoder {\n\tif c.config.DisableCaching {\n\t\treturn nil\n\t}\n\tkey := cacheKey{fingerprint: fingerprint, rtype: rtype}\n\tif enc, ok := c.encoderCache.Load(key); ok {\n\t\treturn enc.(ValEncoder)\n\t}\n\n\treturn nil\n}\n\nfunc (c *frozenConfig) getTagKey() string {\n\ttagKey := c.config.TagKey\n\tif tagKey == \"\" {\n\t\treturn \"avro\"\n\t}\n\treturn tagKey\n}\n\nfunc (c *frozenConfig) getBlockLength() int {\n\tblockSize := c.config.BlockLength\n\tif blockSize <= 0 {\n\t\treturn 100\n\t}\n\treturn blockSize\n}\n\nfunc (c *frozenConfig) getMaxByteSliceSize() int {\n\tsize := c.config.MaxByteSliceSize\n\tif size == 0 {\n\t\treturn maxByteSliceSize\n\t}\n\treturn size\n}\n", "package avro\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"unsafe\"\n)\n\nconst (\n\tmaxIntBufSize  = 5\n\tmaxLongBufSize = 10\n)\n\n// ReaderFunc is a function used to customize the Reader.\ntype ReaderFunc func(r *Reader)\n\n// WithReaderConfig specifies the configuration to use with a reader.\nfunc WithReaderConfig(cfg API) ReaderFunc {\n\treturn func(r *Reader) {\n\t\tr.cfg = cfg.(*frozenConfig)\n\t}\n}\n\n// Reader is an Avro specific io.Reader.\ntype Reader struct {\n\tcfg    *frozenConfig\n\treader io.Reader\n\tslab   []byte\n\tbuf    []byte\n\thead   int\n\ttail   int\n\tError  error\n}\n\n// NewReader creates a new Reader.\nfunc NewReader(r io.Reader, bufSize int, opts ...ReaderFunc) *Reader {\n\treader := &Reader{\n\t\tcfg:    DefaultConfig.(*frozenConfig),\n\t\treader: r,\n\t\tbuf:    make([]byte, bufSize),\n\t\thead:   0,\n\t\ttail:   0,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(reader)\n\t}\n\n\treturn reader\n}\n\n// Reset resets a Reader with a new byte array attached.\nfunc (r *Reader) Reset(b []byte) *Reader {\n\tr.reader = nil\n\tr.buf = b\n\tr.head = 0\n\tr.tail = len(b)\n\treturn r\n}\n\n// ReportError record a error in iterator instance with current position.\nfunc (r *Reader) ReportError(operation, msg string) {\n\tif r.Error != nil && !errors.Is(r.Error, io.EOF) {\n\t\treturn\n\t}\n\n\tr.Error = fmt.Errorf(\"avro: %s: %s\", operation, msg)\n}\n\nfunc (r *Reader) loadMore() bool {\n\tif r.reader == nil {\n\t\tif r.Error == nil {\n\t\t\tr.head = r.tail\n\t\t\tr.Error = io.EOF\n\t\t}\n\t\treturn false\n\t}\n\n\tfor {\n\t\tn, err := r.reader.Read(r.buf)\n\t\tif n == 0 {\n\t\t\tif err != nil {\n\t\t\t\tif r.Error == nil {\n\t\t\t\t\tr.Error = err\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tr.head = 0\n\t\tr.tail = n\n\t\treturn true\n\t}\n}\n\nfunc (r *Reader) readByte() byte {\n\tif r.head == r.tail {\n\t\tif !r.loadMore() {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tb := r.buf[r.head]\n\tr.head++\n\n\treturn b\n}\n\n// Read reads data into the given bytes.\nfunc (r *Reader) Read(b []byte) {\n\tsize := len(b)\n\tread := 0\n\n\tfor read < size {\n\t\tif r.head == r.tail {\n\t\t\tif !r.loadMore() {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tn := copy(b[read:], r.buf[r.head:r.tail])\n\t\tr.head += n\n\t\tread += n\n\t}\n}\n\n// ReadBool reads a Bool from the Reader.\nfunc (r *Reader) ReadBool() bool {\n\tb := r.readByte()\n\n\tif b != 0 && b != 1 {\n\t\tr.ReportError(\"ReadBool\", \"invalid bool\")\n\t}\n\treturn b == 1\n}\n\n// ReadInt reads an Int from the Reader.\nfunc (r *Reader) ReadInt() int32 {\n\tvar val uint32\n\tvar offset int8\n\n\tfor r.Error == nil {\n\t\tif offset == maxIntBufSize {\n\t\t\tr.ReportError(\"ReadInt\", \"int overflow\")\n\t\t\treturn 0\n\t\t}\n\n\t\tb := r.readByte()\n\t\tval |= uint32(b&0x7F) << uint(7*offset)\n\t\tif b&0x80 == 0 {\n\t\t\tbreak\n\t\t}\n\t\toffset++\n\t}\n\n\treturn int32((val >> 1) ^ -(val & 1))\n}\n\n// ReadLong reads a Long from the Reader.\nfunc (r *Reader) ReadLong() int64 {\n\tvar val uint64\n\tvar offset int8\n\n\tfor r.Error == nil {\n\t\tif offset == maxLongBufSize {\n\t\t\tr.ReportError(\"ReadLong\", \"long overflow\")\n\t\t\treturn 0\n\t\t}\n\n\t\tb := r.readByte()\n\t\tval |= uint64(b&0x7F) << uint(7*offset)\n\t\tif b&0x80 == 0 {\n\t\t\tbreak\n\t\t}\n\t\toffset++\n\t}\n\n\treturn int64((val >> 1) ^ -(val & 1))\n}\n\n// ReadFloat reads a Float from the Reader.\nfunc (r *Reader) ReadFloat() float32 {\n\tvar buf [4]byte\n\tr.Read(buf[:])\n\n\tfloat := *(*float32)(unsafe.Pointer(&buf[0]))\n\treturn float\n}\n\n// ReadDouble reads a Double from the Reader.\nfunc (r *Reader) ReadDouble() float64 {\n\tvar buf [8]byte\n\tr.Read(buf[:])\n\n\tfloat := *(*float64)(unsafe.Pointer(&buf[0]))\n\treturn float\n}\n\n// ReadBytes reads Bytes from the Reader.\nfunc (r *Reader) ReadBytes() []byte {\n\treturn r.readBytes(\"bytes\")\n}\n\n// ReadString reads a String from the Reader.\nfunc (r *Reader) ReadString() string {\n\tb := r.readBytes(\"string\")\n\tif len(b) == 0 {\n\t\treturn \"\"\n\t}\n\n\treturn *(*string)(unsafe.Pointer(&b))\n}\n\nfunc (r *Reader) readBytes(op string) []byte {\n\tsize := int(r.ReadLong())\n\tif size < 0 {\n\t\tfnName := \"Read\" + strings.ToTitle(op)\n\t\tr.ReportError(fnName, \"invalid \"+op+\" length\")\n\t\treturn nil\n\t}\n\tif size == 0 {\n\t\treturn []byte{}\n\t}\n\tif max := r.cfg.getMaxByteSliceSize(); max > 0 && size > max {\n\t\tfnName := \"Read\" + strings.ToTitle(op)\n\t\tr.ReportError(fnName, \"size is greater than `Config.MaxByteSliceSize`\")\n\t\treturn nil\n\t}\n\n\t// The bytes are entirely in the buffer and of a reasonable size.\n\t// Use the byte slab.\n\tif r.head+size <= r.tail && size <= 1024 {\n\t\tif cap(r.slab) < size {\n\t\t\tr.slab = make([]byte, 1024)\n\t\t}\n\t\tdst := r.slab[:size]\n\t\tr.slab = r.slab[size:]\n\t\tcopy(dst, r.buf[r.head:r.head+size])\n\t\tr.head += size\n\t\treturn dst\n\t}\n\n\tbuf := make([]byte, size)\n\tr.Read(buf)\n\treturn buf\n}\n\n// ReadBlockHeader reads a Block Header from the Reader.\nfunc (r *Reader) ReadBlockHeader() (int64, int64) {\n\tlength := r.ReadLong()\n\tif length < 0 {\n\t\tsize := r.ReadLong()\n\n\t\treturn -length, size\n\t}\n\n\treturn length, 0\n}\n", "package avro_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/hamba/avro/v2\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewReader(t *testing.T) {\n\tr := avro.NewReader(bytes.NewBuffer([]byte{}), 10)\n\n\tassert.IsType(t, &avro.Reader{}, r)\n}\n\nfunc TestReader_Reset(t *testing.T) {\n\tr := &avro.Reader{}\n\n\tr.Reset([]byte{0x01})\n\n\tassert.True(t, r.ReadBool())\n}\n\nfunc TestReader_ReportError(t *testing.T) {\n\tr := &avro.Reader{}\n\n\tr.ReportError(\"test\", \"bar\")\n\n\tassert.EqualError(t, r.Error, \"avro: test: bar\")\n}\n\nfunc TestReader_ReportErrorExistingError(t *testing.T) {\n\terr := errors.New(\"test\")\n\n\tr := &avro.Reader{}\n\tr.Error = err\n\n\tr.ReportError(\"test\", \"bar\")\n\n\tassert.Equal(t, err, r.Error)\n}\n\nfunc TestReader_ReadPastBuffer(t *testing.T) {\n\tr := (&avro.Reader{}).Reset([]byte{0xE2})\n\n\tr.ReadInt()\n\n\tassert.Error(t, r.Error)\n}\n\nfunc TestReader_ReadDelayedReader(t *testing.T) {\n\trdr := &delayedReader{b: []byte{0x36}}\n\tr := avro.NewReader(rdr, 10)\n\n\ti := r.ReadInt()\n\n\trequire.NoError(t, r.Error)\n\tassert.Equal(t, int32(27), i)\n}\n\nfunc TestReader_Read(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdata    []byte\n\t\twant    []byte\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tname:    \"valid\",\n\t\t\tdata:    []byte{0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twant:    []byte{0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"eof\",\n\t\t\tdata:    []byte{0xAC}, // io.EOF\n\t\t\twant:    []byte{0xAC, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 2)\n\n\t\t\tgot := make([]byte, 6)\n\t\t\tr.Read(got)\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadBool(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdata    []byte\n\t\twant    bool\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tname:    \"false\",\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    false,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"true\",\n\t\t\tdata:    []byte{0x01},\n\t\t\twant:    true,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid bool\",\n\t\t\tdata:    []byte{0x02},\n\t\t\twant:    false,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tname:    \"eof\",\n\t\t\tdata:    []byte(nil), // io.EOF\n\t\t\twant:    false,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadBool()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadInt(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdata    []byte\n\t\twant    int32\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tname:    \"positive int\",\n\t\t\tdata:    []byte{0x36},\n\t\t\twant:    27,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative int\",\n\t\t\tdata:    []byte{0x0F},\n\t\t\twant:    -8,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative int\",\n\t\t\tdata:    []byte{0x01},\n\t\t\twant:    -1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"zero\",\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"one\",\n\t\t\tdata:    []byte{0x02},\n\t\t\twant:    1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative 64\",\n\t\t\tdata:    []byte{0x7F},\n\t\t\twant:    -64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"multi byte int\",\n\t\t\tdata:    []byte{0x80, 0x01},\n\t\t\twant:    64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"large int\",\n\t\t\tdata:    []byte{0xAA, 0xB4, 0xDE, 0x75},\n\t\t\twant:    123456789,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"larger int\",\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0x07},\n\t\t\twant:    987654321,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tname:    \"overflow\",\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0xAD, 0xAD},\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tname:    \"eof\",\n\t\t\tdata:    []byte{0xE2},\n\t\t\twant:    49,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadInt()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadLong(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    int64\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x36},\n\t\t\twant:    27,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0F},\n\t\t\twant:    -8,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x01},\n\t\t\twant:    -1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x02},\n\t\t\twant:    1,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x7F},\n\t\t\twant:    -64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x80, 0x01},\n\t\t\twant:    64,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xAA, 0xB4, 0xDE, 0x75},\n\t\t\twant:    123456789,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0x07},\n\t\t\twant:    987654321,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01},\n\t\t\twant:    9223372036854775807,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01},\n\t\t\twant:    -9223372036854775808,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xBD, 0xB1, 0xAE, 0xD4, 0xD2, 0xCD, 0xBD, 0xE4, 0x97, 0x01},\n\t\t\twant:    -5468631321897454687,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xE2, 0xA2, 0xF3, 0xAD, 0xAD, 0xAD, 0xE2, 0xA2, 0xF3, 0xAD, 0xAD}, // Overflow\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xE2}, // io.EOF\n\t\t\twant:    49,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadLong()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadFloat(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    float32\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00},\n\t\t\twant:    0.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x80, 0x3F},\n\t\t\twant:    1.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x33, 0x33, 0x93, 0x3F},\n\t\t\twant:    1.15,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x23, 0xDB, 0x57, 0xC2},\n\t\t\twant:    -53.964,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xA3, 0x79, 0xEB, 0xCC},\n\t\t\twant:    -123456789.123,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x62, 0x20, 0x71, 0x49},\n\t\t\twant:    987654.111115,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tr := avro.NewReader(bytes.NewReader(test.data), 2)\n\n\t\tgot := r.ReadFloat()\n\n\t\ttest.wantErr(t, r.Error)\n\t\tassert.Equal(t, test.want, got)\n\t}\n}\n\nfunc TestReader_ReadDouble(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    float64\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\twant:    0.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F},\n\t\t\twant:    1.0,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xF2, 0x3F},\n\t\t\twant:    1.15,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0xAC, 0x1C, 0x5A, 0x64, 0xFB, 0x4A, 0xC0},\n\t\t\twant:    -53.964,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xB6, 0xF3, 0x7D, 0x54, 0x34, 0x6F, 0x9D, 0xC1},\n\t\t\twant:    -123456789.123,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0xB6, 0x10, 0xE4, 0x38, 0x0C, 0x24, 0x2E, 0x41},\n\t\t\twant:    987654.111115,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x75, 0x6B, 0x7E, 0x54, 0x34, 0x6F, 0x9D, 0x41},\n\t\t\twant:    123456789.123456789,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x00, 0x00, 0x00, 0x00, 0xD0, 0x12, 0x63, 0x41},\n\t\t\twant:    9999999.99999999999999999999999,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x18, 0xFC, 0x1A, 0xDD, 0x1F, 0x0E, 0x0A, 0x43},\n\t\t\twant:    916734926348163.01973408746523,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0A, 0x8F, 0xA6, 0x40, 0xAC, 0xAD, 0x8D, 0xC3},\n\t\t\twant:    -267319348967891263.1928357138913857,\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF\n\t\t\twant:    0,\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := avro.NewReader(bytes.NewReader(test.data), 4)\n\n\t\tgot := r.ReadDouble()\n\n\t\ttest.wantErr(t, r.Error)\n\t\tassert.Equal(t, test.want, got)\n\t}\n}\n\nfunc TestReader_ReadBytes(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    []byte\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x02, 0x02},\n\t\t\twant:    []byte{0x02},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x04, 0x03, 0xFF},\n\t\t\twant:    []byte{0x03, 0xFF},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0xEC, 0xAB, 0x44, 0x00},\n\t\t\twant:    []byte{0xEC, 0xAB, 0x44, 0x00},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0C, 0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twant:    []byte{0xAC, 0xDC, 0x01, 0x00, 0x10, 0x0F},\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF no length\n\t\t\twant:    []byte{},\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x05, 0x03, 0xFF, 0x0A}, // Invalid bytes length\n\t\t\twant:    nil,\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0xFF}, // io.EOF length greater then data\n\t\t\twant:    []byte{0xFF, 0x0, 0x0, 0x0},\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadBytes()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadBytesLargerThanMaxByteSliceSize(t *testing.T) {\n\tdata := []byte{\n\t\t246, 255, 255, 255, 255, 10, 255, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t\t32, 32, 32, 32, 32, 32, 32,\n\t}\n\tr := avro.NewReader(bytes.NewReader(data), 4)\n\n\t_ = r.ReadBytes()\n\n\tassert.Error(t, r.Error)\n}\n\nfunc TestReader_ReadString(t *testing.T) {\n\ttests := []struct {\n\t\tdata    []byte\n\t\twant    string\n\t\twantErr require.ErrorAssertionFunc\n\t}{\n\t\t{\n\t\t\tdata:    []byte{0x00},\n\t\t\twant:    \"\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x06, 0x66, 0x6F, 0x6F},\n\t\t\twant:    \"foo\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0x61, 0x76, 0x72, 0x6F},\n\t\t\twant:    \"avro\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0C, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65},\n\t\t\twant:    \"apache\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x28, 0x6F, 0x70, 0x70, 0x61, 0x6E, 0x20, 0x67, 0x61, 0x6E, 0x67, 0x6E, 0x61, 0x6D, 0x20, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x21},\n\t\t\twant:    \"oppan gangnam style!\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x36, 0xD1, 0x87, 0xD0, 0xB5, 0x2D, 0xD1, 0x82, 0xD0, 0xBE, 0x20, 0xD0, 0xBF, 0xD0, 0xBE, 0x20, 0xD1, 0x80, 0xD1, 0x83, 0xD1, 0x81, 0xD1, 0x81, 0xD0, 0xBA, 0xD0, 0xB8},\n\t\t\twant:    \"\u0447\u0435-\u0442\u043e \u043f\u043e \u0440\u0443\u0441\u0441\u043a\u0438\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x0C, 0xE4, 0xB8, 0x96, 0xE7, 0x95, 0x8C},\n\t\t\twant:    \"\u4e16\u754c\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x22, 0x21, 0xE2, 0x84, 0x96, 0x3B, 0x25, 0x3A, 0x3F, 0x2A, 0x22, 0x28, 0x29, 0x40, 0x23, 0x24, 0x5E, 0x26},\n\t\t\twant:    \"!\u2116;%:?*\\\"()@#$^&\",\n\t\t\twantErr: require.NoError,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(nil), // io.EOF no length\n\t\t\twant:    \"\",\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x05, 0x66, 0x6F, 0x6F, 0x6F}, // Invalid string length\n\t\t\twant:    \"\",\n\t\t\twantErr: require.Error,\n\t\t},\n\t\t{\n\t\t\tdata:    []byte{0x08, 0x66}, // io.EOF length greater then data\n\t\t\twant:    \"\\x66\\x00\\x00\\x00\",\n\t\t\twantErr: require.Error,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\t\tgot := r.ReadString()\n\n\t\t\ttest.wantErr(t, r.Error)\n\t\t\tassert.Equal(t, test.want, got)\n\t\t})\n\t}\n}\n\nfunc TestReader_ReadStringLargerThanMaxByteSliceSize(t *testing.T) {\n\tdata := []byte{\n\t\t246, 255, 255, 255, 255, 10, 255, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t\t32, 32, 32, 32, 32, 32, 32,\n\t}\n\tr := avro.NewReader(bytes.NewReader(data), 4)\n\n\t_ = r.ReadString()\n\n\tassert.Error(t, r.Error)\n}\n\nfunc TestReader_ReadStringFastPathIsntBoundToBuffer(t *testing.T) {\n\tdata := []byte{0x06, 0x66, 0x6F, 0x6F, 0x08, 0x61, 0x76, 0x72, 0x6F}\n\tr := avro.NewReader(bytes.NewReader(data), 4)\n\n\tgot1 := r.ReadString()\n\tgot2 := r.ReadString()\n\n\trequire.NoError(t, r.Error)\n\tassert.Equal(t, \"foo\", got1)\n\tassert.Equal(t, \"avro\", got2)\n}\n\nfunc TestReader_ReadBlockHeader(t *testing.T) {\n\ttests := []struct {\n\t\tdata []byte\n\t\tlen  int64\n\t\tsize int64\n\t}{\n\t\t{\n\t\t\tdata: []byte{0x80, 0x01},\n\t\t\tlen:  64,\n\t\t\tsize: 0,\n\t\t},\n\t\t{\n\t\t\tdata: []byte{0x7F, 0x80, 0x01},\n\t\t\tlen:  64,\n\t\t\tsize: 64,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := avro.NewReader(bytes.NewReader(test.data), 10)\n\n\t\tgotLen, gotSize := r.ReadBlockHeader()\n\n\t\trequire.NoError(t, r.Error)\n\t\tassert.Equal(t, test.len, gotLen)\n\t\tassert.Equal(t, test.size, gotSize)\n\t}\n}\n\ntype delayedReader struct {\n\tcount int\n\tb     []byte\n}\n\nfunc (r *delayedReader) Read(p []byte) (n int, err error) {\n\tif r.count == 0 {\n\t\tr.count++\n\t\treturn 0, nil\n\t}\n\n\treturn copy(p, r.b), nil\n}\n"], "filenames": ["README.md", "config.go", "reader.go", "reader_test.go"], "buggy_code_start_loc": [127, 9, 6, 509], "buggy_code_end_loc": [131, 254, 223, 585], "fixing_code_start_loc": [128, 10, 7, 510], "fixing_code_end_loc": [139, 269, 231, 612], "type": "CWE-400", "message": "Hamba avro is a go lang encoder/decoder implementation of the avro codec specification. In affected versions a well-crafted string passed to avro's `github.com/hamba/avro/v2.Unmarshal()` can throw a `fatal error: runtime: out of memory` which is unrecoverable and can cause denial of service of the consumer of avro. The root cause of the issue is that avro uses part of the input to `Unmarshal()` to determine the size when creating a new slice and hence an attacker may consume arbitrary amounts of memory which in turn may cause the application to crash. This issue has been addressed in commit `b4a402f4` which has been included in release version `2.13.0`. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-37475", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-17T17:15:10.127", "lastModified": "2023-07-26T21:35:57.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Hamba avro is a go lang encoder/decoder implementation of the avro codec specification. In affected versions a well-crafted string passed to avro's `github.com/hamba/avro/v2.Unmarshal()` can throw a `fatal error: runtime: out of memory` which is unrecoverable and can cause denial of service of the consumer of avro. The root cause of the issue is that avro uses part of the input to `Unmarshal()` to determine the size when creating a new slice and hence an attacker may consume arbitrary amounts of memory which in turn may cause the application to crash. This issue has been addressed in commit `b4a402f4` which has been included in release version `2.13.0`. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:avro_project:avro:*:*:*:*:*:go:*:*", "versionEndExcluding": "2.13.0", "matchCriteriaId": "5AC3910F-0EB5-45EE-B590-FE81DEE4ED39"}]}]}], "references": [{"url": "https://github.com/hamba/avro/commit/b4a402f41cf44b6094b5131286830ba9bb1eb290", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/hamba/avro/security/advisories/GHSA-9x44-9pgq-cf45", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/hamba/avro/commit/b4a402f41cf44b6094b5131286830ba9bb1eb290"}}