{"buggy_code": ["/* \n        pf.c    (c) 1997-8  Grant R. Guenther <grant@torque.net>\n                            Under the terms of the GNU General Public License.\n\n        This is the high-level driver for parallel port ATAPI disk\n        drives based on chips supported by the paride module.\n\n        By default, the driver will autoprobe for a single parallel\n        port ATAPI disk drive, but if their individual parameters are\n        specified, the driver can handle up to 4 drives.\n\n        The behaviour of the pf driver can be altered by setting\n        some parameters from the insmod command line.  The following\n        parameters are adjustable:\n\n            drive0      These four arguments can be arrays of       \n            drive1      1-7 integers as follows:\n            drive2\n            drive3      <prt>,<pro>,<uni>,<mod>,<slv>,<lun>,<dly>\n\n                        Where,\n\n                <prt>   is the base of the parallel port address for\n                        the corresponding drive.  (required)\n\n                <pro>   is the protocol number for the adapter that\n                        supports this drive.  These numbers are\n                        logged by 'paride' when the protocol modules\n                        are initialised.  (0 if not given)\n\n                <uni>   for those adapters that support chained\n                        devices, this is the unit selector for the\n                        chain of devices on the given port.  It should\n                        be zero for devices that don't support chaining.\n                        (0 if not given)\n\n                <mod>   this can be -1 to choose the best mode, or one\n                        of the mode numbers supported by the adapter.\n                        (-1 if not given)\n\n                <slv>   ATAPI CDroms can be jumpered to master or slave.\n                        Set this to 0 to choose the master drive, 1 to\n                        choose the slave, -1 (the default) to choose the\n                        first drive found.\n\n\t\t<lun>   Some ATAPI devices support multiple LUNs.\n                        One example is the ATAPI PD/CD drive from\n                        Matshita/Panasonic.  This device has a \n                        CD drive on LUN 0 and a PD drive on LUN 1.\n                        By default, the driver will search for the\n                        first LUN with a supported device.  Set \n                        this parameter to force it to use a specific\n                        LUN.  (default -1)\n\n                <dly>   some parallel ports require the driver to \n                        go more slowly.  -1 sets a default value that\n                        should work with the chosen protocol.  Otherwise,\n                        set this to a small integer, the larger it is\n                        the slower the port i/o.  In some cases, setting\n                        this to zero will speed up the device. (default -1)\n\n\t    major\tYou may use this parameter to override the\n\t\t\tdefault major number (47) that this driver\n\t\t\twill use.  Be sure to change the device\n\t\t\tname as well.\n\n\t    name\tThis parameter is a character string that\n\t\t\tcontains the name the kernel will use for this\n\t\t\tdevice (in /proc output, for instance).\n\t\t\t(default \"pf\").\n\n            cluster     The driver will attempt to aggregate requests\n                        for adjacent blocks into larger multi-block\n                        clusters.  The maximum cluster size (in 512\n                        byte sectors) is set with this parameter.\n                        (default 64)\n\n            verbose     This parameter controls the amount of logging\n                        that the driver will do.  Set it to 0 for\n                        normal operation, 1 to see autoprobe progress\n                        messages, or 2 to see additional debugging\n                        output.  (default 0)\n \n\t    nice        This parameter controls the driver's use of\n\t\t\tidle CPU time, at the expense of some speed.\n\n        If this driver is built into the kernel, you can use the\n        following command line parameters, with the same values\n        as the corresponding module parameters listed above:\n\n            pf.drive0\n            pf.drive1\n            pf.drive2\n            pf.drive3\n\t    pf.cluster\n            pf.nice\n\n        In addition, you can use the parameter pf.disable to disable\n        the driver entirely.\n\n*/\n\n/* Changes:\n\n\t1.01\tGRG 1998.05.03  Changes for SMP.  Eliminate sti().\n\t\t\t\tFix for drives that don't clear STAT_ERR\n\t\t\t        until after next CDB delivered.\n\t\t\t\tSmall change in pf_completion to round\n\t\t\t\tup transfer size.\n\t1.02    GRG 1998.06.16  Eliminated an Ugh\n\t1.03    GRG 1998.08.16  Use HZ in loop timings, extra debugging\n\t1.04    GRG 1998.09.24  Added jumbo support\n\n*/\n\n#define PF_VERSION      \"1.04\"\n#define PF_MAJOR\t47\n#define PF_NAME\t\t\"pf\"\n#define PF_UNITS\t4\n\n#include <linux/types.h>\n\n/* Here are things one can override from the insmod command.\n   Most are autoprobed by paride unless set here.  Verbose is off\n   by default.\n\n*/\n\nstatic bool verbose = 0;\nstatic int major = PF_MAJOR;\nstatic char *name = PF_NAME;\nstatic int cluster = 64;\nstatic int nice = 0;\nstatic int disable = 0;\n\nstatic int drive0[7] = { 0, 0, 0, -1, -1, -1, -1 };\nstatic int drive1[7] = { 0, 0, 0, -1, -1, -1, -1 };\nstatic int drive2[7] = { 0, 0, 0, -1, -1, -1, -1 };\nstatic int drive3[7] = { 0, 0, 0, -1, -1, -1, -1 };\n\nstatic int (*drives[4])[7] = {&drive0, &drive1, &drive2, &drive3};\nstatic int pf_drive_count;\n\nenum {D_PRT, D_PRO, D_UNI, D_MOD, D_SLV, D_LUN, D_DLY};\n\n/* end of parameters */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/hdreg.h>\n#include <linux/cdrom.h>\n#include <linux/spinlock.h>\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\nstatic DEFINE_MUTEX(pf_mutex);\nstatic DEFINE_SPINLOCK(pf_spin_lock);\n\nmodule_param(verbose, bool, 0644);\nmodule_param(major, int, 0);\nmodule_param(name, charp, 0);\nmodule_param(cluster, int, 0);\nmodule_param(nice, int, 0);\nmodule_param_array(drive0, int, NULL, 0);\nmodule_param_array(drive1, int, NULL, 0);\nmodule_param_array(drive2, int, NULL, 0);\nmodule_param_array(drive3, int, NULL, 0);\n\n#include \"paride.h\"\n#include \"pseudo.h\"\n\n/* constants for faking geometry numbers */\n\n#define PF_FD_MAX\t8192\t/* use FD geometry under this size */\n#define PF_FD_HDS\t2\n#define PF_FD_SPT\t18\n#define PF_HD_HDS\t64\n#define PF_HD_SPT\t32\n\n#define PF_MAX_RETRIES  5\n#define PF_TMO          800\t/* interrupt timeout in jiffies */\n#define PF_SPIN_DEL     50\t/* spin delay in micro-seconds  */\n\n#define PF_SPIN         (1000000*PF_TMO)/(HZ*PF_SPIN_DEL)\n\n#define STAT_ERR        0x00001\n#define STAT_INDEX      0x00002\n#define STAT_ECC        0x00004\n#define STAT_DRQ        0x00008\n#define STAT_SEEK       0x00010\n#define STAT_WRERR      0x00020\n#define STAT_READY      0x00040\n#define STAT_BUSY       0x00080\n\n#define ATAPI_REQ_SENSE\t\t0x03\n#define ATAPI_LOCK\t\t0x1e\n#define ATAPI_DOOR\t\t0x1b\n#define ATAPI_MODE_SENSE\t0x5a\n#define ATAPI_CAPACITY\t\t0x25\n#define ATAPI_IDENTIFY\t\t0x12\n#define ATAPI_READ_10\t\t0x28\n#define ATAPI_WRITE_10\t\t0x2a\n\nstatic int pf_open(struct block_device *bdev, fmode_t mode);\nstatic blk_status_t pf_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tconst struct blk_mq_queue_data *bd);\nstatic int pf_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg);\nstatic int pf_getgeo(struct block_device *bdev, struct hd_geometry *geo);\n\nstatic void pf_release(struct gendisk *disk, fmode_t mode);\n\nstatic int pf_detect(void);\nstatic void do_pf_read(void);\nstatic void do_pf_read_start(void);\nstatic void do_pf_write(void);\nstatic void do_pf_write_start(void);\nstatic void do_pf_read_drq(void);\nstatic void do_pf_write_done(void);\n\n#define PF_NM           0\n#define PF_RO           1\n#define PF_RW           2\n\n#define PF_NAMELEN      8\n\nstruct pf_unit {\n\tstruct pi_adapter pia;\t/* interface to paride layer */\n\tstruct pi_adapter *pi;\n\tint removable;\t\t/* removable media device  ?  */\n\tint media_status;\t/* media present ?  WP ? */\n\tint drive;\t\t/* drive */\n\tint lun;\n\tint access;\t\t/* count of active opens ... */\n\tint present;\t\t/* device present ? */\n\tchar name[PF_NAMELEN];\t/* pf0, pf1, ... */\n\tstruct gendisk *disk;\n\tstruct blk_mq_tag_set tag_set;\n\tstruct list_head rq_list;\n};\n\nstatic struct pf_unit units[PF_UNITS];\n\nstatic int pf_identify(struct pf_unit *pf);\nstatic void pf_lock(struct pf_unit *pf, int func);\nstatic void pf_eject(struct pf_unit *pf);\nstatic unsigned int pf_check_events(struct gendisk *disk,\n\t\t\t\t    unsigned int clearing);\n\nstatic char pf_scratch[512];\t/* scratch block buffer */\n\n/* the variables below are used mainly in the I/O request engine, which\n   processes only one request at a time.\n*/\n\nstatic int pf_retries = 0;\t/* i/o error retry count */\nstatic int pf_busy = 0;\t\t/* request being processed ? */\nstatic struct request *pf_req;\t/* current request */\nstatic int pf_block;\t\t/* address of next requested block */\nstatic int pf_count;\t\t/* number of blocks still to do */\nstatic int pf_run;\t\t/* sectors in current cluster */\nstatic int pf_cmd;\t\t/* current command READ/WRITE */\nstatic struct pf_unit *pf_current;/* unit of current request */\nstatic int pf_mask;\t\t/* stopper for pseudo-int */\nstatic char *pf_buf;\t\t/* buffer for request in progress */\nstatic void *par_drv;\t\t/* reference of parport driver */\n\n/* kernel glue structures */\n\nstatic const struct block_device_operations pf_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pf_open,\n\t.release\t= pf_release,\n\t.ioctl\t\t= pf_ioctl,\n\t.getgeo\t\t= pf_getgeo,\n\t.check_events\t= pf_check_events,\n};\n\nstatic const struct blk_mq_ops pf_mq_ops = {\n\t.queue_rq\t= pf_queue_rq,\n};\n\nstatic void __init pf_init_units(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tpf_drive_count = 0;\n\tfor (unit = 0, pf = units; unit < PF_UNITS; unit++, pf++) {\n\t\tstruct gendisk *disk;\n\n\t\tdisk = alloc_disk(1);\n\t\tif (!disk)\n\t\t\tcontinue;\n\n\t\tdisk->queue = blk_mq_init_sq_queue(&pf->tag_set, &pf_mq_ops,\n\t\t\t\t\t\t\t1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&pf->rq_list);\n\t\tdisk->queue->queuedata = pf;\n\t\tblk_queue_max_segments(disk->queue, cluster);\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tpf->disk = disk;\n\t\tpf->pi = &pf->pia;\n\t\tpf->media_status = PF_NM;\n\t\tpf->drive = (*drives[unit])[D_SLV];\n\t\tpf->lun = (*drives[unit])[D_LUN];\n\t\tsnprintf(pf->name, PF_NAMELEN, \"%s%d\", name, unit);\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, pf->name);\n\t\tdisk->fops = &pf_fops;\n\t\tif (!(*drives[unit])[D_PRT])\n\t\t\tpf_drive_count++;\n\t}\n}\n\nstatic int pf_open(struct block_device *bdev, fmode_t mode)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\tint ret;\n\n\tmutex_lock(&pf_mutex);\n\tpf_identify(pf);\n\n\tret = -ENODEV;\n\tif (pf->media_status == PF_NM)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif ((pf->media_status == PF_RO) && (mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = 0;\n\tpf->access++;\n\tif (pf->removable)\n\t\tpf_lock(pf, 1);\nout:\n\tmutex_unlock(&pf_mutex);\n\treturn ret;\n}\n\nstatic int pf_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\tsector_t capacity = get_capacity(pf->disk);\n\n\tif (capacity < PF_FD_MAX) {\n\t\tgeo->cylinders = sector_div(capacity, PF_FD_HDS * PF_FD_SPT);\n\t\tgeo->heads = PF_FD_HDS;\n\t\tgeo->sectors = PF_FD_SPT;\n\t} else {\n\t\tgeo->cylinders = sector_div(capacity, PF_HD_HDS * PF_HD_SPT);\n\t\tgeo->heads = PF_HD_HDS;\n\t\tgeo->sectors = PF_HD_SPT;\n\t}\n\n\treturn 0;\n}\n\nstatic int pf_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\n\tif (cmd != CDROMEJECT)\n\t\treturn -EINVAL;\n\n\tif (pf->access != 1)\n\t\treturn -EBUSY;\n\tmutex_lock(&pf_mutex);\n\tpf_eject(pf);\n\tmutex_unlock(&pf_mutex);\n\n\treturn 0;\n}\n\nstatic void pf_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct pf_unit *pf = disk->private_data;\n\n\tmutex_lock(&pf_mutex);\n\tif (pf->access <= 0) {\n\t\tmutex_unlock(&pf_mutex);\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tpf->access--;\n\n\tif (!pf->access && pf->removable)\n\t\tpf_lock(pf, 0);\n\n\tmutex_unlock(&pf_mutex);\n}\n\nstatic unsigned int pf_check_events(struct gendisk *disk, unsigned int clearing)\n{\n\treturn DISK_EVENT_MEDIA_CHANGE;\n}\n\nstatic inline int status_reg(struct pf_unit *pf)\n{\n\treturn pi_read_regr(pf->pi, 1, 6);\n}\n\nstatic inline int read_reg(struct pf_unit *pf, int reg)\n{\n\treturn pi_read_regr(pf->pi, 0, reg);\n}\n\nstatic inline void write_reg(struct pf_unit *pf, int reg, int val)\n{\n\tpi_write_regr(pf->pi, 0, reg, val);\n}\n\nstatic int pf_wait(struct pf_unit *pf, int go, int stop, char *fun, char *msg)\n{\n\tint j, r, e, s, p;\n\n\tj = 0;\n\twhile ((((r = status_reg(pf)) & go) || (stop && (!(r & stop))))\n\t       && (j++ < PF_SPIN))\n\t\tudelay(PF_SPIN_DEL);\n\n\tif ((r & (STAT_ERR & stop)) || (j > PF_SPIN)) {\n\t\ts = read_reg(pf, 7);\n\t\te = read_reg(pf, 1);\n\t\tp = read_reg(pf, 2);\n\t\tif (j > PF_SPIN)\n\t\t\te |= 0x100;\n\t\tif (fun)\n\t\t\tprintk(\"%s: %s %s: alt=0x%x stat=0x%x err=0x%x\"\n\t\t\t       \" loop=%d phase=%d\\n\",\n\t\t\t       pf->name, fun, msg, r, s, e, j, p);\n\t\treturn (e << 8) + s;\n\t}\n\treturn 0;\n}\n\nstatic int pf_command(struct pf_unit *pf, char *cmd, int dlen, char *fun)\n{\n\tpi_connect(pf->pi);\n\n\twrite_reg(pf, 6, 0xa0+0x10*pf->drive);\n\n\tif (pf_wait(pf, STAT_BUSY | STAT_DRQ, 0, fun, \"before command\")) {\n\t\tpi_disconnect(pf->pi);\n\t\treturn -1;\n\t}\n\n\twrite_reg(pf, 4, dlen % 256);\n\twrite_reg(pf, 5, dlen / 256);\n\twrite_reg(pf, 7, 0xa0);\t/* ATAPI packet command */\n\n\tif (pf_wait(pf, STAT_BUSY, STAT_DRQ, fun, \"command DRQ\")) {\n\t\tpi_disconnect(pf->pi);\n\t\treturn -1;\n\t}\n\n\tif (read_reg(pf, 2) != 1) {\n\t\tprintk(\"%s: %s: command phase error\\n\", pf->name, fun);\n\t\tpi_disconnect(pf->pi);\n\t\treturn -1;\n\t}\n\n\tpi_write_block(pf->pi, cmd, 12);\n\n\treturn 0;\n}\n\nstatic int pf_completion(struct pf_unit *pf, char *buf, char *fun)\n{\n\tint r, s, n;\n\n\tr = pf_wait(pf, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,\n\t\t    fun, \"completion\");\n\n\tif ((read_reg(pf, 2) & 2) && (read_reg(pf, 7) & STAT_DRQ)) {\n\t\tn = (((read_reg(pf, 4) + 256 * read_reg(pf, 5)) +\n\t\t      3) & 0xfffc);\n\t\tpi_read_block(pf->pi, buf, n);\n\t}\n\n\ts = pf_wait(pf, STAT_BUSY, STAT_READY | STAT_ERR, fun, \"data done\");\n\n\tpi_disconnect(pf->pi);\n\n\treturn (r ? r : s);\n}\n\nstatic void pf_req_sense(struct pf_unit *pf, int quiet)\n{\n\tchar rs_cmd[12] =\n\t    { ATAPI_REQ_SENSE, pf->lun << 5, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[16];\n\tint r;\n\n\tr = pf_command(pf, rs_cmd, 16, \"Request sense\");\n\tmdelay(1);\n\tif (!r)\n\t\tpf_completion(pf, buf, \"Request sense\");\n\n\tif ((!r) && (!quiet))\n\t\tprintk(\"%s: Sense key: %x, ASC: %x, ASQ: %x\\n\",\n\t\t       pf->name, buf[2] & 0xf, buf[12], buf[13]);\n}\n\nstatic int pf_atapi(struct pf_unit *pf, char *cmd, int dlen, char *buf, char *fun)\n{\n\tint r;\n\n\tr = pf_command(pf, cmd, dlen, fun);\n\tmdelay(1);\n\tif (!r)\n\t\tr = pf_completion(pf, buf, fun);\n\tif (r)\n\t\tpf_req_sense(pf, !fun);\n\n\treturn r;\n}\n\nstatic void pf_lock(struct pf_unit *pf, int func)\n{\n\tchar lo_cmd[12] = { ATAPI_LOCK, pf->lun << 5, 0, 0, func, 0, 0, 0, 0, 0, 0, 0 };\n\n\tpf_atapi(pf, lo_cmd, 0, pf_scratch, func ? \"lock\" : \"unlock\");\n}\n\nstatic void pf_eject(struct pf_unit *pf)\n{\n\tchar ej_cmd[12] = { ATAPI_DOOR, pf->lun << 5, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 };\n\n\tpf_lock(pf, 0);\n\tpf_atapi(pf, ej_cmd, 0, pf_scratch, \"eject\");\n}\n\n#define PF_RESET_TMO   30\t/* in tenths of a second */\n\nstatic void pf_sleep(int cs)\n{\n\tschedule_timeout_interruptible(cs);\n}\n\n/* the ATAPI standard actually specifies the contents of all 7 registers\n   after a reset, but the specification is ambiguous concerning the last\n   two bytes, and different drives interpret the standard differently.\n */\n\nstatic int pf_reset(struct pf_unit *pf)\n{\n\tint i, k, flg;\n\tint expect[5] = { 1, 1, 1, 0x14, 0xeb };\n\n\tpi_connect(pf->pi);\n\twrite_reg(pf, 6, 0xa0+0x10*pf->drive);\n\twrite_reg(pf, 7, 8);\n\n\tpf_sleep(20 * HZ / 1000);\n\n\tk = 0;\n\twhile ((k++ < PF_RESET_TMO) && (status_reg(pf) & STAT_BUSY))\n\t\tpf_sleep(HZ / 10);\n\n\tflg = 1;\n\tfor (i = 0; i < 5; i++)\n\t\tflg &= (read_reg(pf, i + 1) == expect[i]);\n\n\tif (verbose) {\n\t\tprintk(\"%s: Reset (%d) signature = \", pf->name, k);\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tprintk(\"%3x\", read_reg(pf, i + 1));\n\t\tif (!flg)\n\t\t\tprintk(\" (incorrect)\");\n\t\tprintk(\"\\n\");\n\t}\n\n\tpi_disconnect(pf->pi);\n\treturn flg - 1;\n}\n\nstatic void pf_mode_sense(struct pf_unit *pf)\n{\n\tchar ms_cmd[12] =\n\t    { ATAPI_MODE_SENSE, pf->lun << 5, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0 };\n\tchar buf[8];\n\n\tpf_atapi(pf, ms_cmd, 8, buf, \"mode sense\");\n\tpf->media_status = PF_RW;\n\tif (buf[3] & 0x80)\n\t\tpf->media_status = PF_RO;\n}\n\nstatic void xs(char *buf, char *targ, int offs, int len)\n{\n\tint j, k, l;\n\n\tj = 0;\n\tl = 0;\n\tfor (k = 0; k < len; k++)\n\t\tif ((buf[k + offs] != 0x20) || (buf[k + offs] != l))\n\t\t\tl = targ[j++] = buf[k + offs];\n\tif (l == 0x20)\n\t\tj--;\n\ttarg[j] = 0;\n}\n\nstatic int xl(char *buf, int offs)\n{\n\tint v, k;\n\n\tv = 0;\n\tfor (k = 0; k < 4; k++)\n\t\tv = v * 256 + (buf[k + offs] & 0xff);\n\treturn v;\n}\n\nstatic void pf_get_capacity(struct pf_unit *pf)\n{\n\tchar rc_cmd[12] = { ATAPI_CAPACITY, pf->lun << 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[8];\n\tint bs;\n\n\tif (pf_atapi(pf, rc_cmd, 8, buf, \"get capacity\")) {\n\t\tpf->media_status = PF_NM;\n\t\treturn;\n\t}\n\tset_capacity(pf->disk, xl(buf, 0) + 1);\n\tbs = xl(buf, 4);\n\tif (bs != 512) {\n\t\tset_capacity(pf->disk, 0);\n\t\tif (verbose)\n\t\t\tprintk(\"%s: Drive %d, LUN %d,\"\n\t\t\t       \" unsupported block size %d\\n\",\n\t\t\t       pf->name, pf->drive, pf->lun, bs);\n\t}\n}\n\nstatic int pf_identify(struct pf_unit *pf)\n{\n\tint dt, s;\n\tchar *ms[2] = { \"master\", \"slave\" };\n\tchar mf[10], id[18];\n\tchar id_cmd[12] =\n\t    { ATAPI_IDENTIFY, pf->lun << 5, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[36];\n\n\ts = pf_atapi(pf, id_cmd, 36, buf, \"identify\");\n\tif (s)\n\t\treturn -1;\n\n\tdt = buf[0] & 0x1f;\n\tif ((dt != 0) && (dt != 7)) {\n\t\tif (verbose)\n\t\t\tprintk(\"%s: Drive %d, LUN %d, unsupported type %d\\n\",\n\t\t\t       pf->name, pf->drive, pf->lun, dt);\n\t\treturn -1;\n\t}\n\n\txs(buf, mf, 8, 8);\n\txs(buf, id, 16, 16);\n\n\tpf->removable = (buf[1] & 0x80);\n\n\tpf_mode_sense(pf);\n\tpf_mode_sense(pf);\n\tpf_mode_sense(pf);\n\n\tpf_get_capacity(pf);\n\n\tprintk(\"%s: %s %s, %s LUN %d, type %d\",\n\t       pf->name, mf, id, ms[pf->drive], pf->lun, dt);\n\tif (pf->removable)\n\t\tprintk(\", removable\");\n\tif (pf->media_status == PF_NM)\n\t\tprintk(\", no media\\n\");\n\telse {\n\t\tif (pf->media_status == PF_RO)\n\t\t\tprintk(\", RO\");\n\t\tprintk(\", %llu blocks\\n\",\n\t\t\t(unsigned long long)get_capacity(pf->disk));\n\t}\n\treturn 0;\n}\n\n/*\treturns  0, with id set if drive is detected\n\t        -1, if drive detection failed\n*/\nstatic int pf_probe(struct pf_unit *pf)\n{\n\tif (pf->drive == -1) {\n\t\tfor (pf->drive = 0; pf->drive <= 1; pf->drive++)\n\t\t\tif (!pf_reset(pf)) {\n\t\t\t\tif (pf->lun != -1)\n\t\t\t\t\treturn pf_identify(pf);\n\t\t\t\telse\n\t\t\t\t\tfor (pf->lun = 0; pf->lun < 8; pf->lun++)\n\t\t\t\t\t\tif (!pf_identify(pf))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t}\n\t} else {\n\t\tif (pf_reset(pf))\n\t\t\treturn -1;\n\t\tif (pf->lun != -1)\n\t\t\treturn pf_identify(pf);\n\t\tfor (pf->lun = 0; pf->lun < 8; pf->lun++)\n\t\t\tif (!pf_identify(pf))\n\t\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}\n\n/* The i/o request engine */\n\nstatic int pf_start(struct pf_unit *pf, int cmd, int b, int c)\n{\n\tint i;\n\tchar io_cmd[12] = { cmd, pf->lun << 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\tfor (i = 0; i < 4; i++) {\n\t\tio_cmd[5 - i] = b & 0xff;\n\t\tb = b >> 8;\n\t}\n\n\tio_cmd[8] = c & 0xff;\n\tio_cmd[7] = (c >> 8) & 0xff;\n\n\ti = pf_command(pf, io_cmd, c * 512, \"start i/o\");\n\n\tmdelay(1);\n\n\treturn i;\n}\n\nstatic int pf_ready(void)\n{\n\treturn (((status_reg(pf_current) & (STAT_BUSY | pf_mask)) == pf_mask));\n}\n\nstatic int pf_queue;\n\nstatic int set_next_request(void)\n{\n\tstruct pf_unit *pf;\n\tint old_pos = pf_queue;\n\n\tdo {\n\t\tpf = &units[pf_queue];\n\t\tif (++pf_queue == PF_UNITS)\n\t\t\tpf_queue = 0;\n\t\tif (pf->present && !list_empty(&pf->rq_list)) {\n\t\t\tpf_req = list_first_entry(&pf->rq_list, struct request,\n\t\t\t\t\t\t\tqueuelist);\n\t\t\tlist_del_init(&pf_req->queuelist);\n\t\t\tblk_mq_start_request(pf_req);\n\t\t\tbreak;\n\t\t}\n\t} while (pf_queue != old_pos);\n\n\treturn pf_req != NULL;\n}\n\nstatic void pf_end_request(blk_status_t err)\n{\n\tif (!pf_req)\n\t\treturn;\n\tif (!blk_update_request(pf_req, err, blk_rq_cur_bytes(pf_req))) {\n\t\t__blk_mq_end_request(pf_req, err);\n\t\tpf_req = NULL;\n\t}\n}\n\nstatic void pf_request(void)\n{\n\tif (pf_busy)\n\t\treturn;\nrepeat:\n\tif (!pf_req && !set_next_request())\n\t\treturn;\n\n\tpf_current = pf_req->rq_disk->private_data;\n\tpf_block = blk_rq_pos(pf_req);\n\tpf_run = blk_rq_sectors(pf_req);\n\tpf_count = blk_rq_cur_sectors(pf_req);\n\n\tif (pf_block + pf_count > get_capacity(pf_req->rq_disk)) {\n\t\tpf_end_request(BLK_STS_IOERR);\n\t\tgoto repeat;\n\t}\n\n\tpf_cmd = rq_data_dir(pf_req);\n\tpf_buf = bio_data(pf_req->bio);\n\tpf_retries = 0;\n\n\tpf_busy = 1;\n\tif (pf_cmd == READ)\n\t\tpi_do_claimed(pf_current->pi, do_pf_read);\n\telse if (pf_cmd == WRITE)\n\t\tpi_do_claimed(pf_current->pi, do_pf_write);\n\telse {\n\t\tpf_busy = 0;\n\t\tpf_end_request(BLK_STS_IOERR);\n\t\tgoto repeat;\n\t}\n}\n\nstatic blk_status_t pf_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tconst struct blk_mq_queue_data *bd)\n{\n\tstruct pf_unit *pf = hctx->queue->queuedata;\n\n\tspin_lock_irq(&pf_spin_lock);\n\tlist_add_tail(&bd->rq->queuelist, &pf->rq_list);\n\tpf_request();\n\tspin_unlock_irq(&pf_spin_lock);\n\n\treturn BLK_STS_OK;\n}\n\nstatic int pf_next_buf(void)\n{\n\tunsigned long saved_flags;\n\n\tpf_count--;\n\tpf_run--;\n\tpf_buf += 512;\n\tpf_block++;\n\tif (!pf_run)\n\t\treturn 1;\n\tif (!pf_count) {\n\t\tspin_lock_irqsave(&pf_spin_lock, saved_flags);\n\t\tpf_end_request(0);\n\t\tspin_unlock_irqrestore(&pf_spin_lock, saved_flags);\n\t\tif (!pf_req)\n\t\t\treturn 1;\n\t\tpf_count = blk_rq_cur_sectors(pf_req);\n\t\tpf_buf = bio_data(pf_req->bio);\n\t}\n\treturn 0;\n}\n\nstatic inline void next_request(blk_status_t err)\n{\n\tunsigned long saved_flags;\n\n\tspin_lock_irqsave(&pf_spin_lock, saved_flags);\n\tpf_end_request(err);\n\tpf_busy = 0;\n\tpf_request();\n\tspin_unlock_irqrestore(&pf_spin_lock, saved_flags);\n}\n\n/* detach from the calling context - in case the spinlock is held */\nstatic void do_pf_read(void)\n{\n\tps_set_intr(do_pf_read_start, NULL, 0, nice);\n}\n\nstatic void do_pf_read_start(void)\n{\n\tpf_busy = 1;\n\n\tif (pf_start(pf_current, ATAPI_READ_10, pf_block, pf_run)) {\n\t\tpi_disconnect(pf_current->pi);\n\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\tpf_retries++;\n\t\t\tpi_do_claimed(pf_current->pi, do_pf_read_start);\n\t\t\treturn;\n\t\t}\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\tpf_mask = STAT_DRQ;\n\tps_set_intr(do_pf_read_drq, pf_ready, PF_TMO, nice);\n}\n\nstatic void do_pf_read_drq(void)\n{\n\twhile (1) {\n\t\tif (pf_wait(pf_current, STAT_BUSY, STAT_DRQ | STAT_ERR,\n\t\t\t    \"read block\", \"completion\") & STAT_ERR) {\n\t\t\tpi_disconnect(pf_current->pi);\n\t\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\t\tpf_req_sense(pf_current, 0);\n\t\t\t\tpf_retries++;\n\t\t\t\tpi_do_claimed(pf_current->pi, do_pf_read_start);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnext_request(BLK_STS_IOERR);\n\t\t\treturn;\n\t\t}\n\t\tpi_read_block(pf_current->pi, pf_buf, 512);\n\t\tif (pf_next_buf())\n\t\t\tbreak;\n\t}\n\tpi_disconnect(pf_current->pi);\n\tnext_request(0);\n}\n\nstatic void do_pf_write(void)\n{\n\tps_set_intr(do_pf_write_start, NULL, 0, nice);\n}\n\nstatic void do_pf_write_start(void)\n{\n\tpf_busy = 1;\n\n\tif (pf_start(pf_current, ATAPI_WRITE_10, pf_block, pf_run)) {\n\t\tpi_disconnect(pf_current->pi);\n\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\tpf_retries++;\n\t\t\tpi_do_claimed(pf_current->pi, do_pf_write_start);\n\t\t\treturn;\n\t\t}\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\tif (pf_wait(pf_current, STAT_BUSY, STAT_DRQ | STAT_ERR,\n\t\t\t    \"write block\", \"data wait\") & STAT_ERR) {\n\t\t\tpi_disconnect(pf_current->pi);\n\t\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\t\tpf_retries++;\n\t\t\t\tpi_do_claimed(pf_current->pi, do_pf_write_start);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnext_request(BLK_STS_IOERR);\n\t\t\treturn;\n\t\t}\n\t\tpi_write_block(pf_current->pi, pf_buf, 512);\n\t\tif (pf_next_buf())\n\t\t\tbreak;\n\t}\n\tpf_mask = 0;\n\tps_set_intr(do_pf_write_done, pf_ready, PF_TMO, nice);\n}\n\nstatic void do_pf_write_done(void)\n{\n\tif (pf_wait(pf_current, STAT_BUSY, 0, \"write block\", \"done\") & STAT_ERR) {\n\t\tpi_disconnect(pf_current->pi);\n\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\tpf_retries++;\n\t\t\tpi_do_claimed(pf_current->pi, do_pf_write_start);\n\t\t\treturn;\n\t\t}\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\tpi_disconnect(pf_current->pi);\n\tnext_request(0);\n}\n\nstatic int __init pf_init(void)\n{\t\t\t\t/* preliminary initialisation */\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}\n\nstatic void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}\n\nMODULE_LICENSE(\"GPL\");\nmodule_init(pf_init)\nmodule_exit(pf_exit)\n"], "fixing_code": ["/* \n        pf.c    (c) 1997-8  Grant R. Guenther <grant@torque.net>\n                            Under the terms of the GNU General Public License.\n\n        This is the high-level driver for parallel port ATAPI disk\n        drives based on chips supported by the paride module.\n\n        By default, the driver will autoprobe for a single parallel\n        port ATAPI disk drive, but if their individual parameters are\n        specified, the driver can handle up to 4 drives.\n\n        The behaviour of the pf driver can be altered by setting\n        some parameters from the insmod command line.  The following\n        parameters are adjustable:\n\n            drive0      These four arguments can be arrays of       \n            drive1      1-7 integers as follows:\n            drive2\n            drive3      <prt>,<pro>,<uni>,<mod>,<slv>,<lun>,<dly>\n\n                        Where,\n\n                <prt>   is the base of the parallel port address for\n                        the corresponding drive.  (required)\n\n                <pro>   is the protocol number for the adapter that\n                        supports this drive.  These numbers are\n                        logged by 'paride' when the protocol modules\n                        are initialised.  (0 if not given)\n\n                <uni>   for those adapters that support chained\n                        devices, this is the unit selector for the\n                        chain of devices on the given port.  It should\n                        be zero for devices that don't support chaining.\n                        (0 if not given)\n\n                <mod>   this can be -1 to choose the best mode, or one\n                        of the mode numbers supported by the adapter.\n                        (-1 if not given)\n\n                <slv>   ATAPI CDroms can be jumpered to master or slave.\n                        Set this to 0 to choose the master drive, 1 to\n                        choose the slave, -1 (the default) to choose the\n                        first drive found.\n\n\t\t<lun>   Some ATAPI devices support multiple LUNs.\n                        One example is the ATAPI PD/CD drive from\n                        Matshita/Panasonic.  This device has a \n                        CD drive on LUN 0 and a PD drive on LUN 1.\n                        By default, the driver will search for the\n                        first LUN with a supported device.  Set \n                        this parameter to force it to use a specific\n                        LUN.  (default -1)\n\n                <dly>   some parallel ports require the driver to \n                        go more slowly.  -1 sets a default value that\n                        should work with the chosen protocol.  Otherwise,\n                        set this to a small integer, the larger it is\n                        the slower the port i/o.  In some cases, setting\n                        this to zero will speed up the device. (default -1)\n\n\t    major\tYou may use this parameter to override the\n\t\t\tdefault major number (47) that this driver\n\t\t\twill use.  Be sure to change the device\n\t\t\tname as well.\n\n\t    name\tThis parameter is a character string that\n\t\t\tcontains the name the kernel will use for this\n\t\t\tdevice (in /proc output, for instance).\n\t\t\t(default \"pf\").\n\n            cluster     The driver will attempt to aggregate requests\n                        for adjacent blocks into larger multi-block\n                        clusters.  The maximum cluster size (in 512\n                        byte sectors) is set with this parameter.\n                        (default 64)\n\n            verbose     This parameter controls the amount of logging\n                        that the driver will do.  Set it to 0 for\n                        normal operation, 1 to see autoprobe progress\n                        messages, or 2 to see additional debugging\n                        output.  (default 0)\n \n\t    nice        This parameter controls the driver's use of\n\t\t\tidle CPU time, at the expense of some speed.\n\n        If this driver is built into the kernel, you can use the\n        following command line parameters, with the same values\n        as the corresponding module parameters listed above:\n\n            pf.drive0\n            pf.drive1\n            pf.drive2\n            pf.drive3\n\t    pf.cluster\n            pf.nice\n\n        In addition, you can use the parameter pf.disable to disable\n        the driver entirely.\n\n*/\n\n/* Changes:\n\n\t1.01\tGRG 1998.05.03  Changes for SMP.  Eliminate sti().\n\t\t\t\tFix for drives that don't clear STAT_ERR\n\t\t\t        until after next CDB delivered.\n\t\t\t\tSmall change in pf_completion to round\n\t\t\t\tup transfer size.\n\t1.02    GRG 1998.06.16  Eliminated an Ugh\n\t1.03    GRG 1998.08.16  Use HZ in loop timings, extra debugging\n\t1.04    GRG 1998.09.24  Added jumbo support\n\n*/\n\n#define PF_VERSION      \"1.04\"\n#define PF_MAJOR\t47\n#define PF_NAME\t\t\"pf\"\n#define PF_UNITS\t4\n\n#include <linux/types.h>\n\n/* Here are things one can override from the insmod command.\n   Most are autoprobed by paride unless set here.  Verbose is off\n   by default.\n\n*/\n\nstatic bool verbose = 0;\nstatic int major = PF_MAJOR;\nstatic char *name = PF_NAME;\nstatic int cluster = 64;\nstatic int nice = 0;\nstatic int disable = 0;\n\nstatic int drive0[7] = { 0, 0, 0, -1, -1, -1, -1 };\nstatic int drive1[7] = { 0, 0, 0, -1, -1, -1, -1 };\nstatic int drive2[7] = { 0, 0, 0, -1, -1, -1, -1 };\nstatic int drive3[7] = { 0, 0, 0, -1, -1, -1, -1 };\n\nstatic int (*drives[4])[7] = {&drive0, &drive1, &drive2, &drive3};\nstatic int pf_drive_count;\n\nenum {D_PRT, D_PRO, D_UNI, D_MOD, D_SLV, D_LUN, D_DLY};\n\n/* end of parameters */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/hdreg.h>\n#include <linux/cdrom.h>\n#include <linux/spinlock.h>\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\nstatic DEFINE_MUTEX(pf_mutex);\nstatic DEFINE_SPINLOCK(pf_spin_lock);\n\nmodule_param(verbose, bool, 0644);\nmodule_param(major, int, 0);\nmodule_param(name, charp, 0);\nmodule_param(cluster, int, 0);\nmodule_param(nice, int, 0);\nmodule_param_array(drive0, int, NULL, 0);\nmodule_param_array(drive1, int, NULL, 0);\nmodule_param_array(drive2, int, NULL, 0);\nmodule_param_array(drive3, int, NULL, 0);\n\n#include \"paride.h\"\n#include \"pseudo.h\"\n\n/* constants for faking geometry numbers */\n\n#define PF_FD_MAX\t8192\t/* use FD geometry under this size */\n#define PF_FD_HDS\t2\n#define PF_FD_SPT\t18\n#define PF_HD_HDS\t64\n#define PF_HD_SPT\t32\n\n#define PF_MAX_RETRIES  5\n#define PF_TMO          800\t/* interrupt timeout in jiffies */\n#define PF_SPIN_DEL     50\t/* spin delay in micro-seconds  */\n\n#define PF_SPIN         (1000000*PF_TMO)/(HZ*PF_SPIN_DEL)\n\n#define STAT_ERR        0x00001\n#define STAT_INDEX      0x00002\n#define STAT_ECC        0x00004\n#define STAT_DRQ        0x00008\n#define STAT_SEEK       0x00010\n#define STAT_WRERR      0x00020\n#define STAT_READY      0x00040\n#define STAT_BUSY       0x00080\n\n#define ATAPI_REQ_SENSE\t\t0x03\n#define ATAPI_LOCK\t\t0x1e\n#define ATAPI_DOOR\t\t0x1b\n#define ATAPI_MODE_SENSE\t0x5a\n#define ATAPI_CAPACITY\t\t0x25\n#define ATAPI_IDENTIFY\t\t0x12\n#define ATAPI_READ_10\t\t0x28\n#define ATAPI_WRITE_10\t\t0x2a\n\nstatic int pf_open(struct block_device *bdev, fmode_t mode);\nstatic blk_status_t pf_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tconst struct blk_mq_queue_data *bd);\nstatic int pf_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg);\nstatic int pf_getgeo(struct block_device *bdev, struct hd_geometry *geo);\n\nstatic void pf_release(struct gendisk *disk, fmode_t mode);\n\nstatic int pf_detect(void);\nstatic void do_pf_read(void);\nstatic void do_pf_read_start(void);\nstatic void do_pf_write(void);\nstatic void do_pf_write_start(void);\nstatic void do_pf_read_drq(void);\nstatic void do_pf_write_done(void);\n\n#define PF_NM           0\n#define PF_RO           1\n#define PF_RW           2\n\n#define PF_NAMELEN      8\n\nstruct pf_unit {\n\tstruct pi_adapter pia;\t/* interface to paride layer */\n\tstruct pi_adapter *pi;\n\tint removable;\t\t/* removable media device  ?  */\n\tint media_status;\t/* media present ?  WP ? */\n\tint drive;\t\t/* drive */\n\tint lun;\n\tint access;\t\t/* count of active opens ... */\n\tint present;\t\t/* device present ? */\n\tchar name[PF_NAMELEN];\t/* pf0, pf1, ... */\n\tstruct gendisk *disk;\n\tstruct blk_mq_tag_set tag_set;\n\tstruct list_head rq_list;\n};\n\nstatic struct pf_unit units[PF_UNITS];\n\nstatic int pf_identify(struct pf_unit *pf);\nstatic void pf_lock(struct pf_unit *pf, int func);\nstatic void pf_eject(struct pf_unit *pf);\nstatic unsigned int pf_check_events(struct gendisk *disk,\n\t\t\t\t    unsigned int clearing);\n\nstatic char pf_scratch[512];\t/* scratch block buffer */\n\n/* the variables below are used mainly in the I/O request engine, which\n   processes only one request at a time.\n*/\n\nstatic int pf_retries = 0;\t/* i/o error retry count */\nstatic int pf_busy = 0;\t\t/* request being processed ? */\nstatic struct request *pf_req;\t/* current request */\nstatic int pf_block;\t\t/* address of next requested block */\nstatic int pf_count;\t\t/* number of blocks still to do */\nstatic int pf_run;\t\t/* sectors in current cluster */\nstatic int pf_cmd;\t\t/* current command READ/WRITE */\nstatic struct pf_unit *pf_current;/* unit of current request */\nstatic int pf_mask;\t\t/* stopper for pseudo-int */\nstatic char *pf_buf;\t\t/* buffer for request in progress */\nstatic void *par_drv;\t\t/* reference of parport driver */\n\n/* kernel glue structures */\n\nstatic const struct block_device_operations pf_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pf_open,\n\t.release\t= pf_release,\n\t.ioctl\t\t= pf_ioctl,\n\t.getgeo\t\t= pf_getgeo,\n\t.check_events\t= pf_check_events,\n};\n\nstatic const struct blk_mq_ops pf_mq_ops = {\n\t.queue_rq\t= pf_queue_rq,\n};\n\nstatic void __init pf_init_units(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tpf_drive_count = 0;\n\tfor (unit = 0, pf = units; unit < PF_UNITS; unit++, pf++) {\n\t\tstruct gendisk *disk;\n\n\t\tdisk = alloc_disk(1);\n\t\tif (!disk)\n\t\t\tcontinue;\n\n\t\tdisk->queue = blk_mq_init_sq_queue(&pf->tag_set, &pf_mq_ops,\n\t\t\t\t\t\t\t1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&pf->rq_list);\n\t\tdisk->queue->queuedata = pf;\n\t\tblk_queue_max_segments(disk->queue, cluster);\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tpf->disk = disk;\n\t\tpf->pi = &pf->pia;\n\t\tpf->media_status = PF_NM;\n\t\tpf->drive = (*drives[unit])[D_SLV];\n\t\tpf->lun = (*drives[unit])[D_LUN];\n\t\tsnprintf(pf->name, PF_NAMELEN, \"%s%d\", name, unit);\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, pf->name);\n\t\tdisk->fops = &pf_fops;\n\t\tif (!(*drives[unit])[D_PRT])\n\t\t\tpf_drive_count++;\n\t}\n}\n\nstatic int pf_open(struct block_device *bdev, fmode_t mode)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\tint ret;\n\n\tmutex_lock(&pf_mutex);\n\tpf_identify(pf);\n\n\tret = -ENODEV;\n\tif (pf->media_status == PF_NM)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif ((pf->media_status == PF_RO) && (mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = 0;\n\tpf->access++;\n\tif (pf->removable)\n\t\tpf_lock(pf, 1);\nout:\n\tmutex_unlock(&pf_mutex);\n\treturn ret;\n}\n\nstatic int pf_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\tsector_t capacity = get_capacity(pf->disk);\n\n\tif (capacity < PF_FD_MAX) {\n\t\tgeo->cylinders = sector_div(capacity, PF_FD_HDS * PF_FD_SPT);\n\t\tgeo->heads = PF_FD_HDS;\n\t\tgeo->sectors = PF_FD_SPT;\n\t} else {\n\t\tgeo->cylinders = sector_div(capacity, PF_HD_HDS * PF_HD_SPT);\n\t\tgeo->heads = PF_HD_HDS;\n\t\tgeo->sectors = PF_HD_SPT;\n\t}\n\n\treturn 0;\n}\n\nstatic int pf_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\n\tif (cmd != CDROMEJECT)\n\t\treturn -EINVAL;\n\n\tif (pf->access != 1)\n\t\treturn -EBUSY;\n\tmutex_lock(&pf_mutex);\n\tpf_eject(pf);\n\tmutex_unlock(&pf_mutex);\n\n\treturn 0;\n}\n\nstatic void pf_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct pf_unit *pf = disk->private_data;\n\n\tmutex_lock(&pf_mutex);\n\tif (pf->access <= 0) {\n\t\tmutex_unlock(&pf_mutex);\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tpf->access--;\n\n\tif (!pf->access && pf->removable)\n\t\tpf_lock(pf, 0);\n\n\tmutex_unlock(&pf_mutex);\n}\n\nstatic unsigned int pf_check_events(struct gendisk *disk, unsigned int clearing)\n{\n\treturn DISK_EVENT_MEDIA_CHANGE;\n}\n\nstatic inline int status_reg(struct pf_unit *pf)\n{\n\treturn pi_read_regr(pf->pi, 1, 6);\n}\n\nstatic inline int read_reg(struct pf_unit *pf, int reg)\n{\n\treturn pi_read_regr(pf->pi, 0, reg);\n}\n\nstatic inline void write_reg(struct pf_unit *pf, int reg, int val)\n{\n\tpi_write_regr(pf->pi, 0, reg, val);\n}\n\nstatic int pf_wait(struct pf_unit *pf, int go, int stop, char *fun, char *msg)\n{\n\tint j, r, e, s, p;\n\n\tj = 0;\n\twhile ((((r = status_reg(pf)) & go) || (stop && (!(r & stop))))\n\t       && (j++ < PF_SPIN))\n\t\tudelay(PF_SPIN_DEL);\n\n\tif ((r & (STAT_ERR & stop)) || (j > PF_SPIN)) {\n\t\ts = read_reg(pf, 7);\n\t\te = read_reg(pf, 1);\n\t\tp = read_reg(pf, 2);\n\t\tif (j > PF_SPIN)\n\t\t\te |= 0x100;\n\t\tif (fun)\n\t\t\tprintk(\"%s: %s %s: alt=0x%x stat=0x%x err=0x%x\"\n\t\t\t       \" loop=%d phase=%d\\n\",\n\t\t\t       pf->name, fun, msg, r, s, e, j, p);\n\t\treturn (e << 8) + s;\n\t}\n\treturn 0;\n}\n\nstatic int pf_command(struct pf_unit *pf, char *cmd, int dlen, char *fun)\n{\n\tpi_connect(pf->pi);\n\n\twrite_reg(pf, 6, 0xa0+0x10*pf->drive);\n\n\tif (pf_wait(pf, STAT_BUSY | STAT_DRQ, 0, fun, \"before command\")) {\n\t\tpi_disconnect(pf->pi);\n\t\treturn -1;\n\t}\n\n\twrite_reg(pf, 4, dlen % 256);\n\twrite_reg(pf, 5, dlen / 256);\n\twrite_reg(pf, 7, 0xa0);\t/* ATAPI packet command */\n\n\tif (pf_wait(pf, STAT_BUSY, STAT_DRQ, fun, \"command DRQ\")) {\n\t\tpi_disconnect(pf->pi);\n\t\treturn -1;\n\t}\n\n\tif (read_reg(pf, 2) != 1) {\n\t\tprintk(\"%s: %s: command phase error\\n\", pf->name, fun);\n\t\tpi_disconnect(pf->pi);\n\t\treturn -1;\n\t}\n\n\tpi_write_block(pf->pi, cmd, 12);\n\n\treturn 0;\n}\n\nstatic int pf_completion(struct pf_unit *pf, char *buf, char *fun)\n{\n\tint r, s, n;\n\n\tr = pf_wait(pf, STAT_BUSY, STAT_DRQ | STAT_READY | STAT_ERR,\n\t\t    fun, \"completion\");\n\n\tif ((read_reg(pf, 2) & 2) && (read_reg(pf, 7) & STAT_DRQ)) {\n\t\tn = (((read_reg(pf, 4) + 256 * read_reg(pf, 5)) +\n\t\t      3) & 0xfffc);\n\t\tpi_read_block(pf->pi, buf, n);\n\t}\n\n\ts = pf_wait(pf, STAT_BUSY, STAT_READY | STAT_ERR, fun, \"data done\");\n\n\tpi_disconnect(pf->pi);\n\n\treturn (r ? r : s);\n}\n\nstatic void pf_req_sense(struct pf_unit *pf, int quiet)\n{\n\tchar rs_cmd[12] =\n\t    { ATAPI_REQ_SENSE, pf->lun << 5, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[16];\n\tint r;\n\n\tr = pf_command(pf, rs_cmd, 16, \"Request sense\");\n\tmdelay(1);\n\tif (!r)\n\t\tpf_completion(pf, buf, \"Request sense\");\n\n\tif ((!r) && (!quiet))\n\t\tprintk(\"%s: Sense key: %x, ASC: %x, ASQ: %x\\n\",\n\t\t       pf->name, buf[2] & 0xf, buf[12], buf[13]);\n}\n\nstatic int pf_atapi(struct pf_unit *pf, char *cmd, int dlen, char *buf, char *fun)\n{\n\tint r;\n\n\tr = pf_command(pf, cmd, dlen, fun);\n\tmdelay(1);\n\tif (!r)\n\t\tr = pf_completion(pf, buf, fun);\n\tif (r)\n\t\tpf_req_sense(pf, !fun);\n\n\treturn r;\n}\n\nstatic void pf_lock(struct pf_unit *pf, int func)\n{\n\tchar lo_cmd[12] = { ATAPI_LOCK, pf->lun << 5, 0, 0, func, 0, 0, 0, 0, 0, 0, 0 };\n\n\tpf_atapi(pf, lo_cmd, 0, pf_scratch, func ? \"lock\" : \"unlock\");\n}\n\nstatic void pf_eject(struct pf_unit *pf)\n{\n\tchar ej_cmd[12] = { ATAPI_DOOR, pf->lun << 5, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 };\n\n\tpf_lock(pf, 0);\n\tpf_atapi(pf, ej_cmd, 0, pf_scratch, \"eject\");\n}\n\n#define PF_RESET_TMO   30\t/* in tenths of a second */\n\nstatic void pf_sleep(int cs)\n{\n\tschedule_timeout_interruptible(cs);\n}\n\n/* the ATAPI standard actually specifies the contents of all 7 registers\n   after a reset, but the specification is ambiguous concerning the last\n   two bytes, and different drives interpret the standard differently.\n */\n\nstatic int pf_reset(struct pf_unit *pf)\n{\n\tint i, k, flg;\n\tint expect[5] = { 1, 1, 1, 0x14, 0xeb };\n\n\tpi_connect(pf->pi);\n\twrite_reg(pf, 6, 0xa0+0x10*pf->drive);\n\twrite_reg(pf, 7, 8);\n\n\tpf_sleep(20 * HZ / 1000);\n\n\tk = 0;\n\twhile ((k++ < PF_RESET_TMO) && (status_reg(pf) & STAT_BUSY))\n\t\tpf_sleep(HZ / 10);\n\n\tflg = 1;\n\tfor (i = 0; i < 5; i++)\n\t\tflg &= (read_reg(pf, i + 1) == expect[i]);\n\n\tif (verbose) {\n\t\tprintk(\"%s: Reset (%d) signature = \", pf->name, k);\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tprintk(\"%3x\", read_reg(pf, i + 1));\n\t\tif (!flg)\n\t\t\tprintk(\" (incorrect)\");\n\t\tprintk(\"\\n\");\n\t}\n\n\tpi_disconnect(pf->pi);\n\treturn flg - 1;\n}\n\nstatic void pf_mode_sense(struct pf_unit *pf)\n{\n\tchar ms_cmd[12] =\n\t    { ATAPI_MODE_SENSE, pf->lun << 5, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0 };\n\tchar buf[8];\n\n\tpf_atapi(pf, ms_cmd, 8, buf, \"mode sense\");\n\tpf->media_status = PF_RW;\n\tif (buf[3] & 0x80)\n\t\tpf->media_status = PF_RO;\n}\n\nstatic void xs(char *buf, char *targ, int offs, int len)\n{\n\tint j, k, l;\n\n\tj = 0;\n\tl = 0;\n\tfor (k = 0; k < len; k++)\n\t\tif ((buf[k + offs] != 0x20) || (buf[k + offs] != l))\n\t\t\tl = targ[j++] = buf[k + offs];\n\tif (l == 0x20)\n\t\tj--;\n\ttarg[j] = 0;\n}\n\nstatic int xl(char *buf, int offs)\n{\n\tint v, k;\n\n\tv = 0;\n\tfor (k = 0; k < 4; k++)\n\t\tv = v * 256 + (buf[k + offs] & 0xff);\n\treturn v;\n}\n\nstatic void pf_get_capacity(struct pf_unit *pf)\n{\n\tchar rc_cmd[12] = { ATAPI_CAPACITY, pf->lun << 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[8];\n\tint bs;\n\n\tif (pf_atapi(pf, rc_cmd, 8, buf, \"get capacity\")) {\n\t\tpf->media_status = PF_NM;\n\t\treturn;\n\t}\n\tset_capacity(pf->disk, xl(buf, 0) + 1);\n\tbs = xl(buf, 4);\n\tif (bs != 512) {\n\t\tset_capacity(pf->disk, 0);\n\t\tif (verbose)\n\t\t\tprintk(\"%s: Drive %d, LUN %d,\"\n\t\t\t       \" unsupported block size %d\\n\",\n\t\t\t       pf->name, pf->drive, pf->lun, bs);\n\t}\n}\n\nstatic int pf_identify(struct pf_unit *pf)\n{\n\tint dt, s;\n\tchar *ms[2] = { \"master\", \"slave\" };\n\tchar mf[10], id[18];\n\tchar id_cmd[12] =\n\t    { ATAPI_IDENTIFY, pf->lun << 5, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[36];\n\n\ts = pf_atapi(pf, id_cmd, 36, buf, \"identify\");\n\tif (s)\n\t\treturn -1;\n\n\tdt = buf[0] & 0x1f;\n\tif ((dt != 0) && (dt != 7)) {\n\t\tif (verbose)\n\t\t\tprintk(\"%s: Drive %d, LUN %d, unsupported type %d\\n\",\n\t\t\t       pf->name, pf->drive, pf->lun, dt);\n\t\treturn -1;\n\t}\n\n\txs(buf, mf, 8, 8);\n\txs(buf, id, 16, 16);\n\n\tpf->removable = (buf[1] & 0x80);\n\n\tpf_mode_sense(pf);\n\tpf_mode_sense(pf);\n\tpf_mode_sense(pf);\n\n\tpf_get_capacity(pf);\n\n\tprintk(\"%s: %s %s, %s LUN %d, type %d\",\n\t       pf->name, mf, id, ms[pf->drive], pf->lun, dt);\n\tif (pf->removable)\n\t\tprintk(\", removable\");\n\tif (pf->media_status == PF_NM)\n\t\tprintk(\", no media\\n\");\n\telse {\n\t\tif (pf->media_status == PF_RO)\n\t\t\tprintk(\", RO\");\n\t\tprintk(\", %llu blocks\\n\",\n\t\t\t(unsigned long long)get_capacity(pf->disk));\n\t}\n\treturn 0;\n}\n\n/*\treturns  0, with id set if drive is detected\n\t        -1, if drive detection failed\n*/\nstatic int pf_probe(struct pf_unit *pf)\n{\n\tif (pf->drive == -1) {\n\t\tfor (pf->drive = 0; pf->drive <= 1; pf->drive++)\n\t\t\tif (!pf_reset(pf)) {\n\t\t\t\tif (pf->lun != -1)\n\t\t\t\t\treturn pf_identify(pf);\n\t\t\t\telse\n\t\t\t\t\tfor (pf->lun = 0; pf->lun < 8; pf->lun++)\n\t\t\t\t\t\tif (!pf_identify(pf))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t}\n\t} else {\n\t\tif (pf_reset(pf))\n\t\t\treturn -1;\n\t\tif (pf->lun != -1)\n\t\t\treturn pf_identify(pf);\n\t\tfor (pf->lun = 0; pf->lun < 8; pf->lun++)\n\t\t\tif (!pf_identify(pf))\n\t\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}\n\n/* The i/o request engine */\n\nstatic int pf_start(struct pf_unit *pf, int cmd, int b, int c)\n{\n\tint i;\n\tchar io_cmd[12] = { cmd, pf->lun << 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\tfor (i = 0; i < 4; i++) {\n\t\tio_cmd[5 - i] = b & 0xff;\n\t\tb = b >> 8;\n\t}\n\n\tio_cmd[8] = c & 0xff;\n\tio_cmd[7] = (c >> 8) & 0xff;\n\n\ti = pf_command(pf, io_cmd, c * 512, \"start i/o\");\n\n\tmdelay(1);\n\n\treturn i;\n}\n\nstatic int pf_ready(void)\n{\n\treturn (((status_reg(pf_current) & (STAT_BUSY | pf_mask)) == pf_mask));\n}\n\nstatic int pf_queue;\n\nstatic int set_next_request(void)\n{\n\tstruct pf_unit *pf;\n\tint old_pos = pf_queue;\n\n\tdo {\n\t\tpf = &units[pf_queue];\n\t\tif (++pf_queue == PF_UNITS)\n\t\t\tpf_queue = 0;\n\t\tif (pf->present && !list_empty(&pf->rq_list)) {\n\t\t\tpf_req = list_first_entry(&pf->rq_list, struct request,\n\t\t\t\t\t\t\tqueuelist);\n\t\t\tlist_del_init(&pf_req->queuelist);\n\t\t\tblk_mq_start_request(pf_req);\n\t\t\tbreak;\n\t\t}\n\t} while (pf_queue != old_pos);\n\n\treturn pf_req != NULL;\n}\n\nstatic void pf_end_request(blk_status_t err)\n{\n\tif (!pf_req)\n\t\treturn;\n\tif (!blk_update_request(pf_req, err, blk_rq_cur_bytes(pf_req))) {\n\t\t__blk_mq_end_request(pf_req, err);\n\t\tpf_req = NULL;\n\t}\n}\n\nstatic void pf_request(void)\n{\n\tif (pf_busy)\n\t\treturn;\nrepeat:\n\tif (!pf_req && !set_next_request())\n\t\treturn;\n\n\tpf_current = pf_req->rq_disk->private_data;\n\tpf_block = blk_rq_pos(pf_req);\n\tpf_run = blk_rq_sectors(pf_req);\n\tpf_count = blk_rq_cur_sectors(pf_req);\n\n\tif (pf_block + pf_count > get_capacity(pf_req->rq_disk)) {\n\t\tpf_end_request(BLK_STS_IOERR);\n\t\tgoto repeat;\n\t}\n\n\tpf_cmd = rq_data_dir(pf_req);\n\tpf_buf = bio_data(pf_req->bio);\n\tpf_retries = 0;\n\n\tpf_busy = 1;\n\tif (pf_cmd == READ)\n\t\tpi_do_claimed(pf_current->pi, do_pf_read);\n\telse if (pf_cmd == WRITE)\n\t\tpi_do_claimed(pf_current->pi, do_pf_write);\n\telse {\n\t\tpf_busy = 0;\n\t\tpf_end_request(BLK_STS_IOERR);\n\t\tgoto repeat;\n\t}\n}\n\nstatic blk_status_t pf_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\tconst struct blk_mq_queue_data *bd)\n{\n\tstruct pf_unit *pf = hctx->queue->queuedata;\n\n\tspin_lock_irq(&pf_spin_lock);\n\tlist_add_tail(&bd->rq->queuelist, &pf->rq_list);\n\tpf_request();\n\tspin_unlock_irq(&pf_spin_lock);\n\n\treturn BLK_STS_OK;\n}\n\nstatic int pf_next_buf(void)\n{\n\tunsigned long saved_flags;\n\n\tpf_count--;\n\tpf_run--;\n\tpf_buf += 512;\n\tpf_block++;\n\tif (!pf_run)\n\t\treturn 1;\n\tif (!pf_count) {\n\t\tspin_lock_irqsave(&pf_spin_lock, saved_flags);\n\t\tpf_end_request(0);\n\t\tspin_unlock_irqrestore(&pf_spin_lock, saved_flags);\n\t\tif (!pf_req)\n\t\t\treturn 1;\n\t\tpf_count = blk_rq_cur_sectors(pf_req);\n\t\tpf_buf = bio_data(pf_req->bio);\n\t}\n\treturn 0;\n}\n\nstatic inline void next_request(blk_status_t err)\n{\n\tunsigned long saved_flags;\n\n\tspin_lock_irqsave(&pf_spin_lock, saved_flags);\n\tpf_end_request(err);\n\tpf_busy = 0;\n\tpf_request();\n\tspin_unlock_irqrestore(&pf_spin_lock, saved_flags);\n}\n\n/* detach from the calling context - in case the spinlock is held */\nstatic void do_pf_read(void)\n{\n\tps_set_intr(do_pf_read_start, NULL, 0, nice);\n}\n\nstatic void do_pf_read_start(void)\n{\n\tpf_busy = 1;\n\n\tif (pf_start(pf_current, ATAPI_READ_10, pf_block, pf_run)) {\n\t\tpi_disconnect(pf_current->pi);\n\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\tpf_retries++;\n\t\t\tpi_do_claimed(pf_current->pi, do_pf_read_start);\n\t\t\treturn;\n\t\t}\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\tpf_mask = STAT_DRQ;\n\tps_set_intr(do_pf_read_drq, pf_ready, PF_TMO, nice);\n}\n\nstatic void do_pf_read_drq(void)\n{\n\twhile (1) {\n\t\tif (pf_wait(pf_current, STAT_BUSY, STAT_DRQ | STAT_ERR,\n\t\t\t    \"read block\", \"completion\") & STAT_ERR) {\n\t\t\tpi_disconnect(pf_current->pi);\n\t\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\t\tpf_req_sense(pf_current, 0);\n\t\t\t\tpf_retries++;\n\t\t\t\tpi_do_claimed(pf_current->pi, do_pf_read_start);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnext_request(BLK_STS_IOERR);\n\t\t\treturn;\n\t\t}\n\t\tpi_read_block(pf_current->pi, pf_buf, 512);\n\t\tif (pf_next_buf())\n\t\t\tbreak;\n\t}\n\tpi_disconnect(pf_current->pi);\n\tnext_request(0);\n}\n\nstatic void do_pf_write(void)\n{\n\tps_set_intr(do_pf_write_start, NULL, 0, nice);\n}\n\nstatic void do_pf_write_start(void)\n{\n\tpf_busy = 1;\n\n\tif (pf_start(pf_current, ATAPI_WRITE_10, pf_block, pf_run)) {\n\t\tpi_disconnect(pf_current->pi);\n\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\tpf_retries++;\n\t\t\tpi_do_claimed(pf_current->pi, do_pf_write_start);\n\t\t\treturn;\n\t\t}\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\tif (pf_wait(pf_current, STAT_BUSY, STAT_DRQ | STAT_ERR,\n\t\t\t    \"write block\", \"data wait\") & STAT_ERR) {\n\t\t\tpi_disconnect(pf_current->pi);\n\t\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\t\tpf_retries++;\n\t\t\t\tpi_do_claimed(pf_current->pi, do_pf_write_start);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnext_request(BLK_STS_IOERR);\n\t\t\treturn;\n\t\t}\n\t\tpi_write_block(pf_current->pi, pf_buf, 512);\n\t\tif (pf_next_buf())\n\t\t\tbreak;\n\t}\n\tpf_mask = 0;\n\tps_set_intr(do_pf_write_done, pf_ready, PF_TMO, nice);\n}\n\nstatic void do_pf_write_done(void)\n{\n\tif (pf_wait(pf_current, STAT_BUSY, 0, \"write block\", \"done\") & STAT_ERR) {\n\t\tpi_disconnect(pf_current->pi);\n\t\tif (pf_retries < PF_MAX_RETRIES) {\n\t\t\tpf_retries++;\n\t\t\tpi_do_claimed(pf_current->pi, do_pf_write_start);\n\t\t\treturn;\n\t\t}\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\tpi_disconnect(pf_current->pi);\n\tnext_request(0);\n}\n\nstatic int __init pf_init(void)\n{\t\t\t\t/* preliminary initialisation */\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\t\tif (!pf->disk)\n\t\t\t\tcontinue;\n\t\t\tblk_cleanup_queue(pf->disk->queue);\n\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\t\tput_disk(pf->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}\n\nstatic void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}\n\nMODULE_LICENSE(\"GPL\");\nmodule_init(pf_init)\nmodule_exit(pf_exit)\n"], "filenames": ["drivers/block/paride/pf.c"], "buggy_code_start_loc": [764], "buggy_code_end_loc": [1053], "fixing_code_start_loc": [765], "fixing_code_end_loc": [1064], "type": "CWE-476", "message": "An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a pf data structure if alloc_disk fails in drivers/block/paride/pf.c.", "other": {"cve": {"id": "CVE-2019-15922", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-04T19:15:12.287", "lastModified": "2019-10-04T09:15:13.527", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a pf data structure if alloc_disk fails in drivers/block/paride/pf.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.0.9. Se presenta una desreferencia del puntero NULL para una estructura de datos pf si la funci\u00f3n alloc_disk presenta un fallo en el archivo drivers/block/paride/pf.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.9", "matchCriteriaId": "6F073F68-1CAE-4D5C-8FF9-E86E008F043B"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.0.9", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/58ccd2d31e502c37e108b285bf3d343eb00c235b", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191004-0001/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/58ccd2d31e502c37e108b285bf3d343eb00c235b"}}