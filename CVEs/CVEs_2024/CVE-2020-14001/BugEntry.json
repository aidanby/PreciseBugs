{"buggy_code": ["# -*- coding: utf-8; frozen_string_literal: true -*-\n#\n#--\n# Copyright (C) 2009-2019 Thomas Leitner <t_leitner@gmx.at>\n#\n# This file is part of kramdown which is licensed under the MIT.\n#++\n#\n\nrequire 'yaml'\n\nmodule Kramdown\n\n  # This module defines all options that are used by parsers and/or converters as well as providing\n  # methods to deal with the options.\n  module Options\n\n    # Helper class introducing a boolean type for specifying boolean values (+true+ and +false+) as\n    # option types.\n    class Boolean\n\n      # Return +true+ if +other+ is either +true+ or +false+\n      def self.===(other)\n        FalseClass === other || TrueClass === other\n      end\n\n    end\n\n    # ----------------------------\n    # :section: Option definitions\n    #\n    # This sections describes the methods that can be used on the Options module.\n    # ----------------------------\n\n    # Struct class for storing the definition of an option.\n    Definition = Struct.new(:name, :type, :default, :desc, :validator)\n\n    # Allowed option types.\n    ALLOWED_TYPES = [String, Integer, Float, Symbol, Boolean, Object]\n\n    @options = {}\n\n    # Define a new option called +name+ (a Symbol) with the given +type+ (String, Integer, Float,\n    # Symbol, Boolean, Object), default value +default+ and the description +desc+. If a block is\n    # specified, it should validate the value and either raise an error or return a valid value.\n    #\n    # The type 'Object' should only be used for complex types for which none of the other types\n    # suffices. A block needs to be specified when using type 'Object' and it has to cope with\n    # a value given as string and as the opaque type.\n    def self.define(name, type, default, desc, &block)\n      name = name.to_sym\n      raise ArgumentError, \"Option name #{name} is already used\" if @options.key?(name)\n      raise ArgumentError, \"Invalid option type #{type} specified\" unless ALLOWED_TYPES.include?(type)\n      raise ArgumentError, \"Invalid type for default value\" if !(type === default) && !default.nil?\n      raise ArgumentError, \"Missing validator block\" if type == Object && block.nil?\n      @options[name] = Definition.new(name, type, default, desc, block)\n    end\n\n    # Return all option definitions.\n    def self.definitions\n      @options\n    end\n\n    # Return +true+ if an option called +name+ is defined.\n    def self.defined?(name)\n      @options.key?(name.to_sym)\n    end\n\n    # Return a Hash with the default values for all options.\n    def self.defaults\n      temp = {}\n      @options.each {|_n, o| temp[o.name] = o.default }\n      temp\n    end\n\n    # Merge the #defaults Hash with the *parsed* options from the given Hash, i.e. only valid option\n    # names are considered and their value is run through the #parse method.\n    def self.merge(hash)\n      temp = defaults\n      hash.each do |k, v|\n        k = k.to_sym\n        temp[k] = @options.key?(k) ? parse(k, v) : v\n      end\n      temp\n    end\n\n    # Parse the given value +data+ as if it was a value for the option +name+ and return the parsed\n    # value with the correct type.\n    #\n    # If +data+ already has the correct type, it is just returned. Otherwise it is converted to a\n    # String and then to the correct type.\n    def self.parse(name, data)\n      name = name.to_sym\n      raise ArgumentError, \"No option named #{name} defined\" unless @options.key?(name)\n      unless @options[name].type === data\n        data = data.to_s\n        data = if @options[name].type == String\n                 data\n               elsif @options[name].type == Integer\n                 Integer(data) rescue raise Kramdown::Error, \"Invalid integer value for option '#{name}': '#{data}'\"\n               elsif @options[name].type == Float\n                 Float(data) rescue raise Kramdown::Error, \"Invalid float value for option '#{name}': '#{data}'\"\n               elsif @options[name].type == Symbol\n                 str_to_sym(data)\n               elsif @options[name].type == Boolean\n                 data.downcase.strip != 'false' && !data.empty?\n               end\n      end\n      data = @options[name].validator[data] if @options[name].validator\n      data\n    end\n\n    # Converts the given String +data+ into a Symbol or +nil+ with the\n    # following provisions:\n    #\n    # - A leading colon is stripped from the string.\n    # - An empty value or a value equal to \"nil\" results in +nil+.\n    def self.str_to_sym(data)\n      data = data.strip\n      data = data[1..-1] if data[0] == ':'\n      (data.empty? || data == 'nil' ? nil : data.to_sym)\n    end\n\n    # ----------------------------\n    # :section: Option Validators\n    #\n    # This sections contains all pre-defined option validators.\n    # ----------------------------\n\n    # Ensures that the option value +val+ for the option called +name+ is a valid array. The\n    # parameter +val+ can be\n    #\n    # - a comma separated string which is split into an array of values\n    # - or an array.\n    #\n    # Optionally, the array is checked for the correct size.\n    def self.simple_array_validator(val, name, size = nil)\n      if String === val\n        val = val.split(/,/)\n      elsif !(Array === val)\n        raise Kramdown::Error, \"Invalid type #{val.class} for option #{name}\"\n      end\n      if size && val.size != size\n        raise Kramdown::Error, \"Option #{name} needs exactly #{size} values\"\n      end\n      val\n    end\n\n    # Ensures that the option value +val+ for the option called +name+ is a valid hash. The\n    # parameter +val+ can be\n    #\n    # - a hash in YAML format\n    # - or a Ruby Hash object.\n    def self.simple_hash_validator(val, name)\n      if String === val\n        begin\n          val = YAML.safe_load(val)\n        rescue RuntimeError, ArgumentError, SyntaxError\n          raise Kramdown::Error, \"Invalid YAML value for option #{name}\"\n        end\n      end\n      raise Kramdown::Error, \"Invalid type #{val.class} for option #{name}\" unless Hash === val\n      val\n    end\n\n    # ----------------------------\n    # :section: Option Definitions\n    #\n    # This sections contains all option definitions that are used by the included\n    # parsers/converters.\n    # ----------------------------\n\n    define(:template, String, '', <<~EOF)\n      The name of an ERB template file that should be used to wrap the output\n      or the ERB template itself.\n\n      This is used to wrap the output in an environment so that the output can\n      be used as a stand-alone document. For example, an HTML template would\n      provide the needed header and body tags so that the whole output is a\n      valid HTML file. If no template is specified, the output will be just\n      the converted text.\n\n      When resolving the template file, the given template name is used first.\n      If such a file is not found, the converter extension (the same as the\n      converter name) is appended. If the file still cannot be found, the\n      templates name is interpreted as a template name that is provided by\n      kramdown (without the converter extension). If the file is still not\n      found, the template name is checked if it starts with 'string://' and if\n      it does, this prefix is removed and the rest is used as template\n      content.\n\n      kramdown provides a default template named 'document' for each converter.\n\n      Default: ''\n      Used by: all converters\n    EOF\n\n    define(:auto_ids, Boolean, true, <<~EOF)\n      Use automatic header ID generation\n\n      If this option is `true`, ID values for all headers are automatically\n      generated if no ID is explicitly specified.\n\n      Default: true\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:auto_id_stripping, Boolean, false, <<~EOF)\n      Strip all formatting from header text for automatic ID generation\n\n      If this option is `true`, only the text elements of a header are used\n      for generating the ID later (in contrast to just using the raw header\n      text line).\n\n      This option will be removed in version 2.0 because this will be the\n      default then.\n\n      Default: false\n      Used by: kramdown parser\n    EOF\n\n    define(:auto_id_prefix, String, '', <<~EOF)\n      Prefix used for automatically generated header IDs\n\n      This option can be used to set a prefix for the automatically generated\n      header IDs so that there is no conflict when rendering multiple kramdown\n      documents into one output file separately. The prefix should only\n      contain characters that are valid in an ID!\n\n      Default: ''\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:transliterated_header_ids, Boolean, false, <<~EOF)\n      Transliterate the header text before generating the ID\n\n      Only ASCII characters are used in headers IDs. This is not good for\n      languages with many non-ASCII characters. By enabling this option\n      the header text is transliterated to ASCII as good as possible so that\n      the resulting header ID is more useful.\n\n      The stringex library needs to be installed for this feature to work!\n\n      Default: false\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:parse_block_html, Boolean, false, <<~EOF)\n      Process kramdown syntax in block HTML tags\n\n      If this option is `true`, the kramdown parser processes the content of\n      block HTML tags as text containing block-level elements. Since this is\n      not wanted normally, the default is `false`. It is normally better to\n      selectively enable kramdown processing via the markdown attribute.\n\n      Default: false\n      Used by: kramdown parser\n    EOF\n\n    define(:parse_span_html, Boolean, true, <<~EOF)\n      Process kramdown syntax in span HTML tags\n\n      If this option is `true`, the kramdown parser processes the content of\n      span HTML tags as text containing span-level elements.\n\n      Default: true\n      Used by: kramdown parser\n    EOF\n\n    define(:html_to_native, Boolean, false, <<~EOF)\n      Convert HTML elements to native elements\n\n      If this option is `true`, the parser converts HTML elements to native\n      elements. For example, when parsing `<em>hallo</em>` the emphasis tag\n      would normally be converted to an `:html` element with tag type `:em`.\n      If `html_to_native` is `true`, then the emphasis would be converted to a\n      native `:em` element.\n\n      This is useful for converters that cannot deal with HTML elements.\n\n      Default: false\n      Used by: kramdown parser\n    EOF\n\n    define(:link_defs, Object, {}, <<~EOF) do |val|\n      Pre-defines link definitions\n\n      This option can be used to pre-define link definitions. The value needs\n      to be a Hash where the keys are the link identifiers and the values are\n      two element Arrays with the link URL and the link title.\n\n      If the value is a String, it has to contain a valid YAML hash and the\n      hash has to follow the above guidelines.\n\n      Default: {}\n      Used by: kramdown parser\n    EOF\n      val = simple_hash_validator(val, :link_defs)\n      val.each do |_k, v|\n        if !(Array === v) || v.size > 2 || v.empty?\n          raise Kramdown::Error, \"Invalid structure for hash value of option #{name}\"\n        end\n        v << nil if v.size == 1\n      end\n      val\n    end\n\n    define(:footnote_nr, Integer, 1, <<~EOF)\n      The number of the first footnote\n\n      This option can be used to specify the number that is used for the first\n      footnote.\n\n      Default: 1\n      Used by: HTML converter\n    EOF\n\n    define(:entity_output, Symbol, :as_char, <<~EOF)\n      Defines how entities are output\n\n      The possible values are :as_input (entities are output in the same\n      form as found in the input), :numeric (entities are output in numeric\n      form), :symbolic (entities are output in symbolic form if possible) or\n      :as_char (entities are output as characters if possible, only available\n      on Ruby 1.9).\n\n      Default: :as_char\n      Used by: HTML converter, kramdown converter\n    EOF\n\n    TOC_LEVELS_RANGE = (1..6).freeze\n    TOC_LEVELS_ARRAY = TOC_LEVELS_RANGE.to_a.freeze\n    private_constant :TOC_LEVELS_RANGE, :TOC_LEVELS_ARRAY\n\n    define(:toc_levels, Object, TOC_LEVELS_ARRAY, <<~EOF) do |val|\n      Defines the levels that are used for the table of contents\n\n      The individual levels can be specified by separating them with commas\n      (e.g. 1,2,3) or by using the range syntax (e.g. 1..3). Only the\n      specified levels are used for the table of contents.\n\n      Default: 1..6\n      Used by: HTML/Latex converter\n    EOF\n      case val\n      when String\n        if val =~ /^(\\d)\\.\\.(\\d)$/\n          val = Range.new($1.to_i, $2.to_i).to_a\n        elsif val =~ /^\\d(?:,\\d)*$/\n          val = val.split(/,/).map(&:to_i).uniq\n        else\n          raise Kramdown::Error, \"Invalid syntax for option toc_levels\"\n        end\n      when Array\n        unless val.eql?(TOC_LEVELS_ARRAY)\n          val = val.map(&:to_i).uniq\n        end\n      when Range\n        if val.eql?(TOC_LEVELS_RANGE)\n          val = TOC_LEVELS_ARRAY\n        else\n          val = val.map(&:to_i).uniq\n        end\n      else\n        raise Kramdown::Error, \"Invalid type #{val.class} for option toc_levels\"\n      end\n      if val.any? {|i| !TOC_LEVELS_RANGE.cover?(i) }\n        raise Kramdown::Error, \"Level numbers for option toc_levels have to be integers from 1 to 6\"\n      end\n      val\n    end\n\n    define(:line_width, Integer, 72, <<~EOF)\n      Defines the line width to be used when outputting a document\n\n      Default: 72\n      Used by: kramdown converter\n    EOF\n\n    define(:latex_headers, Object, %w[section subsection subsubsection paragraph subparagraph subparagraph], <<~EOF) do |val|\n      Defines the LaTeX commands for different header levels\n\n      The commands for the header levels one to six can be specified by\n      separating them with commas.\n\n      Default: section,subsection,subsubsection,paragraph,subparagraph,subparagraph\n      Used by: Latex converter\n    EOF\n      simple_array_validator(val, :latex_headers, 6)\n    end\n\n    SMART_QUOTES_ENTITIES = %w[lsquo rsquo ldquo rdquo].freeze\n    SMART_QUOTES_STR = SMART_QUOTES_ENTITIES.join(',').freeze\n    private_constant :SMART_QUOTES_ENTITIES, :SMART_QUOTES_STR\n\n    define(:smart_quotes, Object, SMART_QUOTES_ENTITIES, <<~EOF) do |val|\n      Defines the HTML entity names or code points for smart quote output\n\n      The entities identified by entity name or code point that should be\n      used for, in order, a left single quote, a right single quote, a left\n      double and a right double quote are specified by separating them with\n      commas.\n\n      Default: lsquo,rsquo,ldquo,rdquo\n      Used by: HTML/Latex converter\n    EOF\n      if val == SMART_QUOTES_STR || val == SMART_QUOTES_ENTITIES\n        SMART_QUOTES_ENTITIES\n      else\n        val = simple_array_validator(val, :smart_quotes, 4)\n        val.map! {|v| Integer(v) rescue v }\n        val\n      end\n    end\n\n    define(:typographic_symbols, Object, {}, <<~EOF) do |val|\n      Defines a mapping from typographical symbol to output characters\n\n      Typographical symbols are normally output using their equivalent Unicode\n      codepoint. However, sometimes one wants to change the output, mostly to\n      fallback to a sequence of ASCII characters.\n\n      This option allows this by specifying a mapping from typographical\n      symbol to its output string. For example, the mapping {hellip: ...} would\n      output the standard ASCII representation of an ellipsis.\n\n      The available typographical symbol names are:\n\n      * hellip: ellipsis\n      * mdash: em-dash\n      * ndash: en-dash\n      * laquo: left guillemet\n      * raquo: right guillemet\n      * laquo_space: left guillemet followed by a space\n      * raquo_space: right guillemet preceeded by a space\n\n      Default: {}\n      Used by: HTML/Latex converter\n    EOF\n      val = simple_hash_validator(val, :typographic_symbols)\n      val.keys.each do |k|\n        val[k.kind_of?(String) ? str_to_sym(k) : k] = val.delete(k).to_s\n      end\n      val\n    end\n\n    define(:remove_block_html_tags, Boolean, true, <<~EOF)\n      Remove block HTML tags\n\n      If this option is `true`, the RemoveHtmlTags converter removes\n      block HTML tags.\n\n      Default: true\n      Used by: RemoveHtmlTags converter\n    EOF\n\n    define(:remove_span_html_tags, Boolean, false, <<~EOF)\n      Remove span HTML tags\n\n      If this option is `true`, the RemoveHtmlTags converter removes\n      span HTML tags.\n\n      Default: false\n      Used by: RemoveHtmlTags converter\n    EOF\n\n    define(:header_offset, Integer, 0, <<~EOF)\n      Sets the output offset for headers\n\n      If this option is c (may also be negative) then a header with level n\n      will be output as a header with level c+n. If c+n is lower than 1,\n      level 1 will be used. If c+n is greater than 6, level 6 will be used.\n\n      Default: 0\n      Used by: HTML converter, Kramdown converter, Latex converter\n    EOF\n\n    define(:syntax_highlighter, Symbol, :rouge, <<~EOF)\n      Set the syntax highlighter\n\n      Specifies the syntax highlighter that should be used for highlighting\n      code blocks and spans. If this option is set to +nil+, no syntax\n      highlighting is done.\n\n      Options for the syntax highlighter can be set with the\n      syntax_highlighter_opts configuration option.\n\n      Default: rouge\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:syntax_highlighter_opts, Object, {}, <<~EOF) do |val|\n      Set the syntax highlighter options\n\n      Specifies options for the syntax highlighter set via the\n      syntax_highlighter configuration option.\n\n      The value needs to be a hash with key-value pairs that are understood by\n      the used syntax highlighter.\n\n      Default: {}\n      Used by: HTML/Latex converter\n    EOF\n      val = simple_hash_validator(val, :syntax_highlighter_opts)\n      val.keys.each do |k|\n        val[k.kind_of?(String) ? str_to_sym(k) : k] = val.delete(k)\n      end\n      val\n    end\n\n    define(:math_engine, Symbol, :mathjax, <<~EOF)\n      Set the math engine\n\n      Specifies the math engine that should be used for converting math\n      blocks/spans. If this option is set to +nil+, no math engine is used and\n      the math blocks/spans are output as is.\n\n      Options for the selected math engine can be set with the\n      math_engine_opts configuration option.\n\n      Default: mathjax\n      Used by: HTML converter\n    EOF\n\n    define(:math_engine_opts, Object, {}, <<~EOF) do |val|\n      Set the math engine options\n\n      Specifies options for the math engine set via the math_engine\n      configuration option.\n\n      The value needs to be a hash with key-value pairs that are understood by\n      the used math engine.\n\n      Default: {}\n      Used by: HTML converter\n    EOF\n      val = simple_hash_validator(val, :math_engine_opts)\n      val.keys.each do |k|\n        val[k.kind_of?(String) ? str_to_sym(k) : k] = val.delete(k)\n      end\n      val\n    end\n\n    define(:footnote_backlink, String, '&#8617;', <<~EOF)\n      Defines the text that should be used for the footnote backlinks\n\n      The footnote backlink is just text, so any special HTML characters will\n      be escaped.\n\n      If the footnote backlint text is an empty string, no footnote backlinks\n      will be generated.\n\n      Default: '&8617;'\n      Used by: HTML converter\n    EOF\n\n    define(:footnote_backlink_inline, Boolean, false, <<~EOF)\n      Specifies whether the footnote backlink should always be inline\n\n      With the default of false the footnote backlink is placed at the end of\n      the last paragraph if there is one, or an extra paragraph with only the\n      footnote backlink is created.\n\n      Setting this option to true tries to place the footnote backlink in the\n      last, possibly nested paragraph or header. If this fails (e.g. in the\n      case of a table), an extra paragraph with only the footnote backlink is\n      created.\n\n      Default: false\n      Used by: HTML converter\n    EOF\n\n    define(:footnote_prefix, String, '', <<~EOF)\n      Prefix used for footnote IDs\n\n      This option can be used to set a prefix for footnote IDs. This is useful\n      when rendering multiple documents into the same output file to avoid\n      duplicate IDs. The prefix should only contain characters that are valid\n      in an ID!\n\n      Default: ''\n      Used by: HTML\n    EOF\n\n    define(:remove_line_breaks_for_cjk, Boolean, false, <<~EOF)\n      Specifies whether line breaks should be removed between CJK characters\n\n      Default: false\n      Used by: HTML converter\n    EOF\n\n  end\n\nend\n", "# -*- coding: utf-8; frozen_string_literal: true -*-\n#\n#--\n# Copyright (C) 2009-2019 Thomas Leitner <t_leitner@gmx.at>\n#\n# This file is part of kramdown which is licensed under the MIT.\n#++\n#\n\nmodule Kramdown\n  module Parser\n    class Kramdown\n\n      IAL_CLASS_ATTR = 'class'\n\n      # Parse the string +str+ and extract all attributes and add all found attributes to the hash\n      # +opts+.\n      def parse_attribute_list(str, opts)\n        return if str.strip.empty? || str.strip == ':'\n        attrs = str.scan(ALD_TYPE_ANY)\n        attrs.each do |key, sep, val, ref, id_and_or_class, _, _|\n          if ref\n            (opts[:refs] ||= []) << ref\n          elsif id_and_or_class\n            id_and_or_class.scan(ALD_TYPE_ID_OR_CLASS).each do |id_attr, class_attr|\n              if class_attr\n                opts[IAL_CLASS_ATTR] = \"#{opts[IAL_CLASS_ATTR]} #{class_attr}\".lstrip\n              else\n                opts['id'] = id_attr\n              end\n            end\n          else\n            val.gsub!(/\\\\(\\}|#{sep})/, \"\\\\1\")\n            opts[key] = val\n          end\n        end\n        warning(\"No or invalid attributes found in IAL/ALD content: #{str}\") if attrs.empty?\n      end\n\n      # Update the +ial+ with the information from the inline attribute list +opts+.\n      def update_ial_with_ial(ial, opts)\n        (ial[:refs] ||= []).concat(opts[:refs]) if opts.key?(:refs)\n        opts.each do |k, v|\n          if k == IAL_CLASS_ATTR\n            ial[k] = \"#{ial[k]} #{v}\".lstrip\n          elsif k.kind_of?(String)\n            ial[k] = v\n          end\n        end\n      end\n\n      # Parse the generic extension at the current point. The parameter +type+ can either be :block\n      # or :span depending whether we parse a block or span extension tag.\n      def parse_extension_start_tag(type)\n        saved_pos = @src.save_pos\n        start_line_number = @src.current_line_number\n        @src.pos += @src.matched_size\n\n        error_block = lambda do |msg|\n          warning(msg)\n          @src.revert_pos(saved_pos)\n          add_text(@src.getch) if type == :span\n          false\n        end\n\n        if @src[4] || @src.matched == '{:/}'\n          name = (@src[4] ? \"for '#{@src[4]}' \" : '')\n          return error_block.call(\"Invalid extension stop tag #{name} found on line \" \\\n                                  \"#{start_line_number} - ignoring it\")\n        end\n\n        ext = @src[1]\n        opts = {}\n        body = nil\n        parse_attribute_list(@src[2] || '', opts)\n\n        unless @src[3]\n          stop_re = (type == :block ? /#{EXT_BLOCK_STOP_STR % ext}/ : /#{EXT_STOP_STR % ext}/)\n          if (result = @src.scan_until(stop_re))\n            body = result.sub!(stop_re, '')\n            body.chomp! if type == :block\n          else\n            return error_block.call(\"No stop tag for extension '#{ext}' found on line \" \\\n                                    \"#{start_line_number} - ignoring it\")\n          end\n        end\n\n        if !handle_extension(ext, opts, body, type, start_line_number)\n          error_block.call(\"Invalid extension with name '#{ext}' specified on line \" \\\n                           \"#{start_line_number} - ignoring it\")\n        else\n          true\n        end\n      end\n\n      def handle_extension(name, opts, body, type, line_no = nil)\n        case name\n        when 'comment'\n          if body.kind_of?(String)\n            @tree.children << Element.new(:comment, body, nil, category: type, location: line_no)\n          end\n          true\n        when 'nomarkdown'\n          if body.kind_of?(String)\n            @tree.children << Element.new(:raw, body, nil, category: type,\n                                          location: line_no, type: opts['type'].to_s.split(/\\s+/))\n          end\n          true\n        when 'options'\n          opts.select do |k, v|\n            k = k.to_sym\n            if Kramdown::Options.defined?(k)\n              begin\n                val = Kramdown::Options.parse(k, v)\n                @options[k] = val\n                (@root.options[:options] ||= {})[k] = val\n              rescue StandardError\n              end\n              false\n            else\n              true\n            end\n          end.each do |k, _v|\n            warning(\"Unknown kramdown option '#{k}'\")\n          end\n          @tree.children << new_block_el(:eob, :extension) if type == :block\n          true\n        else\n          false\n        end\n      end\n\n      ALD_ID_CHARS = /[\\w-]/\n      ALD_ANY_CHARS = /\\\\\\}|[^\\}]/\n      ALD_ID_NAME = /\\w#{ALD_ID_CHARS}*/\n      ALD_CLASS_NAME = /[^\\s\\.#]+/\n      ALD_TYPE_KEY_VALUE_PAIR = /(#{ALD_ID_NAME})=(\"|')((?:\\\\\\}|\\\\\\2|[^\\}\\2])*?)\\2/\n      ALD_TYPE_CLASS_NAME = /\\.(#{ALD_CLASS_NAME})/\n      ALD_TYPE_ID_NAME = /#([A-Za-z][\\w:-]*)/\n      ALD_TYPE_ID_OR_CLASS = /#{ALD_TYPE_ID_NAME}|#{ALD_TYPE_CLASS_NAME}/\n      ALD_TYPE_ID_OR_CLASS_MULTI = /((?:#{ALD_TYPE_ID_NAME}|#{ALD_TYPE_CLASS_NAME})+)/\n      ALD_TYPE_REF = /(#{ALD_ID_NAME})/\n      ALD_TYPE_ANY = /(?:\\A|\\s)(?:#{ALD_TYPE_KEY_VALUE_PAIR}|#{ALD_TYPE_REF}|#{ALD_TYPE_ID_OR_CLASS_MULTI})(?=\\s|\\Z)/\n      ALD_START = /^#{OPT_SPACE}\\{:(#{ALD_ID_NAME}):(#{ALD_ANY_CHARS}+)\\}\\s*?\\n/\n\n      EXT_STOP_STR = \"\\\\{:/(%s)?\\\\}\"\n      EXT_START_STR = \"\\\\{::(\\\\w+)(?:\\\\s(#{ALD_ANY_CHARS}*?)|)(\\\\/)?\\\\}\"\n      EXT_BLOCK_START = /^#{OPT_SPACE}(?:#{EXT_START_STR}|#{EXT_STOP_STR % ALD_ID_NAME})\\s*?\\n/\n      EXT_BLOCK_STOP_STR = \"^#{OPT_SPACE}#{EXT_STOP_STR}\\s*?\\n\"\n\n      IAL_BLOCK = /\\{:(?!:|\\/)(#{ALD_ANY_CHARS}+)\\}\\s*?\\n/\n      IAL_BLOCK_START = /^#{OPT_SPACE}#{IAL_BLOCK}/\n\n      BLOCK_EXTENSIONS_START = /^#{OPT_SPACE}\\{:/\n\n      # Parse one of the block extensions (ALD, block IAL or generic extension) at the current\n      # location.\n      def parse_block_extensions\n        if @src.scan(ALD_START)\n          parse_attribute_list(@src[2], @alds[@src[1]] ||= {})\n          @tree.children << new_block_el(:eob, :ald)\n          true\n        elsif @src.check(EXT_BLOCK_START)\n          parse_extension_start_tag(:block)\n        elsif @src.scan(IAL_BLOCK_START)\n          if (last_child = @tree.children.last) && last_child.type != :blank &&\n              (last_child.type != :eob ||\n               [:link_def, :abbrev_def, :footnote_def].include?(last_child.value))\n            parse_attribute_list(@src[1], last_child.options[:ial] ||= {})\n            @tree.children << new_block_el(:eob, :ial) unless @src.check(IAL_BLOCK_START)\n          else\n            parse_attribute_list(@src[1], @block_ial ||= {})\n          end\n          true\n        else\n          false\n        end\n      end\n      define_parser(:block_extensions, BLOCK_EXTENSIONS_START)\n\n      EXT_SPAN_START = /#{EXT_START_STR}|#{EXT_STOP_STR % ALD_ID_NAME}/\n      IAL_SPAN_START = /\\{:(#{ALD_ANY_CHARS}+)\\}/\n      SPAN_EXTENSIONS_START = /\\{:/\n\n      # Parse the extension span at the current location.\n      def parse_span_extensions\n        if @src.check(EXT_SPAN_START)\n          parse_extension_start_tag(:span)\n        elsif @src.check(IAL_SPAN_START)\n          if (last_child = @tree.children.last) && last_child.type != :text\n            @src.pos += @src.matched_size\n            attr = {}\n            parse_attribute_list(@src[1], attr)\n            update_ial_with_ial(last_child.options[:ial] ||= {}, attr)\n            update_attr_with_ial(last_child.attr, attr)\n          else\n            warning(\"Found span IAL after text - ignoring it\")\n            add_text(@src.getch)\n          end\n        else\n          add_text(@src.getch)\n        end\n      end\n      define_parser(:span_extensions, SPAN_EXTENSIONS_START, '\\{:')\n\n    end\n  end\nend\n", "# No header id\n\n{::options unusedvar=\"val\" /}\n\n# without header id\n\n<div>\nsome <span>*para*</span>\n</div>\n\n{::options parse_block_html=\"true\" parse_span_html=\"true\" /}\n\n<div>\nsome <span>*para*</span>\n</div>\n\n{::options footnote_nr=\"10\" /}\n\nSome text[^ab].\n\n[^ab]: Some text.\n"], "fixing_code": ["# -*- coding: utf-8; frozen_string_literal: true -*-\n#\n#--\n# Copyright (C) 2009-2019 Thomas Leitner <t_leitner@gmx.at>\n#\n# This file is part of kramdown which is licensed under the MIT.\n#++\n#\n\nrequire 'yaml'\n\nmodule Kramdown\n\n  # This module defines all options that are used by parsers and/or converters as well as providing\n  # methods to deal with the options.\n  module Options\n\n    # Helper class introducing a boolean type for specifying boolean values (+true+ and +false+) as\n    # option types.\n    class Boolean\n\n      # Return +true+ if +other+ is either +true+ or +false+\n      def self.===(other)\n        FalseClass === other || TrueClass === other\n      end\n\n    end\n\n    # ----------------------------\n    # :section: Option definitions\n    #\n    # This sections describes the methods that can be used on the Options module.\n    # ----------------------------\n\n    # Struct class for storing the definition of an option.\n    Definition = Struct.new(:name, :type, :default, :desc, :validator)\n\n    # Allowed option types.\n    ALLOWED_TYPES = [String, Integer, Float, Symbol, Boolean, Object]\n\n    @options = {}\n\n    # Define a new option called +name+ (a Symbol) with the given +type+ (String, Integer, Float,\n    # Symbol, Boolean, Object), default value +default+ and the description +desc+. If a block is\n    # specified, it should validate the value and either raise an error or return a valid value.\n    #\n    # The type 'Object' should only be used for complex types for which none of the other types\n    # suffices. A block needs to be specified when using type 'Object' and it has to cope with\n    # a value given as string and as the opaque type.\n    def self.define(name, type, default, desc, &block)\n      name = name.to_sym\n      raise ArgumentError, \"Option name #{name} is already used\" if @options.key?(name)\n      raise ArgumentError, \"Invalid option type #{type} specified\" unless ALLOWED_TYPES.include?(type)\n      raise ArgumentError, \"Invalid type for default value\" if !(type === default) && !default.nil?\n      raise ArgumentError, \"Missing validator block\" if type == Object && block.nil?\n      @options[name] = Definition.new(name, type, default, desc, block)\n    end\n\n    # Return all option definitions.\n    def self.definitions\n      @options\n    end\n\n    # Return +true+ if an option called +name+ is defined.\n    def self.defined?(name)\n      @options.key?(name.to_sym)\n    end\n\n    # Return a Hash with the default values for all options.\n    def self.defaults\n      temp = {}\n      @options.each {|_n, o| temp[o.name] = o.default }\n      temp\n    end\n\n    # Merge the #defaults Hash with the *parsed* options from the given Hash, i.e. only valid option\n    # names are considered and their value is run through the #parse method.\n    def self.merge(hash)\n      temp = defaults\n      hash.each do |k, v|\n        k = k.to_sym\n        temp[k] = @options.key?(k) ? parse(k, v) : v\n      end\n      temp\n    end\n\n    # Parse the given value +data+ as if it was a value for the option +name+ and return the parsed\n    # value with the correct type.\n    #\n    # If +data+ already has the correct type, it is just returned. Otherwise it is converted to a\n    # String and then to the correct type.\n    def self.parse(name, data)\n      name = name.to_sym\n      raise ArgumentError, \"No option named #{name} defined\" unless @options.key?(name)\n      unless @options[name].type === data\n        data = data.to_s\n        data = if @options[name].type == String\n                 data\n               elsif @options[name].type == Integer\n                 Integer(data) rescue raise Kramdown::Error, \"Invalid integer value for option '#{name}': '#{data}'\"\n               elsif @options[name].type == Float\n                 Float(data) rescue raise Kramdown::Error, \"Invalid float value for option '#{name}': '#{data}'\"\n               elsif @options[name].type == Symbol\n                 str_to_sym(data)\n               elsif @options[name].type == Boolean\n                 data.downcase.strip != 'false' && !data.empty?\n               end\n      end\n      data = @options[name].validator[data] if @options[name].validator\n      data\n    end\n\n    # Converts the given String +data+ into a Symbol or +nil+ with the\n    # following provisions:\n    #\n    # - A leading colon is stripped from the string.\n    # - An empty value or a value equal to \"nil\" results in +nil+.\n    def self.str_to_sym(data)\n      data = data.strip\n      data = data[1..-1] if data[0] == ':'\n      (data.empty? || data == 'nil' ? nil : data.to_sym)\n    end\n\n    # ----------------------------\n    # :section: Option Validators\n    #\n    # This sections contains all pre-defined option validators.\n    # ----------------------------\n\n    # Ensures that the option value +val+ for the option called +name+ is a valid array. The\n    # parameter +val+ can be\n    #\n    # - a comma separated string which is split into an array of values\n    # - or an array.\n    #\n    # Optionally, the array is checked for the correct size.\n    def self.simple_array_validator(val, name, size = nil)\n      if String === val\n        val = val.split(/,/)\n      elsif !(Array === val)\n        raise Kramdown::Error, \"Invalid type #{val.class} for option #{name}\"\n      end\n      if size && val.size != size\n        raise Kramdown::Error, \"Option #{name} needs exactly #{size} values\"\n      end\n      val\n    end\n\n    # Ensures that the option value +val+ for the option called +name+ is a valid hash. The\n    # parameter +val+ can be\n    #\n    # - a hash in YAML format\n    # - or a Ruby Hash object.\n    def self.simple_hash_validator(val, name)\n      if String === val\n        begin\n          val = YAML.safe_load(val)\n        rescue RuntimeError, ArgumentError, SyntaxError\n          raise Kramdown::Error, \"Invalid YAML value for option #{name}\"\n        end\n      end\n      raise Kramdown::Error, \"Invalid type #{val.class} for option #{name}\" unless Hash === val\n      val\n    end\n\n    # ----------------------------\n    # :section: Option Definitions\n    #\n    # This sections contains all option definitions that are used by the included\n    # parsers/converters.\n    # ----------------------------\n\n    define(:template, String, '', <<~EOF)\n      The name of an ERB template file that should be used to wrap the output\n      or the ERB template itself.\n\n      This is used to wrap the output in an environment so that the output can\n      be used as a stand-alone document. For example, an HTML template would\n      provide the needed header and body tags so that the whole output is a\n      valid HTML file. If no template is specified, the output will be just\n      the converted text.\n\n      When resolving the template file, the given template name is used first.\n      If such a file is not found, the converter extension (the same as the\n      converter name) is appended. If the file still cannot be found, the\n      templates name is interpreted as a template name that is provided by\n      kramdown (without the converter extension). If the file is still not\n      found, the template name is checked if it starts with 'string://' and if\n      it does, this prefix is removed and the rest is used as template\n      content.\n\n      kramdown provides a default template named 'document' for each converter.\n\n      Default: ''\n      Used by: all converters\n    EOF\n\n    define(:auto_ids, Boolean, true, <<~EOF)\n      Use automatic header ID generation\n\n      If this option is `true`, ID values for all headers are automatically\n      generated if no ID is explicitly specified.\n\n      Default: true\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:auto_id_stripping, Boolean, false, <<~EOF)\n      Strip all formatting from header text for automatic ID generation\n\n      If this option is `true`, only the text elements of a header are used\n      for generating the ID later (in contrast to just using the raw header\n      text line).\n\n      This option will be removed in version 2.0 because this will be the\n      default then.\n\n      Default: false\n      Used by: kramdown parser\n    EOF\n\n    define(:auto_id_prefix, String, '', <<~EOF)\n      Prefix used for automatically generated header IDs\n\n      This option can be used to set a prefix for the automatically generated\n      header IDs so that there is no conflict when rendering multiple kramdown\n      documents into one output file separately. The prefix should only\n      contain characters that are valid in an ID!\n\n      Default: ''\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:transliterated_header_ids, Boolean, false, <<~EOF)\n      Transliterate the header text before generating the ID\n\n      Only ASCII characters are used in headers IDs. This is not good for\n      languages with many non-ASCII characters. By enabling this option\n      the header text is transliterated to ASCII as good as possible so that\n      the resulting header ID is more useful.\n\n      The stringex library needs to be installed for this feature to work!\n\n      Default: false\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:parse_block_html, Boolean, false, <<~EOF)\n      Process kramdown syntax in block HTML tags\n\n      If this option is `true`, the kramdown parser processes the content of\n      block HTML tags as text containing block-level elements. Since this is\n      not wanted normally, the default is `false`. It is normally better to\n      selectively enable kramdown processing via the markdown attribute.\n\n      Default: false\n      Used by: kramdown parser\n    EOF\n\n    define(:parse_span_html, Boolean, true, <<~EOF)\n      Process kramdown syntax in span HTML tags\n\n      If this option is `true`, the kramdown parser processes the content of\n      span HTML tags as text containing span-level elements.\n\n      Default: true\n      Used by: kramdown parser\n    EOF\n\n    define(:html_to_native, Boolean, false, <<~EOF)\n      Convert HTML elements to native elements\n\n      If this option is `true`, the parser converts HTML elements to native\n      elements. For example, when parsing `<em>hallo</em>` the emphasis tag\n      would normally be converted to an `:html` element with tag type `:em`.\n      If `html_to_native` is `true`, then the emphasis would be converted to a\n      native `:em` element.\n\n      This is useful for converters that cannot deal with HTML elements.\n\n      Default: false\n      Used by: kramdown parser\n    EOF\n\n    define(:link_defs, Object, {}, <<~EOF) do |val|\n      Pre-defines link definitions\n\n      This option can be used to pre-define link definitions. The value needs\n      to be a Hash where the keys are the link identifiers and the values are\n      two element Arrays with the link URL and the link title.\n\n      If the value is a String, it has to contain a valid YAML hash and the\n      hash has to follow the above guidelines.\n\n      Default: {}\n      Used by: kramdown parser\n    EOF\n      val = simple_hash_validator(val, :link_defs)\n      val.each do |_k, v|\n        if !(Array === v) || v.size > 2 || v.empty?\n          raise Kramdown::Error, \"Invalid structure for hash value of option #{name}\"\n        end\n        v << nil if v.size == 1\n      end\n      val\n    end\n\n    define(:footnote_nr, Integer, 1, <<~EOF)\n      The number of the first footnote\n\n      This option can be used to specify the number that is used for the first\n      footnote.\n\n      Default: 1\n      Used by: HTML converter\n    EOF\n\n    define(:entity_output, Symbol, :as_char, <<~EOF)\n      Defines how entities are output\n\n      The possible values are :as_input (entities are output in the same\n      form as found in the input), :numeric (entities are output in numeric\n      form), :symbolic (entities are output in symbolic form if possible) or\n      :as_char (entities are output as characters if possible, only available\n      on Ruby 1.9).\n\n      Default: :as_char\n      Used by: HTML converter, kramdown converter\n    EOF\n\n    TOC_LEVELS_RANGE = (1..6).freeze\n    TOC_LEVELS_ARRAY = TOC_LEVELS_RANGE.to_a.freeze\n    private_constant :TOC_LEVELS_RANGE, :TOC_LEVELS_ARRAY\n\n    define(:toc_levels, Object, TOC_LEVELS_ARRAY, <<~EOF) do |val|\n      Defines the levels that are used for the table of contents\n\n      The individual levels can be specified by separating them with commas\n      (e.g. 1,2,3) or by using the range syntax (e.g. 1..3). Only the\n      specified levels are used for the table of contents.\n\n      Default: 1..6\n      Used by: HTML/Latex converter\n    EOF\n      case val\n      when String\n        if val =~ /^(\\d)\\.\\.(\\d)$/\n          val = Range.new($1.to_i, $2.to_i).to_a\n        elsif val =~ /^\\d(?:,\\d)*$/\n          val = val.split(/,/).map(&:to_i).uniq\n        else\n          raise Kramdown::Error, \"Invalid syntax for option toc_levels\"\n        end\n      when Array\n        unless val.eql?(TOC_LEVELS_ARRAY)\n          val = val.map(&:to_i).uniq\n        end\n      when Range\n        if val.eql?(TOC_LEVELS_RANGE)\n          val = TOC_LEVELS_ARRAY\n        else\n          val = val.map(&:to_i).uniq\n        end\n      else\n        raise Kramdown::Error, \"Invalid type #{val.class} for option toc_levels\"\n      end\n      if val.any? {|i| !TOC_LEVELS_RANGE.cover?(i) }\n        raise Kramdown::Error, \"Level numbers for option toc_levels have to be integers from 1 to 6\"\n      end\n      val\n    end\n\n    define(:line_width, Integer, 72, <<~EOF)\n      Defines the line width to be used when outputting a document\n\n      Default: 72\n      Used by: kramdown converter\n    EOF\n\n    define(:latex_headers, Object, %w[section subsection subsubsection paragraph subparagraph subparagraph], <<~EOF) do |val|\n      Defines the LaTeX commands for different header levels\n\n      The commands for the header levels one to six can be specified by\n      separating them with commas.\n\n      Default: section,subsection,subsubsection,paragraph,subparagraph,subparagraph\n      Used by: Latex converter\n    EOF\n      simple_array_validator(val, :latex_headers, 6)\n    end\n\n    SMART_QUOTES_ENTITIES = %w[lsquo rsquo ldquo rdquo].freeze\n    SMART_QUOTES_STR = SMART_QUOTES_ENTITIES.join(',').freeze\n    private_constant :SMART_QUOTES_ENTITIES, :SMART_QUOTES_STR\n\n    define(:smart_quotes, Object, SMART_QUOTES_ENTITIES, <<~EOF) do |val|\n      Defines the HTML entity names or code points for smart quote output\n\n      The entities identified by entity name or code point that should be\n      used for, in order, a left single quote, a right single quote, a left\n      double and a right double quote are specified by separating them with\n      commas.\n\n      Default: lsquo,rsquo,ldquo,rdquo\n      Used by: HTML/Latex converter\n    EOF\n      if val == SMART_QUOTES_STR || val == SMART_QUOTES_ENTITIES\n        SMART_QUOTES_ENTITIES\n      else\n        val = simple_array_validator(val, :smart_quotes, 4)\n        val.map! {|v| Integer(v) rescue v }\n        val\n      end\n    end\n\n    define(:typographic_symbols, Object, {}, <<~EOF) do |val|\n      Defines a mapping from typographical symbol to output characters\n\n      Typographical symbols are normally output using their equivalent Unicode\n      codepoint. However, sometimes one wants to change the output, mostly to\n      fallback to a sequence of ASCII characters.\n\n      This option allows this by specifying a mapping from typographical\n      symbol to its output string. For example, the mapping {hellip: ...} would\n      output the standard ASCII representation of an ellipsis.\n\n      The available typographical symbol names are:\n\n      * hellip: ellipsis\n      * mdash: em-dash\n      * ndash: en-dash\n      * laquo: left guillemet\n      * raquo: right guillemet\n      * laquo_space: left guillemet followed by a space\n      * raquo_space: right guillemet preceeded by a space\n\n      Default: {}\n      Used by: HTML/Latex converter\n    EOF\n      val = simple_hash_validator(val, :typographic_symbols)\n      val.keys.each do |k|\n        val[k.kind_of?(String) ? str_to_sym(k) : k] = val.delete(k).to_s\n      end\n      val\n    end\n\n    define(:remove_block_html_tags, Boolean, true, <<~EOF)\n      Remove block HTML tags\n\n      If this option is `true`, the RemoveHtmlTags converter removes\n      block HTML tags.\n\n      Default: true\n      Used by: RemoveHtmlTags converter\n    EOF\n\n    define(:remove_span_html_tags, Boolean, false, <<~EOF)\n      Remove span HTML tags\n\n      If this option is `true`, the RemoveHtmlTags converter removes\n      span HTML tags.\n\n      Default: false\n      Used by: RemoveHtmlTags converter\n    EOF\n\n    define(:header_offset, Integer, 0, <<~EOF)\n      Sets the output offset for headers\n\n      If this option is c (may also be negative) then a header with level n\n      will be output as a header with level c+n. If c+n is lower than 1,\n      level 1 will be used. If c+n is greater than 6, level 6 will be used.\n\n      Default: 0\n      Used by: HTML converter, Kramdown converter, Latex converter\n    EOF\n\n    define(:syntax_highlighter, Symbol, :rouge, <<~EOF)\n      Set the syntax highlighter\n\n      Specifies the syntax highlighter that should be used for highlighting\n      code blocks and spans. If this option is set to +nil+, no syntax\n      highlighting is done.\n\n      Options for the syntax highlighter can be set with the\n      syntax_highlighter_opts configuration option.\n\n      Default: rouge\n      Used by: HTML/Latex converter\n    EOF\n\n    define(:syntax_highlighter_opts, Object, {}, <<~EOF) do |val|\n      Set the syntax highlighter options\n\n      Specifies options for the syntax highlighter set via the\n      syntax_highlighter configuration option.\n\n      The value needs to be a hash with key-value pairs that are understood by\n      the used syntax highlighter.\n\n      Default: {}\n      Used by: HTML/Latex converter\n    EOF\n      val = simple_hash_validator(val, :syntax_highlighter_opts)\n      val.keys.each do |k|\n        val[k.kind_of?(String) ? str_to_sym(k) : k] = val.delete(k)\n      end\n      val\n    end\n\n    define(:math_engine, Symbol, :mathjax, <<~EOF)\n      Set the math engine\n\n      Specifies the math engine that should be used for converting math\n      blocks/spans. If this option is set to +nil+, no math engine is used and\n      the math blocks/spans are output as is.\n\n      Options for the selected math engine can be set with the\n      math_engine_opts configuration option.\n\n      Default: mathjax\n      Used by: HTML converter\n    EOF\n\n    define(:math_engine_opts, Object, {}, <<~EOF) do |val|\n      Set the math engine options\n\n      Specifies options for the math engine set via the math_engine\n      configuration option.\n\n      The value needs to be a hash with key-value pairs that are understood by\n      the used math engine.\n\n      Default: {}\n      Used by: HTML converter\n    EOF\n      val = simple_hash_validator(val, :math_engine_opts)\n      val.keys.each do |k|\n        val[k.kind_of?(String) ? str_to_sym(k) : k] = val.delete(k)\n      end\n      val\n    end\n\n    define(:footnote_backlink, String, '&#8617;', <<~EOF)\n      Defines the text that should be used for the footnote backlinks\n\n      The footnote backlink is just text, so any special HTML characters will\n      be escaped.\n\n      If the footnote backlint text is an empty string, no footnote backlinks\n      will be generated.\n\n      Default: '&8617;'\n      Used by: HTML converter\n    EOF\n\n    define(:footnote_backlink_inline, Boolean, false, <<~EOF)\n      Specifies whether the footnote backlink should always be inline\n\n      With the default of false the footnote backlink is placed at the end of\n      the last paragraph if there is one, or an extra paragraph with only the\n      footnote backlink is created.\n\n      Setting this option to true tries to place the footnote backlink in the\n      last, possibly nested paragraph or header. If this fails (e.g. in the\n      case of a table), an extra paragraph with only the footnote backlink is\n      created.\n\n      Default: false\n      Used by: HTML converter\n    EOF\n\n    define(:footnote_prefix, String, '', <<~EOF)\n      Prefix used for footnote IDs\n\n      This option can be used to set a prefix for footnote IDs. This is useful\n      when rendering multiple documents into the same output file to avoid\n      duplicate IDs. The prefix should only contain characters that are valid\n      in an ID!\n\n      Default: ''\n      Used by: HTML\n    EOF\n\n    define(:remove_line_breaks_for_cjk, Boolean, false, <<~EOF)\n      Specifies whether line breaks should be removed between CJK characters\n\n      Default: false\n      Used by: HTML converter\n    EOF\n\n    define(:forbidden_inline_options, Object, %w[template], <<~EOF) do |val|\n      Defines the options that may not be set using the {::options} extension\n\n      Default: template\n      Used by: HTML converter\n    EOF\n      val.map! {|item| item.kind_of?(String) ? str_to_sym(item) : item }\n      simple_array_validator(val, :forbidden_inline_options)\n    end\n\n  end\n\nend\n", "# -*- coding: utf-8; frozen_string_literal: true -*-\n#\n#--\n# Copyright (C) 2009-2019 Thomas Leitner <t_leitner@gmx.at>\n#\n# This file is part of kramdown which is licensed under the MIT.\n#++\n#\n\nmodule Kramdown\n  module Parser\n    class Kramdown\n\n      IAL_CLASS_ATTR = 'class'\n\n      # Parse the string +str+ and extract all attributes and add all found attributes to the hash\n      # +opts+.\n      def parse_attribute_list(str, opts)\n        return if str.strip.empty? || str.strip == ':'\n        attrs = str.scan(ALD_TYPE_ANY)\n        attrs.each do |key, sep, val, ref, id_and_or_class, _, _|\n          if ref\n            (opts[:refs] ||= []) << ref\n          elsif id_and_or_class\n            id_and_or_class.scan(ALD_TYPE_ID_OR_CLASS).each do |id_attr, class_attr|\n              if class_attr\n                opts[IAL_CLASS_ATTR] = \"#{opts[IAL_CLASS_ATTR]} #{class_attr}\".lstrip\n              else\n                opts['id'] = id_attr\n              end\n            end\n          else\n            val.gsub!(/\\\\(\\}|#{sep})/, \"\\\\1\")\n            opts[key] = val\n          end\n        end\n        warning(\"No or invalid attributes found in IAL/ALD content: #{str}\") if attrs.empty?\n      end\n\n      # Update the +ial+ with the information from the inline attribute list +opts+.\n      def update_ial_with_ial(ial, opts)\n        (ial[:refs] ||= []).concat(opts[:refs]) if opts.key?(:refs)\n        opts.each do |k, v|\n          if k == IAL_CLASS_ATTR\n            ial[k] = \"#{ial[k]} #{v}\".lstrip\n          elsif k.kind_of?(String)\n            ial[k] = v\n          end\n        end\n      end\n\n      # Parse the generic extension at the current point. The parameter +type+ can either be :block\n      # or :span depending whether we parse a block or span extension tag.\n      def parse_extension_start_tag(type)\n        saved_pos = @src.save_pos\n        start_line_number = @src.current_line_number\n        @src.pos += @src.matched_size\n\n        error_block = lambda do |msg|\n          warning(msg)\n          @src.revert_pos(saved_pos)\n          add_text(@src.getch) if type == :span\n          false\n        end\n\n        if @src[4] || @src.matched == '{:/}'\n          name = (@src[4] ? \"for '#{@src[4]}' \" : '')\n          return error_block.call(\"Invalid extension stop tag #{name} found on line \" \\\n                                  \"#{start_line_number} - ignoring it\")\n        end\n\n        ext = @src[1]\n        opts = {}\n        body = nil\n        parse_attribute_list(@src[2] || '', opts)\n\n        unless @src[3]\n          stop_re = (type == :block ? /#{EXT_BLOCK_STOP_STR % ext}/ : /#{EXT_STOP_STR % ext}/)\n          if (result = @src.scan_until(stop_re))\n            body = result.sub!(stop_re, '')\n            body.chomp! if type == :block\n          else\n            return error_block.call(\"No stop tag for extension '#{ext}' found on line \" \\\n                                    \"#{start_line_number} - ignoring it\")\n          end\n        end\n\n        if !handle_extension(ext, opts, body, type, start_line_number)\n          error_block.call(\"Invalid extension with name '#{ext}' specified on line \" \\\n                           \"#{start_line_number} - ignoring it\")\n        else\n          true\n        end\n      end\n\n      def handle_extension(name, opts, body, type, line_no = nil)\n        case name\n        when 'comment'\n          if body.kind_of?(String)\n            @tree.children << Element.new(:comment, body, nil, category: type, location: line_no)\n          end\n          true\n        when 'nomarkdown'\n          if body.kind_of?(String)\n            @tree.children << Element.new(:raw, body, nil, category: type,\n                                          location: line_no, type: opts['type'].to_s.split(/\\s+/))\n          end\n          true\n        when 'options'\n          opts.select do |k, v|\n            k = k.to_sym\n            if Kramdown::Options.defined?(k)\n              if @options[:forbidden_inline_options].include?(k) ||\n                  k == :forbidden_inline_options\n                warning(\"Option #{k} may not be set inline\")\n                next false\n              end\n\n              begin\n                val = Kramdown::Options.parse(k, v)\n                @options[k] = val\n                (@root.options[:options] ||= {})[k] = val\n              rescue StandardError\n              end\n              false\n            else\n              true\n            end\n          end.each do |k, _v|\n            warning(\"Unknown kramdown option '#{k}'\")\n          end\n          @tree.children << new_block_el(:eob, :extension) if type == :block\n          true\n        else\n          false\n        end\n      end\n\n      ALD_ID_CHARS = /[\\w-]/\n      ALD_ANY_CHARS = /\\\\\\}|[^\\}]/\n      ALD_ID_NAME = /\\w#{ALD_ID_CHARS}*/\n      ALD_CLASS_NAME = /[^\\s\\.#]+/\n      ALD_TYPE_KEY_VALUE_PAIR = /(#{ALD_ID_NAME})=(\"|')((?:\\\\\\}|\\\\\\2|[^\\}\\2])*?)\\2/\n      ALD_TYPE_CLASS_NAME = /\\.(#{ALD_CLASS_NAME})/\n      ALD_TYPE_ID_NAME = /#([A-Za-z][\\w:-]*)/\n      ALD_TYPE_ID_OR_CLASS = /#{ALD_TYPE_ID_NAME}|#{ALD_TYPE_CLASS_NAME}/\n      ALD_TYPE_ID_OR_CLASS_MULTI = /((?:#{ALD_TYPE_ID_NAME}|#{ALD_TYPE_CLASS_NAME})+)/\n      ALD_TYPE_REF = /(#{ALD_ID_NAME})/\n      ALD_TYPE_ANY = /(?:\\A|\\s)(?:#{ALD_TYPE_KEY_VALUE_PAIR}|#{ALD_TYPE_REF}|#{ALD_TYPE_ID_OR_CLASS_MULTI})(?=\\s|\\Z)/\n      ALD_START = /^#{OPT_SPACE}\\{:(#{ALD_ID_NAME}):(#{ALD_ANY_CHARS}+)\\}\\s*?\\n/\n\n      EXT_STOP_STR = \"\\\\{:/(%s)?\\\\}\"\n      EXT_START_STR = \"\\\\{::(\\\\w+)(?:\\\\s(#{ALD_ANY_CHARS}*?)|)(\\\\/)?\\\\}\"\n      EXT_BLOCK_START = /^#{OPT_SPACE}(?:#{EXT_START_STR}|#{EXT_STOP_STR % ALD_ID_NAME})\\s*?\\n/\n      EXT_BLOCK_STOP_STR = \"^#{OPT_SPACE}#{EXT_STOP_STR}\\s*?\\n\"\n\n      IAL_BLOCK = /\\{:(?!:|\\/)(#{ALD_ANY_CHARS}+)\\}\\s*?\\n/\n      IAL_BLOCK_START = /^#{OPT_SPACE}#{IAL_BLOCK}/\n\n      BLOCK_EXTENSIONS_START = /^#{OPT_SPACE}\\{:/\n\n      # Parse one of the block extensions (ALD, block IAL or generic extension) at the current\n      # location.\n      def parse_block_extensions\n        if @src.scan(ALD_START)\n          parse_attribute_list(@src[2], @alds[@src[1]] ||= {})\n          @tree.children << new_block_el(:eob, :ald)\n          true\n        elsif @src.check(EXT_BLOCK_START)\n          parse_extension_start_tag(:block)\n        elsif @src.scan(IAL_BLOCK_START)\n          if (last_child = @tree.children.last) && last_child.type != :blank &&\n              (last_child.type != :eob ||\n               [:link_def, :abbrev_def, :footnote_def].include?(last_child.value))\n            parse_attribute_list(@src[1], last_child.options[:ial] ||= {})\n            @tree.children << new_block_el(:eob, :ial) unless @src.check(IAL_BLOCK_START)\n          else\n            parse_attribute_list(@src[1], @block_ial ||= {})\n          end\n          true\n        else\n          false\n        end\n      end\n      define_parser(:block_extensions, BLOCK_EXTENSIONS_START)\n\n      EXT_SPAN_START = /#{EXT_START_STR}|#{EXT_STOP_STR % ALD_ID_NAME}/\n      IAL_SPAN_START = /\\{:(#{ALD_ANY_CHARS}+)\\}/\n      SPAN_EXTENSIONS_START = /\\{:/\n\n      # Parse the extension span at the current location.\n      def parse_span_extensions\n        if @src.check(EXT_SPAN_START)\n          parse_extension_start_tag(:span)\n        elsif @src.check(IAL_SPAN_START)\n          if (last_child = @tree.children.last) && last_child.type != :text\n            @src.pos += @src.matched_size\n            attr = {}\n            parse_attribute_list(@src[1], attr)\n            update_ial_with_ial(last_child.options[:ial] ||= {}, attr)\n            update_attr_with_ial(last_child.attr, attr)\n          else\n            warning(\"Found span IAL after text - ignoring it\")\n            add_text(@src.getch)\n          end\n        else\n          add_text(@src.getch)\n        end\n      end\n      define_parser(:span_extensions, SPAN_EXTENSIONS_START, '\\{:')\n\n    end\n  end\nend\n", "# No header id\n\n{::options unusedvar=\"val\" /}\n\n# without header id\n\n<div>\nsome <span>*para*</span>\n</div>\n\n{::options parse_block_html=\"true\" parse_span_html=\"true\" /}\n\n<div>\nsome <span>*para*</span>\n</div>\n\n{::options footnote_nr=\"10\" /}\n\nSome text[^ab].\n\n[^ab]: Some text.\n\n{::options template=\"/etc/passwd\" /}\n"], "filenames": ["lib/kramdown/options.rb", "lib/kramdown/parser/kramdown/extensions.rb", "test/testcases/block/12_extension/options.text"], "buggy_code_start_loc": [591, 112, 21], "buggy_code_end_loc": [591, 112, 21], "fixing_code_start_loc": [592, 113, 22], "fixing_code_end_loc": [602, 119, 24], "type": "CWE-862", "message": "The kramdown gem before 2.3.0 for Ruby processes the template option inside Kramdown documents by default, which allows unintended read access (such as template=\"/etc/passwd\") or unintended embedded Ruby code execution (such as a string that begins with template=\"string://<%= `). NOTE: kramdown is used in Jekyll, GitLab Pages, GitHub Pages, and Thredded Forum.", "other": {"cve": {"id": "CVE-2020-14001", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-17T16:15:11.230", "lastModified": "2022-04-28T18:57:42.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The kramdown gem before 2.3.0 for Ruby processes the template option inside Kramdown documents by default, which allows unintended read access (such as template=\"/etc/passwd\") or unintended embedded Ruby code execution (such as a string that begins with template=\"string://<%= `). NOTE: kramdown is used in Jekyll, GitLab Pages, GitHub Pages, and Thredded Forum."}, {"lang": "es", "value": "La gema kramdown versiones anteriores a 2.3.0 para Ruby procesa la opci\u00f3n de plantilla dentro de los documentos de Kramdown por defecto, lo que permite el acceso de lectura no deseada (tal y como template=\"/etc/passwd\") o la ejecuci\u00f3n de c\u00f3digo Ruby insertado no previsto (tal y como una cadena que comienza con template=\"string://(%= \"). NOTA: kramdown es usado en Jekyll, GitLab Pages, GitHub Pages y Thredded Forum"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kramdown_project:kramdown:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "796E1C66-E0EF-4C52-B378-FE4382555C86"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://github.com/gettalong/kramdown", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/gettalong/kramdown/commit/1b8fd33c3120bfc6e5164b449e2c2fc9c9306fde", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gettalong/kramdown/compare/REL_2_2_1...REL_2_3_0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://kramdown.gettalong.org", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://kramdown.gettalong.org/news.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/r96df7899fbb456fe2705882f710a0c8e8614b573fbffd8d12e3f54d2@%3Cnotifications.fluo.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ENMMGKHRQIZ3QKGOMBBBGB6B4LB5I7NQ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KBLTGBYU7NKOUOHDKVCU4GFZMGA6BP4L/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://rubygems.org/gems/kramdown", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200731-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4562-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4743", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gettalong/kramdown/commit/1b8fd33c3120bfc6e5164b449e2c2fc9c9306fde"}}