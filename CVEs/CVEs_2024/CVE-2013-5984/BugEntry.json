{"buggy_code": ["<?php\n/**\n * Class used to backup and restore the database or the userfiles directory\n *\n * You can use it to create backup of the site. The backup will contain na sql export of the database\n * and also a zip file with userfiles directory.\n *\n *\n * @package utils\n */\n\n\nnamespace Microweber\\Utils;\n\n\nuse ZipArchive;\nuse RecursiveIteratorIterator;\nuse RecursiveDirectoryIterator;\n\n\napi_expose('Utils\\Backup\\delete');\napi_expose('Utils\\Backup\\create');\napi_expose('Utils\\Backup\\download');\napi_expose('Utils\\Backup\\create_full');\napi_expose('Utils\\Backup\\move_uploaded_file_to_backup');\n\napi_expose('Utils\\Backup\\restore');\napi_expose('Utils\\Backup\\cronjob');\n\nclass Backup\n{\n\n    public $backups_folder = false;\n    public $backup_file = false;\n    /**\n     * The backup class is used for making or restoring a backup\n     *\n     * @category  mics\n     * @package   utils\n     */\n\n\n    private $file_q_sep = '; /* MW_QUERY_SEPERATOR */';\n    private $prefix_placeholder = '/* MW_PREFIX_PLACEHOLDER */';\n\n    public $app;\n\n\n    function __construct($app = null)\n    {\n\n\n        api_expose('Microweber\\Utils\\Backup\\delete');\n        api_expose('Microweber\\Utils\\Backup\\create');\n        api_expose('Microweber\\Utils\\Backup\\download');\n        api_expose('Microweber\\Utils\\Backup\\create_full');\n        api_expose('Microweber\\Utils\\Backup\\move_uploaded_file_to_backup');\n\n        api_expose('Microweber\\Utils\\Backup\\restore');\n        api_expose('Microweber\\Utils\\Backup\\cronjob');\n\n        if (!defined('USER_IP')) {\n            if (isset($_SERVER[\"REMOTE_ADDR\"])) {\n                define(\"USER_IP\", $_SERVER[\"REMOTE_ADDR\"]);\n            } else {\n                define(\"USER_IP\", '127.0.0.1');\n\n            }\n        }\n\n\n        // if (!is_object($this->app)) {\n\n        if (is_object($app)) {\n            $this->app = $app;\n        } else {\n            $this->app = mw('application');\n        }\n\n        // }\n\n\n    }\n\n    static function bgworker_restore($params)\n    {\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n        $url = site_url();\n        // header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        $back_log_action = \"Restoring backup\";\n        self::log_bg_action($back_log_action);\n        $api = new \\Microweber\\Utils\\Backup();\n        $api->exec_restore($params);\n\n    }\n\n    static function log_bg_action($back_log_action)\n    {\n\n        if ($back_log_action == false) {\n            mw()->log->delete(\"is_system=y&rel=backup&user_ip=\" . USER_IP);\n        } else {\n            $check = mw()->log->get(\"order_by=created_on desc&one=true&is_system=y&created_on=[mt]30 min ago&field=action&rel=backup&user_ip=\" . USER_IP);\n\n            if (is_array($check) and isset($check['id'])) {\n                mw()->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP . \"&id=\" . $check['id']);\n            } else {\n                mw()->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP);\n            }\n        }\n\n    }\n\n    function exec_restore($params = false)\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n\n        ignore_user_abort(true);\n\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n        $loc = $this->backup_file;\n        // Get the provided arg\n        if (isset($params['id'])) {\n            $id = $params['id'];\n        } else if (isset($_GET['filename'])) {\n            $id = $params['filename'];\n        } else if (isset($_GET['file'])) {\n            $id = $params['file'];\n\n        } else if ($loc != false) {\n            $id = $loc;\n\n        }\n\n        // Check if the file has needed args\n        if ($id == NULL) {\n\n            return array('error' => \"You have not provided a backup to restore.\");\n            die();\n        }\n\n        $here = $this->get_bakup_location();\n        // Generate filename and set error variables\n\n        $filename = $here . $id;\n        //\t$filename = $here . $id . '.sql';\n        $ext = get_file_extension($filename);\n        $ext_error = false;\n\n        $sql_file = false;\n\n        if (!is_file($filename)) {\n            return array('error' => \"You have not provided a existing backup to restore.\");\n            die();\n        }\n\n        $temp_dir_restore = false;\n        switch ($ext) {\n            case 'zip' :\n                $back_log_action = \"Unzipping userfiles\";\n                $this->log_action($back_log_action);\n\n                $exract_folder = md5(basename($filename));\n                $unzip = new \\Microweber\\Utils\\Unzip();\n                $target_dir = MW_CACHE_DIR . 'backup_restore' . DS . $exract_folder . DS;\n                if (!is_dir($target_dir)) {\n                    mkdir_recursive($target_dir);\n                }\n\n                $result = $unzip->extract($filename, $target_dir, $preserve_filepath = TRUE);\n\n                $temp_dir_restore = $target_dir;\n\n                $sql_restore = $target_dir . 'mw_sql_restore.sql';\n                if (is_file($sql_restore)) {\n                    $sql_file = $sql_restore;\n                }\n                //return $result;\n                break;\n\n            case 'sql' :\n                $sql_file = $filename;\n                break;\n\n            default :\n                $ext_error = true;\n                break;\n        }\n\n        if ($ext_error == true) {\n            return array('error' => \"Invalid file extension. The restore file must be .sql or .zip\");\n            die();\n        }\n\n        if ($sql_file != false) {\n            $back_log_action = \"Restoring database\";\n            $this->log_action($back_log_action);\n\n            $db = $this->app->config('db');\n            $filename = $sql_file;\n            // Settings\n            $table = '*';\n            $host = $DBhost = $db['host'];\n            $user = $DBuser = $db['user'];\n            $pass = $DBpass = $db['pass'];\n            $name = $DBName = $db['dbname'];\n\n            $sqlErrorText = '';\n            $sqlErrorCode = 0;\n            $sqlStmt = '';\n\n            // Restore the backup\n            //\t$con = mysql_connect($DBhost, $DBuser, $DBpass);\n            //if ($con !== false) {\n            // Load and explode the sql file\n            //\tmysql_select_db(\"$DBName\");\n            $f = fopen($filename, \"r+\");\n            $sqlFile = fread($f, filesize($filename));\n            $sqlArray = explode($this->file_q_sep, $sqlFile);\n\n            // Process the sql file by statements\n            foreach ($sqlArray as $stmt) {\n                $stmt = str_replace('/* MW_TABLE_SEP */', ' ', $stmt);\n                $stmt = str_ireplace($this->prefix_placeholder, MW_TABLE_PREFIX, $stmt);\n\n                if (strlen($stmt) > 3) {\n                    try {\n                        //$result = mysql_query($stmt);\n\n                        mw('db')->q($stmt);\n                        //\tprint $stmt;\n                    } catch (Exception $e) {\n                        print 'Caught exception: ' . $e->getMessage() . \"\\n\";\n                        $sqlErrorCode = 1;\n                    }\n\n                    //d($stmt);\n                    //\n                }\n            }\n            //}\n\n            // Print message (error or success)\n            if ($sqlErrorCode == 0) {\n                $back_log_action = \"Database restored successfully!\";\n                $this->log_action($back_log_action);\n\n                print(\"Database restored successfully!\\n\");\n                print(\"Backup used: \" . $filename . \"\\n\");\n            } else {\n                print(\"An error occurred while restoring backup!<br><br>\\n\");\n                print(\"Error code: $sqlErrorCode<br>\\n\");\n                print(\"Error text: $sqlErrorText<br>\\n\");\n                print(\"Statement:<br/> $sqlStmt<br>\");\n            }\n\n            // Close the connection\n            // mysql_close($con);\n\n            // Change the filename from sql to zip\n            //$filename = str_replace('.sql', '.zip', $filename);\n            $back_log_action = \"Database restored successfully!\";\n            $this->log_action($back_log_action);\n\n            // Files restored successfully\n            print(\"Files restored successfully!<br>\\n\");\n            print(\"Backup used: \" . $filename . \"<br>\\n\");\n            fclose($f);\n            if ($temp_dir_restore != false) {\n                unlink($filename);\n            }\n\n        }\n\n\n        if (defined('MW_USERFILES')) {\n            if (!is_dir(MW_USERFILES)) {\n                mkdir_recursive(MW_USERFILES);\n            }\n        }\n\n\n        if (defined('MW_MEDIA_DIR')) {\n            if (!is_dir(MW_MEDIA_DIR)) {\n                mkdir_recursive(MW_MEDIA_DIR);\n            }\n        }\n\n        if ($temp_dir_restore != false and is_dir($temp_dir_restore)) {\n\n            $srcDir = $temp_dir_restore;\n            $destDir = MW_USERFILES;\n\n\n            $this->copyr($srcDir, $destDir);\n\n        }\n\n        if (function_exists('mw_post_update')) {\n            mw_post_update();\n        }\n        $back_log_action = \"Cleaning up cache\";\n        $this->log_action($back_log_action);\n        mw('cache')->clear();\n\n        sleep(5);\n        $this->log_action(false);\n\n    }\n\n    function get_bakup_location()\n    {\n\n        if (defined('MW_CRON_EXEC')) {\n\n        } else if (!is_admin()) {\n            error(\"must be admin\");\n        }\n\n        $loc = $this->backups_folder;\n\n        if ($loc != false) {\n            return $loc;\n        }\n        $here = MW_ROOTPATH . \"backup\" . DS;\n\n        if (!is_dir($here)) {\n            mkdir_recursive($here);\n            $hta = $here . '.htaccess';\n            if (!is_file($hta)) {\n                touch($hta);\n                file_put_contents($hta, 'Deny from all');\n            }\n        }\n\n        $here = MW_ROOTPATH . \"backup\" . DS . MW_TABLE_PREFIX . DS;\n\n        $here2 = mw('option')->get('backup_location', 'admin/backup');\n        if ($here2 != false and is_string($here2) and trim($here2) != 'default' and trim($here2) != '') {\n            $here2 = normalize_path($here2, true);\n\n            if (!is_dir($here2)) {\n                mkdir_recursive($here2);\n            }\n\n            if (is_dir($here2)) {\n                $here = $here2;\n            }\n        }\n\n\n        if (!is_dir($here)) {\n            mkdir_recursive($here);\n        }\n\n\n        $loc = $here;\n\n\n        $this->backups_folder = $loc;\n        return $here;\n    }\n\n    function log_action($back_log_action)\n    {\n\n        if (defined('MW_IS_INSTALLED') and MW_IS_INSTALLED == true) {\n\n\n            if ($back_log_action == false) {\n                $this->app->log->delete(\"is_system=y&rel=backup&user_ip=\" . USER_IP);\n            } else {\n                $check = $this->app->log->get(\"order_by=created_on desc&one=true&is_system=y&created_on=[mt]30 min ago&field=action&rel=backup&user_ip=\" . USER_IP);\n\n                if (is_array($check) and isset($check['id'])) {\n                    $this->app->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP . \"&id=\" . $check['id']);\n                } else {\n                    $this->app->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP);\n                }\n            }\n        }\n    }\n\n    function copyr($source, $dest)\n    {\n        // Simple copy for a file\n        if (is_file($source)) {\n            return copy($source, $dest);\n        }\n\n        // Make destination directory\n        if (!is_dir($dest)) {\n            mkdir_recursive($dest);\n        }\n\n        // Loop through the folder\n        $dir = dir($source);\n        while (false !== $entry = $dir->read()) {\n            // Skip pointers\n            if ($entry == '.' || $entry == '..') {\n                continue;\n            }\n\n            // Deep copy directories\n            if ($dest !== \"$source/$entry\") {\n                $this->copyr(\"$source/$entry\", \"$dest/$entry\");\n            }\n        }\n\n        // Clean up\n        $dir->close();\n        return true;\n    }\n\n    static function bgworker()\n    {\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n        $url = site_url();\n        //header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        //$back_log_action = \"Creating full backup\";\n        //self::log_bg_action($back_log_action);\n\n\n        if (!defined('MW_BACKUP_BG_WORKER_STARTED')) {\n            define('MW_BACKUP_BG_WORKER_STARTED', 1);\n            $backup_api = new \\Microweber\\Utils\\Backup();\n            $backup_api->exec_create_full();\n            unset($backup_api);\n        } else {\n\n        }\n\n        //  exit();\n\n\n    }\n\n    function exec_create_full()\n    {\n\n\n        if (!defined('MW_BACKUP_STARTED')) {\n            define('MW_BACKUP_STARTED', 1);\n        } else {\n            return false;\n        }\n\n\n        $start = microtime_float();\n        if (defined('MW_CRON_EXEC')) {\n\n        } else {\n            only_admin_access();\n\n        }\n\n        @ob_end_clean();\n\n        ignore_user_abort(true);\n        $back_log_action = \"Preparing to zip\";\n        $this->log_action($back_log_action);\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n        $here = $this->get_bakup_location();\n        $filename = $here . 'full_backup_' . date(\"Y-M-d-His\") . '_' . uniqid() . '' . '.zip';\n\n        $userfiles_folder = MW_USERFILES;\n\n        $locations = array();\n        $locations[] = MW_USERFILES;\n        //$locations[] = $filename2;\n        $fileTime = date(\"D, d M Y H:i:s T\");\n\n        $db_file = $this->create();\n\n        $zip = new \\Microweber\\Utils\\Zip($filename);\n        $zip->setZipFile($filename);\n        $zip->setComment(\"Microweber backup of the userfiles folder and db.\n\t\t\t\t\\n The Microweber version at the time of backup was {MW_VERSION}\n\t\t\t\t\\nCreated on \" . date('l jS \\of F Y h:i:s A'));\n        if (isset($db_file['filename'])) {\n            $filename2 = $here . $db_file['filename'];\n            if (is_file($filename2)) {\n                $back_log_action = \"Adding sql restore to zip\";\n                $this->log_action($back_log_action);\n                $zip->addLargeFile($filename2, 'mw_sql_restore.sql', filectime($filename2), 'SQL Restore file');\n                //  $zip->addFile(file_get_contents($filename2), 'mw_sql_restore.sql', filectime($filename2));\n\n            }\n        }\n\n        $this->log_action(false);\n\n        $back_log_action = \"Adding files to zip\";\n        $this->log_action($back_log_action);\n\n\n        $zip->addDirectoryContent(MW_USERFILES, '', true);\n        $back_log_action = \"Adding userfiles to zip\";\n        $this->log_action($back_log_action);\n\n        // $zip = $zip->finalize();\n        $filename_to_return = $filename;\n        $end = microtime_float();\n        $end = round($end - $start, 3);\n\n        $back_log_action = \"Backup was created for $end sec!\";\n        $this->log_action($back_log_action);\n\n        sleep(5);\n        $back_log_action = \"reload\";\n        $this->log_action($back_log_action);\n\n        sleep(5);\n        $this->log_action(false);\n        return array('success' => \"Backup was created for $end sec! $filename_to_return\", 'filename' => $filename_to_return, 'runtime' => $end);\n\n\n    }\n\n    function create($filename = false)\n    {\n        if (is_array($filename)) {\n            $filename = false;\n        }\n\n\n        ignore_user_abort(true);\n        $start = microtime_float();\n\n        if (defined('MW_CRON_EXEC')) {\n\n        } else {\n            only_admin_access();\n\n        }\n        $temp_db = $db = $this->app->config('db');\n\n        // Settings\n        $table = '*';\n        $host = $DBhost = $db['host'];\n        $user = $DBuser = $db['user'];\n        $pass = $DBpass = $db['pass'];\n        $name = $DBName = $db['dbname'];\n\n        // Set the suffix of the backup filename\n        if ($table == '*') {\n            $extname = 'all';\n        } else {\n            $extname = str_replace(\",\", \"_\", $table);\n            $extname = str_replace(\" \", \"_\", $extname);\n        }\n\n        $here = $this->get_bakup_location();\n\n        if (!is_dir($here)) {\n            if (!mkdir_recursive($here)) {\n\n                $back_log_action = \"Error the dir is not writable: \" . $here;\n                $this->log_action($back_log_action);\n\n\n            } else {\n\n            }\n        }\n\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n        // Generate the filename for the backup file\n        $index1 = $here . 'index.php';\n        if ($filename == false) {\n            $filename_to_return = 'database_backup_' . date(\"Y-M-d-His\") . uniqid() . '_' . $extname . '.sql';\n        } else {\n            $filename_to_return = $filename;\n        }\n\n        $filess = $here . $filename_to_return;\n\n        if (is_file($filess)) {\n            return false;\n        }\n\n\n        touch($filess);\n        touch($index1);\n\n        $sql_bak_file = $filess;\n\n\n        $hta = $here . '.htaccess';\n        if (!is_file($hta)) {\n            touch($hta);\n            file_put_contents($hta, 'Deny from all');\n        }\n\n        $head = \"/* Microweber database backup exported on: \" . date('l jS \\of F Y h:i:s A') . \" */ \\n\";\n        $head .= \"/* MW_TABLE_PREFIX: \" . MW_TABLE_PREFIX . \" */ \\n\\n\\n\";\n        file_put_contents($sql_bak_file, $head);\n        $return = \"\";\n        $tables = '*';\n        // Get all of the tables\n        if ($tables == '*') {\n            $tables = array();\n            //$result = mysql_query('SHOW TABLES');\n            $qs = 'SHOW TABLES';\n            $result = mw('db')->query($qs, $cache_id = false, $cache_group = false, $only_query = false, $temp_db);\n            //while ($row = mysql_fetch_row($result)) {\n            //\t$tables[] = $row[0];\n            //}\n            if (!empty($result)) {\n                foreach ($result as $item) {\n                    $item_vals = (array_values($item));\n                    $tables[] = $item_vals[0];\n                }\n            }\n\n\n        } else {\n            if (is_array($tables)) {\n                $tables = explode(',', $tables);\n            }\n        }\n\n        $back_log_action = \"Starting database backup\";\n        $this->log_action($back_log_action);\n        // Cycle through each provided table\n        foreach ($tables as $table) {\n\n            if (stristr($table, MW_TABLE_PREFIX)) {\n\n                $back_log_action = \"Backing up database table $table\";\n                $this->log_action($back_log_action);\n\n                //$result = mysql_query('SELECT * FROM ' . $table);\n\n                $qs = 'SELECT * FROM ' . $table;\n                $result = mw('db')->query($qs, $cache_id = false, $cache_group = false, $only_query = false, $temp_db);\n\n                $num_fields = count($result[0]);\n                //$num_fields = mysql_num_fields($result);\n                $table_without_prefix = $this->prefix_placeholder . str_ireplace(MW_TABLE_PREFIX, \"\", $table);\n\n                // First part of the output - remove the table\n                //$return .= 'DROP TABLE IF EXISTS ' . $table_without_prefix . $this -> file_q_sep . \"\\n\\n\\n\";\n                $return = 'DROP TABLE IF EXISTS ' . $table_without_prefix . $this->file_q_sep . \"\\n\\n\\n\";\n                $this->append_string_to_file($sql_bak_file, $return);\n\n\n                // Second part of the output - create table\n//\t\t\t\t$res_ch = mysql_query('SHOW CREATE TABLE ' . $table);\n//\t\t\t\tif ($res_ch == false) {\n//\t\t\t\t\t$err = mysql_error();\n//\t\t\t\t\tif ($err != false) {\n//\t\t\t\t\t\treturn array('error' => 'Query failed: ' . $err);\n//\t\t\t\t\t}\n//\n//\t\t\t\t}\n//\t\t\t\t$row2 = mysql_fetch_row($res_ch);\n\n\n                $qs = 'SHOW CREATE TABLE ' . $table;\n                $res_ch = mw('db')->query($qs, $cache_id = false, $cache_group = false, $only_query = false, $temp_db);\n                $row2 = array_values($res_ch[0]);\n\n\n                $create_table_without_prefix = str_ireplace(MW_TABLE_PREFIX, $this->prefix_placeholder, $row2[1]);\n\n                //$return .= \"\\n\\n\" . $create_table_without_prefix . $this -> file_q_sep . \"\\n\\n\\n\";\n\n\n                $return = \"\\n\\n\" . $create_table_without_prefix . $this->file_q_sep . \"\\n\\n\\n\";\n                $this->append_string_to_file($sql_bak_file, $return);\n                // Third part of the output - insert values into new table\n                //for ($i = 0; $i < $num_fields; $i++) {\n\n                $this->log_action(false);\n                if (!empty($result)) {\n                    foreach ($result as $row) {\n                        $row = array_values($row);\n                        $return = 'INSERT INTO ' . $table_without_prefix . ' VALUES(';\n                        for ($j = 0; $j < $num_fields; $j++) {\n                            $row[$j] = addslashes($row[$j]);\n                            $row[$j] = str_replace(\"\\n\", \"\\\\n\", $row[$j]);\n                            if (isset($row[$j])) {\n                                $return .= '\"' . $row[$j] . '\"';\n                            } else {\n                                $return .= '\"\"';\n                            }\n                            if ($j < ($num_fields - 1)) {\n                                $return .= ',';\n                            }\n                        }\n                        $return .= \")\" . $this->file_q_sep . \"\\n\\n\\n\";\n                        $this->append_string_to_file($sql_bak_file, $return);\n                        //$this->log_action(false);\n                    }\n                    //  }\n\n//\t\t\t\t\twhile ($row = mysql_fetch_row($result)) {\n//\n//\t\t\t\t\t}\n\n\n                }\n                $return = \"\\n\\n\\n\";\n                $this->append_string_to_file($sql_bak_file, $return);\n            }\n\n        }\n        $this->log_action(false);\n        $back_log_action = \"Saving to file \" . basename($filess);\n        $this->log_action($back_log_action);\n        // Save the sql file\n//\t\t$handle = fopen($filess, 'w+');\n//\t\t$head = \"/* Microweber database backup exported on: \" . date('l jS \\of F Y h:i:s A') . \" */ \\n\";\n//\t\t$head .= \"/* MW_TABLE_PREFIX: \" . MW_TABLE_PREFIX . \" */ \\n\\n\\n\";\n//\t\t$return = $head . $return;\n//\n//\t\tfwrite($handle, $return);\n//\t\tfclose($handle);\n\n\n        //  unset($return);\n        $end = microtime_float();\n        $end = round($end - $start, 3);\n        $this->log_action(false);\n\n        //mysql_close($link);\n\n        return array('success' => \"Backup was created for $end sec! $filename_to_return\", 'filename' => $filename_to_return, 'runtime' => $end);\n        // Close MySQL Connection\n        //\n    }\n\n    function append_string_to_file($file_path, $string_to_append)\n    {\n        file_put_contents($file_path, $string_to_append, FILE_APPEND);\n\n    }\n\n    function cronjob_exec($params = false)\n    {\n\n\n        print 'backup cronjob';\n\n\n    }\n\n    function restore($params)\n    {\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n        $id = null;\n        if (isset($params['id'])) {\n            $id = $params['id'];\n        } else if (isset($_GET['filename'])) {\n            $id = $params['filename'];\n        } else if (isset($_GET['file'])) {\n            $id = $params['file'];\n\n        }\n\n        if ($id == NULL) {\n\n            return array('error' => \"You have not provided a backup to restore.\");\n            die();\n        }\n\n        $url = site_url();\n        header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        $scheduler = new \\Microweber\\Utils\\Events();\n\n        // schedule a global scope function:\n        $scheduler->registerShutdownEvent(\"\\Microweber\\Utils\\Backup::bgworker_restore\", $params);\n\n        exit();\n    }\n\n    function cronjob($params = false)\n    {\n\n        if (!defined(\"INI_SYSTEM_CHECK_DISABLED\")) {\n            define(\"INI_SYSTEM_CHECK_DISABLED\", ini_get('disable_functions'));\n        }\n        if (!defined(\"MW_NO_SESSION\")) {\n            define(\"MW_NO_SESSION\", true);\n        }\n\n        if (!defined(\"IS_ADMIN\")) {\n            define(\"IS_ADMIN\", true);\n        }\n\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'ini_set')) {\n            ini_set('memory_limit', '512M');\n            //ini_set(\"set_time_limit\", 600);\n\n        }\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'set_time_limit')) {\n            set_time_limit(600);\n        }\n\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'ignore_user_abort')) {\n            ignore_user_abort();\n        }\n\n        $type = 'full';\n\n        if (isset($params['type'])) {\n            $type = trim($params['type']);\n        }\n\n        $cache_id = 'backup_queue';\n        // $cache_id_folders = 'backup_cron_folders' . (USER_IP);\n        $cache_id_loc = 'backup_progress';\n        $cache_state_id = 'backup_zip_state';\n\n        $cache_content = $this->app->cache->get($cache_id, 'backup');\n        $cache_lock = $this->app->cache->get($cache_id_loc, 'backup');\n        $cache_state = $this->app->cache->get($cache_state_id, 'backup', 30);\n\n        //$cache_folders = $this->app->cache->get($cache_id_folders, 'backup');\n\n\n        //$fileTime = date(\"D, d M Y H:i:s T\");\n\n        $time = time();\n        $here = $this->get_bakup_location();\n\n        session_write_close();\n        if ($cache_state == 'opened') {\n\n\n            return true;\n        }\n\n\n        //   $filename2 = $here . 'test_' . date(\"Y-M-d-H\") . '_' . crc32(USER_IP) . '' . '.zip';\n\n        if ($cache_content == false or empty($cache_content)) {\n            $this->app->cache->save(false, $cache_id_loc, 'backup');\n            $this->app->cache->save(false, $cache_id, 'backup');\n\n            $cron = new \\Microweber\\Utils\\Cron();\n            $cron->delete_job('make_full_backup');\n            return true;\n        } else {\n\n\n            $bak_fn = 'backup_' . date(\"Y-M-d-His\") . '_' . uniqid() . '';\n\n            $filename = $here . $bak_fn . '.zip';\n\n            if ($cache_lock == false or !is_array($cache_lock)) {\n\n\n                $cache_lock = array();\n                $cache_lock['processed'] = 0;\n                $cache_lock['files_count'] = count($cache_content);\n                $cache_lock['time'] = $time;\n                $cache_lock['filename'] = $filename;\n                $this->app->cache->save($cache_lock, $cache_id_loc, 'backup');\n                // return false;\n            } else {\n                if (isset($cache_lock['filename'])) {\n                    $filename = $cache_lock['filename'];\n                }\n\n            }\n\n            if (isset($cache_lock['time'])) {\n                $time_sec = intval($cache_lock['time']);\n\n                if (($time - 3) < $time_sec) {\n                    // print 'time lock';\n                    return false;\n                }\n\n            }\n\n\n            $backup_actions = $cache_content;\n\n            global $mw_backup_zip_obj;\n            if (!is_object($mw_backup_zip_obj)) {\n                $mw_backup_zip_obj = new  ZipArchive();\n            }\n\n            if (is_array($backup_actions)) {\n                $i = 0;\n\n                $this->app->cache->save($filename, $cache_id_loc, 'backup');\n\n\n                if (!$mw_backup_zip_obj->open($filename, ZIPARCHIVE::CREATE)) {\n                    return false;\n                }\n                $this->app->cache->save('opened', $cache_state_id, 'backup');\n\n                $limit_per_turn = 20;\n\n                foreach ($backup_actions as $key => $item) {\n                    $flie_ext = strtolower(get_file_extension($item));\n\n                    if ($flie_ext == 'php' or $flie_ext == 'css' or $flie_ext == 'js') {\n                        $limit_per_turn = 150;\n\n                    }\n\n\n                    if ($i > $limit_per_turn or $cache_lock == $item) {\n                        $mw_backup_zip_obj->close();\n                        $this->app->cache->save('closed', $cache_state_id, 'backup');\n                    } else {\n\n                        $cache_lock['processed']++;\n                        $cache_lock['time'] = time();\n                        $cache_lock['filename'] = $filename;\n\n\n                        $precent = ($cache_lock['processed'] / $cache_lock['files_count']) * 100;\n                        $precent = round($precent);\n                        $cache_lock['percent'] = $precent;\n\n\n                        $back_log_action = \"Progress  {$precent}% ({$cache_lock['processed']}/{$cache_lock['files_count']}) <br><small>\" . basename($item) . \"</small>\";\n                        $this->log_action($back_log_action);\n\n                        $this->app->cache->save($cache_lock, $cache_id_loc, 'backup');\n\n\n                        if ($item == 'make_db_backup') {\n\n                            $limit_per_turn = 1;\n                            $mw_backup_zip_obj->close();\n                            $this->app->cache->save('closed', $cache_state_id, 'backup');\n\n\n                            $db_file = $this->create($bak_fn . '.sql');\n\n\n                            if (!$mw_backup_zip_obj->open($filename, ZIPARCHIVE::CREATE)) {\n                                return false;\n                            }\n                            $this->app->cache->save('opened', $cache_state_id, 'backup');\n\n\n                            if (isset($db_file['filename'])) {\n                                $filename2 = $here . $db_file['filename'];\n                                if (is_file($filename2)) {\n                                    $back_log_action = \"Adding sql restore to zip\";\n                                    $this->log_action($back_log_action);\n                                    $mw_backup_zip_obj->addFile($filename2, 'mw_sql_restore.sql');\n                                    //  $zip->addFile(file_get_contents($filename2), 'mw_sql_restore.sql', filectime($filename2));\n\n                                }\n                            }\n                        } else {\n                            $relative_loc = str_replace(MW_USERFILES, '', $item);\n\n\n                            $new_backup_actions = array();\n\n\n                            if (is_dir($item)) {\n                                $mw_backup_zip_obj->addEmptyDir($relative_loc);\n                            } elseif (is_file($item)) {\n                                // d($item);\n                                //$relative_loc_dn = dirname($relative_loc);\n\n                                //$mw_backup_zip_obj->addFromString($relative_loc, file_get_contents($item));\n\n                                $mw_backup_zip_obj->addFile($item, $relative_loc);\n\n                            }\n\n\n                        }\n\n\n                        unset($backup_actions[$key]);\n\n\n                        if (isset($new_backup_actions) and !empty($new_backup_actions)) {\n                            $backup_actions = array_merge($backup_actions, $new_backup_actions);\n                            array_unique($backup_actions);\n                            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n\n                        } else {\n                            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n\n                        }\n                        //  d($backup_actions[$key]);\n\n                        if (empty($backup_actions)) {\n                            $this->app->cache->save(false, $cache_id, 'backup');\n\n                        }\n\n                    }\n                    $i++;\n                }\n\n                $mw_backup_zip_obj->close();\n                $this->app->cache->save('closed', $cache_state_id, 'backup');\n            }\n        }\n\n        // $this->app->cache->save(false, $cache_id_loc, 'backup');\n        if (empty($backup_actions)) {\n            $this->app->cache->save(false, $cache_id, 'backup');\n\n        }\n\n    }\n\n    function DELcronjob($params = false)\n    {\n\n        $type = 'full';\n\n        if (isset($params['type'])) {\n            $type = trim($params['type']);\n        }\n\n        $cache_id = 'backup_cron' . (USER_IP);\n        $cache_id_loc = 'backup_cron_lock' . (USER_IP);\n        $cache_content = $this->app->cache->get($cache_id, 'backup');\n        $cache_lock = $this->app->cache->get($cache_id_loc, 'backup');\n\n        //  d($folders);\n\n        $fileTime = date(\"D, d M Y H:i:s T\");\n\n\n        $here = $this->get_bakup_location();\n\n        $filename = $here . 'backup_' . date(\"Y-M-d-H\") . '_' . crc32(USER_IP) . '' . '.zip';\n\n        if ($cache_lock == $filename) {\n            $this->app->cache->save('false', $cache_id_loc, 'backup');\n            return false;\n        }\n\n\n        //   $filename2 = $here . 'test_' . date(\"Y-M-d-H\") . '_' . crc32(USER_IP) . '' . '.zip';\n\n        if ($cache_content == false or empty($cache_content)) {\n            $backup_actions = array();\n            $backup_actions[] = 'make_db_backup';\n\n            $userfiles_folder = MW_USERFILES;\n\n\n            $folders = rglob($userfiles_folder . '*', GLOB_NOSORT);\n            if (!empty($folders)) {\n                foreach ($folders as $fold) {\n                    $backup_actions[] = $fold;\n\n                }\n            }\n\n            //$backup_actions[] = 'makesdfsdf_db_backup';\n            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n        } else {\n            $backup_actions = $cache_content;\n\n\n            //  d($backup_actions);\n\n\n            if (is_array($backup_actions)) {\n                $i = 0;\n                // if (!isset($zip)) {\n                // $zip = new  \\Microweber\\Utils\\ZipStream($filename);\n\n                $this->app->cache->save($filename, $cache_id_loc, 'backup');\n//                $zip = new \\ZipArchive;\n//\n//                if ($zip->open($filename, ZipArchive::CREATE) === false) {\n//                    return false;\n//                }\n\n                //  d($filename);\n\n//\n//                if (!is_file($filename)) {\n//\n//\n//                } else {\n//                    if ($zip->open($filename, ZipArchive) === false) {\n//                        return false;\n//                    }\n//\n//                }\n\n                //   $zip = new \\Microweber\\Utils\\Zip($filename);\n                //  if (is_file($filename)) {\n                // $stream=$zip->getZipData();\n                // $stream=$zip->openStream($filename);\n                //  $zip->setZipFile($stream);\n                //  } else {\n                // $zip->setZipFile($filename);\n                //  }\n\n\n                //  }\n\n\n                foreach ($backup_actions as $key => $item) {\n\n                    if ($i > 10 or $cache_lock == $item) {\n\n                    } else {\n\n\n                        if ($item == 'make_db_backup') {\n//                            $db_file = $this->create();\n//                            if (isset($db_file['filename'])) {\n//                                $filename2 = $here . $db_file['filename'];\n//                                if (is_file($filename2)) {\n//                                    $back_log_action = \"Adding sql restore to zip\";\n//                                    $this->log_action($back_log_action);\n//                                    $zip->addLargeFile($filename2, 'mw_sql_restore.sql', filectime($filename2), 'SQL Restore file');\n//                                    //  $zip->addFile(file_get_contents($filename2), 'mw_sql_restore.sql', filectime($filename2));\n//\n//                                }\n//                            }\n                        } else {\n                            $relative_loc = str_replace(MW_USERFILES, '', $item);\n                            //   d($relative_loc);\n                            if (is_dir($item)) {\n                                //  $zip->addEmptyDir($relative_loc);\n                                // $zip->addDir($item, $relative_loc);\n                                $relative_loc = normalize_path($relative_loc, false);\n\n\n                                zip_folder($item, $filename, $relative_loc);\n\n\n                                //$zip->addEmptyDir($relative_loc);\n                                // $zip->addDirectoryContent($item, $relative_loc, false);\n\n//                                foreach (glob($item . '/*') as $file) {\n//                                    if ($file != \".\" and $file != \"..\") {\n//                                        $newFile = str_replace(MW_USERFILES, '', $file);\n//                                        $newFile = normalize_path($newFile, false);\n//                                        $file = normalize_path($file, false);\n//\n//                                        $newFile = str_replace('\\\\', '/', $newFile);\n//\n//\n//                                        print 'DIRRRRRRRRRRR: ' . var_dump($file, $newFile);\n//                                        $zip->addFile($file, $newFile);\n//                                    }\n//\n//\n//                                }\n\n\n                                // $zip->addDirectoryContent($item, $relative_loc, false);\n                            } elseif (is_file($item)) {\n                                $relative_loc_dn = dirname($relative_loc);\n                                // $zip->addEmptyDir($relative_loc_dn);\n                                // print 'FILEEEEE: '. var_dump($relative_loc);\n                                // $zip->addFile($item, $relative_loc);\n                                zip_folder($item, $filename, $relative_loc);\n\n                                //$zip->addLargeFile($item, $relative_loc, filectime($item));\n                            }\n                            //$zip->addDirectoryContent(MW_USERFILES, '', true);\n                            //  $back_log_action = \"Adding userfiles to zip\";\n\n\n                        }\n                        d($item);\n                        unset($backup_actions[$key]);\n                        if (isset($backup_actions)) {\n                            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n                        }\n                        //d($item);\n\n                        // break;\n                    }\n                    $i++;\n                }\n\n\n            }\n        }\n        if (isset($zip) and is_object($zip)) {\n            // $zip->close();\n            // $zip->finalize();\n            // $zip->setZipFile($filename2);\n        }\n\n        $this->app->cache->save('false', $cache_id_loc, 'backup');\n        //d($params);\n\n\n        //print 'cronjobcronjobcronjobcronjobcronjobcronjobcronjobcronjob';\n    }\n\n    function create_full()\n    {\n\n        if (!defined(\"INI_SYSTEM_CHECK_DISABLED\")) {\n            define(\"INI_SYSTEM_CHECK_DISABLED\", ini_get('disable_functions'));\n        }\n\n\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'ini_set')) {\n            ini_set('memory_limit', '512M');\n            //ini_set(\"set_time_limit\", 600);\n\n        }\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'set_time_limit')) {\n            set_time_limit(600);\n        }\n\n        $cron = new \\Microweber\\Utils\\Cron();\n\n        $backup_actions = array();\n        $backup_actions[] = 'make_db_backup';\n\n        $userfiles_folder = MW_USERFILES;\n\n\n//        $it = new RecursiveDirectoryIterator($userfiles_folder);\n//\n//        foreach(new RecursiveIteratorIterator($it) as $file) {\n//            $backup_actions[] = $file;\n//           // echo $file . \"\\n\";\n//\n//        }\n\n\n        $folders = \\rglob($userfiles_folder . '*', GLOB_NOSORT);\n        if (!empty($folders)) {\n            $text_files = array();\n\n\n            foreach ($folders as $fold) {\n\n                if (strstr($fold, '.php') or strstr($fold, '.js')  or strstr($fold, '.css')) {\n                    $text_files[] = $fold;\n                } else {\n                    $backup_actions[] = $fold;\n\n                }\n\n\n            }\n\n            if (!empty($text_files)) {\n                $backup_actions = array_merge($text_files, $backup_actions);\n            }\n\n            //    rsort($backup_actions);\n\n        }\n        $cache_id = 'backup_queue';\n        $cache_id_loc = 'backup_progress';\n\n        $cache_state_id = 'backup_zip_state';\n        //$backup_actions[] = 'makesdfsdf_db_backup';\n        $this->app->cache->save($backup_actions, $cache_id, 'backup');\n        $this->app->cache->save(false, $cache_id_loc, 'backup');\n        $this->app->cache->save(false, $cache_state_id, 'backup');\n        //$cron->Register('make_full_backup', 0, '\\Microweber\\Utils\\Backup::cronjob_exec');\n        //$cron->job('make_full_backup', 0, array('\\Microweber\\Utils\\Backup','cronjob_exec'));\n\n        // $cron->job('run_something_once', 0, array('\\Microweber\\Utils\\Backup','cronjob'));\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n\n        $cron->job('make_full_backup', '25 sec', array('\\Microweber\\Utils\\Backup', 'cronjob'), array('type' => 'full'));\n        //  $cron->job('another_job', 10, 'some_function' ,array('param'=>'val') );\n        exit();\n\n\n        $this->log_action(false);\n        //  $url = site_url();\n        //header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        //@ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        $scheduler = new \\Microweber\\Utils\\Events();\n\n        // schedule a global scope function:\n        $scheduler->registerShutdownEvent(\"\\Microweber\\Utils\\Backup::bgworker\");\n\n        exit();\n    }\n\n    function move_uploaded_file_to_backup($params)\n    {\n        only_admin_access();\n\n        if (!isset($params['src'])) {\n\n            return array('error' => \"You have not provided src to the file.\");\n\n        }\n\n        $check = url2dir(trim($params['src']));\n        $here = $this->get_bakup_location();\n        if (is_file($check)) {\n            $fn = basename($check);\n            if (copy($check, $here . $fn)) {\n                @unlink($check);\n                return array('success' => \"$fn was uploaded!\");\n\n            } else {\n                return array('error' => \"Error moving uploaded file!\");\n\n            }\n\n        } else {\n            return array('error' => \"Uploaded file is not found!\");\n\n        }\n\n    }\n\n    // Read a file and display its content chunk by chunk\n\n    public function get()\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n        ;\n        $here = $this->get_bakup_location();\n\n        $files = glob(\"$here{*.sql,*.zip}\", GLOB_BRACE);\n\n        usort($files, function ($a, $b) {\n            return filemtime($a) < filemtime($b);\n        });\n\n        $backups = array();\n        if (!empty($files)) {\n            foreach ($files as $file) {\n\n                if (strpos($file, '.sql', 1) or strpos($file, '.zip', 1)) {\n                    $mtime = filemtime($file);\n                    // Get time and date from filename\n                    $date = date(\"F d Y\", $mtime);\n                    $time = date(\"H:i:s\", $mtime);\n                    // Remove the sql extension part in the filename\n                    //\t$filenameboth = str_replace('.sql', '', $file);\n                    $bak = array();\n                    $bak['filename'] = basename($file);\n                    $bak['date'] = $date;\n                    $bak['time'] = str_replace('_', ':', $time);\n                    ;\n                    $bak['size'] = filesize($file);\n\n                    $backups[] = $bak;\n                }\n\n            }\n\n        }\n\n        return $backups;\n\n    }\n\n    function delete($params)\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n\n\n        // Get the provided arg\n        $id = $params['id'];\n\n        // Check if the file has needed args\n        if ($id == NULL) {\n\n            return array('error' => \"You have not provided filename to be deleted.\");\n\n        }\n\n        $here = $this->get_bakup_location();\n        $filename = $here . $id;\n\n\n        $id = str_replace('..', '', $id);\n        $filename = str_replace('..', '', $filename);\n\n        if (is_file($filename)) {\n\n            unlink($filename);\n            return array('success' => \"$id was deleted!\");\n        } else {\n\n            $filename = $here . $id . '.sql';\n            if (is_file($filename)) {\n                unlink($filename);\n                return array('success' => \"$id was deleted!\");\n            }\n        }\n\n        //d($filename);\n    }\n\n    function download($params)\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n        ;\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n\n        if (isset($params['id'])) {\n            $id = $params['id'];\n        } else if (isset($_GET['filename'])) {\n            $id = $params['filename'];\n        } else if (isset($_GET['file'])) {\n            $id = $params['file'];\n        }\n\n        // Check if the file has needed args\n        if ($id == NULL) {\n            return array('error' => \"You have not provided filename to download.\");\n\n            die();\n        }\n\n        $here = $this->get_bakup_location();\n        // Generate filename and set error variables\n\n        $filename = $here . $id;\n        if (!is_file($filename)) {\n            return array('error' => \"You have not provided a existising filename to download.\");\n\n            die();\n        }\n        // Check if the file exist.\n        if (file_exists($filename)) {\n            // Add headers\n            $name = basename($filename);\n            $type = 'sql';\n            header('Cache-Control: public');\n            header('Content-Description: File Transfer');\n            header('Content-Disposition: attachment; filename=' . $name);\n            header('Content-Length: ' . filesize($filename));\n            // Read file\n            $this->readfile_chunked($filename);\n        } else {\n            die('File does not exist');\n        }\n    }\n\n    function readfile_chunked($filename, $retbytes = TRUE)\n    {\n        $chunk_size = 1024 * 1024;\n        $buffer = \"\";\n        $cnt = 0;\n        // $handle = fopen($filename, \"rb\");\n        $handle = fopen($filename, \"rb\");\n        if ($handle === false) {\n            return false;\n        }\n        while (!feof($handle)) {\n            $buffer = fread($handle, $chunk_size);\n            echo $buffer;\n            ob_flush();\n            flush();\n            if ($retbytes) {\n                $cnt += strlen($buffer);\n            }\n        }\n        $status = fclose($handle);\n        if ($retbytes && $status) {\n            return $cnt; // return num. bytes delivered like readfile() does.\n        }\n        return $status;\n    }\n\n}\n\n$mw_backup_zip_obj = false;"], "fixing_code": ["<?php\n/**\n * Class used to backup and restore the database or the userfiles directory\n *\n * You can use it to create backup of the site. The backup will contain na sql export of the database\n * and also a zip file with userfiles directory.\n *\n *\n * @package utils\n */\n\n\nnamespace Microweber\\Utils;\n\n\nuse ZipArchive;\nuse RecursiveIteratorIterator;\nuse RecursiveDirectoryIterator;\n\n\napi_expose('Utils\\Backup\\delete');\napi_expose('Utils\\Backup\\create');\napi_expose('Utils\\Backup\\download');\napi_expose('Utils\\Backup\\create_full');\napi_expose('Utils\\Backup\\move_uploaded_file_to_backup');\n\napi_expose('Utils\\Backup\\restore');\napi_expose('Utils\\Backup\\cronjob');\n\nclass Backup\n{\n\n    public $backups_folder = false;\n    public $backup_file = false;\n    /**\n     * The backup class is used for making or restoring a backup\n     *\n     * @category  mics\n     * @package   utils\n     */\n\n\n    private $file_q_sep = '; /* MW_QUERY_SEPERATOR */';\n    private $prefix_placeholder = '/* MW_PREFIX_PLACEHOLDER */';\n\n    public $app;\n\n\n    function __construct($app = null)\n    {\n\n\n        api_expose('Microweber\\Utils\\Backup\\delete');\n        api_expose('Microweber\\Utils\\Backup\\create');\n        api_expose('Microweber\\Utils\\Backup\\download');\n        api_expose('Microweber\\Utils\\Backup\\create_full');\n        api_expose('Microweber\\Utils\\Backup\\move_uploaded_file_to_backup');\n\n        api_expose('Microweber\\Utils\\Backup\\restore');\n        api_expose('Microweber\\Utils\\Backup\\cronjob');\n\n        if (!defined('USER_IP')) {\n            if (isset($_SERVER[\"REMOTE_ADDR\"])) {\n                define(\"USER_IP\", $_SERVER[\"REMOTE_ADDR\"]);\n            } else {\n                define(\"USER_IP\", '127.0.0.1');\n\n            }\n        }\n\n\n        // if (!is_object($this->app)) {\n\n        if (is_object($app)) {\n            $this->app = $app;\n        } else {\n            $this->app = mw('application');\n        }\n\n        // }\n\n\n    }\n\n    static function bgworker_restore($params)\n    {\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n        $url = site_url();\n        // header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        $back_log_action = \"Restoring backup\";\n        self::log_bg_action($back_log_action);\n        $api = new \\Microweber\\Utils\\Backup();\n        $api->exec_restore($params);\n\n    }\n\n    static function log_bg_action($back_log_action)\n    {\n\n        if ($back_log_action == false) {\n            mw()->log->delete(\"is_system=y&rel=backup&user_ip=\" . USER_IP);\n        } else {\n            $check = mw()->log->get(\"order_by=created_on desc&one=true&is_system=y&created_on=[mt]30 min ago&field=action&rel=backup&user_ip=\" . USER_IP);\n\n            if (is_array($check) and isset($check['id'])) {\n                mw()->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP . \"&id=\" . $check['id']);\n            } else {\n                mw()->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP);\n            }\n        }\n\n    }\n\n    function exec_restore($params = false)\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n\n        ignore_user_abort(true);\n\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n        $loc = $this->backup_file;\n        // Get the provided arg\n        if (isset($params['id'])) {\n            $id = $params['id'];\n        } else if (isset($_GET['filename'])) {\n            $id = $params['filename'];\n        } else if (isset($_GET['file'])) {\n            $id = $params['file'];\n\n        } else if ($loc != false) {\n            $id = $loc;\n\n        }\n\n        // Check if the file has needed args\n        if ($id == NULL) {\n\n            return array('error' => \"You have not provided a backup to restore.\");\n            die();\n        }\n\n        $here = $this->get_bakup_location();\n        // Generate filename and set error variables\n\n        $filename = $here . $id;\n        //\t$filename = $here . $id . '.sql';\n        $ext = get_file_extension($filename);\n        $ext_error = false;\n\n        $sql_file = false;\n\n        if (!is_file($filename)) {\n            return array('error' => \"You have not provided a existing backup to restore.\");\n            die();\n        }\n\n        $temp_dir_restore = false;\n        switch ($ext) {\n            case 'zip' :\n                $back_log_action = \"Unzipping userfiles\";\n                $this->log_action($back_log_action);\n\n                $exract_folder = md5(basename($filename));\n                $unzip = new \\Microweber\\Utils\\Unzip();\n                $target_dir = MW_CACHE_DIR . 'backup_restore' . DS . $exract_folder . DS;\n                if (!is_dir($target_dir)) {\n                    mkdir_recursive($target_dir);\n                }\n\n                $result = $unzip->extract($filename, $target_dir, $preserve_filepath = TRUE);\n\n                $temp_dir_restore = $target_dir;\n\n                $sql_restore = $target_dir . 'mw_sql_restore.sql';\n                if (is_file($sql_restore)) {\n                    $sql_file = $sql_restore;\n                }\n                //return $result;\n                break;\n\n            case 'sql' :\n                $sql_file = $filename;\n                break;\n\n            default :\n                $ext_error = true;\n                break;\n        }\n\n        if ($ext_error == true) {\n            return array('error' => \"Invalid file extension. The restore file must be .sql or .zip\");\n            die();\n        }\n\n        if ($sql_file != false) {\n            $back_log_action = \"Restoring database\";\n            $this->log_action($back_log_action);\n\n            $db = $this->app->config('db');\n            $filename = $sql_file;\n            // Settings\n            $table = '*';\n            $host = $DBhost = $db['host'];\n            $user = $DBuser = $db['user'];\n            $pass = $DBpass = $db['pass'];\n            $name = $DBName = $db['dbname'];\n\n            $sqlErrorText = '';\n            $sqlErrorCode = 0;\n            $sqlStmt = '';\n\n            // Restore the backup\n            //\t$con = mysql_connect($DBhost, $DBuser, $DBpass);\n            //if ($con !== false) {\n            // Load and explode the sql file\n            //\tmysql_select_db(\"$DBName\");\n            $f = fopen($filename, \"r+\");\n            $sqlFile = fread($f, filesize($filename));\n            $sqlArray = explode($this->file_q_sep, $sqlFile);\n\n            // Process the sql file by statements\n            foreach ($sqlArray as $stmt) {\n                $stmt = str_replace('/* MW_TABLE_SEP */', ' ', $stmt);\n                $stmt = str_ireplace($this->prefix_placeholder, MW_TABLE_PREFIX, $stmt);\n\n                if (strlen($stmt) > 3) {\n                    try {\n                        //$result = mysql_query($stmt);\n\n                        mw('db')->q($stmt);\n                        //\tprint $stmt;\n                    } catch (Exception $e) {\n                        print 'Caught exception: ' . $e->getMessage() . \"\\n\";\n                        $sqlErrorCode = 1;\n                    }\n\n                    //d($stmt);\n                    //\n                }\n            }\n            //}\n\n            // Print message (error or success)\n            if ($sqlErrorCode == 0) {\n                $back_log_action = \"Database restored successfully!\";\n                $this->log_action($back_log_action);\n\n                print(\"Database restored successfully!\\n\");\n                print(\"Backup used: \" . $filename . \"\\n\");\n            } else {\n                print(\"An error occurred while restoring backup!<br><br>\\n\");\n                print(\"Error code: $sqlErrorCode<br>\\n\");\n                print(\"Error text: $sqlErrorText<br>\\n\");\n                print(\"Statement:<br/> $sqlStmt<br>\");\n            }\n\n            // Close the connection\n            // mysql_close($con);\n\n            // Change the filename from sql to zip\n            //$filename = str_replace('.sql', '.zip', $filename);\n            $back_log_action = \"Database restored successfully!\";\n            $this->log_action($back_log_action);\n\n            // Files restored successfully\n            print(\"Files restored successfully!<br>\\n\");\n            print(\"Backup used: \" . $filename . \"<br>\\n\");\n            fclose($f);\n            if ($temp_dir_restore != false) {\n                unlink($filename);\n            }\n\n        }\n\n\n        if (defined('MW_USERFILES')) {\n            if (!is_dir(MW_USERFILES)) {\n                mkdir_recursive(MW_USERFILES);\n            }\n        }\n\n\n        if (defined('MW_MEDIA_DIR')) {\n            if (!is_dir(MW_MEDIA_DIR)) {\n                mkdir_recursive(MW_MEDIA_DIR);\n            }\n        }\n\n        if ($temp_dir_restore != false and is_dir($temp_dir_restore)) {\n\n            $srcDir = $temp_dir_restore;\n            $destDir = MW_USERFILES;\n\n\n            $this->copyr($srcDir, $destDir);\n\n        }\n\n        if (function_exists('mw_post_update')) {\n            mw_post_update();\n        }\n        $back_log_action = \"Cleaning up cache\";\n        $this->log_action($back_log_action);\n        mw('cache')->clear();\n\n        sleep(5);\n        $this->log_action(false);\n\n    }\n\n    function get_bakup_location()\n    {\n\n        if (defined('MW_CRON_EXEC')) {\n\n        } else if (!is_admin()) {\n            error(\"must be admin\");\n        }\n\n        $loc = $this->backups_folder;\n\n        if ($loc != false) {\n            return $loc;\n        }\n        $here = MW_ROOTPATH . \"backup\" . DS;\n\n        if (!is_dir($here)) {\n            mkdir_recursive($here);\n            $hta = $here . '.htaccess';\n            if (!is_file($hta)) {\n                touch($hta);\n                file_put_contents($hta, 'Deny from all');\n            }\n        }\n\n        $here = MW_ROOTPATH . \"backup\" . DS . MW_TABLE_PREFIX . DS;\n\n        $here2 = mw('option')->get('backup_location', 'admin/backup');\n        if ($here2 != false and is_string($here2) and trim($here2) != 'default' and trim($here2) != '') {\n            $here2 = normalize_path($here2, true);\n\n            if (!is_dir($here2)) {\n                mkdir_recursive($here2);\n            }\n\n            if (is_dir($here2)) {\n                $here = $here2;\n            }\n        }\n\n\n        if (!is_dir($here)) {\n            mkdir_recursive($here);\n        }\n\n\n        $loc = $here;\n\n\n        $this->backups_folder = $loc;\n        return $here;\n    }\n\n    function log_action($back_log_action)\n    {\n\n        if (defined('MW_IS_INSTALLED') and MW_IS_INSTALLED == true) {\n\n\n            if ($back_log_action == false) {\n                $this->app->log->delete(\"is_system=y&rel=backup&user_ip=\" . USER_IP);\n            } else {\n                $check = $this->app->log->get(\"order_by=created_on desc&one=true&is_system=y&created_on=[mt]30 min ago&field=action&rel=backup&user_ip=\" . USER_IP);\n\n                if (is_array($check) and isset($check['id'])) {\n                    $this->app->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP . \"&id=\" . $check['id']);\n                } else {\n                    $this->app->log->save(\"is_system=y&field=action&rel=backup&value=\" . $back_log_action . \"&user_ip=\" . USER_IP);\n                }\n            }\n        }\n    }\n\n    function copyr($source, $dest)\n    {\n        // Simple copy for a file\n        if (is_file($source)) {\n            return copy($source, $dest);\n        }\n\n        // Make destination directory\n        if (!is_dir($dest)) {\n            mkdir_recursive($dest);\n        }\n\n        // Loop through the folder\n        $dir = dir($source);\n        while (false !== $entry = $dir->read()) {\n            // Skip pointers\n            if ($entry == '.' || $entry == '..') {\n                continue;\n            }\n\n            // Deep copy directories\n            if ($dest !== \"$source/$entry\") {\n                $this->copyr(\"$source/$entry\", \"$dest/$entry\");\n            }\n        }\n\n        // Clean up\n        $dir->close();\n        return true;\n    }\n\n    static function bgworker()\n    {\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n        $url = site_url();\n        //header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        //$back_log_action = \"Creating full backup\";\n        //self::log_bg_action($back_log_action);\n\n\n        if (!defined('MW_BACKUP_BG_WORKER_STARTED')) {\n            define('MW_BACKUP_BG_WORKER_STARTED', 1);\n            $backup_api = new \\Microweber\\Utils\\Backup();\n            $backup_api->exec_create_full();\n            unset($backup_api);\n        } else {\n\n        }\n\n        //  exit();\n\n\n    }\n\n    function exec_create_full()\n    {\n\n\n        if (!defined('MW_BACKUP_STARTED')) {\n            define('MW_BACKUP_STARTED', 1);\n        } else {\n            return false;\n        }\n\n\n        $start = microtime_float();\n        if (defined('MW_CRON_EXEC')) {\n\n        } else {\n            only_admin_access();\n\n        }\n\n        @ob_end_clean();\n\n        ignore_user_abort(true);\n        $back_log_action = \"Preparing to zip\";\n        $this->log_action($back_log_action);\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n        $here = $this->get_bakup_location();\n        $filename = $here . 'full_backup_' . date(\"Y-M-d-His\") . '_' . uniqid() . '' . '.zip';\n\n        $userfiles_folder = MW_USERFILES;\n\n        $locations = array();\n        $locations[] = MW_USERFILES;\n        //$locations[] = $filename2;\n        $fileTime = date(\"D, d M Y H:i:s T\");\n\n        $db_file = $this->create();\n\n        $zip = new \\Microweber\\Utils\\Zip($filename);\n        $zip->setZipFile($filename);\n        $zip->setComment(\"Microweber backup of the userfiles folder and db.\n\t\t\t\t\\n The Microweber version at the time of backup was {MW_VERSION}\n\t\t\t\t\\nCreated on \" . date('l jS \\of F Y h:i:s A'));\n        if (isset($db_file['filename'])) {\n            $filename2 = $here . $db_file['filename'];\n            if (is_file($filename2)) {\n                $back_log_action = \"Adding sql restore to zip\";\n                $this->log_action($back_log_action);\n                $zip->addLargeFile($filename2, 'mw_sql_restore.sql', filectime($filename2), 'SQL Restore file');\n                //  $zip->addFile(file_get_contents($filename2), 'mw_sql_restore.sql', filectime($filename2));\n\n            }\n        }\n\n        $this->log_action(false);\n\n        $back_log_action = \"Adding files to zip\";\n        $this->log_action($back_log_action);\n\n\n        $zip->addDirectoryContent(MW_USERFILES, '', true);\n        $back_log_action = \"Adding userfiles to zip\";\n        $this->log_action($back_log_action);\n\n        // $zip = $zip->finalize();\n        $filename_to_return = $filename;\n        $end = microtime_float();\n        $end = round($end - $start, 3);\n\n        $back_log_action = \"Backup was created for $end sec!\";\n        $this->log_action($back_log_action);\n\n        sleep(5);\n        $back_log_action = \"reload\";\n        $this->log_action($back_log_action);\n\n        sleep(5);\n        $this->log_action(false);\n        return array('success' => \"Backup was created for $end sec! $filename_to_return\", 'filename' => $filename_to_return, 'runtime' => $end);\n\n\n    }\n\n    function create($filename = false)\n    {\n        if (is_array($filename)) {\n            $filename = false;\n        }\n\n\n        ignore_user_abort(true);\n        $start = microtime_float();\n\n        if (defined('MW_CRON_EXEC')) {\n\n        } else {\n            only_admin_access();\n\n        }\n        $temp_db = $db = $this->app->config('db');\n\n        // Settings\n        $table = '*';\n        $host = $DBhost = $db['host'];\n        $user = $DBuser = $db['user'];\n        $pass = $DBpass = $db['pass'];\n        $name = $DBName = $db['dbname'];\n\n        // Set the suffix of the backup filename\n        if ($table == '*') {\n            $extname = 'all';\n        } else {\n            $extname = str_replace(\",\", \"_\", $table);\n            $extname = str_replace(\" \", \"_\", $extname);\n        }\n\n        $here = $this->get_bakup_location();\n\n        if (!is_dir($here)) {\n            if (!mkdir_recursive($here)) {\n\n                $back_log_action = \"Error the dir is not writable: \" . $here;\n                $this->log_action($back_log_action);\n\n\n            } else {\n\n            }\n        }\n\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n        // Generate the filename for the backup file\n        $index1 = $here . 'index.php';\n        if ($filename == false) {\n            $filename_to_return = 'database_backup_' . date(\"Y-M-d-His\") . uniqid() . '_' . $extname . '.sql';\n        } else {\n            $filename_to_return = $filename;\n        }\n\n        $filess = $here . $filename_to_return;\n\n        if (is_file($filess)) {\n            return false;\n        }\n\n\n        touch($filess);\n        touch($index1);\n\n        $sql_bak_file = $filess;\n\n\n        $hta = $here . '.htaccess';\n        if (!is_file($hta)) {\n            touch($hta);\n            file_put_contents($hta, 'Deny from all');\n        }\n\n        $head = \"/* Microweber database backup exported on: \" . date('l jS \\of F Y h:i:s A') . \" */ \\n\";\n        $head .= \"/* MW_TABLE_PREFIX: \" . MW_TABLE_PREFIX . \" */ \\n\\n\\n\";\n        file_put_contents($sql_bak_file, $head);\n        $return = \"\";\n        $tables = '*';\n        // Get all of the tables\n        if ($tables == '*') {\n            $tables = array();\n            //$result = mysql_query('SHOW TABLES');\n            $qs = 'SHOW TABLES';\n            $result = mw('db')->query($qs, $cache_id = false, $cache_group = false, $only_query = false, $temp_db);\n            //while ($row = mysql_fetch_row($result)) {\n            //\t$tables[] = $row[0];\n            //}\n            if (!empty($result)) {\n                foreach ($result as $item) {\n                    $item_vals = (array_values($item));\n                    $tables[] = $item_vals[0];\n                }\n            }\n\n\n        } else {\n            if (is_array($tables)) {\n                $tables = explode(',', $tables);\n            }\n        }\n\n        $back_log_action = \"Starting database backup\";\n        $this->log_action($back_log_action);\n        // Cycle through each provided table\n        foreach ($tables as $table) {\n\n            if (stristr($table, MW_TABLE_PREFIX)) {\n\n                $back_log_action = \"Backing up database table $table\";\n                $this->log_action($back_log_action);\n\n                //$result = mysql_query('SELECT * FROM ' . $table);\n\n                $qs = 'SELECT * FROM ' . $table;\n                $result = mw('db')->query($qs, $cache_id = false, $cache_group = false, $only_query = false, $temp_db);\n\n                $num_fields = count($result[0]);\n                //$num_fields = mysql_num_fields($result);\n                $table_without_prefix = $this->prefix_placeholder . str_ireplace(MW_TABLE_PREFIX, \"\", $table);\n\n                // First part of the output - remove the table\n                //$return .= 'DROP TABLE IF EXISTS ' . $table_without_prefix . $this -> file_q_sep . \"\\n\\n\\n\";\n                $return = 'DROP TABLE IF EXISTS ' . $table_without_prefix . $this->file_q_sep . \"\\n\\n\\n\";\n                $this->append_string_to_file($sql_bak_file, $return);\n\n\n                // Second part of the output - create table\n//\t\t\t\t$res_ch = mysql_query('SHOW CREATE TABLE ' . $table);\n//\t\t\t\tif ($res_ch == false) {\n//\t\t\t\t\t$err = mysql_error();\n//\t\t\t\t\tif ($err != false) {\n//\t\t\t\t\t\treturn array('error' => 'Query failed: ' . $err);\n//\t\t\t\t\t}\n//\n//\t\t\t\t}\n//\t\t\t\t$row2 = mysql_fetch_row($res_ch);\n\n\n                $qs = 'SHOW CREATE TABLE ' . $table;\n                $res_ch = mw('db')->query($qs, $cache_id = false, $cache_group = false, $only_query = false, $temp_db);\n                $row2 = array_values($res_ch[0]);\n\n\n                $create_table_without_prefix = str_ireplace(MW_TABLE_PREFIX, $this->prefix_placeholder, $row2[1]);\n\n                //$return .= \"\\n\\n\" . $create_table_without_prefix . $this -> file_q_sep . \"\\n\\n\\n\";\n\n\n                $return = \"\\n\\n\" . $create_table_without_prefix . $this->file_q_sep . \"\\n\\n\\n\";\n                $this->append_string_to_file($sql_bak_file, $return);\n                // Third part of the output - insert values into new table\n                //for ($i = 0; $i < $num_fields; $i++) {\n\n                $this->log_action(false);\n                if (!empty($result)) {\n                    foreach ($result as $row) {\n                        $row = array_values($row);\n                        $return = 'INSERT INTO ' . $table_without_prefix . ' VALUES(';\n                        for ($j = 0; $j < $num_fields; $j++) {\n                            $row[$j] = addslashes($row[$j]);\n                            $row[$j] = str_replace(\"\\n\", \"\\\\n\", $row[$j]);\n                            if (isset($row[$j])) {\n                                $return .= '\"' . $row[$j] . '\"';\n                            } else {\n                                $return .= '\"\"';\n                            }\n                            if ($j < ($num_fields - 1)) {\n                                $return .= ',';\n                            }\n                        }\n                        $return .= \")\" . $this->file_q_sep . \"\\n\\n\\n\";\n                        $this->append_string_to_file($sql_bak_file, $return);\n                        //$this->log_action(false);\n                    }\n                    //  }\n\n//\t\t\t\t\twhile ($row = mysql_fetch_row($result)) {\n//\n//\t\t\t\t\t}\n\n\n                }\n                $return = \"\\n\\n\\n\";\n                $this->append_string_to_file($sql_bak_file, $return);\n            }\n\n        }\n        $this->log_action(false);\n        $back_log_action = \"Saving to file \" . basename($filess);\n        $this->log_action($back_log_action);\n        // Save the sql file\n//\t\t$handle = fopen($filess, 'w+');\n//\t\t$head = \"/* Microweber database backup exported on: \" . date('l jS \\of F Y h:i:s A') . \" */ \\n\";\n//\t\t$head .= \"/* MW_TABLE_PREFIX: \" . MW_TABLE_PREFIX . \" */ \\n\\n\\n\";\n//\t\t$return = $head . $return;\n//\n//\t\tfwrite($handle, $return);\n//\t\tfclose($handle);\n\n\n        //  unset($return);\n        $end = microtime_float();\n        $end = round($end - $start, 3);\n        $this->log_action(false);\n\n        //mysql_close($link);\n\n        return array('success' => \"Backup was created for $end sec! $filename_to_return\", 'filename' => $filename_to_return, 'runtime' => $end);\n        // Close MySQL Connection\n        //\n    }\n\n    function append_string_to_file($file_path, $string_to_append)\n    {\n        file_put_contents($file_path, $string_to_append, FILE_APPEND);\n\n    }\n\n    function cronjob_exec($params = false)\n    {\n\n\n        print 'backup cronjob';\n\n\n    }\n\n    function restore($params)\n    {\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n        $id = null;\n        if (isset($params['id'])) {\n            $id = $params['id'];\n        } else if (isset($_GET['filename'])) {\n            $id = $params['filename'];\n        } else if (isset($_GET['file'])) {\n            $id = $params['file'];\n\n        }\n\n        if ($id == NULL) {\n\n            return array('error' => \"You have not provided a backup to restore.\");\n            die();\n        }\n\n        $url = site_url();\n        header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        $scheduler = new \\Microweber\\Utils\\Events();\n\n        // schedule a global scope function:\n        $scheduler->registerShutdownEvent(\"\\Microweber\\Utils\\Backup::bgworker_restore\", $params);\n\n        exit();\n    }\n\n    function cronjob($params = false)\n    {\n\n        if (!defined(\"INI_SYSTEM_CHECK_DISABLED\")) {\n            define(\"INI_SYSTEM_CHECK_DISABLED\", ini_get('disable_functions'));\n        }\n        if (!defined(\"MW_NO_SESSION\")) {\n            define(\"MW_NO_SESSION\", true);\n        }\n\n        if (!defined(\"IS_ADMIN\")) {\n            define(\"IS_ADMIN\", true);\n        }\n\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'ini_set')) {\n            ini_set('memory_limit', '512M');\n            //ini_set(\"set_time_limit\", 600);\n\n        }\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'set_time_limit')) {\n            set_time_limit(600);\n        }\n\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'ignore_user_abort')) {\n            ignore_user_abort();\n        }\n\n        $type = 'full';\n\n        if (isset($params['type'])) {\n            $type = trim($params['type']);\n        }\n\n        $cache_id = 'backup_queue';\n        // $cache_id_folders = 'backup_cron_folders' . (USER_IP);\n        $cache_id_loc = 'backup_progress';\n        $cache_state_id = 'backup_zip_state';\n\n        $cache_content = $this->app->cache->get($cache_id, 'backup');\n        $cache_lock = $this->app->cache->get($cache_id_loc, 'backup');\n        $cache_state = $this->app->cache->get($cache_state_id, 'backup', 30);\n\n        //$cache_folders = $this->app->cache->get($cache_id_folders, 'backup');\n\n\n        //$fileTime = date(\"D, d M Y H:i:s T\");\n\n        $time = time();\n        $here = $this->get_bakup_location();\n\n        session_write_close();\n        if ($cache_state == 'opened') {\n\n\n            return true;\n        }\n\n\n        //   $filename2 = $here . 'test_' . date(\"Y-M-d-H\") . '_' . crc32(USER_IP) . '' . '.zip';\n\n        if ($cache_content == false or empty($cache_content)) {\n            $this->app->cache->save(false, $cache_id_loc, 'backup');\n            $this->app->cache->save(false, $cache_id, 'backup');\n\n            $cron = new \\Microweber\\Utils\\Cron();\n            $cron->delete_job('make_full_backup');\n            return true;\n        } else {\n\n\n            $bak_fn = 'backup_' . date(\"Y-M-d-His\") . '_' . uniqid() . '';\n\n            $filename = $here . $bak_fn . '.zip';\n\n            if ($cache_lock == false or !is_array($cache_lock)) {\n\n\n                $cache_lock = array();\n                $cache_lock['processed'] = 0;\n                $cache_lock['files_count'] = count($cache_content);\n                $cache_lock['time'] = $time;\n                $cache_lock['filename'] = $filename;\n                $this->app->cache->save($cache_lock, $cache_id_loc, 'backup');\n                // return false;\n            } else {\n                if (isset($cache_lock['filename'])) {\n                    $filename = $cache_lock['filename'];\n                }\n\n            }\n\n            if (isset($cache_lock['time'])) {\n                $time_sec = intval($cache_lock['time']);\n\n                if (($time - 3) < $time_sec) {\n                    // print 'time lock';\n                    return false;\n                }\n\n            }\n\n\n            $backup_actions = $cache_content;\n\n            global $mw_backup_zip_obj;\n            if (!is_object($mw_backup_zip_obj)) {\n                $mw_backup_zip_obj = new  ZipArchive();\n            }\n\n            if (is_array($backup_actions)) {\n                $i = 0;\n\n                $this->app->cache->save($filename, $cache_id_loc, 'backup');\n\n\n                if (!$mw_backup_zip_obj->open($filename, ZIPARCHIVE::CREATE)) {\n                    return false;\n                }\n                $this->app->cache->save('opened', $cache_state_id, 'backup');\n\n                $limit_per_turn = 20;\n\n                foreach ($backup_actions as $key => $item) {\n                    $flie_ext = strtolower(get_file_extension($item));\n\n                    if ($flie_ext == 'php' or $flie_ext == 'css' or $flie_ext == 'js') {\n                        $limit_per_turn = 150;\n\n                    }\n\n\n                    if ($i > $limit_per_turn or $cache_lock == $item) {\n                        $mw_backup_zip_obj->close();\n                        $this->app->cache->save('closed', $cache_state_id, 'backup');\n                    } else {\n\n                        $cache_lock['processed']++;\n                        $cache_lock['time'] = time();\n                        $cache_lock['filename'] = $filename;\n\n\n                        $precent = ($cache_lock['processed'] / $cache_lock['files_count']) * 100;\n                        $precent = round($precent);\n                        $cache_lock['percent'] = $precent;\n\n\n                        $back_log_action = \"Progress  {$precent}% ({$cache_lock['processed']}/{$cache_lock['files_count']}) <br><small>\" . basename($item) . \"</small>\";\n                        $this->log_action($back_log_action);\n\n                        $this->app->cache->save($cache_lock, $cache_id_loc, 'backup');\n\n\n                        if ($item == 'make_db_backup') {\n\n                            $limit_per_turn = 1;\n                            $mw_backup_zip_obj->close();\n                            $this->app->cache->save('closed', $cache_state_id, 'backup');\n\n\n                            $db_file = $this->create($bak_fn . '.sql');\n\n\n                            if (!$mw_backup_zip_obj->open($filename, ZIPARCHIVE::CREATE)) {\n                                return false;\n                            }\n                            $this->app->cache->save('opened', $cache_state_id, 'backup');\n\n\n                            if (isset($db_file['filename'])) {\n                                $filename2 = $here . $db_file['filename'];\n                                if (is_file($filename2)) {\n                                    $back_log_action = \"Adding sql restore to zip\";\n                                    $this->log_action($back_log_action);\n                                    $mw_backup_zip_obj->addFile($filename2, 'mw_sql_restore.sql');\n                                    //  $zip->addFile(file_get_contents($filename2), 'mw_sql_restore.sql', filectime($filename2));\n\n                                }\n                            }\n                        } else {\n                            $relative_loc = str_replace(MW_USERFILES, '', $item);\n\n\n                            $new_backup_actions = array();\n\n\n                            if (is_dir($item)) {\n                                $mw_backup_zip_obj->addEmptyDir($relative_loc);\n                            } elseif (is_file($item)) {\n                                // d($item);\n                                //$relative_loc_dn = dirname($relative_loc);\n\n                                //$mw_backup_zip_obj->addFromString($relative_loc, file_get_contents($item));\n\n                                $mw_backup_zip_obj->addFile($item, $relative_loc);\n\n                            }\n\n\n                        }\n\n\n                        unset($backup_actions[$key]);\n\n\n                        if (isset($new_backup_actions) and !empty($new_backup_actions)) {\n                            $backup_actions = array_merge($backup_actions, $new_backup_actions);\n                            array_unique($backup_actions);\n                            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n\n                        } else {\n                            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n\n                        }\n                        //  d($backup_actions[$key]);\n\n                        if (empty($backup_actions)) {\n                            $this->app->cache->save(false, $cache_id, 'backup');\n\n                        }\n\n                    }\n                    $i++;\n                }\n\n                $mw_backup_zip_obj->close();\n                $this->app->cache->save('closed', $cache_state_id, 'backup');\n            }\n        }\n\n        // $this->app->cache->save(false, $cache_id_loc, 'backup');\n        if (empty($backup_actions)) {\n            $this->app->cache->save(false, $cache_id, 'backup');\n\n        }\n\n    }\n\n    function DELcronjob($params = false)\n    {\n\n        $type = 'full';\n\n        if (isset($params['type'])) {\n            $type = trim($params['type']);\n        }\n\n        $cache_id = 'backup_cron' . (USER_IP);\n        $cache_id_loc = 'backup_cron_lock' . (USER_IP);\n        $cache_content = $this->app->cache->get($cache_id, 'backup');\n        $cache_lock = $this->app->cache->get($cache_id_loc, 'backup');\n\n        //  d($folders);\n\n        $fileTime = date(\"D, d M Y H:i:s T\");\n\n\n        $here = $this->get_bakup_location();\n\n        $filename = $here . 'backup_' . date(\"Y-M-d-H\") . '_' . crc32(USER_IP) . '' . '.zip';\n\n        if ($cache_lock == $filename) {\n            $this->app->cache->save('false', $cache_id_loc, 'backup');\n            return false;\n        }\n\n\n        //   $filename2 = $here . 'test_' . date(\"Y-M-d-H\") . '_' . crc32(USER_IP) . '' . '.zip';\n\n        if ($cache_content == false or empty($cache_content)) {\n            $backup_actions = array();\n            $backup_actions[] = 'make_db_backup';\n\n            $userfiles_folder = MW_USERFILES;\n\n\n            $folders = rglob($userfiles_folder . '*', GLOB_NOSORT);\n            if (!empty($folders)) {\n                foreach ($folders as $fold) {\n                    $backup_actions[] = $fold;\n\n                }\n            }\n\n            //$backup_actions[] = 'makesdfsdf_db_backup';\n            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n        } else {\n            $backup_actions = $cache_content;\n\n\n            //  d($backup_actions);\n\n\n            if (is_array($backup_actions)) {\n                $i = 0;\n                // if (!isset($zip)) {\n                // $zip = new  \\Microweber\\Utils\\ZipStream($filename);\n\n                $this->app->cache->save($filename, $cache_id_loc, 'backup');\n//                $zip = new \\ZipArchive;\n//\n//                if ($zip->open($filename, ZipArchive::CREATE) === false) {\n//                    return false;\n//                }\n\n                //  d($filename);\n\n//\n//                if (!is_file($filename)) {\n//\n//\n//                } else {\n//                    if ($zip->open($filename, ZipArchive) === false) {\n//                        return false;\n//                    }\n//\n//                }\n\n                //   $zip = new \\Microweber\\Utils\\Zip($filename);\n                //  if (is_file($filename)) {\n                // $stream=$zip->getZipData();\n                // $stream=$zip->openStream($filename);\n                //  $zip->setZipFile($stream);\n                //  } else {\n                // $zip->setZipFile($filename);\n                //  }\n\n\n                //  }\n\n\n                foreach ($backup_actions as $key => $item) {\n\n                    if ($i > 10 or $cache_lock == $item) {\n\n                    } else {\n\n\n                        if ($item == 'make_db_backup') {\n//                            $db_file = $this->create();\n//                            if (isset($db_file['filename'])) {\n//                                $filename2 = $here . $db_file['filename'];\n//                                if (is_file($filename2)) {\n//                                    $back_log_action = \"Adding sql restore to zip\";\n//                                    $this->log_action($back_log_action);\n//                                    $zip->addLargeFile($filename2, 'mw_sql_restore.sql', filectime($filename2), 'SQL Restore file');\n//                                    //  $zip->addFile(file_get_contents($filename2), 'mw_sql_restore.sql', filectime($filename2));\n//\n//                                }\n//                            }\n                        } else {\n                            $relative_loc = str_replace(MW_USERFILES, '', $item);\n                            //   d($relative_loc);\n                            if (is_dir($item)) {\n                                //  $zip->addEmptyDir($relative_loc);\n                                // $zip->addDir($item, $relative_loc);\n                                $relative_loc = normalize_path($relative_loc, false);\n\n\n                                zip_folder($item, $filename, $relative_loc);\n\n\n                                //$zip->addEmptyDir($relative_loc);\n                                // $zip->addDirectoryContent($item, $relative_loc, false);\n\n//                                foreach (glob($item . '/*') as $file) {\n//                                    if ($file != \".\" and $file != \"..\") {\n//                                        $newFile = str_replace(MW_USERFILES, '', $file);\n//                                        $newFile = normalize_path($newFile, false);\n//                                        $file = normalize_path($file, false);\n//\n//                                        $newFile = str_replace('\\\\', '/', $newFile);\n//\n//\n//                                        print 'DIRRRRRRRRRRR: ' . var_dump($file, $newFile);\n//                                        $zip->addFile($file, $newFile);\n//                                    }\n//\n//\n//                                }\n\n\n                                // $zip->addDirectoryContent($item, $relative_loc, false);\n                            } elseif (is_file($item)) {\n                                $relative_loc_dn = dirname($relative_loc);\n                                // $zip->addEmptyDir($relative_loc_dn);\n                                // print 'FILEEEEE: '. var_dump($relative_loc);\n                                // $zip->addFile($item, $relative_loc);\n                                zip_folder($item, $filename, $relative_loc);\n\n                                //$zip->addLargeFile($item, $relative_loc, filectime($item));\n                            }\n                            //$zip->addDirectoryContent(MW_USERFILES, '', true);\n                            //  $back_log_action = \"Adding userfiles to zip\";\n\n\n                        }\n                        d($item);\n                        unset($backup_actions[$key]);\n                        if (isset($backup_actions)) {\n                            $this->app->cache->save($backup_actions, $cache_id, 'backup');\n                        }\n                        //d($item);\n\n                        // break;\n                    }\n                    $i++;\n                }\n\n\n            }\n        }\n        if (isset($zip) and is_object($zip)) {\n            // $zip->close();\n            // $zip->finalize();\n            // $zip->setZipFile($filename2);\n        }\n\n        $this->app->cache->save('false', $cache_id_loc, 'backup');\n        //d($params);\n\n\n        //print 'cronjobcronjobcronjobcronjobcronjobcronjobcronjobcronjob';\n    }\n\n    function create_full()\n    {\n\n        if (!defined(\"INI_SYSTEM_CHECK_DISABLED\")) {\n            define(\"INI_SYSTEM_CHECK_DISABLED\", ini_get('disable_functions'));\n        }\n\n\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'ini_set')) {\n            ini_set('memory_limit', '512M');\n            //ini_set(\"set_time_limit\", 600);\n\n        }\n        if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'set_time_limit')) {\n            set_time_limit(600);\n        }\n\n        $cron = new \\Microweber\\Utils\\Cron();\n\n        $backup_actions = array();\n        $backup_actions[] = 'make_db_backup';\n\n        $userfiles_folder = MW_USERFILES;\n\n\n//        $it = new RecursiveDirectoryIterator($userfiles_folder);\n//\n//        foreach(new RecursiveIteratorIterator($it) as $file) {\n//            $backup_actions[] = $file;\n//           // echo $file . \"\\n\";\n//\n//        }\n\n\n        $folders = \\rglob($userfiles_folder . '*', GLOB_NOSORT);\n        if (!empty($folders)) {\n            $text_files = array();\n\n\n            foreach ($folders as $fold) {\n\n                if (strstr($fold, '.php') or strstr($fold, '.js')  or strstr($fold, '.css')) {\n                    $text_files[] = $fold;\n                } else {\n                    $backup_actions[] = $fold;\n\n                }\n\n\n            }\n\n            if (!empty($text_files)) {\n                $backup_actions = array_merge($text_files, $backup_actions);\n            }\n\n            //    rsort($backup_actions);\n\n        }\n        $cache_id = 'backup_queue';\n        $cache_id_loc = 'backup_progress';\n\n        $cache_state_id = 'backup_zip_state';\n        //$backup_actions[] = 'makesdfsdf_db_backup';\n        $this->app->cache->save($backup_actions, $cache_id, 'backup');\n        $this->app->cache->save(false, $cache_id_loc, 'backup');\n        $this->app->cache->save(false, $cache_state_id, 'backup');\n        //$cron->Register('make_full_backup', 0, '\\Microweber\\Utils\\Backup::cronjob_exec');\n        //$cron->job('make_full_backup', 0, array('\\Microweber\\Utils\\Backup','cronjob_exec'));\n\n        // $cron->job('run_something_once', 0, array('\\Microweber\\Utils\\Backup','cronjob'));\n        if (!defined('MW_NO_SESSION')) {\n            define('MW_NO_SESSION', 1);\n        }\n\n        $cron->job('make_full_backup', '25 sec', array('\\Microweber\\Utils\\Backup', 'cronjob'), array('type' => 'full'));\n        //  $cron->job('another_job', 10, 'some_function' ,array('param'=>'val') );\n        exit();\n\n\n        $this->log_action(false);\n        //  $url = site_url();\n        //header(\"Location: \" . $url);\n        // redirect the url to the 'busy importing' page\n        ob_end_clean();\n        //Erase the output buffer\n        header(\"Connection: close\");\n        //Tell the browser that the connection's closed\n        ignore_user_abort(true);\n        //Ignore the user's abort (which we caused with the redirect).\n        set_time_limit(0);\n        //Extend time limit\n        ob_start();\n        //Start output buffering again\n        header(\"Content-Length: 0\");\n        //Tell the browser we're serious... there's really nothing else to receive from this page.\n        //@ob_end_flush();\n        //Send the output buffer and turn output buffering off.\n        flush();\n        //Yes... flush again.\n        session_write_close();\n\n        $scheduler = new \\Microweber\\Utils\\Events();\n\n        // schedule a global scope function:\n        $scheduler->registerShutdownEvent(\"\\Microweber\\Utils\\Backup::bgworker\");\n\n        exit();\n    }\n\n    function move_uploaded_file_to_backup($params)\n    {\n        only_admin_access();\n\n        if (!isset($params['src'])) {\n\n            return array('error' => \"You have not provided src to the file.\");\n\n        }\n\n        $check = url2dir(trim($params['src']));\n        $here = $this->get_bakup_location();\n        if (is_file($check)) {\n            $fn = basename($check);\n            if (copy($check, $here . $fn)) {\n                @unlink($check);\n                return array('success' => \"$fn was uploaded!\");\n\n            } else {\n                return array('error' => \"Error moving uploaded file!\");\n\n            }\n\n        } else {\n            return array('error' => \"Uploaded file is not found!\");\n\n        }\n\n    }\n\n    // Read a file and display its content chunk by chunk\n\n    public function get()\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n        ;\n        $here = $this->get_bakup_location();\n\n        $files = glob(\"$here{*.sql,*.zip}\", GLOB_BRACE);\n\n        usort($files, function ($a, $b) {\n            return filemtime($a) < filemtime($b);\n        });\n\n        $backups = array();\n        if (!empty($files)) {\n            foreach ($files as $file) {\n\n                if (strpos($file, '.sql', 1) or strpos($file, '.zip', 1)) {\n                    $mtime = filemtime($file);\n                    // Get time and date from filename\n                    $date = date(\"F d Y\", $mtime);\n                    $time = date(\"H:i:s\", $mtime);\n                    // Remove the sql extension part in the filename\n                    //\t$filenameboth = str_replace('.sql', '', $file);\n                    $bak = array();\n                    $bak['filename'] = basename($file);\n                    $bak['date'] = $date;\n                    $bak['time'] = str_replace('_', ':', $time);\n                    ;\n                    $bak['size'] = filesize($file);\n\n                    $backups[] = $bak;\n                }\n\n            }\n\n        }\n\n        return $backups;\n\n    }\n\n    function delete($params)\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n\n\n        // Get the provided arg\n        $id = $params['id'];\n\n        // Check if the file has needed args\n        if ($id == NULL) {\n\n            return array('error' => \"You have not provided filename to be deleted.\");\n\n        }\n\n        $here = $this->get_bakup_location();\n        $filename = $here . $id;\n\n\n        $id = str_replace('..', '', $id);\n        $filename = str_replace('..', '', $filename);\n\n        if (is_file($filename)) {\n\n            unlink($filename);\n            return array('success' => \"$id was deleted!\");\n        } else {\n\n            $filename = $here . $id . '.sql';\n            if (is_file($filename)) {\n                unlink($filename);\n                return array('success' => \"$id was deleted!\");\n            }\n        }\n\n        //d($filename);\n    }\n\n    function download($params)\n    {\n        if (!is_admin()) {\n            error(\"must be admin\");\n        }\n\n        ini_set('memory_limit', '512M');\n        set_time_limit(0);\n\n        if (isset($params['id'])) {\n            $id = $params['id'];\n        } else if (isset($_GET['filename'])) {\n            $id = $params['filename'];\n        } else if (isset($_GET['file'])) {\n            $id = $params['file'];\n        }\n        $id = str_replace('..', '', $id);\n\n\n        // Check if the file has needed args\n        if ($id == NULL) {\n            return array('error' => \"You have not provided filename to download.\");\n\n            die();\n        }\n\n        $here = $this->get_bakup_location();\n        // Generate filename and set error variables\n\n        $filename = $here . $id;\n        $filename = str_replace('..','',$filename);\n        if (!is_file($filename)) {\n            return array('error' => \"You have not provided a existising filename to download.\");\n\n            die();\n        }\n        // Check if the file exist.\n        if (file_exists($filename)) {\n            // Add headers\n            $name = basename($filename);\n            $type = 'sql';\n            header('Cache-Control: public');\n            header('Content-Description: File Transfer');\n            header('Content-Disposition: attachment; filename=' . $name);\n            header('Content-Length: ' . filesize($filename));\n            // Read file\n            $this->readfile_chunked($filename);\n        } else {\n            die('File does not exist');\n        }\n    }\n\n    function readfile_chunked($filename, $retbytes = TRUE)\n    {\n\n\n        $filename = str_replace('..','',$filename);\n\n        $chunk_size = 1024 * 1024;\n        $buffer = \"\";\n        $cnt = 0;\n        // $handle = fopen($filename, \"rb\");\n        $handle = fopen($filename, \"rb\");\n        if ($handle === false) {\n            return false;\n        }\n\n\n\n\n        while (!feof($handle)) {\n            $buffer = fread($handle, $chunk_size);\n            echo $buffer;\n            ob_flush();\n            flush();\n            if ($retbytes) {\n                $cnt += strlen($buffer);\n            }\n        }\n        $status = fclose($handle);\n        if ($retbytes && $status) {\n            return $cnt; // return num. bytes delivered like readfile() does.\n        }\n        return $status;\n    }\n\n}\n\n$mw_backup_zip_obj = false;"], "filenames": ["src/Microweber/Utils/Backup.php"], "buggy_code_start_loc": [1499], "buggy_code_end_loc": [1552], "fixing_code_start_loc": [1499], "fixing_code_end_loc": [1564], "type": "CWE-22", "message": "Directory traversal vulnerability in userfiles/modules/admin/backup/delete.php in Microweber before 0.830 allows remote attackers to delete arbitrary files via a .. (dot dot) in the file parameter.", "other": {"cve": {"id": "CVE-2013-5984", "sourceIdentifier": "cve@mitre.org", "published": "2014-05-12T14:55:06.070", "lastModified": "2014-05-13T13:21:30.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Directory traversal vulnerability in userfiles/modules/admin/backup/delete.php in Microweber before 0.830 allows remote attackers to delete arbitrary files via a .. (dot dot) in the file parameter."}, {"lang": "es", "value": "Vulnerabilidad de salto de directorio en userfiles/modules/admin/backup/delete.php en Microweber anterior a 0.830 permite a atacantes remotos eliminar archivos arbitrarios a trav\u00e9s de un .. (punto punto) en el par\u00e1metro file."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microweber:microweber:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8", "matchCriteriaId": "A8B43BBD-AF3E-425A-B547-5F3A94FEEC6E"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/123652/Microweber-0.8-Arbitrary-File-Deletion.html", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/microweber/microweber/commit/9177d134960c24cb642d5cf3b42a1fba286219cc", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://www.htbridge.com/advisory/HTB23175", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/microweber/microweber/commit/9177d134960c24cb642d5cf3b42a1fba286219cc"}}