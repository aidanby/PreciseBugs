{"buggy_code": ["/*\n * ----------------------------------------------------------------------------\n * nmakehlp.c --\n *\n *\tThis is used to fix limitations within nmake and the environment.\n *\n * Copyright (c) 2002 by David Gravereaux.\n * Copyright (c) 2006 by Pat Thoyts\n *\n * See the file \"license.terms\" for information on usage and redistribution of\n * this file, and for a DISCLAIMER OF ALL WARRANTIES.\n * ----------------------------------------------------------------------------\n */\n\n#define _CRT_SECURE_NO_DEPRECATE\n#include <windows.h>\n#pragma comment (lib, \"user32.lib\")\n#pragma comment (lib, \"kernel32.lib\")\n#include <stdio.h>\n#include <math.h>\n\n/*\n * This library is required for x64 builds with _some_ versions of MSVC\n */\n#if defined(_M_IA64) || defined(_M_AMD64)\n#if _MSC_VER >= 1400 && _MSC_VER < 1500\n#pragma comment(lib, \"bufferoverflowU\")\n#endif\n#endif\n\n/* ISO hack for dumb VC++ */\n#ifdef _MSC_VER\n#define   snprintf\t_snprintf\n#endif\n\n\n/* protos */\n\nstatic int CheckForCompilerFeature(const char *option);\nstatic int CheckForLinkerFeature(const char **options, int count);\nstatic int IsIn(const char *string, const char *substring);\nstatic int SubstituteFile(const char *substs, const char *filename);\nstatic int QualifyPath(const char *path);\nstatic int LocateDependency(const char *keyfile);\nstatic const char *GetVersionFromFile(const char *filename, const char *match, int numdots);\nstatic DWORD WINAPI ReadFromPipe(LPVOID args);\n\n/* globals */\n\n#define CHUNK\t25\n#define STATICBUFFERSIZE    1000\ntypedef struct {\n    HANDLE pipe;\n    char buffer[STATICBUFFERSIZE];\n} pipeinfo;\n\npipeinfo Out = {INVALID_HANDLE_VALUE, '\\0'};\npipeinfo Err = {INVALID_HANDLE_VALUE, '\\0'};\n\f\n/*\n * exitcodes: 0 == no, 1 == yes, 2 == error\n */\n\nint\nmain(\n    int argc,\n    char *argv[])\n{\n    char msg[300];\n    DWORD dwWritten;\n    int chars;\n    const char *s;\n\n    /*\n     * Make sure children (cl.exe and link.exe) are kept quiet.\n     */\n\n    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);\n\n    /*\n     * Make sure the compiler and linker aren't effected by the outside world.\n     */\n\n    SetEnvironmentVariable(\"CL\", \"\");\n    SetEnvironmentVariable(\"LINK\", \"\");\n\n    if (argc > 1 && *argv[1] == '-') {\n\tswitch (*(argv[1]+1)) {\n\tcase 'c':\n\t    if (argc != 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t        \"usage: %s -c <compiler option>\\n\"\n\t\t\t\"Tests for whether cl.exe supports an option\\n\"\n\t\t\t\"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return CheckForCompilerFeature(argv[2]);\n\tcase 'l':\n\t    if (argc < 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t       \t\t\"usage: %s -l <linker option> ?<mandatory option> ...?\\n\"\n\t\t\t\"Tests for whether link.exe supports an option\\n\"\n\t\t\t\"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return CheckForLinkerFeature(&argv[2], argc-2);\n\tcase 'f':\n\t    if (argc == 2) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t\t\"usage: %s -f <string> <substring>\\n\"\n\t\t\t\"Find a substring within another\\n\"\n\t\t\t\"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    } else if (argc == 3) {\n\t\t/*\n\t\t * If the string is blank, there is no match.\n\t\t */\n\n\t\treturn 0;\n\t    } else {\n\t\treturn IsIn(argv[2], argv[3]);\n\t    }\n\tcase 's':\n\t    if (argc == 2) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t\t\"usage: %s -s <substitutions file> <file>\\n\"\n\t\t\t\"Perform a set of string map type substutitions on a file\\n\"\n\t\t\t\"exitcodes: 0\\n\",\n\t\t\targv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return SubstituteFile(argv[2], argv[3]);\n\tcase 'V':\n\t    if (argc != 4) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t    \"usage: %s -V filename matchstring\\n\"\n\t\t    \"Extract a version from a file:\\n\"\n\t\t    \"eg: pkgIndex.tcl \\\"package ifneeded http\\\"\",\n\t\t    argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t    &dwWritten, NULL);\n\t\treturn 0;\n\t    }\n\t    s = GetVersionFromFile(argv[2], argv[3], *(argv[1]+2) - '0');\n\t    if (s && *s) {\n\t\tprintf(\"%s\\n\", s);\n\t\treturn 0;\n\t    } else\n\t\treturn 1; /* Version not found. Return non-0 exit code */\n\n\tcase 'Q':\n\t    if (argc != 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t    \"usage: %s -Q path\\n\"\n\t\t    \"Emit the fully qualified path\\n\"\n\t\t    \"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t    &dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return QualifyPath(argv[2]);\n\n\tcase 'L':\n\t    if (argc != 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t    \"usage: %s -L keypath\\n\"\n\t\t    \"Emit the fully qualified path of directory containing keypath\\n\"\n\t\t    \"exitcodes: 0 == success, 1 == not found, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t    &dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return LocateDependency(argv[2]);\n\t}\n    }\n    chars = snprintf(msg, sizeof(msg) - 1,\n\t    \"usage: %s -c|-f|-l|-Q|-s|-V ...\\n\"\n\t    \"This is a little helper app to equalize shell differences between WinNT and\\n\"\n\t    \"Win9x and get nmake.exe to accomplish its job.\\n\",\n\t    argv[0]);\n    WriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars, &dwWritten, NULL);\n    return 2;\n}\n\f\nstatic int\nCheckForCompilerFeature(\n    const char *option)\n{\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    SECURITY_ATTRIBUTES sa;\n    DWORD threadID;\n    char msg[300];\n    BOOL ok;\n    HANDLE hProcess, h, pipeThreads[2];\n    char cmdline[100];\n\n    hProcess = GetCurrentProcess();\n\n    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n    ZeroMemory(&si, sizeof(STARTUPINFO));\n    si.cb = sizeof(STARTUPINFO);\n    si.dwFlags   = STARTF_USESTDHANDLES;\n    si.hStdInput = INVALID_HANDLE_VALUE;\n\n    ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.lpSecurityDescriptor = NULL;\n    sa.bInheritHandle = FALSE;\n\n    /*\n     * Create a non-inheritible pipe.\n     */\n\n    CreatePipe(&Out.pipe, &h, &sa, 0);\n\n    /*\n     * Dupe the write side, make it inheritible, and close the original.\n     */\n\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdOutput, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Same as above, but for the error side.\n     */\n\n    CreatePipe(&Err.pipe, &h, &sa, 0);\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdError, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Base command line.\n     */\n\n    lstrcpy(cmdline, \"cl.exe -nologo -c -TC -Zs -X -Fp.\\\\_junk.pch \");\n\n    /*\n     * Append our option for testing\n     */\n\n    lstrcat(cmdline, option);\n\n    /*\n     * Filename to compile, which exists, but is nothing and empty.\n     */\n\n    lstrcat(cmdline, \" .\\\\nul\");\n\n    ok = CreateProcess(\n\t    NULL,\t    /* Module name. */\n\t    cmdline,\t    /* Command line. */\n\t    NULL,\t    /* Process handle not inheritable. */\n\t    NULL,\t    /* Thread handle not inheritable. */\n\t    TRUE,\t    /* yes, inherit handles. */\n\t    DETACHED_PROCESS, /* No console for you. */\n\t    NULL,\t    /* Use parent's environment block. */\n\t    NULL,\t    /* Use parent's starting directory. */\n\t    &si,\t    /* Pointer to STARTUPINFO structure. */\n\t    &pi);\t    /* Pointer to PROCESS_INFORMATION structure. */\n\n    if (!ok) {\n\tDWORD err = GetLastError();\n\tint chars = snprintf(msg, sizeof(msg) - 1,\n\t\t\"Tried to launch: \\\"%s\\\", but got error [%u]: \", cmdline, err);\n\n\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\tFORMAT_MESSAGE_MAX_WIDTH_MASK, 0L, err, 0, (LPVOID)&msg[chars],\n\t\t(300-chars), 0);\n\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, lstrlen(msg), &err,NULL);\n\treturn 2;\n    }\n\n    /*\n     * Close our references to the write handles that have now been inherited.\n     */\n\n    CloseHandle(si.hStdOutput);\n    CloseHandle(si.hStdError);\n\n    WaitForInputIdle(pi.hProcess, 5000);\n    CloseHandle(pi.hThread);\n\n    /*\n     * Start the pipe reader threads.\n     */\n\n    pipeThreads[0] = CreateThread(NULL, 0, ReadFromPipe, &Out, 0, &threadID);\n    pipeThreads[1] = CreateThread(NULL, 0, ReadFromPipe, &Err, 0, &threadID);\n\n    /*\n     * Block waiting for the process to end.\n     */\n\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hProcess);\n\n    /*\n     * Wait for our pipe to get done reading, should it be a little slow.\n     */\n\n    WaitForMultipleObjects(2, pipeThreads, TRUE, 500);\n    CloseHandle(pipeThreads[0]);\n    CloseHandle(pipeThreads[1]);\n\n    /*\n     * Look for the commandline warning code in both streams.\n     *  - in MSVC 6 & 7 we get D4002, in MSVC 8 we get D9002.\n     */\n\n    return !(strstr(Out.buffer, \"D4002\") != NULL\n             || strstr(Err.buffer, \"D4002\") != NULL\n             || strstr(Out.buffer, \"D9002\") != NULL\n             || strstr(Err.buffer, \"D9002\") != NULL\n             || strstr(Out.buffer, \"D2021\") != NULL\n             || strstr(Err.buffer, \"D2021\") != NULL);\n}\n\f\nstatic int\nCheckForLinkerFeature(\n    const char **options,\n    int count)\n{\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    SECURITY_ATTRIBUTES sa;\n    DWORD threadID;\n    char msg[300];\n    BOOL ok;\n    HANDLE hProcess, h, pipeThreads[2];\n    int i;\n    char cmdline[255];\n\n    hProcess = GetCurrentProcess();\n\n    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n    ZeroMemory(&si, sizeof(STARTUPINFO));\n    si.cb = sizeof(STARTUPINFO);\n    si.dwFlags   = STARTF_USESTDHANDLES;\n    si.hStdInput = INVALID_HANDLE_VALUE;\n\n    ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.lpSecurityDescriptor = NULL;\n    sa.bInheritHandle = TRUE;\n\n    /*\n     * Create a non-inheritible pipe.\n     */\n\n    CreatePipe(&Out.pipe, &h, &sa, 0);\n\n    /*\n     * Dupe the write side, make it inheritible, and close the original.\n     */\n\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdOutput, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Same as above, but for the error side.\n     */\n\n    CreatePipe(&Err.pipe, &h, &sa, 0);\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdError, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Base command line.\n     */\n\n    lstrcpy(cmdline, \"link.exe -nologo \");\n\n    /*\n     * Append our option for testing.\n     */\n\n    for (i = 0; i < count; i++) {\n\tlstrcat(cmdline, \" \\\"\");\n\tlstrcat(cmdline, options[i]);\n\tlstrcat(cmdline, \"\\\"\");\n    }\n\n    ok = CreateProcess(\n\t    NULL,\t    /* Module name. */\n\t    cmdline,\t    /* Command line. */\n\t    NULL,\t    /* Process handle not inheritable. */\n\t    NULL,\t    /* Thread handle not inheritable. */\n\t    TRUE,\t    /* yes, inherit handles. */\n\t    DETACHED_PROCESS, /* No console for you. */\n\t    NULL,\t    /* Use parent's environment block. */\n\t    NULL,\t    /* Use parent's starting directory. */\n\t    &si,\t    /* Pointer to STARTUPINFO structure. */\n\t    &pi);\t    /* Pointer to PROCESS_INFORMATION structure. */\n\n    if (!ok) {\n\tDWORD err = GetLastError();\n\tint chars = snprintf(msg, sizeof(msg) - 1,\n\t\t\"Tried to launch: \\\"%s\\\", but got error [%u]: \", cmdline, err);\n\n\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\tFORMAT_MESSAGE_MAX_WIDTH_MASK, 0L, err, 0, (LPVOID)&msg[chars],\n\t\t(300-chars), 0);\n\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, lstrlen(msg), &err,NULL);\n\treturn 2;\n    }\n\n    /*\n     * Close our references to the write handles that have now been inherited.\n     */\n\n    CloseHandle(si.hStdOutput);\n    CloseHandle(si.hStdError);\n\n    WaitForInputIdle(pi.hProcess, 5000);\n    CloseHandle(pi.hThread);\n\n    /*\n     * Start the pipe reader threads.\n     */\n\n    pipeThreads[0] = CreateThread(NULL, 0, ReadFromPipe, &Out, 0, &threadID);\n    pipeThreads[1] = CreateThread(NULL, 0, ReadFromPipe, &Err, 0, &threadID);\n\n    /*\n     * Block waiting for the process to end.\n     */\n\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hProcess);\n\n    /*\n     * Wait for our pipe to get done reading, should it be a little slow.\n     */\n\n    WaitForMultipleObjects(2, pipeThreads, TRUE, 500);\n    CloseHandle(pipeThreads[0]);\n    CloseHandle(pipeThreads[1]);\n\n    /*\n     * Look for the commandline warning code in the stderr stream.\n     */\n\n    return !(strstr(Out.buffer, \"LNK1117\") != NULL ||\n\t    strstr(Err.buffer, \"LNK1117\") != NULL ||\n\t    strstr(Out.buffer, \"LNK4044\") != NULL ||\n\t    strstr(Err.buffer, \"LNK4044\") != NULL ||\n\t    strstr(Out.buffer, \"LNK4224\") != NULL ||\n\t    strstr(Err.buffer, \"LNK4224\") != NULL);\n}\n\f\nstatic DWORD WINAPI\nReadFromPipe(\n    LPVOID args)\n{\n    pipeinfo *pi = (pipeinfo *) args;\n    char *lastBuf = pi->buffer;\n    DWORD dwRead;\n    BOOL ok;\n\n  again:\n    if (lastBuf - pi->buffer + CHUNK > STATICBUFFERSIZE) {\n\tCloseHandle(pi->pipe);\n\treturn (DWORD)-1;\n    }\n    ok = ReadFile(pi->pipe, lastBuf, CHUNK, &dwRead, 0L);\n    if (!ok || dwRead == 0) {\n\tCloseHandle(pi->pipe);\n\treturn 0;\n    }\n    lastBuf += dwRead;\n    goto again;\n\n    return 0;  /* makes the compiler happy */\n}\n\f\nstatic int\nIsIn(\n    const char *string,\n    const char *substring)\n{\n    return (strstr(string, substring) != NULL);\n}\n\f\n/*\n * GetVersionFromFile --\n * \tLooks for a match string in a file and then returns the version\n * \tfollowing the match where a version is anything acceptable to\n * \tpackage provide or package ifneeded.\n */\n\nstatic const char *\nGetVersionFromFile(\n    const char *filename,\n    const char *match,\n    int numdots)\n{\n    size_t cbBuffer = 100;\n    static char szBuffer[100];\n    char *szResult = NULL;\n    FILE *fp = fopen(filename, \"rt\");\n\n    if (fp != NULL) {\n\t/*\n\t * Read data until we see our match string.\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    LPSTR p, q;\n\n\t    p = strstr(szBuffer, match);\n\t    if (p != NULL) {\n\t\t/*\n\t\t * Skip to first digit after the match.\n\t\t */\n\n\t\tp += strlen(match);\n\t\twhile (*p && !isdigit(*p)) {\n\t\t    ++p;\n\t\t}\n\n\t\t/*\n\t\t * Find ending whitespace.\n\t\t */\n\n\t\tq = p;\n\t\twhile (*q && (strchr(\"0123456789.ab\", *q)) && ((!strchr(\".ab\", *q)\n\t\t\t    && (!strchr(\"ab\", q[-1])) || --numdots))) {\n\t\t    ++q;\n\t\t}\n\n\t\tmemcpy(szBuffer, p, q - p);\n\t\tszBuffer[q-p] = 0;\n\t\tszResult = szBuffer;\n\t\tbreak;\n\t    }\n\t}\n\tfclose(fp);\n    }\n    return szResult;\n}\n\f\n/*\n * List helpers for the SubstituteFile function\n */\n\ntypedef struct list_item_t {\n    struct list_item_t *nextPtr;\n    char * key;\n    char * value;\n} list_item_t;\n\n/* insert a list item into the list (list may be null) */\nstatic list_item_t *\nlist_insert(list_item_t **listPtrPtr, const char *key, const char *value)\n{\n    list_item_t *itemPtr = malloc(sizeof(list_item_t));\n    if (itemPtr) {\n\titemPtr->key = strdup(key);\n\titemPtr->value = strdup(value);\n\titemPtr->nextPtr = NULL;\n\n\twhile(*listPtrPtr) {\n\t    listPtrPtr = &(*listPtrPtr)->nextPtr;\n\t}\n\t*listPtrPtr = itemPtr;\n    }\n    return itemPtr;\n}\n\nstatic void\nlist_free(list_item_t **listPtrPtr)\n{\n    list_item_t *tmpPtr, *listPtr = *listPtrPtr;\n    while (listPtr) {\n\ttmpPtr = listPtr;\n\tlistPtr = listPtr->nextPtr;\n\tfree(tmpPtr->key);\n\tfree(tmpPtr->value);\n\tfree(tmpPtr);\n    }\n}\n\f\n/*\n * SubstituteFile --\n *\tAs windows doesn't provide anything useful like sed and it's unreliable\n *\tto use the tclsh you are building against (consider x-platform builds -\n *\teg compiling AMD64 target from IX86) we provide a simple substitution\n *\toption here to handle autoconf style substitutions.\n *\tThe substitution file is whitespace and line delimited. The file should\n *\tconsist of lines matching the regular expression:\n *\t  \\s*\\S+\\s+\\S*$\n *\n *\tUsage is something like:\n *\t  nmakehlp -S << $** > $@\n *        @PACKAGE_NAME@ $(PACKAGE_NAME)\n *        @PACKAGE_VERSION@ $(PACKAGE_VERSION)\n *        <<\n */\n\nstatic int\nSubstituteFile(\n    const char *substitutions,\n    const char *filename)\n{\n    size_t cbBuffer = 1024;\n    static char szBuffer[1024], szCopy[1024];\n    char *szResult = NULL;\n    list_item_t *substPtr = NULL;\n    FILE *fp, *sp;\n\n    fp = fopen(filename, \"rt\");\n    if (fp != NULL) {\n\n\t/*\n\t * Build a list of substutitions from the first filename\n\t */\n\n\tsp = fopen(substitutions, \"rt\");\n\tif (sp != NULL) {\n\t    while (fgets(szBuffer, cbBuffer, sp) != NULL) {\n\t\tunsigned char *ks, *ke, *vs, *ve;\n\t\tks = (unsigned char*)szBuffer;\n\t\twhile (ks && *ks && isspace(*ks)) ++ks;\n\t\tke = ks;\n\t\twhile (ke && *ke && !isspace(*ke)) ++ke;\n\t\tvs = ke;\n\t\twhile (vs && *vs && isspace(*vs)) ++vs;\n\t\tve = vs;\n\t\twhile (ve && *ve && !(*ve == '\\r' || *ve == '\\n')) ++ve;\n\t\t*ke = 0, *ve = 0;\n\t\tlist_insert(&substPtr, (char*)ks, (char*)vs);\n\t    }\n\t    fclose(sp);\n\t}\n\n\t/* debug: dump the list */\n#ifndef NDEBUG\n\t{\n\t    int n = 0;\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {\n\t\tfprintf(stderr, \"% 3d '%s' => '%s'\\n\", n, p->key, p->value);\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Run the substitutions over each line of the input\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr) {\n\t\tchar *m = strstr(szBuffer, p->key);\n\t\tif (m) {\n\t\t    char *cp, *op, *sp;\n\t\t    cp = szCopy;\n\t\t    op = szBuffer;\n\t\t    while (op != m) *cp++ = *op++;\n\t\t    sp = p->value;\n\t\t    while (sp && *sp) *cp++ = *sp++;\n\t\t    op += strlen(p->key);\n\t\t    while (*op) *cp++ = *op++;\n\t\t    *cp = 0;\n\t\t    memcpy(szBuffer, szCopy, sizeof(szCopy));\n\t\t}\n\t    }\n\t    printf(szBuffer);\n\t}\n\n\tlist_free(&substPtr);\n    }\n    fclose(fp);\n    return 0;\n}\n\f\nBOOL FileExists(LPCTSTR szPath)\n{\n#ifndef INVALID_FILE_ATTRIBUTES\n    #define INVALID_FILE_ATTRIBUTES ((DWORD)-1)\n#endif\n    DWORD pathAttr = GetFileAttributes(szPath);\n    return (pathAttr != INVALID_FILE_ATTRIBUTES &&\n\t    !(pathAttr & FILE_ATTRIBUTE_DIRECTORY));\n}\n\f\n\n/*\n * QualifyPath --\n *\n *\tThis composes the current working directory with a provided path\n *\tand returns the fully qualified and normalized path.\n *\tMostly needed to setup paths for testing.\n */\n\nstatic int\nQualifyPath(\n    const char *szPath)\n{\n    char szCwd[MAX_PATH + 1];\n\n    GetFullPathName(szPath, sizeof(szCwd)-1, szCwd, NULL);\n    printf(\"%s\\n\", szCwd);\n    return 0;\n}\n\n/*\n * Implements LocateDependency for a single directory. See that command\n * for an explanation.\n * Returns 0 if found after printing the directory.\n * Returns 1 if not found but no errors.\n * Returns 2 on any kind of error\n * Basically, these are used as exit codes for the process.\n */\nstatic int LocateDependencyHelper(const char *dir, const char *keypath)\n{\n    HANDLE hSearch;\n    char path[MAX_PATH+1];\n    int dirlen, keylen, ret;\n    WIN32_FIND_DATA finfo;\n\n    if (dir == NULL || keypath == NULL)\n\treturn 2; /* Have no real error reporting mechanism into nmake */\n    dirlen = strlen(dir);\n    if ((dirlen + 3) > sizeof(path))\n\treturn 2;\n    strncpy(path, dir, dirlen);\n    strncpy(path+dirlen, \"\\\\*\", 3);\t/* Including terminating \\0 */\n    keylen = strlen(keypath);\n\n#if 0 /* This function is not available in Visual C++ 6 */\n    /*\n     * Use numerics 0 -> FindExInfoStandard,\n     * 1 -> FindExSearchLimitToDirectories,\n     * as these are not defined in Visual C++ 6\n     */\n    hSearch = FindFirstFileEx(path, 0, &finfo, 1, NULL, 0);\n#else\n    hSearch = FindFirstFile(path, &finfo);\n#endif\n    if (hSearch == INVALID_HANDLE_VALUE)\n\treturn 1; /* Not found */\n\n    /* Loop through all subdirs checking if the keypath is under there */\n    ret = 1; /* Assume not found */\n    do {\n\tint sublen;\n\t/*\n\t * We need to check it is a directory despite the\n\t * FindExSearchLimitToDirectories in the above call. See SDK docs\n\t */\n\tif ((finfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)\n\t    continue;\n\tsublen = strlen(finfo.cFileName);\n\tif ((dirlen+1+sublen+1+keylen+1) > sizeof(path))\n\t    continue;\t\t/* Path does not fit, assume not matched */\n\tstrncpy(path+dirlen+1, finfo.cFileName, sublen);\n\tpath[dirlen+1+sublen] = '\\\\';\n\tstrncpy(path+dirlen+1+sublen+1, keypath, keylen+1);\n\tif (FileExists(path)) {\n\t    /* Found a match, print to stdout */\n\t    path[dirlen+1+sublen] = '\\0';\n\t    QualifyPath(path);\n\t    ret = 0;\n\t    break;\n\t}\n    } while (FindNextFile(hSearch, &finfo));\n    FindClose(hSearch);\n    return ret;\n}\n\n/*\n * LocateDependency --\n *\n *\tLocates a dependency for a package.\n *        keypath - a relative path within the package directory\n *          that is used to confirm it is the correct directory.\n *\tThe search path for the package directory is currently only\n *      the parent and grandparent of the current working directory.\n *      If found, the command prints\n *         name_DIRPATH=<full path of located directory>\n *      and returns 0. If not found, does not print anything and returns 1.\n */\nstatic int LocateDependency(const char *keypath)\n{\n    int i, ret;\n    static const char *paths[] = {\"..\", \"..\\\\..\", \"..\\\\..\\\\..\"};\n\n    for (i = 0; i < (sizeof(paths)/sizeof(paths[0])); ++i) {\n\tret = LocateDependencyHelper(paths[i], keypath);\n\tif (ret == 0)\n\t    return ret;\n    }\n    return ret;\n}\n\n\n/*\n * Local variables:\n *   mode: c\n *   c-basic-offset: 4\n *   fill-column: 78\n *   indent-tabs-mode: t\n *   tab-width: 8\n * End:\n */\n"], "fixing_code": ["/*\n * ----------------------------------------------------------------------------\n * nmakehlp.c --\n *\n *\tThis is used to fix limitations within nmake and the environment.\n *\n * Copyright (c) 2002 by David Gravereaux.\n * Copyright (c) 2006 by Pat Thoyts\n *\n * See the file \"license.terms\" for information on usage and redistribution of\n * this file, and for a DISCLAIMER OF ALL WARRANTIES.\n * ----------------------------------------------------------------------------\n */\n\n#define _CRT_SECURE_NO_DEPRECATE\n#include <windows.h>\n#pragma comment (lib, \"user32.lib\")\n#pragma comment (lib, \"kernel32.lib\")\n#include <stdio.h>\n#include <math.h>\n\n/*\n * This library is required for x64 builds with _some_ versions of MSVC\n */\n#if defined(_M_IA64) || defined(_M_AMD64)\n#if _MSC_VER >= 1400 && _MSC_VER < 1500\n#pragma comment(lib, \"bufferoverflowU\")\n#endif\n#endif\n\n/* ISO hack for dumb VC++ */\n#ifdef _MSC_VER\n#define   snprintf\t_snprintf\n#endif\n\n\n/* protos */\n\nstatic int CheckForCompilerFeature(const char *option);\nstatic int CheckForLinkerFeature(const char **options, int count);\nstatic int IsIn(const char *string, const char *substring);\nstatic int SubstituteFile(const char *substs, const char *filename);\nstatic int QualifyPath(const char *path);\nstatic int LocateDependency(const char *keyfile);\nstatic const char *GetVersionFromFile(const char *filename, const char *match, int numdots);\nstatic DWORD WINAPI ReadFromPipe(LPVOID args);\n\n/* globals */\n\n#define CHUNK\t25\n#define STATICBUFFERSIZE    1000\ntypedef struct {\n    HANDLE pipe;\n    char buffer[STATICBUFFERSIZE];\n} pipeinfo;\n\npipeinfo Out = {INVALID_HANDLE_VALUE, '\\0'};\npipeinfo Err = {INVALID_HANDLE_VALUE, '\\0'};\n\f\n/*\n * exitcodes: 0 == no, 1 == yes, 2 == error\n */\n\nint\nmain(\n    int argc,\n    char *argv[])\n{\n    char msg[300];\n    DWORD dwWritten;\n    int chars;\n    const char *s;\n\n    /*\n     * Make sure children (cl.exe and link.exe) are kept quiet.\n     */\n\n    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);\n\n    /*\n     * Make sure the compiler and linker aren't effected by the outside world.\n     */\n\n    SetEnvironmentVariable(\"CL\", \"\");\n    SetEnvironmentVariable(\"LINK\", \"\");\n\n    if (argc > 1 && *argv[1] == '-') {\n\tswitch (*(argv[1]+1)) {\n\tcase 'c':\n\t    if (argc != 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t        \"usage: %s -c <compiler option>\\n\"\n\t\t\t\"Tests for whether cl.exe supports an option\\n\"\n\t\t\t\"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return CheckForCompilerFeature(argv[2]);\n\tcase 'l':\n\t    if (argc < 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t       \t\t\"usage: %s -l <linker option> ?<mandatory option> ...?\\n\"\n\t\t\t\"Tests for whether link.exe supports an option\\n\"\n\t\t\t\"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return CheckForLinkerFeature(&argv[2], argc-2);\n\tcase 'f':\n\t    if (argc == 2) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t\t\"usage: %s -f <string> <substring>\\n\"\n\t\t\t\"Find a substring within another\\n\"\n\t\t\t\"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    } else if (argc == 3) {\n\t\t/*\n\t\t * If the string is blank, there is no match.\n\t\t */\n\n\t\treturn 0;\n\t    } else {\n\t\treturn IsIn(argv[2], argv[3]);\n\t    }\n\tcase 's':\n\t    if (argc == 2) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t\t\"usage: %s -s <substitutions file> <file>\\n\"\n\t\t\t\"Perform a set of string map type substutitions on a file\\n\"\n\t\t\t\"exitcodes: 0\\n\",\n\t\t\targv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t\t&dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return SubstituteFile(argv[2], argv[3]);\n\tcase 'V':\n\t    if (argc != 4) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t    \"usage: %s -V filename matchstring\\n\"\n\t\t    \"Extract a version from a file:\\n\"\n\t\t    \"eg: pkgIndex.tcl \\\"package ifneeded http\\\"\",\n\t\t    argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t    &dwWritten, NULL);\n\t\treturn 0;\n\t    }\n\t    s = GetVersionFromFile(argv[2], argv[3], *(argv[1]+2) - '0');\n\t    if (s && *s) {\n\t\tprintf(\"%s\\n\", s);\n\t\treturn 0;\n\t    } else\n\t\treturn 1; /* Version not found. Return non-0 exit code */\n\n\tcase 'Q':\n\t    if (argc != 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t    \"usage: %s -Q path\\n\"\n\t\t    \"Emit the fully qualified path\\n\"\n\t\t    \"exitcodes: 0 == no, 1 == yes, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t    &dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return QualifyPath(argv[2]);\n\n\tcase 'L':\n\t    if (argc != 3) {\n\t\tchars = snprintf(msg, sizeof(msg) - 1,\n\t\t    \"usage: %s -L keypath\\n\"\n\t\t    \"Emit the fully qualified path of directory containing keypath\\n\"\n\t\t    \"exitcodes: 0 == success, 1 == not found, 2 == error\\n\", argv[0]);\n\t\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars,\n\t\t    &dwWritten, NULL);\n\t\treturn 2;\n\t    }\n\t    return LocateDependency(argv[2]);\n\t}\n    }\n    chars = snprintf(msg, sizeof(msg) - 1,\n\t    \"usage: %s -c|-f|-l|-Q|-s|-V ...\\n\"\n\t    \"This is a little helper app to equalize shell differences between WinNT and\\n\"\n\t    \"Win9x and get nmake.exe to accomplish its job.\\n\",\n\t    argv[0]);\n    WriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, chars, &dwWritten, NULL);\n    return 2;\n}\n\f\nstatic int\nCheckForCompilerFeature(\n    const char *option)\n{\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    SECURITY_ATTRIBUTES sa;\n    DWORD threadID;\n    char msg[300];\n    BOOL ok;\n    HANDLE hProcess, h, pipeThreads[2];\n    char cmdline[100];\n\n    hProcess = GetCurrentProcess();\n\n    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n    ZeroMemory(&si, sizeof(STARTUPINFO));\n    si.cb = sizeof(STARTUPINFO);\n    si.dwFlags   = STARTF_USESTDHANDLES;\n    si.hStdInput = INVALID_HANDLE_VALUE;\n\n    ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.lpSecurityDescriptor = NULL;\n    sa.bInheritHandle = FALSE;\n\n    /*\n     * Create a non-inheritible pipe.\n     */\n\n    CreatePipe(&Out.pipe, &h, &sa, 0);\n\n    /*\n     * Dupe the write side, make it inheritible, and close the original.\n     */\n\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdOutput, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Same as above, but for the error side.\n     */\n\n    CreatePipe(&Err.pipe, &h, &sa, 0);\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdError, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Base command line.\n     */\n\n    lstrcpy(cmdline, \"cl.exe -nologo -c -TC -Zs -X -Fp.\\\\_junk.pch \");\n\n    /*\n     * Append our option for testing\n     */\n\n    lstrcat(cmdline, option);\n\n    /*\n     * Filename to compile, which exists, but is nothing and empty.\n     */\n\n    lstrcat(cmdline, \" .\\\\nul\");\n\n    ok = CreateProcess(\n\t    NULL,\t    /* Module name. */\n\t    cmdline,\t    /* Command line. */\n\t    NULL,\t    /* Process handle not inheritable. */\n\t    NULL,\t    /* Thread handle not inheritable. */\n\t    TRUE,\t    /* yes, inherit handles. */\n\t    DETACHED_PROCESS, /* No console for you. */\n\t    NULL,\t    /* Use parent's environment block. */\n\t    NULL,\t    /* Use parent's starting directory. */\n\t    &si,\t    /* Pointer to STARTUPINFO structure. */\n\t    &pi);\t    /* Pointer to PROCESS_INFORMATION structure. */\n\n    if (!ok) {\n\tDWORD err = GetLastError();\n\tint chars = snprintf(msg, sizeof(msg) - 1,\n\t\t\"Tried to launch: \\\"%s\\\", but got error [%u]: \", cmdline, err);\n\n\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\tFORMAT_MESSAGE_MAX_WIDTH_MASK, 0L, err, 0, (LPVOID)&msg[chars],\n\t\t(300-chars), 0);\n\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, lstrlen(msg), &err,NULL);\n\treturn 2;\n    }\n\n    /*\n     * Close our references to the write handles that have now been inherited.\n     */\n\n    CloseHandle(si.hStdOutput);\n    CloseHandle(si.hStdError);\n\n    WaitForInputIdle(pi.hProcess, 5000);\n    CloseHandle(pi.hThread);\n\n    /*\n     * Start the pipe reader threads.\n     */\n\n    pipeThreads[0] = CreateThread(NULL, 0, ReadFromPipe, &Out, 0, &threadID);\n    pipeThreads[1] = CreateThread(NULL, 0, ReadFromPipe, &Err, 0, &threadID);\n\n    /*\n     * Block waiting for the process to end.\n     */\n\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hProcess);\n\n    /*\n     * Wait for our pipe to get done reading, should it be a little slow.\n     */\n\n    WaitForMultipleObjects(2, pipeThreads, TRUE, 500);\n    CloseHandle(pipeThreads[0]);\n    CloseHandle(pipeThreads[1]);\n\n    /*\n     * Look for the commandline warning code in both streams.\n     *  - in MSVC 6 & 7 we get D4002, in MSVC 8 we get D9002.\n     */\n\n    return !(strstr(Out.buffer, \"D4002\") != NULL\n             || strstr(Err.buffer, \"D4002\") != NULL\n             || strstr(Out.buffer, \"D9002\") != NULL\n             || strstr(Err.buffer, \"D9002\") != NULL\n             || strstr(Out.buffer, \"D2021\") != NULL\n             || strstr(Err.buffer, \"D2021\") != NULL);\n}\n\f\nstatic int\nCheckForLinkerFeature(\n    const char **options,\n    int count)\n{\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    SECURITY_ATTRIBUTES sa;\n    DWORD threadID;\n    char msg[300];\n    BOOL ok;\n    HANDLE hProcess, h, pipeThreads[2];\n    int i;\n    char cmdline[255];\n\n    hProcess = GetCurrentProcess();\n\n    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n    ZeroMemory(&si, sizeof(STARTUPINFO));\n    si.cb = sizeof(STARTUPINFO);\n    si.dwFlags   = STARTF_USESTDHANDLES;\n    si.hStdInput = INVALID_HANDLE_VALUE;\n\n    ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.lpSecurityDescriptor = NULL;\n    sa.bInheritHandle = TRUE;\n\n    /*\n     * Create a non-inheritible pipe.\n     */\n\n    CreatePipe(&Out.pipe, &h, &sa, 0);\n\n    /*\n     * Dupe the write side, make it inheritible, and close the original.\n     */\n\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdOutput, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Same as above, but for the error side.\n     */\n\n    CreatePipe(&Err.pipe, &h, &sa, 0);\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdError, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Base command line.\n     */\n\n    lstrcpy(cmdline, \"link.exe -nologo \");\n\n    /*\n     * Append our option for testing.\n     */\n\n    for (i = 0; i < count; i++) {\n\tlstrcat(cmdline, \" \\\"\");\n\tlstrcat(cmdline, options[i]);\n\tlstrcat(cmdline, \"\\\"\");\n    }\n\n    ok = CreateProcess(\n\t    NULL,\t    /* Module name. */\n\t    cmdline,\t    /* Command line. */\n\t    NULL,\t    /* Process handle not inheritable. */\n\t    NULL,\t    /* Thread handle not inheritable. */\n\t    TRUE,\t    /* yes, inherit handles. */\n\t    DETACHED_PROCESS, /* No console for you. */\n\t    NULL,\t    /* Use parent's environment block. */\n\t    NULL,\t    /* Use parent's starting directory. */\n\t    &si,\t    /* Pointer to STARTUPINFO structure. */\n\t    &pi);\t    /* Pointer to PROCESS_INFORMATION structure. */\n\n    if (!ok) {\n\tDWORD err = GetLastError();\n\tint chars = snprintf(msg, sizeof(msg) - 1,\n\t\t\"Tried to launch: \\\"%s\\\", but got error [%u]: \", cmdline, err);\n\n\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\tFORMAT_MESSAGE_MAX_WIDTH_MASK, 0L, err, 0, (LPVOID)&msg[chars],\n\t\t(300-chars), 0);\n\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, lstrlen(msg), &err,NULL);\n\treturn 2;\n    }\n\n    /*\n     * Close our references to the write handles that have now been inherited.\n     */\n\n    CloseHandle(si.hStdOutput);\n    CloseHandle(si.hStdError);\n\n    WaitForInputIdle(pi.hProcess, 5000);\n    CloseHandle(pi.hThread);\n\n    /*\n     * Start the pipe reader threads.\n     */\n\n    pipeThreads[0] = CreateThread(NULL, 0, ReadFromPipe, &Out, 0, &threadID);\n    pipeThreads[1] = CreateThread(NULL, 0, ReadFromPipe, &Err, 0, &threadID);\n\n    /*\n     * Block waiting for the process to end.\n     */\n\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hProcess);\n\n    /*\n     * Wait for our pipe to get done reading, should it be a little slow.\n     */\n\n    WaitForMultipleObjects(2, pipeThreads, TRUE, 500);\n    CloseHandle(pipeThreads[0]);\n    CloseHandle(pipeThreads[1]);\n\n    /*\n     * Look for the commandline warning code in the stderr stream.\n     */\n\n    return !(strstr(Out.buffer, \"LNK1117\") != NULL ||\n\t    strstr(Err.buffer, \"LNK1117\") != NULL ||\n\t    strstr(Out.buffer, \"LNK4044\") != NULL ||\n\t    strstr(Err.buffer, \"LNK4044\") != NULL ||\n\t    strstr(Out.buffer, \"LNK4224\") != NULL ||\n\t    strstr(Err.buffer, \"LNK4224\") != NULL);\n}\n\f\nstatic DWORD WINAPI\nReadFromPipe(\n    LPVOID args)\n{\n    pipeinfo *pi = (pipeinfo *) args;\n    char *lastBuf = pi->buffer;\n    DWORD dwRead;\n    BOOL ok;\n\n  again:\n    if (lastBuf - pi->buffer + CHUNK > STATICBUFFERSIZE) {\n\tCloseHandle(pi->pipe);\n\treturn (DWORD)-1;\n    }\n    ok = ReadFile(pi->pipe, lastBuf, CHUNK, &dwRead, 0L);\n    if (!ok || dwRead == 0) {\n\tCloseHandle(pi->pipe);\n\treturn 0;\n    }\n    lastBuf += dwRead;\n    goto again;\n\n    return 0;  /* makes the compiler happy */\n}\n\f\nstatic int\nIsIn(\n    const char *string,\n    const char *substring)\n{\n    return (strstr(string, substring) != NULL);\n}\n\f\n/*\n * GetVersionFromFile --\n * \tLooks for a match string in a file and then returns the version\n * \tfollowing the match where a version is anything acceptable to\n * \tpackage provide or package ifneeded.\n */\n\nstatic const char *\nGetVersionFromFile(\n    const char *filename,\n    const char *match,\n    int numdots)\n{\n    size_t cbBuffer = 100;\n    static char szBuffer[100];\n    char *szResult = NULL;\n    FILE *fp = fopen(filename, \"rt\");\n\n    if (fp != NULL) {\n\t/*\n\t * Read data until we see our match string.\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    LPSTR p, q;\n\n\t    p = strstr(szBuffer, match);\n\t    if (p != NULL) {\n\t\t/*\n\t\t * Skip to first digit after the match.\n\t\t */\n\n\t\tp += strlen(match);\n\t\twhile (*p && !isdigit(*p)) {\n\t\t    ++p;\n\t\t}\n\n\t\t/*\n\t\t * Find ending whitespace.\n\t\t */\n\n\t\tq = p;\n\t\twhile (*q && (strchr(\"0123456789.ab\", *q)) && ((!strchr(\".ab\", *q)\n\t\t\t    && (!strchr(\"ab\", q[-1])) || --numdots))) {\n\t\t    ++q;\n\t\t}\n\n\t\tmemmove(szBuffer, p, q - p);\n\t\tszBuffer[q-p] = 0;\n\t\tszResult = szBuffer;\n\t\tbreak;\n\t    }\n\t}\n\tfclose(fp);\n    }\n    return szResult;\n}\n\f\n/*\n * List helpers for the SubstituteFile function\n */\n\ntypedef struct list_item_t {\n    struct list_item_t *nextPtr;\n    char * key;\n    char * value;\n} list_item_t;\n\n/* insert a list item into the list (list may be null) */\nstatic list_item_t *\nlist_insert(list_item_t **listPtrPtr, const char *key, const char *value)\n{\n    list_item_t *itemPtr = malloc(sizeof(list_item_t));\n    if (itemPtr) {\n\titemPtr->key = strdup(key);\n\titemPtr->value = strdup(value);\n\titemPtr->nextPtr = NULL;\n\n\twhile(*listPtrPtr) {\n\t    listPtrPtr = &(*listPtrPtr)->nextPtr;\n\t}\n\t*listPtrPtr = itemPtr;\n    }\n    return itemPtr;\n}\n\nstatic void\nlist_free(list_item_t **listPtrPtr)\n{\n    list_item_t *tmpPtr, *listPtr = *listPtrPtr;\n    while (listPtr) {\n\ttmpPtr = listPtr;\n\tlistPtr = listPtr->nextPtr;\n\tfree(tmpPtr->key);\n\tfree(tmpPtr->value);\n\tfree(tmpPtr);\n    }\n}\n\f\n/*\n * SubstituteFile --\n *\tAs windows doesn't provide anything useful like sed and it's unreliable\n *\tto use the tclsh you are building against (consider x-platform builds -\n *\teg compiling AMD64 target from IX86) we provide a simple substitution\n *\toption here to handle autoconf style substitutions.\n *\tThe substitution file is whitespace and line delimited. The file should\n *\tconsist of lines matching the regular expression:\n *\t  \\s*\\S+\\s+\\S*$\n *\n *\tUsage is something like:\n *\t  nmakehlp -S << $** > $@\n *        @PACKAGE_NAME@ $(PACKAGE_NAME)\n *        @PACKAGE_VERSION@ $(PACKAGE_VERSION)\n *        <<\n */\n\nstatic int\nSubstituteFile(\n    const char *substitutions,\n    const char *filename)\n{\n    size_t cbBuffer = 1024;\n    static char szBuffer[1024], szCopy[1024];\n    char *szResult = NULL;\n    list_item_t *substPtr = NULL;\n    FILE *fp, *sp;\n\n    fp = fopen(filename, \"rt\");\n    if (fp != NULL) {\n\n\t/*\n\t * Build a list of substutitions from the first filename\n\t */\n\n\tsp = fopen(substitutions, \"rt\");\n\tif (sp != NULL) {\n\t    while (fgets(szBuffer, cbBuffer, sp) != NULL) {\n\t\tunsigned char *ks, *ke, *vs, *ve;\n\t\tks = (unsigned char*)szBuffer;\n\t\twhile (ks && *ks && isspace(*ks)) ++ks;\n\t\tke = ks;\n\t\twhile (ke && *ke && !isspace(*ke)) ++ke;\n\t\tvs = ke;\n\t\twhile (vs && *vs && isspace(*vs)) ++vs;\n\t\tve = vs;\n\t\twhile (ve && *ve && !(*ve == '\\r' || *ve == '\\n')) ++ve;\n\t\t*ke = 0, *ve = 0;\n\t\tlist_insert(&substPtr, (char*)ks, (char*)vs);\n\t    }\n\t    fclose(sp);\n\t}\n\n\t/* debug: dump the list */\n#ifndef NDEBUG\n\t{\n\t    int n = 0;\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {\n\t\tfprintf(stderr, \"% 3d '%s' => '%s'\\n\", n, p->key, p->value);\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Run the substitutions over each line of the input\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr) {\n\t\tchar *m = strstr(szBuffer, p->key);\n\t\tif (m) {\n\t\t    char *cp, *op, *sp;\n\t\t    cp = szCopy;\n\t\t    op = szBuffer;\n\t\t    while (op != m) *cp++ = *op++;\n\t\t    sp = p->value;\n\t\t    while (sp && *sp) *cp++ = *sp++;\n\t\t    op += strlen(p->key);\n\t\t    while (*op) *cp++ = *op++;\n\t\t    *cp = 0;\n\t\t    memcpy(szBuffer, szCopy, sizeof(szCopy));\n\t\t}\n\t    }\n\t    printf(\"%s\", szBuffer);\n\t}\n\n\tlist_free(&substPtr);\n    }\n    fclose(fp);\n    return 0;\n}\n\f\nBOOL FileExists(LPCTSTR szPath)\n{\n#ifndef INVALID_FILE_ATTRIBUTES\n    #define INVALID_FILE_ATTRIBUTES ((DWORD)-1)\n#endif\n    DWORD pathAttr = GetFileAttributes(szPath);\n    return (pathAttr != INVALID_FILE_ATTRIBUTES &&\n\t    !(pathAttr & FILE_ATTRIBUTE_DIRECTORY));\n}\n\f\n\n/*\n * QualifyPath --\n *\n *\tThis composes the current working directory with a provided path\n *\tand returns the fully qualified and normalized path.\n *\tMostly needed to setup paths for testing.\n */\n\nstatic int\nQualifyPath(\n    const char *szPath)\n{\n    char szCwd[MAX_PATH + 1];\n\n    GetFullPathName(szPath, sizeof(szCwd)-1, szCwd, NULL);\n    printf(\"%s\\n\", szCwd);\n    return 0;\n}\n\n/*\n * Implements LocateDependency for a single directory. See that command\n * for an explanation.\n * Returns 0 if found after printing the directory.\n * Returns 1 if not found but no errors.\n * Returns 2 on any kind of error\n * Basically, these are used as exit codes for the process.\n */\nstatic int LocateDependencyHelper(const char *dir, const char *keypath)\n{\n    HANDLE hSearch;\n    char path[MAX_PATH+1];\n    int dirlen, keylen, ret;\n    WIN32_FIND_DATA finfo;\n\n    if (dir == NULL || keypath == NULL)\n\treturn 2; /* Have no real error reporting mechanism into nmake */\n    dirlen = strlen(dir);\n    if ((dirlen + 3) > sizeof(path))\n\treturn 2;\n    strncpy(path, dir, dirlen);\n    strncpy(path+dirlen, \"\\\\*\", 3);\t/* Including terminating \\0 */\n    keylen = strlen(keypath);\n\n#if 0 /* This function is not available in Visual C++ 6 */\n    /*\n     * Use numerics 0 -> FindExInfoStandard,\n     * 1 -> FindExSearchLimitToDirectories,\n     * as these are not defined in Visual C++ 6\n     */\n    hSearch = FindFirstFileEx(path, 0, &finfo, 1, NULL, 0);\n#else\n    hSearch = FindFirstFile(path, &finfo);\n#endif\n    if (hSearch == INVALID_HANDLE_VALUE)\n\treturn 1; /* Not found */\n\n    /* Loop through all subdirs checking if the keypath is under there */\n    ret = 1; /* Assume not found */\n    do {\n\tint sublen;\n\t/*\n\t * We need to check it is a directory despite the\n\t * FindExSearchLimitToDirectories in the above call. See SDK docs\n\t */\n\tif ((finfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)\n\t    continue;\n\tsublen = strlen(finfo.cFileName);\n\tif ((dirlen+1+sublen+1+keylen+1) > sizeof(path))\n\t    continue;\t\t/* Path does not fit, assume not matched */\n\tstrncpy(path+dirlen+1, finfo.cFileName, sublen);\n\tpath[dirlen+1+sublen] = '\\\\';\n\tstrncpy(path+dirlen+1+sublen+1, keypath, keylen+1);\n\tif (FileExists(path)) {\n\t    /* Found a match, print to stdout */\n\t    path[dirlen+1+sublen] = '\\0';\n\t    QualifyPath(path);\n\t    ret = 0;\n\t    break;\n\t}\n    } while (FindNextFile(hSearch, &finfo));\n    FindClose(hSearch);\n    return ret;\n}\n\n/*\n * LocateDependency --\n *\n *\tLocates a dependency for a package.\n *        keypath - a relative path within the package directory\n *          that is used to confirm it is the correct directory.\n *\tThe search path for the package directory is currently only\n *      the parent and grandparent of the current working directory.\n *      If found, the command prints\n *         name_DIRPATH=<full path of located directory>\n *      and returns 0. If not found, does not print anything and returns 1.\n */\nstatic int LocateDependency(const char *keypath)\n{\n    int i, ret;\n    static const char *paths[] = {\"..\", \"..\\\\..\", \"..\\\\..\\\\..\"};\n\n    for (i = 0; i < (sizeof(paths)/sizeof(paths[0])); ++i) {\n\tret = LocateDependencyHelper(paths[i], keypath);\n\tif (ret == 0)\n\t    return ret;\n    }\n    return ret;\n}\n\n\n/*\n * Local variables:\n *   mode: c\n *   c-basic-offset: 4\n *   fill-column: 78\n *   indent-tabs-mode: t\n *   tab-width: 8\n * End:\n */\n"], "filenames": ["win/nmakehlp.c"], "buggy_code_start_loc": [546], "buggy_code_end_loc": [686], "fixing_code_start_loc": [546], "fixing_code_end_loc": [686], "type": "CWE-134", "message": "** DISPUTED ** In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding.", "other": {"cve": {"id": "CVE-2021-35331", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-05T15:15:07.997", "lastModified": "2021-09-20T19:00:40.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding."}, {"lang": "es", "value": "** EN DISPUTA ** En Tcl versi\u00f3n 8.6.11, una vulnerabilidad de cadena de formato en nmakehlp.c podr\u00eda permitir la ejecuci\u00f3n de c\u00f3digo a trav\u00e9s de un archivo manipulado. NOTA: varios terceros discuten la importancia de este hallazgo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcl:tcl:8.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "6BE08290-3693-466E-A9E8-92E1E40D6357"}]}]}], "references": [{"url": "https://core.tcl-lang.org/tcl/info/28ef6c0c741408a2", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://core.tcl-lang.org/tcl/info/bad6cc213dfe8280", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/tcltk/tcl/commit/4705dbdde2f32ff90420765cd93e7ac71d81a222", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://sqlite.org/forum/info/7dcd751996c93ec9", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tcltk/tcl/commit/4705dbdde2f32ff90420765cd93e7ac71d81a222"}}