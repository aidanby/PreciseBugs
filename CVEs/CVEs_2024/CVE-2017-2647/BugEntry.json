{"buggy_code": ["/* Asymmetric public-key cryptography key type\n *\n * See Documentation/security/asymmetric-keys.txt\n *\n * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n#include <keys/asymmetric-subtype.h>\n#include <keys/asymmetric-parser.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"asymmetric_keys.h\"\n\nMODULE_LICENSE(\"GPL\");\n\nstatic LIST_HEAD(asymmetric_key_parsers);\nstatic DECLARE_RWSEM(asymmetric_key_parsers_sem);\n\n/*\n * Match asymmetric key id with partial match\n * @id:\t\tkey id to match in a form \"id:<id>\"\n */\nint asymmetric_keyid_match(const char *kid, const char *id)\n{\n\tsize_t idlen, kidlen;\n\n\tif (!kid || !id)\n\t\treturn 0;\n\n\t/* make it possible to use id as in the request: \"id:<id>\" */\n\tif (strncmp(id, \"id:\", 3) == 0)\n\t\tid += 3;\n\n\t/* Anything after here requires a partial match on the ID string */\n\tidlen = strlen(id);\n\tkidlen = strlen(kid);\n\tif (idlen > kidlen)\n\t\treturn 0;\n\n\tkid += kidlen - idlen;\n\tif (strcasecmp(id, kid) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n\n/*\n * Match asymmetric keys on (part of) their name\n * We have some shorthand methods for matching keys.  We allow:\n *\n *\t\"<desc>\"\t- request a key by description\n *\t\"id:<id>\"\t- request a key matching the ID\n *\t\"<subtype>:<id>\" - request a key of a subtype\n */\nstatic int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\n\t/* See if the full key description matches as is */\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\n\t/* All tests from here on break the criterion description into a\n\t * specifier, a colon and then an identifier.\n\t */\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\n\tspeclen = id - spec;\n\tid++;\n\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n * Preparse the match criterion.  If we don't set lookup_type and cmp,\n * the default will be an exact match on the key description.\n *\n * There are some specifiers for matching key IDs rather than by the key\n * description:\n *\n *\t\"id:<id>\" - request a key by any available ID\n *\n * These have to be searched by iteration rather than by direct lookup because\n * the key is hashed according to its description.\n */\nstatic int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\treturn 0;\n}\n\n/*\n * Free the preparsed the match criterion.\n */\nstatic void asymmetric_key_match_free(struct key_match_data *match_data)\n{\n}\n\n/*\n * Describe the asymmetric key\n */\nstatic void asymmetric_key_describe(const struct key *key, struct seq_file *m)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *kid = asymmetric_key_id(key);\n\tsize_t n;\n\n\tseq_puts(m, key->description);\n\n\tif (subtype) {\n\t\tseq_puts(m, \": \");\n\t\tsubtype->describe(key, m);\n\n\t\tif (kid) {\n\t\t\tseq_putc(m, ' ');\n\t\t\tn = strlen(kid);\n\t\t\tif (n <= 8)\n\t\t\t\tseq_puts(m, kid);\n\t\t\telse\n\t\t\t\tseq_puts(m, kid + n - 8);\n\t\t}\n\n\t\tseq_puts(m, \" [\");\n\t\t/* put something here to indicate the key's capabilities */\n\t\tseq_putc(m, ']');\n\t}\n}\n\n/*\n * Preparse a asymmetric payload to get format the contents appropriately for the\n * internal payload to cut down on the number of scans of the data performed.\n *\n * We also generate a proposed description from the contents of the key that\n * can be used to name the key if the user doesn't want to provide one.\n */\nstatic int asymmetric_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct asymmetric_key_parser *parser;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (prep->datalen == 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&asymmetric_key_parsers_sem);\n\n\tret = -EBADMSG;\n\tlist_for_each_entry(parser, &asymmetric_key_parsers, link) {\n\t\tpr_debug(\"Trying parser '%s'\\n\", parser->name);\n\n\t\tret = parser->parse(prep);\n\t\tif (ret != -EBADMSG) {\n\t\t\tpr_debug(\"Parser recognised the format (ret %d)\\n\",\n\t\t\t\t ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&asymmetric_key_parsers_sem);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n/*\n * Clean up the preparse data\n */\nstatic void asymmetric_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct asymmetric_key_subtype *subtype = prep->type_data[0];\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (subtype) {\n\t\tsubtype->destroy(prep->payload[0]);\n\t\tmodule_put(subtype->owner);\n\t}\n\tkfree(prep->type_data[1]);\n\tkfree(prep->description);\n}\n\n/*\n * dispose of the data dangling from the corpse of a asymmetric key\n */\nstatic void asymmetric_key_destroy(struct key *key)\n{\n\tstruct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tif (subtype) {\n\t\tsubtype->destroy(key->payload.data);\n\t\tmodule_put(subtype->owner);\n\t\tkey->type_data.p[0] = NULL;\n\t}\n\tkfree(key->type_data.p[1]);\n\tkey->type_data.p[1] = NULL;\n}\n\nstruct key_type key_type_asymmetric = {\n\t.name\t\t= \"asymmetric\",\n\t.preparse\t= asymmetric_key_preparse,\n\t.free_preparse\t= asymmetric_key_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match_preparse\t= asymmetric_key_match_preparse,\n\t.match\t\t= asymmetric_key_match,\n\t.match_free\t= asymmetric_key_match_free,\n\t.destroy\t= asymmetric_key_destroy,\n\t.describe\t= asymmetric_key_describe,\n};\nEXPORT_SYMBOL_GPL(key_type_asymmetric);\n\n/**\n * register_asymmetric_key_parser - Register a asymmetric key blob parser\n * @parser: The parser to register\n */\nint register_asymmetric_key_parser(struct asymmetric_key_parser *parser)\n{\n\tstruct asymmetric_key_parser *cursor;\n\tint ret;\n\n\tdown_write(&asymmetric_key_parsers_sem);\n\n\tlist_for_each_entry(cursor, &asymmetric_key_parsers, link) {\n\t\tif (strcmp(cursor->name, parser->name) == 0) {\n\t\t\tpr_err(\"Asymmetric key parser '%s' already registered\\n\",\n\t\t\t       parser->name);\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_tail(&parser->link, &asymmetric_key_parsers);\n\n\tpr_notice(\"Asymmetric key parser '%s' registered\\n\", parser->name);\n\tret = 0;\n\nout:\n\tup_write(&asymmetric_key_parsers_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_asymmetric_key_parser);\n\n/**\n * unregister_asymmetric_key_parser - Unregister a asymmetric key blob parser\n * @parser: The parser to unregister\n */\nvoid unregister_asymmetric_key_parser(struct asymmetric_key_parser *parser)\n{\n\tdown_write(&asymmetric_key_parsers_sem);\n\tlist_del(&parser->link);\n\tup_write(&asymmetric_key_parsers_sem);\n\n\tpr_notice(\"Asymmetric key parser '%s' unregistered\\n\", parser->name);\n}\nEXPORT_SYMBOL_GPL(unregister_asymmetric_key_parser);\n\n/*\n * Module stuff\n */\nstatic int __init asymmetric_key_init(void)\n{\n\treturn register_key_type(&key_type_asymmetric);\n}\n\nstatic void __exit asymmetric_key_cleanup(void)\n{\n\tunregister_key_type(&key_type_asymmetric);\n}\n\nmodule_init(asymmetric_key_init);\nmodule_exit(asymmetric_key_cleanup);\n", "/* Testing module to load key from trusted PKCS#7 message\n *\n * Copyright (C) 2014 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) \"PKCS7key: \"fmt\n#include <linux/key.h>\n#include <linux/err.h>\n#include <linux/key-type.h>\n#include <crypto/pkcs7.h>\n#include <keys/user-type.h>\n#include <keys/system_keyring.h>\n#include \"pkcs7_parser.h\"\n\n/*\n * Preparse a PKCS#7 wrapped and validated data blob.\n */\nstatic int pkcs7_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct pkcs7_message *pkcs7;\n\tconst void *data, *saved_prep_data;\n\tsize_t datalen, saved_prep_datalen;\n\tbool trusted;\n\tint ret;\n\n\tkenter(\"\");\n\n\tsaved_prep_data = prep->data;\n\tsaved_prep_datalen = prep->datalen;\n\tpkcs7 = pkcs7_parse_message(saved_prep_data, saved_prep_datalen);\n\tif (IS_ERR(pkcs7)) {\n\t\tret = PTR_ERR(pkcs7);\n\t\tgoto error;\n\t}\n\n\tret = pkcs7_verify(pkcs7);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);\n\tif (ret < 0)\n\t\tgoto error_free;\n\tif (!trusted)\n\t\tpr_warn(\"PKCS#7 message doesn't chain back to a trusted key\\n\");\n\n\tret = pkcs7_get_content_data(pkcs7, &data, &datalen, false);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tprep->data = data;\n\tprep->datalen = datalen;\n\tret = user_preparse(prep);\n\tprep->data = saved_prep_data;\n\tprep->datalen = saved_prep_datalen;\n\nerror_free:\n\tpkcs7_free_message(pkcs7);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstatic struct key_type key_type_pkcs7 = {\n\t.name\t\t\t= \"pkcs7_test\",\n\t.preparse\t\t= pkcs7_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.match\t\t\t= user_match,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\n/*\n * Module stuff\n */\nstatic int __init pkcs7_key_init(void)\n{\n\treturn register_key_type(&key_type_pkcs7);\n}\n\nstatic void __exit pkcs7_key_cleanup(void)\n{\n\tunregister_key_type(&key_type_pkcs7);\n}\n\nmodule_init(pkcs7_key_init);\nmodule_exit(pkcs7_key_cleanup);\n", "/*\n *   fs/cifs/cifs_spnego.c -- SPNEGO upcall management for CIFS\n *\n *   Copyright (c) 2007 Red Hat, Inc.\n *   Author(s): Jeff Layton (jlayton@redhat.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/inet.h>\n#include \"cifsglob.h\"\n#include \"cifs_spnego.h\"\n#include \"cifs_debug.h\"\n\n/* create a new cifs key */\nstatic int\ncifs_spnego_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\tint ret;\n\n\tret = -ENOMEM;\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\tgoto error;\n\n\t/* attach the data */\n\tkey->payload.data = payload;\n\tret = 0;\n\nerror:\n\treturn ret;\n}\n\nstatic void\ncifs_spnego_key_destroy(struct key *key)\n{\n\tkfree(key->payload.data);\n}\n\n\n/*\n * keytype for CIFS spnego keys\n */\nstruct key_type cifs_spnego_key_type = {\n\t.name\t\t= \"cifs.spnego\",\n\t.instantiate\t= cifs_spnego_key_instantiate,\n\t.match\t\t= user_match,\n\t.destroy\t= cifs_spnego_key_destroy,\n\t.describe\t= user_describe,\n};\n\n/* length of longest version string e.g.  strlen(\"ver=0xFF\") */\n#define MAX_VER_STR_LEN\t\t8\n\n/* length of longest security mechanism name, eg in future could have\n * strlen(\";sec=ntlmsspi\") */\n#define MAX_MECH_STR_LEN\t13\n\n/* strlen of \"host=\" */\n#define HOST_KEY_LEN\t\t5\n\n/* strlen of \";ip4=\" or \";ip6=\" */\n#define IP_KEY_LEN\t\t5\n\n/* strlen of \";uid=0x\" */\n#define UID_KEY_LEN\t\t7\n\n/* strlen of \";creduid=0x\" */\n#define CREDUID_KEY_LEN\t\t11\n\n/* strlen of \";user=\" */\n#define USER_KEY_LEN\t\t6\n\n/* strlen of \";pid=0x\" */\n#define PID_KEY_LEN\t\t7\n\n/* get a key struct with a SPNEGO security blob, suitable for session setup */\nstruct key *\ncifs_get_spnego_key(struct cifs_ses *sesInfo)\n{\n\tstruct TCP_Server_Info *server = sesInfo->server;\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\tchar *description, *dp;\n\tsize_t desc_len;\n\tstruct key *spnego_key;\n\tconst char *hostname = server->hostname;\n\n\t/* length of fields (with semicolons): ver=0xyz ip4=ipaddress\n\t   host=hostname sec=mechanism uid=0xFF user=username */\n\tdesc_len = MAX_VER_STR_LEN +\n\t\t   HOST_KEY_LEN + strlen(hostname) +\n\t\t   IP_KEY_LEN + INET6_ADDRSTRLEN +\n\t\t   MAX_MECH_STR_LEN +\n\t\t   UID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\n\n\tif (sesInfo->user_name)\n\t\tdesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\n\n\tspnego_key = ERR_PTR(-ENOMEM);\n\tdescription = kzalloc(desc_len, GFP_KERNEL);\n\tif (description == NULL)\n\t\tgoto out;\n\n\tdp = description;\n\t/* start with version and hostname portion of UNC string */\n\tspnego_key = ERR_PTR(-EINVAL);\n\tsprintf(dp, \"ver=0x%x;host=%s;\", CIFS_SPNEGO_UPCALL_VERSION,\n\t\thostname);\n\tdp = description + strlen(description);\n\n\t/* add the server address */\n\tif (server->dstaddr.ss_family == AF_INET)\n\t\tsprintf(dp, \"ip4=%pI4\", &sa->sin_addr);\n\telse if (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(dp, \"ip6=%pI6\", &sa6->sin6_addr);\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\n\t/* for now, only sec=krb5 and sec=mskrb5 are valid */\n\tif (server->sec_kerberos)\n\t\tsprintf(dp, \";sec=krb5\");\n\telse if (server->sec_mskerberos)\n\t\tsprintf(dp, \";sec=mskrb5\");\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";uid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";creduid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\n\n\tif (sesInfo->user_name) {\n\t\tdp = description + strlen(description);\n\t\tsprintf(dp, \";user=%s\", sesInfo->user_name);\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";pid=0x%x\", current->pid);\n\n\tcifs_dbg(FYI, \"key description = %s\\n\", description);\n\tspnego_key = request_key(&cifs_spnego_key_type, description, \"\");\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (cifsFYI && !IS_ERR(spnego_key)) {\n\t\tstruct cifs_spnego_msg *msg = spnego_key->payload.data;\n\t\tcifs_dump_mem(\"SPNEGO reply blob:\", msg->data, min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len));\n\t}\n#endif /* CONFIG_CIFS_DEBUG2 */\n\nout:\n\tkfree(description);\n\treturn spnego_key;\n}\n", "/*\n *   fs/cifs/cifsacl.c\n *\n *   Copyright (C) International Business Machines  Corp., 2007,2008\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   Contains the routines for mapping CIFS/NTFS ACLs\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/keyctl.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n\n/* security id for everyone/world system group */\nstatic const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n/* security id for Authenticated Users system group */\nstatic const struct cifs_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {__constant_cpu_to_le32(11)} };\n/* group users */\nstatic const struct cifs_sid sid_user = {1, 2 , {0, 0, 0, 0, 0, 5}, {} };\n\nstatic const struct cred *root_cred;\n\nstatic int\ncifs_idmap_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\n\t/*\n\t * If the payload is less than or equal to the size of a pointer, then\n\t * an allocation here is wasteful. Just copy the data directly to the\n\t * payload.value union member instead.\n\t *\n\t * With this however, you must check the datalen before trying to\n\t * dereference payload.data!\n\t */\n\tif (prep->datalen <= sizeof(key->payload)) {\n\t\tkey->payload.value = 0;\n\t\tmemcpy(&key->payload.value, prep->data, prep->datalen);\n\t\tkey->datalen = prep->datalen;\n\t\treturn 0;\n\t}\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\treturn -ENOMEM;\n\n\tkey->payload.data = payload;\n\tkey->datalen = prep->datalen;\n\treturn 0;\n}\n\nstatic inline void\ncifs_idmap_key_destroy(struct key *key)\n{\n\tif (key->datalen > sizeof(key->payload))\n\t\tkfree(key->payload.data);\n}\n\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n\t.match       = user_match,\n};\n\nstatic char *\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\n\t/* 3 bytes for prefix */\n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\n\t/* The authority field is a single 48-bit number */\n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\n\t/*\n\t * MS-DTYP states that if the authority is >= 2^32, then it should be\n\t * expressed as a hex value.\n\t */\n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\n\tstrptr += len;\n\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\n\treturn sidstr;\n}\n\n/*\n * if the two SIDs (roughly equivalent to a UUID for a user or group) are\n * the same returns zero, if they do not match returns non-zero.\n */\nstatic int\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif ((!ctsid) || (!cwsid))\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t\tle32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}\n\nstatic void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}\n\nstatic int\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tstruct cifs_sid *ksid;\n\tunsigned int ksid_size;\n\tchar desc[3 + 10 + 1]; /* 3 byte prefix + 10 bytes for value + NULL */\n\tconst struct cred *saved_cred;\n\n\trc = snprintf(desc, sizeof(desc), \"%ci:%u\",\n\t\t\tsidtype == SIDOWNER ? 'o' : 'g', cid);\n\tif (rc >= sizeof(desc))\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, desc, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map %cid %u to a SID\\n\",\n\t\t\t __func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\n\t\tgoto out_revert_creds;\n\t} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tgoto invalidate_key;\n\t}\n\n\t/*\n\t * A sid is usually too large to be embedded in payload.value, but if\n\t * there are no subauthorities and the host has 8-byte pointers, then\n\t * it could be.\n\t */\n\tksid = sidkey->datalen <= sizeof(sidkey->payload) ?\n\t\t(struct cifs_sid *)&sidkey->payload.value :\n\t\t(struct cifs_sid *)sidkey->payload.data;\n\n\tksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\n\tif (ksid_size > sidkey->datalen) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\",\n\t\t\t __func__, sidkey->datalen, ksid_size);\n\t\tgoto invalidate_key;\n\t}\n\n\tcifs_copy_sid(ssid, ksid);\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\treturn rc;\n\ninvalidate_key:\n\tkey_invalidate(sidkey);\n\tgoto out_key_put;\n}\n\nstatic int\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t/*\n\t * FIXME: Here we assume that uid_t and gid_t are same size. It's\n\t * probably a safe assumption but might be better to check based on\n\t * sidtype.\n\t */\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\n\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\n\t/*\n\t * Note that we return 0 here unconditionally. If the mapping\n\t * fails then we just fall back to using the mnt_uid/mnt_gid.\n\t */\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn 0;\n}\n\nint\ninit_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\n\t/* create an override credential set with a special thread keyring in\n\t * which requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nvoid\nexit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}\n\n/* copy ntsd, owner sid, and group sid from a security descriptor to another */\nstatic void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\n\t/* copy security descriptor control portion */\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\n\t/* copy owner sid */\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\n\t/* copy group sid */\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\n\treturn;\n}\n\n\n/*\n   change posix mode to reflect permissions\n   pmode is the existing mode (we only want to overwrite part of this\n   bits to set can be: S_IRWXU, S_IRWXG or S_IRWXO ie 00700 or 00070 or 00007\n*/\nstatic void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}\n\n/*\n   Generate access flags to reflect permissions mode is the existing mode.\n   This function is called for every ACE in the DACL whose SID matches\n   with either owner or group or everyone.\n*/\n\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t__u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/* check for R/W/X UGO since we do not know whose flags\n\t   is this but we have cleared all the bits sans RWX for\n\t   either user or group or other as per bits_to_use */\n\tif (mode & S_IRUGO)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & S_IWUGO)\n\t\t*pace_flags |= SET_FILE_WRITE_RIGHTS;\n\tif (mode & S_IXUGO)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tcifs_dbg(NOISY, \"mode: 0x%x, access flags now 0x%x\\n\",\n\t\t mode, *pace_flags);\n\treturn;\n}\n\nstatic __u16 fill_ace_for_sid(struct cifs_ace *pntace,\n\t\t\tconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = ACCESS_ALLOWED;\n\tpntace->flags = 0x0;\n\tmode_to_access_flags(nmode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}\n\n\n#ifdef CONFIG_CIFS_DEBUG2\nstatic void dump_ace(struct cifs_ace *pace, char *end_of_acl)\n{\n\tint num_subauth;\n\n\t/* validate that we do not go past end of acl */\n\n\tif (le16_to_cpu(pace->size) < 16) {\n\t\tcifs_dbg(VFS, \"ACE too small %d\\n\", le16_to_cpu(pace->size));\n\t\treturn;\n\t}\n\n\tif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse ACE\\n\");\n\t\treturn;\n\t}\n\n\tnum_subauth = pace->sid.num_subauth;\n\tif (num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"ACE revision %d num_auth %d type %d flags %d size %d\\n\",\n\t\t\t pace->sid.revision, pace->sid.num_subauth, pace->type,\n\t\t\t pace->flags, le16_to_cpu(pace->size));\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tcifs_dbg(FYI, \"ACE sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(pace->sid.sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t}\n\n\treturn;\n}\n#endif\n\n\nstatic void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\n\t\t       struct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\t       struct cifs_fattr *fattr)\n{\n\tint i;\n\tint num_aces = 0;\n\tint acl_size;\n\tchar *acl_base;\n\tstruct cifs_ace **ppace;\n\n\t/* BB need to add parm so we can store the SID BB */\n\n\tif (!pdacl) {\n\t\t/* no DACL in the security descriptor, set\n\t\t   all the permissions for user/group/other */\n\t\tfattr->cf_mode |= S_IRWXUGO;\n\t\treturn;\n\t}\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tcifs_dbg(NOISY, \"DACL revision %d size %d num aces %d\\n\",\n\t\t le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t le32_to_cpu(pdacl->num_aces));\n\n\t/* reset rwx permissions for user/group/other.\n\t   Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t   user/group/other have no permissions */\n\tfattr->cf_mode &= ~(S_IRWXUGO);\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct cifs_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces > 0) {\n\t\tumode_t user_mask = S_IRWXU;\n\t\tumode_t group_mask = S_IRWXG;\n\t\tumode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\n\n\t\tif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\n\t\t\treturn;\n\t\tppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ppace)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num_aces; ++i) {\n\t\t\tppace[i] = (struct cifs_ace *) (acl_base + acl_size);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tdump_ace(ppace[i], end_of_acl);\n#endif\n\t\t\tif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &user_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &group_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\n\n/*\t\t\tmemcpy((void *)(&(cifscred->aces[i])),\n\t\t\t\t(void *)ppace[i],\n\t\t\t\tsizeof(struct cifs_ace)); */\n\n\t\t\tacl_base = (char *)ppace[i];\n\t\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\t}\n\n\t\tkfree(ppace);\n\t}\n\n\treturn;\n}\n\n\nstatic int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\n\t\t\tstruct cifs_sid *pgrpsid, __u64 nmode)\n{\n\tu16 size = 0;\n\tstruct cifs_acl *pnndacl;\n\n\tpnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\n\n\tsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\n\t\t\t\t\tpownersid, nmode, S_IRWXU);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\tpgrpsid, nmode, S_IRWXG);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\t &sid_everyone, nmode, S_IRWXO);\n\n\tpndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\n\tpndacl->num_aces = cpu_to_le32(3);\n\n\treturn 0;\n}\n\n\nstatic int parse_sid(struct cifs_sid *psid, char *end_of_acl)\n{\n\t/* BB need to add parm so we can store the SID BB */\n\n\t/* validate that we do not go past end of ACL - sid must be at least 8\n\t   bytes long (assuming no sub-auths - e.g. the null SID */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (psid->num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"SID revision %d num_auth %d\\n\",\n\t\t\t psid->revision, psid->num_subauth);\n\n\t\tfor (i = 0; i < psid->num_subauth; i++) {\n\t\t\tcifs_dbg(FYI, \"SID sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(psid->sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t\tcifs_dbg(FYI, \"RID 0x%x\\n\",\n\t\t\t le32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\n\t}\n#endif\n\n\treturn 0;\n}\n\n\n/* Convert CIFS ACL to POSIX form */\nstatic int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}\n\n/* Convert permission bits from mode to equivalent CIFS ACL */\nstatic int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\n\t__u32 secdesclen, __u64 nmode, kuid_t uid, kgid_t gid, int *aclflag)\n{\n\tint rc = 0;\n\t__u32 dacloffset;\n\t__u32 ndacloffset;\n\t__u32 sidsoffset;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct cifs_acl *dacl_ptr = NULL;  /* no need for SACL ptr */\n\tstruct cifs_acl *ndacl_ptr = NULL; /* no need for SACL ptr */\n\n\tif (nmode != NO_CHANGE_64) { /* chmod */\n\t\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision = dacl_ptr->revision;\n\t\tndacl_ptr->size = 0;\n\t\tndacl_ptr->num_aces = 0;\n\n\t\trc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\n\t\t\t\t\tnmode);\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t/* copy sec desc control portion & owner and group sids */\n\t\tcopy_sec_desc(pntsd, pnntsd, sidsoffset);\n\t\t*aclflag = CIFS_ACL_DACL;\n\t} else {\n\t\tmemcpy(pnntsd, pntsd, secdesclen);\n\t\tif (uid_valid(uid)) { /* chown */\n\t\t\tuid_t id;\n\t\t\towner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->osidoffset));\n\t\t\tnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nowner_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kuid(&init_user_ns, uid);\n\t\t\trc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for owner id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(nowner_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\t\tkfree(nowner_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_OWNER;\n\t\t}\n\t\tif (gid_valid(gid)) { /* chgrp */\n\t\t\tgid_t id;\n\t\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->gsidoffset));\n\t\t\tngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ngroup_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kgid(&init_user_ns, gid);\n\t\t\trc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for group id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_GROUP;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstruct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\tconst struct cifs_fid *cifsfid, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), cifsfid->netfid, &pntsd,\n\t\t\t\tpacllen);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}\n\nstatic struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\tconst char *path, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = READ_CONTROL;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (!rc) {\n\t\trc = CIFSSMBGetCIFSACL(xid, tcon, fid.netfid, &pntsd, pacllen);\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}\n\n/* Retrieve an ACL from the server */\nstruct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}\n\n /* Set an ACL on the server */\nint set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\n\t\t\tstruct inode *inode, const char *path, int aclflag)\n{\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, access_flags, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)\n\t\taccess_flags = WRITE_OWNER;\n\telse\n\t\taccess_flags = WRITE_DAC;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = access_flags;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Unable to open file to set ACL\\n\");\n\t\tgoto out;\n\t}\n\n\trc = CIFSSMBSetCIFSACL(xid, tcon, fid.netfid, pnntsd, acllen, aclflag);\n\tcifs_dbg(NOISY, \"SetCIFSACL rc = %d\\n\", rc);\n\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n/* Translate the CIFS ACL (simlar to NTFS ACL) for a file into mode bits */\nint\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t  struct inode *inode, const char *path,\n\t\t  const struct cifs_fid *pfid)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu32 acllen = 0;\n\tint rc = 0;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(NOISY, \"converting ACL to mode for %s\\n\", path);\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (pfid && (tcon->ses->server->ops->get_acl_by_fid))\n\t\tpntsd = tcon->ses->server->ops->get_acl_by_fid(cifs_sb, pfid,\n\t\t\t\t\t\t\t  &acllen);\n\telse if (tcon->ses->server->ops->get_acl)\n\t\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t\t&acllen);\n\telse {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* if we can retrieve the ACL, now parse Access Control Entries, ACEs */\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t} else {\n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\n\t\tkfree(pntsd);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"parse sec desc failed rc = %d\\n\", rc);\n\t}\n\n\tcifs_put_tlink(tlink);\n\n\treturn rc;\n}\n\n/* Convert mode bits to an ACL so we can update the ACL on the server */\nint\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\n\t\t\tkuid_t uid, kgid_t gid)\n{\n\tint rc = 0;\n\tint aclflag = CIFS_ACL_DACL; /* default flag to set */\n\t__u32 secdesclen = 0;\n\tstruct cifs_ntsd *pntsd = NULL; /* acl obtained from server */\n\tstruct cifs_ntsd *pnntsd = NULL; /* modified acl to be sent to server */\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tcifs_dbg(NOISY, \"set ACL from mode for %s\\n\", path);\n\n\t/* Get the security descriptor */\n\n\tif (tcon->ses->server->ops->get_acl == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t&secdesclen);\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Add three ACEs for owner, group, everyone getting rid of other ACEs\n\t * as chmod disables ACEs and set the security descriptor. Allocate\n\t * memory for the smb header, set security descriptor request security\n\t * descriptor parameters, and secuirty descriptor itself\n\t */\n\tsecdesclen = max_t(u32, secdesclen, DEFAULT_SEC_DESC_LEN);\n\tpnntsd = kmalloc(secdesclen, GFP_KERNEL);\n\tif (!pnntsd) {\n\t\tkfree(pntsd);\n\t\tcifs_put_tlink(tlink);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\n\t\t\t\t&aclflag);\n\n\tcifs_dbg(NOISY, \"build_sec_desc rc: %d\\n\", rc);\n\n\tif (tcon->ses->server->ops->set_acl == NULL)\n\t\trc = -EOPNOTSUPP;\n\n\tif (!rc) {\n\t\t/* Set the security descriptor */\n\t\trc = tcon->ses->server->ops->set_acl(pnntsd, secdesclen, inode,\n\t\t\t\t\t\t     path, aclflag);\n\t\tcifs_dbg(NOISY, \"set_cifs_acl rc: %d\\n\", rc);\n\t}\n\tcifs_put_tlink(tlink);\n\n\tkfree(pnntsd);\n\tkfree(pntsd);\n\treturn rc;\n}\n", "/*\n * fs/nfs/idmap.c\n *\n *  UID and GID to name mapping for clients.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Marius Aamodt Eriksen <marius@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include <linux/types.h>\n#include <linux/parser.h>\n#include <linux/fs.h>\n#include <linux/nfs_idmap.h>\n#include <net/net_namespace.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n\n#include \"internal.h\"\n#include \"netns.h\"\n#include \"nfs4trace.h\"\n\n#define NFS_UINT_MAXLEN 11\n\nstatic const struct cred *id_resolver_cache;\nstatic struct key_type key_type_id_resolver_legacy;\n\nstruct idmap_legacy_upcalldata {\n\tstruct rpc_pipe_msg pipe_msg;\n\tstruct idmap_msg idmap_msg;\n\tstruct key_construction\t*key_cons;\n\tstruct idmap *idmap;\n};\n\nstruct idmap {\n\tstruct rpc_pipe_dir_object idmap_pdo;\n\tstruct rpc_pipe\t\t*idmap_pipe;\n\tstruct idmap_legacy_upcalldata *idmap_upcall_data;\n\tstruct mutex\t\tidmap_mutex;\n};\n\n/**\n * nfs_fattr_init_names - initialise the nfs_fattr owner_name/group_name fields\n * @fattr: fully initialised struct nfs_fattr\n * @owner_name: owner name string cache\n * @group_name: group name string cache\n */\nvoid nfs_fattr_init_names(struct nfs_fattr *fattr,\n\t\tstruct nfs4_string *owner_name,\n\t\tstruct nfs4_string *group_name)\n{\n\tfattr->owner_name = owner_name;\n\tfattr->group_name = group_name;\n}\n\nstatic void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\n\tkfree(fattr->owner_name->data);\n}\n\nstatic void nfs_fattr_free_group_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_GROUP_NAME;\n\tkfree(fattr->group_name->data);\n}\n\nstatic bool nfs_fattr_map_owner_name(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_string *owner = fattr->owner_name;\n\tkuid_t uid;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_OWNER_NAME))\n\t\treturn false;\n\tif (nfs_map_name_to_uid(server, owner->data, owner->len, &uid) == 0) {\n\t\tfattr->uid = uid;\n\t\tfattr->valid |= NFS_ATTR_FATTR_OWNER;\n\t}\n\treturn true;\n}\n\nstatic bool nfs_fattr_map_group_name(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_string *group = fattr->group_name;\n\tkgid_t gid;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_GROUP_NAME))\n\t\treturn false;\n\tif (nfs_map_group_to_gid(server, group->data, group->len, &gid) == 0) {\n\t\tfattr->gid = gid;\n\t\tfattr->valid |= NFS_ATTR_FATTR_GROUP;\n\t}\n\treturn true;\n}\n\n/**\n * nfs_fattr_free_names - free up the NFSv4 owner and group strings\n * @fattr: a fully initialised nfs_fattr structure\n */\nvoid nfs_fattr_free_names(struct nfs_fattr *fattr)\n{\n\tif (fattr->valid & NFS_ATTR_FATTR_OWNER_NAME)\n\t\tnfs_fattr_free_owner_name(fattr);\n\tif (fattr->valid & NFS_ATTR_FATTR_GROUP_NAME)\n\t\tnfs_fattr_free_group_name(fattr);\n}\n\n/**\n * nfs_fattr_map_and_free_names - map owner/group strings into uid/gid and free\n * @server: pointer to the filesystem nfs_server structure\n * @fattr: a fully initialised nfs_fattr structure\n *\n * This helper maps the cached NFSv4 owner/group strings in fattr into\n * their numeric uid/gid equivalents, and then frees the cached strings.\n */\nvoid nfs_fattr_map_and_free_names(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tif (nfs_fattr_map_owner_name(server, fattr))\n\t\tnfs_fattr_free_owner_name(fattr);\n\tif (nfs_fattr_map_group_name(server, fattr))\n\t\tnfs_fattr_free_group_name(fattr);\n}\n\nstatic int nfs_map_string_to_numeric(const char *name, size_t namelen, __u32 *res)\n{\n\tunsigned long val;\n\tchar buf[16];\n\n\tif (memchr(name, '@', namelen) != NULL || namelen >= sizeof(buf))\n\t\treturn 0;\n\tmemcpy(buf, name, namelen);\n\tbuf[namelen] = '\\0';\n\tif (kstrtoul(buf, 0, &val) != 0)\n\t\treturn 0;\n\t*res = val;\n\treturn 1;\n}\n\nstatic int nfs_map_numeric_to_string(__u32 id, char *buf, size_t buflen)\n{\n\treturn snprintf(buf, buflen, \"%u\", id);\n}\n\nstatic struct key_type key_type_id_resolver = {\n\t.name\t\t= \"id_resolver\",\n\t.preparse\t= user_preparse,\n\t.free_preparse\t= user_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match\t\t= user_match,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= user_describe,\n\t.read\t\t= user_read,\n};\n\nstatic int nfs_idmap_init_keyring(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret = 0;\n\n\tprintk(KERN_NOTICE \"NFS: Registering the %s key type\\n\",\n\t\tkey_type_id_resolver.name);\n\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".id_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_id_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\tret = register_key_type(&key_type_id_resolver_legacy);\n\tif (ret < 0)\n\t\tgoto failed_reg_legacy;\n\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tid_resolver_cache = cred;\n\treturn 0;\n\nfailed_reg_legacy:\n\tunregister_key_type(&key_type_id_resolver);\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void nfs_idmap_quit_keyring(void)\n{\n\tkey_revoke(id_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_id_resolver);\n\tunregister_key_type(&key_type_id_resolver_legacy);\n\tput_cred(id_resolver_cache);\n}\n\n/*\n * Assemble the description to pass to request_key()\n * This function will allocate a new string and update dest to point\n * at it.  The caller is responsible for freeing dest.\n *\n * On error 0 is returned.  Otherwise, the length of dest is returned.\n */\nstatic ssize_t nfs_idmap_get_desc(const char *name, size_t namelen,\n\t\t\t\tconst char *type, size_t typelen, char **desc)\n{\n\tchar *cp;\n\tsize_t desclen = typelen + namelen + 2;\n\n\t*desc = kmalloc(desclen, GFP_KERNEL);\n\tif (!*desc)\n\t\treturn -ENOMEM;\n\n\tcp = *desc;\n\tmemcpy(cp, type, typelen);\n\tcp += typelen;\n\t*cp++ = ':';\n\n\tmemcpy(cp, name, namelen);\n\tcp += namelen;\n\t*cp = '\\0';\n\treturn desclen;\n}\n\nstatic struct key *nfs_idmap_request_key(const char *name, size_t namelen,\n\t\t\t\t\t const char *type, struct idmap *idmap)\n{\n\tchar *desc;\n\tstruct key *rkey;\n\tssize_t ret;\n\n\tret = nfs_idmap_get_desc(name, namelen, type, strlen(type), &desc);\n\tif (ret <= 0)\n\t\treturn ERR_PTR(ret);\n\n\trkey = request_key(&key_type_id_resolver, desc, \"\");\n\tif (IS_ERR(rkey)) {\n\t\tmutex_lock(&idmap->idmap_mutex);\n\t\trkey = request_key_with_auxdata(&key_type_id_resolver_legacy,\n\t\t\t\t\t\tdesc, \"\", 0, idmap);\n\t\tmutex_unlock(&idmap->idmap_mutex);\n\t}\n\tif (!IS_ERR(rkey))\n\t\tset_bit(KEY_FLAG_ROOT_CAN_INVAL, &rkey->flags);\n\n\tkfree(desc);\n\treturn rkey;\n}\n\nstatic ssize_t nfs_idmap_get_key(const char *name, size_t namelen,\n\t\t\t\t const char *type, void *data,\n\t\t\t\t size_t data_size, struct idmap *idmap)\n{\n\tconst struct cred *saved_cred;\n\tstruct key *rkey;\n\tstruct user_key_payload *payload;\n\tssize_t ret;\n\n\tsaved_cred = override_creds(id_resolver_cache);\n\trkey = nfs_idmap_request_key(name, namelen, type, idmap);\n\trevert_creds(saved_cred);\n\n\tif (IS_ERR(rkey)) {\n\t\tret = PTR_ERR(rkey);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\trkey->perm |= KEY_USR_VIEW;\n\n\tret = key_validate(rkey);\n\tif (ret < 0)\n\t\tgoto out_up;\n\n\tpayload = rcu_dereference(rkey->payload.rcudata);\n\tif (IS_ERR_OR_NULL(payload)) {\n\t\tret = PTR_ERR(payload);\n\t\tgoto out_up;\n\t}\n\n\tret = payload->datalen;\n\tif (ret > 0 && ret <= data_size)\n\t\tmemcpy(data, payload->data, ret);\n\telse\n\t\tret = -EINVAL;\n\nout_up:\n\trcu_read_unlock();\n\tkey_put(rkey);\nout:\n\treturn ret;\n}\n\n/* ID -> Name */\nstatic ssize_t nfs_idmap_lookup_name(__u32 id, const char *type, char *buf,\n\t\t\t\t     size_t buflen, struct idmap *idmap)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tint id_len;\n\tssize_t ret;\n\n\tid_len = snprintf(id_str, sizeof(id_str), \"%u\", id);\n\tret = nfs_idmap_get_key(id_str, id_len, type, buf, buflen, idmap);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn ret;\n}\n\n/* Name -> ID */\nstatic int nfs_idmap_lookup_id(const char *name, size_t namelen, const char *type,\n\t\t\t       __u32 *id, struct idmap *idmap)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tlong id_long;\n\tssize_t data_size;\n\tint ret = 0;\n\n\tdata_size = nfs_idmap_get_key(name, namelen, type, id_str, NFS_UINT_MAXLEN, idmap);\n\tif (data_size <= 0) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = kstrtol(id_str, 10, &id_long);\n\t\t*id = (__u32)id_long;\n\t}\n\treturn ret;\n}\n\n/* idmap classic begins here */\n\nenum {\n\tOpt_find_uid, Opt_find_gid, Opt_find_user, Opt_find_group, Opt_find_err\n};\n\nstatic const match_table_t nfs_idmap_tokens = {\n\t{ Opt_find_uid, \"uid:%s\" },\n\t{ Opt_find_gid, \"gid:%s\" },\n\t{ Opt_find_user, \"user:%s\" },\n\t{ Opt_find_group, \"group:%s\" },\n\t{ Opt_find_err, NULL }\n};\n\nstatic int nfs_idmap_legacy_upcall(struct key_construction *, const char *, void *);\nstatic ssize_t idmap_pipe_downcall(struct file *, const char __user *,\n\t\t\t\t   size_t);\nstatic void idmap_release_pipe(struct inode *);\nstatic void idmap_pipe_destroy_msg(struct rpc_pipe_msg *);\n\nstatic const struct rpc_pipe_ops idmap_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= idmap_pipe_downcall,\n\t.release_pipe\t= idmap_release_pipe,\n\t.destroy_msg\t= idmap_pipe_destroy_msg,\n};\n\nstatic struct key_type key_type_id_resolver_legacy = {\n\t.name\t\t= \"id_legacy\",\n\t.preparse\t= user_preparse,\n\t.free_preparse\t= user_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match\t\t= user_match,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= user_describe,\n\t.read\t\t= user_read,\n\t.request_key\t= nfs_idmap_legacy_upcall,\n};\n\nstatic void nfs_idmap_pipe_destroy(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct idmap *idmap = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = idmap->idmap_pipe;\n\n\tif (pipe->dentry) {\n\t\trpc_unlink(pipe->dentry);\n\t\tpipe->dentry = NULL;\n\t}\n}\n\nstatic int nfs_idmap_pipe_create(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct idmap *idmap = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = idmap->idmap_pipe;\n\tstruct dentry *dentry;\n\n\tdentry = rpc_mkpipe_dentry(dir, \"idmap\", idmap, pipe);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tpipe->dentry = dentry;\n\treturn 0;\n}\n\nstatic const struct rpc_pipe_dir_object_ops nfs_idmap_pipe_dir_object_ops = {\n\t.create = nfs_idmap_pipe_create,\n\t.destroy = nfs_idmap_pipe_destroy,\n};\n\nint\nnfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\tmutex_init(&idmap->idmap_mutex);\n\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tkfree(idmap);\n\treturn error;\n}\n\nvoid\nnfs_idmap_delete(struct nfs_client *clp)\n{\n\tstruct idmap *idmap = clp->cl_idmap;\n\n\tif (!idmap)\n\t\treturn;\n\tclp->cl_idmap = NULL;\n\trpc_remove_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\n\tkfree(idmap);\n}\n\nint nfs_idmap_init(void)\n{\n\tint ret;\n\tret = nfs_idmap_init_keyring();\n\tif (ret != 0)\n\t\tgoto out;\nout:\n\treturn ret;\n}\n\nvoid nfs_idmap_quit(void)\n{\n\tnfs_idmap_quit_keyring();\n}\n\nstatic int nfs_idmap_prepare_message(char *desc, struct idmap *idmap,\n\t\t\t\t     struct idmap_msg *im,\n\t\t\t\t     struct rpc_pipe_msg *msg)\n{\n\tsubstring_t substr;\n\tint token, ret;\n\n\tim->im_type = IDMAP_TYPE_GROUP;\n\ttoken = match_token(desc, nfs_idmap_tokens, &substr);\n\n\tswitch (token) {\n\tcase Opt_find_uid:\n\t\tim->im_type = IDMAP_TYPE_USER;\n\tcase Opt_find_gid:\n\t\tim->im_conv = IDMAP_CONV_NAMETOID;\n\t\tret = match_strlcpy(im->im_name, &substr, IDMAP_NAMESZ);\n\t\tbreak;\n\n\tcase Opt_find_user:\n\t\tim->im_type = IDMAP_TYPE_USER;\n\tcase Opt_find_group:\n\t\tim->im_conv = IDMAP_CONV_IDTONAME;\n\t\tret = match_int(&substr, &im->im_id);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmsg->data = im;\n\tmsg->len  = sizeof(struct idmap_msg);\n\nout:\n\treturn ret;\n}\n\nstatic bool\nnfs_idmap_prepare_pipe_upcall(struct idmap *idmap,\n\t\tstruct idmap_legacy_upcalldata *data)\n{\n\tif (idmap->idmap_upcall_data != NULL) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\tidmap->idmap_upcall_data = data;\n\treturn true;\n}\n\nstatic void\nnfs_idmap_complete_pipe_upcall_locked(struct idmap *idmap, int ret)\n{\n\tstruct key_construction *cons = idmap->idmap_upcall_data->key_cons;\n\n\tkfree(idmap->idmap_upcall_data);\n\tidmap->idmap_upcall_data = NULL;\n\tcomplete_request_key(cons, ret);\n}\n\nstatic void\nnfs_idmap_abort_pipe_upcall(struct idmap *idmap, int ret)\n{\n\tif (idmap->idmap_upcall_data != NULL)\n\t\tnfs_idmap_complete_pipe_upcall_locked(idmap, ret);\n}\n\nstatic int nfs_idmap_legacy_upcall(struct key_construction *cons,\n\t\t\t\t   const char *op,\n\t\t\t\t   void *aux)\n{\n\tstruct idmap_legacy_upcalldata *data;\n\tstruct rpc_pipe_msg *msg;\n\tstruct idmap_msg *im;\n\tstruct idmap *idmap = (struct idmap *)aux;\n\tstruct key *key = cons->key;\n\tint ret = -ENOMEM;\n\n\t/* msg and im are freed in idmap_pipe_destroy_msg */\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out1;\n\n\tmsg = &data->pipe_msg;\n\tim = &data->idmap_msg;\n\tdata->idmap = idmap;\n\tdata->key_cons = cons;\n\n\tret = nfs_idmap_prepare_message(key->description, idmap, im, msg);\n\tif (ret < 0)\n\t\tgoto out2;\n\n\tret = -EAGAIN;\n\tif (!nfs_idmap_prepare_pipe_upcall(idmap, data))\n\t\tgoto out2;\n\n\tret = rpc_queue_upcall(idmap->idmap_pipe, msg);\n\tif (ret < 0)\n\t\tnfs_idmap_abort_pipe_upcall(idmap, ret);\n\n\treturn ret;\nout2:\n\tkfree(data);\nout1:\n\tcomplete_request_key(cons, ret);\n\treturn ret;\n}\n\nstatic int nfs_idmap_instantiate(struct key *key, struct key *authkey, char *data, size_t datalen)\n{\n\treturn key_instantiate_and_link(key, data, datalen,\n\t\t\t\t\tid_resolver_cache->thread_keyring,\n\t\t\t\t\tauthkey);\n}\n\nstatic int nfs_idmap_read_and_verify_message(struct idmap_msg *im,\n\t\tstruct idmap_msg *upcall,\n\t\tstruct key *key, struct key *authkey)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tsize_t len;\n\tint ret = -ENOKEY;\n\n\t/* ret = -ENOKEY */\n\tif (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)\n\t\tgoto out;\n\tswitch (im->im_conv) {\n\tcase IDMAP_CONV_NAMETOID:\n\t\tif (strcmp(upcall->im_name, im->im_name) != 0)\n\t\t\tbreak;\n\t\t/* Note: here we store the NUL terminator too */\n\t\tlen = sprintf(id_str, \"%d\", im->im_id) + 1;\n\t\tret = nfs_idmap_instantiate(key, authkey, id_str, len);\n\t\tbreak;\n\tcase IDMAP_CONV_IDTONAME:\n\t\tif (upcall->im_id != im->im_id)\n\t\t\tbreak;\n\t\tlen = strlen(im->im_name);\n\t\tret = nfs_idmap_instantiate(key, authkey, im->im_name, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\treturn ret;\n}\n\nstatic ssize_t\nidmap_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct rpc_inode *rpci = RPC_I(file_inode(filp));\n\tstruct idmap *idmap = (struct idmap *)rpci->private;\n\tstruct key_construction *cons;\n\tstruct idmap_msg im;\n\tsize_t namelen_in;\n\tint ret = -ENOKEY;\n\n\t/* If instantiation is successful, anyone waiting for key construction\n\t * will have been woken up and someone else may now have used\n\t * idmap_key_cons - so after this point we may no longer touch it.\n\t */\n\tif (idmap->idmap_upcall_data == NULL)\n\t\tgoto out_noupcall;\n\n\tcons = idmap->idmap_upcall_data->key_cons;\n\n\tif (mlen != sizeof(im)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&im, src, mlen) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!(im.im_status & IDMAP_STATUS_SUCCESS)) {\n\t\tret = -ENOKEY;\n\t\tgoto out;\n\t}\n\n\tnamelen_in = strnlen(im.im_name, IDMAP_NAMESZ);\n\tif (namelen_in == 0 || namelen_in == IDMAP_NAMESZ) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n}\n\n\tret = nfs_idmap_read_and_verify_message(&im,\n\t\t\t&idmap->idmap_upcall_data->idmap_msg,\n\t\t\tcons->key, cons->authkey);\n\tif (ret >= 0) {\n\t\tkey_set_timeout(cons->key, nfs_idmap_cache_timeout);\n\t\tret = mlen;\n\t}\n\nout:\n\tnfs_idmap_complete_pipe_upcall_locked(idmap, ret);\nout_noupcall:\n\treturn ret;\n}\n\nstatic void\nidmap_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct idmap_legacy_upcalldata *data = container_of(msg,\n\t\t\tstruct idmap_legacy_upcalldata,\n\t\t\tpipe_msg);\n\tstruct idmap *idmap = data->idmap;\n\n\tif (msg->errno)\n\t\tnfs_idmap_abort_pipe_upcall(idmap, msg->errno);\n}\n\nstatic void\nidmap_release_pipe(struct inode *inode)\n{\n\tstruct rpc_inode *rpci = RPC_I(inode);\n\tstruct idmap *idmap = (struct idmap *)rpci->private;\n\n\tnfs_idmap_abort_pipe_upcall(idmap, -EPIPE);\n}\n\nint nfs_map_name_to_uid(const struct nfs_server *server, const char *name, size_t namelen, kuid_t *uid)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\t__u32 id = -1;\n\tint ret = 0;\n\n\tif (!nfs_map_string_to_numeric(name, namelen, &id))\n\t\tret = nfs_idmap_lookup_id(name, namelen, \"uid\", &id, idmap);\n\tif (ret == 0) {\n\t\t*uid = make_kuid(&init_user_ns, id);\n\t\tif (!uid_valid(*uid))\n\t\t\tret = -ERANGE;\n\t}\n\ttrace_nfs4_map_name_to_uid(name, namelen, id, ret);\n\treturn ret;\n}\n\nint nfs_map_group_to_gid(const struct nfs_server *server, const char *name, size_t namelen, kgid_t *gid)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\t__u32 id = -1;\n\tint ret = 0;\n\n\tif (!nfs_map_string_to_numeric(name, namelen, &id))\n\t\tret = nfs_idmap_lookup_id(name, namelen, \"gid\", &id, idmap);\n\tif (ret == 0) {\n\t\t*gid = make_kgid(&init_user_ns, id);\n\t\tif (!gid_valid(*gid))\n\t\t\tret = -ERANGE;\n\t}\n\ttrace_nfs4_map_group_to_gid(name, namelen, id, ret);\n\treturn ret;\n}\n\nint nfs_map_uid_to_name(const struct nfs_server *server, kuid_t uid, char *buf, size_t buflen)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\tint ret = -EINVAL;\n\t__u32 id;\n\n\tid = from_kuid(&init_user_ns, uid);\n\tif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\n\t\tret = nfs_idmap_lookup_name(id, \"user\", buf, buflen, idmap);\n\tif (ret < 0)\n\t\tret = nfs_map_numeric_to_string(id, buf, buflen);\n\ttrace_nfs4_map_uid_to_name(buf, ret, id, ret);\n\treturn ret;\n}\nint nfs_map_gid_to_group(const struct nfs_server *server, kgid_t gid, char *buf, size_t buflen)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\tint ret = -EINVAL;\n\t__u32 id;\n\n\tid = from_kgid(&init_user_ns, gid);\n\tif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\n\t\tret = nfs_idmap_lookup_name(id, \"group\", buf, buflen, idmap);\n\tif (ret < 0)\n\t\tret = nfs_map_numeric_to_string(id, buf, buflen);\n\ttrace_nfs4_map_gid_to_group(buf, ret, id, ret);\n\treturn ret;\n}\n", "/* user-type.h: User-defined key type\n *\n * Copyright (C) 2005 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#ifndef _KEYS_USER_TYPE_H\n#define _KEYS_USER_TYPE_H\n\n#include <linux/key.h>\n#include <linux/rcupdate.h>\n\n/*****************************************************************************/\n/*\n * the payload for a key of type \"user\" or \"logon\"\n * - once filled in and attached to a key:\n *   - the payload struct is invariant may not be changed, only replaced\n *   - the payload must be read with RCU procedures or with the key semaphore\n *     held\n *   - the payload may only be replaced with the key semaphore write-locked\n * - the key's data length is the size of the actual data, not including the\n *   payload wrapper\n */\nstruct user_key_payload {\n\tstruct rcu_head\trcu;\t\t/* RCU destructor */\n\tunsigned short\tdatalen;\t/* length of this data */\n\tchar\t\tdata[0];\t/* actual data */\n};\n\nextern struct key_type key_type_user;\nextern struct key_type key_type_logon;\n\nstruct key_preparsed_payload;\nstruct key_match_data;\n\nextern int user_preparse(struct key_preparsed_payload *prep);\nextern void user_free_preparse(struct key_preparsed_payload *prep);\nextern int user_update(struct key *key, struct key_preparsed_payload *prep);\nextern int user_match(const struct key *key,\n\t\t      const struct key_match_data *match_data);\nextern void user_revoke(struct key *key);\nextern void user_destroy(struct key *key);\nextern void user_describe(const struct key *user, struct seq_file *m);\nextern long user_read(const struct key *key,\n\t\t      char __user *buffer, size_t buflen);\n\n\n#endif /* _KEYS_USER_TYPE_H */\n", "/* Definitions for key type implementations\n *\n * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#ifndef _LINUX_KEY_TYPE_H\n#define _LINUX_KEY_TYPE_H\n\n#include <linux/key.h>\n#include <linux/errno.h>\n\n#ifdef CONFIG_KEYS\n\n/*\n * key under-construction record\n * - passed to the request_key actor if supplied\n */\nstruct key_construction {\n\tstruct key\t*key;\t/* key being constructed */\n\tstruct key\t*authkey;/* authorisation for key being constructed */\n};\n\n/*\n * Pre-parsed payload, used by key add, update and instantiate.\n *\n * This struct will be cleared and data and datalen will be set with the data\n * and length parameters from the caller and quotalen will be set from\n * def_datalen from the key type.  Then if the preparse() op is provided by the\n * key type, that will be called.  Then the struct will be passed to the\n * instantiate() or the update() op.\n *\n * If the preparse() op is given, the free_preparse() op will be called to\n * clear the contents.\n */\nstruct key_preparsed_payload {\n\tchar\t\t*description;\t/* Proposed key description (or NULL) */\n\tvoid\t\t*type_data[2];\t/* Private key-type data */\n\tvoid\t\t*payload[2];\t/* Proposed payload */\n\tconst void\t*data;\t\t/* Raw data */\n\tsize_t\t\tdatalen;\t/* Raw datalen */\n\tsize_t\t\tquotalen;\t/* Quota length for proposed payload */\n\ttime_t\t\texpiry;\t\t/* Expiry time of key */\n\tbool\t\ttrusted;\t/* True if key is trusted */\n};\n\ntypedef int (*request_key_actor_t)(struct key_construction *key,\n\t\t\t\t   const char *op, void *aux);\n\n/*\n * Preparsed matching criterion.\n */\nstruct key_match_data {\n\t/* Comparison function, defaults to type->match, but can be replaced by\n\t * type->match_preparse(). */\n\tint (*cmp)(const struct key *key,\n\t\t   const struct key_match_data *match_data);\n\n\tconst void\t*raw_data;\t/* Raw match data */\n\tvoid\t\t*preparsed;\t/* For ->match_preparse() to stash stuff */\n\tunsigned\tlookup_type;\t/* Type of lookup for this search. */\n#define KEYRING_SEARCH_LOOKUP_DIRECT\t0x0000\t/* Direct lookup by description. */\n#define KEYRING_SEARCH_LOOKUP_ITERATE\t0x0001\t/* Iterative search. */\n};\n\n/*\n * kernel managed key type definition\n */\nstruct key_type {\n\t/* name of the type */\n\tconst char *name;\n\n\t/* default payload length for quota precalculation (optional)\n\t * - this can be used instead of calling key_payload_reserve(), that\n\t *   function only needs to be called if the real datalen is different\n\t */\n\tsize_t def_datalen;\n\n\t/* vet a description */\n\tint (*vet_description)(const char *description);\n\n\t/* Preparse the data blob from userspace that is to be the payload,\n\t * generating a proposed description and payload that will be handed to\n\t * the instantiate() and update() ops.\n\t */\n\tint (*preparse)(struct key_preparsed_payload *prep);\n\n\t/* Free a preparse data structure.\n\t */\n\tvoid (*free_preparse)(struct key_preparsed_payload *prep);\n\n\t/* instantiate a key of this type\n\t * - this method should call key_payload_reserve() to determine if the\n\t *   user's quota will hold the payload\n\t */\n\tint (*instantiate)(struct key *key, struct key_preparsed_payload *prep);\n\n\t/* update a key of this type (optional)\n\t * - this method should call key_payload_reserve() to recalculate the\n\t *   quota consumption\n\t * - the key must be locked against read when modifying\n\t */\n\tint (*update)(struct key *key, struct key_preparsed_payload *prep);\n\n\t/* Preparse the data supplied to ->match() (optional).  The\n\t * data to be preparsed can be found in match_data->raw_data.\n\t * The lookup type can also be set by this function.\n\t */\n\tint (*match_preparse)(struct key_match_data *match_data);\n\n\t/* match a key against a description */\n\tint (*match)(const struct key *key,\n\t\t     const struct key_match_data *match_data);\n\n\t/* Free preparsed match data (optional).  This should be supplied it\n\t * ->match_preparse() is supplied. */\n\tvoid (*match_free)(struct key_match_data *match_data);\n\n\t/* clear some of the data from a key on revokation (optional)\n\t * - the key's semaphore will be write-locked by the caller\n\t */\n\tvoid (*revoke)(struct key *key);\n\n\t/* clear the data from a key (optional) */\n\tvoid (*destroy)(struct key *key);\n\n\t/* describe a key */\n\tvoid (*describe)(const struct key *key, struct seq_file *p);\n\n\t/* read a key's data (optional)\n\t * - permission checks will be done by the caller\n\t * - the key's semaphore will be readlocked by the caller\n\t * - should return the amount of data that could be read, no matter how\n\t *   much is copied into the buffer\n\t * - shouldn't do the copy if the buffer is NULL\n\t */\n\tlong (*read)(const struct key *key, char __user *buffer, size_t buflen);\n\n\t/* handle request_key() for this type instead of invoking\n\t * /sbin/request-key (optional)\n\t * - key is the key to instantiate\n\t * - authkey is the authority to assume when instantiating this key\n\t * - op is the operation to be done, usually \"create\"\n\t * - the call must not return until the instantiation process has run\n\t *   its course\n\t */\n\trequest_key_actor_t request_key;\n\n\t/* internal fields */\n\tstruct list_head\tlink;\t\t/* link in types list */\n\tstruct lock_class_key\tlock_class;\t/* key->sem lock class */\n};\n\nextern struct key_type key_type_keyring;\n\nextern int register_key_type(struct key_type *ktype);\nextern void unregister_key_type(struct key_type *ktype);\n\nextern int key_payload_reserve(struct key *key, size_t datalen);\nextern int key_instantiate_and_link(struct key *key,\n\t\t\t\t    const void *data,\n\t\t\t\t    size_t datalen,\n\t\t\t\t    struct key *keyring,\n\t\t\t\t    struct key *instkey);\nextern int key_reject_and_link(struct key *key,\n\t\t\t       unsigned timeout,\n\t\t\t       unsigned error,\n\t\t\t       struct key *keyring,\n\t\t\t       struct key *instkey);\nextern void complete_request_key(struct key_construction *cons, int error);\n\nstatic inline int key_negate_and_link(struct key *key,\n\t\t\t\t      unsigned timeout,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *instkey)\n{\n\treturn key_reject_and_link(key, timeout, ENOKEY, keyring, instkey);\n}\n\nextern int generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep);\n\n#endif /* CONFIG_KEYS */\n#endif /* _LINUX_KEY_TYPE_H */\n", "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <crypto/hash.h>\n#include <linux/key-type.h>\n\n#include <keys/ceph-type.h>\n#include <keys/user-type.h>\n#include <linux/ceph/decode.h>\n#include \"crypto.h\"\n\nint ceph_crypto_key_clone(struct ceph_crypto_key *dst,\n\t\t\t  const struct ceph_crypto_key *src)\n{\n\tmemcpy(dst, src, sizeof(struct ceph_crypto_key));\n\tdst->key = kmemdup(src->key, src->len, GFP_NOFS);\n\tif (!dst->key)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint ceph_crypto_key_encode(struct ceph_crypto_key *key, void **p, void *end)\n{\n\tif (*p + sizeof(u16) + sizeof(key->created) +\n\t    sizeof(u16) + key->len > end)\n\t\treturn -ERANGE;\n\tceph_encode_16(p, key->type);\n\tceph_encode_copy(p, &key->created, sizeof(key->created));\n\tceph_encode_16(p, key->len);\n\tceph_encode_copy(p, key->key, key->len);\n\treturn 0;\n}\n\nint ceph_crypto_key_decode(struct ceph_crypto_key *key, void **p, void *end)\n{\n\tceph_decode_need(p, end, 2*sizeof(u16) + sizeof(key->created), bad);\n\tkey->type = ceph_decode_16(p);\n\tceph_decode_copy(p, &key->created, sizeof(key->created));\n\tkey->len = ceph_decode_16(p);\n\tceph_decode_need(p, end, key->len, bad);\n\tkey->key = kmalloc(key->len, GFP_NOFS);\n\tif (!key->key)\n\t\treturn -ENOMEM;\n\tceph_decode_copy(p, key->key, key->len);\n\treturn 0;\n\nbad:\n\tdout(\"failed to decode crypto key\\n\");\n\treturn -EINVAL;\n}\n\nint ceph_crypto_key_unarmor(struct ceph_crypto_key *key, const char *inkey)\n{\n\tint inlen = strlen(inkey);\n\tint blen = inlen * 3 / 4;\n\tvoid *buf, *p;\n\tint ret;\n\n\tdout(\"crypto_key_unarmor %s\\n\", inkey);\n\tbuf = kmalloc(blen, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tblen = ceph_unarmor(buf, inkey, inkey+inlen);\n\tif (blen < 0) {\n\t\tkfree(buf);\n\t\treturn blen;\n\t}\n\n\tp = buf;\n\tret = ceph_crypto_key_decode(key, &p, p + blen);\n\tkfree(buf);\n\tif (ret)\n\t\treturn ret;\n\tdout(\"crypto_key_unarmor key %p type %d len %d\\n\", key,\n\t     key->type, key->len);\n\treturn 0;\n}\n\n\n\n#define AES_KEY_SIZE 16\n\nstatic struct crypto_blkcipher *ceph_crypto_alloc_cipher(void)\n{\n\treturn crypto_alloc_blkcipher(\"cbc(aes)\", 0, CRYPTO_ALG_ASYNC);\n}\n\nstatic const u8 *aes_iv = (u8 *)CEPH_AES_IV;\n\nstatic int ceph_aes_encrypt(const void *key, int key_len,\n\t\t\t    void *dst, size_t *dst_len,\n\t\t\t    const void *src, size_t src_len)\n{\n\tstruct scatterlist sg_in[2], sg_out[1];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm, .flags = 0 };\n\tint ret;\n\tvoid *iv;\n\tint ivsize;\n\tsize_t zero_padding = (0x10 - (src_len & 0x0f));\n\tchar pad[16];\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tmemset(pad, zero_padding, zero_padding);\n\n\t*dst_len = src_len + zero_padding;\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], src, src_len);\n\tsg_set_buf(&sg_in[1], pad, zero_padding);\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, dst, *dst_len);\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc src: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tsrc, src_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc pad: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tpad, zero_padding, 1);\n\t*/\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in,\n\t\t\t\t     src_len + zero_padding);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"ceph_aes_crypt failed %d\\n\", ret);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc out: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst, *dst_len, 1);\n\t*/\n\treturn 0;\n}\n\nstatic int ceph_aes_encrypt2(const void *key, int key_len, void *dst,\n\t\t\t     size_t *dst_len,\n\t\t\t     const void *src1, size_t src1_len,\n\t\t\t     const void *src2, size_t src2_len)\n{\n\tstruct scatterlist sg_in[3], sg_out[1];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm, .flags = 0 };\n\tint ret;\n\tvoid *iv;\n\tint ivsize;\n\tsize_t zero_padding = (0x10 - ((src1_len + src2_len) & 0x0f));\n\tchar pad[16];\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tmemset(pad, zero_padding, zero_padding);\n\n\t*dst_len = src1_len + src2_len + zero_padding;\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tsg_init_table(sg_in, 3);\n\tsg_set_buf(&sg_in[0], src1, src1_len);\n\tsg_set_buf(&sg_in[1], src2, src2_len);\n\tsg_set_buf(&sg_in[2], pad, zero_padding);\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, dst, *dst_len);\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc  key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc src1: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tsrc1, src1_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc src2: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tsrc2, src2_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc  pad: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tpad, zero_padding, 1);\n\t*/\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in,\n\t\t\t\t     src1_len + src2_len + zero_padding);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"ceph_aes_crypt2 failed %d\\n\", ret);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc  out: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst, *dst_len, 1);\n\t*/\n\treturn 0;\n}\n\nstatic int ceph_aes_decrypt(const void *key, int key_len,\n\t\t\t    void *dst, size_t *dst_len,\n\t\t\t    const void *src, size_t src_len)\n{\n\tstruct scatterlist sg_in[1], sg_out[2];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm };\n\tchar pad[16];\n\tvoid *iv;\n\tint ivsize;\n\tint ret;\n\tint last_byte;\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, src, src_len);\n\tsg_set_buf(&sg_out[0], dst, *dst_len);\n\tsg_set_buf(&sg_out[1], pad, sizeof(pad));\n\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"dec  in: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       src, src_len, 1);\n\t*/\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, src_len);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0) {\n\t\tpr_err(\"ceph_aes_decrypt failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (src_len <= *dst_len)\n\t\tlast_byte = ((char *)dst)[src_len - 1];\n\telse\n\t\tlast_byte = pad[src_len - *dst_len - 1];\n\tif (last_byte <= 16 && src_len >= last_byte) {\n\t\t*dst_len = src_len - last_byte;\n\t} else {\n\t\tpr_err(\"ceph_aes_decrypt got bad padding %d on src len %d\\n\",\n\t\t       last_byte, (int)src_len);\n\t\treturn -EPERM;  /* bad padding */\n\t}\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec out: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst, *dst_len, 1);\n\t*/\n\treturn 0;\n}\n\nstatic int ceph_aes_decrypt2(const void *key, int key_len,\n\t\t\t     void *dst1, size_t *dst1_len,\n\t\t\t     void *dst2, size_t *dst2_len,\n\t\t\t     const void *src, size_t src_len)\n{\n\tstruct scatterlist sg_in[1], sg_out[3];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm };\n\tchar pad[16];\n\tvoid *iv;\n\tint ivsize;\n\tint ret;\n\tint last_byte;\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tsg_init_table(sg_in, 1);\n\tsg_set_buf(sg_in, src, src_len);\n\tsg_init_table(sg_out, 3);\n\tsg_set_buf(&sg_out[0], dst1, *dst1_len);\n\tsg_set_buf(&sg_out[1], dst2, *dst2_len);\n\tsg_set_buf(&sg_out[2], pad, sizeof(pad));\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec  key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"dec   in: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       src, src_len, 1);\n\t*/\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, src_len);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0) {\n\t\tpr_err(\"ceph_aes_decrypt failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (src_len <= *dst1_len)\n\t\tlast_byte = ((char *)dst1)[src_len - 1];\n\telse if (src_len <= *dst1_len + *dst2_len)\n\t\tlast_byte = ((char *)dst2)[src_len - *dst1_len - 1];\n\telse\n\t\tlast_byte = pad[src_len - *dst1_len - *dst2_len - 1];\n\tif (last_byte <= 16 && src_len >= last_byte) {\n\t\tsrc_len -= last_byte;\n\t} else {\n\t\tpr_err(\"ceph_aes_decrypt got bad padding %d on src len %d\\n\",\n\t\t       last_byte, (int)src_len);\n\t\treturn -EPERM;  /* bad padding */\n\t}\n\n\tif (src_len < *dst1_len) {\n\t\t*dst1_len = src_len;\n\t\t*dst2_len = 0;\n\t} else {\n\t\t*dst2_len = src_len - *dst1_len;\n\t}\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec  out1: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst1, *dst1_len, 1);\n\tprint_hex_dump(KERN_ERR, \"dec  out2: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst2, *dst2_len, 1);\n\t*/\n\n\treturn 0;\n}\n\n\nint ceph_decrypt(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n\t\t const void *src, size_t src_len)\n{\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst_len < src_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(dst, src, src_len);\n\t\t*dst_len = src_len;\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_decrypt(secret->key, secret->len, dst,\n\t\t\t\t\tdst_len, src, src_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint ceph_decrypt2(struct ceph_crypto_key *secret,\n\t\t\tvoid *dst1, size_t *dst1_len,\n\t\t\tvoid *dst2, size_t *dst2_len,\n\t\t\tconst void *src, size_t src_len)\n{\n\tsize_t t;\n\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst1_len + *dst2_len < src_len)\n\t\t\treturn -ERANGE;\n\t\tt = min(*dst1_len, src_len);\n\t\tmemcpy(dst1, src, t);\n\t\t*dst1_len = t;\n\t\tsrc += t;\n\t\tsrc_len -= t;\n\t\tif (src_len) {\n\t\t\tt = min(*dst2_len, src_len);\n\t\t\tmemcpy(dst2, src, t);\n\t\t\t*dst2_len = t;\n\t\t}\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_decrypt2(secret->key, secret->len,\n\t\t\t\t\t dst1, dst1_len, dst2, dst2_len,\n\t\t\t\t\t src, src_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint ceph_encrypt(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n\t\t const void *src, size_t src_len)\n{\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst_len < src_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(dst, src, src_len);\n\t\t*dst_len = src_len;\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_encrypt(secret->key, secret->len, dst,\n\t\t\t\t\tdst_len, src, src_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint ceph_encrypt2(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n\t\t  const void *src1, size_t src1_len,\n\t\t  const void *src2, size_t src2_len)\n{\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst_len < src1_len + src2_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(dst, src1, src1_len);\n\t\tmemcpy(dst + src1_len, src2, src2_len);\n\t\t*dst_len = src1_len + src2_len;\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_encrypt2(secret->key, secret->len, dst, dst_len,\n\t\t\t\t\t src1, src1_len, src2, src2_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ceph_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\tvoid *p;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tckey = kmalloc(sizeof(*ckey), GFP_KERNEL);\n\tif (!ckey)\n\t\tgoto err;\n\n\t/* TODO ceph_crypto_key_decode should really take const input */\n\tp = (void *)prep->data;\n\tret = ceph_crypto_key_decode(ckey, &p, (char*)prep->data+datalen);\n\tif (ret < 0)\n\t\tgoto err_ckey;\n\n\tprep->payload[0] = ckey;\n\tprep->quotalen = datalen;\n\treturn 0;\n\nerr_ckey:\n\tkfree(ckey);\nerr:\n\treturn ret;\n}\n\nstatic void ceph_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey = prep->payload[0];\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n\nstatic void ceph_key_destroy(struct key *key)\n{\n\tstruct ceph_crypto_key *ckey = key->payload.data;\n\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n\nstruct key_type key_type_ceph = {\n\t.name\t\t= \"ceph\",\n\t.preparse\t= ceph_key_preparse,\n\t.free_preparse\t= ceph_key_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match\t\t= user_match,\n\t.destroy\t= ceph_key_destroy,\n};\n\nint ceph_crypto_init(void) {\n\treturn register_key_type(&key_type_ceph);\n}\n\nvoid ceph_crypto_shutdown(void) {\n\tunregister_key_type(&key_type_ceph);\n}\n", "/* Key type used to cache DNS lookups made by the kernel\n *\n * See Documentation/networking/dns_resolver.txt\n *\n *   Copyright (c) 2007 Igor Mammedov\n *   Author(s): Igor Mammedov (niallain@gmail.com)\n *              Steve French (sfrench@us.ibm.com)\n *              Wang Lei (wang840925@gmail.com)\n *\t\tDavid Howells (dhowells@redhat.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/keyctl.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <keys/dns_resolver-type.h>\n#include <keys/user-type.h>\n#include \"internal.h\"\n\nMODULE_DESCRIPTION(\"DNS Resolver\");\nMODULE_AUTHOR(\"Wang Lei\");\nMODULE_LICENSE(\"GPL\");\n\nunsigned int dns_resolver_debug;\nmodule_param_named(debug, dns_resolver_debug, uint, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(debug, \"DNS Resolver debugging mask\");\n\nconst struct cred *dns_resolver_cache;\n\n#define\tDNS_ERRORNO_OPTION\t\"dnserror\"\n\n/*\n * Preparse instantiation data for a dns_resolver key.\n *\n * The data must be a NUL-terminated string, with the NUL char accounted in\n * datalen.\n *\n * If the data contains a '#' characters, then we take the clause after each\n * one to be an option of the form 'key=value'.  The actual data of interest is\n * the string leading up to the first '#'.  For instance:\n *\n *        \"ip1,ip2,...#foo=bar\"\n */\nstatic int\ndns_resolver_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tunsigned long derrno;\n\tint ret;\n\tint datalen = prep->datalen, result_len = 0;\n\tconst char *data = prep->data, *end, *opt;\n\n\tkenter(\"'%*.*s',%u\", datalen, datalen, data, datalen);\n\n\tif (datalen <= 1 || !data || data[datalen - 1] != '\\0')\n\t\treturn -EINVAL;\n\tdatalen--;\n\n\t/* deal with any options embedded in the data */\n\tend = data + datalen;\n\topt = memchr(data, '#', datalen);\n\tif (!opt) {\n\t\t/* no options: the entire data is the result */\n\t\tkdebug(\"no options\");\n\t\tresult_len = datalen;\n\t} else {\n\t\tconst char *next_opt;\n\n\t\tresult_len = opt - data;\n\t\topt++;\n\t\tkdebug(\"options: '%s'\", opt);\n\t\tdo {\n\t\t\tconst char *eq;\n\t\t\tint opt_len, opt_nlen, opt_vlen, tmp;\n\n\t\t\tnext_opt = memchr(opt, '#', end - opt) ?: end;\n\t\t\topt_len = next_opt - opt;\n\t\t\tif (!opt_len) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"Empty option to dns_resolver key\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\teq = memchr(opt, '=', opt_len) ?: end;\n\t\t\topt_nlen = eq - opt;\n\t\t\teq++;\n\t\t\topt_vlen = next_opt - eq; /* will be -1 if no value */\n\n\t\t\ttmp = opt_vlen >= 0 ? opt_vlen : 0;\n\t\t\tkdebug(\"option '%*.*s' val '%*.*s'\",\n\t\t\t       opt_nlen, opt_nlen, opt, tmp, tmp, eq);\n\n\t\t\t/* see if it's an error number representing a DNS error\n\t\t\t * that's to be recorded as the result in this key */\n\t\t\tif (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&\n\t\t\t    memcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {\n\t\t\t\tkdebug(\"dns error number option\");\n\t\t\t\tif (opt_vlen <= 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tret = kstrtoul(eq, 10, &derrno);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tif (derrno < 1 || derrno > 511)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tkdebug(\"dns error no. = %lu\", derrno);\n\t\t\t\tprep->type_data[0] = ERR_PTR(-derrno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tbad_option_value:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"Option '%*.*s' to dns_resolver key:\"\n\t\t\t       \" bad/missing value\\n\",\n\t\t\t       opt_nlen, opt_nlen, opt);\n\t\t\treturn -EINVAL;\n\t\t} while (opt = next_opt + 1, opt < end);\n\t}\n\n\t/* don't cache the result if we're caching an error saying there's no\n\t * result */\n\tif (prep->type_data[0]) {\n\t\tkleave(\" = 0 [h_error %ld]\", PTR_ERR(prep->type_data[0]));\n\t\treturn 0;\n\t}\n\n\tkdebug(\"store result\");\n\tprep->quotalen = result_len;\n\n\tupayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);\n\tif (!upayload) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tupayload->datalen = result_len;\n\tmemcpy(upayload->data, data, result_len);\n\tupayload->data[result_len] = '\\0';\n\n\tprep->payload[0] = upayload;\n\tkleave(\" = 0\");\n\treturn 0;\n}\n\n/*\n * Clean up the preparse data\n */\nstatic void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n{\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tkfree(prep->payload[0]);\n}\n\n/*\n * The description is of the form \"[<type>:]<domain_name>\"\n *\n * The domain name may be a simple name or an absolute domain name (which\n * should end with a period).  The domain name is case-independent.\n */\nstatic int\ndns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Describe a DNS key\n */\nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tint err = key->type_data.x[0];\n\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n\n/*\n * read the DNS data\n * - the key's semaphore is read-locked\n */\nstatic long dns_resolver_read(const struct key *key,\n\t\t\t      char __user *buffer, size_t buflen)\n{\n\tif (key->type_data.x[0])\n\t\treturn key->type_data.x[0];\n\n\treturn user_read(key, buffer, buflen);\n}\n\nstruct key_type key_type_dns_resolver = {\n\t.name\t\t= \"dns_resolver\",\n\t.preparse\t= dns_resolver_preparse,\n\t.free_preparse\t= dns_resolver_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match\t\t= dns_resolver_match,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= dns_resolver_describe,\n\t.read\t\t= dns_resolver_read,\n};\n\nstatic int __init init_dns_resolver(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\t/* create an override credential set with a special thread keyring in\n\t * which DNS requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".dns_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_dns_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tdns_resolver_cache = cred;\n\n\tkdebug(\"DNS resolver keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void __exit exit_dns_resolver(void)\n{\n\tkey_revoke(dns_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_dns_resolver);\n\tput_cred(dns_resolver_cache);\n}\n\nmodule_init(init_dns_resolver)\nmodule_exit(exit_dns_resolver)\nMODULE_LICENSE(\"GPL\");\n\n", "/* RxRPC key management\n *\n * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * RxRPC keys should have a description of describing their purpose:\n *\t\"afs@CAMBRIDGE.REDHAT.COM>\n */\n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/key-type.h>\n#include <linux/crypto.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <keys/rxrpc-type.h>\n#include <keys/user-type.h>\n#include \"ar-internal.h\"\n\nstatic int rxrpc_vet_description_s(const char *);\nstatic int rxrpc_preparse(struct key_preparsed_payload *);\nstatic int rxrpc_preparse_s(struct key_preparsed_payload *);\nstatic void rxrpc_free_preparse(struct key_preparsed_payload *);\nstatic void rxrpc_free_preparse_s(struct key_preparsed_payload *);\nstatic void rxrpc_destroy(struct key *);\nstatic void rxrpc_destroy_s(struct key *);\nstatic void rxrpc_describe(const struct key *, struct seq_file *);\nstatic long rxrpc_read(const struct key *, char __user *, size_t);\n\n/*\n * rxrpc defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_rxrpc = {\n\t.name\t\t= \"rxrpc\",\n\t.preparse\t= rxrpc_preparse,\n\t.free_preparse\t= rxrpc_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match\t\t= user_match,\n\t.destroy\t= rxrpc_destroy,\n\t.describe\t= rxrpc_describe,\n\t.read\t\t= rxrpc_read,\n};\nEXPORT_SYMBOL(key_type_rxrpc);\n\n/*\n * rxrpc server defined keys take \"<serviceId>:<securityIndex>\" as the\n * description and an 8-byte decryption key as the payload\n */\nstruct key_type key_type_rxrpc_s = {\n\t.name\t\t= \"rxrpc_s\",\n\t.vet_description = rxrpc_vet_description_s,\n\t.preparse\t= rxrpc_preparse_s,\n\t.free_preparse\t= rxrpc_free_preparse_s,\n\t.instantiate\t= generic_key_instantiate,\n\t.match\t\t= user_match,\n\t.destroy\t= rxrpc_destroy_s,\n\t.describe\t= rxrpc_describe,\n};\n\n/*\n * Vet the description for an RxRPC server key\n */\nstatic int rxrpc_vet_description_s(const char *desc)\n{\n\tunsigned long num;\n\tchar *p;\n\n\tnum = simple_strtoul(desc, &p, 10);\n\tif (*p != ':' || num > 65535)\n\t\treturn -EINVAL;\n\tnum = simple_strtoul(p + 1, &p, 10);\n\tif (*p || num < 1 || num > 255)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n/*\n * parse an RxKAD type XDR format token\n * - the caller guarantees we have at least 4 words\n */\nstatic int rxrpc_preparse_xdr_rxkad(struct key_preparsed_payload *prep,\n\t\t\t\t    size_t datalen,\n\t\t\t\t    const __be32 *xdr, unsigned int toklen)\n{\n\tstruct rxrpc_key_token *token, **pptoken;\n\tsize_t plen;\n\tu32 tktlen;\n\n\t_enter(\",{%x,%x,%x,%x},%u\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       toklen);\n\n\tif (toklen <= 8 * 4)\n\t\treturn -EKEYREJECTED;\n\ttktlen = ntohl(xdr[7]);\n\t_debug(\"tktlen: %x\", tktlen);\n\tif (tktlen > AFSTOKEN_RK_TIX_MAX)\n\t\treturn -EKEYREJECTED;\n\tif (toklen < 8 * 4 + tktlen)\n\t\treturn -EKEYREJECTED;\n\n\tplen = sizeof(*token) + sizeof(*token->kad) + tktlen;\n\tprep->quotalen = datalen + plen;\n\n\tplen -= sizeof(*token);\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\treturn -ENOMEM;\n\n\ttoken->kad = kzalloc(plen, GFP_KERNEL);\n\tif (!token->kad) {\n\t\tkfree(token);\n\t\treturn -ENOMEM;\n\t}\n\n\ttoken->security_index\t= RXRPC_SECURITY_RXKAD;\n\ttoken->kad->ticket_len\t= tktlen;\n\ttoken->kad->vice_id\t= ntohl(xdr[0]);\n\ttoken->kad->kvno\t= ntohl(xdr[1]);\n\ttoken->kad->start\t= ntohl(xdr[4]);\n\ttoken->kad->expiry\t= ntohl(xdr[5]);\n\ttoken->kad->primary_flag = ntohl(xdr[6]);\n\tmemcpy(&token->kad->session_key, &xdr[2], 8);\n\tmemcpy(&token->kad->ticket, &xdr[8], tktlen);\n\n\t_debug(\"SCIX: %u\", token->security_index);\n\t_debug(\"TLEN: %u\", token->kad->ticket_len);\n\t_debug(\"EXPY: %x\", token->kad->expiry);\n\t_debug(\"KVNO: %u\", token->kad->kvno);\n\t_debug(\"PRIM: %u\", token->kad->primary_flag);\n\t_debug(\"SKEY: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t       token->kad->session_key[0], token->kad->session_key[1],\n\t       token->kad->session_key[2], token->kad->session_key[3],\n\t       token->kad->session_key[4], token->kad->session_key[5],\n\t       token->kad->session_key[6], token->kad->session_key[7]);\n\tif (token->kad->ticket_len >= 8)\n\t\t_debug(\"TCKT: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t\t       token->kad->ticket[0], token->kad->ticket[1],\n\t\t       token->kad->ticket[2], token->kad->ticket[3],\n\t\t       token->kad->ticket[4], token->kad->ticket[5],\n\t\t       token->kad->ticket[6], token->kad->ticket[7]);\n\n\t/* count the number of tokens attached */\n\tprep->type_data[0] = (void *)((unsigned long)prep->type_data[0] + 1);\n\n\t/* attach the data */\n\tfor (pptoken = (struct rxrpc_key_token **)&prep->payload[0];\n\t     *pptoken;\n\t     pptoken = &(*pptoken)->next)\n\t\tcontinue;\n\t*pptoken = token;\n\tif (token->kad->expiry < prep->expiry)\n\t\tprep->expiry = token->kad->expiry;\n\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\nstatic void rxrpc_free_krb5_principal(struct krb5_principal *princ)\n{\n\tint loop;\n\n\tif (princ->name_parts) {\n\t\tfor (loop = princ->n_name_parts - 1; loop >= 0; loop--)\n\t\t\tkfree(princ->name_parts[loop]);\n\t\tkfree(princ->name_parts);\n\t}\n\tkfree(princ->realm);\n}\n\nstatic void rxrpc_free_krb5_tagged(struct krb5_tagged_data *td)\n{\n\tkfree(td->data);\n}\n\n/*\n * free up an RxK5 token\n */\nstatic void rxrpc_rxk5_free(struct rxk5_key *rxk5)\n{\n\tint loop;\n\n\trxrpc_free_krb5_principal(&rxk5->client);\n\trxrpc_free_krb5_principal(&rxk5->server);\n\trxrpc_free_krb5_tagged(&rxk5->session);\n\n\tif (rxk5->addresses) {\n\t\tfor (loop = rxk5->n_addresses - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->addresses[loop]);\n\t\tkfree(rxk5->addresses);\n\t}\n\tif (rxk5->authdata) {\n\t\tfor (loop = rxk5->n_authdata - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->authdata[loop]);\n\t\tkfree(rxk5->authdata);\n\t}\n\n\tkfree(rxk5->ticket);\n\tkfree(rxk5->ticket2);\n\tkfree(rxk5);\n}\n\n/*\n * extract a krb5 principal\n */\nstatic int rxrpc_krb5_decode_principal(struct krb5_principal *princ,\n\t\t\t\t       const __be32 **_xdr,\n\t\t\t\t       unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, n_parts, loop, tmp;\n\n\t/* there must be at least one name, and at least #names+1 length\n\t * words */\n\tif (toklen <= 12)\n\t\treturn -EINVAL;\n\n\t_enter(\",{%x,%x,%x},%u\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), toklen);\n\n\tn_parts = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (n_parts <= 0 || n_parts > AFSTOKEN_K5_COMPONENTS_MAX)\n\t\treturn -EINVAL;\n\tprinc->n_name_parts = n_parts;\n\n\tif (toklen <= (n_parts + 1) * 4)\n\t\treturn -EINVAL;\n\n\tprinc->name_parts = kcalloc(n_parts, sizeof(char *), GFP_KERNEL);\n\tif (!princ->name_parts)\n\t\treturn -ENOMEM;\n\n\tfor (loop = 0; loop < n_parts; loop++) {\n\t\tif (toklen < 4)\n\t\t\treturn -EINVAL;\n\t\ttmp = ntohl(*xdr++);\n\t\ttoklen -= 4;\n\t\tif (tmp <= 0 || tmp > AFSTOKEN_STRING_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (tmp > toklen)\n\t\t\treturn -EINVAL;\n\t\tprinc->name_parts[loop] = kmalloc(tmp + 1, GFP_KERNEL);\n\t\tif (!princ->name_parts[loop])\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(princ->name_parts[loop], xdr, tmp);\n\t\tprinc->name_parts[loop][tmp] = 0;\n\t\ttmp = (tmp + 3) & ~3;\n\t\ttoklen -= tmp;\n\t\txdr += tmp >> 2;\n\t}\n\n\tif (toklen < 4)\n\t\treturn -EINVAL;\n\ttmp = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (tmp <= 0 || tmp > AFSTOKEN_K5_REALM_MAX)\n\t\treturn -EINVAL;\n\tif (tmp > toklen)\n\t\treturn -EINVAL;\n\tprinc->realm = kmalloc(tmp + 1, GFP_KERNEL);\n\tif (!princ->realm)\n\t\treturn -ENOMEM;\n\tmemcpy(princ->realm, xdr, tmp);\n\tprinc->realm[tmp] = 0;\n\ttmp = (tmp + 3) & ~3;\n\ttoklen -= tmp;\n\txdr += tmp >> 2;\n\n\t_debug(\"%s/...@%s\", princ->name_parts[0], princ->realm);\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * extract a piece of krb5 tagged data\n */\nstatic int rxrpc_krb5_decode_tagged_data(struct krb5_tagged_data *td,\n\t\t\t\t\t size_t max_data_size,\n\t\t\t\t\t const __be32 **_xdr,\n\t\t\t\t\t unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, len;\n\n\t/* there must be at least one tag and one length word */\n\tif (toklen <= 8)\n\t\treturn -EINVAL;\n\n\t_enter(\",%zu,{%x,%x},%u\",\n\t       max_data_size, ntohl(xdr[0]), ntohl(xdr[1]), toklen);\n\n\ttd->tag = ntohl(*xdr++);\n\tlen = ntohl(*xdr++);\n\ttoklen -= 8;\n\tif (len > max_data_size)\n\t\treturn -EINVAL;\n\ttd->data_len = len;\n\n\tif (len > 0) {\n\t\ttd->data = kmemdup(xdr, len, GFP_KERNEL);\n\t\tif (!td->data)\n\t\t\treturn -ENOMEM;\n\t\tlen = (len + 3) & ~3;\n\t\ttoklen -= len;\n\t\txdr += len >> 2;\n\t}\n\n\t_debug(\"tag %x len %x\", td->tag, td->data_len);\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * extract an array of tagged data\n */\nstatic int rxrpc_krb5_decode_tagged_array(struct krb5_tagged_data **_td,\n\t\t\t\t\t  u8 *_n_elem,\n\t\t\t\t\t  u8 max_n_elem,\n\t\t\t\t\t  size_t max_elem_size,\n\t\t\t\t\t  const __be32 **_xdr,\n\t\t\t\t\t  unsigned int *_toklen)\n{\n\tstruct krb5_tagged_data *td;\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, n_elem, loop;\n\tint ret;\n\n\t/* there must be at least one count */\n\tif (toklen < 4)\n\t\treturn -EINVAL;\n\n\t_enter(\",,%u,%zu,{%x},%u\",\n\t       max_n_elem, max_elem_size, ntohl(xdr[0]), toklen);\n\n\tn_elem = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (n_elem < 0 || n_elem > max_n_elem)\n\t\treturn -EINVAL;\n\t*_n_elem = n_elem;\n\tif (n_elem > 0) {\n\t\tif (toklen <= (n_elem + 1) * 4)\n\t\t\treturn -EINVAL;\n\n\t\t_debug(\"n_elem %d\", n_elem);\n\n\t\ttd = kcalloc(n_elem, sizeof(struct krb5_tagged_data),\n\t\t\t     GFP_KERNEL);\n\t\tif (!td)\n\t\t\treturn -ENOMEM;\n\t\t*_td = td;\n\n\t\tfor (loop = 0; loop < n_elem; loop++) {\n\t\t\tret = rxrpc_krb5_decode_tagged_data(&td[loop],\n\t\t\t\t\t\t\t    max_elem_size,\n\t\t\t\t\t\t\t    &xdr, &toklen);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * extract a krb5 ticket\n */\nstatic int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,\n\t\t\t\t    const __be32 **_xdr, unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, len;\n\n\t/* there must be at least one length word */\n\tif (toklen <= 4)\n\t\treturn -EINVAL;\n\n\t_enter(\",{%x},%u\", ntohl(xdr[0]), toklen);\n\n\tlen = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (len > AFSTOKEN_K5_TIX_MAX)\n\t\treturn -EINVAL;\n\t*_tktlen = len;\n\n\t_debug(\"ticket len %u\", len);\n\n\tif (len > 0) {\n\t\t*_ticket = kmemdup(xdr, len, GFP_KERNEL);\n\t\tif (!*_ticket)\n\t\t\treturn -ENOMEM;\n\t\tlen = (len + 3) & ~3;\n\t\ttoklen -= len;\n\t\txdr += len >> 2;\n\t}\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * parse an RxK5 type XDR format token\n * - the caller guarantees we have at least 4 words\n */\nstatic int rxrpc_preparse_xdr_rxk5(struct key_preparsed_payload *prep,\n\t\t\t\t   size_t datalen,\n\t\t\t\t   const __be32 *xdr, unsigned int toklen)\n{\n\tstruct rxrpc_key_token *token, **pptoken;\n\tstruct rxk5_key *rxk5;\n\tconst __be32 *end_xdr = xdr + (toklen >> 2);\n\tint ret;\n\n\t_enter(\",{%x,%x,%x,%x},%u\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       toklen);\n\n\t/* reserve some payload space for this subkey - the length of the token\n\t * is a reasonable approximation */\n\tprep->quotalen = datalen + toklen;\n\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\treturn -ENOMEM;\n\n\trxk5 = kzalloc(sizeof(*rxk5), GFP_KERNEL);\n\tif (!rxk5) {\n\t\tkfree(token);\n\t\treturn -ENOMEM;\n\t}\n\n\ttoken->security_index = RXRPC_SECURITY_RXK5;\n\ttoken->k5 = rxk5;\n\n\t/* extract the principals */\n\tret = rxrpc_krb5_decode_principal(&rxk5->client, &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = rxrpc_krb5_decode_principal(&rxk5->server, &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* extract the session key and the encoding type (the tag field ->\n\t * ENCTYPE_xxx) */\n\tret = rxrpc_krb5_decode_tagged_data(&rxk5->session, AFSTOKEN_DATA_MAX,\n\t\t\t\t\t    &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (toklen < 4 * 8 + 2 * 4)\n\t\tgoto inval;\n\trxk5->authtime\t= be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->starttime\t= be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->endtime\t= be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->renew_till = be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->is_skey = ntohl(*xdr++);\n\trxk5->flags = ntohl(*xdr++);\n\ttoklen -= 4 * 8 + 2 * 4;\n\n\t_debug(\"times: a=%llx s=%llx e=%llx rt=%llx\",\n\t       rxk5->authtime, rxk5->starttime, rxk5->endtime,\n\t       rxk5->renew_till);\n\t_debug(\"is_skey=%x flags=%x\", rxk5->is_skey, rxk5->flags);\n\n\t/* extract the permitted client addresses */\n\tret = rxrpc_krb5_decode_tagged_array(&rxk5->addresses,\n\t\t\t\t\t     &rxk5->n_addresses,\n\t\t\t\t\t     AFSTOKEN_K5_ADDRESSES_MAX,\n\t\t\t\t\t     AFSTOKEN_DATA_MAX,\n\t\t\t\t\t     &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\n\n\t/* extract the tickets */\n\tret = rxrpc_krb5_decode_ticket(&rxk5->ticket, &rxk5->ticket_len,\n\t\t\t\t       &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = rxrpc_krb5_decode_ticket(&rxk5->ticket2, &rxk5->ticket2_len,\n\t\t\t\t       &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\n\n\t/* extract the typed auth data */\n\tret = rxrpc_krb5_decode_tagged_array(&rxk5->authdata,\n\t\t\t\t\t     &rxk5->n_authdata,\n\t\t\t\t\t     AFSTOKEN_K5_AUTHDATA_MAX,\n\t\t\t\t\t     AFSTOKEN_BDATALN_MAX,\n\t\t\t\t\t     &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\n\n\tif (toklen != 0)\n\t\tgoto inval;\n\n\t/* attach the payload */\n\tfor (pptoken = (struct rxrpc_key_token **)&prep->payload[0];\n\t     *pptoken;\n\t     pptoken = &(*pptoken)->next)\n\t\tcontinue;\n\t*pptoken = token;\n\tif (token->kad->expiry < prep->expiry)\n\t\tprep->expiry = token->kad->expiry;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tret = -EINVAL;\nerror:\n\trxrpc_rxk5_free(rxk5);\n\tkfree(token);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * attempt to parse the data as the XDR format\n * - the caller guarantees we have more than 7 words\n */\nstatic int rxrpc_preparse_xdr(struct key_preparsed_payload *prep)\n{\n\tconst __be32 *xdr = prep->data, *token;\n\tconst char *cp;\n\tunsigned int len, tmp, loop, ntoken, toklen, sec_ix;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\t_enter(\",{%x,%x,%x,%x},%zu\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       prep->datalen);\n\n\tif (datalen > AFSTOKEN_LENGTH_MAX)\n\t\tgoto not_xdr;\n\n\t/* XDR is an array of __be32's */\n\tif (datalen & 3)\n\t\tgoto not_xdr;\n\n\t/* the flags should be 0 (the setpag bit must be handled by\n\t * userspace) */\n\tif (ntohl(*xdr++) != 0)\n\t\tgoto not_xdr;\n\tdatalen -= 4;\n\n\t/* check the cell name */\n\tlen = ntohl(*xdr++);\n\tif (len < 1 || len > AFSTOKEN_CELL_MAX)\n\t\tgoto not_xdr;\n\tdatalen -= 4;\n\ttmp = (len + 3) & ~3;\n\tif (tmp > datalen)\n\t\tgoto not_xdr;\n\n\tcp = (const char *) xdr;\n\tfor (loop = 0; loop < len; loop++)\n\t\tif (!isprint(cp[loop]))\n\t\t\tgoto not_xdr;\n\tif (len < tmp)\n\t\tfor (; loop < tmp; loop++)\n\t\t\tif (cp[loop])\n\t\t\t\tgoto not_xdr;\n\t_debug(\"cellname: [%u/%u] '%*.*s'\",\n\t       len, tmp, len, len, (const char *) xdr);\n\tdatalen -= tmp;\n\txdr += tmp >> 2;\n\n\t/* get the token count */\n\tif (datalen < 12)\n\t\tgoto not_xdr;\n\tntoken = ntohl(*xdr++);\n\tdatalen -= 4;\n\t_debug(\"ntoken: %x\", ntoken);\n\tif (ntoken < 1 || ntoken > AFSTOKEN_MAX)\n\t\tgoto not_xdr;\n\n\t/* check each token wrapper */\n\ttoken = xdr;\n\tloop = ntoken;\n\tdo {\n\t\tif (datalen < 8)\n\t\t\tgoto not_xdr;\n\t\ttoklen = ntohl(*xdr++);\n\t\tsec_ix = ntohl(*xdr);\n\t\tdatalen -= 4;\n\t\t_debug(\"token: [%x/%zx] %x\", toklen, datalen, sec_ix);\n\t\tif (toklen < 20 || toklen > datalen)\n\t\t\tgoto not_xdr;\n\t\tdatalen -= (toklen + 3) & ~3;\n\t\txdr += (toklen + 3) >> 2;\n\n\t} while (--loop > 0);\n\n\t_debug(\"remainder: %zu\", datalen);\n\tif (datalen != 0)\n\t\tgoto not_xdr;\n\n\t/* okay: we're going to assume it's valid XDR format\n\t * - we ignore the cellname, relying on the key to be correctly named\n\t */\n\tdo {\n\t\txdr = token;\n\t\ttoklen = ntohl(*xdr++);\n\t\ttoken = xdr + ((toklen + 3) >> 2);\n\t\tsec_ix = ntohl(*xdr++);\n\t\ttoklen -= 4;\n\n\t\t_debug(\"TOKEN type=%u [%p-%p]\", sec_ix, xdr, token);\n\n\t\tswitch (sec_ix) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tret = rxrpc_preparse_xdr_rxkad(prep, datalen, xdr, toklen);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tret = rxrpc_preparse_xdr_rxk5(prep, datalen, xdr, toklen);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto error;\n\t\t}\n\n\t} while (--ntoken > 0);\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nnot_xdr:\n\t_leave(\" = -EPROTO\");\n\treturn -EPROTO;\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Preparse an rxrpc defined key.\n *\n * Data should be of the form:\n *\tOFFSET\tLEN\tCONTENT\n *\t0\t4\tkey interface version number\n *\t4\t2\tsecurity index (type)\n *\t6\t2\tticket length\n *\t8\t4\tkey expiry time (time_t)\n *\t12\t4\tkvno\n *\t16\t8\tsession key\n *\t24\t[len]\tticket\n *\n * if no data is provided, then a no-security key is made\n */\nstatic int rxrpc_preparse(struct key_preparsed_payload *prep)\n{\n\tconst struct rxrpc_key_data_v1 *v1;\n\tstruct rxrpc_key_token *token, **pp;\n\tsize_t plen;\n\tu32 kver;\n\tint ret;\n\n\t_enter(\"%zu\", prep->datalen);\n\n\t/* handle a no-security key */\n\tif (!prep->data && prep->datalen == 0)\n\t\treturn 0;\n\n\t/* determine if the XDR payload format is being used */\n\tif (prep->datalen > 7 * 4) {\n\t\tret = rxrpc_preparse_xdr(prep);\n\t\tif (ret != -EPROTO)\n\t\t\treturn ret;\n\t}\n\n\t/* get the key interface version number */\n\tret = -EINVAL;\n\tif (prep->datalen <= 4 || !prep->data)\n\t\tgoto error;\n\tmemcpy(&kver, prep->data, sizeof(kver));\n\tprep->data += sizeof(kver);\n\tprep->datalen -= sizeof(kver);\n\n\t_debug(\"KEY I/F VERSION: %u\", kver);\n\n\tret = -EKEYREJECTED;\n\tif (kver != 1)\n\t\tgoto error;\n\n\t/* deal with a version 1 key */\n\tret = -EINVAL;\n\tif (prep->datalen < sizeof(*v1))\n\t\tgoto error;\n\n\tv1 = prep->data;\n\tif (prep->datalen != sizeof(*v1) + v1->ticket_length)\n\t\tgoto error;\n\n\t_debug(\"SCIX: %u\", v1->security_index);\n\t_debug(\"TLEN: %u\", v1->ticket_length);\n\t_debug(\"EXPY: %x\", v1->expiry);\n\t_debug(\"KVNO: %u\", v1->kvno);\n\t_debug(\"SKEY: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t       v1->session_key[0], v1->session_key[1],\n\t       v1->session_key[2], v1->session_key[3],\n\t       v1->session_key[4], v1->session_key[5],\n\t       v1->session_key[6], v1->session_key[7]);\n\tif (v1->ticket_length >= 8)\n\t\t_debug(\"TCKT: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t\t       v1->ticket[0], v1->ticket[1],\n\t\t       v1->ticket[2], v1->ticket[3],\n\t\t       v1->ticket[4], v1->ticket[5],\n\t\t       v1->ticket[6], v1->ticket[7]);\n\n\tret = -EPROTONOSUPPORT;\n\tif (v1->security_index != RXRPC_SECURITY_RXKAD)\n\t\tgoto error;\n\n\tplen = sizeof(*token->kad) + v1->ticket_length;\n\tprep->quotalen = plen + sizeof(*token);\n\n\tret = -ENOMEM;\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\tgoto error;\n\ttoken->kad = kzalloc(plen, GFP_KERNEL);\n\tif (!token->kad)\n\t\tgoto error_free;\n\n\ttoken->security_index\t\t= RXRPC_SECURITY_RXKAD;\n\ttoken->kad->ticket_len\t\t= v1->ticket_length;\n\ttoken->kad->expiry\t\t= v1->expiry;\n\ttoken->kad->kvno\t\t= v1->kvno;\n\tmemcpy(&token->kad->session_key, &v1->session_key, 8);\n\tmemcpy(&token->kad->ticket, v1->ticket, v1->ticket_length);\n\n\t/* count the number of tokens attached */\n\tprep->type_data[0] = (void *)((unsigned long)prep->type_data[0] + 1);\n\n\t/* attach the data */\n\tpp = (struct rxrpc_key_token **)&prep->payload[0];\n\twhile (*pp)\n\t\tpp = &(*pp)->next;\n\t*pp = token;\n\tif (token->kad->expiry < prep->expiry)\n\t\tprep->expiry = token->kad->expiry;\n\ttoken = NULL;\n\tret = 0;\n\nerror_free:\n\tkfree(token);\nerror:\n\treturn ret;\n}\n\n/*\n * Free token list.\n */\nstatic void rxrpc_free_token_list(struct rxrpc_key_token *token)\n{\n\tstruct rxrpc_key_token *next;\n\n\tfor (; token; token = next) {\n\t\tnext = token->next;\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tkfree(token->kad);\n\t\t\tbreak;\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tif (token->k5)\n\t\t\t\trxrpc_rxk5_free(token->k5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"Unknown token type %x on rxrpc key\\n\",\n\t\t\t       token->security_index);\n\t\t\tBUG();\n\t\t}\n\n\t\tkfree(token);\n\t}\n}\n\n/*\n * Clean up preparse data.\n */\nstatic void rxrpc_free_preparse(struct key_preparsed_payload *prep)\n{\n\trxrpc_free_token_list(prep->payload[0]);\n}\n\n/*\n * Preparse a server secret key.\n *\n * The data should be the 8-byte secret key.\n */\nstatic int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_blkcipher *ci;\n\n\t_enter(\"%zu\", prep->datalen);\n\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\n\tmemcpy(&prep->type_data, prep->data, 8);\n\n\tci = crypto_alloc_blkcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\n\tif (crypto_blkcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\n\tprep->payload[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n/*\n * Clean up preparse data.\n */\nstatic void rxrpc_free_preparse_s(struct key_preparsed_payload *prep)\n{\n\tif (prep->payload[0])\n\t\tcrypto_free_blkcipher(prep->payload[0]);\n}\n\n/*\n * dispose of the data dangling from the corpse of a rxrpc key\n */\nstatic void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data);\n}\n\n/*\n * dispose of the data dangling from the corpse of a rxrpc key\n */\nstatic void rxrpc_destroy_s(struct key *key)\n{\n\tif (key->payload.data) {\n\t\tcrypto_free_blkcipher(key->payload.data);\n\t\tkey->payload.data = NULL;\n\t}\n}\n\n/*\n * describe the rxrpc key\n */\nstatic void rxrpc_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n}\n\n/*\n * grab the security key for a socket\n */\nint rxrpc_request_key(struct rxrpc_sock *rx, char __user *optval, int optlen)\n{\n\tstruct key *key;\n\tchar *description;\n\n\t_enter(\"\");\n\n\tif (optlen <= 0 || optlen > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\n\tdescription = kmalloc(optlen + 1, GFP_KERNEL);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(description, optval, optlen)) {\n\t\tkfree(description);\n\t\treturn -EFAULT;\n\t}\n\tdescription[optlen] = 0;\n\n\tkey = request_key(&key_type_rxrpc, description, NULL);\n\tif (IS_ERR(key)) {\n\t\tkfree(description);\n\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\trx->key = key;\n\tkfree(description);\n\t_leave(\" = 0 [key %x]\", key->serial);\n\treturn 0;\n}\n\n/*\n * grab the security keyring for a server socket\n */\nint rxrpc_server_keyring(struct rxrpc_sock *rx, char __user *optval,\n\t\t\t int optlen)\n{\n\tstruct key *key;\n\tchar *description;\n\n\t_enter(\"\");\n\n\tif (optlen <= 0 || optlen > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\n\tdescription = kmalloc(optlen + 1, GFP_KERNEL);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(description, optval, optlen)) {\n\t\tkfree(description);\n\t\treturn -EFAULT;\n\t}\n\tdescription[optlen] = 0;\n\n\tkey = request_key(&key_type_keyring, description, NULL);\n\tif (IS_ERR(key)) {\n\t\tkfree(description);\n\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\trx->securities = key;\n\tkfree(description);\n\t_leave(\" = 0 [key %x]\", key->serial);\n\treturn 0;\n}\n\n/*\n * generate a server data key\n */\nint rxrpc_get_server_data_key(struct rxrpc_connection *conn,\n\t\t\t      const void *session_key,\n\t\t\t      time_t expiry,\n\t\t\t      u32 kvno)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\n\tstruct {\n\t\tu32 kver;\n\t\tstruct rxrpc_key_data_v1 v1;\n\t} data;\n\n\t_enter(\"\");\n\n\tkey = key_alloc(&key_type_rxrpc, \"x\",\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred, 0,\n\t\t\tKEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = -ENOMEM [alloc %ld]\", PTR_ERR(key));\n\t\treturn -ENOMEM;\n\t}\n\n\t_debug(\"key %d\", key_serial(key));\n\n\tdata.kver = 1;\n\tdata.v1.security_index = RXRPC_SECURITY_RXKAD;\n\tdata.v1.ticket_length = 0;\n\tdata.v1.expiry = expiry;\n\tdata.v1.kvno = 0;\n\n\tmemcpy(&data.v1.session_key, session_key, sizeof(data.v1.session_key));\n\n\tret = key_instantiate_and_link(key, &data, sizeof(data), NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tconn->key = key;\n\t_leave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\nerror:\n\tkey_revoke(key);\n\tkey_put(key);\n\t_leave(\" = -ENOMEM [ins %d]\", ret);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(rxrpc_get_server_data_key);\n\n/**\n * rxrpc_get_null_key - Generate a null RxRPC key\n * @keyname: The name to give the key.\n *\n * Generate a null RxRPC key that can be used to indicate anonymous security is\n * required for a particular domain.\n */\nstruct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key))\n\t\treturn key;\n\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn key;\n}\nEXPORT_SYMBOL(rxrpc_get_null_key);\n\n/*\n * read the contents of an rxrpc key\n * - this returns the result in XDR form\n */\nstatic long rxrpc_read(const struct key *key,\n\t\t       char __user *buffer, size_t buflen)\n{\n\tconst struct rxrpc_key_token *token;\n\tconst struct krb5_principal *princ;\n\tsize_t size;\n\t__be32 __user *xdr, *oldxdr;\n\tu32 cnlen, toksize, ntoks, tok, zero;\n\tu16 toksizes[AFSTOKEN_MAX];\n\tint loop;\n\n\t_enter(\"\");\n\n\t/* we don't know what form we should return non-AFS keys in */\n\tif (memcmp(key->description, \"afs@\", 4) != 0)\n\t\treturn -EOPNOTSUPP;\n\tcnlen = strlen(key->description + 4);\n\n#define RND(X) (((X) + 3) & ~3)\n\n\t/* AFS keys we return in XDR form, so we need to work out the size of\n\t * the XDR */\n\tsize = 2 * 4;\t/* flags, cellname len */\n\tsize += RND(cnlen);\t/* cellname */\n\tsize += 1 * 4;\t/* token count */\n\n\tntoks = 0;\n\tfor (token = key->payload.data; token; token = token->next) {\n\t\ttoksize = 4;\t/* sec index */\n\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\ttoksize += 8 * 4;\t/* viceid, kvno, key*2, begin,\n\t\t\t\t\t\t * end, primary, tktlen */\n\t\t\ttoksize += RND(token->kad->ticket_len);\n\t\t\tbreak;\n\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tprinc = &token->k5->client;\n\t\t\ttoksize += 4 + princ->n_name_parts * 4;\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\ttoksize += RND(strlen(princ->name_parts[loop]));\n\t\t\ttoksize += 4 + RND(strlen(princ->realm));\n\n\t\t\tprinc = &token->k5->server;\n\t\t\ttoksize += 4 + princ->n_name_parts * 4;\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\ttoksize += RND(strlen(princ->name_parts[loop]));\n\t\t\ttoksize += 4 + RND(strlen(princ->realm));\n\n\t\t\ttoksize += 8 + RND(token->k5->session.data_len);\n\n\t\t\ttoksize += 4 * 8 + 2 * 4;\n\n\t\t\ttoksize += 4 + token->k5->n_addresses * 8;\n\t\t\tfor (loop = 0; loop < token->k5->n_addresses; loop++)\n\t\t\t\ttoksize += RND(token->k5->addresses[loop].data_len);\n\n\t\t\ttoksize += 4 + RND(token->k5->ticket_len);\n\t\t\ttoksize += 4 + RND(token->k5->ticket2_len);\n\n\t\t\ttoksize += 4 + token->k5->n_authdata * 8;\n\t\t\tfor (loop = 0; loop < token->k5->n_authdata; loop++)\n\t\t\t\ttoksize += RND(token->k5->authdata[loop].data_len);\n\t\t\tbreak;\n\n\t\tdefault: /* we have a ticket we can't encode */\n\t\t\tBUG();\n\t\t\tcontinue;\n\t\t}\n\n\t\t_debug(\"token[%u]: toksize=%u\", ntoks, toksize);\n\t\tASSERTCMP(toksize, <=, AFSTOKEN_LENGTH_MAX);\n\n\t\ttoksizes[ntoks++] = toksize;\n\t\tsize += toksize + 4; /* each token has a length word */\n\t}\n\n#undef RND\n\n\tif (!buffer || buflen < size)\n\t\treturn size;\n\n\txdr = (__be32 __user *) buffer;\n\tzero = 0;\n#define ENCODE(x)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\t__be32 y = htonl(x);\t\t\\\n\t\tif (put_user(y, xdr++) < 0)\t\\\n\t\t\tgoto fault;\t\t\\\n\t} while(0)\n#define ENCODE_DATA(l, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tu32 _l = (l);\t\t\t\t\t\t\\\n\t\tENCODE(l);\t\t\t\t\t\t\\\n\t\tif (copy_to_user(xdr, (s), _l) != 0)\t\t\t\\\n\t\t\tgoto fault;\t\t\t\t\t\\\n\t\tif (_l & 3 &&\t\t\t\t\t\t\\\n\t\t    copy_to_user((u8 *)xdr + _l, &zero, 4 - (_l & 3)) != 0) \\\n\t\t\tgoto fault;\t\t\t\t\t\\\n\t\txdr += (_l + 3) >> 2;\t\t\t\t\t\\\n\t} while(0)\n#define ENCODE64(x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t__be64 y = cpu_to_be64(x);\t\t\\\n\t\tif (copy_to_user(xdr, &y, 8) != 0)\t\\\n\t\t\tgoto fault;\t\t\t\\\n\t\txdr += 8 >> 2;\t\t\t\t\\\n\t} while(0)\n#define ENCODE_STR(s)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tconst char *_s = (s);\t\t\\\n\t\tENCODE_DATA(strlen(_s), _s);\t\\\n\t} while(0)\n\n\tENCODE(0);\t\t\t\t\t/* flags */\n\tENCODE_DATA(cnlen, key->description + 4);\t/* cellname */\n\tENCODE(ntoks);\n\n\ttok = 0;\n\tfor (token = key->payload.data; token; token = token->next) {\n\t\ttoksize = toksizes[tok++];\n\t\tENCODE(toksize);\n\t\toldxdr = xdr;\n\t\tENCODE(token->security_index);\n\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tENCODE(token->kad->vice_id);\n\t\t\tENCODE(token->kad->kvno);\n\t\t\tENCODE_DATA(8, token->kad->session_key);\n\t\t\tENCODE(token->kad->start);\n\t\t\tENCODE(token->kad->expiry);\n\t\t\tENCODE(token->kad->primary_flag);\n\t\t\tENCODE_DATA(token->kad->ticket_len, token->kad->ticket);\n\t\t\tbreak;\n\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tprinc = &token->k5->client;\n\t\t\tENCODE(princ->n_name_parts);\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\tENCODE_STR(princ->name_parts[loop]);\n\t\t\tENCODE_STR(princ->realm);\n\n\t\t\tprinc = &token->k5->server;\n\t\t\tENCODE(princ->n_name_parts);\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\tENCODE_STR(princ->name_parts[loop]);\n\t\t\tENCODE_STR(princ->realm);\n\n\t\t\tENCODE(token->k5->session.tag);\n\t\t\tENCODE_DATA(token->k5->session.data_len,\n\t\t\t\t    token->k5->session.data);\n\n\t\t\tENCODE64(token->k5->authtime);\n\t\t\tENCODE64(token->k5->starttime);\n\t\t\tENCODE64(token->k5->endtime);\n\t\t\tENCODE64(token->k5->renew_till);\n\t\t\tENCODE(token->k5->is_skey);\n\t\t\tENCODE(token->k5->flags);\n\n\t\t\tENCODE(token->k5->n_addresses);\n\t\t\tfor (loop = 0; loop < token->k5->n_addresses; loop++) {\n\t\t\t\tENCODE(token->k5->addresses[loop].tag);\n\t\t\t\tENCODE_DATA(token->k5->addresses[loop].data_len,\n\t\t\t\t\t    token->k5->addresses[loop].data);\n\t\t\t}\n\n\t\t\tENCODE_DATA(token->k5->ticket_len, token->k5->ticket);\n\t\t\tENCODE_DATA(token->k5->ticket2_len, token->k5->ticket2);\n\n\t\t\tENCODE(token->k5->n_authdata);\n\t\t\tfor (loop = 0; loop < token->k5->n_authdata; loop++) {\n\t\t\t\tENCODE(token->k5->authdata[loop].tag);\n\t\t\t\tENCODE_DATA(token->k5->authdata[loop].data_len,\n\t\t\t\t\t    token->k5->authdata[loop].data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tASSERTCMP((unsigned long)xdr - (unsigned long)oldxdr, ==,\n\t\t\t  toksize);\n\t}\n\n#undef ENCODE_STR\n#undef ENCODE_DATA\n#undef ENCODE64\n#undef ENCODE\n\n\tASSERTCMP(tok, ==, ntoks);\n\tASSERTCMP((char __user *) xdr - buffer, ==, size);\n\t_leave(\" = %zu\", size);\n\treturn size;\n\nfault:\n\t_leave(\" = -EFAULT\");\n\treturn -EFAULT;\n}\n", "/* Large capacity key type\n *\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/shmem_fs.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/big_key-type.h>\n\nMODULE_LICENSE(\"GPL\");\n\n/*\n * If the data is under this limit, there's no point creating a shm file to\n * hold it as the permanently resident metadata for the shmem fs will be at\n * least as large as the data.\n */\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\n/*\n * big_key defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.match\t\t\t= user_match,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n};\n\n/*\n * Preparse a big key\n */\nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload;\n\tstruct file *file;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->type_data[1] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * TODO: Encrypt the stored data with a temporary key.\n\t\t */\n\t\tfile = shmem_kernel_file_setup(\"\", datalen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\twritten = kernel_write(file, prep->data, prep->datalen, 0);\n\t\tif (written != datalen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload[0] = memcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerror:\n\treturn ret;\n}\n\n/*\n * Clear preparsement.\n */\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload;\n\t\tpath_put(path);\n\t} else {\n\t\tkfree(prep->payload[0]);\n\t}\n}\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data2;\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) && key->type_data.x[1] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}\n\n/*\n * dispose of the data dangling from the corpse of a big_key key\n */\nvoid big_key_destroy(struct key *key)\n{\n\tif (key->type_data.x[1] > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data2;\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t} else {\n\t\tkfree(key->payload.data);\n\t\tkey->payload.data = NULL;\n\t}\n}\n\n/*\n * describe the big_key key\n */\nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tunsigned long datalen = key->type_data.x[1];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %lu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tunsigned long datalen = key->type_data.x[1];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data2;\n\t\tstruct file *file;\n\t\tloff_t pos;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\n\t\tpos = 0;\n\t\tret = vfs_read(file, buffer, datalen, &pos);\n\t\tfput(file);\n\t\tif (ret >= 0 && ret != datalen)\n\t\t\tret = -EIO;\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Module stuff\n */\nstatic int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}\n\nstatic void __exit big_key_cleanup(void)\n{\n\tunregister_key_type(&key_type_big_key);\n}\n\nmodule_init(big_key_init);\nmodule_exit(big_key_cleanup);\n", "/*\n * Copyright (C) 2010 IBM Corporation\n * Copyright (C) 2010 Politecnico di Torino, Italy\n *                    TORSEC group -- http://security.polito.it\n *\n * Authors:\n * Mimi Zohar <zohar@us.ibm.com>\n * Roberto Sassu <roberto.sassu@polito.it>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/ctype.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <crypto/aes.h>\n\n#include \"encrypted.h\"\n#include \"ecryptfs_format.h\"\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\nstatic const char hash_alg[] = \"sha256\";\nstatic const char hmac_alg[] = \"hmac(sha256)\";\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_ECRYPTFS_DESC_LEN 16\n#define HASH_SIZE SHA256_DIGEST_SIZE\n#define MAX_DATA_SIZE 4096\n#define MIN_DATA_SIZE  20\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nenum {\n\tOpt_err = -1, Opt_new, Opt_load, Opt_update\n};\n\nenum {\n\tOpt_error = -1, Opt_default, Opt_ecryptfs\n};\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_blkcipher *tfm;\n\n\ttfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\tblksize = crypto_blkcipher_blocksize(tfm);\n\tcrypto_free_blkcipher(tfm);\n\treturn 0;\n}\n\n/*\n * valid_ecryptfs_desc - verify the description of a new/loaded encrypted key\n *\n * The description of a encrypted key with format 'ecryptfs' must contain\n * exactly 16 hexadecimal characters.\n *\n */\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * valid_master_desc - verify the 'key-type:desc' of a new/updated master-key\n *\n * key-type:= \"trusted:\" | \"user:\"\n * desc:= master-key description\n *\n * Verify that 'key-type' is valid and that 'desc' exists. On key update,\n * only the master key description is permitted to change, not the key-type.\n * The key-type remains constant.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}\n\n/*\n * datablob_parse - parse the keyctl data\n *\n * datablob format:\n * new [<format>] <master-key name> <decrypted data length>\n * load [<format>] <master-key name> <decrypted data length>\n *     <encrypted iv + data>\n * update <new-master-key name>\n *\n * Tokenizes a copy of the keyctl data, returning a pointer to each token,\n * which is null terminated.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n/*\n * datablob_format - format as an ascii string, before copying to userspace\n */\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}\n\n/*\n * request_user_key - request the user key\n *\n * Use a user provided key to encrypt/decrypt an encrypted-key.\n */\nstatic struct key *request_user_key(const char *master_desc, u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tstruct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = ukey->payload.data;\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n\nstatic struct sdesc *alloc_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (!ret)\n\t\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int calc_hash(u8 *digest, const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nenum derived_key_type { ENC_KEY, AUTH_KEY };\n\n/* Derive authentication/encryption key from trusted key */\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf) {\n\t\tpr_err(\"encrypted_key: out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(derived_key, derived_buf, derived_buf_len);\n\tkfree(derived_buf);\n\treturn ret;\n}\n\nstatic int init_blkcipher_desc(struct blkcipher_desc *desc, const u8 *key,\n\t\t\t       unsigned int key_len, const u8 *iv,\n\t\t\t       unsigned int ivsize)\n{\n\tint ret;\n\n\tdesc->tfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc->tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(desc->tfm));\n\t\treturn PTR_ERR(desc->tfm);\n\t}\n\tdesc->flags = 0;\n\n\tret = crypto_blkcipher_setkey(desc->tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_blkcipher(desc->tfm);\n\t\treturn ret;\n\t}\n\tcrypto_blkcipher_set_iv(desc->tfm, iv, ivsize);\n\treturn 0;\n}\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = NULL;\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n\n/* Before returning data to userspace, encrypt decrypted data. */\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tunsigned int padlen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tpadlen = encrypted_datalen - epayload->decrypted_datalen;\n\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_in[1], pad, padlen);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\treturn ret;\n}\n\n/* verify HMAC before decrypting encrypted key */\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = memcmp(digest, epayload->format + epayload->datablob_len,\n\t\t     sizeof digest);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, sizeof pad);\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\treturn ret;\n}\n\n/* Allocate memory for decrypted key and datablob. */\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tu8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}\n\n/*\n * encrypted_init - initialize an encrypted key\n *\n * For a new key, use a random number for both the iv and data\n * itself.  For an old key, decrypt the hex encoded data.\n */\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}\n\n/*\n * encrypted_instantiate - instantiate an encrypted key\n *\n * Decrypt an existing encrypted datablob or create a new encrypted key\n * based on a kernel random number.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkfree(datablob);\n\treturn ret;\n}\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(epayload);\n}\n\n/*\n * encrypted_update - update the master key description\n *\n * Change the master key description for an existing encrypted key.\n * The next read will return an encrypted datablob using the new\n * master key description.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n/*\n * encrypted_read - format and copy the encrypted data to userspace\n *\n * The resulting datablob format is:\n * <master-key name> <decrypted data length> <encrypted iv> <encrypted data>\n *\n * On success, return to userspace the encrypted key datablob size.\n */\nstatic long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tu8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = rcu_dereference_key(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\n/*\n * encrypted_destroy - before freeing the key, clear the decrypted data\n *\n * Before freeing the key, clear the memory containing the decrypted\n * key data.\n */\nstatic void encrypted_destroy(struct key *key)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\n\tif (!epayload)\n\t\treturn;\n\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(key->payload.data);\n}\n\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.match = user_match,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_encrypted);\n\nstatic void encrypted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init encrypted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\tret = encrypted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn aes_get_sizes();\nout:\n\tencrypted_shash_release();\n\treturn ret;\n\n}\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tencrypted_shash_release();\n\tunregister_key_type(&key_type_encrypted);\n}\n\nlate_initcall(init_encrypted);\nmodule_exit(cleanup_encrypted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* Authentication token and access key management internal defs\n *\n * Copyright (C) 2003-5, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#ifndef _INTERNAL_H\n#define _INTERNAL_H\n\n#include <linux/sched.h>\n#include <linux/key-type.h>\n#include <linux/task_work.h>\n\nstruct iovec;\n\n#ifdef __KDEBUG\n#define kenter(FMT, ...) \\\n\tprintk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tprintk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tprintk(KERN_DEBUG \"   \"FMT\"\\n\", ##__VA_ARGS__)\n#else\n#define kenter(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tno_printk(KERN_DEBUG FMT\"\\n\", ##__VA_ARGS__)\n#endif\n\nextern struct key_type key_type_dead;\nextern struct key_type key_type_user;\nextern struct key_type key_type_logon;\n\n/*****************************************************************************/\n/*\n * Keep track of keys for a user.\n *\n * This needs to be separate to user_struct to avoid a refcount-loop\n * (user_struct pins some keyrings which pin this struct).\n *\n * We also keep track of keys under request from userspace for this UID here.\n */\nstruct key_user {\n\tstruct rb_node\t\tnode;\n\tstruct mutex\t\tcons_lock;\t/* construction initiation lock */\n\tspinlock_t\t\tlock;\n\tatomic_t\t\tusage;\t\t/* for accessing qnkeys & qnbytes */\n\tatomic_t\t\tnkeys;\t\t/* number of keys */\n\tatomic_t\t\tnikeys;\t\t/* number of instantiated keys */\n\tkuid_t\t\t\tuid;\n\tint\t\t\tqnkeys;\t\t/* number of keys allocated to this user */\n\tint\t\t\tqnbytes;\t/* number of bytes allocated to this user */\n};\n\nextern struct rb_root\tkey_user_tree;\nextern spinlock_t\tkey_user_lock;\nextern struct key_user\troot_key_user;\n\nextern struct key_user *key_user_lookup(kuid_t uid);\nextern void key_user_put(struct key_user *user);\n\n/*\n * Key quota limits.\n * - root has its own separate limits to everyone else\n */\nextern unsigned key_quota_root_maxkeys;\nextern unsigned key_quota_root_maxbytes;\nextern unsigned key_quota_maxkeys;\nextern unsigned key_quota_maxbytes;\n\n#define KEYQUOTA_LINK_BYTES\t4\t\t/* a link in a keyring is worth 4 bytes */\n\n\nextern struct kmem_cache *key_jar;\nextern struct rb_root key_serial_tree;\nextern spinlock_t key_serial_lock;\nextern struct mutex key_construction_mutex;\nextern wait_queue_head_t request_key_conswq;\n\n\nextern struct key_type *key_type_lookup(const char *type);\nextern void key_type_put(struct key_type *ktype);\n\nextern int __key_link_begin(struct key *keyring,\n\t\t\t    const struct keyring_index_key *index_key,\n\t\t\t    struct assoc_array_edit **_edit);\nextern int __key_link_check_live_key(struct key *keyring, struct key *key);\nextern void __key_link(struct key *key, struct assoc_array_edit **_edit);\nextern void __key_link_end(struct key *keyring,\n\t\t\t   const struct keyring_index_key *index_key,\n\t\t\t   struct assoc_array_edit *edit);\n\nextern key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t\t    const struct keyring_index_key *index_key);\n\nextern struct key *keyring_search_instkey(struct key *keyring,\n\t\t\t\t\t  key_serial_t target_id);\n\nextern int iterate_over_keyring(const struct key *keyring,\n\t\t\t\tint (*func)(const struct key *key, void *data),\n\t\t\t\tvoid *data);\n\nstruct keyring_search_context {\n\tstruct keyring_index_key index_key;\n\tconst struct cred\t*cred;\n\tstruct key_match_data\tmatch_data;\n\tunsigned\t\tflags;\n#define KEYRING_SEARCH_NO_STATE_CHECK\t0x0001\t/* Skip state checks */\n#define KEYRING_SEARCH_DO_STATE_CHECK\t0x0002\t/* Override NO_STATE_CHECK */\n#define KEYRING_SEARCH_NO_UPDATE_TIME\t0x0004\t/* Don't update times */\n#define KEYRING_SEARCH_NO_CHECK_PERM\t0x0008\t/* Don't check permissions */\n#define KEYRING_SEARCH_DETECT_TOO_DEEP\t0x0010\t/* Give an error on excessive depth */\n\n\tint (*iterator)(const void *object, void *iterator_data);\n\n\t/* Internal stuff */\n\tint\t\t\tskipped_ret;\n\tbool\t\t\tpossessed;\n\tkey_ref_t\t\tresult;\n\tstruct timespec\t\tnow;\n};\n\nextern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t\t    struct keyring_search_context *ctx);\n\nextern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);\nextern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);\n\nextern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);\n\nextern int install_user_keyrings(void);\nextern int install_thread_keyring_to_cred(struct cred *);\nextern int install_process_keyring_to_cred(struct cred *);\nextern int install_session_keyring_to_cred(struct cred *, struct key *);\n\nextern struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t\tconst char *description,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tvoid *aux,\n\t\t\t\t\tstruct key *dest_keyring,\n\t\t\t\t\tunsigned long flags);\n\nextern int lookup_user_key_possessed(const struct key *key,\n\t\t\t\t     const struct key_match_data *match_data);\nextern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,\n\t\t\t\t key_perm_t perm);\n#define KEY_LOOKUP_CREATE\t0x01\n#define KEY_LOOKUP_PARTIAL\t0x02\n#define KEY_LOOKUP_FOR_UNLINK\t0x04\n\nextern long join_session_keyring(const char *name);\nextern void key_change_session_keyring(struct callback_head *twork);\n\nextern struct work_struct key_gc_work;\nextern unsigned key_gc_delay;\nextern void keyring_gc(struct key *keyring, time_t limit);\nextern void key_schedule_gc(time_t gc_at);\nextern void key_schedule_gc_links(void);\nextern void key_gc_keytype(struct key_type *ktype);\n\nextern int key_task_permission(const key_ref_t key_ref,\n\t\t\t       const struct cred *cred,\n\t\t\t       key_perm_t perm);\n\n/*\n * Check to see whether permission is granted to use a key in the desired way.\n */\nstatic inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}\n\n/*\n * Authorisation record for request_key().\n */\nstruct request_key_auth {\n\tstruct key\t\t*target_key;\n\tstruct key\t\t*dest_keyring;\n\tconst struct cred\t*cred;\n\tvoid\t\t\t*callout_info;\n\tsize_t\t\t\tcallout_len;\n\tpid_t\t\t\tpid;\n};\n\nextern struct key_type key_type_request_key_auth;\nextern struct key *request_key_auth_new(struct key *target,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tstruct key *dest_keyring);\n\nextern struct key *key_get_instantiation_authkey(key_serial_t target_id);\n\n/*\n * Determine whether a key is dead.\n */\nstatic inline bool key_is_dead(const struct key *key, time_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}\n\n/*\n * keyctl() functions\n */\nextern long keyctl_get_keyring_ID(key_serial_t, int);\nextern long keyctl_join_session_keyring(const char __user *);\nextern long keyctl_update_key(key_serial_t, const void __user *, size_t);\nextern long keyctl_revoke_key(key_serial_t);\nextern long keyctl_keyring_clear(key_serial_t);\nextern long keyctl_keyring_link(key_serial_t, key_serial_t);\nextern long keyctl_keyring_unlink(key_serial_t, key_serial_t);\nextern long keyctl_describe_key(key_serial_t, char __user *, size_t);\nextern long keyctl_keyring_search(key_serial_t, const char __user *,\n\t\t\t\t  const char __user *, key_serial_t);\nextern long keyctl_read_key(key_serial_t, char __user *, size_t);\nextern long keyctl_chown_key(key_serial_t, uid_t, gid_t);\nextern long keyctl_setperm_key(key_serial_t, key_perm_t);\nextern long keyctl_instantiate_key(key_serial_t, const void __user *,\n\t\t\t\t   size_t, key_serial_t);\nextern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);\nextern long keyctl_set_reqkey_keyring(int);\nextern long keyctl_set_timeout(key_serial_t, unsigned);\nextern long keyctl_assume_authority(key_serial_t);\nextern long keyctl_get_security(key_serial_t keyid, char __user *buffer,\n\t\t\t\tsize_t buflen);\nextern long keyctl_session_to_parent(void);\nextern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);\nextern long keyctl_instantiate_key_iov(key_serial_t,\n\t\t\t\t       const struct iovec __user *,\n\t\t\t\t       unsigned, key_serial_t);\nextern long keyctl_invalidate_key(key_serial_t);\n\nextern long keyctl_instantiate_key_common(key_serial_t,\n\t\t\t\t\t  const struct iovec *,\n\t\t\t\t\t  unsigned, size_t, key_serial_t);\n#ifdef CONFIG_PERSISTENT_KEYRINGS\nextern long keyctl_get_persistent(uid_t, key_serial_t);\nextern unsigned persistent_keyring_expiry;\n#else\nstatic inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n/*\n * Debugging key validation\n */\n#ifdef KEY_DEBUGGING\nextern void __key_check(const struct key *);\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}\n\n#else\n\n#define key_check(key) do {} while(0)\n\n#endif\n\n#endif /* _INTERNAL_H */\n", "/* Basic authentication token and access key management\n *\n * Copyright (C) 2004-2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include \"internal.h\"\n\nstruct kmem_cache *key_jar;\nstruct rb_root\t\tkey_serial_tree; /* tree of keys indexed by serial */\nDEFINE_SPINLOCK(key_serial_lock);\n\nstruct rb_root\tkey_user_tree; /* tree of quota records indexed by UID */\nDEFINE_SPINLOCK(key_user_lock);\n\nunsigned int key_quota_root_maxkeys = 200;\t/* root's key count quota */\nunsigned int key_quota_root_maxbytes = 20000;\t/* root's key space quota */\nunsigned int key_quota_maxkeys = 200;\t\t/* general key count quota */\nunsigned int key_quota_maxbytes = 20000;\t/* general key space quota */\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\n/* We serialise key instantiation and link */\nDEFINE_MUTEX(key_construction_mutex);\n\n#ifdef KEY_DEBUGGING\nvoid __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}\n#endif\n\n/*\n * Get the key quota record for a user, allocating a new record if one doesn't\n * already exist.\n */\nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p;\n\ntry_again:\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\tatomic_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\tatomic_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}\n\n/*\n * Dispose of a user structure\n */\nvoid key_user_put(struct key_user *user)\n{\n\tif (atomic_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}\n\n/*\n * Allocate a serial number for a key.  These are assigned randomly to avoid\n * security issues through covert channel problems.\n */\nstatic inline void key_alloc_serial(struct key *key)\n{\n\tstruct rb_node *parent, **p;\n\tstruct key *xkey;\n\n\t/* propose a random serial number and look for a hole for it in the\n\t * serial number tree */\n\tdo {\n\t\tget_random_bytes(&key->serial, sizeof(key->serial));\n\n\t\tkey->serial >>= 1; /* negative numbers are not permitted */\n\t} while (key->serial < 3);\n\n\tspin_lock(&key_serial_lock);\n\nattempt_insertion:\n\tparent = NULL;\n\tp = &key_serial_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\n\t\tif (key->serial < xkey->serial)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key->serial > xkey->serial)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto serial_exists;\n\t}\n\n\t/* we've found a suitable hole - arrange for this key to occupy it */\n\trb_link_node(&key->serial_node, parent, p);\n\trb_insert_color(&key->serial_node, &key_serial_tree);\n\n\tspin_unlock(&key_serial_lock);\n\treturn;\n\n\t/* we found a key with the proposed serial number - walk the tree from\n\t * that point looking for the next unused serial number */\nserial_exists:\n\tfor (;;) {\n\t\tkey->serial++;\n\t\tif (key->serial < 3) {\n\t\t\tkey->serial = 3;\n\t\t\tgoto attempt_insertion;\n\t\t}\n\n\t\tparent = rb_next(parent);\n\t\tif (!parent)\n\t\t\tgoto attempt_insertion;\n\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\t\tif (key->serial < xkey->serial)\n\t\t\tgoto attempt_insertion;\n\t}\n}\n\n/**\n * key_alloc - Allocate a key of the specified type.\n * @type: The type of key to allocate.\n * @desc: The key description to allow the key to be searched out.\n * @uid: The owner of the new key.\n * @gid: The group ID for the new key's group permissions.\n * @cred: The credentials specifying UID namespace.\n * @perm: The permissions mask of the new key.\n * @flags: Flags specifying quota properties.\n *\n * Allocate a key of the specified type with the attributes given.  The key is\n * returned in an uninstantiated state and the caller needs to instantiate the\n * key before returning.\n *\n * The user's key count quota is updated to reflect the creation of the key and\n * the user's key data quota has the default for the key type reserved.  The\n * instantiation function should amend this as necessary.  If insufficient\n * quota is available, -EDQUOT will be returned.\n *\n * The LSM security modules can prevent a key being created, in which case\n * -EACCES will be returned.\n *\n * Returns a pointer to the new key if successful and an error code otherwise.\n *\n * Note that the caller needs to ensure the key type isn't uninstantiated.\n * Internally this can be done by locking key_types_sem.  Externally, this can\n * be done by either never unregistering the key type, or making sure\n * key_alloc() calls don't race with module unloading.\n */\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tif (desc) {\n\t\tkey->index_key.desc_len = desclen;\n\t\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\t\tif (!key->description)\n\t\t\tgoto no_memory_3;\n\t}\n\n\tatomic_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_TRUSTED)\n\t\tkey->flags |= 1 << KEY_FLAG_TRUSTED;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}\nEXPORT_SYMBOL(key_alloc);\n\n/**\n * key_payload_reserve - Adjust data quota reservation for the key's payload\n * @key: The key to make the reservation for.\n * @datalen: The amount of data payload the caller now wants.\n *\n * Adjust the amount of the owning user's key data quota that a key reserves.\n * If the amount is increased, then -EDQUOT may be returned if there isn't\n * enough free quota available.\n *\n * If successful, 0 is returned.\n */\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(key_payload_reserve);\n\n/*\n * Instantiate a key and link it into the target keyring atomically.  Must be\n * called with the target keyring's semaphore writelocked.  The target key's\n * semaphore need not be locked as instantiation is serialised by\n * key_construction_mutex.\n */\nstatic int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring)\n\t\t\t\t__key_link(key, _edit);\n\n\t\t\t/* disable the authorisation key */\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret;\n}\n\n/**\n * key_instantiate_and_link - Instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @data: The data to use to instantiate the keyring.\n * @datalen: The length of @data.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Instantiate a key that's in the uninstantiated state using the provided data\n * and, if successful, link it in to the destination keyring if one is\n * supplied.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(key_instantiate_and_link);\n\n/**\n * key_reject_and_link - Negatively instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @timeout: The timeout on the negative key.\n * @error: The error to return when the key is hit.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Negatively instantiate a key that's in the uninstantiated state and, if\n * successful, set its timeout and stored error and link it in to the\n * destination keyring if one is supplied.  The key and any links to the key\n * will be automatically garbage collected after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the stored error code (typically ENOKEY) until the negative\n * key expires.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring)\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->type_data.reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\nEXPORT_SYMBOL(key_reject_and_link);\n\n/**\n * key_put - Discard a reference to a key.\n * @key: The key to discard a reference from.\n *\n * Discard a reference to a key, and when all the references are gone, we\n * schedule the cleanup task to come and pull it out of the tree in process\n * context at some later time.\n */\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (atomic_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}\nEXPORT_SYMBOL(key_put);\n\n/*\n * Find a key by its serial number.\n */\nstruct key *key_lookup(key_serial_t id)\n{\n\tstruct rb_node *n;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\t/* search the tree for the specified key */\n\tn = key_serial_tree.rb_node;\n\twhile (n) {\n\t\tkey = rb_entry(n, struct key, serial_node);\n\n\t\tif (id < key->serial)\n\t\t\tn = n->rb_left;\n\t\telse if (id > key->serial)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\nnot_found:\n\tkey = ERR_PTR(-ENOKEY);\n\tgoto error;\n\nfound:\n\t/* pretend it doesn't exist if it is awaiting deletion */\n\tif (atomic_read(&key->usage) == 0)\n\t\tgoto not_found;\n\n\t/* this races with key_put(), but that doesn't matter since key_put()\n\t * doesn't actually change the key\n\t */\n\t__key_get(key);\n\nerror:\n\tspin_unlock(&key_serial_lock);\n\treturn key;\n}\n\n/*\n * Find and lock the specified key type against removal.\n *\n * We return with the sem read-locked if successful.  If the type wasn't\n * available -ENOKEY is returned instead.\n */\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL_GPL(key_set_timeout);\n\n/*\n * Unlock a key type locked by key_type_lookup().\n */\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}\n\n/*\n * Attempt to update an existing key.\n *\n * The key is given to us with an incremented refcount that we need to discard\n * if we get an error.\n */\nstatic inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n\n/**\n * key_create_or_update - Update or create and instantiate a key.\n * @keyring_ref: A pointer to the destination keyring with possession flag.\n * @type: The type of key.\n * @description: The searchable description for the key.\n * @payload: The data to use to instantiate or update the key.\n * @plen: The length of @payload.\n * @perm: The permissions mask for a new key.\n * @flags: The quota flags for a new key.\n *\n * Search the destination keyring for a key of the same description and if one\n * is found, update it, otherwise create and instantiate a new one and create a\n * link to it from that keyring.\n *\n * If perm is KEY_PERM_UNDEF then an appropriate key permissions mask will be\n * concocted.\n *\n * Returns a pointer to the new key if successful, -ENODEV if the key type\n * wasn't available, -ENOTDIR if the keyring wasn't a keyring, -EACCES if the\n * caller isn't permitted to modify the keyring or the LSM did not permit\n * creation of the key.\n *\n * On success, the possession flag from the keyring ref will be tacked on to\n * the key ref before it is returned.\n */\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->match || !index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.trusted = flags & KEY_ALLOC_TRUSTED;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\n\t\tgoto error_free_prep;\n\tflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\nEXPORT_SYMBOL(key_create_or_update);\n\n/**\n * key_update - Update a key's contents.\n * @key_ref: The pointer (plus possession flag) to the key.\n * @payload: The data to be used to update the key.\n * @plen: The length of @payload.\n *\n * Attempt to update the contents of a key with the given payload data.  The\n * caller must be granted Write permission on the key.  Negative keys can be\n * instantiated by this method.\n *\n * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key\n * type does not support updating.  The key type may return other errors.\n */\nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* attempt to update it if supported */\n\tret = -EOPNOTSUPP;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_update);\n\n/**\n * key_revoke - Revoke a key.\n * @key: The key to be revoked.\n *\n * Mark a key as being revoked and ask the type to free up its resources.  The\n * revocation timeout is set and the key and all its links will be\n * automatically garbage collected after key_gc_delay amount of time if they\n * are not manually dealt with first.\n */\nvoid key_revoke(struct key *key)\n{\n\tstruct timespec now;\n\ttime_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\tnow = current_kernel_time();\n\ttime = now.tv_sec;\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL(key_revoke);\n\n/**\n * key_invalidate - Invalidate a key.\n * @key: The key to be invalidated.\n *\n * Mark a key as being invalidated and have it cleaned up immediately.  The key\n * is ignored by all searches and other operations from this point.\n */\nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}\nEXPORT_SYMBOL(key_invalidate);\n\n/**\n * generic_key_instantiate - Simple instantiation of a key from preparsed data\n * @key: The key to be instantiated\n * @prep: The preparsed data to load.\n *\n * Instantiate a key from preparsed data.  We assume we can just copy the data\n * in directly and clear the old pointers.\n *\n * This can be pointed to directly by the key type instantiate op pointer.\n */\nint generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\tkey->type_data.p[0] = prep->type_data[0];\n\t\tkey->type_data.p[1] = prep->type_data[1];\n\t\trcu_assign_keypointer(key, prep->payload[0]);\n\t\tkey->payload.data2[1] = prep->payload[1];\n\t\tprep->type_data[0] = NULL;\n\t\tprep->type_data[1] = NULL;\n\t\tprep->payload[0] = NULL;\n\t\tprep->payload[1] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_key_instantiate);\n\n/**\n * register_key_type - Register a type of key.\n * @ktype: The new key type.\n *\n * Register a new key type.\n *\n * Returns 0 on success or -EEXIST if a type of this name already exists.\n */\nint register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t/* disallow key types with the same name */\n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* store the type */\n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(register_key_type);\n\n/**\n * unregister_key_type - Unregister a type of key.\n * @ktype: The key type.\n *\n * Unregister a key type and mark all the extant keys of this type as dead.\n * Those keys of this type are then destroyed to get rid of their payloads and\n * they and their links will be garbage collected as soon as possible.\n */\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}\nEXPORT_SYMBOL(unregister_key_type);\n\n/*\n * Initialise the key management state.\n */\nvoid __init key_init(void)\n{\n\t/* allocate a slab in which we can store keys */\n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t/* add the special key types */\n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\n\t/* record the root user tracking */\n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}\n", "/* Keyring handling\n *\n * Copyright (C) 2004-2005, 2008, 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/*\n * When plumbing the depths of the key tree, this sets a hard limit\n * set on how deep we're willing to go.\n */\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\n/*\n * We keep all named keyrings in a hash to speed looking them up.\n */\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\n/*\n * We mark pointers we pass to the associative array with bit 1 set if\n * they're keyrings and clear otherwise.\n */\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}\n\n/*\n * The keyring key type definition.  Keyrings are simply keys of this type and\n * can be treated as ordinary keys in addition to having their own special\n * operations.\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.match\t\t= user_match,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nEXPORT_SYMBOL(key_type_keyring);\n\n/*\n * Semaphore to serialise link/link calls to prevent two link calls in parallel\n * introducing a cycle.\n */\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\n/*\n * Publish the name of a keyring so that it can be found by name (if it has\n * one).\n */\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->type_data.link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n\n/*\n * Preparse a keyring payload\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}\n\n/*\n * Free a preparse of a user defined key payload\n */\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Initialise a keyring.\n *\n * Returns 0 on success, -EINVAL if given any data.\n */\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}\n\n/*\n * Multiply 64-bits by 32-bits to 96-bits and fold back to 64-bit.  Ideally we'd\n * fold the carry back too, but that requires inline asm.\n */\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}\n\n/*\n * Hash a key type and description.\n */\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}\n\n/*\n * Build the next index key chunk.\n *\n * On 32-bit systems the index key is laid out as:\n *\n *\t0\t4\t5\t9...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * On 64-bit systems:\n *\n *\t0\t8\t9\t17...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * We return it one word-sized chunk at a time.\n */\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}\n\n/*\n * Compare the index keys of a pair of objects and determine the bit position\n * at which they differ - if they differ.\n */\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\n\n/*\n * Free an object after stripping the keyring flag off of the pointer.\n */\nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}\n\n/*\n * Operations for keyring management by the index-tree routines.\n */\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\n/*\n * Clean up a keyring when it is destroyed.  Unpublish its name if it had one\n * and dispose of its data.\n *\n * The garbage collector detects the final key_put(), removes the keyring from\n * the serial number tree and then does RCU synchronisation before coming here,\n * so we shouldn't need to worry about code poking around here with the RCU\n * readlock held by this time.\n */\nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->type_data.link.next != NULL &&\n\t\t    !list_empty(&keyring->type_data.link))\n\t\t\tlist_del(&keyring->type_data.link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}\n\n/*\n * Describe a keyring for /proc.\n */\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tqty;\n\tsize_t\t\t\tcount;\n\tkey_serial_t __user\t*buffer;\n};\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->qty);\n\n\tif (ctx->count >= ctx->qty)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}\n\n/*\n * Read a list of key IDs from the keyring's contents in binary form\n *\n * The keyring's semaphore is read-locked by the caller.  This prevents someone\n * from modifying it under us - which could cause us to read key IDs multiple\n * times.\n */\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tunsigned long nr_keys;\n\tint ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\tnr_keys = keyring->keys.nr_leaves_on_tree;\n\tif (nr_keys == 0)\n\t\treturn 0;\n\n\t/* Calculate how much data we could return */\n\tctx.qty = nr_keys * sizeof(key_serial_t);\n\n\tif (!buffer || !buflen)\n\t\treturn ctx.qty;\n\n\tif (buflen > ctx.qty)\n\t\tctx.qty = buflen;\n\n\t/* Copy the IDs of the subscribed keys into the buffer */\n\tctx.buffer = (key_serial_t __user *)buffer;\n\tctx.count = 0;\n\tret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\n\tif (ret < 0) {\n\t\tkleave(\" = %d [iterate]\", ret);\n\t\treturn ret;\n\t}\n\n\tkleave(\" = %zu [ok]\", ctx.count);\n\treturn ctx.count;\n}\n\n/*\n * Allocate a keyring and link into the destination keyring.\n */\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags, struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}\nEXPORT_SYMBOL(keyring_alloc);\n\n/*\n * Iteration function to consider each key found.\n */\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->type_data.reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n\n/*\n * Search inside a keyring for a key.  We can search by walking to it\n * directly based on its index-key or we can iterate over the entire\n * tree looking for it, based on the match function.\n */\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}\n\n/*\n * Search a tree of keyrings that point to other keyrings up to the maximum\n * depth.\n */\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tctx->flags |= KEYRING_SEARCH_DO_STATE_CHECK;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\tif (ctx->flags & KEYRING_SEARCH_NO_STATE_CHECK)\n\t\tctx->flags &= ~KEYRING_SEARCH_DO_STATE_CHECK;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = ACCESS_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = ACCESS_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = ACCESS_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = ACCESS_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = ACCESS_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now.tv_sec;\n\t\tkeyring->last_used_at = ctx->now.tv_sec;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\n\n/**\n * keyring_search_aux - Search a keyring tree for a key matching some criteria\n * @keyring_ref: A pointer to the keyring with possession indicator.\n * @ctx: The keyring search context.\n *\n * Search the supplied keyring tree for a key that matches the criteria given.\n * The root keyring and any linked keyrings must grant Search permission to the\n * caller to be searchable and keys can only be found if they too grant Search\n * to the caller. The possession flag on the root keyring pointer controls use\n * of the possessor bits in permissions checking of the entire tree.  In\n * addition, the LSM gets to forbid keyring searches and key matches.\n *\n * The search is performed as a breadth-then-depth search up to the prescribed\n * limit (KEYRING_SEARCH_MAX_DEPTH).\n *\n * Keys are matched to the type provided and are then filtered by the match\n * function, which is given the description to use in any way it sees fit.  The\n * match function may use any attributes of a key that it wishes to to\n * determine the match.  Normally the match function from the key type would be\n * used.\n *\n * RCU can be used to prevent the keyring key lists from disappearing without\n * the need to take lots of locks.\n *\n * Returns a pointer to the found key and increments the key usage count if\n * successful; -EAGAIN if no matching keys were found, or if expired or revoked\n * keys were found; -ENOKEY if only negative keys were found; -ENOTDIR if the\n * specified keyring wasn't a keyring.\n *\n * In the case of a successful return, the possession attribute from\n * @keyring_ref is propagated to the returned key reference.\n */\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = current_kernel_time();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}\n\n/**\n * keyring_search - Search the supplied keyring tree for a matching key\n * @keyring: The root of the keyring tree to be searched.\n * @type: The type of keyring we want to find.\n * @description: The name of the keyring we want to find.\n *\n * As keyring_search_aux() above, but using the current task's credentials and\n * type's default matching function and preferred search method.\n */\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\nEXPORT_SYMBOL(keyring_search);\n\n/*\n * Search the given keyring for a key that might be updated.\n *\n * The caller must guarantee that the keyring is a keyring and that the\n * permission is granted to modify the keyring as no check is made here.  The\n * caller must also hold a lock on the keyring semaphore.\n *\n * Returns a pointer to the found key with usage count incremented if\n * successful and returns NULL if not found.  Revoked and invalidated keys are\n * skipped over.\n *\n * If successful, the possession indicator is propagated from the keyring ref\n * to the returned key reference.\n */\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}\n\n/*\n * Find a keyring with the specified name.\n *\n * All named keyrings in the current user namespace are searched, provided they\n * grant Search permission directly to the caller (unless this check is\n * skipped).  Keyrings whose usage points have reached zero or who have been\n * revoked are skipped.\n *\n * Returns a pointer to the keyring with the keyring's refcount having being\n * incremented on success.  -ENOKEY is returned if a key could not be found.\n */\nstruct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!atomic_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}\n\n/*\n * See if a cycle will will be created by inserting acyclic tree B in acyclic\n * tree A at the topmost level (ie: as a direct child of A).\n *\n * Since we are adding B to A at the top level, checking for cycles should just\n * be a matter of seeing if node A is somewhere in tree B.\n */\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}\n\n/*\n * Preallocate memory so that a key can be linked into to a keyring.\n */\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Check already instantiated keys aren't going to be a problem.\n *\n * The caller must have called __key_link_begin(). Don't need to call this for\n * keys that were created since __key_link_begin() was called.\n */\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}\n\n/*\n * Link a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.  Discards any\n * already extant link to matching key if there is one, so that each keyring\n * holds at most one link to any given key of a particular type+description\n * combination.\n */\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}\n\n/*\n * Finish linking a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.\n */\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}\n\n/**\n * key_link - Link a key to a keyring\n * @keyring: The keyring to make the link in.\n * @key: The key to link to.\n *\n * Make a link in a keyring to a key, such that the keyring holds a reference\n * on that key and the key can potentially be found by searching that keyring.\n *\n * This function will write-lock the keyring's semaphore and will consume some\n * of the user's key data quota to hold the link.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring,\n * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is\n * full, -EDQUOT if there is insufficient key data quota remaining to add\n * another link or -ENOMEM if there's insufficient memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be made (the keyring should have Write permission and the key Link\n * permission).\n */\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, atomic_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags) &&\n\t    !test_bit(KEY_FLAG_TRUSTED, &key->flags))\n\t\treturn -EPERM;\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, atomic_read(&keyring->usage));\n\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, atomic_read(&keyring->usage));\n\treturn ret;\n}\nEXPORT_SYMBOL(key_link);\n\n/**\n * key_unlink - Unlink the first link to a key from a keyring.\n * @keyring: The keyring to remove the link from.\n * @key: The key the link is to.\n *\n * Remove a link from a keyring to a key.\n *\n * This function will write-lock the keyring's semaphore.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring, -ENOENT if\n * the key isn't linked to by the keyring or -ENOMEM if there's insufficient\n * memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be removed (the keyring should have Write permission; no permissions are\n * required on the key).\n */\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_unlink);\n\n/**\n * keyring_clear - Clear a keyring\n * @keyring: The keyring to clear.\n *\n * Clear the contents of the specified keyring.\n *\n * Returns 0 if successful or -ENOTDIR if the keyring isn't a keyring.\n */\nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_clear);\n\n/*\n * Dispose of the links from a revoked keyring.\n *\n * This is called with the key sem write-locked.\n */\nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}\n\n/*\n * Garbage collect pointers from a keyring.\n *\n * Not called with any locks held.  The keyring's key struct will not be\n * deallocated under us as only our caller may deallocate it.\n */\nvoid keyring_gc(struct key *keyring, time_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}\n", "/* Request a key from userspace\n *\n * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys-request-key.txt\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/keyctl.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define key_negative_timeout\t60\t/* default timeout on a negative key's existence */\n\n/*\n * wait_on_bit() sleep function for uninterruptible waiting\n */\nstatic int key_wait_bit(void *flags)\n{\n\tschedule();\n\treturn 0;\n}\n\n/*\n * wait_on_bit() sleep function for interruptible waiting\n */\nstatic int key_wait_bit_intr(void *flags)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n\n/**\n * complete_request_key - Complete the construction of a key.\n * @cons: The key construction record.\n * @error: The success or failute of the construction.\n *\n * Complete the attempt to construct a key.  The key will be negated\n * if an error is indicated.  The authorisation key will be revoked\n * unconditionally.\n */\nvoid complete_request_key(struct key_construction *cons, int error)\n{\n\tkenter(\"{%d,%d},%d\", cons->key->serial, cons->authkey->serial, error);\n\n\tif (error < 0)\n\t\tkey_negate_and_link(cons->key, key_negative_timeout, NULL,\n\t\t\t\t    cons->authkey);\n\telse\n\t\tkey_revoke(cons->authkey);\n\n\tkey_put(cons->key);\n\tkey_put(cons->authkey);\n\tkfree(cons);\n}\nEXPORT_SYMBOL(complete_request_key);\n\n/*\n * Initialise a usermode helper that is going to have a specific session\n * keyring.\n *\n * This is called in context of freshly forked kthread before kernel_execve(),\n * so we can simply install the desired session_keyring at this point.\n */\nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\n{\n\tstruct key *keyring = info->data;\n\n\treturn install_session_keyring_to_cred(cred, keyring);\n}\n\n/*\n * Clean up a usermode helper with session keyring.\n */\nstatic void umh_keys_cleanup(struct subprocess_info *info)\n{\n\tstruct key *keyring = info->data;\n\tkey_put(keyring);\n}\n\n/*\n * Call a usermode helper with a specific session keyring.\n */\nstatic int call_usermodehelper_keys(char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\tstruct subprocess_info *info;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t  umh_keys_init, umh_keys_cleanup,\n\t\t\t\t\t  session_keyring);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tkey_get(session_keyring);\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n/*\n * Request userspace finish the construction of a key\n * - execute \"/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>\"\n */\nstatic int call_sbin_request_key(struct key_construction *cons,\n\t\t\t\t const char *op,\n\t\t\t\t void *aux)\n{\n\tconst struct cred *cred = current_cred();\n\tkey_serial_t prkey, sskey;\n\tstruct key *key = cons->key, *authkey = cons->authkey, *keyring,\n\t\t*session;\n\tchar *argv[9], *envp[3], uid_str[12], gid_str[12];\n\tchar key_str[12], keyring_str[3][12];\n\tchar desc[20];\n\tint ret, i;\n\n\tkenter(\"{%d},{%d},%s\", key->serial, authkey->serial, op);\n\n\tret = install_user_keyrings();\n\tif (ret < 0)\n\t\tgoto error_alloc;\n\n\t/* allocate a new session keyring */\n\tsprintf(desc, \"_req.%u\", key->serial);\n\n\tcred = get_current_cred();\n\tkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL);\n\tput_cred(cred);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error_alloc;\n\t}\n\n\t/* attach the auth key to the session keyring */\n\tret = key_link(keyring, authkey);\n\tif (ret < 0)\n\t\tgoto error_link;\n\n\t/* record the UID and GID */\n\tsprintf(uid_str, \"%d\", from_kuid(&init_user_ns, cred->fsuid));\n\tsprintf(gid_str, \"%d\", from_kgid(&init_user_ns, cred->fsgid));\n\n\t/* we say which key is under construction */\n\tsprintf(key_str, \"%d\", key->serial);\n\n\t/* we specify the process's default keyrings */\n\tsprintf(keyring_str[0], \"%d\",\n\t\tcred->thread_keyring ? cred->thread_keyring->serial : 0);\n\n\tprkey = 0;\n\tif (cred->process_keyring)\n\t\tprkey = cred->process_keyring->serial;\n\tsprintf(keyring_str[1], \"%d\", prkey);\n\n\trcu_read_lock();\n\tsession = rcu_dereference(cred->session_keyring);\n\tif (!session)\n\t\tsession = cred->user->session_keyring;\n\tsskey = session->serial;\n\trcu_read_unlock();\n\n\tsprintf(keyring_str[2], \"%d\", sskey);\n\n\t/* set up a minimal environment */\n\ti = 0;\n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[i] = NULL;\n\n\t/* set up the argument list */\n\ti = 0;\n\targv[i++] = \"/sbin/request-key\";\n\targv[i++] = (char *) op;\n\targv[i++] = key_str;\n\targv[i++] = uid_str;\n\targv[i++] = gid_str;\n\targv[i++] = keyring_str[0];\n\targv[i++] = keyring_str[1];\n\targv[i++] = keyring_str[2];\n\targv[i] = NULL;\n\n\t/* do it */\n\tret = call_usermodehelper_keys(argv[0], argv, envp, keyring,\n\t\t\t\t       UMH_WAIT_PROC);\n\tkdebug(\"usermode -> 0x%x\", ret);\n\tif (ret >= 0) {\n\t\t/* ret is the exit/wait code */\n\t\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\n\t\t    key_validate(key) < 0)\n\t\t\tret = -ENOKEY;\n\t\telse\n\t\t\t/* ignore any errors from userspace if the key was\n\t\t\t * instantiated */\n\t\t\tret = 0;\n\t}\n\nerror_link:\n\tkey_put(keyring);\n\nerror_alloc:\n\tcomplete_request_key(cons, ret);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Call out to userspace for key construction.\n *\n * Program failure is ignored in favour of key status.\n */\nstatic int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Get the appropriate destination keyring for the request.\n *\n * The keyring selected is returned with an extra reference upon it which the\n * caller must release.\n */\nstatic void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data;\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}\n\n/*\n * Allocate a new key in under-construction state and attempt to link it in to\n * the requested keyring.\n *\n * May return a key that's already under construction instead if there was a\n * race between two thread calling request_key().\n */\nstatic int construct_alloc_key(struct keyring_search_context *ctx,\n\t\t\t       struct key *dest_keyring,\n\t\t\t       unsigned long flags,\n\t\t\t       struct key_user *user,\n\t\t\t       struct key **_key)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct key *key;\n\tkey_perm_t perm;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,,,\",\n\t       ctx->index_key.type->name, ctx->index_key.description);\n\n\t*_key = NULL;\n\tmutex_lock(&user->cons_lock);\n\n\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\tperm |= KEY_USR_VIEW;\n\tif (ctx->index_key.type->read)\n\t\tperm |= KEY_POS_READ;\n\tif (ctx->index_key.type == &key_type_keyring ||\n\t    ctx->index_key.type->update)\n\t\tperm |= KEY_POS_WRITE;\n\n\tkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\n\t\t\tctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n\t\t\tperm, flags);\n\tif (IS_ERR(key))\n\t\tgoto alloc_failed;\n\n\tset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_prealloc_failed;\n\t}\n\n\t/* attach the key to the destination keyring under lock, but we do need\n\t * to do another check just in case someone beat us to it whilst we\n\t * waited for locks */\n\tmutex_lock(&key_construction_mutex);\n\n\tkey_ref = search_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto key_already_present;\n\n\tif (dest_keyring)\n\t\t__key_link(key, &edit);\n\n\tmutex_unlock(&key_construction_mutex);\n\tif (dest_keyring)\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\n\t/* the key is now present - we tell the caller that we found it by\n\t * returning -EINPROGRESS  */\nkey_already_present:\n\tkey_put(key);\n\tmutex_unlock(&key_construction_mutex);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (dest_keyring) {\n\t\tret = __key_link_check_live_key(dest_keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_check_failed;\n\t}\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n\treturn -EINPROGRESS;\n\nlink_check_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [linkcheck]\", ret);\n\treturn ret;\n\nlink_prealloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %d [prelink]\", ret);\n\treturn ret;\n\nalloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %ld\", PTR_ERR(key));\n\treturn PTR_ERR(key);\n}\n\n/*\n * Commence key construction.\n */\nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/**\n * request_key_and_link - Request a key and cache it in a keyring.\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n * @dest_keyring: Where to cache the key.\n * @flags: Flags to key_alloc().\n *\n * A key matching the specified criteria is searched for in the process's\n * keyrings and returned with its usage count incremented if found.  Otherwise,\n * if callout_info is not NULL, a key will be allocated and some service\n * (probably in userspace) will be asked to instantiate it.\n *\n * If successfully found or created, the key will be linked to the destination\n * keyring if one is provided.\n *\n * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED\n * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was\n * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT\n * if insufficient key quota was available to create a new key; or -ENOMEM if\n * insufficient memory was available.\n *\n * If the returned key was created, then it may still be under construction,\n * and wait_for_key_construction() should be used to wait for that to complete.\n */\nstruct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n\n/**\n * wait_for_key_construction - Wait for construction of a key to complete\n * @key: The key being waited for.\n * @intr: Whether to wait interruptibly.\n *\n * Wait for a key to finish being constructed.\n *\n * Returns 0 if successful; -ERESTARTSYS if the wait was interrupted; -ENOKEY\n * if the key was negated; or -EKEYREVOKED or -EKEYEXPIRED if the key was\n * revoked or expired.\n */\nint wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? key_wait_bit_intr : key_wait_bit,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->type_data.reject_error;\n\t}\n\treturn key_validate(key);\n}\nEXPORT_SYMBOL(wait_for_key_construction);\n\n/**\n * request_key - Request a key and wait for construction\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota,\n * the callout_info must be a NUL-terminated string and no auxiliary data can\n * be passed.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key(struct key_type *type,\n\t\t\tconst char *description,\n\t\t\tconst char *callout_info)\n{\n\tstruct key *key;\n\tsize_t callout_len = 0;\n\tint ret;\n\n\tif (callout_info)\n\t\tcallout_len = strlen(callout_info);\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   NULL, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key);\n\n/**\n * request_key_with_auxdata - Request a key with auxiliary data for the upcaller\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len,\n\t\t\t\t     void *aux)\n{\n\tstruct key *key;\n\tint ret;\n\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   aux, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_with_auxdata);\n\n/*\n * request_key_async - Request a key (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota and\n * no auxiliary data can be passed.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async(struct key_type *type,\n\t\t\t      const char *description,\n\t\t\t      const void *callout_info,\n\t\t\t      size_t callout_len)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, NULL, NULL,\n\t\t\t\t    KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async);\n\n/*\n * request a key with auxiliary data for the upcaller (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t   const char *description,\n\t\t\t\t\t   const void *callout_info,\n\t\t\t\t\t   size_t callout_len,\n\t\t\t\t\t   void *aux)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async_with_auxdata);\n", "/* Request key authorisation token key definition.\n *\n * Copyright (C) 2005 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys-request-key.txt\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <keys/user-type.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\nstatic void request_key_auth_describe(const struct key *, struct seq_file *);\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\n/*\n * The request-key authorisation key type definition.\n */\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *prep)\n{\n\treturn 0;\n}\n\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Instantiate a request-key authorisation key.\n */\nstatic int request_key_auth_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\tkey->payload.data = (struct request_key_auth *)prep->data;\n\treturn 0;\n}\n\n/*\n * Describe an authorisation token.\n */\nstatic void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}\n\n/*\n * Read the callout_info data (retrieves the callout information).\n * - the key's semaphore is read-locked\n */\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Handle revocation of an authorisation token key.\n *\n * Called with the key sem write-locked.\n */\nstatic void request_key_auth_revoke(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n}\n\n/*\n * Destroy an instantiation authorisation token key.\n */\nstatic void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}\n\n/*\n * Create an authorisation token for /sbin/request-key or whoever to gain\n * access to the caller's security data.\n */\nstruct key *request_key_auth_new(struct key *target, const void *callout_info,\n\t\t\t\t size_t callout_len, struct key *dest_keyring)\n{\n\tstruct request_key_auth *rka, *irka;\n\tconst struct cred *cred = current->cred;\n\tstruct key *authkey = NULL;\n\tchar desc[20];\n\tint ret;\n\n\tkenter(\"%d,\", target->serial);\n\n\t/* allocate a auth record */\n\trka = kmalloc(sizeof(*rka), GFP_KERNEL);\n\tif (!rka) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\trka->callout_info = kmalloc(callout_len, GFP_KERNEL);\n\tif (!rka->callout_info) {\n\t\tkleave(\" = -ENOMEM\");\n\t\tkfree(rka);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* see if the calling process is already servicing the key request of\n\t * another process */\n\tif (cred->request_key_auth) {\n\t\t/* it is - use that instantiation context here too */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\t/* if the auth key has been revoked, then the key we're\n\t\t * servicing is already instantiated */\n\t\tif (test_bit(KEY_FLAG_REVOKED, &cred->request_key_auth->flags))\n\t\t\tgoto auth_key_revoked;\n\n\t\tirka = cred->request_key_auth->payload.data;\n\t\trka->cred = get_cred(irka->cred);\n\t\trka->pid = irka->pid;\n\n\t\tup_read(&cred->request_key_auth->sem);\n\t}\n\telse {\n\t\t/* it isn't - use this process as the context */\n\t\trka->cred = get_cred(cred);\n\t\trka->pid = current->pid;\n\t}\n\n\trka->target_key = key_get(target);\n\trka->dest_keyring = key_get(dest_keyring);\n\tmemcpy(rka->callout_info, callout_info, callout_len);\n\trka->callout_len = callout_len;\n\n\t/* allocate the auth key */\n\tsprintf(desc, \"%x\", target->serial);\n\n\tauthkey = key_alloc(&key_type_request_key_auth, desc,\n\t\t\t    cred->fsuid, cred->fsgid, cred,\n\t\t\t    KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error_alloc;\n\t}\n\n\t/* construct the auth key */\n\tret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error_inst;\n\n\tkleave(\" = {%d,%d}\", authkey->serial, atomic_read(&authkey->usage));\n\treturn authkey;\n\nauth_key_revoked:\n\tup_read(&cred->request_key_auth->sem);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n\tkleave(\"= -EKEYREVOKED\");\n\treturn ERR_PTR(-EKEYREVOKED);\n\nerror_inst:\n\tkey_revoke(authkey);\n\tkey_put(authkey);\nerror_alloc:\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n\tkleave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/*\n * Search the current process's keyrings for the authorisation key for\n * instantiation of a key.\n */\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}\n", "/*\n * Copyright (C) 2010 IBM Corporation\n *\n * Author:\n * David Safford <safford@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <linux/key-type.h>\n#include <linux/rcupdate.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <linux/capability.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include \"trusted.h\"\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * calculate authorization info fields to send to TPM\n */\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH1_COMMAND (Seal) result from TPM\n */\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH2_COMMAND (unseal) result from TPM\n */\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * For key specific tpm requests, we will generate and send our\n * own TPM command packets using the drivers send function.\n */\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}\n\n/*\n * Lock a trusted key, by extending a selected PCR.\n *\n * Prevents a trusted key that is sealed to PCRs from being accessed.\n * This uses the tpm driver's extend function.\n */\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}\n\n/*\n * Create an object specific authorisation protocol (OSAP) session\n */\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}\n\n/*\n * Create an object independent authorisation protocol (oiap) session\n */\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}\n\nstruct tpm_digests {\n\tunsigned char encauth[SHA1_DIGEST_SIZE];\n\tunsigned char pubauth[SHA1_DIGEST_SIZE];\n\tunsigned char xorwork[SHA1_DIGEST_SIZE * 2];\n\tunsigned char xorhash[SHA1_DIGEST_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n};\n\n/*\n * Have the TPM seal(encrypt) the trusted key, possibly based on\n * Platform Configuration Registers (PCRs). AUTH1 for sealing key.\n */\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkfree(td);\n\treturn ret;\n}\n\n/*\n * use the AUTH2_COMMAND form of unseal, to authorize both key and blob\n */\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}\n\n/*\n * Have the TPM seal(encrypt) the symmetric key\n */\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkfree(tb);\n\treturn ret;\n}\n\n/*\n * Have the TPM unseal(decrypt) the symmetric key\n */\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkfree(tb);\n\treturn ret;\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_new, Opt_load, Opt_update,\n\tOpt_keyhandle, Opt_keyauth, Opt_blobauth,\n\tOpt_pcrinfo, Opt_pcrlock, Opt_migratable\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_err, NULL}\n};\n\n/* can have zero or more token= options */\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data and fill in the\n * \t\t    payload and options structures\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}\n\n/*\n * trusted_instantiate - create a new trusted key\n *\n * Unseal an existing trusted blob or, for a new key, get a\n * random key, then seal and create a trusted key-type key,\n * adding it to the specified keyring.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkfree(datablob);\n\tkfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkfree(payload);\n\treturn ret;\n}\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tmemset(p->key, 0, p->key_len);\n\tkfree(p);\n}\n\n/*\n * trusted_update - reseal an existing key with new PCR values\n */\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}\n\n/*\n * trusted_read - copy the sealed blob data to userspace in hex.\n * On success, return to userspace the trusted key datablob size.\n */\nstatic long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = rcu_dereference_key(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\tif (!buffer || buflen <= 0)\n\t\treturn 2 * p->blob_len;\n\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\treturn -ENOMEM;\n\n\tbufp = ascii_buf;\n\tfor (i = 0; i < p->blob_len; i++)\n\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\tif ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {\n\t\tkfree(ascii_buf);\n\t\treturn -EFAULT;\n\t}\n\tkfree(ascii_buf);\n\treturn 2 * p->blob_len;\n}\n\n/*\n * trusted_destroy - before freeing the key, clear the decrypted data\n */\nstatic void trusted_destroy(struct key *key)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\n\tif (!p)\n\t\treturn;\n\tmemset(p->key, 0, p->key_len);\n\tkfree(key->payload.data);\n}\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.match = user_match,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_trusted);\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}\n\nstatic void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}\n\nlate_initcall(init_trusted);\nmodule_exit(cleanup_trusted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* user_defined.c: user defined key type\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n\nstatic int logon_vet_description(const char *desc);\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_user = {\n\t.name\t\t\t= \"user\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.match\t\t\t= user_match,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_user);\n\n/*\n * This key type is essentially the same as key_type_user, but it does\n * not define a .read op. This is suitable for storing username and\n * password pairs in the keyring that you do not want to be readable\n * from userspace.\n */\nstruct key_type key_type_logon = {\n\t.name\t\t\t= \"logon\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.match\t\t\t= user_match,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.vet_description\t= logon_vet_description,\n};\nEXPORT_SYMBOL_GPL(key_type_logon);\n\n/*\n * Preparse a user defined key payload\n */\nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(user_preparse);\n\n/*\n * Free a preparse of a user defined key payload\n */\nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkfree(prep->payload[0]);\n}\nEXPORT_SYMBOL_GPL(user_free_preparse);\n\n/*\n * update a user defined key\n * - the key's semaphore is write-locked\n */\nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_update);\n\n/*\n * match users on their name\n */\nint user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n\nEXPORT_SYMBOL_GPL(user_match);\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data;\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tkfree_rcu(upayload, rcu);\n\t}\n}\n\nEXPORT_SYMBOL(user_revoke);\n\n/*\n * dispose of the data dangling from the corpse of a user key\n */\nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data;\n\n\tkfree(upayload);\n}\n\nEXPORT_SYMBOL_GPL(user_destroy);\n\n/*\n * describe the user key\n */\nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n\nEXPORT_SYMBOL_GPL(user_describe);\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tstruct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = rcu_dereference_key(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_read);\n\n/* Vet the description for a \"logon\" key */\nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n"], "fixing_code": ["/* Asymmetric public-key cryptography key type\n *\n * See Documentation/security/asymmetric-keys.txt\n *\n * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n#include <keys/asymmetric-subtype.h>\n#include <keys/asymmetric-parser.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"asymmetric_keys.h\"\n\nMODULE_LICENSE(\"GPL\");\n\nstatic LIST_HEAD(asymmetric_key_parsers);\nstatic DECLARE_RWSEM(asymmetric_key_parsers_sem);\n\n/*\n * Match asymmetric key id with partial match\n * @id:\t\tkey id to match in a form \"id:<id>\"\n */\nint asymmetric_keyid_match(const char *kid, const char *id)\n{\n\tsize_t idlen, kidlen;\n\n\tif (!kid || !id)\n\t\treturn 0;\n\n\t/* make it possible to use id as in the request: \"id:<id>\" */\n\tif (strncmp(id, \"id:\", 3) == 0)\n\t\tid += 3;\n\n\t/* Anything after here requires a partial match on the ID string */\n\tidlen = strlen(id);\n\tkidlen = strlen(kid);\n\tif (idlen > kidlen)\n\t\treturn 0;\n\n\tkid += kidlen - idlen;\n\tif (strcasecmp(id, kid) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n\n/*\n * Match asymmetric keys on (part of) their name\n * We have some shorthand methods for matching keys.  We allow:\n *\n *\t\"<desc>\"\t- request a key by description\n *\t\"id:<id>\"\t- request a key matching the ID\n *\t\"<subtype>:<id>\" - request a key of a subtype\n */\nstatic int asymmetric_key_cmp(const struct key *key,\n\t\t\t      const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\n\t/* See if the full key description matches as is */\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\n\t/* All tests from here on break the criterion description into a\n\t * specifier, a colon and then an identifier.\n\t */\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\n\tspeclen = id - spec;\n\tid++;\n\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n * Preparse the match criterion.  If we don't set lookup_type and cmp,\n * the default will be an exact match on the key description.\n *\n * There are some specifiers for matching key IDs rather than by the key\n * description:\n *\n *\t\"id:<id>\" - request a key by any available ID\n *\n * These have to be searched by iteration rather than by direct lookup because\n * the key is hashed according to its description.\n */\nstatic int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n\treturn 0;\n}\n\n/*\n * Free the preparsed the match criterion.\n */\nstatic void asymmetric_key_match_free(struct key_match_data *match_data)\n{\n}\n\n/*\n * Describe the asymmetric key\n */\nstatic void asymmetric_key_describe(const struct key *key, struct seq_file *m)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *kid = asymmetric_key_id(key);\n\tsize_t n;\n\n\tseq_puts(m, key->description);\n\n\tif (subtype) {\n\t\tseq_puts(m, \": \");\n\t\tsubtype->describe(key, m);\n\n\t\tif (kid) {\n\t\t\tseq_putc(m, ' ');\n\t\t\tn = strlen(kid);\n\t\t\tif (n <= 8)\n\t\t\t\tseq_puts(m, kid);\n\t\t\telse\n\t\t\t\tseq_puts(m, kid + n - 8);\n\t\t}\n\n\t\tseq_puts(m, \" [\");\n\t\t/* put something here to indicate the key's capabilities */\n\t\tseq_putc(m, ']');\n\t}\n}\n\n/*\n * Preparse a asymmetric payload to get format the contents appropriately for the\n * internal payload to cut down on the number of scans of the data performed.\n *\n * We also generate a proposed description from the contents of the key that\n * can be used to name the key if the user doesn't want to provide one.\n */\nstatic int asymmetric_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct asymmetric_key_parser *parser;\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (prep->datalen == 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&asymmetric_key_parsers_sem);\n\n\tret = -EBADMSG;\n\tlist_for_each_entry(parser, &asymmetric_key_parsers, link) {\n\t\tpr_debug(\"Trying parser '%s'\\n\", parser->name);\n\n\t\tret = parser->parse(prep);\n\t\tif (ret != -EBADMSG) {\n\t\t\tpr_debug(\"Parser recognised the format (ret %d)\\n\",\n\t\t\t\t ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&asymmetric_key_parsers_sem);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n/*\n * Clean up the preparse data\n */\nstatic void asymmetric_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct asymmetric_key_subtype *subtype = prep->type_data[0];\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tif (subtype) {\n\t\tsubtype->destroy(prep->payload[0]);\n\t\tmodule_put(subtype->owner);\n\t}\n\tkfree(prep->type_data[1]);\n\tkfree(prep->description);\n}\n\n/*\n * dispose of the data dangling from the corpse of a asymmetric key\n */\nstatic void asymmetric_key_destroy(struct key *key)\n{\n\tstruct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tif (subtype) {\n\t\tsubtype->destroy(key->payload.data);\n\t\tmodule_put(subtype->owner);\n\t\tkey->type_data.p[0] = NULL;\n\t}\n\tkfree(key->type_data.p[1]);\n\tkey->type_data.p[1] = NULL;\n}\n\nstruct key_type key_type_asymmetric = {\n\t.name\t\t= \"asymmetric\",\n\t.preparse\t= asymmetric_key_preparse,\n\t.free_preparse\t= asymmetric_key_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match_preparse\t= asymmetric_key_match_preparse,\n\t.match_free\t= asymmetric_key_match_free,\n\t.destroy\t= asymmetric_key_destroy,\n\t.describe\t= asymmetric_key_describe,\n};\nEXPORT_SYMBOL_GPL(key_type_asymmetric);\n\n/**\n * register_asymmetric_key_parser - Register a asymmetric key blob parser\n * @parser: The parser to register\n */\nint register_asymmetric_key_parser(struct asymmetric_key_parser *parser)\n{\n\tstruct asymmetric_key_parser *cursor;\n\tint ret;\n\n\tdown_write(&asymmetric_key_parsers_sem);\n\n\tlist_for_each_entry(cursor, &asymmetric_key_parsers, link) {\n\t\tif (strcmp(cursor->name, parser->name) == 0) {\n\t\t\tpr_err(\"Asymmetric key parser '%s' already registered\\n\",\n\t\t\t       parser->name);\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_tail(&parser->link, &asymmetric_key_parsers);\n\n\tpr_notice(\"Asymmetric key parser '%s' registered\\n\", parser->name);\n\tret = 0;\n\nout:\n\tup_write(&asymmetric_key_parsers_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_asymmetric_key_parser);\n\n/**\n * unregister_asymmetric_key_parser - Unregister a asymmetric key blob parser\n * @parser: The parser to unregister\n */\nvoid unregister_asymmetric_key_parser(struct asymmetric_key_parser *parser)\n{\n\tdown_write(&asymmetric_key_parsers_sem);\n\tlist_del(&parser->link);\n\tup_write(&asymmetric_key_parsers_sem);\n\n\tpr_notice(\"Asymmetric key parser '%s' unregistered\\n\", parser->name);\n}\nEXPORT_SYMBOL_GPL(unregister_asymmetric_key_parser);\n\n/*\n * Module stuff\n */\nstatic int __init asymmetric_key_init(void)\n{\n\treturn register_key_type(&key_type_asymmetric);\n}\n\nstatic void __exit asymmetric_key_cleanup(void)\n{\n\tunregister_key_type(&key_type_asymmetric);\n}\n\nmodule_init(asymmetric_key_init);\nmodule_exit(asymmetric_key_cleanup);\n", "/* Testing module to load key from trusted PKCS#7 message\n *\n * Copyright (C) 2014 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) \"PKCS7key: \"fmt\n#include <linux/key.h>\n#include <linux/err.h>\n#include <linux/key-type.h>\n#include <crypto/pkcs7.h>\n#include <keys/user-type.h>\n#include <keys/system_keyring.h>\n#include \"pkcs7_parser.h\"\n\n/*\n * Preparse a PKCS#7 wrapped and validated data blob.\n */\nstatic int pkcs7_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct pkcs7_message *pkcs7;\n\tconst void *data, *saved_prep_data;\n\tsize_t datalen, saved_prep_datalen;\n\tbool trusted;\n\tint ret;\n\n\tkenter(\"\");\n\n\tsaved_prep_data = prep->data;\n\tsaved_prep_datalen = prep->datalen;\n\tpkcs7 = pkcs7_parse_message(saved_prep_data, saved_prep_datalen);\n\tif (IS_ERR(pkcs7)) {\n\t\tret = PTR_ERR(pkcs7);\n\t\tgoto error;\n\t}\n\n\tret = pkcs7_verify(pkcs7);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tret = pkcs7_validate_trust(pkcs7, system_trusted_keyring, &trusted);\n\tif (ret < 0)\n\t\tgoto error_free;\n\tif (!trusted)\n\t\tpr_warn(\"PKCS#7 message doesn't chain back to a trusted key\\n\");\n\n\tret = pkcs7_get_content_data(pkcs7, &data, &datalen, false);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tprep->data = data;\n\tprep->datalen = datalen;\n\tret = user_preparse(prep);\n\tprep->data = saved_prep_data;\n\tprep->datalen = saved_prep_datalen;\n\nerror_free:\n\tpkcs7_free_message(pkcs7);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstatic struct key_type key_type_pkcs7 = {\n\t.name\t\t\t= \"pkcs7_test\",\n\t.preparse\t\t= pkcs7_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\n/*\n * Module stuff\n */\nstatic int __init pkcs7_key_init(void)\n{\n\treturn register_key_type(&key_type_pkcs7);\n}\n\nstatic void __exit pkcs7_key_cleanup(void)\n{\n\tunregister_key_type(&key_type_pkcs7);\n}\n\nmodule_init(pkcs7_key_init);\nmodule_exit(pkcs7_key_cleanup);\n", "/*\n *   fs/cifs/cifs_spnego.c -- SPNEGO upcall management for CIFS\n *\n *   Copyright (c) 2007 Red Hat, Inc.\n *   Author(s): Jeff Layton (jlayton@redhat.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/inet.h>\n#include \"cifsglob.h\"\n#include \"cifs_spnego.h\"\n#include \"cifs_debug.h\"\n\n/* create a new cifs key */\nstatic int\ncifs_spnego_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\tint ret;\n\n\tret = -ENOMEM;\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\tgoto error;\n\n\t/* attach the data */\n\tkey->payload.data = payload;\n\tret = 0;\n\nerror:\n\treturn ret;\n}\n\nstatic void\ncifs_spnego_key_destroy(struct key *key)\n{\n\tkfree(key->payload.data);\n}\n\n\n/*\n * keytype for CIFS spnego keys\n */\nstruct key_type cifs_spnego_key_type = {\n\t.name\t\t= \"cifs.spnego\",\n\t.instantiate\t= cifs_spnego_key_instantiate,\n\t.destroy\t= cifs_spnego_key_destroy,\n\t.describe\t= user_describe,\n};\n\n/* length of longest version string e.g.  strlen(\"ver=0xFF\") */\n#define MAX_VER_STR_LEN\t\t8\n\n/* length of longest security mechanism name, eg in future could have\n * strlen(\";sec=ntlmsspi\") */\n#define MAX_MECH_STR_LEN\t13\n\n/* strlen of \"host=\" */\n#define HOST_KEY_LEN\t\t5\n\n/* strlen of \";ip4=\" or \";ip6=\" */\n#define IP_KEY_LEN\t\t5\n\n/* strlen of \";uid=0x\" */\n#define UID_KEY_LEN\t\t7\n\n/* strlen of \";creduid=0x\" */\n#define CREDUID_KEY_LEN\t\t11\n\n/* strlen of \";user=\" */\n#define USER_KEY_LEN\t\t6\n\n/* strlen of \";pid=0x\" */\n#define PID_KEY_LEN\t\t7\n\n/* get a key struct with a SPNEGO security blob, suitable for session setup */\nstruct key *\ncifs_get_spnego_key(struct cifs_ses *sesInfo)\n{\n\tstruct TCP_Server_Info *server = sesInfo->server;\n\tstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\n\tstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\n\tchar *description, *dp;\n\tsize_t desc_len;\n\tstruct key *spnego_key;\n\tconst char *hostname = server->hostname;\n\n\t/* length of fields (with semicolons): ver=0xyz ip4=ipaddress\n\t   host=hostname sec=mechanism uid=0xFF user=username */\n\tdesc_len = MAX_VER_STR_LEN +\n\t\t   HOST_KEY_LEN + strlen(hostname) +\n\t\t   IP_KEY_LEN + INET6_ADDRSTRLEN +\n\t\t   MAX_MECH_STR_LEN +\n\t\t   UID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   CREDUID_KEY_LEN + (sizeof(uid_t) * 2) +\n\t\t   PID_KEY_LEN + (sizeof(pid_t) * 2) + 1;\n\n\tif (sesInfo->user_name)\n\t\tdesc_len += USER_KEY_LEN + strlen(sesInfo->user_name);\n\n\tspnego_key = ERR_PTR(-ENOMEM);\n\tdescription = kzalloc(desc_len, GFP_KERNEL);\n\tif (description == NULL)\n\t\tgoto out;\n\n\tdp = description;\n\t/* start with version and hostname portion of UNC string */\n\tspnego_key = ERR_PTR(-EINVAL);\n\tsprintf(dp, \"ver=0x%x;host=%s;\", CIFS_SPNEGO_UPCALL_VERSION,\n\t\thostname);\n\tdp = description + strlen(description);\n\n\t/* add the server address */\n\tif (server->dstaddr.ss_family == AF_INET)\n\t\tsprintf(dp, \"ip4=%pI4\", &sa->sin_addr);\n\telse if (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(dp, \"ip6=%pI6\", &sa6->sin6_addr);\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\n\t/* for now, only sec=krb5 and sec=mskrb5 are valid */\n\tif (server->sec_kerberos)\n\t\tsprintf(dp, \";sec=krb5\");\n\telse if (server->sec_mskerberos)\n\t\tsprintf(dp, \";sec=mskrb5\");\n\telse\n\t\tgoto out;\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";uid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->linux_uid));\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";creduid=0x%x\",\n\t\tfrom_kuid_munged(&init_user_ns, sesInfo->cred_uid));\n\n\tif (sesInfo->user_name) {\n\t\tdp = description + strlen(description);\n\t\tsprintf(dp, \";user=%s\", sesInfo->user_name);\n\t}\n\n\tdp = description + strlen(description);\n\tsprintf(dp, \";pid=0x%x\", current->pid);\n\n\tcifs_dbg(FYI, \"key description = %s\\n\", description);\n\tspnego_key = request_key(&cifs_spnego_key_type, description, \"\");\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (cifsFYI && !IS_ERR(spnego_key)) {\n\t\tstruct cifs_spnego_msg *msg = spnego_key->payload.data;\n\t\tcifs_dump_mem(\"SPNEGO reply blob:\", msg->data, min(1024U,\n\t\t\t\tmsg->secblob_len + msg->sesskey_len));\n\t}\n#endif /* CONFIG_CIFS_DEBUG2 */\n\nout:\n\tkfree(description);\n\treturn spnego_key;\n}\n", "/*\n *   fs/cifs/cifsacl.c\n *\n *   Copyright (C) International Business Machines  Corp., 2007,2008\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   Contains the routines for mapping CIFS/NTFS ACLs\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/keyctl.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n\n/* security id for everyone/world system group */\nstatic const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n/* security id for Authenticated Users system group */\nstatic const struct cifs_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {__constant_cpu_to_le32(11)} };\n/* group users */\nstatic const struct cifs_sid sid_user = {1, 2 , {0, 0, 0, 0, 0, 5}, {} };\n\nstatic const struct cred *root_cred;\n\nstatic int\ncifs_idmap_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\n\t/*\n\t * If the payload is less than or equal to the size of a pointer, then\n\t * an allocation here is wasteful. Just copy the data directly to the\n\t * payload.value union member instead.\n\t *\n\t * With this however, you must check the datalen before trying to\n\t * dereference payload.data!\n\t */\n\tif (prep->datalen <= sizeof(key->payload)) {\n\t\tkey->payload.value = 0;\n\t\tmemcpy(&key->payload.value, prep->data, prep->datalen);\n\t\tkey->datalen = prep->datalen;\n\t\treturn 0;\n\t}\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\treturn -ENOMEM;\n\n\tkey->payload.data = payload;\n\tkey->datalen = prep->datalen;\n\treturn 0;\n}\n\nstatic inline void\ncifs_idmap_key_destroy(struct key *key)\n{\n\tif (key->datalen > sizeof(key->payload))\n\t\tkfree(key->payload.data);\n}\n\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nstatic char *\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\n\t/* 3 bytes for prefix */\n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\n\t/* The authority field is a single 48-bit number */\n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\n\t/*\n\t * MS-DTYP states that if the authority is >= 2^32, then it should be\n\t * expressed as a hex value.\n\t */\n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\n\tstrptr += len;\n\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\n\treturn sidstr;\n}\n\n/*\n * if the two SIDs (roughly equivalent to a UUID for a user or group) are\n * the same returns zero, if they do not match returns non-zero.\n */\nstatic int\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif ((!ctsid) || (!cwsid))\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t\tle32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}\n\nstatic void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}\n\nstatic int\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tstruct cifs_sid *ksid;\n\tunsigned int ksid_size;\n\tchar desc[3 + 10 + 1]; /* 3 byte prefix + 10 bytes for value + NULL */\n\tconst struct cred *saved_cred;\n\n\trc = snprintf(desc, sizeof(desc), \"%ci:%u\",\n\t\t\tsidtype == SIDOWNER ? 'o' : 'g', cid);\n\tif (rc >= sizeof(desc))\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, desc, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map %cid %u to a SID\\n\",\n\t\t\t __func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\n\t\tgoto out_revert_creds;\n\t} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tgoto invalidate_key;\n\t}\n\n\t/*\n\t * A sid is usually too large to be embedded in payload.value, but if\n\t * there are no subauthorities and the host has 8-byte pointers, then\n\t * it could be.\n\t */\n\tksid = sidkey->datalen <= sizeof(sidkey->payload) ?\n\t\t(struct cifs_sid *)&sidkey->payload.value :\n\t\t(struct cifs_sid *)sidkey->payload.data;\n\n\tksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\n\tif (ksid_size > sidkey->datalen) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\",\n\t\t\t __func__, sidkey->datalen, ksid_size);\n\t\tgoto invalidate_key;\n\t}\n\n\tcifs_copy_sid(ssid, ksid);\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\treturn rc;\n\ninvalidate_key:\n\tkey_invalidate(sidkey);\n\tgoto out_key_put;\n}\n\nstatic int\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t/*\n\t * FIXME: Here we assume that uid_t and gid_t are same size. It's\n\t * probably a safe assumption but might be better to check based on\n\t * sidtype.\n\t */\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\n\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\n\t/*\n\t * Note that we return 0 here unconditionally. If the mapping\n\t * fails then we just fall back to using the mnt_uid/mnt_gid.\n\t */\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn 0;\n}\n\nint\ninit_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\n\t/* create an override credential set with a special thread keyring in\n\t * which requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nvoid\nexit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}\n\n/* copy ntsd, owner sid, and group sid from a security descriptor to another */\nstatic void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\n\t/* copy security descriptor control portion */\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\n\t/* copy owner sid */\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\n\t/* copy group sid */\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\n\treturn;\n}\n\n\n/*\n   change posix mode to reflect permissions\n   pmode is the existing mode (we only want to overwrite part of this\n   bits to set can be: S_IRWXU, S_IRWXG or S_IRWXO ie 00700 or 00070 or 00007\n*/\nstatic void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}\n\n/*\n   Generate access flags to reflect permissions mode is the existing mode.\n   This function is called for every ACE in the DACL whose SID matches\n   with either owner or group or everyone.\n*/\n\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t__u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/* check for R/W/X UGO since we do not know whose flags\n\t   is this but we have cleared all the bits sans RWX for\n\t   either user or group or other as per bits_to_use */\n\tif (mode & S_IRUGO)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & S_IWUGO)\n\t\t*pace_flags |= SET_FILE_WRITE_RIGHTS;\n\tif (mode & S_IXUGO)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tcifs_dbg(NOISY, \"mode: 0x%x, access flags now 0x%x\\n\",\n\t\t mode, *pace_flags);\n\treturn;\n}\n\nstatic __u16 fill_ace_for_sid(struct cifs_ace *pntace,\n\t\t\tconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = ACCESS_ALLOWED;\n\tpntace->flags = 0x0;\n\tmode_to_access_flags(nmode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}\n\n\n#ifdef CONFIG_CIFS_DEBUG2\nstatic void dump_ace(struct cifs_ace *pace, char *end_of_acl)\n{\n\tint num_subauth;\n\n\t/* validate that we do not go past end of acl */\n\n\tif (le16_to_cpu(pace->size) < 16) {\n\t\tcifs_dbg(VFS, \"ACE too small %d\\n\", le16_to_cpu(pace->size));\n\t\treturn;\n\t}\n\n\tif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse ACE\\n\");\n\t\treturn;\n\t}\n\n\tnum_subauth = pace->sid.num_subauth;\n\tif (num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"ACE revision %d num_auth %d type %d flags %d size %d\\n\",\n\t\t\t pace->sid.revision, pace->sid.num_subauth, pace->type,\n\t\t\t pace->flags, le16_to_cpu(pace->size));\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tcifs_dbg(FYI, \"ACE sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(pace->sid.sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t}\n\n\treturn;\n}\n#endif\n\n\nstatic void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\n\t\t       struct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\t       struct cifs_fattr *fattr)\n{\n\tint i;\n\tint num_aces = 0;\n\tint acl_size;\n\tchar *acl_base;\n\tstruct cifs_ace **ppace;\n\n\t/* BB need to add parm so we can store the SID BB */\n\n\tif (!pdacl) {\n\t\t/* no DACL in the security descriptor, set\n\t\t   all the permissions for user/group/other */\n\t\tfattr->cf_mode |= S_IRWXUGO;\n\t\treturn;\n\t}\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tcifs_dbg(NOISY, \"DACL revision %d size %d num aces %d\\n\",\n\t\t le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t le32_to_cpu(pdacl->num_aces));\n\n\t/* reset rwx permissions for user/group/other.\n\t   Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t   user/group/other have no permissions */\n\tfattr->cf_mode &= ~(S_IRWXUGO);\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct cifs_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces > 0) {\n\t\tumode_t user_mask = S_IRWXU;\n\t\tumode_t group_mask = S_IRWXG;\n\t\tumode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\n\n\t\tif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\n\t\t\treturn;\n\t\tppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ppace)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num_aces; ++i) {\n\t\t\tppace[i] = (struct cifs_ace *) (acl_base + acl_size);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tdump_ace(ppace[i], end_of_acl);\n#endif\n\t\t\tif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &user_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &group_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\n\n/*\t\t\tmemcpy((void *)(&(cifscred->aces[i])),\n\t\t\t\t(void *)ppace[i],\n\t\t\t\tsizeof(struct cifs_ace)); */\n\n\t\t\tacl_base = (char *)ppace[i];\n\t\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\t}\n\n\t\tkfree(ppace);\n\t}\n\n\treturn;\n}\n\n\nstatic int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\n\t\t\tstruct cifs_sid *pgrpsid, __u64 nmode)\n{\n\tu16 size = 0;\n\tstruct cifs_acl *pnndacl;\n\n\tpnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\n\n\tsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\n\t\t\t\t\tpownersid, nmode, S_IRWXU);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\tpgrpsid, nmode, S_IRWXG);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\t &sid_everyone, nmode, S_IRWXO);\n\n\tpndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\n\tpndacl->num_aces = cpu_to_le32(3);\n\n\treturn 0;\n}\n\n\nstatic int parse_sid(struct cifs_sid *psid, char *end_of_acl)\n{\n\t/* BB need to add parm so we can store the SID BB */\n\n\t/* validate that we do not go past end of ACL - sid must be at least 8\n\t   bytes long (assuming no sub-auths - e.g. the null SID */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (psid->num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"SID revision %d num_auth %d\\n\",\n\t\t\t psid->revision, psid->num_subauth);\n\n\t\tfor (i = 0; i < psid->num_subauth; i++) {\n\t\t\tcifs_dbg(FYI, \"SID sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(psid->sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t\tcifs_dbg(FYI, \"RID 0x%x\\n\",\n\t\t\t le32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\n\t}\n#endif\n\n\treturn 0;\n}\n\n\n/* Convert CIFS ACL to POSIX form */\nstatic int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}\n\n/* Convert permission bits from mode to equivalent CIFS ACL */\nstatic int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\n\t__u32 secdesclen, __u64 nmode, kuid_t uid, kgid_t gid, int *aclflag)\n{\n\tint rc = 0;\n\t__u32 dacloffset;\n\t__u32 ndacloffset;\n\t__u32 sidsoffset;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct cifs_acl *dacl_ptr = NULL;  /* no need for SACL ptr */\n\tstruct cifs_acl *ndacl_ptr = NULL; /* no need for SACL ptr */\n\n\tif (nmode != NO_CHANGE_64) { /* chmod */\n\t\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision = dacl_ptr->revision;\n\t\tndacl_ptr->size = 0;\n\t\tndacl_ptr->num_aces = 0;\n\n\t\trc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\n\t\t\t\t\tnmode);\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t/* copy sec desc control portion & owner and group sids */\n\t\tcopy_sec_desc(pntsd, pnntsd, sidsoffset);\n\t\t*aclflag = CIFS_ACL_DACL;\n\t} else {\n\t\tmemcpy(pnntsd, pntsd, secdesclen);\n\t\tif (uid_valid(uid)) { /* chown */\n\t\t\tuid_t id;\n\t\t\towner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->osidoffset));\n\t\t\tnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nowner_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kuid(&init_user_ns, uid);\n\t\t\trc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for owner id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(nowner_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\t\tkfree(nowner_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_OWNER;\n\t\t}\n\t\tif (gid_valid(gid)) { /* chgrp */\n\t\t\tgid_t id;\n\t\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->gsidoffset));\n\t\t\tngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ngroup_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kgid(&init_user_ns, gid);\n\t\t\trc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for group id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_GROUP;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstruct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\tconst struct cifs_fid *cifsfid, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), cifsfid->netfid, &pntsd,\n\t\t\t\tpacllen);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}\n\nstatic struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\tconst char *path, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = READ_CONTROL;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (!rc) {\n\t\trc = CIFSSMBGetCIFSACL(xid, tcon, fid.netfid, &pntsd, pacllen);\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}\n\n/* Retrieve an ACL from the server */\nstruct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}\n\n /* Set an ACL on the server */\nint set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\n\t\t\tstruct inode *inode, const char *path, int aclflag)\n{\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, access_flags, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)\n\t\taccess_flags = WRITE_OWNER;\n\telse\n\t\taccess_flags = WRITE_DAC;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = access_flags;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Unable to open file to set ACL\\n\");\n\t\tgoto out;\n\t}\n\n\trc = CIFSSMBSetCIFSACL(xid, tcon, fid.netfid, pnntsd, acllen, aclflag);\n\tcifs_dbg(NOISY, \"SetCIFSACL rc = %d\\n\", rc);\n\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\n/* Translate the CIFS ACL (simlar to NTFS ACL) for a file into mode bits */\nint\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t  struct inode *inode, const char *path,\n\t\t  const struct cifs_fid *pfid)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu32 acllen = 0;\n\tint rc = 0;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(NOISY, \"converting ACL to mode for %s\\n\", path);\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (pfid && (tcon->ses->server->ops->get_acl_by_fid))\n\t\tpntsd = tcon->ses->server->ops->get_acl_by_fid(cifs_sb, pfid,\n\t\t\t\t\t\t\t  &acllen);\n\telse if (tcon->ses->server->ops->get_acl)\n\t\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t\t&acllen);\n\telse {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* if we can retrieve the ACL, now parse Access Control Entries, ACEs */\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t} else {\n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\n\t\tkfree(pntsd);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"parse sec desc failed rc = %d\\n\", rc);\n\t}\n\n\tcifs_put_tlink(tlink);\n\n\treturn rc;\n}\n\n/* Convert mode bits to an ACL so we can update the ACL on the server */\nint\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\n\t\t\tkuid_t uid, kgid_t gid)\n{\n\tint rc = 0;\n\tint aclflag = CIFS_ACL_DACL; /* default flag to set */\n\t__u32 secdesclen = 0;\n\tstruct cifs_ntsd *pntsd = NULL; /* acl obtained from server */\n\tstruct cifs_ntsd *pnntsd = NULL; /* modified acl to be sent to server */\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tcifs_dbg(NOISY, \"set ACL from mode for %s\\n\", path);\n\n\t/* Get the security descriptor */\n\n\tif (tcon->ses->server->ops->get_acl == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t&secdesclen);\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Add three ACEs for owner, group, everyone getting rid of other ACEs\n\t * as chmod disables ACEs and set the security descriptor. Allocate\n\t * memory for the smb header, set security descriptor request security\n\t * descriptor parameters, and secuirty descriptor itself\n\t */\n\tsecdesclen = max_t(u32, secdesclen, DEFAULT_SEC_DESC_LEN);\n\tpnntsd = kmalloc(secdesclen, GFP_KERNEL);\n\tif (!pnntsd) {\n\t\tkfree(pntsd);\n\t\tcifs_put_tlink(tlink);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\n\t\t\t\t&aclflag);\n\n\tcifs_dbg(NOISY, \"build_sec_desc rc: %d\\n\", rc);\n\n\tif (tcon->ses->server->ops->set_acl == NULL)\n\t\trc = -EOPNOTSUPP;\n\n\tif (!rc) {\n\t\t/* Set the security descriptor */\n\t\trc = tcon->ses->server->ops->set_acl(pnntsd, secdesclen, inode,\n\t\t\t\t\t\t     path, aclflag);\n\t\tcifs_dbg(NOISY, \"set_cifs_acl rc: %d\\n\", rc);\n\t}\n\tcifs_put_tlink(tlink);\n\n\tkfree(pnntsd);\n\tkfree(pntsd);\n\treturn rc;\n}\n", "/*\n * fs/nfs/idmap.c\n *\n *  UID and GID to name mapping for clients.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Marius Aamodt Eriksen <marius@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include <linux/types.h>\n#include <linux/parser.h>\n#include <linux/fs.h>\n#include <linux/nfs_idmap.h>\n#include <net/net_namespace.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n\n#include \"internal.h\"\n#include \"netns.h\"\n#include \"nfs4trace.h\"\n\n#define NFS_UINT_MAXLEN 11\n\nstatic const struct cred *id_resolver_cache;\nstatic struct key_type key_type_id_resolver_legacy;\n\nstruct idmap_legacy_upcalldata {\n\tstruct rpc_pipe_msg pipe_msg;\n\tstruct idmap_msg idmap_msg;\n\tstruct key_construction\t*key_cons;\n\tstruct idmap *idmap;\n};\n\nstruct idmap {\n\tstruct rpc_pipe_dir_object idmap_pdo;\n\tstruct rpc_pipe\t\t*idmap_pipe;\n\tstruct idmap_legacy_upcalldata *idmap_upcall_data;\n\tstruct mutex\t\tidmap_mutex;\n};\n\n/**\n * nfs_fattr_init_names - initialise the nfs_fattr owner_name/group_name fields\n * @fattr: fully initialised struct nfs_fattr\n * @owner_name: owner name string cache\n * @group_name: group name string cache\n */\nvoid nfs_fattr_init_names(struct nfs_fattr *fattr,\n\t\tstruct nfs4_string *owner_name,\n\t\tstruct nfs4_string *group_name)\n{\n\tfattr->owner_name = owner_name;\n\tfattr->group_name = group_name;\n}\n\nstatic void nfs_fattr_free_owner_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_OWNER_NAME;\n\tkfree(fattr->owner_name->data);\n}\n\nstatic void nfs_fattr_free_group_name(struct nfs_fattr *fattr)\n{\n\tfattr->valid &= ~NFS_ATTR_FATTR_GROUP_NAME;\n\tkfree(fattr->group_name->data);\n}\n\nstatic bool nfs_fattr_map_owner_name(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_string *owner = fattr->owner_name;\n\tkuid_t uid;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_OWNER_NAME))\n\t\treturn false;\n\tif (nfs_map_name_to_uid(server, owner->data, owner->len, &uid) == 0) {\n\t\tfattr->uid = uid;\n\t\tfattr->valid |= NFS_ATTR_FATTR_OWNER;\n\t}\n\treturn true;\n}\n\nstatic bool nfs_fattr_map_group_name(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_string *group = fattr->group_name;\n\tkgid_t gid;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_GROUP_NAME))\n\t\treturn false;\n\tif (nfs_map_group_to_gid(server, group->data, group->len, &gid) == 0) {\n\t\tfattr->gid = gid;\n\t\tfattr->valid |= NFS_ATTR_FATTR_GROUP;\n\t}\n\treturn true;\n}\n\n/**\n * nfs_fattr_free_names - free up the NFSv4 owner and group strings\n * @fattr: a fully initialised nfs_fattr structure\n */\nvoid nfs_fattr_free_names(struct nfs_fattr *fattr)\n{\n\tif (fattr->valid & NFS_ATTR_FATTR_OWNER_NAME)\n\t\tnfs_fattr_free_owner_name(fattr);\n\tif (fattr->valid & NFS_ATTR_FATTR_GROUP_NAME)\n\t\tnfs_fattr_free_group_name(fattr);\n}\n\n/**\n * nfs_fattr_map_and_free_names - map owner/group strings into uid/gid and free\n * @server: pointer to the filesystem nfs_server structure\n * @fattr: a fully initialised nfs_fattr structure\n *\n * This helper maps the cached NFSv4 owner/group strings in fattr into\n * their numeric uid/gid equivalents, and then frees the cached strings.\n */\nvoid nfs_fattr_map_and_free_names(struct nfs_server *server, struct nfs_fattr *fattr)\n{\n\tif (nfs_fattr_map_owner_name(server, fattr))\n\t\tnfs_fattr_free_owner_name(fattr);\n\tif (nfs_fattr_map_group_name(server, fattr))\n\t\tnfs_fattr_free_group_name(fattr);\n}\n\nstatic int nfs_map_string_to_numeric(const char *name, size_t namelen, __u32 *res)\n{\n\tunsigned long val;\n\tchar buf[16];\n\n\tif (memchr(name, '@', namelen) != NULL || namelen >= sizeof(buf))\n\t\treturn 0;\n\tmemcpy(buf, name, namelen);\n\tbuf[namelen] = '\\0';\n\tif (kstrtoul(buf, 0, &val) != 0)\n\t\treturn 0;\n\t*res = val;\n\treturn 1;\n}\n\nstatic int nfs_map_numeric_to_string(__u32 id, char *buf, size_t buflen)\n{\n\treturn snprintf(buf, buflen, \"%u\", id);\n}\n\nstatic struct key_type key_type_id_resolver = {\n\t.name\t\t= \"id_resolver\",\n\t.preparse\t= user_preparse,\n\t.free_preparse\t= user_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= user_describe,\n\t.read\t\t= user_read,\n};\n\nstatic int nfs_idmap_init_keyring(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret = 0;\n\n\tprintk(KERN_NOTICE \"NFS: Registering the %s key type\\n\",\n\t\tkey_type_id_resolver.name);\n\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".id_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_id_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\tret = register_key_type(&key_type_id_resolver_legacy);\n\tif (ret < 0)\n\t\tgoto failed_reg_legacy;\n\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tid_resolver_cache = cred;\n\treturn 0;\n\nfailed_reg_legacy:\n\tunregister_key_type(&key_type_id_resolver);\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void nfs_idmap_quit_keyring(void)\n{\n\tkey_revoke(id_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_id_resolver);\n\tunregister_key_type(&key_type_id_resolver_legacy);\n\tput_cred(id_resolver_cache);\n}\n\n/*\n * Assemble the description to pass to request_key()\n * This function will allocate a new string and update dest to point\n * at it.  The caller is responsible for freeing dest.\n *\n * On error 0 is returned.  Otherwise, the length of dest is returned.\n */\nstatic ssize_t nfs_idmap_get_desc(const char *name, size_t namelen,\n\t\t\t\tconst char *type, size_t typelen, char **desc)\n{\n\tchar *cp;\n\tsize_t desclen = typelen + namelen + 2;\n\n\t*desc = kmalloc(desclen, GFP_KERNEL);\n\tif (!*desc)\n\t\treturn -ENOMEM;\n\n\tcp = *desc;\n\tmemcpy(cp, type, typelen);\n\tcp += typelen;\n\t*cp++ = ':';\n\n\tmemcpy(cp, name, namelen);\n\tcp += namelen;\n\t*cp = '\\0';\n\treturn desclen;\n}\n\nstatic struct key *nfs_idmap_request_key(const char *name, size_t namelen,\n\t\t\t\t\t const char *type, struct idmap *idmap)\n{\n\tchar *desc;\n\tstruct key *rkey;\n\tssize_t ret;\n\n\tret = nfs_idmap_get_desc(name, namelen, type, strlen(type), &desc);\n\tif (ret <= 0)\n\t\treturn ERR_PTR(ret);\n\n\trkey = request_key(&key_type_id_resolver, desc, \"\");\n\tif (IS_ERR(rkey)) {\n\t\tmutex_lock(&idmap->idmap_mutex);\n\t\trkey = request_key_with_auxdata(&key_type_id_resolver_legacy,\n\t\t\t\t\t\tdesc, \"\", 0, idmap);\n\t\tmutex_unlock(&idmap->idmap_mutex);\n\t}\n\tif (!IS_ERR(rkey))\n\t\tset_bit(KEY_FLAG_ROOT_CAN_INVAL, &rkey->flags);\n\n\tkfree(desc);\n\treturn rkey;\n}\n\nstatic ssize_t nfs_idmap_get_key(const char *name, size_t namelen,\n\t\t\t\t const char *type, void *data,\n\t\t\t\t size_t data_size, struct idmap *idmap)\n{\n\tconst struct cred *saved_cred;\n\tstruct key *rkey;\n\tstruct user_key_payload *payload;\n\tssize_t ret;\n\n\tsaved_cred = override_creds(id_resolver_cache);\n\trkey = nfs_idmap_request_key(name, namelen, type, idmap);\n\trevert_creds(saved_cred);\n\n\tif (IS_ERR(rkey)) {\n\t\tret = PTR_ERR(rkey);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\trkey->perm |= KEY_USR_VIEW;\n\n\tret = key_validate(rkey);\n\tif (ret < 0)\n\t\tgoto out_up;\n\n\tpayload = rcu_dereference(rkey->payload.rcudata);\n\tif (IS_ERR_OR_NULL(payload)) {\n\t\tret = PTR_ERR(payload);\n\t\tgoto out_up;\n\t}\n\n\tret = payload->datalen;\n\tif (ret > 0 && ret <= data_size)\n\t\tmemcpy(data, payload->data, ret);\n\telse\n\t\tret = -EINVAL;\n\nout_up:\n\trcu_read_unlock();\n\tkey_put(rkey);\nout:\n\treturn ret;\n}\n\n/* ID -> Name */\nstatic ssize_t nfs_idmap_lookup_name(__u32 id, const char *type, char *buf,\n\t\t\t\t     size_t buflen, struct idmap *idmap)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tint id_len;\n\tssize_t ret;\n\n\tid_len = snprintf(id_str, sizeof(id_str), \"%u\", id);\n\tret = nfs_idmap_get_key(id_str, id_len, type, buf, buflen, idmap);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn ret;\n}\n\n/* Name -> ID */\nstatic int nfs_idmap_lookup_id(const char *name, size_t namelen, const char *type,\n\t\t\t       __u32 *id, struct idmap *idmap)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tlong id_long;\n\tssize_t data_size;\n\tint ret = 0;\n\n\tdata_size = nfs_idmap_get_key(name, namelen, type, id_str, NFS_UINT_MAXLEN, idmap);\n\tif (data_size <= 0) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = kstrtol(id_str, 10, &id_long);\n\t\t*id = (__u32)id_long;\n\t}\n\treturn ret;\n}\n\n/* idmap classic begins here */\n\nenum {\n\tOpt_find_uid, Opt_find_gid, Opt_find_user, Opt_find_group, Opt_find_err\n};\n\nstatic const match_table_t nfs_idmap_tokens = {\n\t{ Opt_find_uid, \"uid:%s\" },\n\t{ Opt_find_gid, \"gid:%s\" },\n\t{ Opt_find_user, \"user:%s\" },\n\t{ Opt_find_group, \"group:%s\" },\n\t{ Opt_find_err, NULL }\n};\n\nstatic int nfs_idmap_legacy_upcall(struct key_construction *, const char *, void *);\nstatic ssize_t idmap_pipe_downcall(struct file *, const char __user *,\n\t\t\t\t   size_t);\nstatic void idmap_release_pipe(struct inode *);\nstatic void idmap_pipe_destroy_msg(struct rpc_pipe_msg *);\n\nstatic const struct rpc_pipe_ops idmap_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= idmap_pipe_downcall,\n\t.release_pipe\t= idmap_release_pipe,\n\t.destroy_msg\t= idmap_pipe_destroy_msg,\n};\n\nstatic struct key_type key_type_id_resolver_legacy = {\n\t.name\t\t= \"id_legacy\",\n\t.preparse\t= user_preparse,\n\t.free_preparse\t= user_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= user_describe,\n\t.read\t\t= user_read,\n\t.request_key\t= nfs_idmap_legacy_upcall,\n};\n\nstatic void nfs_idmap_pipe_destroy(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct idmap *idmap = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = idmap->idmap_pipe;\n\n\tif (pipe->dentry) {\n\t\trpc_unlink(pipe->dentry);\n\t\tpipe->dentry = NULL;\n\t}\n}\n\nstatic int nfs_idmap_pipe_create(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct idmap *idmap = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = idmap->idmap_pipe;\n\tstruct dentry *dentry;\n\n\tdentry = rpc_mkpipe_dentry(dir, \"idmap\", idmap, pipe);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tpipe->dentry = dentry;\n\treturn 0;\n}\n\nstatic const struct rpc_pipe_dir_object_ops nfs_idmap_pipe_dir_object_ops = {\n\t.create = nfs_idmap_pipe_create,\n\t.destroy = nfs_idmap_pipe_destroy,\n};\n\nint\nnfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\tmutex_init(&idmap->idmap_mutex);\n\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tkfree(idmap);\n\treturn error;\n}\n\nvoid\nnfs_idmap_delete(struct nfs_client *clp)\n{\n\tstruct idmap *idmap = clp->cl_idmap;\n\n\tif (!idmap)\n\t\treturn;\n\tclp->cl_idmap = NULL;\n\trpc_remove_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\n\tkfree(idmap);\n}\n\nint nfs_idmap_init(void)\n{\n\tint ret;\n\tret = nfs_idmap_init_keyring();\n\tif (ret != 0)\n\t\tgoto out;\nout:\n\treturn ret;\n}\n\nvoid nfs_idmap_quit(void)\n{\n\tnfs_idmap_quit_keyring();\n}\n\nstatic int nfs_idmap_prepare_message(char *desc, struct idmap *idmap,\n\t\t\t\t     struct idmap_msg *im,\n\t\t\t\t     struct rpc_pipe_msg *msg)\n{\n\tsubstring_t substr;\n\tint token, ret;\n\n\tim->im_type = IDMAP_TYPE_GROUP;\n\ttoken = match_token(desc, nfs_idmap_tokens, &substr);\n\n\tswitch (token) {\n\tcase Opt_find_uid:\n\t\tim->im_type = IDMAP_TYPE_USER;\n\tcase Opt_find_gid:\n\t\tim->im_conv = IDMAP_CONV_NAMETOID;\n\t\tret = match_strlcpy(im->im_name, &substr, IDMAP_NAMESZ);\n\t\tbreak;\n\n\tcase Opt_find_user:\n\t\tim->im_type = IDMAP_TYPE_USER;\n\tcase Opt_find_group:\n\t\tim->im_conv = IDMAP_CONV_IDTONAME;\n\t\tret = match_int(&substr, &im->im_id);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmsg->data = im;\n\tmsg->len  = sizeof(struct idmap_msg);\n\nout:\n\treturn ret;\n}\n\nstatic bool\nnfs_idmap_prepare_pipe_upcall(struct idmap *idmap,\n\t\tstruct idmap_legacy_upcalldata *data)\n{\n\tif (idmap->idmap_upcall_data != NULL) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\tidmap->idmap_upcall_data = data;\n\treturn true;\n}\n\nstatic void\nnfs_idmap_complete_pipe_upcall_locked(struct idmap *idmap, int ret)\n{\n\tstruct key_construction *cons = idmap->idmap_upcall_data->key_cons;\n\n\tkfree(idmap->idmap_upcall_data);\n\tidmap->idmap_upcall_data = NULL;\n\tcomplete_request_key(cons, ret);\n}\n\nstatic void\nnfs_idmap_abort_pipe_upcall(struct idmap *idmap, int ret)\n{\n\tif (idmap->idmap_upcall_data != NULL)\n\t\tnfs_idmap_complete_pipe_upcall_locked(idmap, ret);\n}\n\nstatic int nfs_idmap_legacy_upcall(struct key_construction *cons,\n\t\t\t\t   const char *op,\n\t\t\t\t   void *aux)\n{\n\tstruct idmap_legacy_upcalldata *data;\n\tstruct rpc_pipe_msg *msg;\n\tstruct idmap_msg *im;\n\tstruct idmap *idmap = (struct idmap *)aux;\n\tstruct key *key = cons->key;\n\tint ret = -ENOMEM;\n\n\t/* msg and im are freed in idmap_pipe_destroy_msg */\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out1;\n\n\tmsg = &data->pipe_msg;\n\tim = &data->idmap_msg;\n\tdata->idmap = idmap;\n\tdata->key_cons = cons;\n\n\tret = nfs_idmap_prepare_message(key->description, idmap, im, msg);\n\tif (ret < 0)\n\t\tgoto out2;\n\n\tret = -EAGAIN;\n\tif (!nfs_idmap_prepare_pipe_upcall(idmap, data))\n\t\tgoto out2;\n\n\tret = rpc_queue_upcall(idmap->idmap_pipe, msg);\n\tif (ret < 0)\n\t\tnfs_idmap_abort_pipe_upcall(idmap, ret);\n\n\treturn ret;\nout2:\n\tkfree(data);\nout1:\n\tcomplete_request_key(cons, ret);\n\treturn ret;\n}\n\nstatic int nfs_idmap_instantiate(struct key *key, struct key *authkey, char *data, size_t datalen)\n{\n\treturn key_instantiate_and_link(key, data, datalen,\n\t\t\t\t\tid_resolver_cache->thread_keyring,\n\t\t\t\t\tauthkey);\n}\n\nstatic int nfs_idmap_read_and_verify_message(struct idmap_msg *im,\n\t\tstruct idmap_msg *upcall,\n\t\tstruct key *key, struct key *authkey)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tsize_t len;\n\tint ret = -ENOKEY;\n\n\t/* ret = -ENOKEY */\n\tif (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)\n\t\tgoto out;\n\tswitch (im->im_conv) {\n\tcase IDMAP_CONV_NAMETOID:\n\t\tif (strcmp(upcall->im_name, im->im_name) != 0)\n\t\t\tbreak;\n\t\t/* Note: here we store the NUL terminator too */\n\t\tlen = sprintf(id_str, \"%d\", im->im_id) + 1;\n\t\tret = nfs_idmap_instantiate(key, authkey, id_str, len);\n\t\tbreak;\n\tcase IDMAP_CONV_IDTONAME:\n\t\tif (upcall->im_id != im->im_id)\n\t\t\tbreak;\n\t\tlen = strlen(im->im_name);\n\t\tret = nfs_idmap_instantiate(key, authkey, im->im_name, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\treturn ret;\n}\n\nstatic ssize_t\nidmap_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct rpc_inode *rpci = RPC_I(file_inode(filp));\n\tstruct idmap *idmap = (struct idmap *)rpci->private;\n\tstruct key_construction *cons;\n\tstruct idmap_msg im;\n\tsize_t namelen_in;\n\tint ret = -ENOKEY;\n\n\t/* If instantiation is successful, anyone waiting for key construction\n\t * will have been woken up and someone else may now have used\n\t * idmap_key_cons - so after this point we may no longer touch it.\n\t */\n\tif (idmap->idmap_upcall_data == NULL)\n\t\tgoto out_noupcall;\n\n\tcons = idmap->idmap_upcall_data->key_cons;\n\n\tif (mlen != sizeof(im)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&im, src, mlen) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!(im.im_status & IDMAP_STATUS_SUCCESS)) {\n\t\tret = -ENOKEY;\n\t\tgoto out;\n\t}\n\n\tnamelen_in = strnlen(im.im_name, IDMAP_NAMESZ);\n\tif (namelen_in == 0 || namelen_in == IDMAP_NAMESZ) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n}\n\n\tret = nfs_idmap_read_and_verify_message(&im,\n\t\t\t&idmap->idmap_upcall_data->idmap_msg,\n\t\t\tcons->key, cons->authkey);\n\tif (ret >= 0) {\n\t\tkey_set_timeout(cons->key, nfs_idmap_cache_timeout);\n\t\tret = mlen;\n\t}\n\nout:\n\tnfs_idmap_complete_pipe_upcall_locked(idmap, ret);\nout_noupcall:\n\treturn ret;\n}\n\nstatic void\nidmap_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct idmap_legacy_upcalldata *data = container_of(msg,\n\t\t\tstruct idmap_legacy_upcalldata,\n\t\t\tpipe_msg);\n\tstruct idmap *idmap = data->idmap;\n\n\tif (msg->errno)\n\t\tnfs_idmap_abort_pipe_upcall(idmap, msg->errno);\n}\n\nstatic void\nidmap_release_pipe(struct inode *inode)\n{\n\tstruct rpc_inode *rpci = RPC_I(inode);\n\tstruct idmap *idmap = (struct idmap *)rpci->private;\n\n\tnfs_idmap_abort_pipe_upcall(idmap, -EPIPE);\n}\n\nint nfs_map_name_to_uid(const struct nfs_server *server, const char *name, size_t namelen, kuid_t *uid)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\t__u32 id = -1;\n\tint ret = 0;\n\n\tif (!nfs_map_string_to_numeric(name, namelen, &id))\n\t\tret = nfs_idmap_lookup_id(name, namelen, \"uid\", &id, idmap);\n\tif (ret == 0) {\n\t\t*uid = make_kuid(&init_user_ns, id);\n\t\tif (!uid_valid(*uid))\n\t\t\tret = -ERANGE;\n\t}\n\ttrace_nfs4_map_name_to_uid(name, namelen, id, ret);\n\treturn ret;\n}\n\nint nfs_map_group_to_gid(const struct nfs_server *server, const char *name, size_t namelen, kgid_t *gid)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\t__u32 id = -1;\n\tint ret = 0;\n\n\tif (!nfs_map_string_to_numeric(name, namelen, &id))\n\t\tret = nfs_idmap_lookup_id(name, namelen, \"gid\", &id, idmap);\n\tif (ret == 0) {\n\t\t*gid = make_kgid(&init_user_ns, id);\n\t\tif (!gid_valid(*gid))\n\t\t\tret = -ERANGE;\n\t}\n\ttrace_nfs4_map_group_to_gid(name, namelen, id, ret);\n\treturn ret;\n}\n\nint nfs_map_uid_to_name(const struct nfs_server *server, kuid_t uid, char *buf, size_t buflen)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\tint ret = -EINVAL;\n\t__u32 id;\n\n\tid = from_kuid(&init_user_ns, uid);\n\tif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\n\t\tret = nfs_idmap_lookup_name(id, \"user\", buf, buflen, idmap);\n\tif (ret < 0)\n\t\tret = nfs_map_numeric_to_string(id, buf, buflen);\n\ttrace_nfs4_map_uid_to_name(buf, ret, id, ret);\n\treturn ret;\n}\nint nfs_map_gid_to_group(const struct nfs_server *server, kgid_t gid, char *buf, size_t buflen)\n{\n\tstruct idmap *idmap = server->nfs_client->cl_idmap;\n\tint ret = -EINVAL;\n\t__u32 id;\n\n\tid = from_kgid(&init_user_ns, gid);\n\tif (!(server->caps & NFS_CAP_UIDGID_NOMAP))\n\t\tret = nfs_idmap_lookup_name(id, \"group\", buf, buflen, idmap);\n\tif (ret < 0)\n\t\tret = nfs_map_numeric_to_string(id, buf, buflen);\n\ttrace_nfs4_map_gid_to_group(buf, ret, id, ret);\n\treturn ret;\n}\n", "/* user-type.h: User-defined key type\n *\n * Copyright (C) 2005 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#ifndef _KEYS_USER_TYPE_H\n#define _KEYS_USER_TYPE_H\n\n#include <linux/key.h>\n#include <linux/rcupdate.h>\n\n/*****************************************************************************/\n/*\n * the payload for a key of type \"user\" or \"logon\"\n * - once filled in and attached to a key:\n *   - the payload struct is invariant may not be changed, only replaced\n *   - the payload must be read with RCU procedures or with the key semaphore\n *     held\n *   - the payload may only be replaced with the key semaphore write-locked\n * - the key's data length is the size of the actual data, not including the\n *   payload wrapper\n */\nstruct user_key_payload {\n\tstruct rcu_head\trcu;\t\t/* RCU destructor */\n\tunsigned short\tdatalen;\t/* length of this data */\n\tchar\t\tdata[0];\t/* actual data */\n};\n\nextern struct key_type key_type_user;\nextern struct key_type key_type_logon;\n\nstruct key_preparsed_payload;\n\nextern int user_preparse(struct key_preparsed_payload *prep);\nextern void user_free_preparse(struct key_preparsed_payload *prep);\nextern int user_update(struct key *key, struct key_preparsed_payload *prep);\nextern void user_revoke(struct key *key);\nextern void user_destroy(struct key *key);\nextern void user_describe(const struct key *user, struct seq_file *m);\nextern long user_read(const struct key *key,\n\t\t      char __user *buffer, size_t buflen);\n\n\n#endif /* _KEYS_USER_TYPE_H */\n", "/* Definitions for key type implementations\n *\n * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#ifndef _LINUX_KEY_TYPE_H\n#define _LINUX_KEY_TYPE_H\n\n#include <linux/key.h>\n#include <linux/errno.h>\n\n#ifdef CONFIG_KEYS\n\n/*\n * key under-construction record\n * - passed to the request_key actor if supplied\n */\nstruct key_construction {\n\tstruct key\t*key;\t/* key being constructed */\n\tstruct key\t*authkey;/* authorisation for key being constructed */\n};\n\n/*\n * Pre-parsed payload, used by key add, update and instantiate.\n *\n * This struct will be cleared and data and datalen will be set with the data\n * and length parameters from the caller and quotalen will be set from\n * def_datalen from the key type.  Then if the preparse() op is provided by the\n * key type, that will be called.  Then the struct will be passed to the\n * instantiate() or the update() op.\n *\n * If the preparse() op is given, the free_preparse() op will be called to\n * clear the contents.\n */\nstruct key_preparsed_payload {\n\tchar\t\t*description;\t/* Proposed key description (or NULL) */\n\tvoid\t\t*type_data[2];\t/* Private key-type data */\n\tvoid\t\t*payload[2];\t/* Proposed payload */\n\tconst void\t*data;\t\t/* Raw data */\n\tsize_t\t\tdatalen;\t/* Raw datalen */\n\tsize_t\t\tquotalen;\t/* Quota length for proposed payload */\n\ttime_t\t\texpiry;\t\t/* Expiry time of key */\n\tbool\t\ttrusted;\t/* True if key is trusted */\n};\n\ntypedef int (*request_key_actor_t)(struct key_construction *key,\n\t\t\t\t   const char *op, void *aux);\n\n/*\n * Preparsed matching criterion.\n */\nstruct key_match_data {\n\t/* Comparison function, defaults to type->match, but can be replaced by\n\t * type->match_preparse(). */\n\tint (*cmp)(const struct key *key,\n\t\t   const struct key_match_data *match_data);\n\n\tconst void\t*raw_data;\t/* Raw match data */\n\tvoid\t\t*preparsed;\t/* For ->match_preparse() to stash stuff */\n\tunsigned\tlookup_type;\t/* Type of lookup for this search. */\n#define KEYRING_SEARCH_LOOKUP_DIRECT\t0x0000\t/* Direct lookup by description. */\n#define KEYRING_SEARCH_LOOKUP_ITERATE\t0x0001\t/* Iterative search. */\n};\n\n/*\n * kernel managed key type definition\n */\nstruct key_type {\n\t/* name of the type */\n\tconst char *name;\n\n\t/* default payload length for quota precalculation (optional)\n\t * - this can be used instead of calling key_payload_reserve(), that\n\t *   function only needs to be called if the real datalen is different\n\t */\n\tsize_t def_datalen;\n\n\t/* vet a description */\n\tint (*vet_description)(const char *description);\n\n\t/* Preparse the data blob from userspace that is to be the payload,\n\t * generating a proposed description and payload that will be handed to\n\t * the instantiate() and update() ops.\n\t */\n\tint (*preparse)(struct key_preparsed_payload *prep);\n\n\t/* Free a preparse data structure.\n\t */\n\tvoid (*free_preparse)(struct key_preparsed_payload *prep);\n\n\t/* instantiate a key of this type\n\t * - this method should call key_payload_reserve() to determine if the\n\t *   user's quota will hold the payload\n\t */\n\tint (*instantiate)(struct key *key, struct key_preparsed_payload *prep);\n\n\t/* update a key of this type (optional)\n\t * - this method should call key_payload_reserve() to recalculate the\n\t *   quota consumption\n\t * - the key must be locked against read when modifying\n\t */\n\tint (*update)(struct key *key, struct key_preparsed_payload *prep);\n\n\t/* Preparse the data supplied to ->match() (optional).  The\n\t * data to be preparsed can be found in match_data->raw_data.\n\t * The lookup type can also be set by this function.\n\t */\n\tint (*match_preparse)(struct key_match_data *match_data);\n\n\t/* Free preparsed match data (optional).  This should be supplied it\n\t * ->match_preparse() is supplied. */\n\tvoid (*match_free)(struct key_match_data *match_data);\n\n\t/* clear some of the data from a key on revokation (optional)\n\t * - the key's semaphore will be write-locked by the caller\n\t */\n\tvoid (*revoke)(struct key *key);\n\n\t/* clear the data from a key (optional) */\n\tvoid (*destroy)(struct key *key);\n\n\t/* describe a key */\n\tvoid (*describe)(const struct key *key, struct seq_file *p);\n\n\t/* read a key's data (optional)\n\t * - permission checks will be done by the caller\n\t * - the key's semaphore will be readlocked by the caller\n\t * - should return the amount of data that could be read, no matter how\n\t *   much is copied into the buffer\n\t * - shouldn't do the copy if the buffer is NULL\n\t */\n\tlong (*read)(const struct key *key, char __user *buffer, size_t buflen);\n\n\t/* handle request_key() for this type instead of invoking\n\t * /sbin/request-key (optional)\n\t * - key is the key to instantiate\n\t * - authkey is the authority to assume when instantiating this key\n\t * - op is the operation to be done, usually \"create\"\n\t * - the call must not return until the instantiation process has run\n\t *   its course\n\t */\n\trequest_key_actor_t request_key;\n\n\t/* internal fields */\n\tstruct list_head\tlink;\t\t/* link in types list */\n\tstruct lock_class_key\tlock_class;\t/* key->sem lock class */\n};\n\nextern struct key_type key_type_keyring;\n\nextern int register_key_type(struct key_type *ktype);\nextern void unregister_key_type(struct key_type *ktype);\n\nextern int key_payload_reserve(struct key *key, size_t datalen);\nextern int key_instantiate_and_link(struct key *key,\n\t\t\t\t    const void *data,\n\t\t\t\t    size_t datalen,\n\t\t\t\t    struct key *keyring,\n\t\t\t\t    struct key *instkey);\nextern int key_reject_and_link(struct key *key,\n\t\t\t       unsigned timeout,\n\t\t\t       unsigned error,\n\t\t\t       struct key *keyring,\n\t\t\t       struct key *instkey);\nextern void complete_request_key(struct key_construction *cons, int error);\n\nstatic inline int key_negate_and_link(struct key *key,\n\t\t\t\t      unsigned timeout,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *instkey)\n{\n\treturn key_reject_and_link(key, timeout, ENOKEY, keyring, instkey);\n}\n\nextern int generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep);\n\n#endif /* CONFIG_KEYS */\n#endif /* _LINUX_KEY_TYPE_H */\n", "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <crypto/hash.h>\n#include <linux/key-type.h>\n\n#include <keys/ceph-type.h>\n#include <keys/user-type.h>\n#include <linux/ceph/decode.h>\n#include \"crypto.h\"\n\nint ceph_crypto_key_clone(struct ceph_crypto_key *dst,\n\t\t\t  const struct ceph_crypto_key *src)\n{\n\tmemcpy(dst, src, sizeof(struct ceph_crypto_key));\n\tdst->key = kmemdup(src->key, src->len, GFP_NOFS);\n\tif (!dst->key)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint ceph_crypto_key_encode(struct ceph_crypto_key *key, void **p, void *end)\n{\n\tif (*p + sizeof(u16) + sizeof(key->created) +\n\t    sizeof(u16) + key->len > end)\n\t\treturn -ERANGE;\n\tceph_encode_16(p, key->type);\n\tceph_encode_copy(p, &key->created, sizeof(key->created));\n\tceph_encode_16(p, key->len);\n\tceph_encode_copy(p, key->key, key->len);\n\treturn 0;\n}\n\nint ceph_crypto_key_decode(struct ceph_crypto_key *key, void **p, void *end)\n{\n\tceph_decode_need(p, end, 2*sizeof(u16) + sizeof(key->created), bad);\n\tkey->type = ceph_decode_16(p);\n\tceph_decode_copy(p, &key->created, sizeof(key->created));\n\tkey->len = ceph_decode_16(p);\n\tceph_decode_need(p, end, key->len, bad);\n\tkey->key = kmalloc(key->len, GFP_NOFS);\n\tif (!key->key)\n\t\treturn -ENOMEM;\n\tceph_decode_copy(p, key->key, key->len);\n\treturn 0;\n\nbad:\n\tdout(\"failed to decode crypto key\\n\");\n\treturn -EINVAL;\n}\n\nint ceph_crypto_key_unarmor(struct ceph_crypto_key *key, const char *inkey)\n{\n\tint inlen = strlen(inkey);\n\tint blen = inlen * 3 / 4;\n\tvoid *buf, *p;\n\tint ret;\n\n\tdout(\"crypto_key_unarmor %s\\n\", inkey);\n\tbuf = kmalloc(blen, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tblen = ceph_unarmor(buf, inkey, inkey+inlen);\n\tif (blen < 0) {\n\t\tkfree(buf);\n\t\treturn blen;\n\t}\n\n\tp = buf;\n\tret = ceph_crypto_key_decode(key, &p, p + blen);\n\tkfree(buf);\n\tif (ret)\n\t\treturn ret;\n\tdout(\"crypto_key_unarmor key %p type %d len %d\\n\", key,\n\t     key->type, key->len);\n\treturn 0;\n}\n\n\n\n#define AES_KEY_SIZE 16\n\nstatic struct crypto_blkcipher *ceph_crypto_alloc_cipher(void)\n{\n\treturn crypto_alloc_blkcipher(\"cbc(aes)\", 0, CRYPTO_ALG_ASYNC);\n}\n\nstatic const u8 *aes_iv = (u8 *)CEPH_AES_IV;\n\nstatic int ceph_aes_encrypt(const void *key, int key_len,\n\t\t\t    void *dst, size_t *dst_len,\n\t\t\t    const void *src, size_t src_len)\n{\n\tstruct scatterlist sg_in[2], sg_out[1];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm, .flags = 0 };\n\tint ret;\n\tvoid *iv;\n\tint ivsize;\n\tsize_t zero_padding = (0x10 - (src_len & 0x0f));\n\tchar pad[16];\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tmemset(pad, zero_padding, zero_padding);\n\n\t*dst_len = src_len + zero_padding;\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], src, src_len);\n\tsg_set_buf(&sg_in[1], pad, zero_padding);\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, dst, *dst_len);\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc src: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tsrc, src_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc pad: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tpad, zero_padding, 1);\n\t*/\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in,\n\t\t\t\t     src_len + zero_padding);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"ceph_aes_crypt failed %d\\n\", ret);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc out: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst, *dst_len, 1);\n\t*/\n\treturn 0;\n}\n\nstatic int ceph_aes_encrypt2(const void *key, int key_len, void *dst,\n\t\t\t     size_t *dst_len,\n\t\t\t     const void *src1, size_t src1_len,\n\t\t\t     const void *src2, size_t src2_len)\n{\n\tstruct scatterlist sg_in[3], sg_out[1];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm, .flags = 0 };\n\tint ret;\n\tvoid *iv;\n\tint ivsize;\n\tsize_t zero_padding = (0x10 - ((src1_len + src2_len) & 0x0f));\n\tchar pad[16];\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tmemset(pad, zero_padding, zero_padding);\n\n\t*dst_len = src1_len + src2_len + zero_padding;\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tsg_init_table(sg_in, 3);\n\tsg_set_buf(&sg_in[0], src1, src1_len);\n\tsg_set_buf(&sg_in[1], src2, src2_len);\n\tsg_set_buf(&sg_in[2], pad, zero_padding);\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, dst, *dst_len);\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc  key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc src1: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tsrc1, src1_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc src2: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tsrc2, src2_len, 1);\n\tprint_hex_dump(KERN_ERR, \"enc  pad: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\tpad, zero_padding, 1);\n\t*/\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in,\n\t\t\t\t     src1_len + src2_len + zero_padding);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"ceph_aes_crypt2 failed %d\\n\", ret);\n\t/*\n\tprint_hex_dump(KERN_ERR, \"enc  out: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst, *dst_len, 1);\n\t*/\n\treturn 0;\n}\n\nstatic int ceph_aes_decrypt(const void *key, int key_len,\n\t\t\t    void *dst, size_t *dst_len,\n\t\t\t    const void *src, size_t src_len)\n{\n\tstruct scatterlist sg_in[1], sg_out[2];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm };\n\tchar pad[16];\n\tvoid *iv;\n\tint ivsize;\n\tint ret;\n\tint last_byte;\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, src, src_len);\n\tsg_set_buf(&sg_out[0], dst, *dst_len);\n\tsg_set_buf(&sg_out[1], pad, sizeof(pad));\n\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"dec  in: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       src, src_len, 1);\n\t*/\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, src_len);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0) {\n\t\tpr_err(\"ceph_aes_decrypt failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (src_len <= *dst_len)\n\t\tlast_byte = ((char *)dst)[src_len - 1];\n\telse\n\t\tlast_byte = pad[src_len - *dst_len - 1];\n\tif (last_byte <= 16 && src_len >= last_byte) {\n\t\t*dst_len = src_len - last_byte;\n\t} else {\n\t\tpr_err(\"ceph_aes_decrypt got bad padding %d on src len %d\\n\",\n\t\t       last_byte, (int)src_len);\n\t\treturn -EPERM;  /* bad padding */\n\t}\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec out: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst, *dst_len, 1);\n\t*/\n\treturn 0;\n}\n\nstatic int ceph_aes_decrypt2(const void *key, int key_len,\n\t\t\t     void *dst1, size_t *dst1_len,\n\t\t\t     void *dst2, size_t *dst2_len,\n\t\t\t     const void *src, size_t src_len)\n{\n\tstruct scatterlist sg_in[1], sg_out[3];\n\tstruct crypto_blkcipher *tfm = ceph_crypto_alloc_cipher();\n\tstruct blkcipher_desc desc = { .tfm = tfm };\n\tchar pad[16];\n\tvoid *iv;\n\tint ivsize;\n\tint ret;\n\tint last_byte;\n\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tsg_init_table(sg_in, 1);\n\tsg_set_buf(sg_in, src, src_len);\n\tsg_init_table(sg_out, 3);\n\tsg_set_buf(&sg_out[0], dst1, *dst1_len);\n\tsg_set_buf(&sg_out[1], dst2, *dst2_len);\n\tsg_set_buf(&sg_out[2], pad, sizeof(pad));\n\n\tcrypto_blkcipher_setkey((void *)tfm, key, key_len);\n\tiv = crypto_blkcipher_crt(tfm)->iv;\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\n\tmemcpy(iv, aes_iv, ivsize);\n\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec  key: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       key, key_len, 1);\n\tprint_hex_dump(KERN_ERR, \"dec   in: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       src, src_len, 1);\n\t*/\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, src_len);\n\tcrypto_free_blkcipher(tfm);\n\tif (ret < 0) {\n\t\tpr_err(\"ceph_aes_decrypt failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (src_len <= *dst1_len)\n\t\tlast_byte = ((char *)dst1)[src_len - 1];\n\telse if (src_len <= *dst1_len + *dst2_len)\n\t\tlast_byte = ((char *)dst2)[src_len - *dst1_len - 1];\n\telse\n\t\tlast_byte = pad[src_len - *dst1_len - *dst2_len - 1];\n\tif (last_byte <= 16 && src_len >= last_byte) {\n\t\tsrc_len -= last_byte;\n\t} else {\n\t\tpr_err(\"ceph_aes_decrypt got bad padding %d on src len %d\\n\",\n\t\t       last_byte, (int)src_len);\n\t\treturn -EPERM;  /* bad padding */\n\t}\n\n\tif (src_len < *dst1_len) {\n\t\t*dst1_len = src_len;\n\t\t*dst2_len = 0;\n\t} else {\n\t\t*dst2_len = src_len - *dst1_len;\n\t}\n\t/*\n\tprint_hex_dump(KERN_ERR, \"dec  out1: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst1, *dst1_len, 1);\n\tprint_hex_dump(KERN_ERR, \"dec  out2: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       dst2, *dst2_len, 1);\n\t*/\n\n\treturn 0;\n}\n\n\nint ceph_decrypt(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n\t\t const void *src, size_t src_len)\n{\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst_len < src_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(dst, src, src_len);\n\t\t*dst_len = src_len;\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_decrypt(secret->key, secret->len, dst,\n\t\t\t\t\tdst_len, src, src_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint ceph_decrypt2(struct ceph_crypto_key *secret,\n\t\t\tvoid *dst1, size_t *dst1_len,\n\t\t\tvoid *dst2, size_t *dst2_len,\n\t\t\tconst void *src, size_t src_len)\n{\n\tsize_t t;\n\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst1_len + *dst2_len < src_len)\n\t\t\treturn -ERANGE;\n\t\tt = min(*dst1_len, src_len);\n\t\tmemcpy(dst1, src, t);\n\t\t*dst1_len = t;\n\t\tsrc += t;\n\t\tsrc_len -= t;\n\t\tif (src_len) {\n\t\t\tt = min(*dst2_len, src_len);\n\t\t\tmemcpy(dst2, src, t);\n\t\t\t*dst2_len = t;\n\t\t}\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_decrypt2(secret->key, secret->len,\n\t\t\t\t\t dst1, dst1_len, dst2, dst2_len,\n\t\t\t\t\t src, src_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint ceph_encrypt(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n\t\t const void *src, size_t src_len)\n{\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst_len < src_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(dst, src, src_len);\n\t\t*dst_len = src_len;\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_encrypt(secret->key, secret->len, dst,\n\t\t\t\t\tdst_len, src, src_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint ceph_encrypt2(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n\t\t  const void *src1, size_t src1_len,\n\t\t  const void *src2, size_t src2_len)\n{\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst_len < src1_len + src2_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(dst, src1, src1_len);\n\t\tmemcpy(dst + src1_len, src2, src2_len);\n\t\t*dst_len = src1_len + src2_len;\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_encrypt2(secret->key, secret->len, dst, dst_len,\n\t\t\t\t\t src1, src1_len, src2, src2_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ceph_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\tvoid *p;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tckey = kmalloc(sizeof(*ckey), GFP_KERNEL);\n\tif (!ckey)\n\t\tgoto err;\n\n\t/* TODO ceph_crypto_key_decode should really take const input */\n\tp = (void *)prep->data;\n\tret = ceph_crypto_key_decode(ckey, &p, (char*)prep->data+datalen);\n\tif (ret < 0)\n\t\tgoto err_ckey;\n\n\tprep->payload[0] = ckey;\n\tprep->quotalen = datalen;\n\treturn 0;\n\nerr_ckey:\n\tkfree(ckey);\nerr:\n\treturn ret;\n}\n\nstatic void ceph_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey = prep->payload[0];\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n\nstatic void ceph_key_destroy(struct key *key)\n{\n\tstruct ceph_crypto_key *ckey = key->payload.data;\n\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n\nstruct key_type key_type_ceph = {\n\t.name\t\t= \"ceph\",\n\t.preparse\t= ceph_key_preparse,\n\t.free_preparse\t= ceph_key_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.destroy\t= ceph_key_destroy,\n};\n\nint ceph_crypto_init(void) {\n\treturn register_key_type(&key_type_ceph);\n}\n\nvoid ceph_crypto_shutdown(void) {\n\tunregister_key_type(&key_type_ceph);\n}\n", "/* Key type used to cache DNS lookups made by the kernel\n *\n * See Documentation/networking/dns_resolver.txt\n *\n *   Copyright (c) 2007 Igor Mammedov\n *   Author(s): Igor Mammedov (niallain@gmail.com)\n *              Steve French (sfrench@us.ibm.com)\n *              Wang Lei (wang840925@gmail.com)\n *\t\tDavid Howells (dhowells@redhat.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/keyctl.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <keys/dns_resolver-type.h>\n#include <keys/user-type.h>\n#include \"internal.h\"\n\nMODULE_DESCRIPTION(\"DNS Resolver\");\nMODULE_AUTHOR(\"Wang Lei\");\nMODULE_LICENSE(\"GPL\");\n\nunsigned int dns_resolver_debug;\nmodule_param_named(debug, dns_resolver_debug, uint, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(debug, \"DNS Resolver debugging mask\");\n\nconst struct cred *dns_resolver_cache;\n\n#define\tDNS_ERRORNO_OPTION\t\"dnserror\"\n\n/*\n * Preparse instantiation data for a dns_resolver key.\n *\n * The data must be a NUL-terminated string, with the NUL char accounted in\n * datalen.\n *\n * If the data contains a '#' characters, then we take the clause after each\n * one to be an option of the form 'key=value'.  The actual data of interest is\n * the string leading up to the first '#'.  For instance:\n *\n *        \"ip1,ip2,...#foo=bar\"\n */\nstatic int\ndns_resolver_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tunsigned long derrno;\n\tint ret;\n\tint datalen = prep->datalen, result_len = 0;\n\tconst char *data = prep->data, *end, *opt;\n\n\tkenter(\"'%*.*s',%u\", datalen, datalen, data, datalen);\n\n\tif (datalen <= 1 || !data || data[datalen - 1] != '\\0')\n\t\treturn -EINVAL;\n\tdatalen--;\n\n\t/* deal with any options embedded in the data */\n\tend = data + datalen;\n\topt = memchr(data, '#', datalen);\n\tif (!opt) {\n\t\t/* no options: the entire data is the result */\n\t\tkdebug(\"no options\");\n\t\tresult_len = datalen;\n\t} else {\n\t\tconst char *next_opt;\n\n\t\tresult_len = opt - data;\n\t\topt++;\n\t\tkdebug(\"options: '%s'\", opt);\n\t\tdo {\n\t\t\tconst char *eq;\n\t\t\tint opt_len, opt_nlen, opt_vlen, tmp;\n\n\t\t\tnext_opt = memchr(opt, '#', end - opt) ?: end;\n\t\t\topt_len = next_opt - opt;\n\t\t\tif (!opt_len) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"Empty option to dns_resolver key\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\teq = memchr(opt, '=', opt_len) ?: end;\n\t\t\topt_nlen = eq - opt;\n\t\t\teq++;\n\t\t\topt_vlen = next_opt - eq; /* will be -1 if no value */\n\n\t\t\ttmp = opt_vlen >= 0 ? opt_vlen : 0;\n\t\t\tkdebug(\"option '%*.*s' val '%*.*s'\",\n\t\t\t       opt_nlen, opt_nlen, opt, tmp, tmp, eq);\n\n\t\t\t/* see if it's an error number representing a DNS error\n\t\t\t * that's to be recorded as the result in this key */\n\t\t\tif (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&\n\t\t\t    memcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {\n\t\t\t\tkdebug(\"dns error number option\");\n\t\t\t\tif (opt_vlen <= 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tret = kstrtoul(eq, 10, &derrno);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tif (derrno < 1 || derrno > 511)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tkdebug(\"dns error no. = %lu\", derrno);\n\t\t\t\tprep->type_data[0] = ERR_PTR(-derrno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tbad_option_value:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"Option '%*.*s' to dns_resolver key:\"\n\t\t\t       \" bad/missing value\\n\",\n\t\t\t       opt_nlen, opt_nlen, opt);\n\t\t\treturn -EINVAL;\n\t\t} while (opt = next_opt + 1, opt < end);\n\t}\n\n\t/* don't cache the result if we're caching an error saying there's no\n\t * result */\n\tif (prep->type_data[0]) {\n\t\tkleave(\" = 0 [h_error %ld]\", PTR_ERR(prep->type_data[0]));\n\t\treturn 0;\n\t}\n\n\tkdebug(\"store result\");\n\tprep->quotalen = result_len;\n\n\tupayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);\n\tif (!upayload) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tupayload->datalen = result_len;\n\tmemcpy(upayload->data, data, result_len);\n\tupayload->data[result_len] = '\\0';\n\n\tprep->payload[0] = upayload;\n\tkleave(\" = 0\");\n\treturn 0;\n}\n\n/*\n * Clean up the preparse data\n */\nstatic void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n{\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tkfree(prep->payload[0]);\n}\n\n/*\n * The description is of the form \"[<type>:]<domain_name>\"\n *\n * The domain name may be a simple name or an absolute domain name (which\n * should end with a period).  The domain name is case-independent.\n */\nstatic int dns_resolver_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Preparse the match criterion.\n */\nstatic int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}\n\n/*\n * Describe a DNS key\n */\nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tint err = key->type_data.x[0];\n\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n\n/*\n * read the DNS data\n * - the key's semaphore is read-locked\n */\nstatic long dns_resolver_read(const struct key *key,\n\t\t\t      char __user *buffer, size_t buflen)\n{\n\tif (key->type_data.x[0])\n\t\treturn key->type_data.x[0];\n\n\treturn user_read(key, buffer, buflen);\n}\n\nstruct key_type key_type_dns_resolver = {\n\t.name\t\t= \"dns_resolver\",\n\t.preparse\t= dns_resolver_preparse,\n\t.free_preparse\t= dns_resolver_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match_preparse\t= dns_resolver_match_preparse,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= dns_resolver_describe,\n\t.read\t\t= dns_resolver_read,\n};\n\nstatic int __init init_dns_resolver(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\t/* create an override credential set with a special thread keyring in\n\t * which DNS requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".dns_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_dns_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tdns_resolver_cache = cred;\n\n\tkdebug(\"DNS resolver keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void __exit exit_dns_resolver(void)\n{\n\tkey_revoke(dns_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_dns_resolver);\n\tput_cred(dns_resolver_cache);\n}\n\nmodule_init(init_dns_resolver)\nmodule_exit(exit_dns_resolver)\nMODULE_LICENSE(\"GPL\");\n\n", "/* RxRPC key management\n *\n * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * RxRPC keys should have a description of describing their purpose:\n *\t\"afs@CAMBRIDGE.REDHAT.COM>\n */\n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/key-type.h>\n#include <linux/crypto.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <keys/rxrpc-type.h>\n#include <keys/user-type.h>\n#include \"ar-internal.h\"\n\nstatic int rxrpc_vet_description_s(const char *);\nstatic int rxrpc_preparse(struct key_preparsed_payload *);\nstatic int rxrpc_preparse_s(struct key_preparsed_payload *);\nstatic void rxrpc_free_preparse(struct key_preparsed_payload *);\nstatic void rxrpc_free_preparse_s(struct key_preparsed_payload *);\nstatic void rxrpc_destroy(struct key *);\nstatic void rxrpc_destroy_s(struct key *);\nstatic void rxrpc_describe(const struct key *, struct seq_file *);\nstatic long rxrpc_read(const struct key *, char __user *, size_t);\n\n/*\n * rxrpc defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_rxrpc = {\n\t.name\t\t= \"rxrpc\",\n\t.preparse\t= rxrpc_preparse,\n\t.free_preparse\t= rxrpc_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.destroy\t= rxrpc_destroy,\n\t.describe\t= rxrpc_describe,\n\t.read\t\t= rxrpc_read,\n};\nEXPORT_SYMBOL(key_type_rxrpc);\n\n/*\n * rxrpc server defined keys take \"<serviceId>:<securityIndex>\" as the\n * description and an 8-byte decryption key as the payload\n */\nstruct key_type key_type_rxrpc_s = {\n\t.name\t\t= \"rxrpc_s\",\n\t.vet_description = rxrpc_vet_description_s,\n\t.preparse\t= rxrpc_preparse_s,\n\t.free_preparse\t= rxrpc_free_preparse_s,\n\t.instantiate\t= generic_key_instantiate,\n\t.destroy\t= rxrpc_destroy_s,\n\t.describe\t= rxrpc_describe,\n};\n\n/*\n * Vet the description for an RxRPC server key\n */\nstatic int rxrpc_vet_description_s(const char *desc)\n{\n\tunsigned long num;\n\tchar *p;\n\n\tnum = simple_strtoul(desc, &p, 10);\n\tif (*p != ':' || num > 65535)\n\t\treturn -EINVAL;\n\tnum = simple_strtoul(p + 1, &p, 10);\n\tif (*p || num < 1 || num > 255)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n/*\n * parse an RxKAD type XDR format token\n * - the caller guarantees we have at least 4 words\n */\nstatic int rxrpc_preparse_xdr_rxkad(struct key_preparsed_payload *prep,\n\t\t\t\t    size_t datalen,\n\t\t\t\t    const __be32 *xdr, unsigned int toklen)\n{\n\tstruct rxrpc_key_token *token, **pptoken;\n\tsize_t plen;\n\tu32 tktlen;\n\n\t_enter(\",{%x,%x,%x,%x},%u\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       toklen);\n\n\tif (toklen <= 8 * 4)\n\t\treturn -EKEYREJECTED;\n\ttktlen = ntohl(xdr[7]);\n\t_debug(\"tktlen: %x\", tktlen);\n\tif (tktlen > AFSTOKEN_RK_TIX_MAX)\n\t\treturn -EKEYREJECTED;\n\tif (toklen < 8 * 4 + tktlen)\n\t\treturn -EKEYREJECTED;\n\n\tplen = sizeof(*token) + sizeof(*token->kad) + tktlen;\n\tprep->quotalen = datalen + plen;\n\n\tplen -= sizeof(*token);\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\treturn -ENOMEM;\n\n\ttoken->kad = kzalloc(plen, GFP_KERNEL);\n\tif (!token->kad) {\n\t\tkfree(token);\n\t\treturn -ENOMEM;\n\t}\n\n\ttoken->security_index\t= RXRPC_SECURITY_RXKAD;\n\ttoken->kad->ticket_len\t= tktlen;\n\ttoken->kad->vice_id\t= ntohl(xdr[0]);\n\ttoken->kad->kvno\t= ntohl(xdr[1]);\n\ttoken->kad->start\t= ntohl(xdr[4]);\n\ttoken->kad->expiry\t= ntohl(xdr[5]);\n\ttoken->kad->primary_flag = ntohl(xdr[6]);\n\tmemcpy(&token->kad->session_key, &xdr[2], 8);\n\tmemcpy(&token->kad->ticket, &xdr[8], tktlen);\n\n\t_debug(\"SCIX: %u\", token->security_index);\n\t_debug(\"TLEN: %u\", token->kad->ticket_len);\n\t_debug(\"EXPY: %x\", token->kad->expiry);\n\t_debug(\"KVNO: %u\", token->kad->kvno);\n\t_debug(\"PRIM: %u\", token->kad->primary_flag);\n\t_debug(\"SKEY: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t       token->kad->session_key[0], token->kad->session_key[1],\n\t       token->kad->session_key[2], token->kad->session_key[3],\n\t       token->kad->session_key[4], token->kad->session_key[5],\n\t       token->kad->session_key[6], token->kad->session_key[7]);\n\tif (token->kad->ticket_len >= 8)\n\t\t_debug(\"TCKT: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t\t       token->kad->ticket[0], token->kad->ticket[1],\n\t\t       token->kad->ticket[2], token->kad->ticket[3],\n\t\t       token->kad->ticket[4], token->kad->ticket[5],\n\t\t       token->kad->ticket[6], token->kad->ticket[7]);\n\n\t/* count the number of tokens attached */\n\tprep->type_data[0] = (void *)((unsigned long)prep->type_data[0] + 1);\n\n\t/* attach the data */\n\tfor (pptoken = (struct rxrpc_key_token **)&prep->payload[0];\n\t     *pptoken;\n\t     pptoken = &(*pptoken)->next)\n\t\tcontinue;\n\t*pptoken = token;\n\tif (token->kad->expiry < prep->expiry)\n\t\tprep->expiry = token->kad->expiry;\n\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\nstatic void rxrpc_free_krb5_principal(struct krb5_principal *princ)\n{\n\tint loop;\n\n\tif (princ->name_parts) {\n\t\tfor (loop = princ->n_name_parts - 1; loop >= 0; loop--)\n\t\t\tkfree(princ->name_parts[loop]);\n\t\tkfree(princ->name_parts);\n\t}\n\tkfree(princ->realm);\n}\n\nstatic void rxrpc_free_krb5_tagged(struct krb5_tagged_data *td)\n{\n\tkfree(td->data);\n}\n\n/*\n * free up an RxK5 token\n */\nstatic void rxrpc_rxk5_free(struct rxk5_key *rxk5)\n{\n\tint loop;\n\n\trxrpc_free_krb5_principal(&rxk5->client);\n\trxrpc_free_krb5_principal(&rxk5->server);\n\trxrpc_free_krb5_tagged(&rxk5->session);\n\n\tif (rxk5->addresses) {\n\t\tfor (loop = rxk5->n_addresses - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->addresses[loop]);\n\t\tkfree(rxk5->addresses);\n\t}\n\tif (rxk5->authdata) {\n\t\tfor (loop = rxk5->n_authdata - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->authdata[loop]);\n\t\tkfree(rxk5->authdata);\n\t}\n\n\tkfree(rxk5->ticket);\n\tkfree(rxk5->ticket2);\n\tkfree(rxk5);\n}\n\n/*\n * extract a krb5 principal\n */\nstatic int rxrpc_krb5_decode_principal(struct krb5_principal *princ,\n\t\t\t\t       const __be32 **_xdr,\n\t\t\t\t       unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, n_parts, loop, tmp;\n\n\t/* there must be at least one name, and at least #names+1 length\n\t * words */\n\tif (toklen <= 12)\n\t\treturn -EINVAL;\n\n\t_enter(\",{%x,%x,%x},%u\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), toklen);\n\n\tn_parts = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (n_parts <= 0 || n_parts > AFSTOKEN_K5_COMPONENTS_MAX)\n\t\treturn -EINVAL;\n\tprinc->n_name_parts = n_parts;\n\n\tif (toklen <= (n_parts + 1) * 4)\n\t\treturn -EINVAL;\n\n\tprinc->name_parts = kcalloc(n_parts, sizeof(char *), GFP_KERNEL);\n\tif (!princ->name_parts)\n\t\treturn -ENOMEM;\n\n\tfor (loop = 0; loop < n_parts; loop++) {\n\t\tif (toklen < 4)\n\t\t\treturn -EINVAL;\n\t\ttmp = ntohl(*xdr++);\n\t\ttoklen -= 4;\n\t\tif (tmp <= 0 || tmp > AFSTOKEN_STRING_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (tmp > toklen)\n\t\t\treturn -EINVAL;\n\t\tprinc->name_parts[loop] = kmalloc(tmp + 1, GFP_KERNEL);\n\t\tif (!princ->name_parts[loop])\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(princ->name_parts[loop], xdr, tmp);\n\t\tprinc->name_parts[loop][tmp] = 0;\n\t\ttmp = (tmp + 3) & ~3;\n\t\ttoklen -= tmp;\n\t\txdr += tmp >> 2;\n\t}\n\n\tif (toklen < 4)\n\t\treturn -EINVAL;\n\ttmp = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (tmp <= 0 || tmp > AFSTOKEN_K5_REALM_MAX)\n\t\treturn -EINVAL;\n\tif (tmp > toklen)\n\t\treturn -EINVAL;\n\tprinc->realm = kmalloc(tmp + 1, GFP_KERNEL);\n\tif (!princ->realm)\n\t\treturn -ENOMEM;\n\tmemcpy(princ->realm, xdr, tmp);\n\tprinc->realm[tmp] = 0;\n\ttmp = (tmp + 3) & ~3;\n\ttoklen -= tmp;\n\txdr += tmp >> 2;\n\n\t_debug(\"%s/...@%s\", princ->name_parts[0], princ->realm);\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * extract a piece of krb5 tagged data\n */\nstatic int rxrpc_krb5_decode_tagged_data(struct krb5_tagged_data *td,\n\t\t\t\t\t size_t max_data_size,\n\t\t\t\t\t const __be32 **_xdr,\n\t\t\t\t\t unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, len;\n\n\t/* there must be at least one tag and one length word */\n\tif (toklen <= 8)\n\t\treturn -EINVAL;\n\n\t_enter(\",%zu,{%x,%x},%u\",\n\t       max_data_size, ntohl(xdr[0]), ntohl(xdr[1]), toklen);\n\n\ttd->tag = ntohl(*xdr++);\n\tlen = ntohl(*xdr++);\n\ttoklen -= 8;\n\tif (len > max_data_size)\n\t\treturn -EINVAL;\n\ttd->data_len = len;\n\n\tif (len > 0) {\n\t\ttd->data = kmemdup(xdr, len, GFP_KERNEL);\n\t\tif (!td->data)\n\t\t\treturn -ENOMEM;\n\t\tlen = (len + 3) & ~3;\n\t\ttoklen -= len;\n\t\txdr += len >> 2;\n\t}\n\n\t_debug(\"tag %x len %x\", td->tag, td->data_len);\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * extract an array of tagged data\n */\nstatic int rxrpc_krb5_decode_tagged_array(struct krb5_tagged_data **_td,\n\t\t\t\t\t  u8 *_n_elem,\n\t\t\t\t\t  u8 max_n_elem,\n\t\t\t\t\t  size_t max_elem_size,\n\t\t\t\t\t  const __be32 **_xdr,\n\t\t\t\t\t  unsigned int *_toklen)\n{\n\tstruct krb5_tagged_data *td;\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, n_elem, loop;\n\tint ret;\n\n\t/* there must be at least one count */\n\tif (toklen < 4)\n\t\treturn -EINVAL;\n\n\t_enter(\",,%u,%zu,{%x},%u\",\n\t       max_n_elem, max_elem_size, ntohl(xdr[0]), toklen);\n\n\tn_elem = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (n_elem < 0 || n_elem > max_n_elem)\n\t\treturn -EINVAL;\n\t*_n_elem = n_elem;\n\tif (n_elem > 0) {\n\t\tif (toklen <= (n_elem + 1) * 4)\n\t\t\treturn -EINVAL;\n\n\t\t_debug(\"n_elem %d\", n_elem);\n\n\t\ttd = kcalloc(n_elem, sizeof(struct krb5_tagged_data),\n\t\t\t     GFP_KERNEL);\n\t\tif (!td)\n\t\t\treturn -ENOMEM;\n\t\t*_td = td;\n\n\t\tfor (loop = 0; loop < n_elem; loop++) {\n\t\t\tret = rxrpc_krb5_decode_tagged_data(&td[loop],\n\t\t\t\t\t\t\t    max_elem_size,\n\t\t\t\t\t\t\t    &xdr, &toklen);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * extract a krb5 ticket\n */\nstatic int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,\n\t\t\t\t    const __be32 **_xdr, unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, len;\n\n\t/* there must be at least one length word */\n\tif (toklen <= 4)\n\t\treturn -EINVAL;\n\n\t_enter(\",{%x},%u\", ntohl(xdr[0]), toklen);\n\n\tlen = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (len > AFSTOKEN_K5_TIX_MAX)\n\t\treturn -EINVAL;\n\t*_tktlen = len;\n\n\t_debug(\"ticket len %u\", len);\n\n\tif (len > 0) {\n\t\t*_ticket = kmemdup(xdr, len, GFP_KERNEL);\n\t\tif (!*_ticket)\n\t\t\treturn -ENOMEM;\n\t\tlen = (len + 3) & ~3;\n\t\ttoklen -= len;\n\t\txdr += len >> 2;\n\t}\n\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}\n\n/*\n * parse an RxK5 type XDR format token\n * - the caller guarantees we have at least 4 words\n */\nstatic int rxrpc_preparse_xdr_rxk5(struct key_preparsed_payload *prep,\n\t\t\t\t   size_t datalen,\n\t\t\t\t   const __be32 *xdr, unsigned int toklen)\n{\n\tstruct rxrpc_key_token *token, **pptoken;\n\tstruct rxk5_key *rxk5;\n\tconst __be32 *end_xdr = xdr + (toklen >> 2);\n\tint ret;\n\n\t_enter(\",{%x,%x,%x,%x},%u\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       toklen);\n\n\t/* reserve some payload space for this subkey - the length of the token\n\t * is a reasonable approximation */\n\tprep->quotalen = datalen + toklen;\n\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\treturn -ENOMEM;\n\n\trxk5 = kzalloc(sizeof(*rxk5), GFP_KERNEL);\n\tif (!rxk5) {\n\t\tkfree(token);\n\t\treturn -ENOMEM;\n\t}\n\n\ttoken->security_index = RXRPC_SECURITY_RXK5;\n\ttoken->k5 = rxk5;\n\n\t/* extract the principals */\n\tret = rxrpc_krb5_decode_principal(&rxk5->client, &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = rxrpc_krb5_decode_principal(&rxk5->server, &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* extract the session key and the encoding type (the tag field ->\n\t * ENCTYPE_xxx) */\n\tret = rxrpc_krb5_decode_tagged_data(&rxk5->session, AFSTOKEN_DATA_MAX,\n\t\t\t\t\t    &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (toklen < 4 * 8 + 2 * 4)\n\t\tgoto inval;\n\trxk5->authtime\t= be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->starttime\t= be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->endtime\t= be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->renew_till = be64_to_cpup((const __be64 *) xdr);\n\txdr += 2;\n\trxk5->is_skey = ntohl(*xdr++);\n\trxk5->flags = ntohl(*xdr++);\n\ttoklen -= 4 * 8 + 2 * 4;\n\n\t_debug(\"times: a=%llx s=%llx e=%llx rt=%llx\",\n\t       rxk5->authtime, rxk5->starttime, rxk5->endtime,\n\t       rxk5->renew_till);\n\t_debug(\"is_skey=%x flags=%x\", rxk5->is_skey, rxk5->flags);\n\n\t/* extract the permitted client addresses */\n\tret = rxrpc_krb5_decode_tagged_array(&rxk5->addresses,\n\t\t\t\t\t     &rxk5->n_addresses,\n\t\t\t\t\t     AFSTOKEN_K5_ADDRESSES_MAX,\n\t\t\t\t\t     AFSTOKEN_DATA_MAX,\n\t\t\t\t\t     &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\n\n\t/* extract the tickets */\n\tret = rxrpc_krb5_decode_ticket(&rxk5->ticket, &rxk5->ticket_len,\n\t\t\t\t       &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = rxrpc_krb5_decode_ticket(&rxk5->ticket2, &rxk5->ticket2_len,\n\t\t\t\t       &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\n\n\t/* extract the typed auth data */\n\tret = rxrpc_krb5_decode_tagged_array(&rxk5->authdata,\n\t\t\t\t\t     &rxk5->n_authdata,\n\t\t\t\t\t     AFSTOKEN_K5_AUTHDATA_MAX,\n\t\t\t\t\t     AFSTOKEN_BDATALN_MAX,\n\t\t\t\t\t     &xdr, &toklen);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tASSERTCMP((end_xdr - xdr) << 2, ==, toklen);\n\n\tif (toklen != 0)\n\t\tgoto inval;\n\n\t/* attach the payload */\n\tfor (pptoken = (struct rxrpc_key_token **)&prep->payload[0];\n\t     *pptoken;\n\t     pptoken = &(*pptoken)->next)\n\t\tcontinue;\n\t*pptoken = token;\n\tif (token->kad->expiry < prep->expiry)\n\t\tprep->expiry = token->kad->expiry;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tret = -EINVAL;\nerror:\n\trxrpc_rxk5_free(rxk5);\n\tkfree(token);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * attempt to parse the data as the XDR format\n * - the caller guarantees we have more than 7 words\n */\nstatic int rxrpc_preparse_xdr(struct key_preparsed_payload *prep)\n{\n\tconst __be32 *xdr = prep->data, *token;\n\tconst char *cp;\n\tunsigned int len, tmp, loop, ntoken, toklen, sec_ix;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\t_enter(\",{%x,%x,%x,%x},%zu\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       prep->datalen);\n\n\tif (datalen > AFSTOKEN_LENGTH_MAX)\n\t\tgoto not_xdr;\n\n\t/* XDR is an array of __be32's */\n\tif (datalen & 3)\n\t\tgoto not_xdr;\n\n\t/* the flags should be 0 (the setpag bit must be handled by\n\t * userspace) */\n\tif (ntohl(*xdr++) != 0)\n\t\tgoto not_xdr;\n\tdatalen -= 4;\n\n\t/* check the cell name */\n\tlen = ntohl(*xdr++);\n\tif (len < 1 || len > AFSTOKEN_CELL_MAX)\n\t\tgoto not_xdr;\n\tdatalen -= 4;\n\ttmp = (len + 3) & ~3;\n\tif (tmp > datalen)\n\t\tgoto not_xdr;\n\n\tcp = (const char *) xdr;\n\tfor (loop = 0; loop < len; loop++)\n\t\tif (!isprint(cp[loop]))\n\t\t\tgoto not_xdr;\n\tif (len < tmp)\n\t\tfor (; loop < tmp; loop++)\n\t\t\tif (cp[loop])\n\t\t\t\tgoto not_xdr;\n\t_debug(\"cellname: [%u/%u] '%*.*s'\",\n\t       len, tmp, len, len, (const char *) xdr);\n\tdatalen -= tmp;\n\txdr += tmp >> 2;\n\n\t/* get the token count */\n\tif (datalen < 12)\n\t\tgoto not_xdr;\n\tntoken = ntohl(*xdr++);\n\tdatalen -= 4;\n\t_debug(\"ntoken: %x\", ntoken);\n\tif (ntoken < 1 || ntoken > AFSTOKEN_MAX)\n\t\tgoto not_xdr;\n\n\t/* check each token wrapper */\n\ttoken = xdr;\n\tloop = ntoken;\n\tdo {\n\t\tif (datalen < 8)\n\t\t\tgoto not_xdr;\n\t\ttoklen = ntohl(*xdr++);\n\t\tsec_ix = ntohl(*xdr);\n\t\tdatalen -= 4;\n\t\t_debug(\"token: [%x/%zx] %x\", toklen, datalen, sec_ix);\n\t\tif (toklen < 20 || toklen > datalen)\n\t\t\tgoto not_xdr;\n\t\tdatalen -= (toklen + 3) & ~3;\n\t\txdr += (toklen + 3) >> 2;\n\n\t} while (--loop > 0);\n\n\t_debug(\"remainder: %zu\", datalen);\n\tif (datalen != 0)\n\t\tgoto not_xdr;\n\n\t/* okay: we're going to assume it's valid XDR format\n\t * - we ignore the cellname, relying on the key to be correctly named\n\t */\n\tdo {\n\t\txdr = token;\n\t\ttoklen = ntohl(*xdr++);\n\t\ttoken = xdr + ((toklen + 3) >> 2);\n\t\tsec_ix = ntohl(*xdr++);\n\t\ttoklen -= 4;\n\n\t\t_debug(\"TOKEN type=%u [%p-%p]\", sec_ix, xdr, token);\n\n\t\tswitch (sec_ix) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tret = rxrpc_preparse_xdr_rxkad(prep, datalen, xdr, toklen);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tret = rxrpc_preparse_xdr_rxk5(prep, datalen, xdr, toklen);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto error;\n\t\t}\n\n\t} while (--ntoken > 0);\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nnot_xdr:\n\t_leave(\" = -EPROTO\");\n\treturn -EPROTO;\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Preparse an rxrpc defined key.\n *\n * Data should be of the form:\n *\tOFFSET\tLEN\tCONTENT\n *\t0\t4\tkey interface version number\n *\t4\t2\tsecurity index (type)\n *\t6\t2\tticket length\n *\t8\t4\tkey expiry time (time_t)\n *\t12\t4\tkvno\n *\t16\t8\tsession key\n *\t24\t[len]\tticket\n *\n * if no data is provided, then a no-security key is made\n */\nstatic int rxrpc_preparse(struct key_preparsed_payload *prep)\n{\n\tconst struct rxrpc_key_data_v1 *v1;\n\tstruct rxrpc_key_token *token, **pp;\n\tsize_t plen;\n\tu32 kver;\n\tint ret;\n\n\t_enter(\"%zu\", prep->datalen);\n\n\t/* handle a no-security key */\n\tif (!prep->data && prep->datalen == 0)\n\t\treturn 0;\n\n\t/* determine if the XDR payload format is being used */\n\tif (prep->datalen > 7 * 4) {\n\t\tret = rxrpc_preparse_xdr(prep);\n\t\tif (ret != -EPROTO)\n\t\t\treturn ret;\n\t}\n\n\t/* get the key interface version number */\n\tret = -EINVAL;\n\tif (prep->datalen <= 4 || !prep->data)\n\t\tgoto error;\n\tmemcpy(&kver, prep->data, sizeof(kver));\n\tprep->data += sizeof(kver);\n\tprep->datalen -= sizeof(kver);\n\n\t_debug(\"KEY I/F VERSION: %u\", kver);\n\n\tret = -EKEYREJECTED;\n\tif (kver != 1)\n\t\tgoto error;\n\n\t/* deal with a version 1 key */\n\tret = -EINVAL;\n\tif (prep->datalen < sizeof(*v1))\n\t\tgoto error;\n\n\tv1 = prep->data;\n\tif (prep->datalen != sizeof(*v1) + v1->ticket_length)\n\t\tgoto error;\n\n\t_debug(\"SCIX: %u\", v1->security_index);\n\t_debug(\"TLEN: %u\", v1->ticket_length);\n\t_debug(\"EXPY: %x\", v1->expiry);\n\t_debug(\"KVNO: %u\", v1->kvno);\n\t_debug(\"SKEY: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t       v1->session_key[0], v1->session_key[1],\n\t       v1->session_key[2], v1->session_key[3],\n\t       v1->session_key[4], v1->session_key[5],\n\t       v1->session_key[6], v1->session_key[7]);\n\tif (v1->ticket_length >= 8)\n\t\t_debug(\"TCKT: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t\t       v1->ticket[0], v1->ticket[1],\n\t\t       v1->ticket[2], v1->ticket[3],\n\t\t       v1->ticket[4], v1->ticket[5],\n\t\t       v1->ticket[6], v1->ticket[7]);\n\n\tret = -EPROTONOSUPPORT;\n\tif (v1->security_index != RXRPC_SECURITY_RXKAD)\n\t\tgoto error;\n\n\tplen = sizeof(*token->kad) + v1->ticket_length;\n\tprep->quotalen = plen + sizeof(*token);\n\n\tret = -ENOMEM;\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\tgoto error;\n\ttoken->kad = kzalloc(plen, GFP_KERNEL);\n\tif (!token->kad)\n\t\tgoto error_free;\n\n\ttoken->security_index\t\t= RXRPC_SECURITY_RXKAD;\n\ttoken->kad->ticket_len\t\t= v1->ticket_length;\n\ttoken->kad->expiry\t\t= v1->expiry;\n\ttoken->kad->kvno\t\t= v1->kvno;\n\tmemcpy(&token->kad->session_key, &v1->session_key, 8);\n\tmemcpy(&token->kad->ticket, v1->ticket, v1->ticket_length);\n\n\t/* count the number of tokens attached */\n\tprep->type_data[0] = (void *)((unsigned long)prep->type_data[0] + 1);\n\n\t/* attach the data */\n\tpp = (struct rxrpc_key_token **)&prep->payload[0];\n\twhile (*pp)\n\t\tpp = &(*pp)->next;\n\t*pp = token;\n\tif (token->kad->expiry < prep->expiry)\n\t\tprep->expiry = token->kad->expiry;\n\ttoken = NULL;\n\tret = 0;\n\nerror_free:\n\tkfree(token);\nerror:\n\treturn ret;\n}\n\n/*\n * Free token list.\n */\nstatic void rxrpc_free_token_list(struct rxrpc_key_token *token)\n{\n\tstruct rxrpc_key_token *next;\n\n\tfor (; token; token = next) {\n\t\tnext = token->next;\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tkfree(token->kad);\n\t\t\tbreak;\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tif (token->k5)\n\t\t\t\trxrpc_rxk5_free(token->k5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"Unknown token type %x on rxrpc key\\n\",\n\t\t\t       token->security_index);\n\t\t\tBUG();\n\t\t}\n\n\t\tkfree(token);\n\t}\n}\n\n/*\n * Clean up preparse data.\n */\nstatic void rxrpc_free_preparse(struct key_preparsed_payload *prep)\n{\n\trxrpc_free_token_list(prep->payload[0]);\n}\n\n/*\n * Preparse a server secret key.\n *\n * The data should be the 8-byte secret key.\n */\nstatic int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_blkcipher *ci;\n\n\t_enter(\"%zu\", prep->datalen);\n\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\n\tmemcpy(&prep->type_data, prep->data, 8);\n\n\tci = crypto_alloc_blkcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\n\tif (crypto_blkcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\n\tprep->payload[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n/*\n * Clean up preparse data.\n */\nstatic void rxrpc_free_preparse_s(struct key_preparsed_payload *prep)\n{\n\tif (prep->payload[0])\n\t\tcrypto_free_blkcipher(prep->payload[0]);\n}\n\n/*\n * dispose of the data dangling from the corpse of a rxrpc key\n */\nstatic void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data);\n}\n\n/*\n * dispose of the data dangling from the corpse of a rxrpc key\n */\nstatic void rxrpc_destroy_s(struct key *key)\n{\n\tif (key->payload.data) {\n\t\tcrypto_free_blkcipher(key->payload.data);\n\t\tkey->payload.data = NULL;\n\t}\n}\n\n/*\n * describe the rxrpc key\n */\nstatic void rxrpc_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n}\n\n/*\n * grab the security key for a socket\n */\nint rxrpc_request_key(struct rxrpc_sock *rx, char __user *optval, int optlen)\n{\n\tstruct key *key;\n\tchar *description;\n\n\t_enter(\"\");\n\n\tif (optlen <= 0 || optlen > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\n\tdescription = kmalloc(optlen + 1, GFP_KERNEL);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(description, optval, optlen)) {\n\t\tkfree(description);\n\t\treturn -EFAULT;\n\t}\n\tdescription[optlen] = 0;\n\n\tkey = request_key(&key_type_rxrpc, description, NULL);\n\tif (IS_ERR(key)) {\n\t\tkfree(description);\n\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\trx->key = key;\n\tkfree(description);\n\t_leave(\" = 0 [key %x]\", key->serial);\n\treturn 0;\n}\n\n/*\n * grab the security keyring for a server socket\n */\nint rxrpc_server_keyring(struct rxrpc_sock *rx, char __user *optval,\n\t\t\t int optlen)\n{\n\tstruct key *key;\n\tchar *description;\n\n\t_enter(\"\");\n\n\tif (optlen <= 0 || optlen > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\n\tdescription = kmalloc(optlen + 1, GFP_KERNEL);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(description, optval, optlen)) {\n\t\tkfree(description);\n\t\treturn -EFAULT;\n\t}\n\tdescription[optlen] = 0;\n\n\tkey = request_key(&key_type_keyring, description, NULL);\n\tif (IS_ERR(key)) {\n\t\tkfree(description);\n\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\trx->securities = key;\n\tkfree(description);\n\t_leave(\" = 0 [key %x]\", key->serial);\n\treturn 0;\n}\n\n/*\n * generate a server data key\n */\nint rxrpc_get_server_data_key(struct rxrpc_connection *conn,\n\t\t\t      const void *session_key,\n\t\t\t      time_t expiry,\n\t\t\t      u32 kvno)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\n\tstruct {\n\t\tu32 kver;\n\t\tstruct rxrpc_key_data_v1 v1;\n\t} data;\n\n\t_enter(\"\");\n\n\tkey = key_alloc(&key_type_rxrpc, \"x\",\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred, 0,\n\t\t\tKEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = -ENOMEM [alloc %ld]\", PTR_ERR(key));\n\t\treturn -ENOMEM;\n\t}\n\n\t_debug(\"key %d\", key_serial(key));\n\n\tdata.kver = 1;\n\tdata.v1.security_index = RXRPC_SECURITY_RXKAD;\n\tdata.v1.ticket_length = 0;\n\tdata.v1.expiry = expiry;\n\tdata.v1.kvno = 0;\n\n\tmemcpy(&data.v1.session_key, session_key, sizeof(data.v1.session_key));\n\n\tret = key_instantiate_and_link(key, &data, sizeof(data), NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tconn->key = key;\n\t_leave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\nerror:\n\tkey_revoke(key);\n\tkey_put(key);\n\t_leave(\" = -ENOMEM [ins %d]\", ret);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(rxrpc_get_server_data_key);\n\n/**\n * rxrpc_get_null_key - Generate a null RxRPC key\n * @keyname: The name to give the key.\n *\n * Generate a null RxRPC key that can be used to indicate anonymous security is\n * required for a particular domain.\n */\nstruct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key))\n\t\treturn key;\n\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn key;\n}\nEXPORT_SYMBOL(rxrpc_get_null_key);\n\n/*\n * read the contents of an rxrpc key\n * - this returns the result in XDR form\n */\nstatic long rxrpc_read(const struct key *key,\n\t\t       char __user *buffer, size_t buflen)\n{\n\tconst struct rxrpc_key_token *token;\n\tconst struct krb5_principal *princ;\n\tsize_t size;\n\t__be32 __user *xdr, *oldxdr;\n\tu32 cnlen, toksize, ntoks, tok, zero;\n\tu16 toksizes[AFSTOKEN_MAX];\n\tint loop;\n\n\t_enter(\"\");\n\n\t/* we don't know what form we should return non-AFS keys in */\n\tif (memcmp(key->description, \"afs@\", 4) != 0)\n\t\treturn -EOPNOTSUPP;\n\tcnlen = strlen(key->description + 4);\n\n#define RND(X) (((X) + 3) & ~3)\n\n\t/* AFS keys we return in XDR form, so we need to work out the size of\n\t * the XDR */\n\tsize = 2 * 4;\t/* flags, cellname len */\n\tsize += RND(cnlen);\t/* cellname */\n\tsize += 1 * 4;\t/* token count */\n\n\tntoks = 0;\n\tfor (token = key->payload.data; token; token = token->next) {\n\t\ttoksize = 4;\t/* sec index */\n\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\ttoksize += 8 * 4;\t/* viceid, kvno, key*2, begin,\n\t\t\t\t\t\t * end, primary, tktlen */\n\t\t\ttoksize += RND(token->kad->ticket_len);\n\t\t\tbreak;\n\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tprinc = &token->k5->client;\n\t\t\ttoksize += 4 + princ->n_name_parts * 4;\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\ttoksize += RND(strlen(princ->name_parts[loop]));\n\t\t\ttoksize += 4 + RND(strlen(princ->realm));\n\n\t\t\tprinc = &token->k5->server;\n\t\t\ttoksize += 4 + princ->n_name_parts * 4;\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\ttoksize += RND(strlen(princ->name_parts[loop]));\n\t\t\ttoksize += 4 + RND(strlen(princ->realm));\n\n\t\t\ttoksize += 8 + RND(token->k5->session.data_len);\n\n\t\t\ttoksize += 4 * 8 + 2 * 4;\n\n\t\t\ttoksize += 4 + token->k5->n_addresses * 8;\n\t\t\tfor (loop = 0; loop < token->k5->n_addresses; loop++)\n\t\t\t\ttoksize += RND(token->k5->addresses[loop].data_len);\n\n\t\t\ttoksize += 4 + RND(token->k5->ticket_len);\n\t\t\ttoksize += 4 + RND(token->k5->ticket2_len);\n\n\t\t\ttoksize += 4 + token->k5->n_authdata * 8;\n\t\t\tfor (loop = 0; loop < token->k5->n_authdata; loop++)\n\t\t\t\ttoksize += RND(token->k5->authdata[loop].data_len);\n\t\t\tbreak;\n\n\t\tdefault: /* we have a ticket we can't encode */\n\t\t\tBUG();\n\t\t\tcontinue;\n\t\t}\n\n\t\t_debug(\"token[%u]: toksize=%u\", ntoks, toksize);\n\t\tASSERTCMP(toksize, <=, AFSTOKEN_LENGTH_MAX);\n\n\t\ttoksizes[ntoks++] = toksize;\n\t\tsize += toksize + 4; /* each token has a length word */\n\t}\n\n#undef RND\n\n\tif (!buffer || buflen < size)\n\t\treturn size;\n\n\txdr = (__be32 __user *) buffer;\n\tzero = 0;\n#define ENCODE(x)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\t__be32 y = htonl(x);\t\t\\\n\t\tif (put_user(y, xdr++) < 0)\t\\\n\t\t\tgoto fault;\t\t\\\n\t} while(0)\n#define ENCODE_DATA(l, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tu32 _l = (l);\t\t\t\t\t\t\\\n\t\tENCODE(l);\t\t\t\t\t\t\\\n\t\tif (copy_to_user(xdr, (s), _l) != 0)\t\t\t\\\n\t\t\tgoto fault;\t\t\t\t\t\\\n\t\tif (_l & 3 &&\t\t\t\t\t\t\\\n\t\t    copy_to_user((u8 *)xdr + _l, &zero, 4 - (_l & 3)) != 0) \\\n\t\t\tgoto fault;\t\t\t\t\t\\\n\t\txdr += (_l + 3) >> 2;\t\t\t\t\t\\\n\t} while(0)\n#define ENCODE64(x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t__be64 y = cpu_to_be64(x);\t\t\\\n\t\tif (copy_to_user(xdr, &y, 8) != 0)\t\\\n\t\t\tgoto fault;\t\t\t\\\n\t\txdr += 8 >> 2;\t\t\t\t\\\n\t} while(0)\n#define ENCODE_STR(s)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tconst char *_s = (s);\t\t\\\n\t\tENCODE_DATA(strlen(_s), _s);\t\\\n\t} while(0)\n\n\tENCODE(0);\t\t\t\t\t/* flags */\n\tENCODE_DATA(cnlen, key->description + 4);\t/* cellname */\n\tENCODE(ntoks);\n\n\ttok = 0;\n\tfor (token = key->payload.data; token; token = token->next) {\n\t\ttoksize = toksizes[tok++];\n\t\tENCODE(toksize);\n\t\toldxdr = xdr;\n\t\tENCODE(token->security_index);\n\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tENCODE(token->kad->vice_id);\n\t\t\tENCODE(token->kad->kvno);\n\t\t\tENCODE_DATA(8, token->kad->session_key);\n\t\t\tENCODE(token->kad->start);\n\t\t\tENCODE(token->kad->expiry);\n\t\t\tENCODE(token->kad->primary_flag);\n\t\t\tENCODE_DATA(token->kad->ticket_len, token->kad->ticket);\n\t\t\tbreak;\n\n\t\tcase RXRPC_SECURITY_RXK5:\n\t\t\tprinc = &token->k5->client;\n\t\t\tENCODE(princ->n_name_parts);\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\tENCODE_STR(princ->name_parts[loop]);\n\t\t\tENCODE_STR(princ->realm);\n\n\t\t\tprinc = &token->k5->server;\n\t\t\tENCODE(princ->n_name_parts);\n\t\t\tfor (loop = 0; loop < princ->n_name_parts; loop++)\n\t\t\t\tENCODE_STR(princ->name_parts[loop]);\n\t\t\tENCODE_STR(princ->realm);\n\n\t\t\tENCODE(token->k5->session.tag);\n\t\t\tENCODE_DATA(token->k5->session.data_len,\n\t\t\t\t    token->k5->session.data);\n\n\t\t\tENCODE64(token->k5->authtime);\n\t\t\tENCODE64(token->k5->starttime);\n\t\t\tENCODE64(token->k5->endtime);\n\t\t\tENCODE64(token->k5->renew_till);\n\t\t\tENCODE(token->k5->is_skey);\n\t\t\tENCODE(token->k5->flags);\n\n\t\t\tENCODE(token->k5->n_addresses);\n\t\t\tfor (loop = 0; loop < token->k5->n_addresses; loop++) {\n\t\t\t\tENCODE(token->k5->addresses[loop].tag);\n\t\t\t\tENCODE_DATA(token->k5->addresses[loop].data_len,\n\t\t\t\t\t    token->k5->addresses[loop].data);\n\t\t\t}\n\n\t\t\tENCODE_DATA(token->k5->ticket_len, token->k5->ticket);\n\t\t\tENCODE_DATA(token->k5->ticket2_len, token->k5->ticket2);\n\n\t\t\tENCODE(token->k5->n_authdata);\n\t\t\tfor (loop = 0; loop < token->k5->n_authdata; loop++) {\n\t\t\t\tENCODE(token->k5->authdata[loop].tag);\n\t\t\t\tENCODE_DATA(token->k5->authdata[loop].data_len,\n\t\t\t\t\t    token->k5->authdata[loop].data);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\n\t\tASSERTCMP((unsigned long)xdr - (unsigned long)oldxdr, ==,\n\t\t\t  toksize);\n\t}\n\n#undef ENCODE_STR\n#undef ENCODE_DATA\n#undef ENCODE64\n#undef ENCODE\n\n\tASSERTCMP(tok, ==, ntoks);\n\tASSERTCMP((char __user *) xdr - buffer, ==, size);\n\t_leave(\" = %zu\", size);\n\treturn size;\n\nfault:\n\t_leave(\" = -EFAULT\");\n\treturn -EFAULT;\n}\n", "/* Large capacity key type\n *\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/shmem_fs.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/big_key-type.h>\n\nMODULE_LICENSE(\"GPL\");\n\n/*\n * If the data is under this limit, there's no point creating a shm file to\n * hold it as the permanently resident metadata for the shmem fs will be at\n * least as large as the data.\n */\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\n/*\n * big_key defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n};\n\n/*\n * Preparse a big key\n */\nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload;\n\tstruct file *file;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->type_data[1] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * TODO: Encrypt the stored data with a temporary key.\n\t\t */\n\t\tfile = shmem_kernel_file_setup(\"\", datalen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\twritten = kernel_write(file, prep->data, prep->datalen, 0);\n\t\tif (written != datalen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload[0] = memcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerror:\n\treturn ret;\n}\n\n/*\n * Clear preparsement.\n */\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload;\n\t\tpath_put(path);\n\t} else {\n\t\tkfree(prep->payload[0]);\n\t}\n}\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data2;\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) && key->type_data.x[1] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}\n\n/*\n * dispose of the data dangling from the corpse of a big_key key\n */\nvoid big_key_destroy(struct key *key)\n{\n\tif (key->type_data.x[1] > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data2;\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t} else {\n\t\tkfree(key->payload.data);\n\t\tkey->payload.data = NULL;\n\t}\n}\n\n/*\n * describe the big_key key\n */\nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tunsigned long datalen = key->type_data.x[1];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %lu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tunsigned long datalen = key->type_data.x[1];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data2;\n\t\tstruct file *file;\n\t\tloff_t pos;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\n\t\tpos = 0;\n\t\tret = vfs_read(file, buffer, datalen, &pos);\n\t\tfput(file);\n\t\tif (ret >= 0 && ret != datalen)\n\t\t\tret = -EIO;\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Module stuff\n */\nstatic int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}\n\nstatic void __exit big_key_cleanup(void)\n{\n\tunregister_key_type(&key_type_big_key);\n}\n\nmodule_init(big_key_init);\nmodule_exit(big_key_cleanup);\n", "/*\n * Copyright (C) 2010 IBM Corporation\n * Copyright (C) 2010 Politecnico di Torino, Italy\n *                    TORSEC group -- http://security.polito.it\n *\n * Authors:\n * Mimi Zohar <zohar@us.ibm.com>\n * Roberto Sassu <roberto.sassu@polito.it>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/ctype.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <crypto/aes.h>\n\n#include \"encrypted.h\"\n#include \"ecryptfs_format.h\"\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\nstatic const char hash_alg[] = \"sha256\";\nstatic const char hmac_alg[] = \"hmac(sha256)\";\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_ECRYPTFS_DESC_LEN 16\n#define HASH_SIZE SHA256_DIGEST_SIZE\n#define MAX_DATA_SIZE 4096\n#define MIN_DATA_SIZE  20\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nenum {\n\tOpt_err = -1, Opt_new, Opt_load, Opt_update\n};\n\nenum {\n\tOpt_error = -1, Opt_default, Opt_ecryptfs\n};\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_blkcipher *tfm;\n\n\ttfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_blkcipher_ivsize(tfm);\n\tblksize = crypto_blkcipher_blocksize(tfm);\n\tcrypto_free_blkcipher(tfm);\n\treturn 0;\n}\n\n/*\n * valid_ecryptfs_desc - verify the description of a new/loaded encrypted key\n *\n * The description of a encrypted key with format 'ecryptfs' must contain\n * exactly 16 hexadecimal characters.\n *\n */\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * valid_master_desc - verify the 'key-type:desc' of a new/updated master-key\n *\n * key-type:= \"trusted:\" | \"user:\"\n * desc:= master-key description\n *\n * Verify that 'key-type' is valid and that 'desc' exists. On key update,\n * only the master key description is permitted to change, not the key-type.\n * The key-type remains constant.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tif (!memcmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_TRUSTED_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_TRUSTED_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else if (!memcmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN)) {\n\t\tif (strlen(new_desc) == KEY_USER_PREFIX_LEN)\n\t\t\tgoto out;\n\t\tif (orig_desc)\n\t\t\tif (memcmp(new_desc, orig_desc, KEY_USER_PREFIX_LEN))\n\t\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn -EINVAL;\n}\n\n/*\n * datablob_parse - parse the keyctl data\n *\n * datablob format:\n * new [<format>] <master-key name> <decrypted data length>\n * load [<format>] <master-key name> <decrypted data length>\n *     <encrypted iv + data>\n * update <new-master-key name>\n *\n * Tokenizes a copy of the keyctl data, returning a pointer to each token,\n * which is null terminated.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n/*\n * datablob_format - format as an ascii string, before copying to userspace\n */\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}\n\n/*\n * request_user_key - request the user key\n *\n * Use a user provided key to encrypt/decrypt an encrypted-key.\n */\nstatic struct key *request_user_key(const char *master_desc, u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tstruct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = ukey->payload.data;\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n\nstatic struct sdesc *alloc_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (!ret)\n\t\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int calc_hash(u8 *digest, const u8 *buf, unsigned int buflen)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = alloc_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"encrypted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, buf, buflen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nenum derived_key_type { ENC_KEY, AUTH_KEY };\n\n/* Derive authentication/encryption key from trusted key */\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf) {\n\t\tpr_err(\"encrypted_key: out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(derived_key, derived_buf, derived_buf_len);\n\tkfree(derived_buf);\n\treturn ret;\n}\n\nstatic int init_blkcipher_desc(struct blkcipher_desc *desc, const u8 *key,\n\t\t\t       unsigned int key_len, const u8 *iv,\n\t\t\t       unsigned int ivsize)\n{\n\tint ret;\n\n\tdesc->tfm = crypto_alloc_blkcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc->tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(desc->tfm));\n\t\treturn PTR_ERR(desc->tfm);\n\t}\n\tdesc->flags = 0;\n\n\tret = crypto_blkcipher_setkey(desc->tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_blkcipher(desc->tfm);\n\t\treturn ret;\n\t}\n\tcrypto_blkcipher_set_iv(desc->tfm, iv, ivsize);\n\treturn 0;\n}\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = NULL;\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n\n/* Before returning data to userspace, encrypt decrypted data. */\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tunsigned int padlen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tpadlen = encrypted_datalen - epayload->decrypted_datalen;\n\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_in[1], pad, padlen);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\treturn ret;\n}\n\n/* verify HMAC before decrypting encrypted key */\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = memcmp(digest, epayload->format + epayload->datablob_len,\n\t\t     sizeof digest);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct blkcipher_desc desc;\n\tunsigned int encrypted_datalen;\n\tchar pad[16];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,\n\t\t\t\t  epayload->iv, ivsize);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tmemset(pad, 0, sizeof pad);\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, sizeof pad);\n\n\tret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, encrypted_datalen);\n\tcrypto_free_blkcipher(desc.tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\treturn ret;\n}\n\n/* Allocate memory for decrypted key and datablob. */\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tu8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}\n\n/*\n * encrypted_init - initialize an encrypted key\n *\n * For a new key, use a random number for both the iv and data\n * itself.  For an old key, decrypt the hex encoded data.\n */\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}\n\n/*\n * encrypted_instantiate - instantiate an encrypted key\n *\n * Decrypt an existing encrypted datablob or create a new encrypted key\n * based on a kernel random number.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkfree(datablob);\n\treturn ret;\n}\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(epayload);\n}\n\n/*\n * encrypted_update - update the master key description\n *\n * Change the master key description for an existing encrypted key.\n * The next read will return an encrypted datablob using the new\n * master key description.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n/*\n * encrypted_read - format and copy the encrypted data to userspace\n *\n * The resulting datablob format is:\n * <master-key name> <decrypted data length> <encrypted iv> <encrypted data>\n *\n * On success, return to userspace the encrypted key datablob size.\n */\nstatic long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tu8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = rcu_dereference_key(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\treturn ret;\n}\n\n/*\n * encrypted_destroy - before freeing the key, clear the decrypted data\n *\n * Before freeing the key, clear the memory containing the decrypted\n * key data.\n */\nstatic void encrypted_destroy(struct key *key)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\n\tif (!epayload)\n\t\treturn;\n\n\tmemset(epayload->decrypted_data, 0, epayload->decrypted_datalen);\n\tkfree(key->payload.data);\n}\n\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_encrypted);\n\nstatic void encrypted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init encrypted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"encrypted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\tret = encrypted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn aes_get_sizes();\nout:\n\tencrypted_shash_release();\n\treturn ret;\n\n}\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tencrypted_shash_release();\n\tunregister_key_type(&key_type_encrypted);\n}\n\nlate_initcall(init_encrypted);\nmodule_exit(cleanup_encrypted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* Authentication token and access key management internal defs\n *\n * Copyright (C) 2003-5, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#ifndef _INTERNAL_H\n#define _INTERNAL_H\n\n#include <linux/sched.h>\n#include <linux/key-type.h>\n#include <linux/task_work.h>\n\nstruct iovec;\n\n#ifdef __KDEBUG\n#define kenter(FMT, ...) \\\n\tprintk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tprintk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tprintk(KERN_DEBUG \"   \"FMT\"\\n\", ##__VA_ARGS__)\n#else\n#define kenter(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"==> %s(\"FMT\")\\n\", __func__, ##__VA_ARGS__)\n#define kleave(FMT, ...) \\\n\tno_printk(KERN_DEBUG \"<== %s()\"FMT\"\\n\", __func__, ##__VA_ARGS__)\n#define kdebug(FMT, ...) \\\n\tno_printk(KERN_DEBUG FMT\"\\n\", ##__VA_ARGS__)\n#endif\n\nextern struct key_type key_type_dead;\nextern struct key_type key_type_user;\nextern struct key_type key_type_logon;\n\n/*****************************************************************************/\n/*\n * Keep track of keys for a user.\n *\n * This needs to be separate to user_struct to avoid a refcount-loop\n * (user_struct pins some keyrings which pin this struct).\n *\n * We also keep track of keys under request from userspace for this UID here.\n */\nstruct key_user {\n\tstruct rb_node\t\tnode;\n\tstruct mutex\t\tcons_lock;\t/* construction initiation lock */\n\tspinlock_t\t\tlock;\n\tatomic_t\t\tusage;\t\t/* for accessing qnkeys & qnbytes */\n\tatomic_t\t\tnkeys;\t\t/* number of keys */\n\tatomic_t\t\tnikeys;\t\t/* number of instantiated keys */\n\tkuid_t\t\t\tuid;\n\tint\t\t\tqnkeys;\t\t/* number of keys allocated to this user */\n\tint\t\t\tqnbytes;\t/* number of bytes allocated to this user */\n};\n\nextern struct rb_root\tkey_user_tree;\nextern spinlock_t\tkey_user_lock;\nextern struct key_user\troot_key_user;\n\nextern struct key_user *key_user_lookup(kuid_t uid);\nextern void key_user_put(struct key_user *user);\n\n/*\n * Key quota limits.\n * - root has its own separate limits to everyone else\n */\nextern unsigned key_quota_root_maxkeys;\nextern unsigned key_quota_root_maxbytes;\nextern unsigned key_quota_maxkeys;\nextern unsigned key_quota_maxbytes;\n\n#define KEYQUOTA_LINK_BYTES\t4\t\t/* a link in a keyring is worth 4 bytes */\n\n\nextern struct kmem_cache *key_jar;\nextern struct rb_root key_serial_tree;\nextern spinlock_t key_serial_lock;\nextern struct mutex key_construction_mutex;\nextern wait_queue_head_t request_key_conswq;\n\n\nextern struct key_type *key_type_lookup(const char *type);\nextern void key_type_put(struct key_type *ktype);\n\nextern int __key_link_begin(struct key *keyring,\n\t\t\t    const struct keyring_index_key *index_key,\n\t\t\t    struct assoc_array_edit **_edit);\nextern int __key_link_check_live_key(struct key *keyring, struct key *key);\nextern void __key_link(struct key *key, struct assoc_array_edit **_edit);\nextern void __key_link_end(struct key *keyring,\n\t\t\t   const struct keyring_index_key *index_key,\n\t\t\t   struct assoc_array_edit *edit);\n\nextern key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t\t    const struct keyring_index_key *index_key);\n\nextern struct key *keyring_search_instkey(struct key *keyring,\n\t\t\t\t\t  key_serial_t target_id);\n\nextern int iterate_over_keyring(const struct key *keyring,\n\t\t\t\tint (*func)(const struct key *key, void *data),\n\t\t\t\tvoid *data);\n\nstruct keyring_search_context {\n\tstruct keyring_index_key index_key;\n\tconst struct cred\t*cred;\n\tstruct key_match_data\tmatch_data;\n\tunsigned\t\tflags;\n#define KEYRING_SEARCH_NO_STATE_CHECK\t0x0001\t/* Skip state checks */\n#define KEYRING_SEARCH_DO_STATE_CHECK\t0x0002\t/* Override NO_STATE_CHECK */\n#define KEYRING_SEARCH_NO_UPDATE_TIME\t0x0004\t/* Don't update times */\n#define KEYRING_SEARCH_NO_CHECK_PERM\t0x0008\t/* Don't check permissions */\n#define KEYRING_SEARCH_DETECT_TOO_DEEP\t0x0010\t/* Give an error on excessive depth */\n\n\tint (*iterator)(const void *object, void *iterator_data);\n\n\t/* Internal stuff */\n\tint\t\t\tskipped_ret;\n\tbool\t\t\tpossessed;\n\tkey_ref_t\t\tresult;\n\tstruct timespec\t\tnow;\n};\n\nextern int key_default_cmp(const struct key *key,\n\t\t\t   const struct key_match_data *match_data);\nextern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t\t    struct keyring_search_context *ctx);\n\nextern key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx);\nextern key_ref_t search_process_keyrings(struct keyring_search_context *ctx);\n\nextern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);\n\nextern int install_user_keyrings(void);\nextern int install_thread_keyring_to_cred(struct cred *);\nextern int install_process_keyring_to_cred(struct cred *);\nextern int install_session_keyring_to_cred(struct cred *, struct key *);\n\nextern struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t\tconst char *description,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tvoid *aux,\n\t\t\t\t\tstruct key *dest_keyring,\n\t\t\t\t\tunsigned long flags);\n\nextern int lookup_user_key_possessed(const struct key *key,\n\t\t\t\t     const struct key_match_data *match_data);\nextern key_ref_t lookup_user_key(key_serial_t id, unsigned long flags,\n\t\t\t\t key_perm_t perm);\n#define KEY_LOOKUP_CREATE\t0x01\n#define KEY_LOOKUP_PARTIAL\t0x02\n#define KEY_LOOKUP_FOR_UNLINK\t0x04\n\nextern long join_session_keyring(const char *name);\nextern void key_change_session_keyring(struct callback_head *twork);\n\nextern struct work_struct key_gc_work;\nextern unsigned key_gc_delay;\nextern void keyring_gc(struct key *keyring, time_t limit);\nextern void key_schedule_gc(time_t gc_at);\nextern void key_schedule_gc_links(void);\nextern void key_gc_keytype(struct key_type *ktype);\n\nextern int key_task_permission(const key_ref_t key_ref,\n\t\t\t       const struct cred *cred,\n\t\t\t       key_perm_t perm);\n\n/*\n * Check to see whether permission is granted to use a key in the desired way.\n */\nstatic inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}\n\n/*\n * Authorisation record for request_key().\n */\nstruct request_key_auth {\n\tstruct key\t\t*target_key;\n\tstruct key\t\t*dest_keyring;\n\tconst struct cred\t*cred;\n\tvoid\t\t\t*callout_info;\n\tsize_t\t\t\tcallout_len;\n\tpid_t\t\t\tpid;\n};\n\nextern struct key_type key_type_request_key_auth;\nextern struct key *request_key_auth_new(struct key *target,\n\t\t\t\t\tconst void *callout_info,\n\t\t\t\t\tsize_t callout_len,\n\t\t\t\t\tstruct key *dest_keyring);\n\nextern struct key *key_get_instantiation_authkey(key_serial_t target_id);\n\n/*\n * Determine whether a key is dead.\n */\nstatic inline bool key_is_dead(const struct key *key, time_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}\n\n/*\n * keyctl() functions\n */\nextern long keyctl_get_keyring_ID(key_serial_t, int);\nextern long keyctl_join_session_keyring(const char __user *);\nextern long keyctl_update_key(key_serial_t, const void __user *, size_t);\nextern long keyctl_revoke_key(key_serial_t);\nextern long keyctl_keyring_clear(key_serial_t);\nextern long keyctl_keyring_link(key_serial_t, key_serial_t);\nextern long keyctl_keyring_unlink(key_serial_t, key_serial_t);\nextern long keyctl_describe_key(key_serial_t, char __user *, size_t);\nextern long keyctl_keyring_search(key_serial_t, const char __user *,\n\t\t\t\t  const char __user *, key_serial_t);\nextern long keyctl_read_key(key_serial_t, char __user *, size_t);\nextern long keyctl_chown_key(key_serial_t, uid_t, gid_t);\nextern long keyctl_setperm_key(key_serial_t, key_perm_t);\nextern long keyctl_instantiate_key(key_serial_t, const void __user *,\n\t\t\t\t   size_t, key_serial_t);\nextern long keyctl_negate_key(key_serial_t, unsigned, key_serial_t);\nextern long keyctl_set_reqkey_keyring(int);\nextern long keyctl_set_timeout(key_serial_t, unsigned);\nextern long keyctl_assume_authority(key_serial_t);\nextern long keyctl_get_security(key_serial_t keyid, char __user *buffer,\n\t\t\t\tsize_t buflen);\nextern long keyctl_session_to_parent(void);\nextern long keyctl_reject_key(key_serial_t, unsigned, unsigned, key_serial_t);\nextern long keyctl_instantiate_key_iov(key_serial_t,\n\t\t\t\t       const struct iovec __user *,\n\t\t\t\t       unsigned, key_serial_t);\nextern long keyctl_invalidate_key(key_serial_t);\n\nextern long keyctl_instantiate_key_common(key_serial_t,\n\t\t\t\t\t  const struct iovec *,\n\t\t\t\t\t  unsigned, size_t, key_serial_t);\n#ifdef CONFIG_PERSISTENT_KEYRINGS\nextern long keyctl_get_persistent(uid_t, key_serial_t);\nextern unsigned persistent_keyring_expiry;\n#else\nstatic inline long keyctl_get_persistent(uid_t uid, key_serial_t destring)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\n/*\n * Debugging key validation\n */\n#ifdef KEY_DEBUGGING\nextern void __key_check(const struct key *);\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}\n\n#else\n\n#define key_check(key) do {} while(0)\n\n#endif\n\n#endif /* _INTERNAL_H */\n", "/* Basic authentication token and access key management\n *\n * Copyright (C) 2004-2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include \"internal.h\"\n\nstruct kmem_cache *key_jar;\nstruct rb_root\t\tkey_serial_tree; /* tree of keys indexed by serial */\nDEFINE_SPINLOCK(key_serial_lock);\n\nstruct rb_root\tkey_user_tree; /* tree of quota records indexed by UID */\nDEFINE_SPINLOCK(key_user_lock);\n\nunsigned int key_quota_root_maxkeys = 200;\t/* root's key count quota */\nunsigned int key_quota_root_maxbytes = 20000;\t/* root's key space quota */\nunsigned int key_quota_maxkeys = 200;\t\t/* general key count quota */\nunsigned int key_quota_maxbytes = 20000;\t/* general key space quota */\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\n/* We serialise key instantiation and link */\nDEFINE_MUTEX(key_construction_mutex);\n\n#ifdef KEY_DEBUGGING\nvoid __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}\n#endif\n\n/*\n * Get the key quota record for a user, allocating a new record if one doesn't\n * already exist.\n */\nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p;\n\ntry_again:\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\tatomic_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\tatomic_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}\n\n/*\n * Dispose of a user structure\n */\nvoid key_user_put(struct key_user *user)\n{\n\tif (atomic_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}\n\n/*\n * Allocate a serial number for a key.  These are assigned randomly to avoid\n * security issues through covert channel problems.\n */\nstatic inline void key_alloc_serial(struct key *key)\n{\n\tstruct rb_node *parent, **p;\n\tstruct key *xkey;\n\n\t/* propose a random serial number and look for a hole for it in the\n\t * serial number tree */\n\tdo {\n\t\tget_random_bytes(&key->serial, sizeof(key->serial));\n\n\t\tkey->serial >>= 1; /* negative numbers are not permitted */\n\t} while (key->serial < 3);\n\n\tspin_lock(&key_serial_lock);\n\nattempt_insertion:\n\tparent = NULL;\n\tp = &key_serial_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\n\t\tif (key->serial < xkey->serial)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key->serial > xkey->serial)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto serial_exists;\n\t}\n\n\t/* we've found a suitable hole - arrange for this key to occupy it */\n\trb_link_node(&key->serial_node, parent, p);\n\trb_insert_color(&key->serial_node, &key_serial_tree);\n\n\tspin_unlock(&key_serial_lock);\n\treturn;\n\n\t/* we found a key with the proposed serial number - walk the tree from\n\t * that point looking for the next unused serial number */\nserial_exists:\n\tfor (;;) {\n\t\tkey->serial++;\n\t\tif (key->serial < 3) {\n\t\t\tkey->serial = 3;\n\t\t\tgoto attempt_insertion;\n\t\t}\n\n\t\tparent = rb_next(parent);\n\t\tif (!parent)\n\t\t\tgoto attempt_insertion;\n\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\t\tif (key->serial < xkey->serial)\n\t\t\tgoto attempt_insertion;\n\t}\n}\n\n/**\n * key_alloc - Allocate a key of the specified type.\n * @type: The type of key to allocate.\n * @desc: The key description to allow the key to be searched out.\n * @uid: The owner of the new key.\n * @gid: The group ID for the new key's group permissions.\n * @cred: The credentials specifying UID namespace.\n * @perm: The permissions mask of the new key.\n * @flags: Flags specifying quota properties.\n *\n * Allocate a key of the specified type with the attributes given.  The key is\n * returned in an uninstantiated state and the caller needs to instantiate the\n * key before returning.\n *\n * The user's key count quota is updated to reflect the creation of the key and\n * the user's key data quota has the default for the key type reserved.  The\n * instantiation function should amend this as necessary.  If insufficient\n * quota is available, -EDQUOT will be returned.\n *\n * The LSM security modules can prevent a key being created, in which case\n * -EACCES will be returned.\n *\n * Returns a pointer to the new key if successful and an error code otherwise.\n *\n * Note that the caller needs to ensure the key type isn't uninstantiated.\n * Internally this can be done by locking key_types_sem.  Externally, this can\n * be done by either never unregistering the key type, or making sure\n * key_alloc() calls don't race with module unloading.\n */\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tif (desc) {\n\t\tkey->index_key.desc_len = desclen;\n\t\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\t\tif (!key->description)\n\t\t\tgoto no_memory_3;\n\t}\n\n\tatomic_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_TRUSTED)\n\t\tkey->flags |= 1 << KEY_FLAG_TRUSTED;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}\nEXPORT_SYMBOL(key_alloc);\n\n/**\n * key_payload_reserve - Adjust data quota reservation for the key's payload\n * @key: The key to make the reservation for.\n * @datalen: The amount of data payload the caller now wants.\n *\n * Adjust the amount of the owning user's key data quota that a key reserves.\n * If the amount is increased, then -EDQUOT may be returned if there isn't\n * enough free quota available.\n *\n * If successful, 0 is returned.\n */\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(key_payload_reserve);\n\n/*\n * Instantiate a key and link it into the target keyring atomically.  Must be\n * called with the target keyring's semaphore writelocked.  The target key's\n * semaphore need not be locked as instantiation is serialised by\n * key_construction_mutex.\n */\nstatic int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring)\n\t\t\t\t__key_link(key, _edit);\n\n\t\t\t/* disable the authorisation key */\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret;\n}\n\n/**\n * key_instantiate_and_link - Instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @data: The data to use to instantiate the keyring.\n * @datalen: The length of @data.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Instantiate a key that's in the uninstantiated state using the provided data\n * and, if successful, link it in to the destination keyring if one is\n * supplied.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(key_instantiate_and_link);\n\n/**\n * key_reject_and_link - Negatively instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @timeout: The timeout on the negative key.\n * @error: The error to return when the key is hit.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Negatively instantiate a key that's in the uninstantiated state and, if\n * successful, set its timeout and stored error and link it in to the\n * destination keyring if one is supplied.  The key and any links to the key\n * will be automatically garbage collected after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the stored error code (typically ENOKEY) until the negative\n * key expires.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring)\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->type_data.reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\nEXPORT_SYMBOL(key_reject_and_link);\n\n/**\n * key_put - Discard a reference to a key.\n * @key: The key to discard a reference from.\n *\n * Discard a reference to a key, and when all the references are gone, we\n * schedule the cleanup task to come and pull it out of the tree in process\n * context at some later time.\n */\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (atomic_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}\nEXPORT_SYMBOL(key_put);\n\n/*\n * Find a key by its serial number.\n */\nstruct key *key_lookup(key_serial_t id)\n{\n\tstruct rb_node *n;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\t/* search the tree for the specified key */\n\tn = key_serial_tree.rb_node;\n\twhile (n) {\n\t\tkey = rb_entry(n, struct key, serial_node);\n\n\t\tif (id < key->serial)\n\t\t\tn = n->rb_left;\n\t\telse if (id > key->serial)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\nnot_found:\n\tkey = ERR_PTR(-ENOKEY);\n\tgoto error;\n\nfound:\n\t/* pretend it doesn't exist if it is awaiting deletion */\n\tif (atomic_read(&key->usage) == 0)\n\t\tgoto not_found;\n\n\t/* this races with key_put(), but that doesn't matter since key_put()\n\t * doesn't actually change the key\n\t */\n\t__key_get(key);\n\nerror:\n\tspin_unlock(&key_serial_lock);\n\treturn key;\n}\n\n/*\n * Find and lock the specified key type against removal.\n *\n * We return with the sem read-locked if successful.  If the type wasn't\n * available -ENOKEY is returned instead.\n */\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL_GPL(key_set_timeout);\n\n/*\n * Unlock a key type locked by key_type_lookup().\n */\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}\n\n/*\n * Attempt to update an existing key.\n *\n * The key is given to us with an incremented refcount that we need to discard\n * if we get an error.\n */\nstatic inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n\n/**\n * key_create_or_update - Update or create and instantiate a key.\n * @keyring_ref: A pointer to the destination keyring with possession flag.\n * @type: The type of key.\n * @description: The searchable description for the key.\n * @payload: The data to use to instantiate or update the key.\n * @plen: The length of @payload.\n * @perm: The permissions mask for a new key.\n * @flags: The quota flags for a new key.\n *\n * Search the destination keyring for a key of the same description and if one\n * is found, update it, otherwise create and instantiate a new one and create a\n * link to it from that keyring.\n *\n * If perm is KEY_PERM_UNDEF then an appropriate key permissions mask will be\n * concocted.\n *\n * Returns a pointer to the new key if successful, -ENODEV if the key type\n * wasn't available, -ENOTDIR if the keyring wasn't a keyring, -EACCES if the\n * caller isn't permitted to modify the keyring or the LSM did not permit\n * creation of the key.\n *\n * On success, the possession flag from the keyring ref will be tacked on to\n * the key ref before it is returned.\n */\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.trusted = flags & KEY_ALLOC_TRUSTED;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\n\t\tgoto error_free_prep;\n\tflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\nEXPORT_SYMBOL(key_create_or_update);\n\n/**\n * key_update - Update a key's contents.\n * @key_ref: The pointer (plus possession flag) to the key.\n * @payload: The data to be used to update the key.\n * @plen: The length of @payload.\n *\n * Attempt to update the contents of a key with the given payload data.  The\n * caller must be granted Write permission on the key.  Negative keys can be\n * instantiated by this method.\n *\n * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key\n * type does not support updating.  The key type may return other errors.\n */\nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* attempt to update it if supported */\n\tret = -EOPNOTSUPP;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_update);\n\n/**\n * key_revoke - Revoke a key.\n * @key: The key to be revoked.\n *\n * Mark a key as being revoked and ask the type to free up its resources.  The\n * revocation timeout is set and the key and all its links will be\n * automatically garbage collected after key_gc_delay amount of time if they\n * are not manually dealt with first.\n */\nvoid key_revoke(struct key *key)\n{\n\tstruct timespec now;\n\ttime_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\tnow = current_kernel_time();\n\ttime = now.tv_sec;\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL(key_revoke);\n\n/**\n * key_invalidate - Invalidate a key.\n * @key: The key to be invalidated.\n *\n * Mark a key as being invalidated and have it cleaned up immediately.  The key\n * is ignored by all searches and other operations from this point.\n */\nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}\nEXPORT_SYMBOL(key_invalidate);\n\n/**\n * generic_key_instantiate - Simple instantiation of a key from preparsed data\n * @key: The key to be instantiated\n * @prep: The preparsed data to load.\n *\n * Instantiate a key from preparsed data.  We assume we can just copy the data\n * in directly and clear the old pointers.\n *\n * This can be pointed to directly by the key type instantiate op pointer.\n */\nint generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\tkey->type_data.p[0] = prep->type_data[0];\n\t\tkey->type_data.p[1] = prep->type_data[1];\n\t\trcu_assign_keypointer(key, prep->payload[0]);\n\t\tkey->payload.data2[1] = prep->payload[1];\n\t\tprep->type_data[0] = NULL;\n\t\tprep->type_data[1] = NULL;\n\t\tprep->payload[0] = NULL;\n\t\tprep->payload[1] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_key_instantiate);\n\n/**\n * register_key_type - Register a type of key.\n * @ktype: The new key type.\n *\n * Register a new key type.\n *\n * Returns 0 on success or -EEXIST if a type of this name already exists.\n */\nint register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t/* disallow key types with the same name */\n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* store the type */\n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(register_key_type);\n\n/**\n * unregister_key_type - Unregister a type of key.\n * @ktype: The key type.\n *\n * Unregister a key type and mark all the extant keys of this type as dead.\n * Those keys of this type are then destroyed to get rid of their payloads and\n * they and their links will be garbage collected as soon as possible.\n */\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}\nEXPORT_SYMBOL(unregister_key_type);\n\n/*\n * Initialise the key management state.\n */\nvoid __init key_init(void)\n{\n\t/* allocate a slab in which we can store keys */\n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t/* add the special key types */\n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\n\t/* record the root user tracking */\n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}\n", "/* Keyring handling\n *\n * Copyright (C) 2004-2005, 2008, 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/*\n * When plumbing the depths of the key tree, this sets a hard limit\n * set on how deep we're willing to go.\n */\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\n/*\n * We keep all named keyrings in a hash to speed looking them up.\n */\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\n/*\n * We mark pointers we pass to the associative array with bit 1 set if\n * they're keyrings and clear otherwise.\n */\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}\n\n/*\n * The keyring key type definition.  Keyrings are simply keys of this type and\n * can be treated as ordinary keys in addition to having their own special\n * operations.\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nEXPORT_SYMBOL(key_type_keyring);\n\n/*\n * Semaphore to serialise link/link calls to prevent two link calls in parallel\n * introducing a cycle.\n */\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\n/*\n * Publish the name of a keyring so that it can be found by name (if it has\n * one).\n */\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->type_data.link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n\n/*\n * Preparse a keyring payload\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}\n\n/*\n * Free a preparse of a user defined key payload\n */\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Initialise a keyring.\n *\n * Returns 0 on success, -EINVAL if given any data.\n */\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}\n\n/*\n * Multiply 64-bits by 32-bits to 96-bits and fold back to 64-bit.  Ideally we'd\n * fold the carry back too, but that requires inline asm.\n */\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}\n\n/*\n * Hash a key type and description.\n */\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}\n\n/*\n * Build the next index key chunk.\n *\n * On 32-bit systems the index key is laid out as:\n *\n *\t0\t4\t5\t9...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * On 64-bit systems:\n *\n *\t0\t8\t9\t17...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * We return it one word-sized chunk at a time.\n */\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}\n\n/*\n * Compare the index keys of a pair of objects and determine the bit position\n * at which they differ - if they differ.\n */\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\n\n/*\n * Free an object after stripping the keyring flag off of the pointer.\n */\nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}\n\n/*\n * Operations for keyring management by the index-tree routines.\n */\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\n/*\n * Clean up a keyring when it is destroyed.  Unpublish its name if it had one\n * and dispose of its data.\n *\n * The garbage collector detects the final key_put(), removes the keyring from\n * the serial number tree and then does RCU synchronisation before coming here,\n * so we shouldn't need to worry about code poking around here with the RCU\n * readlock held by this time.\n */\nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->type_data.link.next != NULL &&\n\t\t    !list_empty(&keyring->type_data.link))\n\t\t\tlist_del(&keyring->type_data.link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}\n\n/*\n * Describe a keyring for /proc.\n */\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tqty;\n\tsize_t\t\t\tcount;\n\tkey_serial_t __user\t*buffer;\n};\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->qty);\n\n\tif (ctx->count >= ctx->qty)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}\n\n/*\n * Read a list of key IDs from the keyring's contents in binary form\n *\n * The keyring's semaphore is read-locked by the caller.  This prevents someone\n * from modifying it under us - which could cause us to read key IDs multiple\n * times.\n */\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tunsigned long nr_keys;\n\tint ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\tnr_keys = keyring->keys.nr_leaves_on_tree;\n\tif (nr_keys == 0)\n\t\treturn 0;\n\n\t/* Calculate how much data we could return */\n\tctx.qty = nr_keys * sizeof(key_serial_t);\n\n\tif (!buffer || !buflen)\n\t\treturn ctx.qty;\n\n\tif (buflen > ctx.qty)\n\t\tctx.qty = buflen;\n\n\t/* Copy the IDs of the subscribed keys into the buffer */\n\tctx.buffer = (key_serial_t __user *)buffer;\n\tctx.count = 0;\n\tret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\n\tif (ret < 0) {\n\t\tkleave(\" = %d [iterate]\", ret);\n\t\treturn ret;\n\t}\n\n\tkleave(\" = %zu [ok]\", ctx.count);\n\treturn ctx.count;\n}\n\n/*\n * Allocate a keyring and link into the destination keyring.\n */\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags, struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}\nEXPORT_SYMBOL(keyring_alloc);\n\n/*\n * By default, we keys found by getting an exact match on their descriptions.\n */\nint key_default_cmp(const struct key *key,\n\t\t    const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n\n/*\n * Iteration function to consider each key found.\n */\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->type_data.reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n\n/*\n * Search inside a keyring for a key.  We can search by walking to it\n * directly based on its index-key or we can iterate over the entire\n * tree looking for it, based on the match function.\n */\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}\n\n/*\n * Search a tree of keyrings that point to other keyrings up to the maximum\n * depth.\n */\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tctx->flags |= KEYRING_SEARCH_DO_STATE_CHECK;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\tif (ctx->flags & KEYRING_SEARCH_NO_STATE_CHECK)\n\t\tctx->flags &= ~KEYRING_SEARCH_DO_STATE_CHECK;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = ACCESS_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = ACCESS_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = ACCESS_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = ACCESS_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = ACCESS_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = ACCESS_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now.tv_sec;\n\t\tkeyring->last_used_at = ctx->now.tv_sec;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\n\n/**\n * keyring_search_aux - Search a keyring tree for a key matching some criteria\n * @keyring_ref: A pointer to the keyring with possession indicator.\n * @ctx: The keyring search context.\n *\n * Search the supplied keyring tree for a key that matches the criteria given.\n * The root keyring and any linked keyrings must grant Search permission to the\n * caller to be searchable and keys can only be found if they too grant Search\n * to the caller. The possession flag on the root keyring pointer controls use\n * of the possessor bits in permissions checking of the entire tree.  In\n * addition, the LSM gets to forbid keyring searches and key matches.\n *\n * The search is performed as a breadth-then-depth search up to the prescribed\n * limit (KEYRING_SEARCH_MAX_DEPTH).\n *\n * Keys are matched to the type provided and are then filtered by the match\n * function, which is given the description to use in any way it sees fit.  The\n * match function may use any attributes of a key that it wishes to to\n * determine the match.  Normally the match function from the key type would be\n * used.\n *\n * RCU can be used to prevent the keyring key lists from disappearing without\n * the need to take lots of locks.\n *\n * Returns a pointer to the found key and increments the key usage count if\n * successful; -EAGAIN if no matching keys were found, or if expired or revoked\n * keys were found; -ENOKEY if only negative keys were found; -ENOTDIR if the\n * specified keyring wasn't a keyring.\n *\n * In the case of a successful return, the possession attribute from\n * @keyring_ref is propagated to the returned key reference.\n */\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = current_kernel_time();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}\n\n/**\n * keyring_search - Search the supplied keyring tree for a matching key\n * @keyring: The root of the keyring tree to be searched.\n * @type: The type of keyring we want to find.\n * @description: The name of the keyring we want to find.\n *\n * As keyring_search_aux() above, but using the current task's credentials and\n * type's default matching function and preferred search method.\n */\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\nEXPORT_SYMBOL(keyring_search);\n\n/*\n * Search the given keyring for a key that might be updated.\n *\n * The caller must guarantee that the keyring is a keyring and that the\n * permission is granted to modify the keyring as no check is made here.  The\n * caller must also hold a lock on the keyring semaphore.\n *\n * Returns a pointer to the found key with usage count incremented if\n * successful and returns NULL if not found.  Revoked and invalidated keys are\n * skipped over.\n *\n * If successful, the possession indicator is propagated from the keyring ref\n * to the returned key reference.\n */\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}\n\n/*\n * Find a keyring with the specified name.\n *\n * All named keyrings in the current user namespace are searched, provided they\n * grant Search permission directly to the caller (unless this check is\n * skipped).  Keyrings whose usage points have reached zero or who have been\n * revoked are skipped.\n *\n * Returns a pointer to the keyring with the keyring's refcount having being\n * incremented on success.  -ENOKEY is returned if a key could not be found.\n */\nstruct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!atomic_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}\n\n/*\n * See if a cycle will will be created by inserting acyclic tree B in acyclic\n * tree A at the topmost level (ie: as a direct child of A).\n *\n * Since we are adding B to A at the top level, checking for cycles should just\n * be a matter of seeing if node A is somewhere in tree B.\n */\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}\n\n/*\n * Preallocate memory so that a key can be linked into to a keyring.\n */\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Check already instantiated keys aren't going to be a problem.\n *\n * The caller must have called __key_link_begin(). Don't need to call this for\n * keys that were created since __key_link_begin() was called.\n */\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}\n\n/*\n * Link a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.  Discards any\n * already extant link to matching key if there is one, so that each keyring\n * holds at most one link to any given key of a particular type+description\n * combination.\n */\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}\n\n/*\n * Finish linking a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.\n */\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}\n\n/**\n * key_link - Link a key to a keyring\n * @keyring: The keyring to make the link in.\n * @key: The key to link to.\n *\n * Make a link in a keyring to a key, such that the keyring holds a reference\n * on that key and the key can potentially be found by searching that keyring.\n *\n * This function will write-lock the keyring's semaphore and will consume some\n * of the user's key data quota to hold the link.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring,\n * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is\n * full, -EDQUOT if there is insufficient key data quota remaining to add\n * another link or -ENOMEM if there's insufficient memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be made (the keyring should have Write permission and the key Link\n * permission).\n */\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, atomic_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags) &&\n\t    !test_bit(KEY_FLAG_TRUSTED, &key->flags))\n\t\treturn -EPERM;\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, atomic_read(&keyring->usage));\n\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, atomic_read(&keyring->usage));\n\treturn ret;\n}\nEXPORT_SYMBOL(key_link);\n\n/**\n * key_unlink - Unlink the first link to a key from a keyring.\n * @keyring: The keyring to remove the link from.\n * @key: The key the link is to.\n *\n * Remove a link from a keyring to a key.\n *\n * This function will write-lock the keyring's semaphore.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring, -ENOENT if\n * the key isn't linked to by the keyring or -ENOMEM if there's insufficient\n * memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be removed (the keyring should have Write permission; no permissions are\n * required on the key).\n */\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_unlink);\n\n/**\n * keyring_clear - Clear a keyring\n * @keyring: The keyring to clear.\n *\n * Clear the contents of the specified keyring.\n *\n * Returns 0 if successful or -ENOTDIR if the keyring isn't a keyring.\n */\nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_clear);\n\n/*\n * Dispose of the links from a revoked keyring.\n *\n * This is called with the key sem write-locked.\n */\nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}\n\n/*\n * Garbage collect pointers from a keyring.\n *\n * Not called with any locks held.  The keyring's key struct will not be\n * deallocated under us as only our caller may deallocate it.\n */\nvoid keyring_gc(struct key *keyring, time_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}\n", "/* Request a key from userspace\n *\n * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys-request-key.txt\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/keyctl.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define key_negative_timeout\t60\t/* default timeout on a negative key's existence */\n\n/*\n * wait_on_bit() sleep function for uninterruptible waiting\n */\nstatic int key_wait_bit(void *flags)\n{\n\tschedule();\n\treturn 0;\n}\n\n/*\n * wait_on_bit() sleep function for interruptible waiting\n */\nstatic int key_wait_bit_intr(void *flags)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n\n/**\n * complete_request_key - Complete the construction of a key.\n * @cons: The key construction record.\n * @error: The success or failute of the construction.\n *\n * Complete the attempt to construct a key.  The key will be negated\n * if an error is indicated.  The authorisation key will be revoked\n * unconditionally.\n */\nvoid complete_request_key(struct key_construction *cons, int error)\n{\n\tkenter(\"{%d,%d},%d\", cons->key->serial, cons->authkey->serial, error);\n\n\tif (error < 0)\n\t\tkey_negate_and_link(cons->key, key_negative_timeout, NULL,\n\t\t\t\t    cons->authkey);\n\telse\n\t\tkey_revoke(cons->authkey);\n\n\tkey_put(cons->key);\n\tkey_put(cons->authkey);\n\tkfree(cons);\n}\nEXPORT_SYMBOL(complete_request_key);\n\n/*\n * Initialise a usermode helper that is going to have a specific session\n * keyring.\n *\n * This is called in context of freshly forked kthread before kernel_execve(),\n * so we can simply install the desired session_keyring at this point.\n */\nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\n{\n\tstruct key *keyring = info->data;\n\n\treturn install_session_keyring_to_cred(cred, keyring);\n}\n\n/*\n * Clean up a usermode helper with session keyring.\n */\nstatic void umh_keys_cleanup(struct subprocess_info *info)\n{\n\tstruct key *keyring = info->data;\n\tkey_put(keyring);\n}\n\n/*\n * Call a usermode helper with a specific session keyring.\n */\nstatic int call_usermodehelper_keys(char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\tstruct subprocess_info *info;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t  umh_keys_init, umh_keys_cleanup,\n\t\t\t\t\t  session_keyring);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tkey_get(session_keyring);\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n/*\n * Request userspace finish the construction of a key\n * - execute \"/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>\"\n */\nstatic int call_sbin_request_key(struct key_construction *cons,\n\t\t\t\t const char *op,\n\t\t\t\t void *aux)\n{\n\tconst struct cred *cred = current_cred();\n\tkey_serial_t prkey, sskey;\n\tstruct key *key = cons->key, *authkey = cons->authkey, *keyring,\n\t\t*session;\n\tchar *argv[9], *envp[3], uid_str[12], gid_str[12];\n\tchar key_str[12], keyring_str[3][12];\n\tchar desc[20];\n\tint ret, i;\n\n\tkenter(\"{%d},{%d},%s\", key->serial, authkey->serial, op);\n\n\tret = install_user_keyrings();\n\tif (ret < 0)\n\t\tgoto error_alloc;\n\n\t/* allocate a new session keyring */\n\tsprintf(desc, \"_req.%u\", key->serial);\n\n\tcred = get_current_cred();\n\tkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL);\n\tput_cred(cred);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error_alloc;\n\t}\n\n\t/* attach the auth key to the session keyring */\n\tret = key_link(keyring, authkey);\n\tif (ret < 0)\n\t\tgoto error_link;\n\n\t/* record the UID and GID */\n\tsprintf(uid_str, \"%d\", from_kuid(&init_user_ns, cred->fsuid));\n\tsprintf(gid_str, \"%d\", from_kgid(&init_user_ns, cred->fsgid));\n\n\t/* we say which key is under construction */\n\tsprintf(key_str, \"%d\", key->serial);\n\n\t/* we specify the process's default keyrings */\n\tsprintf(keyring_str[0], \"%d\",\n\t\tcred->thread_keyring ? cred->thread_keyring->serial : 0);\n\n\tprkey = 0;\n\tif (cred->process_keyring)\n\t\tprkey = cred->process_keyring->serial;\n\tsprintf(keyring_str[1], \"%d\", prkey);\n\n\trcu_read_lock();\n\tsession = rcu_dereference(cred->session_keyring);\n\tif (!session)\n\t\tsession = cred->user->session_keyring;\n\tsskey = session->serial;\n\trcu_read_unlock();\n\n\tsprintf(keyring_str[2], \"%d\", sskey);\n\n\t/* set up a minimal environment */\n\ti = 0;\n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[i] = NULL;\n\n\t/* set up the argument list */\n\ti = 0;\n\targv[i++] = \"/sbin/request-key\";\n\targv[i++] = (char *) op;\n\targv[i++] = key_str;\n\targv[i++] = uid_str;\n\targv[i++] = gid_str;\n\targv[i++] = keyring_str[0];\n\targv[i++] = keyring_str[1];\n\targv[i++] = keyring_str[2];\n\targv[i] = NULL;\n\n\t/* do it */\n\tret = call_usermodehelper_keys(argv[0], argv, envp, keyring,\n\t\t\t\t       UMH_WAIT_PROC);\n\tkdebug(\"usermode -> 0x%x\", ret);\n\tif (ret >= 0) {\n\t\t/* ret is the exit/wait code */\n\t\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\n\t\t    key_validate(key) < 0)\n\t\t\tret = -ENOKEY;\n\t\telse\n\t\t\t/* ignore any errors from userspace if the key was\n\t\t\t * instantiated */\n\t\t\tret = 0;\n\t}\n\nerror_link:\n\tkey_put(keyring);\n\nerror_alloc:\n\tcomplete_request_key(cons, ret);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Call out to userspace for key construction.\n *\n * Program failure is ignored in favour of key status.\n */\nstatic int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Get the appropriate destination keyring for the request.\n *\n * The keyring selected is returned with an extra reference upon it which the\n * caller must release.\n */\nstatic void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data;\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}\n\n/*\n * Allocate a new key in under-construction state and attempt to link it in to\n * the requested keyring.\n *\n * May return a key that's already under construction instead if there was a\n * race between two thread calling request_key().\n */\nstatic int construct_alloc_key(struct keyring_search_context *ctx,\n\t\t\t       struct key *dest_keyring,\n\t\t\t       unsigned long flags,\n\t\t\t       struct key_user *user,\n\t\t\t       struct key **_key)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct key *key;\n\tkey_perm_t perm;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,,,\",\n\t       ctx->index_key.type->name, ctx->index_key.description);\n\n\t*_key = NULL;\n\tmutex_lock(&user->cons_lock);\n\n\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\tperm |= KEY_USR_VIEW;\n\tif (ctx->index_key.type->read)\n\t\tperm |= KEY_POS_READ;\n\tif (ctx->index_key.type == &key_type_keyring ||\n\t    ctx->index_key.type->update)\n\t\tperm |= KEY_POS_WRITE;\n\n\tkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\n\t\t\tctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n\t\t\tperm, flags);\n\tif (IS_ERR(key))\n\t\tgoto alloc_failed;\n\n\tset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_prealloc_failed;\n\t}\n\n\t/* attach the key to the destination keyring under lock, but we do need\n\t * to do another check just in case someone beat us to it whilst we\n\t * waited for locks */\n\tmutex_lock(&key_construction_mutex);\n\n\tkey_ref = search_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto key_already_present;\n\n\tif (dest_keyring)\n\t\t__key_link(key, &edit);\n\n\tmutex_unlock(&key_construction_mutex);\n\tif (dest_keyring)\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\n\t/* the key is now present - we tell the caller that we found it by\n\t * returning -EINPROGRESS  */\nkey_already_present:\n\tkey_put(key);\n\tmutex_unlock(&key_construction_mutex);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (dest_keyring) {\n\t\tret = __key_link_check_live_key(dest_keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_check_failed;\n\t}\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n\treturn -EINPROGRESS;\n\nlink_check_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [linkcheck]\", ret);\n\treturn ret;\n\nlink_prealloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %d [prelink]\", ret);\n\treturn ret;\n\nalloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %ld\", PTR_ERR(key));\n\treturn PTR_ERR(key);\n}\n\n/*\n * Commence key construction.\n */\nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/**\n * request_key_and_link - Request a key and cache it in a keyring.\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n * @dest_keyring: Where to cache the key.\n * @flags: Flags to key_alloc().\n *\n * A key matching the specified criteria is searched for in the process's\n * keyrings and returned with its usage count incremented if found.  Otherwise,\n * if callout_info is not NULL, a key will be allocated and some service\n * (probably in userspace) will be asked to instantiate it.\n *\n * If successfully found or created, the key will be linked to the destination\n * keyring if one is provided.\n *\n * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED\n * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was\n * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT\n * if insufficient key quota was available to create a new key; or -ENOMEM if\n * insufficient memory was available.\n *\n * If the returned key was created, then it may still be under construction,\n * and wait_for_key_construction() should be used to wait for that to complete.\n */\nstruct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n\n/**\n * wait_for_key_construction - Wait for construction of a key to complete\n * @key: The key being waited for.\n * @intr: Whether to wait interruptibly.\n *\n * Wait for a key to finish being constructed.\n *\n * Returns 0 if successful; -ERESTARTSYS if the wait was interrupted; -ENOKEY\n * if the key was negated; or -EKEYREVOKED or -EKEYEXPIRED if the key was\n * revoked or expired.\n */\nint wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? key_wait_bit_intr : key_wait_bit,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->type_data.reject_error;\n\t}\n\treturn key_validate(key);\n}\nEXPORT_SYMBOL(wait_for_key_construction);\n\n/**\n * request_key - Request a key and wait for construction\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota,\n * the callout_info must be a NUL-terminated string and no auxiliary data can\n * be passed.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key(struct key_type *type,\n\t\t\tconst char *description,\n\t\t\tconst char *callout_info)\n{\n\tstruct key *key;\n\tsize_t callout_len = 0;\n\tint ret;\n\n\tif (callout_info)\n\t\tcallout_len = strlen(callout_info);\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   NULL, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key);\n\n/**\n * request_key_with_auxdata - Request a key with auxiliary data for the upcaller\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len,\n\t\t\t\t     void *aux)\n{\n\tstruct key *key;\n\tint ret;\n\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   aux, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_with_auxdata);\n\n/*\n * request_key_async - Request a key (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota and\n * no auxiliary data can be passed.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async(struct key_type *type,\n\t\t\t      const char *description,\n\t\t\t      const void *callout_info,\n\t\t\t      size_t callout_len)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, NULL, NULL,\n\t\t\t\t    KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async);\n\n/*\n * request a key with auxiliary data for the upcaller (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t   const char *description,\n\t\t\t\t\t   const void *callout_info,\n\t\t\t\t\t   size_t callout_len,\n\t\t\t\t\t   void *aux)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async_with_auxdata);\n", "/* Request key authorisation token key definition.\n *\n * Copyright (C) 2005 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys-request-key.txt\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <keys/user-type.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\nstatic void request_key_auth_describe(const struct key *, struct seq_file *);\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\n/*\n * The request-key authorisation key type definition.\n */\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *prep)\n{\n\treturn 0;\n}\n\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Instantiate a request-key authorisation key.\n */\nstatic int request_key_auth_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\tkey->payload.data = (struct request_key_auth *)prep->data;\n\treturn 0;\n}\n\n/*\n * Describe an authorisation token.\n */\nstatic void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}\n\n/*\n * Read the callout_info data (retrieves the callout information).\n * - the key's semaphore is read-locked\n */\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Handle revocation of an authorisation token key.\n *\n * Called with the key sem write-locked.\n */\nstatic void request_key_auth_revoke(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n}\n\n/*\n * Destroy an instantiation authorisation token key.\n */\nstatic void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data;\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}\n\n/*\n * Create an authorisation token for /sbin/request-key or whoever to gain\n * access to the caller's security data.\n */\nstruct key *request_key_auth_new(struct key *target, const void *callout_info,\n\t\t\t\t size_t callout_len, struct key *dest_keyring)\n{\n\tstruct request_key_auth *rka, *irka;\n\tconst struct cred *cred = current->cred;\n\tstruct key *authkey = NULL;\n\tchar desc[20];\n\tint ret;\n\n\tkenter(\"%d,\", target->serial);\n\n\t/* allocate a auth record */\n\trka = kmalloc(sizeof(*rka), GFP_KERNEL);\n\tif (!rka) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\trka->callout_info = kmalloc(callout_len, GFP_KERNEL);\n\tif (!rka->callout_info) {\n\t\tkleave(\" = -ENOMEM\");\n\t\tkfree(rka);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* see if the calling process is already servicing the key request of\n\t * another process */\n\tif (cred->request_key_auth) {\n\t\t/* it is - use that instantiation context here too */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\t/* if the auth key has been revoked, then the key we're\n\t\t * servicing is already instantiated */\n\t\tif (test_bit(KEY_FLAG_REVOKED, &cred->request_key_auth->flags))\n\t\t\tgoto auth_key_revoked;\n\n\t\tirka = cred->request_key_auth->payload.data;\n\t\trka->cred = get_cred(irka->cred);\n\t\trka->pid = irka->pid;\n\n\t\tup_read(&cred->request_key_auth->sem);\n\t}\n\telse {\n\t\t/* it isn't - use this process as the context */\n\t\trka->cred = get_cred(cred);\n\t\trka->pid = current->pid;\n\t}\n\n\trka->target_key = key_get(target);\n\trka->dest_keyring = key_get(dest_keyring);\n\tmemcpy(rka->callout_info, callout_info, callout_len);\n\trka->callout_len = callout_len;\n\n\t/* allocate the auth key */\n\tsprintf(desc, \"%x\", target->serial);\n\n\tauthkey = key_alloc(&key_type_request_key_auth, desc,\n\t\t\t    cred->fsuid, cred->fsgid, cred,\n\t\t\t    KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error_alloc;\n\t}\n\n\t/* construct the auth key */\n\tret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error_inst;\n\n\tkleave(\" = {%d,%d}\", authkey->serial, atomic_read(&authkey->usage));\n\treturn authkey;\n\nauth_key_revoked:\n\tup_read(&cred->request_key_auth->sem);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n\tkleave(\"= -EKEYREVOKED\");\n\treturn ERR_PTR(-EKEYREVOKED);\n\nerror_inst:\n\tkey_revoke(authkey);\n\tkey_put(authkey);\nerror_alloc:\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n\tkleave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/*\n * Search the current process's keyrings for the authorisation key for\n * instantiation of a key.\n */\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}\n", "/*\n * Copyright (C) 2010 IBM Corporation\n *\n * Author:\n * David Safford <safford@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys-trusted-encrypted.txt\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <linux/key-type.h>\n#include <linux/rcupdate.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <linux/capability.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include \"trusted.h\"\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkfree(sdesc);\n\treturn ret;\n}\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * calculate authorization info fields to send to TPM\n */\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH1_COMMAND (Seal) result from TPM\n */\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH2_COMMAND (unseal) result from TPM\n */\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkfree(sdesc);\n\treturn ret;\n}\n\n/*\n * For key specific tpm requests, we will generate and send our\n * own TPM command packets using the drivers send function.\n */\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}\n\n/*\n * Lock a trusted key, by extending a selected PCR.\n *\n * Prevents a trusted key that is sealed to PCRs from being accessed.\n * This uses the tpm driver's extend function.\n */\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}\n\n/*\n * Create an object specific authorisation protocol (OSAP) session\n */\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}\n\n/*\n * Create an object independent authorisation protocol (oiap) session\n */\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}\n\nstruct tpm_digests {\n\tunsigned char encauth[SHA1_DIGEST_SIZE];\n\tunsigned char pubauth[SHA1_DIGEST_SIZE];\n\tunsigned char xorwork[SHA1_DIGEST_SIZE * 2];\n\tunsigned char xorhash[SHA1_DIGEST_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n};\n\n/*\n * Have the TPM seal(encrypt) the trusted key, possibly based on\n * Platform Configuration Registers (PCRs). AUTH1 for sealing key.\n */\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkfree(td);\n\treturn ret;\n}\n\n/*\n * use the AUTH2_COMMAND form of unseal, to authorize both key and blob\n */\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}\n\n/*\n * Have the TPM seal(encrypt) the symmetric key\n */\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkfree(tb);\n\treturn ret;\n}\n\n/*\n * Have the TPM unseal(decrypt) the symmetric key\n */\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkfree(tb);\n\treturn ret;\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_new, Opt_load, Opt_update,\n\tOpt_keyhandle, Opt_keyauth, Opt_blobauth,\n\tOpt_pcrinfo, Opt_pcrlock, Opt_migratable\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_err, NULL}\n};\n\n/* can have zero or more token= options */\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data and fill in the\n * \t\t    payload and options structures\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}\n\n/*\n * trusted_instantiate - create a new trusted key\n *\n * Unseal an existing trusted blob or, for a new key, get a\n * random key, then seal and create a trusted key-type key,\n * adding it to the specified keyring.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkfree(datablob);\n\tkfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkfree(payload);\n\treturn ret;\n}\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tmemset(p->key, 0, p->key_len);\n\tkfree(p);\n}\n\n/*\n * trusted_update - reseal an existing key with new PCR values\n */\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}\n\n/*\n * trusted_read - copy the sealed blob data to userspace in hex.\n * On success, return to userspace the trusted key datablob size.\n */\nstatic long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = rcu_dereference_key(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\tif (!buffer || buflen <= 0)\n\t\treturn 2 * p->blob_len;\n\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\treturn -ENOMEM;\n\n\tbufp = ascii_buf;\n\tfor (i = 0; i < p->blob_len; i++)\n\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\tif ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {\n\t\tkfree(ascii_buf);\n\t\treturn -EFAULT;\n\t}\n\tkfree(ascii_buf);\n\treturn 2 * p->blob_len;\n}\n\n/*\n * trusted_destroy - before freeing the key, clear the decrypted data\n */\nstatic void trusted_destroy(struct key *key)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\n\tif (!p)\n\t\treturn;\n\tmemset(p->key, 0, p->key_len);\n\tkfree(key->payload.data);\n}\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_trusted);\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}\n\nstatic void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}\n\nlate_initcall(init_trusted);\nmodule_exit(cleanup_trusted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* user_defined.c: user defined key type\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n\nstatic int logon_vet_description(const char *desc);\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_user = {\n\t.name\t\t\t= \"user\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_user);\n\n/*\n * This key type is essentially the same as key_type_user, but it does\n * not define a .read op. This is suitable for storing username and\n * password pairs in the keyring that you do not want to be readable\n * from userspace.\n */\nstruct key_type key_type_logon = {\n\t.name\t\t\t= \"logon\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.vet_description\t= logon_vet_description,\n};\nEXPORT_SYMBOL_GPL(key_type_logon);\n\n/*\n * Preparse a user defined key payload\n */\nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(user_preparse);\n\n/*\n * Free a preparse of a user defined key payload\n */\nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkfree(prep->payload[0]);\n}\nEXPORT_SYMBOL_GPL(user_free_preparse);\n\n/*\n * update a user defined key\n * - the key's semaphore is write-locked\n */\nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_update);\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data;\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tkfree_rcu(upayload, rcu);\n\t}\n}\n\nEXPORT_SYMBOL(user_revoke);\n\n/*\n * dispose of the data dangling from the corpse of a user key\n */\nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data;\n\n\tkfree(upayload);\n}\n\nEXPORT_SYMBOL_GPL(user_destroy);\n\n/*\n * describe the user key\n */\nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n\nEXPORT_SYMBOL_GPL(user_describe);\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tstruct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = rcu_dereference_key(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_read);\n\n/* Vet the description for a \"logon\" key */\nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n"], "filenames": ["crypto/asymmetric_keys/asymmetric_type.c", "crypto/asymmetric_keys/pkcs7_key_type.c", "fs/cifs/cifs_spnego.c", "fs/cifs/cifsacl.c", "fs/nfs/idmap.c", "include/keys/user-type.h", "include/linux/key-type.h", "net/ceph/crypto.c", "net/dns_resolver/dns_key.c", "net/rxrpc/ar-key.c", "security/keys/big_key.c", "security/keys/encrypted-keys/encrypted.c", "security/keys/internal.h", "security/keys/key.c", "security/keys/keyring.c", "security/keys/request_key.c", "security/keys/request_key_auth.c", "security/keys/trusted.c", "security/keys/user_defined.c"], "buggy_code_start_loc": [62, 78, 65, 87, 180, 39, 116, 479, 179, 47, 39, 973, 129, 802, 92, 534, 249, 1099, 33], "buggy_code_end_loc": [228, 79, 66, 88, 405, 46, 120, 480, 247, 65, 40, 974, 129, 803, 897, 535, 250, 1100, 150], "fixing_code_start_loc": [62, 77, 64, 86, 179, 38, 115, 478, 179, 46, 38, 972, 130, 802, 91, 534, 249, 1098, 32], "fixing_code_end_loc": [227, 77, 64, 86, 402, 42, 115, 478, 256, 62, 38, 972, 132, 803, 901, 535, 250, 1098, 137], "type": "CWE-476", "message": "The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c.", "other": {"cve": {"id": "CVE-2017-2647", "sourceIdentifier": "secalert@redhat.com", "published": "2017-03-31T04:59:00.157", "lastModified": "2023-02-12T23:29:38.360", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c."}, {"lang": "es", "value": "El subsistema KEYS en el kernel de Linux en versiones anteriores a 3.18 permite a los usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y bloqueo del sistema) a trav\u00e9s de vectores que implican un valor NULL para un cierto campo de coincidencia, relacionado con la funci\u00f3n keyring_search_iterator en keyring.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.17.8", "matchCriteriaId": "D096AE24-5BB5-4ED2-8D2B-DC2AE8012E40"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97258", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2437", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2444", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1428353", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3849-1/", "source": "secalert@redhat.com"}, {"url": "https://usn.ubuntu.com/3849-2/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81"}}