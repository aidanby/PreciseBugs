{"buggy_code": ["language: node_js\nsudo: false\nnode_js:\n    - 10\n    - 12\n    - 14\n    - 15\nnotifications:\n    email:\n        - andris@kreata.ee\n    webhooks:\n        urls:\n            - https://webhooks.gitter.im/e/0ed18fd9b3e529b3c2cc\n        on_success: change # options: [always|never|change] default: always\n        on_failure: always # options: [always|never|change] default: always\n        on_start: false # default: false\n", "# CHANGELOG\n\n## 6.6.0 2021-04-28\n\n-   Added new option `newline` for MailComposer\n-   aws ses connection verification (Ognjen Jevremovic)\n\n## 6.5.0 2021-02-26\n\n-   Pass through textEncoding to subnodes\n-   Added support for AWS SES v3 SDK\n-   Fixed tests\n\n## 6.4.18 2021-02-11\n\n-   Updated README\n\n## 6.4.17 2020-12-11\n\n-   Allow mixing attachments with caendar alternatives\n\n## 6.4.16 2020-11-12\n\n-   Applied updated prettier formating rules\n\n## 6.4.15 2020-11-06\n\n-   Minor changes in header key casing\n\n## 6.4.14 2020-10-14\n\n-   Disabled postinstall script\n\n## 6.4.13 2020-10-02\n\n-   Fix normalizeHeaderKey method for single node messages\n\n## 6.4.12 2020-09-30\n\n-   Better handling of attachment filenames that include quote symbols\n-   Includes all information from the oath2 error response in the error message (Normal Gaussian) [1787f227]\n\n## 6.4.11 2020-07-29\n\n-   Fixed escape sequence handling in address parsing\n\n## 6.4.10 2020-06-17\n\n-   Fixed RFC822 output for MailComposer when using invalid content-type value. Mostly relevant if message attachments have stragne content-type values set.\n\n## 6.4.7 2020-05-28\n\n-   Always set charset=utf-8 for Content-Type headers\n-   Catch error whn using invalid crypto.sign input\n\n## 6.4.6 2020-03-20\n\n-   fix: `requeueAttempts=n` should requeue `n` times (Patrick Malouin) [a27ed2f7]\n\n## 6.4.4 2020-03-01\n\n-   Add `options.forceAuth` for SMTP (Patrick Malouin) [a27ed2f7]\n\n## 6.4.3 2020-02-22\n\n-   Added an option to specify max number of requeues when connection closes unexpectedly (Igor Sechyn) [8a927f5a]\n\n## 6.4.2 2019-12-11\n\n-   Fixed bug where array item was used with a potentially empty array\n\n## 6.4.1 2019-12-07\n\n-   Fix processing server output with unterminated responses\n\n## 6.4.0 2019-12-04\n\n-   Do not use auth if server does not advertise AUTH support [f419b09d]\n-   add dns.CONNREFUSED (Hiroyuki Okada) [5c4c8ca8]\n\n## 6.3.1 2019-10-09\n\n-   Ignore \"end\" events because it might be \"error\" after it (dex4er) [72bade9]\n-   Set username and password on the connection proxy object correctly (UsamaAshraf) [250b1a8]\n-   Support more DNS errors (madarche) [2391aa4]\n\n## 6.3.0 2019-07-14\n\n-   Added new option to pass a set of httpHeaders to be sent when fetching attachments. See [PR #1034](https://github.com/nodemailer/nodemailer/pull/1034)\n\n## 6.2.1 2019-05-24\n\n-   No changes. It is the same as 6.2.0 that was accidentally published as 6.2.1 to npm\n\n## 6.2.0 2019-05-24\n\n-   Added new option for addressparser: `flatten`. If true then ignores group names and returns a single list of all addresses\n\n## 6.1.1 2019-04-20\n\n-   Fixed regression bug with missing smtp `authMethod` property\n\n## 6.1.0 2019-04-06\n\n-   Added new message property `amp` for providing AMP4EMAIL content\n\n## 6.0.0 2019-03-25\n\n-   SMTPConnection: use removeListener instead of removeAllListeners (xr0master) [ddc4af15]\n    Using removeListener should fix memory leak with Node.js streams\n\n## 5.1.1 2019-01-09\n\n-   Added missing option argument for custom auth\n\n## 5.1.0 2019-01-09\n\n-   Official support for custom authentication methods and examples (examples/custom-auth-async.js and examples/custom-auth-cb.js)\n\n## 5.0.1 2019-01-09\n\n-   Fixed regression error to support Node versions lower than 6.11\n-   Added expiremental custom authentication support\n\n## 5.0.0 2018-12-28\n\n-   Start using dns.resolve() instead of dns.lookup() for resolving SMTP hostnames. Might be breaking change on some environments so upgrade with care\n-   Show more logs for renewing OAuth2 tokens, previously it was not possible to see what actually failed\n\n## 4.7.0 2018-11-19\n\n-   Cleaned up List-\\* header generation\n-   Fixed 'full' return option for DSN (klaronix) [23b93a3b]\n-   Support promises `for mailcomposer.build()`\n\n## 4.6.8 2018-08-15\n\n-   Use first IP address from DNS resolution when using a proxy (Limbozz) [d4ca847c]\n-   Return raw email from SES transport (gabegorelick) [3aa08967]\n\n## 4.6.7 2018-06-15\n\n-   Added option `skipEncoding` to JSONTransport\n\n## 4.6.6 2018-06-10\n\n-   Fixes mime encoded-word compatibility issue with invalid clients like Zimbra\n\n## 4.6.5 2018-05-23\n\n-   Fixed broken DKIM stream in Node.js v10\n-   Updated error messages for SMTP responses to not include a newline\n\n## 4.6.4 2018-03-31\n\n-   Readded logo author link to README that was accidentally removed a while ago\n\n## 4.6.3 2018-03-13\n\n-   Removed unneeded dependency\n\n## 4.6.2 2018-03-06\n\n-   When redirecting URL calls then do not include original POST content\n\n## 4.6.1 2018-03-06\n\n-   Fixed Smtp connection freezing, when trying to send after close / quit (twawszczak) [73d3911c]\n\n## 4.6.0 2018-02-22\n\n-   Support socks module v2 in addition to v1 [e228bcb2]\n-   Fixed invalid promise return value when using createTestAccount [5524e627]\n-   Allow using local addresses [8f6fa35f]\n\n## 4.5.0 2018-02-21\n\n-   Added new message transport option `normalizeHeaderKey(key)=>normalizedKey` for custom header formatting\n\n## 4.4.2 2018-01-20\n\n-   Added sponsors section to README\n-   enclose encodeURIComponent in try..catch to handle invalid urls\n\n## 4.4.1 2017-12-08\n\n-   Better handling of unexpectedly dropping connections\n\n## 4.4.0 2017-11-10\n\n-   Changed default behavior for attachment option contentTransferEncoding. If it is unset then base64 encoding is used for the attachment. If it is set to false then previous default applies (base64 for most, 7bit for text)\n\n## 4.3.1 2017-10-25\n\n-   Fixed a confict with Electron.js where timers do not have unref method\n\n## 4.3.0 2017-10-23\n\n-   Added new mail object method `mail.normalize(cb)` that should make creating HTTP API based transports much easier\n\n## 4.2.0 2017-10-13\n\n-   Expose streamed messages size and timers in info response\n\n## v4.1.3 2017-10-06\n\n-   Allow generating preview links without calling createTestAccount first\n\n## v4.1.2 2017-10-03\n\n-   No actual changes. Needed to push updated README to npmjs\n\n## v4.1.1 2017-09-25\n\n-   Fixed JSONTransport attachment handling\n\n## v4.1.0 2017-08-28\n\n-   Added new methods `createTestAccount` and `getTestMessageUrl` to use autogenerated email accounts from https://Ethereal.email\n\n## v4.0.1 2017-04-13\n\n-   Fixed issue with LMTP and STARTTLS\n\n## v4.0.0 2017-04-06\n\n-   License changed from EUPLv1.1 to MIT\n\n## v3.1.8 2017-03-21\n\n-   Fixed invalid List-\\* header generation\n\n## v3.1.7 2017-03-14\n\n-   Emit an error if STARTTLS ends with connection being closed\n\n## v3.1.6 2017-03-14\n\n-   Expose last server response for smtpConnection\n\n## v3.1.5 2017-03-08\n\n-   Fixed SES transport, added missing `response` value\n\n## v3.1.4 2017-02-26\n\n-   Fixed DKIM calculation for empty body\n-   Ensure linebreak after message content. This fixes DKIM signatures for non-multipart messages where input did not end with a newline\n\n## v3.1.3 2017-02-17\n\n-   Fixed missing `transport.verify()` methods for SES transport\n\n## v3.1.2 2017-02-17\n\n-   Added missing error handlers for Sendmail, SES and Stream transports. If a messages contained an invalid URL as attachment then these transports threw an uncatched error\n\n## v3.1.1 2017-02-13\n\n-   Fixed missing `transport.on('idle')` and `transport.isIdle()` methods for SES transports\n\n## v3.1.0 2017-02-13\n\n-   Added built-in transport for AWS SES. [Docs](http://localhost:1313/transports/ses/)\n-   Updated stream transport to allow building JSON strings. [Docs](http://localhost:1313/transports/stream/#json-transport)\n-   Added new method _mail.resolveAll_ that fetches all attachments and such to be able to more easily build API-based transports\n\n## v3.0.2 2017-02-04\n\n-   Fixed a bug with OAuth2 login where error callback was fired twice if getToken was not available.\n\n## v3.0.1 2017-02-03\n\n-   Fixed a bug where Nodemailer threw an exception if `disableFileAccess` option was used\n-   Added FLOSS [exception declaration](FLOSS_EXCEPTIONS.md)\n\n## v3.0.0 2017-01-31\n\n-   Initial version of Nodemailer 3\n\nThis update brings a lot of breaking changes:\n\n-   License changed from MIT to **EUPL-1.1**. This was possible as the new version of Nodemailer is a major rewrite. The features I don't have ownership for, were removed or reimplemented. If there's still some snippets in the code that have vague ownership then notify <mailto:andris@kreata.ee> about the conflicting code and I'll fix it.\n-   Requires **Node.js v6+**\n-   All **templating is gone**. It was too confusing to use and to be really universal a huge list of different renderers would be required. Nodemailer is about email, not about parsing different template syntaxes\n-   **No NTLM authentication**. It was too difficult to re-implement. If you still need it then it would be possible to introduce a pluggable SASL interface where you could load the NTLM module in your own code and pass it to Nodemailer. Currently this is not possible.\n-   **OAuth2 authentication** is built in and has a different [configuration](https://nodemailer.com/smtp/oauth2/). You can use both user (3LO) and service (2LO) accounts to generate access tokens from Nodemailer. Additionally there's a new feature to authenticate differently for every message \u2013 useful if your application sends on behalf of different users instead of a single sender.\n-   **Improved Calendaring**. Provide an ical file to Nodemailer to send out [calendar events](https://nodemailer.com/message/calendar-events/).\n\nAnd also some non-breaking changes:\n\n-   All **dependencies were dropped**. There is exactly 0 dependencies needed to use Nodemailer. This brings the installation time of Nodemailer from NPM down to less than 2 seconds\n-   **Delivery status notifications** added to Nodemailer\n-   Improved and built-in **DKIM** signing of messages. Previously you needed an external module for this and it did quite a lousy job with larger messages\n-   **Stream transport** to return a RFC822 formatted message as a stream. Useful if you want to use Nodemailer as a preprocessor and not for actual delivery.\n-   **Sendmail** transport built-in, no need for external transport plugin\n\nSee [Nodemailer.com](https://nodemailer.com/) for full documentation\n\n## 2.7.0 2016-12-08\n\n-   Bumped mailcomposer that generates encoded-words differently which might break some tests\n\n## 2.6.0 2016-09-05\n\n-   Added new options disableFileAccess and disableUrlAccess\n-   Fixed envelope handling where cc/bcc fields were ignored in the envelope object\n\n## 2.4.2 2016-05-25\n\n-   Removed shrinkwrap file. Seemed to cause more trouble than help\n\n## 2.4.1 2016-05-12\n\n-   Fixed outdated shrinkwrap file\n\n## 2.4.0 2016-05-11\n\n-   Bumped mailcomposer module to allow using `false` as attachment filename (suppresses filename usage)\n-   Added NTLM authentication support\n\n## 2.3.2 2016-04-11\n\n-   Bumped smtp transport modules to get newest smtp-connection that fixes SMTPUTF8 support for internationalized email addresses\n\n## 2.3.1 2016-04-08\n\n-   Bumped mailcomposer to have better support for message/822 attachments\n\n## 2.3.0 2016-03-03\n\n-   Fixed a bug with attachment filename that contains mixed unicode and dashes\n-   Added built-in support for proxies by providing a new SMTP option `proxy` that takes a proxy configuration url as its value\n-   Added option `transport` to dynamically load transport plugins\n-   Do not require globally installed grunt-cli\n\n## 2.2.1 2016-02-20\n\n-   Fixed a bug in SMTP requireTLS option that was broken\n\n## 2.2.0 2016-02-18\n\n-   Removed the need to use `clone` dependency\n-   Added new method `verify` to check SMTP configuration\n-   Direct transport uses STARTTLS by default, fallbacks to plaintext if STARTTLS fails\n-   Added new message option `list` for setting List-\\* headers\n-   Add simple proxy support with `getSocket` method\n-   Added new message option `textEncoding`. If `textEncoding` is not set then detect best encoding automatically\n-   Added new message option `icalEvent` to embed iCalendar events. Example [here](examples/ical-event.js)\n-   Added new attachment option `raw` to use prepared MIME contents instead of generating a new one. This might be useful when you want to handcraft some parts of the message yourself, for example if you want to inject a PGP encrypted message as the contents of a MIME node\n-   Added new message option `raw` to use an existing MIME message instead of generating a new one\n\n## 2.1.0 2016-02-01\n\nRepublishing 2.1.0-rc.1 as stable. To recap, here's the notable changes between v2.0 and v2.1:\n\n-   Implemented templating support. You can either use a simple built-in renderer or some external advanced renderer, eg. [node-email-templates](https://github.com/niftylettuce/node-email-templates). Templating [docs](http://nodemailer.com/2-0-0-beta/templating/).\n-   Updated smtp-pool to emit 'idle' events in order to handle message queue more effectively\n-   Updated custom header handling, works everywhere the same now, no differences between adding custom headers to the message or to an attachment\n\n## 2.1.0-rc.1 2016-01-25\n\nSneaked in some new features even though it is already rc\n\n-   If a SMTP pool is closed while there are still messages in a queue, the message callbacks are invoked with an error\n-   In case of SMTP pool the transporter emits 'idle' when there is a free connection slot available\n-   Added method `isIdle()` that checks if a pool has still some free connection slots available\n\n## 2.1.0-rc.0 2016-01-20\n\n-   Bumped dependency versions\n\n## 2.1.0-beta.3 2016-01-20\n\n-   Added support for node-email-templates templating in addition to the built-in renderer\n\n## 2.1.0-beta.2 2016-01-20\n\n-   Implemented simple templating feature\n\n## 2.1.0-beta.1 2016-01-20\n\n-   Allow using prepared header values that are not folded or encoded by Nodemailer\n\n## 2.1.0-beta.0 2016-01-20\n\n-   Use the same header custom structure for message root, attachments and alternatives\n-   Ensure that Message-Id exists when accessing message\n-   Allow using array values for custom headers (inserts every value in its own row)\n\n## 2.0.0 2016-01-11\n\n-   Released rc.2 as stable\n\n## 2.0.0-rc.2 2016-01-04\n\n-   Locked dependencies\n\n## 2.0.0-beta.2 2016-01-04\n\n-   Updated documentation to reflect changes with SMTP handling\n-   Use beta versions for smtp/pool/direct transports\n-   Updated logging\n\n## 2.0.0-beta.1 2016-01-03\n\n-   Use bunyan compatible logger instead of the emit('log') style\n-   Outsourced some reusable methods to nodemailer-shared\n-   Support setting direct/smtp/pool with the default configuration\n\n## 2.0.0-beta.0 2015-12-31\n\n-   Stream errors are not silently swallowed\n-   Do not use format=flowed\n-   Use nodemailer-fetch to fetch URL streams\n-   jshint replaced by eslint\n\n## v1.11.0 2015-12-28\n\nAllow connection url based SMTP configurations\n\n## v1.10.0 2015-11-13\n\nAdded `defaults` argument for `createTransport` to predefine commonn values (eg. `from` address)\n\n## v1.9.0 2015-11-09\n\nReturns a Promise for `sendMail` if callback is not defined\n\n## v1.8.0 2015-10-08\n\nAdded priority option (high, normal, low) for setting Importance header\n\n## v1.7.0 2015-10-06\n\nReplaced hyperquest with needle. Fixes issues with compressed data and redirects\n\n## v1.6.0 2015-10-05\n\nMaintenance release. Bumped dependencies to get support for unicode filenames for QQ webmail and to support emoji in filenames\n\n## v1.5.0 2015-09-24\n\nUse mailcomposer instead of built in solution to generate message sources. Bumped libmime gives better quoted-printable handling.\n\n## v1.4.0 2015-06-27\n\nAdded new message option `watchHtml` to specify Apple Watch specific HTML part of the message. See [this post](https://litmus.com/blog/how-to-send-hidden-version-email-apple-watch) for details\n\n## v1.3.4 2015-04-25\n\nMaintenance release, bumped buildmail version to get fixed format=flowed handling\n\n## v1.3.3 2015-04-25\n\nMaintenance release, bumped dependencies\n\n## v1.3.2 2015-03-09\n\nMaintenance release, upgraded dependencies. Replaced simplesmtp based tests with smtp-server based ones.\n\n## v1.3.0 2014-09-12\n\nMaintenance release, upgrades buildmail and libmime. Allows using functions as transform plugins and fixes issue with unicode filenames in Gmail.\n\n## v1.2.2 2014-09-05\n\nProper handling of data uris as attachments. Attachment `path` property can also be defined as a data uri, not just regular url or file path.\n\n## v1.2.1 2014-08-21\n\nBumped libmime and mailbuild versions to properly handle filenames with spaces (short ascii only filenames with spaces were left unquoted).\n\n## v1.2.0 2014-08-18\n\nAllow using encoded strings as attachments. Added new property `encoding` which defines the encoding used for a `content` string. If encoding is set, the content value is converted to a Buffer value using the defined encoding before usage. Useful for including binary attachemnts in JSON formatted email objects.\n\n## v1.1.2 2014-08-18\n\nReturn deprecatin error for v0.x style configuration\n\n## v1.1.1 2014-07-30\n\nBumped nodemailer-direct-transport dependency. Updated version includes a bugfix for Stream nodes handling. Important only if use direct-transport with Streams (not file paths or urls) as attachment content.\n\n## v1.1.0 2014-07-29\n\nAdded new method `resolveContent()` to get the html/text/attachment content as a String or Buffer.\n\n## v1.0.4 2014-07-23\n\nBugfix release. HTML node was instered twice if the message consisted of a HTML content (but no text content) + at least one attachment with CID + at least one attachment without CID. In this case the HTML node was inserted both to the root level multipart/mixed section and to the multipart/related sub section\n\n## v1.0.3 2014-07-16\n\nFixed a bug where Nodemailer crashed if the message content type was multipart/related\n\n## v1.0.2 2014-07-16\n\nUpgraded nodemailer-smtp-transport to 0.1.11\\. The docs state that for SSL you should use 'secure' option but the underlying smtp-connection module used 'secureConnection' for this purpose. Fixed smpt-connection to match the docs.\n\n## v1.0.1 2014-07-15\n\nImplemented missing #close method that is passed to the underlying transport object. Required by the smtp pool.\n\n## v1.0.0 2014-07-15\n\nTotal rewrite. See migration guide here: <http://www.andrisreinman.com/nodemailer-v1-0/#migrationguide>\n\n## v0.7.1 2014-07-09\n\n-   Upgraded aws-sdk to 2.0.5\n\n## v0.7.0 2014-06-17\n\n-   Bumped version to v0.7.0\n-   Fix AWS-SES usage [5b6bc144]\n-   Replace current SES with new SES using AWS-SDK (Elanorr) [c79d797a]\n-   Updated README.md about Node Email Templates (niftylettuce) [e52bef81]\n\n## v0.6.5 2014-05-15\n\n-   Bumped version to v0.6.5\n-   Use tildes instead of carets for dependency listing [5296ce41]\n-   Allow clients to set a custom identityString (venables) [5373287d]\n-   bugfix (adding \"-i\" to sendmail command line for each new mail) by copying this.args (vrodic) [05a8a9a3]\n-   update copyright (gdi2290) [3a6cba3a]\n\n## v0.6.4 2014-05-13\n\n-   Bumped version to v0.6.4\n-   added npmignore, bumped dependencies [21bddcd9]\n-   Add AOL to well-known services (msouce) [da7dd3b7]\n\n## v0.6.3 2014-04-16\n\n-   Bumped version to v0.6.3\n-   Upgraded simplesmtp dependency [dd367f59]\n\n## v0.6.2 2014-04-09\n\n-   Bumped version to v0.6.2\n-   Added error option to Stub transport [c423acad]\n-   Use SVG npm badge (t3chnoboy) [677117b7]\n-   add SendCloud to well known services (haio) [43c358e0]\n-   High-res build-passing and NPM module badges (sahat) [9fdc37cd]\n\n## v0.6.1 2014-01-26\n\n-   Bumped version to v0.6.1\n-   Do not throw on multiple errors from sendmail command [c6e2cd12]\n-   Do not require callback for pickup, fixes #238 [93eb3214]\n-   Added AWSSecurityToken information to README, fixes #235 [58e921d1]\n-   Added Nodemailer logo [06b7d1a8]\n\n## v0.6.0 2013-12-30\n\n-   Bumped version to v0.6.0\n-   Allow defining custom transport methods [ec5b48ce]\n-   Return messageId with responseObject for all built in transport methods [74445cec]\n-   Bumped dependency versions for mailcomposer and readable-stream [9a034c34]\n-   Changed pickup argument name to 'directory' [01c3ea53]\n-   Added support for IIS pickup directory with PICKUP transport (philipproplesch) [36940b59..360a2878]\n-   Applied common styles [9e93a409]\n-   Updated readme [c78075e7]\n\n## v0.5.15 2013-12-13\n\n-   bumped version to v0.5.15\n-   Updated README, added global options info for setting uo transports [554bb0e5]\n-   Resolve public hostname, if resolveHostname property for a transport object is set to `true` [9023a6e1..4c66b819]\n\n## v0.5.14 2013-12-05\n\n-   bumped version to v0.5.14\n-   Expose status for direct messages [f0312df6]\n-   Allow to skip the X-Mailer header if xMailer value is set to 'false' [f2c20a68]\n\n## v0.5.13 2013-12-03\n\n-   bumped version to v0.5.13\n-   Use the name property from the transport object to use for the domain part of message-id values (1598eee9)\n\n## v0.5.12 2013-12-02\n\n-   bumped version to v0.5.12\n-   Expose transport method and transport module version if available [a495106e]\n-   Added 'he' module instead of using custom html entity decoding [c197d102]\n-   Added xMailer property for transport configuration object to override X-Mailer value [e8733a61]\n-   Updated README, added description for 'mail' method [e1f5f3a6]\n\n## v0.5.11 2013-11-28\n\n-   bumped version to v0.5.11\n-   Updated mailcomposer version. Replaces ent with he [6a45b790e]\n\n## v0.5.10 2013-11-26\n\n-   bumped version to v0.5.10\n-   added shorthand function mail() for direct transport type [88129bd7]\n-   minor tweaks and typo fixes [f797409e..ceac0ca4]\n\n## v0.5.9 2013-11-25\n\n-   bumped version to v0.5.9\n-   Update for 'direct' handling [77b84e2f]\n-   do not require callback to be provided for 'direct' type [ec51c79f]\n\n## v0.5.8 2013-11-22\n\n-   bumped version to v0.5.8\n-   Added support for 'direct' transport [826f226d..0dbbcbbc]\n\n## v0.5.7 2013-11-18\n\n-   bumped version to v0.5.7\n-   Replace \\r\\n by \\n in Sendmail transport (rolftimmermans) [fed2089e..616ec90c] A lot of sendmail implementations choke on \\r\\n newlines and require \\n This commit addresses this by transforming all \\r\\n sequences passed to the sendmail command with \\n\n\n## v0.5.6 2013-11-15\n\n-   bumped version to v0.5.6\n-   Upgraded mailcomposer dependency to 0.2.4 [e5ff9c40]\n-   Removed noCR option [e810d1b8]\n-   Update wellknown.js, added FastMail (k-j-kleist) [cf930f6d]\n\n## v0.5.5 2013-10-30\n\n-   bumped version to v0.5.5\n-   Updated mailcomposer dependnecy version to 0.2.3\n-   Remove legacy code - node v0.4 is not supported anymore anyway\n-   Use hostname (autodetected or from the options.name property) for Message-Id instead of \"Nodemailer\" (helps a bit when messages are identified as spam)\n-   Added maxMessages info to README\n\n## v0.5.4 2013-10-29\n\n-   bumped version to v0.5.4\n-   added \"use strict\" statements\n-   Added DSN info to README\n-   add support for QQ enterprise email (coderhaoxin)\n-   Add a Bitdeli Badge to README\n-   DSN options Passthrought into simplesmtp. (irvinzz)\n\n## v0.5.3 2013-10-03\n\n-   bumped version v0.5.3\n-   Using a stub transport to prevent sendmail from being called during a test. (jsdevel)\n-   closes #78: sendmail transport does not work correctly on Unix machines. (jsdevel)\n-   Updated PaaS Support list to include Modulus. (fiveisprime)\n-   Translate self closing break tags to newline (kosmasgiannis)\n-   fix typos (aeosynth)\n\n## v0.5.2 2013-07-25\n\n-   bumped version v0.5.2\n-   Merge pull request #177 from MrSwitch/master Fixing Amazon SES, fatal error caused by bad connection\n", "'use strict';\n\nconst MailComposer = require('../lib/mail-composer');\n\nconst mailOptions = {\n    from: 'mailer@kreata.ee',\n    to: 'daemon@kreata.ee',\n    envelope: {\n        from: 'Daemon <deamon@kreata.ee>',\n        to: 'mailer@kreata.ee, Mailer <mailer2@kreata.ee>'\n    },\n    text: 'Test\\n 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u00f6\\r\\nsage',\n    newline: '\\r\\n'\n};\n\nasync function main() {\n    let raw = await new MailComposer(mailOptions).compile().build();\n    process.stdout.write(raw);\n}\n\nmain();\n", "/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst os = require('os');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst fetch = require('../fetch');\nconst LastNewline = require('./last-newline');\n\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n    constructor(contentType, options) {\n        this.nodeCounter = 0;\n\n        options = options || {};\n\n        /**\n         * shared part of the unique multipart boundary\n         */\n        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n\n        this.disableFileAccess = !!options.disableFileAccess;\n        this.disableUrlAccess = !!options.disableUrlAccess;\n\n        this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n        /**\n         * If date headers is missing and current node is the root, this value is used instead\n         */\n        this.date = new Date();\n\n        /**\n         * Root node for current mime tree\n         */\n        this.rootNode = options.rootNode || this;\n\n        /**\n         * If true include Bcc in generated headers (if available)\n         */\n        this.keepBcc = !!options.keepBcc;\n\n        /**\n         * If filename is specified but contentType is not (probably an attachment)\n         * detect the content type from filename extension\n         */\n        if (options.filename) {\n            /**\n             * Filename for this node. Useful with attachments\n             */\n            this.filename = options.filename;\n            if (!contentType) {\n                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n            }\n        }\n\n        /**\n         * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n         */\n        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n        /**\n         * Immediate parent for this node (or undefined if not set)\n         */\n        this.parentNode = options.parentNode;\n\n        /**\n         * Hostname for default message-id values\n         */\n        this.hostname = options.hostname;\n\n        /**\n         * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n         */\n        this.newline = options.newline;\n\n        /**\n         * An array for possible child nodes\n         */\n        this.childNodes = [];\n\n        /**\n         * Used for generating unique boundaries (prepended to the shared base)\n         */\n        this._nodeId = ++this.rootNode.nodeCounter;\n\n        /**\n         * A list of header values for this node in the form of [{key:'', value:''}]\n         */\n        this._headers = [];\n\n        /**\n         * True if the content only uses ASCII printable characters\n         * @type {Boolean}\n         */\n        this._isPlainText = false;\n\n        /**\n         * True if the content is plain text but has longer lines than allowed\n         * @type {Boolean}\n         */\n        this._hasLongLines = false;\n\n        /**\n         * If set, use instead this value for envelopes instead of generating one\n         * @type {Boolean}\n         */\n        this._envelope = false;\n\n        /**\n         * If set then use this value as the stream content instead of building it\n         * @type {String|Buffer|Stream}\n         */\n        this._raw = false;\n\n        /**\n         * Additional transform streams that the message will be piped before\n         * exposing by createReadStream\n         * @type {Array}\n         */\n        this._transforms = [];\n\n        /**\n         * Additional process functions that the message will be piped through before\n         * exposing by createReadStream. These functions are run after transforms\n         * @type {Array}\n         */\n        this._processFuncs = [];\n\n        /**\n         * If content type is set (or derived from the filename) add it to headers\n         */\n        if (contentType) {\n            this.setHeader('Content-Type', contentType);\n        }\n    }\n\n    /////// PUBLIC METHODS\n\n    /**\n     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n     *\n     * @param {String} [contentType] Optional content type\n     * @param {Object} [options] Optional options object\n     * @return {Object} Created node object\n     */\n    createChild(contentType, options) {\n        if (!options && typeof contentType === 'object') {\n            options = contentType;\n            contentType = undefined;\n        }\n        let node = new MimeNode(contentType, options);\n        this.appendChild(node);\n        return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n    appendChild(childNode) {\n        if (childNode.rootNode !== this.rootNode) {\n            childNode.rootNode = this.rootNode;\n            childNode._nodeId = ++this.rootNode.nodeCounter;\n        }\n\n        childNode.parentNode = this;\n\n        this.childNodes.push(childNode);\n        return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n    replace(node) {\n        if (node === this) {\n            return this;\n        }\n\n        this.parentNode.childNodes.forEach((childNode, i) => {\n            if (childNode === this) {\n                node.rootNode = this.rootNode;\n                node.parentNode = this.parentNode;\n                node._nodeId = this._nodeId;\n\n                this.rootNode = this;\n                this.parentNode = undefined;\n\n                node.parentNode.childNodes[i] = node;\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n    remove() {\n        if (!this.parentNode) {\n            return this;\n        }\n\n        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n            if (this.parentNode.childNodes[i] === this) {\n                this.parentNode.childNodes.splice(i, 1);\n                this.parentNode = undefined;\n                this.rootNode = this;\n                return this;\n            }\n        }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    setHeader(key, value) {\n        let added = false,\n            headerValue;\n\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && 'value' in key) {\n                this.setHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.setHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.setHeader(i, key[i]);\n                });\n            }\n            return this;\n        }\n\n        key = this._normalizeHeaderKey(key);\n\n        headerValue = {\n            key,\n            value\n        };\n\n        // Check if the value exists and overwrite\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                if (!added) {\n                    // replace the first match\n                    this._headers[i] = headerValue;\n                    added = true;\n                } else {\n                    // remove following matches\n                    this._headers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n\n        // match not found, append the value\n        if (!added) {\n            this._headers.push(headerValue);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    addHeader(key, value) {\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && key.value) {\n                this.addHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.addHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.addHeader(i, key[i]);\n                });\n            }\n            return this;\n        } else if (Array.isArray(value)) {\n            value.forEach(val => {\n                this.addHeader(key, val);\n            });\n            return this;\n        }\n\n        this._headers.push({\n            key: this._normalizeHeaderKey(key),\n            value\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n    getHeader(key) {\n        key = this._normalizeHeaderKey(key);\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                return this._headers[i].value;\n            }\n        }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n    setContent(content) {\n        this.content = content;\n        if (typeof this.content.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this.content.removeListener('error', this._contentErrorHandler);\n                this.content = err;\n            };\n            this.content.once('error', this._contentErrorHandler);\n        } else if (typeof this.content === 'string') {\n            this._isPlainText = mimeFuncs.isPlainText(this.content);\n            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n                // If there are lines longer than 76 symbols/bytes do not use 7bit\n                this._hasLongLines = true;\n            }\n        }\n        return this;\n    }\n\n    build(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let stream = this.createReadStream();\n        let buf = [];\n        let buflen = 0;\n        let returned = false;\n\n        stream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = stream.read()) !== null) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n        });\n\n        stream.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            return callback(err);\n        });\n\n        stream.once('end', chunk => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            if (chunk && chunk.length) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n            return callback(null, Buffer.concat(buf, buflen));\n        });\n\n        return promise;\n    }\n\n    getTransferEncoding() {\n        let transferEncoding = false;\n        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n        if (this.content) {\n            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n                if (/^text\\//i.test(contentType)) {\n                    // If there are no special symbols, no need to modify the text\n                    if (this._isPlainText && !this._hasLongLines) {\n                        transferEncoding = '7bit';\n                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                        // detect preferred encoding for string value\n                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                    } else {\n                        // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                        transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n                    }\n                } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                    transferEncoding = transferEncoding || 'base64';\n                }\n            }\n        }\n        return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n    buildHeaders() {\n        let transferEncoding = this.getTransferEncoding();\n        let headers = [];\n\n        if (transferEncoding) {\n            this.setHeader('Content-Transfer-Encoding', transferEncoding);\n        }\n\n        if (this.filename && !this.getHeader('Content-Disposition')) {\n            this.setHeader('Content-Disposition', 'attachment');\n        }\n\n        // Ensure mandatory header fields\n        if (this.rootNode === this) {\n            if (!this.getHeader('Date')) {\n                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n            }\n\n            // ensure that Message-Id is present\n            this.messageId();\n\n            if (!this.getHeader('MIME-Version')) {\n                this.setHeader('MIME-Version', '1.0');\n            }\n        }\n\n        this._headers.forEach(header => {\n            let key = header.key;\n            let value = header.value;\n            let structured;\n            let param;\n            let options = {};\n            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n                Object.keys(value).forEach(key => {\n                    if (key !== 'value') {\n                        options[key] = value[key];\n                    }\n                });\n                value = (value.value || '').toString();\n                if (!value.trim()) {\n                    return;\n                }\n            }\n\n            if (options.prepared) {\n                // header value is\n                if (options.foldLines) {\n                    headers.push(mimeFuncs.foldLines(key + ': ' + value));\n                } else {\n                    headers.push(key + ': ' + value);\n                }\n                return;\n            }\n\n            switch (header.key) {\n                case 'Content-Disposition':\n                    structured = mimeFuncs.parseHeaderValue(value);\n                    if (this.filename) {\n                        structured.params.filename = this.filename;\n                    }\n                    value = mimeFuncs.buildHeaderValue(structured);\n                    break;\n\n                case 'Content-Type':\n                    structured = mimeFuncs.parseHeaderValue(value);\n\n                    this._handleContentType(structured);\n\n                    if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n                        structured.params.charset = 'utf-8';\n                    }\n\n                    value = mimeFuncs.buildHeaderValue(structured);\n\n                    if (this.filename) {\n                        // add support for non-compliant clients like QQ webmail\n                        // we can't build the value with buildHeaderValue as the value is non standard and\n                        // would be converted to parameter continuation encoding that we do not want\n                        param = this._encodeWords(this.filename);\n\n                        if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                            // include value in quotes if needed\n                            param = '\"' + param + '\"';\n                        }\n                        value += '; name=' + param;\n                    }\n                    break;\n\n                case 'Bcc':\n                    if (!this.keepBcc) {\n                        // skip BCC values\n                        return;\n                    }\n                    break;\n            }\n\n            value = this._encodeHeaderValue(key, value);\n\n            // skip empty lines\n            if (!(value || '').toString().trim()) {\n                return;\n            }\n\n            if (typeof this.normalizeHeaderKey === 'function') {\n                let normalized = this.normalizeHeaderKey(key, value);\n                if (normalized && typeof normalized === 'string' && normalized.length) {\n                    key = normalized;\n                }\n            }\n\n            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n        });\n\n        return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n    createReadStream(options) {\n        options = options || {};\n\n        let stream = new PassThrough(options);\n        let outputStream = stream;\n        let transform;\n\n        this.stream(stream, options, err => {\n            if (err) {\n                outputStream.emit('error', err);\n                return;\n            }\n            stream.end();\n        });\n\n        for (let i = 0, len = this._transforms.length; i < len; i++) {\n            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n            outputStream.once('error', err => {\n                transform.emit('error', err);\n            });\n            outputStream = outputStream.pipe(transform);\n        }\n\n        // ensure terminating newline after possible user transforms\n        transform = new LastNewline();\n        outputStream.once('error', err => {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n\n        // dkim and stuff\n        for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n            transform = this._processFuncs[i];\n            outputStream = transform(outputStream);\n        }\n\n        if (this.newline) {\n            const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n\n            const stream = outputStream.pipe(newlineTransform);\n            outputStream.on('error', err => stream.emit('error', err));\n            return stream;\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n    transform(transform) {\n        this._transforms.push(transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n    processFunc(processFunc) {\n        this._processFuncs.push(processFunc);\n    }\n\n    stream(outputStream, options, done) {\n        let transferEncoding = this.getTransferEncoding();\n        let contentStream;\n        let localStream;\n\n        // protect actual callback against multiple triggering\n        let returned = false;\n        let callback = err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            done(err);\n        };\n\n        // for multipart nodes, push child nodes\n        // for content nodes end the stream\n        let finalize = () => {\n            let childId = 0;\n            let processChildNode = () => {\n                if (childId >= this.childNodes.length) {\n                    outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n                    return callback();\n                }\n                let child = this.childNodes[childId++];\n                outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n                child.stream(outputStream, options, err => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    setImmediate(processChildNode);\n                });\n            };\n\n            if (this.multipart) {\n                setImmediate(processChildNode);\n            } else {\n                return callback();\n            }\n        };\n\n        // pushes node content\n        let sendContent = () => {\n            if (this.content) {\n                if (Object.prototype.toString.call(this.content) === '[object Error]') {\n                    // content is already errored\n                    return callback(this.content);\n                }\n\n                if (typeof this.content.pipe === 'function') {\n                    this.content.removeListener('error', this._contentErrorHandler);\n                    this._contentErrorHandler = err => callback(err);\n                    this.content.once('error', this._contentErrorHandler);\n                }\n\n                let createStream = () => {\n                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n\n                        contentStream.pipe(outputStream, {\n                            end: false\n                        });\n                        contentStream.once('end', finalize);\n                        contentStream.once('error', err => callback(err));\n\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(contentStream);\n                    } else {\n                        // anything that is not QP or Base54 passes as-is\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(outputStream, {\n                            end: false\n                        });\n                        localStream.once('end', finalize);\n                    }\n\n                    localStream.once('error', err => callback(err));\n                };\n\n                if (this.content._resolve) {\n                    let chunks = [];\n                    let chunklen = 0;\n                    let returned = false;\n                    let sourceStream = this._getStream(this.content);\n                    sourceStream.on('error', err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        callback(err);\n                    });\n                    sourceStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = sourceStream.read()) !== null) {\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n                    sourceStream.on('end', () => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        this.content._resolve = false;\n                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n                        setImmediate(createStream);\n                    });\n                } else {\n                    setImmediate(createStream);\n                }\n                return;\n            } else {\n                return setImmediate(finalize);\n            }\n        };\n\n        if (this._raw) {\n            setImmediate(() => {\n                if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n                    // content is already errored\n                    return callback(this._raw);\n                }\n\n                // remove default error handler (if set)\n                if (typeof this._raw.pipe === 'function') {\n                    this._raw.removeListener('error', this._contentErrorHandler);\n                }\n\n                let raw = this._getStream(this._raw);\n                raw.pipe(outputStream, {\n                    end: false\n                });\n                raw.on('error', err => outputStream.emit('error', err));\n                raw.on('end', finalize);\n            });\n        } else {\n            outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n            setImmediate(sendContent);\n        }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    setEnvelope(envelope) {\n        let list;\n\n        this._envelope = {\n            from: false,\n            to: []\n        };\n\n        if (envelope.from) {\n            list = [];\n            this._convertAddresses(this._parseAddresses(envelope.from), list);\n            list = list.filter(address => address && address.address);\n            if (list.length && list[0]) {\n                this._envelope.from = list[0].address;\n            }\n        }\n        ['to', 'cc', 'bcc'].forEach(key => {\n            if (envelope[key]) {\n                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n            }\n        });\n\n        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n\n        let standardFields = ['to', 'cc', 'bcc', 'from'];\n        Object.keys(envelope).forEach(key => {\n            if (!standardFields.includes(key)) {\n                this._envelope[key] = envelope[key];\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n    getAddresses() {\n        let addresses = {};\n\n        this._headers.forEach(header => {\n            let key = header.key.toLowerCase();\n            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n                if (!Array.isArray(addresses[key])) {\n                    addresses[key] = [];\n                }\n\n                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n            }\n        });\n\n        return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    getEnvelope() {\n        if (this._envelope) {\n            return this._envelope;\n        }\n\n        let envelope = {\n            from: false,\n            to: []\n        };\n        this._headers.forEach(header => {\n            let list = [];\n            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {\n                this._convertAddresses(this._parseAddresses(header.value), list);\n                if (list.length && list[0]) {\n                    envelope.from = list[0].address;\n                }\n            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n                this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n            }\n        });\n\n        envelope.to = envelope.to.map(to => to.address);\n\n        return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n    messageId() {\n        let messageId = this.getHeader('Message-ID');\n        // You really should define your own Message-Id field!\n        if (!messageId) {\n            messageId = this._generateMessageId();\n            this.setHeader('Message-ID', messageId);\n        }\n        return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n    setRaw(raw) {\n        this._raw = raw;\n\n        if (this._raw && typeof this._raw.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this._raw.removeListener('error', this._contentErrorHandler);\n                this._raw = err;\n            };\n            this._raw.once('error', this._contentErrorHandler);\n        }\n\n        return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n    _getStream(content) {\n        let contentStream;\n\n        if (content._resolvedValue) {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content._resolvedValue));\n            return contentStream;\n        } else if (typeof content.pipe === 'function') {\n            // assume as stream\n            return content;\n        } else if (content && typeof content.path === 'string' && !content.href) {\n            if (this.disableFileAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n                return contentStream;\n            }\n            // read file\n            return fs.createReadStream(content.path);\n        } else if (content && typeof content.href === 'string') {\n            if (this.disableUrlAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n                return contentStream;\n            }\n            // fetch URL\n            return fetch(content.href, { headers: content.httpHeaders });\n        } else {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content || ''));\n            return contentStream;\n        }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n    _parseAddresses(addresses) {\n        return [].concat.apply(\n            [],\n            [].concat(addresses).map(address => {\n                // eslint-disable-line prefer-spread\n                if (address && address.address) {\n                    address.address = this._normalizeAddress(address.address);\n                    address.name = address.name || '';\n                    return [address];\n                }\n                return addressparser(address);\n            })\n        );\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n    _normalizeHeaderKey(key) {\n        key = (key || '')\n            .toString()\n            // no newlines in keys\n            .replace(/\\r?\\n|\\r/g, ' ')\n            .trim()\n            .toLowerCase()\n            // use uppercase words, except MIME\n            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n            // special case\n            .replace(/^Content-Features$/i, 'Content-features');\n\n        return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n    _handleContentType(structured) {\n        this.contentType = structured.value.trim().toLowerCase();\n\n        this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n        if (this.multipart) {\n            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n        } else {\n            this.boundary = false;\n        }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n    _generateBoundary() {\n        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n    _encodeHeaderValue(key, value) {\n        key = this._normalizeHeaderKey(key);\n\n        switch (key) {\n            // Structured headers\n            case 'From':\n            case 'Sender':\n            case 'To':\n            case 'Cc':\n            case 'Bcc':\n            case 'Reply-To':\n                return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n            case 'Message-ID':\n            case 'In-Reply-To':\n            case 'Content-Id':\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n                if (value.charAt(0) !== '<') {\n                    value = '<' + value;\n                }\n\n                if (value.charAt(value.length - 1) !== '>') {\n                    value = value + '>';\n                }\n                return value;\n\n            // space separated list of values enclosed in <>\n            case 'References':\n                value = [].concat\n                    .apply(\n                        [],\n                        [].concat(value || '').map(elm => {\n                            // eslint-disable-line prefer-spread\n                            elm = (elm || '')\n                                .toString()\n                                .replace(/\\r?\\n|\\r/g, ' ')\n                                .trim();\n                            return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n                        })\n                    )\n                    .map(elm => {\n                        if (elm.charAt(0) !== '<') {\n                            elm = '<' + elm;\n                        }\n                        if (elm.charAt(elm.length - 1) !== '>') {\n                            elm = elm + '>';\n                        }\n                        return elm;\n                    });\n\n                return value.join(' ').trim();\n\n            case 'Date':\n                if (Object.prototype.toString.call(value) === '[object Date]') {\n                    return value.toUTCString().replace(/GMT/, '+0000');\n                }\n\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                return this._encodeWords(value);\n\n            case 'Content-Type':\n            case 'Content-Disposition':\n                // if it includes a filename then it is already encoded\n                return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            default:\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                // encodeWords only encodes if needed, otherwise the original string is returned\n                return this._encodeWords(value);\n        }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n    _convertAddresses(addresses, uniqueList) {\n        let values = [];\n\n        uniqueList = uniqueList || [];\n\n        [].concat(addresses || []).forEach(address => {\n            if (address.address) {\n                address.address = this._normalizeAddress(address.address);\n\n                if (!address.name) {\n                    values.push(address.address);\n                } else if (address.name) {\n                    values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');\n                }\n\n                if (address.address) {\n                    if (!uniqueList.filter(a => a.address === address.address).length) {\n                        uniqueList.push(address);\n                    }\n                }\n            } else if (address.group) {\n                values.push(\n                    this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';'\n                );\n            }\n        });\n\n        return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n    _normalizeAddress(address) {\n        address = (address || '').toString().trim();\n\n        let lastAt = address.lastIndexOf('@');\n        if (lastAt < 0) {\n            // Bare username\n            return address;\n        }\n        let user = address.substr(0, lastAt);\n        let domain = address.substr(lastAt + 1);\n\n        // Usernames are not touched and are kept as is even if these include unicode\n        // Domains are punycoded by default\n        // 'j\u00f5geva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n\n        return user + '@' + punycode.toASCII(domain.toLowerCase());\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeAddressName(name) {\n        if (!/^[\\w ']*$/.test(name)) {\n            if (/^[\\x20-\\x7e]*$/.test(name)) {\n                return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n            } else {\n                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeWords(value) {\n        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n        // by default only words that include non-ascii should be converted into encoded words\n        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n    _getTextEncoding(value) {\n        value = (value || '').toString();\n\n        let encoding = this.textEncoding;\n        let latinLen;\n        let nonLatinLen;\n\n        if (!encoding) {\n            // count latin alphabet symbols and 8-bit range symbols + control symbols\n            // if there are more latin characters, then use quoted-printable\n            // encoding, otherwise use base64\n            nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n            latinLen = (value.match(/[a-z]/gi) || []).length;\n            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n            encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n        }\n        return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n    _generateMessageId() {\n        return (\n            '<' +\n            [2, 2, 2, 6].reduce(\n                // crux to generate UUID-like random strings\n                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),\n                crypto.randomBytes(4).toString('hex')\n            ) +\n            '@' +\n            // try to use the domain of the FROM address or fallback to server hostname\n            (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() +\n            '>'\n        );\n    }\n}\n\nmodule.exports = MimeNode;\n", "{\n    \"name\": \"nodemailer\",\n    \"version\": \"6.6.0\",\n    \"description\": \"Easy as cake e-mail sending from your Node.js applications\",\n    \"main\": \"lib/nodemailer.js\",\n    \"scripts\": {\n        \"test\": \"grunt\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/nodemailer/nodemailer.git\"\n    },\n    \"keywords\": [\n        \"Nodemailer\"\n    ],\n    \"author\": \"Andris Reinman\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/nodemailer/nodemailer/issues\"\n    },\n    \"homepage\": \"https://nodemailer.com/\",\n    \"devDependencies\": {\n        \"bunyan\": \"1.8.15\",\n        \"chai\": \"4.3.4\",\n        \"eslint-config-nodemailer\": \"1.2.0\",\n        \"eslint-config-prettier\": \"8.3.0\",\n        \"grunt\": \"1.4.0\",\n        \"grunt-cli\": \"1.4.2\",\n        \"grunt-eslint\": \"23.0.0\",\n        \"grunt-mocha-test\": \"0.13.3\",\n        \"libbase64\": \"1.2.1\",\n        \"libmime\": \"5.0.0\",\n        \"libqp\": \"1.1.0\",\n        \"mocha\": \"8.3.2\",\n        \"nodemailer-ntlm-auth\": \"1.0.1\",\n        \"proxy\": \"1.0.2\",\n        \"proxy-test-server\": \"1.0.0\",\n        \"sinon\": \"10.0.0\",\n        \"smtp-server\": \"3.8.0\"\n    },\n    \"engines\": {\n        \"node\": \">=6.0.0\"\n    }\n}\n"], "fixing_code": ["language: node_js\nsudo: false\nnode_js:\n    - 10\n    - 12\n    - 14\n    - 16\nnotifications:\n    email:\n        - andris@kreata.ee\n    webhooks:\n        urls:\n            - https://webhooks.gitter.im/e/0ed18fd9b3e529b3c2cc\n        on_success: change # options: [always|never|change] default: always\n        on_failure: always # options: [always|never|change] default: always\n        on_start: false # default: false\n", "# CHANGELOG\n\n## 6.6.1 2021-05-23\n\n-   Fixed address formatting issue where newlines in an email address, if provided via address object, were not properly removed. Reported by tmazeika (#1289)\n\n## 6.6.0 2021-04-28\n\n-   Added new option `newline` for MailComposer\n-   aws ses connection verification (Ognjen Jevremovic)\n\n## 6.5.0 2021-02-26\n\n-   Pass through textEncoding to subnodes\n-   Added support for AWS SES v3 SDK\n-   Fixed tests\n\n## 6.4.18 2021-02-11\n\n-   Updated README\n\n## 6.4.17 2020-12-11\n\n-   Allow mixing attachments with caendar alternatives\n\n## 6.4.16 2020-11-12\n\n-   Applied updated prettier formating rules\n\n## 6.4.15 2020-11-06\n\n-   Minor changes in header key casing\n\n## 6.4.14 2020-10-14\n\n-   Disabled postinstall script\n\n## 6.4.13 2020-10-02\n\n-   Fix normalizeHeaderKey method for single node messages\n\n## 6.4.12 2020-09-30\n\n-   Better handling of attachment filenames that include quote symbols\n-   Includes all information from the oath2 error response in the error message (Normal Gaussian) [1787f227]\n\n## 6.4.11 2020-07-29\n\n-   Fixed escape sequence handling in address parsing\n\n## 6.4.10 2020-06-17\n\n-   Fixed RFC822 output for MailComposer when using invalid content-type value. Mostly relevant if message attachments have stragne content-type values set.\n\n## 6.4.7 2020-05-28\n\n-   Always set charset=utf-8 for Content-Type headers\n-   Catch error whn using invalid crypto.sign input\n\n## 6.4.6 2020-03-20\n\n-   fix: `requeueAttempts=n` should requeue `n` times (Patrick Malouin) [a27ed2f7]\n\n## 6.4.4 2020-03-01\n\n-   Add `options.forceAuth` for SMTP (Patrick Malouin) [a27ed2f7]\n\n## 6.4.3 2020-02-22\n\n-   Added an option to specify max number of requeues when connection closes unexpectedly (Igor Sechyn) [8a927f5a]\n\n## 6.4.2 2019-12-11\n\n-   Fixed bug where array item was used with a potentially empty array\n\n## 6.4.1 2019-12-07\n\n-   Fix processing server output with unterminated responses\n\n## 6.4.0 2019-12-04\n\n-   Do not use auth if server does not advertise AUTH support [f419b09d]\n-   add dns.CONNREFUSED (Hiroyuki Okada) [5c4c8ca8]\n\n## 6.3.1 2019-10-09\n\n-   Ignore \"end\" events because it might be \"error\" after it (dex4er) [72bade9]\n-   Set username and password on the connection proxy object correctly (UsamaAshraf) [250b1a8]\n-   Support more DNS errors (madarche) [2391aa4]\n\n## 6.3.0 2019-07-14\n\n-   Added new option to pass a set of httpHeaders to be sent when fetching attachments. See [PR #1034](https://github.com/nodemailer/nodemailer/pull/1034)\n\n## 6.2.1 2019-05-24\n\n-   No changes. It is the same as 6.2.0 that was accidentally published as 6.2.1 to npm\n\n## 6.2.0 2019-05-24\n\n-   Added new option for addressparser: `flatten`. If true then ignores group names and returns a single list of all addresses\n\n## 6.1.1 2019-04-20\n\n-   Fixed regression bug with missing smtp `authMethod` property\n\n## 6.1.0 2019-04-06\n\n-   Added new message property `amp` for providing AMP4EMAIL content\n\n## 6.0.0 2019-03-25\n\n-   SMTPConnection: use removeListener instead of removeAllListeners (xr0master) [ddc4af15]\n    Using removeListener should fix memory leak with Node.js streams\n\n## 5.1.1 2019-01-09\n\n-   Added missing option argument for custom auth\n\n## 5.1.0 2019-01-09\n\n-   Official support for custom authentication methods and examples (examples/custom-auth-async.js and examples/custom-auth-cb.js)\n\n## 5.0.1 2019-01-09\n\n-   Fixed regression error to support Node versions lower than 6.11\n-   Added expiremental custom authentication support\n\n## 5.0.0 2018-12-28\n\n-   Start using dns.resolve() instead of dns.lookup() for resolving SMTP hostnames. Might be breaking change on some environments so upgrade with care\n-   Show more logs for renewing OAuth2 tokens, previously it was not possible to see what actually failed\n\n## 4.7.0 2018-11-19\n\n-   Cleaned up List-\\* header generation\n-   Fixed 'full' return option for DSN (klaronix) [23b93a3b]\n-   Support promises `for mailcomposer.build()`\n\n## 4.6.8 2018-08-15\n\n-   Use first IP address from DNS resolution when using a proxy (Limbozz) [d4ca847c]\n-   Return raw email from SES transport (gabegorelick) [3aa08967]\n\n## 4.6.7 2018-06-15\n\n-   Added option `skipEncoding` to JSONTransport\n\n## 4.6.6 2018-06-10\n\n-   Fixes mime encoded-word compatibility issue with invalid clients like Zimbra\n\n## 4.6.5 2018-05-23\n\n-   Fixed broken DKIM stream in Node.js v10\n-   Updated error messages for SMTP responses to not include a newline\n\n## 4.6.4 2018-03-31\n\n-   Readded logo author link to README that was accidentally removed a while ago\n\n## 4.6.3 2018-03-13\n\n-   Removed unneeded dependency\n\n## 4.6.2 2018-03-06\n\n-   When redirecting URL calls then do not include original POST content\n\n## 4.6.1 2018-03-06\n\n-   Fixed Smtp connection freezing, when trying to send after close / quit (twawszczak) [73d3911c]\n\n## 4.6.0 2018-02-22\n\n-   Support socks module v2 in addition to v1 [e228bcb2]\n-   Fixed invalid promise return value when using createTestAccount [5524e627]\n-   Allow using local addresses [8f6fa35f]\n\n## 4.5.0 2018-02-21\n\n-   Added new message transport option `normalizeHeaderKey(key)=>normalizedKey` for custom header formatting\n\n## 4.4.2 2018-01-20\n\n-   Added sponsors section to README\n-   enclose encodeURIComponent in try..catch to handle invalid urls\n\n## 4.4.1 2017-12-08\n\n-   Better handling of unexpectedly dropping connections\n\n## 4.4.0 2017-11-10\n\n-   Changed default behavior for attachment option contentTransferEncoding. If it is unset then base64 encoding is used for the attachment. If it is set to false then previous default applies (base64 for most, 7bit for text)\n\n## 4.3.1 2017-10-25\n\n-   Fixed a confict with Electron.js where timers do not have unref method\n\n## 4.3.0 2017-10-23\n\n-   Added new mail object method `mail.normalize(cb)` that should make creating HTTP API based transports much easier\n\n## 4.2.0 2017-10-13\n\n-   Expose streamed messages size and timers in info response\n\n## v4.1.3 2017-10-06\n\n-   Allow generating preview links without calling createTestAccount first\n\n## v4.1.2 2017-10-03\n\n-   No actual changes. Needed to push updated README to npmjs\n\n## v4.1.1 2017-09-25\n\n-   Fixed JSONTransport attachment handling\n\n## v4.1.0 2017-08-28\n\n-   Added new methods `createTestAccount` and `getTestMessageUrl` to use autogenerated email accounts from https://Ethereal.email\n\n## v4.0.1 2017-04-13\n\n-   Fixed issue with LMTP and STARTTLS\n\n## v4.0.0 2017-04-06\n\n-   License changed from EUPLv1.1 to MIT\n\n## v3.1.8 2017-03-21\n\n-   Fixed invalid List-\\* header generation\n\n## v3.1.7 2017-03-14\n\n-   Emit an error if STARTTLS ends with connection being closed\n\n## v3.1.6 2017-03-14\n\n-   Expose last server response for smtpConnection\n\n## v3.1.5 2017-03-08\n\n-   Fixed SES transport, added missing `response` value\n\n## v3.1.4 2017-02-26\n\n-   Fixed DKIM calculation for empty body\n-   Ensure linebreak after message content. This fixes DKIM signatures for non-multipart messages where input did not end with a newline\n\n## v3.1.3 2017-02-17\n\n-   Fixed missing `transport.verify()` methods for SES transport\n\n## v3.1.2 2017-02-17\n\n-   Added missing error handlers for Sendmail, SES and Stream transports. If a messages contained an invalid URL as attachment then these transports threw an uncatched error\n\n## v3.1.1 2017-02-13\n\n-   Fixed missing `transport.on('idle')` and `transport.isIdle()` methods for SES transports\n\n## v3.1.0 2017-02-13\n\n-   Added built-in transport for AWS SES. [Docs](http://localhost:1313/transports/ses/)\n-   Updated stream transport to allow building JSON strings. [Docs](http://localhost:1313/transports/stream/#json-transport)\n-   Added new method _mail.resolveAll_ that fetches all attachments and such to be able to more easily build API-based transports\n\n## v3.0.2 2017-02-04\n\n-   Fixed a bug with OAuth2 login where error callback was fired twice if getToken was not available.\n\n## v3.0.1 2017-02-03\n\n-   Fixed a bug where Nodemailer threw an exception if `disableFileAccess` option was used\n-   Added FLOSS [exception declaration](FLOSS_EXCEPTIONS.md)\n\n## v3.0.0 2017-01-31\n\n-   Initial version of Nodemailer 3\n\nThis update brings a lot of breaking changes:\n\n-   License changed from MIT to **EUPL-1.1**. This was possible as the new version of Nodemailer is a major rewrite. The features I don't have ownership for, were removed or reimplemented. If there's still some snippets in the code that have vague ownership then notify <mailto:andris@kreata.ee> about the conflicting code and I'll fix it.\n-   Requires **Node.js v6+**\n-   All **templating is gone**. It was too confusing to use and to be really universal a huge list of different renderers would be required. Nodemailer is about email, not about parsing different template syntaxes\n-   **No NTLM authentication**. It was too difficult to re-implement. If you still need it then it would be possible to introduce a pluggable SASL interface where you could load the NTLM module in your own code and pass it to Nodemailer. Currently this is not possible.\n-   **OAuth2 authentication** is built in and has a different [configuration](https://nodemailer.com/smtp/oauth2/). You can use both user (3LO) and service (2LO) accounts to generate access tokens from Nodemailer. Additionally there's a new feature to authenticate differently for every message \u2013 useful if your application sends on behalf of different users instead of a single sender.\n-   **Improved Calendaring**. Provide an ical file to Nodemailer to send out [calendar events](https://nodemailer.com/message/calendar-events/).\n\nAnd also some non-breaking changes:\n\n-   All **dependencies were dropped**. There is exactly 0 dependencies needed to use Nodemailer. This brings the installation time of Nodemailer from NPM down to less than 2 seconds\n-   **Delivery status notifications** added to Nodemailer\n-   Improved and built-in **DKIM** signing of messages. Previously you needed an external module for this and it did quite a lousy job with larger messages\n-   **Stream transport** to return a RFC822 formatted message as a stream. Useful if you want to use Nodemailer as a preprocessor and not for actual delivery.\n-   **Sendmail** transport built-in, no need for external transport plugin\n\nSee [Nodemailer.com](https://nodemailer.com/) for full documentation\n\n## 2.7.0 2016-12-08\n\n-   Bumped mailcomposer that generates encoded-words differently which might break some tests\n\n## 2.6.0 2016-09-05\n\n-   Added new options disableFileAccess and disableUrlAccess\n-   Fixed envelope handling where cc/bcc fields were ignored in the envelope object\n\n## 2.4.2 2016-05-25\n\n-   Removed shrinkwrap file. Seemed to cause more trouble than help\n\n## 2.4.1 2016-05-12\n\n-   Fixed outdated shrinkwrap file\n\n## 2.4.0 2016-05-11\n\n-   Bumped mailcomposer module to allow using `false` as attachment filename (suppresses filename usage)\n-   Added NTLM authentication support\n\n## 2.3.2 2016-04-11\n\n-   Bumped smtp transport modules to get newest smtp-connection that fixes SMTPUTF8 support for internationalized email addresses\n\n## 2.3.1 2016-04-08\n\n-   Bumped mailcomposer to have better support for message/822 attachments\n\n## 2.3.0 2016-03-03\n\n-   Fixed a bug with attachment filename that contains mixed unicode and dashes\n-   Added built-in support for proxies by providing a new SMTP option `proxy` that takes a proxy configuration url as its value\n-   Added option `transport` to dynamically load transport plugins\n-   Do not require globally installed grunt-cli\n\n## 2.2.1 2016-02-20\n\n-   Fixed a bug in SMTP requireTLS option that was broken\n\n## 2.2.0 2016-02-18\n\n-   Removed the need to use `clone` dependency\n-   Added new method `verify` to check SMTP configuration\n-   Direct transport uses STARTTLS by default, fallbacks to plaintext if STARTTLS fails\n-   Added new message option `list` for setting List-\\* headers\n-   Add simple proxy support with `getSocket` method\n-   Added new message option `textEncoding`. If `textEncoding` is not set then detect best encoding automatically\n-   Added new message option `icalEvent` to embed iCalendar events. Example [here](examples/ical-event.js)\n-   Added new attachment option `raw` to use prepared MIME contents instead of generating a new one. This might be useful when you want to handcraft some parts of the message yourself, for example if you want to inject a PGP encrypted message as the contents of a MIME node\n-   Added new message option `raw` to use an existing MIME message instead of generating a new one\n\n## 2.1.0 2016-02-01\n\nRepublishing 2.1.0-rc.1 as stable. To recap, here's the notable changes between v2.0 and v2.1:\n\n-   Implemented templating support. You can either use a simple built-in renderer or some external advanced renderer, eg. [node-email-templates](https://github.com/niftylettuce/node-email-templates). Templating [docs](http://nodemailer.com/2-0-0-beta/templating/).\n-   Updated smtp-pool to emit 'idle' events in order to handle message queue more effectively\n-   Updated custom header handling, works everywhere the same now, no differences between adding custom headers to the message or to an attachment\n\n## 2.1.0-rc.1 2016-01-25\n\nSneaked in some new features even though it is already rc\n\n-   If a SMTP pool is closed while there are still messages in a queue, the message callbacks are invoked with an error\n-   In case of SMTP pool the transporter emits 'idle' when there is a free connection slot available\n-   Added method `isIdle()` that checks if a pool has still some free connection slots available\n\n## 2.1.0-rc.0 2016-01-20\n\n-   Bumped dependency versions\n\n## 2.1.0-beta.3 2016-01-20\n\n-   Added support for node-email-templates templating in addition to the built-in renderer\n\n## 2.1.0-beta.2 2016-01-20\n\n-   Implemented simple templating feature\n\n## 2.1.0-beta.1 2016-01-20\n\n-   Allow using prepared header values that are not folded or encoded by Nodemailer\n\n## 2.1.0-beta.0 2016-01-20\n\n-   Use the same header custom structure for message root, attachments and alternatives\n-   Ensure that Message-Id exists when accessing message\n-   Allow using array values for custom headers (inserts every value in its own row)\n\n## 2.0.0 2016-01-11\n\n-   Released rc.2 as stable\n\n## 2.0.0-rc.2 2016-01-04\n\n-   Locked dependencies\n\n## 2.0.0-beta.2 2016-01-04\n\n-   Updated documentation to reflect changes with SMTP handling\n-   Use beta versions for smtp/pool/direct transports\n-   Updated logging\n\n## 2.0.0-beta.1 2016-01-03\n\n-   Use bunyan compatible logger instead of the emit('log') style\n-   Outsourced some reusable methods to nodemailer-shared\n-   Support setting direct/smtp/pool with the default configuration\n\n## 2.0.0-beta.0 2015-12-31\n\n-   Stream errors are not silently swallowed\n-   Do not use format=flowed\n-   Use nodemailer-fetch to fetch URL streams\n-   jshint replaced by eslint\n\n## v1.11.0 2015-12-28\n\nAllow connection url based SMTP configurations\n\n## v1.10.0 2015-11-13\n\nAdded `defaults` argument for `createTransport` to predefine commonn values (eg. `from` address)\n\n## v1.9.0 2015-11-09\n\nReturns a Promise for `sendMail` if callback is not defined\n\n## v1.8.0 2015-10-08\n\nAdded priority option (high, normal, low) for setting Importance header\n\n## v1.7.0 2015-10-06\n\nReplaced hyperquest with needle. Fixes issues with compressed data and redirects\n\n## v1.6.0 2015-10-05\n\nMaintenance release. Bumped dependencies to get support for unicode filenames for QQ webmail and to support emoji in filenames\n\n## v1.5.0 2015-09-24\n\nUse mailcomposer instead of built in solution to generate message sources. Bumped libmime gives better quoted-printable handling.\n\n## v1.4.0 2015-06-27\n\nAdded new message option `watchHtml` to specify Apple Watch specific HTML part of the message. See [this post](https://litmus.com/blog/how-to-send-hidden-version-email-apple-watch) for details\n\n## v1.3.4 2015-04-25\n\nMaintenance release, bumped buildmail version to get fixed format=flowed handling\n\n## v1.3.3 2015-04-25\n\nMaintenance release, bumped dependencies\n\n## v1.3.2 2015-03-09\n\nMaintenance release, upgraded dependencies. Replaced simplesmtp based tests with smtp-server based ones.\n\n## v1.3.0 2014-09-12\n\nMaintenance release, upgrades buildmail and libmime. Allows using functions as transform plugins and fixes issue with unicode filenames in Gmail.\n\n## v1.2.2 2014-09-05\n\nProper handling of data uris as attachments. Attachment `path` property can also be defined as a data uri, not just regular url or file path.\n\n## v1.2.1 2014-08-21\n\nBumped libmime and mailbuild versions to properly handle filenames with spaces (short ascii only filenames with spaces were left unquoted).\n\n## v1.2.0 2014-08-18\n\nAllow using encoded strings as attachments. Added new property `encoding` which defines the encoding used for a `content` string. If encoding is set, the content value is converted to a Buffer value using the defined encoding before usage. Useful for including binary attachemnts in JSON formatted email objects.\n\n## v1.1.2 2014-08-18\n\nReturn deprecatin error for v0.x style configuration\n\n## v1.1.1 2014-07-30\n\nBumped nodemailer-direct-transport dependency. Updated version includes a bugfix for Stream nodes handling. Important only if use direct-transport with Streams (not file paths or urls) as attachment content.\n\n## v1.1.0 2014-07-29\n\nAdded new method `resolveContent()` to get the html/text/attachment content as a String or Buffer.\n\n## v1.0.4 2014-07-23\n\nBugfix release. HTML node was instered twice if the message consisted of a HTML content (but no text content) + at least one attachment with CID + at least one attachment without CID. In this case the HTML node was inserted both to the root level multipart/mixed section and to the multipart/related sub section\n\n## v1.0.3 2014-07-16\n\nFixed a bug where Nodemailer crashed if the message content type was multipart/related\n\n## v1.0.2 2014-07-16\n\nUpgraded nodemailer-smtp-transport to 0.1.11\\. The docs state that for SSL you should use 'secure' option but the underlying smtp-connection module used 'secureConnection' for this purpose. Fixed smpt-connection to match the docs.\n\n## v1.0.1 2014-07-15\n\nImplemented missing #close method that is passed to the underlying transport object. Required by the smtp pool.\n\n## v1.0.0 2014-07-15\n\nTotal rewrite. See migration guide here: <http://www.andrisreinman.com/nodemailer-v1-0/#migrationguide>\n\n## v0.7.1 2014-07-09\n\n-   Upgraded aws-sdk to 2.0.5\n\n## v0.7.0 2014-06-17\n\n-   Bumped version to v0.7.0\n-   Fix AWS-SES usage [5b6bc144]\n-   Replace current SES with new SES using AWS-SDK (Elanorr) [c79d797a]\n-   Updated README.md about Node Email Templates (niftylettuce) [e52bef81]\n\n## v0.6.5 2014-05-15\n\n-   Bumped version to v0.6.5\n-   Use tildes instead of carets for dependency listing [5296ce41]\n-   Allow clients to set a custom identityString (venables) [5373287d]\n-   bugfix (adding \"-i\" to sendmail command line for each new mail) by copying this.args (vrodic) [05a8a9a3]\n-   update copyright (gdi2290) [3a6cba3a]\n\n## v0.6.4 2014-05-13\n\n-   Bumped version to v0.6.4\n-   added npmignore, bumped dependencies [21bddcd9]\n-   Add AOL to well-known services (msouce) [da7dd3b7]\n\n## v0.6.3 2014-04-16\n\n-   Bumped version to v0.6.3\n-   Upgraded simplesmtp dependency [dd367f59]\n\n## v0.6.2 2014-04-09\n\n-   Bumped version to v0.6.2\n-   Added error option to Stub transport [c423acad]\n-   Use SVG npm badge (t3chnoboy) [677117b7]\n-   add SendCloud to well known services (haio) [43c358e0]\n-   High-res build-passing and NPM module badges (sahat) [9fdc37cd]\n\n## v0.6.1 2014-01-26\n\n-   Bumped version to v0.6.1\n-   Do not throw on multiple errors from sendmail command [c6e2cd12]\n-   Do not require callback for pickup, fixes #238 [93eb3214]\n-   Added AWSSecurityToken information to README, fixes #235 [58e921d1]\n-   Added Nodemailer logo [06b7d1a8]\n\n## v0.6.0 2013-12-30\n\n-   Bumped version to v0.6.0\n-   Allow defining custom transport methods [ec5b48ce]\n-   Return messageId with responseObject for all built in transport methods [74445cec]\n-   Bumped dependency versions for mailcomposer and readable-stream [9a034c34]\n-   Changed pickup argument name to 'directory' [01c3ea53]\n-   Added support for IIS pickup directory with PICKUP transport (philipproplesch) [36940b59..360a2878]\n-   Applied common styles [9e93a409]\n-   Updated readme [c78075e7]\n\n## v0.5.15 2013-12-13\n\n-   bumped version to v0.5.15\n-   Updated README, added global options info for setting uo transports [554bb0e5]\n-   Resolve public hostname, if resolveHostname property for a transport object is set to `true` [9023a6e1..4c66b819]\n\n## v0.5.14 2013-12-05\n\n-   bumped version to v0.5.14\n-   Expose status for direct messages [f0312df6]\n-   Allow to skip the X-Mailer header if xMailer value is set to 'false' [f2c20a68]\n\n## v0.5.13 2013-12-03\n\n-   bumped version to v0.5.13\n-   Use the name property from the transport object to use for the domain part of message-id values (1598eee9)\n\n## v0.5.12 2013-12-02\n\n-   bumped version to v0.5.12\n-   Expose transport method and transport module version if available [a495106e]\n-   Added 'he' module instead of using custom html entity decoding [c197d102]\n-   Added xMailer property for transport configuration object to override X-Mailer value [e8733a61]\n-   Updated README, added description for 'mail' method [e1f5f3a6]\n\n## v0.5.11 2013-11-28\n\n-   bumped version to v0.5.11\n-   Updated mailcomposer version. Replaces ent with he [6a45b790e]\n\n## v0.5.10 2013-11-26\n\n-   bumped version to v0.5.10\n-   added shorthand function mail() for direct transport type [88129bd7]\n-   minor tweaks and typo fixes [f797409e..ceac0ca4]\n\n## v0.5.9 2013-11-25\n\n-   bumped version to v0.5.9\n-   Update for 'direct' handling [77b84e2f]\n-   do not require callback to be provided for 'direct' type [ec51c79f]\n\n## v0.5.8 2013-11-22\n\n-   bumped version to v0.5.8\n-   Added support for 'direct' transport [826f226d..0dbbcbbc]\n\n## v0.5.7 2013-11-18\n\n-   bumped version to v0.5.7\n-   Replace \\r\\n by \\n in Sendmail transport (rolftimmermans) [fed2089e..616ec90c] A lot of sendmail implementations choke on \\r\\n newlines and require \\n This commit addresses this by transforming all \\r\\n sequences passed to the sendmail command with \\n\n\n## v0.5.6 2013-11-15\n\n-   bumped version to v0.5.6\n-   Upgraded mailcomposer dependency to 0.2.4 [e5ff9c40]\n-   Removed noCR option [e810d1b8]\n-   Update wellknown.js, added FastMail (k-j-kleist) [cf930f6d]\n\n## v0.5.5 2013-10-30\n\n-   bumped version to v0.5.5\n-   Updated mailcomposer dependnecy version to 0.2.3\n-   Remove legacy code - node v0.4 is not supported anymore anyway\n-   Use hostname (autodetected or from the options.name property) for Message-Id instead of \"Nodemailer\" (helps a bit when messages are identified as spam)\n-   Added maxMessages info to README\n\n## v0.5.4 2013-10-29\n\n-   bumped version to v0.5.4\n-   added \"use strict\" statements\n-   Added DSN info to README\n-   add support for QQ enterprise email (coderhaoxin)\n-   Add a Bitdeli Badge to README\n-   DSN options Passthrought into simplesmtp. (irvinzz)\n\n## v0.5.3 2013-10-03\n\n-   bumped version v0.5.3\n-   Using a stub transport to prevent sendmail from being called during a test. (jsdevel)\n-   closes #78: sendmail transport does not work correctly on Unix machines. (jsdevel)\n-   Updated PaaS Support list to include Modulus. (fiveisprime)\n-   Translate self closing break tags to newline (kosmasgiannis)\n-   fix typos (aeosynth)\n\n## v0.5.2 2013-07-25\n\n-   bumped version v0.5.2\n-   Merge pull request #177 from MrSwitch/master Fixing Amazon SES, fatal error caused by bad connection\n", "'use strict';\n\nconst MailComposer = require('../lib/mail-composer');\n\nconst mailOptions = {\n    from: 'mailer@kreata.ee',\n    to: 'daemon@kreata.ee',\n    envelope: {\n        from: 'Daemon <deamon@kreata.ee>',\n        to: 'mailer@kreata.ee, Mailer <mailer2@kreata.ee>'\n    },\n    text: `Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it, 'and what is the use of a book,' thought Alice 'without pictures or conversations?'\n\nSo she was considering in her own mind (as well as she could, for the hot day made her feel very sleepy and stupid), whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her.`,\n    newline: '\\r\\n'\n};\n\nasync function main() {\n    let raw = await new MailComposer(mailOptions).compile().build();\n    process.stdout.write(raw);\n}\n\nmain();\n", "/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst os = require('os');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst fetch = require('../fetch');\nconst LastNewline = require('./last-newline');\n\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n    constructor(contentType, options) {\n        this.nodeCounter = 0;\n\n        options = options || {};\n\n        /**\n         * shared part of the unique multipart boundary\n         */\n        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n\n        this.disableFileAccess = !!options.disableFileAccess;\n        this.disableUrlAccess = !!options.disableUrlAccess;\n\n        this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n        /**\n         * If date headers is missing and current node is the root, this value is used instead\n         */\n        this.date = new Date();\n\n        /**\n         * Root node for current mime tree\n         */\n        this.rootNode = options.rootNode || this;\n\n        /**\n         * If true include Bcc in generated headers (if available)\n         */\n        this.keepBcc = !!options.keepBcc;\n\n        /**\n         * If filename is specified but contentType is not (probably an attachment)\n         * detect the content type from filename extension\n         */\n        if (options.filename) {\n            /**\n             * Filename for this node. Useful with attachments\n             */\n            this.filename = options.filename;\n            if (!contentType) {\n                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n            }\n        }\n\n        /**\n         * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n         */\n        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n        /**\n         * Immediate parent for this node (or undefined if not set)\n         */\n        this.parentNode = options.parentNode;\n\n        /**\n         * Hostname for default message-id values\n         */\n        this.hostname = options.hostname;\n\n        /**\n         * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n         */\n        this.newline = options.newline;\n\n        /**\n         * An array for possible child nodes\n         */\n        this.childNodes = [];\n\n        /**\n         * Used for generating unique boundaries (prepended to the shared base)\n         */\n        this._nodeId = ++this.rootNode.nodeCounter;\n\n        /**\n         * A list of header values for this node in the form of [{key:'', value:''}]\n         */\n        this._headers = [];\n\n        /**\n         * True if the content only uses ASCII printable characters\n         * @type {Boolean}\n         */\n        this._isPlainText = false;\n\n        /**\n         * True if the content is plain text but has longer lines than allowed\n         * @type {Boolean}\n         */\n        this._hasLongLines = false;\n\n        /**\n         * If set, use instead this value for envelopes instead of generating one\n         * @type {Boolean}\n         */\n        this._envelope = false;\n\n        /**\n         * If set then use this value as the stream content instead of building it\n         * @type {String|Buffer|Stream}\n         */\n        this._raw = false;\n\n        /**\n         * Additional transform streams that the message will be piped before\n         * exposing by createReadStream\n         * @type {Array}\n         */\n        this._transforms = [];\n\n        /**\n         * Additional process functions that the message will be piped through before\n         * exposing by createReadStream. These functions are run after transforms\n         * @type {Array}\n         */\n        this._processFuncs = [];\n\n        /**\n         * If content type is set (or derived from the filename) add it to headers\n         */\n        if (contentType) {\n            this.setHeader('Content-Type', contentType);\n        }\n    }\n\n    /////// PUBLIC METHODS\n\n    /**\n     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n     *\n     * @param {String} [contentType] Optional content type\n     * @param {Object} [options] Optional options object\n     * @return {Object} Created node object\n     */\n    createChild(contentType, options) {\n        if (!options && typeof contentType === 'object') {\n            options = contentType;\n            contentType = undefined;\n        }\n        let node = new MimeNode(contentType, options);\n        this.appendChild(node);\n        return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n    appendChild(childNode) {\n        if (childNode.rootNode !== this.rootNode) {\n            childNode.rootNode = this.rootNode;\n            childNode._nodeId = ++this.rootNode.nodeCounter;\n        }\n\n        childNode.parentNode = this;\n\n        this.childNodes.push(childNode);\n        return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n    replace(node) {\n        if (node === this) {\n            return this;\n        }\n\n        this.parentNode.childNodes.forEach((childNode, i) => {\n            if (childNode === this) {\n                node.rootNode = this.rootNode;\n                node.parentNode = this.parentNode;\n                node._nodeId = this._nodeId;\n\n                this.rootNode = this;\n                this.parentNode = undefined;\n\n                node.parentNode.childNodes[i] = node;\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n    remove() {\n        if (!this.parentNode) {\n            return this;\n        }\n\n        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n            if (this.parentNode.childNodes[i] === this) {\n                this.parentNode.childNodes.splice(i, 1);\n                this.parentNode = undefined;\n                this.rootNode = this;\n                return this;\n            }\n        }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    setHeader(key, value) {\n        let added = false,\n            headerValue;\n\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && 'value' in key) {\n                this.setHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.setHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.setHeader(i, key[i]);\n                });\n            }\n            return this;\n        }\n\n        key = this._normalizeHeaderKey(key);\n\n        headerValue = {\n            key,\n            value\n        };\n\n        // Check if the value exists and overwrite\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                if (!added) {\n                    // replace the first match\n                    this._headers[i] = headerValue;\n                    added = true;\n                } else {\n                    // remove following matches\n                    this._headers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n\n        // match not found, append the value\n        if (!added) {\n            this._headers.push(headerValue);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    addHeader(key, value) {\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && key.value) {\n                this.addHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.addHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.addHeader(i, key[i]);\n                });\n            }\n            return this;\n        } else if (Array.isArray(value)) {\n            value.forEach(val => {\n                this.addHeader(key, val);\n            });\n            return this;\n        }\n\n        this._headers.push({\n            key: this._normalizeHeaderKey(key),\n            value\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n    getHeader(key) {\n        key = this._normalizeHeaderKey(key);\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                return this._headers[i].value;\n            }\n        }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n    setContent(content) {\n        this.content = content;\n        if (typeof this.content.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this.content.removeListener('error', this._contentErrorHandler);\n                this.content = err;\n            };\n            this.content.once('error', this._contentErrorHandler);\n        } else if (typeof this.content === 'string') {\n            this._isPlainText = mimeFuncs.isPlainText(this.content);\n            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n                // If there are lines longer than 76 symbols/bytes do not use 7bit\n                this._hasLongLines = true;\n            }\n        }\n        return this;\n    }\n\n    build(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let stream = this.createReadStream();\n        let buf = [];\n        let buflen = 0;\n        let returned = false;\n\n        stream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = stream.read()) !== null) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n        });\n\n        stream.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            return callback(err);\n        });\n\n        stream.once('end', chunk => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            if (chunk && chunk.length) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n            return callback(null, Buffer.concat(buf, buflen));\n        });\n\n        return promise;\n    }\n\n    getTransferEncoding() {\n        let transferEncoding = false;\n        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n        if (this.content) {\n            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n                if (/^text\\//i.test(contentType)) {\n                    // If there are no special symbols, no need to modify the text\n                    if (this._isPlainText && !this._hasLongLines) {\n                        transferEncoding = '7bit';\n                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                        // detect preferred encoding for string value\n                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                    } else {\n                        // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                        transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n                    }\n                } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                    transferEncoding = transferEncoding || 'base64';\n                }\n            }\n        }\n        return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n    buildHeaders() {\n        let transferEncoding = this.getTransferEncoding();\n        let headers = [];\n\n        if (transferEncoding) {\n            this.setHeader('Content-Transfer-Encoding', transferEncoding);\n        }\n\n        if (this.filename && !this.getHeader('Content-Disposition')) {\n            this.setHeader('Content-Disposition', 'attachment');\n        }\n\n        // Ensure mandatory header fields\n        if (this.rootNode === this) {\n            if (!this.getHeader('Date')) {\n                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n            }\n\n            // ensure that Message-Id is present\n            this.messageId();\n\n            if (!this.getHeader('MIME-Version')) {\n                this.setHeader('MIME-Version', '1.0');\n            }\n        }\n\n        this._headers.forEach(header => {\n            let key = header.key;\n            let value = header.value;\n            let structured;\n            let param;\n            let options = {};\n            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n                Object.keys(value).forEach(key => {\n                    if (key !== 'value') {\n                        options[key] = value[key];\n                    }\n                });\n                value = (value.value || '').toString();\n                if (!value.trim()) {\n                    return;\n                }\n            }\n\n            if (options.prepared) {\n                // header value is\n                if (options.foldLines) {\n                    headers.push(mimeFuncs.foldLines(key + ': ' + value));\n                } else {\n                    headers.push(key + ': ' + value);\n                }\n                return;\n            }\n\n            switch (header.key) {\n                case 'Content-Disposition':\n                    structured = mimeFuncs.parseHeaderValue(value);\n                    if (this.filename) {\n                        structured.params.filename = this.filename;\n                    }\n                    value = mimeFuncs.buildHeaderValue(structured);\n                    break;\n\n                case 'Content-Type':\n                    structured = mimeFuncs.parseHeaderValue(value);\n\n                    this._handleContentType(structured);\n\n                    if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n                        structured.params.charset = 'utf-8';\n                    }\n\n                    value = mimeFuncs.buildHeaderValue(structured);\n\n                    if (this.filename) {\n                        // add support for non-compliant clients like QQ webmail\n                        // we can't build the value with buildHeaderValue as the value is non standard and\n                        // would be converted to parameter continuation encoding that we do not want\n                        param = this._encodeWords(this.filename);\n\n                        if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                            // include value in quotes if needed\n                            param = '\"' + param + '\"';\n                        }\n                        value += '; name=' + param;\n                    }\n                    break;\n\n                case 'Bcc':\n                    if (!this.keepBcc) {\n                        // skip BCC values\n                        return;\n                    }\n                    break;\n            }\n\n            value = this._encodeHeaderValue(key, value);\n\n            // skip empty lines\n            if (!(value || '').toString().trim()) {\n                return;\n            }\n\n            if (typeof this.normalizeHeaderKey === 'function') {\n                let normalized = this.normalizeHeaderKey(key, value);\n                if (normalized && typeof normalized === 'string' && normalized.length) {\n                    key = normalized;\n                }\n            }\n\n            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n        });\n\n        return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n    createReadStream(options) {\n        options = options || {};\n\n        let stream = new PassThrough(options);\n        let outputStream = stream;\n        let transform;\n\n        this.stream(stream, options, err => {\n            if (err) {\n                outputStream.emit('error', err);\n                return;\n            }\n            stream.end();\n        });\n\n        for (let i = 0, len = this._transforms.length; i < len; i++) {\n            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n            outputStream.once('error', err => {\n                transform.emit('error', err);\n            });\n            outputStream = outputStream.pipe(transform);\n        }\n\n        // ensure terminating newline after possible user transforms\n        transform = new LastNewline();\n        outputStream.once('error', err => {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n\n        // dkim and stuff\n        for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n            transform = this._processFuncs[i];\n            outputStream = transform(outputStream);\n        }\n\n        if (this.newline) {\n            const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n\n            const stream = outputStream.pipe(newlineTransform);\n            outputStream.on('error', err => stream.emit('error', err));\n            return stream;\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n    transform(transform) {\n        this._transforms.push(transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n    processFunc(processFunc) {\n        this._processFuncs.push(processFunc);\n    }\n\n    stream(outputStream, options, done) {\n        let transferEncoding = this.getTransferEncoding();\n        let contentStream;\n        let localStream;\n\n        // protect actual callback against multiple triggering\n        let returned = false;\n        let callback = err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            done(err);\n        };\n\n        // for multipart nodes, push child nodes\n        // for content nodes end the stream\n        let finalize = () => {\n            let childId = 0;\n            let processChildNode = () => {\n                if (childId >= this.childNodes.length) {\n                    outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n                    return callback();\n                }\n                let child = this.childNodes[childId++];\n                outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n                child.stream(outputStream, options, err => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    setImmediate(processChildNode);\n                });\n            };\n\n            if (this.multipart) {\n                setImmediate(processChildNode);\n            } else {\n                return callback();\n            }\n        };\n\n        // pushes node content\n        let sendContent = () => {\n            if (this.content) {\n                if (Object.prototype.toString.call(this.content) === '[object Error]') {\n                    // content is already errored\n                    return callback(this.content);\n                }\n\n                if (typeof this.content.pipe === 'function') {\n                    this.content.removeListener('error', this._contentErrorHandler);\n                    this._contentErrorHandler = err => callback(err);\n                    this.content.once('error', this._contentErrorHandler);\n                }\n\n                let createStream = () => {\n                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n\n                        contentStream.pipe(outputStream, {\n                            end: false\n                        });\n                        contentStream.once('end', finalize);\n                        contentStream.once('error', err => callback(err));\n\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(contentStream);\n                    } else {\n                        // anything that is not QP or Base54 passes as-is\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(outputStream, {\n                            end: false\n                        });\n                        localStream.once('end', finalize);\n                    }\n\n                    localStream.once('error', err => callback(err));\n                };\n\n                if (this.content._resolve) {\n                    let chunks = [];\n                    let chunklen = 0;\n                    let returned = false;\n                    let sourceStream = this._getStream(this.content);\n                    sourceStream.on('error', err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        callback(err);\n                    });\n                    sourceStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = sourceStream.read()) !== null) {\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n                    sourceStream.on('end', () => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        this.content._resolve = false;\n                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n                        setImmediate(createStream);\n                    });\n                } else {\n                    setImmediate(createStream);\n                }\n                return;\n            } else {\n                return setImmediate(finalize);\n            }\n        };\n\n        if (this._raw) {\n            setImmediate(() => {\n                if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n                    // content is already errored\n                    return callback(this._raw);\n                }\n\n                // remove default error handler (if set)\n                if (typeof this._raw.pipe === 'function') {\n                    this._raw.removeListener('error', this._contentErrorHandler);\n                }\n\n                let raw = this._getStream(this._raw);\n                raw.pipe(outputStream, {\n                    end: false\n                });\n                raw.on('error', err => outputStream.emit('error', err));\n                raw.on('end', finalize);\n            });\n        } else {\n            outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n            setImmediate(sendContent);\n        }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    setEnvelope(envelope) {\n        let list;\n\n        this._envelope = {\n            from: false,\n            to: []\n        };\n\n        if (envelope.from) {\n            list = [];\n            this._convertAddresses(this._parseAddresses(envelope.from), list);\n            list = list.filter(address => address && address.address);\n            if (list.length && list[0]) {\n                this._envelope.from = list[0].address;\n            }\n        }\n        ['to', 'cc', 'bcc'].forEach(key => {\n            if (envelope[key]) {\n                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n            }\n        });\n\n        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n\n        let standardFields = ['to', 'cc', 'bcc', 'from'];\n        Object.keys(envelope).forEach(key => {\n            if (!standardFields.includes(key)) {\n                this._envelope[key] = envelope[key];\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n    getAddresses() {\n        let addresses = {};\n\n        this._headers.forEach(header => {\n            let key = header.key.toLowerCase();\n            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n                if (!Array.isArray(addresses[key])) {\n                    addresses[key] = [];\n                }\n\n                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n            }\n        });\n\n        return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    getEnvelope() {\n        if (this._envelope) {\n            return this._envelope;\n        }\n\n        let envelope = {\n            from: false,\n            to: []\n        };\n        this._headers.forEach(header => {\n            let list = [];\n            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {\n                this._convertAddresses(this._parseAddresses(header.value), list);\n                if (list.length && list[0]) {\n                    envelope.from = list[0].address;\n                }\n            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n                this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n            }\n        });\n\n        envelope.to = envelope.to.map(to => to.address);\n\n        return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n    messageId() {\n        let messageId = this.getHeader('Message-ID');\n        // You really should define your own Message-Id field!\n        if (!messageId) {\n            messageId = this._generateMessageId();\n            this.setHeader('Message-ID', messageId);\n        }\n        return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n    setRaw(raw) {\n        this._raw = raw;\n\n        if (this._raw && typeof this._raw.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this._raw.removeListener('error', this._contentErrorHandler);\n                this._raw = err;\n            };\n            this._raw.once('error', this._contentErrorHandler);\n        }\n\n        return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n    _getStream(content) {\n        let contentStream;\n\n        if (content._resolvedValue) {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content._resolvedValue));\n            return contentStream;\n        } else if (typeof content.pipe === 'function') {\n            // assume as stream\n            return content;\n        } else if (content && typeof content.path === 'string' && !content.href) {\n            if (this.disableFileAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n                return contentStream;\n            }\n            // read file\n            return fs.createReadStream(content.path);\n        } else if (content && typeof content.href === 'string') {\n            if (this.disableUrlAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n                return contentStream;\n            }\n            // fetch URL\n            return fetch(content.href, { headers: content.httpHeaders });\n        } else {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content || ''));\n            return contentStream;\n        }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n    _parseAddresses(addresses) {\n        return [].concat.apply(\n            [],\n            [].concat(addresses).map(address => {\n                // eslint-disable-line prefer-spread\n                if (address && address.address) {\n                    address.address = this._normalizeAddress(address.address);\n                    address.name = address.name || '';\n                    return [address];\n                }\n                return addressparser(address);\n            })\n        );\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n    _normalizeHeaderKey(key) {\n        key = (key || '')\n            .toString()\n            // no newlines in keys\n            .replace(/\\r?\\n|\\r/g, ' ')\n            .trim()\n            .toLowerCase()\n            // use uppercase words, except MIME\n            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n            // special case\n            .replace(/^Content-Features$/i, 'Content-features');\n\n        return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n    _handleContentType(structured) {\n        this.contentType = structured.value.trim().toLowerCase();\n\n        this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n        if (this.multipart) {\n            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n        } else {\n            this.boundary = false;\n        }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n    _generateBoundary() {\n        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n    _encodeHeaderValue(key, value) {\n        key = this._normalizeHeaderKey(key);\n\n        switch (key) {\n            // Structured headers\n            case 'From':\n            case 'Sender':\n            case 'To':\n            case 'Cc':\n            case 'Bcc':\n            case 'Reply-To':\n                return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n            case 'Message-ID':\n            case 'In-Reply-To':\n            case 'Content-Id':\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n                if (value.charAt(0) !== '<') {\n                    value = '<' + value;\n                }\n\n                if (value.charAt(value.length - 1) !== '>') {\n                    value = value + '>';\n                }\n                return value;\n\n            // space separated list of values enclosed in <>\n            case 'References':\n                value = [].concat\n                    .apply(\n                        [],\n                        [].concat(value || '').map(elm => {\n                            // eslint-disable-line prefer-spread\n                            elm = (elm || '')\n                                .toString()\n                                .replace(/\\r?\\n|\\r/g, ' ')\n                                .trim();\n                            return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n                        })\n                    )\n                    .map(elm => {\n                        if (elm.charAt(0) !== '<') {\n                            elm = '<' + elm;\n                        }\n                        if (elm.charAt(elm.length - 1) !== '>') {\n                            elm = elm + '>';\n                        }\n                        return elm;\n                    });\n\n                return value.join(' ').trim();\n\n            case 'Date':\n                if (Object.prototype.toString.call(value) === '[object Date]') {\n                    return value.toUTCString().replace(/GMT/, '+0000');\n                }\n\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                return this._encodeWords(value);\n\n            case 'Content-Type':\n            case 'Content-Disposition':\n                // if it includes a filename then it is already encoded\n                return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            default:\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                // encodeWords only encodes if needed, otherwise the original string is returned\n                return this._encodeWords(value);\n        }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n    _convertAddresses(addresses, uniqueList) {\n        let values = [];\n\n        uniqueList = uniqueList || [];\n\n        [].concat(addresses || []).forEach(address => {\n            if (address.address) {\n                address.address = this._normalizeAddress(address.address);\n\n                if (!address.name) {\n                    values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n                } else if (address.name) {\n                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n                }\n\n                if (address.address) {\n                    if (!uniqueList.filter(a => a.address === address.address).length) {\n                        uniqueList.push(address);\n                    }\n                }\n            } else if (address.group) {\n                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n            }\n        });\n\n        return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n    _normalizeAddress(address) {\n        address = (address || '')\n            .toString()\n            .replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n            .trim();\n\n        let lastAt = address.lastIndexOf('@');\n        if (lastAt < 0) {\n            // Bare username\n            return address;\n        }\n\n        let user = address.substr(0, lastAt);\n        let domain = address.substr(lastAt + 1);\n\n        // Usernames are not touched and are kept as is even if these include unicode\n        // Domains are punycoded by default\n        // 'j\u00f5geva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n\n        let encodedDomain;\n\n        try {\n            encodedDomain = punycode.toASCII(domain.toLowerCase());\n        } catch (err) {\n            // keep as is?\n        }\n\n        if (user.indexOf(' ') >= 0) {\n            if (user.charAt(0) !== '\"') {\n                user = '\"' + user;\n            }\n            if (user.substr(-1) !== '\"') {\n                user = user + '\"';\n            }\n        }\n\n        return `${user}@${encodedDomain}`;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeAddressName(name) {\n        if (!/^[\\w ']*$/.test(name)) {\n            if (/^[\\x20-\\x7e]*$/.test(name)) {\n                return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n            } else {\n                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeWords(value) {\n        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n        // by default only words that include non-ascii should be converted into encoded words\n        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n    _getTextEncoding(value) {\n        value = (value || '').toString();\n\n        let encoding = this.textEncoding;\n        let latinLen;\n        let nonLatinLen;\n\n        if (!encoding) {\n            // count latin alphabet symbols and 8-bit range symbols + control symbols\n            // if there are more latin characters, then use quoted-printable\n            // encoding, otherwise use base64\n            nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n            latinLen = (value.match(/[a-z]/gi) || []).length;\n            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n            encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n        }\n        return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n    _generateMessageId() {\n        return (\n            '<' +\n            [2, 2, 2, 6].reduce(\n                // crux to generate UUID-like random strings\n                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),\n                crypto.randomBytes(4).toString('hex')\n            ) +\n            '@' +\n            // try to use the domain of the FROM address or fallback to server hostname\n            (this.getEnvelope().from || this.hostname || os.hostname() || 'localhost').split('@').pop() +\n            '>'\n        );\n    }\n}\n\nmodule.exports = MimeNode;\n", "{\n    \"name\": \"nodemailer\",\n    \"version\": \"6.6.1\",\n    \"description\": \"Easy as cake e-mail sending from your Node.js applications\",\n    \"main\": \"lib/nodemailer.js\",\n    \"scripts\": {\n        \"test\": \"grunt\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/nodemailer/nodemailer.git\"\n    },\n    \"keywords\": [\n        \"Nodemailer\"\n    ],\n    \"author\": \"Andris Reinman\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/nodemailer/nodemailer/issues\"\n    },\n    \"homepage\": \"https://nodemailer.com/\",\n    \"devDependencies\": {\n        \"bunyan\": \"1.8.15\",\n        \"chai\": \"4.3.4\",\n        \"eslint-config-nodemailer\": \"1.2.0\",\n        \"eslint-config-prettier\": \"8.3.0\",\n        \"grunt\": \"1.4.0\",\n        \"grunt-cli\": \"1.4.2\",\n        \"grunt-eslint\": \"23.0.0\",\n        \"grunt-mocha-test\": \"0.13.3\",\n        \"libbase64\": \"1.2.1\",\n        \"libmime\": \"5.0.0\",\n        \"libqp\": \"1.1.0\",\n        \"mocha\": \"8.4.0\",\n        \"nodemailer-ntlm-auth\": \"1.0.1\",\n        \"proxy\": \"1.0.2\",\n        \"proxy-test-server\": \"1.0.0\",\n        \"sinon\": \"10.0.0\",\n        \"smtp-server\": \"3.8.0\"\n    },\n    \"engines\": {\n        \"node\": \">=6.0.0\"\n    }\n}\n"], "filenames": [".travis.yml", "CHANGELOG.md", "examples/mailcomposer.js", "lib/mime-node/index.js", "package.json"], "buggy_code_start_loc": [7, 1, 12, 1150, 3], "buggy_code_end_loc": [8, 1, 13, 1193, 35], "fixing_code_start_loc": [7, 2, 12, 1150, 3], "fixing_code_end_loc": [8, 6, 15, 1213, 35], "type": "CWE-74", "message": "The package nodemailer before 6.6.1 are vulnerable to HTTP Header Injection if unsanitized user input that may contain newlines and carriage returns is passed into an address object.", "other": {"cve": {"id": "CVE-2021-23400", "sourceIdentifier": "report@snyk.io", "published": "2021-06-29T12:15:08.363", "lastModified": "2021-07-06T18:48:29.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package nodemailer before 6.6.1 are vulnerable to HTTP Header Injection if unsanitized user input that may contain newlines and carriage returns is passed into an address object."}, {"lang": "es", "value": "El paquete nodemailer versiones anteriores a 6.6.1, es vulnerable a una inyecci\u00f3n de encabezados HTTP si una entrada de usuario no saneada que puede contener newlines y carriage returns dentro de un objeto de direcci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodemailer:nodemailer:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "6.6.1", "matchCriteriaId": "4FBF694C-AC48-438A-9A96-174DB8BB2193"}]}]}], "references": [{"url": "https://github.com/nodemailer/nodemailer/commit/7e02648cc8cd863f5085bad3cd09087bccf84b9f", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nodemailer/nodemailer/issues/1289", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1314737", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-NODEMAILER-1296415", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nodemailer/nodemailer/commit/7e02648cc8cd863f5085bad3cd09087bccf84b9f"}}