{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/utf.h>\n#include <gpac/constants.h>\n#include <gpac/network.h>\n#include <gpac/internal/bifs_dev.h>\n#include <gpac/internal/scenegraph_dev.h>\n\n#include <gpac/nodes_x3d.h>\n#include <gpac/color.h>\n\n\n#if !defined(GPAC_DISABLE_LOADER_BT) && !defined(GPAC_DISABLE_ZLIB)\n\n#include <gpac/mpeg4_odf.h>\n\n/*since 0.2.2, we use zlib for bt reading to handle wrl.gz files*/\n#include <zlib.h>\n\nvoid gf_sm_update_bitwrapper_buffer(GF_Node *node, const char *fileName);\n\nvoid load_bt_done(GF_SceneLoader *load);\n\n#define BT_LINE_SIZE\t4000\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n} BTDefSymbol;\n\ntypedef struct\n{\n\tGF_SceneLoader *load;\n\tBool initialized;\n\tgzFile gz_in;\n\tu32 file_size, file_pos;\n\n\t/*create from string only*/\n\tGF_List *top_nodes;\n\n\tGF_Err last_error;\n\tu32 line;\n\n\tBool done, in_com;\n\tu32 is_wrl;\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tu32 unicode_type;\n\n\tGF_List *def_symbols;\n\n\t/*routes are not created in the graph when parsing, so we need to track insert and delete/replace*/\n\tGF_List *unresolved_routes, *inserted_routes, *peeked_nodes;\n\tGF_List *undef_nodes, *def_nodes;\n\n\tchar *line_buffer;\n\tchar cur_buffer[500];\n\ts32 line_size, line_pos, line_start_pos;\n\n\tu32 block_comment;\n\n\t/*set when parsing proto*/\n\tGF_Proto *parsing_proto;\n\tBool is_extern_proto_field;\n\n\t/*current stream ID, AU time and RAP flag*/\n\tu32 stream_id;\n\tu32 au_time;\n\tBool au_is_rap;\n\n\t/*current BIFS stream & AU*/\n\tGF_StreamContext *bifs_es;\n\tGF_AUContext *bifs_au;\n\tu32 base_bifs_id;\n\tGF_Command *cur_com;\n\n\t/*current OD stream & AU*/\n\tGF_StreamContext *od_es;\n\tGF_AUContext *od_au;\n\tu32 base_od_id;\n\n\tGF_List *scripts;\n\n\tu32 def_w, def_h;\n\n} GF_BTParser;\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList);\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com);\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean);\n\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID);\n\nstatic GF_Err gf_bt_report(GF_BTParser *parser, GF_Err e, char *format, ...)\n{\n#ifndef GPAC_DISABLE_LOG\n\tif (format && gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tchar szMsg[2048];\n\t\tva_list args;\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 2048, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (\"[BT/WRL Parsing] %s (line %d)\\n\", szMsg, parser->line));\n\t}\n#endif\n\tif (e) parser->last_error = e;\n\treturn e;\n}\n\n\nvoid gf_bt_check_line(GF_BTParser *parser)\n{\nreload_line:\n\twhile (parser->line_pos < parser->line_size) {\n\t\tswitch (parser->line_buffer[parser->line_pos]) {\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\t\tparser->line_pos++;\n\t\t\tcontinue;\n\t\tcase '\\0':\n\t\t\tparser->line_pos = parser->line_size;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (parser->line_pos < parser->line_size) {\n\t\tif (parser->line_buffer[parser->line_pos]=='#') {\n\t\t\tparser->line_size = parser->line_pos;\n\t\t}\n\t\telse if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) {\n\t\t\tparser->line_size = parser->line_pos;\n\t\t}\n\t}\n\n\tif (parser->line_size == parser->line_pos) {\n\t\t/*string based input - done*/\n\t\tif (!parser->gz_in) {\n\t\t\tparser->done = 1;\n\t\t\treturn;\n\t\t}\n\nnext_line:\n\t\tparser->line_start_pos = (s32) gf_gztell(parser->gz_in);\n\t\tparser->line_buffer[0] = 0;\n\t\tif (parser->unicode_type) {\n\t\t\tu8 c1, c2;\n\t\t\tunsigned short wchar;\n\t\t\tunsigned short l[BT_LINE_SIZE];\n\t\t\tunsigned short *dst = l;\n\t\t\tBool is_ret = 0;\n\t\t\tu32 last_space_pos, last_space_pos_stream;\n\t\t\tu32 go = BT_LINE_SIZE - 1;\n\t\t\tlast_space_pos = last_space_pos_stream = 0;\n\t\t\twhile (go && !gf_gzeof(parser->gz_in) ) {\n\t\t\t\tc1 = gf_gzgetc(parser->gz_in);\n\t\t\t\tc2 = gf_gzgetc(parser->gz_in);\n\t\t\t\t/*Little-endian order*/\n\t\t\t\tif (parser->unicode_type==2) {\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar = c2;\n\t\t\t\t\t\twchar <<=8;\n\t\t\t\t\t\twchar |= c1;\n\t\t\t\t\t}\n\t\t\t\t\telse wchar = c1;\n\t\t\t\t} else {\n\t\t\t\t\twchar = c1;\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar <<= 8;\n\t\t\t\t\t\twchar |= c2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*dst = wchar;\n\t\t\t\tif (wchar=='\\r') is_ret = 1;\n\t\t\t\telse if (wchar=='\\n') {\n\t\t\t\t\tdst++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (is_ret) {\n\t\t\t\t\tu32 fpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tgf_gzseek(parser->gz_in, fpos-2, SEEK_SET);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (wchar==' ') {\n\t\t\t\t\t//last_space_pos_stream = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tlast_space_pos = (u32) (dst - l);\n\t\t\t\t}\n\t\t\t\tdst++;\n\t\t\t\tgo--;\n\n\t\t\t}\n\t\t\t*dst = 0;\n\t\t\t/*long line, rewind stream to last space*/\n\t\t\tif (!go) {\n\t\t\t\tu32 rew_pos = (u32)  (gf_gztell(parser->gz_in) - 2*(dst - &l[last_space_pos]) );\n\t\t\t\tgf_gzseek(parser->gz_in, rew_pos, SEEK_SET);\n\t\t\t\tl[last_space_pos+1] = 0;\n\t\t\t}\n\t\t\t/*check eof*/\n\t\t\tif (l[0]==0xFFFF) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*convert to mbc string*/\n\t\t\tdst = l;\n\t\t\tgf_utf8_wcstombs(parser->line_buffer, BT_LINE_SIZE, (const unsigned short **) &dst);\n\n\t\t\tif (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in)) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((gf_gzgets(parser->gz_in, parser->line_buffer, BT_LINE_SIZE) == NULL)\n\t\t\t        || (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in))) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*watchout for long lines*/\n\t\t\tif (1 + strlen(parser->line_buffer) == BT_LINE_SIZE) {\n\t\t\t\tu32 rew, pos, go;\n\t\t\t\trew = 0;\n\t\t\t\tgo = 1;\n\t\t\t\twhile (go) {\n\t\t\t\t\tswitch (parser->line_buffer[strlen(parser->line_buffer)-1]) {\n\t\t\t\t\tcase ' ':\n\t\t\t\t\tcase ',':\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tgo = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparser->line_buffer[strlen(parser->line_buffer)-1] = 0;\n\t\t\t\t\t\trew++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\tgf_gzseek(parser->gz_in, pos-rew, SEEK_SET);\n\t\t\t}\n\t\t}\n\n\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tu32 len = (u32) strlen(parser->line_buffer);\n\t\t\tif (!len) break;\n\t\t\tc = parser->line_buffer[len-1];\n\t\t\tif (!strchr(\"\\n\\r\\t\", c)) break;\n\t\t\tparser->line_buffer[len-1] = 0;\n\t\t}\n\n\n\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\tparser->line_pos = 0;\n\t\tparser->line++;\n\n\t\t{\n\t\t\tu32 pos = (u32) gf_gztell(parser->gz_in);\n\t\t\tif (pos>=parser->file_pos) {\n\t\t\t\tparser->file_pos = pos;\n\t\t\t\tif (parser->line>1) gf_set_progress(\"BT Parsing\", pos, parser->file_size);\n\t\t\t}\n\t\t}\n\n\t\twhile ((parser->line_buffer[parser->line_pos]==' ') || (parser->line_buffer[parser->line_pos]=='\\t'))\n\t\t\tparser->line_pos++;\n\t\tif ( (parser->line_buffer[parser->line_pos]=='#')\n\t\t        || ( (parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/')) ) {\n\n\t\t\tif (parser->line==1) {\n\t\t\t\tif (strstr(parser->line_buffer, \"VRML\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"VRML V2.0\")) parser->is_wrl = 1;\n\t\t\t\t\t/*although not std, many files use this*/\n\t\t\t\t\telse if (strstr(parser->line_buffer, \"VRML2.0\")) parser->is_wrl = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: VRML Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (strstr(parser->line_buffer, \"X3D\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"X3D V3.0\")) parser->is_wrl = 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: X3D Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"#define \", 8) && !parser->block_comment) {\n\t\t\t\tchar *buf, *sep;\n\t\t\t\tparser->line_pos+=8;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\tsep = strchr(buf, ' ');\n\t\t\t\tif (sep && (sep[1]!='\\n') ) {\n\t\t\t\t\tBTDefSymbol *def;\n\t\t\t\t\tGF_SAFEALLOC(def, BTDefSymbol);\n\t\t\t\t\tif (!def) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Fail to allocate DEF node\\n\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\tdef->name = gf_strdup(buf);\n\t\t\t\t\tsep[0] = ' ';\n\t\t\t\t\tbuf = sep+1;\n\t\t\t\t\twhile (strchr(\" \\t\", buf[0])) buf++;\n\t\t\t\t\tdef->value = gf_strdup(buf);\n\t\t\t\t\tgf_list_add(parser->def_symbols, def);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#if \", 4)) {\n\t\t\t\tu32 len = 0;\n\t\t\t\tparser->line_pos+=4;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (parser->line_pos+(s32)len==parser->line_size) break;\n\t\t\t\t\tif (strchr(\" \\n\\t\", parser->line_buffer[parser->line_pos+len]))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\tif (len) {\n\t\t\t\t\tif (len==1) {\n\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"0\", 1)) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 i, count;\n\t\t\t\t\t\tchar *keyWord = NULL;\n\t\t\t\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, def->name, len)) {\n\t\t\t\t\t\t\t\tkeyWord = def->value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keyWord && !strcmp(keyWord, \"0\")) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#endif\", 6)) {\n\t\t\t\tif (parser->block_comment) parser->block_comment--;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#else\", 5)) {\n\t\t\t\tif (parser->block_comment)\n\t\t\t\t\tparser->block_comment--;\n\t\t\t\telse\n\t\t\t\t\tparser->block_comment++;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#size\", 5)) {\n\t\t\t\tchar *buf;\n\t\t\t\tparser->line_pos+=6;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\twhile (strchr(\" \\t\", buf[0]))\n\t\t\t\t\tbuf++;\n\t\t\t\tsscanf(buf, \"%dx%d\", &parser->def_w, &parser->def_h);\n\t\t\t}\n\t\t\tgoto next_line;\n\t\t}\n\n\t\tif (parser->block_comment)\n\t\t\tgoto next_line;\n\n\t\t/*brute-force replacement of defined symbols (!!FIXME - no mem checking done !!)*/\n\t\tif (parser->line_pos < parser->line_size) {\n\t\t\tu32 i, count;\n\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\twhile (1) {\n\t\t\t\tBool found = 0;\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tu32 symb_len, val_len, copy_len;\n\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\tchar *start = strstr(parser->line_buffer, def->name);\n\t\t\t\t\tif (!start) continue;\n\t\t\t\t\tsymb_len = (u32) strlen(def->name);\n\t\t\t\t\tif (!strchr(\" \\n\\r\\t,[]{}\\'\\\"\", start[symb_len])) continue;\n\t\t\t\t\tval_len = (u32) strlen(def->value);\n\t\t\t\t\tcopy_len = (u32) strlen(start + symb_len) + 1;\n\t\t\t\t\tmemmove(start + val_len, start + symb_len, sizeof(char)*copy_len);\n\t\t\t\t\tmemcpy(start, def->value, sizeof(char)*val_len);\n\t\t\t\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\t\t\t\tfound = 1;\n\t\t\t\t}\n\t\t\t\tif (!found) break;\n\t\t\t}\n\t\t}\n\t}\n\tif (!parser->line_size) {\n\t\tif (!gf_gzeof(parser->gz_in))\n\t\t\t//avoid recursion\n\t\t\tgoto reload_line;\n\t\telse\n\t\t\tparser->done = 1;\n\t}\n\telse if (!parser->done && (parser->line_size == parser->line_pos))\n\t\t//avoid recursion\n\t\tgoto reload_line;\n}\n\nvoid gf_bt_force_line(GF_BTParser *parser)\n{\n\tparser->line_pos = parser->line_size;\n}\n\nBool gf_bt_check_code(GF_BTParser *parser, char code)\n{\n\tgf_bt_check_line(parser);\n\tif (parser->line_buffer[parser->line_pos]==code) {\n\t\tparser->line_pos++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nchar *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\n\t\t\tif (parser->line_pos+i==parser->line_size) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}\n\nchar *gf_bt_get_string(GF_BTParser *parser, u8 string_delim)\n{\n\tchar *res;\n\ts32 i, size;\n\n#define\tBT_STR_CHECK_ALLOC\t\\\n\t\tif (i==size) {\t\t\\\n\t\t\tres = (char*)gf_realloc(res, sizeof(char) * (size+500+1));\t\\\n\t\t\tsize += 500;\t\\\n\t\t}\t\\\n\n\tres = (char*)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\twhile (parser->line_buffer[parser->line_pos]==' ') parser->line_pos++;\n\n\tif (parser->line_pos==parser->line_size) {\n\t\tif (gf_gzeof(parser->gz_in)) return NULL;\n\t\tgf_bt_check_line(parser);\n\t}\n\tif (!string_delim) string_delim = '\"';\n\n\ti=0;\n\twhile (1) {\n\t\tif (parser->line_buffer[parser->line_pos] == string_delim)\n\t\t\tif ( !parser->line_pos || (parser->line_buffer[parser->line_pos-1] != '\\\\') ) break;\n\n\t\tBT_STR_CHECK_ALLOC\n\n\t\tif ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') && (parser->line_buffer[parser->line_pos-1]!=':') ) {\n\t\t\t/*this looks like a comment*/\n\t\t\tif (!strchr(&parser->line_buffer[parser->line_pos], string_delim)) {\n\t\t\t\tgf_bt_check_line(parser);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((parser->line_buffer[parser->line_pos] != '\\\\') || (parser->line_buffer[parser->line_pos+1] != string_delim)) {\n\t\t\t/*handle UTF-8 - WARNING: if parser is in unicode string is already utf8 multibyte chars*/\n\t\t\tif (!parser->unicode_type && parser->line_buffer[parser->line_pos] & 0x80) {\n\t\t\t\tchar c = parser->line_buffer[parser->line_pos];\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (parser->line_buffer[parser->line_pos+1] & 0xc0) != 0x80) {\n\t\t\t\t\tres[i] = 0xc0 | ( (parser->line_buffer[parser->line_pos] >> 6) & 0x3 );\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tparser->line_buffer[parser->line_pos] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (c & 0xe0) == 0xc0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (c & 0xf0) == 0xe0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (c & 0xf8) == 0xf0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\ti++;\n\t\t}\n\t\tparser->line_pos++;\n\t\tif (parser->line_pos==parser->line_size) {\n\t\t\tgf_bt_check_line(parser);\n\t\t}\n\n\t}\n\n#undef\tBT_STR_CHECK_ALLOC\n\n\tres[i] = 0;\n\tparser->line_pos += 1;\n\treturn res;\n}\n\nBool gf_bt_check_externproto_field(GF_BTParser *parser, char *str)\n{\n\tif (!parser->is_extern_proto_field) return 0;\n\tif (!strcmp(str, \"\") || !strcmp(str, \"field\") || !strcmp(str, \"eventIn\") || !strcmp(str, \"eventOut\") || !strcmp(str, \"exposedField\")) {\n\t\tparser->last_error = GF_EOS;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic Bool check_keyword(GF_BTParser *parser, char *str, s32 *val)\n{\n\ts32 res;\n\tchar *sep;\n\tsep = strchr(str, '$');\n\tif (!sep) return 0;\n\tsep++;\n\tif (!strcmp(sep, \"F1\")) res = GF_KEY_F1;\n\telse if (!strcmp(sep, \"F2\")) res = GF_KEY_F2;\n\telse if (!strcmp(sep, \"F3\")) res = GF_KEY_F3;\n\telse if (!strcmp(sep, \"F4\")) res = GF_KEY_F4;\n\telse if (!strcmp(sep, \"F5\")) res = GF_KEY_F5;\n\telse if (!strcmp(sep, \"F6\")) res = GF_KEY_F6;\n\telse if (!strcmp(sep, \"F7\")) res = GF_KEY_F7;\n\telse if (!strcmp(sep, \"F8\")) res = GF_KEY_F8;\n\telse if (!strcmp(sep, \"F9\")) res = GF_KEY_F9;\n\telse if (!strcmp(sep, \"F10\")) res = GF_KEY_F10;\n\telse if (!strcmp(sep, \"F11\")) res = GF_KEY_F11;\n\telse if (!strcmp(sep, \"F12\")) res = GF_KEY_F12;\n\telse if (!strcmp(sep, \"HOME\")) res = GF_KEY_HOME;\n\telse if (!strcmp(sep, \"END\")) res = GF_KEY_END;\n\telse if (!strcmp(sep, \"PREV\")) res = GF_KEY_PAGEUP;\n\telse if (!strcmp(sep, \"NEXT\")) res = GF_KEY_PAGEDOWN;\n\telse if (!strcmp(sep, \"UP\")) res = GF_KEY_UP;\n\telse if (!strcmp(sep, \"DOWN\")) res = GF_KEY_DOWN;\n\telse if (!strcmp(sep, \"LEFT\")) res = GF_KEY_LEFT;\n\telse if (!strcmp(sep, \"RIGHT\")) res = GF_KEY_RIGHT;\n\telse if (!strcmp(sep, \"RETURN\")) res = GF_KEY_ENTER;\n\telse if (!strcmp(sep, \"BACK\")) res = GF_KEY_BACKSPACE;\n\telse if (!strcmp(sep, \"TAB\")) res = GF_KEY_TAB;\n\telse if (strlen(sep)==1) {\n\t\tchar c;\n\t\tsscanf(sep, \"%c\", &c);\n\t\tres = c;\n\t} else {\n\t\tgf_bt_report(parser, GF_OK, \"unrecognized keyword %s - skipping\", str);\n\t\tres = 0;\n\t}\n\tif (strchr(str, '-')) *val = -res;\n\telse *val = res;\n\treturn 1;\n}\n\nGF_Err gf_bt_parse_float(GF_BTParser *parser, const char *name, Fixed *val)\n{\n\ts32 var;\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, &var)) {\n\t\t*val = INT2FIX(var);\n\t\treturn GF_OK;\n\t}\n\tif (sscanf(str, \"%g\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\t*val = FLT2FIX(f);\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_double(GF_BTParser *parser, const char *name, SFDouble *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\tif (sscanf(str, \"%lf\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_int(GF_BTParser *parser, const char *name, SFInt32 *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, val)) return GF_OK;\n\t/*URL ODID*/\n\tif (!strnicmp(str, \"od:\", 3)) str += 3;\n\tif (sscanf(str, \"%d\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_bool(GF_BTParser *parser, const char *name, SFBool *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (!stricmp(str, \"true\") || !strcmp(str, \"1\") ) {\n\t\t*val = 1;\n\t}\n\telse if (!stricmp(str, \"false\") || !strcmp(str, \"0\") ) {\n\t\t*val = 0;\n\t} else {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Boolean expected\", name);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_bt_parse_color(GF_BTParser *parser, const char *name, SFColor *col)\n{\n\tFloat f;\n\tu32 val;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (sscanf(str, \"%f\", &f) == 1) {\n\t\tcol->red = FLT2FIX(f);\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->green);\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->blue);\n\t\treturn parser->last_error;\n\t}\n\tval = gf_color_parse(str);\n\tif (!val) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number or name expected\", name);\n\t}\n\tcol->red = INT2FIX((val>>16) & 0xFF) / 255;\n\tcol->green = INT2FIX((val>>8) & 0xFF) / 255;\n\tcol->blue = INT2FIX(val & 0xFF) / 255;\n\treturn parser->last_error;\n}\n\nGF_Err gf_bt_parse_colorRGBA(GF_BTParser *parser, const char *name, SFColorRGBA *col)\n{\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\t/*HTML code*/\n\tif (str[0]=='$') {\n\t\tu32 val;\n\t\tsscanf(str, \"%x\", &val);\n\t\tcol->red = INT2FIX((val>>24) & 0xFF) / 255;\n\t\tcol->green = INT2FIX((val>>16) & 0xFF) / 255;\n\t\tcol->blue = INT2FIX((val>>8) & 0xFF) / 255;\n\t\tcol->alpha = INT2FIX(val & 0xFF) / 255;\n\t\treturn parser->last_error;\n\t}\n\tif (sscanf(str, \"%f\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\tcol->red = FLT2FIX(f);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->green);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->blue);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->alpha);\n\treturn parser->last_error;\n}\n\nstatic void gf_bt_offset_time(GF_BTParser *parser, Double *time)\n{\n\tif (!parser->is_wrl) {\n\t\tDouble res;\n\t\tres = parser->au_time;\n\t\tres /= parser->bifs_es->timeScale;\n\t\t*time += res;\n\t}\n}\n\nstatic void gf_bt_check_time_offset(GF_BTParser *parser, GF_Node *n, GF_FieldInfo *info)\n{\n\tif (!n || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\tif (gf_node_get_tag(n) != TAG_ProtoNode) {\n\t\tif (!stricmp(info->name, \"startTime\") || !stricmp(info->name, \"stopTime\"))\n\t\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t} else if (gf_sg_proto_field_is_sftime_offset(n, info)) {\n\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t}\n}\nstatic void gf_bt_update_timenode(GF_BTParser *parser, GF_Node *node)\n{\n\tif (!node || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_AnimationStream:\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioBuffer:\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioClip:\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioSource:\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_MovieTexture:\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_TimeSensor:\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_ProtoNode:\n\t{\n\t\tu32 i, nbFields;\n\t\tGF_FieldInfo inf;\n\t\tnbFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tgf_node_get_field(node, i, &inf);\n\t\t\tif (inf.fieldType != GF_SG_VRML_SFTIME) continue;\n\t\t\tgf_bt_check_time_offset(parser, node, &inf);\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\n\nvoid gf_bt_sffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tswitch (info->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\tgf_bt_parse_int(parser, info->name, (SFInt32 *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFBOOL:\n\t\tgf_bt_parse_bool(parser, info->name, (SFBool *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tgf_bt_parse_float(parser, info->name, (SFFloat *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFDOUBLE:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_check_time_offset(parser, n, info);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tgf_bt_parse_color(parser, info->name, (SFColor *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\t\tgf_bt_parse_colorRGBA(parser, info->name, (SFColorRGBA *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC4F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str)\n\t\t\t\tgoto err;\n\t\t\tif (((SFString *)info->far_ptr)->buffer) gf_free(((SFString *)info->far_ptr)->buffer);\n\t\t\t((SFString *)info->far_ptr)->buffer = NULL;\n\t\t\tif (strlen(str))\n\t\t\t\t((SFString *)info->far_ptr)->buffer = str;\n\t\t\telse\n\t\t\t\tgf_free(str);\n\n\t\t\tif (n && (n->sgprivate->tag==TAG_MPEG4_BitWrapper)) {\n\t\t\t\tgf_sm_update_bitwrapper_buffer(n, parser->load->fileName);\n\t\t\t}\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tSFURL *url = (SFURL *)info->far_ptr;\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str) goto err;\n\t\t\tif (url->url) gf_free(url->url);\n\t\t\turl->url = NULL;\n\t\t\turl->OD_ID = 0;\n\t\t\tif (strchr(str, '#')) {\n\t\t\t\turl->url = str;\n\t\t\t} else {\n\t\t\t\tu32 id = 0;\n\t\t\t\tchar *odstr = str;\n\t\t\t\tif (!strnicmp(str, \"od://\", 5)) odstr += 5;\n\t\t\t\telse if (!strnicmp(str, \"od:\", 3)) odstr += 3;\n\t\t\t\t/*be careful, an url like \"11-regression-test.mp4\" will return 1 on sscanf :)*/\n\t\t\t\tif (sscanf(odstr, \"%u\", &id) == 1) {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%u\", id);\n\t\t\t\t\tif (strcmp(szURL, odstr)) id=0;\n\t\t\t\t}\n\t\t\t\tif (id) {\n\t\t\t\t\turl->OD_ID = id;\n\t\t\t\t\tgf_free(str);\n\t\t\t\t} else {\n\t\t\t\t\turl->url = str;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts32 val;\n\t\t\tgf_bt_parse_int(parser, info->name, & val );\n\t\t\tif (parser->last_error) return;\n\t\t\t((SFURL *)info->far_ptr)->OD_ID = val;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)info->far_ptr;\n\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\tGF_Command *prev_com = parser->cur_com;\n\t\t\twhile (!parser->last_error) {\n\t\t\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\t\t\tparser->last_error = gf_bt_parse_bifs_command(parser, NULL, cb->commandList);\n\t\t\t}\n\t\t\tparser->cur_com = prev_com;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t{\n\t\tu32 i, size, v;\n\t\tSFImage *img = (SFImage *)info->far_ptr;\n\t\tgf_bt_parse_int(parser, \"width\", (SFInt32 *)&img->width);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"height\", (SFInt32 *)&img->height);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"nbComp\", (SFInt32 *)&v);\n\t\tif (parser->last_error) return;\n\t\timg->numComponents = v;\n\t\tsize = img->width * img->height * img->numComponents;\n\t\tif (img->pixels) gf_free(img->pixels);\n\t\timg->pixels = (unsigned char*)gf_malloc(sizeof(char) * size);\n\t\tfor (i=0; i<size; i++) {\n\t\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\t\tif (strstr(str, \"0x\")) sscanf(str, \"%x\", &v);\n\t\t\telse sscanf(str, \"%u\", &v);\n\t\t\tswitch (img->numComponents) {\n\t\t\tcase 1:\n\t\t\t\timg->pixels[i] = (char) v;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\timg->pixels[i] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v)&0xFF;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->pixels[i] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v)&0xFF;\n\t\t\t\ti+=2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\timg->pixels[i] = (char) (v>>24)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+3] = (char) (v)&0xFF;\n\t\t\t\ti+=3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t{\n\t\tSFScript *sc = (SFScript *) info->far_ptr;\n\t\tif (!gf_bt_check_code(parser, '\\\"')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"\\\" expected in Script\");\n\t\t}\n\t\tsc->script_text = (char*)gf_bt_get_string(parser, '\\\"');\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef*) info->far_ptr;\n\t\tchar *str = gf_bt_get_next(parser, 1);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"'.' expected in SFAttrRef\");\n\t\t} else {\n\t\t\tGF_FieldInfo pinfo;\n\t\t\tar->node = gf_bt_peek_node(parser, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (gf_node_get_field_by_name(ar->node, str, &pinfo) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"field %s is not a member of node %s\", str, gf_node_get_class_name(ar->node) );\n\t\t\t} else {\n\t\t\t\tar->fieldIndex = pinfo.fieldIndex;\n\t\t\t}\n\t\t}\n\n\t}\n\tbreak;\n\tdefault:\n\t\tparser->last_error = GF_NOT_SUPPORTED;\n\t\tbreak;\n\n\t}\n\tgf_bt_check_code(parser, ',');\n\treturn;\nerr:\n\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid field syntax\", info->name);\n}\n\nvoid gf_bt_mffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_FieldInfo sfInfo;\n\tBool force_single = 0;\n\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\tif (parser->is_extern_proto_field) return;\n\t\tforce_single = 1;\n\t}\n\n\tsfInfo.fieldType = gf_sg_vrml_get_sf_type(info->fieldType);\n\tsfInfo.name = info->name;\n\tgf_sg_vrml_mf_reset(info->far_ptr, info->fieldType);\n\n\twhile (!gf_bt_check_code(parser, ']')) {\n\t\tgf_sg_vrml_mf_append(info->far_ptr, info->fieldType, &sfInfo.far_ptr);\n\t\tgf_bt_sffield(parser, &sfInfo, n);\n\t\tif (parser->last_error) return;\n\n\t\tgf_bt_check_code(parser, ',');\n\t\tif (force_single) break;\n\t}\n}\n\nBool gf_bt_check_ndt(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *node, GF_Node *parent)\n{\n\tif (!node) return 1;\n\tif (parent->sgprivate->tag == TAG_MPEG4_Script) return 1;\n#ifndef GPAC_DISABLE_X3D\n\tif (parent->sgprivate->tag == TAG_X3D_Script) return 1;\n#endif\n\tif (node->sgprivate->tag == TAG_UndefinedNode) return 1;\n\n\t/*this handles undefined nodes*/\n\tif (gf_node_in_table(node, info->NDTtype)) return 1;\n\t/*not found*/\n\tgf_bt_report(parser, GF_BAD_PARAM, \"node %s not valid in field %s\\n\", gf_node_get_class_name(node), info->name);\n\tgf_node_unregister(node, parent);\n\treturn 0;\n}\n\nu32 gf_bt_get_next_node_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_node_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_node_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_route_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sg = parser->load->scene_graph;\n\tif (parser->parsing_proto) sg = gf_sg_proto_get_graph(parser->parsing_proto);\n\n\tID = gf_sg_get_next_available_route_id(sg);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_route_id))\n\t\tparser->load->ctx->max_route_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_proto_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_proto_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_proto_id = ID;\n\treturn ID;\n}\n\nu32 gf_bt_get_def_id(GF_BTParser *parser, char *defName)\n{\n\tGF_Node *n=NULL;\n\tu32 ID=0;\n\tif (sscanf(defName, \"N%u\", &ID) == 1) {\n\t\tu32 k=1;\n\t\twhile (defName[k]) {\n\t\t\tif (strchr(\"0123456789\", defName[k])==0) {\n\t\t\t\tID = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tif (ID) {\n\t\t\tID ++;\n\t\t\tn = gf_sg_find_node(parser->load->scene_graph, ID);\n\t\t\tif (!n) {\n\t\t\t\tif (parser->load->ctx && (parser->load->ctx->max_node_id<ID)) parser->load->ctx->max_node_id=ID;\n\t\t\t\treturn ID;\n\t\t\t}\n\t\t}\n\t}\n\n\tID = gf_bt_get_next_node_id(parser);\n\tif (n) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[BT Parsing] (line %d) Binary ID %d already assigned to %s - keeping internal ID %d\", parser->line, gf_node_get_name(n), ID));\n\t}\n\treturn ID;\n}\n\nBool gf_bt_set_field_is(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_FieldInfo pinfo;\n\tchar *str;\n\tgf_bt_check_line(parser);\n\ti=0;\n\twhile ((parser->line_buffer[parser->line_pos + i] == ' ') || (parser->line_buffer[parser->line_pos + i] == '\\t')) i++;\n\tif (strnicmp(&parser->line_buffer[parser->line_pos + i] , \"IS\", 2)) return 0;\n\n\tgf_bt_get_next(parser, 0);\n\tstr = gf_bt_get_next(parser, 0);\n\n\t/*that's an ISed field*/\n\tpfield = gf_sg_proto_field_find_by_name(parser->parsing_proto, str);\n\tif (!pfield) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto field\", str);\n\t\treturn 1;\n\t}\n\tgf_sg_proto_field_get_field(pfield, &pinfo);\n\te = gf_sg_proto_field_set_ised(parser->parsing_proto, pinfo.fieldIndex, n, info->fieldIndex);\n\tif (e) gf_bt_report(parser, GF_BAD_PARAM, \"IS: Invalid field type for field %s\", info->name);\n\treturn 1;\n}\n\nvoid gf_bt_check_unresolved_nodes(GF_BTParser *parser)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->undef_nodes);\n\tif (!count) return;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->undef_nodes, i);\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Cannot find node %s\\n\", gf_node_get_name(n) );\n\t\tgf_node_unregister(n, NULL);\n\t}\n\tparser->last_error = GF_BAD_PARAM;\n}\n\nBool gf_bt_has_been_def(GF_BTParser *parser, char *node_name)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->def_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *) gf_list_get(parser->def_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), node_name)) return 1;\n\t}\n\treturn 0;\n}\n\nu32 gf_bt_get_node_tag(GF_BTParser *parser, char *node_name)\n{\n\tu32 tag;\n\t/*if VRML and allowing non MPEG4 nodes, use X3D*/\n\tif (parser->is_wrl && !(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) {\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(node_name);\n\t\tif (!tag)\n#endif\n\t\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (tag) return tag;\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!strcmp(node_name, \"Rectangle\")) return TAG_X3D_Rectangle2D;\n\t\tif (!strcmp(node_name, \"Circle\")) return TAG_X3D_Circle2D;\n#endif\n\t} else {\n\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (!tag) {\n\t\t\tif (!strcmp(node_name, \"Rectangle2D\")) return TAG_MPEG4_Rectangle;\n\t\t\tif (!strcmp(node_name, \"Circle2D\")) return TAG_MPEG4_Circle;\n#ifndef GPAC_DISABLE_X3D\n\t\t\tif (!(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) return gf_node_x3d_type_by_class_name(node_name);\n#endif\n\t\t}\n\t}\n\treturn tag;\n}\n\nGF_Node *gf_bt_sf_node(GF_BTParser *parser, char *node_name, GF_Node *parent, char *szDEFName)\n{\n\tu32 tag, ID;\n\tBool is_script, replace_prev, register_def;\n\tGF_Proto *proto;\n\tGF_Node *node, *newnode, *undef_node;\n\tGF_FieldInfo info;\n\tBool init_node;\n\tchar *name;\n\tchar * str;\n\n\tinit_node = 0;\n\n\tif (node_name) {\n\t\tstr = node_name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\tname = NULL;\n\tif (!strcmp(str, \"NULL\")) return NULL;\n\n\tID = 0;\n\tregister_def = 0;\n\treplace_prev = 0;\n\tundef_node = NULL;\n\tif (!strcmp(str, \"DEF\")) {\n\t\tregister_def = 1;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tname = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else if (szDEFName) {\n\t\tname = gf_strdup(szDEFName);\n\t\tregister_def = 1;\n\t}\n\tif (name) {\n\t\tundef_node = gf_sg_find_node_by_name(parser->load->scene_graph, name);\n\t\tif (undef_node) {\n\t\t\tgf_list_del_item(parser->peeked_nodes, undef_node);\n\t\t\tID = gf_node_get_id(undef_node);\n\t\t\t/*if we see twice a DEF N1 then force creation of a new node*/\n\t\t\tif (gf_bt_has_been_def(parser, name)) {\n\t\t\t\tundef_node = NULL;\n\t\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t\t\tgf_bt_report(parser, GF_OK, \"Node %s has been DEFed several times, IDs may get corrupted\", name);\n\t\t\t}\n\t\t} else {\n\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t}\n\t}\n\telse if (!strcmp(str, \"USE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tnode = gf_sg_find_node_by_name(parser->load->scene_graph, str);\n\t\tif (!node) {\n\t\t\t/*create a temp node (undefined)*/\n\t\t\tnode = gf_node_new(parser->load->scene_graph, TAG_UndefinedNode);\n\t\t\tID = gf_bt_get_def_id(parser, str);\n\t\t\tgf_node_set_id(node, ID, str);\n\t\t\tgf_node_register(node, NULL);\n\t\t\tgf_list_add(parser->undef_nodes, node);\n\t\t}\n\t\tgf_node_register(node, parent);\n\t\treturn node;\n\t}\n\tproto = NULL;\n\ttag = gf_bt_get_node_tag(parser, str);\n\tif (!tag) {\n\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\twhile (1) {\n\t\t\tproto = gf_sg_find_proto(sg, 0, str);\n\t\t\tif (proto) break;\n\t\t\tsg = sg->parent_scene;\n\t\t\tif (!sg) break;\n\t\t}\n\t\tif (!proto) {\n\t\t\t/*locate proto*/\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\treturn NULL;\n\t\t}\n\t\ttag = TAG_ProtoNode;\n\t}\n\tif (undef_node && (undef_node->sgprivate->tag == tag)) {\n\t\tnode = undef_node;\n\t} else {\n\t\tif (undef_node) replace_prev = 1;\n\t\tif (proto) {\n\t\t\tnode = gf_sg_proto_create_instance(parser->load->scene_graph, proto);\n\t\t} else {\n\t\t\tnode = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tif (!parser->parsing_proto) init_node = 1;\n\t}\n\tis_script = 0;\n\tif ((tag==TAG_MPEG4_Script)\n#ifndef GPAC_DISABLE_X3D\n\t        || (tag==TAG_X3D_Script)\n#endif\n\t   )\n\t\tis_script = 1;\n\n\tif (!node) {\n\t\tparser->last_error = GF_SG_UNKNOWN_NODE;\n\t\treturn NULL;\n\t}\n\tif (register_def) gf_list_add(parser->def_nodes, node);\n\n\tgf_node_register(node, parent);\n\n\t/*VRML: \"The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node\n\tin the transformation hierarchy is its own ancestor\"\n\tthat's good, because the scene graph can't handle cyclic graphs (destroy will never be called).\n\tHowever we still have to register the node before parsing it, to update node registry and get correct IDs*/\n\tif (name) {\n\t\tif (!undef_node || replace_prev) {\n\t\t\tgf_node_set_id(node, ID, name);\n\t\t}\n\t\tgf_free(name);\n\t\tname = NULL;\n\t}\n\tif (!parser->parsing_proto) gf_bt_update_timenode(parser, node);\n\n\tif (gf_bt_check_code(parser, '{')) {\n\n\t\twhile (1) {\n\t\t\tif (gf_bt_check_code(parser, '}'))\n\t\t\t\tbreak;\n\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!str) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid node syntax\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t/*VRML/X3D specific */\n\t\t\tif (parser->is_wrl) {\n\t\t\t\t/*we ignore bboxCenter and bboxSize*/\n\t\t\t\tif (!strcmp(str, \"bboxCenter\") || !strcmp(str, \"bboxSize\")) {\n\t\t\t\t\tFixed f;\n\t\t\t\t\tgf_bt_parse_float(parser, \"x\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"y\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"z\", &f);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*some VRML files declare routes almost anywhere*/\n\t\t\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\t\t\tgf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t/*check common VRML fields removed in MPEG4*/\n\t\t\tif (parser->last_error) {\n\t\t\t\tif (!parser->is_wrl) {\n\t\t\t\t\t/*we ignore 'solid' for MPEG4 box/cone/etc*/\n\t\t\t\t\tif (!strcmp(str, \"solid\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"solid\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*we ignore 'description' for MPEG4 sensors*/\n\t\t\t\t\telse if (!strcmp(str, \"description\")) {\n\t\t\t\t\t\tchar *tmpstr = gf_bt_get_string(parser, 0);\n\t\t\t\t\t\tgf_free(tmpstr);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*remaps X3D to old VRML/MPEG4*/\n\t\t\t\t\telse if ((tag==TAG_MPEG4_LOD) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"level\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_MPEG4_Switch) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"choice\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(str, \"enabled\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"collide\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*remaps old VRML/MPEG4 to X3D if possible*/\n#ifndef GPAC_DISABLE_X3D\n\t\t\t\t\tif ((tag==TAG_X3D_LOD) && !strcmp(str, \"level\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_X3D_Switch) && !strcmp(str, \"choice\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tif (!strcmp(str, \"collide\")) {\n\t\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\t\tgf_bt_parse_bool(parser, \"enabled\", &b);\n\t\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_script && parser->last_error) {\n\t\t\t\tu32 eType, fType;\n\n\t\t\t\tif (!strcmp(str, \"eventIn\") || !strcmp(str, \"inputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_IN;\n\t\t\t\telse if (!strcmp(str, \"eventOut\") || !strcmp(str, \"outputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_OUT;\n\t\t\t\telse if (!strcmp(str, \"field\") || !strcmp(str, \"initializeOnly\")) eType = GF_SG_SCRIPT_TYPE_FIELD;\n\t\t\t\telse {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script event type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tfType = gf_sg_field_type_by_name(str);\n\t\t\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script field type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_sg_script_field_new(node, eType, fType, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\t\t\t\tif ((eType == GF_SG_SCRIPT_TYPE_EVENT_IN) || (eType == GF_SG_SCRIPT_TYPE_EVENT_OUT)) continue;\n\t\t\t}\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, parser->last_error, \"%s: Unknown field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (proto) gf_sg_proto_mark_field_loaded(node, &info);\n\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (* ((GF_Node **)info.far_ptr) ) {\n\t\t\t\t\tgf_node_unregister(* ((GF_Node **)info.far_ptr), node);\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = NULL;\n\t\t\t\t}\n\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\tif (newnode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = newnode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tBool single_child = 0;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tif (parser->is_wrl) single_child = 1;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (undef_node==node) {\n\t\t\t\t\tgf_node_unregister_children(node, *(GF_ChildNodeItem **)info.far_ptr);\n\t\t\t\t\t*(GF_ChildNodeItem **)info.far_ptr = NULL;\n\t\t\t\t}\n\n\t\t\t\twhile (single_child || !gf_bt_check_code(parser, ']')) {\n\t\t\t\t\t/*VRML seems to allow that*/\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\t\tif (newnode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\t\t\t\t\t\tgf_node_list_add_child_last( (GF_ChildNodeItem **)info.far_ptr, newnode, &last);\n\t\t\t\t\t}\n\t\t\t\t\tif (single_child) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, node);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, node);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*VRML seems to allow that*/\n\t\t\tgf_bt_check_code(parser, ',');\n\t\t}\n\t}\n\t/*VRML seems to allow that*/\n\tgf_bt_check_code(parser, ',');\n\n\t/*we must init the node once ID is set in case we're creating rendering stacks*/\n\tif (init_node && (gf_node_get_tag(node)!=TAG_ProtoNode) ) gf_node_init(node);\n\n\t/*remove temp node*/\n\tif (replace_prev) {\n\t\tgf_node_replace(undef_node, node, 0);\n\t\tgf_node_unregister(undef_node, NULL);\n\t\tgf_list_del_item(parser->undef_nodes, undef_node);\n\t}\n\n\tif (!parser->parsing_proto && is_script && (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) ) {\n\t\tif (parser->cur_com) {\n\t\t\tif (!parser->cur_com->scripts_to_load) parser->cur_com->scripts_to_load = gf_list_new();\n\t\t\tgf_list_add(parser->cur_com->scripts_to_load, node);\n\t\t} else {\n\t\t\t/*postpone script init since it may use routes/nodes not yet defined ...*/\n\t\t\tgf_list_add(parser->scripts, node);\n\t\t}\n\t}\n\t/*For Ivica: load proto as soon as found when in playback mode*/\n\tif ( (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) && proto && !parser->parsing_proto) {\n\t\tparser->last_error = gf_sg_proto_load_code(node);\n\t}\n\treturn node;\n\nerr:\n\tgf_node_unregister(node, parent);\n\tif (name) gf_free(name);\n\treturn NULL;\n}\n/*\n\tlocate node, if not defined yet parse ahead in current AU\n\toptimization: we actually peek ALL DEF NODES till end of AU\n*/\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID)\n{\n\tGF_Node *n, *the_node;\n\tu32 tag, ID;\n\tBool prev_is_insert = 0;\n\tchar *ret;\n\tchar nName[1000];\n\tu32 pos, line, line_pos, i, count;\n\n\tn = gf_sg_find_node_by_name(parser->load->scene_graph, defID);\n\tif (n) return n;\n\n\tcount = gf_list_count(parser->peeked_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tn = (GF_Node *)gf_list_get(parser->peeked_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), defID)) return n;\n\t}\n\n\tthe_node = NULL;\n\tpos = parser->line_start_pos;\n\tline_pos = parser->line_pos;\n\tline = parser->line;\n\tstrcpy(nName, defID);\n\n\tn = NULL;\n\twhile (!parser->done && !the_node) {\n\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\tgf_bt_check_code(parser, '[');\n\t\tgf_bt_check_code(parser, ']');\n\t\tgf_bt_check_code(parser, '{');\n\t\tgf_bt_check_code(parser, '}');\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_check_code(parser, '.');\n\n\t\tif ( (!prev_is_insert && !strcmp(str, \"AT\")) || !strcmp(str, \"PROTO\") ) {\n\t\t\t/*only check in current command (but be aware of conditionals..)*/\n\t\t\tif (gf_list_find(parser->bifs_au->commands, parser->cur_com)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(str, \"INSERT\")) prev_is_insert = 1;\n\t\telse prev_is_insert = 0;\n\n\t\tif (strcmp(str, \"DEF\")) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tret = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tgf_free(ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag = gf_bt_get_node_tag(parser, str);\n\t\tif (!tag) {\n\t\t\tGF_Proto *p;\n\t\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\t\twhile (1) {\n\t\t\t\tp = gf_sg_find_proto(sg, 0, str);\n\t\t\t\tif (p) break;\n\t\t\t\tsg = sg->parent_scene;\n\t\t\t\tif (!sg) break;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\t/*locate proto*/\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\t\tgf_free(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tn = gf_sg_proto_create_instance(parser->load->scene_graph, p);\n\t\t} else {\n\t\t\tn = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tID = gf_bt_get_def_id(parser, ret);\n\t\tif (n) {\n\t\t\tgf_node_set_id(n, ID, ret);\n\t\t\tgf_list_add(parser->peeked_nodes, n);\n\t\t\tif (!parser->parsing_proto) gf_node_init(n);\n\t\t\tif (!strcmp(ret, nName)) the_node = n;\n\t\t}\n\t\tgf_free(ret);\n\n\t\t/*NO REGISTER on peek (both scene graph or DEF list) because peek is only used to get node type\n\t\tand fields, never to insert in the graph*/\n\n\t\t/*go on till end of AU*/\n\t}\n\t/*restore context*/\n\tparser->done = 0;\n\tgf_gzrewind(parser->gz_in);\n\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n\tparser->line_pos = parser->line_size;\n\tgf_bt_check_line(parser);\n\tparser->line = line;\n\tparser->line_pos = line_pos;\n\n\treturn the_node;\n}\n\nu32 gf_bt_get_route(GF_BTParser *parser, char *name)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find_by_name(parser->load->scene_graph, name);\n\tif (r) return r->ID;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->def_name && !strcmp(com->def_name, name)) return com->RouteID;\n\t}\n\treturn 0;\n}\n\nBool gf_bt_route_id_used(GF_BTParser *parser, u32 ID)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find(parser->load->scene_graph, ID);\n\tif (r) return 1;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->RouteID == ID) return 1;\n\t}\n\treturn 0;\n}\n\nstatic u32 get_evt_type(char *eventName)\n{\n\tif (!strcmp(eventName, \"eventIn\") || !strcmp(eventName, \"inputOnly\")) return GF_SG_EVENT_IN;\n\telse if (!strcmp(eventName, \"eventOut\") || !strcmp(eventName, \"outputOnly\")) return GF_SG_EVENT_OUT;\n\telse if (!strcmp(eventName, \"field\") || !strcmp(eventName, \"initializeOnly\")) return GF_SG_EVENT_FIELD;\n\telse if (!strcmp(eventName, \"exposedField\") || !strcmp(eventName, \"inputOutput\")) return GF_SG_EVENT_EXPOSED_FIELD;\n\telse return GF_SG_EVENT_UNKNOWN;\n}\n\nGF_Err gf_bt_parse_proto(GF_BTParser *parser, char *proto_code, GF_List *proto_list)\n{\n\tGF_FieldInfo info;\n\tu32 fType, eType, QPType=0, pID;\n\tBool externProto;\n\tGF_Proto *proto, *prevproto;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_SceneGraph *sg;\n\tchar *str, *name;\n\tchar szDefName[1024];\n\tBool isDEF;\n\n\tif (proto_code)\n\t\tstr = proto_code;\n\telse\n\t\tstr = gf_bt_get_next(parser, 0);\n\n\texternProto = !strcmp(str, \"EXTERNPROTO\") ? 1 : 0;\n\tstr = gf_bt_get_next(parser, 0);\n\tname = gf_strdup(str);\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected in proto declare\");\n\t}\n\tpID = gf_bt_get_next_proto_id(parser);\n\t/*if redefinition remove it - WRL only, may be used by loadVRMLFormString*/\n\tif (!proto_list && parser->is_wrl) {\n\t\tproto = gf_sg_find_proto(parser->load->scene_graph, pID, name);\n\t\tif (proto) gf_sg_proto_del(proto);\n\t}\n\tproto = gf_sg_proto_new(parser->load->scene_graph, pID, name, proto_list ? 1 : 0);\n\tif (proto_list) gf_list_add(proto_list, proto);\n\tif (parser->load->ctx && (parser->load->ctx->max_proto_id<pID)) parser->load->ctx->max_proto_id = pID;\n\n\t/*hack for VRML, where externProto default field values are not mandatory*/\n\tparser->is_extern_proto_field = externProto;\n\n\tgf_free(name);\n\t/*get all fields*/\n\twhile (!parser->last_error && !gf_bt_check_code(parser, ']')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\nnext_field:\n\t\tif (gf_bt_check_code(parser, ']')) break;\n\n\t\teType = get_evt_type(str);\n\t\tif (eType==GF_SG_EVENT_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown event type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tfType = gf_sg_field_type_by_name(str);\n\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tpfield = gf_sg_proto_field_new(proto, fType, eType, str);\n\t\tif ((eType==GF_SG_EVENT_IN) || (eType==GF_SG_EVENT_OUT)) continue;\n\n\t\tgf_sg_proto_field_get_field(pfield, &info);\n\t\tif (fType==GF_SG_VRML_SFNODE) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"NULL\")) {\n\t\t\t\tif ( (!strlen(str) || (get_evt_type(str)!=GF_SG_EVENT_UNKNOWN)) && parser->is_extern_proto_field) goto next_field;\n\t\t\t\tpfield->def_sfnode_value = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\t}\n\t\t} else if (fType==GF_SG_VRML_MFNODE) {\n\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tGF_Node *pf_node;\n\t\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\t\tpf_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (pf_node) gf_node_list_add_child_last( &pfield->def_mfnode_value, pf_node, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (gf_sg_vrml_is_sf_field(fType)) {\n\t\t\tgf_bt_sffield(parser, &info, NULL);\n\t\t\t/*value not specified for externproto*/\n\t\t\tif (parser->last_error==GF_EOS) {\n\t\t\t\tparser->last_error=GF_OK;\n\t\t\t\tgoto next_field;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bt_mffield(parser, &info, NULL);\n\t\t}\n\t\t/*check QP info*/\n\t\tif (!gf_bt_check_code(parser, '{')) continue;\n\t\tif (gf_bt_check_code(parser, '}')) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"QP\")) {\n\t\t\tu32 nbBits, hasMin;\n\t\t\tFixed ftMin, ftMax;\n\t\t\tgf_bt_parse_int(parser, \"QPType\", (SFInt32*)&QPType);\n\n\t\t\tnbBits = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!strcmp(str, \"nbBits\")) {\n\t\t\t\tgf_bt_parse_int(parser, \"nbBits\", (SFInt32*)&nbBits);\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\thasMin = 0;\n\t\t\teType = 0;\n\t\t\tif (!strcmp(str, \"b\")) {\n\t\t\t\thasMin = 1;\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid proto coding parameter declare\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tgf_bt_parse_float(parser, \"min\", &ftMin);\n\t\t\t\tgf_bt_parse_float(parser, \"max\", &ftMax);\n\t\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (gf_sg_vrml_get_sf_type(fType) == GF_SG_VRML_SFINT32) {\n\t\t\t\t\teType = GF_SG_VRML_SFINT32;\n\t\t\t\t} else {\n\t\t\t\t\teType = GF_SG_VRML_SFFLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bifs_proto_field_set_aq_info(pfield, QPType, hasMin, eType, &ftMin, &ftMax, nbBits);\n\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\tparser->is_extern_proto_field = 0;\n\n\tif (externProto) {\n\t\tSFURL *url;\n\t\tBool has_urls = 0;\n\t\tif (gf_bt_check_code(parser, '[')) has_urls = 1;\n\n\t\tgf_sg_vrml_mf_reset(&proto->ExternProto, GF_SG_VRML_MFURL);\n\t\tdo {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tgf_sg_vrml_mf_append(&proto->ExternProto, GF_SG_VRML_MFURL, (void **) &url);\n\t\t\tif (!strnicmp(str, \"od:\", 3)) {\n\t\t\t\tsscanf(str, \"od:%u\", &url->OD_ID);\n\t\t\t} else {\n\t\t\t\tif (!sscanf(str, \"%u\", &url->OD_ID)) {\n\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t} else {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%d\", url->OD_ID);\n\t\t\t\t\tif (strcmp(szURL, str)) {\n\t\t\t\t\t\turl->OD_ID = 0;\n\t\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_urls) {\n\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\tif (gf_bt_check_code(parser, ']')) has_urls = 0;\n\t\t\t}\n\t\t} while (has_urls);\n\t\treturn GF_OK;\n\t}\n\n\t/*parse proto code */\n\tif (!gf_bt_check_code(parser, '{')) {\n\t\tgf_bt_report(parser, GF_OK, \"empty proto body\");\n\t\treturn GF_OK;\n\t}\n\n\tprevproto = parser->parsing_proto;\n\tsg = parser->load->scene_graph;\n\tparser->parsing_proto = proto;\n\tparser->load->scene_graph = gf_sg_proto_get_graph(proto);\n\n\tisDEF = 0;\n\twhile (!gf_bt_check_code(parser, '}')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, NULL);\n\t\t} else if (!strcmp(str, \"DEF\")) {\n\t\t\tisDEF = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDefName, str);\n\t\t} else if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Route *r = gf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\tif (isDEF) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDefName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tparser->last_error = gf_sg_route_set_id(r, rID);\n\t\t\t\tgf_sg_route_set_name(r, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_Node *n = gf_bt_sf_node(parser, str, NULL, isDEF ? szDefName : NULL);\n\t\t\tisDEF = 0;\n\t\t\tif (!n) goto err;\n\t\t\tif ((0) && isDEF) {\n\t\t\t\tu32 ID = gf_bt_get_def_id(parser, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t\tgf_node_set_id(n, ID, szDefName);\n\t\t\t}\n\t\t\tgf_sg_proto_add_node_code(proto, n);\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 1);\n\tgf_bt_check_unresolved_nodes(parser);\n\tparser->load->scene_graph = sg;\n\tparser->parsing_proto = prevproto;\n\treturn parser->last_error;\n\nerr:\n\tif (proto_list) gf_list_del_item(proto_list, proto);\n\tgf_sg_proto_del(proto);\n\treturn parser->last_error;\n}\n\n\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com)\n{\n\tGF_Route *r;\n\tchar *str, nstr[1000], rName[1000];\n\tu32 rID;\n\tGF_Node *orig, *dest;\n\tGF_FieldInfo orig_field, dest_field;\n\tGF_Err e;\n\n\trID = 0;\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tif (!skip_def && !strcmp(nstr, \"DEF\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(rName, str);\n\t\trID = gf_bt_get_route(parser, rName);\n\t\tif (!rID && (str[0]=='R') ) {\n\t\t\trID = atoi(&str[1]);\n\t\t\tif (rID) {\n\t\t\t\trID++;\n\t\t\t\tif (gf_bt_route_id_used(parser, rID)) rID = 0;\n\t\t\t}\n\t\t}\n\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\t}\n\torig = gf_bt_peek_node(parser, nstr);\n\tif (!orig) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(orig, &str[4], &orig_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(orig), gf_node_get_class_name(orig));\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\tif (strcmp(str, \"TO\")) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"TO expected in route declaration - got \\\"%s\\\"\", str);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tdest = gf_bt_peek_node(parser, nstr);\n\tif (!dest) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(dest, &str[4], &dest_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(dest), gf_node_get_class_name(dest));\n\t\treturn NULL;\n\t}\n\tif (com) {\n\t\tcom->fromNodeID = gf_node_get_id(orig);\n\t\tcom->fromFieldIndex = orig_field.fieldIndex;\n\t\tcom->toNodeID = gf_node_get_id(dest);\n\t\tcom->toFieldIndex = dest_field.fieldIndex;\n\t\tif (rID) {\n\t\t\tcom->RouteID = rID;\n\t\t\tcom->def_name = gf_strdup(rName);\n\t\t\t/*whenever inserting routes, keep track of max defined ID*/\n\t\t\tif (is_insert) {\n\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\tif (parser->load->ctx && (rID>parser->load->ctx->max_route_id))\n\t\t\t\t\tparser->load->ctx->max_route_id = rID;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\tr = gf_sg_route_new(parser->load->scene_graph, orig, orig_field.fieldIndex, dest, dest_field.fieldIndex);\n\tif (r && rID) {\n\t\tgf_sg_route_set_id(r, rID);\n\t\tgf_sg_route_set_name(r, rName);\n\t}\n\treturn r;\n}\n\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean)\n{\n\t/*resolve all commands*/\n\twhile(gf_list_count(parser->unresolved_routes) ) {\n\t\tGF_Command *com = (GF_Command *)gf_list_get(parser->unresolved_routes, 0);\n\t\tgf_list_rem(parser->unresolved_routes, 0);\n\t\tswitch (com->tag) {\n\t\tcase GF_SG_ROUTE_DELETE:\n\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\tcom->RouteID = gf_bt_get_route(parser, com->unres_name);\n\t\t\tif (!com->RouteID) gf_bt_report(parser, GF_BAD_PARAM, \"Cannot resolve Route %s\", com->unres_name);\n\t\t\tgf_free(com->unres_name);\n\t\t\tcom->unres_name = NULL;\n\t\t\tcom->unresolved = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!clean) return;\n\twhile (gf_list_count(parser->inserted_routes)) gf_list_rem(parser->inserted_routes, 0);\n}\n\n\nstatic void bd_set_com_node(GF_Command *com, GF_Node *node)\n{\n\tcom->node = node;\n\tgf_node_register(com->node, NULL);\n}\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList)\n{\n\ts32 pos;\n\tGF_Route *r;\n\tGF_Node *n, *newnode;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tGF_FieldInfo info;\n\tchar *str, field[1000];\n\tif (!name) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else {\n\t\tstr = name;\n\t}\n\tcom = NULL;\n\tpos = -2;\n\t/*REPLACE commands*/\n\tif (!strcmp(str, \"REPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tr = gf_sg_route_find_by_name(parser->load->scene_graph, str);\n\t\t\tif (!r) strcpy(field, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_REPLACE);\n\t\t\tif (r) {\n\t\t\t\tcom->RouteID = r->ID;\n\t\t\t} else {\n\t\t\t\tcom->unres_name = gf_strdup(field);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\tgf_bt_parse_route(parser, 1, 0, com);\n\t\t\tgf_list_add(cmdList, com);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*scene replace*/\n\t\tif (!strcmp(str, \"SCENE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tgf_bt_resolve_routes(parser, 1);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\twhile (gf_list_count(parser->def_nodes)) gf_list_rem(parser->def_nodes, 0);\n\n\t\t\twhile (1) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\t\t\tgf_bt_parse_proto(parser, str, com->new_proto_list);\n\t\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\tcom->node = n;\n\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\telse if (!strcmp(str, \"BEGIN\")) pos = 0;\n\n\t\tgf_bt_check_code(parser, '.');\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tif ( (parser->last_error = gf_bt_parse_int(parser, \"index\", &pos)) ) return parser->last_error;\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t}\n\t\t/*node replace*/\n\t\tif (!strcmp(field, \"BY\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\tparser->last_error = gf_node_get_field_by_name(n, field, &info);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t/*field replace*/\n\t\tif (pos==-2) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\tinf->new_node = newnode;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(info.fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*indexed field replace*/\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*XREPLACE commands*/\n\tif (!strcmp(str, \"XREPLACE\")) {\n\t\tu32 j;\n\t\tBool force_sf=0;\n\t\tchar csep;\n\t\tGF_Node *targetNode, *idxNode, *childNode, *fromNode;\n\t\tGF_FieldInfo targetField, idxField, childField, fromField;\n\n\t\tidxNode = childNode = fromNode = NULL;\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\t/*get source node*/\n\t\tstrcpy(field, str);\n\t\ttargetNode = gf_bt_peek_node(parser, str);\n\t\tif (!targetNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t}\n\t\t/*get source field*/\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tparser->last_error = gf_node_get_field_by_name(targetNode, field, &targetField);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tpos = -2;\n\t\t\tstr = gf_bt_get_next(parser, 1);\n\t\t\tforce_sf = 1;\n\t\t\tif (sscanf(str, \"%d\", &pos) != 1) {\n\t\t\t\tpos = -2;\n\t\t\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\t\t\telse if (!strcmp(str, \"first\")) pos = 0;\n\t\t\t\telse {\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\t/*get idx node*/\n\t\t\t\t\tidxNode = gf_bt_peek_node(parser, str);\n\t\t\t\t\tif (!idxNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\t\t\t\tif (!gf_bt_check_code(parser, '.'))\n\t\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\n\t\t\t\t\t/*get idx field*/\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(idxNode, field, &idxField);\n\t\t\t\t\tif (parser->last_error)\n\t\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bt_check_code(parser, ']');\n\n\t\t\t/*check if we have a child node*/\n\t\t\tif (gf_bt_check_code(parser, '.')) {\n\t\t\t\ts32 apos = pos;\n\t\t\t\tforce_sf = 0;\n\t\t\t\tif (idxNode) {\n\t\t\t\t\tapos = 0;\n\t\t\t\t\tswitch (idxField.fieldType) {\n\t\t\t\t\tcase GF_SG_VRML_SFBOOL:\n\t\t\t\t\t\tif (*(SFBool*)idxField.far_ptr) apos = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t\t\tif (*(SFInt32*)idxField.far_ptr >=0) apos = *(SFInt32*)idxField.far_ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFFLOAT:\n\t\t\t\t\t\tif ( (*(SFFloat *)idxField.far_ptr) >=0) apos = (s32) floor( FIX2FLT(*(SFFloat*)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t\t\tif ( (*(SFTime *)idxField.far_ptr) >=0) apos = (s32) floor( (*(SFTime *)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchildNode = gf_node_list_get_child(*(GF_ChildNodeItem **)targetField.far_ptr, apos);\n\t\t\t\tif (!childNode)\n\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Cannot find child node at specified index\");\n\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tstrcpy(field, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(childNode, field, &childField);\n\t\t\t\tif (parser->last_error)\n\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t}\n\t\t}\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\t/*peek the next word*/\n\t\tj = 0;\n\t\twhile (strchr(\" \\n\\t\\0\", parser->line_buffer[parser->line_pos + j])) j++;\n\t\tstr = parser->line_buffer + parser->line_pos + j;\n\t\tj = 0;\n\t\twhile (!strchr(\" .\\0\", str[j])) j++;\n\t\tcsep = str[j];\n\t\tstr[j]=0;\n\t\tstrcpy(field, str);\n\t\tstr[j] = csep;\n\t\tfromNode = gf_bt_peek_node(parser, field);\n\t\tif (fromNode) {\n\t\t\tgf_bt_get_next(parser, 1);\n\n\t\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t\t}\n\t\t\t/*get source field*/\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t\tparser->last_error = gf_node_get_field_by_name(fromNode, field, &fromField);\n\t\t\tif (parser->last_error)\n\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t} else {\n\t\t\t/*regular parsing*/\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_XREPLACE);\n\t\tbd_set_com_node(com, targetNode);\n\t\tif (fromNode) {\n\t\t\tcom->fromNodeID = gf_node_get_id(fromNode);\n\t\t\tcom->fromFieldIndex = fromField.fieldIndex;\n\t\t}\n\t\tif (idxNode) {\n\t\t\tcom->toNodeID = gf_node_get_id(idxNode);\n\t\t\tcom->toFieldIndex = idxField.fieldIndex;\n\t\t}\n\t\tif (childNode) {\n\t\t\tcom->ChildNodeTag = gf_node_get_tag(childNode);\n\t\t\tif (com->ChildNodeTag==1) {\n\t\t\t\tcom->ChildNodeTag = ((GF_ProtoInstance*)childNode)->proto_interface->ID;\n\t\t\t\tcom->ChildNodeTag = -com->ChildNodeTag ;\n\t\t\t}\n\t\t\tcom->child_field = childField.fieldIndex;\n\t\t}\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = targetField.fieldIndex;\n\t\tinf->pos = pos;\n\t\tif (force_sf) {\n\t\t\tinf->fieldType = gf_sg_vrml_get_sf_type(targetField.fieldType);\n\t\t} else if (childNode) {\n\t\t\tinf->fieldType = childField.fieldType;\n\t\t} else {\n\t\t\tinf->fieldType = targetField.fieldType;\n\t\t}\n\t\tif (!fromNode) {\n\t\t\tswitch (inf->fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tif (childNode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\n\t\t\t\t\tif (childNode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\t\tinfo.name = targetField.name;\n\n\t\t\t\tif (gf_sg_vrml_is_sf_field(inf->fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\n\n\t/*INSERT commands*/\n\tif (!strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\")) {\n\t\tBool is_append = !strcmp(str, \"APPEND\") ? 1 : 0;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\tgf_bt_parse_route(parser, 0, 1, com);\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (strcmp(str, \"AT\") && strcmp(str, \"TO\")) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, (char*) (is_append ? \"TO expected got %s\" : \"AT expected got %s\"), str);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tif (!is_append) {\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ unexpected in Append command\");\n\t\t\t}\n\t\t\tpos = -1;\n\t\t}\n\t\tgf_node_get_field_by_name(n, field, &info);\n\t\tif (!strcmp(field, \"children\")) {\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (parser->last_error) goto err;\n\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_INSERT);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->pos = pos;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tif (parser->last_error) goto err;\n\t\t\tparser->cur_com = com;\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_INSERT);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*DELETE commands*/\n\tif (!strcmp(str, \"DELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_DELETE);\n\t\t\tcom->RouteID = gf_bt_get_route(parser, str);\n\t\t\tif (!com->RouteID) {\n\t\t\t\tcom->unres_name = gf_strdup(str);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\t/*for bt<->xmt conversions*/\n\t\t\tcom->def_name = gf_strdup(str);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"DELETE %s: Unknown Node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (gf_node_get_field_by_name(n, str, &info) != GF_OK) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s\", str, gf_node_get_class_name(n) );\n\t\t}\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tif (info.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\t\tbd_set_com_node(com, n);\n\t\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\t\tinf->fieldType = info.fieldType;\n\t\t\t\tinf->new_node = NULL;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\treturn gf_list_add(cmdList, com);\n\t\t\t}\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s is an SFField - cannot indexed delete\", info.name);\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_DELETE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = info.fieldType;\n\t\tinf->pos = pos;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\t/*Extended BIFS commands*/\n\n\t/*GlobalQP commands*/\n\tif (!strcmp(str, \"GLOBALQP\")) {\n\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\tif (newnode && (newnode->sgprivate->tag != TAG_MPEG4_QuantizationParameter)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Only QuantizationParameter node allowed in GLOBALQP\");\n\t\t\tgf_node_unregister(newnode, NULL);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_GLOBAL_QUANTIZER);\n\t\tcom->node = NULL;\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->new_node = newnode;\n\t\tinf->field_ptr = &inf->new_node;\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_REPLACE);\n\t\tbd_set_com_node(com, n);\n\n\t\twhile (!gf_bt_check_code(parser, '}')) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = -1;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last( & inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleIndexReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEINDREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\tif (parser->last_error) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field\", info.name);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Only MF field allowed\");\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinfo.fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tpos=0;\n\t\t\tif (gf_bt_parse_int(parser, \"position\", (SFInt32 *)&pos)) goto err;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"BY expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = pos;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t} else {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"XDELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown Node\", field);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE_EX);\n\t\tbd_set_com_node(com, n);\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"INSERTPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_INSERT);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tparser->last_error = gf_bt_parse_proto(parser, NULL, com->new_proto_list);\n\t\t\tif (parser->last_error) goto err;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\tif (!strcmp(str, \"DELETEPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE_ALL);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"ALL\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ALL expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tGF_Proto *proto;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tproto = gf_sg_find_proto(parser->load->scene_graph, 0, str);\n\t\t\tif (!proto) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32)*(com->del_proto_list_size+1));\n\t\t\tcom->del_proto_list[com->del_proto_list_size] = proto->ID;\n\t\t\tcom->del_proto_list_size++;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown command syntax, str\");\n\nerr:\n\tif (com) gf_sg_command_del(com);\n\treturn parser->last_error;\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name);\n\n#ifndef GPAC_MINIMAL_ODF\nGF_IPMPX_Data *gf_bt_parse_ipmpx(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_IPMPX_Data *desc, *subdesc;\n\tGF_Descriptor *oddesc;\n\tGF_Err e;\n\tu32 type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_ipmpx_get_tag(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown IPMPX Data\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_ipmpx_data_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\ttype = gf_ipmpx_get_field_type(desc, str);\n\t\tswitch (type) {\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tassert(desc->tag==GF_IPMPX_CONNECT_TOOL_TAG);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\toddesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!oddesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tassert(oddesc->tag==GF_ODF_IPMP_TAG);\n\t\t\t((GF_IPMPX_ConnectTool *)desc)->toolDescriptor = (GF_IPMP_Descriptor *)oddesc;\n\t\t\tbreak;\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tassert(desc->tag==GF_IPMPX_GET_TOOLS_RESPONSE_TAG);\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_Descriptor *ipmp_t = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!ipmp_t) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tassert(ipmp_t->tag==GF_ODF_IPMP_TOOL_TAG);\n\t\t\t\t\tgf_list_add( ((GF_IPMPX_GetToolsResponse *)desc)->ipmp_tools, ipmp_t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*IPMPX ByteArray list*/\n\t\tcase GF_ODF_FT_IPMPX_BA_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tif (!str) continue;\n\t\t\t\t\tif (gf_ipmpx_set_byte_array(desc, field, str) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX ByteArray: check if declared as sub-data or not*/\n\t\tcase GF_ODF_FT_IPMPX_BA:\n\t\t\tstr = NULL;\n\t\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (stricmp(str, \"array\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP ByteArray syntax is %s { array \\\"...\\\" } or %s \\\"....\\\"\\n\", field, field);\n\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\t} else {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\te = gf_ipmpx_set_byte_array(desc, field, str);\n\t\t\tif (e) {\n\t\t\t\tgf_bt_report(parser, e, \"Error assigning IPMP ByteArray %s\\n\", field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX Data list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*regular IPMPX Data*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown ipmpx %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx in field %s - skipping\", field);\n\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_ipmpx_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn desc;\n}\n#endif\n\nstatic void gf_bt_add_desc(GF_BTParser *parser, GF_Descriptor *par, GF_Descriptor *child, char *fieldName)\n{\n\tGF_Err e = gf_odf_desc_add_desc(par, child);\n\tif (e) {\n\t\tgf_bt_report(parser, GF_OK, \"Invalid child descriptor in field %s - skipping\", fieldName);\n\t\tgf_odf_desc_del(child);\n\t}\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_Descriptor *desc, *subdesc;\n\tGF_ODF_FieldType type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_odf_get_tag_by_name(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown descriptor\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_odf_desc_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\tBool is_anim_mask = 0;\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\n\t\tif ((tag==GF_ODF_BIFS_CFG_TAG) && !strcmp(field, \"animationMask\")) {\n\t\t\tgf_bt_get_next(parser, 0);\n\t\t\tif (gf_bt_check_code(parser, '{')) is_anim_mask = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t}\n\n\t\ttype = gf_odf_get_field_type(desc, str);\n\t\tswitch (type) {\n#ifndef GPAC_MINIMAL_ODF\n\t\t/*IPMPX list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data list only allowed in GF_IPMP_Descriptor\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_add( ((GF_IPMP_Descriptor *)desc)->ipmpx_data, ipmpx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TOOL_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data only allowed in GF_IPMP_Tool\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (ipmpx->tag==GF_IPMPX_PARAMETRIC_DESCRIPTION_TAG) {\n\t\t\t\t\t\tGF_IPMP_Tool *it = (GF_IPMP_Tool *)desc;\n\t\t\t\t\t\tif (it->toolParamDesc) gf_ipmpx_data_del((GF_IPMPX_Data *)it->toolParamDesc);\n\t\t\t\t\t\tit->toolParamDesc = (GF_IPMPX_ParametricDescription*)ipmpx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Only ToolParametricDescription allowed in GF_IPMP_Tool - skipping\");\n\t\t\t\t\t\tgf_ipmpx_data_del(ipmpx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_anim_mask)\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\tbreak;\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\tbreak;\n\t\t/*regular field*/\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_odf_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (desc->tag == GF_ODF_BIFS_CFG_TAG) {\n\t\tGF_BIFSConfig *bcfg = (GF_BIFSConfig *)desc;\n\t\tif (!parser->load->ctx->scene_width) {\n\t\t\tparser->load->ctx->scene_width = bcfg->pixelWidth;\n\t\t\tparser->load->ctx->scene_height = bcfg->pixelHeight;\n\t\t\tparser->load->ctx->is_pixel_metrics = bcfg->pixelMetrics;\n\t\t}\n\n\t\t/*for bt->xmt*/\n\t\tif (!bcfg->version) bcfg->version = 1;\n\t}\n\telse if (desc->tag==GF_ODF_ESD_TAG) {\n\t\tGF_ESD *esd  =(GF_ESD*)desc;\n\t\tif (esd->decoderConfig) {\n\t\t\tGF_StreamContext *sc=NULL;\n\t\t\tGF_MuxInfo *mux;\n\t\t\t/*watchout for default BIFS stream*/\n\t\t\tif (parser->bifs_es && !parser->base_bifs_id && (esd->decoderConfig->streamType==GF_STREAM_SCENE)) {\n\t\t\t\tparser->bifs_es->ESID = parser->base_bifs_id = esd->ESID;\n\t\t\t\tparser->bifs_es->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\tsc = parser->bifs_es;\n\t\t\t} else {\n\t\t\t\tsc = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t/*set default timescale for systems tracks (ignored for other)*/\n\t\t\t\tif (sc) sc->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\t/*assign base OD*/\n\t\t\t\tif (!parser->base_od_id && (esd->decoderConfig->streamType==GF_STREAM_OD)) parser->base_od_id = esd->ESID;\n\t\t\t}\n\t\t\t/*assign broadcast parameter tools*/\n\t\t\tmux = gf_sm_get_mux_info(esd);\n\t\t\tif (sc && mux) {\n\t\t\t\tsc->aggregate_on_esid = mux->aggregate_on_esid;\n\t\t\t\tif (!mux->carousel_period_plus_one) sc->carousel_period  = (u32) -1;\n\t\t\t\telse sc->carousel_period = mux->carousel_period_plus_one - 1;\n\t\t\t}\n\t\t}\n\t} else if (desc->tag==GF_ODF_MUXINFO_TAG) {\n\t\tGF_MuxInfo *mi = (GF_MuxInfo *)desc;\n\t\tif (! mi->src_url) {\n\t\t\tmi->src_url = gf_strdup(parser->load->src_url ? parser->load->src_url : parser->load->fileName);\n\t\t}\n\t}\n\treturn desc;\n}\n\nvoid gf_bt_parse_od_command(GF_BTParser *parser, char *name)\n{\n\tu32 val=0;\n\tchar *str;\n\n\tif (!strcmp(name, \"UPDATE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD update*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODUpdate *odU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ObjectDescriptor\") && strcmp(str, \"InitialObjectDescriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Object Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(odU->objectDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD update*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tGF_ESDUpdate *esdU;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"IN\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IN expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdU = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tparser->last_error = gf_bt_parse_int(parser, \"OD_ID\", (SFInt32*)&val);\n\t\t\tif (parser->last_error) return;\n\t\t\tesdU->ODID = val;\n\t\t\tgf_list_add(parser->od_au->commands, esdU);\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"esDescr\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"esDescr expected got %s\", str);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ES_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ES_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(esdU->ESDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*IPMP descriptor update*/\n\t\tif (!strcmp(str, \"IPMPD\") || !strcmp(str, \"IPMPDX\")) {\n\t\t\tGF_IPMPUpdate *ipU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tipU = (GF_IPMPUpdate *) gf_odf_com_new(GF_ODF_IPMP_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, ipU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"IPMP_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(ipU->IPMPDescList, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"unknown OD command\", str);\n\t\treturn;\n\t}\n\tif (!strcmp(name, \"REMOVE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD remove*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODRemove *odR;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todR = (GF_ODRemove *) gf_odf_com_new(GF_ODF_OD_REMOVE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\todR->OD_ID = (u16*)gf_realloc(odR->OD_ID, sizeof(u16) * (odR->NbODs+1));\n\t\t\t\todR->OD_ID[odR->NbODs] = id;\n\t\t\t\todR->NbODs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD remove*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tu32 odid;\n\t\t\tGF_ESDRemove *esdR;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"FROM\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"FROM expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&odid);\n\t\t\tif (parser->last_error) return;\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdR = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR->ODID = odid;\n\t\t\tgf_list_add(parser->od_au->commands, esdR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ES_ID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\tesdR->ES_ID = (u16*)gf_realloc(esdR->ES_ID, sizeof(u16) * (esdR->NbESDs+1));\n\t\t\t\tesdR->ES_ID[esdR->NbESDs] = id;\n\t\t\t\tesdR->NbESDs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown OD command\", str);\n\t\treturn;\n\t}\n}\n\n\n\nGF_Err gf_bt_loader_run_intern(GF_BTParser *parser, GF_Command *init_com, Bool initial_run)\n{\n\tchar *str;\n\tGF_Node *node, *vrml_root_node;\n\tBool force_new_com;\n\tGF_Route *r;\n\tBool has_id;\n\tchar szDEFName[1000];\n\n\tvrml_root_node = NULL;\n\thas_id = 0;\n\n\tif (init_com)\n\t\tparser->in_com = 0 ;\n\n\tparser->cur_com = init_com;\n\n\tforce_new_com = (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) ? 1 : 0;\n\n\n\t/*create a default root node for all VRML nodes*/\n\tif (parser->is_wrl && !parser->top_nodes) {\n\t\tif (initial_run ) {\n#ifndef GPAC_DISABLE_X3D\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, (parser->load->flags & GF_SM_LOAD_MPEG4_STRICT) ? TAG_MPEG4_Group : TAG_X3D_Group);\n#else\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, TAG_MPEG4_Group);\n#endif\n\t\t\tgf_node_register(vrml_root_node, NULL);\n\t\t\tgf_node_init(vrml_root_node);\n\t\t\tgf_sg_set_root_node(parser->load->scene_graph, vrml_root_node);\n\t\t} else {\n\t\t\tvrml_root_node = gf_sg_get_root_node(parser->load->scene_graph);\n\t\t}\n\t}\n\n\tif (!parser->in_com)\n\t\tparser->stream_id = parser->load->force_es_id;\n\n\t/*parse all top-level items*/\n\twhile (!parser->last_error) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (parser->done) break;\n\n\t\tif (!strcmp(str, \"\")) {\n\t\t\t//empty string, force moving to next char\n\t\t\tif (parser->line_pos<parser->line_size) parser->line_pos++;\n\t\t}\n\t\t/*X3D specific things (ignored for now)*/\n\t\telse if (!strcmp(str, \"PROFILE\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"COMPONENT\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"META\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"IMPORT\") || !strcmp(str, \"EXPORT\")) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"X3D IMPORT/EXPORT not implemented\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*IOD*/\n\t\telse if (!strcmp(str, \"InitialObjectDescriptor\") || !strcmp(str, \"ObjectDescriptor\")) {\n\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_bt_parse_descriptor(parser, str);\n\t\t}\n\t\t/*explicit command*/\n\t\telse if (!strcmp(str, \"AT\") || !strcmp(str, \"RAP\")) {\n\t\t\tparser->au_is_rap = 0;\n\t\t\tif (!strcmp(str, \"RAP\")) {\n\t\t\t\tparser->au_is_rap = 1;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"AT\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"AT expected got %s\", str);\n\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforce_new_com = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (str[0] == 'D') {\n\t\t\t\tparser->au_time += atoi(&str[1]);\n\t\t\t} else {\n\t\t\t\tif (sscanf(str, \"%u\", &parser->au_time) != 1) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Number expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parser->last_error) break;\n\t\t\t/*reset all contexts*/\n\t\t\tif (parser->od_au && (parser->od_au->timing != parser->au_time)) parser->od_au = NULL;\n\t\t\tif (parser->bifs_au && (parser->bifs_au->timing != parser->au_time)) {\n\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tparser->stream_id = 0;\n\t\t\t/*fix for mp4tool bt which doesn't support RAP signaling: assume the first AU\n\t\t\tis always RAP*/\n\t\t\tif (!parser->au_time) parser->au_is_rap = 1;\n\n\t\t\tparser->in_com = 1;\n\n\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"IN\")) {\n\t\t\t\t\tgf_bt_parse_int(parser, \"IN\", (SFInt32*)&parser->stream_id);\n\t\t\t\t\tif (parser->last_error) break;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*done loading init frame*/\n\t\t\tif (init_com && parser->au_time) break;\n\t\t}\n\t\telse if (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, init_com ? init_com->new_proto_list : NULL);\n\t\t}\n\t\t/*compatibility for old bt (mp4tool) in ProtoLibs*/\n\t\telse if (!strcmp(str, \"NULL\")) {\n\t\t}\n\t\telse if (!strcmp(str, \"DEF\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDEFName, str);\n\t\t\thas_id = 1;\n\t\t}\n\t\telse if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Command *com = NULL;\n\t\t\tif (!parser->top_nodes && parser->bifs_au && !parser->is_wrl) {\n\t\t\t\t/*if doing a scene replace, we need route insert stuff*/\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\t}\n\n\t\t\tr = gf_bt_parse_route(parser, 1, 0, com);\n\t\t\tif (has_id) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDEFName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->RouteID = rID;\n\t\t\t\t\tcom->def_name = gf_strdup(szDEFName);\n\t\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\t} else if (r) {\n\t\t\t\t\tgf_sg_route_set_id(r, rID);\n\t\t\t\t\tgf_sg_route_set_name(r, szDEFName);\n\t\t\t\t}\n\t\t\t\thas_id = 0;\n\t\t\t}\n\t\t}\n\t\t/*OD commands*/\n\t\telse if (!strcmp(str, \"UPDATE\") || !strcmp(str, \"REMOVE\")) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\t\t\tif (!parser->stream_id || parser->stream_id==parser->bifs_es->ESID) parser->stream_id = parser->base_od_id;\n\n\t\t\tif (parser->od_es && (parser->od_es->ESID != parser->stream_id)) {\n\t\t\t\tGF_StreamContext *prev = parser->od_es;\n\t\t\t\tparser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->od_es != prev) {\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t\tparser->od_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parser->od_es) parser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\tif (!parser->od_au) parser->od_au = gf_sm_stream_au_new(parser->od_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_od_command(parser, str);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*BIFS commands*/\n\t\telse if (!strcmp(str, \"REPLACE\") || !strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\") || !strcmp(str, \"DELETE\")\n\t\t         /*BIFS extended commands*/\n\t\t         || !strcmp(str, \"GLOBALQP\") || !strcmp(str, \"MULTIPLEREPLACE\") || !strcmp(str, \"MULTIPLEINDREPLACE\") || !strcmp(str, \"XDELETE\") || !strcmp(str, \"DELETEPROTO\") || !strcmp(str, \"INSERTPROTO\")\n\t\t         || !strcmp(str, \"XREPLACE\")\n\t\t        ) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\n\t\t\tif (!parser->stream_id) parser->stream_id = parser->base_bifs_id;\n\t\t\tif (!parser->stream_id || (parser->od_es && (parser->stream_id==parser->od_es->ESID)) ) parser->stream_id = parser->base_bifs_id;\n\n\t\t\tif (parser->bifs_es->ESID != parser->stream_id) {\n\t\t\t\tGF_StreamContext *prev = parser->bifs_es;\n\t\t\t\tparser->bifs_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->bifs_es != prev) {\n\t\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_new_com) {\n\t\t\t\tforce_new_com = 0;\n\t\t\t\tparser->bifs_au = gf_list_last(parser->bifs_es->AUs);\n\t\t\t\tparser->au_time = (u32) (parser->bifs_au ? parser->bifs_au->timing : 0) + 1;\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tif (!parser->bifs_au) parser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_bifs_command(parser, str, parser->bifs_au->commands);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*implicit BIFS command on SFTopNodes only*/\n\t\telse if (!strcmp(str, \"OrderedGroup\")\n\t\t         || !strcmp(str, \"Group\")\n\t\t         || !strcmp(str, \"Layer2D\")\n\t\t         || !strcmp(str, \"Layer3D\")\n\t\t         /* VRML parsing: all nodes are allowed*/\n\t\t         || parser->is_wrl\n\t\t        )\n\t\t{\n\n\t\t\tnode = gf_bt_sf_node(parser, str, vrml_root_node, has_id ? szDEFName : NULL);\n\t\t\thas_id = 0;\n\t\t\tif (!node) break;\n\t\t\tif (parser->top_nodes) {\n\t\t\t\tgf_list_add(parser->top_nodes, node);\n\t\t\t} else if (!vrml_root_node) {\n\t\t\t\tif (init_com) init_com->node = node;\n\t\t\t\telse if (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\t\t\t\tGF_Command *com = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tassert(!parser->bifs_au);\n\t\t\t\t\tassert(parser->bifs_es);\n\t\t\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\t\tcom->node = node;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_node_insert_child(vrml_root_node, node, -1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (!gf_sg_get_root_node(parser->load->scene_graph)) {\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_sg_set_root_node(parser->load->scene_graph, node);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\t/*if in command, check command end*/\n\t\telse {\n\t\t\t/*check command end*/\n\t\t\tif (/*in_com && */gf_bt_check_code(parser, '}')) parser->in_com = 0;\n\t\t\telse if (strlen(str)) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown top-level element\", str);\n\t\t\t}\n\t\t\tparser->au_is_rap = 0;\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 0);\n\tgf_bt_check_unresolved_nodes(parser);\n\n\t/*load scripts*/\n\twhile (gf_list_count(parser->scripts)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->scripts, 0);\n\t\tgf_list_rem(parser->scripts, 0);\n\t\tgf_sg_script_load(n);\n\t}\n\treturn parser->last_error;\n}\n\nstatic GF_Err gf_sm_load_bt_initialize(GF_SceneLoader *load, const char *str, Bool input_only)\n{\n\tu32 size;\n\tgzFile gzInput;\n\tGF_Err e;\n\tunsigned char BOM[5];\n\tGF_BTParser *parser = load->loader_priv;\n\n\tparser->last_error = GF_OK;\n\n\tif (load->fileName) {\n\t\tFILE *test = gf_fopen(load->fileName, \"rb\");\n\t\tif (!test) return GF_URL_ERROR;\n\n\t\tsize = (u32) gf_fsize(test);\n\t\tgf_fclose(test);\n\n\t\tgzInput = gf_gzopen(load->fileName, \"rb\");\n\t\tif (!gzInput) return GF_IO_ERR;\n\n\t\tparser->line_buffer = (char *) gf_malloc(sizeof(char)*BT_LINE_SIZE);\n\t\tmemset(parser->line_buffer, 0, sizeof(char)*BT_LINE_SIZE);\n\t\tparser->file_size = size;\n\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tgf_gzgets(gzInput, (char*) BOM, 5);\n\t\tgf_gzseek(gzInput, 0, SEEK_SET);\n\t\tparser->gz_in = gzInput;\n\n\t} else {\n\t\tif (!str || (strlen(str)<5) ) {\n\t\t\t/*wait for first string data to be fed to the parser (for load from string)*/\n\t\t\tparser->initialized = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tstrncpy((char *) BOM, str, 5);\n\t}\n\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 2;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 1;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 3, SEEK_CUR);\n\t}\n\tparser->initialized = 1;\n\n\tif ( load->fileName )\n\t{\n\t\tchar *sep = gf_file_ext_start(load->fileName);\n\t\tif (sep && !strnicmp(sep, \".wrl\", 4)) parser->is_wrl = 1;\n\t}\n\n\tif (input_only) return GF_OK;\n\n\t/*initalize default streams in the context*/\n\n\t/*chunk parsing*/\n\tif (load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\tu32 i;\n\t\tGF_StreamContext *sc;\n\t\tif (!load->ctx) return GF_BAD_PARAM;\n\n\t\t/*restore context - note that base layer are ALWAYS declared BEFORE enhancement layers with gpac parsers*/\n\t\ti=0;\n\t\twhile ((sc = (GF_StreamContext*)gf_list_enum(load->ctx->streams, &i))) {\n\t\t\tswitch (sc->streamType) {\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\tif (!parser->bifs_es) parser->bifs_es = sc;\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (!parser->od_es) parser->od_es = sc;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*need at least one scene stream*/\n\t\tif (!parser->bifs_es) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->load->ctx->scene_width = 0;\n\t\t\tparser->load->ctx->scene_height = 0;\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\t\telse parser->base_bifs_id = parser->bifs_es->ESID;\n\t\tif (parser->od_es) parser->base_od_id = parser->od_es->ESID;\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"BT: MPEG-4 (BT) Scene Chunk Parsing\"));\n\t}\n\t/*context is not initialized - check for VRML*/\n\telse {\n\t\tGF_Command *com;\n\n\n\t\tparser->load = NULL;\n\t\tgf_bt_check_line(parser);\n\t\tparser->load = load;\n\t\tif (load->ctx && parser->def_w && parser->def_h) {\n\t\t\tload->ctx->scene_width = parser->def_w;\n\t\t\tload->ctx->scene_height = parser->def_h;\n\t\t}\n\n\t\t/*create at least one empty BIFS stream*/\n\t\tif (!parser->is_wrl && load->ctx) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ( ((parser->is_wrl==2) ? \"BT: X3D (WRL) Scene Parsing\\n\" : (parser->is_wrl ? \"BT: VRML Scene Parsing\\n\" : \"BT: MPEG-4 Scene Parsing\\n\")) ));\n\n\t\t/*default scene replace - we create it no matter what since it is used to store BIFS config when parsing IOD.*/\n\t\tcom = NULL;\n\t\tif (!parser->is_wrl) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t}\n\n\t\t/*and perform initial load*/\n\t\te = gf_bt_loader_run_intern(parser, com, 1);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nvoid load_bt_done(GF_SceneLoader *load)\n{\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return;\n\tgf_list_del(parser->unresolved_routes);\n\tgf_list_del(parser->inserted_routes);\n\tgf_list_del(parser->undef_nodes);\n\tgf_list_del(parser->def_nodes);\n\tgf_list_del(parser->peeked_nodes);\n\twhile (gf_list_count(parser->def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser->def_symbols, 0);\n\t\tgf_list_rem(parser->def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser->def_symbols);\n\tgf_list_del(parser->scripts);\n\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n\tif (parser->line_buffer) gf_free(parser->line_buffer);\n\tgf_free(parser);\n\tload->loader_priv = NULL;\n}\n\nGF_Err load_bt_run(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, NULL, 1);\n\t\tif (e) return e;\n\t}\n\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\n\tif ((e<0) || parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tif (parser->gz_in) {\n\t\t\tgf_gzclose(parser->gz_in);\n\t\t\tparser->gz_in = NULL;\n\t\t}\n\n\t\tif (parser->line_buffer) {\n\t\t\tgf_free(parser->line_buffer);\n\t\t\tparser->line_buffer = NULL;\n\t\t}\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tload->fileName = NULL;\n\t}\n\treturn e;\n}\n\n\nGF_Err load_bt_parse_string(GF_SceneLoader *load, const char *str)\n{\n\tGF_Err e;\n\tchar *dup_str;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = 0;\n\t}\n\tparser->line_buffer = dup_str = gf_strdup(str);\n\tparser->line_size = (s32)strlen(str);\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, str, 0);\n\t\tif (e) {\n\t\t\tgf_free(dup_str);\n\t\t\treturn e;\n\t\t}\n\t}\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\tparser->line_buffer = NULL;\n\tparser->line_size = 0;\n\tgf_free(dup_str);\n\treturn e;\n}\n\nGF_Err load_bt_suspend(GF_SceneLoader *load, Bool suspend)\n{\n\treturn GF_OK;\n}\n\nGF_Err gf_sm_load_init_bt(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser;\n\n\tif (!load || (!load->ctx && !load->scene_graph) ) return GF_BAD_PARAM;\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tGF_SAFEALLOC(parser, GF_BTParser);\n\tif (!parser) return GF_OUT_OF_MEM;\n\tparser->load = load;\n\tload->loader_priv = parser;\n\tparser->def_symbols = gf_list_new();\n\tparser->unresolved_routes = gf_list_new();\n\tparser->inserted_routes = gf_list_new();\n\tparser->undef_nodes = gf_list_new();\n\tparser->def_nodes = gf_list_new();\n\tparser->peeked_nodes = gf_list_new();\n\tparser->scripts = gf_list_new();\n\n\tload->process = load_bt_run;\n\tload->done = load_bt_done;\n\tload->suspend = load_bt_suspend;\n\tload->parse_string = load_bt_parse_string;\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tgf_bt_report(parser, GF_OK, NULL);\n\t}\n#endif\n\n\te = gf_sm_load_bt_initialize(load, NULL, 0);\n\tif (e) {\n\t\tload_bt_done(load);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_List *gf_sm_load_bt_from_string(GF_SceneGraph *in_scene, char *node_str, Bool force_wrl)\n{\n\tGF_SceneLoader ctx;\n\tGF_BTParser parser;\n\tmemset(&ctx, 0, sizeof(GF_SceneLoader));\n\tctx.scene_graph = in_scene;\n\tmemset(&parser, 0, sizeof(GF_BTParser));\n\tparser.line_buffer = node_str;\n\tparser.line_size = (u32) strlen(node_str);\n\tparser.load = &ctx;\n\tparser.top_nodes = gf_list_new();\n\tparser.undef_nodes = gf_list_new();\n\tparser.def_nodes = gf_list_new();\n\tparser.peeked_nodes = gf_list_new();\n\tparser.is_wrl = force_wrl;\n\tgf_bt_loader_run_intern(&parser, NULL, 1);\n\tgf_list_del(parser.undef_nodes);\n\tgf_list_del(parser.def_nodes);\n\tgf_list_del(parser.peeked_nodes);\n\twhile (gf_list_count(parser.def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser.def_symbols, 0);\n\t\tgf_list_rem(parser.def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser.def_symbols);\n\tgf_list_del(parser.scripts);\n\n\treturn parser.top_nodes;\n}\n\n#endif /*GPAC_DISABLE_LOADER_BT*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/utf.h>\n#include <gpac/constants.h>\n#include <gpac/network.h>\n#include <gpac/internal/bifs_dev.h>\n#include <gpac/internal/scenegraph_dev.h>\n\n#include <gpac/nodes_x3d.h>\n#include <gpac/color.h>\n\n\n#if !defined(GPAC_DISABLE_LOADER_BT) && !defined(GPAC_DISABLE_ZLIB)\n\n#include <gpac/mpeg4_odf.h>\n\n/*since 0.2.2, we use zlib for bt reading to handle wrl.gz files*/\n#include <zlib.h>\n\nvoid gf_sm_update_bitwrapper_buffer(GF_Node *node, const char *fileName);\n\nvoid load_bt_done(GF_SceneLoader *load);\n\n#define BT_LINE_SIZE\t4000\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n} BTDefSymbol;\n\ntypedef struct\n{\n\tGF_SceneLoader *load;\n\tBool initialized;\n\tgzFile gz_in;\n\tu32 file_size, file_pos;\n\n\t/*create from string only*/\n\tGF_List *top_nodes;\n\n\tGF_Err last_error;\n\tu32 line;\n\n\tBool done, in_com;\n\tu32 is_wrl;\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tu32 unicode_type;\n\n\tGF_List *def_symbols;\n\n\t/*routes are not created in the graph when parsing, so we need to track insert and delete/replace*/\n\tGF_List *unresolved_routes, *inserted_routes, *peeked_nodes;\n\tGF_List *undef_nodes, *def_nodes;\n\n\tchar *line_buffer;\n\tchar cur_buffer[500];\n\ts32 line_size, line_pos, line_start_pos;\n\n\tu32 block_comment;\n\n\t/*set when parsing proto*/\n\tGF_Proto *parsing_proto;\n\tBool is_extern_proto_field;\n\n\t/*current stream ID, AU time and RAP flag*/\n\tu32 stream_id;\n\tu32 au_time;\n\tBool au_is_rap;\n\n\t/*current BIFS stream & AU*/\n\tGF_StreamContext *bifs_es;\n\tGF_AUContext *bifs_au;\n\tu32 base_bifs_id;\n\tGF_Command *cur_com;\n\n\t/*current OD stream & AU*/\n\tGF_StreamContext *od_es;\n\tGF_AUContext *od_au;\n\tu32 base_od_id;\n\n\tGF_List *scripts;\n\n\tu32 def_w, def_h;\n\n} GF_BTParser;\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList);\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com);\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean);\n\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID);\n\nstatic GF_Err gf_bt_report(GF_BTParser *parser, GF_Err e, char *format, ...)\n{\n#ifndef GPAC_DISABLE_LOG\n\tif (format && gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tchar szMsg[2048];\n\t\tva_list args;\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 2048, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (\"[BT/WRL Parsing] %s (line %d)\\n\", szMsg, parser->line));\n\t}\n#endif\n\tif (e) parser->last_error = e;\n\treturn e;\n}\n\n\nvoid gf_bt_check_line(GF_BTParser *parser)\n{\nreload_line:\n\twhile (parser->line_pos < parser->line_size) {\n\t\tswitch (parser->line_buffer[parser->line_pos]) {\n\t\tcase ' ':\n\t\tcase '\\t':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\t\tparser->line_pos++;\n\t\t\tcontinue;\n\t\tcase '\\0':\n\t\t\tparser->line_pos = parser->line_size;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (parser->line_pos < parser->line_size) {\n\t\tif (parser->line_buffer[parser->line_pos]=='#') {\n\t\t\tparser->line_size = parser->line_pos;\n\t\t}\n\t\telse if ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') ) {\n\t\t\tparser->line_size = parser->line_pos;\n\t\t}\n\t}\n\n\tif (parser->line_size == parser->line_pos) {\n\t\t/*string based input - done*/\n\t\tif (!parser->gz_in) {\n\t\t\tparser->done = 1;\n\t\t\treturn;\n\t\t}\n\nnext_line:\n\t\tparser->line_start_pos = (s32) gf_gztell(parser->gz_in);\n\t\tparser->line_buffer[0] = 0;\n\t\tif (parser->unicode_type) {\n\t\t\tu8 c1, c2;\n\t\t\tunsigned short wchar;\n\t\t\tunsigned short l[BT_LINE_SIZE];\n\t\t\tunsigned short *dst = l;\n\t\t\tBool is_ret = 0;\n\t\t\tu32 last_space_pos, last_space_pos_stream;\n\t\t\tu32 go = BT_LINE_SIZE - 1;\n\t\t\tlast_space_pos = last_space_pos_stream = 0;\n\t\t\twhile (go && !gf_gzeof(parser->gz_in) ) {\n\t\t\t\tc1 = gf_gzgetc(parser->gz_in);\n\t\t\t\tc2 = gf_gzgetc(parser->gz_in);\n\t\t\t\t/*Little-endian order*/\n\t\t\t\tif (parser->unicode_type==2) {\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar = c2;\n\t\t\t\t\t\twchar <<=8;\n\t\t\t\t\t\twchar |= c1;\n\t\t\t\t\t}\n\t\t\t\t\telse wchar = c1;\n\t\t\t\t} else {\n\t\t\t\t\twchar = c1;\n\t\t\t\t\tif (c2) {\n\t\t\t\t\t\twchar <<= 8;\n\t\t\t\t\t\twchar |= c2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*dst = wchar;\n\t\t\t\tif (wchar=='\\r') is_ret = 1;\n\t\t\t\telse if (wchar=='\\n') {\n\t\t\t\t\tdst++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (is_ret) {\n\t\t\t\t\tu32 fpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tgf_gzseek(parser->gz_in, fpos-2, SEEK_SET);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (wchar==' ') {\n\t\t\t\t\t//last_space_pos_stream = (u32) gf_gztell(parser->gz_in);\n\t\t\t\t\tlast_space_pos = (u32) (dst - l);\n\t\t\t\t}\n\t\t\t\tdst++;\n\t\t\t\tgo--;\n\n\t\t\t}\n\t\t\t*dst = 0;\n\t\t\t/*long line, rewind stream to last space*/\n\t\t\tif (!go) {\n\t\t\t\tu32 rew_pos = (u32)  (gf_gztell(parser->gz_in) - 2*(dst - &l[last_space_pos]) );\n\t\t\t\tgf_gzseek(parser->gz_in, rew_pos, SEEK_SET);\n\t\t\t\tl[last_space_pos+1] = 0;\n\t\t\t}\n\t\t\t/*check eof*/\n\t\t\tif (l[0]==0xFFFF) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*convert to mbc string*/\n\t\t\tdst = l;\n\t\t\tgf_utf8_wcstombs(parser->line_buffer, BT_LINE_SIZE, (const unsigned short **) &dst);\n\n\t\t\tif (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in)) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((gf_gzgets(parser->gz_in, parser->line_buffer, BT_LINE_SIZE) == NULL)\n\t\t\t        || (!strlen(parser->line_buffer) && gf_gzeof(parser->gz_in))) {\n\t\t\t\tparser->done = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*watchout for long lines*/\n\t\t\tif (1 + strlen(parser->line_buffer) == BT_LINE_SIZE) {\n\t\t\t\tu32 rew, pos, go;\n\t\t\t\trew = 0;\n\t\t\t\tgo = 1;\n\t\t\t\twhile (go) {\n\t\t\t\t\tswitch (parser->line_buffer[strlen(parser->line_buffer)-1]) {\n\t\t\t\t\tcase ' ':\n\t\t\t\t\tcase ',':\n\t\t\t\t\tcase '[':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tgo = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparser->line_buffer[strlen(parser->line_buffer)-1] = 0;\n\t\t\t\t\t\trew++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos = (u32) gf_gztell(parser->gz_in);\n\t\t\t\tgf_gzseek(parser->gz_in, pos-rew, SEEK_SET);\n\t\t\t}\n\t\t}\n\n\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tu32 len = (u32) strlen(parser->line_buffer);\n\t\t\tif (!len) break;\n\t\t\tc = parser->line_buffer[len-1];\n\t\t\tif (!strchr(\"\\n\\r\\t\", c)) break;\n\t\t\tparser->line_buffer[len-1] = 0;\n\t\t}\n\n\n\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\tparser->line_pos = 0;\n\t\tparser->line++;\n\n\t\t{\n\t\t\tu32 pos = (u32) gf_gztell(parser->gz_in);\n\t\t\tif (pos>=parser->file_pos) {\n\t\t\t\tparser->file_pos = pos;\n\t\t\t\tif (parser->line>1) gf_set_progress(\"BT Parsing\", pos, parser->file_size);\n\t\t\t}\n\t\t}\n\n\t\twhile ((parser->line_buffer[parser->line_pos]==' ') || (parser->line_buffer[parser->line_pos]=='\\t'))\n\t\t\tparser->line_pos++;\n\t\tif ( (parser->line_buffer[parser->line_pos]=='#')\n\t\t        || ( (parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/')) ) {\n\n\t\t\tif (parser->line==1) {\n\t\t\t\tif (strstr(parser->line_buffer, \"VRML\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"VRML V2.0\")) parser->is_wrl = 1;\n\t\t\t\t\t/*although not std, many files use this*/\n\t\t\t\t\telse if (strstr(parser->line_buffer, \"VRML2.0\")) parser->is_wrl = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: VRML Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (strstr(parser->line_buffer, \"X3D\")) {\n\t\t\t\t\tif (strstr(parser->line_buffer, \"X3D V3.0\")) parser->is_wrl = 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"%s: X3D Version Not Supported\", parser->line_buffer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"#define \", 8) && !parser->block_comment) {\n\t\t\t\tchar *buf, *sep;\n\t\t\t\tparser->line_pos+=8;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\tsep = strchr(buf, ' ');\n\t\t\t\tif (sep && (sep[1]!='\\n') ) {\n\t\t\t\t\tBTDefSymbol *def;\n\t\t\t\t\tGF_SAFEALLOC(def, BTDefSymbol);\n\t\t\t\t\tif (!def) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Fail to allocate DEF node\\n\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\tdef->name = gf_strdup(buf);\n\t\t\t\t\tsep[0] = ' ';\n\t\t\t\t\tbuf = sep+1;\n\t\t\t\t\twhile (strchr(\" \\t\", buf[0])) buf++;\n\t\t\t\t\tdef->value = gf_strdup(buf);\n\t\t\t\t\tgf_list_add(parser->def_symbols, def);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#if \", 4)) {\n\t\t\t\tu32 len = 0;\n\t\t\t\tparser->line_pos+=4;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (parser->line_pos+(s32)len==parser->line_size) break;\n\t\t\t\t\tif (strchr(\" \\n\\t\", parser->line_buffer[parser->line_pos+len]))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\tif (len) {\n\t\t\t\t\tif (len==1) {\n\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, \"0\", 1)) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 i, count;\n\t\t\t\t\t\tchar *keyWord = NULL;\n\t\t\t\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\t\t\tif (!strnicmp(parser->line_buffer+parser->line_pos, def->name, len)) {\n\t\t\t\t\t\t\t\tkeyWord = def->value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keyWord && !strcmp(keyWord, \"0\")) {\n\t\t\t\t\t\t\tparser->block_comment++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#endif\", 6)) {\n\t\t\t\tif (parser->block_comment) parser->block_comment--;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#else\", 5)) {\n\t\t\t\tif (parser->block_comment)\n\t\t\t\t\tparser->block_comment--;\n\t\t\t\telse\n\t\t\t\t\tparser->block_comment++;\n\t\t\t}\n\t\t\telse if (!strnicmp(parser->line_buffer+parser->line_pos, \"#size\", 5)) {\n\t\t\t\tchar *buf;\n\t\t\t\tparser->line_pos+=6;\n\t\t\t\tbuf = parser->line_buffer+parser->line_pos;\n\t\t\t\twhile (strchr(\" \\t\", buf[0]))\n\t\t\t\t\tbuf++;\n\t\t\t\tsscanf(buf, \"%dx%d\", &parser->def_w, &parser->def_h);\n\t\t\t}\n\t\t\tgoto next_line;\n\t\t}\n\n\t\tif (parser->block_comment)\n\t\t\tgoto next_line;\n\n\t\t/*brute-force replacement of defined symbols (!!FIXME - no mem checking done !!)*/\n\t\tif (parser->line_pos < parser->line_size) {\n\t\t\tu32 i, count;\n\t\t\tcount = gf_list_count(parser->def_symbols);\n\t\t\twhile (1) {\n\t\t\t\tBool found = 0;\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tu32 symb_len, val_len, copy_len;\n\t\t\t\t\tBTDefSymbol *def = (BTDefSymbol *)gf_list_get(parser->def_symbols, i);\n\t\t\t\t\tchar *start = strstr(parser->line_buffer, def->name);\n\t\t\t\t\tif (!start) continue;\n\t\t\t\t\tsymb_len = (u32) strlen(def->name);\n\t\t\t\t\tif (!strchr(\" \\n\\r\\t,[]{}\\'\\\"\", start[symb_len])) continue;\n\t\t\t\t\tval_len = (u32) strlen(def->value);\n\t\t\t\t\tcopy_len = (u32) strlen(start + symb_len) + 1;\n\t\t\t\t\tmemmove(start + val_len, start + symb_len, sizeof(char)*copy_len);\n\t\t\t\t\tmemcpy(start, def->value, sizeof(char)*val_len);\n\t\t\t\t\tparser->line_size = (u32) strlen(parser->line_buffer);\n\t\t\t\t\tfound = 1;\n\t\t\t\t}\n\t\t\t\tif (!found) break;\n\t\t\t}\n\t\t}\n\t}\n\tif (!parser->line_size) {\n\t\tif (!gf_gzeof(parser->gz_in))\n\t\t\t//avoid recursion\n\t\t\tgoto reload_line;\n\t\telse\n\t\t\tparser->done = 1;\n\t}\n\telse if (!parser->done && (parser->line_size == parser->line_pos))\n\t\t//avoid recursion\n\t\tgoto reload_line;\n}\n\nvoid gf_bt_force_line(GF_BTParser *parser)\n{\n\tparser->line_pos = parser->line_size;\n}\n\nBool gf_bt_check_code(GF_BTParser *parser, char code)\n{\n\tgf_bt_check_line(parser);\n\tif (parser->line_buffer[parser->line_pos]==code) {\n\t\tparser->line_pos++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nchar *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_pos+i>=parser->line_size) break;\n\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}\n\nchar *gf_bt_get_string(GF_BTParser *parser, u8 string_delim)\n{\n\tchar *res;\n\ts32 i, size;\n\n#define\tBT_STR_CHECK_ALLOC\t\\\n\t\tif (i==size) {\t\t\\\n\t\t\tres = (char*)gf_realloc(res, sizeof(char) * (size+500+1));\t\\\n\t\t\tsize += 500;\t\\\n\t\t}\t\\\n\n\tres = (char*)gf_malloc(sizeof(char) * 500);\n\tsize = 500;\n\twhile (parser->line_buffer[parser->line_pos]==' ') parser->line_pos++;\n\n\tif (parser->line_pos==parser->line_size) {\n\t\tif (gf_gzeof(parser->gz_in)) return NULL;\n\t\tgf_bt_check_line(parser);\n\t}\n\tif (!string_delim) string_delim = '\"';\n\n\ti=0;\n\twhile (1) {\n\t\tif (parser->line_buffer[parser->line_pos] == string_delim)\n\t\t\tif ( !parser->line_pos || (parser->line_buffer[parser->line_pos-1] != '\\\\') ) break;\n\n\t\tBT_STR_CHECK_ALLOC\n\n\t\tif ((parser->line_buffer[parser->line_pos]=='/') && (parser->line_buffer[parser->line_pos+1]=='/') && (parser->line_buffer[parser->line_pos-1]!=':') ) {\n\t\t\t/*this looks like a comment*/\n\t\t\tif (!strchr(&parser->line_buffer[parser->line_pos], string_delim)) {\n\t\t\t\tgf_bt_check_line(parser);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((parser->line_buffer[parser->line_pos] != '\\\\') || (parser->line_buffer[parser->line_pos+1] != string_delim)) {\n\t\t\t/*handle UTF-8 - WARNING: if parser is in unicode string is already utf8 multibyte chars*/\n\t\t\tif (!parser->unicode_type && parser->line_buffer[parser->line_pos] & 0x80) {\n\t\t\t\tchar c = parser->line_buffer[parser->line_pos];\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (parser->line_buffer[parser->line_pos+1] & 0xc0) != 0x80) {\n\t\t\t\t\tres[i] = 0xc0 | ( (parser->line_buffer[parser->line_pos] >> 6) & 0x3 );\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tparser->line_buffer[parser->line_pos] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (c & 0xe0) == 0xc0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (c & 0xf0) == 0xe0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (c & 0xf8) == 0xf0) {\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\t\t\tparser->line_pos++;\n\t\t\t\t\ti++;\n\t\t\t\t\tBT_STR_CHECK_ALLOC\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres[i] = parser->line_buffer[parser->line_pos];\n\t\t\ti++;\n\t\t}\n\t\tparser->line_pos++;\n\t\tif (parser->line_pos==parser->line_size) {\n\t\t\tgf_bt_check_line(parser);\n\t\t}\n\n\t}\n\n#undef\tBT_STR_CHECK_ALLOC\n\n\tres[i] = 0;\n\tparser->line_pos += 1;\n\treturn res;\n}\n\nBool gf_bt_check_externproto_field(GF_BTParser *parser, char *str)\n{\n\tif (!parser->is_extern_proto_field) return 0;\n\tif (!strcmp(str, \"\") || !strcmp(str, \"field\") || !strcmp(str, \"eventIn\") || !strcmp(str, \"eventOut\") || !strcmp(str, \"exposedField\")) {\n\t\tparser->last_error = GF_EOS;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic Bool check_keyword(GF_BTParser *parser, char *str, s32 *val)\n{\n\ts32 res;\n\tchar *sep;\n\tsep = strchr(str, '$');\n\tif (!sep) return 0;\n\tsep++;\n\tif (!strcmp(sep, \"F1\")) res = GF_KEY_F1;\n\telse if (!strcmp(sep, \"F2\")) res = GF_KEY_F2;\n\telse if (!strcmp(sep, \"F3\")) res = GF_KEY_F3;\n\telse if (!strcmp(sep, \"F4\")) res = GF_KEY_F4;\n\telse if (!strcmp(sep, \"F5\")) res = GF_KEY_F5;\n\telse if (!strcmp(sep, \"F6\")) res = GF_KEY_F6;\n\telse if (!strcmp(sep, \"F7\")) res = GF_KEY_F7;\n\telse if (!strcmp(sep, \"F8\")) res = GF_KEY_F8;\n\telse if (!strcmp(sep, \"F9\")) res = GF_KEY_F9;\n\telse if (!strcmp(sep, \"F10\")) res = GF_KEY_F10;\n\telse if (!strcmp(sep, \"F11\")) res = GF_KEY_F11;\n\telse if (!strcmp(sep, \"F12\")) res = GF_KEY_F12;\n\telse if (!strcmp(sep, \"HOME\")) res = GF_KEY_HOME;\n\telse if (!strcmp(sep, \"END\")) res = GF_KEY_END;\n\telse if (!strcmp(sep, \"PREV\")) res = GF_KEY_PAGEUP;\n\telse if (!strcmp(sep, \"NEXT\")) res = GF_KEY_PAGEDOWN;\n\telse if (!strcmp(sep, \"UP\")) res = GF_KEY_UP;\n\telse if (!strcmp(sep, \"DOWN\")) res = GF_KEY_DOWN;\n\telse if (!strcmp(sep, \"LEFT\")) res = GF_KEY_LEFT;\n\telse if (!strcmp(sep, \"RIGHT\")) res = GF_KEY_RIGHT;\n\telse if (!strcmp(sep, \"RETURN\")) res = GF_KEY_ENTER;\n\telse if (!strcmp(sep, \"BACK\")) res = GF_KEY_BACKSPACE;\n\telse if (!strcmp(sep, \"TAB\")) res = GF_KEY_TAB;\n\telse if (strlen(sep)==1) {\n\t\tchar c;\n\t\tsscanf(sep, \"%c\", &c);\n\t\tres = c;\n\t} else {\n\t\tgf_bt_report(parser, GF_OK, \"unrecognized keyword %s - skipping\", str);\n\t\tres = 0;\n\t}\n\tif (strchr(str, '-')) *val = -res;\n\telse *val = res;\n\treturn 1;\n}\n\nGF_Err gf_bt_parse_float(GF_BTParser *parser, const char *name, Fixed *val)\n{\n\ts32 var;\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, &var)) {\n\t\t*val = INT2FIX(var);\n\t\treturn GF_OK;\n\t}\n\tif (sscanf(str, \"%g\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\t*val = FLT2FIX(f);\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_double(GF_BTParser *parser, const char *name, SFDouble *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\tif (sscanf(str, \"%lf\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_int(GF_BTParser *parser, const char *name, SFInt32 *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (check_keyword(parser, str, val)) return GF_OK;\n\t/*URL ODID*/\n\tif (!strnicmp(str, \"od:\", 3)) str += 3;\n\tif (sscanf(str, \"%d\", val) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\treturn GF_OK;\n}\nGF_Err gf_bt_parse_bool(GF_BTParser *parser, const char *name, SFBool *val)\n{\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (!stricmp(str, \"true\") || !strcmp(str, \"1\") ) {\n\t\t*val = 1;\n\t}\n\telse if (!stricmp(str, \"false\") || !strcmp(str, \"0\") ) {\n\t\t*val = 0;\n\t} else {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Boolean expected\", name);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_bt_parse_color(GF_BTParser *parser, const char *name, SFColor *col)\n{\n\tFloat f;\n\tu32 val;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\tif (sscanf(str, \"%f\", &f) == 1) {\n\t\tcol->red = FLT2FIX(f);\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->green);\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, name, & col->blue);\n\t\treturn parser->last_error;\n\t}\n\tval = gf_color_parse(str);\n\tif (!val) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number or name expected\", name);\n\t}\n\tcol->red = INT2FIX((val>>16) & 0xFF) / 255;\n\tcol->green = INT2FIX((val>>8) & 0xFF) / 255;\n\tcol->blue = INT2FIX(val & 0xFF) / 255;\n\treturn parser->last_error;\n}\n\nGF_Err gf_bt_parse_colorRGBA(GF_BTParser *parser, const char *name, SFColorRGBA *col)\n{\n\tFloat f;\n\tchar *str = gf_bt_get_next(parser, 0);\n\tif (!str) return parser->last_error = GF_IO_ERR;\n\tif (gf_bt_check_externproto_field(parser, str)) return GF_OK;\n\n\t/*HTML code*/\n\tif (str[0]=='$') {\n\t\tu32 val;\n\t\tsscanf(str, \"%x\", &val);\n\t\tcol->red = INT2FIX((val>>24) & 0xFF) / 255;\n\t\tcol->green = INT2FIX((val>>16) & 0xFF) / 255;\n\t\tcol->blue = INT2FIX((val>>8) & 0xFF) / 255;\n\t\tcol->alpha = INT2FIX(val & 0xFF) / 255;\n\t\treturn parser->last_error;\n\t}\n\tif (sscanf(str, \"%f\", &f) != 1) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Number expected\", name);\n\t}\n\tcol->red = FLT2FIX(f);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->green);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->blue);\n\tgf_bt_check_code(parser, ',');\n\tgf_bt_parse_float(parser, name, & col->alpha);\n\treturn parser->last_error;\n}\n\nstatic void gf_bt_offset_time(GF_BTParser *parser, Double *time)\n{\n\tif (!parser->is_wrl) {\n\t\tDouble res;\n\t\tres = parser->au_time;\n\t\tres /= parser->bifs_es->timeScale;\n\t\t*time += res;\n\t}\n}\n\nstatic void gf_bt_check_time_offset(GF_BTParser *parser, GF_Node *n, GF_FieldInfo *info)\n{\n\tif (!n || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\tif (gf_node_get_tag(n) != TAG_ProtoNode) {\n\t\tif (!stricmp(info->name, \"startTime\") || !stricmp(info->name, \"stopTime\"))\n\t\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t} else if (gf_sg_proto_field_is_sftime_offset(n, info)) {\n\t\tgf_bt_offset_time(parser, (Double *)info->far_ptr);\n\t}\n}\nstatic void gf_bt_update_timenode(GF_BTParser *parser, GF_Node *node)\n{\n\tif (!node || !(parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK)) return;\n\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_AnimationStream:\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AnimationStream*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioBuffer:\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioBuffer*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioClip:\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioClip*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioSource:\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_AudioSource*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_MovieTexture:\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_MovieTexture*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_TimeSensor:\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->startTime);\n\t\tgf_bt_offset_time(parser, & ((M_TimeSensor*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_ProtoNode:\n\t{\n\t\tu32 i, nbFields;\n\t\tGF_FieldInfo inf;\n\t\tnbFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tgf_node_get_field(node, i, &inf);\n\t\t\tif (inf.fieldType != GF_SG_VRML_SFTIME) continue;\n\t\t\tgf_bt_check_time_offset(parser, node, &inf);\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\n\nvoid gf_bt_sffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tswitch (info->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\tgf_bt_parse_int(parser, info->name, (SFInt32 *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFBOOL:\n\t\tgf_bt_parse_bool(parser, info->name, (SFBool *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tgf_bt_parse_float(parser, info->name, (SFFloat *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFDOUBLE:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tgf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_check_time_offset(parser, n, info);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tgf_bt_parse_color(parser, info->name, (SFColor *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\t\tgf_bt_parse_colorRGBA(parser, info->name, (SFColorRGBA *)info->far_ptr);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3D:\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC4F:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\t/*many VRML files use ',' separator*/\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->x);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->y);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->z);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->q);\n\t\tif (parser->last_error) return;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str)\n\t\t\t\tgoto err;\n\t\t\tif (((SFString *)info->far_ptr)->buffer) gf_free(((SFString *)info->far_ptr)->buffer);\n\t\t\t((SFString *)info->far_ptr)->buffer = NULL;\n\t\t\tif (strlen(str))\n\t\t\t\t((SFString *)info->far_ptr)->buffer = str;\n\t\t\telse\n\t\t\t\tgf_free(str);\n\n\t\t\tif (n && (n->sgprivate->tag==TAG_MPEG4_BitWrapper)) {\n\t\t\t\tgf_sm_update_bitwrapper_buffer(n, parser->load->fileName);\n\t\t\t}\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tu8 delim = 0;\n\t\tif (gf_bt_check_code(parser, '\\\"')) delim = '\\\"';\n\t\telse if (gf_bt_check_code(parser, '\\'')) delim = '\\'';\n\t\tif (delim) {\n\t\t\tSFURL *url = (SFURL *)info->far_ptr;\n\t\t\tchar *str = gf_bt_get_string(parser, delim);\n\t\t\tif (!str) goto err;\n\t\t\tif (url->url) gf_free(url->url);\n\t\t\turl->url = NULL;\n\t\t\turl->OD_ID = 0;\n\t\t\tif (strchr(str, '#')) {\n\t\t\t\turl->url = str;\n\t\t\t} else {\n\t\t\t\tu32 id = 0;\n\t\t\t\tchar *odstr = str;\n\t\t\t\tif (!strnicmp(str, \"od://\", 5)) odstr += 5;\n\t\t\t\telse if (!strnicmp(str, \"od:\", 3)) odstr += 3;\n\t\t\t\t/*be careful, an url like \"11-regression-test.mp4\" will return 1 on sscanf :)*/\n\t\t\t\tif (sscanf(odstr, \"%u\", &id) == 1) {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%u\", id);\n\t\t\t\t\tif (strcmp(szURL, odstr)) id=0;\n\t\t\t\t}\n\t\t\t\tif (id) {\n\t\t\t\t\turl->OD_ID = id;\n\t\t\t\t\tgf_free(str);\n\t\t\t\t} else {\n\t\t\t\t\turl->url = str;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts32 val;\n\t\t\tgf_bt_parse_int(parser, info->name, & val );\n\t\t\tif (parser->last_error) return;\n\t\t\t((SFURL *)info->far_ptr)->OD_ID = val;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)info->far_ptr;\n\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\tGF_Command *prev_com = parser->cur_com;\n\t\t\twhile (!parser->last_error) {\n\t\t\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\t\t\tparser->last_error = gf_bt_parse_bifs_command(parser, NULL, cb->commandList);\n\t\t\t}\n\t\t\tparser->cur_com = prev_com;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t{\n\t\tu32 i, size, v;\n\t\tSFImage *img = (SFImage *)info->far_ptr;\n\t\tgf_bt_parse_int(parser, \"width\", (SFInt32 *)&img->width);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"height\", (SFInt32 *)&img->height);\n\t\tif (parser->last_error) return;\n\t\tgf_bt_parse_int(parser, \"nbComp\", (SFInt32 *)&v);\n\t\tif (parser->last_error) return;\n\t\timg->numComponents = v;\n\t\tsize = img->width * img->height * img->numComponents;\n\t\tif (img->pixels) gf_free(img->pixels);\n\t\timg->pixels = (unsigned char*)gf_malloc(sizeof(char) * size);\n\t\tfor (i=0; i<size; i++) {\n\t\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\t\tif (strstr(str, \"0x\")) sscanf(str, \"%x\", &v);\n\t\t\telse sscanf(str, \"%u\", &v);\n\t\t\tswitch (img->numComponents) {\n\t\t\tcase 1:\n\t\t\t\timg->pixels[i] = (char) v;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\timg->pixels[i] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v)&0xFF;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->pixels[i] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v)&0xFF;\n\t\t\t\ti+=2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\timg->pixels[i] = (char) (v>>24)&0xFF;\n\t\t\t\timg->pixels[i+1] = (char) (v>>16)&0xFF;\n\t\t\t\timg->pixels[i+2] = (char) (v>>8)&0xFF;\n\t\t\t\timg->pixels[i+3] = (char) (v)&0xFF;\n\t\t\t\ti+=3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t{\n\t\tSFScript *sc = (SFScript *) info->far_ptr;\n\t\tif (!gf_bt_check_code(parser, '\\\"')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"\\\" expected in Script\");\n\t\t}\n\t\tsc->script_text = (char*)gf_bt_get_string(parser, '\\\"');\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef*) info->far_ptr;\n\t\tchar *str = gf_bt_get_next(parser, 1);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"'.' expected in SFAttrRef\");\n\t\t} else {\n\t\t\tGF_FieldInfo pinfo;\n\t\t\tar->node = gf_bt_peek_node(parser, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (gf_node_get_field_by_name(ar->node, str, &pinfo) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"field %s is not a member of node %s\", str, gf_node_get_class_name(ar->node) );\n\t\t\t} else {\n\t\t\t\tar->fieldIndex = pinfo.fieldIndex;\n\t\t\t}\n\t\t}\n\n\t}\n\tbreak;\n\tdefault:\n\t\tparser->last_error = GF_NOT_SUPPORTED;\n\t\tbreak;\n\n\t}\n\tgf_bt_check_code(parser, ',');\n\treturn;\nerr:\n\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid field syntax\", info->name);\n}\n\nvoid gf_bt_mffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_FieldInfo sfInfo;\n\tBool force_single = 0;\n\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\tif (parser->is_extern_proto_field) return;\n\t\tforce_single = 1;\n\t}\n\n\tsfInfo.fieldType = gf_sg_vrml_get_sf_type(info->fieldType);\n\tsfInfo.name = info->name;\n\tgf_sg_vrml_mf_reset(info->far_ptr, info->fieldType);\n\n\twhile (!gf_bt_check_code(parser, ']')) {\n\t\tgf_sg_vrml_mf_append(info->far_ptr, info->fieldType, &sfInfo.far_ptr);\n\t\tgf_bt_sffield(parser, &sfInfo, n);\n\t\tif (parser->last_error) return;\n\n\t\tgf_bt_check_code(parser, ',');\n\t\tif (force_single) break;\n\t}\n}\n\nBool gf_bt_check_ndt(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *node, GF_Node *parent)\n{\n\tif (!node) return 1;\n\tif (parent->sgprivate->tag == TAG_MPEG4_Script) return 1;\n#ifndef GPAC_DISABLE_X3D\n\tif (parent->sgprivate->tag == TAG_X3D_Script) return 1;\n#endif\n\tif (node->sgprivate->tag == TAG_UndefinedNode) return 1;\n\n\t/*this handles undefined nodes*/\n\tif (gf_node_in_table(node, info->NDTtype)) return 1;\n\t/*not found*/\n\tgf_bt_report(parser, GF_BAD_PARAM, \"node %s not valid in field %s\\n\", gf_node_get_class_name(node), info->name);\n\tgf_node_unregister(node, parent);\n\treturn 0;\n}\n\nu32 gf_bt_get_next_node_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_node_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_node_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_route_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sg = parser->load->scene_graph;\n\tif (parser->parsing_proto) sg = gf_sg_proto_get_graph(parser->parsing_proto);\n\n\tID = gf_sg_get_next_available_route_id(sg);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_route_id))\n\t\tparser->load->ctx->max_route_id = ID;\n\treturn ID;\n}\nu32 gf_bt_get_next_proto_id(GF_BTParser *parser)\n{\n\tu32 ID;\n\tGF_SceneGraph *sc = parser->load->scene_graph;\n\tif (parser->parsing_proto) sc = gf_sg_proto_get_graph(parser->parsing_proto);\n\tID = gf_sg_get_next_available_proto_id(sc);\n\tif (parser->load->ctx && (ID>parser->load->ctx->max_node_id))\n\t\tparser->load->ctx->max_proto_id = ID;\n\treturn ID;\n}\n\nu32 gf_bt_get_def_id(GF_BTParser *parser, char *defName)\n{\n\tGF_Node *n=NULL;\n\tu32 ID=0;\n\tif (sscanf(defName, \"N%u\", &ID) == 1) {\n\t\tu32 k=1;\n\t\twhile (defName[k]) {\n\t\t\tif (strchr(\"0123456789\", defName[k])==0) {\n\t\t\t\tID = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tif (ID) {\n\t\t\tID ++;\n\t\t\tn = gf_sg_find_node(parser->load->scene_graph, ID);\n\t\t\tif (!n) {\n\t\t\t\tif (parser->load->ctx && (parser->load->ctx->max_node_id<ID)) parser->load->ctx->max_node_id=ID;\n\t\t\t\treturn ID;\n\t\t\t}\n\t\t}\n\t}\n\n\tID = gf_bt_get_next_node_id(parser);\n\tif (n) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[BT Parsing] (line %d) Binary ID %d already assigned to %s - keeping internal ID %d\", parser->line, gf_node_get_name(n), ID));\n\t}\n\treturn ID;\n}\n\nBool gf_bt_set_field_is(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_FieldInfo pinfo;\n\tchar *str;\n\tgf_bt_check_line(parser);\n\ti=0;\n\twhile ((parser->line_buffer[parser->line_pos + i] == ' ') || (parser->line_buffer[parser->line_pos + i] == '\\t')) i++;\n\tif (strnicmp(&parser->line_buffer[parser->line_pos + i] , \"IS\", 2)) return 0;\n\n\tgf_bt_get_next(parser, 0);\n\tstr = gf_bt_get_next(parser, 0);\n\n\t/*that's an ISed field*/\n\tpfield = gf_sg_proto_field_find_by_name(parser->parsing_proto, str);\n\tif (!pfield) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto field\", str);\n\t\treturn 1;\n\t}\n\tgf_sg_proto_field_get_field(pfield, &pinfo);\n\te = gf_sg_proto_field_set_ised(parser->parsing_proto, pinfo.fieldIndex, n, info->fieldIndex);\n\tif (e) gf_bt_report(parser, GF_BAD_PARAM, \"IS: Invalid field type for field %s\", info->name);\n\treturn 1;\n}\n\nvoid gf_bt_check_unresolved_nodes(GF_BTParser *parser)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->undef_nodes);\n\tif (!count) return;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->undef_nodes, i);\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Cannot find node %s\\n\", gf_node_get_name(n) );\n\t\tgf_node_unregister(n, NULL);\n\t}\n\tparser->last_error = GF_BAD_PARAM;\n}\n\nBool gf_bt_has_been_def(GF_BTParser *parser, char *node_name)\n{\n\tu32 i, count;\n\tcount = gf_list_count(parser->def_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Node *n = (GF_Node *) gf_list_get(parser->def_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), node_name)) return 1;\n\t}\n\treturn 0;\n}\n\nu32 gf_bt_get_node_tag(GF_BTParser *parser, char *node_name)\n{\n\tu32 tag;\n\t/*if VRML and allowing non MPEG4 nodes, use X3D*/\n\tif (parser->is_wrl && !(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) {\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(node_name);\n\t\tif (!tag)\n#endif\n\t\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (tag) return tag;\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!strcmp(node_name, \"Rectangle\")) return TAG_X3D_Rectangle2D;\n\t\tif (!strcmp(node_name, \"Circle\")) return TAG_X3D_Circle2D;\n#endif\n\t} else {\n\t\ttag = gf_node_mpeg4_type_by_class_name(node_name);\n\t\tif (!tag) {\n\t\t\tif (!strcmp(node_name, \"Rectangle2D\")) return TAG_MPEG4_Rectangle;\n\t\t\tif (!strcmp(node_name, \"Circle2D\")) return TAG_MPEG4_Circle;\n#ifndef GPAC_DISABLE_X3D\n\t\t\tif (!(parser->load->flags & GF_SM_LOAD_MPEG4_STRICT)) return gf_node_x3d_type_by_class_name(node_name);\n#endif\n\t\t}\n\t}\n\treturn tag;\n}\n\nGF_Node *gf_bt_sf_node(GF_BTParser *parser, char *node_name, GF_Node *parent, char *szDEFName)\n{\n\tu32 tag, ID;\n\tBool is_script, replace_prev, register_def;\n\tGF_Proto *proto;\n\tGF_Node *node, *newnode, *undef_node;\n\tGF_FieldInfo info;\n\tBool init_node;\n\tchar *name;\n\tchar * str;\n\n\tinit_node = 0;\n\n\tif (node_name) {\n\t\tstr = node_name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\tname = NULL;\n\tif (!strcmp(str, \"NULL\")) return NULL;\n\n\tID = 0;\n\tregister_def = 0;\n\treplace_prev = 0;\n\tundef_node = NULL;\n\tif (!strcmp(str, \"DEF\")) {\n\t\tregister_def = 1;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tname = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else if (szDEFName) {\n\t\tname = gf_strdup(szDEFName);\n\t\tregister_def = 1;\n\t}\n\tif (name) {\n\t\tundef_node = gf_sg_find_node_by_name(parser->load->scene_graph, name);\n\t\tif (undef_node) {\n\t\t\tgf_list_del_item(parser->peeked_nodes, undef_node);\n\t\t\tID = gf_node_get_id(undef_node);\n\t\t\t/*if we see twice a DEF N1 then force creation of a new node*/\n\t\t\tif (gf_bt_has_been_def(parser, name)) {\n\t\t\t\tundef_node = NULL;\n\t\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t\t\tgf_bt_report(parser, GF_OK, \"Node %s has been DEFed several times, IDs may get corrupted\", name);\n\t\t\t}\n\t\t} else {\n\t\t\tID = gf_bt_get_def_id(parser, name);\n\t\t}\n\t}\n\telse if (!strcmp(str, \"USE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tnode = gf_sg_find_node_by_name(parser->load->scene_graph, str);\n\t\tif (!node) {\n\t\t\t/*create a temp node (undefined)*/\n\t\t\tnode = gf_node_new(parser->load->scene_graph, TAG_UndefinedNode);\n\t\t\tID = gf_bt_get_def_id(parser, str);\n\t\t\tgf_node_set_id(node, ID, str);\n\t\t\tgf_node_register(node, NULL);\n\t\t\tgf_list_add(parser->undef_nodes, node);\n\t\t}\n\t\tgf_node_register(node, parent);\n\t\treturn node;\n\t}\n\tproto = NULL;\n\ttag = gf_bt_get_node_tag(parser, str);\n\tif (!tag) {\n\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\twhile (1) {\n\t\t\tproto = gf_sg_find_proto(sg, 0, str);\n\t\t\tif (proto) break;\n\t\t\tsg = sg->parent_scene;\n\t\t\tif (!sg) break;\n\t\t}\n\t\tif (!proto) {\n\t\t\t/*locate proto*/\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\treturn NULL;\n\t\t}\n\t\ttag = TAG_ProtoNode;\n\t}\n\tif (undef_node && (undef_node->sgprivate->tag == tag)) {\n\t\tnode = undef_node;\n\t} else {\n\t\tif (undef_node) replace_prev = 1;\n\t\tif (proto) {\n\t\t\tnode = gf_sg_proto_create_instance(parser->load->scene_graph, proto);\n\t\t} else {\n\t\t\tnode = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tif (!parser->parsing_proto) init_node = 1;\n\t}\n\tis_script = 0;\n\tif ((tag==TAG_MPEG4_Script)\n#ifndef GPAC_DISABLE_X3D\n\t        || (tag==TAG_X3D_Script)\n#endif\n\t   )\n\t\tis_script = 1;\n\n\tif (!node) {\n\t\tparser->last_error = GF_SG_UNKNOWN_NODE;\n\t\treturn NULL;\n\t}\n\tif (register_def) gf_list_add(parser->def_nodes, node);\n\n\tgf_node_register(node, parent);\n\n\t/*VRML: \"The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node\n\tin the transformation hierarchy is its own ancestor\"\n\tthat's good, because the scene graph can't handle cyclic graphs (destroy will never be called).\n\tHowever we still have to register the node before parsing it, to update node registry and get correct IDs*/\n\tif (name) {\n\t\tif (!undef_node || replace_prev) {\n\t\t\tgf_node_set_id(node, ID, name);\n\t\t}\n\t\tgf_free(name);\n\t\tname = NULL;\n\t}\n\tif (!parser->parsing_proto) gf_bt_update_timenode(parser, node);\n\n\tif (gf_bt_check_code(parser, '{')) {\n\n\t\twhile (1) {\n\t\t\tif (gf_bt_check_code(parser, '}'))\n\t\t\t\tbreak;\n\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!str) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid node syntax\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t/*VRML/X3D specific */\n\t\t\tif (parser->is_wrl) {\n\t\t\t\t/*we ignore bboxCenter and bboxSize*/\n\t\t\t\tif (!strcmp(str, \"bboxCenter\") || !strcmp(str, \"bboxSize\")) {\n\t\t\t\t\tFixed f;\n\t\t\t\t\tgf_bt_parse_float(parser, \"x\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"y\", &f);\n\t\t\t\t\tgf_bt_parse_float(parser, \"z\", &f);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*some VRML files declare routes almost anywhere*/\n\t\t\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\t\t\tgf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t/*check common VRML fields removed in MPEG4*/\n\t\t\tif (parser->last_error) {\n\t\t\t\tif (!parser->is_wrl) {\n\t\t\t\t\t/*we ignore 'solid' for MPEG4 box/cone/etc*/\n\t\t\t\t\tif (!strcmp(str, \"solid\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"solid\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*we ignore 'description' for MPEG4 sensors*/\n\t\t\t\t\telse if (!strcmp(str, \"description\")) {\n\t\t\t\t\t\tchar *tmpstr = gf_bt_get_string(parser, 0);\n\t\t\t\t\t\tgf_free(tmpstr);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/*remaps X3D to old VRML/MPEG4*/\n\t\t\t\t\telse if ((tag==TAG_MPEG4_LOD) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"level\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_MPEG4_Switch) && !strcmp(str, \"children\")) {\n\t\t\t\t\t\tstr = \"choice\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(str, \"enabled\")) {\n\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\tgf_bt_parse_bool(parser, \"collide\", &b);\n\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*remaps old VRML/MPEG4 to X3D if possible*/\n#ifndef GPAC_DISABLE_X3D\n\t\t\t\t\tif ((tag==TAG_X3D_LOD) && !strcmp(str, \"level\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((tag==TAG_X3D_Switch) && !strcmp(str, \"choice\")) {\n\t\t\t\t\t\tstr = \"children\";\n\t\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tif (!strcmp(str, \"collide\")) {\n\t\t\t\t\t\t\tSFBool b;\n\t\t\t\t\t\t\tgf_bt_parse_bool(parser, \"enabled\", &b);\n\t\t\t\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_script && parser->last_error) {\n\t\t\t\tu32 eType, fType;\n\n\t\t\t\tif (!strcmp(str, \"eventIn\") || !strcmp(str, \"inputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_IN;\n\t\t\t\telse if (!strcmp(str, \"eventOut\") || !strcmp(str, \"outputOnly\")) eType = GF_SG_SCRIPT_TYPE_EVENT_OUT;\n\t\t\t\telse if (!strcmp(str, \"field\") || !strcmp(str, \"initializeOnly\")) eType = GF_SG_SCRIPT_TYPE_FIELD;\n\t\t\t\telse {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script event type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tfType = gf_sg_field_type_by_name(str);\n\t\t\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown script field type\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tparser->last_error = GF_OK;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_sg_script_field_new(node, eType, fType, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(node, str, &info);\n\n\t\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\t\t\t\tif ((eType == GF_SG_SCRIPT_TYPE_EVENT_IN) || (eType == GF_SG_SCRIPT_TYPE_EVENT_OUT)) continue;\n\t\t\t}\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, parser->last_error, \"%s: Unknown field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (proto) gf_sg_proto_mark_field_loaded(node, &info);\n\t\t\tif (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (* ((GF_Node **)info.far_ptr) ) {\n\t\t\t\t\tgf_node_unregister(* ((GF_Node **)info.far_ptr), node);\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = NULL;\n\t\t\t\t}\n\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\tif (newnode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\n\t\t\t\t\t* ((GF_Node **)info.far_ptr) = newnode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tBool single_child = 0;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tif (parser->is_wrl) single_child = 1;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\n\t\t\t\t/*if redefining node reset it - this happens with CreateVrmlFromString*/\n\t\t\t\tif (undef_node==node) {\n\t\t\t\t\tgf_node_unregister_children(node, *(GF_ChildNodeItem **)info.far_ptr);\n\t\t\t\t\t*(GF_ChildNodeItem **)info.far_ptr = NULL;\n\t\t\t\t}\n\n\t\t\t\twhile (single_child || !gf_bt_check_code(parser, ']')) {\n\t\t\t\t\t/*VRML seems to allow that*/\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, node, NULL);\n\t\t\t\t\tif (!newnode && parser->last_error) goto err;\n\t\t\t\t\tif (newnode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;\n\t\t\t\t\t\tgf_node_list_add_child_last( (GF_ChildNodeItem **)info.far_ptr, newnode, &last);\n\t\t\t\t\t}\n\t\t\t\t\tif (single_child) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, node);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, node);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*VRML seems to allow that*/\n\t\t\tgf_bt_check_code(parser, ',');\n\t\t}\n\t}\n\t/*VRML seems to allow that*/\n\tgf_bt_check_code(parser, ',');\n\n\t/*we must init the node once ID is set in case we're creating rendering stacks*/\n\tif (init_node && (gf_node_get_tag(node)!=TAG_ProtoNode) ) gf_node_init(node);\n\n\t/*remove temp node*/\n\tif (replace_prev) {\n\t\tgf_node_replace(undef_node, node, 0);\n\t\tgf_node_unregister(undef_node, NULL);\n\t\tgf_list_del_item(parser->undef_nodes, undef_node);\n\t}\n\n\tif (!parser->parsing_proto && is_script && (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) ) {\n\t\tif (parser->cur_com) {\n\t\t\tif (!parser->cur_com->scripts_to_load) parser->cur_com->scripts_to_load = gf_list_new();\n\t\t\tgf_list_add(parser->cur_com->scripts_to_load, node);\n\t\t} else {\n\t\t\t/*postpone script init since it may use routes/nodes not yet defined ...*/\n\t\t\tgf_list_add(parser->scripts, node);\n\t\t}\n\t}\n\t/*For Ivica: load proto as soon as found when in playback mode*/\n\tif ( (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) && proto && !parser->parsing_proto) {\n\t\tparser->last_error = gf_sg_proto_load_code(node);\n\t}\n\treturn node;\n\nerr:\n\tgf_node_unregister(node, parent);\n\tif (name) gf_free(name);\n\treturn NULL;\n}\n/*\n\tlocate node, if not defined yet parse ahead in current AU\n\toptimization: we actually peek ALL DEF NODES till end of AU\n*/\nGF_Node *gf_bt_peek_node(GF_BTParser *parser, char *defID)\n{\n\tGF_Node *n, *the_node;\n\tu32 tag, ID;\n\tBool prev_is_insert = 0;\n\tchar *ret;\n\tchar nName[1000];\n\tu32 pos, line, line_pos, i, count;\n\n\tn = gf_sg_find_node_by_name(parser->load->scene_graph, defID);\n\tif (n) return n;\n\n\tcount = gf_list_count(parser->peeked_nodes);\n\tfor (i=0; i<count; i++) {\n\t\tn = (GF_Node *)gf_list_get(parser->peeked_nodes, i);\n\t\tif (!strcmp(gf_node_get_name(n), defID)) return n;\n\t}\n\n\tthe_node = NULL;\n\tpos = parser->line_start_pos;\n\tline_pos = parser->line_pos;\n\tline = parser->line;\n\tstrcpy(nName, defID);\n\n\tn = NULL;\n\twhile (!parser->done && !the_node) {\n\t\tchar *str = gf_bt_get_next(parser, 0);\n\t\tgf_bt_check_code(parser, '[');\n\t\tgf_bt_check_code(parser, ']');\n\t\tgf_bt_check_code(parser, '{');\n\t\tgf_bt_check_code(parser, '}');\n\t\tgf_bt_check_code(parser, ',');\n\t\tgf_bt_check_code(parser, '.');\n\n\t\tif ( (!prev_is_insert && !strcmp(str, \"AT\")) || !strcmp(str, \"PROTO\") ) {\n\t\t\t/*only check in current command (but be aware of conditionals..)*/\n\t\t\tif (gf_list_find(parser->bifs_au->commands, parser->cur_com)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(str, \"INSERT\")) prev_is_insert = 1;\n\t\telse prev_is_insert = 0;\n\n\t\tif (strcmp(str, \"DEF\")) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tret = gf_strdup(str);\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tgf_free(ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag = gf_bt_get_node_tag(parser, str);\n\t\tif (!tag) {\n\t\t\tGF_Proto *p;\n\t\t\tGF_SceneGraph *sg = parser->load->scene_graph;\n\t\t\twhile (1) {\n\t\t\t\tp = gf_sg_find_proto(sg, 0, str);\n\t\t\t\tif (p) break;\n\t\t\t\tsg = sg->parent_scene;\n\t\t\t\tif (!sg) break;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\t/*locate proto*/\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: not a valid/supported node\", str);\n\t\t\t\tgf_free(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tn = gf_sg_proto_create_instance(parser->load->scene_graph, p);\n\t\t} else {\n\t\t\tn = gf_node_new(parser->load->scene_graph, tag);\n\t\t}\n\t\tID = gf_bt_get_def_id(parser, ret);\n\t\tif (n) {\n\t\t\tgf_node_set_id(n, ID, ret);\n\t\t\tgf_list_add(parser->peeked_nodes, n);\n\t\t\tif (!parser->parsing_proto) gf_node_init(n);\n\t\t\tif (!strcmp(ret, nName)) the_node = n;\n\t\t}\n\t\tgf_free(ret);\n\n\t\t/*NO REGISTER on peek (both scene graph or DEF list) because peek is only used to get node type\n\t\tand fields, never to insert in the graph*/\n\n\t\t/*go on till end of AU*/\n\t}\n\t/*restore context*/\n\tparser->done = 0;\n\tgf_gzrewind(parser->gz_in);\n\tgf_gzseek(parser->gz_in, pos, SEEK_SET);\n\tparser->line_pos = parser->line_size;\n\tgf_bt_check_line(parser);\n\tparser->line = line;\n\tparser->line_pos = line_pos;\n\n\treturn the_node;\n}\n\nu32 gf_bt_get_route(GF_BTParser *parser, char *name)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find_by_name(parser->load->scene_graph, name);\n\tif (r) return r->ID;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->def_name && !strcmp(com->def_name, name)) return com->RouteID;\n\t}\n\treturn 0;\n}\n\nBool gf_bt_route_id_used(GF_BTParser *parser, u32 ID)\n{\n\tu32 i;\n\tGF_Command *com;\n\tGF_Route *r = gf_sg_route_find(parser->load->scene_graph, ID);\n\tif (r) return 1;\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(parser->inserted_routes, &i))) {\n\t\tif (com->RouteID == ID) return 1;\n\t}\n\treturn 0;\n}\n\nstatic u32 get_evt_type(char *eventName)\n{\n\tif (!strcmp(eventName, \"eventIn\") || !strcmp(eventName, \"inputOnly\")) return GF_SG_EVENT_IN;\n\telse if (!strcmp(eventName, \"eventOut\") || !strcmp(eventName, \"outputOnly\")) return GF_SG_EVENT_OUT;\n\telse if (!strcmp(eventName, \"field\") || !strcmp(eventName, \"initializeOnly\")) return GF_SG_EVENT_FIELD;\n\telse if (!strcmp(eventName, \"exposedField\") || !strcmp(eventName, \"inputOutput\")) return GF_SG_EVENT_EXPOSED_FIELD;\n\telse return GF_SG_EVENT_UNKNOWN;\n}\n\nGF_Err gf_bt_parse_proto(GF_BTParser *parser, char *proto_code, GF_List *proto_list)\n{\n\tGF_FieldInfo info;\n\tu32 fType, eType, QPType=0, pID;\n\tBool externProto;\n\tGF_Proto *proto, *prevproto;\n\tGF_ProtoFieldInterface *pfield;\n\tGF_SceneGraph *sg;\n\tchar *str, *name;\n\tchar szDefName[1024];\n\tBool isDEF;\n\n\tif (proto_code)\n\t\tstr = proto_code;\n\telse\n\t\tstr = gf_bt_get_next(parser, 0);\n\n\texternProto = !strcmp(str, \"EXTERNPROTO\") ? 1 : 0;\n\tstr = gf_bt_get_next(parser, 0);\n\tname = gf_strdup(str);\n\tif (!gf_bt_check_code(parser, '[')) {\n\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected in proto declare\");\n\t}\n\tpID = gf_bt_get_next_proto_id(parser);\n\t/*if redefinition remove it - WRL only, may be used by loadVRMLFormString*/\n\tif (!proto_list && parser->is_wrl) {\n\t\tproto = gf_sg_find_proto(parser->load->scene_graph, pID, name);\n\t\tif (proto) gf_sg_proto_del(proto);\n\t}\n\tproto = gf_sg_proto_new(parser->load->scene_graph, pID, name, proto_list ? 1 : 0);\n\tif (proto_list) gf_list_add(proto_list, proto);\n\tif (parser->load->ctx && (parser->load->ctx->max_proto_id<pID)) parser->load->ctx->max_proto_id = pID;\n\n\t/*hack for VRML, where externProto default field values are not mandatory*/\n\tparser->is_extern_proto_field = externProto;\n\n\tgf_free(name);\n\t/*get all fields*/\n\twhile (!parser->last_error && !gf_bt_check_code(parser, ']')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\nnext_field:\n\t\tif (gf_bt_check_code(parser, ']')) break;\n\n\t\teType = get_evt_type(str);\n\t\tif (eType==GF_SG_EVENT_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown event type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tfType = gf_sg_field_type_by_name(str);\n\t\tif (fType==GF_SG_VRML_UNKNOWN) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field type\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tpfield = gf_sg_proto_field_new(proto, fType, eType, str);\n\t\tif ((eType==GF_SG_EVENT_IN) || (eType==GF_SG_EVENT_OUT)) continue;\n\n\t\tgf_sg_proto_field_get_field(pfield, &info);\n\t\tif (fType==GF_SG_VRML_SFNODE) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"NULL\")) {\n\t\t\t\tif ( (!strlen(str) || (get_evt_type(str)!=GF_SG_EVENT_UNKNOWN)) && parser->is_extern_proto_field) goto next_field;\n\t\t\t\tpfield->def_sfnode_value = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\t}\n\t\t} else if (fType==GF_SG_VRML_MFNODE) {\n\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tGF_Node *pf_node;\n\t\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\t\tpf_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (pf_node) gf_node_list_add_child_last( &pfield->def_mfnode_value, pf_node, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (gf_sg_vrml_is_sf_field(fType)) {\n\t\t\tgf_bt_sffield(parser, &info, NULL);\n\t\t\t/*value not specified for externproto*/\n\t\t\tif (parser->last_error==GF_EOS) {\n\t\t\t\tparser->last_error=GF_OK;\n\t\t\t\tgoto next_field;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bt_mffield(parser, &info, NULL);\n\t\t}\n\t\t/*check QP info*/\n\t\tif (!gf_bt_check_code(parser, '{')) continue;\n\t\tif (gf_bt_check_code(parser, '}')) continue;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"QP\")) {\n\t\t\tu32 nbBits, hasMin;\n\t\t\tFixed ftMin, ftMax;\n\t\t\tgf_bt_parse_int(parser, \"QPType\", (SFInt32*)&QPType);\n\n\t\t\tnbBits = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (!strcmp(str, \"nbBits\")) {\n\t\t\t\tgf_bt_parse_int(parser, \"nbBits\", (SFInt32*)&nbBits);\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\thasMin = 0;\n\t\t\teType = 0;\n\t\t\tif (!strcmp(str, \"b\")) {\n\t\t\t\thasMin = 1;\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Invalid proto coding parameter declare\", str);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tgf_bt_parse_float(parser, \"min\", &ftMin);\n\t\t\t\tgf_bt_parse_float(parser, \"max\", &ftMax);\n\t\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (gf_sg_vrml_get_sf_type(fType) == GF_SG_VRML_SFINT32) {\n\t\t\t\t\teType = GF_SG_VRML_SFINT32;\n\t\t\t\t} else {\n\t\t\t\t\teType = GF_SG_VRML_SFFLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bifs_proto_field_set_aq_info(pfield, QPType, hasMin, eType, &ftMin, &ftMax, nbBits);\n\t\t\tif (!gf_bt_check_code(parser, '}')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid proto coding parameter declare\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\tparser->is_extern_proto_field = 0;\n\n\tif (externProto) {\n\t\tSFURL *url;\n\t\tBool has_urls = 0;\n\t\tif (gf_bt_check_code(parser, '[')) has_urls = 1;\n\n\t\tgf_sg_vrml_mf_reset(&proto->ExternProto, GF_SG_VRML_MFURL);\n\t\tdo {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tgf_sg_vrml_mf_append(&proto->ExternProto, GF_SG_VRML_MFURL, (void **) &url);\n\t\t\tif (!strnicmp(str, \"od:\", 3)) {\n\t\t\t\tsscanf(str, \"od:%u\", &url->OD_ID);\n\t\t\t} else {\n\t\t\t\tif (!sscanf(str, \"%u\", &url->OD_ID)) {\n\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t} else {\n\t\t\t\t\tchar szURL[20];\n\t\t\t\t\tsprintf(szURL, \"%d\", url->OD_ID);\n\t\t\t\t\tif (strcmp(szURL, str)) {\n\t\t\t\t\t\turl->OD_ID = 0;\n\t\t\t\t\t\turl->url = gf_strdup(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_urls) {\n\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\tif (gf_bt_check_code(parser, ']')) has_urls = 0;\n\t\t\t}\n\t\t} while (has_urls);\n\t\treturn GF_OK;\n\t}\n\n\t/*parse proto code */\n\tif (!gf_bt_check_code(parser, '{')) {\n\t\tgf_bt_report(parser, GF_OK, \"empty proto body\");\n\t\treturn GF_OK;\n\t}\n\n\tprevproto = parser->parsing_proto;\n\tsg = parser->load->scene_graph;\n\tparser->parsing_proto = proto;\n\tparser->load->scene_graph = gf_sg_proto_get_graph(proto);\n\n\tisDEF = 0;\n\twhile (!gf_bt_check_code(parser, '}')) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, NULL);\n\t\t} else if (!strcmp(str, \"DEF\")) {\n\t\t\tisDEF = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDefName, str);\n\t\t} else if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Route *r = gf_bt_parse_route(parser, 1, 0, NULL);\n\t\t\tif (isDEF) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDefName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tparser->last_error = gf_sg_route_set_id(r, rID);\n\t\t\t\tgf_sg_route_set_name(r, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_Node *n = gf_bt_sf_node(parser, str, NULL, isDEF ? szDefName : NULL);\n\t\t\tisDEF = 0;\n\t\t\tif (!n) goto err;\n\t\t\tif ((0) && isDEF) {\n\t\t\t\tu32 ID = gf_bt_get_def_id(parser, szDefName);\n\t\t\t\tisDEF = 0;\n\t\t\t\tgf_node_set_id(n, ID, szDefName);\n\t\t\t}\n\t\t\tgf_sg_proto_add_node_code(proto, n);\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 1);\n\tgf_bt_check_unresolved_nodes(parser);\n\tparser->load->scene_graph = sg;\n\tparser->parsing_proto = prevproto;\n\treturn parser->last_error;\n\nerr:\n\tif (proto_list) gf_list_del_item(proto_list, proto);\n\tgf_sg_proto_del(proto);\n\treturn parser->last_error;\n}\n\n\nGF_Route *gf_bt_parse_route(GF_BTParser *parser, Bool skip_def, Bool is_insert, GF_Command *com)\n{\n\tGF_Route *r;\n\tchar *str, nstr[1000], rName[1000];\n\tu32 rID;\n\tGF_Node *orig, *dest;\n\tGF_FieldInfo orig_field, dest_field;\n\tGF_Err e;\n\n\trID = 0;\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tif (!skip_def && !strcmp(nstr, \"DEF\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(rName, str);\n\t\trID = gf_bt_get_route(parser, rName);\n\t\tif (!rID && (str[0]=='R') ) {\n\t\t\trID = atoi(&str[1]);\n\t\t\tif (rID) {\n\t\t\t\trID++;\n\t\t\t\tif (gf_bt_route_id_used(parser, rID)) rID = 0;\n\t\t\t}\n\t\t}\n\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\t}\n\torig = gf_bt_peek_node(parser, nstr);\n\tif (!orig) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(orig, &str[4], &orig_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(orig, str, &orig_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(orig), gf_node_get_class_name(orig));\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\tif (strcmp(str, \"TO\")) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"TO expected in route declaration - got \\\"%s\\\"\", str);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(nstr, gf_bt_get_next(parser, 1));\n\tdest = gf_bt_peek_node(parser, nstr);\n\tif (!dest) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"cannot find node %s\", nstr);\n\t\treturn NULL;\n\t}\n\tif (!gf_bt_check_code(parser, '.')) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \". expected in route decl\");\n\t\treturn NULL;\n\t}\n\tstr = gf_bt_get_next(parser, 0);\n\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t/*VRML loosy syntax*/\n\tif ((e != GF_OK) && parser->is_wrl && !strnicmp(str, \"set_\", 4))\n\t\te = gf_node_get_field_by_name(dest, &str[4], &dest_field);\n\n\tif ((e != GF_OK) && parser->is_wrl && strstr(str, \"_changed\")) {\n\t\tchar *s = strstr(str, \"_changed\");\n\t\ts[0] = 0;\n\t\te = gf_node_get_field_by_name(dest, str, &dest_field);\n\t}\n\n\tif (e != GF_OK) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s (%s)\", str, gf_node_get_name(dest), gf_node_get_class_name(dest));\n\t\treturn NULL;\n\t}\n\tif (com) {\n\t\tcom->fromNodeID = gf_node_get_id(orig);\n\t\tcom->fromFieldIndex = orig_field.fieldIndex;\n\t\tcom->toNodeID = gf_node_get_id(dest);\n\t\tcom->toFieldIndex = dest_field.fieldIndex;\n\t\tif (rID) {\n\t\t\tcom->RouteID = rID;\n\t\t\tcom->def_name = gf_strdup(rName);\n\t\t\t/*whenever inserting routes, keep track of max defined ID*/\n\t\t\tif (is_insert) {\n\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\tif (parser->load->ctx && (rID>parser->load->ctx->max_route_id))\n\t\t\t\t\tparser->load->ctx->max_route_id = rID;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\tr = gf_sg_route_new(parser->load->scene_graph, orig, orig_field.fieldIndex, dest, dest_field.fieldIndex);\n\tif (r && rID) {\n\t\tgf_sg_route_set_id(r, rID);\n\t\tgf_sg_route_set_name(r, rName);\n\t}\n\treturn r;\n}\n\nvoid gf_bt_resolve_routes(GF_BTParser *parser, Bool clean)\n{\n\t/*resolve all commands*/\n\twhile(gf_list_count(parser->unresolved_routes) ) {\n\t\tGF_Command *com = (GF_Command *)gf_list_get(parser->unresolved_routes, 0);\n\t\tgf_list_rem(parser->unresolved_routes, 0);\n\t\tswitch (com->tag) {\n\t\tcase GF_SG_ROUTE_DELETE:\n\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\tcom->RouteID = gf_bt_get_route(parser, com->unres_name);\n\t\t\tif (!com->RouteID) gf_bt_report(parser, GF_BAD_PARAM, \"Cannot resolve Route %s\", com->unres_name);\n\t\t\tgf_free(com->unres_name);\n\t\t\tcom->unres_name = NULL;\n\t\t\tcom->unresolved = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!clean) return;\n\twhile (gf_list_count(parser->inserted_routes)) gf_list_rem(parser->inserted_routes, 0);\n}\n\n\nstatic void bd_set_com_node(GF_Command *com, GF_Node *node)\n{\n\tcom->node = node;\n\tgf_node_register(com->node, NULL);\n}\n\nGF_Err gf_bt_parse_bifs_command(GF_BTParser *parser, char *name, GF_List *cmdList)\n{\n\ts32 pos;\n\tGF_Route *r;\n\tGF_Node *n, *newnode;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tGF_FieldInfo info;\n\tchar *str, field[1000];\n\tif (!name) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t} else {\n\t\tstr = name;\n\t}\n\tcom = NULL;\n\tpos = -2;\n\t/*REPLACE commands*/\n\tif (!strcmp(str, \"REPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tr = gf_sg_route_find_by_name(parser->load->scene_graph, str);\n\t\t\tif (!r) strcpy(field, str);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_REPLACE);\n\t\t\tif (r) {\n\t\t\t\tcom->RouteID = r->ID;\n\t\t\t} else {\n\t\t\t\tcom->unres_name = gf_strdup(field);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\tgf_bt_parse_route(parser, 1, 0, com);\n\t\t\tgf_list_add(cmdList, com);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*scene replace*/\n\t\tif (!strcmp(str, \"SCENE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\t\t\t}\n\t\t\tgf_bt_resolve_routes(parser, 1);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\twhile (gf_list_count(parser->def_nodes)) gf_list_rem(parser->def_nodes, 0);\n\n\t\t\twhile (1) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\t\t\tgf_bt_parse_proto(parser, str, com->new_proto_list);\n\t\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn = gf_bt_sf_node(parser, str, NULL, NULL);\n\t\t\tcom->node = n;\n\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\telse if (!strcmp(str, \"BEGIN\")) pos = 0;\n\n\t\tgf_bt_check_code(parser, '.');\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tif ( (parser->last_error = gf_bt_parse_int(parser, \"index\", &pos)) ) return parser->last_error;\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t}\n\t\t/*node replace*/\n\t\tif (!strcmp(field, \"BY\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\tparser->last_error = gf_node_get_field_by_name(n, field, &info);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t/*field replace*/\n\t\tif (pos==-2) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\tbd_set_com_node(com, n);\n\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\tinf->new_node = newnode;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(info.fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn parser->last_error;\n\t\t}\n\t\t/*indexed field replace*/\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*XREPLACE commands*/\n\tif (!strcmp(str, \"XREPLACE\")) {\n\t\tu32 j;\n\t\tBool force_sf=0;\n\t\tchar csep;\n\t\tGF_Node *targetNode, *idxNode, *childNode, *fromNode;\n\t\tGF_FieldInfo targetField, idxField, childField, fromField;\n\n\t\tidxNode = childNode = fromNode = NULL;\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\t/*get source node*/\n\t\tstrcpy(field, str);\n\t\ttargetNode = gf_bt_peek_node(parser, str);\n\t\tif (!targetNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t}\n\t\t/*get source field*/\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tparser->last_error = gf_node_get_field_by_name(targetNode, field, &targetField);\n\t\tif (parser->last_error)\n\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tpos = -2;\n\t\t\tstr = gf_bt_get_next(parser, 1);\n\t\t\tforce_sf = 1;\n\t\t\tif (sscanf(str, \"%d\", &pos) != 1) {\n\t\t\t\tpos = -2;\n\t\t\t\tif (!strcmp(str, \"LAST\")) pos = -1;\n\t\t\t\telse if (!strcmp(str, \"first\")) pos = 0;\n\t\t\t\telse {\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\t/*get idx node*/\n\t\t\t\t\tidxNode = gf_bt_peek_node(parser, str);\n\t\t\t\t\tif (!idxNode) return gf_bt_report(parser, GF_BAD_PARAM, \"%s: unknown node\", field);\n\t\t\t\t\tif (!gf_bt_check_code(parser, '.'))\n\t\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\n\t\t\t\t\t/*get idx field*/\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tstrcpy(field, str);\n\t\t\t\t\tparser->last_error = gf_node_get_field_by_name(idxNode, field, &idxField);\n\t\t\t\t\tif (parser->last_error)\n\t\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bt_check_code(parser, ']');\n\n\t\t\t/*check if we have a child node*/\n\t\t\tif (gf_bt_check_code(parser, '.')) {\n\t\t\t\ts32 apos = pos;\n\t\t\t\tforce_sf = 0;\n\t\t\t\tif (idxNode) {\n\t\t\t\t\tapos = 0;\n\t\t\t\t\tswitch (idxField.fieldType) {\n\t\t\t\t\tcase GF_SG_VRML_SFBOOL:\n\t\t\t\t\t\tif (*(SFBool*)idxField.far_ptr) apos = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t\t\tif (*(SFInt32*)idxField.far_ptr >=0) apos = *(SFInt32*)idxField.far_ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFFLOAT:\n\t\t\t\t\t\tif ( (*(SFFloat *)idxField.far_ptr) >=0) apos = (s32) floor( FIX2FLT(*(SFFloat*)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t\t\tif ( (*(SFTime *)idxField.far_ptr) >=0) apos = (s32) floor( (*(SFTime *)idxField.far_ptr) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchildNode = gf_node_list_get_child(*(GF_ChildNodeItem **)targetField.far_ptr, apos);\n\t\t\t\tif (!childNode)\n\t\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Cannot find child node at specified index\");\n\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tstrcpy(field, str);\n\t\t\t\tparser->last_error = gf_node_get_field_by_name(childNode, field, &childField);\n\t\t\t\tif (parser->last_error)\n\t\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\t\t\t}\n\t\t}\n\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (strcmp(str, \"BY\"))\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"BY expected got %s\", str);\n\n\t\t/*peek the next word*/\n\t\tj = 0;\n\t\twhile (strchr(\" \\n\\t\\0\", parser->line_buffer[parser->line_pos + j])) j++;\n\t\tstr = parser->line_buffer + parser->line_pos + j;\n\t\tj = 0;\n\t\twhile (!strchr(\" .\\0\", str[j])) j++;\n\t\tcsep = str[j];\n\t\tstr[j]=0;\n\t\tstrcpy(field, str);\n\t\tstr[j] = csep;\n\t\tfromNode = gf_bt_peek_node(parser, field);\n\t\tif (fromNode) {\n\t\t\tgf_bt_get_next(parser, 1);\n\n\t\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"XREPLACE: '.' expected\");\n\t\t\t}\n\t\t\t/*get source field*/\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t\tparser->last_error = gf_node_get_field_by_name(fromNode, field, &fromField);\n\t\t\tif (parser->last_error)\n\t\t\t\treturn gf_bt_report(parser, parser->last_error, \"%s: Unknown node field\", field);\n\n\t\t} else {\n\t\t\t/*regular parsing*/\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_XREPLACE);\n\t\tbd_set_com_node(com, targetNode);\n\t\tif (fromNode) {\n\t\t\tcom->fromNodeID = gf_node_get_id(fromNode);\n\t\t\tcom->fromFieldIndex = fromField.fieldIndex;\n\t\t}\n\t\tif (idxNode) {\n\t\t\tcom->toNodeID = gf_node_get_id(idxNode);\n\t\t\tcom->toFieldIndex = idxField.fieldIndex;\n\t\t}\n\t\tif (childNode) {\n\t\t\tcom->ChildNodeTag = gf_node_get_tag(childNode);\n\t\t\tif (com->ChildNodeTag==1) {\n\t\t\t\tcom->ChildNodeTag = ((GF_ProtoInstance*)childNode)->proto_interface->ID;\n\t\t\t\tcom->ChildNodeTag = -com->ChildNodeTag ;\n\t\t\t}\n\t\t\tcom->child_field = childField.fieldIndex;\n\t\t}\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = targetField.fieldIndex;\n\t\tinf->pos = pos;\n\t\tif (force_sf) {\n\t\t\tinf->fieldType = gf_sg_vrml_get_sf_type(targetField.fieldType);\n\t\t} else if (childNode) {\n\t\t\tinf->fieldType = childField.fieldType;\n\t\t} else {\n\t\t\tinf->fieldType = targetField.fieldType;\n\t\t}\n\t\tif (!fromNode) {\n\t\t\tswitch (inf->fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tif (childNode) {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t} else {\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) break;\n\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (!newnode) goto err;\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\n\t\t\t\t\tif (childNode) {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &childField, inf->new_node, childNode)) goto err;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!gf_bt_check_ndt(parser, &targetField, inf->new_node, targetNode)) goto err;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_node_list_add_child_last(& inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\t\tinfo.name = targetField.name;\n\n\t\t\t\tif (gf_sg_vrml_is_sf_field(inf->fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, childNode ? childNode : targetNode);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\n\n\t/*INSERT commands*/\n\tif (!strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\")) {\n\t\tBool is_append = !strcmp(str, \"APPEND\") ? 1 : 0;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\tgf_bt_parse_route(parser, 0, 1, com);\n\t\t\tif (parser->last_error) goto err;\n\t\t\tgf_list_add(cmdList, com);\n\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\tparser->cur_com = com;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (strcmp(str, \"AT\") && strcmp(str, \"TO\")) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, (char*) (is_append ? \"TO expected got %s\" : \"AT expected got %s\"), str);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tif (!is_append) {\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"] expected\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ unexpected in Append command\");\n\t\t\t}\n\t\t\tpos = -1;\n\t\t}\n\t\tgf_node_get_field_by_name(n, field, &info);\n\t\tif (!strcmp(field, \"children\")) {\n\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tif (parser->last_error) goto err;\n\n\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_INSERT);\n\t\t\tbd_set_com_node(com, n);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->pos = pos;\n\t\t\tinf->new_node = newnode;\n\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tif (parser->last_error) goto err;\n\t\t\tparser->cur_com = com;\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: MF type field expected\", info.name);\n\t\t\tgoto err;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_INSERT);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\t\tswitch (info.fieldType) {\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo.fieldType = inf->fieldType;\n\t\t\tinf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\tbreak;\n\t\t}\n\t\tif (parser->last_error) goto err;\n\t\tgf_list_add(cmdList, com);\n\t\tparser->cur_com = com;\n\t\treturn parser->last_error;\n\t}\n\t/*DELETE commands*/\n\tif (!strcmp(str, \"DELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tif (!strcmp(str, \"ROUTE\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_DELETE);\n\t\t\tcom->RouteID = gf_bt_get_route(parser, str);\n\t\t\tif (!com->RouteID) {\n\t\t\t\tcom->unres_name = gf_strdup(str);\n\t\t\t\tcom->unresolved = 1;\n\t\t\t\tgf_list_add(parser->unresolved_routes, com);\n\t\t\t}\n\t\t\t/*for bt<->xmt conversions*/\n\t\t\tcom->def_name = gf_strdup(str);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"DELETE %s: Unknown Node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE);\n\t\t\tbd_set_com_node(com, n);\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (gf_node_get_field_by_name(n, str, &info) != GF_OK) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s not a field of node %s\", str, gf_node_get_class_name(n) );\n\t\t}\n\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\tgf_bt_parse_int(parser, \"index\", &pos);\n\t\t\tif (!gf_bt_check_code(parser, ']'))\n\t\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\tif (info.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_FIELD_REPLACE);\n\t\t\t\tbd_set_com_node(com, n);\n\t\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\t\tinf->fieldType = info.fieldType;\n\t\t\t\tinf->new_node = NULL;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\treturn gf_list_add(cmdList, com);\n\t\t\t}\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s is an SFField - cannot indexed delete\", info.name);\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_INDEXED_DELETE);\n\t\tbd_set_com_node(com, n);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->fieldIndex = info.fieldIndex;\n\t\tinf->fieldType = info.fieldType;\n\t\tinf->pos = pos;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\t/*Extended BIFS commands*/\n\n\t/*GlobalQP commands*/\n\tif (!strcmp(str, \"GLOBALQP\")) {\n\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\tif (newnode && (newnode->sgprivate->tag != TAG_MPEG4_QuantizationParameter)) {\n\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Only QuantizationParameter node allowed in GLOBALQP\");\n\t\t\tgf_node_unregister(newnode, NULL);\n\t\t\treturn parser->last_error;\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_GLOBAL_QUANTIZER);\n\t\tcom->node = NULL;\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->new_node = newnode;\n\t\tinf->field_ptr = &inf->new_node;\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_REPLACE);\n\t\tbd_set_com_node(com, n);\n\n\t\twhile (!gf_bt_check_code(parser, '}')) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node field\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = -1;\n\n\t\t\tswitch (info.fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t{\n\t\t\t\tGF_ChildNodeItem *last = NULL;\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tnewnode = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\t\tif (parser->last_error!=GF_OK) goto err;\n\t\t\t\t\tif (!gf_bt_check_ndt(parser, &info, newnode, n)) goto err;\n\t\t\t\t\tgf_node_list_add_child_last( & inf->node_list, newnode, &last);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bt_mffield(parser, &info, n);\n\t\t\t\t}\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\t/*MultipleIndexReplace commands*/\n\tif (!strcmp(str, \"MULTIPLEINDREPLACE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown node\", field);\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '.')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \". expected\");\n\t\t}\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tparser->last_error = gf_node_get_field_by_name(n, str, &info);\n\t\tif (parser->last_error) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown field\", info.name);\n\t\t}\n\t\tif (gf_sg_vrml_is_sf_field(info.fieldType)) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"Only MF field allowed\");\n\t\t}\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_MULTIPLE_INDEXED_REPLACE);\n\t\tbd_set_com_node(com, n);\n\t\tinfo.fieldType = gf_sg_vrml_get_sf_type(info.fieldType);\n\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tpos=0;\n\t\t\tif (gf_bt_parse_int(parser, \"position\", (SFInt32 *)&pos)) goto err;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"BY\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"BY expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldIndex = info.fieldIndex;\n\t\t\tinf->fieldType = info.fieldType;\n\t\t\tinf->pos = pos;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t\tinf->new_node = gf_bt_sf_node(parser, NULL, NULL, NULL);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t\tif (!gf_bt_check_ndt(parser, &info, inf->new_node, n)) goto err;\n\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t} else {\n\t\t\t\tinfo.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t\tgf_bt_sffield(parser, &info, n);\n\t\t\t\tif (parser->last_error) goto err;\n\t\t\t}\n\t\t}\n\t\tparser->cur_com = com;\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"XDELETE\")) {\n\t\tstr = gf_bt_get_next(parser, 1);\n\t\tstrcpy(field, str);\n\t\tn = gf_bt_peek_node(parser, str);\n\t\tif (!n) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown Node\", field);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_NODE_DELETE_EX);\n\t\tbd_set_com_node(com, n);\n\t\treturn gf_list_add(cmdList, com);\n\t}\n\n\tif (!strcmp(str, \"INSERTPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\treturn gf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_INSERT);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tparser->last_error = gf_bt_parse_proto(parser, NULL, com->new_proto_list);\n\t\t\tif (parser->last_error) goto err;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\tif (!strcmp(str, \"DELETEPROTO\")) {\n\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE_ALL);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"ALL\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ALL expected\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\treturn gf_list_add(cmdList, com);\n\t\t}\n\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_PROTO_DELETE);\n\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\tGF_Proto *proto;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tproto = gf_sg_find_proto(parser->load->scene_graph, 0, str);\n\t\t\tif (!proto) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown proto\", str);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32)*(com->del_proto_list_size+1));\n\t\t\tcom->del_proto_list[com->del_proto_list_size] = proto->ID;\n\t\t\tcom->del_proto_list_size++;\n\t\t}\n\t\tgf_list_add(cmdList, com);\n\t\treturn GF_OK;\n\t}\n\treturn gf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown command syntax, str\");\n\nerr:\n\tif (com) gf_sg_command_del(com);\n\treturn parser->last_error;\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name);\n\n#ifndef GPAC_MINIMAL_ODF\nGF_IPMPX_Data *gf_bt_parse_ipmpx(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_IPMPX_Data *desc, *subdesc;\n\tGF_Descriptor *oddesc;\n\tGF_Err e;\n\tu32 type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_ipmpx_get_tag(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown IPMPX Data\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_ipmpx_data_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\t\ttype = gf_ipmpx_get_field_type(desc, str);\n\t\tswitch (type) {\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tassert(desc->tag==GF_IPMPX_CONNECT_TOOL_TAG);\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\toddesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!oddesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tassert(oddesc->tag==GF_ODF_IPMP_TAG);\n\t\t\t((GF_IPMPX_ConnectTool *)desc)->toolDescriptor = (GF_IPMP_Descriptor *)oddesc;\n\t\t\tbreak;\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tassert(desc->tag==GF_IPMPX_GET_TOOLS_RESPONSE_TAG);\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_Descriptor *ipmp_t = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!ipmp_t) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tassert(ipmp_t->tag==GF_ODF_IPMP_TOOL_TAG);\n\t\t\t\t\tgf_list_add( ((GF_IPMPX_GetToolsResponse *)desc)->ipmp_tools, ipmp_t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*IPMPX ByteArray list*/\n\t\tcase GF_ODF_FT_IPMPX_BA_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\t\tif (!str) continue;\n\t\t\t\t\tif (gf_ipmpx_set_byte_array(desc, field, str) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_check_code(parser, ',');\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX ByteArray: check if declared as sub-data or not*/\n\t\tcase GF_ODF_FT_IPMPX_BA:\n\t\t\tstr = NULL;\n\t\t\tif (gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (stricmp(str, \"array\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP ByteArray syntax is %s { array \\\"...\\\" } or %s \\\"....\\\"\\n\", field, field);\n\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\t} else {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t}\n\t\t\te = gf_ipmpx_set_byte_array(desc, field, str);\n\t\t\tif (e) {\n\t\t\t\tgf_bt_report(parser, e, \"Error assigning IPMP ByteArray %s\\n\", field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX Data list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx %s in field %s - skipping\", str, field);\n\t\t\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*regular IPMPX Data*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_ipmpx(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown ipmpx %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_ipmpx_set_sub_data(desc, field, subdesc) != GF_OK) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid ipmpx in field %s - skipping\", field);\n\t\t\t\tgf_ipmpx_data_del(subdesc);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_ipmpx_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_ipmpx_data_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn desc;\n}\n#endif\n\nstatic void gf_bt_add_desc(GF_BTParser *parser, GF_Descriptor *par, GF_Descriptor *child, char *fieldName)\n{\n\tGF_Err e = gf_odf_desc_add_desc(par, child);\n\tif (e) {\n\t\tgf_bt_report(parser, GF_OK, \"Invalid child descriptor in field %s - skipping\", fieldName);\n\t\tgf_odf_desc_del(child);\n\t}\n}\n\nGF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name)\n{\n\tchar *str, field[500];\n\tGF_Descriptor *desc, *subdesc;\n\tGF_ODF_FieldType type;\n\tu8 tag;\n\tif (name) {\n\t\tstr = name;\n\t} else {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t}\n\ttag = gf_odf_get_tag_by_name(str);\n\tif (!tag) {\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown descriptor\", str);\n\t\treturn NULL;\n\t}\n\tdesc = gf_odf_desc_new(tag);\n\n\tif (!desc) return NULL;\n\tif (!gf_bt_check_code(parser, '{')) return desc;\n\n\twhile (1) {\n\t\tBool is_anim_mask = 0;\n\t\t/*done*/\n\t\tif (gf_bt_check_code(parser, '}')) break;\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tstrcpy(field, str);\n\n\t\tif ((tag==GF_ODF_BIFS_CFG_TAG) && !strcmp(field, \"animationMask\")) {\n\t\t\tgf_bt_get_next(parser, 0);\n\t\t\tif (gf_bt_check_code(parser, '{')) is_anim_mask = 1;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(field, str);\n\t\t}\n\n\t\ttype = gf_odf_get_field_type(desc, str);\n\t\tswitch (type) {\n#ifndef GPAC_MINIMAL_ODF\n\t\t/*IPMPX list*/\n\t\tcase GF_ODF_FT_IPMPX_LIST:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data list only allowed in GF_IPMP_Descriptor\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_add( ((GF_IPMP_Descriptor *)desc)->ipmpx_data, ipmpx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IPMPX*/\n\t\tcase GF_ODF_FT_IPMPX:\n\t\t\tif(desc->tag!=GF_ODF_IPMP_TOOL_TAG) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMPX_Data only allowed in GF_IPMP_Tool\");\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tGF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);\n\t\t\t\t\tif (!ipmpx) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (ipmpx->tag==GF_IPMPX_PARAMETRIC_DESCRIPTION_TAG) {\n\t\t\t\t\t\tGF_IPMP_Tool *it = (GF_IPMP_Tool *)desc;\n\t\t\t\t\t\tif (it->toolParamDesc) gf_ipmpx_data_del((GF_IPMPX_Data *)it->toolParamDesc);\n\t\t\t\t\t\tit->toolParamDesc = (GF_IPMPX_ParametricDescription*)ipmpx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bt_report(parser, GF_OK, \"Only ToolParametricDescription allowed in GF_IPMP_Tool - skipping\");\n\t\t\t\t\t\tgf_ipmpx_data_del(ipmpx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\t/*descriptor list*/\n\t\tcase GF_ODF_FT_OD_LIST:\n\t\t\tif (gf_bt_check_code(parser, '[')) {\n\t\t\t\twhile (!gf_bt_check_code(parser, ']')) {\n\t\t\t\t\tsubdesc = gf_bt_parse_descriptor(parser, NULL);\n\t\t\t\t\tif (!subdesc) {\n\t\t\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_anim_mask)\n\t\t\t\tgf_bt_check_code(parser, '}');\n\t\t\tbreak;\n\t\t/*single descriptor*/\n\t\tcase GF_ODF_FT_OD:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tsubdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\tif (!subdesc) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Unknown desc %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bt_add_desc(parser, desc, subdesc, field);\n\t\t\tbreak;\n\t\t/*regular field*/\n\t\tdefault:\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tparser->last_error = gf_odf_set_field(desc, field, str);\n\n\t\t\tif (parser->last_error) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Invalid value %s in field %s\", str, field);\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (desc->tag == GF_ODF_BIFS_CFG_TAG) {\n\t\tGF_BIFSConfig *bcfg = (GF_BIFSConfig *)desc;\n\t\tif (!parser->load->ctx->scene_width) {\n\t\t\tparser->load->ctx->scene_width = bcfg->pixelWidth;\n\t\t\tparser->load->ctx->scene_height = bcfg->pixelHeight;\n\t\t\tparser->load->ctx->is_pixel_metrics = bcfg->pixelMetrics;\n\t\t}\n\n\t\t/*for bt->xmt*/\n\t\tif (!bcfg->version) bcfg->version = 1;\n\t}\n\telse if (desc->tag==GF_ODF_ESD_TAG) {\n\t\tGF_ESD *esd  =(GF_ESD*)desc;\n\t\tif (esd->decoderConfig) {\n\t\t\tGF_StreamContext *sc=NULL;\n\t\t\tGF_MuxInfo *mux;\n\t\t\t/*watchout for default BIFS stream*/\n\t\t\tif (parser->bifs_es && !parser->base_bifs_id && (esd->decoderConfig->streamType==GF_STREAM_SCENE)) {\n\t\t\t\tparser->bifs_es->ESID = parser->base_bifs_id = esd->ESID;\n\t\t\t\tparser->bifs_es->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\tsc = parser->bifs_es;\n\t\t\t} else {\n\t\t\t\tsc = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t/*set default timescale for systems tracks (ignored for other)*/\n\t\t\t\tif (sc) sc->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\t/*assign base OD*/\n\t\t\t\tif (!parser->base_od_id && (esd->decoderConfig->streamType==GF_STREAM_OD)) parser->base_od_id = esd->ESID;\n\t\t\t}\n\t\t\t/*assign broadcast parameter tools*/\n\t\t\tmux = gf_sm_get_mux_info(esd);\n\t\t\tif (sc && mux) {\n\t\t\t\tsc->aggregate_on_esid = mux->aggregate_on_esid;\n\t\t\t\tif (!mux->carousel_period_plus_one) sc->carousel_period  = (u32) -1;\n\t\t\t\telse sc->carousel_period = mux->carousel_period_plus_one - 1;\n\t\t\t}\n\t\t}\n\t} else if (desc->tag==GF_ODF_MUXINFO_TAG) {\n\t\tGF_MuxInfo *mi = (GF_MuxInfo *)desc;\n\t\tif (! mi->src_url) {\n\t\t\tmi->src_url = gf_strdup(parser->load->src_url ? parser->load->src_url : parser->load->fileName);\n\t\t}\n\t}\n\treturn desc;\n}\n\nvoid gf_bt_parse_od_command(GF_BTParser *parser, char *name)\n{\n\tu32 val=0;\n\tchar *str;\n\n\tif (!strcmp(name, \"UPDATE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD update*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODUpdate *odU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ObjectDescriptor\") && strcmp(str, \"InitialObjectDescriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Object Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(odU->objectDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD update*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tGF_ESDUpdate *esdU;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"IN\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IN expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdU = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n\t\t\tparser->last_error = gf_bt_parse_int(parser, \"OD_ID\", (SFInt32*)&val);\n\t\t\tif (parser->last_error) return;\n\t\t\tesdU->ODID = val;\n\t\t\tgf_list_add(parser->od_au->commands, esdU);\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"esDescr\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"esDescr expected got %s\", str);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"ES_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"ES_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(esdU->ESDescriptors, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*IPMP descriptor update*/\n\t\tif (!strcmp(str, \"IPMPD\") || !strcmp(str, \"IPMPDX\")) {\n\t\t\tGF_IPMPUpdate *ipU;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tipU = (GF_IPMPUpdate *) gf_odf_com_new(GF_ODF_IPMP_UPDATE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, ipU);\n\t\t\twhile (!parser->done) {\n\t\t\t\tGF_Descriptor *desc;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tif (strcmp(str, \"IPMP_Descriptor\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"IPMP_Descriptor expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = gf_bt_parse_descriptor(parser, str);\n\t\t\t\tif (!desc) break;\n\t\t\t\tgf_list_add(ipU->IPMPDescList, desc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"unknown OD command\", str);\n\t\treturn;\n\t}\n\tif (!strcmp(name, \"REMOVE\")) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\t/*OD remove*/\n\t\tif (!strcmp(str, \"OD\")) {\n\t\t\tGF_ODRemove *odR;\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\todR = (GF_ODRemove *) gf_odf_com_new(GF_ODF_OD_REMOVE_TAG);\n\t\t\tgf_list_add(parser->od_au->commands, odR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\todR->OD_ID = (u16*)gf_realloc(odR->OD_ID, sizeof(u16) * (odR->NbODs+1));\n\t\t\t\todR->OD_ID[odR->NbODs] = id;\n\t\t\t\todR->NbODs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t/*ESD remove*/\n\t\tif (!strcmp(str, \"ESD\")) {\n\t\t\tu32 odid;\n\t\t\tGF_ESDRemove *esdR;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (strcmp(str, \"FROM\")) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"FROM expected got %s\", str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_bt_parse_int(parser, \"ODID\", (SFInt32*)&odid);\n\t\t\tif (parser->last_error) return;\n\n\t\t\tif (!gf_bt_check_code(parser, '[')) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"[ expected\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesdR = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n\t\t\tesdR->ODID = odid;\n\t\t\tgf_list_add(parser->od_au->commands, esdR);\n\t\t\twhile (!parser->done) {\n\t\t\t\tu32 id;\n\t\t\t\tif (gf_bt_check_code(parser, ']')) break;\n\t\t\t\tgf_bt_parse_int(parser, \"ES_ID\", (SFInt32*)&id);\n\t\t\t\tif (parser->last_error) return;\n\t\t\t\tesdR->ES_ID = (u16*)gf_realloc(esdR->ES_ID, sizeof(u16) * (esdR->NbESDs+1));\n\t\t\t\tesdR->ES_ID[esdR->NbESDs] = id;\n\t\t\t\tesdR->NbESDs++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown OD command\", str);\n\t\treturn;\n\t}\n}\n\n\n\nGF_Err gf_bt_loader_run_intern(GF_BTParser *parser, GF_Command *init_com, Bool initial_run)\n{\n\tchar *str;\n\tGF_Node *node, *vrml_root_node;\n\tBool force_new_com;\n\tGF_Route *r;\n\tBool has_id;\n\tchar szDEFName[1000];\n\n\tvrml_root_node = NULL;\n\thas_id = 0;\n\n\tif (init_com)\n\t\tparser->in_com = 0 ;\n\n\tparser->cur_com = init_com;\n\n\tforce_new_com = (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) ? 1 : 0;\n\n\n\t/*create a default root node for all VRML nodes*/\n\tif (parser->is_wrl && !parser->top_nodes) {\n\t\tif (initial_run ) {\n#ifndef GPAC_DISABLE_X3D\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, (parser->load->flags & GF_SM_LOAD_MPEG4_STRICT) ? TAG_MPEG4_Group : TAG_X3D_Group);\n#else\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, TAG_MPEG4_Group);\n#endif\n\t\t\tgf_node_register(vrml_root_node, NULL);\n\t\t\tgf_node_init(vrml_root_node);\n\t\t\tgf_sg_set_root_node(parser->load->scene_graph, vrml_root_node);\n\t\t} else {\n\t\t\tvrml_root_node = gf_sg_get_root_node(parser->load->scene_graph);\n\t\t}\n\t}\n\n\tif (!parser->in_com)\n\t\tparser->stream_id = parser->load->force_es_id;\n\n\t/*parse all top-level items*/\n\twhile (!parser->last_error) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (parser->done) break;\n\n\t\tif (!strcmp(str, \"\")) {\n\t\t\t//empty string, force moving to next char\n\t\t\tif (parser->line_pos<parser->line_size) parser->line_pos++;\n\t\t}\n\t\t/*X3D specific things (ignored for now)*/\n\t\telse if (!strcmp(str, \"PROFILE\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"COMPONENT\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"META\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"IMPORT\") || !strcmp(str, \"EXPORT\")) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"X3D IMPORT/EXPORT not implemented\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*IOD*/\n\t\telse if (!strcmp(str, \"InitialObjectDescriptor\") || !strcmp(str, \"ObjectDescriptor\")) {\n\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_bt_parse_descriptor(parser, str);\n\t\t}\n\t\t/*explicit command*/\n\t\telse if (!strcmp(str, \"AT\") || !strcmp(str, \"RAP\")) {\n\t\t\tparser->au_is_rap = 0;\n\t\t\tif (!strcmp(str, \"RAP\")) {\n\t\t\t\tparser->au_is_rap = 1;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"AT\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"AT expected got %s\", str);\n\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforce_new_com = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (str[0] == 'D') {\n\t\t\t\tparser->au_time += atoi(&str[1]);\n\t\t\t} else {\n\t\t\t\tif (sscanf(str, \"%u\", &parser->au_time) != 1) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Number expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parser->last_error) break;\n\t\t\t/*reset all contexts*/\n\t\t\tif (parser->od_au && (parser->od_au->timing != parser->au_time)) parser->od_au = NULL;\n\t\t\tif (parser->bifs_au && (parser->bifs_au->timing != parser->au_time)) {\n\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tparser->stream_id = 0;\n\t\t\t/*fix for mp4tool bt which doesn't support RAP signaling: assume the first AU\n\t\t\tis always RAP*/\n\t\t\tif (!parser->au_time) parser->au_is_rap = 1;\n\n\t\t\tparser->in_com = 1;\n\n\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"IN\")) {\n\t\t\t\t\tgf_bt_parse_int(parser, \"IN\", (SFInt32*)&parser->stream_id);\n\t\t\t\t\tif (parser->last_error) break;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*done loading init frame*/\n\t\t\tif (init_com && parser->au_time) break;\n\t\t}\n\t\telse if (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, init_com ? init_com->new_proto_list : NULL);\n\t\t}\n\t\t/*compatibility for old bt (mp4tool) in ProtoLibs*/\n\t\telse if (!strcmp(str, \"NULL\")) {\n\t\t}\n\t\telse if (!strcmp(str, \"DEF\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDEFName, str);\n\t\t\thas_id = 1;\n\t\t}\n\t\telse if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Command *com = NULL;\n\t\t\tif (!parser->top_nodes && parser->bifs_au && !parser->is_wrl) {\n\t\t\t\t/*if doing a scene replace, we need route insert stuff*/\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\t}\n\n\t\t\tr = gf_bt_parse_route(parser, 1, 0, com);\n\t\t\tif (has_id) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDEFName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->RouteID = rID;\n\t\t\t\t\tcom->def_name = gf_strdup(szDEFName);\n\t\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\t} else if (r) {\n\t\t\t\t\tgf_sg_route_set_id(r, rID);\n\t\t\t\t\tgf_sg_route_set_name(r, szDEFName);\n\t\t\t\t}\n\t\t\t\thas_id = 0;\n\t\t\t}\n\t\t}\n\t\t/*OD commands*/\n\t\telse if (!strcmp(str, \"UPDATE\") || !strcmp(str, \"REMOVE\")) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\t\t\tif (!parser->stream_id || parser->stream_id==parser->bifs_es->ESID) parser->stream_id = parser->base_od_id;\n\n\t\t\tif (parser->od_es && (parser->od_es->ESID != parser->stream_id)) {\n\t\t\t\tGF_StreamContext *prev = parser->od_es;\n\t\t\t\tparser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->od_es != prev) {\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t\tparser->od_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parser->od_es) parser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\tif (!parser->od_au) parser->od_au = gf_sm_stream_au_new(parser->od_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_od_command(parser, str);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*BIFS commands*/\n\t\telse if (!strcmp(str, \"REPLACE\") || !strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\") || !strcmp(str, \"DELETE\")\n\t\t         /*BIFS extended commands*/\n\t\t         || !strcmp(str, \"GLOBALQP\") || !strcmp(str, \"MULTIPLEREPLACE\") || !strcmp(str, \"MULTIPLEINDREPLACE\") || !strcmp(str, \"XDELETE\") || !strcmp(str, \"DELETEPROTO\") || !strcmp(str, \"INSERTPROTO\")\n\t\t         || !strcmp(str, \"XREPLACE\")\n\t\t        ) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\n\t\t\tif (!parser->stream_id) parser->stream_id = parser->base_bifs_id;\n\t\t\tif (!parser->stream_id || (parser->od_es && (parser->stream_id==parser->od_es->ESID)) ) parser->stream_id = parser->base_bifs_id;\n\n\t\t\tif (parser->bifs_es->ESID != parser->stream_id) {\n\t\t\t\tGF_StreamContext *prev = parser->bifs_es;\n\t\t\t\tparser->bifs_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->bifs_es != prev) {\n\t\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_new_com) {\n\t\t\t\tforce_new_com = 0;\n\t\t\t\tparser->bifs_au = gf_list_last(parser->bifs_es->AUs);\n\t\t\t\tparser->au_time = (u32) (parser->bifs_au ? parser->bifs_au->timing : 0) + 1;\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tif (!parser->bifs_au) parser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_bifs_command(parser, str, parser->bifs_au->commands);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*implicit BIFS command on SFTopNodes only*/\n\t\telse if (!strcmp(str, \"OrderedGroup\")\n\t\t         || !strcmp(str, \"Group\")\n\t\t         || !strcmp(str, \"Layer2D\")\n\t\t         || !strcmp(str, \"Layer3D\")\n\t\t         /* VRML parsing: all nodes are allowed*/\n\t\t         || parser->is_wrl\n\t\t        )\n\t\t{\n\n\t\t\tnode = gf_bt_sf_node(parser, str, vrml_root_node, has_id ? szDEFName : NULL);\n\t\t\thas_id = 0;\n\t\t\tif (!node) break;\n\t\t\tif (parser->top_nodes) {\n\t\t\t\tgf_list_add(parser->top_nodes, node);\n\t\t\t} else if (!vrml_root_node) {\n\t\t\t\tif (init_com) init_com->node = node;\n\t\t\t\telse if (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\t\t\t\tGF_Command *com = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tassert(!parser->bifs_au);\n\t\t\t\t\tassert(parser->bifs_es);\n\t\t\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\t\tcom->node = node;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_node_insert_child(vrml_root_node, node, -1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (!gf_sg_get_root_node(parser->load->scene_graph)) {\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_sg_set_root_node(parser->load->scene_graph, node);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\t/*if in command, check command end*/\n\t\telse {\n\t\t\t/*check command end*/\n\t\t\tif (/*in_com && */gf_bt_check_code(parser, '}')) parser->in_com = 0;\n\t\t\telse if (strlen(str)) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown top-level element\", str);\n\t\t\t}\n\t\t\tparser->au_is_rap = 0;\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 0);\n\tgf_bt_check_unresolved_nodes(parser);\n\n\t/*load scripts*/\n\twhile (gf_list_count(parser->scripts)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->scripts, 0);\n\t\tgf_list_rem(parser->scripts, 0);\n\t\tgf_sg_script_load(n);\n\t}\n\treturn parser->last_error;\n}\n\nstatic GF_Err gf_sm_load_bt_initialize(GF_SceneLoader *load, const char *str, Bool input_only)\n{\n\tu32 size;\n\tgzFile gzInput;\n\tGF_Err e;\n\tunsigned char BOM[5];\n\tGF_BTParser *parser = load->loader_priv;\n\n\tparser->last_error = GF_OK;\n\n\tif (load->fileName) {\n\t\tFILE *test = gf_fopen(load->fileName, \"rb\");\n\t\tif (!test) return GF_URL_ERROR;\n\n\t\tsize = (u32) gf_fsize(test);\n\t\tgf_fclose(test);\n\n\t\tgzInput = gf_gzopen(load->fileName, \"rb\");\n\t\tif (!gzInput) return GF_IO_ERR;\n\n\t\tparser->line_buffer = (char *) gf_malloc(sizeof(char)*BT_LINE_SIZE);\n\t\tmemset(parser->line_buffer, 0, sizeof(char)*BT_LINE_SIZE);\n\t\tparser->file_size = size;\n\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tgf_gzgets(gzInput, (char*) BOM, 5);\n\t\tgf_gzseek(gzInput, 0, SEEK_SET);\n\t\tparser->gz_in = gzInput;\n\n\t} else {\n\t\tif (!str || (strlen(str)<5) ) {\n\t\t\t/*wait for first string data to be fed to the parser (for load from string)*/\n\t\t\tparser->initialized = 0;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tstrncpy((char *) BOM, str, 5);\n\t}\n\n\t/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 2;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\tif (!BOM[2] && !BOM[3]) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"UTF-32 Text Files not supported\");\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tparser->unicode_type = 1;\n\t\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);\n\t\t}\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\t/*we handle UTF8 as asci*/\n\t\tparser->unicode_type = 0;\n\t\tif (parser->gz_in) gf_gzseek(parser->gz_in, 3, SEEK_CUR);\n\t}\n\tparser->initialized = 1;\n\n\tif ( load->fileName )\n\t{\n\t\tchar *sep = gf_file_ext_start(load->fileName);\n\t\tif (sep && !strnicmp(sep, \".wrl\", 4)) parser->is_wrl = 1;\n\t}\n\n\tif (input_only) return GF_OK;\n\n\t/*initalize default streams in the context*/\n\n\t/*chunk parsing*/\n\tif (load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\tu32 i;\n\t\tGF_StreamContext *sc;\n\t\tif (!load->ctx) return GF_BAD_PARAM;\n\n\t\t/*restore context - note that base layer are ALWAYS declared BEFORE enhancement layers with gpac parsers*/\n\t\ti=0;\n\t\twhile ((sc = (GF_StreamContext*)gf_list_enum(load->ctx->streams, &i))) {\n\t\t\tswitch (sc->streamType) {\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\tif (!parser->bifs_es) parser->bifs_es = sc;\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (!parser->od_es) parser->od_es = sc;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*need at least one scene stream*/\n\t\tif (!parser->bifs_es) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->load->ctx->scene_width = 0;\n\t\t\tparser->load->ctx->scene_height = 0;\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\t\telse parser->base_bifs_id = parser->bifs_es->ESID;\n\t\tif (parser->od_es) parser->base_od_id = parser->od_es->ESID;\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"BT: MPEG-4 (BT) Scene Chunk Parsing\"));\n\t}\n\t/*context is not initialized - check for VRML*/\n\telse {\n\t\tGF_Command *com;\n\n\n\t\tparser->load = NULL;\n\t\tgf_bt_check_line(parser);\n\t\tparser->load = load;\n\t\tif (load->ctx && parser->def_w && parser->def_h) {\n\t\t\tload->ctx->scene_width = parser->def_w;\n\t\t\tload->ctx->scene_height = parser->def_h;\n\t\t}\n\n\t\t/*create at least one empty BIFS stream*/\n\t\tif (!parser->is_wrl && load->ctx) {\n\t\t\tparser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\tparser->load->ctx->is_pixel_metrics = 1;\n\t\t}\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ( ((parser->is_wrl==2) ? \"BT: X3D (WRL) Scene Parsing\\n\" : (parser->is_wrl ? \"BT: VRML Scene Parsing\\n\" : \"BT: MPEG-4 Scene Parsing\\n\")) ));\n\n\t\t/*default scene replace - we create it no matter what since it is used to store BIFS config when parsing IOD.*/\n\t\tcom = NULL;\n\t\tif (!parser->is_wrl) {\n\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t}\n\n\t\t/*and perform initial load*/\n\t\te = gf_bt_loader_run_intern(parser, com, 1);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nvoid load_bt_done(GF_SceneLoader *load)\n{\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return;\n\tgf_list_del(parser->unresolved_routes);\n\tgf_list_del(parser->inserted_routes);\n\tgf_list_del(parser->undef_nodes);\n\tgf_list_del(parser->def_nodes);\n\tgf_list_del(parser->peeked_nodes);\n\twhile (gf_list_count(parser->def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser->def_symbols, 0);\n\t\tgf_list_rem(parser->def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser->def_symbols);\n\tgf_list_del(parser->scripts);\n\n\tif (parser->gz_in) gf_gzclose(parser->gz_in);\n\tif (parser->line_buffer) gf_free(parser->line_buffer);\n\tgf_free(parser);\n\tload->loader_priv = NULL;\n}\n\nGF_Err load_bt_run(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, NULL, 1);\n\t\tif (e) return e;\n\t}\n\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\n\tif ((e<0) || parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tif (parser->gz_in) {\n\t\t\tgf_gzclose(parser->gz_in);\n\t\t\tparser->gz_in = NULL;\n\t\t}\n\n\t\tif (parser->line_buffer) {\n\t\t\tgf_free(parser->line_buffer);\n\t\t\tparser->line_buffer = NULL;\n\t\t}\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = parser->line_size = 0;\n\t\tload->fileName = NULL;\n\t}\n\treturn e;\n}\n\n\nGF_Err load_bt_parse_string(GF_SceneLoader *load, const char *str)\n{\n\tGF_Err e;\n\tchar *dup_str;\n\tGF_BTParser *parser = (GF_BTParser *)load->loader_priv;\n\tif (!parser) return GF_BAD_PARAM;\n\n\tif (parser->done) {\n\t\tparser->done = 0;\n\t\tparser->initialized = 0;\n\t\tparser->file_size = 0;\n\t\tparser->line_pos = 0;\n\t}\n\tparser->line_buffer = dup_str = gf_strdup(str);\n\tparser->line_size = (s32)strlen(str);\n\n\tif (!parser->initialized) {\n\t\te = gf_sm_load_bt_initialize(load, str, 0);\n\t\tif (e) {\n\t\t\tgf_free(dup_str);\n\t\t\treturn e;\n\t\t}\n\t}\n\te = gf_bt_loader_run_intern(parser, NULL, 0);\n\tparser->line_buffer = NULL;\n\tparser->line_size = 0;\n\tgf_free(dup_str);\n\treturn e;\n}\n\nGF_Err load_bt_suspend(GF_SceneLoader *load, Bool suspend)\n{\n\treturn GF_OK;\n}\n\nGF_Err gf_sm_load_init_bt(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tGF_BTParser *parser;\n\n\tif (!load || (!load->ctx && !load->scene_graph) ) return GF_BAD_PARAM;\n\tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;\n\n\tGF_SAFEALLOC(parser, GF_BTParser);\n\tif (!parser) return GF_OUT_OF_MEM;\n\tparser->load = load;\n\tload->loader_priv = parser;\n\tparser->def_symbols = gf_list_new();\n\tparser->unresolved_routes = gf_list_new();\n\tparser->inserted_routes = gf_list_new();\n\tparser->undef_nodes = gf_list_new();\n\tparser->def_nodes = gf_list_new();\n\tparser->peeked_nodes = gf_list_new();\n\tparser->scripts = gf_list_new();\n\n\tload->process = load_bt_run;\n\tload->done = load_bt_done;\n\tload->suspend = load_bt_suspend;\n\tload->parse_string = load_bt_parse_string;\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tgf_bt_report(parser, GF_OK, NULL);\n\t}\n#endif\n\n\te = gf_sm_load_bt_initialize(load, NULL, 0);\n\tif (e) {\n\t\tload_bt_done(load);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_List *gf_sm_load_bt_from_string(GF_SceneGraph *in_scene, char *node_str, Bool force_wrl)\n{\n\tGF_SceneLoader ctx;\n\tGF_BTParser parser;\n\tmemset(&ctx, 0, sizeof(GF_SceneLoader));\n\tctx.scene_graph = in_scene;\n\tmemset(&parser, 0, sizeof(GF_BTParser));\n\tparser.line_buffer = node_str;\n\tparser.line_size = (u32) strlen(node_str);\n\tparser.load = &ctx;\n\tparser.top_nodes = gf_list_new();\n\tparser.undef_nodes = gf_list_new();\n\tparser.def_nodes = gf_list_new();\n\tparser.peeked_nodes = gf_list_new();\n\tparser.is_wrl = force_wrl;\n\tgf_bt_loader_run_intern(&parser, NULL, 1);\n\tgf_list_del(parser.undef_nodes);\n\tgf_list_del(parser.def_nodes);\n\tgf_list_del(parser.peeked_nodes);\n\twhile (gf_list_count(parser.def_symbols)) {\n\t\tBTDefSymbol *d = (BTDefSymbol *)gf_list_get(parser.def_symbols, 0);\n\t\tgf_list_rem(parser.def_symbols, 0);\n\t\tgf_free(d->name);\n\t\tgf_free(d->value);\n\t\tgf_free(d);\n\t}\n\tgf_list_del(parser.def_symbols);\n\tgf_list_del(parser.scripts);\n\n\treturn parser.top_nodes;\n}\n\n#endif /*GPAC_DISABLE_LOADER_BT*/\n"], "filenames": ["src/scene_manager/loader_bt.c"], "buggy_code_start_loc": [449], "buggy_code_end_loc": [456], "fixing_code_start_loc": [450], "fixing_code_end_loc": [455], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3-DEV.", "other": {"cve": {"id": "CVE-2023-4778", "sourceIdentifier": "security@huntr.dev", "published": "2023-09-05T16:15:08.207", "lastModified": "2023-09-07T19:34:34.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3-DEV."}, {"lang": "es", "value": "Lectura fuera de l\u00edmites en el repositorio de GitHub gpac/gpac anterior a la versi\u00f3n 2.3-DEV. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3-dev", "matchCriteriaId": "F76B0068-AE98-4B7C-885D-B083842F6521"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/d553698050af478049e1a09e44a15ac884f223ed", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/abb450fb-4ab2-49b0-90da-3d878eea5397", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/d553698050af478049e1a09e44a15ac884f223ed"}}