{"buggy_code": ["/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/timer.h>\n#include <linux/rtnetlink.h>\n\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"sta_info.h\"\n#include \"debugfs_sta.h\"\n#include \"mesh.h\"\n#include \"wme.h\"\n\n/**\n * DOC: STA information lifetime rules\n *\n * STA info structures (&struct sta_info) are managed in a hash table\n * for faster lookup and a list for iteration. They are managed using\n * RCU, i.e. access to the list and hash table is protected by RCU.\n *\n * Upon allocating a STA info structure with sta_info_alloc(), the caller\n * owns that structure. It must then insert it into the hash table using\n * either sta_info_insert() or sta_info_insert_rcu(); only in the latter\n * case (which acquires an rcu read section but must not be called from\n * within one) will the pointer still be valid after the call. Note that\n * the caller may not do much with the STA info before inserting it, in\n * particular, it may not start any mesh peer link management or add\n * encryption keys.\n *\n * When the insertion fails (sta_info_insert()) returns non-zero), the\n * structure will have been freed by sta_info_insert()!\n *\n * Station entries are added by mac80211 when you establish a link with a\n * peer. This means different things for the different type of interfaces\n * we support. For a regular station this mean we add the AP sta when we\n * receive an association response from the AP. For IBSS this occurs when\n * get to know about a peer on the same IBSS. For WDS we add the sta for\n * the peer immediately upon device open. When using AP mode we add stations\n * for each respective station upon request from userspace through nl80211.\n *\n * In order to remove a STA info structure, various sta_info_destroy_*()\n * calls are available.\n *\n * There is no concept of ownership on a STA entry, each structure is\n * owned by the global hash table/list until it is removed. All users of\n * the structure need to be RCU protected so that the structure won't be\n * freed before they are done using it.\n */\n\n/* Caller must hold local->sta_mtx */\nstatic int sta_info_hash_del(struct ieee80211_local *local,\n\t\t\t     struct sta_info *sta)\n{\n\tstruct sta_info *s;\n\n\ts = rcu_dereference_protected(local->sta_hash[STA_HASH(sta->sta.addr)],\n\t\t\t\t      lockdep_is_held(&local->sta_mtx));\n\tif (!s)\n\t\treturn -ENOENT;\n\tif (s == sta) {\n\t\trcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)],\n\t\t\t\t   s->hnext);\n\t\treturn 0;\n\t}\n\n\twhile (rcu_access_pointer(s->hnext) &&\n\t       rcu_access_pointer(s->hnext) != sta)\n\t\ts = rcu_dereference_protected(s->hnext,\n\t\t\t\t\tlockdep_is_held(&local->sta_mtx));\n\tif (rcu_access_pointer(s->hnext)) {\n\t\trcu_assign_pointer(s->hnext, sta->hnext);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic void cleanup_single_sta(struct sta_info *sta)\n{\n\tint ac, i;\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ps_data *ps;\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tps = &sdata->bss->ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\treturn;\n\n\t\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\n\t\tatomic_dec(&ps->num_sta_ps);\n\t\tsta_info_recalc_tim(sta);\n\t}\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tlocal->total_ps_buffered -= skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\tieee80211_purge_tx_queue(&local->hw, &sta->ps_tx_buf[ac]);\n\t\tieee80211_purge_tx_queue(&local->hw, &sta->tx_filtered[ac]);\n\t}\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_sta_cleanup(sta);\n\n\tcancel_work_sync(&sta->drv_unblock_wk);\n\n\t/*\n\t * Destroy aggregation state here. It would be nice to wait for the\n\t * driver to finish aggregation stop and then clean up, but for now\n\t * drivers have to handle aggregation stop being requested, followed\n\t * directly by station destruction.\n\t */\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\tkfree(sta->ampdu_mlme.tid_start_tx[i]);\n\t\ttid_tx = rcu_dereference_raw(sta->ampdu_mlme.tid_tx[i]);\n\t\tif (!tid_tx)\n\t\t\tcontinue;\n\t\tieee80211_purge_tx_queue(&local->hw, &tid_tx->pending);\n\t\tkfree(tid_tx);\n\t}\n\n\tsta_info_free(local, sta);\n}\n\n/* protected by RCU */\nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tsta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],\n\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\twhile (sta) {\n\t\tif (sta->sdata == sdata &&\n\t\t    ether_addr_equal(sta->sta.addr, addr))\n\t\t\tbreak;\n\t\tsta = rcu_dereference_check(sta->hnext,\n\t\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\t}\n\treturn sta;\n}\n\n/*\n * Get sta info either from the specified interface\n * or from one of its vlans\n */\nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  const u8 *addr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tsta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],\n\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\twhile (sta) {\n\t\tif ((sta->sdata == sdata ||\n\t\t     (sta->sdata->bss && sta->sdata->bss == sdata->bss)) &&\n\t\t    ether_addr_equal(sta->sta.addr, addr))\n\t\t\tbreak;\n\t\tsta = rcu_dereference_check(sta->hnext,\n\t\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\t}\n\treturn sta;\n}\n\nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     int idx)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tint i = 0;\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\t\tif (i < idx) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\treturn sta;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * sta_info_free - free STA\n *\n * @local: pointer to the global information\n * @sta: STA info to free\n *\n * This function must undo everything done by sta_info_alloc()\n * that may happen before sta_info_insert(). It may only be\n * called when sta_info_insert() has not been attempted (and\n * if that fails, the station is freed anyway.)\n */\nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta)\n{\n\tint i;\n\n\tif (sta->rate_ctrl)\n\t\trate_control_free_sta(sta);\n\n\tif (sta->tx_lat) {\n\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\t\tkfree(sta->tx_lat[i].bins);\n\t\tkfree(sta->tx_lat);\n\t}\n\n\tsta_dbg(sta->sdata, \"Destroyed STA %pM\\n\", sta->sta.addr);\n\n\tkfree(sta);\n}\n\n/* Caller must hold local->sta_mtx */\nstatic void sta_info_hash_add(struct ieee80211_local *local,\n\t\t\t      struct sta_info *sta)\n{\n\tlockdep_assert_held(&local->sta_mtx);\n\tsta->hnext = local->sta_hash[STA_HASH(sta->sta.addr)];\n\trcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)], sta);\n}\n\nstatic void sta_unblock(struct work_struct *wk)\n{\n\tstruct sta_info *sta;\n\n\tsta = container_of(wk, struct sta_info, drv_unblock_wk);\n\n\tif (sta->dead)\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\tlocal_bh_disable();\n\t\tieee80211_sta_ps_deliver_wakeup(sta);\n\t\tlocal_bh_enable();\n\t} else if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL)) {\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\n\t\tlocal_bh_disable();\n\t\tieee80211_sta_ps_deliver_poll_response(sta);\n\t\tlocal_bh_enable();\n\t} else if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD)) {\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\n\t\tlocal_bh_disable();\n\t\tieee80211_sta_ps_deliver_uapsd(sta);\n\t\tlocal_bh_enable();\n\t} else\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n}\n\nstatic int sta_prepare_rate_control(struct ieee80211_local *local,\n\t\t\t\t    struct sta_info *sta, gfp_t gfp)\n{\n\tif (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL)\n\t\treturn 0;\n\n\tsta->rate_ctrl = local->rate_ctrl;\n\tsta->rate_ctrl_priv = rate_control_alloc_sta(sta->rate_ctrl,\n\t\t\t\t\t\t     &sta->sta, gfp);\n\tif (!sta->rate_ctrl_priv)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct timespec uptime;\n\tstruct ieee80211_tx_latency_bin_ranges *tx_latency;\n\tint i;\n\n\tsta = kzalloc(sizeof(*sta) + local->hw.sta_data_size, gfp);\n\tif (!sta)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttx_latency = rcu_dereference(local->tx_latency);\n\t/* init stations Tx latency statistics && TID bins */\n\tif (tx_latency) {\n\t\tsta->tx_lat = kzalloc(IEEE80211_NUM_TIDS *\n\t\t\t\t      sizeof(struct ieee80211_tx_latency_stat),\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!sta->tx_lat) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (tx_latency->n_ranges) {\n\t\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\t\t\t/* size of bins is size of the ranges +1 */\n\t\t\t\tsta->tx_lat[i].bin_count =\n\t\t\t\t\ttx_latency->n_ranges + 1;\n\t\t\t\tsta->tx_lat[i].bins =\n\t\t\t\t\tkcalloc(sta->tx_lat[i].bin_count,\n\t\t\t\t\t\tsizeof(u32), GFP_ATOMIC);\n\t\t\t\tif (!sta->tx_lat[i].bins) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tspin_lock_init(&sta->lock);\n\tINIT_WORK(&sta->drv_unblock_wk, sta_unblock);\n\tINIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);\n\tmutex_init(&sta->ampdu_mlme.mtx);\n#ifdef CONFIG_MAC80211_MESH\n\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t    !sdata->u.mesh.user_mpm)\n\t\tinit_timer(&sta->plink_timer);\n\tsta->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\n#endif\n\n\tmemcpy(sta->sta.addr, addr, ETH_ALEN);\n\tsta->local = local;\n\tsta->sdata = sdata;\n\tsta->last_rx = jiffies;\n\n\tsta->sta_state = IEEE80211_STA_NONE;\n\n\tdo_posix_clock_monotonic_gettime(&uptime);\n\tsta->last_connected = uptime.tv_sec;\n\tewma_init(&sta->avg_signal, 1024, 8);\n\tfor (i = 0; i < ARRAY_SIZE(sta->chain_signal_avg); i++)\n\t\tewma_init(&sta->chain_signal_avg[i], 1024, 8);\n\n\tif (sta_prepare_rate_control(local, sta, gfp))\n\t\tgoto free;\n\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\t/*\n\t\t * timer_to_tid must be initialized with identity mapping\n\t\t * to enable session_timer's data differentiation. See\n\t\t * sta_rx_agg_session_timer_expired for usage.\n\t\t */\n\t\tsta->timer_to_tid[i] = i;\n\t}\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tskb_queue_head_init(&sta->ps_tx_buf[i]);\n\t\tskb_queue_head_init(&sta->tx_filtered[i]);\n\t}\n\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\tsta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\n\n\tsta->sta.smps_mode = IEEE80211_SMPS_OFF;\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal->hw.wiphy->bands[ieee80211_get_sdata_band(sdata)];\n\t\tu8 smps = (sband->ht_cap.cap & IEEE80211_HT_CAP_SM_PS) >>\n\t\t\t\tIEEE80211_HT_CAP_SM_PS_SHIFT;\n\t\t/*\n\t\t * Assume that hostapd advertises our caps in the beacon and\n\t\t * this is the known_smps_mode for a station that just assciated\n\t\t */\n\t\tswitch (smps) {\n\t\tcase WLAN_HT_SMPS_CONTROL_DISABLED:\n\t\t\tsta->known_smps_mode = IEEE80211_SMPS_OFF;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_STATIC:\n\t\t\tsta->known_smps_mode = IEEE80211_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_DYNAMIC:\n\t\t\tsta->known_smps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\n\tsta_dbg(sdata, \"Allocated STA %pM\\n\", sta->sta.addr);\n\treturn sta;\n\nfree:\n\tif (sta->tx_lat) {\n\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\t\tkfree(sta->tx_lat[i].bins);\n\t\tkfree(sta->tx_lat);\n\t}\n\tkfree(sta);\n\treturn NULL;\n}\n\nstatic int sta_info_insert_check(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\t/*\n\t * Can't be a WARN_ON because it can be triggered through a race:\n\t * something inserts a STA (on one CPU) without holding the RTNL\n\t * and another CPU turns off the net device.\n\t */\n\tif (unlikely(!ieee80211_sdata_running(sdata)))\n\t\treturn -ENETDOWN;\n\n\tif (WARN_ON(ether_addr_equal(sta->sta.addr, sdata->vif.addr) ||\n\t\t    is_multicast_ether_addr(sta->sta.addr)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sta_info_insert_drv_state(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct sta_info *sta)\n{\n\tenum ieee80211_sta_state state;\n\tint err = 0;\n\n\tfor (state = IEEE80211_STA_NOTEXIST; state < sta->sta_state; state++) {\n\t\terr = drv_sta_state(local, sdata, sta, state, state + 1);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err) {\n\t\t/*\n\t\t * Drivers using legacy sta_add/sta_remove callbacks only\n\t\t * get uploaded set to true after sta_add is called.\n\t\t */\n\t\tif (!local->ops->sta_add)\n\t\t\tsta->uploaded = true;\n\t\treturn 0;\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to move IBSS STA %pM to state %d (%d) - keeping it anyway\\n\",\n\t\t\t   sta->sta.addr, state + 1, err);\n\t\terr = 0;\n\t}\n\n\t/* unwind on error */\n\tfor (; state > IEEE80211_STA_NOTEXIST; state--)\n\t\tWARN_ON(drv_sta_state(local, sdata, sta, state, state - 1));\n\n\treturn err;\n}\n\n/*\n * should be called with sta_mtx locked\n * this function replaces the mutex lock\n * with a RCU lock\n */\nstatic int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct station_info sinfo;\n\tint err = 0;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/* check if STA exists already */\n\tif (sta_info_get_bss(sdata, sta->sta.addr)) {\n\t\terr = -EEXIST;\n\t\tgoto out_err;\n\t}\n\n\t/* notify driver */\n\terr = sta_info_insert_drv_state(local, sdata, sta);\n\tif (err)\n\t\tgoto out_err;\n\n\tlocal->num_sta++;\n\tlocal->sta_generation++;\n\tsmp_mb();\n\n\t/* make the station visible */\n\tsta_info_hash_add(local, sta);\n\n\tlist_add_rcu(&sta->list, &local->sta_list);\n\n\tset_sta_flag(sta, WLAN_STA_INSERTED);\n\n\tieee80211_recalc_min_chandef(sdata);\n\tieee80211_sta_debugfs_add(sta);\n\trate_control_add_sta_debugfs(sta);\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tsinfo.filled = 0;\n\tsinfo.generation = local->sta_generation;\n\tcfg80211_new_sta(sdata->dev, sta->sta.addr, &sinfo, GFP_KERNEL);\n\n\tsta_dbg(sdata, \"Inserted STA %pM\\n\", sta->sta.addr);\n\n\t/* move reference to rcu-protected */\n\trcu_read_lock();\n\tmutex_unlock(&local->sta_mtx);\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_accept_plinks_update(sdata);\n\n\treturn 0;\n out_err:\n\tmutex_unlock(&local->sta_mtx);\n\trcu_read_lock();\n\treturn err;\n}\n\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tint err = 0;\n\n\tmight_sleep();\n\n\terr = sta_info_insert_check(sta);\n\tif (err) {\n\t\trcu_read_lock();\n\t\tgoto out_free;\n\t}\n\n\tmutex_lock(&local->sta_mtx);\n\n\terr = sta_info_insert_finish(sta);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n out_free:\n\tBUG_ON(!err);\n\tsta_info_free(local, sta);\n\treturn err;\n}\n\nint sta_info_insert(struct sta_info *sta)\n{\n\tint err = sta_info_insert_rcu(sta);\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic inline void __bss_tim_set(u8 *tim, u16 id)\n{\n\t/*\n\t * This format has been mandated by the IEEE specifications,\n\t * so this line may not be changed to use the __set_bit() format.\n\t */\n\ttim[id / 8] |= (1 << (id % 8));\n}\n\nstatic inline void __bss_tim_clear(u8 *tim, u16 id)\n{\n\t/*\n\t * This format has been mandated by the IEEE specifications,\n\t * so this line may not be changed to use the __clear_bit() format.\n\t */\n\ttim[id / 8] &= ~(1 << (id % 8));\n}\n\nstatic inline bool __bss_tim_get(u8 *tim, u16 id)\n{\n\t/*\n\t * This format has been mandated by the IEEE specifications,\n\t * so this line may not be changed to use the test_bit() format.\n\t */\n\treturn tim[id / 8] & (1 << (id % 8));\n}\n\nstatic unsigned long ieee80211_tids_for_ac(int ac)\n{\n\t/* If we ever support TIDs > 7, this obviously needs to be adjusted */\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\treturn BIT(6) | BIT(7);\n\tcase IEEE80211_AC_VI:\n\t\treturn BIT(4) | BIT(5);\n\tcase IEEE80211_AC_BE:\n\t\treturn BIT(0) | BIT(3);\n\tcase IEEE80211_AC_BK:\n\t\treturn BIT(1) | BIT(2);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nvoid sta_info_recalc_tim(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ps_data *ps;\n\tbool indicate_tim = false;\n\tu8 ignore_for_tim = sta->sta.uapsd_queues;\n\tint ac;\n\tu16 id;\n\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (WARN_ON_ONCE(!sta->sdata->bss))\n\t\t\treturn;\n\n\t\tps = &sta->sdata->bss->ps;\n\t\tid = sta->sta.aid;\n#ifdef CONFIG_MAC80211_MESH\n\t} else if (ieee80211_vif_is_mesh(&sta->sdata->vif)) {\n\t\tps = &sta->sdata->u.mesh.ps;\n\t\t/* TIM map only for 1 <= PLID <= IEEE80211_MAX_AID */\n\t\tid = sta->plid % (IEEE80211_MAX_AID + 1);\n#endif\n\t} else {\n\t\treturn;\n\t}\n\n\t/* No need to do anything if the driver does all */\n\tif (local->hw.flags & IEEE80211_HW_AP_LINK_PS)\n\t\treturn;\n\n\tif (sta->dead)\n\t\tgoto done;\n\n\t/*\n\t * If all ACs are delivery-enabled then we should build\n\t * the TIM bit for all ACs anyway; if only some are then\n\t * we ignore those and build the TIM bit using only the\n\t * non-enabled ones.\n\t */\n\tif (ignore_for_tim == BIT(IEEE80211_NUM_ACS) - 1)\n\t\tignore_for_tim = 0;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tunsigned long tids;\n\n\t\tif (ignore_for_tim & BIT(ac))\n\t\t\tcontinue;\n\n\t\tindicate_tim |= !skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t\t\t!skb_queue_empty(&sta->ps_tx_buf[ac]);\n\t\tif (indicate_tim)\n\t\t\tbreak;\n\n\t\ttids = ieee80211_tids_for_ac(ac);\n\n\t\tindicate_tim |=\n\t\t\tsta->driver_buffered_tids & tids;\n\t}\n\n done:\n\tspin_lock_bh(&local->tim_lock);\n\n\tif (indicate_tim == __bss_tim_get(ps->tim, id))\n\t\tgoto out_unlock;\n\n\tif (indicate_tim)\n\t\t__bss_tim_set(ps->tim, id);\n\telse\n\t\t__bss_tim_clear(ps->tim, id);\n\n\tif (local->ops->set_tim) {\n\t\tlocal->tim_in_locked_section = true;\n\t\tdrv_set_tim(local, &sta->sta, indicate_tim);\n\t\tlocal->tim_in_locked_section = false;\n\t}\n\nout_unlock:\n\tspin_unlock_bh(&local->tim_lock);\n}\n\nstatic bool sta_info_buffer_expired(struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info;\n\tint timeout;\n\n\tif (!skb)\n\t\treturn false;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\t/* Timeout: (2 * listen_interval * beacon_int * 1024 / 1000000) sec */\n\ttimeout = (sta->listen_interval *\n\t\t   sta->sdata->vif.bss_conf.beacon_int *\n\t\t   32 / 15625) * HZ;\n\tif (timeout < STA_TX_BUFFER_EXPIRE)\n\t\ttimeout = STA_TX_BUFFER_EXPIRE;\n\treturn time_after(jiffies, info->control.jiffies + timeout);\n}\n\n\nstatic bool sta_info_cleanup_expire_buffered_ac(struct ieee80211_local *local,\n\t\t\t\t\t\tstruct sta_info *sta, int ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\t/*\n\t * First check for frames that should expire on the filtered\n\t * queue. Frames here were rejected by the driver and are on\n\t * a separate queue to avoid reordering with normal PS-buffered\n\t * frames. They also aren't accounted for right now in the\n\t * total_ps_buffered counter.\n\t */\n\tfor (;;) {\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb = skb_peek(&sta->tx_filtered[ac]);\n\t\tif (sta_info_buffer_expired(sta, skb))\n\t\t\tskb = __skb_dequeue(&sta->tx_filtered[ac]);\n\t\telse\n\t\t\tskb = NULL;\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\n\t\t/*\n\t\t * Frames are queued in order, so if this one\n\t\t * hasn't expired yet we can stop testing. If\n\t\t * we actually reached the end of the queue we\n\t\t * also need to stop, of course.\n\t\t */\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n\n\t/*\n\t * Now also check the normal PS-buffered queue, this will\n\t * only find something if the filtered queue was emptied\n\t * since the filtered frames are all before the normal PS\n\t * buffered frames.\n\t */\n\tfor (;;) {\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb = skb_peek(&sta->ps_tx_buf[ac]);\n\t\tif (sta_info_buffer_expired(sta, skb))\n\t\t\tskb = __skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\telse\n\t\t\tskb = NULL;\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\n\t\t/*\n\t\t * frames are queued in order, so if this one\n\t\t * hasn't expired yet (or we reached the end of\n\t\t * the queue) we can stop testing\n\t\t */\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tlocal->total_ps_buffered--;\n\t\tps_dbg(sta->sdata, \"Buffered frame expired (STA %pM)\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n\n\t/*\n\t * Finally, recalculate the TIM bit for this station -- it might\n\t * now be clear because the station was too slow to retrieve its\n\t * frames.\n\t */\n\tsta_info_recalc_tim(sta);\n\n\t/*\n\t * Return whether there are any frames still buffered, this is\n\t * used to check whether the cleanup timer still needs to run,\n\t * if there are no frames we don't need to rearm the timer.\n\t */\n\treturn !(skb_queue_empty(&sta->ps_tx_buf[ac]) &&\n\t\t skb_queue_empty(&sta->tx_filtered[ac]));\n}\n\nstatic bool sta_info_cleanup_expire_buffered(struct ieee80211_local *local,\n\t\t\t\t\t     struct sta_info *sta)\n{\n\tbool have_buffered = false;\n\tint ac;\n\n\t/* This is only necessary for stations on BSS/MBSS interfaces */\n\tif (!sta->sdata->bss &&\n\t    !ieee80211_vif_is_mesh(&sta->sdata->vif))\n\t\treturn false;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\thave_buffered |=\n\t\t\tsta_info_cleanup_expire_buffered_ac(local, sta, ac);\n\n\treturn have_buffered;\n}\n\nstatic int __must_check __sta_info_destroy_part1(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tlocal = sta->local;\n\tsdata = sta->sdata;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/*\n\t * Before removing the station from the driver and\n\t * rate control, it might still start new aggregation\n\t * sessions -- block that to make sure the tear-down\n\t * will be sufficient.\n\t */\n\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\tieee80211_sta_tear_down_BA_sessions(sta, AGG_STOP_DESTROY_STA);\n\n\tret = sta_info_hash_del(local, sta);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\tlist_del_rcu(&sta->list);\n\n\tdrv_sta_pre_rcu_remove(local, sta->sdata, sta);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    rcu_access_pointer(sdata->u.vlan.sta) == sta)\n\t\tRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\n\n\treturn 0;\n}\n\nstatic void __sta_info_destroy_part2(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tint ret;\n\n\t/*\n\t * NOTE: This assumes at least synchronize_net() was done\n\t *\t after _part1 and before _part2!\n\t */\n\n\tmight_sleep();\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/* now keys can no longer be reached */\n\tieee80211_free_sta_keys(local, sta);\n\n\tsta->dead = true;\n\n\tlocal->num_sta--;\n\tlocal->sta_generation++;\n\n\twhile (sta->sta_state > IEEE80211_STA_NONE) {\n\t\tret = sta_info_move_state(sta, sta->sta_state - 1);\n\t\tif (ret) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sta->uploaded) {\n\t\tret = drv_sta_state(local, sdata, sta, IEEE80211_STA_NONE,\n\t\t\t\t    IEEE80211_STA_NOTEXIST);\n\t\tWARN_ON_ONCE(ret != 0);\n\t}\n\n\tsta_dbg(sdata, \"Removed STA %pM\\n\", sta->sta.addr);\n\n\tcfg80211_del_sta(sdata->dev, sta->sta.addr, GFP_KERNEL);\n\n\trate_control_remove_sta_debugfs(sta);\n\tieee80211_sta_debugfs_remove(sta);\n\tieee80211_recalc_min_chandef(sdata);\n\n\tcleanup_single_sta(sta);\n}\n\nint __must_check __sta_info_destroy(struct sta_info *sta)\n{\n\tint err = __sta_info_destroy_part1(sta);\n\n\tif (err)\n\t\treturn err;\n\n\tsynchronize_net();\n\n\t__sta_info_destroy_part2(sta);\n\n\treturn 0;\n}\n\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata, const u8 *addr)\n{\n\tstruct sta_info *sta;\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get(sdata, addr);\n\tret = __sta_info_destroy(sta);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr)\n{\n\tstruct sta_info *sta;\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get_bss(sdata, addr);\n\tret = __sta_info_destroy(sta);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic void sta_info_cleanup(unsigned long data)\n{\n\tstruct ieee80211_local *local = (struct ieee80211_local *) data;\n\tstruct sta_info *sta;\n\tbool timer_needed = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list)\n\t\tif (sta_info_cleanup_expire_buffered(local, sta))\n\t\t\ttimer_needed = true;\n\trcu_read_unlock();\n\n\tif (local->quiescing)\n\t\treturn;\n\n\tif (!timer_needed)\n\t\treturn;\n\n\tmod_timer(&local->sta_cleanup,\n\t\t  round_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL));\n}\n\nvoid sta_info_init(struct ieee80211_local *local)\n{\n\tspin_lock_init(&local->tim_lock);\n\tmutex_init(&local->sta_mtx);\n\tINIT_LIST_HEAD(&local->sta_list);\n\n\tsetup_timer(&local->sta_cleanup, sta_info_cleanup,\n\t\t    (unsigned long)local);\n}\n\nvoid sta_info_stop(struct ieee80211_local *local)\n{\n\tdel_timer_sync(&local->sta_cleanup);\n}\n\n\nint __sta_info_flush(struct ieee80211_sub_if_data *sdata, bool vlans)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\tLIST_HEAD(free_list);\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tWARN_ON(vlans && sdata->vif.type != NL80211_IFTYPE_AP);\n\tWARN_ON(vlans && !sdata->bss);\n\n\tmutex_lock(&local->sta_mtx);\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tif (sdata == sta->sdata ||\n\t\t    (vlans && sdata->bss == sta->sdata->bss)) {\n\t\t\tif (!WARN_ON(__sta_info_destroy_part1(sta)))\n\t\t\t\tlist_add(&sta->free_list, &free_list);\n\t\t\tret++;\n\t\t}\n\t}\n\n\tif (!list_empty(&free_list)) {\n\t\tsynchronize_net();\n\t\tlist_for_each_entry_safe(sta, tmp, &free_list, free_list)\n\t\t\t__sta_info_destroy_part2(sta);\n\t}\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn ret;\n}\n\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tif (time_after(jiffies, sta->last_rx + exp_time)) {\n\t\t\tsta_dbg(sta->sdata, \"expiring inactive STA %pM\\n\",\n\t\t\t\tsta->sta.addr);\n\n\t\t\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t\t    test_sta_flag(sta, WLAN_STA_PS_STA))\n\t\t\t\tatomic_dec(&sdata->u.mesh.ps.num_sta_ps);\n\n\t\t\tWARN_ON(__sta_info_destroy(sta));\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n}\n\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\n\t\t\t\t\t       const u8 *addr,\n\t\t\t\t\t       const u8 *localaddr)\n{\n\tstruct sta_info *sta, *nxt;\n\n\t/*\n\t * Just return a random station if localaddr is NULL\n\t * ... first in list.\n\t */\n\tfor_each_sta_info(hw_to_local(hw), addr, sta, nxt) {\n\t\tif (localaddr &&\n\t\t    !ether_addr_equal(sta->sdata->vif.addr, localaddr))\n\t\t\tcontinue;\n\t\tif (!sta->uploaded)\n\t\t\treturn NULL;\n\t\treturn &sta->sta;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ieee80211_find_sta_by_ifaddr);\n\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\n\t\t\t\t\t const u8 *addr)\n{\n\tstruct sta_info *sta;\n\n\tif (!vif)\n\t\treturn NULL;\n\n\tsta = sta_info_get_bss(vif_to_sdata(vif), addr);\n\tif (!sta)\n\t\treturn NULL;\n\n\tif (!sta->uploaded)\n\t\treturn NULL;\n\n\treturn &sta->sta;\n}\nEXPORT_SYMBOL(ieee80211_find_sta);\n\nstatic void clear_sta_ps_flags(void *_sta)\n{\n\tstruct sta_info *sta = _sta;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ps_data *ps;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tps = &sdata->bss->ps;\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tps = &sdata->u.mesh.ps;\n\telse\n\t\treturn;\n\n\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\tif (test_and_clear_sta_flag(sta, WLAN_STA_PS_STA))\n\t\tatomic_dec(&ps->num_sta_ps);\n}\n\n/* powersave support code */\nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff_head pending;\n\tint filtered = 0, buffered = 0, ac;\n\tunsigned long flags;\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\tBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\n\tsta->driver_buffered_tids = 0;\n\n\tif (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\n\n\tskb_queue_head_init(&pending);\n\n\t/* Send all buffered frames to the station */\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tint count = skb_queue_len(&pending), tmp;\n\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tfiltered += tmp - count;\n\t\tcount = tmp;\n\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tbuffered += tmp - count;\n\t}\n\n\tieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\n\n\t/* This station just woke up and isn't aware of our SMPS state */\n\tif (!ieee80211_smps_is_restrictive(sta->known_smps_mode,\n\t\t\t\t\t   sdata->smps_mode) &&\n\t    sta->known_smps_mode != sdata->bss->req_smps &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sdata,\n\t\t       \"%pM just woke up and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sdata, sdata->bss->req_smps,\n\t\t\t\t\t   sta->sta.addr,\n\t\t\t\t\t   sdata->vif.bss_conf.bssid);\n\t}\n\n\tlocal->total_ps_buffered -= buffered;\n\n\tsta_info_recalc_tim(sta);\n\n\tps_dbg(sdata,\n\t       \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\",\n\t       sta->sta.addr, sta->sta.aid, filtered, buffered);\n}\n\nstatic void ieee80211_send_null_response(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct sta_info *sta, int tid,\n\t\t\t\t\t enum ieee80211_frame_release_type reason,\n\t\t\t\t\t bool call_driver)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_qos_hdr *nullfunc;\n\tstruct sk_buff *skb;\n\tint size = sizeof(*nullfunc);\n\t__le16 fc;\n\tbool qos = test_sta_flag(sta, WLAN_STA_WME);\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tif (qos) {\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t} else {\n\t\tsize -= 2;\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t}\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + size);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = (void *) skb_put(skb, size);\n\tnullfunc->frame_control = fc;\n\tnullfunc->duration_id = 0;\n\tmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);\n\n\tskb->priority = tid;\n\tskb_set_queue_mapping(skb, ieee802_1d_to_ac[tid]);\n\tif (qos) {\n\t\tnullfunc->qos_ctrl = cpu_to_le16(tid);\n\n\t\tif (reason == IEEE80211_FRAME_RELEASE_UAPSD)\n\t\t\tnullfunc->qos_ctrl |=\n\t\t\t\tcpu_to_le16(IEEE80211_QOS_CTL_EOSP);\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\t/*\n\t * Tell TX path to send this frame even though the\n\t * STA may still remain is PS mode after this frame\n\t * exchange. Also set EOSP to indicate this packet\n\t * ends the poll/service period.\n\t */\n\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t       IEEE80211_TX_CTL_PS_RESPONSE |\n\t\t       IEEE80211_TX_STATUS_EOSP |\n\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tif (call_driver)\n\t\tdrv_allow_buffered_frames(local, sta, BIT(tid), 1,\n\t\t\t\t\t  reason, false);\n\n\tskb->dev = sdata->dev;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tieee80211_xmit(sdata, skb, chanctx_conf->def.chan->band);\n\trcu_read_unlock();\n}\n\nstatic int find_highest_prio_tid(unsigned long tids)\n{\n\t/* lower 3 TIDs aren't ordered perfectly */\n\tif (tids & 0xF8)\n\t\treturn fls(tids) - 1;\n\t/* TID 0 is BE just like TID 3 */\n\tif (tids & BIT(0))\n\t\treturn 0;\n\treturn fls(tids) - 1;\n}\n\nstatic void\nieee80211_sta_ps_deliver_response(struct sta_info *sta,\n\t\t\t\t  int n_frames, u8 ignored_acs,\n\t\t\t\t  enum ieee80211_frame_release_type reason)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tbool more_data = false;\n\tint ac;\n\tunsigned long driver_release_tids = 0;\n\tstruct sk_buff_head frames;\n\n\t/* Service or PS-Poll period starts */\n\tset_sta_flag(sta, WLAN_STA_SP);\n\n\t__skb_queue_head_init(&frames);\n\n\t/* Get response frame(s) and more data bit for the last one. */\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tunsigned long tids;\n\n\t\tif (ignored_acs & BIT(ac))\n\t\t\tcontinue;\n\n\t\ttids = ieee80211_tids_for_ac(ac);\n\n\t\t/* if we already have frames from software, then we can't also\n\t\t * release from hardware queues\n\t\t */\n\t\tif (skb_queue_empty(&frames))\n\t\t\tdriver_release_tids |= sta->driver_buffered_tids & tids;\n\n\t\tif (driver_release_tids) {\n\t\t\t/* If the driver has data on more than one TID then\n\t\t\t * certainly there's more data if we release just a\n\t\t\t * single frame now (from a single TID). This will\n\t\t\t * only happen for PS-Poll.\n\t\t\t */\n\t\t\tif (reason == IEEE80211_FRAME_RELEASE_PSPOLL &&\n\t\t\t    hweight16(driver_release_tids) > 1) {\n\t\t\t\tmore_data = true;\n\t\t\t\tdriver_release_tids =\n\t\t\t\t\tBIT(find_highest_prio_tid(\n\t\t\t\t\t\tdriver_release_tids));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\twhile (n_frames > 0) {\n\t\t\t\tskb = skb_dequeue(&sta->tx_filtered[ac]);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tskb = skb_dequeue(\n\t\t\t\t\t\t&sta->ps_tx_buf[ac]);\n\t\t\t\t\tif (skb)\n\t\t\t\t\t\tlocal->total_ps_buffered--;\n\t\t\t\t}\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\t\t\t\tn_frames--;\n\t\t\t\t__skb_queue_tail(&frames, skb);\n\t\t\t}\n\t\t}\n\n\t\t/* If we have more frames buffered on this AC, then set the\n\t\t * more-data bit and abort the loop since we can't send more\n\t\t * data from other ACs before the buffered frames from this.\n\t\t */\n\t\tif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t    !skb_queue_empty(&sta->ps_tx_buf[ac])) {\n\t\t\tmore_data = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skb_queue_empty(&frames) && !driver_release_tids) {\n\t\tint tid;\n\n\t\t/*\n\t\t * For PS-Poll, this can only happen due to a race condition\n\t\t * when we set the TIM bit and the station notices it, but\n\t\t * before it can poll for the frame we expire it.\n\t\t *\n\t\t * For uAPSD, this is said in the standard (11.2.1.5 h):\n\t\t *\tAt each unscheduled SP for a non-AP STA, the AP shall\n\t\t *\tattempt to transmit at least one MSDU or MMPDU, but no\n\t\t *\tmore than the value specified in the Max SP Length field\n\t\t *\tin the QoS Capability element from delivery-enabled ACs,\n\t\t *\tthat are destined for the non-AP STA.\n\t\t *\n\t\t * Since we have no other MSDU/MMPDU, transmit a QoS null frame.\n\t\t */\n\n\t\t/* This will evaluate to 1, 3, 5 or 7. */\n\t\ttid = 7 - ((ffs(~ignored_acs) - 1) << 1);\n\n\t\tieee80211_send_null_response(sdata, sta, tid, reason, true);\n\t} else if (!driver_release_tids) {\n\t\tstruct sk_buff_head pending;\n\t\tstruct sk_buff *skb;\n\t\tint num = 0;\n\t\tu16 tids = 0;\n\t\tbool need_null = false;\n\n\t\tskb_queue_head_init(&pending);\n\n\t\twhile ((skb = __skb_dequeue(&frames))) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\t\t\tu8 *qoshdr = NULL;\n\n\t\t\tnum++;\n\n\t\t\t/*\n\t\t\t * Tell TX path to send this frame even though the\n\t\t\t * STA may still remain is PS mode after this frame\n\t\t\t * exchange.\n\t\t\t */\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t\t\t       IEEE80211_TX_CTL_PS_RESPONSE;\n\n\t\t\t/*\n\t\t\t * Use MoreData flag to indicate whether there are\n\t\t\t * more buffered frames for this STA\n\t\t\t */\n\t\t\tif (more_data || !skb_queue_empty(&frames))\n\t\t\t\thdr->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t\telse\n\t\t\t\thdr->frame_control &=\n\t\t\t\t\tcpu_to_le16(~IEEE80211_FCTL_MOREDATA);\n\n\t\t\tif (ieee80211_is_data_qos(hdr->frame_control) ||\n\t\t\t    ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\t\t\tqoshdr = ieee80211_get_qos_ctl(hdr);\n\n\t\t\ttids |= BIT(skb->priority);\n\n\t\t\t__skb_queue_tail(&pending, skb);\n\n\t\t\t/* end service period after last frame or add one */\n\t\t\tif (!skb_queue_empty(&frames))\n\t\t\t\tcontinue;\n\n\t\t\tif (reason != IEEE80211_FRAME_RELEASE_UAPSD) {\n\t\t\t\t/* for PS-Poll, there's only one frame */\n\t\t\t\tinfo->flags |= IEEE80211_TX_STATUS_EOSP |\n\t\t\t\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* For uAPSD, things are a bit more complicated. If the\n\t\t\t * last frame has a QoS header (i.e. is a QoS-data or\n\t\t\t * QoS-nulldata frame) then just set the EOSP bit there\n\t\t\t * and be done.\n\t\t\t * If the frame doesn't have a QoS header (which means\n\t\t\t * it should be a bufferable MMPDU) then we can't set\n\t\t\t * the EOSP bit in the QoS header; add a QoS-nulldata\n\t\t\t * frame to the list to send it after the MMPDU.\n\t\t\t *\n\t\t\t * Note that this code is only in the mac80211-release\n\t\t\t * code path, we assume that the driver will not buffer\n\t\t\t * anything but QoS-data frames, or if it does, will\n\t\t\t * create the QoS-nulldata frame by itself if needed.\n\t\t\t *\n\t\t\t * Cf. 802.11-2012 10.2.1.10 (c).\n\t\t\t */\n\t\t\tif (qoshdr) {\n\t\t\t\t*qoshdr |= IEEE80211_QOS_CTL_EOSP;\n\n\t\t\t\tinfo->flags |= IEEE80211_TX_STATUS_EOSP |\n\t\t\t\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t} else {\n\t\t\t\t/* The standard isn't completely clear on this\n\t\t\t\t * as it says the more-data bit should be set\n\t\t\t\t * if there are more BUs. The QoS-Null frame\n\t\t\t\t * we're about to send isn't buffered yet, we\n\t\t\t\t * only create it below, but let's pretend it\n\t\t\t\t * was buffered just in case some clients only\n\t\t\t\t * expect more-data=0 when eosp=1.\n\t\t\t\t */\n\t\t\t\thdr->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t\t\tneed_null = true;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdrv_allow_buffered_frames(local, sta, tids, num,\n\t\t\t\t\t  reason, more_data);\n\n\t\tieee80211_add_pending_skbs(local, &pending);\n\n\t\tif (need_null)\n\t\t\tieee80211_send_null_response(\n\t\t\t\tsdata, sta, find_highest_prio_tid(tids),\n\t\t\t\treason, false);\n\n\t\tsta_info_recalc_tim(sta);\n\t} else {\n\t\t/*\n\t\t * We need to release a frame that is buffered somewhere in the\n\t\t * driver ... it'll have to handle that.\n\t\t * Note that the driver also has to check the number of frames\n\t\t * on the TIDs we're releasing from - if there are more than\n\t\t * n_frames it has to set the more-data bit (if we didn't ask\n\t\t * it to set it anyway due to other buffered frames); if there\n\t\t * are fewer than n_frames it has to make sure to adjust that\n\t\t * to allow the service period to end properly.\n\t\t */\n\t\tdrv_release_buffered_frames(local, sta, driver_release_tids,\n\t\t\t\t\t    n_frames, reason, more_data);\n\n\t\t/*\n\t\t * Note that we don't recalculate the TIM bit here as it would\n\t\t * most likely have no effect at all unless the driver told us\n\t\t * that the TID(s) became empty before returning here from the\n\t\t * release function.\n\t\t * Either way, however, when the driver tells us that the TID(s)\n\t\t * became empty we'll do the TIM recalculation.\n\t\t */\n\t}\n}\n\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta)\n{\n\tu8 ignore_for_response = sta->sta.uapsd_queues;\n\n\t/*\n\t * If all ACs are delivery-enabled then we should reply\n\t * from any of them, if only some are enabled we reply\n\t * only from the non-enabled ones.\n\t */\n\tif (ignore_for_response == BIT(IEEE80211_NUM_ACS) - 1)\n\t\tignore_for_response = 0;\n\n\tieee80211_sta_ps_deliver_response(sta, 1, ignore_for_response,\n\t\t\t\t\t  IEEE80211_FRAME_RELEASE_PSPOLL);\n}\n\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta)\n{\n\tint n_frames = sta->sta.max_sp;\n\tu8 delivery_enabled = sta->sta.uapsd_queues;\n\n\t/*\n\t * If we ever grow support for TSPEC this might happen if\n\t * the TSPEC update from hostapd comes in between a trigger\n\t * frame setting WLAN_STA_UAPSD in the RX path and this\n\t * actually getting called.\n\t */\n\tif (!delivery_enabled)\n\t\treturn;\n\n\tswitch (sta->sta.max_sp) {\n\tcase 1:\n\t\tn_frames = 2;\n\t\tbreak;\n\tcase 2:\n\t\tn_frames = 4;\n\t\tbreak;\n\tcase 3:\n\t\tn_frames = 6;\n\t\tbreak;\n\tcase 0:\n\t\t/* XXX: what is a good value? */\n\t\tn_frames = 8;\n\t\tbreak;\n\t}\n\n\tieee80211_sta_ps_deliver_response(sta, n_frames, ~delivery_enabled,\n\t\t\t\t\t  IEEE80211_FRAME_RELEASE_UAPSD);\n}\n\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\ttrace_api_sta_block_awake(sta->local, pubsta, block);\n\n\tif (block)\n\t\tset_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\telse if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_queue_work(hw, &sta->drv_unblock_wk);\n}\nEXPORT_SYMBOL(ieee80211_sta_block_awake);\n\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_local *local = sta->local;\n\n\ttrace_api_eosp(local, pubsta);\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n}\nEXPORT_SYMBOL(ieee80211_sta_eosp);\n\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *pubsta,\n\t\t\t\tu8 tid, bool buffered)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\n\ttrace_api_sta_set_buffered(sta->local, pubsta, tid, buffered);\n\n\tif (buffered)\n\t\tset_bit(tid, &sta->driver_buffered_tids);\n\telse\n\t\tclear_bit(tid, &sta->driver_buffered_tids);\n\n\tsta_info_recalc_tim(sta);\n}\nEXPORT_SYMBOL(ieee80211_sta_set_buffered);\n\nint sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state)\n{\n\tmight_sleep();\n\n\tif (sta->sta_state == new_state)\n\t\treturn 0;\n\n\t/* check allowed transitions first */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state != IEEE80211_STA_NONE &&\n\t\t    sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH &&\n\t\t    sta->sta_state != IEEE80211_STA_AUTHORIZED)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid state %d\", new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tsta_dbg(sta->sdata, \"moving STA %pM to state %d\\n\",\n\t\tsta->sta.addr, new_state);\n\n\t/*\n\t * notify the driver before the actual changes so it can\n\t * fail the transition\n\t */\n\tif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\n\t\tint err = drv_sta_state(sta->local, sta->sdata, sta,\n\t\t\t\t\tsta->sta_state, new_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reflect the change in all state variables */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH)\n\t\t\tclear_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state == IEEE80211_STA_NONE)\n\t\t\tset_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\telse if (sta->sta_state == IEEE80211_STA_ASSOC)\n\t\t\tclear_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH) {\n\t\t\tset_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\n\t\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t\t    (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     !sta->sdata->u.vlan.sta))\n\t\t\t\tatomic_dec(&sta->sdata->bss->num_mcast_sta);\n\t\t\tclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t\t    (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     !sta->sdata->u.vlan.sta))\n\t\t\t\tatomic_inc(&sta->sdata->bss->num_mcast_sta);\n\t\t\tset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsta->sta_state = new_state;\n\n\treturn 0;\n}\n\nu8 sta_info_tx_streams(struct sta_info *sta)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->sta.ht_cap;\n\tu8 rx_streams;\n\n\tif (!sta->sta.ht_cap.ht_supported)\n\t\treturn 1;\n\n\tif (sta->sta.vht_cap.vht_supported) {\n\t\tint i;\n\t\tu16 tx_mcs_map =\n\t\t\tle16_to_cpu(sta->sta.vht_cap.vht_mcs.tx_mcs_map);\n\n\t\tfor (i = 7; i >= 0; i--)\n\t\t\tif ((tx_mcs_map & (0x3 << (i * 2))) !=\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\t\treturn i + 1;\n\t}\n\n\tif (ht_cap->mcs.rx_mask[3])\n\t\trx_streams = 4;\n\telse if (ht_cap->mcs.rx_mask[2])\n\t\trx_streams = 3;\n\telse if (ht_cap->mcs.rx_mask[1])\n\t\trx_streams = 2;\n\telse\n\t\trx_streams = 1;\n\n\tif (!(ht_cap->mcs.tx_params & IEEE80211_HT_MCS_TX_RX_DIFF))\n\t\treturn rx_streams;\n\n\treturn ((ht_cap->mcs.tx_params & IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK)\n\t\t\t>> IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT) + 1;\n}\n", "/*\n * Copyright 2002-2005, Devicescape Software, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#ifndef STA_INFO_H\n#define STA_INFO_H\n\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/if_ether.h>\n#include <linux/workqueue.h>\n#include <linux/average.h>\n#include <linux/etherdevice.h>\n#include \"key.h\"\n\n/**\n * enum ieee80211_sta_info_flags - Stations flags\n *\n * These flags are used with &struct sta_info's @flags member, but\n * only indirectly with set_sta_flag() and friends.\n *\n * @WLAN_STA_AUTH: Station is authenticated.\n * @WLAN_STA_ASSOC: Station is associated.\n * @WLAN_STA_PS_STA: Station is in power-save mode\n * @WLAN_STA_AUTHORIZED: Station is authorized to send/receive traffic.\n *\tThis bit is always checked so needs to be enabled for all stations\n *\twhen virtual port control is not in use.\n * @WLAN_STA_SHORT_PREAMBLE: Station is capable of receiving short-preamble\n *\tframes.\n * @WLAN_STA_WME: Station is a QoS-STA.\n * @WLAN_STA_WDS: Station is one of our WDS peers.\n * @WLAN_STA_CLEAR_PS_FILT: Clear PS filter in hardware (using the\n *\tIEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next\n *\tframe to this station is transmitted.\n * @WLAN_STA_MFP: Management frame protection is used with this STA.\n * @WLAN_STA_BLOCK_BA: Used to deny ADDBA requests (both TX and RX)\n *\tduring suspend/resume and station removal.\n * @WLAN_STA_PS_DRIVER: driver requires keeping this station in\n *\tpower-save mode logically to flush frames that might still\n *\tbe in the queues\n * @WLAN_STA_PSPOLL: Station sent PS-poll while driver was keeping\n *\tstation in power-save mode, reply when the driver unblocks.\n * @WLAN_STA_TDLS_PEER: Station is a TDLS peer.\n * @WLAN_STA_TDLS_PEER_AUTH: This TDLS peer is authorized to send direct\n *\tpackets. This means the link is enabled.\n * @WLAN_STA_UAPSD: Station requested unscheduled SP while driver was\n *\tkeeping station in power-save mode, reply when the driver\n *\tunblocks the station.\n * @WLAN_STA_SP: Station is in a service period, so don't try to\n *\treply to other uAPSD trigger frames or PS-Poll.\n * @WLAN_STA_4ADDR_EVENT: 4-addr event was already sent for this frame.\n * @WLAN_STA_INSERTED: This station is inserted into the hash table.\n * @WLAN_STA_RATE_CONTROL: rate control was initialized for this station.\n * @WLAN_STA_TOFFSET_KNOWN: toffset calculated for this station is valid.\n * @WLAN_STA_MPSP_OWNER: local STA is owner of a mesh Peer Service Period.\n * @WLAN_STA_MPSP_RECIPIENT: local STA is recipient of a MPSP.\n */\nenum ieee80211_sta_info_flags {\n\tWLAN_STA_AUTH,\n\tWLAN_STA_ASSOC,\n\tWLAN_STA_PS_STA,\n\tWLAN_STA_AUTHORIZED,\n\tWLAN_STA_SHORT_PREAMBLE,\n\tWLAN_STA_WME,\n\tWLAN_STA_WDS,\n\tWLAN_STA_CLEAR_PS_FILT,\n\tWLAN_STA_MFP,\n\tWLAN_STA_BLOCK_BA,\n\tWLAN_STA_PS_DRIVER,\n\tWLAN_STA_PSPOLL,\n\tWLAN_STA_TDLS_PEER,\n\tWLAN_STA_TDLS_PEER_AUTH,\n\tWLAN_STA_UAPSD,\n\tWLAN_STA_SP,\n\tWLAN_STA_4ADDR_EVENT,\n\tWLAN_STA_INSERTED,\n\tWLAN_STA_RATE_CONTROL,\n\tWLAN_STA_TOFFSET_KNOWN,\n\tWLAN_STA_MPSP_OWNER,\n\tWLAN_STA_MPSP_RECIPIENT,\n};\n\n#define ADDBA_RESP_INTERVAL HZ\n#define HT_AGG_MAX_RETRIES\t\t15\n#define HT_AGG_BURST_RETRIES\t\t3\n#define HT_AGG_RETRIES_PERIOD\t\t(15 * HZ)\n\n#define HT_AGG_STATE_DRV_READY\t\t0\n#define HT_AGG_STATE_RESPONSE_RECEIVED\t1\n#define HT_AGG_STATE_OPERATIONAL\t2\n#define HT_AGG_STATE_STOPPING\t\t3\n#define HT_AGG_STATE_WANT_START\t\t4\n#define HT_AGG_STATE_WANT_STOP\t\t5\n\nenum ieee80211_agg_stop_reason {\n\tAGG_STOP_DECLINED,\n\tAGG_STOP_LOCAL_REQUEST,\n\tAGG_STOP_PEER_REQUEST,\n\tAGG_STOP_DESTROY_STA,\n};\n\n/**\n * struct tid_ampdu_tx - TID aggregation information (Tx).\n *\n * @rcu_head: rcu head for freeing structure\n * @session_timer: check if we keep Tx-ing on the TID (by timeout value)\n * @addba_resp_timer: timer for peer's response to addba request\n * @pending: pending frames queue -- use sta's spinlock to protect\n * @dialog_token: dialog token for aggregation session\n * @timeout: session timeout value to be filled in ADDBA requests\n * @state: session state (see above)\n * @last_tx: jiffies of last tx activity\n * @stop_initiator: initiator of a session stop\n * @tx_stop: TX DelBA frame when stopping\n * @buf_size: reorder buffer size at receiver\n * @failed_bar_ssn: ssn of the last failed BAR tx attempt\n * @bar_pending: BAR needs to be re-sent\n *\n * This structure's lifetime is managed by RCU, assignments to\n * the array holding it must hold the aggregation mutex.\n *\n * The TX path can access it under RCU lock-free if, and\n * only if, the state has the flag %HT_AGG_STATE_OPERATIONAL\n * set. Otherwise, the TX path must also acquire the spinlock\n * and re-check the state, see comments in the tx code\n * touching it.\n */\nstruct tid_ampdu_tx {\n\tstruct rcu_head rcu_head;\n\tstruct timer_list session_timer;\n\tstruct timer_list addba_resp_timer;\n\tstruct sk_buff_head pending;\n\tunsigned long state;\n\tunsigned long last_tx;\n\tu16 timeout;\n\tu8 dialog_token;\n\tu8 stop_initiator;\n\tbool tx_stop;\n\tu8 buf_size;\n\n\tu16 failed_bar_ssn;\n\tbool bar_pending;\n};\n\n/**\n * struct tid_ampdu_rx - TID aggregation information (Rx).\n *\n * @reorder_buf: buffer to reorder incoming aggregated MPDUs\n * @reorder_time: jiffies when skb was added\n * @session_timer: check if peer keeps Tx-ing on the TID (by timeout value)\n * @reorder_timer: releases expired frames from the reorder buffer.\n * @last_rx: jiffies of last rx activity\n * @head_seq_num: head sequence number in reordering buffer.\n * @stored_mpdu_num: number of MPDUs in reordering buffer\n * @ssn: Starting Sequence Number expected to be aggregated.\n * @buf_size: buffer size for incoming A-MPDUs\n * @timeout: reset timer value (in TUs).\n * @dialog_token: dialog token for aggregation session\n * @rcu_head: RCU head used for freeing this struct\n * @reorder_lock: serializes access to reorder buffer, see below.\n *\n * This structure's lifetime is managed by RCU, assignments to\n * the array holding it must hold the aggregation mutex.\n *\n * The @reorder_lock is used to protect the members of this\n * struct, except for @timeout, @buf_size and @dialog_token,\n * which are constant across the lifetime of the struct (the\n * dialog token being used only for debugging).\n */\nstruct tid_ampdu_rx {\n\tstruct rcu_head rcu_head;\n\tspinlock_t reorder_lock;\n\tstruct sk_buff **reorder_buf;\n\tunsigned long *reorder_time;\n\tstruct timer_list session_timer;\n\tstruct timer_list reorder_timer;\n\tunsigned long last_rx;\n\tu16 head_seq_num;\n\tu16 stored_mpdu_num;\n\tu16 ssn;\n\tu16 buf_size;\n\tu16 timeout;\n\tu8 dialog_token;\n};\n\n/**\n * struct sta_ampdu_mlme - STA aggregation information.\n *\n * @tid_rx: aggregation info for Rx per TID -- RCU protected\n * @tid_tx: aggregation info for Tx per TID\n * @tid_start_tx: sessions where start was requested\n * @addba_req_num: number of times addBA request has been sent.\n * @last_addba_req_time: timestamp of the last addBA request.\n * @dialog_token_allocator: dialog token enumerator for each new session;\n * @work: work struct for starting/stopping aggregation\n * @tid_rx_timer_expired: bitmap indicating on which TIDs the\n *\tRX timer expired until the work for it runs\n * @tid_rx_stop_requested:  bitmap indicating which BA sessions per TID the\n *\tdriver requested to close until the work for it runs\n * @mtx: mutex to protect all TX data (except non-NULL assignments\n *\tto tid_tx[idx], which are protected by the sta spinlock)\n *\ttid_start_tx is also protected by sta->lock.\n */\nstruct sta_ampdu_mlme {\n\tstruct mutex mtx;\n\t/* rx */\n\tstruct tid_ampdu_rx __rcu *tid_rx[IEEE80211_NUM_TIDS];\n\tunsigned long tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\tunsigned long tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\t/* tx */\n\tstruct work_struct work;\n\tstruct tid_ampdu_tx __rcu *tid_tx[IEEE80211_NUM_TIDS];\n\tstruct tid_ampdu_tx *tid_start_tx[IEEE80211_NUM_TIDS];\n\tunsigned long last_addba_req_time[IEEE80211_NUM_TIDS];\n\tu8 addba_req_num[IEEE80211_NUM_TIDS];\n\tu8 dialog_token_allocator;\n};\n\n/*\n * struct ieee80211_tx_latency_stat - Tx latency statistics\n *\n * Measures TX latency and jitter for a station per TID.\n *\n * @max: worst case latency\n * @sum: sum of all latencies\n * @counter: amount of Tx frames sent from interface\n * @bins: each bin counts how many frames transmitted within a certain\n * latency range. when disabled it is NULL.\n * @bin_count: amount of bins.\n */\nstruct ieee80211_tx_latency_stat {\n\tu32 max;\n\tu32 sum;\n\tu32 counter;\n\tu32 *bins;\n\tu32 bin_count;\n};\n\n/**\n * struct sta_info - STA information\n *\n * This structure collects information about a station that\n * mac80211 is communicating with.\n *\n * @list: global linked list entry\n * @free_list: list entry for keeping track of stations to free\n * @hnext: hash table linked list pointer\n * @local: pointer to the global information\n * @sdata: virtual interface this station belongs to\n * @ptk: peer keys negotiated with this station, if any\n * @ptk_idx: last installed peer key index\n * @gtk: group keys negotiated with this station, if any\n * @gtk_idx: last installed group key index\n * @rate_ctrl: rate control algorithm reference\n * @rate_ctrl_priv: rate control private per-STA pointer\n * @last_tx_rate: rate used for last transmit, to report to userspace as\n *\t\"the\" transmit rate\n * @last_rx_rate_idx: rx status rate index of the last data packet\n * @last_rx_rate_flag: rx status flag of the last data packet\n * @last_rx_rate_vht_nss: rx status nss of last data packet\n * @lock: used for locking all fields that require locking, see comments\n *\tin the header file.\n * @drv_unblock_wk: used for driver PS unblocking\n * @listen_interval: listen interval of this station, when we're acting as AP\n * @_flags: STA flags, see &enum ieee80211_sta_info_flags, do not use directly\n * @ps_tx_buf: buffers (per AC) of frames to transmit to this station\n *\twhen it leaves power saving state or polls\n * @tx_filtered: buffers (per AC) of frames we already tried to\n *\ttransmit but were filtered by hardware due to STA having\n *\tentered power saving state, these are also delivered to\n *\tthe station when it leaves powersave or polls for frames\n * @driver_buffered_tids: bitmap of TIDs the driver has data buffered on\n * @rx_packets: Number of MSDUs received from this STA\n * @rx_bytes: Number of bytes received from this STA\n * @wep_weak_iv_count: number of weak WEP IVs received from this station\n * @last_rx: time (in jiffies) when last frame was received from this STA\n * @last_connected: time (in seconds) when a station got connected\n * @num_duplicates: number of duplicate frames received from this STA\n * @rx_fragments: number of received MPDUs\n * @rx_dropped: number of dropped MPDUs from this STA\n * @last_signal: signal of last received frame from this STA\n * @avg_signal: moving average of signal of received frames from this STA\n * @last_ack_signal: signal of last received Ack frame from this STA\n * @last_seq_ctrl: last received seq/frag number from this STA (per RX queue)\n * @tx_filtered_count: number of frames the hardware filtered for this STA\n * @tx_retry_failed: number of frames that failed retry\n * @tx_retry_count: total number of retries for frames to this STA\n * @fail_avg: moving percentage of failed MSDUs\n * @tx_packets: number of RX/TX MSDUs\n * @tx_bytes: number of bytes transmitted to this STA\n * @tx_fragments: number of transmitted MPDUs\n * @tid_seq: per-TID sequence numbers for sending to this STA\n * @ampdu_mlme: A-MPDU state machine state\n * @timer_to_tid: identity mapping to ID timers\n * @tx_lat: Tx latency statistics\n * @llid: Local link ID\n * @plid: Peer link ID\n * @reason: Cancel reason on PLINK_HOLDING state\n * @plink_retries: Retries in establishment\n * @ignore_plink_timer: ignore the peer-link timer (used internally)\n * @plink_state: peer link state\n * @plink_timeout: timeout of peer link\n * @plink_timer: peer link watch timer\n * @t_offset: timing offset relative to this host\n * @t_offset_setpoint: reference timing offset of this sta to be used when\n * \tcalculating clockdrift\n * @local_pm: local link-specific power save mode\n * @peer_pm: peer-specific power save mode towards local STA\n * @nonpeer_pm: STA power save mode towards non-peer neighbors\n * @debugfs: debug filesystem info\n * @dead: set to true when sta is unlinked\n * @uploaded: set to true when sta is uploaded to the driver\n * @lost_packets: number of consecutive lost packets\n * @sta: station information we share with the driver\n * @sta_state: duplicates information about station state (for debug)\n * @beacon_loss_count: number of times beacon loss has triggered\n * @rcu_head: RCU head used for freeing this station struct\n * @cur_max_bandwidth: maximum bandwidth to use for TX to the station,\n *\ttaken from HT/VHT capabilities or VHT operating mode notification\n * @chains: chains ever used for RX from this station\n * @chain_signal_last: last signal (per chain)\n * @chain_signal_avg: signal average (per chain)\n * @known_smps_mode: the smps_mode the client thinks we are in. Relevant for\n *\tAP only.\n * @cipher_scheme: optional cipher scheme for this station\n */\nstruct sta_info {\n\t/* General information, mostly static */\n\tstruct list_head list, free_list;\n\tstruct rcu_head rcu_head;\n\tstruct sta_info __rcu *hnext;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS];\n\tstruct ieee80211_key __rcu *ptk[NUM_DEFAULT_KEYS];\n\tu8 gtk_idx;\n\tu8 ptk_idx;\n\tstruct rate_control_ref *rate_ctrl;\n\tvoid *rate_ctrl_priv;\n\tspinlock_t lock;\n\n\tstruct work_struct drv_unblock_wk;\n\n\tu16 listen_interval;\n\n\tbool dead;\n\n\tbool uploaded;\n\n\tenum ieee80211_sta_state sta_state;\n\n\t/* use the accessors defined below */\n\tunsigned long _flags;\n\n\t/*\n\t * STA powersave frame queues, no more than the internal\n\t * locking required.\n\t */\n\tstruct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];\n\tstruct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];\n\tunsigned long driver_buffered_tids;\n\n\t/* Updated from RX path only, no locking requirements */\n\tunsigned long rx_packets;\n\tu64 rx_bytes;\n\tunsigned long wep_weak_iv_count;\n\tunsigned long last_rx;\n\tlong last_connected;\n\tunsigned long num_duplicates;\n\tunsigned long rx_fragments;\n\tunsigned long rx_dropped;\n\tint last_signal;\n\tstruct ewma avg_signal;\n\tint last_ack_signal;\n\n\tu8 chains;\n\ts8 chain_signal_last[IEEE80211_MAX_CHAINS];\n\tstruct ewma chain_signal_avg[IEEE80211_MAX_CHAINS];\n\n\t/* Plus 1 for non-QoS frames */\n\t__le16 last_seq_ctrl[IEEE80211_NUM_TIDS + 1];\n\n\t/* Updated from TX status path only, no locking requirements */\n\tunsigned long tx_filtered_count;\n\tunsigned long tx_retry_failed, tx_retry_count;\n\t/* moving percentage of failed MSDUs */\n\tunsigned int fail_avg;\n\n\t/* Updated from TX path only, no locking requirements */\n\tu32 tx_fragments;\n\tu64 tx_packets[IEEE80211_NUM_ACS];\n\tu64 tx_bytes[IEEE80211_NUM_ACS];\n\tstruct ieee80211_tx_rate last_tx_rate;\n\tint last_rx_rate_idx;\n\tu32 last_rx_rate_flag;\n\tu8 last_rx_rate_vht_nss;\n\tu16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];\n\n\t/*\n\t * Aggregation information, locked with lock.\n\t */\n\tstruct sta_ampdu_mlme ampdu_mlme;\n\tu8 timer_to_tid[IEEE80211_NUM_TIDS];\n\n\tstruct ieee80211_tx_latency_stat *tx_lat;\n\n#ifdef CONFIG_MAC80211_MESH\n\t/*\n\t * Mesh peer link attributes\n\t * TODO: move to a sub-structure that is referenced with pointer?\n\t */\n\tu16 llid;\n\tu16 plid;\n\tu16 reason;\n\tu8 plink_retries;\n\tbool ignore_plink_timer;\n\tenum nl80211_plink_state plink_state;\n\tu32 plink_timeout;\n\tstruct timer_list plink_timer;\n\ts64 t_offset;\n\ts64 t_offset_setpoint;\n\t/* mesh power save */\n\tenum nl80211_mesh_power_mode local_pm;\n\tenum nl80211_mesh_power_mode peer_pm;\n\tenum nl80211_mesh_power_mode nonpeer_pm;\n#endif\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct sta_info_debugfsdentries {\n\t\tstruct dentry *dir;\n\t\tbool add_has_run;\n\t} debugfs;\n#endif\n\n\tenum ieee80211_sta_rx_bandwidth cur_max_bandwidth;\n\n\tunsigned int lost_packets;\n\tunsigned int beacon_loss_count;\n\n\tenum ieee80211_smps_mode known_smps_mode;\n\tconst struct ieee80211_cipher_scheme *cipher_scheme;\n\n\t/* keep last! */\n\tstruct ieee80211_sta sta;\n};\n\nstatic inline enum nl80211_plink_state sta_plink_state(struct sta_info *sta)\n{\n#ifdef CONFIG_MAC80211_MESH\n\treturn sta->plink_state;\n#endif\n\treturn NL80211_PLINK_LISTEN;\n}\n\nstatic inline void set_sta_flag(struct sta_info *sta,\n\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\tset_bit(flag, &sta->_flags);\n}\n\nstatic inline void clear_sta_flag(struct sta_info *sta,\n\t\t\t\t  enum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\tclear_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_sta_flag(struct sta_info *sta,\n\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\treturn test_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_and_clear_sta_flag(struct sta_info *sta,\n\t\t\t\t\t  enum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\treturn test_and_clear_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_and_set_sta_flag(struct sta_info *sta,\n\t\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\treturn test_and_set_bit(flag, &sta->_flags);\n}\n\nint sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state);\n\nstatic inline void sta_info_pre_move_state(struct sta_info *sta,\n\t\t\t\t\t   enum ieee80211_sta_state new_state)\n{\n\tint ret;\n\n\tWARN_ON_ONCE(test_sta_flag(sta, WLAN_STA_INSERTED));\n\n\tret = sta_info_move_state(sta, new_state);\n\tWARN_ON_ONCE(ret);\n}\n\n\nvoid ieee80211_assign_tid_tx(struct sta_info *sta, int tid,\n\t\t\t     struct tid_ampdu_tx *tid_tx);\n\nstatic inline struct tid_ampdu_tx *\nrcu_dereference_protected_tid_tx(struct sta_info *sta, int tid)\n{\n\treturn rcu_dereference_protected(sta->ampdu_mlme.tid_tx[tid],\n\t\t\t\t\t lockdep_is_held(&sta->lock) ||\n\t\t\t\t\t lockdep_is_held(&sta->ampdu_mlme.mtx));\n}\n\n#define STA_HASH_SIZE 256\n#define STA_HASH(sta) (sta[5])\n\n\n/* Maximum number of frames to buffer per power saving station per AC */\n#define STA_MAX_TX_BUFFER\t64\n\n/* Minimum buffered frame expiry time. If STA uses listen interval that is\n * smaller than this value, the minimum value here is used instead. */\n#define STA_TX_BUFFER_EXPIRE (10 * HZ)\n\n/* How often station data is cleaned up (e.g., expiration of buffered frames)\n */\n#define STA_INFO_CLEANUP_INTERVAL (10 * HZ)\n\n/*\n * Get a STA info, must be under RCU read lock.\n */\nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr);\n\nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  const u8 *addr);\n\nstatic inline\nvoid for_each_sta_info_type_check(struct ieee80211_local *local,\n\t\t\t\t  const u8 *addr,\n\t\t\t\t  struct sta_info *sta,\n\t\t\t\t  struct sta_info *nxt)\n{\n}\n\n#define for_each_sta_info(local, _addr, _sta, nxt)\t\t\t\\\n\tfor (\t/* initialise loop */\t\t\t\t\t\\\n\t\t_sta = rcu_dereference(local->sta_hash[STA_HASH(_addr)]),\\\n\t\tnxt = _sta ? rcu_dereference(_sta->hnext) : NULL;\t\\\n\t\t/* typecheck */\t\t\t\t\t\t\\\n\t\tfor_each_sta_info_type_check(local, (_addr), _sta, nxt),\\\n\t\t/* continue condition */\t\t\t\t\\\n\t\t_sta;\t\t\t\t\t\t\t\\\n\t\t/* advance loop */\t\t\t\t\t\\\n\t\t_sta = nxt,\t\t\t\t\t\t\\\n\t\tnxt = _sta ? rcu_dereference(_sta->hnext) : NULL\t\\\n\t     )\t\t\t\t\t\t\t\t\\\n\t/* compare address and run code only if it matches */\t\t\\\n\tif (ether_addr_equal(_sta->sta.addr, (_addr)))\n\n/*\n * Get STA info by index, BROKEN!\n */\nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     int idx);\n/*\n * Create a new STA info, caller owns returned structure\n * until sta_info_insert().\n */\nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *addr, gfp_t gfp);\n\nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta);\n\n/*\n * Insert STA info into hash table/list, returns zero or a\n * -EEXIST if (if the same MAC address is already present).\n *\n * Calling the non-rcu version makes the caller relinquish,\n * the _rcu version calls read_lock_rcu() and must be called\n * without it held.\n */\nint sta_info_insert(struct sta_info *sta);\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU);\n\nint __must_check __sta_info_destroy(struct sta_info *sta);\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata,\n\t\t\t  const u8 *addr);\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr);\n\nvoid sta_info_recalc_tim(struct sta_info *sta);\n\nvoid sta_info_init(struct ieee80211_local *local);\nvoid sta_info_stop(struct ieee80211_local *local);\n\n/**\n * sta_info_flush - flush matching STA entries from the STA table\n *\n * Returns the number of removed STA entries.\n *\n * @sdata: sdata to remove all stations from\n * @vlans: if the given interface is an AP interface, also flush VLANs\n */\nint __sta_info_flush(struct ieee80211_sub_if_data *sdata, bool vlans);\n\nstatic inline int sta_info_flush(struct ieee80211_sub_if_data *sdata)\n{\n\treturn __sta_info_flush(sdata, false);\n}\n\nvoid sta_set_rate_info_tx(struct sta_info *sta,\n\t\t\t  const struct ieee80211_tx_rate *rate,\n\t\t\t  struct rate_info *rinfo);\nvoid sta_set_rate_info_rx(struct sta_info *sta,\n\t\t\t  struct rate_info *rinfo);\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time);\nu8 sta_info_tx_streams(struct sta_info *sta);\n\nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta);\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta);\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta);\n\n#endif /* STA_INFO_H */\n", "/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007\tJohannes Berg <johannes@sipsolutions.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n *\n * Transmit and frame generation functions.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/bitmap.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/time.h>\n#include <net/net_namespace.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"led.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"wpa.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n/* misc utils */\n\nstatic __le16 ieee80211_duration(struct ieee80211_tx_data *tx,\n\t\t\t\t struct sk_buff *skb, int group_addr,\n\t\t\t\t int next_frag_len)\n{\n\tint rate, mrate, erp, dur, i, shift = 0;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tu32 rate_flags = 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(tx->sdata->vif.chanctx_conf);\n\tif (chanctx_conf) {\n\t\tshift = ieee80211_chandef_get_shift(&chanctx_conf->def);\n\t\trate_flags = ieee80211_chandef_rate_flags(&chanctx_conf->def);\n\t}\n\trcu_read_unlock();\n\n\t/* assume HW handles this */\n\tif (tx->rate.flags & IEEE80211_TX_RC_MCS)\n\t\treturn 0;\n\n\t/* uh huh? */\n\tif (WARN_ON_ONCE(tx->rate.idx < 0))\n\t\treturn 0;\n\n\tsband = local->hw.wiphy->bands[info->band];\n\ttxrate = &sband->bitrates[tx->rate.idx];\n\n\terp = txrate->flags & IEEE80211_RATE_ERP_G;\n\n\t/*\n\t * data and mgmt (except PS Poll):\n\t * - during CFP: 32768\n\t * - during contention period:\n\t *   if addr1 is group address: 0\n\t *   if more fragments = 0 and addr1 is individual address: time to\n\t *      transmit one ACK plus SIFS\n\t *   if more fragments = 1 and addr1 is individual address: time to\n\t *      transmit next fragment plus 2 x ACK plus 3 x SIFS\n\t *\n\t * IEEE 802.11, 9.6:\n\t * - control response frame (CTS or ACK) shall be transmitted using the\n\t *   same rate as the immediately previous frame in the frame exchange\n\t *   sequence, if this rate belongs to the PHY mandatory rates, or else\n\t *   at the highest possible rate belonging to the PHY rates in the\n\t *   BSSBasicRateSet\n\t */\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (ieee80211_is_ctl(hdr->frame_control)) {\n\t\t/* TODO: These control frames are not currently sent by\n\t\t * mac80211, but should they be implemented, this function\n\t\t * needs to be updated to support duration field calculation.\n\t\t *\n\t\t * RTS: time needed to transmit pending data/mgmt frame plus\n\t\t *    one CTS frame plus one ACK frame plus 3 x SIFS\n\t\t * CTS: duration of immediately previous RTS minus time\n\t\t *    required to transmit CTS and its SIFS\n\t\t * ACK: 0 if immediately previous directed data/mgmt had\n\t\t *    more=0, with more=1 duration in ACK frame is duration\n\t\t *    from previous frame minus time needed to transmit ACK\n\t\t *    and its SIFS\n\t\t * PS Poll: BIT(15) | BIT(14) | aid\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/* data/mgmt */\n\tif (0 /* FIX: data/mgmt during CFP */)\n\t\treturn cpu_to_le16(32768);\n\n\tif (group_addr) /* Group address as the destination - no ACK */\n\t\treturn 0;\n\n\t/* Individual destination address:\n\t * IEEE 802.11, Ch. 9.6 (after IEEE 802.11g changes)\n\t * CTS and ACK frames shall be transmitted using the highest rate in\n\t * basic rate set that is less than or equal to the rate of the\n\t * immediately previous frame and that is using the same modulation\n\t * (CCK or OFDM). If no basic rate set matches with these requirements,\n\t * the highest mandatory rate of the PHY that is less than or equal to\n\t * the rate of the previous frame is used.\n\t * Mandatory rates for IEEE 802.11g PHY: 1, 2, 5.5, 11, 6, 12, 24 Mbps\n\t */\n\trate = -1;\n\t/* use lowest available if everything fails */\n\tmrate = sband->bitrates[0].bitrate;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tstruct ieee80211_rate *r = &sband->bitrates[i];\n\n\t\tif (r->bitrate > txrate->bitrate)\n\t\t\tbreak;\n\n\t\tif ((rate_flags & r->flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tif (tx->sdata->vif.bss_conf.basic_rates & BIT(i))\n\t\t\trate = DIV_ROUND_UP(r->bitrate, 1 << shift);\n\n\t\tswitch (sband->band) {\n\t\tcase IEEE80211_BAND_2GHZ: {\n\t\t\tu32 flag;\n\t\t\tif (tx->sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_G;\n\t\t\telse\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_B;\n\t\t\tif (r->flags & flag)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\t}\n\t\tcase IEEE80211_BAND_5GHZ:\n\t\t\tif (r->flags & IEEE80211_RATE_MANDATORY_A)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\tcase IEEE80211_BAND_60GHZ:\n\t\t\t/* TODO, for now fall through */\n\t\tcase IEEE80211_NUM_BANDS:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rate == -1) {\n\t\t/* No matching basic rate found; use highest suitable mandatory\n\t\t * PHY rate */\n\t\trate = DIV_ROUND_UP(mrate, 1 << shift);\n\t}\n\n\t/* Don't calculate ACKs for QoS Frames with NoAck Policy set */\n\tif (ieee80211_is_data_qos(hdr->frame_control) &&\n\t    *(ieee80211_get_qos_ctl(hdr)) & IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\tdur = 0;\n\telse\n\t\t/* Time needed to transmit ACK\n\t\t * (10 bytes + 4-byte FCS = 112 bits) plus SIFS; rounded up\n\t\t * to closest integer */\n\t\tdur = ieee80211_frame_duration(sband->band, 10, rate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\n\tif (next_frag_len) {\n\t\t/* Frame is fragmented: duration increases with time needed to\n\t\t * transmit next fragment plus ACK and 2 x SIFS. */\n\t\tdur *= 2; /* ACK + SIFS */\n\t\t/* next fragment */\n\t\tdur += ieee80211_frame_duration(sband->band, next_frag_len,\n\t\t\t\ttxrate->bitrate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\t}\n\n\treturn cpu_to_le16(dur);\n}\n\n/* tx handlers */\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\n\t/* driver doesn't support power save */\n\tif (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\n\t/* hardware does dynamic power save */\n\tif (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic power save disabled */\n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\n\t/* we are scanning, don't enable power save */\n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\n\t/* No point if we're going to suspend */\n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic ps is supported only in managed mode */\n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\n\tifmgd = &tx->sdata->u.mgd;\n\n\t/*\n\t * Don't wakeup from power save if u-apsd is enabled, voip ac has\n\t * u-apsd enabled and the frame is in voip class. This effectively\n\t * means that even if all access categories have u-apsd enabled, in\n\t * practise u-apsd is only used with the voip ac. This is a\n\t * workaround for the case when received voip class packets do not\n\t * have correct qos tag for some reason, due the network or the\n\t * peer application.\n\t *\n\t * Note: ifmgd->uapsd_queues access is racy here. If the value is\n\t * changed via debugfs, user needs to reassociate manually to have\n\t * everything in sync.\n\t */\n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\n\t/* Don't restart the timer if we're not disassociated */\n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_nullfunc(hdr->frame_control))\n\t\t/*\n\t\t * When software scanning only nullfunc frames (to notify\n\t\t * the sleep state to the AP) and probe requests (for the\n\t\t * active scan) are allowed, all other frames should not be\n\t\t * sent and we should not get here, but if we do\n\t\t * nonetheless, drop them to avoid sending them\n\t\t * off-channel. See the link below and\n\t\t * ieee80211_start_scan() for more.\n\t\t *\n\t\t * http://article.gmane.org/gmane.linux.kernel.wireless.general/30089\n\t\t */\n\t\treturn TX_DROP;\n\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(tx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    !atomic_read(&tx->sdata->u.ap.num_mcast_sta))) {\n\t\t/*\n\t\t * No associated STAs - no need to send multicast\n\t\t * frames.\n\t\t */\n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* This function is called whenever the AP is about to exceed the maximum limit\n * of buffered frames for power saving STAs. This situation should not really\n * happen often during normal operation, so dropping the oldest buffered packet\n * from each queue should be OK to make some room for new frames. */\nstatic void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\n\t/*\n\t * broadcast/multicast frame\n\t *\n\t * If any of the associated/peer stations is in power save mode,\n\t * the frame is buffered to be sent after DTIM beacon frame.\n\t * This is done either by the hardware or us.\n\t */\n\n\t/* powersaving STAs currently only in AP/VLAN/mesh mode */\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\n\n\t/* no buffering for ordered frames */\n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (tx->local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\n\t/* no stations in PS mode */\n\tif (!atomic_read(&ps->num_sta_ps))\n\t\treturn TX_CONTINUE;\n\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\n\t/* device releases frame after DTIM beacon */\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\n\t/* buffered in mac80211 */\n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tdev_kfree_skb(skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\n\treturn TX_QUEUED;\n}\n\nstatic int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,\n\t\t\t     struct sk_buff *skb)\n{\n\tif (!ieee80211_is_mgmt(fc))\n\t\treturn 0;\n\n\tif (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))\n\t\treturn 0;\n\n\tif (!ieee80211_is_robust_mgmt_frame((struct ieee80211_hdr *)\n\t\t\t\t\t    skb->data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_local *local = tx->local;\n\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n\t\t       sta->sta.addr, sta->sta.aid, ac);\n\t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\t\tpurge_old_ps_buffers(tx->local);\n\t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n\t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n\t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n\n\t\tif (!timer_pending(&local->sta_cleanup))\n\t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\n\t\t/*\n\t\t * We queued up some frames, so the TIM bit might\n\t\t * need to be set, recalculate it.\n\t\t */\n\t\tsta_info_recalc_tim(sta);\n\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\n\tif (unlikely(tx->flags & IEEE80211_TX_PS_BUFFERED))\n\t\treturn TX_CONTINUE;\n\n\t/* only deauth, disassoc and action are bufferable MMPDUs */\n\tif (ieee80211_is_mgmt(hdr->frame_control) &&\n\t    !ieee80211_is_deauth(hdr->frame_control) &&\n\t    !ieee80211_is_disassoc(hdr->frame_control) &&\n\t    !ieee80211_is_action(hdr->frame_control)) {\n\t\tif (tx->flags & IEEE80211_TX_UNICAST)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\n\t\treturn TX_CONTINUE;\n\t}\n\n\tif (tx->flags & IEEE80211_TX_UNICAST)\n\t\treturn ieee80211_tx_h_unicast_ps_buf(tx);\n\telse\n\t\treturn ieee80211_tx_h_multicast_ps_buf(tx);\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\tif (unlikely(tx->sdata->control_port_protocol == tx->skb->protocol)) {\n\t\tif (tx->sdata->control_port_no_encrypt)\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_select_key(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT))\n\t\ttx->key = NULL;\n\telse if (tx->sta &&\n\t\t (key = rcu_dereference(tx->sta->ptk[tx->sta->ptk_idx])))\n\t\ttx->key = key;\n\telse if (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t is_multicast_ether_addr(hdr->addr1) &&\n\t\t ieee80211_is_robust_mgmt_frame(hdr) &&\n\t\t (key = rcu_dereference(tx->sdata->default_mgmt_key)))\n\t\ttx->key = key;\n\telse if (is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_multicast_key)))\n\t\ttx->key = key;\n\telse if (!is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_unicast_key)))\n\t\ttx->key = key;\n\telse if (info->flags & IEEE80211_TX_CTL_INJECTED)\n\t\ttx->key = NULL;\n\telse if (!tx->sdata->drop_unencrypted)\n\t\ttx->key = NULL;\n\telse if (tx->skb->protocol == tx->sdata->control_port_protocol)\n\t\ttx->key = NULL;\n\telse if (ieee80211_is_robust_mgmt_frame(hdr) &&\n\t\t !(ieee80211_is_action(hdr->frame_control) &&\n\t\t   tx->sta && test_sta_flag(tx->sta, WLAN_STA_MFP)))\n\t\ttx->key = NULL;\n\telse if (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t !ieee80211_is_robust_mgmt_frame(hdr))\n\t\ttx->key = NULL;\n\telse {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_unencrypted);\n\t\treturn TX_DROP;\n\t}\n\n\tif (tx->key) {\n\t\tbool skip_hw = false;\n\n\t\ttx->key->tx_rx_count++;\n\t\t/* TODO: add threshold stuff again */\n\n\t\tswitch (tx->key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control) &&\n\t\t\t    !ieee80211_use_mfp(hdr->frame_control, tx->sta,\n\t\t\t\t\t       tx->skb))\n\t\t\t\ttx->key = NULL;\n\t\t\telse\n\t\t\t\tskip_hw = (tx->key->conf.flags &\n\t\t\t\t\t   IEEE80211_KEY_FLAG_SW_MGMT_TX) &&\n\t\t\t\t\tieee80211_is_mgmt(hdr->frame_control);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(tx->key && tx->key->flags & KEY_FLAG_TAINTED &&\n\t\t\t     !ieee80211_is_deauth(hdr->frame_control)))\n\t\t\treturn TX_DROP;\n\n\t\tif (!skip_hw && tx->key &&\n\t\t    tx->key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)\n\t\t\tinfo->control.hw_key = &tx->key->conf;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_rate_ctrl(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (void *)tx->skb->data;\n\tstruct ieee80211_supported_band *sband;\n\tu32 len;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_sta_rates *ratetbl = NULL;\n\tbool assoc = false;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\n\tsband = tx->local->hw.wiphy->bands[info->band];\n\n\tlen = min_t(u32, tx->skb->len + FCS_LEN,\n\t\t\t tx->local->hw.wiphy->frag_threshold);\n\n\t/* set up the tx rate control struct we give the RC algo */\n\ttxrc.hw = &tx->local->hw;\n\ttxrc.sband = sband;\n\ttxrc.bss_conf = &tx->sdata->vif.bss_conf;\n\ttxrc.skb = tx->skb;\n\ttxrc.reported_rate.idx = -1;\n\ttxrc.rate_idx_mask = tx->sdata->rc_rateidx_mask[info->band];\n\tif (txrc.rate_idx_mask == (1 << sband->n_bitrates) - 1)\n\t\ttxrc.max_rate_idx = -1;\n\telse\n\t\ttxrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;\n\n\tif (tx->sdata->rc_has_mcs_mask[info->band])\n\t\ttxrc.rate_idx_mcs_mask =\n\t\t\ttx->sdata->rc_rateidx_mcs_mask[info->band];\n\n\ttxrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC);\n\n\t/* set up RTS protection if desired */\n\tif (len > tx->local->hw.wiphy->rts_threshold) {\n\t\ttxrc.rts = true;\n\t}\n\n\tinfo->control.use_rts = txrc.rts;\n\tinfo->control.use_cts_prot = tx->sdata->vif.bss_conf.use_cts_prot;\n\n\t/*\n\t * Use short preamble if the BSS can handle it, but not for\n\t * management frames unless we know the receiver can handle\n\t * that -- the management frame might be to a station that\n\t * just wants a probe response.\n\t */\n\tif (tx->sdata->vif.bss_conf.use_short_preamble &&\n\t    (ieee80211_is_data(hdr->frame_control) ||\n\t     (tx->sta && test_sta_flag(tx->sta, WLAN_STA_SHORT_PREAMBLE))))\n\t\ttxrc.short_preamble = true;\n\n\tinfo->control.short_preamble = txrc.short_preamble;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\t/*\n\t * Lets not bother rate control if we're associated and cannot\n\t * talk to the sta. This should not happen.\n\t */\n\tif (WARN(test_bit(SCAN_SW_SCANNING, &tx->local->scanning) && assoc &&\n\t\t !rate_usable_index_exists(sband, &tx->sta->sta),\n\t\t \"%s: Dropped data frame as no usable bitrate found while \"\n\t\t \"scanning and associated. Target station: \"\n\t\t \"%pM on %d GHz band\\n\",\n\t\t tx->sdata->name, hdr->addr1,\n\t\t info->band ? 5 : 2))\n\t\treturn TX_DROP;\n\n\t/*\n\t * If we're associated with the sta at this point we know we can at\n\t * least send the frame at the lowest bit rate.\n\t */\n\trate_control_get_rate(tx->sdata, tx->sta, &txrc);\n\n\tif (tx->sta && !info->control.skip_table)\n\t\tratetbl = rcu_dereference(tx->sta->sta.rates);\n\n\tif (unlikely(info->control.rates[0].idx < 0)) {\n\t\tif (ratetbl) {\n\t\t\tstruct ieee80211_tx_rate rate = {\n\t\t\t\t.idx = ratetbl->rate[0].idx,\n\t\t\t\t.flags = ratetbl->rate[0].flags,\n\t\t\t\t.count = ratetbl->rate[0].count\n\t\t\t};\n\n\t\t\tif (ratetbl->rate[0].idx < 0)\n\t\t\t\treturn TX_DROP;\n\n\t\t\ttx->rate = rate;\n\t\t} else {\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else {\n\t\ttx->rate = info->control.rates[0];\n\t}\n\n\tif (txrc.reported_rate.idx < 0) {\n\t\ttxrc.reported_rate = tx->rate;\n\t\tif (tx->sta && ieee80211_is_data(hdr->frame_control))\n\t\t\ttx->sta->last_tx_rate = txrc.reported_rate;\n\t} else if (tx->sta)\n\t\ttx->sta->last_tx_rate = txrc.reported_rate;\n\n\tif (ratetbl)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(!info->control.rates[0].count))\n\t\tinfo->control.rates[0].count = 1;\n\n\tif (WARN_ON_ONCE((info->control.rates[0].count > 1) &&\n\t\t\t (info->flags & IEEE80211_TX_CTL_NO_ACK)))\n\t\tinfo->control.rates[0].count = 1;\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_sequence(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tu16 *seq;\n\tu8 *qc;\n\tint tid;\n\n\t/*\n\t * Packet injection may want to control the sequence\n\t * number, if we have no matching interface then we\n\t * neither assign one ourselves nor ask the driver to.\n\t */\n\tif (unlikely(info->control.vif->type == NL80211_IFTYPE_MONITOR))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(ieee80211_is_ctl(hdr->frame_control)))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hdrlen(hdr->frame_control) < 24)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Anything but QoS data that has a sequence number field\n\t * (is long enough) gets a sequence number from the global\n\t * counter.  QoS data frames with a multicast destination\n\t * also use the global counter (802.11-2012 9.3.2.10).\n\t */\n\tif (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1)) {\n\t\t/* driver should assign sequence number */\n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\t/* for pure STA mode without beacons, we can do it */\n\t\thdr->seq_ctrl = cpu_to_le16(tx->sdata->sequence_number);\n\t\ttx->sdata->sequence_number += 0x10;\n\t\treturn TX_CONTINUE;\n\t}\n\n\t/*\n\t * This should be true for injected/management frames only, for\n\t * management frames we have set the IEEE80211_TX_CTL_ASSIGN_SEQ\n\t * above since they are not QoS-data frames.\n\t */\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\t/* include per-STA, per-TID sequence counter */\n\n\tqc = ieee80211_get_qos_ctl(hdr);\n\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\tseq = &tx->sta->tid_seq[tid];\n\n\thdr->seq_ctrl = cpu_to_le16(*seq);\n\n\t/* Increase the sequence number. */\n\t*seq = (*seq + 0x10) & IEEE80211_SCTL_SEQ;\n\n\treturn TX_CONTINUE;\n}\n\nstatic int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\n\t/* first fragment was already added to queue by caller */\n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\n\t\t/* copy control information */\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\n\t\t/* copy header and data */\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\n\t\tpos += fraglen;\n\t}\n\n\t/* adjust first fragment's length */\n\tskb_trim(skb, hdrlen + per_fragm);\n\treturn 0;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb = tx->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tint frag_threshold = tx->local->hw.wiphy->frag_threshold;\n\tint hdrlen;\n\tint fragnum;\n\n\t/* no matter what happens, tx->skb moves to tx->skbs */\n\t__skb_queue_tail(&tx->skbs, skb);\n\ttx->skb = NULL;\n\n\tif (info->flags & IEEE80211_TX_CTL_DONTFRAG)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->local->ops->set_frag_threshold)\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Warn when submitting a fragmented A-MPDU frame and drop it.\n\t * This scenario is handled in ieee80211_tx_prepare but extra\n\t * caution taken here as fragmented ampdu may cause Tx stop.\n\t */\n\tif (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\treturn TX_DROP;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t/* internal error, why isn't DONTFRAG set? */\n\tif (WARN_ON(skb->len + FCS_LEN <= frag_threshold))\n\t\treturn TX_DROP;\n\n\t/*\n\t * Now fragment the frame. This will allocate all the fragments and\n\t * chain them (using skb as the first fragment) to skb->next.\n\t * During transmission, we will remove the successfully transmitted\n\t * fragments from this list. When the low-level driver rejects one\n\t * of the fragments then we will simply pretend to accept the skb\n\t * but store it away as pending.\n\t */\n\tif (ieee80211_fragment(tx, skb, hdrlen, frag_threshold))\n\t\treturn TX_DROP;\n\n\t/* update duration/seq/flags of fragments */\n\tfragnum = 0;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tconst __le16 morefrags = cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\n\n\t\thdr = (void *)skb->data;\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\thdr->frame_control |= morefrags;\n\t\t\t/*\n\t\t\t * No multi-rate retries for fragmented frames, that\n\t\t\t * would completely throw off the NAV at other STAs.\n\t\t\t */\n\t\t\tinfo->control.rates[1].idx = -1;\n\t\t\tinfo->control.rates[2].idx = -1;\n\t\t\tinfo->control.rates[3].idx = -1;\n\t\t\tBUILD_BUG_ON(IEEE80211_TX_MAX_RATES != 4);\n\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_RATE_CTRL_PROBE;\n\t\t} else {\n\t\t\thdr->frame_control &= ~morefrags;\n\t\t}\n\t\thdr->seq_ctrl |= cpu_to_le16(fragnum & IEEE80211_SCTL_FRAG);\n\t\tfragnum++;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_stats(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tint ac = -1;\n\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tac = skb_get_queue_mapping(skb);\n\t\ttx->sta->tx_fragments++;\n\t\ttx->sta->tx_bytes[ac] += skb->len;\n\t}\n\tif (ac >= 0)\n\t\ttx->sta->tx_packets[ac]++;\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_encrypt(struct ieee80211_tx_data *tx)\n{\n\tif (!tx->key)\n\t\treturn TX_CONTINUE;\n\n\tswitch (tx->key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn ieee80211_crypto_wep_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn ieee80211_crypto_tkip_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn ieee80211_crypto_ccmp_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\treturn ieee80211_crypto_aes_cmac_encrypt(tx);\n\tdefault:\n\t\treturn ieee80211_crypto_hw_encrypt(tx);\n\t}\n\n\treturn TX_DROP;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_calculate_duration(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tint next_len;\n\tbool group_addr;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\thdr = (void *) skb->data;\n\t\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control)))\n\t\t\tbreak; /* must not overwrite AID */\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(&tx->skbs, skb);\n\t\t\tnext_len = next->len;\n\t\t} else\n\t\t\tnext_len = 0;\n\t\tgroup_addr = is_multicast_ether_addr(hdr->addr1);\n\n\t\thdr->duration_id =\n\t\t\tieee80211_duration(tx, skb, group_addr, next_len);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* actual transmit path */\n\nstatic bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  struct tid_ampdu_tx *tid_tx,\n\t\t\t\t  int tid)\n{\n\tbool queued = false;\n\tbool reset_agg_timer = false;\n\tstruct sk_buff *purge_skb = NULL;\n\n\tif (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treset_agg_timer = true;\n\t} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t\t/*\n\t\t * nothing -- this aggregation session is being started\n\t\t * but that might still fail with the driver\n\t\t */\n\t} else {\n\t\tspin_lock(&tx->sta->lock);\n\t\t/*\n\t\t * Need to re-check now, because we may get here\n\t\t *\n\t\t *  1) in the window during which the setup is actually\n\t\t *     already done, but not marked yet because not all\n\t\t *     packets are spliced over to the driver pending\n\t\t *     queue yet -- if this happened we acquire the lock\n\t\t *     either before or after the splice happens, but\n\t\t *     need to recheck which of these cases happened.\n\t\t *\n\t\t *  2) during session teardown, if the OPERATIONAL bit\n\t\t *     was cleared due to the teardown but the pointer\n\t\t *     hasn't been assigned NULL yet (or we loaded it\n\t\t *     before it was assigned) -- in this case it may\n\t\t *     now be NULL which means we should just let the\n\t\t *     packet pass through because splicing the frames\n\t\t *     back is already done.\n\t\t */\n\t\ttid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);\n\n\t\tif (!tid_tx) {\n\t\t\t/* do nothing, let packet pass through */\n\t\t} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\t\treset_agg_timer = true;\n\t\t} else {\n\t\t\tqueued = true;\n\t\t\tinfo->control.vif = &tx->sdata->vif;\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\t\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\t\t__skb_queue_tail(&tid_tx->pending, skb);\n\t\t\tif (skb_queue_len(&tid_tx->pending) > STA_MAX_TX_BUFFER)\n\t\t\t\tpurge_skb = __skb_dequeue(&tid_tx->pending);\n\t\t}\n\t\tspin_unlock(&tx->sta->lock);\n\n\t\tif (purge_skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, purge_skb);\n\t}\n\n\t/* reset session timer */\n\tif (reset_agg_timer && tid_tx->timeout)\n\t\ttid_tx->last_tx = jiffies;\n\n\treturn queued;\n}\n\n/*\n * initialises @tx\n */\nstatic ieee80211_tx_result\nieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_tx_data *tx,\n\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tid;\n\tu8 *qc;\n\n\tmemset(tx, 0, sizeof(*tx));\n\ttx->skb = skb;\n\ttx->local = local;\n\ttx->sdata = sdata;\n\t__skb_queue_head_init(&tx->skbs);\n\n\t/*\n\t * If this flag is set to true anywhere, and we get here,\n\t * we are doing the needed processing, so remove the flag\n\t * now.\n\t */\n\tinfo->flags &= ~IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\ttx->sta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (!tx->sta && sdata->dev->ieee80211_ptr->use_4addr)\n\t\t\treturn TX_DROP;\n\t} else if (info->flags & (IEEE80211_TX_CTL_INJECTED |\n\t\t\t\t  IEEE80211_TX_INTFL_NL80211_FRAME_TX) ||\n\t\t   tx->sdata->control_port_protocol == tx->skb->protocol) {\n\t\ttx->sta = sta_info_get_bss(sdata, hdr->addr1);\n\t}\n\tif (!tx->sta)\n\t\ttx->sta = sta_info_get(sdata, hdr->addr1);\n\n\tif (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&\n\t    (local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) &&\n\t    !(local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW)) {\n\t\tstruct tid_ampdu_tx *tid_tx;\n\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tbool queued;\n\n\t\t\tqueued = ieee80211_tx_prep_agg(tx, skb, info,\n\t\t\t\t\t\t       tid_tx, tid);\n\n\t\t\tif (unlikely(queued))\n\t\t\t\treturn TX_QUEUED;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\ttx->flags &= ~IEEE80211_TX_UNICAST;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t} else\n\t\ttx->flags |= IEEE80211_TX_UNICAST;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {\n\t\tif (!(tx->flags & IEEE80211_TX_UNICAST) ||\n\t\t    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_DONTFRAG;\n\t}\n\n\tif (!tx->sta)\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\telse if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT))\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\n\tinfo->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;\n\n\treturn TX_CONTINUE;\n}\n\nstatic bool ieee80211_tx_frags(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct sk_buff_head *skbs,\n\t\t\t       bool txpending)\n{\n\tstruct ieee80211_tx_control control;\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\n\tskb_queue_walk_safe(skbs, skb, tmp) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tint q = info->hw_queue;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tif (WARN_ON_ONCE(q >= local->hw.queues)) {\n\t\t\t__skb_unlink(skb, skbs);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\tif (local->queue_stop_reasons[q] ||\n\t\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\t\tif (unlikely(info->flags &\n\t\t\t\t     IEEE80211_TX_INTFL_OFFCHAN_TX_OK)) {\n\t\t\t\tif (local->queue_stop_reasons[q] &\n\t\t\t\t    ~BIT(IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Drop off-channel frames if queues\n\t\t\t\t\t * are stopped for any reason other\n\t\t\t\t\t * than off-channel operation. Never\n\t\t\t\t\t * queue them.\n\t\t\t\t\t */\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tieee80211_purge_tx_queue(&local->hw,\n\t\t\t\t\t\t\t\t skbs);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * Since queue is stopped, queue up frames for\n\t\t\t\t * later transmission from the tx-pending\n\t\t\t\t * tasklet when the queue is woken again.\n\t\t\t\t */\n\t\t\t\tif (txpending)\n\t\t\t\t\tskb_queue_splice_init(skbs,\n\t\t\t\t\t\t\t      &local->pending[q]);\n\t\t\t\telse\n\t\t\t\t\tskb_queue_splice_tail_init(skbs,\n\t\t\t\t\t\t\t\t   &local->pending[q]);\n\n\t\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\tinfo->control.vif = vif;\n\t\tcontrol.sta = sta;\n\n\t\t__skb_unlink(skb, skbs);\n\t\tdrv_tx(local, &control, skb);\n\t}\n\n\treturn true;\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool __ieee80211_tx(struct ieee80211_local *local,\n\t\t\t   struct sk_buff_head *skbs, int led_len,\n\t\t\t   struct sta_info *sta, bool txpending)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *pubsta;\n\tstruct sk_buff *skb;\n\tbool result = true;\n\t__le16 fc;\n\n\tif (WARN_ON(skb_queue_empty(skbs)))\n\t\treturn true;\n\n\tskb = skb_peek(skbs);\n\tfc = ((struct ieee80211_hdr *)skb->data)->frame_control;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tsdata = vif_to_sdata(info->control.vif);\n\tif (sta && !sta->uploaded)\n\t\tsta = NULL;\n\n\tif (sta)\n\t\tpubsta = &sta->sta;\n\telse\n\t\tpubsta = NULL;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr_flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\tsdata = rcu_dereference(local->monitor_sdata);\n\t\tif (sdata) {\n\t\t\tvif = &sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (local->hw.flags & IEEE80211_HW_QUEUE_CONTROL) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t} else\n\t\t\tvif = NULL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\t\t/* fall through */\n\tdefault:\n\t\tvif = &sdata->vif;\n\t\tbreak;\n\t}\n\n\tresult = ieee80211_tx_frags(local, vif, pubsta, skbs,\n\t\t\t\t    txpending);\n\n\tieee80211_tpt_led_trig_tx(local, fc, led_len);\n\n\tWARN_ON_ONCE(!skb_queue_empty(skbs));\n\n\treturn result;\n}\n\n/*\n * Invoke TX handlers, return 0 on success and non-zero if the\n * frame was dropped or queued.\n */\nstatic int invoke_tx_handlers(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tieee80211_tx_result res = TX_DROP;\n\n#define CALL_TXH(txh) \\\n\tdo {\t\t\t\t\\\n\t\tres = txh(tx);\t\t\\\n\t\tif (res != TX_CONTINUE)\t\\\n\t\t\tgoto txh_done;\t\\\n\t} while (0)\n\n\tCALL_TXH(ieee80211_tx_h_dynamic_ps);\n\tCALL_TXH(ieee80211_tx_h_check_assoc);\n\tCALL_TXH(ieee80211_tx_h_ps_buf);\n\tCALL_TXH(ieee80211_tx_h_check_control_port_protocol);\n\tCALL_TXH(ieee80211_tx_h_select_key);\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_rate_ctrl);\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION)) {\n\t\t__skb_queue_tail(&tx->skbs, tx->skb);\n\t\ttx->skb = NULL;\n\t\tgoto txh_done;\n\t}\n\n\tCALL_TXH(ieee80211_tx_h_michael_mic_add);\n\tCALL_TXH(ieee80211_tx_h_sequence);\n\tCALL_TXH(ieee80211_tx_h_fragment);\n\t/* handlers after fragment must be aware of tx info fragmentation! */\n\tCALL_TXH(ieee80211_tx_h_stats);\n\tCALL_TXH(ieee80211_tx_h_encrypt);\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_calculate_duration);\n#undef CALL_TXH\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_data tx;\n\n\tif (ieee80211_tx_prepare(sdata, &tx, skb) == TX_DROP)\n\t\treturn false;\n\n\tinfo->band = band;\n\tinfo->control.vif = vif;\n\tinfo->hw_queue = vif->hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers(&tx))\n\t\treturn false;\n\n\tif (sta) {\n\t\tif (tx.sta)\n\t\t\t*sta = &tx.sta->sta;\n\t\telse\n\t\t\t*sta = NULL;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_tx_prepare_skb);\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb, bool txpending,\n\t\t\t enum ieee80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result res_prepare;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool result = true;\n\tint led_len;\n\n\tif (unlikely(skb->len < 10)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn true;\n\t}\n\n\t/* initialises tx */\n\tled_len = skb->len;\n\tres_prepare = ieee80211_tx_prepare(sdata, &tx, skb);\n\n\tif (unlikely(res_prepare == TX_DROP)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn true;\n\t} else if (unlikely(res_prepare == TX_QUEUED)) {\n\t\treturn true;\n\t}\n\n\tinfo->band = band;\n\n\t/* set up hw_queue value early */\n\tif (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||\n\t    !(local->hw.flags & IEEE80211_HW_QUEUE_CONTROL))\n\t\tinfo->hw_queue =\n\t\t\tsdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (!invoke_tx_handlers(&tx))\n\t\tresult = __ieee80211_tx(local, &tx.skbs, led_len,\n\t\t\t\t\ttx.sta, txpending);\n\n\treturn result;\n}\n\n/* device xmit handlers */\n\nstatic int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tint head_need, bool may_encrypt)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint tail_need = 0;\n\n\tif (may_encrypt && sdata->crypto_tx_tailroom_needed_cnt) {\n\t\ttail_need = IEEE80211_ENCRYPT_TAILROOM;\n\t\ttail_need -= skb_tailroom(skb);\n\t\ttail_need = max_t(int, tail_need, 0);\n\t}\n\n\tif (skb_cloned(skb))\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head_cloned);\n\telse if (head_need || tail_need)\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\telse\n\t\treturn 0;\n\n\tif (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {\n\t\twiphy_debug(local->hw.wiphy,\n\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_xmit(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb,\n\t\t    enum ieee80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tint headroom;\n\tbool may_encrypt;\n\n\tmay_encrypt = !(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT);\n\n\theadroom = local->tx_headroom;\n\tif (may_encrypt)\n\t\theadroom += sdata->encrypt_headroom;\n\theadroom -= skb_headroom(skb);\n\theadroom = max_t(int, 0, headroom);\n\n\tif (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    is_unicast_ether_addr(hdr->addr1)) {\n\t\t\tif (mesh_nexthop_resolve(sdata, skb))\n\t\t\t\treturn; /* skb queued: don't free */\n\t\t} else {\n\t\t\tieee80211_mps_set_frame_flags(sdata, NULL, hdr);\n\t\t}\n\t}\n\n\tieee80211_set_qos_hdr(sdata, skb);\n\tieee80211_tx(sdata, skb, false, band);\n}\n\nstatic bool ieee80211_parse_tx_radiotap(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.txt\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\t/*\n\t * remove the radiotap header\n\t * iterator->_max_length was sanity-checked against\n\t * skb->len by iterator init\n\t */\n\tskb_pull(skb, iterator._max_length);\n\n\treturn true;\n}\n\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *chan;\n\tstruct ieee80211_radiotap_header *prthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\t/* check for not even having the fixed radiotap header part */\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\tgoto fail; /* too short to be possibly valid */\n\n\t/* is it a header version we can trust to find length from? */\n\tif (unlikely(prthdr->it_version))\n\t\tgoto fail; /* only version 0 is supported */\n\n\t/* then there must be a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/* does the skb contain enough to deliver on the alleged length? */\n\tif (unlikely(skb->len < len_rthdr))\n\t\tgoto fail; /* skb too short for claimed rt header extent */\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* process and remove the injection radiotap header */\n\tif (!ieee80211_parse_tx_radiotap(skb))\n\t\tgoto fail;\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN/WDS support we will need a different mechanism (which\n\t * likely isn't going to be monitor interfaces).\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchan = chanctx_conf->def.chan;\n\telse if (!local->use_chanctx)\n\t\tchan = local->_oper_chandef.chan;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif ((chan->flags & (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR)))\n\t\tgoto fail_rcu;\n\n\tieee80211_xmit(sdata, skb, chan->band);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}\n\n/*\n * Measure Tx frame arrival time for Tx latency statistics calculation\n * A single Tx frame latency should be measured from when it is entering the\n * Kernel until we receive Tx complete confirmation indication and the skb is\n * freed.\n */\nstatic void ieee80211_tx_latency_start_msrmnt(struct ieee80211_local *local,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct timespec skb_arv;\n\tstruct ieee80211_tx_latency_bin_ranges *tx_latency;\n\n\ttx_latency = rcu_dereference(local->tx_latency);\n\tif (!tx_latency)\n\t\treturn;\n\n\tktime_get_ts(&skb_arv);\n\tskb->tstamp = ktime_set(skb_arv.tv_sec, skb_arv.tv_nsec);\n}\n\n/**\n * ieee80211_subif_start_xmit - netif start_xmit function for Ethernet-type\n * subinterfaces (wlan#, WDS, and VLAN interfaces)\n * @skb: packet to be sent\n * @dev: incoming interface\n *\n * Returns: 0 on success (and frees skb in this case) or 1 on failure (skb will\n * not be freed, and caller is responsible for either retrying later or freeing\n * skb).\n *\n * This function takes in an Ethernet header and encapsulates it with suitable\n * IEEE 802.11 header based on which interface the packet is coming in. The\n * encapsulated packet will then be passed to master interface, wlan#.11, for\n * transmission (through low-level driver).\n */\nnetdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info;\n\tint head_need;\n\tu16 ethertype, hdrlen,  meshhdrlen = 0;\n\t__le16 fc;\n\tstruct ieee80211_hdr hdr;\n\tstruct ieee80211s_hdr mesh_hdr __maybe_unused;\n\tstruct mesh_path __maybe_unused *mppath = NULL, *mpath = NULL;\n\tconst u8 *encaps_data;\n\tint encaps_len, skip_header_bytes;\n\tint nh_pos, h_pos;\n\tstruct sta_info *sta = NULL;\n\tbool wme_sta = false, authorized = false, tdls_auth = false;\n\tbool tdls_direct = false;\n\tbool multicast;\n\tu32 info_flags = 0;\n\tu16 info_id = 0;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_sub_if_data *ap_sdata;\n\tenum ieee80211_band band;\n\n\tif (unlikely(skb->len < ETH_HLEN))\n\t\tgoto fail;\n\n\t/* convert Ethernet header to proper 802.11 header (based on\n\t * operation mode) */\n\tethertype = (skb->data[12] << 8) | skb->data[13];\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\trcu_read_lock();\n\n\t/* Measure frame arrival for Tx latency statistics calculation */\n\tieee80211_tx_latency_start_msrmnt(local, skb);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (sta) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\t\twme_sta = test_sta_flag(sta, WLAN_STA_WME);\n\t\t}\n\t\tap_sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t\tu.ap);\n\t\tchanctx_conf = rcu_dereference(ap_sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tif (sta)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase NL80211_IFTYPE_AP:\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t/* DA BSSID SA */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, skb->data + ETH_ALEN, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t/* RA TA DA SA */\n\t\tmemcpy(hdr.addr1, sdata->u.wds.remote_addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\thdrlen = 30;\n\t\t/*\n\t\t * This is the exception! WDS style interfaces are prohibited\n\t\t * when channel contexts are in used so this must be valid\n\t\t */\n\t\tband = local->hw.conf.chandef.chan->band;\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!is_multicast_ether_addr(skb->data)) {\n\t\t\tstruct sta_info *next_hop;\n\t\t\tbool mpp_lookup = true;\n\n\t\t\tmpath = mesh_path_lookup(sdata, skb->data);\n\t\t\tif (mpath) {\n\t\t\t\tmpp_lookup = false;\n\t\t\t\tnext_hop = rcu_dereference(mpath->next_hop);\n\t\t\t\tif (!next_hop ||\n\t\t\t\t    !(mpath->flags & (MESH_PATH_ACTIVE |\n\t\t\t\t\t\t      MESH_PATH_RESOLVING)))\n\t\t\t\t\tmpp_lookup = true;\n\t\t\t}\n\n\t\t\tif (mpp_lookup)\n\t\t\t\tmppath = mpp_path_lookup(sdata, skb->data);\n\n\t\t\tif (mppath && mpath)\n\t\t\t\tmesh_path_del(mpath->sdata, mpath->dst);\n\t\t}\n\n\t\t/*\n\t\t * Use address extension if it is a packet from\n\t\t * another interface or if we know the destination\n\t\t * is being proxied by a portal (i.e. portal address\n\t\t * differs from proxied address)\n\t\t */\n\t\tif (ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN) &&\n\t\t    !(mppath && !ether_addr_equal(mppath->mpp, skb->data))) {\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tskb->data, skb->data + ETH_ALEN);\n\t\t\tmeshhdrlen = ieee80211_new_mesh_header(sdata, &mesh_hdr,\n\t\t\t\t\t\t\t       NULL, NULL);\n\t\t} else {\n\t\t\t/* DS -> MBSS (802.11-2012 13.11.3.3).\n\t\t\t * For unicast with unknown forwarding information,\n\t\t\t * destination might be in the MBSS or if that fails\n\t\t\t * forwarded to another mesh gate. In either case\n\t\t\t * resolution will be handled in ieee80211_xmit(), so\n\t\t\t * leave the original DA. This also works for mcast */\n\t\t\tconst u8 *mesh_da = skb->data;\n\n\t\t\tif (mppath)\n\t\t\t\tmesh_da = mppath->mpp;\n\t\t\telse if (mpath)\n\t\t\t\tmesh_da = mpath->dst;\n\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tmesh_da, sdata->vif.addr);\n\t\t\tif (is_multicast_ether_addr(mesh_da))\n\t\t\t\t/* DA TA mSA AE:SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr,\n\t\t\t\t\t\tskb->data + ETH_ALEN, NULL);\n\t\t\telse\n\t\t\t\t/* RA TA mDA mSA AE:DA SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr, skb->data,\n\t\t\t\t\t\tskb->data + ETH_ALEN);\n\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\t\tbool tdls_peer = false;\n\n\t\t\tsta = sta_info_get(sdata, skb->data);\n\t\t\tif (sta) {\n\t\t\t\tauthorized = test_sta_flag(sta,\n\t\t\t\t\t\t\tWLAN_STA_AUTHORIZED);\n\t\t\t\twme_sta = test_sta_flag(sta, WLAN_STA_WME);\n\t\t\t\ttdls_peer = test_sta_flag(sta,\n\t\t\t\t\t\t\t WLAN_STA_TDLS_PEER);\n\t\t\t\ttdls_auth = test_sta_flag(sta,\n\t\t\t\t\t\tWLAN_STA_TDLS_PEER_AUTH);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the TDLS link is enabled, send everything\n\t\t\t * directly. Otherwise, allow TDLS setup frames\n\t\t\t * to be transmitted indirectly.\n\t\t\t */\n\t\t\ttdls_direct = tdls_peer && (tdls_auth ||\n\t\t\t\t !(ethertype == ETH_P_TDLS && skb->len > 14 &&\n\t\t\t\t   skb->data[14] == WLAN_TDLS_SNAP_RFTYPE));\n\t\t}\n\n\t\tif (tdls_direct) {\n\t\t\t/* link during setup - throw out frames to peer */\n\t\t\tif (!tdls_auth)\n\t\t\t\tgoto fail_rcu;\n\n\t\t\t/* DA SA BSSID */\n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}  else if (sdata->u.mgd.use_4addr &&\n\t\t\t    cpu_to_be16(ethertype) != sdata->control_port_protocol) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t} else {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t\t/* BSSID SA DA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* DA SA BSSID */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail_rcu;\n\t}\n\n\t/*\n\t * There's no need to try to look up the destination\n\t * if it is a multicast address (which can only happen\n\t * in AP mode)\n\t */\n\tmulticast = is_multicast_ether_addr(hdr.addr1);\n\tif (!multicast) {\n\t\tsta = sta_info_get(sdata, hdr.addr1);\n\t\tif (sta) {\n\t\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\t\twme_sta = test_sta_flag(sta, WLAN_STA_WME);\n\t\t}\n\t}\n\n\t/* For mesh, the use of the QoS header is mandatory */\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\twme_sta = true;\n\n\t/* receiver and we are QoS enabled, use a QoS type frame */\n\tif (wme_sta && local->hw.queues >= IEEE80211_NUM_ACS) {\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t\thdrlen += 2;\n\t}\n\n\t/*\n\t * Drop unicast frames to unauthorised stations unless they are\n\t * EAPOL frames from the local station.\n\t */\n\tif (unlikely(!ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t     !multicast && !authorized &&\n\t\t     (cpu_to_be16(ethertype) != sdata->control_port_protocol ||\n\t\t      !ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN)))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tnet_info_ratelimited(\"%s: dropped frame to %pM (unauthorized port)\\n\",\n\t\t\t\t    dev->name, hdr.addr1);\n#endif\n\n\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\n\t\tgoto fail_rcu;\n\t}\n\n\tif (unlikely(!multicast && skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)) {\n\t\tstruct sk_buff *orig_skb = skb;\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (skb) {\n\t\t\tunsigned long flags;\n\t\t\tint id;\n\n\t\t\tspin_lock_irqsave(&local->ack_status_lock, flags);\n\t\t\tid = idr_alloc(&local->ack_status_frames, orig_skb,\n\t\t\t\t       1, 0x10000, GFP_ATOMIC);\n\t\t\tspin_unlock_irqrestore(&local->ack_status_lock, flags);\n\n\t\t\tif (id >= 0) {\n\t\t\t\tinfo_id = id;\n\t\t\t\tinfo_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t} else if (skb_shared(skb)) {\n\t\t\t\tkfree_skb(orig_skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = orig_skb;\n\t\t\t}\n\t\t} else {\n\t\t\t/* couldn't clone -- lose tx status ... */\n\t\t\tskb = orig_skb;\n\t\t}\n\t}\n\n\t/*\n\t * If the skb is shared we need to obtain our own copy.\n\t */\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *tmp_skb = skb;\n\n\t\t/* can't happen -- skb is a clone if info_id != 0 */\n\t\tWARN_ON(info_id);\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tkfree_skb(tmp_skb);\n\n\t\tif (!skb)\n\t\t\tgoto fail_rcu;\n\t}\n\n\thdr.frame_control = fc;\n\thdr.duration_id = 0;\n\thdr.seq_ctrl = 0;\n\n\tskip_header_bytes = ETH_HLEN;\n\tif (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {\n\t\tencaps_data = bridge_tunnel_header;\n\t\tencaps_len = sizeof(bridge_tunnel_header);\n\t\tskip_header_bytes -= 2;\n\t} else if (ethertype >= ETH_P_802_3_MIN) {\n\t\tencaps_data = rfc1042_header;\n\t\tencaps_len = sizeof(rfc1042_header);\n\t\tskip_header_bytes -= 2;\n\t} else {\n\t\tencaps_data = NULL;\n\t\tencaps_len = 0;\n\t}\n\n\tnh_pos = skb_network_header(skb) - skb->data;\n\th_pos = skb_transport_header(skb) - skb->data;\n\n\tskb_pull(skb, skip_header_bytes);\n\tnh_pos -= skip_header_bytes;\n\th_pos -= skip_header_bytes;\n\n\thead_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);\n\n\t/*\n\t * So we need to modify the skb header and hence need a copy of\n\t * that. The head_need variable above doesn't, so far, include\n\t * the needed header space that we don't need right away. If we\n\t * can, then we don't reallocate right now but only after the\n\t * frame arrives at the master device (if it does...)\n\t *\n\t * If we cannot, however, then we will reallocate to include all\n\t * the ever needed space. Also, if we need to reallocate it anyway,\n\t * make it big enough for everything we may ever need.\n\t */\n\n\tif (head_need > 0 || skb_cloned(skb)) {\n\t\thead_need += sdata->encrypt_headroom;\n\t\thead_need += local->tx_headroom;\n\t\thead_need = max_t(int, 0, head_need);\n\t\tif (ieee80211_skb_resize(sdata, skb, head_need, true)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tskb = NULL;\n\t\t\tgoto fail_rcu;\n\t\t}\n\t}\n\n\tif (encaps_data) {\n\t\tmemcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);\n\t\tnh_pos += encaps_len;\n\t\th_pos += encaps_len;\n\t}\n\n#ifdef CONFIG_MAC80211_MESH\n\tif (meshhdrlen > 0) {\n\t\tmemcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);\n\t\tnh_pos += meshhdrlen;\n\t\th_pos += meshhdrlen;\n\t}\n#endif\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\t__le16 *qos_control;\n\n\t\tqos_control = (__le16 *) skb_push(skb, 2);\n\t\tmemcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);\n\t\t/*\n\t\t * Maybe we could actually set some fields here, for now just\n\t\t * initialise to zero to indicate no special operation.\n\t\t */\n\t\t*qos_control = 0;\n\t} else\n\t\tmemcpy(skb_push(skb, hdrlen), &hdr, hdrlen);\n\n\tnh_pos += hdrlen;\n\th_pos += hdrlen;\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\t/* Update skb pointers to various headers since this modified frame\n\t * is going to go through Linux networking code that may potentially\n\t * need things like pointer to IP header. */\n\tskb_set_mac_header(skb, 0);\n\tskb_set_network_header(skb, nh_pos);\n\tskb_set_transport_header(skb, h_pos);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\n\tdev->trans_start = jiffies;\n\n\tinfo->flags = info_flags;\n\tinfo->ack_frame_id = info_id;\n\n\tieee80211_xmit(sdata, skb, band);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\n fail_rcu:\n\trcu_read_unlock();\n fail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n/*\n * ieee80211_clear_tx_pending may not be called in a context where\n * it is possible that it packets could come in again.\n */\nvoid ieee80211_clear_tx_pending(struct ieee80211_local *local)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\twhile ((skb = skb_dequeue(&local->pending[i])) != NULL)\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead,\n * which in this case means re-queued -- take as an indication to stop sending\n * more pending frames.\n */\nstatic bool ieee80211_tx_pending_skb(struct ieee80211_local *local,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_hdr *hdr;\n\tbool result;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(info->control.vif);\n\n\tif (info->flags & IEEE80211_TX_INTFL_NEED_TXPROCESSING) {\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (unlikely(!chanctx_conf)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\t\tresult = ieee80211_tx(sdata, skb, true,\n\t\t\t\t      chanctx_conf->def.chan->band);\n\t} else {\n\t\tstruct sk_buff_head skbs;\n\n\t\t__skb_queue_head_init(&skbs);\n\t\t__skb_queue_tail(&skbs, skb);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tsta = sta_info_get(sdata, hdr->addr1);\n\n\t\tresult = __ieee80211_tx(local, &skbs, skb->len, sta, true);\n\t}\n\n\treturn result;\n}\n\n/*\n * Transmit all pending packets. Called from tasklet.\n */\nvoid ieee80211_tx_pending(unsigned long data)\n{\n\tstruct ieee80211_local *local = (struct ieee80211_local *)data;\n\tunsigned long flags;\n\tint i;\n\tbool txok;\n\n\trcu_read_lock();\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\t/*\n\t\t * If queue is stopped by something other than due to pending\n\t\t * frames, or we have no pending frames, proceed to next queue.\n\t\t */\n\t\tif (local->queue_stop_reasons[i] ||\n\t\t    skb_queue_empty(&local->pending[i]))\n\t\t\tcontinue;\n\n\t\twhile (!skb_queue_empty(&local->pending[i])) {\n\t\t\tstruct sk_buff *skb = __skb_dequeue(&local->pending[i]);\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\t\tif (WARN_ON(!info->control.vif)) {\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\n\t\t\ttxok = ieee80211_tx_pending_skb(local, skb);\n\t\t\tspin_lock_irqsave(&local->queue_stop_reason_lock,\n\t\t\t\t\t  flags);\n\t\t\tif (!txok)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb_queue_empty(&local->pending[i]))\n\t\t\tieee80211_propagate_queue_wake(local, i);\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\trcu_read_unlock();\n}\n\n/* functions for drivers to get certain frames */\n\nstatic void __ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ps_data *ps, struct sk_buff *skb)\n{\n\tu8 *pos, *tim;\n\tint aid0 = 0;\n\tint i, have_bits = 0, n1, n2;\n\n\t/* Generate bitmap for TIM only if there are any STAs in power save\n\t * mode. */\n\tif (atomic_read(&ps->num_sta_ps) > 0)\n\t\t/* in the hope that this is faster than\n\t\t * checking byte-for-byte */\n\t\thave_bits = !bitmap_empty((unsigned long *)ps->tim,\n\t\t\t\t\t  IEEE80211_MAX_AID+1);\n\n\tif (ps->dtim_count == 0)\n\t\tps->dtim_count = sdata->vif.bss_conf.dtim_period - 1;\n\telse\n\t\tps->dtim_count--;\n\n\ttim = pos = (u8 *) skb_put(skb, 6);\n\t*pos++ = WLAN_EID_TIM;\n\t*pos++ = 4;\n\t*pos++ = ps->dtim_count;\n\t*pos++ = sdata->vif.bss_conf.dtim_period;\n\n\tif (ps->dtim_count == 0 && !skb_queue_empty(&ps->bc_buf))\n\t\taid0 = 1;\n\n\tps->dtim_bc_mc = aid0 == 1;\n\n\tif (have_bits) {\n\t\t/* Find largest even number N1 so that bits numbered 1 through\n\t\t * (N1 x 8) - 1 in the bitmap are 0 and number N2 so that bits\n\t\t * (N2 + 1) x 8 through 2007 are 0. */\n\t\tn1 = 0;\n\t\tfor (i = 0; i < IEEE80211_MAX_TIM_LEN; i++) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn1 = i & 0xfe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn2 = n1;\n\t\tfor (i = IEEE80211_MAX_TIM_LEN - 1; i >= n1; i--) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Bitmap control */\n\t\t*pos++ = n1 | aid0;\n\t\t/* Part Virt Bitmap */\n\t\tskb_put(skb, n2 - n1);\n\t\tmemcpy(pos, ps->tim + n1, n2 - n1 + 1);\n\n\t\ttim[1] = n2 - n1 + 4;\n\t} else {\n\t\t*pos++ = aid0; /* Bitmap control */\n\t\t*pos++ = 0; /* Part Virt Bitmap */\n\t}\n}\n\nstatic int ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ps_data *ps, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\t/*\n\t * Not very nice, but we want to allow the driver to call\n\t * ieee80211_beacon_get() as a response to the set_tim()\n\t * callback. That, however, is already invoked under the\n\t * sta_lock to guarantee consistent and race-free update\n\t * of the tim bitmap in mac80211 and the driver.\n\t */\n\tif (local->tim_in_locked_section) {\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb);\n\t} else {\n\t\tspin_lock_bh(&local->tim_lock);\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb);\n\t\tspin_unlock_bh(&local->tim_lock);\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_csa_finish(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tieee80211_queue_work(&sdata->local->hw,\n\t\t\t     &sdata->csa_finalize_work);\n}\nEXPORT_SYMBOL(ieee80211_csa_finish);\n\nstatic void ieee80211_update_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct beacon_data *beacon)\n{\n\tstruct probe_resp *resp;\n\tint counter_offset_beacon = sdata->csa_counter_offset_beacon;\n\tint counter_offset_presp = sdata->csa_counter_offset_presp;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (WARN_ON(counter_offset_beacon >= beacon_data_len))\n\t\treturn;\n\n\t/* warn if the driver did not check for/react to csa completeness */\n\tif (WARN_ON(beacon_data[counter_offset_beacon] == 0))\n\t\treturn;\n\n\tbeacon_data[counter_offset_beacon]--;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP && counter_offset_presp) {\n\t\trcu_read_lock();\n\t\tresp = rcu_dereference(sdata->u.ap.probe_resp);\n\n\t\t/* if nl80211 accepted the offset, this should not happen. */\n\t\tif (WARN_ON(!resp)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tresp->data[counter_offset_presp]--;\n\t\trcu_read_unlock();\n\t}\n}\n\nbool ieee80211_csa_is_complete(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tint counter_beacon = sdata->csa_counter_offset_beacon;\n\tint ret = false;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\n\t\tbeacon = rcu_dereference(ap->beacon);\n\t\tif (WARN_ON(!beacon || !beacon->tail))\n\t\t\tgoto out;\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t} else if (vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else if (vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(counter_beacon > beacon_data_len))\n\t\tgoto out;\n\n\tif (beacon_data[counter_beacon] == 0)\n\t\tret = true;\n out:\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_csa_is_complete);\n\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tenum ieee80211_band band;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\trcu_read_lock();\n\n\tsdata = vif_to_sdata(vif);\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!ieee80211_sdata_running(sdata) || !chanctx_conf)\n\t\tgoto out;\n\n\tif (tim_offset)\n\t\t*tim_offset = 0;\n\tif (tim_length)\n\t\t*tim_length = 0;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\t\tstruct beacon_data *beacon = rcu_dereference(ap->beacon);\n\n\t\tif (beacon) {\n\t\t\tif (sdata->vif.csa_active)\n\t\t\t\tieee80211_update_csa(sdata, beacon);\n\n\t\t\t/*\n\t\t\t * headroom, head length,\n\t\t\t * tail length and maximum TIM length\n\t\t\t */\n\t\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t\t    beacon->head_len +\n\t\t\t\t\t    beacon->tail_len + 256 +\n\t\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\t\tif (!skb)\n\t\t\t\tgoto out;\n\n\t\t\tskb_reserve(skb, local->tx_headroom);\n\t\t\tmemcpy(skb_put(skb, beacon->head_len), beacon->head,\n\t\t\t       beacon->head_len);\n\n\t\t\tieee80211_beacon_add_tim(sdata, &ap->ps, skb);\n\n\t\t\tif (tim_offset)\n\t\t\t\t*tim_offset = beacon->head_len;\n\t\t\tif (tim_length)\n\t\t\t\t*tim_length = skb->len - beacon->head_len;\n\n\t\t\tif (beacon->tail)\n\t\t\t\tmemcpy(skb_put(skb, beacon->tail_len),\n\t\t\t\t       beacon->tail, beacon->tail_len);\n\t\t} else\n\t\t\tgoto out;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\t\tstruct ieee80211_hdr *hdr;\n\t\tstruct beacon_data *presp = rcu_dereference(ifibss->presp);\n\n\t\tif (!presp)\n\t\t\tgoto out;\n\n\t\tif (sdata->vif.csa_active)\n\t\t\tieee80211_update_csa(sdata, presp);\n\n\n\t\tskb = dev_alloc_skb(local->tx_headroom + presp->head_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tmemcpy(skb_put(skb, presp->head_len), presp->head,\n\t\t       presp->head_len);\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t IEEE80211_STYPE_BEACON);\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\t\tstruct beacon_data *bcn = rcu_dereference(ifmsh->beacon);\n\n\t\tif (!bcn)\n\t\t\tgoto out;\n\n\t\tif (sdata->vif.csa_active)\n\t\t\tieee80211_update_csa(sdata, bcn);\n\n\t\tif (ifmsh->sync_ops)\n\t\t\tifmsh->sync_ops->adjust_tbtt(sdata, bcn);\n\n\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    bcn->head_len +\n\t\t\t\t    256 + /* TIM IE */\n\t\t\t\t    bcn->tail_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tmemcpy(skb_put(skb, bcn->head_len), bcn->head, bcn->head_len);\n\t\tieee80211_beacon_add_tim(sdata, &ifmsh->ps, skb);\n\t\tmemcpy(skb_put(skb, bcn->tail_len), bcn->tail, bcn->tail_len);\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\tinfo->band = band;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\ttxrc.hw = hw;\n\ttxrc.sband = local->hw.wiphy->bands[band];\n\ttxrc.bss_conf = &sdata->vif.bss_conf;\n\ttxrc.skb = skb;\n\ttxrc.reported_rate.idx = -1;\n\ttxrc.rate_idx_mask = sdata->rc_rateidx_mask[band];\n\tif (txrc.rate_idx_mask == (1 << txrc.sband->n_bitrates) - 1)\n\t\ttxrc.max_rate_idx = -1;\n\telse\n\t\ttxrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;\n\ttxrc.bss = true;\n\trate_control_get_rate(sdata, NULL, &txrc);\n\n\tinfo->control.vif = vif;\n\n\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\tIEEE80211_TX_CTL_ASSIGN_SEQ |\n\t\t\tIEEE80211_TX_CTL_FIRST_FRAGMENT;\n out:\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_tim);\n\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ieee80211_if_ap *ap = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct probe_resp *presp = NULL;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tap = &sdata->u.ap;\n\tpresp = rcu_dereference(ap->probe_resp);\n\tif (!presp)\n\t\tgoto out;\n\n\tskb = dev_alloc_skb(presp->len);\n\tif (!skb)\n\t\tgoto out;\n\n\tmemcpy(skb_put(skb, presp->len), presp->data, presp->len);\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tmemset(hdr->addr1, 0, sizeof(hdr->addr1));\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_proberesp_get);\n\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_pspoll *pspoll;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*pspoll));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tpspoll = (struct ieee80211_pspoll *) skb_put(skb, sizeof(*pspoll));\n\tmemset(pspoll, 0, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL);\n\tpspoll->aid = cpu_to_le16(ifmgd->aid);\n\n\t/* aid in PS-Poll has its two MSBs each set to 1 */\n\tpspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);\n\n\tmemcpy(pspoll->bssid, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, vif->addr, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_pspoll_get);\n\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*nullfunc));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = (struct ieee80211_hdr_3addr *) skb_put(skb,\n\t\t\t\t\t\t\t  sizeof(*nullfunc));\n\tmemset(nullfunc, 0, sizeof(*nullfunc));\n\tnullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t      IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t      IEEE80211_FCTL_TODS);\n\tmemcpy(nullfunc->addr1, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, vif->addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, ifmgd->bssid, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_nullfunc_get);\n\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_hdr_3addr *hdr;\n\tstruct sk_buff *skb;\n\tsize_t ie_ssid_len;\n\tu8 *pos;\n\n\tsdata = vif_to_sdata(vif);\n\tlocal = sdata->local;\n\tie_ssid_len = 2 + ssid_len;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*hdr) +\n\t\t\t    ie_ssid_len + tailroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\thdr = (struct ieee80211_hdr_3addr *) skb_put(skb, sizeof(*hdr));\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(hdr->addr1);\n\tmemcpy(hdr->addr2, vif->addr, ETH_ALEN);\n\teth_broadcast_addr(hdr->addr3);\n\n\tpos = skb_put(skb, ie_ssid_len);\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = ssid_len;\n\tif (ssid_len)\n\t\tmemcpy(pos, ssid, ssid_len);\n\tpos += ssid_len;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_probereq_get);\n\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\trts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);\n\trts->duration = ieee80211_rts_duration(hw, vif, frame_len,\n\t\t\t\t\t       frame_txctl);\n\tmemcpy(rts->ra, hdr->addr1, sizeof(rts->ra));\n\tmemcpy(rts->ta, hdr->addr2, sizeof(rts->ta));\n}\nEXPORT_SYMBOL(ieee80211_rts_get);\n\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\tcts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);\n\tcts->duration = ieee80211_ctstoself_duration(hw, vif,\n\t\t\t\t\t\t     frame_len, frame_txctl);\n\tmemcpy(cts->ra, hdr->addr1, sizeof(cts->ra));\n}\nEXPORT_SYMBOL(ieee80211_ctstoself_get);\n\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_data tx;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ps_data *ps;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(vif);\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!chanctx_conf)\n\t\tgoto out;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct beacon_data *beacon =\n\t\t\t\trcu_dereference(sdata->u.ap.beacon);\n\n\t\tif (!beacon || !beacon->head)\n\t\t\tgoto out;\n\n\t\tps = &sdata->u.ap.ps;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tps = &sdata->u.mesh.ps;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (ps->dtim_count != 0 || !ps->dtim_bc_mc)\n\t\tgoto out; /* send buffered bc/mc only after DTIM beacon */\n\n\twhile (1) {\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tlocal->total_ps_buffered--;\n\n\t\tif (!skb_queue_empty(&ps->bc_buf) && skb->len >= 2) {\n\t\t\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *) skb->data;\n\t\t\t/* more buffered multicast/broadcast frames ==> set\n\t\t\t * MoreData flag in IEEE 802.11 header to inform PS\n\t\t\t * STAs */\n\t\t\thdr->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tsdata = IEEE80211_DEV_TO_SUB_IF(skb->dev);\n\t\tif (!ieee80211_tx_prepare(sdata, &tx, skb))\n\t\t\tbreak;\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\ttx.flags |= IEEE80211_TX_PS_BUFFERED;\n\tinfo->band = chanctx_conf->def.chan->band;\n\n\tif (invoke_tx_handlers(&tx))\n\t\tskb = NULL;\n out:\n\trcu_read_unlock();\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_buffered_bc);\n\nvoid __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb, int tid,\n\t\t\t\t enum ieee80211_band band)\n{\n\tint ac = ieee802_1d_to_ac[tid & 7];\n\n\tskb_set_mac_header(skb, 0);\n\tskb_set_network_header(skb, 0);\n\tskb_set_transport_header(skb, 0);\n\n\tskb_set_queue_mapping(skb, ac);\n\tskb->priority = tid;\n\n\tskb->dev = sdata->dev;\n\n\t/*\n\t * The other path calling ieee80211_xmit is from the tasklet,\n\t * and while we can handle concurrent transmissions locking\n\t * requirements are that we do not come into tx with bhs on.\n\t */\n\tlocal_bh_disable();\n\tieee80211_xmit(sdata, skb, band);\n\tlocal_bh_enable();\n}\n"], "fixing_code": ["/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/timer.h>\n#include <linux/rtnetlink.h>\n\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"sta_info.h\"\n#include \"debugfs_sta.h\"\n#include \"mesh.h\"\n#include \"wme.h\"\n\n/**\n * DOC: STA information lifetime rules\n *\n * STA info structures (&struct sta_info) are managed in a hash table\n * for faster lookup and a list for iteration. They are managed using\n * RCU, i.e. access to the list and hash table is protected by RCU.\n *\n * Upon allocating a STA info structure with sta_info_alloc(), the caller\n * owns that structure. It must then insert it into the hash table using\n * either sta_info_insert() or sta_info_insert_rcu(); only in the latter\n * case (which acquires an rcu read section but must not be called from\n * within one) will the pointer still be valid after the call. Note that\n * the caller may not do much with the STA info before inserting it, in\n * particular, it may not start any mesh peer link management or add\n * encryption keys.\n *\n * When the insertion fails (sta_info_insert()) returns non-zero), the\n * structure will have been freed by sta_info_insert()!\n *\n * Station entries are added by mac80211 when you establish a link with a\n * peer. This means different things for the different type of interfaces\n * we support. For a regular station this mean we add the AP sta when we\n * receive an association response from the AP. For IBSS this occurs when\n * get to know about a peer on the same IBSS. For WDS we add the sta for\n * the peer immediately upon device open. When using AP mode we add stations\n * for each respective station upon request from userspace through nl80211.\n *\n * In order to remove a STA info structure, various sta_info_destroy_*()\n * calls are available.\n *\n * There is no concept of ownership on a STA entry, each structure is\n * owned by the global hash table/list until it is removed. All users of\n * the structure need to be RCU protected so that the structure won't be\n * freed before they are done using it.\n */\n\n/* Caller must hold local->sta_mtx */\nstatic int sta_info_hash_del(struct ieee80211_local *local,\n\t\t\t     struct sta_info *sta)\n{\n\tstruct sta_info *s;\n\n\ts = rcu_dereference_protected(local->sta_hash[STA_HASH(sta->sta.addr)],\n\t\t\t\t      lockdep_is_held(&local->sta_mtx));\n\tif (!s)\n\t\treturn -ENOENT;\n\tif (s == sta) {\n\t\trcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)],\n\t\t\t\t   s->hnext);\n\t\treturn 0;\n\t}\n\n\twhile (rcu_access_pointer(s->hnext) &&\n\t       rcu_access_pointer(s->hnext) != sta)\n\t\ts = rcu_dereference_protected(s->hnext,\n\t\t\t\t\tlockdep_is_held(&local->sta_mtx));\n\tif (rcu_access_pointer(s->hnext)) {\n\t\trcu_assign_pointer(s->hnext, sta->hnext);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic void cleanup_single_sta(struct sta_info *sta)\n{\n\tint ac, i;\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ps_data *ps;\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tps = &sdata->bss->ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\treturn;\n\n\t\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\n\t\tatomic_dec(&ps->num_sta_ps);\n\t\tsta_info_recalc_tim(sta);\n\t}\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tlocal->total_ps_buffered -= skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\tieee80211_purge_tx_queue(&local->hw, &sta->ps_tx_buf[ac]);\n\t\tieee80211_purge_tx_queue(&local->hw, &sta->tx_filtered[ac]);\n\t}\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_sta_cleanup(sta);\n\n\tcancel_work_sync(&sta->drv_unblock_wk);\n\n\t/*\n\t * Destroy aggregation state here. It would be nice to wait for the\n\t * driver to finish aggregation stop and then clean up, but for now\n\t * drivers have to handle aggregation stop being requested, followed\n\t * directly by station destruction.\n\t */\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\tkfree(sta->ampdu_mlme.tid_start_tx[i]);\n\t\ttid_tx = rcu_dereference_raw(sta->ampdu_mlme.tid_tx[i]);\n\t\tif (!tid_tx)\n\t\t\tcontinue;\n\t\tieee80211_purge_tx_queue(&local->hw, &tid_tx->pending);\n\t\tkfree(tid_tx);\n\t}\n\n\tsta_info_free(local, sta);\n}\n\n/* protected by RCU */\nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tsta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],\n\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\twhile (sta) {\n\t\tif (sta->sdata == sdata &&\n\t\t    ether_addr_equal(sta->sta.addr, addr))\n\t\t\tbreak;\n\t\tsta = rcu_dereference_check(sta->hnext,\n\t\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\t}\n\treturn sta;\n}\n\n/*\n * Get sta info either from the specified interface\n * or from one of its vlans\n */\nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  const u8 *addr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tsta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],\n\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\twhile (sta) {\n\t\tif ((sta->sdata == sdata ||\n\t\t     (sta->sdata->bss && sta->sdata->bss == sdata->bss)) &&\n\t\t    ether_addr_equal(sta->sta.addr, addr))\n\t\t\tbreak;\n\t\tsta = rcu_dereference_check(sta->hnext,\n\t\t\t\t\t    lockdep_is_held(&local->sta_mtx));\n\t}\n\treturn sta;\n}\n\nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     int idx)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tint i = 0;\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\t\tif (i < idx) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\treturn sta;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * sta_info_free - free STA\n *\n * @local: pointer to the global information\n * @sta: STA info to free\n *\n * This function must undo everything done by sta_info_alloc()\n * that may happen before sta_info_insert(). It may only be\n * called when sta_info_insert() has not been attempted (and\n * if that fails, the station is freed anyway.)\n */\nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta)\n{\n\tint i;\n\n\tif (sta->rate_ctrl)\n\t\trate_control_free_sta(sta);\n\n\tif (sta->tx_lat) {\n\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\t\tkfree(sta->tx_lat[i].bins);\n\t\tkfree(sta->tx_lat);\n\t}\n\n\tsta_dbg(sta->sdata, \"Destroyed STA %pM\\n\", sta->sta.addr);\n\n\tkfree(sta);\n}\n\n/* Caller must hold local->sta_mtx */\nstatic void sta_info_hash_add(struct ieee80211_local *local,\n\t\t\t      struct sta_info *sta)\n{\n\tlockdep_assert_held(&local->sta_mtx);\n\tsta->hnext = local->sta_hash[STA_HASH(sta->sta.addr)];\n\trcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)], sta);\n}\n\nstatic void sta_unblock(struct work_struct *wk)\n{\n\tstruct sta_info *sta;\n\n\tsta = container_of(wk, struct sta_info, drv_unblock_wk);\n\n\tif (sta->dead)\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\tlocal_bh_disable();\n\t\tieee80211_sta_ps_deliver_wakeup(sta);\n\t\tlocal_bh_enable();\n\t} else if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL)) {\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\n\t\tlocal_bh_disable();\n\t\tieee80211_sta_ps_deliver_poll_response(sta);\n\t\tlocal_bh_enable();\n\t} else if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD)) {\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\n\t\tlocal_bh_disable();\n\t\tieee80211_sta_ps_deliver_uapsd(sta);\n\t\tlocal_bh_enable();\n\t} else\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n}\n\nstatic int sta_prepare_rate_control(struct ieee80211_local *local,\n\t\t\t\t    struct sta_info *sta, gfp_t gfp)\n{\n\tif (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL)\n\t\treturn 0;\n\n\tsta->rate_ctrl = local->rate_ctrl;\n\tsta->rate_ctrl_priv = rate_control_alloc_sta(sta->rate_ctrl,\n\t\t\t\t\t\t     &sta->sta, gfp);\n\tif (!sta->rate_ctrl_priv)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct timespec uptime;\n\tstruct ieee80211_tx_latency_bin_ranges *tx_latency;\n\tint i;\n\n\tsta = kzalloc(sizeof(*sta) + local->hw.sta_data_size, gfp);\n\tif (!sta)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttx_latency = rcu_dereference(local->tx_latency);\n\t/* init stations Tx latency statistics && TID bins */\n\tif (tx_latency) {\n\t\tsta->tx_lat = kzalloc(IEEE80211_NUM_TIDS *\n\t\t\t\t      sizeof(struct ieee80211_tx_latency_stat),\n\t\t\t\t      GFP_ATOMIC);\n\t\tif (!sta->tx_lat) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (tx_latency->n_ranges) {\n\t\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\t\t\t/* size of bins is size of the ranges +1 */\n\t\t\t\tsta->tx_lat[i].bin_count =\n\t\t\t\t\ttx_latency->n_ranges + 1;\n\t\t\t\tsta->tx_lat[i].bins =\n\t\t\t\t\tkcalloc(sta->tx_lat[i].bin_count,\n\t\t\t\t\t\tsizeof(u32), GFP_ATOMIC);\n\t\t\t\tif (!sta->tx_lat[i].bins) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tspin_lock_init(&sta->lock);\n\tspin_lock_init(&sta->ps_lock);\n\tINIT_WORK(&sta->drv_unblock_wk, sta_unblock);\n\tINIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);\n\tmutex_init(&sta->ampdu_mlme.mtx);\n#ifdef CONFIG_MAC80211_MESH\n\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t    !sdata->u.mesh.user_mpm)\n\t\tinit_timer(&sta->plink_timer);\n\tsta->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\n#endif\n\n\tmemcpy(sta->sta.addr, addr, ETH_ALEN);\n\tsta->local = local;\n\tsta->sdata = sdata;\n\tsta->last_rx = jiffies;\n\n\tsta->sta_state = IEEE80211_STA_NONE;\n\n\tdo_posix_clock_monotonic_gettime(&uptime);\n\tsta->last_connected = uptime.tv_sec;\n\tewma_init(&sta->avg_signal, 1024, 8);\n\tfor (i = 0; i < ARRAY_SIZE(sta->chain_signal_avg); i++)\n\t\tewma_init(&sta->chain_signal_avg[i], 1024, 8);\n\n\tif (sta_prepare_rate_control(local, sta, gfp))\n\t\tgoto free;\n\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\t/*\n\t\t * timer_to_tid must be initialized with identity mapping\n\t\t * to enable session_timer's data differentiation. See\n\t\t * sta_rx_agg_session_timer_expired for usage.\n\t\t */\n\t\tsta->timer_to_tid[i] = i;\n\t}\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tskb_queue_head_init(&sta->ps_tx_buf[i]);\n\t\tskb_queue_head_init(&sta->tx_filtered[i]);\n\t}\n\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\tsta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\n\n\tsta->sta.smps_mode = IEEE80211_SMPS_OFF;\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal->hw.wiphy->bands[ieee80211_get_sdata_band(sdata)];\n\t\tu8 smps = (sband->ht_cap.cap & IEEE80211_HT_CAP_SM_PS) >>\n\t\t\t\tIEEE80211_HT_CAP_SM_PS_SHIFT;\n\t\t/*\n\t\t * Assume that hostapd advertises our caps in the beacon and\n\t\t * this is the known_smps_mode for a station that just assciated\n\t\t */\n\t\tswitch (smps) {\n\t\tcase WLAN_HT_SMPS_CONTROL_DISABLED:\n\t\t\tsta->known_smps_mode = IEEE80211_SMPS_OFF;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_STATIC:\n\t\t\tsta->known_smps_mode = IEEE80211_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_DYNAMIC:\n\t\t\tsta->known_smps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\n\tsta_dbg(sdata, \"Allocated STA %pM\\n\", sta->sta.addr);\n\treturn sta;\n\nfree:\n\tif (sta->tx_lat) {\n\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\t\tkfree(sta->tx_lat[i].bins);\n\t\tkfree(sta->tx_lat);\n\t}\n\tkfree(sta);\n\treturn NULL;\n}\n\nstatic int sta_info_insert_check(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\t/*\n\t * Can't be a WARN_ON because it can be triggered through a race:\n\t * something inserts a STA (on one CPU) without holding the RTNL\n\t * and another CPU turns off the net device.\n\t */\n\tif (unlikely(!ieee80211_sdata_running(sdata)))\n\t\treturn -ENETDOWN;\n\n\tif (WARN_ON(ether_addr_equal(sta->sta.addr, sdata->vif.addr) ||\n\t\t    is_multicast_ether_addr(sta->sta.addr)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sta_info_insert_drv_state(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct sta_info *sta)\n{\n\tenum ieee80211_sta_state state;\n\tint err = 0;\n\n\tfor (state = IEEE80211_STA_NOTEXIST; state < sta->sta_state; state++) {\n\t\terr = drv_sta_state(local, sdata, sta, state, state + 1);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err) {\n\t\t/*\n\t\t * Drivers using legacy sta_add/sta_remove callbacks only\n\t\t * get uploaded set to true after sta_add is called.\n\t\t */\n\t\tif (!local->ops->sta_add)\n\t\t\tsta->uploaded = true;\n\t\treturn 0;\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to move IBSS STA %pM to state %d (%d) - keeping it anyway\\n\",\n\t\t\t   sta->sta.addr, state + 1, err);\n\t\terr = 0;\n\t}\n\n\t/* unwind on error */\n\tfor (; state > IEEE80211_STA_NOTEXIST; state--)\n\t\tWARN_ON(drv_sta_state(local, sdata, sta, state, state - 1));\n\n\treturn err;\n}\n\n/*\n * should be called with sta_mtx locked\n * this function replaces the mutex lock\n * with a RCU lock\n */\nstatic int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct station_info sinfo;\n\tint err = 0;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/* check if STA exists already */\n\tif (sta_info_get_bss(sdata, sta->sta.addr)) {\n\t\terr = -EEXIST;\n\t\tgoto out_err;\n\t}\n\n\t/* notify driver */\n\terr = sta_info_insert_drv_state(local, sdata, sta);\n\tif (err)\n\t\tgoto out_err;\n\n\tlocal->num_sta++;\n\tlocal->sta_generation++;\n\tsmp_mb();\n\n\t/* make the station visible */\n\tsta_info_hash_add(local, sta);\n\n\tlist_add_rcu(&sta->list, &local->sta_list);\n\n\tset_sta_flag(sta, WLAN_STA_INSERTED);\n\n\tieee80211_recalc_min_chandef(sdata);\n\tieee80211_sta_debugfs_add(sta);\n\trate_control_add_sta_debugfs(sta);\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tsinfo.filled = 0;\n\tsinfo.generation = local->sta_generation;\n\tcfg80211_new_sta(sdata->dev, sta->sta.addr, &sinfo, GFP_KERNEL);\n\n\tsta_dbg(sdata, \"Inserted STA %pM\\n\", sta->sta.addr);\n\n\t/* move reference to rcu-protected */\n\trcu_read_lock();\n\tmutex_unlock(&local->sta_mtx);\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_accept_plinks_update(sdata);\n\n\treturn 0;\n out_err:\n\tmutex_unlock(&local->sta_mtx);\n\trcu_read_lock();\n\treturn err;\n}\n\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tint err = 0;\n\n\tmight_sleep();\n\n\terr = sta_info_insert_check(sta);\n\tif (err) {\n\t\trcu_read_lock();\n\t\tgoto out_free;\n\t}\n\n\tmutex_lock(&local->sta_mtx);\n\n\terr = sta_info_insert_finish(sta);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n out_free:\n\tBUG_ON(!err);\n\tsta_info_free(local, sta);\n\treturn err;\n}\n\nint sta_info_insert(struct sta_info *sta)\n{\n\tint err = sta_info_insert_rcu(sta);\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic inline void __bss_tim_set(u8 *tim, u16 id)\n{\n\t/*\n\t * This format has been mandated by the IEEE specifications,\n\t * so this line may not be changed to use the __set_bit() format.\n\t */\n\ttim[id / 8] |= (1 << (id % 8));\n}\n\nstatic inline void __bss_tim_clear(u8 *tim, u16 id)\n{\n\t/*\n\t * This format has been mandated by the IEEE specifications,\n\t * so this line may not be changed to use the __clear_bit() format.\n\t */\n\ttim[id / 8] &= ~(1 << (id % 8));\n}\n\nstatic inline bool __bss_tim_get(u8 *tim, u16 id)\n{\n\t/*\n\t * This format has been mandated by the IEEE specifications,\n\t * so this line may not be changed to use the test_bit() format.\n\t */\n\treturn tim[id / 8] & (1 << (id % 8));\n}\n\nstatic unsigned long ieee80211_tids_for_ac(int ac)\n{\n\t/* If we ever support TIDs > 7, this obviously needs to be adjusted */\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\treturn BIT(6) | BIT(7);\n\tcase IEEE80211_AC_VI:\n\t\treturn BIT(4) | BIT(5);\n\tcase IEEE80211_AC_BE:\n\t\treturn BIT(0) | BIT(3);\n\tcase IEEE80211_AC_BK:\n\t\treturn BIT(1) | BIT(2);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nvoid sta_info_recalc_tim(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ps_data *ps;\n\tbool indicate_tim = false;\n\tu8 ignore_for_tim = sta->sta.uapsd_queues;\n\tint ac;\n\tu16 id;\n\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (WARN_ON_ONCE(!sta->sdata->bss))\n\t\t\treturn;\n\n\t\tps = &sta->sdata->bss->ps;\n\t\tid = sta->sta.aid;\n#ifdef CONFIG_MAC80211_MESH\n\t} else if (ieee80211_vif_is_mesh(&sta->sdata->vif)) {\n\t\tps = &sta->sdata->u.mesh.ps;\n\t\t/* TIM map only for 1 <= PLID <= IEEE80211_MAX_AID */\n\t\tid = sta->plid % (IEEE80211_MAX_AID + 1);\n#endif\n\t} else {\n\t\treturn;\n\t}\n\n\t/* No need to do anything if the driver does all */\n\tif (local->hw.flags & IEEE80211_HW_AP_LINK_PS)\n\t\treturn;\n\n\tif (sta->dead)\n\t\tgoto done;\n\n\t/*\n\t * If all ACs are delivery-enabled then we should build\n\t * the TIM bit for all ACs anyway; if only some are then\n\t * we ignore those and build the TIM bit using only the\n\t * non-enabled ones.\n\t */\n\tif (ignore_for_tim == BIT(IEEE80211_NUM_ACS) - 1)\n\t\tignore_for_tim = 0;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tunsigned long tids;\n\n\t\tif (ignore_for_tim & BIT(ac))\n\t\t\tcontinue;\n\n\t\tindicate_tim |= !skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t\t\t!skb_queue_empty(&sta->ps_tx_buf[ac]);\n\t\tif (indicate_tim)\n\t\t\tbreak;\n\n\t\ttids = ieee80211_tids_for_ac(ac);\n\n\t\tindicate_tim |=\n\t\t\tsta->driver_buffered_tids & tids;\n\t}\n\n done:\n\tspin_lock_bh(&local->tim_lock);\n\n\tif (indicate_tim == __bss_tim_get(ps->tim, id))\n\t\tgoto out_unlock;\n\n\tif (indicate_tim)\n\t\t__bss_tim_set(ps->tim, id);\n\telse\n\t\t__bss_tim_clear(ps->tim, id);\n\n\tif (local->ops->set_tim) {\n\t\tlocal->tim_in_locked_section = true;\n\t\tdrv_set_tim(local, &sta->sta, indicate_tim);\n\t\tlocal->tim_in_locked_section = false;\n\t}\n\nout_unlock:\n\tspin_unlock_bh(&local->tim_lock);\n}\n\nstatic bool sta_info_buffer_expired(struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info;\n\tint timeout;\n\n\tif (!skb)\n\t\treturn false;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\t/* Timeout: (2 * listen_interval * beacon_int * 1024 / 1000000) sec */\n\ttimeout = (sta->listen_interval *\n\t\t   sta->sdata->vif.bss_conf.beacon_int *\n\t\t   32 / 15625) * HZ;\n\tif (timeout < STA_TX_BUFFER_EXPIRE)\n\t\ttimeout = STA_TX_BUFFER_EXPIRE;\n\treturn time_after(jiffies, info->control.jiffies + timeout);\n}\n\n\nstatic bool sta_info_cleanup_expire_buffered_ac(struct ieee80211_local *local,\n\t\t\t\t\t\tstruct sta_info *sta, int ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\t/*\n\t * First check for frames that should expire on the filtered\n\t * queue. Frames here were rejected by the driver and are on\n\t * a separate queue to avoid reordering with normal PS-buffered\n\t * frames. They also aren't accounted for right now in the\n\t * total_ps_buffered counter.\n\t */\n\tfor (;;) {\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb = skb_peek(&sta->tx_filtered[ac]);\n\t\tif (sta_info_buffer_expired(sta, skb))\n\t\t\tskb = __skb_dequeue(&sta->tx_filtered[ac]);\n\t\telse\n\t\t\tskb = NULL;\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\n\t\t/*\n\t\t * Frames are queued in order, so if this one\n\t\t * hasn't expired yet we can stop testing. If\n\t\t * we actually reached the end of the queue we\n\t\t * also need to stop, of course.\n\t\t */\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n\n\t/*\n\t * Now also check the normal PS-buffered queue, this will\n\t * only find something if the filtered queue was emptied\n\t * since the filtered frames are all before the normal PS\n\t * buffered frames.\n\t */\n\tfor (;;) {\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb = skb_peek(&sta->ps_tx_buf[ac]);\n\t\tif (sta_info_buffer_expired(sta, skb))\n\t\t\tskb = __skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\telse\n\t\t\tskb = NULL;\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\n\t\t/*\n\t\t * frames are queued in order, so if this one\n\t\t * hasn't expired yet (or we reached the end of\n\t\t * the queue) we can stop testing\n\t\t */\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tlocal->total_ps_buffered--;\n\t\tps_dbg(sta->sdata, \"Buffered frame expired (STA %pM)\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n\n\t/*\n\t * Finally, recalculate the TIM bit for this station -- it might\n\t * now be clear because the station was too slow to retrieve its\n\t * frames.\n\t */\n\tsta_info_recalc_tim(sta);\n\n\t/*\n\t * Return whether there are any frames still buffered, this is\n\t * used to check whether the cleanup timer still needs to run,\n\t * if there are no frames we don't need to rearm the timer.\n\t */\n\treturn !(skb_queue_empty(&sta->ps_tx_buf[ac]) &&\n\t\t skb_queue_empty(&sta->tx_filtered[ac]));\n}\n\nstatic bool sta_info_cleanup_expire_buffered(struct ieee80211_local *local,\n\t\t\t\t\t     struct sta_info *sta)\n{\n\tbool have_buffered = false;\n\tint ac;\n\n\t/* This is only necessary for stations on BSS/MBSS interfaces */\n\tif (!sta->sdata->bss &&\n\t    !ieee80211_vif_is_mesh(&sta->sdata->vif))\n\t\treturn false;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\thave_buffered |=\n\t\t\tsta_info_cleanup_expire_buffered_ac(local, sta, ac);\n\n\treturn have_buffered;\n}\n\nstatic int __must_check __sta_info_destroy_part1(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tlocal = sta->local;\n\tsdata = sta->sdata;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/*\n\t * Before removing the station from the driver and\n\t * rate control, it might still start new aggregation\n\t * sessions -- block that to make sure the tear-down\n\t * will be sufficient.\n\t */\n\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\tieee80211_sta_tear_down_BA_sessions(sta, AGG_STOP_DESTROY_STA);\n\n\tret = sta_info_hash_del(local, sta);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\tlist_del_rcu(&sta->list);\n\n\tdrv_sta_pre_rcu_remove(local, sta->sdata, sta);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    rcu_access_pointer(sdata->u.vlan.sta) == sta)\n\t\tRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\n\n\treturn 0;\n}\n\nstatic void __sta_info_destroy_part2(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tint ret;\n\n\t/*\n\t * NOTE: This assumes at least synchronize_net() was done\n\t *\t after _part1 and before _part2!\n\t */\n\n\tmight_sleep();\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/* now keys can no longer be reached */\n\tieee80211_free_sta_keys(local, sta);\n\n\tsta->dead = true;\n\n\tlocal->num_sta--;\n\tlocal->sta_generation++;\n\n\twhile (sta->sta_state > IEEE80211_STA_NONE) {\n\t\tret = sta_info_move_state(sta, sta->sta_state - 1);\n\t\tif (ret) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sta->uploaded) {\n\t\tret = drv_sta_state(local, sdata, sta, IEEE80211_STA_NONE,\n\t\t\t\t    IEEE80211_STA_NOTEXIST);\n\t\tWARN_ON_ONCE(ret != 0);\n\t}\n\n\tsta_dbg(sdata, \"Removed STA %pM\\n\", sta->sta.addr);\n\n\tcfg80211_del_sta(sdata->dev, sta->sta.addr, GFP_KERNEL);\n\n\trate_control_remove_sta_debugfs(sta);\n\tieee80211_sta_debugfs_remove(sta);\n\tieee80211_recalc_min_chandef(sdata);\n\n\tcleanup_single_sta(sta);\n}\n\nint __must_check __sta_info_destroy(struct sta_info *sta)\n{\n\tint err = __sta_info_destroy_part1(sta);\n\n\tif (err)\n\t\treturn err;\n\n\tsynchronize_net();\n\n\t__sta_info_destroy_part2(sta);\n\n\treturn 0;\n}\n\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata, const u8 *addr)\n{\n\tstruct sta_info *sta;\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get(sdata, addr);\n\tret = __sta_info_destroy(sta);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr)\n{\n\tstruct sta_info *sta;\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get_bss(sdata, addr);\n\tret = __sta_info_destroy(sta);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic void sta_info_cleanup(unsigned long data)\n{\n\tstruct ieee80211_local *local = (struct ieee80211_local *) data;\n\tstruct sta_info *sta;\n\tbool timer_needed = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list)\n\t\tif (sta_info_cleanup_expire_buffered(local, sta))\n\t\t\ttimer_needed = true;\n\trcu_read_unlock();\n\n\tif (local->quiescing)\n\t\treturn;\n\n\tif (!timer_needed)\n\t\treturn;\n\n\tmod_timer(&local->sta_cleanup,\n\t\t  round_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL));\n}\n\nvoid sta_info_init(struct ieee80211_local *local)\n{\n\tspin_lock_init(&local->tim_lock);\n\tmutex_init(&local->sta_mtx);\n\tINIT_LIST_HEAD(&local->sta_list);\n\n\tsetup_timer(&local->sta_cleanup, sta_info_cleanup,\n\t\t    (unsigned long)local);\n}\n\nvoid sta_info_stop(struct ieee80211_local *local)\n{\n\tdel_timer_sync(&local->sta_cleanup);\n}\n\n\nint __sta_info_flush(struct ieee80211_sub_if_data *sdata, bool vlans)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\tLIST_HEAD(free_list);\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tWARN_ON(vlans && sdata->vif.type != NL80211_IFTYPE_AP);\n\tWARN_ON(vlans && !sdata->bss);\n\n\tmutex_lock(&local->sta_mtx);\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tif (sdata == sta->sdata ||\n\t\t    (vlans && sdata->bss == sta->sdata->bss)) {\n\t\t\tif (!WARN_ON(__sta_info_destroy_part1(sta)))\n\t\t\t\tlist_add(&sta->free_list, &free_list);\n\t\t\tret++;\n\t\t}\n\t}\n\n\tif (!list_empty(&free_list)) {\n\t\tsynchronize_net();\n\t\tlist_for_each_entry_safe(sta, tmp, &free_list, free_list)\n\t\t\t__sta_info_destroy_part2(sta);\n\t}\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn ret;\n}\n\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tif (time_after(jiffies, sta->last_rx + exp_time)) {\n\t\t\tsta_dbg(sta->sdata, \"expiring inactive STA %pM\\n\",\n\t\t\t\tsta->sta.addr);\n\n\t\t\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t\t    test_sta_flag(sta, WLAN_STA_PS_STA))\n\t\t\t\tatomic_dec(&sdata->u.mesh.ps.num_sta_ps);\n\n\t\t\tWARN_ON(__sta_info_destroy(sta));\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n}\n\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\n\t\t\t\t\t       const u8 *addr,\n\t\t\t\t\t       const u8 *localaddr)\n{\n\tstruct sta_info *sta, *nxt;\n\n\t/*\n\t * Just return a random station if localaddr is NULL\n\t * ... first in list.\n\t */\n\tfor_each_sta_info(hw_to_local(hw), addr, sta, nxt) {\n\t\tif (localaddr &&\n\t\t    !ether_addr_equal(sta->sdata->vif.addr, localaddr))\n\t\t\tcontinue;\n\t\tif (!sta->uploaded)\n\t\t\treturn NULL;\n\t\treturn &sta->sta;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ieee80211_find_sta_by_ifaddr);\n\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\n\t\t\t\t\t const u8 *addr)\n{\n\tstruct sta_info *sta;\n\n\tif (!vif)\n\t\treturn NULL;\n\n\tsta = sta_info_get_bss(vif_to_sdata(vif), addr);\n\tif (!sta)\n\t\treturn NULL;\n\n\tif (!sta->uploaded)\n\t\treturn NULL;\n\n\treturn &sta->sta;\n}\nEXPORT_SYMBOL(ieee80211_find_sta);\n\nstatic void clear_sta_ps_flags(void *_sta)\n{\n\tstruct sta_info *sta = _sta;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ps_data *ps;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tps = &sdata->bss->ps;\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tps = &sdata->u.mesh.ps;\n\telse\n\t\treturn;\n\n\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\tif (test_and_clear_sta_flag(sta, WLAN_STA_PS_STA))\n\t\tatomic_dec(&ps->num_sta_ps);\n}\n\n/* powersave support code */\nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff_head pending;\n\tint filtered = 0, buffered = 0, ac;\n\tunsigned long flags;\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\tBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\n\tsta->driver_buffered_tids = 0;\n\n\tif (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\n\n\tskb_queue_head_init(&pending);\n\n\t/* sync with ieee80211_tx_h_unicast_ps_buf */\n\tspin_lock(&sta->ps_lock);\n\t/* Send all buffered frames to the station */\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tint count = skb_queue_len(&pending), tmp;\n\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tfiltered += tmp - count;\n\t\tcount = tmp;\n\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tbuffered += tmp - count;\n\t}\n\n\tieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\n\tspin_unlock(&sta->ps_lock);\n\n\t/* This station just woke up and isn't aware of our SMPS state */\n\tif (!ieee80211_smps_is_restrictive(sta->known_smps_mode,\n\t\t\t\t\t   sdata->smps_mode) &&\n\t    sta->known_smps_mode != sdata->bss->req_smps &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sdata,\n\t\t       \"%pM just woke up and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sdata, sdata->bss->req_smps,\n\t\t\t\t\t   sta->sta.addr,\n\t\t\t\t\t   sdata->vif.bss_conf.bssid);\n\t}\n\n\tlocal->total_ps_buffered -= buffered;\n\n\tsta_info_recalc_tim(sta);\n\n\tps_dbg(sdata,\n\t       \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\",\n\t       sta->sta.addr, sta->sta.aid, filtered, buffered);\n}\n\nstatic void ieee80211_send_null_response(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct sta_info *sta, int tid,\n\t\t\t\t\t enum ieee80211_frame_release_type reason,\n\t\t\t\t\t bool call_driver)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_qos_hdr *nullfunc;\n\tstruct sk_buff *skb;\n\tint size = sizeof(*nullfunc);\n\t__le16 fc;\n\tbool qos = test_sta_flag(sta, WLAN_STA_WME);\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tif (qos) {\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t} else {\n\t\tsize -= 2;\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t}\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + size);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = (void *) skb_put(skb, size);\n\tnullfunc->frame_control = fc;\n\tnullfunc->duration_id = 0;\n\tmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);\n\n\tskb->priority = tid;\n\tskb_set_queue_mapping(skb, ieee802_1d_to_ac[tid]);\n\tif (qos) {\n\t\tnullfunc->qos_ctrl = cpu_to_le16(tid);\n\n\t\tif (reason == IEEE80211_FRAME_RELEASE_UAPSD)\n\t\t\tnullfunc->qos_ctrl |=\n\t\t\t\tcpu_to_le16(IEEE80211_QOS_CTL_EOSP);\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\t/*\n\t * Tell TX path to send this frame even though the\n\t * STA may still remain is PS mode after this frame\n\t * exchange. Also set EOSP to indicate this packet\n\t * ends the poll/service period.\n\t */\n\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t       IEEE80211_TX_CTL_PS_RESPONSE |\n\t\t       IEEE80211_TX_STATUS_EOSP |\n\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tif (call_driver)\n\t\tdrv_allow_buffered_frames(local, sta, BIT(tid), 1,\n\t\t\t\t\t  reason, false);\n\n\tskb->dev = sdata->dev;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tieee80211_xmit(sdata, skb, chanctx_conf->def.chan->band);\n\trcu_read_unlock();\n}\n\nstatic int find_highest_prio_tid(unsigned long tids)\n{\n\t/* lower 3 TIDs aren't ordered perfectly */\n\tif (tids & 0xF8)\n\t\treturn fls(tids) - 1;\n\t/* TID 0 is BE just like TID 3 */\n\tif (tids & BIT(0))\n\t\treturn 0;\n\treturn fls(tids) - 1;\n}\n\nstatic void\nieee80211_sta_ps_deliver_response(struct sta_info *sta,\n\t\t\t\t  int n_frames, u8 ignored_acs,\n\t\t\t\t  enum ieee80211_frame_release_type reason)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tbool more_data = false;\n\tint ac;\n\tunsigned long driver_release_tids = 0;\n\tstruct sk_buff_head frames;\n\n\t/* Service or PS-Poll period starts */\n\tset_sta_flag(sta, WLAN_STA_SP);\n\n\t__skb_queue_head_init(&frames);\n\n\t/* Get response frame(s) and more data bit for the last one. */\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tunsigned long tids;\n\n\t\tif (ignored_acs & BIT(ac))\n\t\t\tcontinue;\n\n\t\ttids = ieee80211_tids_for_ac(ac);\n\n\t\t/* if we already have frames from software, then we can't also\n\t\t * release from hardware queues\n\t\t */\n\t\tif (skb_queue_empty(&frames))\n\t\t\tdriver_release_tids |= sta->driver_buffered_tids & tids;\n\n\t\tif (driver_release_tids) {\n\t\t\t/* If the driver has data on more than one TID then\n\t\t\t * certainly there's more data if we release just a\n\t\t\t * single frame now (from a single TID). This will\n\t\t\t * only happen for PS-Poll.\n\t\t\t */\n\t\t\tif (reason == IEEE80211_FRAME_RELEASE_PSPOLL &&\n\t\t\t    hweight16(driver_release_tids) > 1) {\n\t\t\t\tmore_data = true;\n\t\t\t\tdriver_release_tids =\n\t\t\t\t\tBIT(find_highest_prio_tid(\n\t\t\t\t\t\tdriver_release_tids));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\twhile (n_frames > 0) {\n\t\t\t\tskb = skb_dequeue(&sta->tx_filtered[ac]);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tskb = skb_dequeue(\n\t\t\t\t\t\t&sta->ps_tx_buf[ac]);\n\t\t\t\t\tif (skb)\n\t\t\t\t\t\tlocal->total_ps_buffered--;\n\t\t\t\t}\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\t\t\t\tn_frames--;\n\t\t\t\t__skb_queue_tail(&frames, skb);\n\t\t\t}\n\t\t}\n\n\t\t/* If we have more frames buffered on this AC, then set the\n\t\t * more-data bit and abort the loop since we can't send more\n\t\t * data from other ACs before the buffered frames from this.\n\t\t */\n\t\tif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t    !skb_queue_empty(&sta->ps_tx_buf[ac])) {\n\t\t\tmore_data = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skb_queue_empty(&frames) && !driver_release_tids) {\n\t\tint tid;\n\n\t\t/*\n\t\t * For PS-Poll, this can only happen due to a race condition\n\t\t * when we set the TIM bit and the station notices it, but\n\t\t * before it can poll for the frame we expire it.\n\t\t *\n\t\t * For uAPSD, this is said in the standard (11.2.1.5 h):\n\t\t *\tAt each unscheduled SP for a non-AP STA, the AP shall\n\t\t *\tattempt to transmit at least one MSDU or MMPDU, but no\n\t\t *\tmore than the value specified in the Max SP Length field\n\t\t *\tin the QoS Capability element from delivery-enabled ACs,\n\t\t *\tthat are destined for the non-AP STA.\n\t\t *\n\t\t * Since we have no other MSDU/MMPDU, transmit a QoS null frame.\n\t\t */\n\n\t\t/* This will evaluate to 1, 3, 5 or 7. */\n\t\ttid = 7 - ((ffs(~ignored_acs) - 1) << 1);\n\n\t\tieee80211_send_null_response(sdata, sta, tid, reason, true);\n\t} else if (!driver_release_tids) {\n\t\tstruct sk_buff_head pending;\n\t\tstruct sk_buff *skb;\n\t\tint num = 0;\n\t\tu16 tids = 0;\n\t\tbool need_null = false;\n\n\t\tskb_queue_head_init(&pending);\n\n\t\twhile ((skb = __skb_dequeue(&frames))) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\t\t\tu8 *qoshdr = NULL;\n\n\t\t\tnum++;\n\n\t\t\t/*\n\t\t\t * Tell TX path to send this frame even though the\n\t\t\t * STA may still remain is PS mode after this frame\n\t\t\t * exchange.\n\t\t\t */\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t\t\t       IEEE80211_TX_CTL_PS_RESPONSE;\n\n\t\t\t/*\n\t\t\t * Use MoreData flag to indicate whether there are\n\t\t\t * more buffered frames for this STA\n\t\t\t */\n\t\t\tif (more_data || !skb_queue_empty(&frames))\n\t\t\t\thdr->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t\telse\n\t\t\t\thdr->frame_control &=\n\t\t\t\t\tcpu_to_le16(~IEEE80211_FCTL_MOREDATA);\n\n\t\t\tif (ieee80211_is_data_qos(hdr->frame_control) ||\n\t\t\t    ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\t\t\tqoshdr = ieee80211_get_qos_ctl(hdr);\n\n\t\t\ttids |= BIT(skb->priority);\n\n\t\t\t__skb_queue_tail(&pending, skb);\n\n\t\t\t/* end service period after last frame or add one */\n\t\t\tif (!skb_queue_empty(&frames))\n\t\t\t\tcontinue;\n\n\t\t\tif (reason != IEEE80211_FRAME_RELEASE_UAPSD) {\n\t\t\t\t/* for PS-Poll, there's only one frame */\n\t\t\t\tinfo->flags |= IEEE80211_TX_STATUS_EOSP |\n\t\t\t\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* For uAPSD, things are a bit more complicated. If the\n\t\t\t * last frame has a QoS header (i.e. is a QoS-data or\n\t\t\t * QoS-nulldata frame) then just set the EOSP bit there\n\t\t\t * and be done.\n\t\t\t * If the frame doesn't have a QoS header (which means\n\t\t\t * it should be a bufferable MMPDU) then we can't set\n\t\t\t * the EOSP bit in the QoS header; add a QoS-nulldata\n\t\t\t * frame to the list to send it after the MMPDU.\n\t\t\t *\n\t\t\t * Note that this code is only in the mac80211-release\n\t\t\t * code path, we assume that the driver will not buffer\n\t\t\t * anything but QoS-data frames, or if it does, will\n\t\t\t * create the QoS-nulldata frame by itself if needed.\n\t\t\t *\n\t\t\t * Cf. 802.11-2012 10.2.1.10 (c).\n\t\t\t */\n\t\t\tif (qoshdr) {\n\t\t\t\t*qoshdr |= IEEE80211_QOS_CTL_EOSP;\n\n\t\t\t\tinfo->flags |= IEEE80211_TX_STATUS_EOSP |\n\t\t\t\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t} else {\n\t\t\t\t/* The standard isn't completely clear on this\n\t\t\t\t * as it says the more-data bit should be set\n\t\t\t\t * if there are more BUs. The QoS-Null frame\n\t\t\t\t * we're about to send isn't buffered yet, we\n\t\t\t\t * only create it below, but let's pretend it\n\t\t\t\t * was buffered just in case some clients only\n\t\t\t\t * expect more-data=0 when eosp=1.\n\t\t\t\t */\n\t\t\t\thdr->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t\t\tneed_null = true;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdrv_allow_buffered_frames(local, sta, tids, num,\n\t\t\t\t\t  reason, more_data);\n\n\t\tieee80211_add_pending_skbs(local, &pending);\n\n\t\tif (need_null)\n\t\t\tieee80211_send_null_response(\n\t\t\t\tsdata, sta, find_highest_prio_tid(tids),\n\t\t\t\treason, false);\n\n\t\tsta_info_recalc_tim(sta);\n\t} else {\n\t\t/*\n\t\t * We need to release a frame that is buffered somewhere in the\n\t\t * driver ... it'll have to handle that.\n\t\t * Note that the driver also has to check the number of frames\n\t\t * on the TIDs we're releasing from - if there are more than\n\t\t * n_frames it has to set the more-data bit (if we didn't ask\n\t\t * it to set it anyway due to other buffered frames); if there\n\t\t * are fewer than n_frames it has to make sure to adjust that\n\t\t * to allow the service period to end properly.\n\t\t */\n\t\tdrv_release_buffered_frames(local, sta, driver_release_tids,\n\t\t\t\t\t    n_frames, reason, more_data);\n\n\t\t/*\n\t\t * Note that we don't recalculate the TIM bit here as it would\n\t\t * most likely have no effect at all unless the driver told us\n\t\t * that the TID(s) became empty before returning here from the\n\t\t * release function.\n\t\t * Either way, however, when the driver tells us that the TID(s)\n\t\t * became empty we'll do the TIM recalculation.\n\t\t */\n\t}\n}\n\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta)\n{\n\tu8 ignore_for_response = sta->sta.uapsd_queues;\n\n\t/*\n\t * If all ACs are delivery-enabled then we should reply\n\t * from any of them, if only some are enabled we reply\n\t * only from the non-enabled ones.\n\t */\n\tif (ignore_for_response == BIT(IEEE80211_NUM_ACS) - 1)\n\t\tignore_for_response = 0;\n\n\tieee80211_sta_ps_deliver_response(sta, 1, ignore_for_response,\n\t\t\t\t\t  IEEE80211_FRAME_RELEASE_PSPOLL);\n}\n\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta)\n{\n\tint n_frames = sta->sta.max_sp;\n\tu8 delivery_enabled = sta->sta.uapsd_queues;\n\n\t/*\n\t * If we ever grow support for TSPEC this might happen if\n\t * the TSPEC update from hostapd comes in between a trigger\n\t * frame setting WLAN_STA_UAPSD in the RX path and this\n\t * actually getting called.\n\t */\n\tif (!delivery_enabled)\n\t\treturn;\n\n\tswitch (sta->sta.max_sp) {\n\tcase 1:\n\t\tn_frames = 2;\n\t\tbreak;\n\tcase 2:\n\t\tn_frames = 4;\n\t\tbreak;\n\tcase 3:\n\t\tn_frames = 6;\n\t\tbreak;\n\tcase 0:\n\t\t/* XXX: what is a good value? */\n\t\tn_frames = 8;\n\t\tbreak;\n\t}\n\n\tieee80211_sta_ps_deliver_response(sta, n_frames, ~delivery_enabled,\n\t\t\t\t\t  IEEE80211_FRAME_RELEASE_UAPSD);\n}\n\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\ttrace_api_sta_block_awake(sta->local, pubsta, block);\n\n\tif (block)\n\t\tset_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\telse if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_queue_work(hw, &sta->drv_unblock_wk);\n}\nEXPORT_SYMBOL(ieee80211_sta_block_awake);\n\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_local *local = sta->local;\n\n\ttrace_api_eosp(local, pubsta);\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n}\nEXPORT_SYMBOL(ieee80211_sta_eosp);\n\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *pubsta,\n\t\t\t\tu8 tid, bool buffered)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\n\ttrace_api_sta_set_buffered(sta->local, pubsta, tid, buffered);\n\n\tif (buffered)\n\t\tset_bit(tid, &sta->driver_buffered_tids);\n\telse\n\t\tclear_bit(tid, &sta->driver_buffered_tids);\n\n\tsta_info_recalc_tim(sta);\n}\nEXPORT_SYMBOL(ieee80211_sta_set_buffered);\n\nint sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state)\n{\n\tmight_sleep();\n\n\tif (sta->sta_state == new_state)\n\t\treturn 0;\n\n\t/* check allowed transitions first */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state != IEEE80211_STA_NONE &&\n\t\t    sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH &&\n\t\t    sta->sta_state != IEEE80211_STA_AUTHORIZED)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid state %d\", new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tsta_dbg(sta->sdata, \"moving STA %pM to state %d\\n\",\n\t\tsta->sta.addr, new_state);\n\n\t/*\n\t * notify the driver before the actual changes so it can\n\t * fail the transition\n\t */\n\tif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\n\t\tint err = drv_sta_state(sta->local, sta->sdata, sta,\n\t\t\t\t\tsta->sta_state, new_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reflect the change in all state variables */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH)\n\t\t\tclear_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state == IEEE80211_STA_NONE)\n\t\t\tset_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\telse if (sta->sta_state == IEEE80211_STA_ASSOC)\n\t\t\tclear_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH) {\n\t\t\tset_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\n\t\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t\t    (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     !sta->sdata->u.vlan.sta))\n\t\t\t\tatomic_dec(&sta->sdata->bss->num_mcast_sta);\n\t\t\tclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t\t    (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     !sta->sdata->u.vlan.sta))\n\t\t\t\tatomic_inc(&sta->sdata->bss->num_mcast_sta);\n\t\t\tset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsta->sta_state = new_state;\n\n\treturn 0;\n}\n\nu8 sta_info_tx_streams(struct sta_info *sta)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->sta.ht_cap;\n\tu8 rx_streams;\n\n\tif (!sta->sta.ht_cap.ht_supported)\n\t\treturn 1;\n\n\tif (sta->sta.vht_cap.vht_supported) {\n\t\tint i;\n\t\tu16 tx_mcs_map =\n\t\t\tle16_to_cpu(sta->sta.vht_cap.vht_mcs.tx_mcs_map);\n\n\t\tfor (i = 7; i >= 0; i--)\n\t\t\tif ((tx_mcs_map & (0x3 << (i * 2))) !=\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\t\treturn i + 1;\n\t}\n\n\tif (ht_cap->mcs.rx_mask[3])\n\t\trx_streams = 4;\n\telse if (ht_cap->mcs.rx_mask[2])\n\t\trx_streams = 3;\n\telse if (ht_cap->mcs.rx_mask[1])\n\t\trx_streams = 2;\n\telse\n\t\trx_streams = 1;\n\n\tif (!(ht_cap->mcs.tx_params & IEEE80211_HT_MCS_TX_RX_DIFF))\n\t\treturn rx_streams;\n\n\treturn ((ht_cap->mcs.tx_params & IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK)\n\t\t\t>> IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT) + 1;\n}\n", "/*\n * Copyright 2002-2005, Devicescape Software, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#ifndef STA_INFO_H\n#define STA_INFO_H\n\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/if_ether.h>\n#include <linux/workqueue.h>\n#include <linux/average.h>\n#include <linux/etherdevice.h>\n#include \"key.h\"\n\n/**\n * enum ieee80211_sta_info_flags - Stations flags\n *\n * These flags are used with &struct sta_info's @flags member, but\n * only indirectly with set_sta_flag() and friends.\n *\n * @WLAN_STA_AUTH: Station is authenticated.\n * @WLAN_STA_ASSOC: Station is associated.\n * @WLAN_STA_PS_STA: Station is in power-save mode\n * @WLAN_STA_AUTHORIZED: Station is authorized to send/receive traffic.\n *\tThis bit is always checked so needs to be enabled for all stations\n *\twhen virtual port control is not in use.\n * @WLAN_STA_SHORT_PREAMBLE: Station is capable of receiving short-preamble\n *\tframes.\n * @WLAN_STA_WME: Station is a QoS-STA.\n * @WLAN_STA_WDS: Station is one of our WDS peers.\n * @WLAN_STA_CLEAR_PS_FILT: Clear PS filter in hardware (using the\n *\tIEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next\n *\tframe to this station is transmitted.\n * @WLAN_STA_MFP: Management frame protection is used with this STA.\n * @WLAN_STA_BLOCK_BA: Used to deny ADDBA requests (both TX and RX)\n *\tduring suspend/resume and station removal.\n * @WLAN_STA_PS_DRIVER: driver requires keeping this station in\n *\tpower-save mode logically to flush frames that might still\n *\tbe in the queues\n * @WLAN_STA_PSPOLL: Station sent PS-poll while driver was keeping\n *\tstation in power-save mode, reply when the driver unblocks.\n * @WLAN_STA_TDLS_PEER: Station is a TDLS peer.\n * @WLAN_STA_TDLS_PEER_AUTH: This TDLS peer is authorized to send direct\n *\tpackets. This means the link is enabled.\n * @WLAN_STA_UAPSD: Station requested unscheduled SP while driver was\n *\tkeeping station in power-save mode, reply when the driver\n *\tunblocks the station.\n * @WLAN_STA_SP: Station is in a service period, so don't try to\n *\treply to other uAPSD trigger frames or PS-Poll.\n * @WLAN_STA_4ADDR_EVENT: 4-addr event was already sent for this frame.\n * @WLAN_STA_INSERTED: This station is inserted into the hash table.\n * @WLAN_STA_RATE_CONTROL: rate control was initialized for this station.\n * @WLAN_STA_TOFFSET_KNOWN: toffset calculated for this station is valid.\n * @WLAN_STA_MPSP_OWNER: local STA is owner of a mesh Peer Service Period.\n * @WLAN_STA_MPSP_RECIPIENT: local STA is recipient of a MPSP.\n */\nenum ieee80211_sta_info_flags {\n\tWLAN_STA_AUTH,\n\tWLAN_STA_ASSOC,\n\tWLAN_STA_PS_STA,\n\tWLAN_STA_AUTHORIZED,\n\tWLAN_STA_SHORT_PREAMBLE,\n\tWLAN_STA_WME,\n\tWLAN_STA_WDS,\n\tWLAN_STA_CLEAR_PS_FILT,\n\tWLAN_STA_MFP,\n\tWLAN_STA_BLOCK_BA,\n\tWLAN_STA_PS_DRIVER,\n\tWLAN_STA_PSPOLL,\n\tWLAN_STA_TDLS_PEER,\n\tWLAN_STA_TDLS_PEER_AUTH,\n\tWLAN_STA_UAPSD,\n\tWLAN_STA_SP,\n\tWLAN_STA_4ADDR_EVENT,\n\tWLAN_STA_INSERTED,\n\tWLAN_STA_RATE_CONTROL,\n\tWLAN_STA_TOFFSET_KNOWN,\n\tWLAN_STA_MPSP_OWNER,\n\tWLAN_STA_MPSP_RECIPIENT,\n};\n\n#define ADDBA_RESP_INTERVAL HZ\n#define HT_AGG_MAX_RETRIES\t\t15\n#define HT_AGG_BURST_RETRIES\t\t3\n#define HT_AGG_RETRIES_PERIOD\t\t(15 * HZ)\n\n#define HT_AGG_STATE_DRV_READY\t\t0\n#define HT_AGG_STATE_RESPONSE_RECEIVED\t1\n#define HT_AGG_STATE_OPERATIONAL\t2\n#define HT_AGG_STATE_STOPPING\t\t3\n#define HT_AGG_STATE_WANT_START\t\t4\n#define HT_AGG_STATE_WANT_STOP\t\t5\n\nenum ieee80211_agg_stop_reason {\n\tAGG_STOP_DECLINED,\n\tAGG_STOP_LOCAL_REQUEST,\n\tAGG_STOP_PEER_REQUEST,\n\tAGG_STOP_DESTROY_STA,\n};\n\n/**\n * struct tid_ampdu_tx - TID aggregation information (Tx).\n *\n * @rcu_head: rcu head for freeing structure\n * @session_timer: check if we keep Tx-ing on the TID (by timeout value)\n * @addba_resp_timer: timer for peer's response to addba request\n * @pending: pending frames queue -- use sta's spinlock to protect\n * @dialog_token: dialog token for aggregation session\n * @timeout: session timeout value to be filled in ADDBA requests\n * @state: session state (see above)\n * @last_tx: jiffies of last tx activity\n * @stop_initiator: initiator of a session stop\n * @tx_stop: TX DelBA frame when stopping\n * @buf_size: reorder buffer size at receiver\n * @failed_bar_ssn: ssn of the last failed BAR tx attempt\n * @bar_pending: BAR needs to be re-sent\n *\n * This structure's lifetime is managed by RCU, assignments to\n * the array holding it must hold the aggregation mutex.\n *\n * The TX path can access it under RCU lock-free if, and\n * only if, the state has the flag %HT_AGG_STATE_OPERATIONAL\n * set. Otherwise, the TX path must also acquire the spinlock\n * and re-check the state, see comments in the tx code\n * touching it.\n */\nstruct tid_ampdu_tx {\n\tstruct rcu_head rcu_head;\n\tstruct timer_list session_timer;\n\tstruct timer_list addba_resp_timer;\n\tstruct sk_buff_head pending;\n\tunsigned long state;\n\tunsigned long last_tx;\n\tu16 timeout;\n\tu8 dialog_token;\n\tu8 stop_initiator;\n\tbool tx_stop;\n\tu8 buf_size;\n\n\tu16 failed_bar_ssn;\n\tbool bar_pending;\n};\n\n/**\n * struct tid_ampdu_rx - TID aggregation information (Rx).\n *\n * @reorder_buf: buffer to reorder incoming aggregated MPDUs\n * @reorder_time: jiffies when skb was added\n * @session_timer: check if peer keeps Tx-ing on the TID (by timeout value)\n * @reorder_timer: releases expired frames from the reorder buffer.\n * @last_rx: jiffies of last rx activity\n * @head_seq_num: head sequence number in reordering buffer.\n * @stored_mpdu_num: number of MPDUs in reordering buffer\n * @ssn: Starting Sequence Number expected to be aggregated.\n * @buf_size: buffer size for incoming A-MPDUs\n * @timeout: reset timer value (in TUs).\n * @dialog_token: dialog token for aggregation session\n * @rcu_head: RCU head used for freeing this struct\n * @reorder_lock: serializes access to reorder buffer, see below.\n *\n * This structure's lifetime is managed by RCU, assignments to\n * the array holding it must hold the aggregation mutex.\n *\n * The @reorder_lock is used to protect the members of this\n * struct, except for @timeout, @buf_size and @dialog_token,\n * which are constant across the lifetime of the struct (the\n * dialog token being used only for debugging).\n */\nstruct tid_ampdu_rx {\n\tstruct rcu_head rcu_head;\n\tspinlock_t reorder_lock;\n\tstruct sk_buff **reorder_buf;\n\tunsigned long *reorder_time;\n\tstruct timer_list session_timer;\n\tstruct timer_list reorder_timer;\n\tunsigned long last_rx;\n\tu16 head_seq_num;\n\tu16 stored_mpdu_num;\n\tu16 ssn;\n\tu16 buf_size;\n\tu16 timeout;\n\tu8 dialog_token;\n};\n\n/**\n * struct sta_ampdu_mlme - STA aggregation information.\n *\n * @tid_rx: aggregation info for Rx per TID -- RCU protected\n * @tid_tx: aggregation info for Tx per TID\n * @tid_start_tx: sessions where start was requested\n * @addba_req_num: number of times addBA request has been sent.\n * @last_addba_req_time: timestamp of the last addBA request.\n * @dialog_token_allocator: dialog token enumerator for each new session;\n * @work: work struct for starting/stopping aggregation\n * @tid_rx_timer_expired: bitmap indicating on which TIDs the\n *\tRX timer expired until the work for it runs\n * @tid_rx_stop_requested:  bitmap indicating which BA sessions per TID the\n *\tdriver requested to close until the work for it runs\n * @mtx: mutex to protect all TX data (except non-NULL assignments\n *\tto tid_tx[idx], which are protected by the sta spinlock)\n *\ttid_start_tx is also protected by sta->lock.\n */\nstruct sta_ampdu_mlme {\n\tstruct mutex mtx;\n\t/* rx */\n\tstruct tid_ampdu_rx __rcu *tid_rx[IEEE80211_NUM_TIDS];\n\tunsigned long tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\tunsigned long tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\t/* tx */\n\tstruct work_struct work;\n\tstruct tid_ampdu_tx __rcu *tid_tx[IEEE80211_NUM_TIDS];\n\tstruct tid_ampdu_tx *tid_start_tx[IEEE80211_NUM_TIDS];\n\tunsigned long last_addba_req_time[IEEE80211_NUM_TIDS];\n\tu8 addba_req_num[IEEE80211_NUM_TIDS];\n\tu8 dialog_token_allocator;\n};\n\n/*\n * struct ieee80211_tx_latency_stat - Tx latency statistics\n *\n * Measures TX latency and jitter for a station per TID.\n *\n * @max: worst case latency\n * @sum: sum of all latencies\n * @counter: amount of Tx frames sent from interface\n * @bins: each bin counts how many frames transmitted within a certain\n * latency range. when disabled it is NULL.\n * @bin_count: amount of bins.\n */\nstruct ieee80211_tx_latency_stat {\n\tu32 max;\n\tu32 sum;\n\tu32 counter;\n\tu32 *bins;\n\tu32 bin_count;\n};\n\n/**\n * struct sta_info - STA information\n *\n * This structure collects information about a station that\n * mac80211 is communicating with.\n *\n * @list: global linked list entry\n * @free_list: list entry for keeping track of stations to free\n * @hnext: hash table linked list pointer\n * @local: pointer to the global information\n * @sdata: virtual interface this station belongs to\n * @ptk: peer keys negotiated with this station, if any\n * @ptk_idx: last installed peer key index\n * @gtk: group keys negotiated with this station, if any\n * @gtk_idx: last installed group key index\n * @rate_ctrl: rate control algorithm reference\n * @rate_ctrl_priv: rate control private per-STA pointer\n * @last_tx_rate: rate used for last transmit, to report to userspace as\n *\t\"the\" transmit rate\n * @last_rx_rate_idx: rx status rate index of the last data packet\n * @last_rx_rate_flag: rx status flag of the last data packet\n * @last_rx_rate_vht_nss: rx status nss of last data packet\n * @lock: used for locking all fields that require locking, see comments\n *\tin the header file.\n * @drv_unblock_wk: used for driver PS unblocking\n * @listen_interval: listen interval of this station, when we're acting as AP\n * @_flags: STA flags, see &enum ieee80211_sta_info_flags, do not use directly\n * @ps_lock: used for powersave (when mac80211 is the AP) related locking\n * @ps_tx_buf: buffers (per AC) of frames to transmit to this station\n *\twhen it leaves power saving state or polls\n * @tx_filtered: buffers (per AC) of frames we already tried to\n *\ttransmit but were filtered by hardware due to STA having\n *\tentered power saving state, these are also delivered to\n *\tthe station when it leaves powersave or polls for frames\n * @driver_buffered_tids: bitmap of TIDs the driver has data buffered on\n * @rx_packets: Number of MSDUs received from this STA\n * @rx_bytes: Number of bytes received from this STA\n * @wep_weak_iv_count: number of weak WEP IVs received from this station\n * @last_rx: time (in jiffies) when last frame was received from this STA\n * @last_connected: time (in seconds) when a station got connected\n * @num_duplicates: number of duplicate frames received from this STA\n * @rx_fragments: number of received MPDUs\n * @rx_dropped: number of dropped MPDUs from this STA\n * @last_signal: signal of last received frame from this STA\n * @avg_signal: moving average of signal of received frames from this STA\n * @last_ack_signal: signal of last received Ack frame from this STA\n * @last_seq_ctrl: last received seq/frag number from this STA (per RX queue)\n * @tx_filtered_count: number of frames the hardware filtered for this STA\n * @tx_retry_failed: number of frames that failed retry\n * @tx_retry_count: total number of retries for frames to this STA\n * @fail_avg: moving percentage of failed MSDUs\n * @tx_packets: number of RX/TX MSDUs\n * @tx_bytes: number of bytes transmitted to this STA\n * @tx_fragments: number of transmitted MPDUs\n * @tid_seq: per-TID sequence numbers for sending to this STA\n * @ampdu_mlme: A-MPDU state machine state\n * @timer_to_tid: identity mapping to ID timers\n * @tx_lat: Tx latency statistics\n * @llid: Local link ID\n * @plid: Peer link ID\n * @reason: Cancel reason on PLINK_HOLDING state\n * @plink_retries: Retries in establishment\n * @ignore_plink_timer: ignore the peer-link timer (used internally)\n * @plink_state: peer link state\n * @plink_timeout: timeout of peer link\n * @plink_timer: peer link watch timer\n * @t_offset: timing offset relative to this host\n * @t_offset_setpoint: reference timing offset of this sta to be used when\n * \tcalculating clockdrift\n * @local_pm: local link-specific power save mode\n * @peer_pm: peer-specific power save mode towards local STA\n * @nonpeer_pm: STA power save mode towards non-peer neighbors\n * @debugfs: debug filesystem info\n * @dead: set to true when sta is unlinked\n * @uploaded: set to true when sta is uploaded to the driver\n * @lost_packets: number of consecutive lost packets\n * @sta: station information we share with the driver\n * @sta_state: duplicates information about station state (for debug)\n * @beacon_loss_count: number of times beacon loss has triggered\n * @rcu_head: RCU head used for freeing this station struct\n * @cur_max_bandwidth: maximum bandwidth to use for TX to the station,\n *\ttaken from HT/VHT capabilities or VHT operating mode notification\n * @chains: chains ever used for RX from this station\n * @chain_signal_last: last signal (per chain)\n * @chain_signal_avg: signal average (per chain)\n * @known_smps_mode: the smps_mode the client thinks we are in. Relevant for\n *\tAP only.\n * @cipher_scheme: optional cipher scheme for this station\n */\nstruct sta_info {\n\t/* General information, mostly static */\n\tstruct list_head list, free_list;\n\tstruct rcu_head rcu_head;\n\tstruct sta_info __rcu *hnext;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS];\n\tstruct ieee80211_key __rcu *ptk[NUM_DEFAULT_KEYS];\n\tu8 gtk_idx;\n\tu8 ptk_idx;\n\tstruct rate_control_ref *rate_ctrl;\n\tvoid *rate_ctrl_priv;\n\tspinlock_t lock;\n\n\tstruct work_struct drv_unblock_wk;\n\n\tu16 listen_interval;\n\n\tbool dead;\n\n\tbool uploaded;\n\n\tenum ieee80211_sta_state sta_state;\n\n\t/* use the accessors defined below */\n\tunsigned long _flags;\n\n\t/* STA powersave lock and frame queues */\n\tspinlock_t ps_lock;\n\tstruct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];\n\tstruct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];\n\tunsigned long driver_buffered_tids;\n\n\t/* Updated from RX path only, no locking requirements */\n\tunsigned long rx_packets;\n\tu64 rx_bytes;\n\tunsigned long wep_weak_iv_count;\n\tunsigned long last_rx;\n\tlong last_connected;\n\tunsigned long num_duplicates;\n\tunsigned long rx_fragments;\n\tunsigned long rx_dropped;\n\tint last_signal;\n\tstruct ewma avg_signal;\n\tint last_ack_signal;\n\n\tu8 chains;\n\ts8 chain_signal_last[IEEE80211_MAX_CHAINS];\n\tstruct ewma chain_signal_avg[IEEE80211_MAX_CHAINS];\n\n\t/* Plus 1 for non-QoS frames */\n\t__le16 last_seq_ctrl[IEEE80211_NUM_TIDS + 1];\n\n\t/* Updated from TX status path only, no locking requirements */\n\tunsigned long tx_filtered_count;\n\tunsigned long tx_retry_failed, tx_retry_count;\n\t/* moving percentage of failed MSDUs */\n\tunsigned int fail_avg;\n\n\t/* Updated from TX path only, no locking requirements */\n\tu32 tx_fragments;\n\tu64 tx_packets[IEEE80211_NUM_ACS];\n\tu64 tx_bytes[IEEE80211_NUM_ACS];\n\tstruct ieee80211_tx_rate last_tx_rate;\n\tint last_rx_rate_idx;\n\tu32 last_rx_rate_flag;\n\tu8 last_rx_rate_vht_nss;\n\tu16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];\n\n\t/*\n\t * Aggregation information, locked with lock.\n\t */\n\tstruct sta_ampdu_mlme ampdu_mlme;\n\tu8 timer_to_tid[IEEE80211_NUM_TIDS];\n\n\tstruct ieee80211_tx_latency_stat *tx_lat;\n\n#ifdef CONFIG_MAC80211_MESH\n\t/*\n\t * Mesh peer link attributes\n\t * TODO: move to a sub-structure that is referenced with pointer?\n\t */\n\tu16 llid;\n\tu16 plid;\n\tu16 reason;\n\tu8 plink_retries;\n\tbool ignore_plink_timer;\n\tenum nl80211_plink_state plink_state;\n\tu32 plink_timeout;\n\tstruct timer_list plink_timer;\n\ts64 t_offset;\n\ts64 t_offset_setpoint;\n\t/* mesh power save */\n\tenum nl80211_mesh_power_mode local_pm;\n\tenum nl80211_mesh_power_mode peer_pm;\n\tenum nl80211_mesh_power_mode nonpeer_pm;\n#endif\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct sta_info_debugfsdentries {\n\t\tstruct dentry *dir;\n\t\tbool add_has_run;\n\t} debugfs;\n#endif\n\n\tenum ieee80211_sta_rx_bandwidth cur_max_bandwidth;\n\n\tunsigned int lost_packets;\n\tunsigned int beacon_loss_count;\n\n\tenum ieee80211_smps_mode known_smps_mode;\n\tconst struct ieee80211_cipher_scheme *cipher_scheme;\n\n\t/* keep last! */\n\tstruct ieee80211_sta sta;\n};\n\nstatic inline enum nl80211_plink_state sta_plink_state(struct sta_info *sta)\n{\n#ifdef CONFIG_MAC80211_MESH\n\treturn sta->plink_state;\n#endif\n\treturn NL80211_PLINK_LISTEN;\n}\n\nstatic inline void set_sta_flag(struct sta_info *sta,\n\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\tset_bit(flag, &sta->_flags);\n}\n\nstatic inline void clear_sta_flag(struct sta_info *sta,\n\t\t\t\t  enum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\tclear_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_sta_flag(struct sta_info *sta,\n\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\treturn test_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_and_clear_sta_flag(struct sta_info *sta,\n\t\t\t\t\t  enum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\treturn test_and_clear_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_and_set_sta_flag(struct sta_info *sta,\n\t\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\treturn test_and_set_bit(flag, &sta->_flags);\n}\n\nint sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state);\n\nstatic inline void sta_info_pre_move_state(struct sta_info *sta,\n\t\t\t\t\t   enum ieee80211_sta_state new_state)\n{\n\tint ret;\n\n\tWARN_ON_ONCE(test_sta_flag(sta, WLAN_STA_INSERTED));\n\n\tret = sta_info_move_state(sta, new_state);\n\tWARN_ON_ONCE(ret);\n}\n\n\nvoid ieee80211_assign_tid_tx(struct sta_info *sta, int tid,\n\t\t\t     struct tid_ampdu_tx *tid_tx);\n\nstatic inline struct tid_ampdu_tx *\nrcu_dereference_protected_tid_tx(struct sta_info *sta, int tid)\n{\n\treturn rcu_dereference_protected(sta->ampdu_mlme.tid_tx[tid],\n\t\t\t\t\t lockdep_is_held(&sta->lock) ||\n\t\t\t\t\t lockdep_is_held(&sta->ampdu_mlme.mtx));\n}\n\n#define STA_HASH_SIZE 256\n#define STA_HASH(sta) (sta[5])\n\n\n/* Maximum number of frames to buffer per power saving station per AC */\n#define STA_MAX_TX_BUFFER\t64\n\n/* Minimum buffered frame expiry time. If STA uses listen interval that is\n * smaller than this value, the minimum value here is used instead. */\n#define STA_TX_BUFFER_EXPIRE (10 * HZ)\n\n/* How often station data is cleaned up (e.g., expiration of buffered frames)\n */\n#define STA_INFO_CLEANUP_INTERVAL (10 * HZ)\n\n/*\n * Get a STA info, must be under RCU read lock.\n */\nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr);\n\nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  const u8 *addr);\n\nstatic inline\nvoid for_each_sta_info_type_check(struct ieee80211_local *local,\n\t\t\t\t  const u8 *addr,\n\t\t\t\t  struct sta_info *sta,\n\t\t\t\t  struct sta_info *nxt)\n{\n}\n\n#define for_each_sta_info(local, _addr, _sta, nxt)\t\t\t\\\n\tfor (\t/* initialise loop */\t\t\t\t\t\\\n\t\t_sta = rcu_dereference(local->sta_hash[STA_HASH(_addr)]),\\\n\t\tnxt = _sta ? rcu_dereference(_sta->hnext) : NULL;\t\\\n\t\t/* typecheck */\t\t\t\t\t\t\\\n\t\tfor_each_sta_info_type_check(local, (_addr), _sta, nxt),\\\n\t\t/* continue condition */\t\t\t\t\\\n\t\t_sta;\t\t\t\t\t\t\t\\\n\t\t/* advance loop */\t\t\t\t\t\\\n\t\t_sta = nxt,\t\t\t\t\t\t\\\n\t\tnxt = _sta ? rcu_dereference(_sta->hnext) : NULL\t\\\n\t     )\t\t\t\t\t\t\t\t\\\n\t/* compare address and run code only if it matches */\t\t\\\n\tif (ether_addr_equal(_sta->sta.addr, (_addr)))\n\n/*\n * Get STA info by index, BROKEN!\n */\nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     int idx);\n/*\n * Create a new STA info, caller owns returned structure\n * until sta_info_insert().\n */\nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *addr, gfp_t gfp);\n\nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta);\n\n/*\n * Insert STA info into hash table/list, returns zero or a\n * -EEXIST if (if the same MAC address is already present).\n *\n * Calling the non-rcu version makes the caller relinquish,\n * the _rcu version calls read_lock_rcu() and must be called\n * without it held.\n */\nint sta_info_insert(struct sta_info *sta);\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU);\n\nint __must_check __sta_info_destroy(struct sta_info *sta);\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata,\n\t\t\t  const u8 *addr);\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr);\n\nvoid sta_info_recalc_tim(struct sta_info *sta);\n\nvoid sta_info_init(struct ieee80211_local *local);\nvoid sta_info_stop(struct ieee80211_local *local);\n\n/**\n * sta_info_flush - flush matching STA entries from the STA table\n *\n * Returns the number of removed STA entries.\n *\n * @sdata: sdata to remove all stations from\n * @vlans: if the given interface is an AP interface, also flush VLANs\n */\nint __sta_info_flush(struct ieee80211_sub_if_data *sdata, bool vlans);\n\nstatic inline int sta_info_flush(struct ieee80211_sub_if_data *sdata)\n{\n\treturn __sta_info_flush(sdata, false);\n}\n\nvoid sta_set_rate_info_tx(struct sta_info *sta,\n\t\t\t  const struct ieee80211_tx_rate *rate,\n\t\t\t  struct rate_info *rinfo);\nvoid sta_set_rate_info_rx(struct sta_info *sta,\n\t\t\t  struct rate_info *rinfo);\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time);\nu8 sta_info_tx_streams(struct sta_info *sta);\n\nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta);\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta);\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta);\n\n#endif /* STA_INFO_H */\n", "/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007\tJohannes Berg <johannes@sipsolutions.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n *\n * Transmit and frame generation functions.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/bitmap.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/time.h>\n#include <net/net_namespace.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"led.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"wpa.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n/* misc utils */\n\nstatic __le16 ieee80211_duration(struct ieee80211_tx_data *tx,\n\t\t\t\t struct sk_buff *skb, int group_addr,\n\t\t\t\t int next_frag_len)\n{\n\tint rate, mrate, erp, dur, i, shift = 0;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tu32 rate_flags = 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(tx->sdata->vif.chanctx_conf);\n\tif (chanctx_conf) {\n\t\tshift = ieee80211_chandef_get_shift(&chanctx_conf->def);\n\t\trate_flags = ieee80211_chandef_rate_flags(&chanctx_conf->def);\n\t}\n\trcu_read_unlock();\n\n\t/* assume HW handles this */\n\tif (tx->rate.flags & IEEE80211_TX_RC_MCS)\n\t\treturn 0;\n\n\t/* uh huh? */\n\tif (WARN_ON_ONCE(tx->rate.idx < 0))\n\t\treturn 0;\n\n\tsband = local->hw.wiphy->bands[info->band];\n\ttxrate = &sband->bitrates[tx->rate.idx];\n\n\terp = txrate->flags & IEEE80211_RATE_ERP_G;\n\n\t/*\n\t * data and mgmt (except PS Poll):\n\t * - during CFP: 32768\n\t * - during contention period:\n\t *   if addr1 is group address: 0\n\t *   if more fragments = 0 and addr1 is individual address: time to\n\t *      transmit one ACK plus SIFS\n\t *   if more fragments = 1 and addr1 is individual address: time to\n\t *      transmit next fragment plus 2 x ACK plus 3 x SIFS\n\t *\n\t * IEEE 802.11, 9.6:\n\t * - control response frame (CTS or ACK) shall be transmitted using the\n\t *   same rate as the immediately previous frame in the frame exchange\n\t *   sequence, if this rate belongs to the PHY mandatory rates, or else\n\t *   at the highest possible rate belonging to the PHY rates in the\n\t *   BSSBasicRateSet\n\t */\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (ieee80211_is_ctl(hdr->frame_control)) {\n\t\t/* TODO: These control frames are not currently sent by\n\t\t * mac80211, but should they be implemented, this function\n\t\t * needs to be updated to support duration field calculation.\n\t\t *\n\t\t * RTS: time needed to transmit pending data/mgmt frame plus\n\t\t *    one CTS frame plus one ACK frame plus 3 x SIFS\n\t\t * CTS: duration of immediately previous RTS minus time\n\t\t *    required to transmit CTS and its SIFS\n\t\t * ACK: 0 if immediately previous directed data/mgmt had\n\t\t *    more=0, with more=1 duration in ACK frame is duration\n\t\t *    from previous frame minus time needed to transmit ACK\n\t\t *    and its SIFS\n\t\t * PS Poll: BIT(15) | BIT(14) | aid\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/* data/mgmt */\n\tif (0 /* FIX: data/mgmt during CFP */)\n\t\treturn cpu_to_le16(32768);\n\n\tif (group_addr) /* Group address as the destination - no ACK */\n\t\treturn 0;\n\n\t/* Individual destination address:\n\t * IEEE 802.11, Ch. 9.6 (after IEEE 802.11g changes)\n\t * CTS and ACK frames shall be transmitted using the highest rate in\n\t * basic rate set that is less than or equal to the rate of the\n\t * immediately previous frame and that is using the same modulation\n\t * (CCK or OFDM). If no basic rate set matches with these requirements,\n\t * the highest mandatory rate of the PHY that is less than or equal to\n\t * the rate of the previous frame is used.\n\t * Mandatory rates for IEEE 802.11g PHY: 1, 2, 5.5, 11, 6, 12, 24 Mbps\n\t */\n\trate = -1;\n\t/* use lowest available if everything fails */\n\tmrate = sband->bitrates[0].bitrate;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tstruct ieee80211_rate *r = &sband->bitrates[i];\n\n\t\tif (r->bitrate > txrate->bitrate)\n\t\t\tbreak;\n\n\t\tif ((rate_flags & r->flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tif (tx->sdata->vif.bss_conf.basic_rates & BIT(i))\n\t\t\trate = DIV_ROUND_UP(r->bitrate, 1 << shift);\n\n\t\tswitch (sband->band) {\n\t\tcase IEEE80211_BAND_2GHZ: {\n\t\t\tu32 flag;\n\t\t\tif (tx->sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_G;\n\t\t\telse\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_B;\n\t\t\tif (r->flags & flag)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\t}\n\t\tcase IEEE80211_BAND_5GHZ:\n\t\t\tif (r->flags & IEEE80211_RATE_MANDATORY_A)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\tcase IEEE80211_BAND_60GHZ:\n\t\t\t/* TODO, for now fall through */\n\t\tcase IEEE80211_NUM_BANDS:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rate == -1) {\n\t\t/* No matching basic rate found; use highest suitable mandatory\n\t\t * PHY rate */\n\t\trate = DIV_ROUND_UP(mrate, 1 << shift);\n\t}\n\n\t/* Don't calculate ACKs for QoS Frames with NoAck Policy set */\n\tif (ieee80211_is_data_qos(hdr->frame_control) &&\n\t    *(ieee80211_get_qos_ctl(hdr)) & IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\tdur = 0;\n\telse\n\t\t/* Time needed to transmit ACK\n\t\t * (10 bytes + 4-byte FCS = 112 bits) plus SIFS; rounded up\n\t\t * to closest integer */\n\t\tdur = ieee80211_frame_duration(sband->band, 10, rate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\n\tif (next_frag_len) {\n\t\t/* Frame is fragmented: duration increases with time needed to\n\t\t * transmit next fragment plus ACK and 2 x SIFS. */\n\t\tdur *= 2; /* ACK + SIFS */\n\t\t/* next fragment */\n\t\tdur += ieee80211_frame_duration(sband->band, next_frag_len,\n\t\t\t\ttxrate->bitrate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\t}\n\n\treturn cpu_to_le16(dur);\n}\n\n/* tx handlers */\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\n\t/* driver doesn't support power save */\n\tif (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\n\t/* hardware does dynamic power save */\n\tif (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic power save disabled */\n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\n\t/* we are scanning, don't enable power save */\n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\n\t/* No point if we're going to suspend */\n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic ps is supported only in managed mode */\n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\n\tifmgd = &tx->sdata->u.mgd;\n\n\t/*\n\t * Don't wakeup from power save if u-apsd is enabled, voip ac has\n\t * u-apsd enabled and the frame is in voip class. This effectively\n\t * means that even if all access categories have u-apsd enabled, in\n\t * practise u-apsd is only used with the voip ac. This is a\n\t * workaround for the case when received voip class packets do not\n\t * have correct qos tag for some reason, due the network or the\n\t * peer application.\n\t *\n\t * Note: ifmgd->uapsd_queues access is racy here. If the value is\n\t * changed via debugfs, user needs to reassociate manually to have\n\t * everything in sync.\n\t */\n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\n\t/* Don't restart the timer if we're not disassociated */\n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_nullfunc(hdr->frame_control))\n\t\t/*\n\t\t * When software scanning only nullfunc frames (to notify\n\t\t * the sleep state to the AP) and probe requests (for the\n\t\t * active scan) are allowed, all other frames should not be\n\t\t * sent and we should not get here, but if we do\n\t\t * nonetheless, drop them to avoid sending them\n\t\t * off-channel. See the link below and\n\t\t * ieee80211_start_scan() for more.\n\t\t *\n\t\t * http://article.gmane.org/gmane.linux.kernel.wireless.general/30089\n\t\t */\n\t\treturn TX_DROP;\n\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(tx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    !atomic_read(&tx->sdata->u.ap.num_mcast_sta))) {\n\t\t/*\n\t\t * No associated STAs - no need to send multicast\n\t\t * frames.\n\t\t */\n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* This function is called whenever the AP is about to exceed the maximum limit\n * of buffered frames for power saving STAs. This situation should not really\n * happen often during normal operation, so dropping the oldest buffered packet\n * from each queue should be OK to make some room for new frames. */\nstatic void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\n\t/*\n\t * broadcast/multicast frame\n\t *\n\t * If any of the associated/peer stations is in power save mode,\n\t * the frame is buffered to be sent after DTIM beacon frame.\n\t * This is done either by the hardware or us.\n\t */\n\n\t/* powersaving STAs currently only in AP/VLAN/mesh mode */\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\n\n\t/* no buffering for ordered frames */\n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (tx->local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\n\t/* no stations in PS mode */\n\tif (!atomic_read(&ps->num_sta_ps))\n\t\treturn TX_CONTINUE;\n\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\n\t/* device releases frame after DTIM beacon */\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\n\t/* buffered in mac80211 */\n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tdev_kfree_skb(skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\n\treturn TX_QUEUED;\n}\n\nstatic int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,\n\t\t\t     struct sk_buff *skb)\n{\n\tif (!ieee80211_is_mgmt(fc))\n\t\treturn 0;\n\n\tif (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))\n\t\treturn 0;\n\n\tif (!ieee80211_is_robust_mgmt_frame((struct ieee80211_hdr *)\n\t\t\t\t\t    skb->data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_local *local = tx->local;\n\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n\t\t       sta->sta.addr, sta->sta.aid, ac);\n\t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\t\tpurge_old_ps_buffers(tx->local);\n\n\t\t/* sync with ieee80211_sta_ps_deliver_wakeup */\n\t\tspin_lock(&sta->ps_lock);\n\t\t/*\n\t\t * STA woke up the meantime and all the frames on ps_tx_buf have\n\t\t * been queued to pending queue. No reordering can happen, go\n\t\t * ahead and Tx the packet.\n\t\t */\n\t\tif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {\n\t\t\tspin_unlock(&sta->ps_lock);\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n\t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n\t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n\t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n\t\tspin_unlock(&sta->ps_lock);\n\n\t\tif (!timer_pending(&local->sta_cleanup))\n\t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\n\t\t/*\n\t\t * We queued up some frames, so the TIM bit might\n\t\t * need to be set, recalculate it.\n\t\t */\n\t\tsta_info_recalc_tim(sta);\n\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\n\tif (unlikely(tx->flags & IEEE80211_TX_PS_BUFFERED))\n\t\treturn TX_CONTINUE;\n\n\t/* only deauth, disassoc and action are bufferable MMPDUs */\n\tif (ieee80211_is_mgmt(hdr->frame_control) &&\n\t    !ieee80211_is_deauth(hdr->frame_control) &&\n\t    !ieee80211_is_disassoc(hdr->frame_control) &&\n\t    !ieee80211_is_action(hdr->frame_control)) {\n\t\tif (tx->flags & IEEE80211_TX_UNICAST)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\n\t\treturn TX_CONTINUE;\n\t}\n\n\tif (tx->flags & IEEE80211_TX_UNICAST)\n\t\treturn ieee80211_tx_h_unicast_ps_buf(tx);\n\telse\n\t\treturn ieee80211_tx_h_multicast_ps_buf(tx);\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\tif (unlikely(tx->sdata->control_port_protocol == tx->skb->protocol)) {\n\t\tif (tx->sdata->control_port_no_encrypt)\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_select_key(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT))\n\t\ttx->key = NULL;\n\telse if (tx->sta &&\n\t\t (key = rcu_dereference(tx->sta->ptk[tx->sta->ptk_idx])))\n\t\ttx->key = key;\n\telse if (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t is_multicast_ether_addr(hdr->addr1) &&\n\t\t ieee80211_is_robust_mgmt_frame(hdr) &&\n\t\t (key = rcu_dereference(tx->sdata->default_mgmt_key)))\n\t\ttx->key = key;\n\telse if (is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_multicast_key)))\n\t\ttx->key = key;\n\telse if (!is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_unicast_key)))\n\t\ttx->key = key;\n\telse if (info->flags & IEEE80211_TX_CTL_INJECTED)\n\t\ttx->key = NULL;\n\telse if (!tx->sdata->drop_unencrypted)\n\t\ttx->key = NULL;\n\telse if (tx->skb->protocol == tx->sdata->control_port_protocol)\n\t\ttx->key = NULL;\n\telse if (ieee80211_is_robust_mgmt_frame(hdr) &&\n\t\t !(ieee80211_is_action(hdr->frame_control) &&\n\t\t   tx->sta && test_sta_flag(tx->sta, WLAN_STA_MFP)))\n\t\ttx->key = NULL;\n\telse if (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t !ieee80211_is_robust_mgmt_frame(hdr))\n\t\ttx->key = NULL;\n\telse {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_unencrypted);\n\t\treturn TX_DROP;\n\t}\n\n\tif (tx->key) {\n\t\tbool skip_hw = false;\n\n\t\ttx->key->tx_rx_count++;\n\t\t/* TODO: add threshold stuff again */\n\n\t\tswitch (tx->key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control) &&\n\t\t\t    !ieee80211_use_mfp(hdr->frame_control, tx->sta,\n\t\t\t\t\t       tx->skb))\n\t\t\t\ttx->key = NULL;\n\t\t\telse\n\t\t\t\tskip_hw = (tx->key->conf.flags &\n\t\t\t\t\t   IEEE80211_KEY_FLAG_SW_MGMT_TX) &&\n\t\t\t\t\tieee80211_is_mgmt(hdr->frame_control);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(tx->key && tx->key->flags & KEY_FLAG_TAINTED &&\n\t\t\t     !ieee80211_is_deauth(hdr->frame_control)))\n\t\t\treturn TX_DROP;\n\n\t\tif (!skip_hw && tx->key &&\n\t\t    tx->key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)\n\t\t\tinfo->control.hw_key = &tx->key->conf;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_rate_ctrl(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (void *)tx->skb->data;\n\tstruct ieee80211_supported_band *sband;\n\tu32 len;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_sta_rates *ratetbl = NULL;\n\tbool assoc = false;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\n\tsband = tx->local->hw.wiphy->bands[info->band];\n\n\tlen = min_t(u32, tx->skb->len + FCS_LEN,\n\t\t\t tx->local->hw.wiphy->frag_threshold);\n\n\t/* set up the tx rate control struct we give the RC algo */\n\ttxrc.hw = &tx->local->hw;\n\ttxrc.sband = sband;\n\ttxrc.bss_conf = &tx->sdata->vif.bss_conf;\n\ttxrc.skb = tx->skb;\n\ttxrc.reported_rate.idx = -1;\n\ttxrc.rate_idx_mask = tx->sdata->rc_rateidx_mask[info->band];\n\tif (txrc.rate_idx_mask == (1 << sband->n_bitrates) - 1)\n\t\ttxrc.max_rate_idx = -1;\n\telse\n\t\ttxrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;\n\n\tif (tx->sdata->rc_has_mcs_mask[info->band])\n\t\ttxrc.rate_idx_mcs_mask =\n\t\t\ttx->sdata->rc_rateidx_mcs_mask[info->band];\n\n\ttxrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC);\n\n\t/* set up RTS protection if desired */\n\tif (len > tx->local->hw.wiphy->rts_threshold) {\n\t\ttxrc.rts = true;\n\t}\n\n\tinfo->control.use_rts = txrc.rts;\n\tinfo->control.use_cts_prot = tx->sdata->vif.bss_conf.use_cts_prot;\n\n\t/*\n\t * Use short preamble if the BSS can handle it, but not for\n\t * management frames unless we know the receiver can handle\n\t * that -- the management frame might be to a station that\n\t * just wants a probe response.\n\t */\n\tif (tx->sdata->vif.bss_conf.use_short_preamble &&\n\t    (ieee80211_is_data(hdr->frame_control) ||\n\t     (tx->sta && test_sta_flag(tx->sta, WLAN_STA_SHORT_PREAMBLE))))\n\t\ttxrc.short_preamble = true;\n\n\tinfo->control.short_preamble = txrc.short_preamble;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\t/*\n\t * Lets not bother rate control if we're associated and cannot\n\t * talk to the sta. This should not happen.\n\t */\n\tif (WARN(test_bit(SCAN_SW_SCANNING, &tx->local->scanning) && assoc &&\n\t\t !rate_usable_index_exists(sband, &tx->sta->sta),\n\t\t \"%s: Dropped data frame as no usable bitrate found while \"\n\t\t \"scanning and associated. Target station: \"\n\t\t \"%pM on %d GHz band\\n\",\n\t\t tx->sdata->name, hdr->addr1,\n\t\t info->band ? 5 : 2))\n\t\treturn TX_DROP;\n\n\t/*\n\t * If we're associated with the sta at this point we know we can at\n\t * least send the frame at the lowest bit rate.\n\t */\n\trate_control_get_rate(tx->sdata, tx->sta, &txrc);\n\n\tif (tx->sta && !info->control.skip_table)\n\t\tratetbl = rcu_dereference(tx->sta->sta.rates);\n\n\tif (unlikely(info->control.rates[0].idx < 0)) {\n\t\tif (ratetbl) {\n\t\t\tstruct ieee80211_tx_rate rate = {\n\t\t\t\t.idx = ratetbl->rate[0].idx,\n\t\t\t\t.flags = ratetbl->rate[0].flags,\n\t\t\t\t.count = ratetbl->rate[0].count\n\t\t\t};\n\n\t\t\tif (ratetbl->rate[0].idx < 0)\n\t\t\t\treturn TX_DROP;\n\n\t\t\ttx->rate = rate;\n\t\t} else {\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else {\n\t\ttx->rate = info->control.rates[0];\n\t}\n\n\tif (txrc.reported_rate.idx < 0) {\n\t\ttxrc.reported_rate = tx->rate;\n\t\tif (tx->sta && ieee80211_is_data(hdr->frame_control))\n\t\t\ttx->sta->last_tx_rate = txrc.reported_rate;\n\t} else if (tx->sta)\n\t\ttx->sta->last_tx_rate = txrc.reported_rate;\n\n\tif (ratetbl)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(!info->control.rates[0].count))\n\t\tinfo->control.rates[0].count = 1;\n\n\tif (WARN_ON_ONCE((info->control.rates[0].count > 1) &&\n\t\t\t (info->flags & IEEE80211_TX_CTL_NO_ACK)))\n\t\tinfo->control.rates[0].count = 1;\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_sequence(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tu16 *seq;\n\tu8 *qc;\n\tint tid;\n\n\t/*\n\t * Packet injection may want to control the sequence\n\t * number, if we have no matching interface then we\n\t * neither assign one ourselves nor ask the driver to.\n\t */\n\tif (unlikely(info->control.vif->type == NL80211_IFTYPE_MONITOR))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(ieee80211_is_ctl(hdr->frame_control)))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hdrlen(hdr->frame_control) < 24)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Anything but QoS data that has a sequence number field\n\t * (is long enough) gets a sequence number from the global\n\t * counter.  QoS data frames with a multicast destination\n\t * also use the global counter (802.11-2012 9.3.2.10).\n\t */\n\tif (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1)) {\n\t\t/* driver should assign sequence number */\n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\t/* for pure STA mode without beacons, we can do it */\n\t\thdr->seq_ctrl = cpu_to_le16(tx->sdata->sequence_number);\n\t\ttx->sdata->sequence_number += 0x10;\n\t\treturn TX_CONTINUE;\n\t}\n\n\t/*\n\t * This should be true for injected/management frames only, for\n\t * management frames we have set the IEEE80211_TX_CTL_ASSIGN_SEQ\n\t * above since they are not QoS-data frames.\n\t */\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\t/* include per-STA, per-TID sequence counter */\n\n\tqc = ieee80211_get_qos_ctl(hdr);\n\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\tseq = &tx->sta->tid_seq[tid];\n\n\thdr->seq_ctrl = cpu_to_le16(*seq);\n\n\t/* Increase the sequence number. */\n\t*seq = (*seq + 0x10) & IEEE80211_SCTL_SEQ;\n\n\treturn TX_CONTINUE;\n}\n\nstatic int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\n\t/* first fragment was already added to queue by caller */\n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\n\t\t/* copy control information */\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\n\t\t/* copy header and data */\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\n\t\tpos += fraglen;\n\t}\n\n\t/* adjust first fragment's length */\n\tskb_trim(skb, hdrlen + per_fragm);\n\treturn 0;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb = tx->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tint frag_threshold = tx->local->hw.wiphy->frag_threshold;\n\tint hdrlen;\n\tint fragnum;\n\n\t/* no matter what happens, tx->skb moves to tx->skbs */\n\t__skb_queue_tail(&tx->skbs, skb);\n\ttx->skb = NULL;\n\n\tif (info->flags & IEEE80211_TX_CTL_DONTFRAG)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->local->ops->set_frag_threshold)\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Warn when submitting a fragmented A-MPDU frame and drop it.\n\t * This scenario is handled in ieee80211_tx_prepare but extra\n\t * caution taken here as fragmented ampdu may cause Tx stop.\n\t */\n\tif (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\treturn TX_DROP;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t/* internal error, why isn't DONTFRAG set? */\n\tif (WARN_ON(skb->len + FCS_LEN <= frag_threshold))\n\t\treturn TX_DROP;\n\n\t/*\n\t * Now fragment the frame. This will allocate all the fragments and\n\t * chain them (using skb as the first fragment) to skb->next.\n\t * During transmission, we will remove the successfully transmitted\n\t * fragments from this list. When the low-level driver rejects one\n\t * of the fragments then we will simply pretend to accept the skb\n\t * but store it away as pending.\n\t */\n\tif (ieee80211_fragment(tx, skb, hdrlen, frag_threshold))\n\t\treturn TX_DROP;\n\n\t/* update duration/seq/flags of fragments */\n\tfragnum = 0;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tconst __le16 morefrags = cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\n\n\t\thdr = (void *)skb->data;\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\thdr->frame_control |= morefrags;\n\t\t\t/*\n\t\t\t * No multi-rate retries for fragmented frames, that\n\t\t\t * would completely throw off the NAV at other STAs.\n\t\t\t */\n\t\t\tinfo->control.rates[1].idx = -1;\n\t\t\tinfo->control.rates[2].idx = -1;\n\t\t\tinfo->control.rates[3].idx = -1;\n\t\t\tBUILD_BUG_ON(IEEE80211_TX_MAX_RATES != 4);\n\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_RATE_CTRL_PROBE;\n\t\t} else {\n\t\t\thdr->frame_control &= ~morefrags;\n\t\t}\n\t\thdr->seq_ctrl |= cpu_to_le16(fragnum & IEEE80211_SCTL_FRAG);\n\t\tfragnum++;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_stats(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tint ac = -1;\n\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tac = skb_get_queue_mapping(skb);\n\t\ttx->sta->tx_fragments++;\n\t\ttx->sta->tx_bytes[ac] += skb->len;\n\t}\n\tif (ac >= 0)\n\t\ttx->sta->tx_packets[ac]++;\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_encrypt(struct ieee80211_tx_data *tx)\n{\n\tif (!tx->key)\n\t\treturn TX_CONTINUE;\n\n\tswitch (tx->key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn ieee80211_crypto_wep_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn ieee80211_crypto_tkip_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn ieee80211_crypto_ccmp_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\treturn ieee80211_crypto_aes_cmac_encrypt(tx);\n\tdefault:\n\t\treturn ieee80211_crypto_hw_encrypt(tx);\n\t}\n\n\treturn TX_DROP;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_calculate_duration(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tint next_len;\n\tbool group_addr;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\thdr = (void *) skb->data;\n\t\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control)))\n\t\t\tbreak; /* must not overwrite AID */\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(&tx->skbs, skb);\n\t\t\tnext_len = next->len;\n\t\t} else\n\t\t\tnext_len = 0;\n\t\tgroup_addr = is_multicast_ether_addr(hdr->addr1);\n\n\t\thdr->duration_id =\n\t\t\tieee80211_duration(tx, skb, group_addr, next_len);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* actual transmit path */\n\nstatic bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  struct tid_ampdu_tx *tid_tx,\n\t\t\t\t  int tid)\n{\n\tbool queued = false;\n\tbool reset_agg_timer = false;\n\tstruct sk_buff *purge_skb = NULL;\n\n\tif (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treset_agg_timer = true;\n\t} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t\t/*\n\t\t * nothing -- this aggregation session is being started\n\t\t * but that might still fail with the driver\n\t\t */\n\t} else {\n\t\tspin_lock(&tx->sta->lock);\n\t\t/*\n\t\t * Need to re-check now, because we may get here\n\t\t *\n\t\t *  1) in the window during which the setup is actually\n\t\t *     already done, but not marked yet because not all\n\t\t *     packets are spliced over to the driver pending\n\t\t *     queue yet -- if this happened we acquire the lock\n\t\t *     either before or after the splice happens, but\n\t\t *     need to recheck which of these cases happened.\n\t\t *\n\t\t *  2) during session teardown, if the OPERATIONAL bit\n\t\t *     was cleared due to the teardown but the pointer\n\t\t *     hasn't been assigned NULL yet (or we loaded it\n\t\t *     before it was assigned) -- in this case it may\n\t\t *     now be NULL which means we should just let the\n\t\t *     packet pass through because splicing the frames\n\t\t *     back is already done.\n\t\t */\n\t\ttid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);\n\n\t\tif (!tid_tx) {\n\t\t\t/* do nothing, let packet pass through */\n\t\t} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\t\treset_agg_timer = true;\n\t\t} else {\n\t\t\tqueued = true;\n\t\t\tinfo->control.vif = &tx->sdata->vif;\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\t\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\t\t__skb_queue_tail(&tid_tx->pending, skb);\n\t\t\tif (skb_queue_len(&tid_tx->pending) > STA_MAX_TX_BUFFER)\n\t\t\t\tpurge_skb = __skb_dequeue(&tid_tx->pending);\n\t\t}\n\t\tspin_unlock(&tx->sta->lock);\n\n\t\tif (purge_skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, purge_skb);\n\t}\n\n\t/* reset session timer */\n\tif (reset_agg_timer && tid_tx->timeout)\n\t\ttid_tx->last_tx = jiffies;\n\n\treturn queued;\n}\n\n/*\n * initialises @tx\n */\nstatic ieee80211_tx_result\nieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_tx_data *tx,\n\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tid;\n\tu8 *qc;\n\n\tmemset(tx, 0, sizeof(*tx));\n\ttx->skb = skb;\n\ttx->local = local;\n\ttx->sdata = sdata;\n\t__skb_queue_head_init(&tx->skbs);\n\n\t/*\n\t * If this flag is set to true anywhere, and we get here,\n\t * we are doing the needed processing, so remove the flag\n\t * now.\n\t */\n\tinfo->flags &= ~IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\ttx->sta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (!tx->sta && sdata->dev->ieee80211_ptr->use_4addr)\n\t\t\treturn TX_DROP;\n\t} else if (info->flags & (IEEE80211_TX_CTL_INJECTED |\n\t\t\t\t  IEEE80211_TX_INTFL_NL80211_FRAME_TX) ||\n\t\t   tx->sdata->control_port_protocol == tx->skb->protocol) {\n\t\ttx->sta = sta_info_get_bss(sdata, hdr->addr1);\n\t}\n\tif (!tx->sta)\n\t\ttx->sta = sta_info_get(sdata, hdr->addr1);\n\n\tif (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&\n\t    (local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) &&\n\t    !(local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW)) {\n\t\tstruct tid_ampdu_tx *tid_tx;\n\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tbool queued;\n\n\t\t\tqueued = ieee80211_tx_prep_agg(tx, skb, info,\n\t\t\t\t\t\t       tid_tx, tid);\n\n\t\t\tif (unlikely(queued))\n\t\t\t\treturn TX_QUEUED;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\ttx->flags &= ~IEEE80211_TX_UNICAST;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t} else\n\t\ttx->flags |= IEEE80211_TX_UNICAST;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {\n\t\tif (!(tx->flags & IEEE80211_TX_UNICAST) ||\n\t\t    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_DONTFRAG;\n\t}\n\n\tif (!tx->sta)\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\telse if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT))\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\n\tinfo->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;\n\n\treturn TX_CONTINUE;\n}\n\nstatic bool ieee80211_tx_frags(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct sk_buff_head *skbs,\n\t\t\t       bool txpending)\n{\n\tstruct ieee80211_tx_control control;\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\n\tskb_queue_walk_safe(skbs, skb, tmp) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tint q = info->hw_queue;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tif (WARN_ON_ONCE(q >= local->hw.queues)) {\n\t\t\t__skb_unlink(skb, skbs);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\tif (local->queue_stop_reasons[q] ||\n\t\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\t\tif (unlikely(info->flags &\n\t\t\t\t     IEEE80211_TX_INTFL_OFFCHAN_TX_OK)) {\n\t\t\t\tif (local->queue_stop_reasons[q] &\n\t\t\t\t    ~BIT(IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Drop off-channel frames if queues\n\t\t\t\t\t * are stopped for any reason other\n\t\t\t\t\t * than off-channel operation. Never\n\t\t\t\t\t * queue them.\n\t\t\t\t\t */\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tieee80211_purge_tx_queue(&local->hw,\n\t\t\t\t\t\t\t\t skbs);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * Since queue is stopped, queue up frames for\n\t\t\t\t * later transmission from the tx-pending\n\t\t\t\t * tasklet when the queue is woken again.\n\t\t\t\t */\n\t\t\t\tif (txpending)\n\t\t\t\t\tskb_queue_splice_init(skbs,\n\t\t\t\t\t\t\t      &local->pending[q]);\n\t\t\t\telse\n\t\t\t\t\tskb_queue_splice_tail_init(skbs,\n\t\t\t\t\t\t\t\t   &local->pending[q]);\n\n\t\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\tinfo->control.vif = vif;\n\t\tcontrol.sta = sta;\n\n\t\t__skb_unlink(skb, skbs);\n\t\tdrv_tx(local, &control, skb);\n\t}\n\n\treturn true;\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool __ieee80211_tx(struct ieee80211_local *local,\n\t\t\t   struct sk_buff_head *skbs, int led_len,\n\t\t\t   struct sta_info *sta, bool txpending)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *pubsta;\n\tstruct sk_buff *skb;\n\tbool result = true;\n\t__le16 fc;\n\n\tif (WARN_ON(skb_queue_empty(skbs)))\n\t\treturn true;\n\n\tskb = skb_peek(skbs);\n\tfc = ((struct ieee80211_hdr *)skb->data)->frame_control;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tsdata = vif_to_sdata(info->control.vif);\n\tif (sta && !sta->uploaded)\n\t\tsta = NULL;\n\n\tif (sta)\n\t\tpubsta = &sta->sta;\n\telse\n\t\tpubsta = NULL;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr_flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\tsdata = rcu_dereference(local->monitor_sdata);\n\t\tif (sdata) {\n\t\t\tvif = &sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (local->hw.flags & IEEE80211_HW_QUEUE_CONTROL) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t} else\n\t\t\tvif = NULL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\t\t/* fall through */\n\tdefault:\n\t\tvif = &sdata->vif;\n\t\tbreak;\n\t}\n\n\tresult = ieee80211_tx_frags(local, vif, pubsta, skbs,\n\t\t\t\t    txpending);\n\n\tieee80211_tpt_led_trig_tx(local, fc, led_len);\n\n\tWARN_ON_ONCE(!skb_queue_empty(skbs));\n\n\treturn result;\n}\n\n/*\n * Invoke TX handlers, return 0 on success and non-zero if the\n * frame was dropped or queued.\n */\nstatic int invoke_tx_handlers(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tieee80211_tx_result res = TX_DROP;\n\n#define CALL_TXH(txh) \\\n\tdo {\t\t\t\t\\\n\t\tres = txh(tx);\t\t\\\n\t\tif (res != TX_CONTINUE)\t\\\n\t\t\tgoto txh_done;\t\\\n\t} while (0)\n\n\tCALL_TXH(ieee80211_tx_h_dynamic_ps);\n\tCALL_TXH(ieee80211_tx_h_check_assoc);\n\tCALL_TXH(ieee80211_tx_h_ps_buf);\n\tCALL_TXH(ieee80211_tx_h_check_control_port_protocol);\n\tCALL_TXH(ieee80211_tx_h_select_key);\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_rate_ctrl);\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION)) {\n\t\t__skb_queue_tail(&tx->skbs, tx->skb);\n\t\ttx->skb = NULL;\n\t\tgoto txh_done;\n\t}\n\n\tCALL_TXH(ieee80211_tx_h_michael_mic_add);\n\tCALL_TXH(ieee80211_tx_h_sequence);\n\tCALL_TXH(ieee80211_tx_h_fragment);\n\t/* handlers after fragment must be aware of tx info fragmentation! */\n\tCALL_TXH(ieee80211_tx_h_stats);\n\tCALL_TXH(ieee80211_tx_h_encrypt);\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_calculate_duration);\n#undef CALL_TXH\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_data tx;\n\n\tif (ieee80211_tx_prepare(sdata, &tx, skb) == TX_DROP)\n\t\treturn false;\n\n\tinfo->band = band;\n\tinfo->control.vif = vif;\n\tinfo->hw_queue = vif->hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers(&tx))\n\t\treturn false;\n\n\tif (sta) {\n\t\tif (tx.sta)\n\t\t\t*sta = &tx.sta->sta;\n\t\telse\n\t\t\t*sta = NULL;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_tx_prepare_skb);\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb, bool txpending,\n\t\t\t enum ieee80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result res_prepare;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool result = true;\n\tint led_len;\n\n\tif (unlikely(skb->len < 10)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn true;\n\t}\n\n\t/* initialises tx */\n\tled_len = skb->len;\n\tres_prepare = ieee80211_tx_prepare(sdata, &tx, skb);\n\n\tif (unlikely(res_prepare == TX_DROP)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn true;\n\t} else if (unlikely(res_prepare == TX_QUEUED)) {\n\t\treturn true;\n\t}\n\n\tinfo->band = band;\n\n\t/* set up hw_queue value early */\n\tif (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||\n\t    !(local->hw.flags & IEEE80211_HW_QUEUE_CONTROL))\n\t\tinfo->hw_queue =\n\t\t\tsdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (!invoke_tx_handlers(&tx))\n\t\tresult = __ieee80211_tx(local, &tx.skbs, led_len,\n\t\t\t\t\ttx.sta, txpending);\n\n\treturn result;\n}\n\n/* device xmit handlers */\n\nstatic int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tint head_need, bool may_encrypt)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint tail_need = 0;\n\n\tif (may_encrypt && sdata->crypto_tx_tailroom_needed_cnt) {\n\t\ttail_need = IEEE80211_ENCRYPT_TAILROOM;\n\t\ttail_need -= skb_tailroom(skb);\n\t\ttail_need = max_t(int, tail_need, 0);\n\t}\n\n\tif (skb_cloned(skb))\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head_cloned);\n\telse if (head_need || tail_need)\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\telse\n\t\treturn 0;\n\n\tif (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {\n\t\twiphy_debug(local->hw.wiphy,\n\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_xmit(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb,\n\t\t    enum ieee80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tint headroom;\n\tbool may_encrypt;\n\n\tmay_encrypt = !(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT);\n\n\theadroom = local->tx_headroom;\n\tif (may_encrypt)\n\t\theadroom += sdata->encrypt_headroom;\n\theadroom -= skb_headroom(skb);\n\theadroom = max_t(int, 0, headroom);\n\n\tif (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    is_unicast_ether_addr(hdr->addr1)) {\n\t\t\tif (mesh_nexthop_resolve(sdata, skb))\n\t\t\t\treturn; /* skb queued: don't free */\n\t\t} else {\n\t\t\tieee80211_mps_set_frame_flags(sdata, NULL, hdr);\n\t\t}\n\t}\n\n\tieee80211_set_qos_hdr(sdata, skb);\n\tieee80211_tx(sdata, skb, false, band);\n}\n\nstatic bool ieee80211_parse_tx_radiotap(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.txt\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\t/*\n\t * remove the radiotap header\n\t * iterator->_max_length was sanity-checked against\n\t * skb->len by iterator init\n\t */\n\tskb_pull(skb, iterator._max_length);\n\n\treturn true;\n}\n\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *chan;\n\tstruct ieee80211_radiotap_header *prthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\t/* check for not even having the fixed radiotap header part */\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\tgoto fail; /* too short to be possibly valid */\n\n\t/* is it a header version we can trust to find length from? */\n\tif (unlikely(prthdr->it_version))\n\t\tgoto fail; /* only version 0 is supported */\n\n\t/* then there must be a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/* does the skb contain enough to deliver on the alleged length? */\n\tif (unlikely(skb->len < len_rthdr))\n\t\tgoto fail; /* skb too short for claimed rt header extent */\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* process and remove the injection radiotap header */\n\tif (!ieee80211_parse_tx_radiotap(skb))\n\t\tgoto fail;\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN/WDS support we will need a different mechanism (which\n\t * likely isn't going to be monitor interfaces).\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchan = chanctx_conf->def.chan;\n\telse if (!local->use_chanctx)\n\t\tchan = local->_oper_chandef.chan;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif ((chan->flags & (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR)))\n\t\tgoto fail_rcu;\n\n\tieee80211_xmit(sdata, skb, chan->band);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}\n\n/*\n * Measure Tx frame arrival time for Tx latency statistics calculation\n * A single Tx frame latency should be measured from when it is entering the\n * Kernel until we receive Tx complete confirmation indication and the skb is\n * freed.\n */\nstatic void ieee80211_tx_latency_start_msrmnt(struct ieee80211_local *local,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct timespec skb_arv;\n\tstruct ieee80211_tx_latency_bin_ranges *tx_latency;\n\n\ttx_latency = rcu_dereference(local->tx_latency);\n\tif (!tx_latency)\n\t\treturn;\n\n\tktime_get_ts(&skb_arv);\n\tskb->tstamp = ktime_set(skb_arv.tv_sec, skb_arv.tv_nsec);\n}\n\n/**\n * ieee80211_subif_start_xmit - netif start_xmit function for Ethernet-type\n * subinterfaces (wlan#, WDS, and VLAN interfaces)\n * @skb: packet to be sent\n * @dev: incoming interface\n *\n * Returns: 0 on success (and frees skb in this case) or 1 on failure (skb will\n * not be freed, and caller is responsible for either retrying later or freeing\n * skb).\n *\n * This function takes in an Ethernet header and encapsulates it with suitable\n * IEEE 802.11 header based on which interface the packet is coming in. The\n * encapsulated packet will then be passed to master interface, wlan#.11, for\n * transmission (through low-level driver).\n */\nnetdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info;\n\tint head_need;\n\tu16 ethertype, hdrlen,  meshhdrlen = 0;\n\t__le16 fc;\n\tstruct ieee80211_hdr hdr;\n\tstruct ieee80211s_hdr mesh_hdr __maybe_unused;\n\tstruct mesh_path __maybe_unused *mppath = NULL, *mpath = NULL;\n\tconst u8 *encaps_data;\n\tint encaps_len, skip_header_bytes;\n\tint nh_pos, h_pos;\n\tstruct sta_info *sta = NULL;\n\tbool wme_sta = false, authorized = false, tdls_auth = false;\n\tbool tdls_direct = false;\n\tbool multicast;\n\tu32 info_flags = 0;\n\tu16 info_id = 0;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_sub_if_data *ap_sdata;\n\tenum ieee80211_band band;\n\n\tif (unlikely(skb->len < ETH_HLEN))\n\t\tgoto fail;\n\n\t/* convert Ethernet header to proper 802.11 header (based on\n\t * operation mode) */\n\tethertype = (skb->data[12] << 8) | skb->data[13];\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\trcu_read_lock();\n\n\t/* Measure frame arrival for Tx latency statistics calculation */\n\tieee80211_tx_latency_start_msrmnt(local, skb);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (sta) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\t\twme_sta = test_sta_flag(sta, WLAN_STA_WME);\n\t\t}\n\t\tap_sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t\tu.ap);\n\t\tchanctx_conf = rcu_dereference(ap_sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tif (sta)\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase NL80211_IFTYPE_AP:\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t/* DA BSSID SA */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, skb->data + ETH_ALEN, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t/* RA TA DA SA */\n\t\tmemcpy(hdr.addr1, sdata->u.wds.remote_addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\thdrlen = 30;\n\t\t/*\n\t\t * This is the exception! WDS style interfaces are prohibited\n\t\t * when channel contexts are in used so this must be valid\n\t\t */\n\t\tband = local->hw.conf.chandef.chan->band;\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!is_multicast_ether_addr(skb->data)) {\n\t\t\tstruct sta_info *next_hop;\n\t\t\tbool mpp_lookup = true;\n\n\t\t\tmpath = mesh_path_lookup(sdata, skb->data);\n\t\t\tif (mpath) {\n\t\t\t\tmpp_lookup = false;\n\t\t\t\tnext_hop = rcu_dereference(mpath->next_hop);\n\t\t\t\tif (!next_hop ||\n\t\t\t\t    !(mpath->flags & (MESH_PATH_ACTIVE |\n\t\t\t\t\t\t      MESH_PATH_RESOLVING)))\n\t\t\t\t\tmpp_lookup = true;\n\t\t\t}\n\n\t\t\tif (mpp_lookup)\n\t\t\t\tmppath = mpp_path_lookup(sdata, skb->data);\n\n\t\t\tif (mppath && mpath)\n\t\t\t\tmesh_path_del(mpath->sdata, mpath->dst);\n\t\t}\n\n\t\t/*\n\t\t * Use address extension if it is a packet from\n\t\t * another interface or if we know the destination\n\t\t * is being proxied by a portal (i.e. portal address\n\t\t * differs from proxied address)\n\t\t */\n\t\tif (ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN) &&\n\t\t    !(mppath && !ether_addr_equal(mppath->mpp, skb->data))) {\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tskb->data, skb->data + ETH_ALEN);\n\t\t\tmeshhdrlen = ieee80211_new_mesh_header(sdata, &mesh_hdr,\n\t\t\t\t\t\t\t       NULL, NULL);\n\t\t} else {\n\t\t\t/* DS -> MBSS (802.11-2012 13.11.3.3).\n\t\t\t * For unicast with unknown forwarding information,\n\t\t\t * destination might be in the MBSS or if that fails\n\t\t\t * forwarded to another mesh gate. In either case\n\t\t\t * resolution will be handled in ieee80211_xmit(), so\n\t\t\t * leave the original DA. This also works for mcast */\n\t\t\tconst u8 *mesh_da = skb->data;\n\n\t\t\tif (mppath)\n\t\t\t\tmesh_da = mppath->mpp;\n\t\t\telse if (mpath)\n\t\t\t\tmesh_da = mpath->dst;\n\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tmesh_da, sdata->vif.addr);\n\t\t\tif (is_multicast_ether_addr(mesh_da))\n\t\t\t\t/* DA TA mSA AE:SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr,\n\t\t\t\t\t\tskb->data + ETH_ALEN, NULL);\n\t\t\telse\n\t\t\t\t/* RA TA mDA mSA AE:DA SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr, skb->data,\n\t\t\t\t\t\tskb->data + ETH_ALEN);\n\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\t\tbool tdls_peer = false;\n\n\t\t\tsta = sta_info_get(sdata, skb->data);\n\t\t\tif (sta) {\n\t\t\t\tauthorized = test_sta_flag(sta,\n\t\t\t\t\t\t\tWLAN_STA_AUTHORIZED);\n\t\t\t\twme_sta = test_sta_flag(sta, WLAN_STA_WME);\n\t\t\t\ttdls_peer = test_sta_flag(sta,\n\t\t\t\t\t\t\t WLAN_STA_TDLS_PEER);\n\t\t\t\ttdls_auth = test_sta_flag(sta,\n\t\t\t\t\t\tWLAN_STA_TDLS_PEER_AUTH);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the TDLS link is enabled, send everything\n\t\t\t * directly. Otherwise, allow TDLS setup frames\n\t\t\t * to be transmitted indirectly.\n\t\t\t */\n\t\t\ttdls_direct = tdls_peer && (tdls_auth ||\n\t\t\t\t !(ethertype == ETH_P_TDLS && skb->len > 14 &&\n\t\t\t\t   skb->data[14] == WLAN_TDLS_SNAP_RFTYPE));\n\t\t}\n\n\t\tif (tdls_direct) {\n\t\t\t/* link during setup - throw out frames to peer */\n\t\t\tif (!tdls_auth)\n\t\t\t\tgoto fail_rcu;\n\n\t\t\t/* DA SA BSSID */\n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}  else if (sdata->u.mgd.use_4addr &&\n\t\t\t    cpu_to_be16(ethertype) != sdata->control_port_protocol) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t} else {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t\t/* BSSID SA DA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* DA SA BSSID */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf)\n\t\t\tgoto fail_rcu;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tdefault:\n\t\tgoto fail_rcu;\n\t}\n\n\t/*\n\t * There's no need to try to look up the destination\n\t * if it is a multicast address (which can only happen\n\t * in AP mode)\n\t */\n\tmulticast = is_multicast_ether_addr(hdr.addr1);\n\tif (!multicast) {\n\t\tsta = sta_info_get(sdata, hdr.addr1);\n\t\tif (sta) {\n\t\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\t\twme_sta = test_sta_flag(sta, WLAN_STA_WME);\n\t\t}\n\t}\n\n\t/* For mesh, the use of the QoS header is mandatory */\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\twme_sta = true;\n\n\t/* receiver and we are QoS enabled, use a QoS type frame */\n\tif (wme_sta && local->hw.queues >= IEEE80211_NUM_ACS) {\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t\thdrlen += 2;\n\t}\n\n\t/*\n\t * Drop unicast frames to unauthorised stations unless they are\n\t * EAPOL frames from the local station.\n\t */\n\tif (unlikely(!ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t     !multicast && !authorized &&\n\t\t     (cpu_to_be16(ethertype) != sdata->control_port_protocol ||\n\t\t      !ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN)))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tnet_info_ratelimited(\"%s: dropped frame to %pM (unauthorized port)\\n\",\n\t\t\t\t    dev->name, hdr.addr1);\n#endif\n\n\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\n\t\tgoto fail_rcu;\n\t}\n\n\tif (unlikely(!multicast && skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)) {\n\t\tstruct sk_buff *orig_skb = skb;\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (skb) {\n\t\t\tunsigned long flags;\n\t\t\tint id;\n\n\t\t\tspin_lock_irqsave(&local->ack_status_lock, flags);\n\t\t\tid = idr_alloc(&local->ack_status_frames, orig_skb,\n\t\t\t\t       1, 0x10000, GFP_ATOMIC);\n\t\t\tspin_unlock_irqrestore(&local->ack_status_lock, flags);\n\n\t\t\tif (id >= 0) {\n\t\t\t\tinfo_id = id;\n\t\t\t\tinfo_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t} else if (skb_shared(skb)) {\n\t\t\t\tkfree_skb(orig_skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = orig_skb;\n\t\t\t}\n\t\t} else {\n\t\t\t/* couldn't clone -- lose tx status ... */\n\t\t\tskb = orig_skb;\n\t\t}\n\t}\n\n\t/*\n\t * If the skb is shared we need to obtain our own copy.\n\t */\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *tmp_skb = skb;\n\n\t\t/* can't happen -- skb is a clone if info_id != 0 */\n\t\tWARN_ON(info_id);\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tkfree_skb(tmp_skb);\n\n\t\tif (!skb)\n\t\t\tgoto fail_rcu;\n\t}\n\n\thdr.frame_control = fc;\n\thdr.duration_id = 0;\n\thdr.seq_ctrl = 0;\n\n\tskip_header_bytes = ETH_HLEN;\n\tif (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {\n\t\tencaps_data = bridge_tunnel_header;\n\t\tencaps_len = sizeof(bridge_tunnel_header);\n\t\tskip_header_bytes -= 2;\n\t} else if (ethertype >= ETH_P_802_3_MIN) {\n\t\tencaps_data = rfc1042_header;\n\t\tencaps_len = sizeof(rfc1042_header);\n\t\tskip_header_bytes -= 2;\n\t} else {\n\t\tencaps_data = NULL;\n\t\tencaps_len = 0;\n\t}\n\n\tnh_pos = skb_network_header(skb) - skb->data;\n\th_pos = skb_transport_header(skb) - skb->data;\n\n\tskb_pull(skb, skip_header_bytes);\n\tnh_pos -= skip_header_bytes;\n\th_pos -= skip_header_bytes;\n\n\thead_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);\n\n\t/*\n\t * So we need to modify the skb header and hence need a copy of\n\t * that. The head_need variable above doesn't, so far, include\n\t * the needed header space that we don't need right away. If we\n\t * can, then we don't reallocate right now but only after the\n\t * frame arrives at the master device (if it does...)\n\t *\n\t * If we cannot, however, then we will reallocate to include all\n\t * the ever needed space. Also, if we need to reallocate it anyway,\n\t * make it big enough for everything we may ever need.\n\t */\n\n\tif (head_need > 0 || skb_cloned(skb)) {\n\t\thead_need += sdata->encrypt_headroom;\n\t\thead_need += local->tx_headroom;\n\t\thead_need = max_t(int, 0, head_need);\n\t\tif (ieee80211_skb_resize(sdata, skb, head_need, true)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tskb = NULL;\n\t\t\tgoto fail_rcu;\n\t\t}\n\t}\n\n\tif (encaps_data) {\n\t\tmemcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);\n\t\tnh_pos += encaps_len;\n\t\th_pos += encaps_len;\n\t}\n\n#ifdef CONFIG_MAC80211_MESH\n\tif (meshhdrlen > 0) {\n\t\tmemcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);\n\t\tnh_pos += meshhdrlen;\n\t\th_pos += meshhdrlen;\n\t}\n#endif\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\t__le16 *qos_control;\n\n\t\tqos_control = (__le16 *) skb_push(skb, 2);\n\t\tmemcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);\n\t\t/*\n\t\t * Maybe we could actually set some fields here, for now just\n\t\t * initialise to zero to indicate no special operation.\n\t\t */\n\t\t*qos_control = 0;\n\t} else\n\t\tmemcpy(skb_push(skb, hdrlen), &hdr, hdrlen);\n\n\tnh_pos += hdrlen;\n\th_pos += hdrlen;\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\t/* Update skb pointers to various headers since this modified frame\n\t * is going to go through Linux networking code that may potentially\n\t * need things like pointer to IP header. */\n\tskb_set_mac_header(skb, 0);\n\tskb_set_network_header(skb, nh_pos);\n\tskb_set_transport_header(skb, h_pos);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\n\tdev->trans_start = jiffies;\n\n\tinfo->flags = info_flags;\n\tinfo->ack_frame_id = info_id;\n\n\tieee80211_xmit(sdata, skb, band);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\n fail_rcu:\n\trcu_read_unlock();\n fail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n/*\n * ieee80211_clear_tx_pending may not be called in a context where\n * it is possible that it packets could come in again.\n */\nvoid ieee80211_clear_tx_pending(struct ieee80211_local *local)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\twhile ((skb = skb_dequeue(&local->pending[i])) != NULL)\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead,\n * which in this case means re-queued -- take as an indication to stop sending\n * more pending frames.\n */\nstatic bool ieee80211_tx_pending_skb(struct ieee80211_local *local,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_hdr *hdr;\n\tbool result;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(info->control.vif);\n\n\tif (info->flags & IEEE80211_TX_INTFL_NEED_TXPROCESSING) {\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (unlikely(!chanctx_conf)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\t\tresult = ieee80211_tx(sdata, skb, true,\n\t\t\t\t      chanctx_conf->def.chan->band);\n\t} else {\n\t\tstruct sk_buff_head skbs;\n\n\t\t__skb_queue_head_init(&skbs);\n\t\t__skb_queue_tail(&skbs, skb);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tsta = sta_info_get(sdata, hdr->addr1);\n\n\t\tresult = __ieee80211_tx(local, &skbs, skb->len, sta, true);\n\t}\n\n\treturn result;\n}\n\n/*\n * Transmit all pending packets. Called from tasklet.\n */\nvoid ieee80211_tx_pending(unsigned long data)\n{\n\tstruct ieee80211_local *local = (struct ieee80211_local *)data;\n\tunsigned long flags;\n\tint i;\n\tbool txok;\n\n\trcu_read_lock();\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\t/*\n\t\t * If queue is stopped by something other than due to pending\n\t\t * frames, or we have no pending frames, proceed to next queue.\n\t\t */\n\t\tif (local->queue_stop_reasons[i] ||\n\t\t    skb_queue_empty(&local->pending[i]))\n\t\t\tcontinue;\n\n\t\twhile (!skb_queue_empty(&local->pending[i])) {\n\t\t\tstruct sk_buff *skb = __skb_dequeue(&local->pending[i]);\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\t\tif (WARN_ON(!info->control.vif)) {\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\n\t\t\ttxok = ieee80211_tx_pending_skb(local, skb);\n\t\t\tspin_lock_irqsave(&local->queue_stop_reason_lock,\n\t\t\t\t\t  flags);\n\t\t\tif (!txok)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb_queue_empty(&local->pending[i]))\n\t\t\tieee80211_propagate_queue_wake(local, i);\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\trcu_read_unlock();\n}\n\n/* functions for drivers to get certain frames */\n\nstatic void __ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ps_data *ps, struct sk_buff *skb)\n{\n\tu8 *pos, *tim;\n\tint aid0 = 0;\n\tint i, have_bits = 0, n1, n2;\n\n\t/* Generate bitmap for TIM only if there are any STAs in power save\n\t * mode. */\n\tif (atomic_read(&ps->num_sta_ps) > 0)\n\t\t/* in the hope that this is faster than\n\t\t * checking byte-for-byte */\n\t\thave_bits = !bitmap_empty((unsigned long *)ps->tim,\n\t\t\t\t\t  IEEE80211_MAX_AID+1);\n\n\tif (ps->dtim_count == 0)\n\t\tps->dtim_count = sdata->vif.bss_conf.dtim_period - 1;\n\telse\n\t\tps->dtim_count--;\n\n\ttim = pos = (u8 *) skb_put(skb, 6);\n\t*pos++ = WLAN_EID_TIM;\n\t*pos++ = 4;\n\t*pos++ = ps->dtim_count;\n\t*pos++ = sdata->vif.bss_conf.dtim_period;\n\n\tif (ps->dtim_count == 0 && !skb_queue_empty(&ps->bc_buf))\n\t\taid0 = 1;\n\n\tps->dtim_bc_mc = aid0 == 1;\n\n\tif (have_bits) {\n\t\t/* Find largest even number N1 so that bits numbered 1 through\n\t\t * (N1 x 8) - 1 in the bitmap are 0 and number N2 so that bits\n\t\t * (N2 + 1) x 8 through 2007 are 0. */\n\t\tn1 = 0;\n\t\tfor (i = 0; i < IEEE80211_MAX_TIM_LEN; i++) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn1 = i & 0xfe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn2 = n1;\n\t\tfor (i = IEEE80211_MAX_TIM_LEN - 1; i >= n1; i--) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Bitmap control */\n\t\t*pos++ = n1 | aid0;\n\t\t/* Part Virt Bitmap */\n\t\tskb_put(skb, n2 - n1);\n\t\tmemcpy(pos, ps->tim + n1, n2 - n1 + 1);\n\n\t\ttim[1] = n2 - n1 + 4;\n\t} else {\n\t\t*pos++ = aid0; /* Bitmap control */\n\t\t*pos++ = 0; /* Part Virt Bitmap */\n\t}\n}\n\nstatic int ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ps_data *ps, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\t/*\n\t * Not very nice, but we want to allow the driver to call\n\t * ieee80211_beacon_get() as a response to the set_tim()\n\t * callback. That, however, is already invoked under the\n\t * sta_lock to guarantee consistent and race-free update\n\t * of the tim bitmap in mac80211 and the driver.\n\t */\n\tif (local->tim_in_locked_section) {\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb);\n\t} else {\n\t\tspin_lock_bh(&local->tim_lock);\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb);\n\t\tspin_unlock_bh(&local->tim_lock);\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_csa_finish(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tieee80211_queue_work(&sdata->local->hw,\n\t\t\t     &sdata->csa_finalize_work);\n}\nEXPORT_SYMBOL(ieee80211_csa_finish);\n\nstatic void ieee80211_update_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct beacon_data *beacon)\n{\n\tstruct probe_resp *resp;\n\tint counter_offset_beacon = sdata->csa_counter_offset_beacon;\n\tint counter_offset_presp = sdata->csa_counter_offset_presp;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (WARN_ON(counter_offset_beacon >= beacon_data_len))\n\t\treturn;\n\n\t/* warn if the driver did not check for/react to csa completeness */\n\tif (WARN_ON(beacon_data[counter_offset_beacon] == 0))\n\t\treturn;\n\n\tbeacon_data[counter_offset_beacon]--;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP && counter_offset_presp) {\n\t\trcu_read_lock();\n\t\tresp = rcu_dereference(sdata->u.ap.probe_resp);\n\n\t\t/* if nl80211 accepted the offset, this should not happen. */\n\t\tif (WARN_ON(!resp)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tresp->data[counter_offset_presp]--;\n\t\trcu_read_unlock();\n\t}\n}\n\nbool ieee80211_csa_is_complete(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tint counter_beacon = sdata->csa_counter_offset_beacon;\n\tint ret = false;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\n\t\tbeacon = rcu_dereference(ap->beacon);\n\t\tif (WARN_ON(!beacon || !beacon->tail))\n\t\t\tgoto out;\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t} else if (vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else if (vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(counter_beacon > beacon_data_len))\n\t\tgoto out;\n\n\tif (beacon_data[counter_beacon] == 0)\n\t\tret = true;\n out:\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_csa_is_complete);\n\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tenum ieee80211_band band;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\trcu_read_lock();\n\n\tsdata = vif_to_sdata(vif);\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!ieee80211_sdata_running(sdata) || !chanctx_conf)\n\t\tgoto out;\n\n\tif (tim_offset)\n\t\t*tim_offset = 0;\n\tif (tim_length)\n\t\t*tim_length = 0;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\t\tstruct beacon_data *beacon = rcu_dereference(ap->beacon);\n\n\t\tif (beacon) {\n\t\t\tif (sdata->vif.csa_active)\n\t\t\t\tieee80211_update_csa(sdata, beacon);\n\n\t\t\t/*\n\t\t\t * headroom, head length,\n\t\t\t * tail length and maximum TIM length\n\t\t\t */\n\t\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t\t    beacon->head_len +\n\t\t\t\t\t    beacon->tail_len + 256 +\n\t\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\t\tif (!skb)\n\t\t\t\tgoto out;\n\n\t\t\tskb_reserve(skb, local->tx_headroom);\n\t\t\tmemcpy(skb_put(skb, beacon->head_len), beacon->head,\n\t\t\t       beacon->head_len);\n\n\t\t\tieee80211_beacon_add_tim(sdata, &ap->ps, skb);\n\n\t\t\tif (tim_offset)\n\t\t\t\t*tim_offset = beacon->head_len;\n\t\t\tif (tim_length)\n\t\t\t\t*tim_length = skb->len - beacon->head_len;\n\n\t\t\tif (beacon->tail)\n\t\t\t\tmemcpy(skb_put(skb, beacon->tail_len),\n\t\t\t\t       beacon->tail, beacon->tail_len);\n\t\t} else\n\t\t\tgoto out;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\t\tstruct ieee80211_hdr *hdr;\n\t\tstruct beacon_data *presp = rcu_dereference(ifibss->presp);\n\n\t\tif (!presp)\n\t\t\tgoto out;\n\n\t\tif (sdata->vif.csa_active)\n\t\t\tieee80211_update_csa(sdata, presp);\n\n\n\t\tskb = dev_alloc_skb(local->tx_headroom + presp->head_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tmemcpy(skb_put(skb, presp->head_len), presp->head,\n\t\t       presp->head_len);\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t IEEE80211_STYPE_BEACON);\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\t\tstruct beacon_data *bcn = rcu_dereference(ifmsh->beacon);\n\n\t\tif (!bcn)\n\t\t\tgoto out;\n\n\t\tif (sdata->vif.csa_active)\n\t\t\tieee80211_update_csa(sdata, bcn);\n\n\t\tif (ifmsh->sync_ops)\n\t\t\tifmsh->sync_ops->adjust_tbtt(sdata, bcn);\n\n\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    bcn->head_len +\n\t\t\t\t    256 + /* TIM IE */\n\t\t\t\t    bcn->tail_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tmemcpy(skb_put(skb, bcn->head_len), bcn->head, bcn->head_len);\n\t\tieee80211_beacon_add_tim(sdata, &ifmsh->ps, skb);\n\t\tmemcpy(skb_put(skb, bcn->tail_len), bcn->tail, bcn->tail_len);\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\tinfo->band = band;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\ttxrc.hw = hw;\n\ttxrc.sband = local->hw.wiphy->bands[band];\n\ttxrc.bss_conf = &sdata->vif.bss_conf;\n\ttxrc.skb = skb;\n\ttxrc.reported_rate.idx = -1;\n\ttxrc.rate_idx_mask = sdata->rc_rateidx_mask[band];\n\tif (txrc.rate_idx_mask == (1 << txrc.sband->n_bitrates) - 1)\n\t\ttxrc.max_rate_idx = -1;\n\telse\n\t\ttxrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;\n\ttxrc.bss = true;\n\trate_control_get_rate(sdata, NULL, &txrc);\n\n\tinfo->control.vif = vif;\n\n\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\tIEEE80211_TX_CTL_ASSIGN_SEQ |\n\t\t\tIEEE80211_TX_CTL_FIRST_FRAGMENT;\n out:\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_tim);\n\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ieee80211_if_ap *ap = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct probe_resp *presp = NULL;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tap = &sdata->u.ap;\n\tpresp = rcu_dereference(ap->probe_resp);\n\tif (!presp)\n\t\tgoto out;\n\n\tskb = dev_alloc_skb(presp->len);\n\tif (!skb)\n\t\tgoto out;\n\n\tmemcpy(skb_put(skb, presp->len), presp->data, presp->len);\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tmemset(hdr->addr1, 0, sizeof(hdr->addr1));\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_proberesp_get);\n\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_pspoll *pspoll;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*pspoll));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tpspoll = (struct ieee80211_pspoll *) skb_put(skb, sizeof(*pspoll));\n\tmemset(pspoll, 0, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL);\n\tpspoll->aid = cpu_to_le16(ifmgd->aid);\n\n\t/* aid in PS-Poll has its two MSBs each set to 1 */\n\tpspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);\n\n\tmemcpy(pspoll->bssid, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, vif->addr, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_pspoll_get);\n\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*nullfunc));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = (struct ieee80211_hdr_3addr *) skb_put(skb,\n\t\t\t\t\t\t\t  sizeof(*nullfunc));\n\tmemset(nullfunc, 0, sizeof(*nullfunc));\n\tnullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t      IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t      IEEE80211_FCTL_TODS);\n\tmemcpy(nullfunc->addr1, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, vif->addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, ifmgd->bssid, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_nullfunc_get);\n\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_hdr_3addr *hdr;\n\tstruct sk_buff *skb;\n\tsize_t ie_ssid_len;\n\tu8 *pos;\n\n\tsdata = vif_to_sdata(vif);\n\tlocal = sdata->local;\n\tie_ssid_len = 2 + ssid_len;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*hdr) +\n\t\t\t    ie_ssid_len + tailroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\thdr = (struct ieee80211_hdr_3addr *) skb_put(skb, sizeof(*hdr));\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(hdr->addr1);\n\tmemcpy(hdr->addr2, vif->addr, ETH_ALEN);\n\teth_broadcast_addr(hdr->addr3);\n\n\tpos = skb_put(skb, ie_ssid_len);\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = ssid_len;\n\tif (ssid_len)\n\t\tmemcpy(pos, ssid, ssid_len);\n\tpos += ssid_len;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_probereq_get);\n\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\trts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);\n\trts->duration = ieee80211_rts_duration(hw, vif, frame_len,\n\t\t\t\t\t       frame_txctl);\n\tmemcpy(rts->ra, hdr->addr1, sizeof(rts->ra));\n\tmemcpy(rts->ta, hdr->addr2, sizeof(rts->ta));\n}\nEXPORT_SYMBOL(ieee80211_rts_get);\n\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\tcts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);\n\tcts->duration = ieee80211_ctstoself_duration(hw, vif,\n\t\t\t\t\t\t     frame_len, frame_txctl);\n\tmemcpy(cts->ra, hdr->addr1, sizeof(cts->ra));\n}\nEXPORT_SYMBOL(ieee80211_ctstoself_get);\n\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_data tx;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ps_data *ps;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(vif);\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!chanctx_conf)\n\t\tgoto out;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct beacon_data *beacon =\n\t\t\t\trcu_dereference(sdata->u.ap.beacon);\n\n\t\tif (!beacon || !beacon->head)\n\t\t\tgoto out;\n\n\t\tps = &sdata->u.ap.ps;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tps = &sdata->u.mesh.ps;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (ps->dtim_count != 0 || !ps->dtim_bc_mc)\n\t\tgoto out; /* send buffered bc/mc only after DTIM beacon */\n\n\twhile (1) {\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tlocal->total_ps_buffered--;\n\n\t\tif (!skb_queue_empty(&ps->bc_buf) && skb->len >= 2) {\n\t\t\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *) skb->data;\n\t\t\t/* more buffered multicast/broadcast frames ==> set\n\t\t\t * MoreData flag in IEEE 802.11 header to inform PS\n\t\t\t * STAs */\n\t\t\thdr->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tsdata = IEEE80211_DEV_TO_SUB_IF(skb->dev);\n\t\tif (!ieee80211_tx_prepare(sdata, &tx, skb))\n\t\t\tbreak;\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\ttx.flags |= IEEE80211_TX_PS_BUFFERED;\n\tinfo->band = chanctx_conf->def.chan->band;\n\n\tif (invoke_tx_handlers(&tx))\n\t\tskb = NULL;\n out:\n\trcu_read_unlock();\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_buffered_bc);\n\nvoid __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb, int tid,\n\t\t\t\t enum ieee80211_band band)\n{\n\tint ac = ieee802_1d_to_ac[tid & 7];\n\n\tskb_set_mac_header(skb, 0);\n\tskb_set_network_header(skb, 0);\n\tskb_set_transport_header(skb, 0);\n\n\tskb_set_queue_mapping(skb, ac);\n\tskb->priority = tid;\n\n\tskb->dev = sdata->dev;\n\n\t/*\n\t * The other path calling ieee80211_xmit is from the tasklet,\n\t * and while we can handle concurrent transmissions locking\n\t * requirements are that we do not come into tx with bhs on.\n\t */\n\tlocal_bh_disable();\n\tieee80211_xmit(sdata, skb, band);\n\tlocal_bh_enable();\n}\n"], "filenames": ["net/mac80211/sta_info.c", "net/mac80211/sta_info.h", "net/mac80211/tx.c"], "buggy_code_start_loc": [332, 269, 480], "buggy_code_end_loc": [1130, 363, 494], "fixing_code_start_loc": [333, 270, 481], "fixing_code_end_loc": [1135, 362, 510], "type": "CWE-362", "message": "Race condition in the mac80211 subsystem in the Linux kernel before 3.13.7 allows remote attackers to cause a denial of service (system crash) via network traffic that improperly interacts with the WLAN_STA_PS_STA state (aka power-save mode), related to sta_info.c and tx.c.", "other": {"cve": {"id": "CVE-2014-2706", "sourceIdentifier": "cve@mitre.org", "published": "2014-04-14T23:55:07.700", "lastModified": "2023-05-19T16:50:46.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in the mac80211 subsystem in the Linux kernel before 3.13.7 allows remote attackers to cause a denial of service (system crash) via network traffic that improperly interacts with the WLAN_STA_PS_STA state (aka power-save mode), related to sta_info.c and tx.c."}, {"lang": "es", "value": "Condici\u00f3n de carrera en el subsistema mac80211 en el kernel de Linux anterior a 3.13.7 permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda de sistema) a trav\u00e9s de trafico de red que no interact\u00faa debidamente con el estado WLAN_STA_PS_STA (tambi\u00e9n conocido como el modo power-save), relacionado con sta_info.c y tx.c."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.56", "matchCriteriaId": "2A746AA8-CF9D-4203-BEE4-AA4662977375"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.4.84", "matchCriteriaId": "2869AF87-7E94-4E08-8EF9-8C62F663EC82"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.5", "versionEndExcluding": "3.10.34", "matchCriteriaId": "67836467-8BEF-44A1-B031-98EFBA19F38C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.15", "matchCriteriaId": "4AE2B033-586E-48AC-95DC-880018601DFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.13.7", "matchCriteriaId": "B13865A2-6E9A-4FFE-A1C2-02B75D66C207"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:-:*:*:*:*:*:*", "matchCriteriaId": "D7B037A8-72A6-4DFF-94B2-D688A5F6F876"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:7:-:*:*:*:*:*:*", "matchCriteriaId": "44B8FEDF-6CB0-46E9-9AD7-4445B001C158"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "A3A907A3-2A3A-46D4-8D75-914649877B65"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_desktop:11:sp3:*:*:*:-:*:*", "matchCriteriaId": "DD41513F-36F9-459C-A0CB-26C025E63CDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp3:*:*:*:-:*:*", "matchCriteriaId": "B2866FAF-4340-4EA7-9009-6594ADA27AF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp3:*:*:*:vmware:*:*", "matchCriteriaId": "0EA03350-8702-43D5-8605-5FB765A3F60B"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=1d147bfa64293b2723c4fec50922168658e613ba", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3052.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.13.7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/04/01/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/66591", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038201", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=70551#c18", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1083512", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-04-01", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba"}}