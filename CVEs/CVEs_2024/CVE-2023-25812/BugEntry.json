{"buggy_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"math\"\n\t\"net/http\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\tobjectlock \"github.com/minio/minio/internal/bucket/object/lock\"\n\t\"github.com/minio/minio/internal/bucket/replication\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/bucket/policy\"\n)\n\n// BucketObjectLockSys - map of bucket and retention configuration.\ntype BucketObjectLockSys struct{}\n\n// Get - Get retention configuration.\nfunc (sys *BucketObjectLockSys) Get(bucketName string) (r objectlock.Retention, err error) {\n\tconfig, _, err := globalBucketMetadataSys.GetObjectLockConfig(bucketName)\n\tif err != nil {\n\t\tif errors.Is(err, BucketObjectLockConfigNotFound{Bucket: bucketName}) {\n\t\t\treturn r, nil\n\t\t}\n\t\tif errors.Is(err, errInvalidArgument) {\n\t\t\treturn r, err\n\t\t}\n\t\tlogger.CriticalIf(context.Background(), err)\n\t\treturn r, err\n\t}\n\treturn config.ToRetention(), nil\n}\n\n// enforceRetentionForDeletion checks if it is appropriate to remove an\n// object according to locking configuration when this is lifecycle/ bucket quota asking.\nfunc enforceRetentionForDeletion(ctx context.Context, objInfo ObjectInfo) (locked bool) {\n\tif objInfo.DeleteMarker {\n\t\treturn false\n\t}\n\n\tlhold := objectlock.GetObjectLegalHoldMeta(objInfo.UserDefined)\n\tif lhold.Status.Valid() && lhold.Status == objectlock.LegalHoldOn {\n\t\treturn true\n\t}\n\n\tret := objectlock.GetObjectRetentionMeta(objInfo.UserDefined)\n\tif ret.Mode.Valid() && (ret.Mode == objectlock.RetCompliance || ret.Mode == objectlock.RetGovernance) {\n\t\tt, err := objectlock.UTCNowNTP()\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn true\n\t\t}\n\t\tif ret.RetainUntilDate.After(t) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// enforceRetentionBypassForDelete enforces whether an existing object under governance can be deleted\n// with governance bypass headers set in the request.\n// Objects under site wide WORM can never be overwritten.\n// For objects in \"Governance\" mode, overwrite is allowed if a) object retention date is past OR\n// governance bypass headers are set and user has governance bypass permissions.\n// Objects in \"Compliance\" mode can be overwritten only if retention date is past.\nfunc enforceRetentionBypassForDelete(ctx context.Context, r *http.Request, bucket string, object ObjectToDelete, oi ObjectInfo, gerr error) APIErrorCode {\n\topts, err := getOpts(ctx, r, bucket, object.ObjectName)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\n\topts.VersionID = object.VersionID\n\tif gerr != nil { // error from GetObjectInfo\n\t\tswitch gerr.(type) {\n\t\tcase MethodNotAllowed: // This happens usually for a delete marker\n\t\t\tif oi.DeleteMarker || !oi.VersionPurgeStatus.Empty() {\n\t\t\t\t// Delete marker should be present and valid.\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t}\n\t\tif isErrObjectNotFound(gerr) || isErrVersionNotFound(gerr) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn toAPIErrorCode(ctx, gerr)\n\t}\n\n\tlhold := objectlock.GetObjectLegalHoldMeta(oi.UserDefined)\n\tif lhold.Status.Valid() && lhold.Status == objectlock.LegalHoldOn {\n\t\treturn ErrObjectLocked\n\t}\n\n\tret := objectlock.GetObjectRetentionMeta(oi.UserDefined)\n\tif ret.Mode.Valid() {\n\t\tswitch ret.Mode {\n\t\tcase objectlock.RetCompliance:\n\t\t\t// In compliance mode, a protected object version can't be overwritten\n\t\t\t// or deleted by any user, including the root user in your AWS account.\n\t\t\t// When an object is locked in compliance mode, its retention mode can't\n\t\t\t// be changed, and its retention period can't be shortened. Compliance mode\n\t\t\t// ensures that an object version can't be overwritten or deleted for the\n\t\t\t// duration of the retention period.\n\t\t\tt, err := objectlock.UTCNowNTP()\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn ErrObjectLocked\n\t\t\t}\n\n\t\t\tif !ret.RetainUntilDate.Before(t) {\n\t\t\t\treturn ErrObjectLocked\n\t\t\t}\n\t\t\treturn ErrNone\n\t\tcase objectlock.RetGovernance:\n\t\t\t// In governance mode, users can't overwrite or delete an object\n\t\t\t// version or alter its lock settings unless they have special\n\t\t\t// permissions. With governance mode, you protect objects against\n\t\t\t// being deleted by most users, but you can still grant some users\n\t\t\t// permission to alter the retention settings or delete the object\n\t\t\t// if necessary. You can also use governance mode to test retention-period\n\t\t\t// settings before creating a compliance-mode retention period.\n\t\t\t// To override or remove governance-mode retention settings, a\n\t\t\t// user must have the s3:BypassGovernanceRetention permission\n\t\t\t// and must explicitly include x-amz-bypass-governance-retention:true\n\t\t\t// as a request header with any request that requires overriding\n\t\t\t// governance mode.\n\t\t\t//\n\t\t\tbyPassSet := objectlock.IsObjectLockGovernanceBypassSet(r.Header)\n\t\t\tif !byPassSet {\n\t\t\t\tt, err := objectlock.UTCNowNTP()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\t\treturn ErrObjectLocked\n\t\t\t\t}\n\n\t\t\t\tif !ret.RetainUntilDate.Before(t) {\n\t\t\t\t\treturn ErrObjectLocked\n\t\t\t\t}\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t\t// https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html#object-lock-retention-modes\n\t\t\t// If you try to delete objects protected by governance mode and have s3:BypassGovernanceRetention\n\t\t\t// or s3:GetBucketObjectLockConfiguration permissions, the operation will succeed.\n\t\t\tgovBypassPerms1 := checkRequestAuthType(ctx, r, policy.BypassGovernanceRetentionAction, bucket, object.ObjectName)\n\t\t\tgovBypassPerms2 := checkRequestAuthType(ctx, r, policy.GetBucketObjectLockConfigurationAction, bucket, object.ObjectName)\n\t\t\tif govBypassPerms1 != ErrNone && govBypassPerms2 != ErrNone {\n\t\t\t\treturn ErrAccessDenied\n\t\t\t}\n\t\t}\n\t}\n\treturn ErrNone\n}\n\n// enforceRetentionBypassForPut enforces whether an existing object under governance can be overwritten\n// with governance bypass headers set in the request.\n// Objects under site wide WORM cannot be overwritten.\n// For objects in \"Governance\" mode, overwrite is allowed if a) object retention date is past OR\n// governance bypass headers are set and user has governance bypass permissions.\n// Objects in compliance mode can be overwritten only if retention date is being extended. No mode change is permitted.\nfunc enforceRetentionBypassForPut(ctx context.Context, r *http.Request, oi ObjectInfo, objRetention *objectlock.ObjectRetention, cred auth.Credentials, owner bool) error {\n\tbyPassSet := objectlock.IsObjectLockGovernanceBypassSet(r.Header)\n\n\tt, err := objectlock.UTCNowNTP()\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\treturn ObjectLocked{Bucket: oi.Bucket, Object: oi.Name, VersionID: oi.VersionID}\n\t}\n\n\t// Pass in relative days from current time, to additionally\n\t// to verify \"object-lock-remaining-retention-days\" policy if any.\n\tdays := int(math.Ceil(math.Abs(objRetention.RetainUntilDate.Sub(t).Hours()) / 24))\n\n\tret := objectlock.GetObjectRetentionMeta(oi.UserDefined)\n\tif ret.Mode.Valid() {\n\t\t// Retention has expired you may change whatever you like.\n\t\tif ret.RetainUntilDate.Before(t) {\n\t\t\tapiErr := isPutRetentionAllowed(oi.Bucket, oi.Name,\n\t\t\t\tdays, objRetention.RetainUntilDate.Time,\n\t\t\t\tobjRetention.Mode, byPassSet, r, cred,\n\t\t\t\towner)\n\t\t\tswitch apiErr {\n\t\t\tcase ErrAccessDenied:\n\t\t\t\treturn errAuthentication\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch ret.Mode {\n\t\tcase objectlock.RetGovernance:\n\t\t\tgovPerm := isPutRetentionAllowed(oi.Bucket, oi.Name, days,\n\t\t\t\tobjRetention.RetainUntilDate.Time, objRetention.Mode,\n\t\t\t\tbyPassSet, r, cred, owner)\n\t\t\t// Governance mode retention period cannot be shortened, if x-amz-bypass-governance is not set.\n\t\t\tif !byPassSet {\n\t\t\t\tif objRetention.Mode != objectlock.RetGovernance || objRetention.RetainUntilDate.Before((ret.RetainUntilDate.Time)) {\n\t\t\t\t\treturn ObjectLocked{Bucket: oi.Bucket, Object: oi.Name, VersionID: oi.VersionID}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch govPerm {\n\t\t\tcase ErrAccessDenied:\n\t\t\t\treturn errAuthentication\n\t\t\t}\n\t\t\treturn nil\n\t\tcase objectlock.RetCompliance:\n\t\t\t// Compliance retention mode cannot be changed or shortened.\n\t\t\t// https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html#object-lock-retention-modes\n\t\t\tif objRetention.Mode != objectlock.RetCompliance || objRetention.RetainUntilDate.Before((ret.RetainUntilDate.Time)) {\n\t\t\t\treturn ObjectLocked{Bucket: oi.Bucket, Object: oi.Name, VersionID: oi.VersionID}\n\t\t\t}\n\t\t\tapiErr := isPutRetentionAllowed(oi.Bucket, oi.Name,\n\t\t\t\tdays, objRetention.RetainUntilDate.Time, objRetention.Mode,\n\t\t\t\tfalse, r, cred, owner)\n\t\t\tswitch apiErr {\n\t\t\tcase ErrAccessDenied:\n\t\t\t\treturn errAuthentication\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treturn nil\n\t} // No pre-existing retention metadata present.\n\n\tapiErr := isPutRetentionAllowed(oi.Bucket, oi.Name,\n\t\tdays, objRetention.RetainUntilDate.Time,\n\t\tobjRetention.Mode, byPassSet, r, cred, owner)\n\tswitch apiErr {\n\tcase ErrAccessDenied:\n\t\treturn errAuthentication\n\t}\n\treturn nil\n}\n\n// checkPutObjectLockAllowed enforces object retention policy and legal hold policy\n// for requests with WORM headers\n// See https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-managing.html for the spec.\n// For non-existing objects with object retention headers set, this method returns ErrNone if bucket has\n// locking enabled and user has requisite permissions (s3:PutObjectRetention)\n// If object exists on object store and site wide WORM enabled - this method\n// returns an error. For objects in \"Governance\" mode, overwrite is allowed if the retention date has expired.\n// For objects in \"Compliance\" mode, retention date cannot be shortened, and mode cannot be altered.\n// For objects with legal hold header set, the s3:PutObjectLegalHold permission is expected to be set\n// Both legal hold and retention can be applied independently on an object\nfunc checkPutObjectLockAllowed(ctx context.Context, rq *http.Request, bucket, object string, getObjectInfoFn GetObjectInfoFn, retentionPermErr, legalHoldPermErr APIErrorCode) (objectlock.RetMode, objectlock.RetentionDate, objectlock.ObjectLegalHold, APIErrorCode) {\n\tvar mode objectlock.RetMode\n\tvar retainDate objectlock.RetentionDate\n\tvar legalHold objectlock.ObjectLegalHold\n\n\tretentionRequested := objectlock.IsObjectLockRetentionRequested(rq.Header)\n\tlegalHoldRequested := objectlock.IsObjectLockLegalHoldRequested(rq.Header)\n\n\tretentionCfg, err := globalBucketObjectLockSys.Get(bucket)\n\tif err != nil {\n\t\treturn mode, retainDate, legalHold, ErrInvalidBucketObjectLockConfiguration\n\t}\n\n\tif !retentionCfg.LockEnabled {\n\t\tif legalHoldRequested || retentionRequested {\n\t\t\treturn mode, retainDate, legalHold, ErrInvalidBucketObjectLockConfiguration\n\t\t}\n\n\t\t// If this not a WORM enabled bucket, we should return right here.\n\t\treturn mode, retainDate, legalHold, ErrNone\n\t}\n\n\topts, err := getOpts(ctx, rq, bucket, object)\n\tif err != nil {\n\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t}\n\n\treplica := rq.Header.Get(xhttp.AmzBucketReplicationStatus) == replication.Replica.String()\n\n\tif opts.VersionID != \"\" && !replica {\n\t\tif objInfo, err := getObjectInfoFn(ctx, bucket, object, opts); err == nil {\n\t\t\tr := objectlock.GetObjectRetentionMeta(objInfo.UserDefined)\n\t\t\tt, err := objectlock.UTCNowNTP()\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t\t}\n\t\t\tif r.Mode == objectlock.RetCompliance && r.RetainUntilDate.After(t) {\n\t\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t\t}\n\t\t\tmode = r.Mode\n\t\t\tretainDate = r.RetainUntilDate\n\t\t\tlegalHold = objectlock.GetObjectLegalHoldMeta(objInfo.UserDefined)\n\t\t\t// Disallow overwriting an object on legal hold\n\t\t\tif legalHold.Status == objectlock.LegalHoldOn {\n\t\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t\t}\n\t\t}\n\t}\n\n\tif legalHoldRequested {\n\t\tvar lerr error\n\t\tif legalHold, lerr = objectlock.ParseObjectLockLegalHoldHeaders(rq.Header); lerr != nil {\n\t\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t\t}\n\t}\n\n\tif retentionRequested {\n\t\tlegalHold, err := objectlock.ParseObjectLockLegalHoldHeaders(rq.Header)\n\t\tif err != nil {\n\t\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t\t}\n\t\trMode, rDate, err := objectlock.ParseObjectLockRetentionHeaders(rq.Header)\n\t\tif err != nil {\n\t\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t\t}\n\t\tif retentionPermErr != ErrNone {\n\t\t\treturn mode, retainDate, legalHold, retentionPermErr\n\t\t}\n\t\treturn rMode, rDate, legalHold, ErrNone\n\t}\n\tif replica { // replica inherits retention metadata only from source\n\t\treturn \"\", objectlock.RetentionDate{}, legalHold, ErrNone\n\t}\n\tif !retentionRequested && retentionCfg.Validity > 0 {\n\t\tif retentionPermErr != ErrNone {\n\t\t\treturn mode, retainDate, legalHold, retentionPermErr\n\t\t}\n\n\t\tt, err := objectlock.UTCNowNTP()\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t}\n\n\t\tif !legalHoldRequested && retentionCfg.LockEnabled {\n\t\t\t// inherit retention from bucket configuration\n\t\t\treturn retentionCfg.Mode, objectlock.RetentionDate{Time: t.Add(retentionCfg.Validity)}, legalHold, ErrNone\n\t\t}\n\t\treturn \"\", objectlock.RetentionDate{}, legalHold, ErrNone\n\t}\n\treturn mode, retainDate, legalHold, ErrNone\n}\n\n// NewBucketObjectLockSys returns initialized BucketObjectLockSys\nfunc NewBucketObjectLockSys() *BucketObjectLockSys {\n\treturn &BucketObjectLockSys{}\n}\n"], "fixing_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"math\"\n\t\"net/http\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\tobjectlock \"github.com/minio/minio/internal/bucket/object/lock\"\n\t\"github.com/minio/minio/internal/bucket/replication\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/pkg/bucket/policy\"\n)\n\n// BucketObjectLockSys - map of bucket and retention configuration.\ntype BucketObjectLockSys struct{}\n\n// Get - Get retention configuration.\nfunc (sys *BucketObjectLockSys) Get(bucketName string) (r objectlock.Retention, err error) {\n\tconfig, _, err := globalBucketMetadataSys.GetObjectLockConfig(bucketName)\n\tif err != nil {\n\t\tif errors.Is(err, BucketObjectLockConfigNotFound{Bucket: bucketName}) {\n\t\t\treturn r, nil\n\t\t}\n\t\tif errors.Is(err, errInvalidArgument) {\n\t\t\treturn r, err\n\t\t}\n\t\tlogger.CriticalIf(context.Background(), err)\n\t\treturn r, err\n\t}\n\treturn config.ToRetention(), nil\n}\n\n// enforceRetentionForDeletion checks if it is appropriate to remove an\n// object according to locking configuration when this is lifecycle/ bucket quota asking.\nfunc enforceRetentionForDeletion(ctx context.Context, objInfo ObjectInfo) (locked bool) {\n\tif objInfo.DeleteMarker {\n\t\treturn false\n\t}\n\n\tlhold := objectlock.GetObjectLegalHoldMeta(objInfo.UserDefined)\n\tif lhold.Status.Valid() && lhold.Status == objectlock.LegalHoldOn {\n\t\treturn true\n\t}\n\n\tret := objectlock.GetObjectRetentionMeta(objInfo.UserDefined)\n\tif ret.Mode.Valid() && (ret.Mode == objectlock.RetCompliance || ret.Mode == objectlock.RetGovernance) {\n\t\tt, err := objectlock.UTCNowNTP()\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn true\n\t\t}\n\t\tif ret.RetainUntilDate.After(t) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// enforceRetentionBypassForDelete enforces whether an existing object under governance can be deleted\n// with governance bypass headers set in the request.\n// Objects under site wide WORM can never be overwritten.\n// For objects in \"Governance\" mode, overwrite is allowed if a) object retention date is past OR\n// governance bypass headers are set and user has governance bypass permissions.\n// Objects in \"Compliance\" mode can be overwritten only if retention date is past.\nfunc enforceRetentionBypassForDelete(ctx context.Context, r *http.Request, bucket string, object ObjectToDelete, oi ObjectInfo, gerr error) APIErrorCode {\n\topts, err := getOpts(ctx, r, bucket, object.ObjectName)\n\tif err != nil {\n\t\treturn toAPIErrorCode(ctx, err)\n\t}\n\n\topts.VersionID = object.VersionID\n\tif gerr != nil { // error from GetObjectInfo\n\t\tswitch gerr.(type) {\n\t\tcase MethodNotAllowed: // This happens usually for a delete marker\n\t\t\tif oi.DeleteMarker || !oi.VersionPurgeStatus.Empty() {\n\t\t\t\t// Delete marker should be present and valid.\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t}\n\t\tif isErrObjectNotFound(gerr) || isErrVersionNotFound(gerr) {\n\t\t\treturn ErrNone\n\t\t}\n\t\treturn toAPIErrorCode(ctx, gerr)\n\t}\n\n\tlhold := objectlock.GetObjectLegalHoldMeta(oi.UserDefined)\n\tif lhold.Status.Valid() && lhold.Status == objectlock.LegalHoldOn {\n\t\treturn ErrObjectLocked\n\t}\n\n\tret := objectlock.GetObjectRetentionMeta(oi.UserDefined)\n\tif ret.Mode.Valid() {\n\t\tswitch ret.Mode {\n\t\tcase objectlock.RetCompliance:\n\t\t\t// In compliance mode, a protected object version can't be overwritten\n\t\t\t// or deleted by any user, including the root user in your AWS account.\n\t\t\t// When an object is locked in compliance mode, its retention mode can't\n\t\t\t// be changed, and its retention period can't be shortened. Compliance mode\n\t\t\t// ensures that an object version can't be overwritten or deleted for the\n\t\t\t// duration of the retention period.\n\t\t\tt, err := objectlock.UTCNowNTP()\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn ErrObjectLocked\n\t\t\t}\n\n\t\t\tif !ret.RetainUntilDate.Before(t) {\n\t\t\t\treturn ErrObjectLocked\n\t\t\t}\n\t\t\treturn ErrNone\n\t\tcase objectlock.RetGovernance:\n\t\t\t// In governance mode, users can't overwrite or delete an object\n\t\t\t// version or alter its lock settings unless they have special\n\t\t\t// permissions. With governance mode, you protect objects against\n\t\t\t// being deleted by most users, but you can still grant some users\n\t\t\t// permission to alter the retention settings or delete the object\n\t\t\t// if necessary. You can also use governance mode to test retention-period\n\t\t\t// settings before creating a compliance-mode retention period.\n\t\t\t// To override or remove governance-mode retention settings, a\n\t\t\t// user must have the s3:BypassGovernanceRetention permission\n\t\t\t// and must explicitly include x-amz-bypass-governance-retention:true\n\t\t\t// as a request header with any request that requires overriding\n\t\t\t// governance mode.\n\t\t\t//\n\t\t\tbyPassSet := objectlock.IsObjectLockGovernanceBypassSet(r.Header)\n\t\t\tif !byPassSet {\n\t\t\t\tt, err := objectlock.UTCNowNTP()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\t\treturn ErrObjectLocked\n\t\t\t\t}\n\n\t\t\t\tif !ret.RetainUntilDate.Before(t) {\n\t\t\t\t\treturn ErrObjectLocked\n\t\t\t\t}\n\t\t\t\treturn ErrNone\n\t\t\t}\n\t\t\t// https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html#object-lock-retention-modes\n\t\t\t// If you try to delete objects protected by governance mode and have s3:BypassGovernanceRetention, the operation will succeed.\n\t\t\tif checkRequestAuthType(ctx, r, policy.BypassGovernanceRetentionAction, bucket, object.ObjectName) != ErrNone {\n\t\t\t\treturn ErrAccessDenied\n\t\t\t}\n\t\t}\n\t}\n\treturn ErrNone\n}\n\n// enforceRetentionBypassForPut enforces whether an existing object under governance can be overwritten\n// with governance bypass headers set in the request.\n// Objects under site wide WORM cannot be overwritten.\n// For objects in \"Governance\" mode, overwrite is allowed if a) object retention date is past OR\n// governance bypass headers are set and user has governance bypass permissions.\n// Objects in compliance mode can be overwritten only if retention date is being extended. No mode change is permitted.\nfunc enforceRetentionBypassForPut(ctx context.Context, r *http.Request, oi ObjectInfo, objRetention *objectlock.ObjectRetention, cred auth.Credentials, owner bool) error {\n\tbyPassSet := objectlock.IsObjectLockGovernanceBypassSet(r.Header)\n\n\tt, err := objectlock.UTCNowNTP()\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\treturn ObjectLocked{Bucket: oi.Bucket, Object: oi.Name, VersionID: oi.VersionID}\n\t}\n\n\t// Pass in relative days from current time, to additionally\n\t// to verify \"object-lock-remaining-retention-days\" policy if any.\n\tdays := int(math.Ceil(math.Abs(objRetention.RetainUntilDate.Sub(t).Hours()) / 24))\n\n\tret := objectlock.GetObjectRetentionMeta(oi.UserDefined)\n\tif ret.Mode.Valid() {\n\t\t// Retention has expired you may change whatever you like.\n\t\tif ret.RetainUntilDate.Before(t) {\n\t\t\tapiErr := isPutRetentionAllowed(oi.Bucket, oi.Name,\n\t\t\t\tdays, objRetention.RetainUntilDate.Time,\n\t\t\t\tobjRetention.Mode, byPassSet, r, cred,\n\t\t\t\towner)\n\t\t\tswitch apiErr {\n\t\t\tcase ErrAccessDenied:\n\t\t\t\treturn errAuthentication\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch ret.Mode {\n\t\tcase objectlock.RetGovernance:\n\t\t\tgovPerm := isPutRetentionAllowed(oi.Bucket, oi.Name, days,\n\t\t\t\tobjRetention.RetainUntilDate.Time, objRetention.Mode,\n\t\t\t\tbyPassSet, r, cred, owner)\n\t\t\t// Governance mode retention period cannot be shortened, if x-amz-bypass-governance is not set.\n\t\t\tif !byPassSet {\n\t\t\t\tif objRetention.Mode != objectlock.RetGovernance || objRetention.RetainUntilDate.Before((ret.RetainUntilDate.Time)) {\n\t\t\t\t\treturn ObjectLocked{Bucket: oi.Bucket, Object: oi.Name, VersionID: oi.VersionID}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch govPerm {\n\t\t\tcase ErrAccessDenied:\n\t\t\t\treturn errAuthentication\n\t\t\t}\n\t\t\treturn nil\n\t\tcase objectlock.RetCompliance:\n\t\t\t// Compliance retention mode cannot be changed or shortened.\n\t\t\t// https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html#object-lock-retention-modes\n\t\t\tif objRetention.Mode != objectlock.RetCompliance || objRetention.RetainUntilDate.Before((ret.RetainUntilDate.Time)) {\n\t\t\t\treturn ObjectLocked{Bucket: oi.Bucket, Object: oi.Name, VersionID: oi.VersionID}\n\t\t\t}\n\t\t\tapiErr := isPutRetentionAllowed(oi.Bucket, oi.Name,\n\t\t\t\tdays, objRetention.RetainUntilDate.Time, objRetention.Mode,\n\t\t\t\tfalse, r, cred, owner)\n\t\t\tswitch apiErr {\n\t\t\tcase ErrAccessDenied:\n\t\t\t\treturn errAuthentication\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treturn nil\n\t} // No pre-existing retention metadata present.\n\n\tapiErr := isPutRetentionAllowed(oi.Bucket, oi.Name,\n\t\tdays, objRetention.RetainUntilDate.Time,\n\t\tobjRetention.Mode, byPassSet, r, cred, owner)\n\tswitch apiErr {\n\tcase ErrAccessDenied:\n\t\treturn errAuthentication\n\t}\n\treturn nil\n}\n\n// checkPutObjectLockAllowed enforces object retention policy and legal hold policy\n// for requests with WORM headers\n// See https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-managing.html for the spec.\n// For non-existing objects with object retention headers set, this method returns ErrNone if bucket has\n// locking enabled and user has requisite permissions (s3:PutObjectRetention)\n// If object exists on object store and site wide WORM enabled - this method\n// returns an error. For objects in \"Governance\" mode, overwrite is allowed if the retention date has expired.\n// For objects in \"Compliance\" mode, retention date cannot be shortened, and mode cannot be altered.\n// For objects with legal hold header set, the s3:PutObjectLegalHold permission is expected to be set\n// Both legal hold and retention can be applied independently on an object\nfunc checkPutObjectLockAllowed(ctx context.Context, rq *http.Request, bucket, object string, getObjectInfoFn GetObjectInfoFn, retentionPermErr, legalHoldPermErr APIErrorCode) (objectlock.RetMode, objectlock.RetentionDate, objectlock.ObjectLegalHold, APIErrorCode) {\n\tvar mode objectlock.RetMode\n\tvar retainDate objectlock.RetentionDate\n\tvar legalHold objectlock.ObjectLegalHold\n\n\tretentionRequested := objectlock.IsObjectLockRetentionRequested(rq.Header)\n\tlegalHoldRequested := objectlock.IsObjectLockLegalHoldRequested(rq.Header)\n\n\tretentionCfg, err := globalBucketObjectLockSys.Get(bucket)\n\tif err != nil {\n\t\treturn mode, retainDate, legalHold, ErrInvalidBucketObjectLockConfiguration\n\t}\n\n\tif !retentionCfg.LockEnabled {\n\t\tif legalHoldRequested || retentionRequested {\n\t\t\treturn mode, retainDate, legalHold, ErrInvalidBucketObjectLockConfiguration\n\t\t}\n\n\t\t// If this not a WORM enabled bucket, we should return right here.\n\t\treturn mode, retainDate, legalHold, ErrNone\n\t}\n\n\topts, err := getOpts(ctx, rq, bucket, object)\n\tif err != nil {\n\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t}\n\n\treplica := rq.Header.Get(xhttp.AmzBucketReplicationStatus) == replication.Replica.String()\n\n\tif opts.VersionID != \"\" && !replica {\n\t\tif objInfo, err := getObjectInfoFn(ctx, bucket, object, opts); err == nil {\n\t\t\tr := objectlock.GetObjectRetentionMeta(objInfo.UserDefined)\n\t\t\tt, err := objectlock.UTCNowNTP()\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t\t}\n\t\t\tif r.Mode == objectlock.RetCompliance && r.RetainUntilDate.After(t) {\n\t\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t\t}\n\t\t\tmode = r.Mode\n\t\t\tretainDate = r.RetainUntilDate\n\t\t\tlegalHold = objectlock.GetObjectLegalHoldMeta(objInfo.UserDefined)\n\t\t\t// Disallow overwriting an object on legal hold\n\t\t\tif legalHold.Status == objectlock.LegalHoldOn {\n\t\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t\t}\n\t\t}\n\t}\n\n\tif legalHoldRequested {\n\t\tvar lerr error\n\t\tif legalHold, lerr = objectlock.ParseObjectLockLegalHoldHeaders(rq.Header); lerr != nil {\n\t\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t\t}\n\t}\n\n\tif retentionRequested {\n\t\tlegalHold, err := objectlock.ParseObjectLockLegalHoldHeaders(rq.Header)\n\t\tif err != nil {\n\t\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t\t}\n\t\trMode, rDate, err := objectlock.ParseObjectLockRetentionHeaders(rq.Header)\n\t\tif err != nil {\n\t\t\treturn mode, retainDate, legalHold, toAPIErrorCode(ctx, err)\n\t\t}\n\t\tif retentionPermErr != ErrNone {\n\t\t\treturn mode, retainDate, legalHold, retentionPermErr\n\t\t}\n\t\treturn rMode, rDate, legalHold, ErrNone\n\t}\n\tif replica { // replica inherits retention metadata only from source\n\t\treturn \"\", objectlock.RetentionDate{}, legalHold, ErrNone\n\t}\n\tif !retentionRequested && retentionCfg.Validity > 0 {\n\t\tif retentionPermErr != ErrNone {\n\t\t\treturn mode, retainDate, legalHold, retentionPermErr\n\t\t}\n\n\t\tt, err := objectlock.UTCNowNTP()\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\treturn mode, retainDate, legalHold, ErrObjectLocked\n\t\t}\n\n\t\tif !legalHoldRequested && retentionCfg.LockEnabled {\n\t\t\t// inherit retention from bucket configuration\n\t\t\treturn retentionCfg.Mode, objectlock.RetentionDate{Time: t.Add(retentionCfg.Validity)}, legalHold, ErrNone\n\t\t}\n\t\treturn \"\", objectlock.RetentionDate{}, legalHold, ErrNone\n\t}\n\treturn mode, retainDate, legalHold, ErrNone\n}\n\n// NewBucketObjectLockSys returns initialized BucketObjectLockSys\nfunc NewBucketObjectLockSys() *BucketObjectLockSys {\n\treturn &BucketObjectLockSys{}\n}\n"], "filenames": ["cmd/bucket-object-lock.go"], "buggy_code_start_loc": [159], "buggy_code_end_loc": [164], "fixing_code_start_loc": [159], "fixing_code_end_loc": [161], "type": "NVD-CWE-noinfo", "message": "Minio is a Multi-Cloud Object Storage framework. Affected versions do not correctly honor a `Deny` policy on ByPassGoverance. Ideally, minio should return \"Access Denied\" to all users attempting to DELETE a versionId with the special header `X-Amz-Bypass-Governance-Retention: true`. However, this was not honored instead the request will be honored and an object under governance would be incorrectly deleted. All users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-25812", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-21T21:15:11.507", "lastModified": "2023-03-07T22:32:11.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Minio is a Multi-Cloud Object Storage framework. Affected versions do not correctly honor a `Deny` policy on ByPassGoverance. Ideally, minio should return \"Access Denied\" to all users attempting to DELETE a versionId with the special header `X-Amz-Bypass-Governance-Retention: true`. However, this was not honored instead the request will be honored and an object under governance would be incorrectly deleted. All users are advised to upgrade. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-281"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionStartIncluding": "2020-04-10t03-34-42z", "versionEndExcluding": "2023-02-17t17-52-43z", "matchCriteriaId": "451D6DA1-D25A-46A8-822B-D0A78D65C642"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/a7188bc9d0f0a5ae05aaf1b8126bcd3cb3fdc485", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/minio/minio/pull/16635", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-c8fc-mjj8-fc63", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/a7188bc9d0f0a5ae05aaf1b8126bcd3cb3fdc485"}}