{"buggy_code": ["// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information\n\nnamespace Dnn.PersonaBar.Servers.Services\n{\n    using System;\n    using System.IO;\n    using System.Net;\n    using System.Net.Http;\n    using System.Web.Http;\n\n    using Dnn.PersonaBar.Library;\n    using Dnn.PersonaBar.Library.Attributes;\n    using Dnn.PersonaBar.Servers.Components.Log;\n    using DotNetNuke.Common;\n    using DotNetNuke.Data;\n    using DotNetNuke.Instrumentation;\n\n    [MenuPermission(Scope = ServiceScope.Host)]\n    public class ServerSettingsLogsController : PersonaBarApiController\n    {\n        private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ServerSettingsLogsController));\n        private readonly LogController _logController = new LogController();\n\n        [HttpGet]\n        public HttpResponseMessage GetLogs()\n        {\n            try\n            {\n                var response = new\n                {\n                    Success = true,\n                    Results = new\n                    {\n                        LogList = this._logController.GetLogFilesList(),\n                        UpgradeLogList = this._logController.GetUpgradeLogList(),\n                    },\n                    TotalResults = 1,\n                };\n                return this.Request.CreateResponse(HttpStatusCode.OK, response);\n            }\n            catch (Exception exc)\n            {\n                Logger.Error(exc);\n                return this.Request.CreateErrorResponse(HttpStatusCode.InternalServerError, exc);\n            }\n        }\n\n        [HttpGet]\n        public HttpResponseMessage GetLogFile(string fileName)\n        {\n            try\n            {\n                var logFilePath = Path.Combine(Globals.ApplicationMapPath, @\"portals\\_default\\logs\", fileName);\n                return this.CreateLogFileResponse(logFilePath);\n            }\n            catch (ArgumentException exc)\n            {\n                return this.Request.CreateErrorResponse(HttpStatusCode.BadRequest, exc.Message);\n            }\n            catch (Exception exc)\n            {\n                Logger.Error(exc);\n                return this.Request.CreateErrorResponse(HttpStatusCode.InternalServerError, exc);\n            }\n        }\n\n        [HttpGet]\n        public HttpResponseMessage GetUpgradeLogFile(string logName)\n        {\n            try\n            {\n                var providerPath = DataProvider.Instance().GetProviderPath();\n                var logFilePath = Path.Combine(providerPath, logName);\n                return this.CreateLogFileResponse(logFilePath);\n            }\n            catch (ArgumentException exc)\n            {\n                return this.Request.CreateErrorResponse(HttpStatusCode.BadRequest, exc.Message);\n            }\n            catch (Exception exc)\n            {\n                Logger.Error(exc);\n                return this.Request.CreateErrorResponse(HttpStatusCode.InternalServerError, exc);\n            }\n        }\n\n        [NonAction]\n        private static void ValidateFilePath(string physicalPath)\n        {\n            var fileInfo = new FileInfo(physicalPath);\n            if (!fileInfo.DirectoryName.StartsWith(Globals.ApplicationMapPath, StringComparison.InvariantCultureIgnoreCase))\n            {\n                throw new ArgumentException(\"Invalid File Path\");\n            }\n        }\n\n        [NonAction]\n        private HttpResponseMessage CreateLogFileResponse(string logFilePath)\n        {\n            ValidateFilePath(logFilePath);\n            if (!File.Exists(logFilePath))\n            {\n                return this.Request.CreateResponse(HttpStatusCode.NotFound);\n\n            }\n\n            using (var reader = File.OpenText(logFilePath))\n            {\n                var logText = reader.ReadToEnd();\n                return this.Request.CreateResponse(HttpStatusCode.OK, logText);\n            }\n        }\n    }\n}\n"], "fixing_code": ["// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information\n\nnamespace Dnn.PersonaBar.Servers.Services\n{\n    using System;\n    using System.IO;\n    using System.Net;\n    using System.Net.Http;\n    using System.Web.Http;\n\n    using Dnn.PersonaBar.Library;\n    using Dnn.PersonaBar.Library.Attributes;\n    using Dnn.PersonaBar.Servers.Components.Log;\n    using DotNetNuke.Common;\n    using DotNetNuke.Data;\n    using DotNetNuke.Instrumentation;\n\n    [MenuPermission(Scope = ServiceScope.Host)]\n    public class ServerSettingsLogsController : PersonaBarApiController\n    {\n        private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ServerSettingsLogsController));\n        private readonly LogController _logController = new LogController();\n\n        [HttpGet]\n        public HttpResponseMessage GetLogs()\n        {\n            try\n            {\n                var response = new\n                {\n                    Success = true,\n                    Results = new\n                    {\n                        LogList = this._logController.GetLogFilesList(),\n                        UpgradeLogList = this._logController.GetUpgradeLogList(),\n                    },\n                    TotalResults = 1,\n                };\n                return this.Request.CreateResponse(HttpStatusCode.OK, response);\n            }\n            catch (Exception exc)\n            {\n                Logger.Error(exc);\n                return this.Request.CreateErrorResponse(HttpStatusCode.InternalServerError, exc);\n            }\n        }\n\n        [HttpGet]\n        public HttpResponseMessage GetLogFile(string fileName)\n        {\n            try\n            {\n                var cleanedFileName = Path.GetFileName(fileName);\n                var logFilePath = Path.Combine(Globals.ApplicationMapPath, @\"portals\\_default\\logs\", cleanedFileName);\n                return this.CreateLogFileResponse(logFilePath);\n            }\n            catch (ArgumentException exc)\n            {\n                return this.Request.CreateErrorResponse(HttpStatusCode.BadRequest, exc.Message);\n            }\n            catch (Exception exc)\n            {\n                Logger.Error(exc);\n                return this.Request.CreateErrorResponse(HttpStatusCode.InternalServerError, exc);\n            }\n        }\n\n        [HttpGet]\n        public HttpResponseMessage GetUpgradeLogFile(string logName)\n        {\n            try\n            {\n                var providerPath = DataProvider.Instance().GetProviderPath();\n                var cleanedLogName = Path.GetFileName(logName);\n                var logFilePath = Path.Combine(providerPath, cleanedLogName);\n                return this.CreateLogFileResponse(logFilePath);\n            }\n            catch (ArgumentException exc)\n            {\n                return this.Request.CreateErrorResponse(HttpStatusCode.BadRequest, exc.Message);\n            }\n            catch (Exception exc)\n            {\n                Logger.Error(exc);\n                return this.Request.CreateErrorResponse(HttpStatusCode.InternalServerError, exc);\n            }\n        }\n\n        [NonAction]\n        private static void ValidateFilePath(string physicalPath)\n        {\n            var fileInfo = new FileInfo(physicalPath);\n            if (!fileInfo.DirectoryName.StartsWith(Globals.ApplicationMapPath, StringComparison.InvariantCultureIgnoreCase))\n            {\n                throw new ArgumentException(\"Invalid File Path\");\n            }\n        }\n\n        [NonAction]\n        private HttpResponseMessage CreateLogFileResponse(string logFilePath)\n        {\n            ValidateFilePath(logFilePath);\n            if (!File.Exists(logFilePath))\n            {\n                return this.Request.CreateResponse(HttpStatusCode.NotFound);\n\n            }\n\n            using (var reader = File.OpenText(logFilePath))\n            {\n                var logText = reader.ReadToEnd();\n                return this.Request.CreateResponse(HttpStatusCode.OK, logText);\n            }\n        }\n    }\n}\n"], "filenames": ["Dnn.AdminExperience/Dnn.PersonaBar.Extensions/Services/ServerSettingsLogsController.cs"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [76], "fixing_code_start_loc": [55], "fixing_code_end_loc": [78], "type": "CWE-22", "message": "Relative Path Traversal in GitHub repository dnnsoftware/dnn.platform prior to 9.11.0.", "other": {"cve": {"id": "CVE-2022-2922", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-30T07:15:08.543", "lastModified": "2022-10-04T16:24:30.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Relative Path Traversal in GitHub repository dnnsoftware/dnn.platform prior to 9.11.0."}, {"lang": "es", "value": "Un Salto de Ruta Relativo en el repositorio de GitHub dnnsoftware/dnn.platform versiones anteriores a 9.11.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-23"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dnnsoftware:dotnetnuke:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.11.0", "matchCriteriaId": "69790179-BFEE-41C7-8C8F-664071E78B20"}]}]}], "references": [{"url": "https://github.com/dnnsoftware/dnn.platform/commit/9b17351592fbde376506ba6705dbcc7a74a2a195", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/74918f40-dc11-4218-abef-064eb71a0703", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dnnsoftware/dnn.platform/commit/9b17351592fbde376506ba6705dbcc7a74a2a195"}}