{"buggy_code": ["\n'use strict';\n\nconst async = require('async');\nconst validator = require('validator');\n\nconst utils = require('../utils');\nconst meta = require('../meta');\nconst db = require('../database');\nconst groups = require('../groups');\nconst plugins = require('../plugins');\n\nmodule.exports = function (User) {\n\tUser.updateProfile = async function (uid, data) {\n\t\tlet fields = [\n\t\t\t'username', 'email', 'fullname', 'website', 'location',\n\t\t\t'groupTitle', 'birthday', 'signature', 'aboutme',\n\t\t];\n\t\tif (!data.uid) {\n\t\t\tthrow new Error('[[error:invalid-update-uid]]');\n\t\t}\n\t\tconst updateUid = data.uid;\n\n\t\tconst result = await plugins.fireHook('filter:user.updateProfile', { uid: uid, data: data, fields: fields });\n\t\tfields = result.fields;\n\t\tdata = result.data;\n\n\t\tawait validateData(uid, data);\n\n\t\tconst oldData = await User.getUserFields(updateUid, fields);\n\n\t\tawait async.each(fields, async function (field) {\n\t\t\tif (!(data[field] !== undefined && typeof data[field] === 'string')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata[field] = data[field].trim();\n\n\t\t\tif (field === 'email') {\n\t\t\t\treturn await updateEmail(updateUid, data.email);\n\t\t\t} else if (field === 'username') {\n\t\t\t\treturn await updateUsername(updateUid, data.username);\n\t\t\t} else if (field === 'fullname') {\n\t\t\t\treturn await updateFullname(updateUid, data.fullname);\n\t\t\t}\n\n\t\t\tawait User.setUserField(updateUid, field, data[field]);\n\t\t});\n\t\tplugins.fireHook('action:user.updateProfile', { uid: uid, data: data, fields: fields, oldData: oldData });\n\t\treturn await User.getUserFields(updateUid, ['email', 'username', 'userslug', 'picture', 'icon:text', 'icon:bgColor']);\n\t};\n\n\tasync function validateData(callerUid, data) {\n\t\tawait isEmailAvailable(data, data.uid);\n\t\tawait isUsernameAvailable(data, data.uid);\n\t\tawait isWebsiteValid(callerUid, data);\n\t\tawait isAboutMeValid(callerUid, data);\n\t\tawait isSignatureValid(callerUid, data);\n\t\tisFullnameValid(data);\n\t\tisLocationValid(data);\n\t\tisBirthdayValid(data);\n\t\tisGroupTitleValid(data);\n\t}\n\n\tasync function isEmailAvailable(data, uid) {\n\t\tif (!data.email) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!utils.isEmailValid(data.email)) {\n\t\t\tthrow new Error('[[error:invalid-email]]');\n\t\t}\n\t\tconst email = await User.getUserField(uid, 'email');\n\t\tif (email === data.email) {\n\t\t\treturn;\n\t\t}\n\t\tconst available = await User.email.available(data.email);\n\t\tif (!available) {\n\t\t\tthrow new Error('[[error:email-taken]]');\n\t\t}\n\t}\n\n\tasync function isUsernameAvailable(data, uid) {\n\t\tif (!data.username) {\n\t\t\treturn;\n\t\t}\n\t\tdata.username = data.username.trim();\n\t\tconst userData = await User.getUserFields(uid, ['username', 'userslug']);\n\t\tvar userslug = utils.slugify(data.username);\n\n\t\tif (data.username.length < meta.config.minimumUsernameLength) {\n\t\t\tthrow new Error('[[error:username-too-short]]');\n\t\t}\n\n\t\tif (data.username.length > meta.config.maximumUsernameLength) {\n\t\t\tthrow new Error('[[error:username-too-long]]');\n\t\t}\n\n\t\tif (!utils.isUserNameValid(data.username) || !userslug) {\n\t\t\tthrow new Error('[[error:invalid-username]]');\n\t\t}\n\n\t\tif (userslug === userData.userslug) {\n\t\t\treturn;\n\t\t}\n\t\tconst exists = await User.existsBySlug(userslug);\n\t\tif (exists) {\n\t\t\tthrow new Error('[[error:username-taken]]');\n\t\t}\n\t}\n\n\tasync function isWebsiteValid(callerUid, data) {\n\t\tif (!data.website) {\n\t\t\treturn;\n\t\t}\n\t\tif (data.website.length > 255) {\n\t\t\tthrow new Error('[[error:invalid-website]]');\n\t\t}\n\t\tawait User.checkMinReputation(callerUid, data.uid, 'min:rep:website');\n\t}\n\n\tasync function isAboutMeValid(callerUid, data) {\n\t\tif (!data.aboutme) {\n\t\t\treturn;\n\t\t}\n\t\tif (data.aboutme !== undefined && data.aboutme.length > meta.config.maximumAboutMeLength) {\n\t\t\tthrow new Error('[[error:about-me-too-long, ' + meta.config.maximumAboutMeLength + ']]');\n\t\t}\n\n\t\tawait User.checkMinReputation(callerUid, data.uid, 'min:rep:aboutme');\n\t}\n\n\tasync function isSignatureValid(callerUid, data) {\n\t\tif (!data.signature) {\n\t\t\treturn;\n\t\t}\n\t\tif (data.signature !== undefined && data.signature.length > meta.config.maximumSignatureLength) {\n\t\t\tthrow new Error('[[error:signature-too-long, ' + meta.config.maximumSignatureLength + ']]');\n\t\t}\n\t\tawait User.checkMinReputation(callerUid, data.uid, 'min:rep:signature');\n\t}\n\n\tfunction isFullnameValid(data) {\n\t\tif (data.fullname && (validator.isURL(data.fullname) || data.fullname.length > 255)) {\n\t\t\tthrow new Error('[[error:invalid-fullname]]');\n\t\t}\n\t}\n\n\tfunction isLocationValid(data) {\n\t\tif (data.location && (validator.isURL(data.location) || data.location.length > 255)) {\n\t\t\tthrow new Error('[[error:invalid-location]]');\n\t\t}\n\t}\n\n\tfunction isBirthdayValid(data) {\n\t\tif (!data.birthday) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = new Date(data.birthday);\n\t\tif (result && result.toString() === 'Invalid Date') {\n\t\t\tthrow new Error('[[error:invalid-birthday]]');\n\t\t}\n\t}\n\n\tfunction isGroupTitleValid(data) {\n\t\tfunction checkTitle(title) {\n\t\t\tif (title === 'registered-users' || groups.isPrivilegeGroup(title)) {\n\t\t\t\tthrow new Error('[[error:invalid-group-title]]');\n\t\t\t}\n\t\t}\n\t\tif (!data.groupTitle) {\n\t\t\treturn;\n\t\t}\n\t\tlet groupTitles = [];\n\t\tif (validator.isJSON(data.groupTitle)) {\n\t\t\tgroupTitles = JSON.parse(data.groupTitle);\n\t\t\tif (!Array.isArray(groupTitles)) {\n\t\t\t\tthrow new Error('[[error:invalid-group-title]]');\n\t\t\t}\n\t\t\tgroupTitles.forEach(title => checkTitle(title));\n\t\t} else {\n\t\t\tgroupTitles = [data.groupTitle];\n\t\t\tcheckTitle(data.groupTitle);\n\t\t}\n\t\tif (!meta.config.allowMultipleBadges && groupTitles.length > 1) {\n\t\t\tdata.groupTitle = JSON.stringify(groupTitles[0]);\n\t\t}\n\t}\n\n\tUser.checkMinReputation = async function (callerUid, uid, setting) {\n\t\tconst isSelf = parseInt(callerUid, 10) === parseInt(uid, 10);\n\t\tif (!isSelf || meta.config['reputation:disabled']) {\n\t\t\treturn;\n\t\t}\n\t\tconst reputation = await User.getUserField(uid, 'reputation');\n\t\tif (reputation < meta.config[setting]) {\n\t\t\tthrow new Error('[[error:not-enough-reputation-' + setting.replace(/:/g, '-') + ']]');\n\t\t}\n\t};\n\n\tasync function updateEmail(uid, newEmail) {\n\t\tlet oldEmail = await User.getUserField(uid, 'email');\n\t\toldEmail = oldEmail || '';\n\t\tif (oldEmail === newEmail) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait db.sortedSetRemove('email:uid', oldEmail.toLowerCase());\n\t\tawait db.sortedSetRemove('email:sorted', oldEmail.toLowerCase() + ':' + uid);\n\t\tawait User.auth.revokeAllSessions(uid);\n\n\t\tawait Promise.all([\n\t\t\tdb.sortedSetAddBulk([\n\t\t\t\t['email:uid', uid, newEmail.toLowerCase()],\n\t\t\t\t['email:sorted', 0, newEmail.toLowerCase() + ':' + uid],\n\t\t\t\t['user:' + uid + ':emails', Date.now(), newEmail + ':' + Date.now()],\n\t\t\t\t['users:notvalidated', Date.now(), uid],\n\t\t\t]),\n\t\t\tUser.setUserFields(uid, { email: newEmail, 'email:confirmed': 0 }),\n\t\t\tUser.reset.cleanByUid(uid),\n\t\t]);\n\n\t\tif (meta.config.requireEmailConfirmation && newEmail) {\n\t\t\tawait User.email.sendValidationEmail(uid, {\n\t\t\t\temail: newEmail,\n\t\t\t\tsubject: '[[email:email.verify-your-email.subject]]',\n\t\t\t\ttemplate: 'verify_email',\n\t\t\t});\n\t\t}\n\t}\n\n\tasync function updateUsername(uid, newUsername) {\n\t\tif (!newUsername) {\n\t\t\treturn;\n\t\t}\n\t\tconst userData = await User.getUserFields(uid, ['username', 'userslug']);\n\t\tif (userData.username === newUsername) {\n\t\t\treturn;\n\t\t}\n\t\tconst newUserslug = utils.slugify(newUsername);\n\t\tconst now = Date.now();\n\t\tawait Promise.all([\n\t\t\tupdateUidMapping('username', uid, newUsername, userData.username),\n\t\t\tupdateUidMapping('userslug', uid, newUserslug, userData.userslug),\n\t\t\tdb.sortedSetAdd('user:' + uid + ':usernames', now, newUsername + ':' + now),\n\t\t]);\n\t\tawait db.sortedSetRemove('username:sorted', userData.username.toLowerCase() + ':' + uid);\n\t\tawait db.sortedSetAdd('username:sorted', 0, newUsername.toLowerCase() + ':' + uid);\n\t}\n\n\tasync function updateUidMapping(field, uid, value, oldValue) {\n\t\tif (value === oldValue) {\n\t\t\treturn;\n\t\t}\n\t\tawait db.sortedSetRemove(field + ':uid', oldValue);\n\t\tawait User.setUserField(uid, field, value);\n\t\tif (value) {\n\t\t\tawait db.sortedSetAdd(field + ':uid', uid, value);\n\t\t}\n\t}\n\n\tasync function updateFullname(uid, newFullname) {\n\t\tconst fullname = await User.getUserField(uid, 'fullname');\n\t\tawait updateUidMapping('fullname', uid, newFullname, fullname);\n\t}\n\n\tUser.changePassword = async function (uid, data) {\n\t\tif (uid <= 0 || !data || !data.uid) {\n\t\t\tthrow new Error('[[error:invalid-uid]]');\n\t\t}\n\t\tUser.isPasswordValid(data.newPassword);\n\t\tconst [isAdmin, hasPassword] = await Promise.all([\n\t\t\tUser.isAdministrator(uid),\n\t\t\tUser.hasPassword(uid),\n\t\t]);\n\n\t\tif (meta.config['password:disableEdit'] && !isAdmin) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\t\tlet isAdminOrPasswordMatch = false;\n\t\tconst isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);\n\t\tif (\n\t\t\t(isAdmin && !isSelf) || // Admins ok\n\t\t\t(!hasPassword && isSelf)\t// Initial password set ok\n\t\t) {\n\t\t\tisAdminOrPasswordMatch = true;\n\t\t} else {\n\t\t\tisAdminOrPasswordMatch = await User.isPasswordCorrect(uid, data.currentPassword, data.ip);\n\t\t}\n\n\t\tif (!isAdminOrPasswordMatch) {\n\t\t\tthrow new Error('[[user:change_password_error_wrong_current]]');\n\t\t}\n\n\t\tconst hashedPassword = await User.hashPassword(data.newPassword);\n\t\tawait Promise.all([\n\t\t\tUser.setUserFields(data.uid, {\n\t\t\t\tpassword: hashedPassword,\n\t\t\t\trss_token: utils.generateUUID(),\n\t\t\t}),\n\t\t\tUser.reset.updateExpiry(data.uid),\n\t\t\tUser.auth.revokeAllSessions(data.uid),\n\t\t]);\n\n\t\tplugins.fireHook('action:password.change', { uid: uid, targetUid: data.uid });\n\t};\n};\n"], "fixing_code": ["\n'use strict';\n\nconst async = require('async');\nconst validator = require('validator');\n\nconst utils = require('../utils');\nconst meta = require('../meta');\nconst db = require('../database');\nconst groups = require('../groups');\nconst plugins = require('../plugins');\n\nmodule.exports = function (User) {\n\tUser.updateProfile = async function (uid, data) {\n\t\tlet fields = [\n\t\t\t'username', 'email', 'fullname', 'website', 'location',\n\t\t\t'groupTitle', 'birthday', 'signature', 'aboutme',\n\t\t];\n\t\tif (!data.uid) {\n\t\t\tthrow new Error('[[error:invalid-update-uid]]');\n\t\t}\n\t\tconst updateUid = data.uid;\n\n\t\tconst result = await plugins.fireHook('filter:user.updateProfile', { uid: uid, data: data, fields: fields });\n\t\tfields = result.fields;\n\t\tdata = result.data;\n\n\t\tawait validateData(uid, data);\n\n\t\tconst oldData = await User.getUserFields(updateUid, fields);\n\n\t\tawait async.each(fields, async function (field) {\n\t\t\tif (!(data[field] !== undefined && typeof data[field] === 'string')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata[field] = data[field].trim();\n\n\t\t\tif (field === 'email') {\n\t\t\t\treturn await updateEmail(updateUid, data.email);\n\t\t\t} else if (field === 'username') {\n\t\t\t\treturn await updateUsername(updateUid, data.username);\n\t\t\t} else if (field === 'fullname') {\n\t\t\t\treturn await updateFullname(updateUid, data.fullname);\n\t\t\t}\n\n\t\t\tawait User.setUserField(updateUid, field, data[field]);\n\t\t});\n\t\tplugins.fireHook('action:user.updateProfile', { uid: uid, data: data, fields: fields, oldData: oldData });\n\t\treturn await User.getUserFields(updateUid, ['email', 'username', 'userslug', 'picture', 'icon:text', 'icon:bgColor']);\n\t};\n\n\tasync function validateData(callerUid, data) {\n\t\tawait isEmailAvailable(data, data.uid);\n\t\tawait isUsernameAvailable(data, data.uid);\n\t\tawait isWebsiteValid(callerUid, data);\n\t\tawait isAboutMeValid(callerUid, data);\n\t\tawait isSignatureValid(callerUid, data);\n\t\tisFullnameValid(data);\n\t\tisLocationValid(data);\n\t\tisBirthdayValid(data);\n\t\tisGroupTitleValid(data);\n\t}\n\n\tasync function isEmailAvailable(data, uid) {\n\t\tif (!data.email) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!utils.isEmailValid(data.email)) {\n\t\t\tthrow new Error('[[error:invalid-email]]');\n\t\t}\n\t\tconst email = await User.getUserField(uid, 'email');\n\t\tif (email === data.email) {\n\t\t\treturn;\n\t\t}\n\t\tconst available = await User.email.available(data.email);\n\t\tif (!available) {\n\t\t\tthrow new Error('[[error:email-taken]]');\n\t\t}\n\t}\n\n\tasync function isUsernameAvailable(data, uid) {\n\t\tif (!data.username) {\n\t\t\treturn;\n\t\t}\n\t\tdata.username = data.username.trim();\n\t\tconst userData = await User.getUserFields(uid, ['username', 'userslug']);\n\t\tvar userslug = utils.slugify(data.username);\n\n\t\tif (data.username.length < meta.config.minimumUsernameLength) {\n\t\t\tthrow new Error('[[error:username-too-short]]');\n\t\t}\n\n\t\tif (data.username.length > meta.config.maximumUsernameLength) {\n\t\t\tthrow new Error('[[error:username-too-long]]');\n\t\t}\n\n\t\tif (!utils.isUserNameValid(data.username) || !userslug) {\n\t\t\tthrow new Error('[[error:invalid-username]]');\n\t\t}\n\n\t\tif (userslug === userData.userslug) {\n\t\t\treturn;\n\t\t}\n\t\tconst exists = await User.existsBySlug(userslug);\n\t\tif (exists) {\n\t\t\tthrow new Error('[[error:username-taken]]');\n\t\t}\n\t}\n\n\tasync function isWebsiteValid(callerUid, data) {\n\t\tif (!data.website) {\n\t\t\treturn;\n\t\t}\n\t\tif (data.website.length > 255) {\n\t\t\tthrow new Error('[[error:invalid-website]]');\n\t\t}\n\t\tawait User.checkMinReputation(callerUid, data.uid, 'min:rep:website');\n\t}\n\n\tasync function isAboutMeValid(callerUid, data) {\n\t\tif (!data.aboutme) {\n\t\t\treturn;\n\t\t}\n\t\tif (data.aboutme !== undefined && data.aboutme.length > meta.config.maximumAboutMeLength) {\n\t\t\tthrow new Error('[[error:about-me-too-long, ' + meta.config.maximumAboutMeLength + ']]');\n\t\t}\n\n\t\tawait User.checkMinReputation(callerUid, data.uid, 'min:rep:aboutme');\n\t}\n\n\tasync function isSignatureValid(callerUid, data) {\n\t\tif (!data.signature) {\n\t\t\treturn;\n\t\t}\n\t\tif (data.signature !== undefined && data.signature.length > meta.config.maximumSignatureLength) {\n\t\t\tthrow new Error('[[error:signature-too-long, ' + meta.config.maximumSignatureLength + ']]');\n\t\t}\n\t\tawait User.checkMinReputation(callerUid, data.uid, 'min:rep:signature');\n\t}\n\n\tfunction isFullnameValid(data) {\n\t\tif (data.fullname && (validator.isURL(data.fullname) || data.fullname.length > 255)) {\n\t\t\tthrow new Error('[[error:invalid-fullname]]');\n\t\t}\n\t}\n\n\tfunction isLocationValid(data) {\n\t\tif (data.location && (validator.isURL(data.location) || data.location.length > 255)) {\n\t\t\tthrow new Error('[[error:invalid-location]]');\n\t\t}\n\t}\n\n\tfunction isBirthdayValid(data) {\n\t\tif (!data.birthday) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = new Date(data.birthday);\n\t\tif (result && result.toString() === 'Invalid Date') {\n\t\t\tthrow new Error('[[error:invalid-birthday]]');\n\t\t}\n\t}\n\n\tfunction isGroupTitleValid(data) {\n\t\tfunction checkTitle(title) {\n\t\t\tif (title === 'registered-users' || groups.isPrivilegeGroup(title)) {\n\t\t\t\tthrow new Error('[[error:invalid-group-title]]');\n\t\t\t}\n\t\t}\n\t\tif (!data.groupTitle) {\n\t\t\treturn;\n\t\t}\n\t\tlet groupTitles = [];\n\t\tif (validator.isJSON(data.groupTitle)) {\n\t\t\tgroupTitles = JSON.parse(data.groupTitle);\n\t\t\tif (!Array.isArray(groupTitles)) {\n\t\t\t\tthrow new Error('[[error:invalid-group-title]]');\n\t\t\t}\n\t\t\tgroupTitles.forEach(title => checkTitle(title));\n\t\t} else {\n\t\t\tgroupTitles = [data.groupTitle];\n\t\t\tcheckTitle(data.groupTitle);\n\t\t}\n\t\tif (!meta.config.allowMultipleBadges && groupTitles.length > 1) {\n\t\t\tdata.groupTitle = JSON.stringify(groupTitles[0]);\n\t\t}\n\t}\n\n\tUser.checkMinReputation = async function (callerUid, uid, setting) {\n\t\tconst isSelf = parseInt(callerUid, 10) === parseInt(uid, 10);\n\t\tif (!isSelf || meta.config['reputation:disabled']) {\n\t\t\treturn;\n\t\t}\n\t\tconst reputation = await User.getUserField(uid, 'reputation');\n\t\tif (reputation < meta.config[setting]) {\n\t\t\tthrow new Error('[[error:not-enough-reputation-' + setting.replace(/:/g, '-') + ']]');\n\t\t}\n\t};\n\n\tasync function updateEmail(uid, newEmail) {\n\t\tlet oldEmail = await User.getUserField(uid, 'email');\n\t\toldEmail = oldEmail || '';\n\t\tif (oldEmail === newEmail) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait db.sortedSetRemove('email:uid', oldEmail.toLowerCase());\n\t\tawait db.sortedSetRemove('email:sorted', oldEmail.toLowerCase() + ':' + uid);\n\t\tawait User.auth.revokeAllSessions(uid);\n\n\t\tawait Promise.all([\n\t\t\tdb.sortedSetAddBulk([\n\t\t\t\t['email:uid', uid, newEmail.toLowerCase()],\n\t\t\t\t['email:sorted', 0, newEmail.toLowerCase() + ':' + uid],\n\t\t\t\t['user:' + uid + ':emails', Date.now(), newEmail + ':' + Date.now()],\n\t\t\t\t['users:notvalidated', Date.now(), uid],\n\t\t\t]),\n\t\t\tUser.setUserFields(uid, { email: newEmail, 'email:confirmed': 0 }),\n\t\t\tUser.reset.cleanByUid(uid),\n\t\t]);\n\n\t\tif (meta.config.requireEmailConfirmation && newEmail) {\n\t\t\tawait User.email.sendValidationEmail(uid, {\n\t\t\t\temail: newEmail,\n\t\t\t\tsubject: '[[email:email.verify-your-email.subject]]',\n\t\t\t\ttemplate: 'verify_email',\n\t\t\t});\n\t\t}\n\t}\n\n\tasync function updateUsername(uid, newUsername) {\n\t\tif (!newUsername) {\n\t\t\treturn;\n\t\t}\n\t\tconst userData = await User.getUserFields(uid, ['username', 'userslug']);\n\t\tif (userData.username === newUsername) {\n\t\t\treturn;\n\t\t}\n\t\tconst newUserslug = utils.slugify(newUsername);\n\t\tconst now = Date.now();\n\t\tawait Promise.all([\n\t\t\tupdateUidMapping('username', uid, newUsername, userData.username),\n\t\t\tupdateUidMapping('userslug', uid, newUserslug, userData.userslug),\n\t\t\tdb.sortedSetAdd('user:' + uid + ':usernames', now, newUsername + ':' + now),\n\t\t]);\n\t\tawait db.sortedSetRemove('username:sorted', userData.username.toLowerCase() + ':' + uid);\n\t\tawait db.sortedSetAdd('username:sorted', 0, newUsername.toLowerCase() + ':' + uid);\n\t}\n\n\tasync function updateUidMapping(field, uid, value, oldValue) {\n\t\tif (value === oldValue) {\n\t\t\treturn;\n\t\t}\n\t\tawait db.sortedSetRemove(field + ':uid', oldValue);\n\t\tawait User.setUserField(uid, field, value);\n\t\tif (value) {\n\t\t\tawait db.sortedSetAdd(field + ':uid', uid, value);\n\t\t}\n\t}\n\n\tasync function updateFullname(uid, newFullname) {\n\t\tconst fullname = await User.getUserField(uid, 'fullname');\n\t\tawait updateUidMapping('fullname', uid, newFullname, fullname);\n\t}\n\n\tUser.changePassword = async function (uid, data) {\n\t\tif (uid <= 0 || !data || !data.uid) {\n\t\t\tthrow new Error('[[error:invalid-uid]]');\n\t\t}\n\t\tUser.isPasswordValid(data.newPassword);\n\t\tconst [isAdmin, hasPassword] = await Promise.all([\n\t\t\tUser.isAdministrator(uid),\n\t\t\tUser.hasPassword(uid),\n\t\t]);\n\n\t\tif (meta.config['password:disableEdit'] && !isAdmin) {\n\t\t\tthrow new Error('[[error:no-privileges]]');\n\t\t}\n\t\tlet isAdminOrPasswordMatch = false;\n\t\tconst isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);\n\n\t\tif (!isAdmin && !isSelf) {\n\t\t\tthrow new Error('[[user:change_password_error_privileges]]');\n\t\t}\n\n\t\tif (\n\t\t\t(isAdmin && !isSelf) || // Admins ok\n\t\t\t(!hasPassword && isSelf)\t// Initial password set ok\n\t\t) {\n\t\t\tisAdminOrPasswordMatch = true;\n\t\t} else {\n\t\t\tisAdminOrPasswordMatch = await User.isPasswordCorrect(data.uid, data.currentPassword, data.ip);\n\t\t}\n\n\t\tif (!isAdminOrPasswordMatch) {\n\t\t\tthrow new Error('[[user:change_password_error_wrong_current]]');\n\t\t}\n\n\t\tconst hashedPassword = await User.hashPassword(data.newPassword);\n\t\tawait Promise.all([\n\t\t\tUser.setUserFields(data.uid, {\n\t\t\t\tpassword: hashedPassword,\n\t\t\t\trss_token: utils.generateUUID(),\n\t\t\t}),\n\t\t\tUser.reset.updateExpiry(data.uid),\n\t\t\tUser.auth.revokeAllSessions(data.uid),\n\t\t]);\n\n\t\tplugins.fireHook('action:password.change', { uid: uid, targetUid: data.uid });\n\t};\n};\n"], "filenames": ["src/user/profile.js"], "buggy_code_start_loc": [282], "buggy_code_end_loc": [290], "fixing_code_start_loc": [283], "fixing_code_end_loc": [295], "type": "CWE-287", "message": "NodeBB before version 1.14.3 has a bug introduced in version 1.12.2 in the validation logic that makes it possible to change the password of any user on a running NodeBB forum by sending a specially crafted socket.io call to the server. This could lead to a privilege escalation event due via an account takeover. As a workaround you may cherry-pick the following commit from the project's repository to your running instance of NodeBB: 16cee1b03ba3eee177834a1fdac4aa8a12b39d2a. This is fixed in version 1.14.3.", "other": {"cve": {"id": "CVE-2020-15149", "sourceIdentifier": "security-advisories@github.com", "published": "2020-08-20T01:17:12.337", "lastModified": "2021-11-18T18:34:43.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NodeBB before version 1.14.3 has a bug introduced in version 1.12.2 in the validation logic that makes it possible to change the password of any user on a running NodeBB forum by sending a specially crafted socket.io call to the server. This could lead to a privilege escalation event due via an account takeover. As a workaround you may cherry-pick the following commit from the project's repository to your running instance of NodeBB: 16cee1b03ba3eee177834a1fdac4aa8a12b39d2a. This is fixed in version 1.14.3."}, {"lang": "es", "value": "NodeBB versiones anteriores a 1.14.3, presenta un error introducido en la versi\u00f3n 1.12.2 en la l\u00f3gica de comprobaci\u00f3n que hace posible cambiar la contrase\u00f1a de cualquier usuario en un foro NodeBB en ejecuci\u00f3n mediante el env\u00edo de una llamada socket.io especialmente dise\u00f1ada al servidor. Esto podr\u00eda conllevar a un evento de escalada de privilegios debido a una toma de control de la cuenta. Como soluci\u00f3n alternativa, puede seleccionar la siguiente confirmaci\u00f3n del repositorio del proyecto en su instancia en ejecuci\u00f3n de NodeBB: 16cee1b03ba3eee177834a1fdac4aa8a12b39d2a. Esto es corregido en la versi\u00f3n 1.14.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.12.2", "versionEndExcluding": "1.14.3", "matchCriteriaId": "1A40F1AF-6D61-48FD-84F1-68578FF119C1"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/159560/NodeBB-Forum-1.14.2-Account-Takeover.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/NodeBB/NodeBB/commit/c2477d9d5ffc43e5ffeb537ea2ceb4ce9592aa39", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/security/advisories/GHSA-hr66-c8pg-5mg7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://zeroauth.ltd/blog/2020/08/20/proof-of-concept-exploit-for-cve-2020-15149-nodebb-arbitrary-user-password-change/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/c2477d9d5ffc43e5ffeb537ea2ceb4ce9592aa39"}}