{"buggy_code": ["{\n  \"name\"          : \"node-uuid\",\n  \"description\"   : \"Rigorous implementation of RFC4122 (v1 and v4) UUIDs.\",\n  \"url\"           : \"http://github.com/broofa/node-uuid\",\n  \"keywords\"      : [\"uuid\", \"guid\", \"rfc4122\"],\n  \"author\"        : \"Robert Kieffer <robert@broofa.com>\",\n  \"contributors\"  : [\n    {\"name\": \"Christoph Tavan <dev@tavan.de>\", \"github\": \"https://github.com/ctavan\"}\n  ],\n  \"bin\": {\n    \"uuid\": \"./bin/uuid\"\n  },\n  \"scripts\": {\n    \"test\": \"node test/test.js\",\n    \"coverage\": \"nyc npm test && nyc report\"\n  },\n  \"lib\"           : \".\",\n  \"main\"          : \"./uuid.js\",\n  \"repository\"    : { \"type\" : \"git\", \"url\" : \"https://github.com/broofa/node-uuid.git\" },\n  \"version\"       : \"1.4.2\",\n  \"license\"       : \"MIT\",\n  \"devDependencies\": { \"nyc\": \"^2.2.0\" }\n\n}\n", "if (!this.uuid) {\n  // node.js\n  uuid = require('../uuid');\n}\n\n//\n// x-platform log/assert shims\n//\n\nfunction _log(msg, type) {\n  type = type || 'log';\n\n  if (typeof(document) != 'undefined') {\n    document.write('<div class=\"' + type + '\">' + msg.replace(/\\n/g, '<br />') + '</div>');\n  }\n  if (typeof(console) != 'undefined') {\n    var color = {\n      log: '\\033[39m',\n      warn: '\\033[33m',\n      error: '\\033[31m'\n    };\n    console[type](color[type] + msg + color.log);\n  }\n}\n\nfunction log(msg) {_log(msg, 'log');}\nfunction warn(msg) {_log(msg, 'warn');}\nfunction error(msg) {_log(msg, 'error');}\n\nfunction assert(res, msg) {\n  if (!res) {\n    error('FAIL: ' + msg);\n  } else {\n    log('Pass: ' + msg);\n  }\n}\n\n//\n// Unit tests\n//\n\n// Verify ordering of v1 ids created with explicit times\nvar TIME = 1321644961388; // 2011-11-18 11:36:01.388-08:00\n\nfunction compare(name, ids) {\n  ids = ids.map(function(id) {\n    return id.split('-').reverse().join('-');\n  }).sort();\n  var sorted = ([].concat(ids)).sort();\n\n  assert(sorted.toString() == ids.toString(), name + ' have expected order');\n}\n\n// Verify ordering of v1 ids created using default behavior\ncompare('uuids with current time', [\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1()\n]);\n\n// Verify ordering of v1 ids created with explicit times\ncompare('uuids with time option', [\n  uuid.v1({msecs: TIME - 10*3600*1000}),\n  uuid.v1({msecs: TIME - 1}),\n  uuid.v1({msecs: TIME}),\n  uuid.v1({msecs: TIME + 1}),\n  uuid.v1({msecs: TIME + 28*24*3600*1000})\n]);\n\nassert(\n  uuid.v1({msecs: TIME}) != uuid.v1({msecs: TIME}),\n  'IDs created at same msec are different'\n);\n\n// Verify throw if too many ids created\nvar thrown = false;\ntry {\n  uuid.v1({msecs: TIME, nsecs: 10000});\n} catch (e) {\n  thrown = true;\n}\nassert(thrown, 'Exception thrown when > 10K ids created in 1 ms');\n\n// Verify clock regression bumps clockseq\nvar uidt = uuid.v1({msecs: TIME});\nvar uidtb = uuid.v1({msecs: TIME - 1});\nassert(\n  parseInt(uidtb.split('-')[3], 16) - parseInt(uidt.split('-')[3], 16) === 1,\n  'Clock regression by msec increments the clockseq'\n);\n\n// Verify clock regression bumps clockseq\nvar uidtn = uuid.v1({msecs: TIME, nsecs: 10});\nvar uidtnb = uuid.v1({msecs: TIME, nsecs: 9});\nassert(\n  parseInt(uidtnb.split('-')[3], 16) - parseInt(uidtn.split('-')[3], 16) === 1,\n  'Clock regression by nsec increments the clockseq'\n);\n\n// Verify explicit options produce expected id\nvar id = uuid.v1({\n  msecs: 1321651533573,\n  nsecs: 5432,\n  clockseq: 0x385c,\n  node: [ 0x61, 0xcd, 0x3c, 0xbb, 0x32, 0x10 ]\n});\nassert(id == 'd9428888-122b-11e1-b85c-61cd3cbb3210', 'Explicit options produce expected id');\n\n// Verify adjacent ids across a msec boundary are 1 time unit apart\nvar u0 = uuid.v1({msecs: TIME, nsecs: 9999});\nvar u1 = uuid.v1({msecs: TIME + 1, nsecs: 0});\n\nvar before = u0.split('-')[0], after = u1.split('-')[0];\nvar dt = parseInt(after, 16) - parseInt(before, 16);\nassert(dt === 1, 'Ids spanning 1ms boundary are 100ns apart');\n\n//\n// Test parse/unparse\n//\n\nid = '00112233445566778899aabbccddeeff';\nassert(uuid.unparse(uuid.parse(id.substr(0,10))) ==\n  '00112233-4400-0000-0000-000000000000', 'Short parse');\nassert(uuid.unparse(uuid.parse('(this is the uuid -> ' + id + id)) ==\n  '00112233-4455-6677-8899-aabbccddeeff', 'Dirty parse');\n\n//\n// Perf tests\n//\n\nvar generators = {\n  v1: uuid.v1,\n  v4: uuid.v4\n};\n\nvar UUID_FORMAT = {\n  v1: /[0-9a-f]{8}-[0-9a-f]{4}-1[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,\n  v4: /[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i\n};\n\nvar N = 1e4;\n\n// Get %'age an actual value differs from the ideal value\nfunction divergence(actual, ideal) {\n  return Math.round(100*100*(actual - ideal)/ideal)/100;\n}\n\nfunction rate(msg, t) {\n  log(msg + ': ' + (N / (Date.now() - t) * 1e3 | 0) + ' uuids\\/second');\n}\n\nfor (var version in generators) {\n  var counts = {}, max = 0;\n  var generator = generators[version];\n  var format = UUID_FORMAT[version];\n\n  log('\\nSanity check ' + N + ' ' + version + ' uuids');\n  for (var i = 0, ok = 0; i < N; i++) {\n    id = generator();\n    if (!format.test(id)) {\n      throw Error(id + ' is not a valid UUID string');\n    }\n\n    if (id != uuid.unparse(uuid.parse(id))) {\n      assert(fail, id + ' is not a valid id');\n    }\n\n    // Count digits for our randomness check\n    if (version == 'v4') {\n      var digits = id.replace(/-/g, '').split('');\n      for (var j = digits.length-1; j >= 0; j--) {\n        var c = digits[j];\n        max = Math.max(max, counts[c] = (counts[c] || 0) + 1);\n      }\n    }\n  }\n\n  // Check randomness for v4 UUIDs\n  if (version == 'v4') {\n    // Limit that we get worried about randomness. (Purely empirical choice, this!)\n    var limit = 2*100*Math.sqrt(1/N);\n\n    log('\\nChecking v4 randomness.  Distribution of Hex Digits (% deviation from ideal)');\n\n    for (var i = 0; i < 16; i++) {\n      var c = i.toString(16);\n      var bar = '', n = counts[c], p = Math.round(n/max*100|0);\n\n      // 1-3,5-8, and D-F: 1:16 odds over 30 digits\n      var ideal = N*30/16;\n      if (i == 4) {\n        // 4: 1:1 odds on 1 digit, plus 1:16 odds on 30 digits\n        ideal = N*(1 + 30/16);\n      } else if (i >= 8 && i <= 11) {\n        // 8-B: 1:4 odds on 1 digit, plus 1:16 odds on 30 digits\n        ideal = N*(1/4 + 30/16);\n      } else {\n        // Otherwise: 1:16 odds on 30 digits\n        ideal = N*30/16;\n      }\n      var d = divergence(n, ideal);\n\n      // Draw bar using UTF squares (just for grins)\n      var s = n/max*50 | 0;\n      while (s--) bar += '=';\n\n      assert(Math.abs(d) < limit, c + ' |' + bar + '| ' + counts[c] + ' (' + d + '% < ' + limit + '%)');\n    }\n  }\n}\n\n// Perf tests\nfor (var version in generators) {\n  log('\\nPerformance testing ' + version + ' UUIDs');\n  var generator = generators[version];\n  var buf = new uuid.BufferClass(16);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator();\n  rate('uuid.' + version + '()', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator('binary');\n  rate('uuid.' + version + '(\\'binary\\')', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator('binary', buf);\n  rate('uuid.' + version + '(\\'binary\\', buffer)', t);\n}\n", "//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng;\n\n  // Allow for MSIE11 msCrypto\n  var _crypto = _global.crypto || _global.msCrypto;\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  //\n  // Moderately fast, high quality\n  if ('function' === typeof require) {\n    try {\n      var _rb = _global.require('crypto').randomBytes;\n      _rng = _rb && function() {return _rb(16);};\n    } catch(e) {}\n  }\n\n  if (!_rng && _crypto && _crypto.getRandomValues) {\n    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n    //\n    // Moderately fast, high quality\n    var _rnds8 = new Uint8Array(16);\n    _rng = function whatwgRNG() {\n      _crypto.getRandomValues(_rnds8);\n      return _rnds8;\n    };\n  }\n\n  if (!_rng) {\n    // Math.random()-based (RNG)\n    //\n    // If all else fails, use Math.random().  It's fast, but is of unspecified\n    // quality.\n    var  _rnds = new Array(16);\n    _rng = function() {\n      for (var i = 0, r; i < 16; i++) {\n        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n      }\n\n      return _rnds;\n    };\n  }\n\n  // Buffer class to use\n  var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  if (typeof(module) != 'undefined' && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else  if (typeof define === 'function' && define.amd) {\n    // Publish as AMD module\n    define(function() {return uuid;});\n \n\n  } else {\n    // Publish as global (in browsers)\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _global.uuid = uuid;\n  }\n}).call(this);\n"], "fixing_code": ["{\n  \"author\": {\n    \"email\": \"robert@broofa.com\",\n    \"name\": \"Robert Kieffer\"\n  },\n  \"bin\": {\n    \"uuid\": \"./bin/uuid\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/broofa/node-uuid/issues\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"AJ ONeal\",\n      \"email\": \"coolaj86@gmail.com\"\n    },\n    {\n      \"name\": \"Christoph Tavan\",\n      \"email\": \"dev@tavan.de\"\n    }\n  ],\n  \"dependencies\": {},\n  \"description\": \"Rigorous implementation of RFC4122 (v1 and v4) UUIDs.\",\n  \"devDependencies\": {\n    \"nyc\": \"^2.2.0\"\n  },\n  \"directories\": {},\n  \"homepage\": \"https://github.com/broofa/node-uuid\",\n  \"installable\": true,\n  \"keywords\": [\n    \"guid\",\n    \"rfc4122\",\n    \"uuid\"\n  ],\n  \"lib\": \".\",\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"https://raw.github.com/broofa/node-uuid/master/LICENSE.md\"\n    }\n  ],\n  \"main\": \"./uuid.js\",\n  \"maintainers\": [\n    {\n      \"name\": \"broofa\",\n      \"email\": \"robert@broofa.com\"\n    }\n  ],\n  \"name\": \"node-uuid\",\n  \"optionalDependencies\": {},\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/broofa/node-uuid.git\"\n  },\n  \"scripts\": {\n    \"coverage\": \"nyc npm test && nyc report\",\n    \"test\": \"node test/test.js\"\n  },\n  \"url\": \"http://github.com/broofa/node-uuid\",\n  \"version\": \"1.4.4\"\n}\n", "if (!this.uuid) {\n  // node.js\n  uuid = require('../uuid');\n  if (!/_rb/.test(uuid._rng.toString())) {\n    throw new Error(\"should use crypto for node.js\");\n  }\n}\n\n//\n// x-platform log/assert shims\n//\n\nfunction _log(msg, type) {\n  type = type || 'log';\n\n  if (typeof(document) != 'undefined') {\n    document.write('<div class=\"' + type + '\">' + msg.replace(/\\n/g, '<br />') + '</div>');\n  }\n  if (typeof(console) != 'undefined') {\n    var color = {\n      log: '\\033[39m',\n      warn: '\\033[33m',\n      error: '\\033[31m'\n    };\n    console[type](color[type] + msg + color.log);\n  }\n}\n\nfunction log(msg) {_log(msg, 'log');}\nfunction warn(msg) {_log(msg, 'warn');}\nfunction error(msg) {_log(msg, 'error');}\n\nfunction assert(res, msg) {\n  if (!res) {\n    error('FAIL: ' + msg);\n  } else {\n    log('Pass: ' + msg);\n  }\n}\n\n//\n// Unit tests\n//\n\n// Verify ordering of v1 ids created with explicit times\nvar TIME = 1321644961388; // 2011-11-18 11:36:01.388-08:00\n\nfunction compare(name, ids) {\n  ids = ids.map(function(id) {\n    return id.split('-').reverse().join('-');\n  }).sort();\n  var sorted = ([].concat(ids)).sort();\n\n  assert(sorted.toString() == ids.toString(), name + ' have expected order');\n}\n\n// Verify ordering of v1 ids created using default behavior\ncompare('uuids with current time', [\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1(),\n  uuid.v1()\n]);\n\n// Verify ordering of v1 ids created with explicit times\ncompare('uuids with time option', [\n  uuid.v1({msecs: TIME - 10*3600*1000}),\n  uuid.v1({msecs: TIME - 1}),\n  uuid.v1({msecs: TIME}),\n  uuid.v1({msecs: TIME + 1}),\n  uuid.v1({msecs: TIME + 28*24*3600*1000})\n]);\n\nassert(\n  uuid.v1({msecs: TIME}) != uuid.v1({msecs: TIME}),\n  'IDs created at same msec are different'\n);\n\n// Verify throw if too many ids created\nvar thrown = false;\ntry {\n  uuid.v1({msecs: TIME, nsecs: 10000});\n} catch (e) {\n  thrown = true;\n}\nassert(thrown, 'Exception thrown when > 10K ids created in 1 ms');\n\n// Verify clock regression bumps clockseq\nvar uidt = uuid.v1({msecs: TIME});\nvar uidtb = uuid.v1({msecs: TIME - 1});\nassert(\n  parseInt(uidtb.split('-')[3], 16) - parseInt(uidt.split('-')[3], 16) === 1,\n  'Clock regression by msec increments the clockseq'\n);\n\n// Verify clock regression bumps clockseq\nvar uidtn = uuid.v1({msecs: TIME, nsecs: 10});\nvar uidtnb = uuid.v1({msecs: TIME, nsecs: 9});\nassert(\n  parseInt(uidtnb.split('-')[3], 16) - parseInt(uidtn.split('-')[3], 16) === 1,\n  'Clock regression by nsec increments the clockseq'\n);\n\n// Verify explicit options produce expected id\nvar id = uuid.v1({\n  msecs: 1321651533573,\n  nsecs: 5432,\n  clockseq: 0x385c,\n  node: [ 0x61, 0xcd, 0x3c, 0xbb, 0x32, 0x10 ]\n});\nassert(id == 'd9428888-122b-11e1-b85c-61cd3cbb3210', 'Explicit options produce expected id');\n\n// Verify adjacent ids across a msec boundary are 1 time unit apart\nvar u0 = uuid.v1({msecs: TIME, nsecs: 9999});\nvar u1 = uuid.v1({msecs: TIME + 1, nsecs: 0});\n\nvar before = u0.split('-')[0], after = u1.split('-')[0];\nvar dt = parseInt(after, 16) - parseInt(before, 16);\nassert(dt === 1, 'Ids spanning 1ms boundary are 100ns apart');\n\n//\n// Test parse/unparse\n//\n\nid = '00112233445566778899aabbccddeeff';\nassert(uuid.unparse(uuid.parse(id.substr(0,10))) ==\n  '00112233-4400-0000-0000-000000000000', 'Short parse');\nassert(uuid.unparse(uuid.parse('(this is the uuid -> ' + id + id)) ==\n  '00112233-4455-6677-8899-aabbccddeeff', 'Dirty parse');\n\n//\n// Perf tests\n//\n\nvar generators = {\n  v1: uuid.v1,\n  v4: uuid.v4\n};\n\nvar UUID_FORMAT = {\n  v1: /[0-9a-f]{8}-[0-9a-f]{4}-1[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,\n  v4: /[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i\n};\n\nvar N = 1e4;\n\n// Get %'age an actual value differs from the ideal value\nfunction divergence(actual, ideal) {\n  return Math.round(100*100*(actual - ideal)/ideal)/100;\n}\n\nfunction rate(msg, t) {\n  log(msg + ': ' + (N / (Date.now() - t) * 1e3 | 0) + ' uuids\\/second');\n}\n\nfor (var version in generators) {\n  var counts = {}, max = 0;\n  var generator = generators[version];\n  var format = UUID_FORMAT[version];\n\n  log('\\nSanity check ' + N + ' ' + version + ' uuids');\n  for (var i = 0, ok = 0; i < N; i++) {\n    id = generator();\n    if (!format.test(id)) {\n      throw Error(id + ' is not a valid UUID string');\n    }\n\n    if (id != uuid.unparse(uuid.parse(id))) {\n      assert(fail, id + ' is not a valid id');\n    }\n\n    // Count digits for our randomness check\n    if (version == 'v4') {\n      var digits = id.replace(/-/g, '').split('');\n      for (var j = digits.length-1; j >= 0; j--) {\n        var c = digits[j];\n        max = Math.max(max, counts[c] = (counts[c] || 0) + 1);\n      }\n    }\n  }\n\n  // Check randomness for v4 UUIDs\n  if (version == 'v4') {\n    // Limit that we get worried about randomness. (Purely empirical choice, this!)\n    var limit = 2*100*Math.sqrt(1/N);\n\n    log('\\nChecking v4 randomness.  Distribution of Hex Digits (% deviation from ideal)');\n\n    for (var i = 0; i < 16; i++) {\n      var c = i.toString(16);\n      var bar = '', n = counts[c], p = Math.round(n/max*100|0);\n\n      // 1-3,5-8, and D-F: 1:16 odds over 30 digits\n      var ideal = N*30/16;\n      if (i == 4) {\n        // 4: 1:1 odds on 1 digit, plus 1:16 odds on 30 digits\n        ideal = N*(1 + 30/16);\n      } else if (i >= 8 && i <= 11) {\n        // 8-B: 1:4 odds on 1 digit, plus 1:16 odds on 30 digits\n        ideal = N*(1/4 + 30/16);\n      } else {\n        // Otherwise: 1:16 odds on 30 digits\n        ideal = N*30/16;\n      }\n      var d = divergence(n, ideal);\n\n      // Draw bar using UTF squares (just for grins)\n      var s = n/max*50 | 0;\n      while (s--) bar += '=';\n\n      assert(Math.abs(d) < limit, c + ' |' + bar + '| ' + counts[c] + ' (' + d + '% < ' + limit + '%)');\n    }\n  }\n}\n\n// Perf tests\nfor (var version in generators) {\n  log('\\nPerformance testing ' + version + ' UUIDs');\n  var generator = generators[version];\n  var buf = new uuid.BufferClass(16);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator();\n  rate('uuid.' + version + '()', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator('binary');\n  rate('uuid.' + version + '(\\'binary\\')', t);\n\n  for (var i = 0, t = Date.now(); i < N; i++) generator('binary', buf);\n  rate('uuid.' + version + '(\\'binary\\', buffer)', t);\n}\n", "//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng;\n\n  // Allow for MSIE11 msCrypto\n  var _crypto = _global.crypto || _global.msCrypto;\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  //\n  // Moderately fast, high quality\n  if ('function' === typeof require) {\n    try {\n      var _rb = require('crypto').randomBytes;\n      _rng = _rb && function() {return _rb(16);};\n    } catch(e) {}\n  }\n\n  if (!_rng && _crypto && _crypto.getRandomValues) {\n    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n    //\n    // Moderately fast, high quality\n    var _rnds8 = new Uint8Array(16);\n    _rng = function whatwgRNG() {\n      _crypto.getRandomValues(_rnds8);\n      return _rnds8;\n    };\n  }\n\n  if (!_rng) {\n    // Math.random()-based (RNG)\n    //\n    // If all else fails, use Math.random().  It's fast, but is of unspecified\n    // quality.\n    var  _rnds = new Array(16);\n    _rng = function() {\n      for (var i = 0, r; i < 16; i++) {\n        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n      }\n\n      return _rnds;\n    };\n  }\n\n  // Buffer class to use\n  var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n  uuid._rng = _rng;\n\n  if (typeof(module) != 'undefined' && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else  if (typeof define === 'function' && define.amd) {\n    // Publish as AMD module\n    define(function() {return uuid;});\n\n\n  } else {\n    // Publish as global (in browsers)\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _global.uuid = uuid;\n  }\n}).call(this);\n"], "filenames": ["package.json", "test/test.js", "uuid.js"], "buggy_code_start_loc": [2, 3, 22], "buggy_code_end_loc": [24, 3, 237], "fixing_code_start_loc": [2, 4, 22], "fixing_code_end_loc": [61, 7, 238], "type": "CWE-331", "message": "node-uuid before 1.4.4 uses insufficiently random data to create a GUID, which could make it easier for attackers to have unspecified impact via brute force guessing.", "other": {"cve": {"id": "CVE-2015-8851", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-30T21:15:14.653", "lastModified": "2020-02-05T17:26:43.053", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "node-uuid before 1.4.4 uses insufficiently random data to create a GUID, which could make it easier for attackers to have unspecified impact via brute force guessing."}, {"lang": "es", "value": "node-uuid versiones anteriores a 1.4.4, utiliza datos insuficientemente aleatorios para crear un GUID, lo que podr\u00eda facilitar a atacantes tener un impacto no especificado por medio de la adivinaci\u00f3n por fuerza bruta."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-331"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:node-uuid_project:node-uuid:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.4.4", "matchCriteriaId": "64FB099E-E5F0-4372-95AE-614BB11C3CFC"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/04/13/8", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1327056", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/broofa/node-uuid/commit/672f3834ed02c798aa021c618d0a5666c8da000d", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://nodesecurity.io/advisories/93", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/broofa/node-uuid/commit/672f3834ed02c798aa021c618d0a5666c8da000d"}}