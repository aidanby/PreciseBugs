{"buggy_code": ["/*\n *  Digital Audio (PCM) abstract layer\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *                   Abramo Bagnara <abramo@alsa-project.org>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/timer.h>\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n#define CREATE_TRACE_POINTS\n#include \"pcm_trace.h\"\n#else\n#define trace_hwptr(substream, pos, in_interrupt)\n#define trace_xrun(substream)\n#define trace_hw_ptr_error(substream, reason)\n#endif\n\n/*\n * fill ring buffer with silence\n * runtime->silence_start: starting pointer to silence area\n * runtime->silence_filled: size filled with silence\n * runtime->silence_threshold: threshold from application\n * runtime->silence_size: maximal size from application\n *\n * when runtime->silence_size >= runtime->boundary - fill processed area with silence immediately\n */\nvoid snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t frames, ofs, transfer;\n\n\tif (runtime->silence_size < runtime->boundary) {\n\t\tsnd_pcm_sframes_t noise_dist, n;\n\t\tif (runtime->silence_start != runtime->control->appl_ptr) {\n\t\t\tn = runtime->control->appl_ptr - runtime->silence_start;\n\t\t\tif (n < 0)\n\t\t\t\tn += runtime->boundary;\n\t\t\tif ((snd_pcm_uframes_t)n < runtime->silence_filled)\n\t\t\t\truntime->silence_filled -= n;\n\t\t\telse\n\t\t\t\truntime->silence_filled = 0;\n\t\t\truntime->silence_start = runtime->control->appl_ptr;\n\t\t}\n\t\tif (runtime->silence_filled >= runtime->buffer_size)\n\t\t\treturn;\n\t\tnoise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;\n\t\tif (noise_dist >= (snd_pcm_sframes_t) runtime->silence_threshold)\n\t\t\treturn;\n\t\tframes = runtime->silence_threshold - noise_dist;\n\t\tif (frames > runtime->silence_size)\n\t\t\tframes = runtime->silence_size;\n\t} else {\n\t\tif (new_hw_ptr == ULONG_MAX) {\t/* initialization */\n\t\t\tsnd_pcm_sframes_t avail = snd_pcm_playback_hw_avail(runtime);\n\t\t\tif (avail > runtime->buffer_size)\n\t\t\t\tavail = runtime->buffer_size;\n\t\t\truntime->silence_filled = avail > 0 ? avail : 0;\n\t\t\truntime->silence_start = (runtime->status->hw_ptr +\n\t\t\t\t\t\t  runtime->silence_filled) %\n\t\t\t\t\t\t runtime->boundary;\n\t\t} else {\n\t\t\tofs = runtime->status->hw_ptr;\n\t\t\tframes = new_hw_ptr - ofs;\n\t\t\tif ((snd_pcm_sframes_t)frames < 0)\n\t\t\t\tframes += runtime->boundary;\n\t\t\truntime->silence_filled -= frames;\n\t\t\tif ((snd_pcm_sframes_t)runtime->silence_filled < 0) {\n\t\t\t\truntime->silence_filled = 0;\n\t\t\t\truntime->silence_start = new_hw_ptr;\n\t\t\t} else {\n\t\t\t\truntime->silence_start = ofs;\n\t\t\t}\n\t\t}\n\t\tframes = runtime->buffer_size - runtime->silence_filled;\n\t}\n\tif (snd_BUG_ON(frames > runtime->buffer_size))\n\t\treturn;\n\tif (frames == 0)\n\t\treturn;\n\tofs = runtime->silence_start % runtime->buffer_size;\n\twhile (frames > 0) {\n\t\ttransfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;\n\t\tif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||\n\t\t    runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {\n\t\t\tif (substream->ops->silence) {\n\t\t\t\tint err;\n\t\t\t\terr = substream->ops->silence(substream, -1, ofs, transfer);\n\t\t\t\tsnd_BUG_ON(err < 0);\n\t\t\t} else {\n\t\t\t\tchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);\n\t\t\t\tsnd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int c;\n\t\t\tunsigned int channels = runtime->channels;\n\t\t\tif (substream->ops->silence) {\n\t\t\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t\t\tint err;\n\t\t\t\t\terr = substream->ops->silence(substream, c, ofs, transfer);\n\t\t\t\t\tsnd_BUG_ON(err < 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsize_t dma_csize = runtime->dma_bytes / channels;\n\t\t\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t\t\tchar *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);\n\t\t\t\t\tsnd_pcm_format_set_silence(runtime->format, hwbuf, transfer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\truntime->silence_filled += transfer;\n\t\tframes -= transfer;\n\t\tofs = 0;\n\t}\n}\n\n#ifdef CONFIG_SND_DEBUG\nvoid snd_pcm_debug_name(struct snd_pcm_substream *substream,\n\t\t\t   char *name, size_t len)\n{\n\tsnprintf(name, len, \"pcmC%dD%d%c:%d\",\n\t\t substream->pcm->card->number,\n\t\t substream->pcm->device,\n\t\t substream->stream ? 'c' : 'p',\n\t\t substream->number);\n}\nEXPORT_SYMBOL(snd_pcm_debug_name);\n#endif\n\n#define XRUN_DEBUG_BASIC\t(1<<0)\n#define XRUN_DEBUG_STACK\t(1<<1)\t/* dump also stack */\n#define XRUN_DEBUG_JIFFIESCHECK\t(1<<2)\t/* do jiffies check */\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n\n#define xrun_debug(substream, mask) \\\n\t\t\t((substream)->pstr->xrun_debug & (mask))\n#else\n#define xrun_debug(substream, mask)\t0\n#endif\n\n#define dump_stack_on_xrun(substream) do {\t\t\t\\\n\t\tif (xrun_debug(substream, XRUN_DEBUG_STACK))\t\\\n\t\t\tdump_stack();\t\t\t\t\\\n\t} while (0)\n\nstatic void xrun(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\ttrace_xrun(substream);\n\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)\n\t\tsnd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);\n\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\n\tif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\n\t\tchar name[16];\n\t\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\t\tpcm_warn(substream->pcm, \"XRUN: %s\\n\", name);\n\t\tdump_stack_on_xrun(substream);\n\t}\n}\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n#define hw_ptr_error(substream, in_interrupt, reason, fmt, args...)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttrace_hw_ptr_error(substream, reason);\t\\\n\t\tif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\t\t\\\n\t\t\tpr_err_ratelimited(\"ALSA: PCM: [%c] \" reason \": \" fmt, \\\n\t\t\t\t\t   (in_interrupt) ? 'Q' : 'P', ##args);\t\\\n\t\t\tdump_stack_on_xrun(substream);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#else /* ! CONFIG_SND_PCM_XRUN_DEBUG */\n\n#define hw_ptr_error(substream, fmt, args...) do { } while (0)\n\n#endif\n\nint snd_pcm_update_state(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_runtime *runtime)\n{\n\tsnd_pcm_uframes_t avail;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tavail = snd_pcm_playback_avail(runtime);\n\telse\n\t\tavail = snd_pcm_capture_avail(runtime);\n\tif (avail > runtime->avail_max)\n\t\truntime->avail_max = avail;\n\tif (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {\n\t\tif (avail >= runtime->buffer_size) {\n\t\t\tsnd_pcm_drain_done(substream);\n\t\t\treturn -EPIPE;\n\t\t}\n\t} else {\n\t\tif (avail >= runtime->stop_threshold) {\n\t\t\txrun(substream);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\tif (runtime->twake) {\n\t\tif (avail >= runtime->twake)\n\t\t\twake_up(&runtime->tsleep);\n\t} else if (avail >= runtime->control->avail_min)\n\t\twake_up(&runtime->sleep);\n\treturn 0;\n}\n\nstatic void update_audio_tstamp(struct snd_pcm_substream *substream,\n\t\t\t\tstruct timespec *curr_tstamp,\n\t\t\t\tstruct timespec *audio_tstamp)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu64 audio_frames, audio_nsecs;\n\tstruct timespec driver_tstamp;\n\n\tif (runtime->tstamp_mode != SNDRV_PCM_TSTAMP_ENABLE)\n\t\treturn;\n\n\tif (!(substream->ops->get_time_info) ||\n\t\t(runtime->audio_tstamp_report.actual_type ==\n\t\t\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\n\n\t\t/*\n\t\t * provide audio timestamp derived from pointer position\n\t\t * add delay only if requested\n\t\t */\n\n\t\taudio_frames = runtime->hw_ptr_wrap + runtime->status->hw_ptr;\n\n\t\tif (runtime->audio_tstamp_config.report_delay) {\n\t\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\taudio_frames -=  runtime->delay;\n\t\t\telse\n\t\t\t\taudio_frames +=  runtime->delay;\n\t\t}\n\t\taudio_nsecs = div_u64(audio_frames * 1000000000LL,\n\t\t\t\truntime->rate);\n\t\t*audio_tstamp = ns_to_timespec(audio_nsecs);\n\t}\n\truntime->status->audio_tstamp = *audio_tstamp;\n\truntime->status->tstamp = *curr_tstamp;\n\n\t/*\n\t * re-take a driver timestamp to let apps detect if the reference tstamp\n\t * read by low-level hardware was provided with a delay\n\t */\n\tsnd_pcm_gettime(substream->runtime, (struct timespec *)&driver_tstamp);\n\truntime->driver_tstamp = driver_tstamp;\n}\n\nstatic int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,\n\t\t\t\t  unsigned int in_interrupt)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t pos;\n\tsnd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;\n\tsnd_pcm_sframes_t hdelta, delta;\n\tunsigned long jdelta;\n\tunsigned long curr_jiffies;\n\tstruct timespec curr_tstamp;\n\tstruct timespec audio_tstamp;\n\tint crossed_boundary = 0;\n\n\told_hw_ptr = runtime->status->hw_ptr;\n\n\t/*\n\t * group pointer, time and jiffies reads to allow for more\n\t * accurate correlations/corrections.\n\t * The values are stored at the end of this routine after\n\t * corrections for hw_ptr position\n\t */\n\tpos = substream->ops->pointer(substream);\n\tcurr_jiffies = jiffies;\n\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\n\t\tif ((substream->ops->get_time_info) &&\n\t\t\t(runtime->audio_tstamp_config.type_requested != SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\n\t\t\tsubstream->ops->get_time_info(substream, &curr_tstamp,\n\t\t\t\t\t\t&audio_tstamp,\n\t\t\t\t\t\t&runtime->audio_tstamp_config,\n\t\t\t\t\t\t&runtime->audio_tstamp_report);\n\n\t\t\t/* re-test in case tstamp type is not supported in hardware and was demoted to DEFAULT */\n\t\t\tif (runtime->audio_tstamp_report.actual_type == SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)\n\t\t\t\tsnd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);\n\t\t} else\n\t\t\tsnd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);\n\t}\n\n\tif (pos == SNDRV_PCM_POS_XRUN) {\n\t\txrun(substream);\n\t\treturn -EPIPE;\n\t}\n\tif (pos >= runtime->buffer_size) {\n\t\tif (printk_ratelimit()) {\n\t\t\tchar name[16];\n\t\t\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\t\t\tpcm_err(substream->pcm,\n\t\t\t\t\"invalid position: %s, pos = %ld, buffer size = %ld, period size = %ld\\n\",\n\t\t\t\tname, pos, runtime->buffer_size,\n\t\t\t\truntime->period_size);\n\t\t}\n\t\tpos = 0;\n\t}\n\tpos -= pos % runtime->min_align;\n\ttrace_hwptr(substream, pos, in_interrupt);\n\thw_base = runtime->hw_ptr_base;\n\tnew_hw_ptr = hw_base + pos;\n\tif (in_interrupt) {\n\t\t/* we know that one period was processed */\n\t\t/* delta = \"expected next hw_ptr\" for in_interrupt != 0 */\n\t\tdelta = runtime->hw_ptr_interrupt + runtime->period_size;\n\t\tif (delta > new_hw_ptr) {\n\t\t\t/* check for double acknowledged interrupts */\n\t\t\thdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\t\t\tif (hdelta > runtime->hw_ptr_buffer_jiffies/2 + 1) {\n\t\t\t\thw_base += runtime->buffer_size;\n\t\t\t\tif (hw_base >= runtime->boundary) {\n\t\t\t\t\thw_base = 0;\n\t\t\t\t\tcrossed_boundary++;\n\t\t\t\t}\n\t\t\t\tnew_hw_ptr = hw_base + pos;\n\t\t\t\tgoto __delta;\n\t\t\t}\n\t\t}\n\t}\n\t/* new_hw_ptr might be lower than old_hw_ptr in case when */\n\t/* pointer crosses the end of the ring buffer */\n\tif (new_hw_ptr < old_hw_ptr) {\n\t\thw_base += runtime->buffer_size;\n\t\tif (hw_base >= runtime->boundary) {\n\t\t\thw_base = 0;\n\t\t\tcrossed_boundary++;\n\t\t}\n\t\tnew_hw_ptr = hw_base + pos;\n\t}\n      __delta:\n\tdelta = new_hw_ptr - old_hw_ptr;\n\tif (delta < 0)\n\t\tdelta += runtime->boundary;\n\n\tif (runtime->no_period_wakeup) {\n\t\tsnd_pcm_sframes_t xrun_threshold;\n\t\t/*\n\t\t * Without regular period interrupts, we have to check\n\t\t * the elapsed time to detect xruns.\n\t\t */\n\t\tjdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\t\tif (jdelta < runtime->hw_ptr_buffer_jiffies / 2)\n\t\t\tgoto no_delta_check;\n\t\thdelta = jdelta - delta * HZ / runtime->rate;\n\t\txrun_threshold = runtime->hw_ptr_buffer_jiffies / 2 + 1;\n\t\twhile (hdelta > xrun_threshold) {\n\t\t\tdelta += runtime->buffer_size;\n\t\t\thw_base += runtime->buffer_size;\n\t\t\tif (hw_base >= runtime->boundary) {\n\t\t\t\thw_base = 0;\n\t\t\t\tcrossed_boundary++;\n\t\t\t}\n\t\t\tnew_hw_ptr = hw_base + pos;\n\t\t\thdelta -= runtime->hw_ptr_buffer_jiffies;\n\t\t}\n\t\tgoto no_delta_check;\n\t}\n\n\t/* something must be really wrong */\n\tif (delta >= runtime->buffer_size + runtime->period_size) {\n\t\thw_ptr_error(substream, in_interrupt, \"Unexpected hw_ptr\",\n\t\t\t     \"(stream=%i, pos=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\\n\",\n\t\t\t     substream->stream, (long)pos,\n\t\t\t     (long)new_hw_ptr, (long)old_hw_ptr);\n\t\treturn 0;\n\t}\n\n\t/* Do jiffies check only in xrun_debug mode */\n\tif (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))\n\t\tgoto no_jiffies_check;\n\n\t/* Skip the jiffies check for hardwares with BATCH flag.\n\t * Such hardware usually just increases the position at each IRQ,\n\t * thus it can't give any strange position.\n\t */\n\tif (runtime->hw.info & SNDRV_PCM_INFO_BATCH)\n\t\tgoto no_jiffies_check;\n\thdelta = delta;\n\tif (hdelta < runtime->delay)\n\t\tgoto no_jiffies_check;\n\thdelta -= runtime->delay;\n\tjdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\tif (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {\n\t\tdelta = jdelta /\n\t\t\t(((runtime->period_size * HZ) / runtime->rate)\n\t\t\t\t\t\t\t\t+ HZ/100);\n\t\t/* move new_hw_ptr according jiffies not pos variable */\n\t\tnew_hw_ptr = old_hw_ptr;\n\t\thw_base = delta;\n\t\t/* use loop to avoid checks for delta overflows */\n\t\t/* the delta value is small or zero in most cases */\n\t\twhile (delta > 0) {\n\t\t\tnew_hw_ptr += runtime->period_size;\n\t\t\tif (new_hw_ptr >= runtime->boundary) {\n\t\t\t\tnew_hw_ptr -= runtime->boundary;\n\t\t\t\tcrossed_boundary--;\n\t\t\t}\n\t\t\tdelta--;\n\t\t}\n\t\t/* align hw_base to buffer_size */\n\t\thw_ptr_error(substream, in_interrupt, \"hw_ptr skipping\",\n\t\t\t     \"(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\\n\",\n\t\t\t     (long)pos, (long)hdelta,\n\t\t\t     (long)runtime->period_size, jdelta,\n\t\t\t     ((hdelta * HZ) / runtime->rate), hw_base,\n\t\t\t     (unsigned long)old_hw_ptr,\n\t\t\t     (unsigned long)new_hw_ptr);\n\t\t/* reset values to proper state */\n\t\tdelta = 0;\n\t\thw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);\n\t}\n no_jiffies_check:\n\tif (delta > runtime->period_size + runtime->period_size / 2) {\n\t\thw_ptr_error(substream, in_interrupt,\n\t\t\t     \"Lost interrupts?\",\n\t\t\t     \"(stream=%i, delta=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\\n\",\n\t\t\t     substream->stream, (long)delta,\n\t\t\t     (long)new_hw_ptr,\n\t\t\t     (long)old_hw_ptr);\n\t}\n\n no_delta_check:\n\tif (runtime->status->hw_ptr == new_hw_ptr) {\n\t\tupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\n\t\treturn 0;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    runtime->silence_size > 0)\n\t\tsnd_pcm_playback_silence(substream, new_hw_ptr);\n\n\tif (in_interrupt) {\n\t\tdelta = new_hw_ptr - runtime->hw_ptr_interrupt;\n\t\tif (delta < 0)\n\t\t\tdelta += runtime->boundary;\n\t\tdelta -= (snd_pcm_uframes_t)delta % runtime->period_size;\n\t\truntime->hw_ptr_interrupt += delta;\n\t\tif (runtime->hw_ptr_interrupt >= runtime->boundary)\n\t\t\truntime->hw_ptr_interrupt -= runtime->boundary;\n\t}\n\truntime->hw_ptr_base = hw_base;\n\truntime->status->hw_ptr = new_hw_ptr;\n\truntime->hw_ptr_jiffies = curr_jiffies;\n\tif (crossed_boundary) {\n\t\tsnd_BUG_ON(crossed_boundary != 1);\n\t\truntime->hw_ptr_wrap += runtime->boundary;\n\t}\n\n\tupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\n\n\treturn snd_pcm_update_state(substream, runtime);\n}\n\n/* CAUTION: call it with irq disabled */\nint snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_update_hw_ptr0(substream, 0);\n}\n\n/**\n * snd_pcm_set_ops - set the PCM operators\n * @pcm: the pcm instance\n * @direction: stream direction, SNDRV_PCM_STREAM_XXX\n * @ops: the operator table\n *\n * Sets the given PCM operators to the pcm instance.\n */\nvoid snd_pcm_set_ops(struct snd_pcm *pcm, int direction,\n\t\t     const struct snd_pcm_ops *ops)\n{\n\tstruct snd_pcm_str *stream = &pcm->streams[direction];\n\tstruct snd_pcm_substream *substream;\n\t\n\tfor (substream = stream->substream; substream != NULL; substream = substream->next)\n\t\tsubstream->ops = ops;\n}\n\nEXPORT_SYMBOL(snd_pcm_set_ops);\n\n/**\n * snd_pcm_sync - set the PCM sync id\n * @substream: the pcm substream\n *\n * Sets the PCM sync identifier for the card.\n */\nvoid snd_pcm_set_sync(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\n\truntime->sync.id32[0] = substream->pcm->card->number;\n\truntime->sync.id32[1] = -1;\n\truntime->sync.id32[2] = -1;\n\truntime->sync.id32[3] = -1;\n}\n\nEXPORT_SYMBOL(snd_pcm_set_sync);\n\n/*\n *  Standard ioctl routine\n */\n\nstatic inline unsigned int div32(unsigned int a, unsigned int b, \n\t\t\t\t unsigned int *r)\n{\n\tif (b == 0) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\t*r = a % b;\n\treturn a / b;\n}\n\nstatic inline unsigned int div_down(unsigned int a, unsigned int b)\n{\n\tif (b == 0)\n\t\treturn UINT_MAX;\n\treturn a / b;\n}\n\nstatic inline unsigned int div_up(unsigned int a, unsigned int b)\n{\n\tunsigned int r;\n\tunsigned int q;\n\tif (b == 0)\n\t\treturn UINT_MAX;\n\tq = div32(a, b, &r);\n\tif (r)\n\t\t++q;\n\treturn q;\n}\n\nstatic inline unsigned int mul(unsigned int a, unsigned int b)\n{\n\tif (a == 0)\n\t\treturn 0;\n\tif (div_down(UINT_MAX, a) < b)\n\t\treturn UINT_MAX;\n\treturn a * b;\n}\n\nstatic inline unsigned int muldiv32(unsigned int a, unsigned int b,\n\t\t\t\t    unsigned int c, unsigned int *r)\n{\n\tu_int64_t n = (u_int64_t) a * b;\n\tif (c == 0) {\n\t\tsnd_BUG_ON(!n);\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\tn = div_u64_rem(n, c, r);\n\tif (n >= UINT_MAX) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\treturn n;\n}\n\n/**\n * snd_interval_refine - refine the interval value of configurator\n * @i: the interval value to refine\n * @v: the interval value to refer to\n *\n * Refines the interval value with the reference value.\n * The interval is changed to the range satisfying both intervals.\n * The interval status (min, max, integer, etc.) are evaluated.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)\n{\n\tint changed = 0;\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (i->min < v->min) {\n\t\ti->min = v->min;\n\t\ti->openmin = v->openmin;\n\t\tchanged = 1;\n\t} else if (i->min == v->min && !i->openmin && v->openmin) {\n\t\ti->openmin = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->max > v->max) {\n\t\ti->max = v->max;\n\t\ti->openmax = v->openmax;\n\t\tchanged = 1;\n\t} else if (i->max == v->max && !i->openmax && v->openmax) {\n\t\ti->openmax = 1;\n\t\tchanged = 1;\n\t}\n\tif (!i->integer && v->integer) {\n\t\ti->integer = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->integer) {\n\t\tif (i->openmin) {\n\t\t\ti->min++;\n\t\t\ti->openmin = 0;\n\t\t}\n\t\tif (i->openmax) {\n\t\t\ti->max--;\n\t\t\ti->openmax = 0;\n\t\t}\n\t} else if (!i->openmin && !i->openmax && i->min == i->max)\n\t\ti->integer = 1;\n\tif (snd_interval_checkempty(i)) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n\nEXPORT_SYMBOL(snd_interval_refine);\n\nstatic int snd_interval_refine_first(struct snd_interval *i)\n{\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (snd_interval_single(i))\n\t\treturn 0;\n\ti->max = i->min;\n\ti->openmax = i->openmin;\n\tif (i->openmax)\n\t\ti->max++;\n\treturn 1;\n}\n\nstatic int snd_interval_refine_last(struct snd_interval *i)\n{\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (snd_interval_single(i))\n\t\treturn 0;\n\ti->min = i->max;\n\ti->openmin = i->openmax;\n\tif (i->openmin)\n\t\ti->min--;\n\treturn 1;\n}\n\nvoid snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\n{\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = mul(a->min, b->min);\n\tc->openmin = (a->openmin || b->openmin);\n\tc->max = mul(a->max,  b->max);\n\tc->openmax = (a->openmax || b->openmax);\n\tc->integer = (a->integer && b->integer);\n}\n\n/**\n * snd_interval_div - refine the interval value with division\n * @a: dividend\n * @b: divisor\n * @c: quotient\n *\n * c = a / b\n *\n * Returns non-zero if the value is changed, zero if not changed.\n */\nvoid snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = div32(a->min, b->max, &r);\n\tc->openmin = (r || a->openmin || b->openmax);\n\tif (b->min > 0) {\n\t\tc->max = div32(a->max, b->min, &r);\n\t\tif (r) {\n\t\t\tc->max++;\n\t\t\tc->openmax = 1;\n\t\t} else\n\t\t\tc->openmax = (a->openmax || b->openmin);\n\t} else {\n\t\tc->max = UINT_MAX;\n\t\tc->openmax = 0;\n\t}\n\tc->integer = 0;\n}\n\n/**\n * snd_interval_muldivk - refine the interval value\n * @a: dividend 1\n * @b: dividend 2\n * @k: divisor (as integer)\n * @c: result\n  *\n * c = a * b / k\n *\n * Returns non-zero if the value is changed, zero if not changed.\n */\nvoid snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b,\n\t\t      unsigned int k, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = muldiv32(a->min, b->min, k, &r);\n\tc->openmin = (r || a->openmin || b->openmin);\n\tc->max = muldiv32(a->max, b->max, k, &r);\n\tif (r) {\n\t\tc->max++;\n\t\tc->openmax = 1;\n\t} else\n\t\tc->openmax = (a->openmax || b->openmax);\n\tc->integer = 0;\n}\n\n/**\n * snd_interval_mulkdiv - refine the interval value\n * @a: dividend 1\n * @k: dividend 2 (as integer)\n * @b: divisor\n * @c: result\n *\n * c = a * k / b\n *\n * Returns non-zero if the value is changed, zero if not changed.\n */\nvoid snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,\n\t\t      const struct snd_interval *b, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = muldiv32(a->min, k, b->max, &r);\n\tc->openmin = (r || a->openmin || b->openmax);\n\tif (b->min > 0) {\n\t\tc->max = muldiv32(a->max, k, b->min, &r);\n\t\tif (r) {\n\t\t\tc->max++;\n\t\t\tc->openmax = 1;\n\t\t} else\n\t\t\tc->openmax = (a->openmax || b->openmin);\n\t} else {\n\t\tc->max = UINT_MAX;\n\t\tc->openmax = 0;\n\t}\n\tc->integer = 0;\n}\n\n/* ---- */\n\n\n/**\n * snd_interval_ratnum - refine the interval value\n * @i: interval to refine\n * @rats_count: number of ratnum_t \n * @rats: ratnum_t array\n * @nump: pointer to store the resultant numerator\n * @denp: pointer to store the resultant denominator\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_ratnum(struct snd_interval *i,\n\t\t\tunsigned int rats_count, const struct snd_ratnum *rats,\n\t\t\tunsigned int *nump, unsigned int *denp)\n{\n\tunsigned int best_num, best_den;\n\tint best_diff;\n\tunsigned int k;\n\tstruct snd_interval t;\n\tint err;\n\tunsigned int result_num, result_den;\n\tint result_diff;\n\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num = rats[k].num;\n\t\tunsigned int den;\n\t\tunsigned int q = i->min;\n\t\tint diff;\n\t\tif (q == 0)\n\t\t\tq = 1;\n\t\tden = div_up(num, q);\n\t\tif (den < rats[k].den_min)\n\t\t\tcontinue;\n\t\tif (den > rats[k].den_max)\n\t\t\tden = rats[k].den_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (den - rats[k].den_min) % rats[k].den_step;\n\t\t\tif (r != 0)\n\t\t\t\tden -= r;\n\t\t}\n\t\tdiff = num - q * den;\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.min = div_down(best_num, best_den);\n\tt.openmin = !!(best_num % best_den);\n\t\n\tresult_num = best_num;\n\tresult_diff = best_diff;\n\tresult_den = best_den;\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num = rats[k].num;\n\t\tunsigned int den;\n\t\tunsigned int q = i->max;\n\t\tint diff;\n\t\tif (q == 0) {\n\t\t\ti->empty = 1;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tden = div_down(num, q);\n\t\tif (den > rats[k].den_max)\n\t\t\tcontinue;\n\t\tif (den < rats[k].den_min)\n\t\t\tden = rats[k].den_min;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (den - rats[k].den_min) % rats[k].den_step;\n\t\t\tif (r != 0)\n\t\t\t\tden += rats[k].den_step - r;\n\t\t}\n\t\tdiff = q * den - num;\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.max = div_up(best_num, best_den);\n\tt.openmax = !!(best_num % best_den);\n\tt.integer = 0;\n\terr = snd_interval_refine(i, &t);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_interval_single(i)) {\n\t\tif (best_diff * result_den < result_diff * best_den) {\n\t\t\tresult_num = best_num;\n\t\t\tresult_den = best_den;\n\t\t}\n\t\tif (nump)\n\t\t\t*nump = result_num;\n\t\tif (denp)\n\t\t\t*denp = result_den;\n\t}\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_interval_ratnum);\n\n/**\n * snd_interval_ratden - refine the interval value\n * @i: interval to refine\n * @rats_count: number of struct ratden\n * @rats: struct ratden array\n * @nump: pointer to store the resultant numerator\n * @denp: pointer to store the resultant denominator\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nstatic int snd_interval_ratden(struct snd_interval *i,\n\t\t\t       unsigned int rats_count,\n\t\t\t       const struct snd_ratden *rats,\n\t\t\t       unsigned int *nump, unsigned int *denp)\n{\n\tunsigned int best_num, best_diff, best_den;\n\tunsigned int k;\n\tstruct snd_interval t;\n\tint err;\n\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num;\n\t\tunsigned int den = rats[k].den;\n\t\tunsigned int q = i->min;\n\t\tint diff;\n\t\tnum = mul(q, den);\n\t\tif (num > rats[k].num_max)\n\t\t\tcontinue;\n\t\tif (num < rats[k].num_min)\n\t\t\tnum = rats[k].num_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (num - rats[k].num_min) % rats[k].num_step;\n\t\t\tif (r != 0)\n\t\t\t\tnum += rats[k].num_step - r;\n\t\t}\n\t\tdiff = num - q * den;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.min = div_down(best_num, best_den);\n\tt.openmin = !!(best_num % best_den);\n\t\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num;\n\t\tunsigned int den = rats[k].den;\n\t\tunsigned int q = i->max;\n\t\tint diff;\n\t\tnum = mul(q, den);\n\t\tif (num < rats[k].num_min)\n\t\t\tcontinue;\n\t\tif (num > rats[k].num_max)\n\t\t\tnum = rats[k].num_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (num - rats[k].num_min) % rats[k].num_step;\n\t\t\tif (r != 0)\n\t\t\t\tnum -= r;\n\t\t}\n\t\tdiff = q * den - num;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.max = div_up(best_num, best_den);\n\tt.openmax = !!(best_num % best_den);\n\tt.integer = 0;\n\terr = snd_interval_refine(i, &t);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_interval_single(i)) {\n\t\tif (nump)\n\t\t\t*nump = best_num;\n\t\tif (denp)\n\t\t\t*denp = best_den;\n\t}\n\treturn err;\n}\n\n/**\n * snd_interval_list - refine the interval value from the list\n * @i: the interval value to refine\n * @count: the number of elements in the list\n * @list: the value list\n * @mask: the bit-mask to evaluate\n *\n * Refines the interval value from the list.\n * When mask is non-zero, only the elements corresponding to bit 1 are\n * evaluated.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_list(struct snd_interval *i, unsigned int count,\n\t\t      const unsigned int *list, unsigned int mask)\n{\n        unsigned int k;\n\tstruct snd_interval list_range;\n\n\tif (!count) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tsnd_interval_any(&list_range);\n\tlist_range.min = UINT_MAX;\n\tlist_range.max = 0;\n        for (k = 0; k < count; k++) {\n\t\tif (mask && !(mask & (1 << k)))\n\t\t\tcontinue;\n\t\tif (!snd_interval_test(i, list[k]))\n\t\t\tcontinue;\n\t\tlist_range.min = min(list_range.min, list[k]);\n\t\tlist_range.max = max(list_range.max, list[k]);\n        }\n\treturn snd_interval_refine(i, &list_range);\n}\n\nEXPORT_SYMBOL(snd_interval_list);\n\n/**\n * snd_interval_ranges - refine the interval value from the list of ranges\n * @i: the interval value to refine\n * @count: the number of elements in the list of ranges\n * @ranges: the ranges list\n * @mask: the bit-mask to evaluate\n *\n * Refines the interval value from the list of ranges.\n * When mask is non-zero, only the elements corresponding to bit 1 are\n * evaluated.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_ranges(struct snd_interval *i, unsigned int count,\n\t\t\tconst struct snd_interval *ranges, unsigned int mask)\n{\n\tunsigned int k;\n\tstruct snd_interval range_union;\n\tstruct snd_interval range;\n\n\tif (!count) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\tsnd_interval_any(&range_union);\n\trange_union.min = UINT_MAX;\n\trange_union.max = 0;\n\tfor (k = 0; k < count; k++) {\n\t\tif (mask && !(mask & (1 << k)))\n\t\t\tcontinue;\n\t\tsnd_interval_copy(&range, &ranges[k]);\n\t\tif (snd_interval_refine(&range, i) < 0)\n\t\t\tcontinue;\n\t\tif (snd_interval_empty(&range))\n\t\t\tcontinue;\n\n\t\tif (range.min < range_union.min) {\n\t\t\trange_union.min = range.min;\n\t\t\trange_union.openmin = 1;\n\t\t}\n\t\tif (range.min == range_union.min && !range.openmin)\n\t\t\trange_union.openmin = 0;\n\t\tif (range.max > range_union.max) {\n\t\t\trange_union.max = range.max;\n\t\t\trange_union.openmax = 1;\n\t\t}\n\t\tif (range.max == range_union.max && !range.openmax)\n\t\t\trange_union.openmax = 0;\n\t}\n\treturn snd_interval_refine(i, &range_union);\n}\nEXPORT_SYMBOL(snd_interval_ranges);\n\nstatic int snd_interval_step(struct snd_interval *i, unsigned int step)\n{\n\tunsigned int n;\n\tint changed = 0;\n\tn = i->min % step;\n\tif (n != 0 || i->openmin) {\n\t\ti->min += step - n;\n\t\ti->openmin = 0;\n\t\tchanged = 1;\n\t}\n\tn = i->max % step;\n\tif (n != 0 || i->openmax) {\n\t\ti->max -= n;\n\t\ti->openmax = 0;\n\t\tchanged = 1;\n\t}\n\tif (snd_interval_checkempty(i)) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n\n/* Info constraints helpers */\n\n/**\n * snd_pcm_hw_rule_add - add the hw-constraint rule\n * @runtime: the pcm runtime instance\n * @cond: condition bits\n * @var: the variable to evaluate\n * @func: the evaluation function\n * @private: the private data pointer passed to function\n * @dep: the dependent variables\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,\n\t\t\tint var,\n\t\t\tsnd_pcm_hw_rule_func_t func, void *private,\n\t\t\tint dep, ...)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_pcm_hw_rule *c;\n\tunsigned int k;\n\tva_list args;\n\tva_start(args, dep);\n\tif (constrs->rules_num >= constrs->rules_all) {\n\t\tstruct snd_pcm_hw_rule *new;\n\t\tunsigned int new_rules = constrs->rules_all + 16;\n\t\tnew = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);\n\t\tif (!new) {\n\t\t\tva_end(args);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (constrs->rules) {\n\t\t\tmemcpy(new, constrs->rules,\n\t\t\t       constrs->rules_num * sizeof(*c));\n\t\t\tkfree(constrs->rules);\n\t\t}\n\t\tconstrs->rules = new;\n\t\tconstrs->rules_all = new_rules;\n\t}\n\tc = &constrs->rules[constrs->rules_num];\n\tc->cond = cond;\n\tc->func = func;\n\tc->var = var;\n\tc->private = private;\n\tk = 0;\n\twhile (1) {\n\t\tif (snd_BUG_ON(k >= ARRAY_SIZE(c->deps))) {\n\t\t\tva_end(args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tc->deps[k++] = dep;\n\t\tif (dep < 0)\n\t\t\tbreak;\n\t\tdep = va_arg(args, int);\n\t}\n\tconstrs->rules_num++;\n\tva_end(args);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_rule_add);\n\n/**\n * snd_pcm_hw_constraint_mask - apply the given bitmap mask constraint\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the mask\n * @mask: the bitmap mask\n *\n * Apply the constraint of the given bitmap mask to a 32-bit mask parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t       u_int32_t mask)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_mask *maskp = constrs_mask(constrs, var);\n\t*maskp->bits &= mask;\n\tmemset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */\n\tif (*maskp->bits == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n/**\n * snd_pcm_hw_constraint_mask64 - apply the given bitmap mask constraint\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the mask\n * @mask: the 64bit bitmap mask\n *\n * Apply the constraint of the given bitmap mask to a 64-bit mask parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t u_int64_t mask)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_mask *maskp = constrs_mask(constrs, var);\n\tmaskp->bits[0] &= (u_int32_t)mask;\n\tmaskp->bits[1] &= (u_int32_t)(mask >> 32);\n\tmemset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */\n\tif (! maskp->bits[0] && ! maskp->bits[1])\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_mask64);\n\n/**\n * snd_pcm_hw_constraint_integer - apply an integer constraint to an interval\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the integer constraint\n *\n * Apply the constraint of integer to an interval parameter.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\treturn snd_interval_setinteger(constrs_interval(constrs, var));\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_integer);\n\n/**\n * snd_pcm_hw_constraint_minmax - apply a min/max range constraint to an interval\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the range\n * @min: the minimal value\n * @max: the maximal value\n * \n * Apply the min/max range constraint to an interval parameter.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t unsigned int min, unsigned int max)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_interval t;\n\tt.min = min;\n\tt.max = max;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 0;\n\treturn snd_interval_refine(constrs_interval(constrs, var), &t);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);\n\nstatic int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_hw_constraint_list *list = rule->private;\n\treturn snd_interval_list(hw_param_interval(params, rule->var), list->count, list->list, list->mask);\n}\t\t\n\n\n/**\n * snd_pcm_hw_constraint_list - apply a list of constraints to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the list constraint\n * @l: list\n * \n * Apply the list of constraints to an interval parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       const struct snd_pcm_hw_constraint_list *l)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_list, (void *)l,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_list);\n\nstatic int snd_pcm_hw_rule_ranges(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_hw_constraint_ranges *r = rule->private;\n\treturn snd_interval_ranges(hw_param_interval(params, rule->var),\n\t\t\t\t   r->count, r->ranges, r->mask);\n}\n\n\n/**\n * snd_pcm_hw_constraint_ranges - apply list of range constraints to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the list of range constraints\n * @r: ranges\n *\n * Apply the list of range constraints to an interval parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,\n\t\t\t\t unsigned int cond,\n\t\t\t\t snd_pcm_hw_param_t var,\n\t\t\t\t const struct snd_pcm_hw_constraint_ranges *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ranges, (void *)r,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ranges);\n\nstatic int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tconst struct snd_pcm_hw_constraint_ratnums *r = rule->private;\n\tunsigned int num = 0, den = 0;\n\tint err;\n\terr = snd_interval_ratnum(hw_param_interval(params, rule->var),\n\t\t\t\t  r->nrats, r->rats, &num, &den);\n\tif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\n\t\tparams->rate_num = num;\n\t\tparams->rate_den = den;\n\t}\n\treturn err;\n}\n\n/**\n * snd_pcm_hw_constraint_ratnums - apply ratnums constraint to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the ratnums constraint\n * @r: struct snd_ratnums constriants\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratnums *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ratnums, (void *)r,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);\n\nstatic int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tconst struct snd_pcm_hw_constraint_ratdens *r = rule->private;\n\tunsigned int num = 0, den = 0;\n\tint err = snd_interval_ratden(hw_param_interval(params, rule->var),\n\t\t\t\t  r->nrats, r->rats, &num, &den);\n\tif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\n\t\tparams->rate_num = num;\n\t\tparams->rate_den = den;\n\t}\n\treturn err;\n}\n\n/**\n * snd_pcm_hw_constraint_ratdens - apply ratdens constraint to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the ratdens constraint\n * @r: struct snd_ratdens constriants\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratdens *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ratdens, (void *)r,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);\n\nstatic int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int l = (unsigned long) rule->private;\n\tint width = l & 0xffff;\n\tunsigned int msbits = l >> 16;\n\tstruct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);\n\n\tif (!snd_interval_single(i))\n\t\treturn 0;\n\n\tif ((snd_interval_value(i) == width) ||\n\t    (width == 0 && snd_interval_value(i) > msbits))\n\t\tparams->msbits = min_not_zero(params->msbits, msbits);\n\n\treturn 0;\n}\n\n/**\n * snd_pcm_hw_constraint_msbits - add a hw constraint msbits rule\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @width: sample bits width\n * @msbits: msbits width\n *\n * This constraint will set the number of most significant bits (msbits) if a\n * sample format with the specified width has been select. If width is set to 0\n * the msbits will be set for any sample format with a width larger than the\n * specified msbits.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, \n\t\t\t\t unsigned int cond,\n\t\t\t\t unsigned int width,\n\t\t\t\t unsigned int msbits)\n{\n\tunsigned long l = (msbits << 16) | width;\n\treturn snd_pcm_hw_rule_add(runtime, cond, -1,\n\t\t\t\t    snd_pcm_hw_rule_msbits,\n\t\t\t\t    (void*) l,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);\n\nstatic int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tunsigned long step = (unsigned long) rule->private;\n\treturn snd_interval_step(hw_param_interval(params, rule->var), step);\n}\n\n/**\n * snd_pcm_hw_constraint_step - add a hw constraint step rule\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the step constraint\n * @step: step size\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       unsigned long step)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var, \n\t\t\t\t   snd_pcm_hw_rule_step, (void *) step,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_step);\n\nstatic int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\n{\n\tstatic unsigned int pow2_sizes[] = {\n\t\t1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,\n\t\t1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,\n\t\t1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,\n\t\t1<<24, 1<<25, 1<<26, 1<<27, 1<<28, 1<<29, 1<<30\n\t};\n\treturn snd_interval_list(hw_param_interval(params, rule->var),\n\t\t\t\t ARRAY_SIZE(pow2_sizes), pow2_sizes, 0);\n}\t\t\n\n/**\n * snd_pcm_hw_constraint_pow2 - add a hw constraint power-of-2 rule\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the power-of-2 constraint\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var, \n\t\t\t\t   snd_pcm_hw_rule_pow2, NULL,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);\n\nstatic int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int base_rate = (unsigned int)(uintptr_t)rule->private;\n\tstruct snd_interval *rate;\n\n\trate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\treturn snd_interval_list(rate, 1, &base_rate, 0);\n}\n\n/**\n * snd_pcm_hw_rule_noresample - add a rule to allow disabling hw resampling\n * @runtime: PCM runtime instance\n * @base_rate: the rate at which the hardware does not resample\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int base_rate)\n{\n\treturn snd_pcm_hw_rule_add(runtime, SNDRV_PCM_HW_PARAMS_NORESAMPLE,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   snd_pcm_hw_rule_noresample_func,\n\t\t\t\t   (void *)(uintptr_t)base_rate,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_rule_noresample);\n\nstatic void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,\n\t\t\t\t  snd_pcm_hw_param_t var)\n{\n\tif (hw_is_mask(var)) {\n\t\tsnd_mask_any(hw_param_mask(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t\treturn;\n\t}\n\tif (hw_is_interval(var)) {\n\t\tsnd_interval_any(hw_param_interval(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t\treturn;\n\t}\n\tsnd_BUG();\n}\n\nvoid _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)\n{\n\tunsigned int k;\n\tmemset(params, 0, sizeof(*params));\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)\n\t\t_snd_pcm_hw_param_any(params, k);\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)\n\t\t_snd_pcm_hw_param_any(params, k);\n\tparams->info = ~0U;\n}\n\nEXPORT_SYMBOL(_snd_pcm_hw_params_any);\n\n/**\n * snd_pcm_hw_param_value - return @params field @var value\n * @params: the hw_params instance\n * @var: parameter to retrieve\n * @dir: pointer to the direction (-1,0,1) or %NULL\n *\n * Return: The value for field @var if it's fixed in configuration space\n * defined by @params. -%EINVAL otherwise.\n */\nint snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,\n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tif (hw_is_mask(var)) {\n\t\tconst struct snd_mask *mask = hw_param_mask_c(params, var);\n\t\tif (!snd_mask_single(mask))\n\t\t\treturn -EINVAL;\n\t\tif (dir)\n\t\t\t*dir = 0;\n\t\treturn snd_mask_value(mask);\n\t}\n\tif (hw_is_interval(var)) {\n\t\tconst struct snd_interval *i = hw_param_interval_c(params, var);\n\t\tif (!snd_interval_single(i))\n\t\t\treturn -EINVAL;\n\t\tif (dir)\n\t\t\t*dir = i->openmin;\n\t\treturn snd_interval_value(i);\n\t}\n\treturn -EINVAL;\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_param_value);\n\nvoid _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,\n\t\t\t\tsnd_pcm_hw_param_t var)\n{\n\tif (hw_is_mask(var)) {\n\t\tsnd_mask_none(hw_param_mask(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t} else if (hw_is_interval(var)) {\n\t\tsnd_interval_none(hw_param_interval(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t} else {\n\t\tsnd_BUG();\n\t}\n}\n\nEXPORT_SYMBOL(_snd_pcm_hw_param_setempty);\n\nstatic int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,\n\t\t\t\t   snd_pcm_hw_param_t var)\n{\n\tint changed;\n\tif (hw_is_mask(var))\n\t\tchanged = snd_mask_refine_first(hw_param_mask(params, var));\n\telse if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_first(hw_param_interval(params, var));\n\telse\n\t\treturn -EINVAL;\n\tif (changed) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n\n/**\n * snd_pcm_hw_param_first - refine config space and return minimum value\n * @pcm: PCM instance\n * @params: the hw_params instance\n * @var: parameter to retrieve\n * @dir: pointer to the direction (-1,0,1) or %NULL\n *\n * Inside configuration space defined by @params remove from @var all\n * values > minimum. Reduce configuration space accordingly.\n *\n * Return: The minimum, or a negative error code on failure.\n */\nint snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, \n\t\t\t   struct snd_pcm_hw_params *params, \n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tint changed = _snd_pcm_hw_param_first(params, var);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (snd_BUG_ON(err < 0))\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value(params, var, dir);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_param_first);\n\nstatic int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,\n\t\t\t\t  snd_pcm_hw_param_t var)\n{\n\tint changed;\n\tif (hw_is_mask(var))\n\t\tchanged = snd_mask_refine_last(hw_param_mask(params, var));\n\telse if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_last(hw_param_interval(params, var));\n\telse\n\t\treturn -EINVAL;\n\tif (changed) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n\n/**\n * snd_pcm_hw_param_last - refine config space and return maximum value\n * @pcm: PCM instance\n * @params: the hw_params instance\n * @var: parameter to retrieve\n * @dir: pointer to the direction (-1,0,1) or %NULL\n *\n * Inside configuration space defined by @params remove from @var all\n * values < maximum. Reduce configuration space accordingly.\n *\n * Return: The maximum, or a negative error code on failure.\n */\nint snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, \n\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t  snd_pcm_hw_param_t var, int *dir)\n{\n\tint changed = _snd_pcm_hw_param_last(params, var);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (snd_BUG_ON(err < 0))\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value(params, var, dir);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_param_last);\n\n/**\n * snd_pcm_hw_param_choose - choose a configuration defined by @params\n * @pcm: PCM instance\n * @params: the hw_params instance\n *\n * Choose one configuration from configuration space defined by @params.\n * The configuration chosen is that obtained fixing in this order:\n * first access, first format, first subformat, min channels,\n * min rate, min period time, max buffer size, min tick time\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstatic int vars[] = {\n\t\tSNDRV_PCM_HW_PARAM_ACCESS,\n\t\tSNDRV_PCM_HW_PARAM_FORMAT,\n\t\tSNDRV_PCM_HW_PARAM_SUBFORMAT,\n\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\tSNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\tSNDRV_PCM_HW_PARAM_TICK_TIME,\n\t\t-1\n\t};\n\tint err, *v;\n\n\tfor (v = vars; *v != -1; v++) {\n\t\tif (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)\n\t\t\terr = snd_pcm_hw_param_first(pcm, params, *v, NULL);\n\t\telse\n\t\t\terr = snd_pcm_hw_param_last(pcm, params, *v, NULL);\n\t\tif (snd_BUG_ON(err < 0))\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,\n\t\t\t\t   void *arg)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long flags;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (snd_pcm_running(substream) &&\n\t    snd_pcm_update_hw_ptr(substream) >= 0)\n\t\truntime->status->hw_ptr %= runtime->buffer_size;\n\telse {\n\t\truntime->status->hw_ptr = 0;\n\t\truntime->hw_ptr_wrap = 0;\n\t}\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_channel_info(struct snd_pcm_substream *substream,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_pcm_channel_info *info = arg;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint width;\n\tif (!(runtime->info & SNDRV_PCM_INFO_MMAP)) {\n\t\tinfo->offset = -1;\n\t\treturn 0;\n\t}\n\twidth = snd_pcm_format_physical_width(runtime->format);\n\tif (width < 0)\n\t\treturn width;\n\tinfo->offset = 0;\n\tswitch (runtime->access) {\n\tcase SNDRV_PCM_ACCESS_MMAP_INTERLEAVED:\n\tcase SNDRV_PCM_ACCESS_RW_INTERLEAVED:\n\t\tinfo->first = info->channel * width;\n\t\tinfo->step = runtime->channels * width;\n\t\tbreak;\n\tcase SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED:\n\tcase SNDRV_PCM_ACCESS_RW_NONINTERLEAVED:\n\t{\n\t\tsize_t size = runtime->dma_bytes / runtime->channels;\n\t\tinfo->first = info->channel * size * 8;\n\t\tinfo->step = width;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,\n\t\t\t\t       void *arg)\n{\n\tstruct snd_pcm_hw_params *params = arg;\n\tsnd_pcm_format_t format;\n\tint channels;\n\tssize_t frame_size;\n\n\tparams->fifo_size = substream->runtime->hw.fifo_size;\n\tif (!(substream->runtime->hw.info & SNDRV_PCM_INFO_FIFO_IN_FRAMES)) {\n\t\tformat = params_format(params);\n\t\tchannels = params_channels(params);\n\t\tframe_size = snd_pcm_format_size(format, channels);\n\t\tif (frame_size > 0)\n\t\t\tparams->fifo_size /= (unsigned)frame_size;\n\t}\n\treturn 0;\n}\n\n/**\n * snd_pcm_lib_ioctl - a generic PCM ioctl callback\n * @substream: the pcm substream instance\n * @cmd: ioctl command\n * @arg: ioctl argument\n *\n * Processes the generic ioctl commands for PCM.\n * Can be passed as the ioctl callback for PCM ops.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,\n\t\t      unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_INFO:\n\t\treturn 0;\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\treturn snd_pcm_lib_ioctl_reset(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t\treturn snd_pcm_lib_ioctl_channel_info(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_FIFO_SIZE:\n\t\treturn snd_pcm_lib_ioctl_fifo_size(substream, arg);\n\t}\n\treturn -ENXIO;\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_ioctl);\n\n/**\n * snd_pcm_period_elapsed - update the pcm status for the next period\n * @substream: the pcm substream instance\n *\n * This function is called from the interrupt handler when the\n * PCM has processed the period size.  It will update the current\n * pointer, wake up sleepers, etc.\n *\n * Even if more than one periods have elapsed since the last call, you\n * have to call this only once.\n */\nvoid snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}\n\nEXPORT_SYMBOL(snd_pcm_period_elapsed);\n\n/*\n * Wait until avail_min data becomes available\n * Returns a negative error code if any error occurs during operation.\n * The available space is stored on availp.  When err = 0 and avail = 0\n * on the capture stream, it indicates the stream is in DRAINING state.\n */\nstatic int wait_for_avail(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_uframes_t *availp)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\twait_queue_t wait;\n\tint err = 0;\n\tsnd_pcm_uframes_t avail = 0;\n\tlong wait_time, tout;\n\n\tinit_waitqueue_entry(&wait, current);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&runtime->tsleep, &wait);\n\n\tif (runtime->no_period_wakeup)\n\t\twait_time = MAX_SCHEDULE_TIMEOUT;\n\telse {\n\t\twait_time = 10;\n\t\tif (runtime->rate) {\n\t\t\tlong t = runtime->period_size * 2 / runtime->rate;\n\t\t\twait_time = max(t, wait_time);\n\t\t}\n\t\twait_time = msecs_to_jiffies(wait_time * 1000);\n\t}\n\n\tfor (;;) {\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to check if space became available already\n\t\t * (and thus the wakeup happened already) first to close\n\t\t * the race of space already having become available.\n\t\t * This check must happen after been added to the waitqueue\n\t\t * and having current state be INTERRUPTIBLE.\n\t\t */\n\t\tif (is_playback)\n\t\t\tavail = snd_pcm_playback_avail(runtime);\n\t\telse\n\t\t\tavail = snd_pcm_capture_avail(runtime);\n\t\tif (avail >= runtime->twake)\n\t\t\tbreak;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\n\t\ttout = schedule_timeout(wait_time);\n\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tswitch (runtime->status->state) {\n\t\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\t\terr = -ESTRPIPE;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\terr = -EPIPE;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_DRAINING:\n\t\t\tif (is_playback)\n\t\t\t\terr = -EPIPE;\n\t\t\telse \n\t\t\t\tavail = 0; /* indicate draining */\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_OPEN:\n\t\tcase SNDRV_PCM_STATE_SETUP:\n\t\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\t\t\terr = -EBADFD;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_PAUSED:\n\t\t\tcontinue;\n\t\t}\n\t\tif (!tout) {\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"%s write error (DMA or IRQ trouble?)\\n\",\n\t\t\t\tis_playback ? \"playback\" : \"capture\");\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n _endloop:\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&runtime->tsleep, &wait);\n\t*availp = avail;\n\treturn err;\n}\n\t\nstatic int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t      unsigned int hwoff,\n\t\t\t\t      unsigned long data, unsigned int off,\n\t\t\t\t      snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tchar __user *buf = (char __user *) data + frames_to_bytes(runtime, off);\n\tif (substream->ops->copy) {\n\t\tif ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)\n\t\t\treturn err;\n\t} else {\n\t\tchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);\n\t\tif (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n \ntypedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,\n\t\t\t  unsigned long data, unsigned int off,\n\t\t\t  snd_pcm_uframes_t size);\n\nstatic snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream, \n\t\t\t\t\t    unsigned long data,\n\t\t\t\t\t    snd_pcm_uframes_t size,\n\t\t\t\t\t    int nonblock,\n\t\t\t\t\t    transfer_f transfer)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t xfer = 0;\n\tsnd_pcm_uframes_t offset = 0;\n\tsnd_pcm_uframes_t avail;\n\tint err = 0;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->status->state) {\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\terr = -EPIPE;\n\t\tgoto _end_unlock;\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\terr = -ESTRPIPE;\n\t\tgoto _end_unlock;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto _end_unlock;\n\t}\n\n\truntime->twake = runtime->control->avail_min ? : 1;\n\tif (runtime->status->state == SNDRV_PCM_STATE_RUNNING)\n\t\tsnd_pcm_update_hw_ptr(substream);\n\tavail = snd_pcm_playback_avail(runtime);\n\twhile (size > 0) {\n\t\tsnd_pcm_uframes_t frames, appl_ptr, appl_ofs;\n\t\tsnd_pcm_uframes_t cont;\n\t\tif (!avail) {\n\t\t\tif (nonblock) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\truntime->twake = min_t(snd_pcm_uframes_t, size,\n\t\t\t\t\truntime->control->avail_min ? : 1);\n\t\t\terr = wait_for_avail(substream, &avail);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t}\n\t\tframes = size > avail ? avail : size;\n\t\tcont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;\n\t\tif (frames > cont)\n\t\t\tframes = cont;\n\t\tif (snd_BUG_ON(!frames)) {\n\t\t\truntime->twake = 0;\n\t\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tappl_ptr = runtime->control->appl_ptr;\n\t\tappl_ofs = appl_ptr % runtime->buffer_size;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\terr = transfer(substream, appl_ofs, data, offset, frames);\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\t\tswitch (runtime->status->state) {\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\terr = -EPIPE;\n\t\t\tgoto _end_unlock;\n\t\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\t\terr = -ESTRPIPE;\n\t\t\tgoto _end_unlock;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tappl_ptr += frames;\n\t\tif (appl_ptr >= runtime->boundary)\n\t\t\tappl_ptr -= runtime->boundary;\n\t\truntime->control->appl_ptr = appl_ptr;\n\t\tif (substream->ops->ack)\n\t\t\tsubstream->ops->ack(substream);\n\n\t\toffset += frames;\n\t\tsize -= frames;\n\t\txfer += frames;\n\t\tavail -= frames;\n\t\tif (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&\n\t\t    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {\n\t\t\terr = snd_pcm_start(substream);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t}\n\t}\n _end_unlock:\n\truntime->twake = 0;\n\tif (xfer > 0 && err >= 0)\n\t\tsnd_pcm_update_state(substream, runtime);\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn xfer > 0 ? (snd_pcm_sframes_t)xfer : err;\n}\n\n/* sanity-check for read/write methods */\nstatic int pcm_sanity_check(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))\n\t\treturn -EINVAL;\n\tif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\treturn 0;\n}\n\nsnd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&\n\t    runtime->channels > 1)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_write1(substream, (unsigned long)buf, size, nonblock,\n\t\t\t\t  snd_pcm_lib_write_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_write);\n\nstatic int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t       unsigned int hwoff,\n\t\t\t\t       unsigned long data, unsigned int off,\n\t\t\t\t       snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tvoid __user **bufs = (void __user **)data;\n\tint channels = runtime->channels;\n\tint c;\n\tif (substream->ops->copy) {\n\t\tif (snd_BUG_ON(!substream->ops->silence))\n\t\t\treturn -EINVAL;\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tif (*bufs == NULL) {\n\t\t\t\tif ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tchar __user *buf = *bufs + samples_to_bytes(runtime, off);\n\t\t\t\tif ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* default transfer behaviour */\n\t\tsize_t dma_csize = runtime->dma_bytes / channels;\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tchar *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);\n\t\t\tif (*bufs == NULL) {\n\t\t\t\tsnd_pcm_format_set_silence(runtime->format, hwbuf, frames);\n\t\t\t} else {\n\t\t\t\tchar __user *buf = *bufs + samples_to_bytes(runtime, off);\n\t\t\t\tif (copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nsnd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,\n\t\t\t\t     void __user **bufs,\n\t\t\t\t     snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_write1(substream, (unsigned long)bufs, frames,\n\t\t\t\t  nonblock, snd_pcm_lib_writev_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_writev);\n\nstatic int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, \n\t\t\t\t     unsigned int hwoff,\n\t\t\t\t     unsigned long data, unsigned int off,\n\t\t\t\t     snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tchar __user *buf = (char __user *) data + frames_to_bytes(runtime, off);\n\tif (substream->ops->copy) {\n\t\tif ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)\n\t\t\treturn err;\n\t} else {\n\t\tchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);\n\t\tif (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,\n\t\t\t\t\t   unsigned long data,\n\t\t\t\t\t   snd_pcm_uframes_t size,\n\t\t\t\t\t   int nonblock,\n\t\t\t\t\t   transfer_f transfer)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t xfer = 0;\n\tsnd_pcm_uframes_t offset = 0;\n\tsnd_pcm_uframes_t avail;\n\tint err = 0;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->status->state) {\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tif (size >= runtime->start_threshold) {\n\t\t\terr = snd_pcm_start(substream);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_DRAINING:\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\terr = -EPIPE;\n\t\tgoto _end_unlock;\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\terr = -ESTRPIPE;\n\t\tgoto _end_unlock;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto _end_unlock;\n\t}\n\n\truntime->twake = runtime->control->avail_min ? : 1;\n\tif (runtime->status->state == SNDRV_PCM_STATE_RUNNING)\n\t\tsnd_pcm_update_hw_ptr(substream);\n\tavail = snd_pcm_capture_avail(runtime);\n\twhile (size > 0) {\n\t\tsnd_pcm_uframes_t frames, appl_ptr, appl_ofs;\n\t\tsnd_pcm_uframes_t cont;\n\t\tif (!avail) {\n\t\t\tif (runtime->status->state ==\n\t\t\t    SNDRV_PCM_STATE_DRAINING) {\n\t\t\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\tif (nonblock) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\truntime->twake = min_t(snd_pcm_uframes_t, size,\n\t\t\t\t\truntime->control->avail_min ? : 1);\n\t\t\terr = wait_for_avail(substream, &avail);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t\tif (!avail)\n\t\t\t\tcontinue; /* draining */\n\t\t}\n\t\tframes = size > avail ? avail : size;\n\t\tcont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;\n\t\tif (frames > cont)\n\t\t\tframes = cont;\n\t\tif (snd_BUG_ON(!frames)) {\n\t\t\truntime->twake = 0;\n\t\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tappl_ptr = runtime->control->appl_ptr;\n\t\tappl_ofs = appl_ptr % runtime->buffer_size;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\terr = transfer(substream, appl_ofs, data, offset, frames);\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\t\tswitch (runtime->status->state) {\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\terr = -EPIPE;\n\t\t\tgoto _end_unlock;\n\t\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\t\terr = -ESTRPIPE;\n\t\t\tgoto _end_unlock;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tappl_ptr += frames;\n\t\tif (appl_ptr >= runtime->boundary)\n\t\t\tappl_ptr -= runtime->boundary;\n\t\truntime->control->appl_ptr = appl_ptr;\n\t\tif (substream->ops->ack)\n\t\t\tsubstream->ops->ack(substream);\n\n\t\toffset += frames;\n\t\tsize -= frames;\n\t\txfer += frames;\n\t\tavail -= frames;\n\t}\n _end_unlock:\n\truntime->twake = 0;\n\tif (xfer > 0 && err >= 0)\n\t\tsnd_pcm_update_state(substream, runtime);\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn xfer > 0 ? (snd_pcm_sframes_t)xfer : err;\n}\n\nsnd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __user *buf, snd_pcm_uframes_t size)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\t\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_read);\n\nstatic int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t      unsigned int hwoff,\n\t\t\t\t      unsigned long data, unsigned int off,\n\t\t\t\t      snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tvoid __user **bufs = (void __user **)data;\n\tint channels = runtime->channels;\n\tint c;\n\tif (substream->ops->copy) {\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tchar __user *buf;\n\t\t\tif (*bufs == NULL)\n\t\t\t\tcontinue;\n\t\t\tbuf = *bufs + samples_to_bytes(runtime, off);\n\t\t\tif ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tsnd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tchar *hwbuf;\n\t\t\tchar __user *buf;\n\t\t\tif (*bufs == NULL)\n\t\t\t\tcontinue;\n\n\t\t\thwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);\n\t\t\tbuf = *bufs + samples_to_bytes(runtime, off);\n\t\t\tif (copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n \nsnd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,\n\t\t\t\t    void __user **bufs,\n\t\t\t\t    snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_readv);\n\n/*\n * standard channel mapping helpers\n */\n\n/* default channel maps for multi-channel playbacks, up to 8 channels */\nconst struct snd_pcm_chmap_elem snd_pcm_std_chmaps[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },\n\t{ .channels = 8,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(snd_pcm_std_chmaps);\n\n/* alternative channel maps with CLFE <-> surround swapped for 6/8 channels */\nconst struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 8,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(snd_pcm_alt_chmaps);\n\nstatic bool valid_chmap_channels(const struct snd_pcm_chmap *info, int ch)\n{\n\tif (ch > info->max_channels)\n\t\treturn false;\n\treturn !info->channel_mask || (info->channel_mask & (1U << ch));\n}\n\nstatic int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 0;\n\tuinfo->count = info->max_channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_LAST;\n\treturn 0;\n}\n\n/* get callback for channel map ctl element\n * stores the channel position firstly matching with the current channels\n */\nstatic int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_pcm_substream *substream;\n\tconst struct snd_pcm_chmap_elem *map;\n\n\tif (snd_BUG_ON(!info->chmap))\n\t\treturn -EINVAL;\n\tsubstream = snd_pcm_chmap_substream(info, idx);\n\tif (!substream)\n\t\treturn -ENODEV;\n\tmemset(ucontrol->value.integer.value, 0,\n\t       sizeof(ucontrol->value.integer.value));\n\tif (!substream->runtime)\n\t\treturn 0; /* no channels set */\n\tfor (map = info->chmap; map->channels; map++) {\n\t\tint i;\n\t\tif (map->channels == substream->runtime->channels &&\n\t\t    valid_chmap_channels(info, map->channels)) {\n\t\t\tfor (i = 0; i < map->channels; i++)\n\t\t\t\tucontrol->value.integer.value[i] = map->map[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n/* tlv callback for channel map ctl element\n * expands the pre-defined channel maps in a form of TLV\n */\nstatic int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t     unsigned int size, unsigned int __user *tlv)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_pcm_chmap_elem *map;\n\tunsigned int __user *dst;\n\tint c, count = 0;\n\n\tif (snd_BUG_ON(!info->chmap))\n\t\treturn -EINVAL;\n\tif (size < 8)\n\t\treturn -ENOMEM;\n\tif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\n\t\treturn -EFAULT;\n\tsize -= 8;\n\tdst = tlv + 2;\n\tfor (map = info->chmap; map->channels; map++) {\n\t\tint chs_bytes = map->channels * 4;\n\t\tif (!valid_chmap_channels(info, map->channels))\n\t\t\tcontinue;\n\t\tif (size < 8)\n\t\t\treturn -ENOMEM;\n\t\tif (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||\n\t\t    put_user(chs_bytes, dst + 1))\n\t\t\treturn -EFAULT;\n\t\tdst += 2;\n\t\tsize -= 8;\n\t\tcount += 8;\n\t\tif (size < chs_bytes)\n\t\t\treturn -ENOMEM;\n\t\tsize -= chs_bytes;\n\t\tcount += chs_bytes;\n\t\tfor (c = 0; c < map->channels; c++) {\n\t\t\tif (put_user(map->map[c], dst))\n\t\t\t\treturn -EFAULT;\n\t\t\tdst++;\n\t\t}\n\t}\n\tif (put_user(count, tlv + 1))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void pcm_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tinfo->pcm->streams[info->stream].chmap_kctl = NULL;\n\tkfree(info);\n}\n\n/**\n * snd_pcm_add_chmap_ctls - create channel-mapping control elements\n * @pcm: the assigned PCM instance\n * @stream: stream direction\n * @chmap: channel map elements (for query)\n * @max_channels: the max number of channels for the stream\n * @private_value: the value passed to each kcontrol's private_value field\n * @info_ret: store struct snd_pcm_chmap instance if non-NULL\n *\n * Create channel-mapping control elements assigned to the given PCM stream(s).\n * Return: Zero if successful, or a negative error value.\n */\nint snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,\n\t\t\t   const struct snd_pcm_chmap_elem *chmap,\n\t\t\t   int max_channels,\n\t\t\t   unsigned long private_value,\n\t\t\t   struct snd_pcm_chmap **info_ret)\n{\n\tstruct snd_pcm_chmap *info;\n\tstruct snd_kcontrol_new knew = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,\n\t\t.info = pcm_chmap_ctl_info,\n\t\t.get = pcm_chmap_ctl_get,\n\t\t.tlv.c = pcm_chmap_ctl_tlv,\n\t};\n\tint err;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->pcm = pcm;\n\tinfo->stream = stream;\n\tinfo->chmap = chmap;\n\tinfo->max_channels = max_channels;\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tknew.name = \"Playback Channel Map\";\n\telse\n\t\tknew.name = \"Capture Channel Map\";\n\tknew.device = pcm->device;\n\tknew.count = pcm->streams[stream].substream_count;\n\tknew.private_value = private_value;\n\tinfo->kctl = snd_ctl_new1(&knew, info);\n\tif (!info->kctl) {\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->kctl->private_free = pcm_chmap_ctl_private_free;\n\terr = snd_ctl_add(pcm->card, info->kctl);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->streams[stream].chmap_kctl = info->kctl;\n\tif (info_ret)\n\t\t*info_ret = info;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_pcm_add_chmap_ctls);\n"], "fixing_code": ["/*\n *  Digital Audio (PCM) abstract layer\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *                   Abramo Bagnara <abramo@alsa-project.org>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/timer.h>\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n#define CREATE_TRACE_POINTS\n#include \"pcm_trace.h\"\n#else\n#define trace_hwptr(substream, pos, in_interrupt)\n#define trace_xrun(substream)\n#define trace_hw_ptr_error(substream, reason)\n#endif\n\n/*\n * fill ring buffer with silence\n * runtime->silence_start: starting pointer to silence area\n * runtime->silence_filled: size filled with silence\n * runtime->silence_threshold: threshold from application\n * runtime->silence_size: maximal size from application\n *\n * when runtime->silence_size >= runtime->boundary - fill processed area with silence immediately\n */\nvoid snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t frames, ofs, transfer;\n\n\tif (runtime->silence_size < runtime->boundary) {\n\t\tsnd_pcm_sframes_t noise_dist, n;\n\t\tif (runtime->silence_start != runtime->control->appl_ptr) {\n\t\t\tn = runtime->control->appl_ptr - runtime->silence_start;\n\t\t\tif (n < 0)\n\t\t\t\tn += runtime->boundary;\n\t\t\tif ((snd_pcm_uframes_t)n < runtime->silence_filled)\n\t\t\t\truntime->silence_filled -= n;\n\t\t\telse\n\t\t\t\truntime->silence_filled = 0;\n\t\t\truntime->silence_start = runtime->control->appl_ptr;\n\t\t}\n\t\tif (runtime->silence_filled >= runtime->buffer_size)\n\t\t\treturn;\n\t\tnoise_dist = snd_pcm_playback_hw_avail(runtime) + runtime->silence_filled;\n\t\tif (noise_dist >= (snd_pcm_sframes_t) runtime->silence_threshold)\n\t\t\treturn;\n\t\tframes = runtime->silence_threshold - noise_dist;\n\t\tif (frames > runtime->silence_size)\n\t\t\tframes = runtime->silence_size;\n\t} else {\n\t\tif (new_hw_ptr == ULONG_MAX) {\t/* initialization */\n\t\t\tsnd_pcm_sframes_t avail = snd_pcm_playback_hw_avail(runtime);\n\t\t\tif (avail > runtime->buffer_size)\n\t\t\t\tavail = runtime->buffer_size;\n\t\t\truntime->silence_filled = avail > 0 ? avail : 0;\n\t\t\truntime->silence_start = (runtime->status->hw_ptr +\n\t\t\t\t\t\t  runtime->silence_filled) %\n\t\t\t\t\t\t runtime->boundary;\n\t\t} else {\n\t\t\tofs = runtime->status->hw_ptr;\n\t\t\tframes = new_hw_ptr - ofs;\n\t\t\tif ((snd_pcm_sframes_t)frames < 0)\n\t\t\t\tframes += runtime->boundary;\n\t\t\truntime->silence_filled -= frames;\n\t\t\tif ((snd_pcm_sframes_t)runtime->silence_filled < 0) {\n\t\t\t\truntime->silence_filled = 0;\n\t\t\t\truntime->silence_start = new_hw_ptr;\n\t\t\t} else {\n\t\t\t\truntime->silence_start = ofs;\n\t\t\t}\n\t\t}\n\t\tframes = runtime->buffer_size - runtime->silence_filled;\n\t}\n\tif (snd_BUG_ON(frames > runtime->buffer_size))\n\t\treturn;\n\tif (frames == 0)\n\t\treturn;\n\tofs = runtime->silence_start % runtime->buffer_size;\n\twhile (frames > 0) {\n\t\ttransfer = ofs + frames > runtime->buffer_size ? runtime->buffer_size - ofs : frames;\n\t\tif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||\n\t\t    runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {\n\t\t\tif (substream->ops->silence) {\n\t\t\t\tint err;\n\t\t\t\terr = substream->ops->silence(substream, -1, ofs, transfer);\n\t\t\t\tsnd_BUG_ON(err < 0);\n\t\t\t} else {\n\t\t\t\tchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, ofs);\n\t\t\t\tsnd_pcm_format_set_silence(runtime->format, hwbuf, transfer * runtime->channels);\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int c;\n\t\t\tunsigned int channels = runtime->channels;\n\t\t\tif (substream->ops->silence) {\n\t\t\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t\t\tint err;\n\t\t\t\t\terr = substream->ops->silence(substream, c, ofs, transfer);\n\t\t\t\t\tsnd_BUG_ON(err < 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsize_t dma_csize = runtime->dma_bytes / channels;\n\t\t\t\tfor (c = 0; c < channels; ++c) {\n\t\t\t\t\tchar *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, ofs);\n\t\t\t\t\tsnd_pcm_format_set_silence(runtime->format, hwbuf, transfer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\truntime->silence_filled += transfer;\n\t\tframes -= transfer;\n\t\tofs = 0;\n\t}\n}\n\n#ifdef CONFIG_SND_DEBUG\nvoid snd_pcm_debug_name(struct snd_pcm_substream *substream,\n\t\t\t   char *name, size_t len)\n{\n\tsnprintf(name, len, \"pcmC%dD%d%c:%d\",\n\t\t substream->pcm->card->number,\n\t\t substream->pcm->device,\n\t\t substream->stream ? 'c' : 'p',\n\t\t substream->number);\n}\nEXPORT_SYMBOL(snd_pcm_debug_name);\n#endif\n\n#define XRUN_DEBUG_BASIC\t(1<<0)\n#define XRUN_DEBUG_STACK\t(1<<1)\t/* dump also stack */\n#define XRUN_DEBUG_JIFFIESCHECK\t(1<<2)\t/* do jiffies check */\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n\n#define xrun_debug(substream, mask) \\\n\t\t\t((substream)->pstr->xrun_debug & (mask))\n#else\n#define xrun_debug(substream, mask)\t0\n#endif\n\n#define dump_stack_on_xrun(substream) do {\t\t\t\\\n\t\tif (xrun_debug(substream, XRUN_DEBUG_STACK))\t\\\n\t\t\tdump_stack();\t\t\t\t\\\n\t} while (0)\n\nstatic void xrun(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\ttrace_xrun(substream);\n\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)\n\t\tsnd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);\n\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\n\tif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\n\t\tchar name[16];\n\t\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\t\tpcm_warn(substream->pcm, \"XRUN: %s\\n\", name);\n\t\tdump_stack_on_xrun(substream);\n\t}\n}\n\n#ifdef CONFIG_SND_PCM_XRUN_DEBUG\n#define hw_ptr_error(substream, in_interrupt, reason, fmt, args...)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttrace_hw_ptr_error(substream, reason);\t\\\n\t\tif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\t\t\\\n\t\t\tpr_err_ratelimited(\"ALSA: PCM: [%c] \" reason \": \" fmt, \\\n\t\t\t\t\t   (in_interrupt) ? 'Q' : 'P', ##args);\t\\\n\t\t\tdump_stack_on_xrun(substream);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#else /* ! CONFIG_SND_PCM_XRUN_DEBUG */\n\n#define hw_ptr_error(substream, fmt, args...) do { } while (0)\n\n#endif\n\nint snd_pcm_update_state(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_runtime *runtime)\n{\n\tsnd_pcm_uframes_t avail;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tavail = snd_pcm_playback_avail(runtime);\n\telse\n\t\tavail = snd_pcm_capture_avail(runtime);\n\tif (avail > runtime->avail_max)\n\t\truntime->avail_max = avail;\n\tif (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {\n\t\tif (avail >= runtime->buffer_size) {\n\t\t\tsnd_pcm_drain_done(substream);\n\t\t\treturn -EPIPE;\n\t\t}\n\t} else {\n\t\tif (avail >= runtime->stop_threshold) {\n\t\t\txrun(substream);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\tif (runtime->twake) {\n\t\tif (avail >= runtime->twake)\n\t\t\twake_up(&runtime->tsleep);\n\t} else if (avail >= runtime->control->avail_min)\n\t\twake_up(&runtime->sleep);\n\treturn 0;\n}\n\nstatic void update_audio_tstamp(struct snd_pcm_substream *substream,\n\t\t\t\tstruct timespec *curr_tstamp,\n\t\t\t\tstruct timespec *audio_tstamp)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tu64 audio_frames, audio_nsecs;\n\tstruct timespec driver_tstamp;\n\n\tif (runtime->tstamp_mode != SNDRV_PCM_TSTAMP_ENABLE)\n\t\treturn;\n\n\tif (!(substream->ops->get_time_info) ||\n\t\t(runtime->audio_tstamp_report.actual_type ==\n\t\t\tSNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\n\n\t\t/*\n\t\t * provide audio timestamp derived from pointer position\n\t\t * add delay only if requested\n\t\t */\n\n\t\taudio_frames = runtime->hw_ptr_wrap + runtime->status->hw_ptr;\n\n\t\tif (runtime->audio_tstamp_config.report_delay) {\n\t\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\taudio_frames -=  runtime->delay;\n\t\t\telse\n\t\t\t\taudio_frames +=  runtime->delay;\n\t\t}\n\t\taudio_nsecs = div_u64(audio_frames * 1000000000LL,\n\t\t\t\truntime->rate);\n\t\t*audio_tstamp = ns_to_timespec(audio_nsecs);\n\t}\n\truntime->status->audio_tstamp = *audio_tstamp;\n\truntime->status->tstamp = *curr_tstamp;\n\n\t/*\n\t * re-take a driver timestamp to let apps detect if the reference tstamp\n\t * read by low-level hardware was provided with a delay\n\t */\n\tsnd_pcm_gettime(substream->runtime, (struct timespec *)&driver_tstamp);\n\truntime->driver_tstamp = driver_tstamp;\n}\n\nstatic int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,\n\t\t\t\t  unsigned int in_interrupt)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t pos;\n\tsnd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;\n\tsnd_pcm_sframes_t hdelta, delta;\n\tunsigned long jdelta;\n\tunsigned long curr_jiffies;\n\tstruct timespec curr_tstamp;\n\tstruct timespec audio_tstamp;\n\tint crossed_boundary = 0;\n\n\told_hw_ptr = runtime->status->hw_ptr;\n\n\t/*\n\t * group pointer, time and jiffies reads to allow for more\n\t * accurate correlations/corrections.\n\t * The values are stored at the end of this routine after\n\t * corrections for hw_ptr position\n\t */\n\tpos = substream->ops->pointer(substream);\n\tcurr_jiffies = jiffies;\n\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\n\t\tif ((substream->ops->get_time_info) &&\n\t\t\t(runtime->audio_tstamp_config.type_requested != SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)) {\n\t\t\tsubstream->ops->get_time_info(substream, &curr_tstamp,\n\t\t\t\t\t\t&audio_tstamp,\n\t\t\t\t\t\t&runtime->audio_tstamp_config,\n\t\t\t\t\t\t&runtime->audio_tstamp_report);\n\n\t\t\t/* re-test in case tstamp type is not supported in hardware and was demoted to DEFAULT */\n\t\t\tif (runtime->audio_tstamp_report.actual_type == SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT)\n\t\t\t\tsnd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);\n\t\t} else\n\t\t\tsnd_pcm_gettime(runtime, (struct timespec *)&curr_tstamp);\n\t}\n\n\tif (pos == SNDRV_PCM_POS_XRUN) {\n\t\txrun(substream);\n\t\treturn -EPIPE;\n\t}\n\tif (pos >= runtime->buffer_size) {\n\t\tif (printk_ratelimit()) {\n\t\t\tchar name[16];\n\t\t\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\t\t\tpcm_err(substream->pcm,\n\t\t\t\t\"invalid position: %s, pos = %ld, buffer size = %ld, period size = %ld\\n\",\n\t\t\t\tname, pos, runtime->buffer_size,\n\t\t\t\truntime->period_size);\n\t\t}\n\t\tpos = 0;\n\t}\n\tpos -= pos % runtime->min_align;\n\ttrace_hwptr(substream, pos, in_interrupt);\n\thw_base = runtime->hw_ptr_base;\n\tnew_hw_ptr = hw_base + pos;\n\tif (in_interrupt) {\n\t\t/* we know that one period was processed */\n\t\t/* delta = \"expected next hw_ptr\" for in_interrupt != 0 */\n\t\tdelta = runtime->hw_ptr_interrupt + runtime->period_size;\n\t\tif (delta > new_hw_ptr) {\n\t\t\t/* check for double acknowledged interrupts */\n\t\t\thdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\t\t\tif (hdelta > runtime->hw_ptr_buffer_jiffies/2 + 1) {\n\t\t\t\thw_base += runtime->buffer_size;\n\t\t\t\tif (hw_base >= runtime->boundary) {\n\t\t\t\t\thw_base = 0;\n\t\t\t\t\tcrossed_boundary++;\n\t\t\t\t}\n\t\t\t\tnew_hw_ptr = hw_base + pos;\n\t\t\t\tgoto __delta;\n\t\t\t}\n\t\t}\n\t}\n\t/* new_hw_ptr might be lower than old_hw_ptr in case when */\n\t/* pointer crosses the end of the ring buffer */\n\tif (new_hw_ptr < old_hw_ptr) {\n\t\thw_base += runtime->buffer_size;\n\t\tif (hw_base >= runtime->boundary) {\n\t\t\thw_base = 0;\n\t\t\tcrossed_boundary++;\n\t\t}\n\t\tnew_hw_ptr = hw_base + pos;\n\t}\n      __delta:\n\tdelta = new_hw_ptr - old_hw_ptr;\n\tif (delta < 0)\n\t\tdelta += runtime->boundary;\n\n\tif (runtime->no_period_wakeup) {\n\t\tsnd_pcm_sframes_t xrun_threshold;\n\t\t/*\n\t\t * Without regular period interrupts, we have to check\n\t\t * the elapsed time to detect xruns.\n\t\t */\n\t\tjdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\t\tif (jdelta < runtime->hw_ptr_buffer_jiffies / 2)\n\t\t\tgoto no_delta_check;\n\t\thdelta = jdelta - delta * HZ / runtime->rate;\n\t\txrun_threshold = runtime->hw_ptr_buffer_jiffies / 2 + 1;\n\t\twhile (hdelta > xrun_threshold) {\n\t\t\tdelta += runtime->buffer_size;\n\t\t\thw_base += runtime->buffer_size;\n\t\t\tif (hw_base >= runtime->boundary) {\n\t\t\t\thw_base = 0;\n\t\t\t\tcrossed_boundary++;\n\t\t\t}\n\t\t\tnew_hw_ptr = hw_base + pos;\n\t\t\thdelta -= runtime->hw_ptr_buffer_jiffies;\n\t\t}\n\t\tgoto no_delta_check;\n\t}\n\n\t/* something must be really wrong */\n\tif (delta >= runtime->buffer_size + runtime->period_size) {\n\t\thw_ptr_error(substream, in_interrupt, \"Unexpected hw_ptr\",\n\t\t\t     \"(stream=%i, pos=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\\n\",\n\t\t\t     substream->stream, (long)pos,\n\t\t\t     (long)new_hw_ptr, (long)old_hw_ptr);\n\t\treturn 0;\n\t}\n\n\t/* Do jiffies check only in xrun_debug mode */\n\tif (!xrun_debug(substream, XRUN_DEBUG_JIFFIESCHECK))\n\t\tgoto no_jiffies_check;\n\n\t/* Skip the jiffies check for hardwares with BATCH flag.\n\t * Such hardware usually just increases the position at each IRQ,\n\t * thus it can't give any strange position.\n\t */\n\tif (runtime->hw.info & SNDRV_PCM_INFO_BATCH)\n\t\tgoto no_jiffies_check;\n\thdelta = delta;\n\tif (hdelta < runtime->delay)\n\t\tgoto no_jiffies_check;\n\thdelta -= runtime->delay;\n\tjdelta = curr_jiffies - runtime->hw_ptr_jiffies;\n\tif (((hdelta * HZ) / runtime->rate) > jdelta + HZ/100) {\n\t\tdelta = jdelta /\n\t\t\t(((runtime->period_size * HZ) / runtime->rate)\n\t\t\t\t\t\t\t\t+ HZ/100);\n\t\t/* move new_hw_ptr according jiffies not pos variable */\n\t\tnew_hw_ptr = old_hw_ptr;\n\t\thw_base = delta;\n\t\t/* use loop to avoid checks for delta overflows */\n\t\t/* the delta value is small or zero in most cases */\n\t\twhile (delta > 0) {\n\t\t\tnew_hw_ptr += runtime->period_size;\n\t\t\tif (new_hw_ptr >= runtime->boundary) {\n\t\t\t\tnew_hw_ptr -= runtime->boundary;\n\t\t\t\tcrossed_boundary--;\n\t\t\t}\n\t\t\tdelta--;\n\t\t}\n\t\t/* align hw_base to buffer_size */\n\t\thw_ptr_error(substream, in_interrupt, \"hw_ptr skipping\",\n\t\t\t     \"(pos=%ld, delta=%ld, period=%ld, jdelta=%lu/%lu/%lu, hw_ptr=%ld/%ld)\\n\",\n\t\t\t     (long)pos, (long)hdelta,\n\t\t\t     (long)runtime->period_size, jdelta,\n\t\t\t     ((hdelta * HZ) / runtime->rate), hw_base,\n\t\t\t     (unsigned long)old_hw_ptr,\n\t\t\t     (unsigned long)new_hw_ptr);\n\t\t/* reset values to proper state */\n\t\tdelta = 0;\n\t\thw_base = new_hw_ptr - (new_hw_ptr % runtime->buffer_size);\n\t}\n no_jiffies_check:\n\tif (delta > runtime->period_size + runtime->period_size / 2) {\n\t\thw_ptr_error(substream, in_interrupt,\n\t\t\t     \"Lost interrupts?\",\n\t\t\t     \"(stream=%i, delta=%ld, new_hw_ptr=%ld, old_hw_ptr=%ld)\\n\",\n\t\t\t     substream->stream, (long)delta,\n\t\t\t     (long)new_hw_ptr,\n\t\t\t     (long)old_hw_ptr);\n\t}\n\n no_delta_check:\n\tif (runtime->status->hw_ptr == new_hw_ptr) {\n\t\tupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\n\t\treturn 0;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    runtime->silence_size > 0)\n\t\tsnd_pcm_playback_silence(substream, new_hw_ptr);\n\n\tif (in_interrupt) {\n\t\tdelta = new_hw_ptr - runtime->hw_ptr_interrupt;\n\t\tif (delta < 0)\n\t\t\tdelta += runtime->boundary;\n\t\tdelta -= (snd_pcm_uframes_t)delta % runtime->period_size;\n\t\truntime->hw_ptr_interrupt += delta;\n\t\tif (runtime->hw_ptr_interrupt >= runtime->boundary)\n\t\t\truntime->hw_ptr_interrupt -= runtime->boundary;\n\t}\n\truntime->hw_ptr_base = hw_base;\n\truntime->status->hw_ptr = new_hw_ptr;\n\truntime->hw_ptr_jiffies = curr_jiffies;\n\tif (crossed_boundary) {\n\t\tsnd_BUG_ON(crossed_boundary != 1);\n\t\truntime->hw_ptr_wrap += runtime->boundary;\n\t}\n\n\tupdate_audio_tstamp(substream, &curr_tstamp, &audio_tstamp);\n\n\treturn snd_pcm_update_state(substream, runtime);\n}\n\n/* CAUTION: call it with irq disabled */\nint snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream)\n{\n\treturn snd_pcm_update_hw_ptr0(substream, 0);\n}\n\n/**\n * snd_pcm_set_ops - set the PCM operators\n * @pcm: the pcm instance\n * @direction: stream direction, SNDRV_PCM_STREAM_XXX\n * @ops: the operator table\n *\n * Sets the given PCM operators to the pcm instance.\n */\nvoid snd_pcm_set_ops(struct snd_pcm *pcm, int direction,\n\t\t     const struct snd_pcm_ops *ops)\n{\n\tstruct snd_pcm_str *stream = &pcm->streams[direction];\n\tstruct snd_pcm_substream *substream;\n\t\n\tfor (substream = stream->substream; substream != NULL; substream = substream->next)\n\t\tsubstream->ops = ops;\n}\n\nEXPORT_SYMBOL(snd_pcm_set_ops);\n\n/**\n * snd_pcm_sync - set the PCM sync id\n * @substream: the pcm substream\n *\n * Sets the PCM sync identifier for the card.\n */\nvoid snd_pcm_set_sync(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\t\n\truntime->sync.id32[0] = substream->pcm->card->number;\n\truntime->sync.id32[1] = -1;\n\truntime->sync.id32[2] = -1;\n\truntime->sync.id32[3] = -1;\n}\n\nEXPORT_SYMBOL(snd_pcm_set_sync);\n\n/*\n *  Standard ioctl routine\n */\n\nstatic inline unsigned int div32(unsigned int a, unsigned int b, \n\t\t\t\t unsigned int *r)\n{\n\tif (b == 0) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\t*r = a % b;\n\treturn a / b;\n}\n\nstatic inline unsigned int div_down(unsigned int a, unsigned int b)\n{\n\tif (b == 0)\n\t\treturn UINT_MAX;\n\treturn a / b;\n}\n\nstatic inline unsigned int div_up(unsigned int a, unsigned int b)\n{\n\tunsigned int r;\n\tunsigned int q;\n\tif (b == 0)\n\t\treturn UINT_MAX;\n\tq = div32(a, b, &r);\n\tif (r)\n\t\t++q;\n\treturn q;\n}\n\nstatic inline unsigned int mul(unsigned int a, unsigned int b)\n{\n\tif (a == 0)\n\t\treturn 0;\n\tif (div_down(UINT_MAX, a) < b)\n\t\treturn UINT_MAX;\n\treturn a * b;\n}\n\nstatic inline unsigned int muldiv32(unsigned int a, unsigned int b,\n\t\t\t\t    unsigned int c, unsigned int *r)\n{\n\tu_int64_t n = (u_int64_t) a * b;\n\tif (c == 0) {\n\t\tsnd_BUG_ON(!n);\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\tn = div_u64_rem(n, c, r);\n\tif (n >= UINT_MAX) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\treturn n;\n}\n\n/**\n * snd_interval_refine - refine the interval value of configurator\n * @i: the interval value to refine\n * @v: the interval value to refer to\n *\n * Refines the interval value with the reference value.\n * The interval is changed to the range satisfying both intervals.\n * The interval status (min, max, integer, etc.) are evaluated.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)\n{\n\tint changed = 0;\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (i->min < v->min) {\n\t\ti->min = v->min;\n\t\ti->openmin = v->openmin;\n\t\tchanged = 1;\n\t} else if (i->min == v->min && !i->openmin && v->openmin) {\n\t\ti->openmin = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->max > v->max) {\n\t\ti->max = v->max;\n\t\ti->openmax = v->openmax;\n\t\tchanged = 1;\n\t} else if (i->max == v->max && !i->openmax && v->openmax) {\n\t\ti->openmax = 1;\n\t\tchanged = 1;\n\t}\n\tif (!i->integer && v->integer) {\n\t\ti->integer = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->integer) {\n\t\tif (i->openmin) {\n\t\t\ti->min++;\n\t\t\ti->openmin = 0;\n\t\t}\n\t\tif (i->openmax) {\n\t\t\ti->max--;\n\t\t\ti->openmax = 0;\n\t\t}\n\t} else if (!i->openmin && !i->openmax && i->min == i->max)\n\t\ti->integer = 1;\n\tif (snd_interval_checkempty(i)) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n\nEXPORT_SYMBOL(snd_interval_refine);\n\nstatic int snd_interval_refine_first(struct snd_interval *i)\n{\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (snd_interval_single(i))\n\t\treturn 0;\n\ti->max = i->min;\n\ti->openmax = i->openmin;\n\tif (i->openmax)\n\t\ti->max++;\n\treturn 1;\n}\n\nstatic int snd_interval_refine_last(struct snd_interval *i)\n{\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (snd_interval_single(i))\n\t\treturn 0;\n\ti->min = i->max;\n\ti->openmin = i->openmax;\n\tif (i->openmin)\n\t\ti->min--;\n\treturn 1;\n}\n\nvoid snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\n{\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = mul(a->min, b->min);\n\tc->openmin = (a->openmin || b->openmin);\n\tc->max = mul(a->max,  b->max);\n\tc->openmax = (a->openmax || b->openmax);\n\tc->integer = (a->integer && b->integer);\n}\n\n/**\n * snd_interval_div - refine the interval value with division\n * @a: dividend\n * @b: divisor\n * @c: quotient\n *\n * c = a / b\n *\n * Returns non-zero if the value is changed, zero if not changed.\n */\nvoid snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = div32(a->min, b->max, &r);\n\tc->openmin = (r || a->openmin || b->openmax);\n\tif (b->min > 0) {\n\t\tc->max = div32(a->max, b->min, &r);\n\t\tif (r) {\n\t\t\tc->max++;\n\t\t\tc->openmax = 1;\n\t\t} else\n\t\t\tc->openmax = (a->openmax || b->openmin);\n\t} else {\n\t\tc->max = UINT_MAX;\n\t\tc->openmax = 0;\n\t}\n\tc->integer = 0;\n}\n\n/**\n * snd_interval_muldivk - refine the interval value\n * @a: dividend 1\n * @b: dividend 2\n * @k: divisor (as integer)\n * @c: result\n  *\n * c = a * b / k\n *\n * Returns non-zero if the value is changed, zero if not changed.\n */\nvoid snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b,\n\t\t      unsigned int k, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = muldiv32(a->min, b->min, k, &r);\n\tc->openmin = (r || a->openmin || b->openmin);\n\tc->max = muldiv32(a->max, b->max, k, &r);\n\tif (r) {\n\t\tc->max++;\n\t\tc->openmax = 1;\n\t} else\n\t\tc->openmax = (a->openmax || b->openmax);\n\tc->integer = 0;\n}\n\n/**\n * snd_interval_mulkdiv - refine the interval value\n * @a: dividend 1\n * @k: dividend 2 (as integer)\n * @b: divisor\n * @c: result\n *\n * c = a * k / b\n *\n * Returns non-zero if the value is changed, zero if not changed.\n */\nvoid snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,\n\t\t      const struct snd_interval *b, struct snd_interval *c)\n{\n\tunsigned int r;\n\tif (a->empty || b->empty) {\n\t\tsnd_interval_none(c);\n\t\treturn;\n\t}\n\tc->empty = 0;\n\tc->min = muldiv32(a->min, k, b->max, &r);\n\tc->openmin = (r || a->openmin || b->openmax);\n\tif (b->min > 0) {\n\t\tc->max = muldiv32(a->max, k, b->min, &r);\n\t\tif (r) {\n\t\t\tc->max++;\n\t\t\tc->openmax = 1;\n\t\t} else\n\t\t\tc->openmax = (a->openmax || b->openmin);\n\t} else {\n\t\tc->max = UINT_MAX;\n\t\tc->openmax = 0;\n\t}\n\tc->integer = 0;\n}\n\n/* ---- */\n\n\n/**\n * snd_interval_ratnum - refine the interval value\n * @i: interval to refine\n * @rats_count: number of ratnum_t \n * @rats: ratnum_t array\n * @nump: pointer to store the resultant numerator\n * @denp: pointer to store the resultant denominator\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_ratnum(struct snd_interval *i,\n\t\t\tunsigned int rats_count, const struct snd_ratnum *rats,\n\t\t\tunsigned int *nump, unsigned int *denp)\n{\n\tunsigned int best_num, best_den;\n\tint best_diff;\n\tunsigned int k;\n\tstruct snd_interval t;\n\tint err;\n\tunsigned int result_num, result_den;\n\tint result_diff;\n\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num = rats[k].num;\n\t\tunsigned int den;\n\t\tunsigned int q = i->min;\n\t\tint diff;\n\t\tif (q == 0)\n\t\t\tq = 1;\n\t\tden = div_up(num, q);\n\t\tif (den < rats[k].den_min)\n\t\t\tcontinue;\n\t\tif (den > rats[k].den_max)\n\t\t\tden = rats[k].den_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (den - rats[k].den_min) % rats[k].den_step;\n\t\t\tif (r != 0)\n\t\t\t\tden -= r;\n\t\t}\n\t\tdiff = num - q * den;\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.min = div_down(best_num, best_den);\n\tt.openmin = !!(best_num % best_den);\n\t\n\tresult_num = best_num;\n\tresult_diff = best_diff;\n\tresult_den = best_den;\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num = rats[k].num;\n\t\tunsigned int den;\n\t\tunsigned int q = i->max;\n\t\tint diff;\n\t\tif (q == 0) {\n\t\t\ti->empty = 1;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tden = div_down(num, q);\n\t\tif (den > rats[k].den_max)\n\t\t\tcontinue;\n\t\tif (den < rats[k].den_min)\n\t\t\tden = rats[k].den_min;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (den - rats[k].den_min) % rats[k].den_step;\n\t\t\tif (r != 0)\n\t\t\t\tden += rats[k].den_step - r;\n\t\t}\n\t\tdiff = q * den - num;\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.max = div_up(best_num, best_den);\n\tt.openmax = !!(best_num % best_den);\n\tt.integer = 0;\n\terr = snd_interval_refine(i, &t);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_interval_single(i)) {\n\t\tif (best_diff * result_den < result_diff * best_den) {\n\t\t\tresult_num = best_num;\n\t\t\tresult_den = best_den;\n\t\t}\n\t\tif (nump)\n\t\t\t*nump = result_num;\n\t\tif (denp)\n\t\t\t*denp = result_den;\n\t}\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_interval_ratnum);\n\n/**\n * snd_interval_ratden - refine the interval value\n * @i: interval to refine\n * @rats_count: number of struct ratden\n * @rats: struct ratden array\n * @nump: pointer to store the resultant numerator\n * @denp: pointer to store the resultant denominator\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nstatic int snd_interval_ratden(struct snd_interval *i,\n\t\t\t       unsigned int rats_count,\n\t\t\t       const struct snd_ratden *rats,\n\t\t\t       unsigned int *nump, unsigned int *denp)\n{\n\tunsigned int best_num, best_diff, best_den;\n\tunsigned int k;\n\tstruct snd_interval t;\n\tint err;\n\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num;\n\t\tunsigned int den = rats[k].den;\n\t\tunsigned int q = i->min;\n\t\tint diff;\n\t\tnum = mul(q, den);\n\t\tif (num > rats[k].num_max)\n\t\t\tcontinue;\n\t\tif (num < rats[k].num_min)\n\t\t\tnum = rats[k].num_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (num - rats[k].num_min) % rats[k].num_step;\n\t\t\tif (r != 0)\n\t\t\t\tnum += rats[k].num_step - r;\n\t\t}\n\t\tdiff = num - q * den;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.min = div_down(best_num, best_den);\n\tt.openmin = !!(best_num % best_den);\n\t\n\tbest_num = best_den = best_diff = 0;\n\tfor (k = 0; k < rats_count; ++k) {\n\t\tunsigned int num;\n\t\tunsigned int den = rats[k].den;\n\t\tunsigned int q = i->max;\n\t\tint diff;\n\t\tnum = mul(q, den);\n\t\tif (num < rats[k].num_min)\n\t\t\tcontinue;\n\t\tif (num > rats[k].num_max)\n\t\t\tnum = rats[k].num_max;\n\t\telse {\n\t\t\tunsigned int r;\n\t\t\tr = (num - rats[k].num_min) % rats[k].num_step;\n\t\t\tif (r != 0)\n\t\t\t\tnum -= r;\n\t\t}\n\t\tdiff = q * den - num;\n\t\tif (best_num == 0 ||\n\t\t    diff * best_den < best_diff * den) {\n\t\t\tbest_diff = diff;\n\t\t\tbest_den = den;\n\t\t\tbest_num = num;\n\t\t}\n\t}\n\tif (best_den == 0) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tt.max = div_up(best_num, best_den);\n\tt.openmax = !!(best_num % best_den);\n\tt.integer = 0;\n\terr = snd_interval_refine(i, &t);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (snd_interval_single(i)) {\n\t\tif (nump)\n\t\t\t*nump = best_num;\n\t\tif (denp)\n\t\t\t*denp = best_den;\n\t}\n\treturn err;\n}\n\n/**\n * snd_interval_list - refine the interval value from the list\n * @i: the interval value to refine\n * @count: the number of elements in the list\n * @list: the value list\n * @mask: the bit-mask to evaluate\n *\n * Refines the interval value from the list.\n * When mask is non-zero, only the elements corresponding to bit 1 are\n * evaluated.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_list(struct snd_interval *i, unsigned int count,\n\t\t      const unsigned int *list, unsigned int mask)\n{\n        unsigned int k;\n\tstruct snd_interval list_range;\n\n\tif (!count) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\tsnd_interval_any(&list_range);\n\tlist_range.min = UINT_MAX;\n\tlist_range.max = 0;\n        for (k = 0; k < count; k++) {\n\t\tif (mask && !(mask & (1 << k)))\n\t\t\tcontinue;\n\t\tif (!snd_interval_test(i, list[k]))\n\t\t\tcontinue;\n\t\tlist_range.min = min(list_range.min, list[k]);\n\t\tlist_range.max = max(list_range.max, list[k]);\n        }\n\treturn snd_interval_refine(i, &list_range);\n}\n\nEXPORT_SYMBOL(snd_interval_list);\n\n/**\n * snd_interval_ranges - refine the interval value from the list of ranges\n * @i: the interval value to refine\n * @count: the number of elements in the list of ranges\n * @ranges: the ranges list\n * @mask: the bit-mask to evaluate\n *\n * Refines the interval value from the list of ranges.\n * When mask is non-zero, only the elements corresponding to bit 1 are\n * evaluated.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_interval_ranges(struct snd_interval *i, unsigned int count,\n\t\t\tconst struct snd_interval *ranges, unsigned int mask)\n{\n\tunsigned int k;\n\tstruct snd_interval range_union;\n\tstruct snd_interval range;\n\n\tif (!count) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\tsnd_interval_any(&range_union);\n\trange_union.min = UINT_MAX;\n\trange_union.max = 0;\n\tfor (k = 0; k < count; k++) {\n\t\tif (mask && !(mask & (1 << k)))\n\t\t\tcontinue;\n\t\tsnd_interval_copy(&range, &ranges[k]);\n\t\tif (snd_interval_refine(&range, i) < 0)\n\t\t\tcontinue;\n\t\tif (snd_interval_empty(&range))\n\t\t\tcontinue;\n\n\t\tif (range.min < range_union.min) {\n\t\t\trange_union.min = range.min;\n\t\t\trange_union.openmin = 1;\n\t\t}\n\t\tif (range.min == range_union.min && !range.openmin)\n\t\t\trange_union.openmin = 0;\n\t\tif (range.max > range_union.max) {\n\t\t\trange_union.max = range.max;\n\t\t\trange_union.openmax = 1;\n\t\t}\n\t\tif (range.max == range_union.max && !range.openmax)\n\t\t\trange_union.openmax = 0;\n\t}\n\treturn snd_interval_refine(i, &range_union);\n}\nEXPORT_SYMBOL(snd_interval_ranges);\n\nstatic int snd_interval_step(struct snd_interval *i, unsigned int step)\n{\n\tunsigned int n;\n\tint changed = 0;\n\tn = i->min % step;\n\tif (n != 0 || i->openmin) {\n\t\ti->min += step - n;\n\t\ti->openmin = 0;\n\t\tchanged = 1;\n\t}\n\tn = i->max % step;\n\tif (n != 0 || i->openmax) {\n\t\ti->max -= n;\n\t\ti->openmax = 0;\n\t\tchanged = 1;\n\t}\n\tif (snd_interval_checkempty(i)) {\n\t\ti->empty = 1;\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n\n/* Info constraints helpers */\n\n/**\n * snd_pcm_hw_rule_add - add the hw-constraint rule\n * @runtime: the pcm runtime instance\n * @cond: condition bits\n * @var: the variable to evaluate\n * @func: the evaluation function\n * @private: the private data pointer passed to function\n * @dep: the dependent variables\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime, unsigned int cond,\n\t\t\tint var,\n\t\t\tsnd_pcm_hw_rule_func_t func, void *private,\n\t\t\tint dep, ...)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_pcm_hw_rule *c;\n\tunsigned int k;\n\tva_list args;\n\tva_start(args, dep);\n\tif (constrs->rules_num >= constrs->rules_all) {\n\t\tstruct snd_pcm_hw_rule *new;\n\t\tunsigned int new_rules = constrs->rules_all + 16;\n\t\tnew = kcalloc(new_rules, sizeof(*c), GFP_KERNEL);\n\t\tif (!new) {\n\t\t\tva_end(args);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (constrs->rules) {\n\t\t\tmemcpy(new, constrs->rules,\n\t\t\t       constrs->rules_num * sizeof(*c));\n\t\t\tkfree(constrs->rules);\n\t\t}\n\t\tconstrs->rules = new;\n\t\tconstrs->rules_all = new_rules;\n\t}\n\tc = &constrs->rules[constrs->rules_num];\n\tc->cond = cond;\n\tc->func = func;\n\tc->var = var;\n\tc->private = private;\n\tk = 0;\n\twhile (1) {\n\t\tif (snd_BUG_ON(k >= ARRAY_SIZE(c->deps))) {\n\t\t\tva_end(args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tc->deps[k++] = dep;\n\t\tif (dep < 0)\n\t\t\tbreak;\n\t\tdep = va_arg(args, int);\n\t}\n\tconstrs->rules_num++;\n\tva_end(args);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_rule_add);\n\n/**\n * snd_pcm_hw_constraint_mask - apply the given bitmap mask constraint\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the mask\n * @mask: the bitmap mask\n *\n * Apply the constraint of the given bitmap mask to a 32-bit mask parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t       u_int32_t mask)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_mask *maskp = constrs_mask(constrs, var);\n\t*maskp->bits &= mask;\n\tmemset(maskp->bits + 1, 0, (SNDRV_MASK_MAX-32) / 8); /* clear rest */\n\tif (*maskp->bits == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n/**\n * snd_pcm_hw_constraint_mask64 - apply the given bitmap mask constraint\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the mask\n * @mask: the 64bit bitmap mask\n *\n * Apply the constraint of the given bitmap mask to a 64-bit mask parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t u_int64_t mask)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_mask *maskp = constrs_mask(constrs, var);\n\tmaskp->bits[0] &= (u_int32_t)mask;\n\tmaskp->bits[1] &= (u_int32_t)(mask >> 32);\n\tmemset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8); /* clear rest */\n\tif (! maskp->bits[0] && ! maskp->bits[1])\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_mask64);\n\n/**\n * snd_pcm_hw_constraint_integer - apply an integer constraint to an interval\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the integer constraint\n *\n * Apply the constraint of integer to an interval parameter.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\treturn snd_interval_setinteger(constrs_interval(constrs, var));\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_integer);\n\n/**\n * snd_pcm_hw_constraint_minmax - apply a min/max range constraint to an interval\n * @runtime: PCM runtime instance\n * @var: hw_params variable to apply the range\n * @min: the minimal value\n * @max: the maximal value\n * \n * Apply the min/max range constraint to an interval parameter.\n *\n * Return: Positive if the value is changed, zero if it's not changed, or a\n * negative error code.\n */\nint snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,\n\t\t\t\t unsigned int min, unsigned int max)\n{\n\tstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\n\tstruct snd_interval t;\n\tt.min = min;\n\tt.max = max;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 0;\n\treturn snd_interval_refine(constrs_interval(constrs, var), &t);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_minmax);\n\nstatic int snd_pcm_hw_rule_list(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_hw_constraint_list *list = rule->private;\n\treturn snd_interval_list(hw_param_interval(params, rule->var), list->count, list->list, list->mask);\n}\t\t\n\n\n/**\n * snd_pcm_hw_constraint_list - apply a list of constraints to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the list constraint\n * @l: list\n * \n * Apply the list of constraints to an interval parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       const struct snd_pcm_hw_constraint_list *l)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_list, (void *)l,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_list);\n\nstatic int snd_pcm_hw_rule_ranges(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_pcm_hw_constraint_ranges *r = rule->private;\n\treturn snd_interval_ranges(hw_param_interval(params, rule->var),\n\t\t\t\t   r->count, r->ranges, r->mask);\n}\n\n\n/**\n * snd_pcm_hw_constraint_ranges - apply list of range constraints to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the list of range constraints\n * @r: ranges\n *\n * Apply the list of range constraints to an interval parameter.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_ranges(struct snd_pcm_runtime *runtime,\n\t\t\t\t unsigned int cond,\n\t\t\t\t snd_pcm_hw_param_t var,\n\t\t\t\t const struct snd_pcm_hw_constraint_ranges *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ranges, (void *)r,\n\t\t\t\t   var, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ranges);\n\nstatic int snd_pcm_hw_rule_ratnums(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tconst struct snd_pcm_hw_constraint_ratnums *r = rule->private;\n\tunsigned int num = 0, den = 0;\n\tint err;\n\terr = snd_interval_ratnum(hw_param_interval(params, rule->var),\n\t\t\t\t  r->nrats, r->rats, &num, &den);\n\tif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\n\t\tparams->rate_num = num;\n\t\tparams->rate_den = den;\n\t}\n\treturn err;\n}\n\n/**\n * snd_pcm_hw_constraint_ratnums - apply ratnums constraint to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the ratnums constraint\n * @r: struct snd_ratnums constriants\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratnums *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ratnums, (void *)r,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ratnums);\n\nstatic int snd_pcm_hw_rule_ratdens(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tconst struct snd_pcm_hw_constraint_ratdens *r = rule->private;\n\tunsigned int num = 0, den = 0;\n\tint err = snd_interval_ratden(hw_param_interval(params, rule->var),\n\t\t\t\t  r->nrats, r->rats, &num, &den);\n\tif (err >= 0 && den && rule->var == SNDRV_PCM_HW_PARAM_RATE) {\n\t\tparams->rate_num = num;\n\t\tparams->rate_den = den;\n\t}\n\treturn err;\n}\n\n/**\n * snd_pcm_hw_constraint_ratdens - apply ratdens constraint to a parameter\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the ratdens constraint\n * @r: struct snd_ratdens constriants\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, \n\t\t\t\t  unsigned int cond,\n\t\t\t\t  snd_pcm_hw_param_t var,\n\t\t\t\t  const struct snd_pcm_hw_constraint_ratdens *r)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_ratdens, (void *)r,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_ratdens);\n\nstatic int snd_pcm_hw_rule_msbits(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int l = (unsigned long) rule->private;\n\tint width = l & 0xffff;\n\tunsigned int msbits = l >> 16;\n\tstruct snd_interval *i = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);\n\n\tif (!snd_interval_single(i))\n\t\treturn 0;\n\n\tif ((snd_interval_value(i) == width) ||\n\t    (width == 0 && snd_interval_value(i) > msbits))\n\t\tparams->msbits = min_not_zero(params->msbits, msbits);\n\n\treturn 0;\n}\n\n/**\n * snd_pcm_hw_constraint_msbits - add a hw constraint msbits rule\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @width: sample bits width\n * @msbits: msbits width\n *\n * This constraint will set the number of most significant bits (msbits) if a\n * sample format with the specified width has been select. If width is set to 0\n * the msbits will be set for any sample format with a width larger than the\n * specified msbits.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, \n\t\t\t\t unsigned int cond,\n\t\t\t\t unsigned int width,\n\t\t\t\t unsigned int msbits)\n{\n\tunsigned long l = (msbits << 16) | width;\n\treturn snd_pcm_hw_rule_add(runtime, cond, -1,\n\t\t\t\t    snd_pcm_hw_rule_msbits,\n\t\t\t\t    (void*) l,\n\t\t\t\t    SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_msbits);\n\nstatic int snd_pcm_hw_rule_step(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tunsigned long step = (unsigned long) rule->private;\n\treturn snd_interval_step(hw_param_interval(params, rule->var), step);\n}\n\n/**\n * snd_pcm_hw_constraint_step - add a hw constraint step rule\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the step constraint\n * @step: step size\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       unsigned long step)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var, \n\t\t\t\t   snd_pcm_hw_rule_step, (void *) step,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_step);\n\nstatic int snd_pcm_hw_rule_pow2(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\n{\n\tstatic unsigned int pow2_sizes[] = {\n\t\t1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7,\n\t\t1<<8, 1<<9, 1<<10, 1<<11, 1<<12, 1<<13, 1<<14, 1<<15,\n\t\t1<<16, 1<<17, 1<<18, 1<<19, 1<<20, 1<<21, 1<<22, 1<<23,\n\t\t1<<24, 1<<25, 1<<26, 1<<27, 1<<28, 1<<29, 1<<30\n\t};\n\treturn snd_interval_list(hw_param_interval(params, rule->var),\n\t\t\t\t ARRAY_SIZE(pow2_sizes), pow2_sizes, 0);\n}\t\t\n\n/**\n * snd_pcm_hw_constraint_pow2 - add a hw constraint power-of-2 rule\n * @runtime: PCM runtime instance\n * @cond: condition bits\n * @var: hw_params variable to apply the power-of-2 constraint\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var, \n\t\t\t\t   snd_pcm_hw_rule_pow2, NULL,\n\t\t\t\t   var, -1);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_constraint_pow2);\n\nstatic int snd_pcm_hw_rule_noresample_func(struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tunsigned int base_rate = (unsigned int)(uintptr_t)rule->private;\n\tstruct snd_interval *rate;\n\n\trate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\treturn snd_interval_list(rate, 1, &base_rate, 0);\n}\n\n/**\n * snd_pcm_hw_rule_noresample - add a rule to allow disabling hw resampling\n * @runtime: PCM runtime instance\n * @base_rate: the rate at which the hardware does not resample\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_rule_noresample(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int base_rate)\n{\n\treturn snd_pcm_hw_rule_add(runtime, SNDRV_PCM_HW_PARAMS_NORESAMPLE,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   snd_pcm_hw_rule_noresample_func,\n\t\t\t\t   (void *)(uintptr_t)base_rate,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE, -1);\n}\nEXPORT_SYMBOL(snd_pcm_hw_rule_noresample);\n\nstatic void _snd_pcm_hw_param_any(struct snd_pcm_hw_params *params,\n\t\t\t\t  snd_pcm_hw_param_t var)\n{\n\tif (hw_is_mask(var)) {\n\t\tsnd_mask_any(hw_param_mask(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t\treturn;\n\t}\n\tif (hw_is_interval(var)) {\n\t\tsnd_interval_any(hw_param_interval(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t\treturn;\n\t}\n\tsnd_BUG();\n}\n\nvoid _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params)\n{\n\tunsigned int k;\n\tmemset(params, 0, sizeof(*params));\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++)\n\t\t_snd_pcm_hw_param_any(params, k);\n\tfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)\n\t\t_snd_pcm_hw_param_any(params, k);\n\tparams->info = ~0U;\n}\n\nEXPORT_SYMBOL(_snd_pcm_hw_params_any);\n\n/**\n * snd_pcm_hw_param_value - return @params field @var value\n * @params: the hw_params instance\n * @var: parameter to retrieve\n * @dir: pointer to the direction (-1,0,1) or %NULL\n *\n * Return: The value for field @var if it's fixed in configuration space\n * defined by @params. -%EINVAL otherwise.\n */\nint snd_pcm_hw_param_value(const struct snd_pcm_hw_params *params,\n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tif (hw_is_mask(var)) {\n\t\tconst struct snd_mask *mask = hw_param_mask_c(params, var);\n\t\tif (!snd_mask_single(mask))\n\t\t\treturn -EINVAL;\n\t\tif (dir)\n\t\t\t*dir = 0;\n\t\treturn snd_mask_value(mask);\n\t}\n\tif (hw_is_interval(var)) {\n\t\tconst struct snd_interval *i = hw_param_interval_c(params, var);\n\t\tif (!snd_interval_single(i))\n\t\t\treturn -EINVAL;\n\t\tif (dir)\n\t\t\t*dir = i->openmin;\n\t\treturn snd_interval_value(i);\n\t}\n\treturn -EINVAL;\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_param_value);\n\nvoid _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params,\n\t\t\t\tsnd_pcm_hw_param_t var)\n{\n\tif (hw_is_mask(var)) {\n\t\tsnd_mask_none(hw_param_mask(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t} else if (hw_is_interval(var)) {\n\t\tsnd_interval_none(hw_param_interval(params, var));\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t} else {\n\t\tsnd_BUG();\n\t}\n}\n\nEXPORT_SYMBOL(_snd_pcm_hw_param_setempty);\n\nstatic int _snd_pcm_hw_param_first(struct snd_pcm_hw_params *params,\n\t\t\t\t   snd_pcm_hw_param_t var)\n{\n\tint changed;\n\tif (hw_is_mask(var))\n\t\tchanged = snd_mask_refine_first(hw_param_mask(params, var));\n\telse if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_first(hw_param_interval(params, var));\n\telse\n\t\treturn -EINVAL;\n\tif (changed) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n\n/**\n * snd_pcm_hw_param_first - refine config space and return minimum value\n * @pcm: PCM instance\n * @params: the hw_params instance\n * @var: parameter to retrieve\n * @dir: pointer to the direction (-1,0,1) or %NULL\n *\n * Inside configuration space defined by @params remove from @var all\n * values > minimum. Reduce configuration space accordingly.\n *\n * Return: The minimum, or a negative error code on failure.\n */\nint snd_pcm_hw_param_first(struct snd_pcm_substream *pcm, \n\t\t\t   struct snd_pcm_hw_params *params, \n\t\t\t   snd_pcm_hw_param_t var, int *dir)\n{\n\tint changed = _snd_pcm_hw_param_first(params, var);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (snd_BUG_ON(err < 0))\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value(params, var, dir);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_param_first);\n\nstatic int _snd_pcm_hw_param_last(struct snd_pcm_hw_params *params,\n\t\t\t\t  snd_pcm_hw_param_t var)\n{\n\tint changed;\n\tif (hw_is_mask(var))\n\t\tchanged = snd_mask_refine_last(hw_param_mask(params, var));\n\telse if (hw_is_interval(var))\n\t\tchanged = snd_interval_refine_last(hw_param_interval(params, var));\n\telse\n\t\treturn -EINVAL;\n\tif (changed) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n\n\n/**\n * snd_pcm_hw_param_last - refine config space and return maximum value\n * @pcm: PCM instance\n * @params: the hw_params instance\n * @var: parameter to retrieve\n * @dir: pointer to the direction (-1,0,1) or %NULL\n *\n * Inside configuration space defined by @params remove from @var all\n * values < maximum. Reduce configuration space accordingly.\n *\n * Return: The maximum, or a negative error code on failure.\n */\nint snd_pcm_hw_param_last(struct snd_pcm_substream *pcm, \n\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t  snd_pcm_hw_param_t var, int *dir)\n{\n\tint changed = _snd_pcm_hw_param_last(params, var);\n\tif (changed < 0)\n\t\treturn changed;\n\tif (params->rmask) {\n\t\tint err = snd_pcm_hw_refine(pcm, params);\n\t\tif (snd_BUG_ON(err < 0))\n\t\t\treturn err;\n\t}\n\treturn snd_pcm_hw_param_value(params, var, dir);\n}\n\nEXPORT_SYMBOL(snd_pcm_hw_param_last);\n\n/**\n * snd_pcm_hw_param_choose - choose a configuration defined by @params\n * @pcm: PCM instance\n * @params: the hw_params instance\n *\n * Choose one configuration from configuration space defined by @params.\n * The configuration chosen is that obtained fixing in this order:\n * first access, first format, first subformat, min channels,\n * min rate, min period time, max buffer size, min tick time\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_hw_params_choose(struct snd_pcm_substream *pcm,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstatic int vars[] = {\n\t\tSNDRV_PCM_HW_PARAM_ACCESS,\n\t\tSNDRV_PCM_HW_PARAM_FORMAT,\n\t\tSNDRV_PCM_HW_PARAM_SUBFORMAT,\n\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\tSNDRV_PCM_HW_PARAM_PERIOD_TIME,\n\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\tSNDRV_PCM_HW_PARAM_TICK_TIME,\n\t\t-1\n\t};\n\tint err, *v;\n\n\tfor (v = vars; *v != -1; v++) {\n\t\tif (*v != SNDRV_PCM_HW_PARAM_BUFFER_SIZE)\n\t\t\terr = snd_pcm_hw_param_first(pcm, params, *v, NULL);\n\t\telse\n\t\t\terr = snd_pcm_hw_param_last(pcm, params, *v, NULL);\n\t\tif (snd_BUG_ON(err < 0))\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_reset(struct snd_pcm_substream *substream,\n\t\t\t\t   void *arg)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long flags;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (snd_pcm_running(substream) &&\n\t    snd_pcm_update_hw_ptr(substream) >= 0)\n\t\truntime->status->hw_ptr %= runtime->buffer_size;\n\telse {\n\t\truntime->status->hw_ptr = 0;\n\t\truntime->hw_ptr_wrap = 0;\n\t}\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_channel_info(struct snd_pcm_substream *substream,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_pcm_channel_info *info = arg;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint width;\n\tif (!(runtime->info & SNDRV_PCM_INFO_MMAP)) {\n\t\tinfo->offset = -1;\n\t\treturn 0;\n\t}\n\twidth = snd_pcm_format_physical_width(runtime->format);\n\tif (width < 0)\n\t\treturn width;\n\tinfo->offset = 0;\n\tswitch (runtime->access) {\n\tcase SNDRV_PCM_ACCESS_MMAP_INTERLEAVED:\n\tcase SNDRV_PCM_ACCESS_RW_INTERLEAVED:\n\t\tinfo->first = info->channel * width;\n\t\tinfo->step = runtime->channels * width;\n\t\tbreak;\n\tcase SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED:\n\tcase SNDRV_PCM_ACCESS_RW_NONINTERLEAVED:\n\t{\n\t\tsize_t size = runtime->dma_bytes / runtime->channels;\n\t\tinfo->first = info->channel * size * 8;\n\t\tinfo->step = width;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsnd_BUG();\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int snd_pcm_lib_ioctl_fifo_size(struct snd_pcm_substream *substream,\n\t\t\t\t       void *arg)\n{\n\tstruct snd_pcm_hw_params *params = arg;\n\tsnd_pcm_format_t format;\n\tint channels;\n\tssize_t frame_size;\n\n\tparams->fifo_size = substream->runtime->hw.fifo_size;\n\tif (!(substream->runtime->hw.info & SNDRV_PCM_INFO_FIFO_IN_FRAMES)) {\n\t\tformat = params_format(params);\n\t\tchannels = params_channels(params);\n\t\tframe_size = snd_pcm_format_size(format, channels);\n\t\tif (frame_size > 0)\n\t\t\tparams->fifo_size /= (unsigned)frame_size;\n\t}\n\treturn 0;\n}\n\n/**\n * snd_pcm_lib_ioctl - a generic PCM ioctl callback\n * @substream: the pcm substream instance\n * @cmd: ioctl command\n * @arg: ioctl argument\n *\n * Processes the generic ioctl commands for PCM.\n * Can be passed as the ioctl callback for PCM ops.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,\n\t\t      unsigned int cmd, void *arg)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_IOCTL1_INFO:\n\t\treturn 0;\n\tcase SNDRV_PCM_IOCTL1_RESET:\n\t\treturn snd_pcm_lib_ioctl_reset(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\n\t\treturn snd_pcm_lib_ioctl_channel_info(substream, arg);\n\tcase SNDRV_PCM_IOCTL1_FIFO_SIZE:\n\t\treturn snd_pcm_lib_ioctl_fifo_size(substream, arg);\n\t}\n\treturn -ENXIO;\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_ioctl);\n\n/**\n * snd_pcm_period_elapsed - update the pcm status for the next period\n * @substream: the pcm substream instance\n *\n * This function is called from the interrupt handler when the\n * PCM has processed the period size.  It will update the current\n * pointer, wake up sleepers, etc.\n *\n * Even if more than one periods have elapsed since the last call, you\n * have to call this only once.\n */\nvoid snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n}\n\nEXPORT_SYMBOL(snd_pcm_period_elapsed);\n\n/*\n * Wait until avail_min data becomes available\n * Returns a negative error code if any error occurs during operation.\n * The available space is stored on availp.  When err = 0 and avail = 0\n * on the capture stream, it indicates the stream is in DRAINING state.\n */\nstatic int wait_for_avail(struct snd_pcm_substream *substream,\n\t\t\t      snd_pcm_uframes_t *availp)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\twait_queue_t wait;\n\tint err = 0;\n\tsnd_pcm_uframes_t avail = 0;\n\tlong wait_time, tout;\n\n\tinit_waitqueue_entry(&wait, current);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&runtime->tsleep, &wait);\n\n\tif (runtime->no_period_wakeup)\n\t\twait_time = MAX_SCHEDULE_TIMEOUT;\n\telse {\n\t\twait_time = 10;\n\t\tif (runtime->rate) {\n\t\t\tlong t = runtime->period_size * 2 / runtime->rate;\n\t\t\twait_time = max(t, wait_time);\n\t\t}\n\t\twait_time = msecs_to_jiffies(wait_time * 1000);\n\t}\n\n\tfor (;;) {\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to check if space became available already\n\t\t * (and thus the wakeup happened already) first to close\n\t\t * the race of space already having become available.\n\t\t * This check must happen after been added to the waitqueue\n\t\t * and having current state be INTERRUPTIBLE.\n\t\t */\n\t\tif (is_playback)\n\t\t\tavail = snd_pcm_playback_avail(runtime);\n\t\telse\n\t\t\tavail = snd_pcm_capture_avail(runtime);\n\t\tif (avail >= runtime->twake)\n\t\t\tbreak;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\n\t\ttout = schedule_timeout(wait_time);\n\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tswitch (runtime->status->state) {\n\t\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\t\terr = -ESTRPIPE;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\terr = -EPIPE;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_DRAINING:\n\t\t\tif (is_playback)\n\t\t\t\terr = -EPIPE;\n\t\t\telse \n\t\t\t\tavail = 0; /* indicate draining */\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_OPEN:\n\t\tcase SNDRV_PCM_STATE_SETUP:\n\t\tcase SNDRV_PCM_STATE_DISCONNECTED:\n\t\t\terr = -EBADFD;\n\t\t\tgoto _endloop;\n\t\tcase SNDRV_PCM_STATE_PAUSED:\n\t\t\tcontinue;\n\t\t}\n\t\tif (!tout) {\n\t\t\tpcm_dbg(substream->pcm,\n\t\t\t\t\"%s write error (DMA or IRQ trouble?)\\n\",\n\t\t\t\tis_playback ? \"playback\" : \"capture\");\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n _endloop:\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&runtime->tsleep, &wait);\n\t*availp = avail;\n\treturn err;\n}\n\t\nstatic int snd_pcm_lib_write_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t      unsigned int hwoff,\n\t\t\t\t      unsigned long data, unsigned int off,\n\t\t\t\t      snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tchar __user *buf = (char __user *) data + frames_to_bytes(runtime, off);\n\tif (substream->ops->copy) {\n\t\tif ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)\n\t\t\treturn err;\n\t} else {\n\t\tchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);\n\t\tif (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n \ntypedef int (*transfer_f)(struct snd_pcm_substream *substream, unsigned int hwoff,\n\t\t\t  unsigned long data, unsigned int off,\n\t\t\t  snd_pcm_uframes_t size);\n\nstatic snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream, \n\t\t\t\t\t    unsigned long data,\n\t\t\t\t\t    snd_pcm_uframes_t size,\n\t\t\t\t\t    int nonblock,\n\t\t\t\t\t    transfer_f transfer)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t xfer = 0;\n\tsnd_pcm_uframes_t offset = 0;\n\tsnd_pcm_uframes_t avail;\n\tint err = 0;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->status->state) {\n\tcase SNDRV_PCM_STATE_PREPARED:\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\terr = -EPIPE;\n\t\tgoto _end_unlock;\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\terr = -ESTRPIPE;\n\t\tgoto _end_unlock;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto _end_unlock;\n\t}\n\n\truntime->twake = runtime->control->avail_min ? : 1;\n\tif (runtime->status->state == SNDRV_PCM_STATE_RUNNING)\n\t\tsnd_pcm_update_hw_ptr(substream);\n\tavail = snd_pcm_playback_avail(runtime);\n\twhile (size > 0) {\n\t\tsnd_pcm_uframes_t frames, appl_ptr, appl_ofs;\n\t\tsnd_pcm_uframes_t cont;\n\t\tif (!avail) {\n\t\t\tif (nonblock) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\truntime->twake = min_t(snd_pcm_uframes_t, size,\n\t\t\t\t\truntime->control->avail_min ? : 1);\n\t\t\terr = wait_for_avail(substream, &avail);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t}\n\t\tframes = size > avail ? avail : size;\n\t\tcont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;\n\t\tif (frames > cont)\n\t\t\tframes = cont;\n\t\tif (snd_BUG_ON(!frames)) {\n\t\t\truntime->twake = 0;\n\t\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tappl_ptr = runtime->control->appl_ptr;\n\t\tappl_ofs = appl_ptr % runtime->buffer_size;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\terr = transfer(substream, appl_ofs, data, offset, frames);\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\t\tswitch (runtime->status->state) {\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\terr = -EPIPE;\n\t\t\tgoto _end_unlock;\n\t\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\t\terr = -ESTRPIPE;\n\t\t\tgoto _end_unlock;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tappl_ptr += frames;\n\t\tif (appl_ptr >= runtime->boundary)\n\t\t\tappl_ptr -= runtime->boundary;\n\t\truntime->control->appl_ptr = appl_ptr;\n\t\tif (substream->ops->ack)\n\t\t\tsubstream->ops->ack(substream);\n\n\t\toffset += frames;\n\t\tsize -= frames;\n\t\txfer += frames;\n\t\tavail -= frames;\n\t\tif (runtime->status->state == SNDRV_PCM_STATE_PREPARED &&\n\t\t    snd_pcm_playback_hw_avail(runtime) >= (snd_pcm_sframes_t)runtime->start_threshold) {\n\t\t\terr = snd_pcm_start(substream);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t}\n\t}\n _end_unlock:\n\truntime->twake = 0;\n\tif (xfer > 0 && err >= 0)\n\t\tsnd_pcm_update_state(substream, runtime);\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn xfer > 0 ? (snd_pcm_sframes_t)xfer : err;\n}\n\n/* sanity-check for read/write methods */\nstatic int pcm_sanity_check(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn -ENXIO;\n\truntime = substream->runtime;\n\tif (snd_BUG_ON(!substream->ops->copy && !runtime->dma_area))\n\t\treturn -EINVAL;\n\tif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\treturn 0;\n}\n\nsnd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream, const void __user *buf, snd_pcm_uframes_t size)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&\n\t    runtime->channels > 1)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_write1(substream, (unsigned long)buf, size, nonblock,\n\t\t\t\t  snd_pcm_lib_write_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_write);\n\nstatic int snd_pcm_lib_writev_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t       unsigned int hwoff,\n\t\t\t\t       unsigned long data, unsigned int off,\n\t\t\t\t       snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tvoid __user **bufs = (void __user **)data;\n\tint channels = runtime->channels;\n\tint c;\n\tif (substream->ops->copy) {\n\t\tif (snd_BUG_ON(!substream->ops->silence))\n\t\t\treturn -EINVAL;\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tif (*bufs == NULL) {\n\t\t\t\tif ((err = substream->ops->silence(substream, c, hwoff, frames)) < 0)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tchar __user *buf = *bufs + samples_to_bytes(runtime, off);\n\t\t\t\tif ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* default transfer behaviour */\n\t\tsize_t dma_csize = runtime->dma_bytes / channels;\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tchar *hwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);\n\t\t\tif (*bufs == NULL) {\n\t\t\t\tsnd_pcm_format_set_silence(runtime->format, hwbuf, frames);\n\t\t\t} else {\n\t\t\t\tchar __user *buf = *bufs + samples_to_bytes(runtime, off);\n\t\t\t\tif (copy_from_user(hwbuf, buf, samples_to_bytes(runtime, frames)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nsnd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,\n\t\t\t\t     void __user **bufs,\n\t\t\t\t     snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_write1(substream, (unsigned long)bufs, frames,\n\t\t\t\t  nonblock, snd_pcm_lib_writev_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_writev);\n\nstatic int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, \n\t\t\t\t     unsigned int hwoff,\n\t\t\t\t     unsigned long data, unsigned int off,\n\t\t\t\t     snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tchar __user *buf = (char __user *) data + frames_to_bytes(runtime, off);\n\tif (substream->ops->copy) {\n\t\tif ((err = substream->ops->copy(substream, -1, hwoff, buf, frames)) < 0)\n\t\t\treturn err;\n\t} else {\n\t\tchar *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);\n\t\tif (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,\n\t\t\t\t\t   unsigned long data,\n\t\t\t\t\t   snd_pcm_uframes_t size,\n\t\t\t\t\t   int nonblock,\n\t\t\t\t\t   transfer_f transfer)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t xfer = 0;\n\tsnd_pcm_uframes_t offset = 0;\n\tsnd_pcm_uframes_t avail;\n\tint err = 0;\n\n\tif (size == 0)\n\t\treturn 0;\n\n\tsnd_pcm_stream_lock_irq(substream);\n\tswitch (runtime->status->state) {\n\tcase SNDRV_PCM_STATE_PREPARED:\n\t\tif (size >= runtime->start_threshold) {\n\t\t\terr = snd_pcm_start(substream);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_DRAINING:\n\tcase SNDRV_PCM_STATE_RUNNING:\n\tcase SNDRV_PCM_STATE_PAUSED:\n\t\tbreak;\n\tcase SNDRV_PCM_STATE_XRUN:\n\t\terr = -EPIPE;\n\t\tgoto _end_unlock;\n\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\terr = -ESTRPIPE;\n\t\tgoto _end_unlock;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto _end_unlock;\n\t}\n\n\truntime->twake = runtime->control->avail_min ? : 1;\n\tif (runtime->status->state == SNDRV_PCM_STATE_RUNNING)\n\t\tsnd_pcm_update_hw_ptr(substream);\n\tavail = snd_pcm_capture_avail(runtime);\n\twhile (size > 0) {\n\t\tsnd_pcm_uframes_t frames, appl_ptr, appl_ofs;\n\t\tsnd_pcm_uframes_t cont;\n\t\tif (!avail) {\n\t\t\tif (runtime->status->state ==\n\t\t\t    SNDRV_PCM_STATE_DRAINING) {\n\t\t\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\tif (nonblock) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _end_unlock;\n\t\t\t}\n\t\t\truntime->twake = min_t(snd_pcm_uframes_t, size,\n\t\t\t\t\truntime->control->avail_min ? : 1);\n\t\t\terr = wait_for_avail(substream, &avail);\n\t\t\tif (err < 0)\n\t\t\t\tgoto _end_unlock;\n\t\t\tif (!avail)\n\t\t\t\tcontinue; /* draining */\n\t\t}\n\t\tframes = size > avail ? avail : size;\n\t\tcont = runtime->buffer_size - runtime->control->appl_ptr % runtime->buffer_size;\n\t\tif (frames > cont)\n\t\t\tframes = cont;\n\t\tif (snd_BUG_ON(!frames)) {\n\t\t\truntime->twake = 0;\n\t\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tappl_ptr = runtime->control->appl_ptr;\n\t\tappl_ofs = appl_ptr % runtime->buffer_size;\n\t\tsnd_pcm_stream_unlock_irq(substream);\n\t\terr = transfer(substream, appl_ofs, data, offset, frames);\n\t\tsnd_pcm_stream_lock_irq(substream);\n\t\tif (err < 0)\n\t\t\tgoto _end_unlock;\n\t\tswitch (runtime->status->state) {\n\t\tcase SNDRV_PCM_STATE_XRUN:\n\t\t\terr = -EPIPE;\n\t\t\tgoto _end_unlock;\n\t\tcase SNDRV_PCM_STATE_SUSPENDED:\n\t\t\terr = -ESTRPIPE;\n\t\t\tgoto _end_unlock;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tappl_ptr += frames;\n\t\tif (appl_ptr >= runtime->boundary)\n\t\t\tappl_ptr -= runtime->boundary;\n\t\truntime->control->appl_ptr = appl_ptr;\n\t\tif (substream->ops->ack)\n\t\t\tsubstream->ops->ack(substream);\n\n\t\toffset += frames;\n\t\tsize -= frames;\n\t\txfer += frames;\n\t\tavail -= frames;\n\t}\n _end_unlock:\n\truntime->twake = 0;\n\tif (xfer > 0 && err >= 0)\n\t\tsnd_pcm_update_state(substream, runtime);\n\tsnd_pcm_stream_unlock_irq(substream);\n\treturn xfer > 0 ? (snd_pcm_sframes_t)xfer : err;\n}\n\nsnd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __user *buf, snd_pcm_uframes_t size)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\t\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_read);\n\nstatic int snd_pcm_lib_readv_transfer(struct snd_pcm_substream *substream,\n\t\t\t\t      unsigned int hwoff,\n\t\t\t\t      unsigned long data, unsigned int off,\n\t\t\t\t      snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\tvoid __user **bufs = (void __user **)data;\n\tint channels = runtime->channels;\n\tint c;\n\tif (substream->ops->copy) {\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tchar __user *buf;\n\t\t\tif (*bufs == NULL)\n\t\t\t\tcontinue;\n\t\t\tbuf = *bufs + samples_to_bytes(runtime, off);\n\t\t\tif ((err = substream->ops->copy(substream, c, hwoff, buf, frames)) < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tsnd_pcm_uframes_t dma_csize = runtime->dma_bytes / channels;\n\t\tfor (c = 0; c < channels; ++c, ++bufs) {\n\t\t\tchar *hwbuf;\n\t\t\tchar __user *buf;\n\t\t\tif (*bufs == NULL)\n\t\t\t\tcontinue;\n\n\t\t\thwbuf = runtime->dma_area + (c * dma_csize) + samples_to_bytes(runtime, hwoff);\n\t\t\tbuf = *bufs + samples_to_bytes(runtime, off);\n\t\t\tif (copy_to_user(buf, hwbuf, samples_to_bytes(runtime, frames)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n \nsnd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,\n\t\t\t\t    void __user **bufs,\n\t\t\t\t    snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);\n}\n\nEXPORT_SYMBOL(snd_pcm_lib_readv);\n\n/*\n * standard channel mapping helpers\n */\n\n/* default channel maps for multi-channel playbacks, up to 8 channels */\nconst struct snd_pcm_chmap_elem snd_pcm_std_chmaps[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE } },\n\t{ .channels = 8,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(snd_pcm_std_chmaps);\n\n/* alternative channel maps with CLFE <-> surround swapped for 6/8 channels */\nconst struct snd_pcm_chmap_elem snd_pcm_alt_chmaps[] = {\n\t{ .channels = 1,\n\t  .map = { SNDRV_CHMAP_MONO } },\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 8,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_SL, SNDRV_CHMAP_SR } },\n\t{ }\n};\nEXPORT_SYMBOL_GPL(snd_pcm_alt_chmaps);\n\nstatic bool valid_chmap_channels(const struct snd_pcm_chmap *info, int ch)\n{\n\tif (ch > info->max_channels)\n\t\treturn false;\n\treturn !info->channel_mask || (info->channel_mask & (1U << ch));\n}\n\nstatic int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 0;\n\tuinfo->count = info->max_channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_LAST;\n\treturn 0;\n}\n\n/* get callback for channel map ctl element\n * stores the channel position firstly matching with the current channels\n */\nstatic int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\n\tstruct snd_pcm_substream *substream;\n\tconst struct snd_pcm_chmap_elem *map;\n\n\tif (snd_BUG_ON(!info->chmap))\n\t\treturn -EINVAL;\n\tsubstream = snd_pcm_chmap_substream(info, idx);\n\tif (!substream)\n\t\treturn -ENODEV;\n\tmemset(ucontrol->value.integer.value, 0,\n\t       sizeof(ucontrol->value.integer.value));\n\tif (!substream->runtime)\n\t\treturn 0; /* no channels set */\n\tfor (map = info->chmap; map->channels; map++) {\n\t\tint i;\n\t\tif (map->channels == substream->runtime->channels &&\n\t\t    valid_chmap_channels(info, map->channels)) {\n\t\t\tfor (i = 0; i < map->channels; i++)\n\t\t\t\tucontrol->value.integer.value[i] = map->map[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n/* tlv callback for channel map ctl element\n * expands the pre-defined channel maps in a form of TLV\n */\nstatic int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t     unsigned int size, unsigned int __user *tlv)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tconst struct snd_pcm_chmap_elem *map;\n\tunsigned int __user *dst;\n\tint c, count = 0;\n\n\tif (snd_BUG_ON(!info->chmap))\n\t\treturn -EINVAL;\n\tif (size < 8)\n\t\treturn -ENOMEM;\n\tif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\n\t\treturn -EFAULT;\n\tsize -= 8;\n\tdst = tlv + 2;\n\tfor (map = info->chmap; map->channels; map++) {\n\t\tint chs_bytes = map->channels * 4;\n\t\tif (!valid_chmap_channels(info, map->channels))\n\t\t\tcontinue;\n\t\tif (size < 8)\n\t\t\treturn -ENOMEM;\n\t\tif (put_user(SNDRV_CTL_TLVT_CHMAP_FIXED, dst) ||\n\t\t    put_user(chs_bytes, dst + 1))\n\t\t\treturn -EFAULT;\n\t\tdst += 2;\n\t\tsize -= 8;\n\t\tcount += 8;\n\t\tif (size < chs_bytes)\n\t\t\treturn -ENOMEM;\n\t\tsize -= chs_bytes;\n\t\tcount += chs_bytes;\n\t\tfor (c = 0; c < map->channels; c++) {\n\t\t\tif (put_user(map->map[c], dst))\n\t\t\t\treturn -EFAULT;\n\t\t\tdst++;\n\t\t}\n\t}\n\tif (put_user(count, tlv + 1))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void pcm_chmap_ctl_private_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tinfo->pcm->streams[info->stream].chmap_kctl = NULL;\n\tkfree(info);\n}\n\n/**\n * snd_pcm_add_chmap_ctls - create channel-mapping control elements\n * @pcm: the assigned PCM instance\n * @stream: stream direction\n * @chmap: channel map elements (for query)\n * @max_channels: the max number of channels for the stream\n * @private_value: the value passed to each kcontrol's private_value field\n * @info_ret: store struct snd_pcm_chmap instance if non-NULL\n *\n * Create channel-mapping control elements assigned to the given PCM stream(s).\n * Return: Zero if successful, or a negative error value.\n */\nint snd_pcm_add_chmap_ctls(struct snd_pcm *pcm, int stream,\n\t\t\t   const struct snd_pcm_chmap_elem *chmap,\n\t\t\t   int max_channels,\n\t\t\t   unsigned long private_value,\n\t\t\t   struct snd_pcm_chmap **info_ret)\n{\n\tstruct snd_pcm_chmap *info;\n\tstruct snd_kcontrol_new knew = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK,\n\t\t.info = pcm_chmap_ctl_info,\n\t\t.get = pcm_chmap_ctl_get,\n\t\t.tlv.c = pcm_chmap_ctl_tlv,\n\t};\n\tint err;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->pcm = pcm;\n\tinfo->stream = stream;\n\tinfo->chmap = chmap;\n\tinfo->max_channels = max_channels;\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tknew.name = \"Playback Channel Map\";\n\telse\n\t\tknew.name = \"Capture Channel Map\";\n\tknew.device = pcm->device;\n\tknew.count = pcm->streams[stream].substream_count;\n\tknew.private_value = private_value;\n\tinfo->kctl = snd_ctl_new1(&knew, info);\n\tif (!info->kctl) {\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->kctl->private_free = pcm_chmap_ctl_private_free;\n\terr = snd_ctl_add(pcm->card, info->kctl);\n\tif (err < 0)\n\t\treturn err;\n\tpcm->streams[stream].chmap_kctl = info->kctl;\n\tif (info_ret)\n\t\t*info_ret = info;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_pcm_add_chmap_ctls);\n"], "filenames": ["sound/core/pcm_lib.c"], "buggy_code_start_loc": [1888], "buggy_code_end_loc": [1891], "fixing_code_start_loc": [1889], "fixing_code_end_loc": [1890], "type": "CWE-362", "message": "Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command.", "other": {"cve": {"id": "CVE-2016-9794", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-28T07:59:00.603", "lastModified": "2023-01-17T21:05:13.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n snd_pcm_period_elapsed en sound/core/pcm_lib.c en el subsistema de ALSA en el kernel de Linux en versiones anteriores a 4.7 permite a usuarios locales provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n de memoria) o posiblemente tener otro impacto no especificado a trav\u00e9s de un comando SNDRV_PCM_TRIGGER_START manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.85", "matchCriteriaId": "9A5A178A-A60C-4053-AEE0-5164430206AD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.10.105", "matchCriteriaId": "2B846CBB-1438-4151-B9FC-816C9548110E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.69", "matchCriteriaId": "28A5A1D2-18D9-4F68-9773-16A6850309FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.16.40", "matchCriteriaId": "1331ABAB-8C2B-4379-BA77-B655A5B9A83F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.52", "matchCriteriaId": "8104AAC1-9700-4372-8E11-37B09309A76F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.4.37", "matchCriteriaId": "3661C6BA-77CF-460F-A579-DF66100188E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.7", "matchCriteriaId": "DE716976-6714-42AC-989C-CA9FE4B8E219"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00057.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00062.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00072.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00075.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00081.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00088.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-12/msg00091.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/03/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.securityfocus.com/bid/94654", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1401494", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://patchwork.kernel.org/patch/8752621/", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://source.android.com/security/bulletin/2017-05-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4"}}