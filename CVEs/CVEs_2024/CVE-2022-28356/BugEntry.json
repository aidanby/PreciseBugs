{"buggy_code": ["/*\n * af_llc.c - LLC User Interface SAPs\n * Description:\n *   Functions in this module are implementation of socket based llc\n *   communications for the Linux operating system. Support of llc class\n *   one and class two is provided via SOCK_DGRAM and SOCK_STREAM\n *   respectively.\n *\n *   An llc2 connection is (mac + sap), only one llc2 sap connection\n *   is allowed per mac. Though one sap may have multiple mac + sap\n *   connections.\n *\n * Copyright (c) 2001 by Jay Schulist <jschlst@samba.org>\n *\t\t 2002-2003 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n * This program can be redistributed or modified under the terms of the\n * GNU General Public License as published by the Free Software Foundation.\n * This program is distributed without any warranty or implied warranty\n * of merchantability or fitness for a particular purpose.\n *\n * See the GNU General Public License for more details.\n */\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <net/llc.h>\n#include <net/llc_sap.h>\n#include <net/llc_pdu.h>\n#include <net/llc_conn.h>\n#include <net/tcp_states.h>\n\n/* remember: uninitialized global data is zeroed because its in .bss */\nstatic u16 llc_ui_sap_last_autoport = LLC_SAP_DYN_START;\nstatic u16 llc_ui_sap_link_no_max[256];\nstatic struct sockaddr_llc llc_ui_addrnull;\nstatic const struct proto_ops llc_ui_ops;\n\nstatic bool llc_ui_wait_for_conn(struct sock *sk, long timeout);\nstatic int llc_ui_wait_for_disc(struct sock *sk, long timeout);\nstatic int llc_ui_wait_for_busy_core(struct sock *sk, long timeout);\n\n#if 0\n#define dprintk(args...) printk(KERN_DEBUG args)\n#else\n#define dprintk(args...) do {} while (0)\n#endif\n\n/* Maybe we'll add some more in the future. */\n#define LLC_CMSG_PKTINFO\t1\n\n\n/**\n *\tllc_ui_next_link_no - return the next unused link number for a sap\n *\t@sap: Address of sap to get link number from.\n *\n *\tReturn the next unused link number for a given sap.\n */\nstatic inline u16 llc_ui_next_link_no(int sap)\n{\n\treturn llc_ui_sap_link_no_max[sap]++;\n}\n\n/**\n *\tllc_proto_type - return eth protocol for ARP header type\n *\t@arphrd: ARP header type.\n *\n *\tGiven an ARP header type return the corresponding ethernet protocol.\n */\nstatic inline __be16 llc_proto_type(u16 arphrd)\n{\n\treturn htons(ETH_P_802_2);\n}\n\n/**\n *\tllc_ui_addr_null - determines if a address structure is null\n *\t@addr: Address to test if null.\n */\nstatic inline u8 llc_ui_addr_null(struct sockaddr_llc *addr)\n{\n\treturn !memcmp(addr, &llc_ui_addrnull, sizeof(*addr));\n}\n\n/**\n *\tllc_ui_header_len - return length of llc header based on operation\n *\t@sk: Socket which contains a valid llc socket type.\n *\t@addr: Complete sockaddr_llc structure received from the user.\n *\n *\tProvide the length of the llc header depending on what kind of\n *\toperation the user would like to perform and the type of socket.\n *\tReturns the correct llc header length.\n */\nstatic inline u8 llc_ui_header_len(struct sock *sk, struct sockaddr_llc *addr)\n{\n\tu8 rc = LLC_PDU_LEN_U;\n\n\tif (addr->sllc_test)\n\t\trc = LLC_PDU_LEN_U;\n\telse if (addr->sllc_xid)\n\t\t/* We need to expand header to sizeof(struct llc_xid_info)\n\t\t * since llc_pdu_init_as_xid_cmd() sets 4,5,6 bytes of LLC header\n\t\t * as XID PDU. In llc_ui_sendmsg() we reserved header size and then\n\t\t * filled all other space with user data. If we won't reserve this\n\t\t * bytes, llc_pdu_init_as_xid_cmd() will overwrite user data\n\t\t */\n\t\trc = LLC_PDU_LEN_U_XID;\n\telse if (sk->sk_type == SOCK_STREAM)\n\t\trc = LLC_PDU_LEN_I;\n\treturn rc;\n}\n\n/**\n *\tllc_ui_send_data - send data via reliable llc2 connection\n *\t@sk: Connection the socket is using.\n *\t@skb: Data the user wishes to send.\n *\t@noblock: can we block waiting for data?\n *\n *\tSend data via reliable llc2 connection.\n *\tReturns 0 upon success, non-zero if action did not succeed.\n *\n *\tThis function always consumes a reference to the skb.\n */\nstatic int llc_ui_send_data(struct sock* sk, struct sk_buff *skb, int noblock)\n{\n\tstruct llc_sock* llc = llc_sk(sk);\n\n\tif (unlikely(llc_data_accept_state(llc->state) ||\n\t\t     llc->remote_busy_flag ||\n\t\t     llc->p_flag)) {\n\t\tlong timeout = sock_sndtimeo(sk, noblock);\n\t\tint rc;\n\n\t\trc = llc_ui_wait_for_busy_core(sk, timeout);\n\t\tif (rc) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn llc_build_and_send_pkt(sk, skb);\n}\n\nstatic void llc_ui_sk_init(struct socket *sock, struct sock *sk)\n{\n\tsock_graft(sk, sock);\n\tsk->sk_type\t= sock->type;\n\tsock->ops\t= &llc_ui_ops;\n}\n\nstatic struct proto llc_proto = {\n\t.name\t  = \"LLC\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct llc_sock),\n\t.slab_flags = SLAB_TYPESAFE_BY_RCU,\n};\n\n/**\n *\tllc_ui_create - alloc and init a new llc_ui socket\n *\t@net: network namespace (must be default network)\n *\t@sock: Socket to initialize and attach allocated sk to.\n *\t@protocol: Unused.\n *\t@kern: on behalf of kernel or userspace\n *\n *\tAllocate and initialize a new llc_ui socket, validate the user wants a\n *\tsocket type we have available.\n *\tReturns 0 upon success, negative upon failure.\n */\nstatic int llc_ui_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t int kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {\n\t\trc = -ENOMEM;\n\t\tsk = llc_sk_alloc(net, PF_LLC, GFP_KERNEL, &llc_proto, kern);\n\t\tif (sk) {\n\t\t\trc = 0;\n\t\t\tllc_ui_sk_init(sock, sk);\n\t\t}\n\t}\n\treturn rc;\n}\n\n/**\n *\tllc_ui_release - shutdown socket\n *\t@sock: Socket to release.\n *\n *\tShutdown and deallocate an existing socket.\n */\nstatic int llc_ui_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc;\n\n\tif (unlikely(sk == NULL))\n\t\tgoto out;\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tllc = llc_sk(sk);\n\tdprintk(\"%s: closing local(%02X) remote(%02X)\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tif (!llc_send_disc(sk))\n\t\tllc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\tstruct llc_sap *sap = llc->sap;\n\n\t\t/* Hold this for release_sock(), so that llc_backlog_rcv()\n\t\t * could still use it.\n\t\t */\n\t\tllc_sap_hold(sap);\n\t\tllc_sap_remove_socket(llc->sap, sk);\n\t\trelease_sock(sk);\n\t\tllc_sap_put(sap);\n\t} else {\n\t\trelease_sock(sk);\n\t}\n\tdev_put_track(llc->dev, &llc->dev_tracker);\n\tsock_put(sk);\n\tllc_sk_free(sk);\nout:\n\treturn 0;\n}\n\n/**\n *\tllc_ui_autoport - provide dynamically allocate SAP number\n *\n *\tProvide the caller with a dynamically allocated SAP number according\n *\tto the rules that are set in this function. Returns: 0, upon failure,\n *\tSAP number otherwise.\n */\nstatic int llc_ui_autoport(void)\n{\n\tstruct llc_sap *sap;\n\tint i, tries = 0;\n\n\twhile (tries < LLC_SAP_DYN_TRIES) {\n\t\tfor (i = llc_ui_sap_last_autoport;\n\t\t     i < LLC_SAP_DYN_STOP; i += 2) {\n\t\t\tsap = llc_sap_find(i);\n\t\t\tif (!sap) {\n\t\t\t\tllc_ui_sap_last_autoport = i + 2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tllc_sap_put(sap);\n\t\t}\n\t\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\t\ttries++;\n\t}\n\ti = 0;\nout:\n\treturn i;\n}\n\n/**\n *\tllc_ui_autobind - automatically bind a socket to a sap\n *\t@sock: socket to bind\n *\t@addr: address to connect to\n *\n * \tUsed by llc_ui_connect and llc_ui_sendmsg when the user hasn't\n * \tspecifically used llc_ui_bind to bind to an specific address/sap\n *\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; /* some other network layer is using the sap */\n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t/* assign new connection to its SAP */\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\treturn rc;\n}\n\n/**\n *\tllc_ui_bind - bind a socket to a specific address.\n *\t@sock: Socket to bind an address to.\n *\t@uaddr: Address the user wants the socket bound to.\n *\t@addrlen: Length of the uaddr structure.\n *\n *\tBind a socket to a specific address. For llc a user is able to bind to\n *\ta specific sap only or mac + sap.\n *\tIf the user desires to bind to a specific mac + sap, it is possible to\n *\thave multiple sap connections via multiple macs.\n *\tBind and autobind for that matter must enforce the correct sap usage\n *\totherwise all hell will break loose.\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addrlen)\n{\n\tstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(!sock_flag(sk, SOCK_ZAPPED) || addrlen != sizeof(*addr)))\n\t\tgoto out;\n\trc = -EAFNOSUPPORT;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (unlikely(addr->sllc_family != AF_LLC || addr->sllc_arphrd != ARPHRD_ETHER))\n\t\tgoto out;\n\tdprintk(\"%s: binding %02X\\n\", __func__, addr->sllc_sap);\n\trc = -ENODEV;\n\trcu_read_lock();\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index_rcu(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev) {\n\t\t\tif (is_zero_ether_addr(addr->sllc_mac))\n\t\t\t\tmemcpy(addr->sllc_mac, llc->dev->dev_addr,\n\t\t\t\t       IFHWADDRLEN);\n\t\t\tif (addr->sllc_arphrd != llc->dev->type ||\n\t\t\t    !ether_addr_equal(addr->sllc_mac,\n\t\t\t\t\t      llc->dev->dev_addr)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tllc->dev = NULL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tllc->dev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd,\n\t\t\t\t\t   addr->sllc_mac);\n\tdev_hold_track(llc->dev, &llc->dev_tracker, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!llc->dev)\n\t\tgoto out;\n\tif (!addr->sllc_sap) {\n\t\trc = -EUSERS;\n\t\taddr->sllc_sap = llc_ui_autoport();\n\t\tif (!addr->sllc_sap)\n\t\t\tgoto out;\n\t}\n\tsap = llc_sap_find(addr->sllc_sap);\n\tif (!sap) {\n\t\tsap = llc_sap_open(addr->sllc_sap, NULL);\n\t\trc = -EBUSY; /* some other network layer is using the sap */\n\t\tif (!sap)\n\t\t\tgoto out;\n\t} else {\n\t\tstruct llc_addr laddr, daddr;\n\t\tstruct sock *ask;\n\n\t\tmemset(&laddr, 0, sizeof(laddr));\n\t\tmemset(&daddr, 0, sizeof(daddr));\n\t\t/*\n\t\t * FIXME: check if the address is multicast,\n\t\t * \t  only SOCK_DGRAM can do this.\n\t\t */\n\t\tmemcpy(laddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\t\tladdr.lsap = addr->sllc_sap;\n\t\trc = -EADDRINUSE; /* mac + sap clash. */\n\t\task = llc_lookup_established(sap, &daddr, &laddr);\n\t\tif (ask) {\n\t\t\tsock_put(ask);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\tllc->laddr.lsap = addr->sllc_sap;\n\tmemcpy(llc->laddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t/* assign new connection to its SAP */\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout_put:\n\tllc_sap_put(sap);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_shutdown - shutdown a connect llc2 socket.\n *\t@sock: Socket to shutdown.\n *\t@how: What part of the socket to shutdown.\n *\n *\tShutdown a connected llc2 socket. Currently this function only supports\n *\tshutting down both sends and receives (2), we could probably make this\n *\tfunction such that a user can shutdown only half the connection but not\n *\tright now.\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_state != TCP_ESTABLISHED))\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (how != 2)\n\t\tgoto out;\n\trc = llc_send_disc(sk);\n\tif (!rc)\n\t\trc = llc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\n\t/* Wake up anyone sleeping in poll */\n\tsk->sk_state_change(sk);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_connect - Connect to a remote llc2 mac + sap.\n *\t@sock: Socket which will be connected to the remote destination.\n *\t@uaddr: Remote and possibly the local address of the new connection.\n *\t@addrlen: Size of uaddr structure.\n *\t@flags: Operational flags specified by the user.\n *\n *\tConnect to a remote llc2 mac + sap. The caller must specify the\n *\tdestination mac and address to connect to. If the user hasn't previously\n *\tcalled bind(2) with a smac the address of the first interface of the\n *\tspecified arp type will be used.\n *\tThis function will autobind if user did not previously call bind.\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int addrlen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(addrlen != sizeof(*addr)))\n\t\tgoto out;\n\trc = -EAFNOSUPPORT;\n\tif (unlikely(addr->sllc_family != AF_LLC))\n\t\tgoto out;\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EALREADY;\n\tif (unlikely(sock->state == SS_CONNECTING))\n\t\tgoto out;\n\t/* bind connection to sap if user hasn't done it. */\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* bind to sap with null dev, exclusive */\n\t\trc = llc_ui_autobind(sock, addr);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\tllc->daddr.lsap = addr->sllc_sap;\n\tmemcpy(llc->daddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\tsock->state = SS_CONNECTING;\n\tsk->sk_state   = TCP_SYN_SENT;\n\tllc->link   = llc_ui_next_link_no(llc->sap->laddr.lsap);\n\trc = llc_establish_connection(sk, llc->dev->dev_addr,\n\t\t\t\t      addr->sllc_mac, addr->sllc_sap);\n\tif (rc) {\n\t\tdprintk(\"%s: llc_ui_send_conn failed :-(\\n\", __func__);\n\t\tsock->state  = SS_UNCONNECTED;\n\t\tsk->sk_state = TCP_CLOSE;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tconst long timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\t\tif (!timeo || !llc_ui_wait_for_conn(sk, timeo))\n\t\t\tgoto out;\n\n\t\trc = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto sock_error;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\nsock_error:\n\trc = sock_error(sk) ? : -ECONNABORTED;\n\tsock->state = SS_UNCONNECTED;\n\tgoto out;\n}\n\n/**\n *\tllc_ui_listen - allow a normal socket to accept incoming connections\n *\t@sock: Socket to allow incoming connections on.\n *\t@backlog: Number of connections to queue.\n *\n *\tAllow a normal socket to accept incoming connections.\n *\tReturns 0 upon success, negative otherwise.\n */\nstatic int llc_ui_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(sock->state != SS_UNCONNECTED))\n\t\tgoto out;\n\trc = -EOPNOTSUPP;\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EAGAIN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\trc = 0;\n\tif (!(unsigned int)backlog)\t/* BSDism */\n\t\tbacklog = 1;\n\tsk->sk_max_ack_backlog = backlog;\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_ack_backlog = 0;\n\t\tsk->sk_state\t   = TCP_LISTEN;\n\t}\n\tsk->sk_socket->flags |= __SO_ACCEPTCON;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int llc_ui_wait_for_disc(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint rc = 0;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk_wait_event(sk, &timeout, sk->sk_state == TCP_CLOSE, &wait))\n\t\t\tbreak;\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeout)\n\t\t\tbreak;\n\t\trc = 0;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic bool llc_ui_wait_for_conn(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk_wait_event(sk, &timeout, sk->sk_state != TCP_SYN_SENT, &wait))\n\t\t\tbreak;\n\t\tif (signal_pending(current) || !timeout)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn timeout;\n}\n\nstatic int llc_ui_wait_for_busy_core(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\trc = 0;\n\t\tif (sk_wait_event(sk, &timeout,\n\t\t\t\t  (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t\t  (!llc_data_accept_state(llc->state) &&\n\t\t\t\t   !llc->remote_busy_flag &&\n\t\t\t\t   !llc->p_flag), &wait))\n\t\t\tbreak;\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeout)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic int llc_wait_data(struct sock *sk, long timeo)\n{\n\tint rc;\n\n\twhile (1) {\n\t\t/*\n\t\t * POSIX 1003.1g mandates this order.\n\t\t */\n\t\trc = sock_error(sk);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = 0;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trc = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tif (sk_wait_data(sk, &timeo, NULL))\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}\n\n/**\n *\tllc_ui_accept - accept a new incoming connection.\n *\t@sock: Socket which connections arrive on.\n *\t@newsock: Socket to move incoming connection to.\n *\t@flags: User specified operational flags.\n *\t@kern: If the socket is kernel internal\n *\n *\tAccept a new incoming connection.\n *\tReturns 0 upon success, negative otherwise.\n */\nstatic int llc_ui_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t\t bool kern)\n{\n\tstruct sock *sk = sock->sk, *newsk;\n\tstruct llc_sock *llc, *newllc;\n\tstruct sk_buff *skb;\n\tint rc = -EOPNOTSUPP;\n\n\tdprintk(\"%s: accepting on %02X\\n\", __func__,\n\t\tllc_sk(sk)->laddr.lsap);\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (unlikely(sock->state != SS_UNCONNECTED ||\n\t\t     sk->sk_state != TCP_LISTEN))\n\t\tgoto out;\n\t/* wait for a connection to arrive. */\n\tif (skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trc = llc_wait_data(sk, sk->sk_rcvtimeo);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\tdprintk(\"%s: got a new connection on %02X\\n\", __func__,\n\t\tllc_sk(sk)->laddr.lsap);\n\tskb = skb_dequeue(&sk->sk_receive_queue);\n\trc = -EINVAL;\n\tif (!skb->sk)\n\t\tgoto frees;\n\trc = 0;\n\tnewsk = skb->sk;\n\t/* attach connection to a new socket. */\n\tllc_ui_sk_init(newsock, newsk);\n\tsock_reset_flag(newsk, SOCK_ZAPPED);\n\tnewsk->sk_state\t\t= TCP_ESTABLISHED;\n\tnewsock->state\t\t= SS_CONNECTED;\n\tllc\t\t\t= llc_sk(sk);\n\tnewllc\t\t\t= llc_sk(newsk);\n\tmemcpy(&newllc->addr, &llc->addr, sizeof(newllc->addr));\n\tnewllc->link = llc_ui_next_link_no(newllc->laddr.lsap);\n\n\t/* put original socket back into a clean listen state. */\n\tsk->sk_state = TCP_LISTEN;\n\tsk_acceptq_removed(sk);\n\tdprintk(\"%s: ok success on %02X, client on %02X\\n\", __func__,\n\t\tllc_sk(sk)->addr.sllc_sap, newllc->daddr.lsap);\nfrees:\n\tkfree_skb(skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_recvmsg - copy received data to the socket user.\n *\t@sock: Socket to copy data from.\n *\t@msg: Various user space related information.\n *\t@len: Size of user buffer.\n *\t@flags: User specified flags.\n *\n *\tCopy received data to the socket user.\n *\tReturns non-negative upon success, negative otherwise.\n */\nstatic int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t  int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_llc *, uaddr, msg->msg_name);\n\tconst int nonblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tsize_t copied = 0;\n\tu32 peek_seq = 0;\n\tu32 *seq, skb_len;\n\tunsigned long used;\n\tint target;\t/* Read at least this many bytes */\n\tlong timeo;\n\n\tlock_sock(sk);\n\tcopied = -ENOTCONN;\n\tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\tseq = &llc->copied_seq;\n\tif (flags & MSG_PEEK) {\n\t\tpeek_seq = llc->copied_seq;\n\t\tseq = &peek_seq;\n\t}\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tcopied = 0;\n\n\tdo {\n\t\tu32 offset;\n\n\t\t/*\n\t\t * We need to check signals first, to get correct SIGURG\n\t\t * handling. FIXME: Need to check this doesn't impact 1003.1g\n\t\t * and move it down to the bottom of the loop\n\t\t */\n\t\tif (signal_pending(current)) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\tcopied = timeo ? sock_intr_errno(timeo) : -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Next get a buffer. */\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\toffset = *seq;\n\t\t\tgoto found_ok_skb;\n\t\t}\n\t\t/* Well, if we have backlog, try to process it now yet. */\n\n\t\tif (copied >= target && !READ_ONCE(sk->sk_backlog.tail))\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    (flags & MSG_PEEK))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This occurs when user tries to read\n\t\t\t\t\t * from never connected socket.\n\t\t\t\t\t */\n\t\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (copied >= target) { /* Do not sleep, just process backlog. */\n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\n\t\tif ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {\n\t\t\tnet_dbg_ratelimited(\"LLC(%s:%d): Application bug, race in MSG_PEEK\\n\",\n\t\t\t\t\t    current->comm,\n\t\t\t\t\t    task_pid_nr(current));\n\t\t\tpeek_seq = llc->copied_seq;\n\t\t}\n\t\tcontinue;\n\tfound_ok_skb:\n\t\tskb_len = skb->len;\n\t\t/* Ok so how much can we use? */\n\t\tused = skb->len - offset;\n\t\tif (len < used)\n\t\t\tused = len;\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\tint rc = skb_copy_datagram_msg(skb, offset, msg, used);\n\t\t\tif (rc) {\n\t\t\t\t/* Exception. Bailout! */\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*seq += used;\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\t/* For non stream protcols we get one packet per recvmsg call */\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\tgoto copy_uaddr;\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\t\tkfree_skb(skb);\n\t\t\t*seq = 0;\n\t\t}\n\n\t\t/* Partial read */\n\t\tif (used + offset < skb_len)\n\t\t\tcontinue;\n\t} while (len > 0);\n\nout:\n\trelease_sock(sk);\n\treturn copied;\ncopy_uaddr:\n\tif (uaddr != NULL && skb != NULL) {\n\t\tmemcpy(uaddr, llc_ui_skb_cb(skb), sizeof(*uaddr));\n\t\tmsg->msg_namelen = sizeof(*uaddr);\n\t}\n\tif (llc_sk(sk)->cmsg_flags)\n\t\tllc_cmsg_rcv(msg, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\tkfree_skb(skb);\n\t\t*seq = 0;\n\t}\n\n\tgoto out;\n}\n\n/**\n *\tllc_ui_sendmsg - Transmit data provided by the socket user.\n *\t@sock: Socket to transmit data from.\n *\t@msg: Various user related information.\n *\t@len: Length of data to transmit.\n *\n *\tTransmit data provided by the socket user.\n *\tReturns non-negative upon success, negative otherwise.\n */\nstatic int llc_ui_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_llc *, addr, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tsize_t size = 0;\n\tint rc = -EINVAL, copied = 0, hdrlen;\n\n\tdprintk(\"%s: sending from %02X to %02X\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tlock_sock(sk);\n\tif (addr) {\n\t\tif (msg->msg_namelen < sizeof(*addr))\n\t\t\tgoto out;\n\t} else {\n\t\tif (llc_ui_addr_null(&llc->addr))\n\t\t\tgoto out;\n\t\taddr = &llc->addr;\n\t}\n\t/* must bind connection to sap if user hasn't done it. */\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* bind to sap with null dev, exclusive. */\n\t\trc = llc_ui_autobind(sock, addr);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\thdrlen = llc->dev->hard_header_len + llc_ui_header_len(sk, addr);\n\tsize = hdrlen + len;\n\tif (size > llc->dev->mtu)\n\t\tsize = llc->dev->mtu;\n\tcopied = size - hdrlen;\n\trc = -EINVAL;\n\tif (copied < 0)\n\t\tgoto out;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tskb->dev      = llc->dev;\n\tskb->protocol = llc_proto_type(addr->sllc_arphrd);\n\tskb_reserve(skb, hdrlen);\n\trc = memcpy_from_msg(skb_put(skb, copied), msg, copied);\n\tif (rc)\n\t\tgoto out;\n\tif (sk->sk_type == SOCK_DGRAM || addr->sllc_ua) {\n\t\tllc_build_and_send_ui_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t  addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\tif (addr->sllc_test) {\n\t\tllc_build_and_send_test_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t    addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\tif (addr->sllc_xid) {\n\t\tllc_build_and_send_xid_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t   addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\trc = -ENOPROTOOPT;\n\tif (!(sk->sk_type == SOCK_STREAM && !addr->sllc_ua))\n\t\tgoto out;\n\trc = llc_ui_send_data(sk, skb, noblock);\n\tskb = NULL;\nout:\n\tkfree_skb(skb);\n\tif (rc)\n\t\tdprintk(\"%s: failed sending from %02X to %02X: %d\\n\",\n\t\t\t__func__, llc->laddr.lsap, llc->daddr.lsap, rc);\n\trelease_sock(sk);\n\treturn rc ? : copied;\n}\n\n/**\n *\tllc_ui_getname - return the address info of a socket\n *\t@sock: Socket to get address of.\n *\t@uaddr: Address structure to return information.\n *\t@peer: Does user want local or remote address information.\n *\n *\tReturn the address information of a socket.\n */\nstatic int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EBADF;\n\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\n\trc = sizeof(sllc);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_ioctl - io controls for PF_LLC\n *\t@sock: Socket to get/set info\n *\t@cmd: command\n *\t@arg: optional argument for cmd\n *\n *\tget/set info on llc sockets\n */\nstatic int llc_ui_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\treturn -ENOIOCTLCMD;\n}\n\n/**\n *\tllc_ui_setsockopt - set various connection specific parameters.\n *\t@sock: Socket to set options on.\n *\t@level: Socket level user is requesting operations on.\n *\t@optname: Operation name.\n *\t@optval: User provided operation data.\n *\t@optlen: Length of optval.\n *\n *\tSet various connection specific parameters.\n */\nstatic int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tunsigned int opt;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = copy_from_sockptr(&opt, optval, sizeof(opt));\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tcase LLC_OPT_PKTINFO:\n\t\tif (opt)\n\t\t\tllc->cmsg_flags |= LLC_CMSG_PKTINFO;\n\t\telse\n\t\t\tllc->cmsg_flags &= ~LLC_CMSG_PKTINFO;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_getsockopt - get connection specific socket info\n *\t@sock: Socket to get information from.\n *\t@level: Socket level user is requesting operations on.\n *\t@optname: Operation name.\n *\t@optval: Variable to return operation data in.\n *\t@optlen: Length of optval.\n *\n *\tGet connection specific socket information.\n */\nstatic int llc_ui_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint val = 0, len = 0, rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC))\n\t\tgoto out;\n\trc = get_user(len, optlen);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (len != sizeof(int))\n\t\tgoto out;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tval = llc->n2;\t\t\t\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tval = llc->n1;\t\t\t\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tval = llc->ack_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tval = llc->pf_cycle_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tval = llc->rej_sent_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tval = llc->busy_state_timer.expire / HZ;\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tval = llc->k;\t\t\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tval = llc->rw;\t\t\t\tbreak;\n\tcase LLC_OPT_PKTINFO:\n\t\tval = (llc->cmsg_flags & LLC_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\trc = -EFAULT;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic const struct net_proto_family llc_ui_family_ops = {\n\t.family = PF_LLC,\n\t.create = llc_ui_create,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops llc_ui_ops = {\n\t.family\t     = PF_LLC,\n\t.owner       = THIS_MODULE,\n\t.release     = llc_ui_release,\n\t.bind\t     = llc_ui_bind,\n\t.connect     = llc_ui_connect,\n\t.socketpair  = sock_no_socketpair,\n\t.accept      = llc_ui_accept,\n\t.getname     = llc_ui_getname,\n\t.poll\t     = datagram_poll,\n\t.ioctl       = llc_ui_ioctl,\n\t.listen      = llc_ui_listen,\n\t.shutdown    = llc_ui_shutdown,\n\t.setsockopt  = llc_ui_setsockopt,\n\t.getsockopt  = llc_ui_getsockopt,\n\t.sendmsg     = llc_ui_sendmsg,\n\t.recvmsg     = llc_ui_recvmsg,\n\t.mmap\t     = sock_no_mmap,\n\t.sendpage    = sock_no_sendpage,\n};\n\nstatic const char llc_proc_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the proc_fs entries\\n\";\nstatic const char llc_sysctl_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the sysctl entries\\n\";\nstatic const char llc_sock_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the network family\\n\";\n\nstatic int __init llc2_init(void)\n{\n\tint rc = proto_register(&llc_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tllc_build_offset_table();\n\tllc_station_init();\n\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\trc = llc_proc_init();\n\tif (rc != 0) {\n\t\tprintk(llc_proc_err_msg);\n\t\tgoto out_station;\n\t}\n\trc = llc_sysctl_init();\n\tif (rc) {\n\t\tprintk(llc_sysctl_err_msg);\n\t\tgoto out_proc;\n\t}\n\trc = sock_register(&llc_ui_family_ops);\n\tif (rc) {\n\t\tprintk(llc_sock_err_msg);\n\t\tgoto out_sysctl;\n\t}\n\tllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\n\tllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\nout:\n\treturn rc;\nout_sysctl:\n\tllc_sysctl_exit();\nout_proc:\n\tllc_proc_exit();\nout_station:\n\tllc_station_exit();\n\tproto_unregister(&llc_proto);\n\tgoto out;\n}\n\nstatic void __exit llc2_exit(void)\n{\n\tllc_station_exit();\n\tllc_remove_pack(LLC_DEST_SAP);\n\tllc_remove_pack(LLC_DEST_CONN);\n\tsock_unregister(PF_LLC);\n\tllc_proc_exit();\n\tllc_sysctl_exit();\n\tproto_unregister(&llc_proto);\n}\n\nmodule_init(llc2_init);\nmodule_exit(llc2_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Procom 1997, Jay Schullist 2001, Arnaldo C. Melo 2001-2003\");\nMODULE_DESCRIPTION(\"IEEE 802.2 PF_LLC support\");\nMODULE_ALIAS_NETPROTO(PF_LLC);\n"], "fixing_code": ["/*\n * af_llc.c - LLC User Interface SAPs\n * Description:\n *   Functions in this module are implementation of socket based llc\n *   communications for the Linux operating system. Support of llc class\n *   one and class two is provided via SOCK_DGRAM and SOCK_STREAM\n *   respectively.\n *\n *   An llc2 connection is (mac + sap), only one llc2 sap connection\n *   is allowed per mac. Though one sap may have multiple mac + sap\n *   connections.\n *\n * Copyright (c) 2001 by Jay Schulist <jschlst@samba.org>\n *\t\t 2002-2003 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n * This program can be redistributed or modified under the terms of the\n * GNU General Public License as published by the Free Software Foundation.\n * This program is distributed without any warranty or implied warranty\n * of merchantability or fitness for a particular purpose.\n *\n * See the GNU General Public License for more details.\n */\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <net/llc.h>\n#include <net/llc_sap.h>\n#include <net/llc_pdu.h>\n#include <net/llc_conn.h>\n#include <net/tcp_states.h>\n\n/* remember: uninitialized global data is zeroed because its in .bss */\nstatic u16 llc_ui_sap_last_autoport = LLC_SAP_DYN_START;\nstatic u16 llc_ui_sap_link_no_max[256];\nstatic struct sockaddr_llc llc_ui_addrnull;\nstatic const struct proto_ops llc_ui_ops;\n\nstatic bool llc_ui_wait_for_conn(struct sock *sk, long timeout);\nstatic int llc_ui_wait_for_disc(struct sock *sk, long timeout);\nstatic int llc_ui_wait_for_busy_core(struct sock *sk, long timeout);\n\n#if 0\n#define dprintk(args...) printk(KERN_DEBUG args)\n#else\n#define dprintk(args...) do {} while (0)\n#endif\n\n/* Maybe we'll add some more in the future. */\n#define LLC_CMSG_PKTINFO\t1\n\n\n/**\n *\tllc_ui_next_link_no - return the next unused link number for a sap\n *\t@sap: Address of sap to get link number from.\n *\n *\tReturn the next unused link number for a given sap.\n */\nstatic inline u16 llc_ui_next_link_no(int sap)\n{\n\treturn llc_ui_sap_link_no_max[sap]++;\n}\n\n/**\n *\tllc_proto_type - return eth protocol for ARP header type\n *\t@arphrd: ARP header type.\n *\n *\tGiven an ARP header type return the corresponding ethernet protocol.\n */\nstatic inline __be16 llc_proto_type(u16 arphrd)\n{\n\treturn htons(ETH_P_802_2);\n}\n\n/**\n *\tllc_ui_addr_null - determines if a address structure is null\n *\t@addr: Address to test if null.\n */\nstatic inline u8 llc_ui_addr_null(struct sockaddr_llc *addr)\n{\n\treturn !memcmp(addr, &llc_ui_addrnull, sizeof(*addr));\n}\n\n/**\n *\tllc_ui_header_len - return length of llc header based on operation\n *\t@sk: Socket which contains a valid llc socket type.\n *\t@addr: Complete sockaddr_llc structure received from the user.\n *\n *\tProvide the length of the llc header depending on what kind of\n *\toperation the user would like to perform and the type of socket.\n *\tReturns the correct llc header length.\n */\nstatic inline u8 llc_ui_header_len(struct sock *sk, struct sockaddr_llc *addr)\n{\n\tu8 rc = LLC_PDU_LEN_U;\n\n\tif (addr->sllc_test)\n\t\trc = LLC_PDU_LEN_U;\n\telse if (addr->sllc_xid)\n\t\t/* We need to expand header to sizeof(struct llc_xid_info)\n\t\t * since llc_pdu_init_as_xid_cmd() sets 4,5,6 bytes of LLC header\n\t\t * as XID PDU. In llc_ui_sendmsg() we reserved header size and then\n\t\t * filled all other space with user data. If we won't reserve this\n\t\t * bytes, llc_pdu_init_as_xid_cmd() will overwrite user data\n\t\t */\n\t\trc = LLC_PDU_LEN_U_XID;\n\telse if (sk->sk_type == SOCK_STREAM)\n\t\trc = LLC_PDU_LEN_I;\n\treturn rc;\n}\n\n/**\n *\tllc_ui_send_data - send data via reliable llc2 connection\n *\t@sk: Connection the socket is using.\n *\t@skb: Data the user wishes to send.\n *\t@noblock: can we block waiting for data?\n *\n *\tSend data via reliable llc2 connection.\n *\tReturns 0 upon success, non-zero if action did not succeed.\n *\n *\tThis function always consumes a reference to the skb.\n */\nstatic int llc_ui_send_data(struct sock* sk, struct sk_buff *skb, int noblock)\n{\n\tstruct llc_sock* llc = llc_sk(sk);\n\n\tif (unlikely(llc_data_accept_state(llc->state) ||\n\t\t     llc->remote_busy_flag ||\n\t\t     llc->p_flag)) {\n\t\tlong timeout = sock_sndtimeo(sk, noblock);\n\t\tint rc;\n\n\t\trc = llc_ui_wait_for_busy_core(sk, timeout);\n\t\tif (rc) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn llc_build_and_send_pkt(sk, skb);\n}\n\nstatic void llc_ui_sk_init(struct socket *sock, struct sock *sk)\n{\n\tsock_graft(sk, sock);\n\tsk->sk_type\t= sock->type;\n\tsock->ops\t= &llc_ui_ops;\n}\n\nstatic struct proto llc_proto = {\n\t.name\t  = \"LLC\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct llc_sock),\n\t.slab_flags = SLAB_TYPESAFE_BY_RCU,\n};\n\n/**\n *\tllc_ui_create - alloc and init a new llc_ui socket\n *\t@net: network namespace (must be default network)\n *\t@sock: Socket to initialize and attach allocated sk to.\n *\t@protocol: Unused.\n *\t@kern: on behalf of kernel or userspace\n *\n *\tAllocate and initialize a new llc_ui socket, validate the user wants a\n *\tsocket type we have available.\n *\tReturns 0 upon success, negative upon failure.\n */\nstatic int llc_ui_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t int kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {\n\t\trc = -ENOMEM;\n\t\tsk = llc_sk_alloc(net, PF_LLC, GFP_KERNEL, &llc_proto, kern);\n\t\tif (sk) {\n\t\t\trc = 0;\n\t\t\tllc_ui_sk_init(sock, sk);\n\t\t}\n\t}\n\treturn rc;\n}\n\n/**\n *\tllc_ui_release - shutdown socket\n *\t@sock: Socket to release.\n *\n *\tShutdown and deallocate an existing socket.\n */\nstatic int llc_ui_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc;\n\n\tif (unlikely(sk == NULL))\n\t\tgoto out;\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tllc = llc_sk(sk);\n\tdprintk(\"%s: closing local(%02X) remote(%02X)\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tif (!llc_send_disc(sk))\n\t\tllc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\tstruct llc_sap *sap = llc->sap;\n\n\t\t/* Hold this for release_sock(), so that llc_backlog_rcv()\n\t\t * could still use it.\n\t\t */\n\t\tllc_sap_hold(sap);\n\t\tllc_sap_remove_socket(llc->sap, sk);\n\t\trelease_sock(sk);\n\t\tllc_sap_put(sap);\n\t} else {\n\t\trelease_sock(sk);\n\t}\n\tdev_put_track(llc->dev, &llc->dev_tracker);\n\tsock_put(sk);\n\tllc_sk_free(sk);\nout:\n\treturn 0;\n}\n\n/**\n *\tllc_ui_autoport - provide dynamically allocate SAP number\n *\n *\tProvide the caller with a dynamically allocated SAP number according\n *\tto the rules that are set in this function. Returns: 0, upon failure,\n *\tSAP number otherwise.\n */\nstatic int llc_ui_autoport(void)\n{\n\tstruct llc_sap *sap;\n\tint i, tries = 0;\n\n\twhile (tries < LLC_SAP_DYN_TRIES) {\n\t\tfor (i = llc_ui_sap_last_autoport;\n\t\t     i < LLC_SAP_DYN_STOP; i += 2) {\n\t\t\tsap = llc_sap_find(i);\n\t\t\tif (!sap) {\n\t\t\t\tllc_ui_sap_last_autoport = i + 2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tllc_sap_put(sap);\n\t\t}\n\t\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\t\ttries++;\n\t}\n\ti = 0;\nout:\n\treturn i;\n}\n\n/**\n *\tllc_ui_autobind - automatically bind a socket to a sap\n *\t@sock: socket to bind\n *\t@addr: address to connect to\n *\n * \tUsed by llc_ui_connect and llc_ui_sendmsg when the user hasn't\n * \tspecifically used llc_ui_bind to bind to an specific address/sap\n *\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; /* some other network layer is using the sap */\n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t/* assign new connection to its SAP */\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\treturn rc;\n}\n\n/**\n *\tllc_ui_bind - bind a socket to a specific address.\n *\t@sock: Socket to bind an address to.\n *\t@uaddr: Address the user wants the socket bound to.\n *\t@addrlen: Length of the uaddr structure.\n *\n *\tBind a socket to a specific address. For llc a user is able to bind to\n *\ta specific sap only or mac + sap.\n *\tIf the user desires to bind to a specific mac + sap, it is possible to\n *\thave multiple sap connections via multiple macs.\n *\tBind and autobind for that matter must enforce the correct sap usage\n *\totherwise all hell will break loose.\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addrlen)\n{\n\tstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(!sock_flag(sk, SOCK_ZAPPED) || addrlen != sizeof(*addr)))\n\t\tgoto out;\n\trc = -EAFNOSUPPORT;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (unlikely(addr->sllc_family != AF_LLC || addr->sllc_arphrd != ARPHRD_ETHER))\n\t\tgoto out;\n\tdprintk(\"%s: binding %02X\\n\", __func__, addr->sllc_sap);\n\trc = -ENODEV;\n\trcu_read_lock();\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index_rcu(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev) {\n\t\t\tif (is_zero_ether_addr(addr->sllc_mac))\n\t\t\t\tmemcpy(addr->sllc_mac, llc->dev->dev_addr,\n\t\t\t\t       IFHWADDRLEN);\n\t\t\tif (addr->sllc_arphrd != llc->dev->type ||\n\t\t\t    !ether_addr_equal(addr->sllc_mac,\n\t\t\t\t\t      llc->dev->dev_addr)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tllc->dev = NULL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tllc->dev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd,\n\t\t\t\t\t   addr->sllc_mac);\n\tdev_hold_track(llc->dev, &llc->dev_tracker, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!llc->dev)\n\t\tgoto out;\n\tif (!addr->sllc_sap) {\n\t\trc = -EUSERS;\n\t\taddr->sllc_sap = llc_ui_autoport();\n\t\tif (!addr->sllc_sap)\n\t\t\tgoto out;\n\t}\n\tsap = llc_sap_find(addr->sllc_sap);\n\tif (!sap) {\n\t\tsap = llc_sap_open(addr->sllc_sap, NULL);\n\t\trc = -EBUSY; /* some other network layer is using the sap */\n\t\tif (!sap)\n\t\t\tgoto out;\n\t} else {\n\t\tstruct llc_addr laddr, daddr;\n\t\tstruct sock *ask;\n\n\t\tmemset(&laddr, 0, sizeof(laddr));\n\t\tmemset(&daddr, 0, sizeof(daddr));\n\t\t/*\n\t\t * FIXME: check if the address is multicast,\n\t\t * \t  only SOCK_DGRAM can do this.\n\t\t */\n\t\tmemcpy(laddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\t\tladdr.lsap = addr->sllc_sap;\n\t\trc = -EADDRINUSE; /* mac + sap clash. */\n\t\task = llc_lookup_established(sap, &daddr, &laddr);\n\t\tif (ask) {\n\t\t\tsock_put(ask);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\tllc->laddr.lsap = addr->sllc_sap;\n\tmemcpy(llc->laddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t/* assign new connection to its SAP */\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout_put:\n\tllc_sap_put(sap);\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_shutdown - shutdown a connect llc2 socket.\n *\t@sock: Socket to shutdown.\n *\t@how: What part of the socket to shutdown.\n *\n *\tShutdown a connected llc2 socket. Currently this function only supports\n *\tshutting down both sends and receives (2), we could probably make this\n *\tfunction such that a user can shutdown only half the connection but not\n *\tright now.\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_state != TCP_ESTABLISHED))\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (how != 2)\n\t\tgoto out;\n\trc = llc_send_disc(sk);\n\tif (!rc)\n\t\trc = llc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\n\t/* Wake up anyone sleeping in poll */\n\tsk->sk_state_change(sk);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_connect - Connect to a remote llc2 mac + sap.\n *\t@sock: Socket which will be connected to the remote destination.\n *\t@uaddr: Remote and possibly the local address of the new connection.\n *\t@addrlen: Size of uaddr structure.\n *\t@flags: Operational flags specified by the user.\n *\n *\tConnect to a remote llc2 mac + sap. The caller must specify the\n *\tdestination mac and address to connect to. If the user hasn't previously\n *\tcalled bind(2) with a smac the address of the first interface of the\n *\tspecified arp type will be used.\n *\tThis function will autobind if user did not previously call bind.\n *\tReturns: 0 upon success, negative otherwise.\n */\nstatic int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int addrlen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(addrlen != sizeof(*addr)))\n\t\tgoto out;\n\trc = -EAFNOSUPPORT;\n\tif (unlikely(addr->sllc_family != AF_LLC))\n\t\tgoto out;\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EALREADY;\n\tif (unlikely(sock->state == SS_CONNECTING))\n\t\tgoto out;\n\t/* bind connection to sap if user hasn't done it. */\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* bind to sap with null dev, exclusive */\n\t\trc = llc_ui_autobind(sock, addr);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\tllc->daddr.lsap = addr->sllc_sap;\n\tmemcpy(llc->daddr.mac, addr->sllc_mac, IFHWADDRLEN);\n\tsock->state = SS_CONNECTING;\n\tsk->sk_state   = TCP_SYN_SENT;\n\tllc->link   = llc_ui_next_link_no(llc->sap->laddr.lsap);\n\trc = llc_establish_connection(sk, llc->dev->dev_addr,\n\t\t\t\t      addr->sllc_mac, addr->sllc_sap);\n\tif (rc) {\n\t\tdprintk(\"%s: llc_ui_send_conn failed :-(\\n\", __func__);\n\t\tsock->state  = SS_UNCONNECTED;\n\t\tsk->sk_state = TCP_CLOSE;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tconst long timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\t\tif (!timeo || !llc_ui_wait_for_conn(sk, timeo))\n\t\t\tgoto out;\n\n\t\trc = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto sock_error;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\nsock_error:\n\trc = sock_error(sk) ? : -ECONNABORTED;\n\tsock->state = SS_UNCONNECTED;\n\tgoto out;\n}\n\n/**\n *\tllc_ui_listen - allow a normal socket to accept incoming connections\n *\t@sock: Socket to allow incoming connections on.\n *\t@backlog: Number of connections to queue.\n *\n *\tAllow a normal socket to accept incoming connections.\n *\tReturns 0 upon success, negative otherwise.\n */\nstatic int llc_ui_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(sock->state != SS_UNCONNECTED))\n\t\tgoto out;\n\trc = -EOPNOTSUPP;\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EAGAIN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\trc = 0;\n\tif (!(unsigned int)backlog)\t/* BSDism */\n\t\tbacklog = 1;\n\tsk->sk_max_ack_backlog = backlog;\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_ack_backlog = 0;\n\t\tsk->sk_state\t   = TCP_LISTEN;\n\t}\n\tsk->sk_socket->flags |= __SO_ACCEPTCON;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int llc_ui_wait_for_disc(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint rc = 0;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk_wait_event(sk, &timeout, sk->sk_state == TCP_CLOSE, &wait))\n\t\t\tbreak;\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeout)\n\t\t\tbreak;\n\t\trc = 0;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic bool llc_ui_wait_for_conn(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk_wait_event(sk, &timeout, sk->sk_state != TCP_SYN_SENT, &wait))\n\t\t\tbreak;\n\t\tif (signal_pending(current) || !timeout)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn timeout;\n}\n\nstatic int llc_ui_wait_for_busy_core(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\trc = 0;\n\t\tif (sk_wait_event(sk, &timeout,\n\t\t\t\t  (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t\t  (!llc_data_accept_state(llc->state) &&\n\t\t\t\t   !llc->remote_busy_flag &&\n\t\t\t\t   !llc->p_flag), &wait))\n\t\t\tbreak;\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeout)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic int llc_wait_data(struct sock *sk, long timeo)\n{\n\tint rc;\n\n\twhile (1) {\n\t\t/*\n\t\t * POSIX 1003.1g mandates this order.\n\t\t */\n\t\trc = sock_error(sk);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = 0;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trc = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tif (sk_wait_data(sk, &timeo, NULL))\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}\n\n/**\n *\tllc_ui_accept - accept a new incoming connection.\n *\t@sock: Socket which connections arrive on.\n *\t@newsock: Socket to move incoming connection to.\n *\t@flags: User specified operational flags.\n *\t@kern: If the socket is kernel internal\n *\n *\tAccept a new incoming connection.\n *\tReturns 0 upon success, negative otherwise.\n */\nstatic int llc_ui_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t\t bool kern)\n{\n\tstruct sock *sk = sock->sk, *newsk;\n\tstruct llc_sock *llc, *newllc;\n\tstruct sk_buff *skb;\n\tint rc = -EOPNOTSUPP;\n\n\tdprintk(\"%s: accepting on %02X\\n\", __func__,\n\t\tllc_sk(sk)->laddr.lsap);\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_type != SOCK_STREAM))\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (unlikely(sock->state != SS_UNCONNECTED ||\n\t\t     sk->sk_state != TCP_LISTEN))\n\t\tgoto out;\n\t/* wait for a connection to arrive. */\n\tif (skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trc = llc_wait_data(sk, sk->sk_rcvtimeo);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\tdprintk(\"%s: got a new connection on %02X\\n\", __func__,\n\t\tllc_sk(sk)->laddr.lsap);\n\tskb = skb_dequeue(&sk->sk_receive_queue);\n\trc = -EINVAL;\n\tif (!skb->sk)\n\t\tgoto frees;\n\trc = 0;\n\tnewsk = skb->sk;\n\t/* attach connection to a new socket. */\n\tllc_ui_sk_init(newsock, newsk);\n\tsock_reset_flag(newsk, SOCK_ZAPPED);\n\tnewsk->sk_state\t\t= TCP_ESTABLISHED;\n\tnewsock->state\t\t= SS_CONNECTED;\n\tllc\t\t\t= llc_sk(sk);\n\tnewllc\t\t\t= llc_sk(newsk);\n\tmemcpy(&newllc->addr, &llc->addr, sizeof(newllc->addr));\n\tnewllc->link = llc_ui_next_link_no(newllc->laddr.lsap);\n\n\t/* put original socket back into a clean listen state. */\n\tsk->sk_state = TCP_LISTEN;\n\tsk_acceptq_removed(sk);\n\tdprintk(\"%s: ok success on %02X, client on %02X\\n\", __func__,\n\t\tllc_sk(sk)->addr.sllc_sap, newllc->daddr.lsap);\nfrees:\n\tkfree_skb(skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_recvmsg - copy received data to the socket user.\n *\t@sock: Socket to copy data from.\n *\t@msg: Various user space related information.\n *\t@len: Size of user buffer.\n *\t@flags: User specified flags.\n *\n *\tCopy received data to the socket user.\n *\tReturns non-negative upon success, negative otherwise.\n */\nstatic int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t  int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_llc *, uaddr, msg->msg_name);\n\tconst int nonblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tsize_t copied = 0;\n\tu32 peek_seq = 0;\n\tu32 *seq, skb_len;\n\tunsigned long used;\n\tint target;\t/* Read at least this many bytes */\n\tlong timeo;\n\n\tlock_sock(sk);\n\tcopied = -ENOTCONN;\n\tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\tseq = &llc->copied_seq;\n\tif (flags & MSG_PEEK) {\n\t\tpeek_seq = llc->copied_seq;\n\t\tseq = &peek_seq;\n\t}\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tcopied = 0;\n\n\tdo {\n\t\tu32 offset;\n\n\t\t/*\n\t\t * We need to check signals first, to get correct SIGURG\n\t\t * handling. FIXME: Need to check this doesn't impact 1003.1g\n\t\t * and move it down to the bottom of the loop\n\t\t */\n\t\tif (signal_pending(current)) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\tcopied = timeo ? sock_intr_errno(timeo) : -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Next get a buffer. */\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\toffset = *seq;\n\t\t\tgoto found_ok_skb;\n\t\t}\n\t\t/* Well, if we have backlog, try to process it now yet. */\n\n\t\tif (copied >= target && !READ_ONCE(sk->sk_backlog.tail))\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    (flags & MSG_PEEK))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This occurs when user tries to read\n\t\t\t\t\t * from never connected socket.\n\t\t\t\t\t */\n\t\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (copied >= target) { /* Do not sleep, just process backlog. */\n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\n\t\tif ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {\n\t\t\tnet_dbg_ratelimited(\"LLC(%s:%d): Application bug, race in MSG_PEEK\\n\",\n\t\t\t\t\t    current->comm,\n\t\t\t\t\t    task_pid_nr(current));\n\t\t\tpeek_seq = llc->copied_seq;\n\t\t}\n\t\tcontinue;\n\tfound_ok_skb:\n\t\tskb_len = skb->len;\n\t\t/* Ok so how much can we use? */\n\t\tused = skb->len - offset;\n\t\tif (len < used)\n\t\t\tused = len;\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\tint rc = skb_copy_datagram_msg(skb, offset, msg, used);\n\t\t\tif (rc) {\n\t\t\t\t/* Exception. Bailout! */\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*seq += used;\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\t/* For non stream protcols we get one packet per recvmsg call */\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\tgoto copy_uaddr;\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\t\tkfree_skb(skb);\n\t\t\t*seq = 0;\n\t\t}\n\n\t\t/* Partial read */\n\t\tif (used + offset < skb_len)\n\t\t\tcontinue;\n\t} while (len > 0);\n\nout:\n\trelease_sock(sk);\n\treturn copied;\ncopy_uaddr:\n\tif (uaddr != NULL && skb != NULL) {\n\t\tmemcpy(uaddr, llc_ui_skb_cb(skb), sizeof(*uaddr));\n\t\tmsg->msg_namelen = sizeof(*uaddr);\n\t}\n\tif (llc_sk(sk)->cmsg_flags)\n\t\tllc_cmsg_rcv(msg, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\tkfree_skb(skb);\n\t\t*seq = 0;\n\t}\n\n\tgoto out;\n}\n\n/**\n *\tllc_ui_sendmsg - Transmit data provided by the socket user.\n *\t@sock: Socket to transmit data from.\n *\t@msg: Various user related information.\n *\t@len: Length of data to transmit.\n *\n *\tTransmit data provided by the socket user.\n *\tReturns non-negative upon success, negative otherwise.\n */\nstatic int llc_ui_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_llc *, addr, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tsize_t size = 0;\n\tint rc = -EINVAL, copied = 0, hdrlen;\n\n\tdprintk(\"%s: sending from %02X to %02X\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tlock_sock(sk);\n\tif (addr) {\n\t\tif (msg->msg_namelen < sizeof(*addr))\n\t\t\tgoto out;\n\t} else {\n\t\tif (llc_ui_addr_null(&llc->addr))\n\t\t\tgoto out;\n\t\taddr = &llc->addr;\n\t}\n\t/* must bind connection to sap if user hasn't done it. */\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* bind to sap with null dev, exclusive. */\n\t\trc = llc_ui_autobind(sock, addr);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\thdrlen = llc->dev->hard_header_len + llc_ui_header_len(sk, addr);\n\tsize = hdrlen + len;\n\tif (size > llc->dev->mtu)\n\t\tsize = llc->dev->mtu;\n\tcopied = size - hdrlen;\n\trc = -EINVAL;\n\tif (copied < 0)\n\t\tgoto out;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tskb->dev      = llc->dev;\n\tskb->protocol = llc_proto_type(addr->sllc_arphrd);\n\tskb_reserve(skb, hdrlen);\n\trc = memcpy_from_msg(skb_put(skb, copied), msg, copied);\n\tif (rc)\n\t\tgoto out;\n\tif (sk->sk_type == SOCK_DGRAM || addr->sllc_ua) {\n\t\tllc_build_and_send_ui_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t  addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\tif (addr->sllc_test) {\n\t\tllc_build_and_send_test_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t    addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\tif (addr->sllc_xid) {\n\t\tllc_build_and_send_xid_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t   addr->sllc_sap);\n\t\tskb = NULL;\n\t\tgoto out;\n\t}\n\trc = -ENOPROTOOPT;\n\tif (!(sk->sk_type == SOCK_STREAM && !addr->sllc_ua))\n\t\tgoto out;\n\trc = llc_ui_send_data(sk, skb, noblock);\n\tskb = NULL;\nout:\n\tkfree_skb(skb);\n\tif (rc)\n\t\tdprintk(\"%s: failed sending from %02X to %02X: %d\\n\",\n\t\t\t__func__, llc->laddr.lsap, llc->daddr.lsap, rc);\n\trelease_sock(sk);\n\treturn rc ? : copied;\n}\n\n/**\n *\tllc_ui_getname - return the address info of a socket\n *\t@sock: Socket to get address of.\n *\t@uaddr: Address structure to return information.\n *\t@peer: Does user want local or remote address information.\n *\n *\tReturn the address information of a socket.\n */\nstatic int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EBADF;\n\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\n\trc = sizeof(sllc);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_ioctl - io controls for PF_LLC\n *\t@sock: Socket to get/set info\n *\t@cmd: command\n *\t@arg: optional argument for cmd\n *\n *\tget/set info on llc sockets\n */\nstatic int llc_ui_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\treturn -ENOIOCTLCMD;\n}\n\n/**\n *\tllc_ui_setsockopt - set various connection specific parameters.\n *\t@sock: Socket to set options on.\n *\t@level: Socket level user is requesting operations on.\n *\t@optname: Operation name.\n *\t@optval: User provided operation data.\n *\t@optlen: Length of optval.\n *\n *\tSet various connection specific parameters.\n */\nstatic int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tunsigned int opt;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = copy_from_sockptr(&opt, optval, sizeof(opt));\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tcase LLC_OPT_PKTINFO:\n\t\tif (opt)\n\t\t\tllc->cmsg_flags |= LLC_CMSG_PKTINFO;\n\t\telse\n\t\t\tllc->cmsg_flags &= ~LLC_CMSG_PKTINFO;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/**\n *\tllc_ui_getsockopt - get connection specific socket info\n *\t@sock: Socket to get information from.\n *\t@level: Socket level user is requesting operations on.\n *\t@optname: Operation name.\n *\t@optval: Variable to return operation data in.\n *\t@optlen: Length of optval.\n *\n *\tGet connection specific socket information.\n */\nstatic int llc_ui_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint val = 0, len = 0, rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC))\n\t\tgoto out;\n\trc = get_user(len, optlen);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (len != sizeof(int))\n\t\tgoto out;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tval = llc->n2;\t\t\t\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tval = llc->n1;\t\t\t\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tval = llc->ack_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tval = llc->pf_cycle_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tval = llc->rej_sent_timer.expire / HZ;\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tval = llc->busy_state_timer.expire / HZ;\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tval = llc->k;\t\t\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tval = llc->rw;\t\t\t\tbreak;\n\tcase LLC_OPT_PKTINFO:\n\t\tval = (llc->cmsg_flags & LLC_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\trc = -EFAULT;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic const struct net_proto_family llc_ui_family_ops = {\n\t.family = PF_LLC,\n\t.create = llc_ui_create,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops llc_ui_ops = {\n\t.family\t     = PF_LLC,\n\t.owner       = THIS_MODULE,\n\t.release     = llc_ui_release,\n\t.bind\t     = llc_ui_bind,\n\t.connect     = llc_ui_connect,\n\t.socketpair  = sock_no_socketpair,\n\t.accept      = llc_ui_accept,\n\t.getname     = llc_ui_getname,\n\t.poll\t     = datagram_poll,\n\t.ioctl       = llc_ui_ioctl,\n\t.listen      = llc_ui_listen,\n\t.shutdown    = llc_ui_shutdown,\n\t.setsockopt  = llc_ui_setsockopt,\n\t.getsockopt  = llc_ui_getsockopt,\n\t.sendmsg     = llc_ui_sendmsg,\n\t.recvmsg     = llc_ui_recvmsg,\n\t.mmap\t     = sock_no_mmap,\n\t.sendpage    = sock_no_sendpage,\n};\n\nstatic const char llc_proc_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the proc_fs entries\\n\";\nstatic const char llc_sysctl_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the sysctl entries\\n\";\nstatic const char llc_sock_err_msg[] __initconst =\n\tKERN_CRIT \"LLC: Unable to register the network family\\n\";\n\nstatic int __init llc2_init(void)\n{\n\tint rc = proto_register(&llc_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tllc_build_offset_table();\n\tllc_station_init();\n\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\trc = llc_proc_init();\n\tif (rc != 0) {\n\t\tprintk(llc_proc_err_msg);\n\t\tgoto out_station;\n\t}\n\trc = llc_sysctl_init();\n\tif (rc) {\n\t\tprintk(llc_sysctl_err_msg);\n\t\tgoto out_proc;\n\t}\n\trc = sock_register(&llc_ui_family_ops);\n\tif (rc) {\n\t\tprintk(llc_sock_err_msg);\n\t\tgoto out_sysctl;\n\t}\n\tllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\n\tllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\nout:\n\treturn rc;\nout_sysctl:\n\tllc_sysctl_exit();\nout_proc:\n\tllc_proc_exit();\nout_station:\n\tllc_station_exit();\n\tproto_unregister(&llc_proto);\n\tgoto out;\n}\n\nstatic void __exit llc2_exit(void)\n{\n\tllc_station_exit();\n\tllc_remove_pack(LLC_DEST_SAP);\n\tllc_remove_pack(LLC_DEST_CONN);\n\tsock_unregister(PF_LLC);\n\tllc_proc_exit();\n\tllc_sysctl_exit();\n\tproto_unregister(&llc_proto);\n}\n\nmodule_init(llc2_init);\nmodule_exit(llc2_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Procom 1997, Jay Schullist 2001, Arnaldo C. Melo 2001-2003\");\nMODULE_DESCRIPTION(\"IEEE 802.2 PF_LLC support\");\nMODULE_ALIAS_NETPROTO(PF_LLC);\n"], "filenames": ["net/llc/af_llc.c"], "buggy_code_start_loc": [313], "buggy_code_end_loc": [410], "fixing_code_start_loc": [314], "fixing_code_end_loc": [419], "type": "NVD-CWE-Other", "message": "In the Linux kernel before 5.17.1, a refcount leak bug was found in net/llc/af_llc.c.", "other": {"cve": {"id": "CVE-2022-28356", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-02T21:15:09.363", "lastModified": "2023-02-03T23:59:15.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.17.1, a refcount leak bug was found in net/llc/af_llc.c."}, {"lang": "es", "value": "En el kernel de Linux versiones anteriores a 5.17.1, se encontr\u00f3 un bug de filtrado de refcount en el archivo net/llc/af_llc.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.17.1", "matchCriteriaId": "C4C36454-2CDC-4F8D-A717-878F1C39CAD1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/04/06/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.1", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/764f4eb6846f5475f1244767d24d25dd86528a4a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220506-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5127", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/764f4eb6846f5475f1244767d24d25dd86528a4a"}}