{"buggy_code": ["/*\n *  Copyright (C) 2000-2002 Constantin Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * rfbproto.c - functions to deal with client side of RFB protocol.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#define _XOPEN_SOURCE 600\n#endif\n#ifndef WIN32\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#endif\n#include <errno.h>\n#include <rfb/rfbclient.h>\n#ifdef WIN32\n#undef socklen_t\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#include <zlib.h>\n#ifdef __CHECKER__\n#undef Z_NULL\n#define Z_NULL NULL\n#endif\n#endif\n\n#ifndef _MSC_VER\n/* Strings.h is not available in MSVC */\n#include <strings.h>\n#endif\n\n#include <stdarg.h>\n#include <time.h>\n\n#include \"crypto.h\"\n\n#include \"sasl.h\"\n#ifdef LIBVNCSERVER_HAVE_LZO\n#include <lzo/lzo1x.h>\n#else\n#include \"minilzo.h\"\n#endif\n#include \"tls.h\"\n\n#define MAX_TEXTCHAT_SIZE 10485760 /* 10MB */\n\n/*\n * rfbClientLog prints a time-stamped message to the log file (stderr).\n */\n\nrfbBool rfbEnableClientLogging=TRUE;\n\nstatic void\nrfbDefaultClientLog(const char *format, ...)\n{\n    va_list args;\n    char buf[256];\n    time_t log_clock;\n\n    if(!rfbEnableClientLogging)\n      return;\n\n    va_start(args, format);\n\n    time(&log_clock);\n    strftime(buf, 255, \"%d/%m/%Y %X \", localtime(&log_clock));\n    fprintf(stderr, \"%s\", buf);\n\n    vfprintf(stderr, format, args);\n    fflush(stderr);\n\n    va_end(args);\n}\n\nrfbClientLogProc rfbClientLog=rfbDefaultClientLog;\nrfbClientLogProc rfbClientErr=rfbDefaultClientLog;\n\n/* extensions */\n\nrfbClientProtocolExtension* rfbClientExtensions = NULL;\n\nvoid rfbClientRegisterExtension(rfbClientProtocolExtension* e)\n{\n\te->next = rfbClientExtensions;\n\trfbClientExtensions = e;\n}\n\n/* client data */\n\nvoid rfbClientSetClientData(rfbClient* client, void* tag, void* data)\n{\n\trfbClientData* clientData = client->clientData;\n\n\twhile(clientData && clientData->tag != tag)\n\t\tclientData = clientData->next;\n\tif(clientData == NULL) {\n\t\tclientData = calloc(sizeof(rfbClientData), 1);\n\t\tclientData->next = client->clientData;\n\t\tclient->clientData = clientData;\n\t\tclientData->tag = tag;\n\t}\n\n\tclientData->data = data;\n}\n\nvoid* rfbClientGetClientData(rfbClient* client, void* tag)\n{\n\trfbClientData* clientData = client->clientData;\n\n\twhile(clientData) {\n\t\tif(clientData->tag == tag)\n\t\t\treturn clientData->data;\n\t\tclientData = clientData->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic rfbBool HandleRRE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleRRE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleRRE32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleCoRRE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleCoRRE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleCoRRE32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleHextile8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleHextile16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleHextile32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltra8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltra16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltra32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltraZip8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltraZip16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltraZip32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE15(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE24(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE24Up(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE24Down(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE32(rfbClient* client, int rx, int ry, int rw, int rh);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\nstatic rfbBool HandleZlib8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZlib16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZlib32(rfbClient* client, int rx, int ry, int rw, int rh);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\nstatic rfbBool HandleTight8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTight16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTight32(rfbClient* client, int rx, int ry, int rw, int rh);\n\nstatic long ReadCompactLen (rfbClient* client);\n#endif\nstatic rfbBool HandleZRLE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE15(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE24(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE24Up(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE24Down(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE32(rfbClient* client, int rx, int ry, int rw, int rh);\n#endif\n\n/*\n * Server Capability Functions\n */\nrfbBool\nSupportsClient2Server(rfbClient* client, int messageType)\n{\n    return (client->supportedMessages.client2server[((messageType & 0xFF)/8)] & (1<<(messageType % 8)) ? TRUE : FALSE);\n}\n\nrfbBool\nSupportsServer2Client(rfbClient* client, int messageType)\n{\n    return (client->supportedMessages.server2client[((messageType & 0xFF)/8)] & (1<<(messageType % 8)) ? TRUE : FALSE);\n}\n\nvoid\nSetClient2Server(rfbClient* client, int messageType)\n{\n  client->supportedMessages.client2server[((messageType & 0xFF)/8)] |= (1<<(messageType % 8));\n}\n\nvoid\nSetServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] |= (1<<(messageType % 8));\n}\n\nvoid\nClearClient2Server(rfbClient* client, int messageType)\n{\n  client->supportedMessages.client2server[((messageType & 0xFF)/8)] &= ~(1<<(messageType % 8));\n}\n\nvoid\nClearServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= ~(1<<(messageType % 8));\n}\n\n\nvoid\nDefaultSupportedMessages(rfbClient* client)\n{\n    memset((char *)&client->supportedMessages,0,sizeof(client->supportedMessages));\n\n    /* Default client supported messages (universal RFB 3.3 protocol) */\n    SetClient2Server(client, rfbSetPixelFormat);\n    /* SetClient2Server(client, rfbFixColourMapEntries); Not currently supported */\n    SetClient2Server(client, rfbSetEncodings);\n    SetClient2Server(client, rfbFramebufferUpdateRequest);\n    SetClient2Server(client, rfbKeyEvent);\n    SetClient2Server(client, rfbPointerEvent);\n    SetClient2Server(client, rfbClientCutText);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbFramebufferUpdate);\n    SetServer2Client(client, rfbSetColourMapEntries);\n    SetServer2Client(client, rfbBell);\n    SetServer2Client(client, rfbServerCutText);\n}\n\nvoid\nDefaultSupportedMessagesUltraVNC(rfbClient* client)\n{\n    DefaultSupportedMessages(client);\n    SetClient2Server(client, rfbFileTransfer);\n    SetClient2Server(client, rfbSetScale);\n    SetClient2Server(client, rfbSetServerInput);\n    SetClient2Server(client, rfbSetSW);\n    SetClient2Server(client, rfbTextChat);\n    SetClient2Server(client, rfbPalmVNCSetScaleFactor);\n    /* technically, we only care what we can *send* to the server */\n    SetServer2Client(client, rfbResizeFrameBuffer);\n    SetServer2Client(client, rfbPalmVNCReSizeFrameBuffer);\n    SetServer2Client(client, rfbFileTransfer);\n    SetServer2Client(client, rfbTextChat);\n}\n\n\nvoid\nDefaultSupportedMessagesTightVNC(rfbClient* client)\n{\n    DefaultSupportedMessages(client);\n    SetClient2Server(client, rfbFileTransfer);\n    SetClient2Server(client, rfbSetServerInput);\n    SetClient2Server(client, rfbSetSW);\n    /* SetClient2Server(client, rfbTextChat); */\n    /* technically, we only care what we can *send* to the server */\n    SetServer2Client(client, rfbFileTransfer);\n    SetServer2Client(client, rfbTextChat);\n}\n\n#ifndef WIN32\nstatic rfbBool\nIsUnixSocket(const char *name)\n{\n  struct stat sb;\n  if(stat(name, &sb) == 0 && (sb.st_mode & S_IFMT) == S_IFSOCK)\n    return TRUE;\n  return FALSE;\n}\n#endif\n\n/*\n * ConnectToRFBServer.\n */\n\nrfbBool\nConnectToRFBServer(rfbClient* client,const char *hostname, int port)\n{\n  if (client->serverPort==-1) {\n    /* serverHost is a file recorded by vncrec. */\n    const char* magic=\"vncLog0.0\";\n    char buffer[10];\n    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));\n    client->vncRec = rec;\n\n    rec->file = fopen(client->serverHost,\"rb\");\n    rec->tv.tv_sec = 0;\n    rec->readTimestamp = FALSE;\n    rec->doNotSleep = FALSE;\n    \n    if (!rec->file) {\n      rfbClientLog(\"Could not open %s.\\n\",client->serverHost);\n      return FALSE;\n    }\n    setbuf(rec->file,NULL);\n\n    if (fread(buffer,1,strlen(magic),rec->file) != strlen(magic) || strncmp(buffer,magic,strlen(magic))) {\n      rfbClientLog(\"File %s was not recorded by vncrec.\\n\",client->serverHost);\n      fclose(rec->file);\n      return FALSE;\n    }\n    client->sock = RFB_INVALID_SOCKET;\n    return TRUE;\n  }\n\n#ifndef WIN32\n  if(IsUnixSocket(hostname))\n    /* serverHost is a UNIX socket. */\n    client->sock = ConnectClientToUnixSockWithTimeout(hostname, client->connectTimeout);\n  else\n#endif\n  {\n#ifdef LIBVNCSERVER_IPv6\n    client->sock = ConnectClientToTcpAddr6WithTimeout(hostname, port, client->connectTimeout);\n#else\n    unsigned int host;\n\n    /* serverHost is a hostname */\n    if (!StringToIPAddr(hostname, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", hostname);\n      return FALSE;\n    }\n    client->sock = ConnectClientToTcpAddrWithTimeout(host, port, client->connectTimeout);\n#endif\n  }\n\n  if (client->sock == RFB_INVALID_SOCKET) {\n    rfbClientLog(\"Unable to connect to VNC server\\n\");\n    return FALSE;\n  }\n\n  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))\n     return FALSE;\n\n  return TRUE;\n}\n\n/*\n * ConnectToRFBRepeater.\n */\n\nrfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6WithTimeout(repeaterHost, repeaterPort, client->connectTimeout);\n#else\n  unsigned int host;\n  if (!StringToIPAddr(repeaterHost, &host)) {\n    rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n    return FALSE;\n  }\n\n  client->sock = ConnectClientToTcpAddrWithTimeout(host, repeaterPort, client->connectTimeout);\n#endif\n\n  if (client->sock == RFB_INVALID_SOCKET) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n\n  /* UltraVNC repeater always report version 000.000 to identify itself */\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n\n  memset(tmphost, 0, sizeof(tmphost));\n  if(snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort) >= (int)sizeof(tmphost))\n    return FALSE; /* output truncated */\n  if (!WriteToRFBServer(client, tmphost, sizeof(tmphost)))\n    return FALSE;\n\n  return TRUE;\n}\n\nextern void rfbClientEncryptBytes(unsigned char* bytes, char* passwd);\nextern void rfbClientEncryptBytes2(unsigned char *where, const int length, unsigned char *key);\n\nstatic void\nReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    if(reasonLen > 1<<20) {\n      rfbClientLog(\"VNC connection failed, but sent reason length of %u exceeds limit of 1MB\",(unsigned int)reasonLen);\n      return;\n    }\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}\n\nrfbBool\nrfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}\n\n\nstatic rfbBool\nReadSupportedSecurityType(rfbClient* client, uint32_t *result, rfbBool subAuth)\n{\n    uint8_t count=0;\n    uint8_t loop=0;\n    uint8_t flag=0;\n    rfbBool extAuthHandler;\n    uint8_t tAuth[256];\n    char buf1[500],buf2[10];\n    uint32_t authScheme;\n    rfbClientProtocolExtension* e;\n\n    if (!ReadFromRFBServer(client, (char *)&count, 1)) return FALSE;\n\n    if (count==0)\n    {\n        rfbClientLog(\"List of security types is ZERO, expecting an error to follow\\n\");\n        ReadReason(client);\n        return FALSE;\n    }\n\n    rfbClientLog(\"We have %d security types to read\\n\", count);\n    authScheme=0;\n    /* now, we have a list of available security types to read ( uint8_t[] ) */\n    for (loop=0;loop<count;loop++)\n    {\n        if (!ReadFromRFBServer(client, (char *)&tAuth[loop], 1)) return FALSE;\n        rfbClientLog(\"%d) Received security type %d\\n\", loop, tAuth[loop]);\n        if (flag) continue;\n        extAuthHandler=FALSE;\n        for (e = rfbClientExtensions; e; e = e->next) {\n            if (!e->handleAuthentication) continue;\n            uint32_t const* secType;\n            for (secType = e->securityTypes; secType && *secType; secType++) {\n                if (tAuth[loop]==*secType) {\n                    extAuthHandler=TRUE;\n                }\n            }\n        }\n        if (tAuth[loop]==rfbVncAuth || tAuth[loop]==rfbNoAuth ||\n\t\t\textAuthHandler ||\n#if defined(LIBVNCSERVER_HAVE_GNUTLS) || defined(LIBVNCSERVER_HAVE_LIBSSL)\n\t    (!subAuth && (tAuth[loop]==rfbTLS || tAuth[loop]==rfbVeNCrypt)) ||\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n            tAuth[loop]==rfbSASL ||\n#endif /* LIBVNCSERVER_HAVE_SASL */\n            (tAuth[loop]==rfbARD && client->GetCredential))\n        {\n            if (!subAuth && client->clientAuthSchemes)\n            {\n                int i;\n                for (i=0;client->clientAuthSchemes[i];i++)\n                {\n                    if (client->clientAuthSchemes[i]==(uint32_t)tAuth[loop])\n                    {\n                        flag++;\n                        authScheme=tAuth[loop];\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                flag++;\n                authScheme=tAuth[loop];\n            }\n            if (flag)\n            {\n                rfbClientLog(\"Selecting security type %d (%d/%d in the list)\\n\", authScheme, loop, count);\n                /* send back a single byte indicating which security type to use */\n                if (!WriteToRFBServer(client, (char *)&tAuth[loop], 1)) return FALSE;\n            }\n        }\n    }\n    if (authScheme==0)\n    {\n        memset(buf1, 0, sizeof(buf1));\n        for (loop=0;loop<count;loop++)\n        {\n            if (strlen(buf1)>=sizeof(buf1)-1) break;\n            snprintf(buf2, sizeof(buf2), (loop>0 ? \", %d\" : \"%d\"), (int)tAuth[loop]);\n            strncat(buf1, buf2, sizeof(buf1)-strlen(buf1)-1);\n        }\n        rfbClientLog(\"Unknown authentication scheme from VNC server: %s\\n\",\n               buf1);\n        return FALSE;\n    }\n    *result = authScheme;\n    return TRUE;\n}\n\nstatic rfbBool\nHandleVncAuth(rfbClient *client)\n{\n    uint8_t challenge[CHALLENGESIZE];\n    char *passwd=NULL;\n    int i;\n\n    if (!ReadFromRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;\n\n    if (client->serverPort!=-1) { /* if not playing a vncrec file */\n      if (client->GetPassword)\n        passwd = client->GetPassword(client);\n\n      if ((!passwd) || (strlen(passwd) == 0)) {\n        rfbClientLog(\"Reading password failed\\n\");\n        return FALSE;\n      }\n      if (strlen(passwd) > 8) {\n        passwd[8] = '\\0';\n      }\n\n      rfbClientEncryptBytes(challenge, passwd);\n\n      /* Lose the password from memory */\n      for (i = strlen(passwd); i >= 0; i--) {\n        passwd[i] = '\\0';\n      }\n      free(passwd);\n\n      if (!WriteToRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;\n    }\n\n    /* Handle the SecurityResult message */\n    if (!rfbHandleAuthResult(client)) return FALSE;\n\n    return TRUE;\n}\n\nstatic void\nFreeUserCredential(rfbCredential *cred)\n{\n  if (cred->userCredential.username) free(cred->userCredential.username);\n  if (cred->userCredential.password) free(cred->userCredential.password);\n  free(cred);\n}\n\nstatic rfbBool\nHandlePlainAuth(rfbClient *client)\n{\n  uint32_t ulen, ulensw;\n  uint32_t plen, plensw;\n  rfbCredential *cred;\n\n  if (!client->GetCredential)\n  {\n    rfbClientLog(\"GetCredential callback is not set.\\n\");\n    return FALSE;\n  }\n  cred = client->GetCredential(client, rfbCredentialTypeUser);\n  if (!cred)\n  {\n    rfbClientLog(\"Reading credential failed\\n\");\n    return FALSE;\n  }\n\n  ulen = (cred->userCredential.username ? strlen(cred->userCredential.username) : 0);\n  ulensw = rfbClientSwap32IfLE(ulen);\n  plen = (cred->userCredential.password ? strlen(cred->userCredential.password) : 0);\n  plensw = rfbClientSwap32IfLE(plen);\n  if (!WriteToRFBServer(client, (char *)&ulensw, 4) ||\n      !WriteToRFBServer(client, (char *)&plensw, 4))\n  {\n    FreeUserCredential(cred);\n    return FALSE;\n  }\n  if (ulen > 0)\n  {\n    if (!WriteToRFBServer(client, cred->userCredential.username, ulen))\n    {\n      FreeUserCredential(cred);\n      return FALSE;\n    }\n  }\n  if (plen > 0)\n  {\n    if (!WriteToRFBServer(client, cred->userCredential.password, plen))\n    {\n      FreeUserCredential(cred);\n      return FALSE;\n    }\n  }\n\n  FreeUserCredential(cred);\n\n  /* Handle the SecurityResult message */\n  if (!rfbHandleAuthResult(client)) return FALSE;\n\n  return TRUE;\n}\n\n/* Simple 64bit big integer arithmetic implementation */\n/* (x + y) % m, works even if (x + y) > 64bit */\n#define rfbAddM64(x,y,m) ((x+y)%m+(x+y<x?(((uint64_t)-1)%m+1)%m:0))\n/* (x * y) % m */\nstatic uint64_t\nrfbMulM64(uint64_t x, uint64_t y, uint64_t m)\n{\n  uint64_t r;\n  for(r=0;x>0;x>>=1)\n  {\n    if (x&1) r=rfbAddM64(r,y,m);\n    y=rfbAddM64(y,y,m);\n  }\n  return r;\n}\n/* (x ^ y) % m */\nstatic uint64_t\nrfbPowM64(uint64_t b, uint64_t e, uint64_t m)\n{\n  uint64_t r;\n  for(r=1;e>0;e>>=1)\n  {\n    if(e&1) r=rfbMulM64(r,b,m);\n    b=rfbMulM64(b,b,m);\n  }\n  return r;\n}\n\nstatic rfbBool\nHandleMSLogonAuth(rfbClient *client)\n{\n  uint64_t gen, mod, resp, priv, pub, key;\n  uint8_t username[256], password[64];\n  rfbCredential *cred;\n\n  if (!ReadFromRFBServer(client, (char *)&gen, 8)) return FALSE;\n  if (!ReadFromRFBServer(client, (char *)&mod, 8)) return FALSE;\n  if (!ReadFromRFBServer(client, (char *)&resp, 8)) return FALSE;\n  gen = rfbClientSwap64IfLE(gen);\n  mod = rfbClientSwap64IfLE(mod);\n  resp = rfbClientSwap64IfLE(resp);\n\n  if (!client->GetCredential)\n  {\n    rfbClientLog(\"GetCredential callback is not set.\\n\");\n    return FALSE;\n  }\n  rfbClientLog(\"WARNING! MSLogon security type has very low password encryption! \"\\\n    \"Use it only with SSH tunnel or trusted network.\\n\");\n  cred = client->GetCredential(client, rfbCredentialTypeUser);\n  if (!cred)\n  {\n    rfbClientLog(\"Reading credential failed\\n\");\n    return FALSE;\n  }\n\n  memset(username, 0, sizeof(username));\n  strncpy((char *)username, cred->userCredential.username, sizeof(username)-1);\n  memset(password, 0, sizeof(password));\n  strncpy((char *)password, cred->userCredential.password, sizeof(password)-1);\n  FreeUserCredential(cred);\n\n  srand(time(NULL));\n  priv = ((uint64_t)rand())<<32;\n  priv |= (uint64_t)rand();\n\n  pub = rfbPowM64(gen, priv, mod);\n  key = rfbPowM64(resp, priv, mod);\n  pub = rfbClientSwap64IfLE(pub);\n  key = rfbClientSwap64IfLE(key);\n\n  rfbClientEncryptBytes2(username, sizeof(username), (unsigned char *)&key);\n  rfbClientEncryptBytes2(password, sizeof(password), (unsigned char *)&key);\n\n  if (!WriteToRFBServer(client, (char *)&pub, 8)) return FALSE;\n  if (!WriteToRFBServer(client, (char *)username, sizeof(username))) return FALSE;\n  if (!WriteToRFBServer(client, (char *)password, sizeof(password))) return FALSE;\n\n  /* Handle the SecurityResult message */\n  if (!rfbHandleAuthResult(client)) return FALSE;\n\n  return TRUE;\n}\n\n\nstatic rfbBool\nHandleARDAuth(rfbClient *client)\n{\n  uint8_t gen[2], len[2];\n  size_t keylen;\n  uint8_t *mod = NULL, *resp = NULL, *priv = NULL, *pub = NULL, *key = NULL, *shared = NULL;\n  uint8_t userpass[128], ciphertext[128];\n  int ciphertext_len;\n  int passwordLen, usernameLen;\n  rfbCredential *cred = NULL;\n  rfbBool result = FALSE;\n\n  /* Step 1: Read the authentication material from the socket.\n     A two-byte generator value, a two-byte key length value. */\n  if (!ReadFromRFBServer(client, (char *)gen, 2)) {\n      rfbClientErr(\"HandleARDAuth: reading generator value failed\\n\");\n      goto out;\n  }\n  if (!ReadFromRFBServer(client, (char *)len, 2)) {\n      rfbClientErr(\"HandleARDAuth: reading key length failed\\n\");\n      goto out;\n  }\n  keylen = 256*len[0]+len[1]; /* convert from char[] to int */\n\n  mod = (uint8_t*)malloc(keylen*5); /* the block actually contains mod, resp, pub, priv and key */\n  if (!mod)\n      goto out;\n\n  resp = mod+keylen;\n  pub = resp+keylen;\n  priv = pub+keylen;\n  key = priv+keylen;\n\n  /* Step 1: Read the authentication material from the socket.\n     The prime modulus (keylen bytes) and the peer's generated public key (keylen bytes). */\n  if (!ReadFromRFBServer(client, (char *)mod, keylen)) {\n      rfbClientErr(\"HandleARDAuth: reading prime modulus failed\\n\");\n      goto out;\n  }\n  if (!ReadFromRFBServer(client, (char *)resp, keylen)) {\n      rfbClientErr(\"HandleARDAuth: reading peer's generated public key failed\\n\");\n      goto out;\n  }\n\n  /* Step 2: Generate own Diffie-Hellman public-private key pair. */\n  if(!dh_generate_keypair(priv, pub, gen, 2, mod, keylen)) {\n      rfbClientErr(\"HandleARDAuth: generating keypair failed\\n\");\n      goto out;\n  }\n\n  /* Step 3: Perform Diffie-Hellman key agreement, using the generator (gen),\n     prime (mod), and the peer's public key. The output will be a shared\n     secret known to both us and the peer. */\n  if(!dh_compute_shared_key(key, priv, resp, mod, keylen)) {\n      rfbClientErr(\"HandleARDAuth: creating shared key failed\\n\");\n      goto out;\n  }\n\n  /* Step 4: Perform an MD5 hash of the shared secret.\n     This 128-bit (16-byte) value will be used as the AES key. */\n  shared = malloc(MD5_HASH_SIZE);\n  if(!hash_md5(shared, key, keylen)) {\n      rfbClientErr(\"HandleARDAuth: hashing shared key failed\\n\");\n      goto out;\n  }\n\n  /* Step 5: Pack the username and password into a 128-byte\n     plaintext \"userpass\" structure: { username[64], password[64] }.\n     Null-terminate each. Fill the unused bytes with random characters\n     so that the encryption output is less predictable. */\n  if(!client->GetCredential) {\n      rfbClientErr(\"HandleARDAuth: GetCredential callback is not set\\n\");\n      goto out;\n  }\n  cred = client->GetCredential(client, rfbCredentialTypeUser);\n  if(!cred) {\n      rfbClientErr(\"HandleARDAuth: reading credential failed\\n\");\n      goto out;\n  }\n  passwordLen = strlen(cred->userCredential.password)+1;\n  usernameLen = strlen(cred->userCredential.username)+1;\n  if (passwordLen > sizeof(userpass)/2)\n      passwordLen = sizeof(userpass)/2;\n  if (usernameLen > sizeof(userpass)/2)\n      usernameLen = sizeof(userpass)/2;\n  random_bytes(userpass, sizeof(userpass));\n  memcpy(userpass, cred->userCredential.username, usernameLen);\n  memcpy(userpass+sizeof(userpass)/2, cred->userCredential.password, passwordLen);\n\n  /* Step 6: Encrypt the plaintext credentials with the 128-bit MD5 hash\n     from step 4, using the AES 128-bit symmetric cipher in electronic\n     codebook (ECB) mode. Use no further padding for this block cipher. */\n  if(!encrypt_aes128ecb(ciphertext, &ciphertext_len, shared, userpass, sizeof(userpass))) {\n      rfbClientErr(\"HandleARDAuth: encrypting credentials failed\\n\");\n      goto out;\n  }\n\n  /* Step 7: Write the ciphertext from step 6 to the stream.\n     Write the generated DH public key to the stream. */\n  if (!WriteToRFBServer(client, (char *)ciphertext, sizeof(ciphertext)))\n      goto out;\n  if (!WriteToRFBServer(client, (char *)pub, keylen))\n      goto out;\n\n  /* Handle the SecurityResult message */\n  if (!rfbHandleAuthResult(client))\n      goto out;\n\n  result = TRUE;\n\n out:\n  if (cred)\n    FreeUserCredential(cred);\n\n  free(mod);\n  free(shared);\n\n  return result;\n}\n\n\n\n/*\n * SetClientAuthSchemes.\n */\n\nvoid\nSetClientAuthSchemes(rfbClient* client,const uint32_t *authSchemes, int size)\n{\n  int i;\n\n  if (client->clientAuthSchemes)\n  {\n    free(client->clientAuthSchemes);\n    client->clientAuthSchemes = NULL;\n  }\n  if (authSchemes)\n  {\n    if (size<0)\n    {\n      /* If size<0 we assume the passed-in list is also 0-terminate, so we\n       * calculate the size here */\n      for (size=0;authSchemes[size];size++) ;\n    }\n    client->clientAuthSchemes = (uint32_t*)malloc(sizeof(uint32_t)*(size+1));\n    for (i=0;i<size;i++)\n      client->clientAuthSchemes[i] = authSchemes[i];\n    client->clientAuthSchemes[size] = 0;\n  }\n}\n\n/*\n * InitialiseRFBConnection.\n */\n\nrfbBool\nInitialiseRFBConnection(rfbClient* client)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  uint32_t authScheme;\n  uint32_t subAuthScheme;\n  rfbClientInitMsg ci;\n\n  /* if the connection is immediately closed, don't report anything, so\n       that pmw's monitor can make test connections */\n\n  if (client->listenSpecified)\n    errorMessageOnReadFailure = FALSE;\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n  pv[sz_rfbProtocolVersionMsg]=0;\n\n  errorMessageOnReadFailure = TRUE;\n\n  pv[sz_rfbProtocolVersionMsg] = 0;\n\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2) {\n    rfbClientLog(\"Not a valid VNC server (%s)\\n\",pv);\n    return FALSE;\n  }\n\n\n  DefaultSupportedMessages(client);\n  client->major = major;\n  client->minor = minor;\n\n  /* fall back to viewer supported version */\n  if ((major==rfbProtocolMajorVersion) && (minor>rfbProtocolMinorVersion))\n    client->minor = rfbProtocolMinorVersion;\n\n  /* UltraVNC uses minor codes 4 and 6 for the server */\n  if (major==3 && (minor==4 || minor==6)) {\n      rfbClientLog(\"UltraVNC server detected, enabling UltraVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  /* UltraVNC Single Click uses minor codes 14 and 16 for the server */\n  if (major==3 && (minor==14 || minor==16)) {\n     minor = minor - 10;\n     client->minor = minor;\n     rfbClientLog(\"UltraVNC Single Click server detected, enabling UltraVNC specific messages\\n\",pv);\n     DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  /* TightVNC uses minor codes 5 for the server */\n  if (major==3 && minor==5) {\n      rfbClientLog(\"TightVNC server detected, enabling TightVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesTightVNC(client);\n  }\n\n  /* we do not support > RFB3.8 */\n  if ((major==3 && minor>8) || major>3)\n  {\n    client->major=3;\n    client->minor=8;\n  }\n\n  rfbClientLog(\"VNC server supports protocol version %d.%d (viewer %d.%d)\\n\",\n\t  major, minor, rfbProtocolMajorVersion, rfbProtocolMinorVersion);\n\n  sprintf(pv,rfbProtocolVersionFormat,client->major,client->minor);\n\n  if (!WriteToRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n\n\n  /* 3.7 and onwards sends a # of security types first */\n  if (client->major==3 && client->minor > 6)\n  {\n    if (!ReadSupportedSecurityType(client, &authScheme, FALSE)) return FALSE;\n  }\n  else\n  {\n    if (!ReadFromRFBServer(client, (char *)&authScheme, 4)) return FALSE;\n    authScheme = rfbClientSwap32IfLE(authScheme);\n  }\n  \n  rfbClientLog(\"Selected Security Scheme %d\\n\", authScheme);\n  client->authScheme = authScheme;\n  \n  switch (authScheme) {\n\n  case rfbConnFailed:\n    ReadReason(client);\n    return FALSE;\n\n  case rfbNoAuth:\n    rfbClientLog(\"No authentication needed\\n\");\n\n    /* 3.8 and upwards sends a Security Result for rfbNoAuth */\n    if ((client->major==3 && client->minor > 7) || client->major>3)\n        if (!rfbHandleAuthResult(client)) return FALSE;        \n\n    break;\n\n  case rfbVncAuth:\n    if (!HandleVncAuth(client)) return FALSE;\n    break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  case rfbSASL:\n    if (!HandleSASLAuth(client)) return FALSE;\n    break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  case rfbMSLogon:\n    if (!HandleMSLogonAuth(client)) return FALSE;\n    break;\n\n  case rfbARD:\n    if (!HandleARDAuth(client)) return FALSE;\n    break;\n\n  case rfbTLS:\n    if (!HandleAnonTLSAuth(client)) return FALSE;\n    /* After the TLS session is established, sub auth types are expected.\n     * Note that all following reading/writing are through the TLS session from here.\n     */\n    if (!ReadSupportedSecurityType(client, &subAuthScheme, TRUE)) return FALSE;\n    client->subAuthScheme = subAuthScheme;\n\n    switch (subAuthScheme) {\n\n      case rfbConnFailed:\n        ReadReason(client);\n        return FALSE;\n\n      case rfbNoAuth:\n        rfbClientLog(\"No sub authentication needed\\n\");\n        /* 3.8 and upwards sends a Security Result for rfbNoAuth */\n        if ((client->major==3 && client->minor > 7) || client->major>3)\n            if (!rfbHandleAuthResult(client)) return FALSE;\n        break;\n\n      case rfbVncAuth:\n        if (!HandleVncAuth(client)) return FALSE;\n        break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n      case rfbSASL:\n        if (!HandleSASLAuth(client)) return FALSE;\n        break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n      default:\n        rfbClientLog(\"Unknown sub authentication scheme from VNC server: %d\\n\",\n            (int)subAuthScheme);\n        return FALSE;\n    }\n\n    break;\n\n  case rfbVeNCrypt:\n    if (!HandleVeNCryptAuth(client)) return FALSE;\n\n    switch (client->subAuthScheme) {\n\n      case rfbVeNCryptTLSNone:\n      case rfbVeNCryptX509None:\n        rfbClientLog(\"No sub authentication needed\\n\");\n        if (!rfbHandleAuthResult(client)) return FALSE;\n        break;\n\n      case rfbVeNCryptTLSVNC:\n      case rfbVeNCryptX509VNC:\n        if (!HandleVncAuth(client)) return FALSE;\n        break;\n\n      case rfbVeNCryptTLSPlain:\n      case rfbVeNCryptX509Plain:\n        if (!HandlePlainAuth(client)) return FALSE;\n        break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n      case rfbVeNCryptX509SASL:\n      case rfbVeNCryptTLSSASL:\n        if (!HandleSASLAuth(client)) return FALSE;\n        break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n      default:\n        rfbClientLog(\"Unknown sub authentication scheme from VNC server: %d\\n\",\n            client->subAuthScheme);\n        return FALSE;\n    }\n\n    break;\n\n  default:\n    {\n      rfbBool authHandled=FALSE;\n      rfbClientProtocolExtension* e;\n      for (e = rfbClientExtensions; e; e = e->next) {\n        uint32_t const* secType;\n        if (!e->handleAuthentication) continue;\n        for (secType = e->securityTypes; secType && *secType; secType++) {\n          if (authScheme==*secType) {\n            if (!e->handleAuthentication(client, authScheme)) return FALSE;\n            if (!rfbHandleAuthResult(client)) return FALSE;\n            authHandled=TRUE;\n          }\n        }\n      }\n      if (authHandled) break;\n    }\n    rfbClientLog(\"Unknown authentication scheme from VNC server: %d\\n\",\n\t    (int)authScheme);\n    return FALSE;\n  }\n\n  ci.shared = (client->appData.shareDesktop ? 1 : 0);\n\n  if (!WriteToRFBServer(client,  (char *)&ci, sz_rfbClientInitMsg)) return FALSE;\n\n  if (!ReadFromRFBServer(client, (char *)&client->si, sz_rfbServerInitMsg)) return FALSE;\n\n  client->si.framebufferWidth = rfbClientSwap16IfLE(client->si.framebufferWidth);\n  client->si.framebufferHeight = rfbClientSwap16IfLE(client->si.framebufferHeight);\n  client->si.format.redMax = rfbClientSwap16IfLE(client->si.format.redMax);\n  client->si.format.greenMax = rfbClientSwap16IfLE(client->si.format.greenMax);\n  client->si.format.blueMax = rfbClientSwap16IfLE(client->si.format.blueMax);\n  client->si.nameLength = rfbClientSwap32IfLE(client->si.nameLength);\n\n  if (client->si.nameLength > 1<<20) {\n      rfbClientErr(\"Too big desktop name length sent by server: %u B > 1 MB\\n\", (unsigned int)client->si.nameLength);\n      return FALSE;\n  }\n\n  client->desktopName = malloc(client->si.nameLength + 1);\n  if (!client->desktopName) {\n    rfbClientLog(\"Error allocating memory for desktop name, %lu bytes\\n\",\n            (unsigned long)client->si.nameLength);\n    return FALSE;\n  }\n\n  if (!ReadFromRFBServer(client, client->desktopName, client->si.nameLength)) return FALSE;\n\n  client->desktopName[client->si.nameLength] = 0;\n\n  rfbClientLog(\"Desktop name \\\"%s\\\"\\n\",client->desktopName);\n\n  rfbClientLog(\"Connected to VNC server, using protocol version %d.%d\\n\",\n\t  client->major, client->minor);\n\n  rfbClientLog(\"VNC server default format:\\n\");\n  PrintPixelFormat(&client->si.format);\n\n  return TRUE;\n}\n\n\n/*\n * SetFormatAndEncodings.\n */\n\nrfbBool\nSetFormatAndEncodings(rfbClient* client)\n{\n  rfbSetPixelFormatMsg spf;\n  char buf[sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4];\n\n  rfbSetEncodingsMsg *se = (rfbSetEncodingsMsg *)buf;\n  uint32_t *encs = (uint32_t *)(&buf[sz_rfbSetEncodingsMsg]);\n  int len = 0;\n  rfbBool requestCompressLevel = FALSE;\n  rfbBool requestQualityLevel = FALSE;\n  rfbBool requestLastRectEncoding = FALSE;\n  rfbClientProtocolExtension* e;\n\n  if (!SupportsClient2Server(client, rfbSetPixelFormat)) return TRUE;\n\n  spf.type = rfbSetPixelFormat;\n  spf.pad1 = 0;\n  spf.pad2 = 0;\n  spf.format = client->format;\n  spf.format.redMax = rfbClientSwap16IfLE(spf.format.redMax);\n  spf.format.greenMax = rfbClientSwap16IfLE(spf.format.greenMax);\n  spf.format.blueMax = rfbClientSwap16IfLE(spf.format.blueMax);\n\n  if (!WriteToRFBServer(client, (char *)&spf, sz_rfbSetPixelFormatMsg))\n    return FALSE;\n\n\n  if (!SupportsClient2Server(client, rfbSetEncodings)) return TRUE;\n\n  se->type = rfbSetEncodings;\n  se->pad = 0;\n  se->nEncodings = 0;\n\n  if (client->appData.encodingsString) {\n    const char *encStr = client->appData.encodingsString;\n    int encStrLen;\n    do {\n      const char *nextEncStr = strchr(encStr, ' ');\n      if (nextEncStr) {\n\tencStrLen = nextEncStr - encStr;\n\tnextEncStr++;\n      } else {\n\tencStrLen = strlen(encStr);\n      }\n\n      if (strncasecmp(encStr,\"raw\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);\n      } else if (strncasecmp(encStr,\"copyrect\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      } else if (strncasecmp(encStr,\"tight\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);\n\trequestLastRectEncoding = TRUE;\n\tif (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)\n\t  requestCompressLevel = TRUE;\n\tif (client->appData.enableJPEG)\n\t  requestQualityLevel = TRUE;\n#endif\n#endif\n      } else if (strncasecmp(encStr,\"hextile\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      } else if (strncasecmp(encStr,\"zlib\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);\n\tif (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)\n\t  requestCompressLevel = TRUE;\n      } else if (strncasecmp(encStr,\"zlibhex\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlibHex);\n\tif (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)\n\t  requestCompressLevel = TRUE;\n      } else if (strncasecmp(encStr,\"trle\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTRLE);\n      } else if (strncasecmp(encStr,\"zrle\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);\n      } else if (strncasecmp(encStr,\"zywrle\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);\n\trequestQualityLevel = TRUE;\n#endif\n      } else if ((strncasecmp(encStr,\"ultra\",encStrLen) == 0) || (strncasecmp(encStr,\"ultrazip\",encStrLen) == 0)) {\n        /* There are 2 encodings used in 'ultra' */\n        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);\n        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);\n      } else if (strncasecmp(encStr,\"corre\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);\n      } else if (strncasecmp(encStr,\"rre\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);\n      } else {\n\trfbClientLog(\"Unknown encoding '%.*s'\\n\",encStrLen,encStr);\n      }\n\n      encStr = nextEncStr;\n    } while (encStr && se->nEncodings < MAX_ENCODINGS);\n\n    if (se->nEncodings < MAX_ENCODINGS && requestCompressLevel) {\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +\n\t\t\t\t\t  rfbEncodingCompressLevel0);\n    }\n\n    if (se->nEncodings < MAX_ENCODINGS && requestQualityLevel) {\n      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)\n        client->appData.qualityLevel = 5;\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +\n\t\t\t\t\t  rfbEncodingQualityLevel0);\n    }\n  }\n  else {\n    if (SameMachine(client->sock)) {\n      /* TODO:\n      if (!tunnelSpecified) {\n      */\n      rfbClientLog(\"Same machine: preferring raw encoding\\n\");\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);\n      /*\n      } else {\n\trfbClientLog(\"Tunneling active: preferring tight encoding\\n\");\n      }\n      */\n    }\n\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);\n    requestLastRectEncoding = TRUE;\n#endif\n#endif\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);\n#endif\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);\n\n    if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9) {\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +\n\t\t\t\t\t  rfbEncodingCompressLevel0);\n    } else /* if (!tunnelSpecified) */ {\n      /* If -tunnel option was provided, we assume that server machine is\n\t not in the local network so we use default compression level for\n\t tight encoding instead of fast compression. Thus we are\n\t requesting level 1 compression only if tunneling is not used. */\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCompressLevel1);\n    }\n\n    if (client->appData.enableJPEG) {\n      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)\n\tclient->appData.qualityLevel = 5;\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +\n\t\t\t\t\t  rfbEncodingQualityLevel0);\n    }\n  }\n\n\n\n  /* Remote Cursor Support (local to viewer) */\n  if (client->appData.useRemoteCursor) {\n    if (se->nEncodings < MAX_ENCODINGS)\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXCursor);\n    if (se->nEncodings < MAX_ENCODINGS)\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRichCursor);\n    if (se->nEncodings < MAX_ENCODINGS)\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingPointerPos);\n  }\n\n  /* Keyboard State Encodings */\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingKeyboardLedState);\n\n  /* New Frame Buffer Size */\n  if (se->nEncodings < MAX_ENCODINGS && client->canHandleNewFBSize)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingNewFBSize);\n\n  /* Last Rect */\n  if (se->nEncodings < MAX_ENCODINGS && requestLastRectEncoding)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingLastRect);\n\n  /* Server Capabilities */\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedMessages);\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedEncodings);\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingServerIdentity);\n\n  /* xvp */\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXvp);\n\n  /* client extensions */\n  for(e = rfbClientExtensions; e; e = e->next)\n    if(e->encodings) {\n      int* enc;\n      for(enc = e->encodings; *enc; enc++)\n        if(se->nEncodings < MAX_ENCODINGS)\n          encs[se->nEncodings++] = rfbClientSwap32IfLE(*enc);\n    }\n\n  len = sz_rfbSetEncodingsMsg + se->nEncodings * 4;\n\n  se->nEncodings = rfbClientSwap16IfLE(se->nEncodings);\n\n  if (!WriteToRFBServer(client, buf, len)) return FALSE;\n\n  return TRUE;\n}\n\n\n/*\n * SendIncrementalFramebufferUpdateRequest.\n */\n\nrfbBool\nSendIncrementalFramebufferUpdateRequest(rfbClient* client)\n{\n\treturn SendFramebufferUpdateRequest(client,\n\t\t\tclient->updateRect.x, client->updateRect.y,\n\t\t\tclient->updateRect.w, client->updateRect.h, TRUE);\n}\n\n\n/*\n * SendFramebufferUpdateRequest.\n */\n\nrfbBool\nSendFramebufferUpdateRequest(rfbClient* client, int x, int y, int w, int h, rfbBool incremental)\n{\n  rfbFramebufferUpdateRequestMsg fur;\n\n  if (!SupportsClient2Server(client, rfbFramebufferUpdateRequest)) return TRUE;\n  \n  fur.type = rfbFramebufferUpdateRequest;\n  fur.incremental = incremental ? 1 : 0;\n  fur.x = rfbClientSwap16IfLE(x);\n  fur.y = rfbClientSwap16IfLE(y);\n  fur.w = rfbClientSwap16IfLE(w);\n  fur.h = rfbClientSwap16IfLE(h);\n\n  if (!WriteToRFBServer(client, (char *)&fur, sz_rfbFramebufferUpdateRequestMsg))\n    return FALSE;\n\n  return TRUE;\n}\n\n\n/*\n * SendScaleSetting.\n */\nrfbBool\nSendScaleSetting(rfbClient* client,int scaleSetting)\n{\n  rfbSetScaleMsg ssm;\n\n  ssm.scale = scaleSetting;\n  ssm.pad = 0;\n  \n  /* favor UltraVNC SetScale if both are supported */\n  if (SupportsClient2Server(client, rfbSetScale)) {\n      ssm.type = rfbSetScale;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  \n  if (SupportsClient2Server(client, rfbPalmVNCSetScaleFactor)) {\n      ssm.type = rfbPalmVNCSetScaleFactor;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n\n  return TRUE;\n}\n\n/*\n * TextChatFunctions (UltraVNC)\n * Extremely bandwidth friendly method of communicating with a user\n * (Think HelpDesk type applications)\n */\n\nrfbBool TextChatSend(rfbClient* client, char *text)\n{\n    rfbTextChatMsg chat;\n    int count = strlen(text);\n\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = (uint32_t)count;\n    chat.length = rfbClientSwap32IfLE(chat.length);\n\n    if (!WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg))\n        return FALSE;\n\n    if (count>0) {\n        if (!WriteToRFBServer(client, text, count))\n            return FALSE;\n    }\n    return TRUE;\n}\n\nrfbBool TextChatOpen(rfbClient* client)\n{\n    rfbTextChatMsg chat;\n\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = rfbClientSwap32IfLE(rfbTextChatOpen);\n    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);\n}\n\nrfbBool TextChatClose(rfbClient* client)\n{\n    rfbTextChatMsg chat;\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = rfbClientSwap32IfLE(rfbTextChatClose);\n    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);\n}\n\nrfbBool TextChatFinish(rfbClient* client)\n{\n    rfbTextChatMsg chat;\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = rfbClientSwap32IfLE(rfbTextChatFinished);\n    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);\n}\n\n/*\n * UltraVNC Server Input Disable\n * Apparently, the remote client can *prevent* the local user from interacting with the display\n * I would think this is extremely helpful when used in a HelpDesk situation\n */\nrfbBool PermitServerInput(rfbClient* client, int enabled)\n{\n    rfbSetServerInputMsg msg;\n\n    if (!SupportsClient2Server(client, rfbSetServerInput)) return TRUE;\n    /* enabled==1, then server input from local keyboard is disabled */\n    msg.type = rfbSetServerInput;\n    msg.status = (enabled ? 1 : 0);\n    msg.pad = 0;\n    return  (WriteToRFBServer(client, (char *)&msg, sz_rfbSetServerInputMsg) ? TRUE : FALSE);\n}\n\n\n/*\n * send xvp client message\n * A client supporting the xvp extension sends this to request that the server initiate\n * a clean shutdown, clean reboot or abrupt reset of the system whose framebuffer the\n * client is displaying.\n *\n * only version 1 is defined in the protocol specs\n *\n * possible values for code are:\n *   rfbXvp_Shutdown\n *   rfbXvp_Reboot\n *   rfbXvp_Reset\n */\n\nrfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code)\n{\n    rfbXvpMsg xvp;\n\n    if (!SupportsClient2Server(client, rfbXvp)) return TRUE;\n    xvp.type = rfbXvp;\n    xvp.pad = 0;\n    xvp.version = version;\n    xvp.code = code;\n\n    if (!WriteToRFBServer(client, (char *)&xvp, sz_rfbXvpMsg))\n        return FALSE;\n\n    return TRUE;\n}\n\n\n/*\n * SendPointerEvent.\n */\n\nrfbBool\nSendPointerEvent(rfbClient* client,int x, int y, int buttonMask)\n{\n  rfbPointerEventMsg pe;\n\n  if (!SupportsClient2Server(client, rfbPointerEvent)) return TRUE;\n\n  pe.type = rfbPointerEvent;\n  pe.buttonMask = buttonMask;\n  if (x < 0) x = 0;\n  if (y < 0) y = 0;\n\n  pe.x = rfbClientSwap16IfLE(x);\n  pe.y = rfbClientSwap16IfLE(y);\n  return WriteToRFBServer(client, (char *)&pe, sz_rfbPointerEventMsg);\n}\n\n\n/*\n * SendKeyEvent.\n */\n\nrfbBool\nSendKeyEvent(rfbClient* client, uint32_t key, rfbBool down)\n{\n  rfbKeyEventMsg ke;\n\n  if (!SupportsClient2Server(client, rfbKeyEvent)) return TRUE;\n\n  memset(&ke, 0, sizeof(ke));\n  ke.type = rfbKeyEvent;\n  ke.down = down ? 1 : 0;\n  ke.key = rfbClientSwap32IfLE(key);\n  return WriteToRFBServer(client, (char *)&ke, sz_rfbKeyEventMsg);\n}\n\n\n/*\n * SendClientCutText.\n */\n\nrfbBool\nSendClientCutText(rfbClient* client, char *str, int len)\n{\n  rfbClientCutTextMsg cct;\n\n  if (!SupportsClient2Server(client, rfbClientCutText)) return TRUE;\n\n  memset(&cct, 0, sizeof(cct));\n  cct.type = rfbClientCutText;\n  cct.length = rfbClientSwap32IfLE(len);\n  return  (WriteToRFBServer(client, (char *)&cct, sz_rfbClientCutTextMsg) &&\n\t   WriteToRFBServer(client, str, len));\n}\n\n\n\n/*\n * HandleRFBServerMessage.\n */\n\nrfbBool\nHandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n\t  if(msg.tc.length > MAX_TEXTCHAT_SIZE)\n\t      return FALSE;\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}\n\n\n#define GET_PIXEL8(pix, ptr) ((pix) = *(ptr)++)\n\n#define GET_PIXEL16(pix, ptr) (((uint8_t*)&(pix))[0] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[1] = *(ptr)++)\n\n#define GET_PIXEL32(pix, ptr) (((uint8_t*)&(pix))[0] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[1] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[2] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[3] = *(ptr)++)\n\n/* CONCAT2 concatenates its two arguments.  CONCAT2E does the same but also\n   expands its arguments if they are macros */\n\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#define CONCAT3(a,b,c) a##b##c\n#define CONCAT3E(a,b,c) CONCAT3(a,b,c)\n\n#define BPP 8\n#include \"rre.c\"\n#include \"corre.c\"\n#include \"hextile.c\"\n#include \"ultra.c\"\n#include \"zlib.c\"\n#include \"tight.c\"\n#include \"trle.c\"\n#include \"zrle.c\"\n#undef BPP\n#define BPP 16\n#include \"rre.c\"\n#include \"corre.c\"\n#include \"hextile.c\"\n#include \"ultra.c\"\n#include \"zlib.c\"\n#include \"tight.c\"\n#include \"trle.c\"\n#include \"zrle.c\"\n#define REALBPP 15\n#include \"trle.c\"\n#define REALBPP 15\n#include \"zrle.c\"\n#undef BPP\n#define BPP 32\n#include \"rre.c\"\n#include \"corre.c\"\n#include \"hextile.c\"\n#include \"ultra.c\"\n#include \"zlib.c\"\n#include \"tight.c\"\n#include \"trle.c\"\n#include \"zrle.c\"\n#define REALBPP 24\n#include \"trle.c\"\n#define REALBPP 24\n#include \"zrle.c\"\n#define REALBPP 24\n#define UNCOMP 8\n#include \"trle.c\"\n#define REALBPP 24\n#define UNCOMP 8\n#include \"zrle.c\"\n#define REALBPP 24\n#define UNCOMP -8\n#include \"trle.c\"\n#define REALBPP 24\n#define UNCOMP -8\n#include \"zrle.c\"\n#undef BPP\n\n\n/*\n * PrintPixelFormat.\n */\n\nvoid\nPrintPixelFormat(rfbPixelFormat *format)\n{\n  if (format->bitsPerPixel == 1) {\n    rfbClientLog(\"  Single bit per pixel.\\n\");\n    rfbClientLog(\n\t    \"  %s significant bit in each byte is leftmost on the screen.\\n\",\n\t    (format->bigEndian ? \"Most\" : \"Least\"));\n  } else {\n    rfbClientLog(\"  %d bits per pixel.\\n\",format->bitsPerPixel);\n    if (format->bitsPerPixel != 8) {\n      rfbClientLog(\"  %s significant byte first in each pixel.\\n\",\n\t      (format->bigEndian ? \"Most\" : \"Least\"));\n    }\n    if (format->trueColour) {\n      rfbClientLog(\"  TRUE colour: max red %d green %d blue %d\"\n\t\t   \", shift red %d green %d blue %d\\n\",\n\t\t   format->redMax, format->greenMax, format->blueMax,\n\t\t   format->redShift, format->greenShift, format->blueShift);\n    } else {\n      rfbClientLog(\"  Colour map (not true colour).\\n\");\n    }\n  }\n}\n\n/* avoid name clashes with LibVNCServer */\n\n#define rfbEncryptBytes rfbClientEncryptBytes\n#define rfbEncryptBytes2 rfbClientEncryptBytes2\n#define rfbDes rfbClientDes\n#define rfbDesKey rfbClientDesKey\n#define rfbUseKey rfbClientUseKey\n\n#include \"vncauth.c\"\n"], "fixing_code": ["/*\n *  Copyright (C) 2000-2002 Constantin Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * rfbproto.c - functions to deal with client side of RFB protocol.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#define _XOPEN_SOURCE 600\n#endif\n#ifndef WIN32\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#endif\n#include <errno.h>\n#include <rfb/rfbclient.h>\n#ifdef WIN32\n#undef socklen_t\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#include <zlib.h>\n#ifdef __CHECKER__\n#undef Z_NULL\n#define Z_NULL NULL\n#endif\n#endif\n\n#ifndef _MSC_VER\n/* Strings.h is not available in MSVC */\n#include <strings.h>\n#endif\n\n#include <stdarg.h>\n#include <time.h>\n\n#include \"crypto.h\"\n\n#include \"sasl.h\"\n#ifdef LIBVNCSERVER_HAVE_LZO\n#include <lzo/lzo1x.h>\n#else\n#include \"minilzo.h\"\n#endif\n#include \"tls.h\"\n\n#define MAX_TEXTCHAT_SIZE 10485760 /* 10MB */\n\n/*\n * rfbClientLog prints a time-stamped message to the log file (stderr).\n */\n\nrfbBool rfbEnableClientLogging=TRUE;\n\nstatic void\nrfbDefaultClientLog(const char *format, ...)\n{\n    va_list args;\n    char buf[256];\n    time_t log_clock;\n\n    if(!rfbEnableClientLogging)\n      return;\n\n    va_start(args, format);\n\n    time(&log_clock);\n    strftime(buf, 255, \"%d/%m/%Y %X \", localtime(&log_clock));\n    fprintf(stderr, \"%s\", buf);\n\n    vfprintf(stderr, format, args);\n    fflush(stderr);\n\n    va_end(args);\n}\n\nrfbClientLogProc rfbClientLog=rfbDefaultClientLog;\nrfbClientLogProc rfbClientErr=rfbDefaultClientLog;\n\n/* extensions */\n\nrfbClientProtocolExtension* rfbClientExtensions = NULL;\n\nvoid rfbClientRegisterExtension(rfbClientProtocolExtension* e)\n{\n\te->next = rfbClientExtensions;\n\trfbClientExtensions = e;\n}\n\n/* client data */\n\nvoid rfbClientSetClientData(rfbClient* client, void* tag, void* data)\n{\n\trfbClientData* clientData = client->clientData;\n\n\twhile(clientData && clientData->tag != tag)\n\t\tclientData = clientData->next;\n\tif(clientData == NULL) {\n\t\tclientData = calloc(sizeof(rfbClientData), 1);\n\t\tclientData->next = client->clientData;\n\t\tclient->clientData = clientData;\n\t\tclientData->tag = tag;\n\t}\n\n\tclientData->data = data;\n}\n\nvoid* rfbClientGetClientData(rfbClient* client, void* tag)\n{\n\trfbClientData* clientData = client->clientData;\n\n\twhile(clientData) {\n\t\tif(clientData->tag == tag)\n\t\t\treturn clientData->data;\n\t\tclientData = clientData->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic rfbBool HandleRRE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleRRE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleRRE32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleCoRRE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleCoRRE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleCoRRE32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleHextile8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleHextile16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleHextile32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltra8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltra16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltra32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltraZip8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltraZip16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleUltraZip32(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE15(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE24(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE24Up(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE24Down(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTRLE32(rfbClient* client, int rx, int ry, int rw, int rh);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\nstatic rfbBool HandleZlib8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZlib16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZlib32(rfbClient* client, int rx, int ry, int rw, int rh);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\nstatic rfbBool HandleTight8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTight16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleTight32(rfbClient* client, int rx, int ry, int rw, int rh);\n\nstatic long ReadCompactLen (rfbClient* client);\n#endif\nstatic rfbBool HandleZRLE8(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE15(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE16(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE24(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE24Up(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE24Down(rfbClient* client, int rx, int ry, int rw, int rh);\nstatic rfbBool HandleZRLE32(rfbClient* client, int rx, int ry, int rw, int rh);\n#endif\n\n/*\n * Server Capability Functions\n */\nrfbBool\nSupportsClient2Server(rfbClient* client, int messageType)\n{\n    return (client->supportedMessages.client2server[((messageType & 0xFF)/8)] & (1<<(messageType % 8)) ? TRUE : FALSE);\n}\n\nrfbBool\nSupportsServer2Client(rfbClient* client, int messageType)\n{\n    return (client->supportedMessages.server2client[((messageType & 0xFF)/8)] & (1<<(messageType % 8)) ? TRUE : FALSE);\n}\n\nvoid\nSetClient2Server(rfbClient* client, int messageType)\n{\n  client->supportedMessages.client2server[((messageType & 0xFF)/8)] |= (1<<(messageType % 8));\n}\n\nvoid\nSetServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] |= (1<<(messageType % 8));\n}\n\nvoid\nClearClient2Server(rfbClient* client, int messageType)\n{\n  client->supportedMessages.client2server[((messageType & 0xFF)/8)] &= ~(1<<(messageType % 8));\n}\n\nvoid\nClearServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= ~(1<<(messageType % 8));\n}\n\n\nvoid\nDefaultSupportedMessages(rfbClient* client)\n{\n    memset((char *)&client->supportedMessages,0,sizeof(client->supportedMessages));\n\n    /* Default client supported messages (universal RFB 3.3 protocol) */\n    SetClient2Server(client, rfbSetPixelFormat);\n    /* SetClient2Server(client, rfbFixColourMapEntries); Not currently supported */\n    SetClient2Server(client, rfbSetEncodings);\n    SetClient2Server(client, rfbFramebufferUpdateRequest);\n    SetClient2Server(client, rfbKeyEvent);\n    SetClient2Server(client, rfbPointerEvent);\n    SetClient2Server(client, rfbClientCutText);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbFramebufferUpdate);\n    SetServer2Client(client, rfbSetColourMapEntries);\n    SetServer2Client(client, rfbBell);\n    SetServer2Client(client, rfbServerCutText);\n}\n\nvoid\nDefaultSupportedMessagesUltraVNC(rfbClient* client)\n{\n    DefaultSupportedMessages(client);\n    SetClient2Server(client, rfbFileTransfer);\n    SetClient2Server(client, rfbSetScale);\n    SetClient2Server(client, rfbSetServerInput);\n    SetClient2Server(client, rfbSetSW);\n    SetClient2Server(client, rfbTextChat);\n    SetClient2Server(client, rfbPalmVNCSetScaleFactor);\n    /* technically, we only care what we can *send* to the server */\n    SetServer2Client(client, rfbResizeFrameBuffer);\n    SetServer2Client(client, rfbPalmVNCReSizeFrameBuffer);\n    SetServer2Client(client, rfbFileTransfer);\n    SetServer2Client(client, rfbTextChat);\n}\n\n\nvoid\nDefaultSupportedMessagesTightVNC(rfbClient* client)\n{\n    DefaultSupportedMessages(client);\n    SetClient2Server(client, rfbFileTransfer);\n    SetClient2Server(client, rfbSetServerInput);\n    SetClient2Server(client, rfbSetSW);\n    /* SetClient2Server(client, rfbTextChat); */\n    /* technically, we only care what we can *send* to the server */\n    SetServer2Client(client, rfbFileTransfer);\n    SetServer2Client(client, rfbTextChat);\n}\n\n#ifndef WIN32\nstatic rfbBool\nIsUnixSocket(const char *name)\n{\n  struct stat sb;\n  if(stat(name, &sb) == 0 && (sb.st_mode & S_IFMT) == S_IFSOCK)\n    return TRUE;\n  return FALSE;\n}\n#endif\n\n/*\n * ConnectToRFBServer.\n */\n\nrfbBool\nConnectToRFBServer(rfbClient* client,const char *hostname, int port)\n{\n  if (client->serverPort==-1) {\n    /* serverHost is a file recorded by vncrec. */\n    const char* magic=\"vncLog0.0\";\n    char buffer[10];\n    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));\n    client->vncRec = rec;\n\n    rec->file = fopen(client->serverHost,\"rb\");\n    rec->tv.tv_sec = 0;\n    rec->readTimestamp = FALSE;\n    rec->doNotSleep = FALSE;\n    \n    if (!rec->file) {\n      rfbClientLog(\"Could not open %s.\\n\",client->serverHost);\n      return FALSE;\n    }\n    setbuf(rec->file,NULL);\n\n    if (fread(buffer,1,strlen(magic),rec->file) != strlen(magic) || strncmp(buffer,magic,strlen(magic))) {\n      rfbClientLog(\"File %s was not recorded by vncrec.\\n\",client->serverHost);\n      fclose(rec->file);\n      return FALSE;\n    }\n    client->sock = RFB_INVALID_SOCKET;\n    return TRUE;\n  }\n\n#ifndef WIN32\n  if(IsUnixSocket(hostname))\n    /* serverHost is a UNIX socket. */\n    client->sock = ConnectClientToUnixSockWithTimeout(hostname, client->connectTimeout);\n  else\n#endif\n  {\n#ifdef LIBVNCSERVER_IPv6\n    client->sock = ConnectClientToTcpAddr6WithTimeout(hostname, port, client->connectTimeout);\n#else\n    unsigned int host;\n\n    /* serverHost is a hostname */\n    if (!StringToIPAddr(hostname, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", hostname);\n      return FALSE;\n    }\n    client->sock = ConnectClientToTcpAddrWithTimeout(host, port, client->connectTimeout);\n#endif\n  }\n\n  if (client->sock == RFB_INVALID_SOCKET) {\n    rfbClientLog(\"Unable to connect to VNC server\\n\");\n    return FALSE;\n  }\n\n  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))\n     return FALSE;\n\n  return TRUE;\n}\n\n/*\n * ConnectToRFBRepeater.\n */\n\nrfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6WithTimeout(repeaterHost, repeaterPort, client->connectTimeout);\n#else\n  unsigned int host;\n  if (!StringToIPAddr(repeaterHost, &host)) {\n    rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n    return FALSE;\n  }\n\n  client->sock = ConnectClientToTcpAddrWithTimeout(host, repeaterPort, client->connectTimeout);\n#endif\n\n  if (client->sock == RFB_INVALID_SOCKET) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n\n  /* UltraVNC repeater always report version 000.000 to identify itself */\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n\n  memset(tmphost, 0, sizeof(tmphost));\n  if(snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort) >= (int)sizeof(tmphost))\n    return FALSE; /* output truncated */\n  if (!WriteToRFBServer(client, tmphost, sizeof(tmphost)))\n    return FALSE;\n\n  return TRUE;\n}\n\nextern void rfbClientEncryptBytes(unsigned char* bytes, char* passwd);\nextern void rfbClientEncryptBytes2(unsigned char *where, const int length, unsigned char *key);\n\nstatic void\nReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    if(reasonLen > 1<<20) {\n      rfbClientLog(\"VNC connection failed, but sent reason length of %u exceeds limit of 1MB\",(unsigned int)reasonLen);\n      return;\n    }\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}\n\nrfbBool\nrfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}\n\n\nstatic rfbBool\nReadSupportedSecurityType(rfbClient* client, uint32_t *result, rfbBool subAuth)\n{\n    uint8_t count=0;\n    uint8_t loop=0;\n    uint8_t flag=0;\n    rfbBool extAuthHandler;\n    uint8_t tAuth[256];\n    char buf1[500],buf2[10];\n    uint32_t authScheme;\n    rfbClientProtocolExtension* e;\n\n    if (!ReadFromRFBServer(client, (char *)&count, 1)) return FALSE;\n\n    if (count==0)\n    {\n        rfbClientLog(\"List of security types is ZERO, expecting an error to follow\\n\");\n        ReadReason(client);\n        return FALSE;\n    }\n\n    rfbClientLog(\"We have %d security types to read\\n\", count);\n    authScheme=0;\n    /* now, we have a list of available security types to read ( uint8_t[] ) */\n    for (loop=0;loop<count;loop++)\n    {\n        if (!ReadFromRFBServer(client, (char *)&tAuth[loop], 1)) return FALSE;\n        rfbClientLog(\"%d) Received security type %d\\n\", loop, tAuth[loop]);\n        if (flag) continue;\n        extAuthHandler=FALSE;\n        for (e = rfbClientExtensions; e; e = e->next) {\n            if (!e->handleAuthentication) continue;\n            uint32_t const* secType;\n            for (secType = e->securityTypes; secType && *secType; secType++) {\n                if (tAuth[loop]==*secType) {\n                    extAuthHandler=TRUE;\n                }\n            }\n        }\n        if (tAuth[loop]==rfbVncAuth || tAuth[loop]==rfbNoAuth ||\n\t\t\textAuthHandler ||\n#if defined(LIBVNCSERVER_HAVE_GNUTLS) || defined(LIBVNCSERVER_HAVE_LIBSSL)\n\t    (!subAuth && (tAuth[loop]==rfbTLS || tAuth[loop]==rfbVeNCrypt)) ||\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n            tAuth[loop]==rfbSASL ||\n#endif /* LIBVNCSERVER_HAVE_SASL */\n            (tAuth[loop]==rfbARD && client->GetCredential))\n        {\n            if (!subAuth && client->clientAuthSchemes)\n            {\n                int i;\n                for (i=0;client->clientAuthSchemes[i];i++)\n                {\n                    if (client->clientAuthSchemes[i]==(uint32_t)tAuth[loop])\n                    {\n                        flag++;\n                        authScheme=tAuth[loop];\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                flag++;\n                authScheme=tAuth[loop];\n            }\n            if (flag)\n            {\n                rfbClientLog(\"Selecting security type %d (%d/%d in the list)\\n\", authScheme, loop, count);\n                /* send back a single byte indicating which security type to use */\n                if (!WriteToRFBServer(client, (char *)&tAuth[loop], 1)) return FALSE;\n            }\n        }\n    }\n    if (authScheme==0)\n    {\n        memset(buf1, 0, sizeof(buf1));\n        for (loop=0;loop<count;loop++)\n        {\n            if (strlen(buf1)>=sizeof(buf1)-1) break;\n            snprintf(buf2, sizeof(buf2), (loop>0 ? \", %d\" : \"%d\"), (int)tAuth[loop]);\n            strncat(buf1, buf2, sizeof(buf1)-strlen(buf1)-1);\n        }\n        rfbClientLog(\"Unknown authentication scheme from VNC server: %s\\n\",\n               buf1);\n        return FALSE;\n    }\n    *result = authScheme;\n    return TRUE;\n}\n\nstatic rfbBool\nHandleVncAuth(rfbClient *client)\n{\n    uint8_t challenge[CHALLENGESIZE];\n    char *passwd=NULL;\n    int i;\n\n    if (!ReadFromRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;\n\n    if (client->serverPort!=-1) { /* if not playing a vncrec file */\n      if (client->GetPassword)\n        passwd = client->GetPassword(client);\n\n      if ((!passwd) || (strlen(passwd) == 0)) {\n        rfbClientLog(\"Reading password failed\\n\");\n        return FALSE;\n      }\n      if (strlen(passwd) > 8) {\n        passwd[8] = '\\0';\n      }\n\n      rfbClientEncryptBytes(challenge, passwd);\n\n      /* Lose the password from memory */\n      for (i = strlen(passwd); i >= 0; i--) {\n        passwd[i] = '\\0';\n      }\n      free(passwd);\n\n      if (!WriteToRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;\n    }\n\n    /* Handle the SecurityResult message */\n    if (!rfbHandleAuthResult(client)) return FALSE;\n\n    return TRUE;\n}\n\nstatic void\nFreeUserCredential(rfbCredential *cred)\n{\n  if (cred->userCredential.username) free(cred->userCredential.username);\n  if (cred->userCredential.password) free(cred->userCredential.password);\n  free(cred);\n}\n\nstatic rfbBool\nHandlePlainAuth(rfbClient *client)\n{\n  uint32_t ulen, ulensw;\n  uint32_t plen, plensw;\n  rfbCredential *cred;\n\n  if (!client->GetCredential)\n  {\n    rfbClientLog(\"GetCredential callback is not set.\\n\");\n    return FALSE;\n  }\n  cred = client->GetCredential(client, rfbCredentialTypeUser);\n  if (!cred)\n  {\n    rfbClientLog(\"Reading credential failed\\n\");\n    return FALSE;\n  }\n\n  ulen = (cred->userCredential.username ? strlen(cred->userCredential.username) : 0);\n  ulensw = rfbClientSwap32IfLE(ulen);\n  plen = (cred->userCredential.password ? strlen(cred->userCredential.password) : 0);\n  plensw = rfbClientSwap32IfLE(plen);\n  if (!WriteToRFBServer(client, (char *)&ulensw, 4) ||\n      !WriteToRFBServer(client, (char *)&plensw, 4))\n  {\n    FreeUserCredential(cred);\n    return FALSE;\n  }\n  if (ulen > 0)\n  {\n    if (!WriteToRFBServer(client, cred->userCredential.username, ulen))\n    {\n      FreeUserCredential(cred);\n      return FALSE;\n    }\n  }\n  if (plen > 0)\n  {\n    if (!WriteToRFBServer(client, cred->userCredential.password, plen))\n    {\n      FreeUserCredential(cred);\n      return FALSE;\n    }\n  }\n\n  FreeUserCredential(cred);\n\n  /* Handle the SecurityResult message */\n  if (!rfbHandleAuthResult(client)) return FALSE;\n\n  return TRUE;\n}\n\n/* Simple 64bit big integer arithmetic implementation */\n/* (x + y) % m, works even if (x + y) > 64bit */\n#define rfbAddM64(x,y,m) ((x+y)%m+(x+y<x?(((uint64_t)-1)%m+1)%m:0))\n/* (x * y) % m */\nstatic uint64_t\nrfbMulM64(uint64_t x, uint64_t y, uint64_t m)\n{\n  uint64_t r;\n  for(r=0;x>0;x>>=1)\n  {\n    if (x&1) r=rfbAddM64(r,y,m);\n    y=rfbAddM64(y,y,m);\n  }\n  return r;\n}\n/* (x ^ y) % m */\nstatic uint64_t\nrfbPowM64(uint64_t b, uint64_t e, uint64_t m)\n{\n  uint64_t r;\n  for(r=1;e>0;e>>=1)\n  {\n    if(e&1) r=rfbMulM64(r,b,m);\n    b=rfbMulM64(b,b,m);\n  }\n  return r;\n}\n\nstatic rfbBool\nHandleMSLogonAuth(rfbClient *client)\n{\n  uint64_t gen, mod, resp, priv, pub, key;\n  uint8_t username[256], password[64];\n  rfbCredential *cred;\n\n  if (!ReadFromRFBServer(client, (char *)&gen, 8)) return FALSE;\n  if (!ReadFromRFBServer(client, (char *)&mod, 8)) return FALSE;\n  if (!ReadFromRFBServer(client, (char *)&resp, 8)) return FALSE;\n  gen = rfbClientSwap64IfLE(gen);\n  mod = rfbClientSwap64IfLE(mod);\n  resp = rfbClientSwap64IfLE(resp);\n\n  if (!client->GetCredential)\n  {\n    rfbClientLog(\"GetCredential callback is not set.\\n\");\n    return FALSE;\n  }\n  rfbClientLog(\"WARNING! MSLogon security type has very low password encryption! \"\\\n    \"Use it only with SSH tunnel or trusted network.\\n\");\n  cred = client->GetCredential(client, rfbCredentialTypeUser);\n  if (!cred)\n  {\n    rfbClientLog(\"Reading credential failed\\n\");\n    return FALSE;\n  }\n\n  memset(username, 0, sizeof(username));\n  strncpy((char *)username, cred->userCredential.username, sizeof(username)-1);\n  memset(password, 0, sizeof(password));\n  strncpy((char *)password, cred->userCredential.password, sizeof(password)-1);\n  FreeUserCredential(cred);\n\n  srand(time(NULL));\n  priv = ((uint64_t)rand())<<32;\n  priv |= (uint64_t)rand();\n\n  pub = rfbPowM64(gen, priv, mod);\n  key = rfbPowM64(resp, priv, mod);\n  pub = rfbClientSwap64IfLE(pub);\n  key = rfbClientSwap64IfLE(key);\n\n  rfbClientEncryptBytes2(username, sizeof(username), (unsigned char *)&key);\n  rfbClientEncryptBytes2(password, sizeof(password), (unsigned char *)&key);\n\n  if (!WriteToRFBServer(client, (char *)&pub, 8)) return FALSE;\n  if (!WriteToRFBServer(client, (char *)username, sizeof(username))) return FALSE;\n  if (!WriteToRFBServer(client, (char *)password, sizeof(password))) return FALSE;\n\n  /* Handle the SecurityResult message */\n  if (!rfbHandleAuthResult(client)) return FALSE;\n\n  return TRUE;\n}\n\n\nstatic rfbBool\nHandleARDAuth(rfbClient *client)\n{\n  uint8_t gen[2], len[2];\n  size_t keylen;\n  uint8_t *mod = NULL, *resp = NULL, *priv = NULL, *pub = NULL, *key = NULL, *shared = NULL;\n  uint8_t userpass[128], ciphertext[128];\n  int ciphertext_len;\n  int passwordLen, usernameLen;\n  rfbCredential *cred = NULL;\n  rfbBool result = FALSE;\n\n  /* Step 1: Read the authentication material from the socket.\n     A two-byte generator value, a two-byte key length value. */\n  if (!ReadFromRFBServer(client, (char *)gen, 2)) {\n      rfbClientErr(\"HandleARDAuth: reading generator value failed\\n\");\n      goto out;\n  }\n  if (!ReadFromRFBServer(client, (char *)len, 2)) {\n      rfbClientErr(\"HandleARDAuth: reading key length failed\\n\");\n      goto out;\n  }\n  keylen = 256*len[0]+len[1]; /* convert from char[] to int */\n\n  mod = (uint8_t*)malloc(keylen*5); /* the block actually contains mod, resp, pub, priv and key */\n  if (!mod)\n      goto out;\n\n  resp = mod+keylen;\n  pub = resp+keylen;\n  priv = pub+keylen;\n  key = priv+keylen;\n\n  /* Step 1: Read the authentication material from the socket.\n     The prime modulus (keylen bytes) and the peer's generated public key (keylen bytes). */\n  if (!ReadFromRFBServer(client, (char *)mod, keylen)) {\n      rfbClientErr(\"HandleARDAuth: reading prime modulus failed\\n\");\n      goto out;\n  }\n  if (!ReadFromRFBServer(client, (char *)resp, keylen)) {\n      rfbClientErr(\"HandleARDAuth: reading peer's generated public key failed\\n\");\n      goto out;\n  }\n\n  /* Step 2: Generate own Diffie-Hellman public-private key pair. */\n  if(!dh_generate_keypair(priv, pub, gen, 2, mod, keylen)) {\n      rfbClientErr(\"HandleARDAuth: generating keypair failed\\n\");\n      goto out;\n  }\n\n  /* Step 3: Perform Diffie-Hellman key agreement, using the generator (gen),\n     prime (mod), and the peer's public key. The output will be a shared\n     secret known to both us and the peer. */\n  if(!dh_compute_shared_key(key, priv, resp, mod, keylen)) {\n      rfbClientErr(\"HandleARDAuth: creating shared key failed\\n\");\n      goto out;\n  }\n\n  /* Step 4: Perform an MD5 hash of the shared secret.\n     This 128-bit (16-byte) value will be used as the AES key. */\n  shared = malloc(MD5_HASH_SIZE);\n  if(!hash_md5(shared, key, keylen)) {\n      rfbClientErr(\"HandleARDAuth: hashing shared key failed\\n\");\n      goto out;\n  }\n\n  /* Step 5: Pack the username and password into a 128-byte\n     plaintext \"userpass\" structure: { username[64], password[64] }.\n     Null-terminate each. Fill the unused bytes with random characters\n     so that the encryption output is less predictable. */\n  if(!client->GetCredential) {\n      rfbClientErr(\"HandleARDAuth: GetCredential callback is not set\\n\");\n      goto out;\n  }\n  cred = client->GetCredential(client, rfbCredentialTypeUser);\n  if(!cred) {\n      rfbClientErr(\"HandleARDAuth: reading credential failed\\n\");\n      goto out;\n  }\n  passwordLen = strlen(cred->userCredential.password)+1;\n  usernameLen = strlen(cred->userCredential.username)+1;\n  if (passwordLen > sizeof(userpass)/2)\n      passwordLen = sizeof(userpass)/2;\n  if (usernameLen > sizeof(userpass)/2)\n      usernameLen = sizeof(userpass)/2;\n  random_bytes(userpass, sizeof(userpass));\n  memcpy(userpass, cred->userCredential.username, usernameLen);\n  memcpy(userpass+sizeof(userpass)/2, cred->userCredential.password, passwordLen);\n\n  /* Step 6: Encrypt the plaintext credentials with the 128-bit MD5 hash\n     from step 4, using the AES 128-bit symmetric cipher in electronic\n     codebook (ECB) mode. Use no further padding for this block cipher. */\n  if(!encrypt_aes128ecb(ciphertext, &ciphertext_len, shared, userpass, sizeof(userpass))) {\n      rfbClientErr(\"HandleARDAuth: encrypting credentials failed\\n\");\n      goto out;\n  }\n\n  /* Step 7: Write the ciphertext from step 6 to the stream.\n     Write the generated DH public key to the stream. */\n  if (!WriteToRFBServer(client, (char *)ciphertext, sizeof(ciphertext)))\n      goto out;\n  if (!WriteToRFBServer(client, (char *)pub, keylen))\n      goto out;\n\n  /* Handle the SecurityResult message */\n  if (!rfbHandleAuthResult(client))\n      goto out;\n\n  result = TRUE;\n\n out:\n  if (cred)\n    FreeUserCredential(cred);\n\n  free(mod);\n  free(shared);\n\n  return result;\n}\n\n\n\n/*\n * SetClientAuthSchemes.\n */\n\nvoid\nSetClientAuthSchemes(rfbClient* client,const uint32_t *authSchemes, int size)\n{\n  int i;\n\n  if (client->clientAuthSchemes)\n  {\n    free(client->clientAuthSchemes);\n    client->clientAuthSchemes = NULL;\n  }\n  if (authSchemes)\n  {\n    if (size<0)\n    {\n      /* If size<0 we assume the passed-in list is also 0-terminate, so we\n       * calculate the size here */\n      for (size=0;authSchemes[size];size++) ;\n    }\n    client->clientAuthSchemes = (uint32_t*)malloc(sizeof(uint32_t)*(size+1));\n    for (i=0;i<size;i++)\n      client->clientAuthSchemes[i] = authSchemes[i];\n    client->clientAuthSchemes[size] = 0;\n  }\n}\n\n/*\n * InitialiseRFBConnection.\n */\n\nrfbBool\nInitialiseRFBConnection(rfbClient* client)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  uint32_t authScheme;\n  uint32_t subAuthScheme;\n  rfbClientInitMsg ci;\n\n  /* if the connection is immediately closed, don't report anything, so\n       that pmw's monitor can make test connections */\n\n  if (client->listenSpecified)\n    errorMessageOnReadFailure = FALSE;\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n  pv[sz_rfbProtocolVersionMsg]=0;\n\n  errorMessageOnReadFailure = TRUE;\n\n  pv[sz_rfbProtocolVersionMsg] = 0;\n\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2) {\n    rfbClientLog(\"Not a valid VNC server (%s)\\n\",pv);\n    return FALSE;\n  }\n\n\n  DefaultSupportedMessages(client);\n  client->major = major;\n  client->minor = minor;\n\n  /* fall back to viewer supported version */\n  if ((major==rfbProtocolMajorVersion) && (minor>rfbProtocolMinorVersion))\n    client->minor = rfbProtocolMinorVersion;\n\n  /* UltraVNC uses minor codes 4 and 6 for the server */\n  if (major==3 && (minor==4 || minor==6)) {\n      rfbClientLog(\"UltraVNC server detected, enabling UltraVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  /* UltraVNC Single Click uses minor codes 14 and 16 for the server */\n  if (major==3 && (minor==14 || minor==16)) {\n     minor = minor - 10;\n     client->minor = minor;\n     rfbClientLog(\"UltraVNC Single Click server detected, enabling UltraVNC specific messages\\n\",pv);\n     DefaultSupportedMessagesUltraVNC(client);\n  }\n\n  /* TightVNC uses minor codes 5 for the server */\n  if (major==3 && minor==5) {\n      rfbClientLog(\"TightVNC server detected, enabling TightVNC specific messages\\n\",pv);\n      DefaultSupportedMessagesTightVNC(client);\n  }\n\n  /* we do not support > RFB3.8 */\n  if ((major==3 && minor>8) || major>3)\n  {\n    client->major=3;\n    client->minor=8;\n  }\n\n  rfbClientLog(\"VNC server supports protocol version %d.%d (viewer %d.%d)\\n\",\n\t  major, minor, rfbProtocolMajorVersion, rfbProtocolMinorVersion);\n\n  sprintf(pv,rfbProtocolVersionFormat,client->major,client->minor);\n\n  if (!WriteToRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;\n\n\n  /* 3.7 and onwards sends a # of security types first */\n  if (client->major==3 && client->minor > 6)\n  {\n    if (!ReadSupportedSecurityType(client, &authScheme, FALSE)) return FALSE;\n  }\n  else\n  {\n    if (!ReadFromRFBServer(client, (char *)&authScheme, 4)) return FALSE;\n    authScheme = rfbClientSwap32IfLE(authScheme);\n  }\n  \n  rfbClientLog(\"Selected Security Scheme %d\\n\", authScheme);\n  client->authScheme = authScheme;\n  \n  switch (authScheme) {\n\n  case rfbConnFailed:\n    ReadReason(client);\n    return FALSE;\n\n  case rfbNoAuth:\n    rfbClientLog(\"No authentication needed\\n\");\n\n    /* 3.8 and upwards sends a Security Result for rfbNoAuth */\n    if ((client->major==3 && client->minor > 7) || client->major>3)\n        if (!rfbHandleAuthResult(client)) return FALSE;        \n\n    break;\n\n  case rfbVncAuth:\n    if (!HandleVncAuth(client)) return FALSE;\n    break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  case rfbSASL:\n    if (!HandleSASLAuth(client)) return FALSE;\n    break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  case rfbMSLogon:\n    if (!HandleMSLogonAuth(client)) return FALSE;\n    break;\n\n  case rfbARD:\n    if (!HandleARDAuth(client)) return FALSE;\n    break;\n\n  case rfbTLS:\n    if (!HandleAnonTLSAuth(client)) return FALSE;\n    /* After the TLS session is established, sub auth types are expected.\n     * Note that all following reading/writing are through the TLS session from here.\n     */\n    if (!ReadSupportedSecurityType(client, &subAuthScheme, TRUE)) return FALSE;\n    client->subAuthScheme = subAuthScheme;\n\n    switch (subAuthScheme) {\n\n      case rfbConnFailed:\n        ReadReason(client);\n        return FALSE;\n\n      case rfbNoAuth:\n        rfbClientLog(\"No sub authentication needed\\n\");\n        /* 3.8 and upwards sends a Security Result for rfbNoAuth */\n        if ((client->major==3 && client->minor > 7) || client->major>3)\n            if (!rfbHandleAuthResult(client)) return FALSE;\n        break;\n\n      case rfbVncAuth:\n        if (!HandleVncAuth(client)) return FALSE;\n        break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n      case rfbSASL:\n        if (!HandleSASLAuth(client)) return FALSE;\n        break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n      default:\n        rfbClientLog(\"Unknown sub authentication scheme from VNC server: %d\\n\",\n            (int)subAuthScheme);\n        return FALSE;\n    }\n\n    break;\n\n  case rfbVeNCrypt:\n    if (!HandleVeNCryptAuth(client)) return FALSE;\n\n    switch (client->subAuthScheme) {\n\n      case rfbVeNCryptTLSNone:\n      case rfbVeNCryptX509None:\n        rfbClientLog(\"No sub authentication needed\\n\");\n        if (!rfbHandleAuthResult(client)) return FALSE;\n        break;\n\n      case rfbVeNCryptTLSVNC:\n      case rfbVeNCryptX509VNC:\n        if (!HandleVncAuth(client)) return FALSE;\n        break;\n\n      case rfbVeNCryptTLSPlain:\n      case rfbVeNCryptX509Plain:\n        if (!HandlePlainAuth(client)) return FALSE;\n        break;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n      case rfbVeNCryptX509SASL:\n      case rfbVeNCryptTLSSASL:\n        if (!HandleSASLAuth(client)) return FALSE;\n        break;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n      default:\n        rfbClientLog(\"Unknown sub authentication scheme from VNC server: %d\\n\",\n            client->subAuthScheme);\n        return FALSE;\n    }\n\n    break;\n\n  default:\n    {\n      rfbBool authHandled=FALSE;\n      rfbClientProtocolExtension* e;\n      for (e = rfbClientExtensions; e; e = e->next) {\n        uint32_t const* secType;\n        if (!e->handleAuthentication) continue;\n        for (secType = e->securityTypes; secType && *secType; secType++) {\n          if (authScheme==*secType) {\n            if (!e->handleAuthentication(client, authScheme)) return FALSE;\n            if (!rfbHandleAuthResult(client)) return FALSE;\n            authHandled=TRUE;\n          }\n        }\n      }\n      if (authHandled) break;\n    }\n    rfbClientLog(\"Unknown authentication scheme from VNC server: %d\\n\",\n\t    (int)authScheme);\n    return FALSE;\n  }\n\n  ci.shared = (client->appData.shareDesktop ? 1 : 0);\n\n  if (!WriteToRFBServer(client,  (char *)&ci, sz_rfbClientInitMsg)) return FALSE;\n\n  if (!ReadFromRFBServer(client, (char *)&client->si, sz_rfbServerInitMsg)) return FALSE;\n\n  client->si.framebufferWidth = rfbClientSwap16IfLE(client->si.framebufferWidth);\n  client->si.framebufferHeight = rfbClientSwap16IfLE(client->si.framebufferHeight);\n  client->si.format.redMax = rfbClientSwap16IfLE(client->si.format.redMax);\n  client->si.format.greenMax = rfbClientSwap16IfLE(client->si.format.greenMax);\n  client->si.format.blueMax = rfbClientSwap16IfLE(client->si.format.blueMax);\n  client->si.nameLength = rfbClientSwap32IfLE(client->si.nameLength);\n\n  if (client->si.nameLength > 1<<20) {\n      rfbClientErr(\"Too big desktop name length sent by server: %u B > 1 MB\\n\", (unsigned int)client->si.nameLength);\n      return FALSE;\n  }\n\n  client->desktopName = malloc(client->si.nameLength + 1);\n  if (!client->desktopName) {\n    rfbClientLog(\"Error allocating memory for desktop name, %lu bytes\\n\",\n            (unsigned long)client->si.nameLength);\n    return FALSE;\n  }\n\n  if (!ReadFromRFBServer(client, client->desktopName, client->si.nameLength)) return FALSE;\n\n  client->desktopName[client->si.nameLength] = 0;\n\n  rfbClientLog(\"Desktop name \\\"%s\\\"\\n\",client->desktopName);\n\n  rfbClientLog(\"Connected to VNC server, using protocol version %d.%d\\n\",\n\t  client->major, client->minor);\n\n  rfbClientLog(\"VNC server default format:\\n\");\n  PrintPixelFormat(&client->si.format);\n\n  return TRUE;\n}\n\n\n/*\n * SetFormatAndEncodings.\n */\n\nrfbBool\nSetFormatAndEncodings(rfbClient* client)\n{\n  rfbSetPixelFormatMsg spf;\n  union {\n    char bytes[sz_rfbSetEncodingsMsg + MAX_ENCODINGS*4];\n    rfbSetEncodingsMsg msg;\n  } buf;\n\n  rfbSetEncodingsMsg *se = &buf.msg;\n  uint32_t *encs = (uint32_t *)(&buf.bytes[sz_rfbSetEncodingsMsg]);\n  int len = 0;\n  rfbBool requestCompressLevel = FALSE;\n  rfbBool requestQualityLevel = FALSE;\n  rfbBool requestLastRectEncoding = FALSE;\n  rfbClientProtocolExtension* e;\n\n  if (!SupportsClient2Server(client, rfbSetPixelFormat)) return TRUE;\n\n  spf.type = rfbSetPixelFormat;\n  spf.pad1 = 0;\n  spf.pad2 = 0;\n  spf.format = client->format;\n  spf.format.redMax = rfbClientSwap16IfLE(spf.format.redMax);\n  spf.format.greenMax = rfbClientSwap16IfLE(spf.format.greenMax);\n  spf.format.blueMax = rfbClientSwap16IfLE(spf.format.blueMax);\n\n  if (!WriteToRFBServer(client, (char *)&spf, sz_rfbSetPixelFormatMsg))\n    return FALSE;\n\n\n  if (!SupportsClient2Server(client, rfbSetEncodings)) return TRUE;\n\n  se->type = rfbSetEncodings;\n  se->pad = 0;\n  se->nEncodings = 0;\n\n  if (client->appData.encodingsString) {\n    const char *encStr = client->appData.encodingsString;\n    int encStrLen;\n    do {\n      const char *nextEncStr = strchr(encStr, ' ');\n      if (nextEncStr) {\n\tencStrLen = nextEncStr - encStr;\n\tnextEncStr++;\n      } else {\n\tencStrLen = strlen(encStr);\n      }\n\n      if (strncasecmp(encStr,\"raw\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);\n      } else if (strncasecmp(encStr,\"copyrect\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      } else if (strncasecmp(encStr,\"tight\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);\n\trequestLastRectEncoding = TRUE;\n\tif (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)\n\t  requestCompressLevel = TRUE;\n\tif (client->appData.enableJPEG)\n\t  requestQualityLevel = TRUE;\n#endif\n#endif\n      } else if (strncasecmp(encStr,\"hextile\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      } else if (strncasecmp(encStr,\"zlib\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);\n\tif (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)\n\t  requestCompressLevel = TRUE;\n      } else if (strncasecmp(encStr,\"zlibhex\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlibHex);\n\tif (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)\n\t  requestCompressLevel = TRUE;\n      } else if (strncasecmp(encStr,\"trle\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTRLE);\n      } else if (strncasecmp(encStr,\"zrle\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);\n      } else if (strncasecmp(encStr,\"zywrle\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);\n\trequestQualityLevel = TRUE;\n#endif\n      } else if ((strncasecmp(encStr,\"ultra\",encStrLen) == 0) || (strncasecmp(encStr,\"ultrazip\",encStrLen) == 0)) {\n        /* There are 2 encodings used in 'ultra' */\n        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);\n        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);\n      } else if (strncasecmp(encStr,\"corre\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);\n      } else if (strncasecmp(encStr,\"rre\",encStrLen) == 0) {\n\tencs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);\n      } else {\n\trfbClientLog(\"Unknown encoding '%.*s'\\n\",encStrLen,encStr);\n      }\n\n      encStr = nextEncStr;\n    } while (encStr && se->nEncodings < MAX_ENCODINGS);\n\n    if (se->nEncodings < MAX_ENCODINGS && requestCompressLevel) {\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +\n\t\t\t\t\t  rfbEncodingCompressLevel0);\n    }\n\n    if (se->nEncodings < MAX_ENCODINGS && requestQualityLevel) {\n      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)\n        client->appData.qualityLevel = 5;\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +\n\t\t\t\t\t  rfbEncodingQualityLevel0);\n    }\n  }\n  else {\n    if (SameMachine(client->sock)) {\n      /* TODO:\n      if (!tunnelSpecified) {\n      */\n      rfbClientLog(\"Same machine: preferring raw encoding\\n\");\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);\n      /*\n      } else {\n\trfbClientLog(\"Tunneling active: preferring tight encoding\\n\");\n      }\n      */\n    }\n\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);\n    requestLastRectEncoding = TRUE;\n#endif\n#endif\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);\n#endif\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);\n\n    if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9) {\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +\n\t\t\t\t\t  rfbEncodingCompressLevel0);\n    } else /* if (!tunnelSpecified) */ {\n      /* If -tunnel option was provided, we assume that server machine is\n\t not in the local network so we use default compression level for\n\t tight encoding instead of fast compression. Thus we are\n\t requesting level 1 compression only if tunneling is not used. */\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCompressLevel1);\n    }\n\n    if (client->appData.enableJPEG) {\n      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)\n\tclient->appData.qualityLevel = 5;\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +\n\t\t\t\t\t  rfbEncodingQualityLevel0);\n    }\n  }\n\n\n\n  /* Remote Cursor Support (local to viewer) */\n  if (client->appData.useRemoteCursor) {\n    if (se->nEncodings < MAX_ENCODINGS)\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXCursor);\n    if (se->nEncodings < MAX_ENCODINGS)\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRichCursor);\n    if (se->nEncodings < MAX_ENCODINGS)\n      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingPointerPos);\n  }\n\n  /* Keyboard State Encodings */\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingKeyboardLedState);\n\n  /* New Frame Buffer Size */\n  if (se->nEncodings < MAX_ENCODINGS && client->canHandleNewFBSize)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingNewFBSize);\n\n  /* Last Rect */\n  if (se->nEncodings < MAX_ENCODINGS && requestLastRectEncoding)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingLastRect);\n\n  /* Server Capabilities */\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedMessages);\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedEncodings);\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingServerIdentity);\n\n  /* xvp */\n  if (se->nEncodings < MAX_ENCODINGS)\n    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXvp);\n\n  /* client extensions */\n  for(e = rfbClientExtensions; e; e = e->next)\n    if(e->encodings) {\n      int* enc;\n      for(enc = e->encodings; *enc; enc++)\n        if(se->nEncodings < MAX_ENCODINGS)\n          encs[se->nEncodings++] = rfbClientSwap32IfLE(*enc);\n    }\n\n  len = sz_rfbSetEncodingsMsg + se->nEncodings * 4;\n\n  se->nEncodings = rfbClientSwap16IfLE(se->nEncodings);\n\n  if (!WriteToRFBServer(client, buf.bytes, len)) return FALSE;\n\n  return TRUE;\n}\n\n\n/*\n * SendIncrementalFramebufferUpdateRequest.\n */\n\nrfbBool\nSendIncrementalFramebufferUpdateRequest(rfbClient* client)\n{\n\treturn SendFramebufferUpdateRequest(client,\n\t\t\tclient->updateRect.x, client->updateRect.y,\n\t\t\tclient->updateRect.w, client->updateRect.h, TRUE);\n}\n\n\n/*\n * SendFramebufferUpdateRequest.\n */\n\nrfbBool\nSendFramebufferUpdateRequest(rfbClient* client, int x, int y, int w, int h, rfbBool incremental)\n{\n  rfbFramebufferUpdateRequestMsg fur;\n\n  if (!SupportsClient2Server(client, rfbFramebufferUpdateRequest)) return TRUE;\n  \n  fur.type = rfbFramebufferUpdateRequest;\n  fur.incremental = incremental ? 1 : 0;\n  fur.x = rfbClientSwap16IfLE(x);\n  fur.y = rfbClientSwap16IfLE(y);\n  fur.w = rfbClientSwap16IfLE(w);\n  fur.h = rfbClientSwap16IfLE(h);\n\n  if (!WriteToRFBServer(client, (char *)&fur, sz_rfbFramebufferUpdateRequestMsg))\n    return FALSE;\n\n  return TRUE;\n}\n\n\n/*\n * SendScaleSetting.\n */\nrfbBool\nSendScaleSetting(rfbClient* client,int scaleSetting)\n{\n  rfbSetScaleMsg ssm;\n\n  ssm.scale = scaleSetting;\n  ssm.pad = 0;\n  \n  /* favor UltraVNC SetScale if both are supported */\n  if (SupportsClient2Server(client, rfbSetScale)) {\n      ssm.type = rfbSetScale;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  \n  if (SupportsClient2Server(client, rfbPalmVNCSetScaleFactor)) {\n      ssm.type = rfbPalmVNCSetScaleFactor;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n\n  return TRUE;\n}\n\n/*\n * TextChatFunctions (UltraVNC)\n * Extremely bandwidth friendly method of communicating with a user\n * (Think HelpDesk type applications)\n */\n\nrfbBool TextChatSend(rfbClient* client, char *text)\n{\n    rfbTextChatMsg chat;\n    int count = strlen(text);\n\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = (uint32_t)count;\n    chat.length = rfbClientSwap32IfLE(chat.length);\n\n    if (!WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg))\n        return FALSE;\n\n    if (count>0) {\n        if (!WriteToRFBServer(client, text, count))\n            return FALSE;\n    }\n    return TRUE;\n}\n\nrfbBool TextChatOpen(rfbClient* client)\n{\n    rfbTextChatMsg chat;\n\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = rfbClientSwap32IfLE(rfbTextChatOpen);\n    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);\n}\n\nrfbBool TextChatClose(rfbClient* client)\n{\n    rfbTextChatMsg chat;\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = rfbClientSwap32IfLE(rfbTextChatClose);\n    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);\n}\n\nrfbBool TextChatFinish(rfbClient* client)\n{\n    rfbTextChatMsg chat;\n    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;\n    chat.type = rfbTextChat;\n    chat.pad1 = 0;\n    chat.pad2 = 0;\n    chat.length = rfbClientSwap32IfLE(rfbTextChatFinished);\n    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);\n}\n\n/*\n * UltraVNC Server Input Disable\n * Apparently, the remote client can *prevent* the local user from interacting with the display\n * I would think this is extremely helpful when used in a HelpDesk situation\n */\nrfbBool PermitServerInput(rfbClient* client, int enabled)\n{\n    rfbSetServerInputMsg msg;\n\n    if (!SupportsClient2Server(client, rfbSetServerInput)) return TRUE;\n    /* enabled==1, then server input from local keyboard is disabled */\n    msg.type = rfbSetServerInput;\n    msg.status = (enabled ? 1 : 0);\n    msg.pad = 0;\n    return  (WriteToRFBServer(client, (char *)&msg, sz_rfbSetServerInputMsg) ? TRUE : FALSE);\n}\n\n\n/*\n * send xvp client message\n * A client supporting the xvp extension sends this to request that the server initiate\n * a clean shutdown, clean reboot or abrupt reset of the system whose framebuffer the\n * client is displaying.\n *\n * only version 1 is defined in the protocol specs\n *\n * possible values for code are:\n *   rfbXvp_Shutdown\n *   rfbXvp_Reboot\n *   rfbXvp_Reset\n */\n\nrfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code)\n{\n    rfbXvpMsg xvp;\n\n    if (!SupportsClient2Server(client, rfbXvp)) return TRUE;\n    xvp.type = rfbXvp;\n    xvp.pad = 0;\n    xvp.version = version;\n    xvp.code = code;\n\n    if (!WriteToRFBServer(client, (char *)&xvp, sz_rfbXvpMsg))\n        return FALSE;\n\n    return TRUE;\n}\n\n\n/*\n * SendPointerEvent.\n */\n\nrfbBool\nSendPointerEvent(rfbClient* client,int x, int y, int buttonMask)\n{\n  rfbPointerEventMsg pe;\n\n  if (!SupportsClient2Server(client, rfbPointerEvent)) return TRUE;\n\n  pe.type = rfbPointerEvent;\n  pe.buttonMask = buttonMask;\n  if (x < 0) x = 0;\n  if (y < 0) y = 0;\n\n  pe.x = rfbClientSwap16IfLE(x);\n  pe.y = rfbClientSwap16IfLE(y);\n  return WriteToRFBServer(client, (char *)&pe, sz_rfbPointerEventMsg);\n}\n\n\n/*\n * SendKeyEvent.\n */\n\nrfbBool\nSendKeyEvent(rfbClient* client, uint32_t key, rfbBool down)\n{\n  rfbKeyEventMsg ke;\n\n  if (!SupportsClient2Server(client, rfbKeyEvent)) return TRUE;\n\n  memset(&ke, 0, sizeof(ke));\n  ke.type = rfbKeyEvent;\n  ke.down = down ? 1 : 0;\n  ke.key = rfbClientSwap32IfLE(key);\n  return WriteToRFBServer(client, (char *)&ke, sz_rfbKeyEventMsg);\n}\n\n\n/*\n * SendClientCutText.\n */\n\nrfbBool\nSendClientCutText(rfbClient* client, char *str, int len)\n{\n  rfbClientCutTextMsg cct;\n\n  if (!SupportsClient2Server(client, rfbClientCutText)) return TRUE;\n\n  memset(&cct, 0, sizeof(cct));\n  cct.type = rfbClientCutText;\n  cct.length = rfbClientSwap32IfLE(len);\n  return  (WriteToRFBServer(client, (char *)&cct, sz_rfbClientCutTextMsg) &&\n\t   WriteToRFBServer(client, str, len));\n}\n\n\n\n/*\n * HandleRFBServerMessage.\n */\n\nrfbBool\nHandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n\t  if(msg.tc.length > MAX_TEXTCHAT_SIZE)\n\t      return FALSE;\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}\n\n\n#define GET_PIXEL8(pix, ptr) ((pix) = *(ptr)++)\n\n#define GET_PIXEL16(pix, ptr) (((uint8_t*)&(pix))[0] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[1] = *(ptr)++)\n\n#define GET_PIXEL32(pix, ptr) (((uint8_t*)&(pix))[0] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[1] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[2] = *(ptr)++, \\\n\t\t\t       ((uint8_t*)&(pix))[3] = *(ptr)++)\n\n/* CONCAT2 concatenates its two arguments.  CONCAT2E does the same but also\n   expands its arguments if they are macros */\n\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#define CONCAT3(a,b,c) a##b##c\n#define CONCAT3E(a,b,c) CONCAT3(a,b,c)\n\n#define BPP 8\n#include \"rre.c\"\n#include \"corre.c\"\n#include \"hextile.c\"\n#include \"ultra.c\"\n#include \"zlib.c\"\n#include \"tight.c\"\n#include \"trle.c\"\n#include \"zrle.c\"\n#undef BPP\n#define BPP 16\n#include \"rre.c\"\n#include \"corre.c\"\n#include \"hextile.c\"\n#include \"ultra.c\"\n#include \"zlib.c\"\n#include \"tight.c\"\n#include \"trle.c\"\n#include \"zrle.c\"\n#define REALBPP 15\n#include \"trle.c\"\n#define REALBPP 15\n#include \"zrle.c\"\n#undef BPP\n#define BPP 32\n#include \"rre.c\"\n#include \"corre.c\"\n#include \"hextile.c\"\n#include \"ultra.c\"\n#include \"zlib.c\"\n#include \"tight.c\"\n#include \"trle.c\"\n#include \"zrle.c\"\n#define REALBPP 24\n#include \"trle.c\"\n#define REALBPP 24\n#include \"zrle.c\"\n#define REALBPP 24\n#define UNCOMP 8\n#include \"trle.c\"\n#define REALBPP 24\n#define UNCOMP 8\n#include \"zrle.c\"\n#define REALBPP 24\n#define UNCOMP -8\n#include \"trle.c\"\n#define REALBPP 24\n#define UNCOMP -8\n#include \"zrle.c\"\n#undef BPP\n\n\n/*\n * PrintPixelFormat.\n */\n\nvoid\nPrintPixelFormat(rfbPixelFormat *format)\n{\n  if (format->bitsPerPixel == 1) {\n    rfbClientLog(\"  Single bit per pixel.\\n\");\n    rfbClientLog(\n\t    \"  %s significant bit in each byte is leftmost on the screen.\\n\",\n\t    (format->bigEndian ? \"Most\" : \"Least\"));\n  } else {\n    rfbClientLog(\"  %d bits per pixel.\\n\",format->bitsPerPixel);\n    if (format->bitsPerPixel != 8) {\n      rfbClientLog(\"  %s significant byte first in each pixel.\\n\",\n\t      (format->bigEndian ? \"Most\" : \"Least\"));\n    }\n    if (format->trueColour) {\n      rfbClientLog(\"  TRUE colour: max red %d green %d blue %d\"\n\t\t   \", shift red %d green %d blue %d\\n\",\n\t\t   format->redMax, format->greenMax, format->blueMax,\n\t\t   format->redShift, format->greenShift, format->blueShift);\n    } else {\n      rfbClientLog(\"  Colour map (not true colour).\\n\");\n    }\n  }\n}\n\n/* avoid name clashes with LibVNCServer */\n\n#define rfbEncryptBytes rfbClientEncryptBytes\n#define rfbEncryptBytes2 rfbClientEncryptBytes2\n#define rfbDes rfbClientDes\n#define rfbDesKey rfbClientDesKey\n#define rfbUseKey rfbClientUseKey\n\n#include \"vncauth.c\"\n"], "filenames": ["libvncclient/rfbproto.c"], "buggy_code_start_loc": [1154], "buggy_code_end_loc": [1358], "fixing_code_start_loc": [1154], "fixing_code_end_loc": [1361], "type": "NVD-CWE-Other", "message": "** DISPUTED ** An issue was discovered in LibVNCServer before 0.9.13. Byte-aligned data is accessed through uint32_t pointers in libvncclient/rfbproto.c. NOTE: there is reportedly \"no trust boundary crossed.\"", "other": {"cve": {"id": "CVE-2020-14399", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:11.930", "lastModified": "2023-02-27T18:14:00.050", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** An issue was discovered in LibVNCServer before 0.9.13. Byte-aligned data is accessed through uint32_t pointers in libvncclient/rfbproto.c. NOTE: there is reportedly \"no trust boundary crossed.\""}, {"lang": "es", "value": "**EN DISPUTA** Se detect\u00f3 un problema en LibVNCServer versiones anteriores a 0.9.13. Los datos Byte-aligned son accedidos por medio de punteros uint32_t en la biblioteca libvncclient/rfbproto.c. NOTA: se informa que \"no se ha cruzado ning\u00fan l\u00edmite de confianza\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvncserver_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.13", "matchCriteriaId": "4F3C4EF0-4663-4832-8662-D1AB70E562E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1860354", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/23e5cbe6b090d7f22982aee909a6a618174d3c2d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/23e5cbe6b090d7f22982aee909a6a618174d3c2d"}}