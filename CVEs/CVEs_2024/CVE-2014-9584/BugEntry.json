{"buggy_code": ["/*\n *  linux/fs/isofs/rock.c\n *\n *  (C) 1992, 1993  Eric Youngdale\n *\n *  Rock Ridge Extensions to iso9660\n */\n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\n#include \"isofs.h\"\n#include \"rock.h\"\n\n/*\n * These functions are designed to read the system areas of a directory record\n * and extract relevant information.  There are different functions provided\n * depending upon what information we need at the time.  One function fills\n * out an inode structure, a second one extracts a filename, a third one\n * returns a symbolic link name, and a fourth one returns the extent number\n * for the file.\n */\n\n#define SIG(A,B) ((A) | ((B) << 8))\t/* isonum_721() */\n\nstruct rock_state {\n\tvoid *buffer;\n\tunsigned char *chr;\n\tint len;\n\tint cont_size;\n\tint cont_extent;\n\tint cont_offset;\n\tint cont_loops;\n\tstruct inode *inode;\n};\n\n/*\n * This is a way of ensuring that we have something in the system\n * use fields that is compatible with Rock Ridge.  Return zero on success.\n */\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}\n\n/* Maximum number of Rock Ridge continuation entries */\n#define RR_MAX_CE_ENTRIES 32\n\n/*\n * Returns 0 if the caller should continue scanning, 1 if the scan must end\n * and -ve on error.\n */\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}\n\n/*\n * We think there's a record of type `sig' at rs->chr.  Parse the signature\n * and make sure that there's really room for a record of that type.\n */\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n/*\n * return length of name field; 0: not found, -1: to be ignored\n */\nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\n#define RR_REGARD_XA 1\n#define RR_RELOC_DE 2\n\nstatic int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}\n\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}\n\n/*\n * readpage() for symlinks: reads symlink contents into the page and either\n * makes it uptodate and returns 0 or returns error (-EIO)\n */\nstatic int rock_ridge_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\tchar *link = kmap(page);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tstruct buffer_head *bh;\n\tchar *rpnt = link;\n\tunsigned char *pnt;\n\tstruct iso_directory_record *raw_de;\n\tunsigned long block, offset;\n\tint sig;\n\tstruct rock_ridge *rr;\n\tstruct rock_state rs;\n\tint ret;\n\n\tif (!sbi->s_rock)\n\t\tgoto error;\n\n\tinit_rock_state(&rs, inode);\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_noread;\n\n\toffset = ei->i_iget5_offset;\n\tpnt = (unsigned char *)bh->b_data + offset;\n\n\traw_de = (struct iso_directory_record *)pnt;\n\n\t/*\n\t * If we go past the end of the buffer, there is some sort of error.\n\t */\n\tif (offset + *pnt > bufsize)\n\t\tgoto out_bad_span;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tsetup_rock_ridge(raw_de, inode, &rs);\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto out;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* corrupted isofs */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_SL) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\trpnt = get_symlink_chunk(rpnt, rr,\n\t\t\t\t\t\t link + (PAGE_SIZE - 1));\n\t\t\tif (rpnt == NULL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\t/* This tells is if there is a continuation record */\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (rpnt == link)\n\t\tgoto fail;\n\tbrelse(bh);\n\t*rpnt = '\\0';\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\n\t/* error exit from macro */\nout:\n\tkfree(rs.buffer);\n\tgoto fail;\nout_noread:\n\tprintk(\"unable to read i-node block\");\n\tgoto fail;\nout_bad_span:\n\tprintk(\"symlink spans iso9660 blocks\\n\");\nfail:\n\tbrelse(bh);\nerror:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn -EIO;\n}\n\nconst struct address_space_operations isofs_symlink_aops = {\n\t.readpage = rock_ridge_symlink_readpage\n};\n"], "fixing_code": ["/*\n *  linux/fs/isofs/rock.c\n *\n *  (C) 1992, 1993  Eric Youngdale\n *\n *  Rock Ridge Extensions to iso9660\n */\n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\n#include \"isofs.h\"\n#include \"rock.h\"\n\n/*\n * These functions are designed to read the system areas of a directory record\n * and extract relevant information.  There are different functions provided\n * depending upon what information we need at the time.  One function fills\n * out an inode structure, a second one extracts a filename, a third one\n * returns a symbolic link name, and a fourth one returns the extent number\n * for the file.\n */\n\n#define SIG(A,B) ((A) | ((B) << 8))\t/* isonum_721() */\n\nstruct rock_state {\n\tvoid *buffer;\n\tunsigned char *chr;\n\tint len;\n\tint cont_size;\n\tint cont_extent;\n\tint cont_offset;\n\tint cont_loops;\n\tstruct inode *inode;\n};\n\n/*\n * This is a way of ensuring that we have something in the system\n * use fields that is compatible with Rock Ridge.  Return zero on success.\n */\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}\n\n/* Maximum number of Rock Ridge continuation entries */\n#define RR_MAX_CE_ENTRIES 32\n\n/*\n * Returns 0 if the caller should continue scanning, 1 if the scan must end\n * and -ve on error.\n */\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}\n\n/*\n * We think there's a record of type `sig' at rs->chr.  Parse the signature\n * and make sure that there's really room for a record of that type.\n */\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n/*\n * return length of name field; 0: not found, -1: to be ignored\n */\nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\n#define RR_REGARD_XA 1\n#define RR_RELOC_DE 2\n\nstatic int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\t/* Invalid length of ER tag id? */\n\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n\t\t\t\tgoto out;\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}\n\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}\n\n/*\n * readpage() for symlinks: reads symlink contents into the page and either\n * makes it uptodate and returns 0 or returns error (-EIO)\n */\nstatic int rock_ridge_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\tchar *link = kmap(page);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tstruct buffer_head *bh;\n\tchar *rpnt = link;\n\tunsigned char *pnt;\n\tstruct iso_directory_record *raw_de;\n\tunsigned long block, offset;\n\tint sig;\n\tstruct rock_ridge *rr;\n\tstruct rock_state rs;\n\tint ret;\n\n\tif (!sbi->s_rock)\n\t\tgoto error;\n\n\tinit_rock_state(&rs, inode);\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_noread;\n\n\toffset = ei->i_iget5_offset;\n\tpnt = (unsigned char *)bh->b_data + offset;\n\n\traw_de = (struct iso_directory_record *)pnt;\n\n\t/*\n\t * If we go past the end of the buffer, there is some sort of error.\n\t */\n\tif (offset + *pnt > bufsize)\n\t\tgoto out_bad_span;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tsetup_rock_ridge(raw_de, inode, &rs);\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto out;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* corrupted isofs */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_SL) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\trpnt = get_symlink_chunk(rpnt, rr,\n\t\t\t\t\t\t link + (PAGE_SIZE - 1));\n\t\t\tif (rpnt == NULL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\t/* This tells is if there is a continuation record */\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (rpnt == link)\n\t\tgoto fail;\n\tbrelse(bh);\n\t*rpnt = '\\0';\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\n\t/* error exit from macro */\nout:\n\tkfree(rs.buffer);\n\tgoto fail;\nout_noread:\n\tprintk(\"unable to read i-node block\");\n\tgoto fail;\nout_bad_span:\n\tprintk(\"symlink spans iso9660 blocks\\n\");\nfail:\n\tbrelse(bh);\nerror:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn -EIO;\n}\n\nconst struct address_space_operations isofs_symlink_aops = {\n\t.readpage = rock_ridge_symlink_readpage\n};\n"], "filenames": ["fs/isofs/rock.c"], "buggy_code_start_loc": [364], "buggy_code_end_loc": [364], "fixing_code_start_loc": [365], "fixing_code_end_loc": [368], "type": "CWE-20", "message": "The parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel before 3.18.2 does not validate a length value in the Extensions Reference (ER) System Use Field, which allows local users to obtain sensitive information from kernel memory via a crafted iso9660 image.", "other": {"cve": {"id": "CVE-2014-9584", "sourceIdentifier": "secalert@redhat.com", "published": "2015-01-09T21:59:01.533", "lastModified": "2023-02-13T00:45:22.080", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel before 3.18.2 does not validate a length value in the Extensions Reference (ER) System Use Field, which allows local users to obtain sensitive information from kernel memory via a crafted iso9660 image."}, {"lang": "es", "value": "La funci\u00f3n parse_rock_ridge_inode_internal en fs/isofs/rock.c en el kernel de Linux anterior a 3.18.2 no valida un valor de longitud en el campo Extensions Reference (ER) System Use, lo que permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel a trav\u00e9s de una imagen iso9660 manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.18.2", "matchCriteriaId": "D59B9C19-9E27-4628-8E95-F03807748CEF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_aus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "893A7EE9-495D-405A-B809-39DC80778B2A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "319EC0C6-94C5-494A-9C5D-DC5124DFC8E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "0E8CD4EF-DC90-40BB-A721-6EC087507906"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "21690BAC-2129-4A33-9B48-1F3BF30072A9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "13E02156-E748-4820-B76F-7074793837E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:evergreen:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "CCE4D64E-8C4B-4F21-A9B0-90637C85C1D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:12:-:*:*:*:*:*:*", "matchCriteriaId": "D2DF4815-B8CB-4AD3-B91D-2E09A8E318E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_real_time_extension:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "3DB41B45-D94D-4A58-88B0-B3EC3EC350E2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:10:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "35BBD83D-BDC7-4678-BE94-639F59281139"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:ltss:*:*:*", "matchCriteriaId": "67960FB9-13D1-4DEE-8158-31BF31BCBE6F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:ltss:*:*:*", "matchCriteriaId": "CB6476C7-03F2-4939-AB85-69AA524516D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:-:*:*:*:*:*:*", "matchCriteriaId": "15FC9014-BD85-4382-9D04-C0703E901D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:12:-:*:*:*:*:*:*", "matchCriteriaId": "1831D45A-EE6E-4220-8F8C-248B69520948"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_workstation_extension:12:*:*:*:*:*:*:*", "matchCriteriaId": "9DFA18B6-2642-470A-A350-68947529EE5D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:lts:*:*:*", "matchCriteriaId": "5D37DF0F-F863-45AC-853A-3E04F9FEC7CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:5:-:*:*:*:*:*:*", "matchCriteriaId": "62A2AC02-A933-4E51-810E-5D040B476B7B"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=4e2024624e678f0ebb916e6192bd23c1f9fdf696", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00010.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00025.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00000.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00009.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00015.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0864.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1137.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1138.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2015/dsa-3128", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.18.2", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2015:058", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/01/09/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjan2016-2867209.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71883", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2511-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2512-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2513-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2514-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2515-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2516-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2517-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2518-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1180119", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/4e2024624e678f0ebb916e6192bd23c1f9fdf696", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4e2024624e678f0ebb916e6192bd23c1f9fdf696"}}