{"buggy_code": ["/**\n * @file\n * Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page newsrc Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * Read/parse/write an NNTP config file of subscribed newsgroups\n */\n\n#include \"config.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"format_flags.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mutt_window.h\"\n#include \"mx.h\"\n#include \"nntp.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"sort.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct BodyCache;\n\n/**\n * nntp_data_find - Find NntpData for given newsgroup or add it\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstatic struct NntpData *nntp_data_find(struct NntpServer *nserv, const char *group)\n{\n  struct NntpData *nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (nntp_data)\n    return nntp_data;\n\n  size_t len = strlen(group) + 1;\n  /* create NntpData structure and add it to hash */\n  nntp_data = mutt_mem_calloc(1, sizeof(struct NntpData) + len);\n  nntp_data->group = (char *) nntp_data + sizeof(struct NntpData);\n  mutt_str_strfcpy(nntp_data->group, group, len);\n  nntp_data->nserv = nserv;\n  nntp_data->deleted = true;\n  mutt_hash_insert(nserv->groups_hash, nntp_data->group, nntp_data);\n\n  /* add NntpData to list */\n  if (nserv->groups_num >= nserv->groups_max)\n  {\n    nserv->groups_max *= 2;\n    mutt_mem_realloc(&nserv->groups_list, nserv->groups_max * sizeof(nntp_data));\n  }\n  nserv->groups_list[nserv->groups_num++] = nntp_data;\n\n  return nntp_data;\n}\n\n/**\n * nntp_acache_free - Remove all temporarily cache files\n * @param nntp_data NNTP data\n */\nvoid nntp_acache_free(struct NntpData *nntp_data)\n{\n  for (int i = 0; i < NNTP_ACACHE_LEN; i++)\n  {\n    if (nntp_data->acache[i].path)\n    {\n      unlink(nntp_data->acache[i].path);\n      FREE(&nntp_data->acache[i].path);\n    }\n  }\n}\n\n/**\n * nntp_data_free - Free NntpData, used to destroy hash elements\n * @param data NNTP data\n */\nvoid nntp_data_free(void *data)\n{\n  struct NntpData *nntp_data = data;\n\n  if (!nntp_data)\n    return;\n  nntp_acache_free(nntp_data);\n  mutt_bcache_close(&nntp_data->bcache);\n  FREE(&nntp_data->newsrc_ent);\n  FREE(&nntp_data->desc);\n  FREE(&data);\n}\n\n/**\n * nntp_hash_destructor - Free our hash table data\n * @param type Type (UNUSED)\n * @param obj  NNTP data\n * @param data Data (UNUSED)\n */\nvoid nntp_hash_destructor(int type, void *obj, intptr_t data)\n{\n  nntp_data_free(obj);\n}\n\n/**\n * nntp_newsrc_close - Unlock and close .newsrc file\n * @param nserv NNTP server\n */\nvoid nntp_newsrc_close(struct NntpServer *nserv)\n{\n  if (!nserv->newsrc_fp)\n    return;\n\n  mutt_debug(1, \"Unlocking %s\\n\", nserv->newsrc_file);\n  mutt_file_unlock(fileno(nserv->newsrc_fp));\n  mutt_file_fclose(&nserv->newsrc_fp);\n}\n\n/**\n * nntp_group_unread_stat - Count number of unread articles using .newsrc data\n * @param nntp_data NNTP data\n */\nvoid nntp_group_unread_stat(struct NntpData *nntp_data)\n{\n  nntp_data->unread = 0;\n  if (nntp_data->last_message == 0 || nntp_data->first_message > nntp_data->last_message)\n    return;\n\n  nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    anum_t first = nntp_data->newsrc_ent[i].first;\n    if (first < nntp_data->first_message)\n      first = nntp_data->first_message;\n    anum_t last = nntp_data->newsrc_ent[i].last;\n    if (last > nntp_data->last_message)\n      last = nntp_data->last_message;\n    if (first <= last)\n      nntp_data->unread -= last - first + 1;\n  }\n}\n\n/**\n * nntp_newsrc_parse - Parse .newsrc file\n * @param nserv NNTP server\n * @retval  0 Not changed\n * @retval  1 Parsed\n * @retval -1 Error\n */\nint nntp_newsrc_parse(struct NntpServer *nserv)\n{\n  char *line = NULL;\n  struct stat sb;\n\n  if (nserv->newsrc_fp)\n  {\n    /* if we already have a handle, close it and reopen */\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n  else\n  {\n    /* if file doesn't exist, create it */\n    nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"a\");\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n\n  /* open .newsrc */\n  nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"r\");\n  if (!nserv->newsrc_fp)\n  {\n    mutt_perror(nserv->newsrc_file);\n    return -1;\n  }\n\n  /* lock it */\n  mutt_debug(1, \"Locking %s\\n\", nserv->newsrc_file);\n  if (mutt_file_lock(fileno(nserv->newsrc_fp), 0, 1))\n  {\n    mutt_file_fclose(&nserv->newsrc_fp);\n    return -1;\n  }\n\n  if (stat(nserv->newsrc_file, &sb))\n  {\n    mutt_perror(nserv->newsrc_file);\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n\n  if (nserv->size == sb.st_size && nserv->mtime == sb.st_mtime)\n    return 0;\n\n  nserv->size = sb.st_size;\n  nserv->mtime = sb.st_mtime;\n  nserv->newsrc_modified = true;\n  mutt_debug(1, \"Parsing %s\\n\", nserv->newsrc_file);\n\n  /* .newsrc has been externally modified or hasn't been loaded yet */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data)\n      continue;\n\n    nntp_data->subscribed = false;\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n\n  line = mutt_mem_malloc(sb.st_size + 1);\n  while (sb.st_size && fgets(line, sb.st_size + 1, nserv->newsrc_fp))\n  {\n    char *b = NULL, *h = NULL;\n    unsigned int j = 1;\n    bool subs = false;\n\n    /* find end of newsgroup name */\n    char *p = strpbrk(line, \":!\");\n    if (!p)\n      continue;\n\n    /* \":\" - subscribed, \"!\" - unsubscribed */\n    if (*p == ':')\n      subs = true;\n    *p++ = '\\0';\n\n    /* get newsgroup data */\n    struct NntpData *nntp_data = nntp_data_find(nserv, line);\n    FREE(&nntp_data->newsrc_ent);\n\n    /* count number of entries */\n    b = p;\n    while (*b)\n      if (*b++ == ',')\n        j++;\n    nntp_data->newsrc_ent = mutt_mem_calloc(j, sizeof(struct NewsrcEntry));\n    nntp_data->subscribed = subs;\n\n    /* parse entries */\n    j = 0;\n    while (p)\n    {\n      b = p;\n\n      /* find end of entry */\n      p = strchr(p, ',');\n      if (p)\n        *p++ = '\\0';\n\n      /* first-last or single number */\n      h = strchr(b, '-');\n      if (h)\n        *h++ = '\\0';\n      else\n        h = b;\n\n      if (sscanf(b, ANUM, &nntp_data->newsrc_ent[j].first) == 1 &&\n          sscanf(h, ANUM, &nntp_data->newsrc_ent[j].last) == 1)\n      {\n        j++;\n      }\n    }\n    if (j == 0)\n    {\n      nntp_data->newsrc_ent[j].first = 1;\n      nntp_data->newsrc_ent[j].last = 0;\n      j++;\n    }\n    if (nntp_data->last_message == 0)\n      nntp_data->last_message = nntp_data->newsrc_ent[j - 1].last;\n    nntp_data->newsrc_len = j;\n    mutt_mem_realloc(&nntp_data->newsrc_ent, j * sizeof(struct NewsrcEntry));\n    nntp_group_unread_stat(nntp_data);\n    mutt_debug(2, \"%s\\n\", nntp_data->group);\n  }\n  FREE(&line);\n  return 1;\n}\n\n/**\n * nntp_newsrc_gen_entries - Generate array of .newsrc entries\n * @param ctx Mailbox\n */\nvoid nntp_newsrc_gen_entries(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data;\n  anum_t last = 0, first = 1;\n  bool series;\n  int save_sort = SORT_ORDER;\n  unsigned int entries;\n\n  if (Sort != SORT_ORDER)\n  {\n    save_sort = Sort;\n    Sort = SORT_ORDER;\n    mutt_sort_headers(ctx, 0);\n  }\n\n  entries = nntp_data->newsrc_len;\n  if (!entries)\n  {\n    entries = 5;\n    nntp_data->newsrc_ent = mutt_mem_calloc(entries, sizeof(struct NewsrcEntry));\n  }\n\n  /* Set up to fake initial sequence from 1 to the article before the\n   * first article in our list */\n  nntp_data->newsrc_len = 0;\n  series = true;\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* search for first unread */\n    if (series)\n    {\n      /* We don't actually check sequential order, since we mark\n       * \"missing\" entries as read/deleted */\n      last = NHDR(ctx->hdrs[i])->article_num;\n      if (last >= nntp_data->first_message && !ctx->hdrs[i]->deleted &&\n          !ctx->hdrs[i]->read)\n      {\n        if (nntp_data->newsrc_len >= entries)\n        {\n          entries *= 2;\n          mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n        }\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].last = last - 1;\n        nntp_data->newsrc_len++;\n        series = false;\n      }\n    }\n\n    /* search for first read */\n    else\n    {\n      if (ctx->hdrs[i]->deleted || ctx->hdrs[i]->read)\n      {\n        first = last + 1;\n        series = true;\n      }\n      last = NHDR(ctx->hdrs[i])->article_num;\n    }\n  }\n\n  if (series && first <= nntp_data->last_loaded)\n  {\n    if (nntp_data->newsrc_len >= entries)\n    {\n      entries++;\n      mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n    }\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].last = nntp_data->last_loaded;\n    nntp_data->newsrc_len++;\n  }\n  mutt_mem_realloc(&nntp_data->newsrc_ent, nntp_data->newsrc_len * sizeof(struct NewsrcEntry));\n\n  if (save_sort != Sort)\n  {\n    Sort = save_sort;\n    mutt_sort_headers(ctx, 0);\n  }\n}\n\n/**\n * update_file - Update file with new contents\n * @param filename File to update\n * @param buf      New context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int update_file(char *filename, char *buf)\n{\n  FILE *fp = NULL;\n  char tmpfile[PATH_MAX];\n  int rc = -1;\n\n  while (true)\n  {\n    snprintf(tmpfile, sizeof(tmpfile), \"%s.tmp\", filename);\n    fp = mutt_file_fopen(tmpfile, \"w\");\n    if (!fp)\n    {\n      mutt_perror(tmpfile);\n      *tmpfile = '\\0';\n      break;\n    }\n    if (fputs(buf, fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      break;\n    }\n    if (mutt_file_fclose(&fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      fp = NULL;\n      break;\n    }\n    fp = NULL;\n    if (rename(tmpfile, filename) < 0)\n    {\n      mutt_perror(filename);\n      break;\n    }\n    *tmpfile = '\\0';\n    rc = 0;\n    break;\n  }\n  if (fp)\n    mutt_file_fclose(&fp);\n  if (*tmpfile)\n    unlink(tmpfile);\n  return rc;\n}\n\n/**\n * nntp_newsrc_update - Update .newsrc file\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_newsrc_update(struct NntpServer *nserv)\n{\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc = -1;\n\n  if (!nserv)\n    return -1;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  off = 0;\n\n  /* we will generate full newsrc here */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->newsrc_ent)\n      continue;\n\n    /* write newsgroup name */\n    if (off + strlen(nntp_data->group) + 3 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s%c \", nntp_data->group,\n             nntp_data->subscribed ? ':' : '!');\n    off += strlen(buf + off);\n\n    /* write entries */\n    for (unsigned int j = 0; j < nntp_data->newsrc_len; j++)\n    {\n      if (off + LONG_STRING > buflen)\n      {\n        buflen *= 2;\n        mutt_mem_realloc(&buf, buflen);\n      }\n      if (j)\n        buf[off++] = ',';\n      if (nntp_data->newsrc_ent[j].first == nntp_data->newsrc_ent[j].last)\n        snprintf(buf + off, buflen - off, \"%u\", nntp_data->newsrc_ent[j].first);\n      else if (nntp_data->newsrc_ent[j].first < nntp_data->newsrc_ent[j].last)\n      {\n        snprintf(buf + off, buflen - off, \"%u-%u\",\n                 nntp_data->newsrc_ent[j].first, nntp_data->newsrc_ent[j].last);\n      }\n      off += strlen(buf + off);\n    }\n    buf[off++] = '\\n';\n  }\n  buf[off] = '\\0';\n\n  /* newrc being fully rewritten */\n  mutt_debug(1, \"Updating %s\\n\", nserv->newsrc_file);\n  if (nserv->newsrc_file && update_file(nserv->newsrc_file, buf) == 0)\n  {\n    struct stat sb;\n\n    rc = stat(nserv->newsrc_file, &sb);\n    if (rc == 0)\n    {\n      nserv->size = sb.st_size;\n      nserv->mtime = sb.st_mtime;\n    }\n    else\n    {\n      mutt_perror(nserv->newsrc_file);\n    }\n  }\n  FREE(&buf);\n  return rc;\n}\n\n/**\n * cache_expand - Make fully qualified cache file name\n * @param dst    Buffer for filename\n * @param dstlen Length of buffer\n * @param acct   Account\n * @param src    Path to add to the URL\n */\nstatic void cache_expand(char *dst, size_t dstlen, struct Account *acct, char *src)\n{\n  char *c = NULL;\n  char file[PATH_MAX];\n\n  /* server subdirectory */\n  if (acct)\n  {\n    struct Url url;\n\n    mutt_account_tourl(acct, &url);\n    url.path = src;\n    url_tostring(&url, file, sizeof(file), U_PATH);\n  }\n  else\n    mutt_str_strfcpy(file, src ? src : \"\", sizeof(file));\n\n  snprintf(dst, dstlen, \"%s/%s\", NewsCacheDir, file);\n\n  /* remove trailing slash */\n  c = dst + strlen(dst) - 1;\n  if (*c == '/')\n    *c = '\\0';\n  mutt_expand_path(dst, dstlen);\n  mutt_encode_path(dst, dstlen, dst);\n}\n\n/**\n * nntp_expand_path - Make fully qualified url from newsgroup name\n * @param line String containing newsgroup name\n * @param len  Length of string\n * @param acct Account to save result\n */\nvoid nntp_expand_path(char *line, size_t len, struct Account *acct)\n{\n  struct Url url;\n\n  mutt_account_tourl(acct, &url);\n  url.path = mutt_str_strdup(line);\n  url_tostring(&url, line, len, 0);\n  FREE(&url.path);\n}\n\n/**\n * nntp_add_group - Parse newsgroup\n * @param line String to parse\n * @param data NNTP data\n * @retval 0 Always\n */\nint nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING] = \"\";\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n\n  if (!nserv || !line)\n    return 0;\n\n  /* These sscanf limits must match the sizes of the group and desc arrays */\n  if (sscanf(line, \"%1023s \" ANUM \" \" ANUM \" %c %8191[^\\n]\", group, &last, &first, &mod, desc) < 4)\n  {\n    mutt_debug(4, \"Cannot parse server line: %s\\n\", line);\n    return 0;\n  }\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}\n\n/**\n * active_get_cache - Load list of all newsgroups from cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int active_get_cache(struct NntpServer *nserv)\n{\n  char buf[HUGE_STRING];\n  char file[PATH_MAX];\n  time_t t;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Parsing %s\\n\", file);\n  FILE *fp = mutt_file_fopen(file, \"r\");\n  if (!fp)\n    return -1;\n\n  if (fgets(buf, sizeof(buf), fp) == NULL || sscanf(buf, \"%ld%s\", &t, file) != 1 || t == 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  nserv->newgroups_time = t;\n\n  mutt_message(_(\"Loading list of groups from cache...\"));\n  while (fgets(buf, sizeof(buf), fp))\n    nntp_add_group(buf, nserv);\n  nntp_add_group(NULL, NULL);\n  mutt_file_fclose(&fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_active_save_cache - Save list of all newsgroups to cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_save_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc;\n\n  if (!nserv->cacheable)\n    return 0;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  snprintf(buf, buflen, \"%lu\\n\", (unsigned long) nserv->newgroups_time);\n  off = strlen(buf);\n\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || nntp_data->deleted)\n      continue;\n\n    if (off + strlen(nntp_data->group) + (nntp_data->desc ? strlen(nntp_data->desc) : 0) + 50 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s %u %u %c%s%s\\n\", nntp_data->group,\n             nntp_data->last_message, nntp_data->first_message,\n             nntp_data->allowed ? 'y' : 'n', nntp_data->desc ? \" \" : \"\",\n             nntp_data->desc ? nntp_data->desc : \"\");\n    off += strlen(buf + off);\n  }\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Updating %s\\n\", file);\n  rc = update_file(file, buf);\n  FREE(&buf);\n  return rc;\n}\n\n#ifdef USE_HCACHE\n/**\n * nntp_hcache_namer - Compose hcache file names\n * @param path    Path of message\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n *\n * Used by mutt_hcache_open() to compose hcache file name\n */\nstatic int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}\n\n/**\n * nntp_hcache_open - Open newsgroup hcache\n * @param nntp_data NNTP data\n * @retval ptr  Header cache\n * @retval NULL Error\n */\nheader_cache_t *nntp_hcache_open(struct NntpData *nntp_data)\n{\n  struct Url url;\n  char file[PATH_MAX];\n\n  if (!nntp_data->nserv || !nntp_data->nserv->cacheable ||\n      !nntp_data->nserv->conn || !nntp_data->group ||\n      !(nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed))\n  {\n    return NULL;\n  }\n\n  mutt_account_tourl(&nntp_data->nserv->conn->account, &url);\n  url.path = nntp_data->group;\n  url_tostring(&url, file, sizeof(file), U_PATH);\n  return mutt_hcache_open(NewsCacheDir, file, nntp_hcache_namer);\n}\n\n/**\n * nntp_hcache_update - Remove stale cached headers\n * @param nntp_data NNTP data\n * @param hc        Header cache\n */\nvoid nntp_hcache_update(struct NntpData *nntp_data, header_cache_t *hc)\n{\n  char buf[16];\n  bool old = false;\n  void *hdata = NULL;\n  anum_t first = 0, last = 0;\n\n  if (!hc)\n    return;\n\n  /* fetch previous values of first and last */\n  hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n  if (hdata)\n  {\n    mutt_debug(2, \"mutt_hcache_fetch index: %s\\n\", (char *) hdata);\n    if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n    {\n      old = true;\n      nntp_data->last_cached = last;\n\n      /* clean removed headers from cache */\n      for (anum_t current = first; current <= last; current++)\n      {\n        if (current >= nntp_data->first_message && current <= nntp_data->last_message)\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n        mutt_hcache_delete(hc, buf, strlen(buf));\n      }\n    }\n    mutt_hcache_free(hc, &hdata);\n  }\n\n  /* store current values of first and last */\n  if (!old || nntp_data->first_message != first || nntp_data->last_message != last)\n  {\n    snprintf(buf, sizeof(buf), \"%u %u\", nntp_data->first_message, nntp_data->last_message);\n    mutt_debug(2, \"mutt_hcache_store index: %s\\n\", buf);\n    mutt_hcache_store_raw(hc, \"index\", 5, buf, strlen(buf));\n  }\n}\n#endif\n\n/**\n * nntp_bcache_delete - Remove bcache file\n * @param id     Body cache ID\n * @param bcache Body cache\n * @param data   NNTP data\n * @retval 0 Always\n */\nstatic int nntp_bcache_delete(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct NntpData *nntp_data = data;\n  anum_t anum;\n  char c;\n\n  if (!nntp_data || sscanf(id, ANUM \"%c\", &anum, &c) != 1 ||\n      anum < nntp_data->first_message || anum > nntp_data->last_message)\n  {\n    if (nntp_data)\n      mutt_debug(2, \"mutt_bcache_del %s\\n\", id);\n    mutt_bcache_del(bcache, id);\n  }\n  return 0;\n}\n\n/**\n * nntp_bcache_update - Remove stale cached messages\n * @param nntp_data NNTP data\n */\nvoid nntp_bcache_update(struct NntpData *nntp_data)\n{\n  mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, nntp_data);\n}\n\n/**\n * nntp_delete_group_cache - Remove hcache and bcache of newsgroup\n * @param nntp_data NNTP data\n */\nvoid nntp_delete_group_cache(struct NntpData *nntp_data)\n{\n  if (!nntp_data || !nntp_data->nserv || !nntp_data->nserv->cacheable)\n    return;\n\n#ifdef USE_HCACHE\n  char file[PATH_MAX];\n  nntp_hcache_namer(nntp_data->group, file, sizeof(file));\n  cache_expand(file, sizeof(file), &nntp_data->nserv->conn->account, file);\n  unlink(file);\n  nntp_data->last_cached = 0;\n  mutt_debug(2, \"%s\\n\", file);\n#endif\n\n  if (!nntp_data->bcache)\n  {\n    nntp_data->bcache =\n        mutt_bcache_open(&nntp_data->nserv->conn->account, nntp_data->group);\n  }\n  if (nntp_data->bcache)\n  {\n    mutt_debug(2, \"%s/*\\n\", nntp_data->group);\n    mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, NULL);\n    mutt_bcache_close(&nntp_data->bcache);\n  }\n}\n\n/**\n * nntp_clear_cache - Clear the NNTP cache\n * @param nserv NNTP server\n *\n * Remove hcache and bcache of all unexistent and unsubscribed newsgroups\n */\nvoid nntp_clear_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *fp = NULL;\n  struct dirent *entry = NULL;\n  DIR *dp = NULL;\n\n  if (!nserv || !nserv->cacheable)\n    return;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, NULL);\n  dp = opendir(file);\n  if (dp)\n  {\n    mutt_str_strncat(file, sizeof(file), \"/\", 1);\n    fp = file + strlen(file);\n    while ((entry = readdir(dp)))\n    {\n      char *group = entry->d_name;\n      struct stat sb;\n      struct NntpData *nntp_data = NULL;\n      struct NntpData nntp_tmp;\n\n      if ((mutt_str_strcmp(group, \".\") == 0) || (mutt_str_strcmp(group, \"..\") == 0))\n        continue;\n      *fp = '\\0';\n      mutt_str_strncat(file, sizeof(file), group, strlen(group));\n      if (stat(file, &sb))\n        continue;\n\n#ifdef USE_HCACHE\n      if (S_ISREG(sb.st_mode))\n      {\n        char *ext = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (mutt_str_strcmp(ext, \".hcache\") != 0))\n          continue;\n        *ext = '\\0';\n      }\n      else\n#endif\n          if (!S_ISDIR(sb.st_mode))\n        continue;\n\n      nntp_data = mutt_hash_find(nserv->groups_hash, group);\n      if (!nntp_data)\n      {\n        nntp_data = &nntp_tmp;\n        nntp_data->nserv = nserv;\n        nntp_data->group = group;\n        nntp_data->bcache = NULL;\n      }\n      else if (nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed)\n        continue;\n\n      nntp_delete_group_cache(nntp_data);\n      if (S_ISDIR(sb.st_mode))\n      {\n        rmdir(file);\n        mutt_debug(2, \"%s\\n\", file);\n      }\n    }\n    closedir(dp);\n  }\n}\n\n/**\n * nntp_format_str - Expand the newsrc filename\n * @param[out] buf      Buffer in which to save string\n * @param[in]  buflen   Buffer length\n * @param[in]  col      Starting column\n * @param[in]  cols     Number of screen columns\n * @param[in]  op       printf-like operator, e.g. 't'\n * @param[in]  src      printf-like format string\n * @param[in]  prec     Field precision, e.g. \"-3.4\"\n * @param[in]  if_str   If condition is met, display this string\n * @param[in]  else_str Otherwise, display this string\n * @param[in]  data     Pointer to the mailbox Context\n * @param[in]  flags    Format flags\n * @retval src (unchanged)\n *\n * nntp_format_str() is a callback function for mutt_expando_format().\n *\n * | Expando | Description\n * |:--------|:--------------------------------------------------------\n * | \\%a     | Account url\n * | \\%p     | Port\n * | \\%P     | Port if specified\n * | \\%s     | News server name\n * | \\%S     | Url schema\n * | \\%u     | Username\n */\nconst char *nntp_format_str(char *buf, size_t buflen, size_t col, int cols, char op,\n                            const char *src, const char *prec, const char *if_str,\n                            const char *else_str, unsigned long data, enum FormatFlag flags)\n{\n  struct NntpServer *nserv = (struct NntpServer *) data;\n  struct Account *acct = &nserv->conn->account;\n  struct Url url;\n  char fn[SHORT_STRING], fmt[SHORT_STRING], *p = NULL;\n\n  switch (op)\n  {\n    case 'a':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, '/');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'p':\n      snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n      snprintf(buf, buflen, fmt, acct->port);\n      break;\n    case 'P':\n      *buf = '\\0';\n      if (acct->flags & MUTT_ACCT_PORT)\n      {\n        snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n        snprintf(buf, buflen, fmt, acct->port);\n      }\n      break;\n    case 's':\n      strncpy(fn, acct->host, sizeof(fn) - 1);\n      mutt_str_strlower(fn);\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'S':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, ':');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'u':\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, acct->user);\n      break;\n  }\n  return src;\n}\n\n/**\n * nntp_select_server - Open a connection to an NNTP server\n * @param server     Server URI\n * @param leave_lock Leave the server locked?\n * @retval ptr  NNTP server\n * @retval NULL Error\n *\n * Automatically loads a newsrc into memory, if necessary.  Checks the\n * size/mtime of a newsrc file, if it doesn't match, load again.  Hmm, if a\n * system has broken mtimes, this might mean the file is reloaded every time,\n * which we'd have to fix.\n */\nstruct NntpServer *nntp_select_server(char *server, bool leave_lock)\n{\n  char file[PATH_MAX];\n#ifdef USE_HCACHE\n  char *p = NULL;\n#endif\n  int rc;\n  struct Account acct;\n  struct NntpServer *nserv = NULL;\n  struct NntpData *nntp_data = NULL;\n  struct Connection *conn = NULL;\n  struct Url url;\n\n  if (!server || !*server)\n  {\n    mutt_error(_(\"No news server defined!\"));\n    return NULL;\n  }\n\n  /* create account from news server url */\n  acct.flags = 0;\n  acct.port = NNTP_PORT;\n  acct.type = MUTT_ACCT_TYPE_NNTP;\n  snprintf(file, sizeof(file), \"%s%s\", strstr(server, \"://\") ? \"\" : \"news://\", server);\n  if (url_parse(&url, file) < 0 || (url.path && *url.path) ||\n      !(url.scheme == U_NNTP || url.scheme == U_NNTPS) || !url.host ||\n      mutt_account_fromurl(&acct, &url) < 0)\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid news server specification!\"), server);\n    return NULL;\n  }\n  if (url.scheme == U_NNTPS)\n  {\n    acct.flags |= MUTT_ACCT_SSL;\n    acct.port = NNTP_SSL_PORT;\n  }\n  url_free(&url);\n\n  /* find connection by account */\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return NULL;\n  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)\n  {\n    conn->account.flags |= MUTT_ACCT_USER;\n    conn->account.user[0] = '\\0';\n  }\n\n  /* news server already exists */\n  nserv = conn->data;\n  if (nserv)\n  {\n    if (nserv->status == NNTP_BYE)\n      nserv->status = NNTP_NONE;\n    if (nntp_open_connection(nserv) < 0)\n      return NULL;\n\n    rc = nntp_newsrc_parse(nserv);\n    if (rc < 0)\n      return NULL;\n\n    /* check for new newsgroups */\n    if (!leave_lock && nntp_check_new_groups(nserv) < 0)\n      rc = -1;\n\n    /* .newsrc has been externally modified */\n    if (rc > 0)\n      nntp_clear_cache(nserv);\n    if (rc < 0 || !leave_lock)\n      nntp_newsrc_close(nserv);\n    return (rc < 0) ? NULL : nserv;\n  }\n\n  /* new news server */\n  nserv = mutt_mem_calloc(1, sizeof(struct NntpServer));\n  nserv->conn = conn;\n  nserv->groups_hash = mutt_hash_create(1009, 0);\n  mutt_hash_set_destructor(nserv->groups_hash, nntp_hash_destructor, 0);\n  nserv->groups_max = 16;\n  nserv->groups_list = mutt_mem_malloc(nserv->groups_max * sizeof(nntp_data));\n\n  rc = nntp_open_connection(nserv);\n\n  /* try to create cache directory and enable caching */\n  nserv->cacheable = false;\n  if (rc >= 0 && NewsCacheDir && *NewsCacheDir)\n  {\n    cache_expand(file, sizeof(file), &conn->account, NULL);\n    if (mutt_file_mkdir(file, S_IRWXU) < 0)\n    {\n      mutt_error(_(\"Can't create %s: %s.\"), file, strerror(errno));\n    }\n    nserv->cacheable = true;\n  }\n\n  /* load .newsrc */\n  if (rc >= 0)\n  {\n    mutt_expando_format(file, sizeof(file), 0, MuttIndexWindow->cols,\n                        NONULL(Newsrc), nntp_format_str, (unsigned long) nserv, 0);\n    mutt_expand_path(file, sizeof(file));\n    nserv->newsrc_file = mutt_str_strdup(file);\n    rc = nntp_newsrc_parse(nserv);\n  }\n  if (rc >= 0)\n  {\n    /* try to load list of newsgroups from cache */\n    if (nserv->cacheable && active_get_cache(nserv) == 0)\n      rc = nntp_check_new_groups(nserv);\n\n    /* load list of newsgroups from server */\n    else\n      rc = nntp_active_fetch(nserv, false);\n  }\n\n  if (rc >= 0)\n    nntp_clear_cache(nserv);\n\n#ifdef USE_HCACHE\n  /* check cache files */\n  if (rc >= 0 && nserv->cacheable)\n  {\n    struct dirent *entry = NULL;\n    DIR *dp = opendir(file);\n\n    if (dp)\n    {\n      while ((entry = readdir(dp)))\n      {\n        header_cache_t *hc = NULL;\n        void *hdata = NULL;\n        char *group = entry->d_name;\n\n        p = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (strcmp(p, \".hcache\") != 0))\n          continue;\n        *p = '\\0';\n        nntp_data = mutt_hash_find(nserv->groups_hash, group);\n        if (!nntp_data)\n          continue;\n\n        hc = nntp_hcache_open(nntp_data);\n        if (!hc)\n          continue;\n\n        /* fetch previous values of first and last */\n        hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n        if (hdata)\n        {\n          anum_t first, last;\n\n          if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n          {\n            if (nntp_data->deleted)\n            {\n              nntp_data->first_message = first;\n              nntp_data->last_message = last;\n            }\n            if (last >= nntp_data->first_message && last <= nntp_data->last_message)\n            {\n              nntp_data->last_cached = last;\n              mutt_debug(2, \"%s last_cached=%u\\n\", nntp_data->group, last);\n            }\n          }\n          mutt_hcache_free(hc, &hdata);\n        }\n        mutt_hcache_close(hc);\n      }\n      closedir(dp);\n    }\n  }\n#endif\n\n  if (rc < 0 || !leave_lock)\n    nntp_newsrc_close(nserv);\n\n  if (rc < 0)\n  {\n    mutt_hash_destroy(&nserv->groups_hash);\n    FREE(&nserv->groups_list);\n    FREE(&nserv->newsrc_file);\n    FREE(&nserv->authenticators);\n    FREE(&nserv);\n    mutt_socket_close(conn);\n    mutt_socket_free(conn);\n    return NULL;\n  }\n\n  conn->data = nserv;\n  return nserv;\n}\n\n/**\n * nntp_article_status - Get status of articles from .newsrc\n * @param ctx   Mailbox\n * @param hdr   Email Header\n * @param group Newsgroup\n * @param anum  Article number\n *\n * Full status flags are not supported by nntp, but we can fake some of them:\n * Read = a read message number is in the .newsrc\n * New = not read and not cached\n * Old = not read but cached\n */\nvoid nntp_article_status(struct Context *ctx, struct Header *hdr, char *group, anum_t anum)\n{\n  struct NntpData *nntp_data = ctx->data;\n\n  if (group)\n    nntp_data = mutt_hash_find(nntp_data->nserv->groups_hash, group);\n\n  if (!nntp_data)\n    return;\n\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    if ((anum >= nntp_data->newsrc_ent[i].first) &&\n        (anum <= nntp_data->newsrc_ent[i].last))\n    {\n      /* can't use mutt_set_flag() because mx_update_context()\n         didn't called yet */\n      hdr->read = true;\n      return;\n    }\n  }\n\n  /* article was not cached yet, it's new */\n  if (anum > nntp_data->last_cached)\n    return;\n\n  /* article isn't read but cached, it's old */\n  if (MarkOld)\n    hdr->old = true;\n}\n\n/**\n * mutt_newsgroup_subscribe - Subscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_subscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->subscribed = true;\n  if (!nntp_data->newsrc_ent)\n  {\n    nntp_data->newsrc_ent = mutt_mem_calloc(1, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = 0;\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_unsubscribe - Unsubscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_unsubscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  nntp_data->subscribed = false;\n  if (!SaveUnsubscribed)\n  {\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_catchup - Catchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_catchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->last_message;\n  }\n  nntp_data->unread = 0;\n  if (Context && Context->data == nntp_data)\n  {\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 1);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_uncatchup - Uncatchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_uncatchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->first_message - 1;\n  }\n  if (Context && Context->data == nntp_data)\n  {\n    nntp_data->unread = Context->msgcount;\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 0);\n  }\n  else\n  {\n    nntp_data->unread = nntp_data->last_message;\n    if (nntp_data->newsrc_ent)\n      nntp_data->unread -= nntp_data->newsrc_ent[0].last;\n  }\n  return nntp_data;\n}\n\n/**\n * nntp_buffy - Get first newsgroup with new messages\n * @param buf Buffer for result\n * @param len Length of buffer\n */\nvoid nntp_buffy(char *buf, size_t len)\n{\n  for (unsigned int i = 0; i < CurrentNewsSrv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = CurrentNewsSrv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->subscribed || !nntp_data->unread)\n      continue;\n\n    if (Context && Context->magic == MUTT_NNTP &&\n        (mutt_str_strcmp(nntp_data->group, ((struct NntpData *) Context->data)->group) == 0))\n    {\n      unsigned int unread = 0;\n\n      for (unsigned int j = 0; j < Context->msgcount; j++)\n        if (!Context->hdrs[j]->read && !Context->hdrs[j]->deleted)\n          unread++;\n      if (!unread)\n        continue;\n    }\n    mutt_str_strfcpy(buf, nntp_data->group, len);\n    break;\n  }\n}\n", "/**\n * @file\n * POP network mailbox\n *\n * @authors\n * Copyright (C) 2000-2002 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2006-2007,2009 Rocco Rutte <pdmef@gmx.net>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page pop POP network mailbox\n *\n * POP network mailbox\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"pop.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"ncrypt/ncrypt.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n#ifdef USE_HCACHE\n#define HC_FNAME \"neomutt\" /* filename for hcache as POP lacks paths */\n#define HC_FEXT \"hcache\"   /* extension for hcache as POP lacks paths */\n#endif\n\n/**\n * fetch_message - write line to file\n * @param line String to write\n * @param file FILE pointer to write to\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_message(char *line, void *file)\n{\n  FILE *f = (FILE *) file;\n\n  fputs(line, f);\n  if (fputc('\\n', f) == EOF)\n    return -1;\n\n  return 0;\n}\n\n/**\n * pop_read_header - Read header\n * @param pop_data POP data\n * @param h        Email header\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_read_header(struct PopData *pop_data, struct Header *h)\n{\n  int rc, index;\n  size_t length;\n  char buf[LONG_STRING];\n\n  FILE *f = mutt_file_mkstemp();\n  if (!f)\n  {\n    mutt_perror(\"mutt_file_mkstemp failed!\");\n    return -3;\n  }\n\n  snprintf(buf, sizeof(buf), \"LIST %d\\r\\n\", h->refno);\n  rc = pop_query(pop_data, buf, sizeof(buf));\n  if (rc == 0)\n  {\n    sscanf(buf, \"+OK %d %zu\", &index, &length);\n\n    snprintf(buf, sizeof(buf), \"TOP %d 0\\r\\n\", h->refno);\n    rc = pop_fetch_data(pop_data, buf, NULL, fetch_message, f);\n\n    if (pop_data->cmd_top == 2)\n    {\n      if (rc == 0)\n      {\n        pop_data->cmd_top = 1;\n\n        mutt_debug(1, \"set TOP capability\\n\");\n      }\n\n      if (rc == -2)\n      {\n        pop_data->cmd_top = 0;\n\n        mutt_debug(1, \"unset TOP capability\\n\");\n        snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n                 _(\"Command TOP is not supported by server.\"));\n      }\n    }\n  }\n\n  switch (rc)\n  {\n    case 0:\n    {\n      rewind(f);\n      h->env = mutt_rfc822_read_header(f, h, 0, 0);\n      h->content->length = length - h->content->offset + 1;\n      rewind(f);\n      while (!feof(f))\n      {\n        h->content->length--;\n        fgets(buf, sizeof(buf), f);\n      }\n      break;\n    }\n    case -2:\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    case -3:\n    {\n      mutt_error(_(\"Can't write header to temporary file!\"));\n      break;\n    }\n  }\n\n  mutt_file_fclose(&f);\n  return rc;\n}\n\n/**\n * fetch_uidl - parse UIDL\n * @param line String to parse\n * @param data Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n\n  return 0;\n}\n\n/**\n * msg_cache_check - Check the Body Cache for an ID\n * @param id     Cache ID\n * @param bcache Body cache\n * @param data   Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  /* message not found in context -> remove it from cache\n   * return the result of bcache, so we stop upon its first error\n   */\n  return mutt_bcache_del(bcache, id);\n}\n\n#ifdef USE_HCACHE\n/**\n * pop_hcache_namer - Create a header cache filename for a POP mailbox\n * @param path    Path of mailbox\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n */\nstatic int pop_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.\" HC_FEXT, path);\n}\n\n/**\n * pop_hcache_open - Open the header cache\n * @param pop_data POP server data\n * @param path     Path to the mailbox\n * @retval ptr Header cache\n */\nstatic header_cache_t *pop_hcache_open(struct PopData *pop_data, const char *path)\n{\n  struct Url url;\n  char p[LONG_STRING];\n\n  if (!pop_data || !pop_data->conn)\n    return mutt_hcache_open(HeaderCache, path, NULL);\n\n  mutt_account_tourl(&pop_data->conn->account, &url);\n  url.path = HC_FNAME;\n  url_tostring(&url, p, sizeof(p), U_PATH);\n  return mutt_hcache_open(HeaderCache, p, pop_hcache_namer);\n}\n#endif\n\n/**\n * pop_fetch_headers - Read headers\n * @param ctx Context\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: new\n       */\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}\n\n/**\n * pop_open_mailbox - open POP mailbox, fetch only headers\n * @param ctx Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_open_mailbox(struct Context *ctx)\n{\n  char buf[PATH_MAX];\n  struct Connection *conn = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n  struct Url url;\n\n  if (pop_parse_path(ctx->path, &acct))\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), ctx->path);\n    return -1;\n  }\n\n  mutt_account_tourl(&acct, &url);\n  url.path = NULL;\n  url_tostring(&url, buf, sizeof(buf), 0);\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return -1;\n\n  FREE(&ctx->path);\n  FREE(&ctx->realpath);\n  ctx->path = mutt_str_strdup(buf);\n  ctx->realpath = mutt_str_strdup(ctx->path);\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n  ctx->data = pop_data;\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  conn->data = pop_data;\n  pop_data->bcache = mutt_bcache_open(&acct, NULL);\n\n  /* init (hard-coded) ACL rights */\n  memset(ctx->rights, 0, sizeof(ctx->rights));\n  mutt_bit_set(ctx->rights, MUTT_ACL_SEEN);\n  mutt_bit_set(ctx->rights, MUTT_ACL_DELETE);\n#ifdef USE_HCACHE\n  /* flags are managed using header cache, so it only makes sense to\n   * enable them in that case */\n  mutt_bit_set(ctx->rights, MUTT_ACL_WRITE);\n#endif\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    ctx->size = pop_data->size;\n\n    mutt_message(_(\"Fetching list of messages...\"));\n\n    const int ret = pop_fetch_headers(ctx);\n\n    if (ret >= 0)\n      return 0;\n\n    if (ret < -1)\n    {\n      mutt_sleep(2);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_clear_cache - delete all cached messages\n * @param pop_data POP server data\n */\nstatic void pop_clear_cache(struct PopData *pop_data)\n{\n  if (!pop_data->clear_cache)\n    return;\n\n  mutt_debug(1, \"delete cached messages\\n\");\n\n  for (int i = 0; i < POP_CACHE_LEN; i++)\n  {\n    if (pop_data->cache[i].path)\n    {\n      unlink(pop_data->cache[i].path);\n      FREE(&pop_data->cache[i].path);\n    }\n  }\n}\n\n/**\n * pop_close_mailbox - close POP mailbox\n * @param ctx Mailbox Context\n * @retval 0 Always\n */\nstatic int pop_close_mailbox(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if (!pop_data)\n    return 0;\n\n  pop_logout(ctx);\n\n  if (pop_data->status != POP_NONE)\n    mutt_socket_close(pop_data->conn);\n\n  pop_data->status = POP_NONE;\n\n  pop_data->clear_cache = true;\n  pop_clear_cache(pop_data);\n\n  if (!pop_data->conn->data)\n    mutt_socket_free(pop_data->conn);\n\n  mutt_bcache_close(&pop_data->bcache);\n\n  return 0;\n}\n\n/**\n * pop_fetch_message - fetch message from POP server\n * @param ctx   Mailbox Context\n * @param msg   Message\n * @param msgno Message number\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n  if (msg->fp)\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n    if (!msg->fp)\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}\n\n/**\n * pop_close_message - Close POP Message\n * @param ctx Mailbox Context\n * @param msg Message\n * @retval 0   Success\n * @retval EOF Error, see errno\n */\nstatic int pop_close_message(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * pop_sync_mailbox - update POP mailbox, delete messages from server\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_check_mailbox - Check for new messages and fetch headers\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_check_mailbox(struct Context *ctx, int *index_hint)\n{\n  int ret;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if ((pop_data->check_time + PopCheckinterval) > time(NULL))\n    return 0;\n\n  pop_logout(ctx);\n\n  mutt_socket_close(pop_data->conn);\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  ctx->size = pop_data->size;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  ret = pop_fetch_headers(ctx);\n  pop_clear_cache(pop_data);\n\n  if (ret < 0)\n    return -1;\n\n  if (ret > 0)\n    return MUTT_NEW_MAIL;\n\n  return 0;\n}\n\n/**\n * pop_fetch_mail - Fetch messages and save them in $spoolfile\n */\nvoid pop_fetch_mail(void)\n{\n  char buffer[LONG_STRING];\n  char msgbuf[SHORT_STRING];\n  char *url = NULL, *p = NULL;\n  int delanswer, last = 0, msgs, bytes, rset = 0, ret;\n  struct Connection *conn = NULL;\n  struct Context ctx;\n  struct Message *msg = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n\n  if (!PopHost)\n  {\n    mutt_error(_(\"POP host is not defined.\"));\n    return;\n  }\n\n  url = p = mutt_mem_calloc(strlen(PopHost) + 7, sizeof(char));\n  if (url_check_scheme(PopHost) == U_UNKNOWN)\n  {\n    strcpy(url, \"pop://\");\n    p = strchr(url, '\\0');\n  }\n  strcpy(p, PopHost);\n\n  ret = pop_parse_path(url, &acct);\n  FREE(&url);\n  if (ret)\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), PopHost);\n    return;\n  }\n\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return;\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n\n  if (pop_open_connection(pop_data) < 0)\n  {\n    mutt_socket_free(pop_data->conn);\n    FREE(&pop_data);\n    return;\n  }\n\n  conn->data = pop_data;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  /* find out how many messages are in the mailbox. */\n  mutt_str_strfcpy(buffer, \"STAT\\r\\n\", sizeof(buffer));\n  ret = pop_query(pop_data, buffer, sizeof(buffer));\n  if (ret == -1)\n    goto fail;\n  if (ret == -2)\n  {\n    mutt_error(\"%s\", pop_data->err_msg);\n    goto finish;\n  }\n\n  sscanf(buffer, \"+OK %d %d\", &msgs, &bytes);\n\n  /* only get unread messages */\n  if (msgs > 0 && PopLast)\n  {\n    mutt_str_strfcpy(buffer, \"LAST\\r\\n\", sizeof(buffer));\n    ret = pop_query(pop_data, buffer, sizeof(buffer));\n    if (ret == -1)\n      goto fail;\n    if (ret == 0)\n      sscanf(buffer, \"+OK %d\", &last);\n  }\n\n  if (msgs <= last)\n  {\n    mutt_message(_(\"No new mail in POP mailbox.\"));\n    goto finish;\n  }\n\n  if (mx_mbox_open(NONULL(Spoolfile), MUTT_APPEND, &ctx) == NULL)\n    goto finish;\n\n  delanswer = query_quadoption(PopDelete, _(\"Delete messages from server?\"));\n\n  snprintf(msgbuf, sizeof(msgbuf),\n           ngettext(\"Reading new messages (%d byte)...\",\n                    \"Reading new messages (%d bytes)...\", bytes),\n           bytes);\n  mutt_message(\"%s\", msgbuf);\n\n  for (int i = last + 1; i <= msgs; i++)\n  {\n    msg = mx_msg_open_new(&ctx, NULL, MUTT_ADD_FROM);\n    if (!msg)\n      ret = -3;\n    else\n    {\n      snprintf(buffer, sizeof(buffer), \"RETR %d\\r\\n\", i);\n      ret = pop_fetch_data(pop_data, buffer, NULL, fetch_message, msg->fp);\n      if (ret == -3)\n        rset = 1;\n\n      if (ret == 0 && mx_msg_commit(&ctx, msg) != 0)\n      {\n        rset = 1;\n        ret = -3;\n      }\n\n      mx_msg_close(&ctx, &msg);\n    }\n\n    if (ret == 0 && delanswer == MUTT_YES)\n    {\n      /* delete the message on the server */\n      snprintf(buffer, sizeof(buffer), \"DELE %d\\r\\n\", i);\n      ret = pop_query(pop_data, buffer, sizeof(buffer));\n    }\n\n    if (ret == -1)\n    {\n      mx_mbox_close(&ctx, NULL);\n      goto fail;\n    }\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    if (ret == -3)\n    {\n      mutt_error(_(\"Error while writing mailbox!\"));\n      break;\n    }\n\n    /* L10N: The plural is picked by the second numerical argument, i.e.\n     * the %d right before 'messages', i.e. the total number of messages. */\n    mutt_message(ngettext(\"%s [%d of %d message read]\",\n                          \"%s [%d of %d messages read]\", msgs - last),\n                 msgbuf, i - last, msgs - last);\n  }\n\n  mx_mbox_close(&ctx, NULL);\n\n  if (rset)\n  {\n    /* make sure no messages get deleted */\n    mutt_str_strfcpy(buffer, \"RSET\\r\\n\", sizeof(buffer));\n    if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n      goto fail;\n  }\n\nfinish:\n  /* exit gracefully */\n  mutt_str_strfcpy(buffer, \"QUIT\\r\\n\", sizeof(buffer));\n  if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n    goto fail;\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n  return;\n\nfail:\n  mutt_error(_(\"Server closed connection!\"));\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n}\n\n// clang-format off\n/**\n * mx_pop_ops - Mailbox callback functions for POP mailboxes\n */\nstruct MxOps mx_pop_ops = {\n  .mbox_open        = pop_open_mailbox,\n  .mbox_open_append = NULL,\n  .mbox_check       = pop_check_mailbox,\n  .mbox_sync        = pop_sync_mailbox,\n  .mbox_close       = pop_close_mailbox,\n  .msg_open         = pop_fetch_message,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = pop_close_message,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n};\n// clang-format on\n"], "fixing_code": ["/**\n * @file\n * Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page newsrc Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * Read/parse/write an NNTP config file of subscribed newsgroups\n */\n\n#include \"config.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"format_flags.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mutt_window.h\"\n#include \"mx.h\"\n#include \"nntp.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"sort.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct BodyCache;\n\n/**\n * nntp_data_find - Find NntpData for given newsgroup or add it\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstatic struct NntpData *nntp_data_find(struct NntpServer *nserv, const char *group)\n{\n  struct NntpData *nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (nntp_data)\n    return nntp_data;\n\n  size_t len = strlen(group) + 1;\n  /* create NntpData structure and add it to hash */\n  nntp_data = mutt_mem_calloc(1, sizeof(struct NntpData) + len);\n  nntp_data->group = (char *) nntp_data + sizeof(struct NntpData);\n  mutt_str_strfcpy(nntp_data->group, group, len);\n  nntp_data->nserv = nserv;\n  nntp_data->deleted = true;\n  mutt_hash_insert(nserv->groups_hash, nntp_data->group, nntp_data);\n\n  /* add NntpData to list */\n  if (nserv->groups_num >= nserv->groups_max)\n  {\n    nserv->groups_max *= 2;\n    mutt_mem_realloc(&nserv->groups_list, nserv->groups_max * sizeof(nntp_data));\n  }\n  nserv->groups_list[nserv->groups_num++] = nntp_data;\n\n  return nntp_data;\n}\n\n/**\n * nntp_acache_free - Remove all temporarily cache files\n * @param nntp_data NNTP data\n */\nvoid nntp_acache_free(struct NntpData *nntp_data)\n{\n  for (int i = 0; i < NNTP_ACACHE_LEN; i++)\n  {\n    if (nntp_data->acache[i].path)\n    {\n      unlink(nntp_data->acache[i].path);\n      FREE(&nntp_data->acache[i].path);\n    }\n  }\n}\n\n/**\n * nntp_data_free - Free NntpData, used to destroy hash elements\n * @param data NNTP data\n */\nvoid nntp_data_free(void *data)\n{\n  struct NntpData *nntp_data = data;\n\n  if (!nntp_data)\n    return;\n  nntp_acache_free(nntp_data);\n  mutt_bcache_close(&nntp_data->bcache);\n  FREE(&nntp_data->newsrc_ent);\n  FREE(&nntp_data->desc);\n  FREE(&data);\n}\n\n/**\n * nntp_hash_destructor - Free our hash table data\n * @param type Type (UNUSED)\n * @param obj  NNTP data\n * @param data Data (UNUSED)\n */\nvoid nntp_hash_destructor(int type, void *obj, intptr_t data)\n{\n  nntp_data_free(obj);\n}\n\n/**\n * nntp_newsrc_close - Unlock and close .newsrc file\n * @param nserv NNTP server\n */\nvoid nntp_newsrc_close(struct NntpServer *nserv)\n{\n  if (!nserv->newsrc_fp)\n    return;\n\n  mutt_debug(1, \"Unlocking %s\\n\", nserv->newsrc_file);\n  mutt_file_unlock(fileno(nserv->newsrc_fp));\n  mutt_file_fclose(&nserv->newsrc_fp);\n}\n\n/**\n * nntp_group_unread_stat - Count number of unread articles using .newsrc data\n * @param nntp_data NNTP data\n */\nvoid nntp_group_unread_stat(struct NntpData *nntp_data)\n{\n  nntp_data->unread = 0;\n  if (nntp_data->last_message == 0 || nntp_data->first_message > nntp_data->last_message)\n    return;\n\n  nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    anum_t first = nntp_data->newsrc_ent[i].first;\n    if (first < nntp_data->first_message)\n      first = nntp_data->first_message;\n    anum_t last = nntp_data->newsrc_ent[i].last;\n    if (last > nntp_data->last_message)\n      last = nntp_data->last_message;\n    if (first <= last)\n      nntp_data->unread -= last - first + 1;\n  }\n}\n\n/**\n * nntp_newsrc_parse - Parse .newsrc file\n * @param nserv NNTP server\n * @retval  0 Not changed\n * @retval  1 Parsed\n * @retval -1 Error\n */\nint nntp_newsrc_parse(struct NntpServer *nserv)\n{\n  char *line = NULL;\n  struct stat sb;\n\n  if (nserv->newsrc_fp)\n  {\n    /* if we already have a handle, close it and reopen */\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n  else\n  {\n    /* if file doesn't exist, create it */\n    nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"a\");\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n\n  /* open .newsrc */\n  nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"r\");\n  if (!nserv->newsrc_fp)\n  {\n    mutt_perror(nserv->newsrc_file);\n    return -1;\n  }\n\n  /* lock it */\n  mutt_debug(1, \"Locking %s\\n\", nserv->newsrc_file);\n  if (mutt_file_lock(fileno(nserv->newsrc_fp), 0, 1))\n  {\n    mutt_file_fclose(&nserv->newsrc_fp);\n    return -1;\n  }\n\n  if (stat(nserv->newsrc_file, &sb))\n  {\n    mutt_perror(nserv->newsrc_file);\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n\n  if (nserv->size == sb.st_size && nserv->mtime == sb.st_mtime)\n    return 0;\n\n  nserv->size = sb.st_size;\n  nserv->mtime = sb.st_mtime;\n  nserv->newsrc_modified = true;\n  mutt_debug(1, \"Parsing %s\\n\", nserv->newsrc_file);\n\n  /* .newsrc has been externally modified or hasn't been loaded yet */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data)\n      continue;\n\n    nntp_data->subscribed = false;\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n\n  line = mutt_mem_malloc(sb.st_size + 1);\n  while (sb.st_size && fgets(line, sb.st_size + 1, nserv->newsrc_fp))\n  {\n    char *b = NULL, *h = NULL;\n    unsigned int j = 1;\n    bool subs = false;\n\n    /* find end of newsgroup name */\n    char *p = strpbrk(line, \":!\");\n    if (!p)\n      continue;\n\n    /* \":\" - subscribed, \"!\" - unsubscribed */\n    if (*p == ':')\n      subs = true;\n    *p++ = '\\0';\n\n    /* get newsgroup data */\n    struct NntpData *nntp_data = nntp_data_find(nserv, line);\n    FREE(&nntp_data->newsrc_ent);\n\n    /* count number of entries */\n    b = p;\n    while (*b)\n      if (*b++ == ',')\n        j++;\n    nntp_data->newsrc_ent = mutt_mem_calloc(j, sizeof(struct NewsrcEntry));\n    nntp_data->subscribed = subs;\n\n    /* parse entries */\n    j = 0;\n    while (p)\n    {\n      b = p;\n\n      /* find end of entry */\n      p = strchr(p, ',');\n      if (p)\n        *p++ = '\\0';\n\n      /* first-last or single number */\n      h = strchr(b, '-');\n      if (h)\n        *h++ = '\\0';\n      else\n        h = b;\n\n      if (sscanf(b, ANUM, &nntp_data->newsrc_ent[j].first) == 1 &&\n          sscanf(h, ANUM, &nntp_data->newsrc_ent[j].last) == 1)\n      {\n        j++;\n      }\n    }\n    if (j == 0)\n    {\n      nntp_data->newsrc_ent[j].first = 1;\n      nntp_data->newsrc_ent[j].last = 0;\n      j++;\n    }\n    if (nntp_data->last_message == 0)\n      nntp_data->last_message = nntp_data->newsrc_ent[j - 1].last;\n    nntp_data->newsrc_len = j;\n    mutt_mem_realloc(&nntp_data->newsrc_ent, j * sizeof(struct NewsrcEntry));\n    nntp_group_unread_stat(nntp_data);\n    mutt_debug(2, \"%s\\n\", nntp_data->group);\n  }\n  FREE(&line);\n  return 1;\n}\n\n/**\n * nntp_newsrc_gen_entries - Generate array of .newsrc entries\n * @param ctx Mailbox\n */\nvoid nntp_newsrc_gen_entries(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data;\n  anum_t last = 0, first = 1;\n  bool series;\n  int save_sort = SORT_ORDER;\n  unsigned int entries;\n\n  if (Sort != SORT_ORDER)\n  {\n    save_sort = Sort;\n    Sort = SORT_ORDER;\n    mutt_sort_headers(ctx, 0);\n  }\n\n  entries = nntp_data->newsrc_len;\n  if (!entries)\n  {\n    entries = 5;\n    nntp_data->newsrc_ent = mutt_mem_calloc(entries, sizeof(struct NewsrcEntry));\n  }\n\n  /* Set up to fake initial sequence from 1 to the article before the\n   * first article in our list */\n  nntp_data->newsrc_len = 0;\n  series = true;\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* search for first unread */\n    if (series)\n    {\n      /* We don't actually check sequential order, since we mark\n       * \"missing\" entries as read/deleted */\n      last = NHDR(ctx->hdrs[i])->article_num;\n      if (last >= nntp_data->first_message && !ctx->hdrs[i]->deleted &&\n          !ctx->hdrs[i]->read)\n      {\n        if (nntp_data->newsrc_len >= entries)\n        {\n          entries *= 2;\n          mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n        }\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].last = last - 1;\n        nntp_data->newsrc_len++;\n        series = false;\n      }\n    }\n\n    /* search for first read */\n    else\n    {\n      if (ctx->hdrs[i]->deleted || ctx->hdrs[i]->read)\n      {\n        first = last + 1;\n        series = true;\n      }\n      last = NHDR(ctx->hdrs[i])->article_num;\n    }\n  }\n\n  if (series && first <= nntp_data->last_loaded)\n  {\n    if (nntp_data->newsrc_len >= entries)\n    {\n      entries++;\n      mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n    }\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].last = nntp_data->last_loaded;\n    nntp_data->newsrc_len++;\n  }\n  mutt_mem_realloc(&nntp_data->newsrc_ent, nntp_data->newsrc_len * sizeof(struct NewsrcEntry));\n\n  if (save_sort != Sort)\n  {\n    Sort = save_sort;\n    mutt_sort_headers(ctx, 0);\n  }\n}\n\n/**\n * update_file - Update file with new contents\n * @param filename File to update\n * @param buf      New context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int update_file(char *filename, char *buf)\n{\n  FILE *fp = NULL;\n  char tmpfile[PATH_MAX];\n  int rc = -1;\n\n  while (true)\n  {\n    snprintf(tmpfile, sizeof(tmpfile), \"%s.tmp\", filename);\n    fp = mutt_file_fopen(tmpfile, \"w\");\n    if (!fp)\n    {\n      mutt_perror(tmpfile);\n      *tmpfile = '\\0';\n      break;\n    }\n    if (fputs(buf, fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      break;\n    }\n    if (mutt_file_fclose(&fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      fp = NULL;\n      break;\n    }\n    fp = NULL;\n    if (rename(tmpfile, filename) < 0)\n    {\n      mutt_perror(filename);\n      break;\n    }\n    *tmpfile = '\\0';\n    rc = 0;\n    break;\n  }\n  if (fp)\n    mutt_file_fclose(&fp);\n  if (*tmpfile)\n    unlink(tmpfile);\n  return rc;\n}\n\n/**\n * nntp_newsrc_update - Update .newsrc file\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_newsrc_update(struct NntpServer *nserv)\n{\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc = -1;\n\n  if (!nserv)\n    return -1;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  off = 0;\n\n  /* we will generate full newsrc here */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->newsrc_ent)\n      continue;\n\n    /* write newsgroup name */\n    if (off + strlen(nntp_data->group) + 3 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s%c \", nntp_data->group,\n             nntp_data->subscribed ? ':' : '!');\n    off += strlen(buf + off);\n\n    /* write entries */\n    for (unsigned int j = 0; j < nntp_data->newsrc_len; j++)\n    {\n      if (off + LONG_STRING > buflen)\n      {\n        buflen *= 2;\n        mutt_mem_realloc(&buf, buflen);\n      }\n      if (j)\n        buf[off++] = ',';\n      if (nntp_data->newsrc_ent[j].first == nntp_data->newsrc_ent[j].last)\n        snprintf(buf + off, buflen - off, \"%u\", nntp_data->newsrc_ent[j].first);\n      else if (nntp_data->newsrc_ent[j].first < nntp_data->newsrc_ent[j].last)\n      {\n        snprintf(buf + off, buflen - off, \"%u-%u\",\n                 nntp_data->newsrc_ent[j].first, nntp_data->newsrc_ent[j].last);\n      }\n      off += strlen(buf + off);\n    }\n    buf[off++] = '\\n';\n  }\n  buf[off] = '\\0';\n\n  /* newrc being fully rewritten */\n  mutt_debug(1, \"Updating %s\\n\", nserv->newsrc_file);\n  if (nserv->newsrc_file && update_file(nserv->newsrc_file, buf) == 0)\n  {\n    struct stat sb;\n\n    rc = stat(nserv->newsrc_file, &sb);\n    if (rc == 0)\n    {\n      nserv->size = sb.st_size;\n      nserv->mtime = sb.st_mtime;\n    }\n    else\n    {\n      mutt_perror(nserv->newsrc_file);\n    }\n  }\n  FREE(&buf);\n  return rc;\n}\n\n/**\n * cache_expand - Make fully qualified cache file name\n * @param dst    Buffer for filename\n * @param dstlen Length of buffer\n * @param acct   Account\n * @param src    Path to add to the URL\n */\nstatic void cache_expand(char *dst, size_t dstlen, struct Account *acct, char *src)\n{\n  char *c = NULL;\n  char file[PATH_MAX];\n\n  /* server subdirectory */\n  if (acct)\n  {\n    struct Url url;\n\n    mutt_account_tourl(acct, &url);\n    url.path = src;\n    url_tostring(&url, file, sizeof(file), U_PATH);\n  }\n  else\n    mutt_str_strfcpy(file, src ? src : \"\", sizeof(file));\n\n  snprintf(dst, dstlen, \"%s/%s\", NewsCacheDir, file);\n\n  /* remove trailing slash */\n  c = dst + strlen(dst) - 1;\n  if (*c == '/')\n    *c = '\\0';\n  mutt_expand_path(dst, dstlen);\n  mutt_encode_path(dst, dstlen, dst);\n}\n\n/**\n * nntp_expand_path - Make fully qualified url from newsgroup name\n * @param line String containing newsgroup name\n * @param len  Length of string\n * @param acct Account to save result\n */\nvoid nntp_expand_path(char *line, size_t len, struct Account *acct)\n{\n  struct Url url;\n\n  mutt_account_tourl(acct, &url);\n  url.path = mutt_str_strdup(line);\n  url_tostring(&url, line, len, 0);\n  FREE(&url.path);\n}\n\n/**\n * nntp_add_group - Parse newsgroup\n * @param line String to parse\n * @param data NNTP data\n * @retval 0 Always\n */\nint nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING] = \"\";\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n\n  if (!nserv || !line)\n    return 0;\n\n  /* These sscanf limits must match the sizes of the group and desc arrays */\n  if (sscanf(line, \"%1023s \" ANUM \" \" ANUM \" %c %8191[^\\n]\", group, &last, &first, &mod, desc) < 4)\n  {\n    mutt_debug(4, \"Cannot parse server line: %s\\n\", line);\n    return 0;\n  }\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}\n\n/**\n * active_get_cache - Load list of all newsgroups from cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int active_get_cache(struct NntpServer *nserv)\n{\n  char buf[HUGE_STRING];\n  char file[PATH_MAX];\n  time_t t;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Parsing %s\\n\", file);\n  FILE *fp = mutt_file_fopen(file, \"r\");\n  if (!fp)\n    return -1;\n\n  if (fgets(buf, sizeof(buf), fp) == NULL || sscanf(buf, \"%ld%s\", &t, file) != 1 || t == 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  nserv->newgroups_time = t;\n\n  mutt_message(_(\"Loading list of groups from cache...\"));\n  while (fgets(buf, sizeof(buf), fp))\n    nntp_add_group(buf, nserv);\n  nntp_add_group(NULL, NULL);\n  mutt_file_fclose(&fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_active_save_cache - Save list of all newsgroups to cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_save_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc;\n\n  if (!nserv->cacheable)\n    return 0;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  snprintf(buf, buflen, \"%lu\\n\", (unsigned long) nserv->newgroups_time);\n  off = strlen(buf);\n\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || nntp_data->deleted)\n      continue;\n\n    if (off + strlen(nntp_data->group) + (nntp_data->desc ? strlen(nntp_data->desc) : 0) + 50 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s %u %u %c%s%s\\n\", nntp_data->group,\n             nntp_data->last_message, nntp_data->first_message,\n             nntp_data->allowed ? 'y' : 'n', nntp_data->desc ? \" \" : \"\",\n             nntp_data->desc ? nntp_data->desc : \"\");\n    off += strlen(buf + off);\n  }\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Updating %s\\n\", file);\n  rc = update_file(file, buf);\n  FREE(&buf);\n  return rc;\n}\n\n#ifdef USE_HCACHE\n/**\n * nntp_hcache_namer - Compose hcache file names\n * @param path    Path of message\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n *\n * Used by mutt_hcache_open() to compose hcache file name\n */\nstatic int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  int count = snprintf(dest, destlen, \"%s.hcache\", path);\n\n  /* Strip out any directories in the path */\n  char *first = strchr(dest, '/');\n  char *last = strrchr(dest, '/');\n  if (first && last && (last > first))\n  {\n    memmove(first, last, strlen(last) + 1);\n    count -= (last - first);\n  }\n\n  return count;\n}\n\n/**\n * nntp_hcache_open - Open newsgroup hcache\n * @param nntp_data NNTP data\n * @retval ptr  Header cache\n * @retval NULL Error\n */\nheader_cache_t *nntp_hcache_open(struct NntpData *nntp_data)\n{\n  struct Url url;\n  char file[PATH_MAX];\n\n  if (!nntp_data->nserv || !nntp_data->nserv->cacheable ||\n      !nntp_data->nserv->conn || !nntp_data->group ||\n      !(nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed))\n  {\n    return NULL;\n  }\n\n  mutt_account_tourl(&nntp_data->nserv->conn->account, &url);\n  url.path = nntp_data->group;\n  url_tostring(&url, file, sizeof(file), U_PATH);\n  return mutt_hcache_open(NewsCacheDir, file, nntp_hcache_namer);\n}\n\n/**\n * nntp_hcache_update - Remove stale cached headers\n * @param nntp_data NNTP data\n * @param hc        Header cache\n */\nvoid nntp_hcache_update(struct NntpData *nntp_data, header_cache_t *hc)\n{\n  char buf[16];\n  bool old = false;\n  void *hdata = NULL;\n  anum_t first = 0, last = 0;\n\n  if (!hc)\n    return;\n\n  /* fetch previous values of first and last */\n  hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n  if (hdata)\n  {\n    mutt_debug(2, \"mutt_hcache_fetch index: %s\\n\", (char *) hdata);\n    if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n    {\n      old = true;\n      nntp_data->last_cached = last;\n\n      /* clean removed headers from cache */\n      for (anum_t current = first; current <= last; current++)\n      {\n        if (current >= nntp_data->first_message && current <= nntp_data->last_message)\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n        mutt_hcache_delete(hc, buf, strlen(buf));\n      }\n    }\n    mutt_hcache_free(hc, &hdata);\n  }\n\n  /* store current values of first and last */\n  if (!old || nntp_data->first_message != first || nntp_data->last_message != last)\n  {\n    snprintf(buf, sizeof(buf), \"%u %u\", nntp_data->first_message, nntp_data->last_message);\n    mutt_debug(2, \"mutt_hcache_store index: %s\\n\", buf);\n    mutt_hcache_store_raw(hc, \"index\", 5, buf, strlen(buf));\n  }\n}\n#endif\n\n/**\n * nntp_bcache_delete - Remove bcache file\n * @param id     Body cache ID\n * @param bcache Body cache\n * @param data   NNTP data\n * @retval 0 Always\n */\nstatic int nntp_bcache_delete(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct NntpData *nntp_data = data;\n  anum_t anum;\n  char c;\n\n  if (!nntp_data || sscanf(id, ANUM \"%c\", &anum, &c) != 1 ||\n      anum < nntp_data->first_message || anum > nntp_data->last_message)\n  {\n    if (nntp_data)\n      mutt_debug(2, \"mutt_bcache_del %s\\n\", id);\n    mutt_bcache_del(bcache, id);\n  }\n  return 0;\n}\n\n/**\n * nntp_bcache_update - Remove stale cached messages\n * @param nntp_data NNTP data\n */\nvoid nntp_bcache_update(struct NntpData *nntp_data)\n{\n  mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, nntp_data);\n}\n\n/**\n * nntp_delete_group_cache - Remove hcache and bcache of newsgroup\n * @param nntp_data NNTP data\n */\nvoid nntp_delete_group_cache(struct NntpData *nntp_data)\n{\n  if (!nntp_data || !nntp_data->nserv || !nntp_data->nserv->cacheable)\n    return;\n\n#ifdef USE_HCACHE\n  char file[PATH_MAX];\n  nntp_hcache_namer(nntp_data->group, file, sizeof(file));\n  cache_expand(file, sizeof(file), &nntp_data->nserv->conn->account, file);\n  unlink(file);\n  nntp_data->last_cached = 0;\n  mutt_debug(2, \"%s\\n\", file);\n#endif\n\n  if (!nntp_data->bcache)\n  {\n    nntp_data->bcache =\n        mutt_bcache_open(&nntp_data->nserv->conn->account, nntp_data->group);\n  }\n  if (nntp_data->bcache)\n  {\n    mutt_debug(2, \"%s/*\\n\", nntp_data->group);\n    mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, NULL);\n    mutt_bcache_close(&nntp_data->bcache);\n  }\n}\n\n/**\n * nntp_clear_cache - Clear the NNTP cache\n * @param nserv NNTP server\n *\n * Remove hcache and bcache of all unexistent and unsubscribed newsgroups\n */\nvoid nntp_clear_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *fp = NULL;\n  struct dirent *entry = NULL;\n  DIR *dp = NULL;\n\n  if (!nserv || !nserv->cacheable)\n    return;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, NULL);\n  dp = opendir(file);\n  if (dp)\n  {\n    mutt_str_strncat(file, sizeof(file), \"/\", 1);\n    fp = file + strlen(file);\n    while ((entry = readdir(dp)))\n    {\n      char *group = entry->d_name;\n      struct stat sb;\n      struct NntpData *nntp_data = NULL;\n      struct NntpData nntp_tmp;\n\n      if ((mutt_str_strcmp(group, \".\") == 0) || (mutt_str_strcmp(group, \"..\") == 0))\n        continue;\n      *fp = '\\0';\n      mutt_str_strncat(file, sizeof(file), group, strlen(group));\n      if (stat(file, &sb))\n        continue;\n\n#ifdef USE_HCACHE\n      if (S_ISREG(sb.st_mode))\n      {\n        char *ext = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (mutt_str_strcmp(ext, \".hcache\") != 0))\n          continue;\n        *ext = '\\0';\n      }\n      else\n#endif\n          if (!S_ISDIR(sb.st_mode))\n        continue;\n\n      nntp_data = mutt_hash_find(nserv->groups_hash, group);\n      if (!nntp_data)\n      {\n        nntp_data = &nntp_tmp;\n        nntp_data->nserv = nserv;\n        nntp_data->group = group;\n        nntp_data->bcache = NULL;\n      }\n      else if (nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed)\n        continue;\n\n      nntp_delete_group_cache(nntp_data);\n      if (S_ISDIR(sb.st_mode))\n      {\n        rmdir(file);\n        mutt_debug(2, \"%s\\n\", file);\n      }\n    }\n    closedir(dp);\n  }\n}\n\n/**\n * nntp_format_str - Expand the newsrc filename\n * @param[out] buf      Buffer in which to save string\n * @param[in]  buflen   Buffer length\n * @param[in]  col      Starting column\n * @param[in]  cols     Number of screen columns\n * @param[in]  op       printf-like operator, e.g. 't'\n * @param[in]  src      printf-like format string\n * @param[in]  prec     Field precision, e.g. \"-3.4\"\n * @param[in]  if_str   If condition is met, display this string\n * @param[in]  else_str Otherwise, display this string\n * @param[in]  data     Pointer to the mailbox Context\n * @param[in]  flags    Format flags\n * @retval src (unchanged)\n *\n * nntp_format_str() is a callback function for mutt_expando_format().\n *\n * | Expando | Description\n * |:--------|:--------------------------------------------------------\n * | \\%a     | Account url\n * | \\%p     | Port\n * | \\%P     | Port if specified\n * | \\%s     | News server name\n * | \\%S     | Url schema\n * | \\%u     | Username\n */\nconst char *nntp_format_str(char *buf, size_t buflen, size_t col, int cols, char op,\n                            const char *src, const char *prec, const char *if_str,\n                            const char *else_str, unsigned long data, enum FormatFlag flags)\n{\n  struct NntpServer *nserv = (struct NntpServer *) data;\n  struct Account *acct = &nserv->conn->account;\n  struct Url url;\n  char fn[SHORT_STRING], fmt[SHORT_STRING], *p = NULL;\n\n  switch (op)\n  {\n    case 'a':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, '/');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'p':\n      snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n      snprintf(buf, buflen, fmt, acct->port);\n      break;\n    case 'P':\n      *buf = '\\0';\n      if (acct->flags & MUTT_ACCT_PORT)\n      {\n        snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n        snprintf(buf, buflen, fmt, acct->port);\n      }\n      break;\n    case 's':\n      strncpy(fn, acct->host, sizeof(fn) - 1);\n      mutt_str_strlower(fn);\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'S':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, ':');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'u':\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, acct->user);\n      break;\n  }\n  return src;\n}\n\n/**\n * nntp_select_server - Open a connection to an NNTP server\n * @param server     Server URI\n * @param leave_lock Leave the server locked?\n * @retval ptr  NNTP server\n * @retval NULL Error\n *\n * Automatically loads a newsrc into memory, if necessary.  Checks the\n * size/mtime of a newsrc file, if it doesn't match, load again.  Hmm, if a\n * system has broken mtimes, this might mean the file is reloaded every time,\n * which we'd have to fix.\n */\nstruct NntpServer *nntp_select_server(char *server, bool leave_lock)\n{\n  char file[PATH_MAX];\n#ifdef USE_HCACHE\n  char *p = NULL;\n#endif\n  int rc;\n  struct Account acct;\n  struct NntpServer *nserv = NULL;\n  struct NntpData *nntp_data = NULL;\n  struct Connection *conn = NULL;\n  struct Url url;\n\n  if (!server || !*server)\n  {\n    mutt_error(_(\"No news server defined!\"));\n    return NULL;\n  }\n\n  /* create account from news server url */\n  acct.flags = 0;\n  acct.port = NNTP_PORT;\n  acct.type = MUTT_ACCT_TYPE_NNTP;\n  snprintf(file, sizeof(file), \"%s%s\", strstr(server, \"://\") ? \"\" : \"news://\", server);\n  if (url_parse(&url, file) < 0 || (url.path && *url.path) ||\n      !(url.scheme == U_NNTP || url.scheme == U_NNTPS) || !url.host ||\n      mutt_account_fromurl(&acct, &url) < 0)\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid news server specification!\"), server);\n    return NULL;\n  }\n  if (url.scheme == U_NNTPS)\n  {\n    acct.flags |= MUTT_ACCT_SSL;\n    acct.port = NNTP_SSL_PORT;\n  }\n  url_free(&url);\n\n  /* find connection by account */\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return NULL;\n  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)\n  {\n    conn->account.flags |= MUTT_ACCT_USER;\n    conn->account.user[0] = '\\0';\n  }\n\n  /* news server already exists */\n  nserv = conn->data;\n  if (nserv)\n  {\n    if (nserv->status == NNTP_BYE)\n      nserv->status = NNTP_NONE;\n    if (nntp_open_connection(nserv) < 0)\n      return NULL;\n\n    rc = nntp_newsrc_parse(nserv);\n    if (rc < 0)\n      return NULL;\n\n    /* check for new newsgroups */\n    if (!leave_lock && nntp_check_new_groups(nserv) < 0)\n      rc = -1;\n\n    /* .newsrc has been externally modified */\n    if (rc > 0)\n      nntp_clear_cache(nserv);\n    if (rc < 0 || !leave_lock)\n      nntp_newsrc_close(nserv);\n    return (rc < 0) ? NULL : nserv;\n  }\n\n  /* new news server */\n  nserv = mutt_mem_calloc(1, sizeof(struct NntpServer));\n  nserv->conn = conn;\n  nserv->groups_hash = mutt_hash_create(1009, 0);\n  mutt_hash_set_destructor(nserv->groups_hash, nntp_hash_destructor, 0);\n  nserv->groups_max = 16;\n  nserv->groups_list = mutt_mem_malloc(nserv->groups_max * sizeof(nntp_data));\n\n  rc = nntp_open_connection(nserv);\n\n  /* try to create cache directory and enable caching */\n  nserv->cacheable = false;\n  if (rc >= 0 && NewsCacheDir && *NewsCacheDir)\n  {\n    cache_expand(file, sizeof(file), &conn->account, NULL);\n    if (mutt_file_mkdir(file, S_IRWXU) < 0)\n    {\n      mutt_error(_(\"Can't create %s: %s.\"), file, strerror(errno));\n    }\n    nserv->cacheable = true;\n  }\n\n  /* load .newsrc */\n  if (rc >= 0)\n  {\n    mutt_expando_format(file, sizeof(file), 0, MuttIndexWindow->cols,\n                        NONULL(Newsrc), nntp_format_str, (unsigned long) nserv, 0);\n    mutt_expand_path(file, sizeof(file));\n    nserv->newsrc_file = mutt_str_strdup(file);\n    rc = nntp_newsrc_parse(nserv);\n  }\n  if (rc >= 0)\n  {\n    /* try to load list of newsgroups from cache */\n    if (nserv->cacheable && active_get_cache(nserv) == 0)\n      rc = nntp_check_new_groups(nserv);\n\n    /* load list of newsgroups from server */\n    else\n      rc = nntp_active_fetch(nserv, false);\n  }\n\n  if (rc >= 0)\n    nntp_clear_cache(nserv);\n\n#ifdef USE_HCACHE\n  /* check cache files */\n  if (rc >= 0 && nserv->cacheable)\n  {\n    struct dirent *entry = NULL;\n    DIR *dp = opendir(file);\n\n    if (dp)\n    {\n      while ((entry = readdir(dp)))\n      {\n        header_cache_t *hc = NULL;\n        void *hdata = NULL;\n        char *group = entry->d_name;\n\n        p = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (strcmp(p, \".hcache\") != 0))\n          continue;\n        *p = '\\0';\n        nntp_data = mutt_hash_find(nserv->groups_hash, group);\n        if (!nntp_data)\n          continue;\n\n        hc = nntp_hcache_open(nntp_data);\n        if (!hc)\n          continue;\n\n        /* fetch previous values of first and last */\n        hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n        if (hdata)\n        {\n          anum_t first, last;\n\n          if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n          {\n            if (nntp_data->deleted)\n            {\n              nntp_data->first_message = first;\n              nntp_data->last_message = last;\n            }\n            if (last >= nntp_data->first_message && last <= nntp_data->last_message)\n            {\n              nntp_data->last_cached = last;\n              mutt_debug(2, \"%s last_cached=%u\\n\", nntp_data->group, last);\n            }\n          }\n          mutt_hcache_free(hc, &hdata);\n        }\n        mutt_hcache_close(hc);\n      }\n      closedir(dp);\n    }\n  }\n#endif\n\n  if (rc < 0 || !leave_lock)\n    nntp_newsrc_close(nserv);\n\n  if (rc < 0)\n  {\n    mutt_hash_destroy(&nserv->groups_hash);\n    FREE(&nserv->groups_list);\n    FREE(&nserv->newsrc_file);\n    FREE(&nserv->authenticators);\n    FREE(&nserv);\n    mutt_socket_close(conn);\n    mutt_socket_free(conn);\n    return NULL;\n  }\n\n  conn->data = nserv;\n  return nserv;\n}\n\n/**\n * nntp_article_status - Get status of articles from .newsrc\n * @param ctx   Mailbox\n * @param hdr   Email Header\n * @param group Newsgroup\n * @param anum  Article number\n *\n * Full status flags are not supported by nntp, but we can fake some of them:\n * Read = a read message number is in the .newsrc\n * New = not read and not cached\n * Old = not read but cached\n */\nvoid nntp_article_status(struct Context *ctx, struct Header *hdr, char *group, anum_t anum)\n{\n  struct NntpData *nntp_data = ctx->data;\n\n  if (group)\n    nntp_data = mutt_hash_find(nntp_data->nserv->groups_hash, group);\n\n  if (!nntp_data)\n    return;\n\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    if ((anum >= nntp_data->newsrc_ent[i].first) &&\n        (anum <= nntp_data->newsrc_ent[i].last))\n    {\n      /* can't use mutt_set_flag() because mx_update_context()\n         didn't called yet */\n      hdr->read = true;\n      return;\n    }\n  }\n\n  /* article was not cached yet, it's new */\n  if (anum > nntp_data->last_cached)\n    return;\n\n  /* article isn't read but cached, it's old */\n  if (MarkOld)\n    hdr->old = true;\n}\n\n/**\n * mutt_newsgroup_subscribe - Subscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_subscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->subscribed = true;\n  if (!nntp_data->newsrc_ent)\n  {\n    nntp_data->newsrc_ent = mutt_mem_calloc(1, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = 0;\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_unsubscribe - Unsubscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_unsubscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  nntp_data->subscribed = false;\n  if (!SaveUnsubscribed)\n  {\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_catchup - Catchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_catchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->last_message;\n  }\n  nntp_data->unread = 0;\n  if (Context && Context->data == nntp_data)\n  {\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 1);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_uncatchup - Uncatchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_uncatchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->first_message - 1;\n  }\n  if (Context && Context->data == nntp_data)\n  {\n    nntp_data->unread = Context->msgcount;\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 0);\n  }\n  else\n  {\n    nntp_data->unread = nntp_data->last_message;\n    if (nntp_data->newsrc_ent)\n      nntp_data->unread -= nntp_data->newsrc_ent[0].last;\n  }\n  return nntp_data;\n}\n\n/**\n * nntp_buffy - Get first newsgroup with new messages\n * @param buf Buffer for result\n * @param len Length of buffer\n */\nvoid nntp_buffy(char *buf, size_t len)\n{\n  for (unsigned int i = 0; i < CurrentNewsSrv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = CurrentNewsSrv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->subscribed || !nntp_data->unread)\n      continue;\n\n    if (Context && Context->magic == MUTT_NNTP &&\n        (mutt_str_strcmp(nntp_data->group, ((struct NntpData *) Context->data)->group) == 0))\n    {\n      unsigned int unread = 0;\n\n      for (unsigned int j = 0; j < Context->msgcount; j++)\n        if (!Context->hdrs[j]->read && !Context->hdrs[j]->deleted)\n          unread++;\n      if (!unread)\n        continue;\n    }\n    mutt_str_strfcpy(buf, nntp_data->group, len);\n    break;\n  }\n}\n", "/**\n * @file\n * POP network mailbox\n *\n * @authors\n * Copyright (C) 2000-2002 Vsevolod Volkov <vvv@mutt.org.ua>\n * Copyright (C) 2006-2007,2009 Rocco Rutte <pdmef@gmx.net>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page pop POP network mailbox\n *\n * POP network mailbox\n */\n\n#include \"config.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"pop.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"ncrypt/ncrypt.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\n#ifdef USE_HCACHE\n#define HC_FNAME \"neomutt\" /* filename for hcache as POP lacks paths */\n#define HC_FEXT \"hcache\"   /* extension for hcache as POP lacks paths */\n#endif\n\n/**\n * cache_id - Make a message-cache-compatible id\n * @param id POP message id\n * @retval ptr Sanitised string\n *\n * The POP message id may contain '/' and other awkward characters.\n *\n * @note This function returns a pointer to a static buffer.\n */\nstatic const char *cache_id(const char *id)\n{\n  static char clean[SHORT_STRING];\n  mutt_str_strfcpy(clean, id, sizeof(clean));\n  mutt_file_sanitize_filename(clean, true);\n  return clean;\n}\n\n/**\n * fetch_message - write line to file\n * @param line String to write\n * @param file FILE pointer to write to\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_message(char *line, void *file)\n{\n  FILE *f = (FILE *) file;\n\n  fputs(line, f);\n  if (fputc('\\n', f) == EOF)\n    return -1;\n\n  return 0;\n}\n\n/**\n * pop_read_header - Read header\n * @param pop_data POP data\n * @param h        Email header\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_read_header(struct PopData *pop_data, struct Header *h)\n{\n  int rc, index;\n  size_t length;\n  char buf[LONG_STRING];\n\n  FILE *f = mutt_file_mkstemp();\n  if (!f)\n  {\n    mutt_perror(\"mutt_file_mkstemp failed!\");\n    return -3;\n  }\n\n  snprintf(buf, sizeof(buf), \"LIST %d\\r\\n\", h->refno);\n  rc = pop_query(pop_data, buf, sizeof(buf));\n  if (rc == 0)\n  {\n    sscanf(buf, \"+OK %d %zu\", &index, &length);\n\n    snprintf(buf, sizeof(buf), \"TOP %d 0\\r\\n\", h->refno);\n    rc = pop_fetch_data(pop_data, buf, NULL, fetch_message, f);\n\n    if (pop_data->cmd_top == 2)\n    {\n      if (rc == 0)\n      {\n        pop_data->cmd_top = 1;\n\n        mutt_debug(1, \"set TOP capability\\n\");\n      }\n\n      if (rc == -2)\n      {\n        pop_data->cmd_top = 0;\n\n        mutt_debug(1, \"unset TOP capability\\n\");\n        snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n                 _(\"Command TOP is not supported by server.\"));\n      }\n    }\n  }\n\n  switch (rc)\n  {\n    case 0:\n    {\n      rewind(f);\n      h->env = mutt_rfc822_read_header(f, h, 0, 0);\n      h->content->length = length - h->content->offset + 1;\n      rewind(f);\n      while (!feof(f))\n      {\n        h->content->length--;\n        fgets(buf, sizeof(buf), f);\n      }\n      break;\n    }\n    case -2:\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    case -3:\n    {\n      mutt_error(_(\"Can't write header to temporary file!\"));\n      break;\n    }\n  }\n\n  mutt_file_fclose(&f);\n  return rc;\n}\n\n/**\n * fetch_uidl - parse UIDL\n * @param line String to parse\n * @param data Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n\n  return 0;\n}\n\n/**\n * msg_cache_check - Check the Body Cache for an ID\n * @param id     Cache ID\n * @param bcache Body cache\n * @param data   Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  /* message not found in context -> remove it from cache\n   * return the result of bcache, so we stop upon its first error\n   */\n  return mutt_bcache_del(bcache, cache_id(id));\n}\n\n#ifdef USE_HCACHE\n/**\n * pop_hcache_namer - Create a header cache filename for a POP mailbox\n * @param path    Path of mailbox\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n */\nstatic int pop_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.\" HC_FEXT, path);\n}\n\n/**\n * pop_hcache_open - Open the header cache\n * @param pop_data POP server data\n * @param path     Path to the mailbox\n * @retval ptr Header cache\n */\nstatic header_cache_t *pop_hcache_open(struct PopData *pop_data, const char *path)\n{\n  struct Url url;\n  char p[LONG_STRING];\n\n  if (!pop_data || !pop_data->conn)\n    return mutt_hcache_open(HeaderCache, path, NULL);\n\n  mutt_account_tourl(&pop_data->conn->account, &url);\n  url.path = HC_FNAME;\n  url_tostring(&url, p, sizeof(p), U_PATH);\n  return mutt_hcache_open(HeaderCache, p, pop_hcache_namer);\n}\n#endif\n\n/**\n * pop_fetch_headers - Read headers\n * @param ctx Context\n * @retval  0 Success\n * @retval -1 Connection lost\n * @retval -2 Invalid command or execution error\n * @retval -3 Error writing to tempfile\n */\nstatic int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: new\n       */\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}\n\n/**\n * pop_open_mailbox - open POP mailbox, fetch only headers\n * @param ctx Mailbox Context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_open_mailbox(struct Context *ctx)\n{\n  char buf[PATH_MAX];\n  struct Connection *conn = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n  struct Url url;\n\n  if (pop_parse_path(ctx->path, &acct))\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), ctx->path);\n    return -1;\n  }\n\n  mutt_account_tourl(&acct, &url);\n  url.path = NULL;\n  url_tostring(&url, buf, sizeof(buf), 0);\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return -1;\n\n  FREE(&ctx->path);\n  FREE(&ctx->realpath);\n  ctx->path = mutt_str_strdup(buf);\n  ctx->realpath = mutt_str_strdup(ctx->path);\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n  ctx->data = pop_data;\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  conn->data = pop_data;\n  pop_data->bcache = mutt_bcache_open(&acct, NULL);\n\n  /* init (hard-coded) ACL rights */\n  memset(ctx->rights, 0, sizeof(ctx->rights));\n  mutt_bit_set(ctx->rights, MUTT_ACL_SEEN);\n  mutt_bit_set(ctx->rights, MUTT_ACL_DELETE);\n#ifdef USE_HCACHE\n  /* flags are managed using header cache, so it only makes sense to\n   * enable them in that case */\n  mutt_bit_set(ctx->rights, MUTT_ACL_WRITE);\n#endif\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    ctx->size = pop_data->size;\n\n    mutt_message(_(\"Fetching list of messages...\"));\n\n    const int ret = pop_fetch_headers(ctx);\n\n    if (ret >= 0)\n      return 0;\n\n    if (ret < -1)\n    {\n      mutt_sleep(2);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_clear_cache - delete all cached messages\n * @param pop_data POP server data\n */\nstatic void pop_clear_cache(struct PopData *pop_data)\n{\n  if (!pop_data->clear_cache)\n    return;\n\n  mutt_debug(1, \"delete cached messages\\n\");\n\n  for (int i = 0; i < POP_CACHE_LEN; i++)\n  {\n    if (pop_data->cache[i].path)\n    {\n      unlink(pop_data->cache[i].path);\n      FREE(&pop_data->cache[i].path);\n    }\n  }\n}\n\n/**\n * pop_close_mailbox - close POP mailbox\n * @param ctx Mailbox Context\n * @retval 0 Always\n */\nstatic int pop_close_mailbox(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if (!pop_data)\n    return 0;\n\n  pop_logout(ctx);\n\n  if (pop_data->status != POP_NONE)\n    mutt_socket_close(pop_data->conn);\n\n  pop_data->status = POP_NONE;\n\n  pop_data->clear_cache = true;\n  pop_clear_cache(pop_data);\n\n  if (!pop_data->conn->data)\n    mutt_socket_free(pop_data->conn);\n\n  mutt_bcache_close(&pop_data->bcache);\n\n  return 0;\n}\n\n/**\n * pop_fetch_message - fetch message from POP server\n * @param ctx   Mailbox Context\n * @param msg   Message\n * @param msgno Message number\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n  if (msg->fp)\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n    if (!msg->fp)\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}\n\n/**\n * pop_close_message - Close POP Message\n * @param ctx Mailbox Context\n * @param msg Message\n * @retval 0   Success\n * @retval EOF Error, see errno\n */\nstatic int pop_close_message(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * pop_sync_mailbox - update POP mailbox, delete messages from server\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}\n\n/**\n * pop_check_mailbox - Check for new messages and fetch headers\n * @param ctx        Mailbox Context\n * @param index_hint Current Message\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int pop_check_mailbox(struct Context *ctx, int *index_hint)\n{\n  int ret;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if ((pop_data->check_time + PopCheckinterval) > time(NULL))\n    return 0;\n\n  pop_logout(ctx);\n\n  mutt_socket_close(pop_data->conn);\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  ctx->size = pop_data->size;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  ret = pop_fetch_headers(ctx);\n  pop_clear_cache(pop_data);\n\n  if (ret < 0)\n    return -1;\n\n  if (ret > 0)\n    return MUTT_NEW_MAIL;\n\n  return 0;\n}\n\n/**\n * pop_fetch_mail - Fetch messages and save them in $spoolfile\n */\nvoid pop_fetch_mail(void)\n{\n  char buffer[LONG_STRING];\n  char msgbuf[SHORT_STRING];\n  char *url = NULL, *p = NULL;\n  int delanswer, last = 0, msgs, bytes, rset = 0, ret;\n  struct Connection *conn = NULL;\n  struct Context ctx;\n  struct Message *msg = NULL;\n  struct Account acct;\n  struct PopData *pop_data = NULL;\n\n  if (!PopHost)\n  {\n    mutt_error(_(\"POP host is not defined.\"));\n    return;\n  }\n\n  url = p = mutt_mem_calloc(strlen(PopHost) + 7, sizeof(char));\n  if (url_check_scheme(PopHost) == U_UNKNOWN)\n  {\n    strcpy(url, \"pop://\");\n    p = strchr(url, '\\0');\n  }\n  strcpy(p, PopHost);\n\n  ret = pop_parse_path(url, &acct);\n  FREE(&url);\n  if (ret)\n  {\n    mutt_error(_(\"%s is an invalid POP path\"), PopHost);\n    return;\n  }\n\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return;\n\n  pop_data = mutt_mem_calloc(1, sizeof(struct PopData));\n  pop_data->conn = conn;\n\n  if (pop_open_connection(pop_data) < 0)\n  {\n    mutt_socket_free(pop_data->conn);\n    FREE(&pop_data);\n    return;\n  }\n\n  conn->data = pop_data;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  /* find out how many messages are in the mailbox. */\n  mutt_str_strfcpy(buffer, \"STAT\\r\\n\", sizeof(buffer));\n  ret = pop_query(pop_data, buffer, sizeof(buffer));\n  if (ret == -1)\n    goto fail;\n  if (ret == -2)\n  {\n    mutt_error(\"%s\", pop_data->err_msg);\n    goto finish;\n  }\n\n  sscanf(buffer, \"+OK %d %d\", &msgs, &bytes);\n\n  /* only get unread messages */\n  if (msgs > 0 && PopLast)\n  {\n    mutt_str_strfcpy(buffer, \"LAST\\r\\n\", sizeof(buffer));\n    ret = pop_query(pop_data, buffer, sizeof(buffer));\n    if (ret == -1)\n      goto fail;\n    if (ret == 0)\n      sscanf(buffer, \"+OK %d\", &last);\n  }\n\n  if (msgs <= last)\n  {\n    mutt_message(_(\"No new mail in POP mailbox.\"));\n    goto finish;\n  }\n\n  if (mx_mbox_open(NONULL(Spoolfile), MUTT_APPEND, &ctx) == NULL)\n    goto finish;\n\n  delanswer = query_quadoption(PopDelete, _(\"Delete messages from server?\"));\n\n  snprintf(msgbuf, sizeof(msgbuf),\n           ngettext(\"Reading new messages (%d byte)...\",\n                    \"Reading new messages (%d bytes)...\", bytes),\n           bytes);\n  mutt_message(\"%s\", msgbuf);\n\n  for (int i = last + 1; i <= msgs; i++)\n  {\n    msg = mx_msg_open_new(&ctx, NULL, MUTT_ADD_FROM);\n    if (!msg)\n      ret = -3;\n    else\n    {\n      snprintf(buffer, sizeof(buffer), \"RETR %d\\r\\n\", i);\n      ret = pop_fetch_data(pop_data, buffer, NULL, fetch_message, msg->fp);\n      if (ret == -3)\n        rset = 1;\n\n      if (ret == 0 && mx_msg_commit(&ctx, msg) != 0)\n      {\n        rset = 1;\n        ret = -3;\n      }\n\n      mx_msg_close(&ctx, &msg);\n    }\n\n    if (ret == 0 && delanswer == MUTT_YES)\n    {\n      /* delete the message on the server */\n      snprintf(buffer, sizeof(buffer), \"DELE %d\\r\\n\", i);\n      ret = pop_query(pop_data, buffer, sizeof(buffer));\n    }\n\n    if (ret == -1)\n    {\n      mx_mbox_close(&ctx, NULL);\n      goto fail;\n    }\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      break;\n    }\n    if (ret == -3)\n    {\n      mutt_error(_(\"Error while writing mailbox!\"));\n      break;\n    }\n\n    /* L10N: The plural is picked by the second numerical argument, i.e.\n     * the %d right before 'messages', i.e. the total number of messages. */\n    mutt_message(ngettext(\"%s [%d of %d message read]\",\n                          \"%s [%d of %d messages read]\", msgs - last),\n                 msgbuf, i - last, msgs - last);\n  }\n\n  mx_mbox_close(&ctx, NULL);\n\n  if (rset)\n  {\n    /* make sure no messages get deleted */\n    mutt_str_strfcpy(buffer, \"RSET\\r\\n\", sizeof(buffer));\n    if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n      goto fail;\n  }\n\nfinish:\n  /* exit gracefully */\n  mutt_str_strfcpy(buffer, \"QUIT\\r\\n\", sizeof(buffer));\n  if (pop_query(pop_data, buffer, sizeof(buffer)) == -1)\n    goto fail;\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n  return;\n\nfail:\n  mutt_error(_(\"Server closed connection!\"));\n  mutt_socket_close(conn);\n  FREE(&pop_data);\n}\n\n// clang-format off\n/**\n * mx_pop_ops - Mailbox callback functions for POP mailboxes\n */\nstruct MxOps mx_pop_ops = {\n  .mbox_open        = pop_open_mailbox,\n  .mbox_open_append = NULL,\n  .mbox_check       = pop_check_mailbox,\n  .mbox_sync        = pop_sync_mailbox,\n  .mbox_close       = pop_close_mailbox,\n  .msg_open         = pop_fetch_message,\n  .msg_open_new     = NULL,\n  .msg_commit       = NULL,\n  .msg_close        = pop_close_message,\n  .tags_edit        = NULL,\n  .tags_commit      = NULL,\n};\n// clang-format on\n"], "filenames": ["newsrc.c", "pop.c"], "buggy_code_start_loc": [718, 66], "buggy_code_end_loc": [719, 787], "fixing_code_start_loc": [718, 67], "fixing_code_end_loc": [730, 804], "type": "CWE-22", "message": "An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.", "other": {"cve": {"id": "CVE-2018-14363", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:01.027", "lastModified": "2020-05-21T01:16:46.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames."}, {"lang": "es", "value": "Se ha descubierto un problema en NeoMutt en versiones anteriores al 2018-07-16. newsrc.c no restringe correctamente los caracteres \"/\" que podr\u00edan interactuar de forma insegura con los nombres de ruta de la cach\u00e9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}], "references": [{"url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e"}}