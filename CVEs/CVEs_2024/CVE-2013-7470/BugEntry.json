{"buggy_code": ["/*\n * CIPSO - Commercial IP Security Option\n *\n * This is an implementation of the CIPSO 2.2 protocol as specified in\n * draft-ietf-cipso-ipsecurity-01.txt with additional tag types as found in\n * FIPS-188, copies of both documents can be found in the Documentation\n * directory.  While CIPSO never became a full IETF RFC standard many vendors\n * have chosen to adopt the protocol and over the years it has become a\n * de-facto standard for labeled networking.\n *\n * Author: Paul Moore <paul@paul-moore.com>\n *\n */\n\n/*\n * (c) Copyright Hewlett-Packard Development Company, L.P., 2006\n *\n * This program is free software;  you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY;  without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n * the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program;  if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n *\n */\n\n#ifndef _CIPSO_IPV4_H\n#define _CIPSO_IPV4_H\n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <net/netlabel.h>\n#include <net/request_sock.h>\n#include <linux/atomic.h>\n#include <asm/unaligned.h>\n\n/* known doi values */\n#define CIPSO_V4_DOI_UNKNOWN          0x00000000\n\n/* standard tag types */\n#define CIPSO_V4_TAG_INVALID          0\n#define CIPSO_V4_TAG_RBITMAP          1\n#define CIPSO_V4_TAG_ENUM             2\n#define CIPSO_V4_TAG_RANGE            5\n#define CIPSO_V4_TAG_PBITMAP          6\n#define CIPSO_V4_TAG_FREEFORM         7\n\n/* non-standard tag types (tags > 127) */\n#define CIPSO_V4_TAG_LOCAL            128\n\n/* doi mapping types */\n#define CIPSO_V4_MAP_UNKNOWN          0\n#define CIPSO_V4_MAP_TRANS            1\n#define CIPSO_V4_MAP_PASS             2\n#define CIPSO_V4_MAP_LOCAL            3\n\n/* limits */\n#define CIPSO_V4_MAX_REM_LVLS         255\n#define CIPSO_V4_INV_LVL              0x80000000\n#define CIPSO_V4_MAX_LOC_LVLS         (CIPSO_V4_INV_LVL - 1)\n#define CIPSO_V4_MAX_REM_CATS         65534\n#define CIPSO_V4_INV_CAT              0x80000000\n#define CIPSO_V4_MAX_LOC_CATS         (CIPSO_V4_INV_CAT - 1)\n\n/*\n * CIPSO DOI definitions\n */\n\n/* DOI definition struct */\n#define CIPSO_V4_TAG_MAXCNT           5\nstruct cipso_v4_doi {\n\tu32 doi;\n\tu32 type;\n\tunion {\n\t\tstruct cipso_v4_std_map_tbl *std;\n\t} map;\n\tu8 tags[CIPSO_V4_TAG_MAXCNT];\n\n\tatomic_t refcount;\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\n/* Standard CIPSO mapping table */\n/* NOTE: the highest order bit (i.e. 0x80000000) is an 'invalid' flag, if the\n *       bit is set then consider that value as unspecified, meaning the\n *       mapping for that particular level/category is invalid */\nstruct cipso_v4_std_map_tbl {\n\tstruct {\n\t\tu32 *cipso;\n\t\tu32 *local;\n\t\tu32 cipso_size;\n\t\tu32 local_size;\n\t} lvl;\n\tstruct {\n\t\tu32 *cipso;\n\t\tu32 *local;\n\t\tu32 cipso_size;\n\t\tu32 local_size;\n\t} cat;\n};\n\n/*\n * Sysctl Variables\n */\n\n#ifdef CONFIG_NETLABEL\nextern int cipso_v4_cache_enabled;\nextern int cipso_v4_cache_bucketsize;\nextern int cipso_v4_rbm_optfmt;\nextern int cipso_v4_rbm_strictvalid;\n#endif\n\n/*\n * Helper Functions\n */\n\n#define CIPSO_V4_OPTEXIST(x) (IPCB(x)->opt.cipso != 0)\n#define CIPSO_V4_OPTPTR(x) (skb_network_header(x) + IPCB(x)->opt.cipso)\n\n/*\n * DOI List Functions\n */\n\n#ifdef CONFIG_NETLABEL\nint cipso_v4_doi_add(struct cipso_v4_doi *doi_def,\n\t\t     struct netlbl_audit *audit_info);\nvoid cipso_v4_doi_free(struct cipso_v4_doi *doi_def);\nint cipso_v4_doi_remove(u32 doi, struct netlbl_audit *audit_info);\nstruct cipso_v4_doi *cipso_v4_doi_getdef(u32 doi);\nvoid cipso_v4_doi_putdef(struct cipso_v4_doi *doi_def);\nint cipso_v4_doi_walk(u32 *skip_cnt,\n\t\t     int (*callback) (struct cipso_v4_doi *doi_def, void *arg),\n\t             void *cb_arg);\n#else\nstatic inline int cipso_v4_doi_add(struct cipso_v4_doi *doi_def,\n\t\t\t\t   struct netlbl_audit *audit_info)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline void cipso_v4_doi_free(struct cipso_v4_doi *doi_def)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_doi_remove(u32 doi,\n\t\t\t\t      struct netlbl_audit *audit_info)\n{\n\treturn 0;\n}\n\nstatic inline struct cipso_v4_doi *cipso_v4_doi_getdef(u32 doi)\n{\n\treturn NULL;\n}\n\nstatic inline int cipso_v4_doi_walk(u32 *skip_cnt,\n\t\t     int (*callback) (struct cipso_v4_doi *doi_def, void *arg),\n\t\t     void *cb_arg)\n{\n\treturn 0;\n}\n\nstatic inline int cipso_v4_doi_domhsh_add(struct cipso_v4_doi *doi_def,\n\t\t\t\t\t  const char *domain)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_doi_domhsh_remove(struct cipso_v4_doi *doi_def,\n\t\t\t\t\t     const char *domain)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NETLABEL */\n\n/*\n * Label Mapping Cache Functions\n */\n\n#ifdef CONFIG_NETLABEL\nvoid cipso_v4_cache_invalidate(void);\nint cipso_v4_cache_add(const struct sk_buff *skb,\n\t\t       const struct netlbl_lsm_secattr *secattr);\n#else\nstatic inline void cipso_v4_cache_invalidate(void)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_cache_add(const struct sk_buff *skb,\n\t\t\t\t     const struct netlbl_lsm_secattr *secattr)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NETLABEL */\n\n/*\n * Protocol Handling Functions\n */\n\n#ifdef CONFIG_NETLABEL\nvoid cipso_v4_error(struct sk_buff *skb, int error, u32 gateway);\nint cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr);\nvoid cipso_v4_sock_delattr(struct sock *sk);\nint cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr);\nint cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr);\nvoid cipso_v4_req_delattr(struct request_sock *req);\nint cipso_v4_skbuff_setattr(struct sk_buff *skb,\n\t\t\t    const struct cipso_v4_doi *doi_def,\n\t\t\t    const struct netlbl_lsm_secattr *secattr);\nint cipso_v4_skbuff_delattr(struct sk_buff *skb);\nint cipso_v4_skbuff_getattr(const struct sk_buff *skb,\n\t\t\t    struct netlbl_lsm_secattr *secattr);\nint cipso_v4_validate(const struct sk_buff *skb, unsigned char **option);\n#else\nstatic inline void cipso_v4_error(struct sk_buff *skb,\n\t\t\t\t  int error,\n\t\t\t\t  u32 gateway)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t\t      const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline void cipso_v4_sock_delattr(struct sock *sk)\n{\n}\n\nstatic inline int cipso_v4_sock_getattr(struct sock *sk,\n\t\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t\t       const struct cipso_v4_doi *doi_def,\n\t\t\t\t       const struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline void cipso_v4_req_delattr(struct request_sock *req)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_skbuff_setattr(struct sk_buff *skb,\n\t\t\t\t      const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_skbuff_delattr(struct sk_buff *skb)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_skbuff_getattr(const struct sk_buff *skb,\n\t\t\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\n\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n\n}\n#endif /* CONFIG_NETLABEL */\n\n#endif /* _CIPSO_IPV4_H */\n"], "fixing_code": ["/*\n * CIPSO - Commercial IP Security Option\n *\n * This is an implementation of the CIPSO 2.2 protocol as specified in\n * draft-ietf-cipso-ipsecurity-01.txt with additional tag types as found in\n * FIPS-188, copies of both documents can be found in the Documentation\n * directory.  While CIPSO never became a full IETF RFC standard many vendors\n * have chosen to adopt the protocol and over the years it has become a\n * de-facto standard for labeled networking.\n *\n * Author: Paul Moore <paul@paul-moore.com>\n *\n */\n\n/*\n * (c) Copyright Hewlett-Packard Development Company, L.P., 2006\n *\n * This program is free software;  you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY;  without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n * the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program;  if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n *\n */\n\n#ifndef _CIPSO_IPV4_H\n#define _CIPSO_IPV4_H\n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <net/netlabel.h>\n#include <net/request_sock.h>\n#include <linux/atomic.h>\n#include <asm/unaligned.h>\n\n/* known doi values */\n#define CIPSO_V4_DOI_UNKNOWN          0x00000000\n\n/* standard tag types */\n#define CIPSO_V4_TAG_INVALID          0\n#define CIPSO_V4_TAG_RBITMAP          1\n#define CIPSO_V4_TAG_ENUM             2\n#define CIPSO_V4_TAG_RANGE            5\n#define CIPSO_V4_TAG_PBITMAP          6\n#define CIPSO_V4_TAG_FREEFORM         7\n\n/* non-standard tag types (tags > 127) */\n#define CIPSO_V4_TAG_LOCAL            128\n\n/* doi mapping types */\n#define CIPSO_V4_MAP_UNKNOWN          0\n#define CIPSO_V4_MAP_TRANS            1\n#define CIPSO_V4_MAP_PASS             2\n#define CIPSO_V4_MAP_LOCAL            3\n\n/* limits */\n#define CIPSO_V4_MAX_REM_LVLS         255\n#define CIPSO_V4_INV_LVL              0x80000000\n#define CIPSO_V4_MAX_LOC_LVLS         (CIPSO_V4_INV_LVL - 1)\n#define CIPSO_V4_MAX_REM_CATS         65534\n#define CIPSO_V4_INV_CAT              0x80000000\n#define CIPSO_V4_MAX_LOC_CATS         (CIPSO_V4_INV_CAT - 1)\n\n/*\n * CIPSO DOI definitions\n */\n\n/* DOI definition struct */\n#define CIPSO_V4_TAG_MAXCNT           5\nstruct cipso_v4_doi {\n\tu32 doi;\n\tu32 type;\n\tunion {\n\t\tstruct cipso_v4_std_map_tbl *std;\n\t} map;\n\tu8 tags[CIPSO_V4_TAG_MAXCNT];\n\n\tatomic_t refcount;\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\n/* Standard CIPSO mapping table */\n/* NOTE: the highest order bit (i.e. 0x80000000) is an 'invalid' flag, if the\n *       bit is set then consider that value as unspecified, meaning the\n *       mapping for that particular level/category is invalid */\nstruct cipso_v4_std_map_tbl {\n\tstruct {\n\t\tu32 *cipso;\n\t\tu32 *local;\n\t\tu32 cipso_size;\n\t\tu32 local_size;\n\t} lvl;\n\tstruct {\n\t\tu32 *cipso;\n\t\tu32 *local;\n\t\tu32 cipso_size;\n\t\tu32 local_size;\n\t} cat;\n};\n\n/*\n * Sysctl Variables\n */\n\n#ifdef CONFIG_NETLABEL\nextern int cipso_v4_cache_enabled;\nextern int cipso_v4_cache_bucketsize;\nextern int cipso_v4_rbm_optfmt;\nextern int cipso_v4_rbm_strictvalid;\n#endif\n\n/*\n * Helper Functions\n */\n\n#define CIPSO_V4_OPTEXIST(x) (IPCB(x)->opt.cipso != 0)\n#define CIPSO_V4_OPTPTR(x) (skb_network_header(x) + IPCB(x)->opt.cipso)\n\n/*\n * DOI List Functions\n */\n\n#ifdef CONFIG_NETLABEL\nint cipso_v4_doi_add(struct cipso_v4_doi *doi_def,\n\t\t     struct netlbl_audit *audit_info);\nvoid cipso_v4_doi_free(struct cipso_v4_doi *doi_def);\nint cipso_v4_doi_remove(u32 doi, struct netlbl_audit *audit_info);\nstruct cipso_v4_doi *cipso_v4_doi_getdef(u32 doi);\nvoid cipso_v4_doi_putdef(struct cipso_v4_doi *doi_def);\nint cipso_v4_doi_walk(u32 *skip_cnt,\n\t\t     int (*callback) (struct cipso_v4_doi *doi_def, void *arg),\n\t             void *cb_arg);\n#else\nstatic inline int cipso_v4_doi_add(struct cipso_v4_doi *doi_def,\n\t\t\t\t   struct netlbl_audit *audit_info)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline void cipso_v4_doi_free(struct cipso_v4_doi *doi_def)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_doi_remove(u32 doi,\n\t\t\t\t      struct netlbl_audit *audit_info)\n{\n\treturn 0;\n}\n\nstatic inline struct cipso_v4_doi *cipso_v4_doi_getdef(u32 doi)\n{\n\treturn NULL;\n}\n\nstatic inline int cipso_v4_doi_walk(u32 *skip_cnt,\n\t\t     int (*callback) (struct cipso_v4_doi *doi_def, void *arg),\n\t\t     void *cb_arg)\n{\n\treturn 0;\n}\n\nstatic inline int cipso_v4_doi_domhsh_add(struct cipso_v4_doi *doi_def,\n\t\t\t\t\t  const char *domain)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_doi_domhsh_remove(struct cipso_v4_doi *doi_def,\n\t\t\t\t\t     const char *domain)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NETLABEL */\n\n/*\n * Label Mapping Cache Functions\n */\n\n#ifdef CONFIG_NETLABEL\nvoid cipso_v4_cache_invalidate(void);\nint cipso_v4_cache_add(const struct sk_buff *skb,\n\t\t       const struct netlbl_lsm_secattr *secattr);\n#else\nstatic inline void cipso_v4_cache_invalidate(void)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_cache_add(const struct sk_buff *skb,\n\t\t\t\t     const struct netlbl_lsm_secattr *secattr)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NETLABEL */\n\n/*\n * Protocol Handling Functions\n */\n\n#ifdef CONFIG_NETLABEL\nvoid cipso_v4_error(struct sk_buff *skb, int error, u32 gateway);\nint cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr);\nvoid cipso_v4_sock_delattr(struct sock *sk);\nint cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr);\nint cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr);\nvoid cipso_v4_req_delattr(struct request_sock *req);\nint cipso_v4_skbuff_setattr(struct sk_buff *skb,\n\t\t\t    const struct cipso_v4_doi *doi_def,\n\t\t\t    const struct netlbl_lsm_secattr *secattr);\nint cipso_v4_skbuff_delattr(struct sk_buff *skb);\nint cipso_v4_skbuff_getattr(const struct sk_buff *skb,\n\t\t\t    struct netlbl_lsm_secattr *secattr);\nint cipso_v4_validate(const struct sk_buff *skb, unsigned char **option);\n#else\nstatic inline void cipso_v4_error(struct sk_buff *skb,\n\t\t\t\t  int error,\n\t\t\t\t  u32 gateway)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t\t      const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline void cipso_v4_sock_delattr(struct sock *sk)\n{\n}\n\nstatic inline int cipso_v4_sock_getattr(struct sock *sk,\n\t\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t\t       const struct cipso_v4_doi *doi_def,\n\t\t\t\t       const struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline void cipso_v4_req_delattr(struct request_sock *req)\n{\n\treturn;\n}\n\nstatic inline int cipso_v4_skbuff_setattr(struct sk_buff *skb,\n\t\t\t\t      const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_skbuff_delattr(struct sk_buff *skb)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_skbuff_getattr(const struct sk_buff *skb,\n\t\t\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tu8 tag_len;\n\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\ttag_len = opt[opt_iter + 1];\n\t\tif ((tag_len == 0) || (opt[opt_iter + 1] > (opt_len - opt_iter))) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += tag_len;\n\t}\n\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n\n}\n#endif /* CONFIG_NETLABEL */\n\n#endif /* _CIPSO_IPV4_H */\n"], "filenames": ["include/net/cipso_ipv4.h"], "buggy_code_start_loc": [292], "buggy_code_end_loc": [310], "fixing_code_start_loc": [293], "fixing_code_end_loc": [312], "type": "CWE-400", "message": "cipso_v4_validate in include/net/cipso_ipv4.h in the Linux kernel before 3.11.7, when CONFIG_NETLABEL is disabled, allows attackers to cause a denial of service (infinite loop and crash), as demonstrated by icmpsic, a different vulnerability than CVE-2013-0310.", "other": {"cve": {"id": "CVE-2013-7470", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-23T03:29:00.243", "lastModified": "2021-11-17T22:15:32.340", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "cipso_v4_validate in include/net/cipso_ipv4.h in the Linux kernel before 3.11.7, when CONFIG_NETLABEL is disabled, allows attackers to cause a denial of service (infinite loop and crash), as demonstrated by icmpsic, a different vulnerability than CVE-2013-0310."}, {"lang": "es", "value": "cipso_v4_validate en include/net/cipso_ipv4. h en el kernel de Linux anterior a la versi\u00f3n 3.11.7, cuando CONFIG_NETLABEL est\u00e1 desactivado, permite a los atacantes causar una Denegaci\u00f3n de Servicio (bucle infinito y bloqueo), como es demostrado en icmpsic, una vulnerabilidad diferente a CVE-2013-0310."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.11.7", "matchCriteriaId": "981CC1D1-1760-449E-8267-69B3FF430489"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.11.7", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f2e5ddcc0d12f9c4c7b254358ad245c9dddce13b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f2e5ddcc0d12f9c4c7b254358ad245c9dddce13b", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "Patch"]}, {"url": "https://support.f5.com/csp/article/K21914362", "source": "cve@mitre.org"}, {"url": "https://www.arista.com/en/support/advisories-notices/security-advisories/7098-security-advisory-40", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f2e5ddcc0d12f9c4c7b254358ad245c9dddce13b"}}