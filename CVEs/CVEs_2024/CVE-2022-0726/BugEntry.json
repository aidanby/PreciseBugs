{"buggy_code": ["import express from 'express'\nimport { body, param, query } from 'express-validator'\nimport { MUserAccountUrl } from '@server/types/models'\nimport { HttpStatusCode, UserRight } from '@shared/models'\nimport { exists, isBooleanValid, isIdValid, toBooleanOrNull } from '../../../helpers/custom-validators/misc'\nimport { isValidVideoCommentText } from '../../../helpers/custom-validators/video-comments'\nimport { logger } from '../../../helpers/logger'\nimport { AcceptResult, isLocalVideoCommentReplyAccepted, isLocalVideoThreadAccepted } from '../../../lib/moderation'\nimport { Hooks } from '../../../lib/plugins/hooks'\nimport { MCommentOwnerVideoReply, MVideo, MVideoFullLight } from '../../../types/models/video'\nimport {\n  areValidationErrors,\n  checkCanSeeVideoIfPrivate,\n  doesVideoCommentExist,\n  doesVideoCommentThreadExist,\n  doesVideoExist,\n  isValidVideoIdParam\n} from '../shared'\n\nconst listVideoCommentsValidator = [\n  query('isLocal')\n  .optional()\n  .customSanitizer(toBooleanOrNull)\n  .custom(isBooleanValid)\n  .withMessage('Should have a valid is local boolean'),\n\n  query('search')\n    .optional()\n    .custom(exists).withMessage('Should have a valid search'),\n\n  query('searchAccount')\n    .optional()\n    .custom(exists).withMessage('Should have a valid account search'),\n\n  query('searchVideo')\n    .optional()\n    .custom(exists).withMessage('Should have a valid video search'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentsValidator parameters.', { parameters: req.query })\n\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\nconst listVideoCommentThreadsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentThreads parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.onlyVideo)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot list comments of private/internal/blocklisted video'\n      })\n    }\n\n    return next()\n  }\n]\n\nconst listVideoThreadCommentsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('threadId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid threadId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoThreadComments parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n    if (!await doesVideoCommentThreadExist(req.params.threadId, res.locals.onlyVideo, res)) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.onlyVideo)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot list threads of private/internal/blocklisted video'\n      })\n    }\n\n    return next()\n  }\n]\n\nconst addVideoCommentThreadValidator = [\n  isValidVideoIdParam('videoId'),\n\n  body('text')\n    .custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentThread parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, false)) return\n\n    return next()\n  }\n]\n\nconst addVideoCommentReplyValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  body('text').custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentReply parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, true)) return\n\n    return next()\n  }\n]\n\nconst videoCommentGetValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoCommentGetValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'id')) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoId, res)) return\n\n    return next()\n  }\n]\n\nconst removeVideoCommentValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking removeVideoCommentValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n\n    // Check if the user who did the request is able to delete the video\n    if (!checkUserCanDeleteVideoComment(res.locals.oauth.token.User, res.locals.videoCommentFull, res)) return\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  listVideoCommentThreadsValidator,\n  listVideoThreadCommentsValidator,\n  addVideoCommentThreadValidator,\n  listVideoCommentsValidator,\n  addVideoCommentReplyValidator,\n  videoCommentGetValidator,\n  removeVideoCommentValidator\n}\n\n// ---------------------------------------------------------------------------\n\nfunction isVideoCommentsEnabled (video: MVideo, res: express.Response) {\n  if (video.commentsEnabled !== true) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'Video comments are disabled for this video.'\n    })\n    return false\n  }\n\n  return true\n}\n\nfunction checkUserCanDeleteVideoComment (user: MUserAccountUrl, videoComment: MCommentOwnerVideoReply, res: express.Response) {\n  if (videoComment.isDeleted()) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'This comment is already deleted'\n    })\n    return false\n  }\n\n  const userAccount = user.Account\n\n  if (\n    user.hasRight(UserRight.REMOVE_ANY_VIDEO_COMMENT) === false && // Not a moderator\n    videoComment.accountId !== userAccount.id && // Not the comment owner\n    videoComment.Video.VideoChannel.accountId !== userAccount.id // Not the video owner\n  ) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot remove video comment of another user'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function isVideoCommentAccepted (req: express.Request, res: express.Response, video: MVideoFullLight, isReply: boolean) {\n  const acceptParameters = {\n    video,\n    commentBody: req.body,\n    user: res.locals.oauth.token.User\n  }\n\n  let acceptedResult: AcceptResult\n\n  if (isReply) {\n    const acceptReplyParameters = Object.assign(acceptParameters, { parentComment: res.locals.videoCommentFull })\n\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoCommentReplyAccepted,\n      acceptReplyParameters,\n      'filter:api.video-comment-reply.create.accept.result'\n    )\n  } else {\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoThreadAccepted,\n      acceptParameters,\n      'filter:api.video-thread.create.accept.result'\n    )\n  }\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused local comment.', { acceptedResult, acceptParameters })\n\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult?.errorMessage || 'Refused local comment'\n    })\n    return false\n  }\n\n  return true\n}\n", "import express from 'express'\nimport { body, param, query } from 'express-validator'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport { VideoRateType } from '../../../../shared/models/videos'\nimport { isAccountNameValid } from '../../../helpers/custom-validators/accounts'\nimport { isIdValid } from '../../../helpers/custom-validators/misc'\nimport { isRatingValid } from '../../../helpers/custom-validators/video-rates'\nimport { isVideoRatingTypeValid } from '../../../helpers/custom-validators/videos'\nimport { logger } from '../../../helpers/logger'\nimport { AccountVideoRateModel } from '../../../models/account/account-video-rate'\nimport { areValidationErrors, doesVideoExist, isValidVideoIdParam } from '../shared'\n\nconst videoUpdateRateValidator = [\n  isValidVideoIdParam('id'),\n\n  body('rating').custom(isVideoRatingTypeValid).withMessage('Should have a valid rate type'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoRate parameters', { parameters: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.id, res)) return\n\n    return next()\n  }\n]\n\nconst getAccountVideoRateValidatorFactory = function (rateType: VideoRateType) {\n  return [\n    param('name').custom(isAccountNameValid).withMessage('Should have a valid account name'),\n    param('videoId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid videoId'),\n\n    async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n      logger.debug('Checking videoCommentGetValidator parameters.', { parameters: req.params })\n\n      if (areValidationErrors(req, res)) return\n\n      const rate = await AccountVideoRateModel.loadLocalAndPopulateVideo(rateType, req.params.name, +req.params.videoId)\n      if (!rate) {\n        return res.fail({\n          status: HttpStatusCode.NOT_FOUND_404,\n          message: 'Video rate not found'\n        })\n      }\n\n      res.locals.accountVideoRate = rate\n\n      return next()\n    }\n  ]\n}\n\nconst videoRatingValidator = [\n  query('rating').optional().custom(isRatingValid).withMessage('Value must be one of \"like\" or \"dislike\"'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking rating parameter', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videoUpdateRateValidator,\n  getAccountVideoRateValidatorFactory,\n  videoRatingValidator\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport * as chai from 'chai'\nimport { checkBadCountPagination, checkBadSortPagination, checkBadStartPagination } from '@server/tests/shared'\nimport { HttpStatusCode, VideoCreateResult, VideoPrivacy } from '@shared/models'\nimport {\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makePostBodyRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/server-commands'\n\nconst expect = chai.expect\n\ndescribe('Test video comments API validator', function () {\n  let pathThread: string\n  let pathComment: string\n  let server: PeerTubeServer\n  let video: VideoCreateResult\n  let userAccessToken: string\n  let userAccessToken2: string\n  let commentId: number\n  let privateCommentId: number\n  let privateVideo: VideoCreateResult\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    {\n      video = await server.videos.upload({ attributes: {} })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    }\n\n    {\n      privateVideo = await server.videos.upload({ attributes: { privacy: VideoPrivacy.PRIVATE } })\n    }\n\n    {\n      const created = await server.comments.createThread({ videoId: video.uuid, text: 'coucou' })\n      commentId = created.id\n      pathComment = '/api/v1/videos/' + video.uuid + '/comments/' + commentId\n    }\n\n    {\n      const created = await server.comments.createThread({ videoId: privateVideo.uuid, text: 'coucou' })\n      privateCommentId = created.id\n    }\n\n    {\n      const user = { username: 'user1', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken = await server.login.getAccessToken(user)\n    }\n\n    {\n      const user = { username: 'user2', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken2 = await server.login.getAccessToken(user)\n    }\n  })\n\n  describe('When listing video comment threads', function () {\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video without token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with another user token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: userAccessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When listing comments of a thread', function () {\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an incorrect thread id', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/156',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video without token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with another user token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: userAccessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should success with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a video thread', function () {\n\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads'\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a comment to a thread', function () {\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When removing video comments', function () {\n    it('Should fail with a non authenticated user', async function () {\n      await makeDeleteRequest({ url: server.url, path: pathComment, token: 'none', expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with another user', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should succeed with the same user', async function () {\n      let commentToDelete: number\n\n      {\n        const created = await server.comments.createThread({ videoId: video.uuid, token: userAccessToken, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + video.uuid + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the owner of the video', async function () {\n      let commentToDelete: number\n      let anotherVideoUUID: string\n\n      {\n        const { uuid } = await server.videos.upload({ token: userAccessToken, attributes: { name: 'video' } })\n        anotherVideoUUID = uuid\n      }\n\n      {\n        const created = await server.comments.createThread({ videoId: anotherVideoUUID, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + anotherVideoUUID + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When a video has comments disabled', function () {\n    before(async function () {\n      video = await server.videos.upload({ attributes: { commentsEnabled: false } })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    })\n\n    it('Should return an empty thread list', async function () {\n      const res = await makeGetRequest({\n        url: server.url,\n        path: pathThread,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n      expect(res.body.total).to.equal(0)\n      expect(res.body.data).to.have.lengthOf(0)\n    })\n\n    it('Should return an thread comments list')\n\n    it('Should return conflict on thread add', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n\n    it('Should return conflict on comment thread add')\n  })\n\n  describe('When listing admin comments threads', function () {\n    const path = '/api/v1/videos/comments'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a non authenticated user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with a non admin user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        query: {\n          isLocal: false,\n          search: 'toto',\n          searchAccount: 'toto',\n          searchVideo: 'toto'\n        },\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport * as chai from 'chai'\nimport { omit } from 'lodash'\nimport { join } from 'path'\nimport { checkBadCountPagination, checkBadSortPagination, checkBadStartPagination, checkUploadVideoParam } from '@server/tests/shared'\nimport { randomInt, root } from '@shared/core-utils'\nimport { HttpStatusCode, PeerTubeProblemDocument, VideoCreateResult, VideoPrivacy } from '@shared/models'\nimport {\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makePutBodyRequest,\n  makeUploadRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/server-commands'\n\nconst expect = chai.expect\n\ndescribe('Test videos API validator', function () {\n  const path = '/api/v1/videos/'\n  let server: PeerTubeServer\n  let userAccessToken = ''\n  let accountName: string\n  let channelId: number\n  let channelName: string\n  let video: VideoCreateResult\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    const username = 'user1'\n    const password = 'my super password'\n    await server.users.create({ username: username, password: password })\n    userAccessToken = await server.login.getAccessToken({ username, password })\n\n    {\n      const body = await server.users.getMyInfo()\n      channelId = body.videoChannels[0].id\n      channelName = body.videoChannels[0].name\n      accountName = body.account.name + '@' + body.account.host\n    }\n  })\n\n  describe('When listing videos', function () {\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path)\n    })\n\n    it('Should fail with a bad skipVideos query', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200, query: { skipCount: 'toto' } })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200, query: { skipCount: false } })\n    })\n  })\n\n  describe('When searching a video', function () {\n\n    it('Should fail with nothing', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: join(path, 'search'),\n        expectedStatus: HttpStatusCode.BAD_REQUEST_400\n      })\n    })\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, join(path, 'search', 'test'))\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, join(path, 'search', 'test'))\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, join(path, 'search', 'test'))\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When listing my videos', function () {\n    const path = '/api/v1/users/me/videos'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an invalid channel', async function () {\n      await makeGetRequest({ url: server.url, token: server.accessToken, path, query: { channelId: 'toto' } })\n    })\n\n    it('Should fail with an unknown channel', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path,\n        query: { channelId: 89898 },\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, token: server.accessToken, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When listing account videos', function () {\n    let path: string\n\n    before(async function () {\n      path = '/api/v1/accounts/' + accountName + '/videos'\n    })\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When listing video channel videos', function () {\n    let path: string\n\n    before(async function () {\n      path = '/api/v1/video-channels/' + channelName + '/videos'\n    })\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When adding a video', function () {\n    let baseCorrectParams\n    const baseCorrectAttaches = {\n      fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.webm')\n    }\n\n    before(function () {\n      // Put in before to have channelId\n      baseCorrectParams = {\n        name: 'my super name',\n        category: 5,\n        licence: 1,\n        language: 'pt',\n        nsfw: false,\n        commentsEnabled: true,\n        downloadEnabled: true,\n        waitTranscoding: true,\n        description: 'my super description',\n        support: 'my super support text',\n        tags: [ 'tag1', 'tag2' ],\n        privacy: VideoPrivacy.PUBLIC,\n        channelId: channelId,\n        originallyPublishedAt: new Date().toISOString()\n      }\n    })\n\n    function runSuite (mode: 'legacy' | 'resumable') {\n\n      it('Should fail with nothing', async function () {\n        const fields = {}\n        const attaches = {}\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail without name', async function () {\n        const fields = omit(baseCorrectParams, 'name')\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a long name', async function () {\n        const fields = { ...baseCorrectParams, name: 'super'.repeat(65) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad category', async function () {\n        const fields = { ...baseCorrectParams, category: 125 }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad licence', async function () {\n        const fields = { ...baseCorrectParams, licence: 125 }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad language', async function () {\n        const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a long description', async function () {\n        const fields = { ...baseCorrectParams, description: 'super'.repeat(2500) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a long support text', async function () {\n        const fields = { ...baseCorrectParams, support: 'super'.repeat(201) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail without a channel', async function () {\n        const fields = omit(baseCorrectParams, 'channelId')\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad channel', async function () {\n        const fields = { ...baseCorrectParams, channelId: 545454 }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with another user channel', async function () {\n        const user = {\n          username: 'fake' + randomInt(0, 1500),\n          password: 'fake_password'\n        }\n        await server.users.create({ username: user.username, password: user.password })\n\n        const accessTokenUser = await server.login.getAccessToken(user)\n        const { videoChannels } = await server.users.getMyInfo({ token: accessTokenUser })\n        const customChannelId = videoChannels[0].id\n\n        const fields = { ...baseCorrectParams, channelId: customChannelId }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, userAccessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with too many tags', async function () {\n        const fields = { ...baseCorrectParams, tags: [ 'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6' ] }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a tag length too low', async function () {\n        const fields = { ...baseCorrectParams, tags: [ 'tag1', 't' ] }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a tag length too big', async function () {\n        const fields = { ...baseCorrectParams, tags: [ 'tag1', 'my_super_tag_too_long_long_long_long_long_long' ] }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad schedule update (miss updateAt)', async function () {\n        const fields = { ...baseCorrectParams, scheduleUpdate: { privacy: VideoPrivacy.PUBLIC } }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad schedule update (wrong updateAt)', async function () {\n        const fields = {\n          ...baseCorrectParams,\n\n          scheduleUpdate: {\n            privacy: VideoPrivacy.PUBLIC,\n            updateAt: 'toto'\n          }\n        }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad originally published at attribute', async function () {\n        const fields = { ...baseCorrectParams, originallyPublishedAt: 'toto' }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail without an input file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {}\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with an incorrect input file', async function () {\n        const fields = baseCorrectParams\n        let attaches = { fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short_fake.webm') }\n\n        await checkUploadVideoParam(\n          server,\n          server.accessToken,\n          { ...fields, ...attaches },\n          HttpStatusCode.UNPROCESSABLE_ENTITY_422,\n          mode\n        )\n\n        attaches = { fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mkv') }\n        await checkUploadVideoParam(\n          server,\n          server.accessToken,\n          { ...fields, ...attaches },\n          HttpStatusCode.UNSUPPORTED_MEDIA_TYPE_415,\n          mode\n        )\n      })\n\n      it('Should fail with an incorrect thumbnail file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a big thumbnail file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with an incorrect preview file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          previewfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a big preview file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          previewfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should report the appropriate error', async function () {\n        const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n        const attaches = baseCorrectAttaches\n\n        const attributes = { ...fields, ...attaches }\n        const body = await checkUploadVideoParam(server, server.accessToken, attributes, HttpStatusCode.BAD_REQUEST_400, mode)\n\n        const error = body as unknown as PeerTubeProblemDocument\n\n        if (mode === 'legacy') {\n          expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/uploadLegacy')\n        } else {\n          expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/uploadResumableInit')\n        }\n\n        expect(error.type).to.equal('about:blank')\n        expect(error.title).to.equal('Bad Request')\n\n        expect(error.detail).to.equal('Incorrect request parameters: language')\n        expect(error.error).to.equal('Incorrect request parameters: language')\n\n        expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n        expect(error['invalid-params'].language).to.exist\n      })\n\n      it('Should succeed with the correct parameters', async function () {\n        this.timeout(10000)\n\n        const fields = baseCorrectParams\n\n        {\n          const attaches = baseCorrectAttaches\n          await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.OK_200, mode)\n        }\n\n        {\n          const attaches = {\n            ...baseCorrectAttaches,\n\n            videofile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n          }\n\n          await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.OK_200, mode)\n        }\n\n        {\n          const attaches = {\n            ...baseCorrectAttaches,\n\n            videofile: join(root(), 'server', 'tests', 'fixtures', 'video_short.ogv')\n          }\n\n          await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.OK_200, mode)\n        }\n      })\n    }\n\n    describe('Resumable upload', function () {\n      runSuite('resumable')\n    })\n\n    describe('Legacy upload', function () {\n      runSuite('legacy')\n    })\n  })\n\n  describe('When updating a video', function () {\n    const baseCorrectParams = {\n      name: 'my super name',\n      category: 5,\n      licence: 2,\n      language: 'pt',\n      nsfw: false,\n      commentsEnabled: false,\n      downloadEnabled: false,\n      description: 'my super description',\n      privacy: VideoPrivacy.PUBLIC,\n      tags: [ 'tag1', 'tag2' ]\n    }\n\n    before(async function () {\n      const { data } = await server.videos.list()\n      video = data[0]\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePutBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail without a valid uuid', async function () {\n      const fields = baseCorrectParams\n      await makePutBodyRequest({ url: server.url, path: path + 'blabla', token: server.accessToken, fields })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      const fields = baseCorrectParams\n\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06',\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a long name', async function () {\n      const fields = { ...baseCorrectParams, name: 'super'.repeat(65) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad category', async function () {\n      const fields = { ...baseCorrectParams, category: 125 }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad licence', async function () {\n      const fields = { ...baseCorrectParams, licence: 125 }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad language', async function () {\n      const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long description', async function () {\n      const fields = { ...baseCorrectParams, description: 'super'.repeat(2500) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long support text', async function () {\n      const fields = { ...baseCorrectParams, support: 'super'.repeat(201) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad channel', async function () {\n      const fields = { ...baseCorrectParams, channelId: 545454 }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with too many tags', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6' ] }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too low', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 't' ] }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too big', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'my_super_tag_too_long_long_long_long_long_long' ] }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad schedule update (miss updateAt)', async function () {\n      const fields = { ...baseCorrectParams, scheduleUpdate: { privacy: VideoPrivacy.PUBLIC } }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad schedule update (wrong updateAt)', async function () {\n      const fields = { ...baseCorrectParams, scheduleUpdate: { updateAt: 'toto', privacy: VideoPrivacy.PUBLIC } }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad originally published at param', async function () {\n      const fields = { ...baseCorrectParams, originallyPublishedAt: 'toto' }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with a big thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with an incorrect preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with a big preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with a video of another user without the appropriate right', async function () {\n      const fields = baseCorrectParams\n\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + video.shortUUID,\n        token: userAccessToken,\n        fields,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should fail with a video of another server')\n\n    it('Shoud report the appropriate error', async function () {\n      const fields = { ...baseCorrectParams, licence: 125 }\n\n      const res = await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n      const error = res.body as PeerTubeProblemDocument\n\n      expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/putVideo')\n\n      expect(error.type).to.equal('about:blank')\n      expect(error.title).to.equal('Bad Request')\n\n      expect(error.detail).to.equal('Incorrect request parameters: licence')\n      expect(error.error).to.equal('Incorrect request parameters: licence')\n\n      expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n      expect(error['invalid-params'].licence).to.exist\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = baseCorrectParams\n\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When getting a video', function () {\n    it('Should return the list of the videos with nothing', async function () {\n      const res = await makeGetRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n\n      expect(res.body.data).to.be.an('array')\n      expect(res.body.data.length).to.equal(6)\n    })\n\n    it('Should fail without a correct uuid', async function () {\n      await server.videos.get({ id: 'coucou', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n    })\n\n    it('Should return 404 with an incorrect video', async function () {\n      await server.videos.get({ id: '4da6fde3-88f7-4d16-b119-108df5630b06', expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Shoud report the appropriate error', async function () {\n      const body = await server.videos.get({ id: 'hi', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n      const error = body as unknown as PeerTubeProblemDocument\n\n      expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/getVideo')\n\n      expect(error.type).to.equal('about:blank')\n      expect(error.title).to.equal('Bad Request')\n\n      expect(error.detail).to.equal('Incorrect request parameters: id')\n      expect(error.error).to.equal('Incorrect request parameters: id')\n\n      expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n      expect(error['invalid-params'].id).to.exist\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await server.videos.get({ id: video.shortUUID })\n    })\n  })\n\n  describe('When rating a video', function () {\n    let videoId: number\n\n    before(async function () {\n      const { data } = await server.videos.list()\n      videoId = data[0].id\n    })\n\n    it('Should fail without a valid uuid', async function () {\n      const fields = {\n        rating: 'like'\n      }\n      await makePutBodyRequest({ url: server.url, path: path + 'blabla/rate', token: server.accessToken, fields })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      const fields = {\n        rating: 'like'\n      }\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/rate',\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a wrong rating', async function () {\n      const fields = {\n        rating: 'likes'\n      }\n      await makePutBodyRequest({ url: server.url, path: path + videoId + '/rate', token: server.accessToken, fields })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        rating: 'like'\n      }\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + videoId + '/rate',\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When removing a video', function () {\n    it('Should have 404 with nothing', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.BAD_REQUEST_400\n      })\n    })\n\n    it('Should fail without a correct uuid', async function () {\n      await server.videos.remove({ id: 'hello', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n    })\n\n    it('Should fail with a video which does not exist', async function () {\n      await server.videos.remove({ id: '4da6fde3-88f7-4d16-b119-108df5630b06', expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should fail with a video of another user without the appropriate right', async function () {\n      await server.videos.remove({ token: userAccessToken, id: video.uuid, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n    })\n\n    it('Should fail with a video of another server')\n\n    it('Shoud report the appropriate error', async function () {\n      const body = await server.videos.remove({ id: 'hello', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n      const error = body as PeerTubeProblemDocument\n\n      expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/delVideo')\n\n      expect(error.type).to.equal('about:blank')\n      expect(error.title).to.equal('Bad Request')\n\n      expect(error.detail).to.equal('Incorrect request parameters: id')\n      expect(error.error).to.equal('Incorrect request parameters: id')\n\n      expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n      expect(error['invalid-params'].id).to.exist\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await server.videos.remove({ id: video.uuid })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "fixing_code": ["import express from 'express'\nimport { body, param, query } from 'express-validator'\nimport { MUserAccountUrl } from '@server/types/models'\nimport { HttpStatusCode, UserRight } from '@shared/models'\nimport { exists, isBooleanValid, isIdValid, toBooleanOrNull } from '../../../helpers/custom-validators/misc'\nimport { isValidVideoCommentText } from '../../../helpers/custom-validators/video-comments'\nimport { logger } from '../../../helpers/logger'\nimport { AcceptResult, isLocalVideoCommentReplyAccepted, isLocalVideoThreadAccepted } from '../../../lib/moderation'\nimport { Hooks } from '../../../lib/plugins/hooks'\nimport { MCommentOwnerVideoReply, MVideo, MVideoFullLight } from '../../../types/models/video'\nimport {\n  areValidationErrors,\n  checkCanSeeVideoIfPrivate,\n  doesVideoCommentExist,\n  doesVideoCommentThreadExist,\n  doesVideoExist,\n  isValidVideoIdParam\n} from '../shared'\n\nconst listVideoCommentsValidator = [\n  query('isLocal')\n  .optional()\n  .customSanitizer(toBooleanOrNull)\n  .custom(isBooleanValid)\n  .withMessage('Should have a valid is local boolean'),\n\n  query('search')\n    .optional()\n    .custom(exists).withMessage('Should have a valid search'),\n\n  query('searchAccount')\n    .optional()\n    .custom(exists).withMessage('Should have a valid account search'),\n\n  query('searchVideo')\n    .optional()\n    .custom(exists).withMessage('Should have a valid video search'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentsValidator parameters.', { parameters: req.query })\n\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\nconst listVideoCommentThreadsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoCommentThreads parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.onlyVideo)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot list comments of private/internal/blocklisted video'\n      })\n    }\n\n    return next()\n  }\n]\n\nconst listVideoThreadCommentsValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('threadId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid threadId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking listVideoThreadComments parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'only-video')) return\n    if (!await doesVideoCommentThreadExist(req.params.threadId, res.locals.onlyVideo, res)) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.onlyVideo)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot list threads of private/internal/blocklisted video'\n      })\n    }\n\n    return next()\n  }\n]\n\nconst addVideoCommentThreadValidator = [\n  isValidVideoIdParam('videoId'),\n\n  body('text')\n    .custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentThread parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.videoAll)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot access to this ressource'\n      })\n    }\n\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, false)) return\n\n    return next()\n  }\n]\n\nconst addVideoCommentReplyValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  body('text').custom(isValidVideoCommentText).not().isEmpty().withMessage('Should have a valid comment text'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking addVideoCommentReply parameters.', { parameters: req.params, body: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.videoAll)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot access to this ressource'\n      })\n    }\n\n    if (!isVideoCommentsEnabled(res.locals.videoAll, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n    if (!await isVideoCommentAccepted(req, res, res.locals.videoAll, true)) return\n\n    return next()\n  }\n]\n\nconst videoCommentGetValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId')\n    .custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoCommentGetValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res, 'id')) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoId, res)) return\n\n    return next()\n  }\n]\n\nconst removeVideoCommentValidator = [\n  isValidVideoIdParam('videoId'),\n\n  param('commentId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid commentId'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking removeVideoCommentValidator parameters.', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.videoId, res)) return\n    if (!await doesVideoCommentExist(req.params.commentId, res.locals.videoAll, res)) return\n\n    // Check if the user who did the request is able to delete the video\n    if (!checkUserCanDeleteVideoComment(res.locals.oauth.token.User, res.locals.videoCommentFull, res)) return\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  listVideoCommentThreadsValidator,\n  listVideoThreadCommentsValidator,\n  addVideoCommentThreadValidator,\n  listVideoCommentsValidator,\n  addVideoCommentReplyValidator,\n  videoCommentGetValidator,\n  removeVideoCommentValidator\n}\n\n// ---------------------------------------------------------------------------\n\nfunction isVideoCommentsEnabled (video: MVideo, res: express.Response) {\n  if (video.commentsEnabled !== true) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'Video comments are disabled for this video.'\n    })\n    return false\n  }\n\n  return true\n}\n\nfunction checkUserCanDeleteVideoComment (user: MUserAccountUrl, videoComment: MCommentOwnerVideoReply, res: express.Response) {\n  if (videoComment.isDeleted()) {\n    res.fail({\n      status: HttpStatusCode.CONFLICT_409,\n      message: 'This comment is already deleted'\n    })\n    return false\n  }\n\n  const userAccount = user.Account\n\n  if (\n    user.hasRight(UserRight.REMOVE_ANY_VIDEO_COMMENT) === false && // Not a moderator\n    videoComment.accountId !== userAccount.id && // Not the comment owner\n    videoComment.Video.VideoChannel.accountId !== userAccount.id // Not the video owner\n  ) {\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: 'Cannot remove video comment of another user'\n    })\n    return false\n  }\n\n  return true\n}\n\nasync function isVideoCommentAccepted (req: express.Request, res: express.Response, video: MVideoFullLight, isReply: boolean) {\n  const acceptParameters = {\n    video,\n    commentBody: req.body,\n    user: res.locals.oauth.token.User\n  }\n\n  let acceptedResult: AcceptResult\n\n  if (isReply) {\n    const acceptReplyParameters = Object.assign(acceptParameters, { parentComment: res.locals.videoCommentFull })\n\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoCommentReplyAccepted,\n      acceptReplyParameters,\n      'filter:api.video-comment-reply.create.accept.result'\n    )\n  } else {\n    acceptedResult = await Hooks.wrapFun(\n      isLocalVideoThreadAccepted,\n      acceptParameters,\n      'filter:api.video-thread.create.accept.result'\n    )\n  }\n\n  if (!acceptedResult || acceptedResult.accepted !== true) {\n    logger.info('Refused local comment.', { acceptedResult, acceptParameters })\n\n    res.fail({\n      status: HttpStatusCode.FORBIDDEN_403,\n      message: acceptedResult?.errorMessage || 'Refused local comment'\n    })\n    return false\n  }\n\n  return true\n}\n", "import express from 'express'\nimport { body, param, query } from 'express-validator'\nimport { HttpStatusCode } from '../../../../shared/models/http/http-error-codes'\nimport { VideoRateType } from '../../../../shared/models/videos'\nimport { isAccountNameValid } from '../../../helpers/custom-validators/accounts'\nimport { isIdValid } from '../../../helpers/custom-validators/misc'\nimport { isRatingValid } from '../../../helpers/custom-validators/video-rates'\nimport { isVideoRatingTypeValid } from '../../../helpers/custom-validators/videos'\nimport { logger } from '../../../helpers/logger'\nimport { AccountVideoRateModel } from '../../../models/account/account-video-rate'\nimport { areValidationErrors, checkCanSeeVideoIfPrivate, doesVideoExist, isValidVideoIdParam } from '../shared'\n\nconst videoUpdateRateValidator = [\n  isValidVideoIdParam('id'),\n\n  body('rating').custom(isVideoRatingTypeValid).withMessage('Should have a valid rate type'),\n\n  async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking videoRate parameters', { parameters: req.body })\n\n    if (areValidationErrors(req, res)) return\n    if (!await doesVideoExist(req.params.id, res)) return\n\n    if (!await checkCanSeeVideoIfPrivate(req, res, res.locals.videoAll)) {\n      return res.fail({\n        status: HttpStatusCode.FORBIDDEN_403,\n        message: 'Cannot access to this ressource'\n      })\n    }\n\n    return next()\n  }\n]\n\nconst getAccountVideoRateValidatorFactory = function (rateType: VideoRateType) {\n  return [\n    param('name').custom(isAccountNameValid).withMessage('Should have a valid account name'),\n    param('videoId').custom(isIdValid).not().isEmpty().withMessage('Should have a valid videoId'),\n\n    async (req: express.Request, res: express.Response, next: express.NextFunction) => {\n      logger.debug('Checking videoCommentGetValidator parameters.', { parameters: req.params })\n\n      if (areValidationErrors(req, res)) return\n\n      const rate = await AccountVideoRateModel.loadLocalAndPopulateVideo(rateType, req.params.name, +req.params.videoId)\n      if (!rate) {\n        return res.fail({\n          status: HttpStatusCode.NOT_FOUND_404,\n          message: 'Video rate not found'\n        })\n      }\n\n      res.locals.accountVideoRate = rate\n\n      return next()\n    }\n  ]\n}\n\nconst videoRatingValidator = [\n  query('rating').optional().custom(isRatingValid).withMessage('Value must be one of \"like\" or \"dislike\"'),\n\n  (req: express.Request, res: express.Response, next: express.NextFunction) => {\n    logger.debug('Checking rating parameter', { parameters: req.params })\n\n    if (areValidationErrors(req, res)) return\n\n    return next()\n  }\n]\n\n// ---------------------------------------------------------------------------\n\nexport {\n  videoUpdateRateValidator,\n  getAccountVideoRateValidatorFactory,\n  videoRatingValidator\n}\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport * as chai from 'chai'\nimport { checkBadCountPagination, checkBadSortPagination, checkBadStartPagination } from '@server/tests/shared'\nimport { HttpStatusCode, VideoCreateResult, VideoPrivacy } from '@shared/models'\nimport {\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makePostBodyRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/server-commands'\n\nconst expect = chai.expect\n\ndescribe('Test video comments API validator', function () {\n  let pathThread: string\n  let pathComment: string\n\n  let server: PeerTubeServer\n\n  let video: VideoCreateResult\n\n  let userAccessToken: string\n  let userAccessToken2: string\n\n  let commentId: number\n  let privateCommentId: number\n  let privateVideo: VideoCreateResult\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    {\n      video = await server.videos.upload({ attributes: {} })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    }\n\n    {\n      privateVideo = await server.videos.upload({ attributes: { privacy: VideoPrivacy.PRIVATE } })\n    }\n\n    {\n      const created = await server.comments.createThread({ videoId: video.uuid, text: 'coucou' })\n      commentId = created.id\n      pathComment = '/api/v1/videos/' + video.uuid + '/comments/' + commentId\n    }\n\n    {\n      const created = await server.comments.createThread({ videoId: privateVideo.uuid, text: 'coucou' })\n      privateCommentId = created.id\n    }\n\n    {\n      const user = { username: 'user1', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken = await server.login.getAccessToken(user)\n    }\n\n    {\n      const user = { username: 'user2', password: 'my super password' }\n      await server.users.create({ username: user.username, password: user.password })\n      userAccessToken2 = await server.login.getAccessToken(user)\n    }\n  })\n\n  describe('When listing video comment threads', function () {\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, pathThread, server.accessToken)\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video without token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with another user token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: userAccessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When listing comments of a thread', function () {\n    it('Should fail with an incorrect video', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with an incorrect thread id', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/156',\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video without token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with another user token', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: userAccessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should success with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads/' + privateCommentId,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n\n      await makeGetRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + video.shortUUID + '/comment-threads/' + commentId,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a video thread', function () {\n\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathThread, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comment-threads'\n      const fields = { text: 'super comment' }\n\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video of another user', async function () {\n      const fields = { text: 'super comment' }\n\n      await makePostBodyRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.shortUUID + '/comment-threads',\n        token: userAccessToken,\n        fields,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = { text: 'super comment' }\n\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When adding a comment to a thread', function () {\n\n    it('Should fail with a non authenticated user', async function () {\n      const fields = {\n        text: 'text'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: 'none',\n        fields,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a short comment', async function () {\n      const fields = {\n        text: ''\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long comment', async function () {\n      const fields = {\n        text: 'h'.repeat(10001)\n      }\n      await makePostBodyRequest({ url: server.url, path: pathComment, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a private video of another user', async function () {\n      const fields = { text: 'super comment' }\n\n      await makePostBodyRequest({\n        url: server.url,\n        path: '/api/v1/videos/' + privateVideo.uuid + '/comments/' + privateCommentId,\n        token: userAccessToken,\n        fields,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  describe('When removing video comments', function () {\n    it('Should fail with a non authenticated user', async function () {\n      await makeDeleteRequest({ url: server.url, path: pathComment, token: 'none', expectedStatus: HttpStatusCode.UNAUTHORIZED_401 })\n    })\n\n    it('Should fail with another user', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should fail with an incorrect video', async function () {\n      const path = '/api/v1/videos/ba708d62-e3d7-45d9-9d73-41b9097cc02d/comments/' + commentId\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should fail with an incorrect comment', async function () {\n      const path = '/api/v1/videos/' + video.uuid + '/comments/124'\n      await makeDeleteRequest({ url: server.url, path, token: server.accessToken, expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should succeed with the same user', async function () {\n      let commentToDelete: number\n\n      {\n        const created = await server.comments.createThread({ videoId: video.uuid, token: userAccessToken, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + video.uuid + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the owner of the video', async function () {\n      let commentToDelete: number\n      let anotherVideoUUID: string\n\n      {\n        const { uuid } = await server.videos.upload({ token: userAccessToken, attributes: { name: 'video' } })\n        anotherVideoUUID = uuid\n      }\n\n      {\n        const created = await server.comments.createThread({ videoId: anotherVideoUUID, text: 'hello' })\n        commentToDelete = created.id\n      }\n\n      const path = '/api/v1/videos/' + anotherVideoUUID + '/comments/' + commentToDelete\n\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken2, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n      await makeDeleteRequest({ url: server.url, path, token: userAccessToken, expectedStatus: HttpStatusCode.NO_CONTENT_204 })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path: pathComment,\n        token: server.accessToken,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When a video has comments disabled', function () {\n    before(async function () {\n      video = await server.videos.upload({ attributes: { commentsEnabled: false } })\n      pathThread = '/api/v1/videos/' + video.uuid + '/comment-threads'\n    })\n\n    it('Should return an empty thread list', async function () {\n      const res = await makeGetRequest({\n        url: server.url,\n        path: pathThread,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n      expect(res.body.total).to.equal(0)\n      expect(res.body.data).to.have.lengthOf(0)\n    })\n\n    it('Should return an thread comments list')\n\n    it('Should return conflict on thread add', async function () {\n      const fields = {\n        text: 'super comment'\n      }\n      await makePostBodyRequest({\n        url: server.url,\n        path: pathThread,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.CONFLICT_409\n      })\n    })\n\n    it('Should return conflict on comment thread add')\n  })\n\n  describe('When listing admin comments threads', function () {\n    const path = '/api/v1/videos/comments'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a non authenticated user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.UNAUTHORIZED_401\n      })\n    })\n\n    it('Should fail with a non admin user', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: userAccessToken,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct params', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path,\n        token: server.accessToken,\n        query: {\n          isLocal: false,\n          search: 'toto',\n          searchAccount: 'toto',\n          searchVideo: 'toto'\n        },\n        expectedStatus: HttpStatusCode.OK_200\n      })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n", "/* eslint-disable @typescript-eslint/no-unused-expressions,@typescript-eslint/require-await */\n\nimport 'mocha'\nimport * as chai from 'chai'\nimport { omit } from 'lodash'\nimport { join } from 'path'\nimport { checkBadCountPagination, checkBadSortPagination, checkBadStartPagination, checkUploadVideoParam } from '@server/tests/shared'\nimport { randomInt, root } from '@shared/core-utils'\nimport { HttpStatusCode, PeerTubeProblemDocument, VideoCreateResult, VideoPrivacy } from '@shared/models'\nimport {\n  cleanupTests,\n  createSingleServer,\n  makeDeleteRequest,\n  makeGetRequest,\n  makePutBodyRequest,\n  makeUploadRequest,\n  PeerTubeServer,\n  setAccessTokensToServers\n} from '@shared/server-commands'\n\nconst expect = chai.expect\n\ndescribe('Test videos API validator', function () {\n  const path = '/api/v1/videos/'\n  let server: PeerTubeServer\n  let userAccessToken = ''\n  let accountName: string\n  let channelId: number\n  let channelName: string\n  let video: VideoCreateResult\n  let privateVideo: VideoCreateResult\n\n  // ---------------------------------------------------------------\n\n  before(async function () {\n    this.timeout(30000)\n\n    server = await createSingleServer(1)\n\n    await setAccessTokensToServers([ server ])\n\n    const username = 'user1'\n    const password = 'my super password'\n    await server.users.create({ username: username, password: password })\n    userAccessToken = await server.login.getAccessToken({ username, password })\n\n    {\n      const body = await server.users.getMyInfo()\n      channelId = body.videoChannels[0].id\n      channelName = body.videoChannels[0].name\n      accountName = body.account.name + '@' + body.account.host\n    }\n\n    {\n      privateVideo = await server.videos.quickUpload({ name: 'private video', privacy: VideoPrivacy.PRIVATE })\n    }\n  })\n\n  describe('When listing videos', function () {\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path)\n    })\n\n    it('Should fail with a bad skipVideos query', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200, query: { skipCount: 'toto' } })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200, query: { skipCount: false } })\n    })\n  })\n\n  describe('When searching a video', function () {\n\n    it('Should fail with nothing', async function () {\n      await makeGetRequest({\n        url: server.url,\n        path: join(path, 'search'),\n        expectedStatus: HttpStatusCode.BAD_REQUEST_400\n      })\n    })\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, join(path, 'search', 'test'))\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, join(path, 'search', 'test'))\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, join(path, 'search', 'test'))\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When listing my videos', function () {\n    const path = '/api/v1/users/me/videos'\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an invalid channel', async function () {\n      await makeGetRequest({ url: server.url, token: server.accessToken, path, query: { channelId: 'toto' } })\n    })\n\n    it('Should fail with an unknown channel', async function () {\n      await makeGetRequest({\n        url: server.url,\n        token: server.accessToken,\n        path,\n        query: { channelId: 89898 },\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, token: server.accessToken, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When listing account videos', function () {\n    let path: string\n\n    before(async function () {\n      path = '/api/v1/accounts/' + accountName + '/videos'\n    })\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When listing video channel videos', function () {\n    let path: string\n\n    before(async function () {\n      path = '/api/v1/video-channels/' + channelName + '/videos'\n    })\n\n    it('Should fail with a bad start pagination', async function () {\n      await checkBadStartPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with a bad count pagination', async function () {\n      await checkBadCountPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should fail with an incorrect sort', async function () {\n      await checkBadSortPagination(server.url, path, server.accessToken)\n    })\n\n    it('Should success with the correct parameters', async function () {\n      await makeGetRequest({ url: server.url, path, expectedStatus: HttpStatusCode.OK_200 })\n    })\n  })\n\n  describe('When adding a video', function () {\n    let baseCorrectParams\n    const baseCorrectAttaches = {\n      fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.webm')\n    }\n\n    before(function () {\n      // Put in before to have channelId\n      baseCorrectParams = {\n        name: 'my super name',\n        category: 5,\n        licence: 1,\n        language: 'pt',\n        nsfw: false,\n        commentsEnabled: true,\n        downloadEnabled: true,\n        waitTranscoding: true,\n        description: 'my super description',\n        support: 'my super support text',\n        tags: [ 'tag1', 'tag2' ],\n        privacy: VideoPrivacy.PUBLIC,\n        channelId: channelId,\n        originallyPublishedAt: new Date().toISOString()\n      }\n    })\n\n    function runSuite (mode: 'legacy' | 'resumable') {\n\n      it('Should fail with nothing', async function () {\n        const fields = {}\n        const attaches = {}\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail without name', async function () {\n        const fields = omit(baseCorrectParams, 'name')\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a long name', async function () {\n        const fields = { ...baseCorrectParams, name: 'super'.repeat(65) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad category', async function () {\n        const fields = { ...baseCorrectParams, category: 125 }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad licence', async function () {\n        const fields = { ...baseCorrectParams, licence: 125 }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad language', async function () {\n        const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a long description', async function () {\n        const fields = { ...baseCorrectParams, description: 'super'.repeat(2500) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a long support text', async function () {\n        const fields = { ...baseCorrectParams, support: 'super'.repeat(201) }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail without a channel', async function () {\n        const fields = omit(baseCorrectParams, 'channelId')\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad channel', async function () {\n        const fields = { ...baseCorrectParams, channelId: 545454 }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with another user channel', async function () {\n        const user = {\n          username: 'fake' + randomInt(0, 1500),\n          password: 'fake_password'\n        }\n        await server.users.create({ username: user.username, password: user.password })\n\n        const accessTokenUser = await server.login.getAccessToken(user)\n        const { videoChannels } = await server.users.getMyInfo({ token: accessTokenUser })\n        const customChannelId = videoChannels[0].id\n\n        const fields = { ...baseCorrectParams, channelId: customChannelId }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, userAccessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with too many tags', async function () {\n        const fields = { ...baseCorrectParams, tags: [ 'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6' ] }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a tag length too low', async function () {\n        const fields = { ...baseCorrectParams, tags: [ 'tag1', 't' ] }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a tag length too big', async function () {\n        const fields = { ...baseCorrectParams, tags: [ 'tag1', 'my_super_tag_too_long_long_long_long_long_long' ] }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad schedule update (miss updateAt)', async function () {\n        const fields = { ...baseCorrectParams, scheduleUpdate: { privacy: VideoPrivacy.PUBLIC } }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad schedule update (wrong updateAt)', async function () {\n        const fields = {\n          ...baseCorrectParams,\n\n          scheduleUpdate: {\n            privacy: VideoPrivacy.PUBLIC,\n            updateAt: 'toto'\n          }\n        }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a bad originally published at attribute', async function () {\n        const fields = { ...baseCorrectParams, originallyPublishedAt: 'toto' }\n        const attaches = baseCorrectAttaches\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail without an input file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {}\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with an incorrect input file', async function () {\n        const fields = baseCorrectParams\n        let attaches = { fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short_fake.webm') }\n\n        await checkUploadVideoParam(\n          server,\n          server.accessToken,\n          { ...fields, ...attaches },\n          HttpStatusCode.UNPROCESSABLE_ENTITY_422,\n          mode\n        )\n\n        attaches = { fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mkv') }\n        await checkUploadVideoParam(\n          server,\n          server.accessToken,\n          { ...fields, ...attaches },\n          HttpStatusCode.UNSUPPORTED_MEDIA_TYPE_415,\n          mode\n        )\n      })\n\n      it('Should fail with an incorrect thumbnail file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a big thumbnail file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with an incorrect preview file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          previewfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should fail with a big preview file', async function () {\n        const fields = baseCorrectParams\n        const attaches = {\n          previewfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png'),\n          fixture: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n        }\n\n        await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.BAD_REQUEST_400, mode)\n      })\n\n      it('Should report the appropriate error', async function () {\n        const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n        const attaches = baseCorrectAttaches\n\n        const attributes = { ...fields, ...attaches }\n        const body = await checkUploadVideoParam(server, server.accessToken, attributes, HttpStatusCode.BAD_REQUEST_400, mode)\n\n        const error = body as unknown as PeerTubeProblemDocument\n\n        if (mode === 'legacy') {\n          expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/uploadLegacy')\n        } else {\n          expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/uploadResumableInit')\n        }\n\n        expect(error.type).to.equal('about:blank')\n        expect(error.title).to.equal('Bad Request')\n\n        expect(error.detail).to.equal('Incorrect request parameters: language')\n        expect(error.error).to.equal('Incorrect request parameters: language')\n\n        expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n        expect(error['invalid-params'].language).to.exist\n      })\n\n      it('Should succeed with the correct parameters', async function () {\n        this.timeout(10000)\n\n        const fields = baseCorrectParams\n\n        {\n          const attaches = baseCorrectAttaches\n          await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.OK_200, mode)\n        }\n\n        {\n          const attaches = {\n            ...baseCorrectAttaches,\n\n            videofile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n          }\n\n          await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.OK_200, mode)\n        }\n\n        {\n          const attaches = {\n            ...baseCorrectAttaches,\n\n            videofile: join(root(), 'server', 'tests', 'fixtures', 'video_short.ogv')\n          }\n\n          await checkUploadVideoParam(server, server.accessToken, { ...fields, ...attaches }, HttpStatusCode.OK_200, mode)\n        }\n      })\n    }\n\n    describe('Resumable upload', function () {\n      runSuite('resumable')\n    })\n\n    describe('Legacy upload', function () {\n      runSuite('legacy')\n    })\n  })\n\n  describe('When updating a video', function () {\n    const baseCorrectParams = {\n      name: 'my super name',\n      category: 5,\n      licence: 2,\n      language: 'pt',\n      nsfw: false,\n      commentsEnabled: false,\n      downloadEnabled: false,\n      description: 'my super description',\n      privacy: VideoPrivacy.PUBLIC,\n      tags: [ 'tag1', 'tag2' ]\n    }\n\n    before(async function () {\n      const { data } = await server.videos.list()\n      video = data[0]\n    })\n\n    it('Should fail with nothing', async function () {\n      const fields = {}\n      await makePutBodyRequest({ url: server.url, path, token: server.accessToken, fields })\n    })\n\n    it('Should fail without a valid uuid', async function () {\n      const fields = baseCorrectParams\n      await makePutBodyRequest({ url: server.url, path: path + 'blabla', token: server.accessToken, fields })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      const fields = baseCorrectParams\n\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06',\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a long name', async function () {\n      const fields = { ...baseCorrectParams, name: 'super'.repeat(65) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad category', async function () {\n      const fields = { ...baseCorrectParams, category: 125 }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad licence', async function () {\n      const fields = { ...baseCorrectParams, licence: 125 }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad language', async function () {\n      const fields = { ...baseCorrectParams, language: 'a'.repeat(15) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long description', async function () {\n      const fields = { ...baseCorrectParams, description: 'super'.repeat(2500) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a long support text', async function () {\n      const fields = { ...baseCorrectParams, support: 'super'.repeat(201) }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad channel', async function () {\n      const fields = { ...baseCorrectParams, channelId: 545454 }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with too many tags', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6' ] }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too low', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 't' ] }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a tag length too big', async function () {\n      const fields = { ...baseCorrectParams, tags: [ 'tag1', 'my_super_tag_too_long_long_long_long_long_long' ] }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad schedule update (miss updateAt)', async function () {\n      const fields = { ...baseCorrectParams, scheduleUpdate: { privacy: VideoPrivacy.PUBLIC } }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad schedule update (wrong updateAt)', async function () {\n      const fields = { ...baseCorrectParams, scheduleUpdate: { updateAt: 'toto', privacy: VideoPrivacy.PUBLIC } }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with a bad originally published at param', async function () {\n      const fields = { ...baseCorrectParams, originallyPublishedAt: 'toto' }\n\n      await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n    })\n\n    it('Should fail with an incorrect thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with a big thumbnail file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        thumbnailfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with an incorrect preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: join(root(), 'server', 'tests', 'fixtures', 'video_short.mp4')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with a big preview file', async function () {\n      const fields = baseCorrectParams\n      const attaches = {\n        previewfile: join(root(), 'server', 'tests', 'fixtures', 'preview-big.png')\n      }\n\n      await makeUploadRequest({\n        url: server.url,\n        method: 'PUT',\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        attaches\n      })\n    })\n\n    it('Should fail with a video of another user without the appropriate right', async function () {\n      const fields = baseCorrectParams\n\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + video.shortUUID,\n        token: userAccessToken,\n        fields,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should fail with a video of another server')\n\n    it('Shoud report the appropriate error', async function () {\n      const fields = { ...baseCorrectParams, licence: 125 }\n\n      const res = await makePutBodyRequest({ url: server.url, path: path + video.shortUUID, token: server.accessToken, fields })\n      const error = res.body as PeerTubeProblemDocument\n\n      expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/putVideo')\n\n      expect(error.type).to.equal('about:blank')\n      expect(error.title).to.equal('Bad Request')\n\n      expect(error.detail).to.equal('Incorrect request parameters: licence')\n      expect(error.error).to.equal('Incorrect request parameters: licence')\n\n      expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n      expect(error['invalid-params'].licence).to.exist\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = baseCorrectParams\n\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + video.shortUUID,\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When getting a video', function () {\n    it('Should return the list of the videos with nothing', async function () {\n      const res = await makeGetRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.OK_200\n      })\n\n      expect(res.body.data).to.be.an('array')\n      expect(res.body.data.length).to.equal(6)\n    })\n\n    it('Should fail without a correct uuid', async function () {\n      await server.videos.get({ id: 'coucou', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n    })\n\n    it('Should return 404 with an incorrect video', async function () {\n      await server.videos.get({ id: '4da6fde3-88f7-4d16-b119-108df5630b06', expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Shoud report the appropriate error', async function () {\n      const body = await server.videos.get({ id: 'hi', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n      const error = body as unknown as PeerTubeProblemDocument\n\n      expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/getVideo')\n\n      expect(error.type).to.equal('about:blank')\n      expect(error.title).to.equal('Bad Request')\n\n      expect(error.detail).to.equal('Incorrect request parameters: id')\n      expect(error.error).to.equal('Incorrect request parameters: id')\n\n      expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n      expect(error['invalid-params'].id).to.exist\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await server.videos.get({ id: video.shortUUID })\n    })\n  })\n\n  describe('When rating a video', function () {\n    let videoId: number\n\n    before(async function () {\n      const { data } = await server.videos.list()\n      videoId = data[0].id\n    })\n\n    it('Should fail without a valid uuid', async function () {\n      const fields = {\n        rating: 'like'\n      }\n      await makePutBodyRequest({ url: server.url, path: path + 'blabla/rate', token: server.accessToken, fields })\n    })\n\n    it('Should fail with an unknown id', async function () {\n      const fields = {\n        rating: 'like'\n      }\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + '4da6fde3-88f7-4d16-b119-108df5630b06/rate',\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NOT_FOUND_404\n      })\n    })\n\n    it('Should fail with a wrong rating', async function () {\n      const fields = {\n        rating: 'likes'\n      }\n      await makePutBodyRequest({ url: server.url, path: path + videoId + '/rate', token: server.accessToken, fields })\n    })\n\n    it('Should fail with a private video of another user', async function () {\n      const fields = {\n        rating: 'like'\n      }\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + privateVideo.uuid + '/rate',\n        token: userAccessToken,\n        fields,\n        expectedStatus: HttpStatusCode.FORBIDDEN_403\n      })\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      const fields = {\n        rating: 'like'\n      }\n      await makePutBodyRequest({\n        url: server.url,\n        path: path + videoId + '/rate',\n        token: server.accessToken,\n        fields,\n        expectedStatus: HttpStatusCode.NO_CONTENT_204\n      })\n    })\n  })\n\n  describe('When removing a video', function () {\n    it('Should have 404 with nothing', async function () {\n      await makeDeleteRequest({\n        url: server.url,\n        path,\n        expectedStatus: HttpStatusCode.BAD_REQUEST_400\n      })\n    })\n\n    it('Should fail without a correct uuid', async function () {\n      await server.videos.remove({ id: 'hello', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n    })\n\n    it('Should fail with a video which does not exist', async function () {\n      await server.videos.remove({ id: '4da6fde3-88f7-4d16-b119-108df5630b06', expectedStatus: HttpStatusCode.NOT_FOUND_404 })\n    })\n\n    it('Should fail with a video of another user without the appropriate right', async function () {\n      await server.videos.remove({ token: userAccessToken, id: video.uuid, expectedStatus: HttpStatusCode.FORBIDDEN_403 })\n    })\n\n    it('Should fail with a video of another server')\n\n    it('Shoud report the appropriate error', async function () {\n      const body = await server.videos.remove({ id: 'hello', expectedStatus: HttpStatusCode.BAD_REQUEST_400 })\n      const error = body as PeerTubeProblemDocument\n\n      expect(error.docs).to.equal('https://docs.joinpeertube.org/api-rest-reference.html#operation/delVideo')\n\n      expect(error.type).to.equal('about:blank')\n      expect(error.title).to.equal('Bad Request')\n\n      expect(error.detail).to.equal('Incorrect request parameters: id')\n      expect(error.error).to.equal('Incorrect request parameters: id')\n\n      expect(error.status).to.equal(HttpStatusCode.BAD_REQUEST_400)\n      expect(error['invalid-params'].id).to.exist\n    })\n\n    it('Should succeed with the correct parameters', async function () {\n      await server.videos.remove({ id: video.uuid })\n    })\n  })\n\n  after(async function () {\n    await cleanupTests([ server ])\n  })\n})\n"], "filenames": ["server/middlewares/validators/videos/video-comments.ts", "server/middlewares/validators/videos/video-rates.ts", "server/tests/api/check-params/video-comments.ts", "server/tests/api/check-params/videos.ts"], "buggy_code_start_loc": [102, 11, 21, 30], "buggy_code_end_loc": [121, 22, 275, 785], "fixing_code_start_loc": [103, 11, 22, 31], "fixing_code_end_loc": [138, 30, 303, 804], "type": "CWE-863", "message": "Improper Authorization in GitHub repository chocobozzz/peertube prior to 4.1.0.", "other": {"cve": {"id": "CVE-2022-0726", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-23T14:15:07.930", "lastModified": "2022-04-05T20:15:00.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Authorization in GitHub repository chocobozzz/peertube prior to 4.1.0."}, {"lang": "es", "value": "Una Autorizaci\u00f3n Incorrecta en el repositorio de GitHub chocobozzz/peertube versiones anteriores a 4.1.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:framasoft:peertube:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.0", "matchCriteriaId": "5AC7935A-1B57-4A2A-BC91-2A5381DB00E0"}]}]}], "references": [{"url": "https://github.com/chocobozzz/peertube/commit/6ea9295b8f5dd7cc254202a79aad61c666cc4259", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8928ab08-7fcb-475e-8da7-18e8412c1ac3", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chocobozzz/peertube/commit/6ea9295b8f5dd7cc254202a79aad61c666cc4259"}}