{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990,1991,2001,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(krb5_kdc_req *,krb5_db_entry **);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_int32\nprep_reprocess_req(krb5_kdc_req *,krb5_principal *);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(krb5_data *pkt, const krb5_fulladdr *from,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock * tgskey = 0;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    krb5_transited enc_tkt_transited;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_timestamp rtime;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    char *cname = 0, *sname = 0, *altcname = 0;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    krb5_enctype useenctype;\n    int errcode, errcode2;\n    register int i;\n    int firstpass = 1;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *krbtgt = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    char *s4u_name = NULL;\n    krb5_boolean is_referral, db_ref_done = FALSE;\n    const char *emsg = NULL;\n    krb5_data *tgs_1 =NULL, *server_1 = NULL;\n    krb5_principal krbtgt_princ;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n\n    reply.padata = 0; /* For cleanup handler */\n    reply_encpart.enc_padata = 0;\n    enc_tkt_reply.authorization_data = NULL;\n\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    if ((retval = setup_server_realm(request->server))) {\n        krb5_free_kdc_req(kdc_context, request);\n        return retval;\n    }\n    errcode = kdc_process_tgs_req(request, from, pkt, &header_ticket,\n                                  &krbtgt, &tgskey, &subkey, &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2 &&\n        (errcode2 = krb5_unparse_name(kdc_context,\n                                      header_ticket->enc_part2->client,\n                                      &cname))) {\n        status = \"UNPARSING CLIENT\";\n        errcode = errcode2;\n        goto cleanup;\n    }\n    limit_string(cname);\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kdc_make_rstate(&state);\n    if (errcode !=0) {\n        status = \"making state\";\n        goto cleanup;\n    }\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    if (errcode !=0) {\n        status = \"kdc_find_fast\";\n        goto cleanup;\n    }\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    db_ref_done = FALSE;\nref_tgt_again:\n    if ((errcode = krb5_unparse_name(kdc_context, request->server, &sname))) {\n        status = \"UNPARSING SERVER\";\n        goto cleanup;\n    }\n    limit_string(sname);\n\n    errcode = krb5_db_get_principal(kdc_context, request->server,\n                                    s_flags, &server);\n    if (errcode && errcode != KRB5_KDB_NOENTRY) {\n        status = \"LOOKING_UP_SERVER\";\n        goto cleanup;\n    }\ntgt_again:\n    if (errcode == KRB5_KDB_NOENTRY) {\n        /*\n         * might be a request for a TGT for some other realm; we\n         * should do our best to find such a TGS in this db\n         */\n        if (firstpass ) {\n\n            if ( krb5_is_tgs_principal(request->server) == TRUE) {\n                /* Principal is a name of krb ticket service */\n                if (krb5_princ_size(kdc_context, request->server) == 2) {\n\n                    server_1 = krb5_princ_component(kdc_context,\n                                                    request->server, 1);\n                    tgs_1 = krb5_princ_component(kdc_context, tgs_server, 1);\n\n                    if (!tgs_1 || !data_eq(*server_1, *tgs_1)) {\n                        errcode = find_alternate_tgs(request, &server);\n                        firstpass = 0;\n                        if (errcode == 0)\n                            goto tgt_again;\n                    }\n                }\n                status = \"UNKNOWN_SERVER\";\n                errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n                goto cleanup;\n\n            } else if ( db_ref_done == FALSE) {\n                retval = prep_reprocess_req(request, &krbtgt_princ);\n                if (!retval) {\n                    krb5_free_principal(kdc_context, request->server);\n                    retval = krb5_copy_principal(kdc_context, krbtgt_princ,\n                                                 &(request->server));\n                    if (!retval) {\n                        db_ref_done = TRUE;\n                        if (sname != NULL)\n                            free(sname);\n                        goto ref_tgt_again;\n                    }\n                }\n            }\n        }\n\n        status = \"UNKNOWN_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    is_referral = krb5_is_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, tgs_server, server->princ);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_context,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    /*\n     * We pick the session keytype here....\n     *\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    useenctype = 0;\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY |\n                  KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        krb5_keyblock  * st_sealing_key;\n        krb5_kvno        st_srv_kvno;\n        krb5_enctype     etype;\n        krb5_db_entry    *st_client;\n\n        /*\n         * Get the key for the second ticket, and decrypt it.\n         */\n        if ((errcode = kdc_get_server_key(request->second_ticket[st_idx],\n                                          c_flags,\n                                          TRUE, /* match_enctype */\n                                          &st_client,\n                                          &st_sealing_key,\n                                          &st_srv_kvno))) {\n            status = \"2ND_TKT_SERVER\";\n            goto cleanup;\n        }\n        errcode = krb5_decrypt_tkt_part(kdc_context, st_sealing_key,\n                                        request->second_ticket[st_idx]);\n        krb5_free_keyblock(kdc_context, st_sealing_key);\n        if (errcode) {\n            status = \"2ND_TKT_DECRYPT\";\n            krb5_db_free_principal(kdc_context, st_client);\n            goto cleanup;\n        }\n\n        etype = request->second_ticket[st_idx]->enc_part2->session->enctype;\n        if (!krb5_c_valid_enctype(etype)) {\n            status = \"BAD_ETYPE_IN_2ND_TKT\";\n            errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n            krb5_db_free_principal(kdc_context, st_client);\n            goto cleanup;\n        }\n\n        for (i = 0; i < request->nktypes; i++) {\n            if (request->ktype[i] == etype) {\n                useenctype = etype;\n                break;\n            }\n        }\n\n        if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n            /* Do constrained delegation protocol and authorization checks */\n            errcode = kdc_process_s4u2proxy_req(kdc_context,\n                                                request,\n                                                request->second_ticket[st_idx]->enc_part2,\n                                                st_client,\n                                                header_ticket->enc_part2->client,\n                                                request->server,\n                                                &status);\n            if (errcode)\n                goto cleanup;\n\n            setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n            assert(krb5_is_tgs_principal(header_ticket->server));\n\n            assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n            client = st_client;\n        } else {\n            /* \"client\" is not used for user2user */\n            krb5_db_free_principal(kdc_context, st_client);\n        }\n    }\n\n    /*\n     * Select the keytype for the ticket session key.\n     */\n    if ((useenctype == 0) &&\n        (useenctype = select_session_keytype(kdc_context, server,\n                                             request->nktypes,\n                                             request->ktype)) == 0) {\n        /* unsupported ktype */\n        status = \"BAD_ENCRYPTION_TYPE\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    errcode = krb5_c_make_random_key(kdc_context, useenctype, &session_key);\n\n    if (errcode) {\n        /* random key failed */\n        status = \"RANDOM_KEY_FAILED\";\n        goto cleanup;\n    }\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = 0;\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /*\n     * Fix header_ticket's starttime; if it's zero, fill in the\n     * authtime's value.\n     */\n    if (!(header_enc_tkt->times.starttime))\n        header_enc_tkt->times.starttime = authtime;\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDED))\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXIABLE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXY);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_MAY_POSTDATE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_POSTDATED);\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_life = enc_tkt_reply.times.endtime - enc_tkt_reply.times.starttime;\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            min(header_ticket->enc_part2->times.renew_till,\n                kdc_time + old_life);\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_context, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n\n        if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n            (enc_tkt_reply.times.endtime < request->till) &&\n            isflagset(header_enc_tkt->flags, TKT_FLG_RENEWABLE)) {\n            setflag(request->kdc_options, KDC_OPT_RENEWABLE);\n            request->rtime =\n                min(request->till, header_enc_tkt->times.renew_till);\n        }\n    }\n    rtime = (request->rtime == 0) ? kdc_infinity : request->rtime;\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE)) {\n        /* already checked above in policy check to reject request for a\n           renewable ticket using a non-renewable ticket */\n        setflag(enc_tkt_reply.flags, TKT_FLG_RENEWABLE);\n        enc_tkt_reply.times.renew_till =\n            min(rtime,\n                min(header_enc_tkt->times.renew_till,\n                    enc_tkt_reply.times.starttime +\n                    min(server->max_renewable_life,\n                        max_renewable_life_for_realm)));\n    } else {\n        enc_tkt_reply.times.renew_till = 0;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        setflag(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /*\n     * Propagate the preauthentication flags through to the returned ticket.\n     */\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_PRE_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PRE_AUTH);\n\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_HW_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_HW_AUTH);\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        errcode = krb5_unparse_name(kdc_context, s4u_x509_user->user_id.user,\n                                    &s4u_name);\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        errcode = krb5_unparse_name(kdc_context, subject_tkt->client,\n                                    &s4u_name);\n    } else {\n        errcode = 0;\n    }\n    if (errcode) {\n        status = \"UNPARSING S4U CLIENT\";\n        goto cleanup;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server, krbtgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              tgskey,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (realm_compare(header_ticket->server, tgs_server) ||\n        realm_compare(header_ticket->server, enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"BAD_TRTYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        enc_tkt_transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        enc_tkt_transited.magic = 0;\n        enc_tkt_transited.tr_contents.magic = 0;\n        enc_tkt_transited.tr_contents.data = 0;\n        enc_tkt_transited.tr_contents.length = 0;\n        enc_tkt_reply.transited = enc_tkt_transited;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TR_FAIL\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, krbtgt);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        unsigned int tlen;\n        char *tdots;\n\n        errcode = kdc_check_transited_list (kdc_context,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        tlen = enc_tkt_reply.transited.tr_contents.length;\n        tdots = tlen > 125 ? \"...\" : \"\";\n        tlen = tlen > 125 ? 125 : tlen;\n\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else if (errcode == KRB5KRB_AP_ERR_ILL_CR_TKT)\n            krb5_klog_syslog(LOG_INFO, _(\"bad realm transit path from '%s' \"\n                                         \"to '%s' via '%.*s%s'\"),\n                             cname ? cname : \"<unknown client>\",\n                             sname ? sname : \"<unknown server>\", tlen,\n                             enc_tkt_reply.transited.tr_contents.data, tdots);\n        else {\n            emsg = krb5_get_error_message(kdc_context, errcode);\n            krb5_klog_syslog(LOG_ERR, _(\"unexpected error checking transit \"\n                                        \"from '%s' to '%s' via '%.*s%s': %s\"),\n                             cname ? cname : \"<unknown client>\",\n                             sname ? sname : \"<unknown server>\", tlen,\n                             enc_tkt_reply.transited.tr_contents.data, tdots,\n                             emsg);\n            krb5_free_error_message(kdc_context, emsg);\n            emsg = NULL;\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (reject_bad_transit\n        && !isflagset (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            if ((errcode = krb5_unparse_name(kdc_context, client2, &altcname)))\n                altcname = 0;\n            if (altcname != NULL)\n                limit_string(altcname);\n\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"TKT_ENCRYPT\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        find_pa_data(request->padata, KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"KDC_RETURN_S4U2SELF_PADATA\";\n            goto cleanup;\n        }\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"Preparing FAST padata\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"generating reply key\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n    log_tgs_req(from, request, &reply, cname, sname, altcname, authtime,\n                c_flags, s4u_name, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > 128)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    if (cname != NULL)\n        free(cname);\n    if (sname != NULL)\n        free(sname);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    krb5_db_free_principal(kdc_context, client);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (s4u_name != NULL)\n        free(s4u_name);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (tgskey != NULL)\n        krb5_free_keyblock(kdc_context, tgskey);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    if (state) {\n        retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                       &errpkt, &fast_edata);\n    }\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(krb5_kdc_req *request, krb5_db_entry **server_ptr)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2, tmpprinc;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n\n    /*\n     * Call to krb5_princ_component is normally not safe but is so\n     * here only because find_alternate_tgs() is only called from\n     * somewhere that has already checked the number of components in\n     * the principal.\n     */\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, request->server),\n                                       krb5_princ_component(kdc_context, request->server, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR)))\n        return retval;\n\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = krb5_db_get_principal(kdc_context, *pl2, 0, &server);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        /* Found it. */\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = krb5_copy_principal(kdc_context, *pl2, &tmpprinc);\n        if (retval)\n            goto cleanup;\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n\n        krb5_free_principal(kdc_context, request->server);\n        request->server = tmpprinc;\n        log_tgs_alt_tgt(request->server);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\n    retval = KRB5_KDB_NOENTRY;\n\ncleanup:\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\nstatic krb5_int32\nprep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH;\n    char **realms, **cpp, *temp_buf=NULL;\n    krb5_data *comp1 = NULL, *comp2 = NULL;\n    char *comp1_str = NULL;\n\n    /* By now we know that server principal name is unknown.\n     * If CANONICALIZE flag is set in the request\n     * If req is not U2U authn. req\n     * the requested server princ. has exactly two components\n     * either\n     *      the name type is NT-SRV-HST\n     *      or name type is NT-UNKNOWN and\n     *         the 1st component is listed in conf file under host_based_services\n     * the 1st component is not in a list in conf under \"no_host_referral\"\n     * the 2d component looks like fully-qualified domain name (FQDN)\n     * If all of these conditions are satisfied - try mapping the FQDN and\n     * re-process the request as if client had asked for cross-realm TGT.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE) &&\n        !isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY) &&\n        krb5_princ_size(kdc_context, request->server) == 2) {\n\n        comp1 = krb5_princ_component(kdc_context, request->server, 0);\n        comp2 = krb5_princ_component(kdc_context, request->server, 1);\n\n        comp1_str = calloc(1,comp1->length+1);\n        if (!comp1_str) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        strlcpy(comp1_str,comp1->data,comp1->length+1);\n\n        if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||\n             krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||\n             (krb5_princ_type(kdc_context, request->server) == KRB5_NT_UNKNOWN &&\n              kdc_active_realm->realm_host_based_services != NULL &&\n              (krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         comp1_str) == TRUE ||\n               krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         KRB5_CONF_ASTERISK) == TRUE))) &&\n            (kdc_active_realm->realm_no_host_referral == NULL ||\n             (krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        KRB5_CONF_ASTERISK) == FALSE &&\n              krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        comp1_str) == FALSE))) {\n\n            if (memchr(comp2->data, '.', comp2->length) == NULL)\n                goto cleanup;\n            temp_buf = calloc(1, comp2->length+1);\n            if (!temp_buf) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n            strlcpy(temp_buf, comp2->data,comp2->length+1);\n            retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);\n            free(temp_buf);\n            if (retval) {\n                /* no match found */\n                kdc_err(kdc_context, retval, \"unable to find realm of host\");\n                goto cleanup;\n            }\n            if (realms == 0) {\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Don't return a referral to the null realm or the service\n             * realm. */\n            if (realms[0] == 0 ||\n                data_eq_string(request->server->realm, realms[0])) {\n                free(realms[0]);\n                free(realms);\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Modify request.\n             * Construct cross-realm tgt :  krbtgt/REMOTE_REALM@LOCAL_REALM\n             * and use it as a principal in this req.\n             */\n            retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                          (*request->server).realm.length,\n                                          (*request->server).realm.data,\n                                          \"krbtgt\", realms[0], (char *)0);\n            for (cpp = realms; *cpp; cpp++)\n                free(*cpp);\n        }\n    }\ncleanup:\n    free(comp1_str);\n\n    return retval;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990,1991,2001,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(krb5_kdc_req *,krb5_db_entry **);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_int32\nprep_reprocess_req(krb5_kdc_req *,krb5_principal *);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(krb5_data *pkt, const krb5_fulladdr *from,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock * tgskey = 0;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    krb5_transited enc_tkt_transited;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_timestamp rtime;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    char *cname = 0, *sname = 0, *altcname = 0;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    krb5_enctype useenctype;\n    int errcode, errcode2;\n    register int i;\n    int firstpass = 1;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *krbtgt = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    char *s4u_name = NULL;\n    krb5_boolean is_referral, db_ref_done = FALSE;\n    const char *emsg = NULL;\n    krb5_data *tgs_1 =NULL, *server_1 = NULL;\n    krb5_principal krbtgt_princ;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n\n    reply.padata = 0; /* For cleanup handler */\n    reply_encpart.enc_padata = 0;\n    enc_tkt_reply.authorization_data = NULL;\n\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    if ((retval = setup_server_realm(request->server))) {\n        krb5_free_kdc_req(kdc_context, request);\n        return retval;\n    }\n    errcode = kdc_process_tgs_req(request, from, pkt, &header_ticket,\n                                  &krbtgt, &tgskey, &subkey, &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2 &&\n        (errcode2 = krb5_unparse_name(kdc_context,\n                                      header_ticket->enc_part2->client,\n                                      &cname))) {\n        status = \"UNPARSING CLIENT\";\n        errcode = errcode2;\n        goto cleanup;\n    }\n    limit_string(cname);\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kdc_make_rstate(&state);\n    if (errcode !=0) {\n        status = \"making state\";\n        goto cleanup;\n    }\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    if (errcode !=0) {\n        status = \"kdc_find_fast\";\n        goto cleanup;\n    }\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    db_ref_done = FALSE;\nref_tgt_again:\n    if ((errcode = krb5_unparse_name(kdc_context, request->server, &sname))) {\n        status = \"UNPARSING SERVER\";\n        goto cleanup;\n    }\n    limit_string(sname);\n\n    errcode = krb5_db_get_principal(kdc_context, request->server,\n                                    s_flags, &server);\n    if (errcode && errcode != KRB5_KDB_NOENTRY) {\n        status = \"LOOKING_UP_SERVER\";\n        goto cleanup;\n    }\ntgt_again:\n    if (errcode == KRB5_KDB_NOENTRY) {\n        /*\n         * might be a request for a TGT for some other realm; we\n         * should do our best to find such a TGS in this db\n         */\n        if (firstpass ) {\n\n            if ( krb5_is_tgs_principal(request->server) == TRUE) {\n                /* Principal is a name of krb ticket service */\n                if (krb5_princ_size(kdc_context, request->server) == 2) {\n\n                    server_1 = krb5_princ_component(kdc_context,\n                                                    request->server, 1);\n                    tgs_1 = krb5_princ_component(kdc_context, tgs_server, 1);\n\n                    if (!tgs_1 || !data_eq(*server_1, *tgs_1)) {\n                        errcode = find_alternate_tgs(request, &server);\n                        firstpass = 0;\n                        if (errcode == 0)\n                            goto tgt_again;\n                    }\n                }\n                status = \"UNKNOWN_SERVER\";\n                errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n                goto cleanup;\n\n            } else if ( db_ref_done == FALSE) {\n                retval = prep_reprocess_req(request, &krbtgt_princ);\n                if (!retval) {\n                    krb5_free_principal(kdc_context, request->server);\n                    retval = krb5_copy_principal(kdc_context, krbtgt_princ,\n                                                 &(request->server));\n                    if (!retval) {\n                        db_ref_done = TRUE;\n                        if (sname != NULL)\n                            free(sname);\n                        goto ref_tgt_again;\n                    }\n                }\n            }\n        }\n\n        status = \"UNKNOWN_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    is_referral = krb5_is_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, tgs_server, server->princ);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_context,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    /*\n     * We pick the session keytype here....\n     *\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    useenctype = 0;\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY |\n                  KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        krb5_keyblock  * st_sealing_key;\n        krb5_kvno        st_srv_kvno;\n        krb5_enctype     etype;\n        krb5_db_entry    *st_client;\n\n        /*\n         * Get the key for the second ticket, and decrypt it.\n         */\n        if ((errcode = kdc_get_server_key(request->second_ticket[st_idx],\n                                          c_flags,\n                                          TRUE, /* match_enctype */\n                                          &st_client,\n                                          &st_sealing_key,\n                                          &st_srv_kvno))) {\n            status = \"2ND_TKT_SERVER\";\n            goto cleanup;\n        }\n        errcode = krb5_decrypt_tkt_part(kdc_context, st_sealing_key,\n                                        request->second_ticket[st_idx]);\n        krb5_free_keyblock(kdc_context, st_sealing_key);\n        if (errcode) {\n            status = \"2ND_TKT_DECRYPT\";\n            krb5_db_free_principal(kdc_context, st_client);\n            goto cleanup;\n        }\n\n        etype = request->second_ticket[st_idx]->enc_part2->session->enctype;\n        if (!krb5_c_valid_enctype(etype)) {\n            status = \"BAD_ETYPE_IN_2ND_TKT\";\n            errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n            krb5_db_free_principal(kdc_context, st_client);\n            goto cleanup;\n        }\n\n        for (i = 0; i < request->nktypes; i++) {\n            if (request->ktype[i] == etype) {\n                useenctype = etype;\n                break;\n            }\n        }\n\n        if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n            /* Do constrained delegation protocol and authorization checks */\n            errcode = kdc_process_s4u2proxy_req(kdc_context,\n                                                request,\n                                                request->second_ticket[st_idx]->enc_part2,\n                                                st_client,\n                                                header_ticket->enc_part2->client,\n                                                request->server,\n                                                &status);\n            if (errcode)\n                goto cleanup;\n\n            setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n            assert(krb5_is_tgs_principal(header_ticket->server));\n\n            assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n            client = st_client;\n        } else {\n            /* \"client\" is not used for user2user */\n            krb5_db_free_principal(kdc_context, st_client);\n        }\n    }\n\n    /*\n     * Select the keytype for the ticket session key.\n     */\n    if ((useenctype == 0) &&\n        (useenctype = select_session_keytype(kdc_context, server,\n                                             request->nktypes,\n                                             request->ktype)) == 0) {\n        /* unsupported ktype */\n        status = \"BAD_ENCRYPTION_TYPE\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n\n    errcode = krb5_c_make_random_key(kdc_context, useenctype, &session_key);\n\n    if (errcode) {\n        /* random key failed */\n        status = \"RANDOM_KEY_FAILED\";\n        goto cleanup;\n    }\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = 0;\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /*\n     * Fix header_ticket's starttime; if it's zero, fill in the\n     * authtime's value.\n     */\n    if (!(header_enc_tkt->times.starttime))\n        header_enc_tkt->times.starttime = authtime;\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDED))\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXIABLE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXY);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_MAY_POSTDATE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_POSTDATED);\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_life = enc_tkt_reply.times.endtime - enc_tkt_reply.times.starttime;\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            min(header_ticket->enc_part2->times.renew_till,\n                kdc_time + old_life);\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_context, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n\n        if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n            (enc_tkt_reply.times.endtime < request->till) &&\n            isflagset(header_enc_tkt->flags, TKT_FLG_RENEWABLE)) {\n            setflag(request->kdc_options, KDC_OPT_RENEWABLE);\n            request->rtime =\n                min(request->till, header_enc_tkt->times.renew_till);\n        }\n    }\n    rtime = (request->rtime == 0) ? kdc_infinity : request->rtime;\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE)) {\n        /* already checked above in policy check to reject request for a\n           renewable ticket using a non-renewable ticket */\n        setflag(enc_tkt_reply.flags, TKT_FLG_RENEWABLE);\n        enc_tkt_reply.times.renew_till =\n            min(rtime,\n                min(header_enc_tkt->times.renew_till,\n                    enc_tkt_reply.times.starttime +\n                    min(server->max_renewable_life,\n                        max_renewable_life_for_realm)));\n    } else {\n        enc_tkt_reply.times.renew_till = 0;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        setflag(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /*\n     * Propagate the preauthentication flags through to the returned ticket.\n     */\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_PRE_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PRE_AUTH);\n\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_HW_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_HW_AUTH);\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        errcode = krb5_unparse_name(kdc_context, s4u_x509_user->user_id.user,\n                                    &s4u_name);\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        errcode = krb5_unparse_name(kdc_context, subject_tkt->client,\n                                    &s4u_name);\n    } else {\n        errcode = 0;\n    }\n    if (errcode) {\n        status = \"UNPARSING S4U CLIENT\";\n        goto cleanup;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server, krbtgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              tgskey,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (realm_compare(header_ticket->server, tgs_server) ||\n        realm_compare(header_ticket->server, enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"BAD_TRTYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        enc_tkt_transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        enc_tkt_transited.magic = 0;\n        enc_tkt_transited.tr_contents.magic = 0;\n        enc_tkt_transited.tr_contents.data = 0;\n        enc_tkt_transited.tr_contents.length = 0;\n        enc_tkt_reply.transited = enc_tkt_transited;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TR_FAIL\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, krbtgt);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        unsigned int tlen;\n        char *tdots;\n\n        errcode = kdc_check_transited_list (kdc_context,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        tlen = enc_tkt_reply.transited.tr_contents.length;\n        tdots = tlen > 125 ? \"...\" : \"\";\n        tlen = tlen > 125 ? 125 : tlen;\n\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else if (errcode == KRB5KRB_AP_ERR_ILL_CR_TKT)\n            krb5_klog_syslog(LOG_INFO, _(\"bad realm transit path from '%s' \"\n                                         \"to '%s' via '%.*s%s'\"),\n                             cname ? cname : \"<unknown client>\",\n                             sname ? sname : \"<unknown server>\", tlen,\n                             enc_tkt_reply.transited.tr_contents.data, tdots);\n        else {\n            emsg = krb5_get_error_message(kdc_context, errcode);\n            krb5_klog_syslog(LOG_ERR, _(\"unexpected error checking transit \"\n                                        \"from '%s' to '%s' via '%.*s%s': %s\"),\n                             cname ? cname : \"<unknown client>\",\n                             sname ? sname : \"<unknown server>\", tlen,\n                             enc_tkt_reply.transited.tr_contents.data, tdots,\n                             emsg);\n            krb5_free_error_message(kdc_context, emsg);\n            emsg = NULL;\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (reject_bad_transit\n        && !isflagset (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            if ((errcode = krb5_unparse_name(kdc_context, client2, &altcname)))\n                altcname = 0;\n            if (altcname != NULL)\n                limit_string(altcname);\n\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"TKT_ENCRYPT\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        find_pa_data(request->padata, KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"KDC_RETURN_S4U2SELF_PADATA\";\n            goto cleanup;\n        }\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"Preparing FAST padata\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"generating reply key\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n    log_tgs_req(from, request, &reply, cname, sname, altcname, authtime,\n                c_flags, s4u_name, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > 128)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    if (cname != NULL)\n        free(cname);\n    if (sname != NULL)\n        free(sname);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    krb5_db_free_principal(kdc_context, client);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (s4u_name != NULL)\n        free(s4u_name);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (tgskey != NULL)\n        krb5_free_keyblock(kdc_context, tgskey);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    if (state) {\n        retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                       &errpkt, &fast_edata);\n    }\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(krb5_kdc_req *request, krb5_db_entry **server_ptr)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2, tmpprinc;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n\n    /*\n     * Call to krb5_princ_component is normally not safe but is so\n     * here only because find_alternate_tgs() is only called from\n     * somewhere that has already checked the number of components in\n     * the principal.\n     */\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, request->server),\n                                       krb5_princ_component(kdc_context, request->server, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR)))\n        return retval;\n\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = krb5_db_get_principal(kdc_context, *pl2, 0, &server);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        /* Found it. */\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = krb5_copy_principal(kdc_context, *pl2, &tmpprinc);\n        if (retval)\n            goto cleanup;\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n\n        krb5_free_principal(kdc_context, request->server);\n        request->server = tmpprinc;\n        log_tgs_alt_tgt(request->server);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\n    retval = KRB5_KDB_NOENTRY;\n\ncleanup:\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\nstatic krb5_int32\nprep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH;\n    char **realms, **cpp, *temp_buf=NULL;\n    krb5_data *comp1 = NULL, *comp2 = NULL;\n    char *comp1_str = NULL;\n\n    /* By now we know that server principal name is unknown.\n     * If CANONICALIZE flag is set in the request\n     * If req is not U2U authn. req\n     * the requested server princ. has exactly two components\n     * either\n     *      the name type is NT-SRV-HST\n     *      or name type is NT-UNKNOWN and\n     *         the 1st component is listed in conf file under host_based_services\n     * the 1st component is not in a list in conf under \"no_host_referral\"\n     * the 2d component looks like fully-qualified domain name (FQDN)\n     * If all of these conditions are satisfied - try mapping the FQDN and\n     * re-process the request as if client had asked for cross-realm TGT.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE) &&\n        !isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY) &&\n        krb5_princ_size(kdc_context, request->server) == 2) {\n\n        comp1 = krb5_princ_component(kdc_context, request->server, 0);\n        comp2 = krb5_princ_component(kdc_context, request->server, 1);\n\n        comp1_str = calloc(1,comp1->length+1);\n        if (!comp1_str) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        if (comp1->data != NULL)\n            memcpy(comp1_str, comp1->data, comp1->length);\n\n        if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||\n             krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||\n             (krb5_princ_type(kdc_context, request->server) == KRB5_NT_UNKNOWN &&\n              kdc_active_realm->realm_host_based_services != NULL &&\n              (krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         comp1_str) == TRUE ||\n               krb5_match_config_pattern(kdc_active_realm->realm_host_based_services,\n                                         KRB5_CONF_ASTERISK) == TRUE))) &&\n            (kdc_active_realm->realm_no_host_referral == NULL ||\n             (krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        KRB5_CONF_ASTERISK) == FALSE &&\n              krb5_match_config_pattern(kdc_active_realm->realm_no_host_referral,\n                                        comp1_str) == FALSE))) {\n\n            if (memchr(comp2->data, '.', comp2->length) == NULL)\n                goto cleanup;\n            temp_buf = calloc(1, comp2->length+1);\n            if (!temp_buf) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n            if (comp2->data != NULL)\n                memcpy(temp_buf, comp2->data, comp2->length);\n            retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);\n            free(temp_buf);\n            if (retval) {\n                /* no match found */\n                kdc_err(kdc_context, retval, \"unable to find realm of host\");\n                goto cleanup;\n            }\n            if (realms == 0) {\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Don't return a referral to the null realm or the service\n             * realm. */\n            if (realms[0] == 0 ||\n                data_eq_string(request->server->realm, realms[0])) {\n                free(realms[0]);\n                free(realms);\n                retval = KRB5KRB_AP_ERR_BADMATCH;\n                goto cleanup;\n            }\n            /* Modify request.\n             * Construct cross-realm tgt :  krbtgt/REMOTE_REALM@LOCAL_REALM\n             * and use it as a principal in this req.\n             */\n            retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                          (*request->server).realm.length,\n                                          (*request->server).realm.data,\n                                          \"krbtgt\", realms[0], (char *)0);\n            for (cpp = realms; *cpp; cpp++)\n                free(*cpp);\n        }\n    }\ncleanup:\n    free(comp1_str);\n\n    return retval;\n}\n"], "filenames": ["src/kdc/do_tgs_req.c"], "buggy_code_start_loc": [1144], "buggy_code_end_loc": [1168], "fixing_code_start_loc": [1144], "fixing_code_end_loc": [1170], "type": "CWE-476", "message": "The prep_reprocess_req function in do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.5 does not properly perform service-principal realm referral, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted TGS-REQ request.", "other": {"cve": {"id": "CVE-2013-1416", "sourceIdentifier": "cve@mitre.org", "published": "2013-04-19T11:44:26.017", "lastModified": "2021-02-02T18:40:23.900", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The prep_reprocess_req function in do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.5 does not properly perform service-principal realm referral, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted TGS-REQ request."}, {"lang": "es", "value": "La funci\u00f3n prep_reprocess_req en do_tgs_req.c en el Key Distribution Center (KDC) en MIT Kerberos 5 (aka krb5) antes de v1.10.5 no realiza correctamente el servicio \u00e1mbito de referencia principal, lo que permite a usuarios remotos autenticados causar una denegaci\u00f3n de servicio (desreferencia a un puntero nulo y la ca\u00edda del demonio) a trav\u00e9s de una solicitud TGS-REQ modificada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.5", "matchCriteriaId": "ADAAA945-792F-419A-9045-01CE94A74320"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.1:*:*:*:*:*:*:*", "matchCriteriaId": "EBB2C482-D2A4-48B3-ACE7-E1DFDCC409B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "D806A17E-B8F9-466D-807D-3F1E77603DC8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:17:*:*:*:*:*:*:*", "matchCriteriaId": "2DA9D861-3EAF-42F5-B0B6-A4CD7BDD6188"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:18:*:*:*:*:*:*:*", "matchCriteriaId": "E14271AE-1309-48F3-B9C6-D7DEEC488279"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "8A8E07B7-3739-4BEB-88F8-C7F62431E889"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "AF83BB87-B203-48F9-9D06-48A5FE399050"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7600", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/102058.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/102074.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-05/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-06/msg00041.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-06/msg00102.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0748.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:157", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:158", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/8ee70ec63931d1e38567905387ab9b1d45734d81", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/8ee70ec63931d1e38567905387ab9b1d45734d81"}}