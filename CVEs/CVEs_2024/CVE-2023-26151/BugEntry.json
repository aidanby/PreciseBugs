{"buggy_code": ["\"\"\"\nSocket server forwarding request to internal server\n\"\"\"\nimport logging\nimport asyncio\nfrom typing import Optional\n\nfrom ..ua.ua_binary import header_from_binary\nfrom ..common.utils import Buffer, NotEnoughData\nfrom .uaprocessor import UaProcessor\nfrom .internal_server import InternalServer\n\nlogger = logging.getLogger(__name__)\n\n\nclass OPCUAProtocol(asyncio.Protocol):\n    \"\"\"\n    Instantiated for every connection.\n    \"\"\"\n\n    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks):\n        self.peer_name = None\n        self.transport = None\n        self.processor = None\n        self._buffer = b''\n        self.iserver: InternalServer = iserver\n        self.policies = policies\n        self.clients = clients\n        self.closing_tasks = closing_tasks\n        self.messages = asyncio.Queue()\n        self._task = None\n\n    def __str__(self):\n        return f'OPCUAProtocol({self.peer_name}, {self.processor.session})'\n\n    __repr__ = __str__\n\n    def connection_made(self, transport):\n        self.peer_name = transport.get_extra_info('peername')\n        logger.info('New connection from %s', self.peer_name)\n        self.transport = transport\n        self.processor = UaProcessor(self.iserver, self.transport)\n        self.processor.set_policies(self.policies)\n        self.iserver.asyncio_transports.append(transport)\n        self.clients.append(self)\n        self._task = asyncio.create_task(self._process_received_message_loop())\n\n    def connection_lost(self, ex):\n        logger.info('Lost connection from %s, %s', self.peer_name, ex)\n        self.transport.close()\n        self.iserver.asyncio_transports.remove(self.transport)\n        closing_task = asyncio.create_task(self.processor.close())\n        self.closing_tasks.append(closing_task)\n        if self in self.clients:\n            self.clients.remove(self)\n        self.messages.put_nowait((None, None))\n        self._task.cancel()\n\n    def data_received(self, data):\n        self._buffer += data\n        # try to parse the incoming data\n        while self._buffer:\n            try:\n                buf = Buffer(self._buffer)\n                try:\n                    header = header_from_binary(buf)\n                except NotEnoughData:\n                    logger.debug('Not enough data while parsing header from client, waiting for more')\n                    return\n                if len(buf) < header.body_size:\n                    logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,\n                                 len(buf))\n                    return\n                # we have a complete message\n                self.messages.put_nowait((header, buf))\n                self._buffer = self._buffer[(header.header_size + header.body_size):]\n            except Exception:\n                logger.exception('Exception raised while parsing message from client')\n                return\n\n    async def _process_received_message_loop(self):\n        \"\"\"\n        Take message from the queue and try to process it.\n        \"\"\"\n        while True:\n            header, buf = await self.messages.get()\n            if header is None and buf is None:\n                # Connection was closed, end task\n                break\n            try:\n                await self._process_one_msg(header, buf)\n            except Exception:\n                logger.exception('Exception raised while processing message from client')\n\n    async def _process_one_msg(self, header, buf):\n        logger.debug('_process_received_message %s %s', header.body_size, len(buf))\n        ret = await self.processor.process(header, buf)\n        if not ret:\n            logger.info('processor returned False, we close connection from %s', self.peer_name)\n            self.transport.close()\n            return\n\n\nclass BinaryServer:\n    def __init__(self, internal_server: InternalServer, hostname, port):\n        self.logger = logging.getLogger(__name__)\n        self.hostname = hostname\n        self.port = port\n        self.iserver: InternalServer = internal_server\n        self._server: Optional[asyncio.AbstractServer] = None\n        self._policies = []\n        self.clients = []\n        self.closing_tasks = []\n        self.cleanup_task = None\n\n    def set_policies(self, policies):\n        self._policies = policies\n\n    def _make_protocol(self):\n        \"\"\"Protocol Factory\"\"\"\n        return OPCUAProtocol(\n            iserver=self.iserver,\n            policies=self._policies,\n            clients=self.clients,\n            closing_tasks=self.closing_tasks,\n        )\n\n    async def start(self):\n        self._server = await asyncio.get_running_loop().create_server(self._make_protocol, self.hostname, self.port)\n        # get the port and the hostname from the created server socket\n        # only relevant for dynamic port asignment (when self.port == 0)\n        if self.port == 0 and len(self._server.sockets) == 1:\n            # will work for AF_INET and AF_INET6 socket names\n            # these are to only families supported by the create_server call\n            sockname = self._server.sockets[0].getsockname()\n            self.hostname = sockname[0]\n            self.port = sockname[1]\n        self.logger.info('Listening on %s:%s', self.hostname, self.port)\n        self.cleanup_task = asyncio.create_task(self._close_task_loop())\n\n    async def stop(self):\n        self.logger.info('Closing asyncio socket server')\n        for transport in self.iserver.asyncio_transports:\n            transport.close()\n\n        # stop cleanup process and run it a last time\n        self.cleanup_task.cancel()\n        try:\n            await self.cleanup_task\n        except asyncio.CancelledError:\n            pass\n        await self._close_tasks()\n\n        if self._server:\n            asyncio.get_running_loop().call_soon(self._server.close)\n            await self._server.wait_closed()\n\n    async def _close_task_loop(self):\n        while True:\n            await self._close_tasks()\n            await asyncio.sleep(10)\n\n    async def _close_tasks(self):\n        while self.closing_tasks:\n            task = self.closing_tasks.pop()\n            try:\n                await task\n            except asyncio.CancelledError:\n                # this means a stop request has been sent, it should not be catched\n                raise\n            except Exception:\n                logger.exception(\"Unexpected crash in BinaryServer._close_tasks\")\n", "# coding: utf-8\nimport asyncio\nimport pytest\n\nfrom asyncua import Client, Server\nfrom asyncua.ua.uaerrors import BadMaxConnectionsReached\n\nfrom .conftest import port_num, find_free_port\n\npytestmark = pytest.mark.asyncio\n\n\nasync def test_max_connections_1(opc):\n    opc.server.iserver.isession.__class__.max_connections = 1\n    port = opc.server.endpoint.port\n    if port == port_num:\n        # if client we already have one connection\n        with pytest.raises(BadMaxConnectionsReached):\n            async with Client(f'opc.tcp://127.0.0.1:{port}'):\n                pass\n    else:\n        async with Client(f'opc.tcp://127.0.0.1:{port}'):\n            with pytest.raises(BadMaxConnectionsReached):\n                async with Client(f'opc.tcp://127.0.0.1:{port}'):\n                    pass\n    opc.server.iserver.isession.__class__.max_connections = 1000\n\n\nasync def test_safe_disconnect():\n    c = Client(url=\"opc.tcp://example:4840\")\n    await c.disconnect()\n    # second disconnect should be noop\n    await c.disconnect()\n\n\nasync def test_client_connection_lost():\n    # Test the disconnect behavoir\n    port = find_free_port()\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(f'opc.tcp://127.0.0.1:{port}')\n    await srv.start()\n    async with Client(f'opc.tcp://127.0.0.1:{port}', timeout=0.5, watchdog_intervall=1) as cl:\n        await srv.stop()\n        await asyncio.sleep(2)\n        with pytest.raises(ConnectionError):\n            # check if connection is alive\n            await cl.check_connection()\n        # check if exception is correct rethrown on second call\n        with pytest.raises(ConnectionError):\n            await cl.check_connection()\n        # check if a exception is thrown when a normal function is called\n        with pytest.raises(ConnectionError):\n            await cl.get_namespace_array()\n"], "fixing_code": ["\"\"\"\nSocket server forwarding request to internal server\n\"\"\"\nimport logging\nimport asyncio\nfrom typing import Optional\n\nfrom ..ua.ua_binary import header_from_binary\nfrom ..common.utils import Buffer, NotEnoughData\nfrom .uaprocessor import UaProcessor\nfrom .internal_server import InternalServer\n\nlogger = logging.getLogger(__name__)\n\n\nclass OPCUAProtocol(asyncio.Protocol):\n    \"\"\"\n    Instantiated for every connection.\n    \"\"\"\n\n    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks):\n        self.peer_name = None\n        self.transport = None\n        self.processor = None\n        self._buffer = b''\n        self.iserver: InternalServer = iserver\n        self.policies = policies\n        self.clients = clients\n        self.closing_tasks = closing_tasks\n        self.messages = asyncio.Queue()\n        self._task = None\n\n    def __str__(self):\n        return f'OPCUAProtocol({self.peer_name}, {self.processor.session})'\n\n    __repr__ = __str__\n\n    def connection_made(self, transport):\n        self.peer_name = transport.get_extra_info('peername')\n        logger.info('New connection from %s', self.peer_name)\n        self.transport = transport\n        self.processor = UaProcessor(self.iserver, self.transport)\n        self.processor.set_policies(self.policies)\n        self.iserver.asyncio_transports.append(transport)\n        self.clients.append(self)\n        self._task = asyncio.create_task(self._process_received_message_loop())\n\n    def connection_lost(self, ex):\n        logger.info('Lost connection from %s, %s', self.peer_name, ex)\n        self.transport.close()\n        self.iserver.asyncio_transports.remove(self.transport)\n        closing_task = asyncio.create_task(self.processor.close())\n        self.closing_tasks.append(closing_task)\n        if self in self.clients:\n            self.clients.remove(self)\n        self.messages.put_nowait((None, None))\n        self._task.cancel()\n\n    def data_received(self, data):\n        self._buffer += data\n        # try to parse the incoming data\n        while self._buffer:\n            try:\n                buf = Buffer(self._buffer)\n                try:\n                    header = header_from_binary(buf)\n                except NotEnoughData:\n                    # a packet should at least contain a header otherwise it is malformed (8 or 12 bytes)\n                    logger.debug('Not enough data while parsing header from client, empty the buffer')\n                    self.transport.close()\n                    return\n                if header.header_size + header.body_size <= header.header_size:\n                    # malformed header prevent invalid access of your buffer\n                    logger.error(f'Got malformed header {header}')\n                    self.transport.close()\n                else:\n                    if len(buf) < header.body_size:\n                        logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,\n                                    len(buf))\n                        return\n                    # we have a complete message\n                    self.messages.put_nowait((header, buf))\n                    self._buffer = self._buffer[(header.header_size + header.body_size):]\n            except Exception:\n                logger.exception('Exception raised while parsing message from client')\n                return\n\n    async def _process_received_message_loop(self):\n        \"\"\"\n        Take message from the queue and try to process it.\n        \"\"\"\n        while True:\n            header, buf = await self.messages.get()\n            if header is None and buf is None:\n                # Connection was closed, end task\n                break\n            try:\n                await self._process_one_msg(header, buf)\n            except Exception:\n                logger.exception('Exception raised while processing message from client')\n\n    async def _process_one_msg(self, header, buf):\n        logger.debug('_process_received_message %s %s', header.body_size, len(buf))\n        ret = await self.processor.process(header, buf)\n        if not ret:\n            logger.info('processor returned False, we close connection from %s', self.peer_name)\n            self.transport.close()\n            return\n\n\nclass BinaryServer:\n    def __init__(self, internal_server: InternalServer, hostname, port):\n        self.logger = logging.getLogger(__name__)\n        self.hostname = hostname\n        self.port = port\n        self.iserver: InternalServer = internal_server\n        self._server: Optional[asyncio.AbstractServer] = None\n        self._policies = []\n        self.clients = []\n        self.closing_tasks = []\n        self.cleanup_task = None\n\n    def set_policies(self, policies):\n        self._policies = policies\n\n    def _make_protocol(self):\n        \"\"\"Protocol Factory\"\"\"\n        return OPCUAProtocol(\n            iserver=self.iserver,\n            policies=self._policies,\n            clients=self.clients,\n            closing_tasks=self.closing_tasks,\n        )\n\n    async def start(self):\n        self._server = await asyncio.get_running_loop().create_server(self._make_protocol, self.hostname, self.port)\n        # get the port and the hostname from the created server socket\n        # only relevant for dynamic port asignment (when self.port == 0)\n        if self.port == 0 and len(self._server.sockets) == 1:\n            # will work for AF_INET and AF_INET6 socket names\n            # these are to only families supported by the create_server call\n            sockname = self._server.sockets[0].getsockname()\n            self.hostname = sockname[0]\n            self.port = sockname[1]\n        self.logger.info('Listening on %s:%s', self.hostname, self.port)\n        self.cleanup_task = asyncio.create_task(self._close_task_loop())\n\n    async def stop(self):\n        self.logger.info('Closing asyncio socket server')\n        for transport in self.iserver.asyncio_transports:\n            transport.close()\n\n        # stop cleanup process and run it a last time\n        self.cleanup_task.cancel()\n        try:\n            await self.cleanup_task\n        except asyncio.CancelledError:\n            pass\n        await self._close_tasks()\n\n        if self._server:\n            asyncio.get_running_loop().call_soon(self._server.close)\n            await self._server.wait_closed()\n\n    async def _close_task_loop(self):\n        while True:\n            await self._close_tasks()\n            await asyncio.sleep(10)\n\n    async def _close_tasks(self):\n        while self.closing_tasks:\n            task = self.closing_tasks.pop()\n            try:\n                await task\n            except asyncio.CancelledError:\n                # this means a stop request has been sent, it should not be catched\n                raise\n            except Exception:\n                logger.exception(\"Unexpected crash in BinaryServer._close_tasks\")\n", "# coding: utf-8\nimport asyncio\nimport pytest\nimport asyncio\nimport struct\n\nfrom asyncua import Client, Server, ua\nfrom asyncua.ua.uaerrors import BadMaxConnectionsReached\nfrom .conftest import port_num, find_free_port\n\npytestmark = pytest.mark.asyncio\n\n\nasync def test_max_connections_1(opc):\n    opc.server.iserver.isession.__class__.max_connections = 1\n    port = opc.server.endpoint.port\n    if port == port_num:\n        # if client we already have one connection\n        with pytest.raises(BadMaxConnectionsReached):\n            async with Client(f'opc.tcp://127.0.0.1:{port}'):\n                pass\n    else:\n        async with Client(f'opc.tcp://127.0.0.1:{port}'):\n            with pytest.raises(BadMaxConnectionsReached):\n                async with Client(f'opc.tcp://127.0.0.1:{port}'):\n                    pass\n    opc.server.iserver.isession.__class__.max_connections = 1000\n\n\nasync def test_dos_server(opc):\n    # See issue 1013 a crafted packet triggered dos\n    port = opc.server.endpoint.port\n    async with Client(f'opc.tcp://127.0.0.1:{port}') as c:\n        # craft invalid packet that trigger dos\n        message_type, chunk_type, packet_size = [ua.MessageType.SecureOpen, b'E', 0]\n        c.uaclient.protocol.transport.write(struct.pack(\"<3scI\", message_type, chunk_type, packet_size))\n        # sleep to give the server time to handle the message because we bypass the asyncio\n        await asyncio.sleep(1.0)\n        with pytest.raises(ConnectionError):\n            # now try to read a value to see if server is still alive\n            server_time_node = c.get_node(ua.NodeId(ua.ObjectIds.Server_ServerStatus_CurrentTime))\n            await server_time_node.read_value()\n\n\nasync def test_safe_disconnect():\n    c = Client(url=\"opc.tcp://example:4840\")\n    await c.disconnect()\n    # second disconnect should be noop\n    await c.disconnect()\n\n\nasync def test_client_connection_lost():\n    # Test the disconnect behavoir\n    port = find_free_port()\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(f'opc.tcp://127.0.0.1:{port}')\n    await srv.start()\n    async with Client(f'opc.tcp://127.0.0.1:{port}', timeout=0.5, watchdog_intervall=1) as cl:\n        await srv.stop()\n        await asyncio.sleep(2)\n        with pytest.raises(ConnectionError):\n            # check if connection is alive\n            await cl.check_connection()\n        # check if exception is correct rethrown on second call\n        with pytest.raises(ConnectionError):\n            await cl.check_connection()\n        # check if a exception is thrown when a normal function is called\n        with pytest.raises(ConnectionError):\n            await cl.get_namespace_array()\n"], "filenames": ["asyncua/server/binary_server_asyncio.py", "tests/test_connections.py"], "buggy_code_start_loc": [68, 3], "buggy_code_end_loc": [77, 26], "fixing_code_start_loc": [68, 4], "fixing_code_end_loc": [84, 43], "type": "CWE-835", "message": "Versions of the package asyncua before 0.9.96 are vulnerable to Denial of Service (DoS) such that an attacker can send a malformed packet and as a result, the server will enter into an infinite loop and consume excessive memory.", "other": {"cve": {"id": "CVE-2023-26151", "sourceIdentifier": "report@snyk.io", "published": "2023-10-03T05:15:50.507", "lastModified": "2023-11-07T04:09:29.060", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Versions of the package asyncua before 0.9.96 are vulnerable to Denial of Service (DoS) such that an attacker can send a malformed packet and as a result, the server will enter into an infinite loop and consume excessive memory."}, {"lang": "es", "value": "Las versiones del paquete asyncua anteriores a la 0.9.96 son vulnerables a la denegaci\u00f3n de servicio (DoS), de modo que un atacante puede enviar un paquete con formato incorrecto y, como resultado, el servidor entrar\u00e1 en un bucle infinito y consumir\u00e1 memoria excesiva."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeopcua:opcua-asyncio:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.9.96", "matchCriteriaId": "D64D2A05-90B8-43AA-B8BE-9D79959CFC61"}]}]}], "references": [{"url": "https://gist.github.com/artfire52/1540b234350795e0ecb4d672608dbec8", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/commit/f6603daa34a93a658f0e176cb0b9ee5a6643b262", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/issues/1013", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/pull/1039", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/releases/tag/v0.9.96", "source": "report@snyk.io", "tags": ["Product", "Release Notes"]}, {"url": "https://security.snyk.io/vuln/SNYK-PYTHON-ASYNCUA-5673709", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeOpcUa/opcua-asyncio/commit/f6603daa34a93a658f0e176cb0b9ee5a6643b262"}}