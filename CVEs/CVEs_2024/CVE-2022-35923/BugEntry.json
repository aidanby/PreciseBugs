{"buggy_code": ["import Context from './Context';\nimport optional from './rules/optional';\n\nfunction v8n() {\n  return typeof Proxy !== 'undefined'\n    ? proxyContext(new Context())\n    : proxylessContext(new Context());\n}\n\n// Custom rules\nlet customRules = {};\n\nv8n.extend = function(newRules) {\n  Object.assign(customRules, newRules);\n};\n\nv8n.clearCustomRules = function() {\n  customRules = {};\n};\n\nfunction proxyContext(context) {\n  return new Proxy(context, {\n    get(obj, prop) {\n      if (prop in obj) {\n        return obj[prop];\n      }\n\n      const newContext = proxyContext(context._clone());\n\n      if (prop in availableModifiers) {\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      }\n      if (prop in customRules) {\n        return newContext._applyRule(customRules[prop], prop);\n      }\n      if (prop in availableRules) {\n        return newContext._applyRule(availableRules[prop], prop);\n      }\n    },\n  });\n}\n\nfunction proxylessContext(context) {\n  const addRuleSet = (ruleSet, targetContext) => {\n    Object.keys(ruleSet).forEach(prop => {\n      targetContext[prop] = (...args) => {\n        const newContext = proxylessContext(targetContext._clone());\n        const contextWithRuleApplied = newContext._applyRule(\n          ruleSet[prop],\n          prop,\n        )(...args);\n        return contextWithRuleApplied;\n      };\n    });\n    return targetContext;\n  };\n\n  const contextWithAvailableRules = addRuleSet(availableRules, context);\n  const contextWithAllRules = addRuleSet(\n    customRules,\n    contextWithAvailableRules,\n  );\n\n  Object.keys(availableModifiers).forEach(prop => {\n    Object.defineProperty(contextWithAllRules, prop, {\n      get: () => {\n        const newContext = proxylessContext(contextWithAllRules._clone());\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      },\n    });\n  });\n\n  return contextWithAllRules;\n}\n\nconst availableModifiers = {\n  not: {\n    simple: fn => value => !fn(value),\n    async: fn => value =>\n      Promise.resolve(fn(value))\n        .then(result => !result)\n        .catch(() => true),\n  },\n\n  some: {\n    simple: fn => value => {\n      return split(value).some(item => {\n        try {\n          return fn(item);\n        } catch (ex) {\n          return false;\n        }\n      });\n    },\n    async: fn => value => {\n      return Promise.all(\n        split(value).map(item => {\n          try {\n            return fn(item).catch(() => false);\n          } catch (ex) {\n            return false;\n          }\n        }),\n      ).then(result => result.some(Boolean));\n    },\n  },\n\n  every: {\n    simple: fn => value => value !== false && split(value).every(fn),\n    async: fn => value =>\n      Promise.all(split(value).map(fn)).then(result => result.every(Boolean)),\n  },\n\n  strict: {\n    simple: (fn, rule) => value => {\n      if (isSchemaRule(rule) && value && typeof value === 'object') {\n        return (\n          Object.keys(rule.args[0]).length === Object.keys(value).length &&\n          fn(value)\n        );\n      }\n      return fn(value);\n    },\n    async: (fn, rule) => value =>\n      Promise.resolve(fn(value))\n        .then(result => {\n          if (isSchemaRule(rule) && value && typeof value === 'object') {\n            return (\n              Object.keys(rule.args[0]).length === Object.keys(value).length &&\n              result\n            );\n          }\n          return result;\n        })\n        .catch(() => false),\n  },\n};\n\nfunction isSchemaRule(rule) {\n  return (\n    rule &&\n    rule.name === 'schema' &&\n    rule.args.length > 0 &&\n    typeof rule.args[0] === 'object'\n  );\n}\n\nfunction split(value) {\n  if (typeof value === 'string') {\n    return value.split('');\n  }\n  return value;\n}\n\nconst availableRules = {\n  // Value\n\n  equal: expected => value => value == expected,\n\n  exact: expected => value => value === expected,\n\n  // Types\n\n  number: (allowInfinite = true) => value =>\n    typeof value === 'number' && (allowInfinite || isFinite(value)),\n\n  integer: () => value => {\n    const isInteger = Number.isInteger || isIntegerPolyfill;\n    return isInteger(value);\n  },\n\n  numeric: () => value => !isNaN(parseFloat(value)) && isFinite(value),\n\n  string: () => testType('string'),\n\n  boolean: () => testType('boolean'),\n\n  undefined: () => testType('undefined'),\n\n  null: () => testType('null'),\n\n  array: () => testType('array'),\n\n  object: () => testType('object'),\n\n  instanceOf: instance => value => value instanceof instance,\n\n  // Pattern\n\n  pattern: expected => value => expected.test(value),\n\n  lowercase: () => value => /^([a-z]+\\s*)+$/.test(value),\n\n  uppercase: () => value => /^([A-Z]+\\s*)+$/.test(value),\n\n  vowel: () => value => /^[aeiou]+$/i.test(value),\n\n  consonant: () => value => /^(?=[^aeiou])([a-z]+)$/i.test(value),\n\n  // Value at\n\n  first: expected => value => value[0] == expected,\n\n  last: expected => value => value[value.length - 1] == expected,\n\n  // Length\n\n  empty: () => value => value.length === 0,\n\n  length: (min, max) => value =>\n    value.length >= min && value.length <= (max || min),\n\n  minLength: min => value => value.length >= min,\n\n  maxLength: max => value => value.length <= max,\n\n  // Range\n\n  negative: () => value => value < 0,\n\n  positive: () => value => value >= 0,\n\n  between: (a, b) => value => value >= a && value <= b,\n\n  range: (a, b) => value => value >= a && value <= b,\n\n  lessThan: n => value => value < n,\n\n  lessThanOrEqual: n => value => value <= n,\n\n  greaterThan: n => value => value > n,\n\n  greaterThanOrEqual: n => value => value >= n,\n\n  // Divisible\n\n  even: () => value => value % 2 === 0,\n\n  odd: () => value => value % 2 !== 0,\n\n  includes: expected => value => ~value.indexOf(expected),\n\n  schema: schema => testSchema(schema),\n\n  // branching\n\n  passesAnyOf: (...validations) => value =>\n    validations.some(validation => validation.test(value)),\n\n  optional,\n};\n\nfunction testType(expected) {\n  return value => {\n    return (\n      (Array.isArray(value) && expected === 'array') ||\n      (value === null && expected === 'null') ||\n      typeof value === expected\n    );\n  };\n}\n\nfunction isIntegerPolyfill(value) {\n  return (\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n  );\n}\n\nfunction testSchema(schema) {\n  return {\n    simple: value => {\n      const causes = [];\n      Object.keys(schema).forEach(key => {\n        const nestedValidation = schema[key];\n        try {\n          nestedValidation.check((value || {})[key]);\n        } catch (ex) {\n          ex.target = key;\n          causes.push(ex);\n        }\n      });\n      if (causes.length > 0) {\n        throw causes;\n      }\n      return true;\n    },\n    async: value => {\n      const causes = [];\n      const nested = Object.keys(schema).map(key => {\n        const nestedValidation = schema[key];\n        return nestedValidation.testAsync((value || {})[key]).catch(ex => {\n          ex.target = key;\n          causes.push(ex);\n        });\n      });\n      return Promise.all(nested).then(() => {\n        if (causes.length > 0) {\n          throw causes;\n        }\n\n        return true;\n      });\n    },\n  };\n}\n\nexport default v8n;\n"], "fixing_code": ["import Context from './Context';\nimport optional from './rules/optional';\n\nfunction v8n() {\n  return typeof Proxy !== 'undefined'\n    ? proxyContext(new Context())\n    : proxylessContext(new Context());\n}\n\n// Custom rules\nlet customRules = {};\n\nv8n.extend = function(newRules) {\n  Object.assign(customRules, newRules);\n};\n\nv8n.clearCustomRules = function() {\n  customRules = {};\n};\n\nfunction proxyContext(context) {\n  return new Proxy(context, {\n    get(obj, prop) {\n      if (prop in obj) {\n        return obj[prop];\n      }\n\n      const newContext = proxyContext(context._clone());\n\n      if (prop in availableModifiers) {\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      }\n      if (prop in customRules) {\n        return newContext._applyRule(customRules[prop], prop);\n      }\n      if (prop in availableRules) {\n        return newContext._applyRule(availableRules[prop], prop);\n      }\n    },\n  });\n}\n\nfunction proxylessContext(context) {\n  const addRuleSet = (ruleSet, targetContext) => {\n    Object.keys(ruleSet).forEach(prop => {\n      targetContext[prop] = (...args) => {\n        const newContext = proxylessContext(targetContext._clone());\n        const contextWithRuleApplied = newContext._applyRule(\n          ruleSet[prop],\n          prop,\n        )(...args);\n        return contextWithRuleApplied;\n      };\n    });\n    return targetContext;\n  };\n\n  const contextWithAvailableRules = addRuleSet(availableRules, context);\n  const contextWithAllRules = addRuleSet(\n    customRules,\n    contextWithAvailableRules,\n  );\n\n  Object.keys(availableModifiers).forEach(prop => {\n    Object.defineProperty(contextWithAllRules, prop, {\n      get: () => {\n        const newContext = proxylessContext(contextWithAllRules._clone());\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      },\n    });\n  });\n\n  return contextWithAllRules;\n}\n\nconst availableModifiers = {\n  not: {\n    simple: fn => value => !fn(value),\n    async: fn => value =>\n      Promise.resolve(fn(value))\n        .then(result => !result)\n        .catch(() => true),\n  },\n\n  some: {\n    simple: fn => value => {\n      return split(value).some(item => {\n        try {\n          return fn(item);\n        } catch (ex) {\n          return false;\n        }\n      });\n    },\n    async: fn => value => {\n      return Promise.all(\n        split(value).map(item => {\n          try {\n            return fn(item).catch(() => false);\n          } catch (ex) {\n            return false;\n          }\n        }),\n      ).then(result => result.some(Boolean));\n    },\n  },\n\n  every: {\n    simple: fn => value => value !== false && split(value).every(fn),\n    async: fn => value =>\n      Promise.all(split(value).map(fn)).then(result => result.every(Boolean)),\n  },\n\n  strict: {\n    simple: (fn, rule) => value => {\n      if (isSchemaRule(rule) && value && typeof value === 'object') {\n        return (\n          Object.keys(rule.args[0]).length === Object.keys(value).length &&\n          fn(value)\n        );\n      }\n      return fn(value);\n    },\n    async: (fn, rule) => value =>\n      Promise.resolve(fn(value))\n        .then(result => {\n          if (isSchemaRule(rule) && value && typeof value === 'object') {\n            return (\n              Object.keys(rule.args[0]).length === Object.keys(value).length &&\n              result\n            );\n          }\n          return result;\n        })\n        .catch(() => false),\n  },\n};\n\nfunction isSchemaRule(rule) {\n  return (\n    rule &&\n    rule.name === 'schema' &&\n    rule.args.length > 0 &&\n    typeof rule.args[0] === 'object'\n  );\n}\n\nfunction split(value) {\n  if (typeof value === 'string') {\n    return value.split('');\n  }\n  return value;\n}\n\nconst availableRules = {\n  // Value\n\n  equal: expected => value => value == expected,\n\n  exact: expected => value => value === expected,\n\n  // Types\n\n  number: (allowInfinite = true) => value =>\n    typeof value === 'number' && (allowInfinite || isFinite(value)),\n\n  integer: () => value => {\n    const isInteger = Number.isInteger || isIntegerPolyfill;\n    return isInteger(value);\n  },\n\n  numeric: () => value => !isNaN(parseFloat(value)) && isFinite(value),\n\n  string: () => testType('string'),\n\n  boolean: () => testType('boolean'),\n\n  undefined: () => testType('undefined'),\n\n  null: () => testType('null'),\n\n  array: () => testType('array'),\n\n  object: () => testType('object'),\n\n  instanceOf: instance => value => value instanceof instance,\n\n  // Pattern\n\n  pattern: expected => value => expected.test(value),\n\n  lowercase: () => value => {\n    return (\n      typeof value === 'boolean' ||\n      (value === value.toLowerCase() && value.trim() !== '')\n    );\n  },\n\n  uppercase: () => value =>\n    value === value.toUpperCase() && value.trim() !== '',\n\n  vowel: () => value => /^[aeiou]+$/i.test(value),\n\n  consonant: () => value => /^(?=[^aeiou])([a-z]+)$/i.test(value),\n\n  // Value at\n\n  first: expected => value => value[0] == expected,\n\n  last: expected => value => value[value.length - 1] == expected,\n\n  // Length\n\n  empty: () => value => value.length === 0,\n\n  length: (min, max) => value =>\n    value.length >= min && value.length <= (max || min),\n\n  minLength: min => value => value.length >= min,\n\n  maxLength: max => value => value.length <= max,\n\n  // Range\n\n  negative: () => value => value < 0,\n\n  positive: () => value => value >= 0,\n\n  between: (a, b) => value => value >= a && value <= b,\n\n  range: (a, b) => value => value >= a && value <= b,\n\n  lessThan: n => value => value < n,\n\n  lessThanOrEqual: n => value => value <= n,\n\n  greaterThan: n => value => value > n,\n\n  greaterThanOrEqual: n => value => value >= n,\n\n  // Divisible\n\n  even: () => value => value % 2 === 0,\n\n  odd: () => value => value % 2 !== 0,\n\n  includes: expected => value => ~value.indexOf(expected),\n\n  schema: schema => testSchema(schema),\n\n  // branching\n\n  passesAnyOf: (...validations) => value =>\n    validations.some(validation => validation.test(value)),\n\n  optional,\n};\n\nfunction testType(expected) {\n  return value => {\n    return (\n      (Array.isArray(value) && expected === 'array') ||\n      (value === null && expected === 'null') ||\n      typeof value === expected\n    );\n  };\n}\n\nfunction isIntegerPolyfill(value) {\n  return (\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n  );\n}\n\nfunction testSchema(schema) {\n  return {\n    simple: value => {\n      const causes = [];\n      Object.keys(schema).forEach(key => {\n        const nestedValidation = schema[key];\n        try {\n          nestedValidation.check((value || {})[key]);\n        } catch (ex) {\n          ex.target = key;\n          causes.push(ex);\n        }\n      });\n      if (causes.length > 0) {\n        throw causes;\n      }\n      return true;\n    },\n    async: value => {\n      const causes = [];\n      const nested = Object.keys(schema).map(key => {\n        const nestedValidation = schema[key];\n        return nestedValidation.testAsync((value || {})[key]).catch(ex => {\n          ex.target = key;\n          causes.push(ex);\n        });\n      });\n      return Promise.all(nested).then(() => {\n        if (causes.length > 0) {\n          throw causes;\n        }\n\n        return true;\n      });\n    },\n  };\n}\n\nexport default v8n;\n"], "filenames": ["src/v8n.js"], "buggy_code_start_loc": [192], "buggy_code_end_loc": [195], "fixing_code_start_loc": [192], "fixing_code_end_loc": [201], "type": "NVD-CWE-Other", "message": "v8n is a javascript validation library. Versions of v8n prior to 1.5.1 were found to have an inefficient regular expression complexity in the `lowercase()` and `uppercase()` regex which could lead to a denial of service attack. In testing of the `lowercase()` function a payload of 'a' + 'a'.repeat(i) + 'A' with 32 leading characters took 29443 ms to execute. The same issue happens with uppercase(). Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35923", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-02T20:15:09.947", "lastModified": "2022-08-08T15:17:22.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "v8n is a javascript validation library. Versions of v8n prior to 1.5.1 were found to have an inefficient regular expression complexity in the `lowercase()` and `uppercase()` regex which could lead to a denial of service attack. In testing of the `lowercase()` function a payload of 'a' + 'a'.repeat(i) + 'A' with 32 leading characters took 29443 ms to execute. The same issue happens with uppercase(). Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "v8n es una biblioteca de comprobaci\u00f3n de javascript. Las versiones de v8n anteriores a 1.5.1, presentaban una complejidad de expresi\u00f3n regular ineficiente en las expresiones regulares \"lowercase()\" y \"uppercase()\" que pod\u00eda conllevar a un ataque de denegaci\u00f3n de servicio. En las pruebas de la funci\u00f3n \"lowercase()\" una carga \u00fatil de \"a\" + \"a\".repeat(i) + \"A\" con 32 caracteres iniciales tardaba 29443 ms en ejecutarse. El mismo problema ocurre con uppercase(). Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:v8n_project:v8n:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.5.1", "matchCriteriaId": "756E657C-AD87-49ED-B83B-5BD406633992"}]}]}], "references": [{"url": "https://github.com/imbrn/v8n/commit/92393862156fad190c05ec3f6e2bc73308dcd2f9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/imbrn/v8n/security/advisories/GHSA-xrx9-gj26-5wx9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2d92f644-593b-43b4-bfd1-c8042ac60609/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/imbrn/v8n/commit/92393862156fad190c05ec3f6e2bc73308dcd2f9"}}