{"buggy_code": ["/*global pkp */\n/**\n * @defgroup js_controllers_modal\n */\n/**\n * @file js/controllers/modal/ModalHandler.js\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class ModalHandler\n * @ingroup js_controllers_modal\n *\n * @brief Basic modal implementation.\n *\n *  A modal that has only one button and expects a simple message string.\n */\n(function($) {\n\n\t/** @type {Object} */\n\t$.pkp.controllers.modal = $.pkp.controllers.modal || { };\n\n\n\n\t/**\n\t * @constructor\n\t *\n\t * @extends $.pkp.classes.Handler\n\t *\n\t * @param {jQueryObject} $handledElement The modal.\n\t * @param {Object.<string, *>} options The modal options.\n\t */\n\t$.pkp.controllers.modal.ModalHandler = function($handledElement, options) {\n\t\tthis.parent($handledElement, options);\n\n\t\t// Check the options.\n\t\tif (!this.checkOptions(options)) {\n\t\t\tthrow new Error('Missing or invalid modal options!');\n\t\t}\n\n\t\t// Clone the options object before we manipulate them.\n\t\tvar internalOptions = $.extend(true, {}, options),\n\t\t\t\tcanClose;\n\n\t\t// Merge user and default options.\n\t\tthis.options = /** @type {{ canClose: boolean, title: string,\n\t\t\t\ttitleIcon: string, closeCleanVueInstances: Array }} */\n\t\t\t\t(this.mergeOptions(internalOptions));\n\n\t\t// Attach content to the modal\n\t\t$handledElement.html(this.modalBuild()[0].outerHTML);\n\n\t\t// Open the modal\n\t\tthis.modalOpen($handledElement);\n\n\t\t// Set up close controls\n\t\t$handledElement.find(\n\t\t\t\t'.pkpModalCloseButton').click(this.callbackWrapper(this.modalClose));\n\t\t$handledElement.on(\n\t\t\t\t'click keyup', this.callbackWrapper(this.handleWrapperEvents));\n\n\t\t// Publish some otherwise private events triggered\n\t\t// by nested widgets so that they can be handled by\n\t\t// the element that opened the modal.\n\t\tthis.publishEvent('redirectRequested');\n\t\tthis.publishEvent('dataChanged');\n\t\tthis.publishEvent('updateHeader');\n\t\tthis.publishEvent('gridRefreshRequested');\n\n\t\tthis.bind('notifyUser', this.redirectNotifyUserEventHandler_);\n\t\tthis.bindGlobal('form-success', this.onFormSuccess_);\n\t};\n\t$.pkp.classes.Helper.inherits($.pkp.controllers.modal.ModalHandler,\n\t\t\t$.pkp.classes.Handler);\n\n\n\t//\n\t// Private static properties\n\t//\n\t/**\n\t * Default options\n\t * @private\n\t * @type {Object}\n\t * @const\n\t */\n\t$.pkp.controllers.modal.ModalHandler.DEFAULT_OPTIONS_ = {\n\t\tautoOpen: true,\n\t\twidth: 710,\n\t\tmodal: true,\n\t\tdraggable: false,\n\t\tresizable: false,\n\t\tposition: {my: 'center', at: 'center center-10%', of: window},\n\t\tcanClose: true,\n\t\tcloseCallback: false,\n\t\t// Vue components to destroy when when modal is closed\n\t\tcloseCleanVueInstances: []\n\t};\n\n\n\t//\n\t// Public properties\n\t//\n\t/**\n\t * Current options\n\t *\n\t * After passed options are merged with defaults.\n\t *\n\t * @type {Object}\n\t */\n\t$.pkp.controllers.modal.ModalHandler.options = null;\n\n\n\t//\n\t// Protected methods\n\t//\n\t/**\n\t * Check whether the correct options have been\n\t * given for this modal.\n\t * @protected\n\t * @param {Object.<string, *>} options Modal options.\n\t * @return {boolean} True if options are ok.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.checkOptions =\n\t\t\tfunction(options) {\n\n\t\t// Check for basic configuration requirements.\n\t\treturn typeof options === 'object' &&\n\t\t\t\t(/** @type {{ buttons: Object }} */ (options)).buttons === undefined;\n\t};\n\n\n\t/**\n\t * Determine the options based on\n\t * default options.\n\t * @protected\n\t * @param {Object.<string, *>} options Non-default modal options.\n\t * @return {Object.<string, *>} The default options merged\n\t *  with the non-default options.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.mergeOptions =\n\t\t\tfunction(options) {\n\n\t\t// Merge the user options into the default options.\n\t\tvar mergedOptions = $.extend(true, { },\n\t\t\t\tthis.self('DEFAULT_OPTIONS_'), options);\n\t\treturn mergedOptions;\n\t};\n\n\n\t//\n\t// Public methods\n\t//\n\t/**\n\t * Build the markup for a modal container, including the header, close\n\t * button and a container for the content to be placed in.\n\t * TODO: This kind of markup probably shouldn't be embedded within the JS...\n\t *\n\t * @protected\n\t * @return {Object} jQuery object representing modal content\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.modalBuild =\n\t\t\tfunction() {\n\n\t\tvar $modal = $('<div class=\"pkp_modal_panel\"></div>');\n\n\t\t// Title bar\n\t\tif (typeof(this.options.title) !== 'undefined') {\n\t\t\t$modal.append('<div class=\"header\">' + this.options.title + '</div>');\n\t\t} else {\n\t\t\t$modal.append('<div class=\"header\">' + '</div>');\n\t\t}\n\n\t\t// Close button\n\t\tif (this.options.canClose) {\n\t\t\t$modal.append(\n\t\t\t\t\t'<a href=\"#\" class=\"close pkpModalCloseButton\">' +\n\t\t\t\t\t'<span :aria-hidden=\"true\">\u00d7</span>' +\n\t\t\t\t\t'<span class=\"pkp_screen_reader\">' +\n\t\t\t\t\t(/** @type {{ closeButtonText: string }} */ (this.options))\n\t\t\t\t\t.closeButtonText + '</span></a>');\n\t\t}\n\n\t\t// Content\n\t\t$modal.append('<div class=\"content\"></div>');\n\n\t\t// Add aria role and label\n\t\t$modal.attr('role', 'dialog')\n\t\t\t\t.attr('aria-label', this.options.title);\n\n\t\treturn $modal;\n\t};\n\n\n\t/**\n\t * Attach a modal to the dom and make it visible\n\t * @param {jQueryObject} $handledElement The modal.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.modalOpen =\n\t\t\tfunction($handledElement) {\n\n\t\t// The $handledElement must be attached to the DOM before events will\n\t\t// bubble up to SiteHandler\n\t\tvar $body = $('body');\n\t\t$body.append($handledElement);\n\n\t\t// Trigger visibility state change on the next tick, so that CSS\n\t\t// transform animations will run\n\t\tsetTimeout(function() {\n\t\t\t$handledElement.addClass('is_visible');\n\t\t},10);\n\n\t\t// Set focus to the modal. Leave a sizeable delay here so that the\n\t\t// element can be added to the dom first\n\t\tsetTimeout(function() {\n\t\t\t$handledElement.focus();\n\t\t}, 300);\n\n\t\t// Trigger events\n\t\t$handledElement.trigger('pkpModalOpen', [$handledElement]);\n\t};\n\n\n\t/**\n\t * Close the modal. Typically invoked via an event of some kind, such as\n\t * a `click` or `keyup`\n\t *\n\t * @param {Object=} opt_callingContext The calling element or object.\n\t * @param {Event=} opt_event The triggering event (e.g. a click on\n\t *  a close button. Not set if called via callback.\n\t * @return {boolean} Should return false to stop event processing.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.modalClose =\n\t\t\tfunction(opt_callingContext, opt_event) {\n\n\t\tvar modalHandler = this,\n\t\t\t\t$modalElement = this.getHtmlElement(),\n\t\t\t\t$form = $modalElement.find('form').first(),\n\t\t\t\thandler, informationObject;\n\n\t\t// Unregister a form if attached to this modalElement\n\t\t// modalClose is called on both 'cancel' and 'close' events.  With\n\t\t// callbacks both callingContext and event are undefined. So,\n\t\t// unregister this form with SiteHandler.\n\t\tif ($form.length == 1) {\n\t\t\tinformationObject = {closePermitted: true};\n\t\t\t$form.trigger('containerClose', [informationObject]);\n\t\t\tif (!informationObject.closePermitted) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Hide the modal, clean up any mounted vue instances, remove it from the\n\t\t// DOM and remove the handler once the CSS animation is complete\n\t\t$modalElement.removeClass('is_visible');\n\t\tthis.trigger('pkpModalClose');\n\t\tsetTimeout(function() {\n\t\t\tvar vueInstances = modalHandler.options.closeCleanVueInstances,\n\t\t\t\t\tinstance,\n\t\t\t\t\ti,\n\t\t\t\t\tid;\n\t\t\tif (vueInstances.length) {\n\t\t\t\tfor (i = 0; i < vueInstances.length; i++) {\n\t\t\t\t\tid = vueInstances[i];\n\t\t\t\t\tif (typeof pkp.registry._instances[id] !== 'undefined') {\n\t\t\t\t\t\tinstance = /** @type {{ $destroy: Function }} */\n\t\t\t\t\t\t\t\t(pkp.registry._instances[id]);\n\t\t\t\t\t\tinstance.$destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodalHandler.unbindPartial($modalElement);\n\t\t\t$modalElement.empty();\n\t\t\tmodalHandler.remove();\n\t\t\t// Fire a callback function if one has been passed with options\n\t\t\tif (typeof modalHandler.options.closeCallback === 'function') {\n\t\t\t\tmodalHandler.options.closeCallback.call();\n\t\t\t}\n\t\t}, 300);\n\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * Process events that reach the wrapper element.\n\t * Should NOT block other events from bubbling up. Doing so\n\t * can disable submit buttons in nested forms.\n\t *\n\t * @param {Object=} opt_callingContext The calling element or object.\n\t * @param {Event=} opt_event The triggering event (e.g. a click on\n\t *  a close button. Not set if called via callback.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.handleWrapperEvents =\n\t\t\tfunction(opt_callingContext, opt_event) {\n\n\t\t// Close click events directly on modal (background screen)\n\t\tif (opt_event.type == 'click' && opt_callingContext == opt_event.target) {\n\t\t\t$.pkp.classes.Handler.getHandler($(opt_callingContext))\n\t\t\t\t\t.modalClose();\n\t\t\treturn;\n\t\t}\n\n\t\t// Close for ESC keypresses (27) that have bubbled up\n\t\tif (opt_event.type == 'keyup' && opt_event.which == 27) {\n\t\t\t$.pkp.classes.Handler.getHandler($(opt_callingContext))\n\t\t\t\t\t.modalClose();\n\t\t\treturn;\n\t\t}\n\t};\n\n\n\t//\n\t// Private methods\n\t//\n\t/**\n\t * Handler to redirect to the correct notification widget the\n\t * notify user event.\n\t * @param {HTMLElement} sourceElement The element that issued the\n\t * \"notifyUser\" event.\n\t * @param {Event} event The \"notify user\" event.\n\t * @param {HTMLElement} triggerElement The element that triggered\n\t * the \"notifyUser\" event.\n\t * @private\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.redirectNotifyUserEventHandler_ =\n\t\t\tfunction(sourceElement, event, triggerElement) {\n\n\t\t// Use the notification helper to redirect the notify user event.\n\t\t$.pkp.classes.notification.NotificationHelper.\n\t\t\t\tredirectNotifyUserEvent(this, triggerElement);\n\t};\n\n\n\t/**\n\t * Handler to listen to global form success events, and close when an event\n\t * from a child form has been fired, and this form matches the config id\n\t *\n\t * @param {Object} source The Vue.js component which fired the event\n\t * @param {Object} formId The form component's id prop\n\t * @private\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.onFormSuccess_ =\n\t\t\tfunction(source, formId) {\n\t\tif (this.options.closeOnFormSuccessId &&\n\t\t\t\tthis.options.closeOnFormSuccessId === formId) {\n\t\t\tvar self = this;\n\t\t\tsetTimeout(function() {\n\t\t\t\tself.modalClose();\n\t\t\t}, 1500);\n\t\t}\n\t};\n\n\n}(jQuery));\n"], "fixing_code": ["/*global pkp */\n/**\n * @defgroup js_controllers_modal\n */\n/**\n * @file js/controllers/modal/ModalHandler.js\n *\n * Copyright (c) 2014-2021 Simon Fraser University\n * Copyright (c) 2000-2021 John Willinsky\n * Distributed under the GNU GPL v3. For full terms see the file docs/COPYING.\n *\n * @class ModalHandler\n * @ingroup js_controllers_modal\n *\n * @brief Basic modal implementation.\n *\n *  A modal that has only one button and expects a simple message string.\n */\n(function($) {\n\n\t/** @type {Object} */\n\t$.pkp.controllers.modal = $.pkp.controllers.modal || { };\n\n\n\n\t/**\n\t * @constructor\n\t *\n\t * @extends $.pkp.classes.Handler\n\t *\n\t * @param {jQueryObject} $handledElement The modal.\n\t * @param {Object.<string, *>} options The modal options.\n\t */\n\t$.pkp.controllers.modal.ModalHandler = function($handledElement, options) {\n\t\tthis.parent($handledElement, options);\n\n\t\t// Check the options.\n\t\tif (!this.checkOptions(options)) {\n\t\t\tthrow new Error('Missing or invalid modal options!');\n\t\t}\n\n\t\t// Clone the options object before we manipulate them.\n\t\tvar internalOptions = $.extend(true, {}, options),\n\t\t\t\tcanClose;\n\n\t\t// Merge user and default options.\n\t\tthis.options = /** @type {{ canClose: boolean, textTitle: string, title: string,\n\t\t\t\ttitleIcon: string, closeCleanVueInstances: Array }} */\n\t\t\t\t(this.mergeOptions(internalOptions));\n\n\t\t// Attach content to the modal\n\t\t$handledElement.html(this.modalBuild()[0].outerHTML);\n\n\t\t// Open the modal\n\t\tthis.modalOpen($handledElement);\n\n\t\t// Set up close controls\n\t\t$handledElement.find(\n\t\t\t\t'.pkpModalCloseButton').click(this.callbackWrapper(this.modalClose));\n\t\t$handledElement.on(\n\t\t\t\t'click keyup', this.callbackWrapper(this.handleWrapperEvents));\n\n\t\t// Publish some otherwise private events triggered\n\t\t// by nested widgets so that they can be handled by\n\t\t// the element that opened the modal.\n\t\tthis.publishEvent('redirectRequested');\n\t\tthis.publishEvent('dataChanged');\n\t\tthis.publishEvent('updateHeader');\n\t\tthis.publishEvent('gridRefreshRequested');\n\n\t\tthis.bind('notifyUser', this.redirectNotifyUserEventHandler_);\n\t\tthis.bindGlobal('form-success', this.onFormSuccess_);\n\t};\n\t$.pkp.classes.Helper.inherits($.pkp.controllers.modal.ModalHandler,\n\t\t\t$.pkp.classes.Handler);\n\n\n\t//\n\t// Private static properties\n\t//\n\t/**\n\t * Default options\n\t * @private\n\t * @type {Object}\n\t * @const\n\t */\n\t$.pkp.controllers.modal.ModalHandler.DEFAULT_OPTIONS_ = {\n\t\tautoOpen: true,\n\t\twidth: 710,\n\t\tmodal: true,\n\t\tdraggable: false,\n\t\tresizable: false,\n\t\tposition: {my: 'center', at: 'center center-10%', of: window},\n\t\tcanClose: true,\n\t\tcloseCallback: false,\n\t\t// Vue components to destroy when when modal is closed\n\t\tcloseCleanVueInstances: []\n\t};\n\n\n\t//\n\t// Public properties\n\t//\n\t/**\n\t * Current options\n\t *\n\t * After passed options are merged with defaults.\n\t *\n\t * @type {Object}\n\t */\n\t$.pkp.controllers.modal.ModalHandler.options = null;\n\n\n\t//\n\t// Protected methods\n\t//\n\t/**\n\t * Check whether the correct options have been\n\t * given for this modal.\n\t * @protected\n\t * @param {Object.<string, *>} options Modal options.\n\t * @return {boolean} True if options are ok.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.checkOptions =\n\t\t\tfunction(options) {\n\n\t\t// Check for basic configuration requirements.\n\t\treturn typeof options === 'object' &&\n\t\t\t\t(/** @type {{ buttons: Object }} */ (options)).buttons === undefined;\n\t};\n\n\n\t/**\n\t * Determine the options based on\n\t * default options.\n\t * @protected\n\t * @param {Object.<string, *>} options Non-default modal options.\n\t * @return {Object.<string, *>} The default options merged\n\t *  with the non-default options.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.mergeOptions =\n\t\t\tfunction(options) {\n\n\t\t// Merge the user options into the default options.\n\t\tvar mergedOptions = $.extend(true, { },\n\t\t\t\tthis.self('DEFAULT_OPTIONS_'), options);\n\t\treturn mergedOptions;\n\t};\n\n\n\t//\n\t// Public methods\n\t//\n\t/**\n\t * Build the markup for a modal container, including the header, close\n\t * button and a container for the content to be placed in.\n\t * TODO: This kind of markup probably shouldn't be embedded within the JS...\n\t *\n\t * @protected\n\t * @return {Object} jQuery object representing modal content\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.modalBuild =\n\t\t\tfunction() {\n\n\t\tvar $titleDiv, $modal = $('<div class=\"pkp_modal_panel\"></div>');\n\n\t\t// Title bar\n\t\tif (typeof(this.options.textTitle) !== 'undefined') {\n\t\t\t$titleDiv = $('<div class=\"header\"/>').text(this.options.textTitle);\n\t\t\t$modal.append($titleDiv);\n\t\t} else if (typeof(this.options.title) !== 'undefined') {\n\t\t\t$modal.append('<div class=\"header\">' + this.options.title + '</div>');\n\t\t} else {\n\t\t\t$modal.append('<div class=\"header\">' + '</div>');\n\t\t}\n\n\t\t// Close button\n\t\tif (this.options.canClose) {\n\t\t\t$modal.append(\n\t\t\t\t\t'<a href=\"#\" class=\"close pkpModalCloseButton\">' +\n\t\t\t\t\t'<span :aria-hidden=\"true\">\u00d7</span>' +\n\t\t\t\t\t'<span class=\"pkp_screen_reader\">' +\n\t\t\t\t\t(/** @type {{ closeButtonText: string }} */ (this.options))\n\t\t\t\t\t.closeButtonText + '</span></a>');\n\t\t}\n\n\t\t// Content\n\t\t$modal.append('<div class=\"content\"></div>');\n\n\t\t// Add aria role and label\n\t\t$modal.attr('role', 'dialog')\n\t\t\t\t.attr('aria-label', this.options.title);\n\n\t\treturn $modal;\n\t};\n\n\n\t/**\n\t * Attach a modal to the dom and make it visible\n\t * @param {jQueryObject} $handledElement The modal.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.modalOpen =\n\t\t\tfunction($handledElement) {\n\n\t\t// The $handledElement must be attached to the DOM before events will\n\t\t// bubble up to SiteHandler\n\t\tvar $body = $('body');\n\t\t$body.append($handledElement);\n\n\t\t// Trigger visibility state change on the next tick, so that CSS\n\t\t// transform animations will run\n\t\tsetTimeout(function() {\n\t\t\t$handledElement.addClass('is_visible');\n\t\t},10);\n\n\t\t// Set focus to the modal. Leave a sizeable delay here so that the\n\t\t// element can be added to the dom first\n\t\tsetTimeout(function() {\n\t\t\t$handledElement.focus();\n\t\t}, 300);\n\n\t\t// Trigger events\n\t\t$handledElement.trigger('pkpModalOpen', [$handledElement]);\n\t};\n\n\n\t/**\n\t * Close the modal. Typically invoked via an event of some kind, such as\n\t * a `click` or `keyup`\n\t *\n\t * @param {Object=} opt_callingContext The calling element or object.\n\t * @param {Event=} opt_event The triggering event (e.g. a click on\n\t *  a close button. Not set if called via callback.\n\t * @return {boolean} Should return false to stop event processing.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.modalClose =\n\t\t\tfunction(opt_callingContext, opt_event) {\n\n\t\tvar modalHandler = this,\n\t\t\t\t$modalElement = this.getHtmlElement(),\n\t\t\t\t$form = $modalElement.find('form').first(),\n\t\t\t\thandler, informationObject;\n\n\t\t// Unregister a form if attached to this modalElement\n\t\t// modalClose is called on both 'cancel' and 'close' events.  With\n\t\t// callbacks both callingContext and event are undefined. So,\n\t\t// unregister this form with SiteHandler.\n\t\tif ($form.length == 1) {\n\t\t\tinformationObject = {closePermitted: true};\n\t\t\t$form.trigger('containerClose', [informationObject]);\n\t\t\tif (!informationObject.closePermitted) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Hide the modal, clean up any mounted vue instances, remove it from the\n\t\t// DOM and remove the handler once the CSS animation is complete\n\t\t$modalElement.removeClass('is_visible');\n\t\tthis.trigger('pkpModalClose');\n\t\tsetTimeout(function() {\n\t\t\tvar vueInstances = modalHandler.options.closeCleanVueInstances,\n\t\t\t\t\tinstance,\n\t\t\t\t\ti,\n\t\t\t\t\tid;\n\t\t\tif (vueInstances.length) {\n\t\t\t\tfor (i = 0; i < vueInstances.length; i++) {\n\t\t\t\t\tid = vueInstances[i];\n\t\t\t\t\tif (typeof pkp.registry._instances[id] !== 'undefined') {\n\t\t\t\t\t\tinstance = /** @type {{ $destroy: Function }} */\n\t\t\t\t\t\t\t\t(pkp.registry._instances[id]);\n\t\t\t\t\t\tinstance.$destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodalHandler.unbindPartial($modalElement);\n\t\t\t$modalElement.empty();\n\t\t\tmodalHandler.remove();\n\t\t\t// Fire a callback function if one has been passed with options\n\t\t\tif (typeof modalHandler.options.closeCallback === 'function') {\n\t\t\t\tmodalHandler.options.closeCallback.call();\n\t\t\t}\n\t\t}, 300);\n\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * Process events that reach the wrapper element.\n\t * Should NOT block other events from bubbling up. Doing so\n\t * can disable submit buttons in nested forms.\n\t *\n\t * @param {Object=} opt_callingContext The calling element or object.\n\t * @param {Event=} opt_event The triggering event (e.g. a click on\n\t *  a close button. Not set if called via callback.\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.handleWrapperEvents =\n\t\t\tfunction(opt_callingContext, opt_event) {\n\n\t\t// Close click events directly on modal (background screen)\n\t\tif (opt_event.type == 'click' && opt_callingContext == opt_event.target) {\n\t\t\t$.pkp.classes.Handler.getHandler($(opt_callingContext))\n\t\t\t\t\t.modalClose();\n\t\t\treturn;\n\t\t}\n\n\t\t// Close for ESC keypresses (27) that have bubbled up\n\t\tif (opt_event.type == 'keyup' && opt_event.which == 27) {\n\t\t\t$.pkp.classes.Handler.getHandler($(opt_callingContext))\n\t\t\t\t\t.modalClose();\n\t\t\treturn;\n\t\t}\n\t};\n\n\n\t//\n\t// Private methods\n\t//\n\t/**\n\t * Handler to redirect to the correct notification widget the\n\t * notify user event.\n\t * @param {HTMLElement} sourceElement The element that issued the\n\t * \"notifyUser\" event.\n\t * @param {Event} event The \"notify user\" event.\n\t * @param {HTMLElement} triggerElement The element that triggered\n\t * the \"notifyUser\" event.\n\t * @private\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.redirectNotifyUserEventHandler_ =\n\t\t\tfunction(sourceElement, event, triggerElement) {\n\n\t\t// Use the notification helper to redirect the notify user event.\n\t\t$.pkp.classes.notification.NotificationHelper.\n\t\t\t\tredirectNotifyUserEvent(this, triggerElement);\n\t};\n\n\n\t/**\n\t * Handler to listen to global form success events, and close when an event\n\t * from a child form has been fired, and this form matches the config id\n\t *\n\t * @param {Object} source The Vue.js component which fired the event\n\t * @param {Object} formId The form component's id prop\n\t * @private\n\t */\n\t$.pkp.controllers.modal.ModalHandler.prototype.onFormSuccess_ =\n\t\t\tfunction(source, formId) {\n\t\tif (this.options.closeOnFormSuccessId &&\n\t\t\t\tthis.options.closeOnFormSuccessId === formId) {\n\t\t\tvar self = this;\n\t\t\tsetTimeout(function() {\n\t\t\t\tself.modalClose();\n\t\t\t}, 1500);\n\t\t}\n\t};\n\n\n}(jQuery));\n"], "filenames": ["js/controllers/modal/ModalHandler.js"], "buggy_code_start_loc": [47], "buggy_code_end_loc": [169], "fixing_code_start_loc": [47], "fixing_code_end_loc": [172], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - DOM in GitHub repository pkp/pkp-lib prior to 3.3.0-16.", "other": {"cve": {"id": "CVE-2023-5895", "sourceIdentifier": "security@huntr.dev", "published": "2023-11-01T01:15:07.817", "lastModified": "2023-11-08T23:25:26.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - DOM in GitHub repository pkp/pkp-lib prior to 3.3.0-16."}, {"lang": "es", "value": "Cross-site Scripting (XSS): DOM en el repositorio de GitHub pkp/pkp-lib anterior a 3.3.0-16."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 0.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sfu:pkp_web_application_library:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.0-16", "matchCriteriaId": "60CE0E67-FCF5-4A26-A91E-514946B97D99"}]}]}], "references": [{"url": "https://github.com/pkp/pkp-lib/commit/83fa560d6fb54458b312addd23a91ee6520dbe63", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/2cc80417-32b2-4024-bbcd-d95a039c11ae", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pkp/pkp-lib/commit/83fa560d6fb54458b312addd23a91ee6520dbe63"}}