{"buggy_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.itemimport;\n\nimport gr.ekt.bte.core.DataLoader;\nimport gr.ekt.bte.core.TransformationEngine;\nimport gr.ekt.bte.core.TransformationResult;\nimport gr.ekt.bte.core.TransformationSpec;\nimport gr.ekt.bte.dataloader.FileDataLoader;\nimport gr.ekt.bteio.generators.DSpaceOutputGenerator;\nimport gr.ekt.bteio.loaders.OAIPMHDataLoader;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipEntry;\n\nimport javax.mail.MessagingException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.PosixParser;\nimport org.apache.commons.collections.ComparatorUtils;\nimport org.apache.commons.io.FileDeleteStrategy;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang.RandomStringUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.log4j.Logger;\nimport org.apache.xpath.XPathAPI;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.AuthorizeManager;\nimport org.dspace.authorize.ResourcePolicy;\nimport org.dspace.content.*;\nimport org.dspace.content.Collection;\nimport org.dspace.core.ConfigurationManager;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.core.Email;\nimport org.dspace.core.I18nUtil;\nimport org.dspace.core.LogManager;\nimport org.dspace.eperson.EPerson;\nimport org.dspace.eperson.Group;\nimport org.dspace.handle.HandleManager;\nimport org.dspace.search.DSIndexer;\nimport org.dspace.utils.DSpace;\nimport org.dspace.workflow.WorkflowManager;\nimport org.dspace.xmlworkflow.XmlWorkflowManager;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n\n/**\n * Import items into DSpace. The conventional use is upload files by copying\n * them. DSpace writes the item's bitstreams into its assetstore. Metadata is\n * also loaded to the DSpace database.\n * <P>\n * A second use assumes the bitstream files already exist in a storage\n * resource accessible to DSpace. In this case the bitstreams are 'registered'.\n * That is, the metadata is loaded to the DSpace database and DSpace is given\n * the location of the file which is subsumed into DSpace.\n * <P>\n * The distinction is controlled by the format of lines in the 'contents' file.\n * See comments in processContentsFile() below.\n * <P>\n * Modified by David Little, UCSD Libraries 12/21/04 to\n * allow the registration of files (bitstreams) into DSpace.\n */\npublic class ItemImport\n{\n    private static final Logger log = Logger.getLogger(ItemImport.class);\n\n    private static boolean useWorkflow = false;\n\n    private static boolean useWorkflowSendEmail = false;\n\n    private static boolean isTest = false;\n\n    private static boolean isResume = false;\n\n    private static boolean isQuiet = false;\n\n    private static boolean template = false;\n\n    private static PrintWriter mapOut = null;\n\n    private static final String tempWorkDir = ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\");\n\n    static {\n        //Ensure tempWorkDir exists\n        File tempWorkDirFile = new File(tempWorkDir);\n        if (!tempWorkDirFile.exists()){\n            boolean success = tempWorkDirFile.mkdir();\n            if (success) {\n                log.info(\"Created org.dspace.app.batchitemimport.work.dir of: \" + tempWorkDir);\n            } else {\n                log.error(\"Cannot create batch import directory! \" + tempWorkDir);\n            }\n        }\n    }\n\n    // File listing filter to look for metadata files\n    private static FilenameFilter metadataFileFilter = new FilenameFilter()\n    {\n        public boolean accept(File dir, String n)\n        {\n            return n.startsWith(\"metadata_\");\n        }\n    };\n\n    // File listing filter to check for folders\n    private static FilenameFilter directoryFilter = new FilenameFilter()\n    {\n        public boolean accept(File dir, String n)\n        {\n            File item = new File(dir.getAbsolutePath() + File.separatorChar + n);\n            return item.isDirectory();\n        }\n    };\n\n\n    public static void main(String[] argv) throws Exception\n    {\n        DSIndexer.setBatchProcessingMode(true);\n        Date startTime = new Date();\n        int status = 0;\n\n        try\n        {\n            // create an options object and populate it\n            CommandLineParser parser = new PosixParser();\n\n            Options options = new Options();\n\n            options.addOption(\"a\", \"add\", false, \"add items to DSpace\");\n            options.addOption(\"b\", \"add-bte\", false, \"add items to DSpace via Biblio-Transformation-Engine (BTE)\");\n            options.addOption(\"r\", \"replace\", false, \"replace items in mapfile\");\n            options.addOption(\"d\", \"delete\", false,\n                    \"delete items listed in mapfile\");\n            options.addOption(\"i\", \"inputtype\", true, \"input type in case of BTE import\");\n            options.addOption(\"s\", \"source\", true, \"source of items (directory)\");\n            options.addOption(\"z\", \"zip\", true, \"name of zip file\");\n            options.addOption(\"c\", \"collection\", true,\n                    \"destination collection(s) Handle or database ID\");\n            options.addOption(\"m\", \"mapfile\", true, \"mapfile items in mapfile\");\n            options.addOption(\"e\", \"eperson\", true,\n                    \"email of eperson doing importing\");\n            options.addOption(\"w\", \"workflow\", false,\n                    \"send submission through collection's workflow\");\n            options.addOption(\"n\", \"notify\", false,\n                            \"if sending submissions through the workflow, send notification emails\");\n            options.addOption(\"t\", \"test\", false,\n                    \"test run - do not actually import items\");\n            options.addOption(\"p\", \"template\", false, \"apply template\");\n            options.addOption(\"R\", \"resume\", false,\n                    \"resume a failed import (add only)\");\n            options.addOption(\"q\", \"quiet\", false, \"don't display metadata\");\n\n            options.addOption(\"h\", \"help\", false, \"help\");\n\n            CommandLine line = parser.parse(options, argv);\n\n            String command = null; // add replace remove, etc\n            String bteInputType = null; //ris, endnote, tsv, csv, bibtex\n            String sourcedir = null;\n            String mapfile = null;\n            String eperson = null; // db ID or email\n            String[] collections = null; // db ID or handles\n\n            if (line.hasOption('h'))\n            {\n                HelpFormatter myhelp = new HelpFormatter();\n                myhelp.printHelp(\"ItemImport\\n\", options);\n                System.out\n                       .println(\"\\nadding items:    ItemImport -a -e eperson -c collection -s sourcedir -m mapfile\");\n                System.out\n                        .println(\"\\nadding items from zip file:    ItemImport -a -e eperson -c collection -s sourcedir -z filename.zip -m mapfile\");\n                System.out\n                        .println(\"replacing items: ItemImport -r -e eperson -c collection -s sourcedir -m mapfile\");\n                System.out\n                        .println(\"deleting items:  ItemImport -d -e eperson -m mapfile\");\n                System.out\n                        .println(\"If multiple collections are specified, the first collection will be the one that owns the item.\");\n\n                System.exit(0);\n            }\n\n            if (line.hasOption('a'))\n            {\n                command = \"add\";\n            }\n\n            if (line.hasOption('r'))\n            {\n                command = \"replace\";\n            }\n\n            if (line.hasOption('d'))\n            {\n                command = \"delete\";\n            }\n\n            if (line.hasOption('b'))\n            {\n                command = \"add-bte\";\n            }\n\n            if (line.hasOption('i'))\n            {\n                bteInputType = line.getOptionValue('i');\n            }\n\n            if (line.hasOption('w'))\n            {\n                useWorkflow = true;\n                if (line.hasOption('n'))\n                {\n                    useWorkflowSendEmail = true;\n                }\n            }\n\n            if (line.hasOption('t'))\n            {\n                isTest = true;\n                System.out.println(\"**Test Run** - not actually importing items.\");\n            }\n\n            if (line.hasOption('p'))\n            {\n                template = true;\n            }\n\n            if (line.hasOption('s')) // source\n            {\n                sourcedir = line.getOptionValue('s');\n            }\n\n            if (line.hasOption('m')) // mapfile\n            {\n                mapfile = line.getOptionValue('m');\n            }\n\n            if (line.hasOption('e')) // eperson\n            {\n                eperson = line.getOptionValue('e');\n            }\n\n            if (line.hasOption('c')) // collections\n            {\n                collections = line.getOptionValues('c');\n            }\n\n            if (line.hasOption('R'))\n            {\n                isResume = true;\n                System.out\n                        .println(\"**Resume import** - attempting to import items not already imported\");\n            }\n\n            if (line.hasOption('q'))\n            {\n                isQuiet = true;\n            }\n\n            boolean zip = false;\n            String zipfilename = \"\";\n            if (line.hasOption('z'))\n            {\n                zip = true;\n                zipfilename = line.getOptionValue('z');\n            }\n\n            //By default assume collections will be given on the command line\n            boolean commandLineCollections = true;\n            // now validate\n            // must have a command set\n            if (command == null)\n            {\n                System.out\n                        .println(\"Error - must run with either add, replace, or remove (run with -h flag for details)\");\n                System.exit(1);\n            }\n            else if (\"add\".equals(command) || \"replace\".equals(command))\n            {\n                if (sourcedir == null)\n                {\n                    System.out\n                            .println(\"Error - a source directory containing items must be set\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (mapfile == null)\n                {\n                    System.out\n                            .println(\"Error - a map file to hold importing results must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (eperson == null)\n                {\n                    System.out\n                            .println(\"Error - an eperson to do the importing must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (collections == null)\n                {\n                    System.out.println(\"No collections given. Assuming 'collections' file inside item directory\");\n                    commandLineCollections = false;\n                }\n            }\n            else if (\"add-bte\".equals(command))\n            {\n            \t//Source dir can be null, the user can specify the parameters for his loader in the Spring XML configuration file\n\n                if (mapfile == null)\n                {\n                    System.out\n                            .println(\"Error - a map file to hold importing results must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (eperson == null)\n                {\n                    System.out\n                            .println(\"Error - an eperson to do the importing must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (collections == null)\n                {\n                    System.out.println(\"No collections given. Assuming 'collections' file inside item directory\");\n                    commandLineCollections = false;\n                }\n\n                if (bteInputType == null)\n                {\n                    System.out\n                            .println(\"Error - an input type (tsv, csv, ris, endnote, bibtex or any other type you have specified in BTE Spring XML configuration file) must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n            }\n            else if (\"delete\".equals(command))\n            {\n                if (eperson == null)\n                {\n                    System.out\n                            .println(\"Error - an eperson to do the importing must be specified\");\n                    System.exit(1);\n                }\n\n                if (mapfile == null)\n                {\n                    System.out.println(\"Error - a map file must be specified\");\n                    System.exit(1);\n                }\n            }\n\n            // can only resume for adds\n            if (isResume && !\"add\".equals(command) && !\"add-bte\".equals(command))\n            {\n                System.out\n                        .println(\"Error - resume option only works with the --add or the --add-bte commands\");\n                System.exit(1);\n            }\n\n            // do checks around mapfile - if mapfile exists and 'add' is selected,\n            // resume must be chosen\n            File myFile = new File(mapfile);\n\n            if (!isResume && \"add\".equals(command) && myFile.exists())\n            {\n                System.out.println(\"Error - the mapfile \" + mapfile\n                        + \" already exists.\");\n                System.out\n                        .println(\"Either delete it or use --resume if attempting to resume an aborted import.\");\n                System.exit(1);\n            }\n\n            ItemImport myloader = new ItemImport();\n\n            // create a context\n            Context c = new Context();\n\n            // find the EPerson, assign to context\n            EPerson myEPerson = null;\n\n            if (eperson.indexOf('@') != -1)\n            {\n                // @ sign, must be an email\n                myEPerson = EPerson.findByEmail(c, eperson);\n            }\n            else\n            {\n                myEPerson = EPerson.find(c, Integer.parseInt(eperson));\n            }\n\n            if (myEPerson == null)\n            {\n                System.out.println(\"Error, eperson cannot be found: \" + eperson);\n                System.exit(1);\n            }\n\n            c.setCurrentUser(myEPerson);\n\n            // find collections\n            Collection[] mycollections = null;\n\n            // don't need to validate collections set if command is \"delete\"\n            // also if no collections are given in the command line\n            if (!\"delete\".equals(command) && commandLineCollections)\n            {\n                System.out.println(\"Destination collections:\");\n\n                mycollections = new Collection[collections.length];\n\n                // validate each collection arg to see if it's a real collection\n                for (int i = 0; i < collections.length; i++)\n                {\n                    // is the ID a handle?\n                    if (collections[i].indexOf('/') != -1)\n                    {\n                        // string has a / so it must be a handle - try and resolve\n                        // it\n                        mycollections[i] = (Collection) HandleManager\n                                .resolveToObject(c, collections[i]);\n\n                        // resolved, now make sure it's a collection\n                        if ((mycollections[i] == null)\n                                || (mycollections[i].getType() != Constants.COLLECTION))\n                        {\n                            mycollections[i] = null;\n                        }\n                    }\n                    // not a handle, try and treat it as an integer collection\n                    // database ID\n                    else if (collections[i] != null)\n                    {\n                        mycollections[i] = Collection.find(c, Integer\n                                .parseInt(collections[i]));\n                    }\n\n                    // was the collection valid?\n                    if (mycollections[i] == null)\n                    {\n                        throw new IllegalArgumentException(\"Cannot resolve \"\n                                + collections[i] + \" to collection\");\n                    }\n\n                    // print progress info\n                    String owningPrefix = \"\";\n\n                    if (i == 0)\n                    {\n                        owningPrefix = \"Owning \";\n                    }\n\n                    System.out.println(owningPrefix + \" Collection: \"\n                            + mycollections[i].getMetadata(\"name\"));\n                }\n            } // end of validating collections\n\n            try\n            {\n                // If this is a zip archive, unzip it first\n                if (zip) {\n                    sourcedir = unzip(sourcedir, zipfilename);\n                }\n\n\n                c.turnOffAuthorisationSystem();\n\n                if (\"add\".equals(command))\n                {\n                    myloader.addItems(c, mycollections, sourcedir, mapfile, template);\n                }\n                else if (\"replace\".equals(command))\n                {\n                    myloader.replaceItems(c, mycollections, sourcedir, mapfile, template);\n                }\n                else if (\"delete\".equals(command))\n                {\n                    myloader.deleteItems(c, mapfile);\n                }\n                else if (\"add-bte\".equals(command))\n                {\n                    myloader.addBTEItems(c, mycollections, sourcedir, mapfile, template, bteInputType, null);\n                }\n\n                // complete all transactions\n                c.complete();\n            }\n            catch (Exception e)\n            {\n                c.abort();\n                e.printStackTrace();\n                System.out.println(e);\n                status = 1;\n            }\n\n            // Delete the unzipped file\n            try\n            {\n                if (zip)\n                {\n                    System.gc();\n                    System.out.println(\"Deleting temporary zip directory: \" + tempWorkDir);\n                    ItemImport.deleteDirectory(new File(tempWorkDir));\n                }\n            }\n            catch (Exception ex)\n            {\n                System.out.println(\"Unable to delete temporary zip archive location: \" + tempWorkDir);\n            }\n\n\n\n            if (isTest)\n            {\n                System.out.println(\"***End of Test Run***\");\n            }\n        }\n        finally\n        {\n            DSIndexer.setBatchProcessingMode(false);\n            Date endTime = new Date();\n            System.out.println(\"Started: \" + startTime.getTime());\n            System.out.println(\"Ended: \" + endTime.getTime());\n            System.out.println(\"Elapsed time: \" + ((endTime.getTime() - startTime.getTime()) / 1000) + \" secs (\" + (endTime.getTime() - startTime.getTime()) + \" msecs)\");\n        }\n\n        System.exit(status);\n    }\n\n    /**\n     * In this method, the BTE is instantiated. THe workflow generates the DSpace files\n     * necessary for the upload, and the default item import method is called\n     * @param c The contect\n     * @param mycollections The collections the items are inserted to\n     * @param sourceDir The filepath to the file to read data from\n     * @param mapFile The filepath to mapfile to be generated\n     * @param template\n     * @param inputType The type of the input data (bibtex, csv, etc.)\n     * @param workingDir The path to create temporary files (for command line or UI based)\n     * @throws Exception\n     */\n    private void addBTEItems(Context c, Collection[] mycollections,\n            String sourceDir, String mapFile, boolean template, String inputType, String workingDir) throws Exception\n    {\n    \t//Determine the folder where BTE will output the results\n    \tString outputFolder = null;\n    \tif (workingDir == null){ //This indicates a command line import, create a random path\n    \t\tFile importDir = new File(ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\"));\n            if (!importDir.exists()){\n            \tboolean success = importDir.mkdir();\n            \tif (!success) {\n            \t\tlog.info(\"Cannot create batch import directory!\");\n            \t\tthrow new Exception(\"Cannot create batch import directory!\");\n            \t}\n            }\n            //Get a random folder in case two admins batch import data at the same time\n    \t\toutputFolder = importDir + File.separator + generateRandomFilename(true);\n    \t}\n    \telse { //This indicates a UI import, working dir is preconfigured\n    \t\toutputFolder = workingDir;\n    \t}\n\n        BTEBatchImportService dls  = new DSpace().getSingletonService(BTEBatchImportService.class);\n        DataLoader dataLoader = dls.getDataLoaders().get(inputType);\n        Map<String, String> outputMap = dls.getOutputMap();\n        TransformationEngine te = dls.getTransformationEngine();\n\n        if (dataLoader==null){\n            System.out.println(\"ERROR: The key used in -i parameter must match a valid DataLoader in the BTE Spring XML configuration file!\");\n            return;\n        }\n\n        if (outputMap==null){\n            System.out.println(\"ERROR: The key used in -i parameter must match a valid outputMapping in the BTE Spring XML configuration file!\");\n            return;\n        }\n\n        if (dataLoader instanceof FileDataLoader){\n            FileDataLoader fdl = (FileDataLoader) dataLoader;\n            if (!StringUtils.isBlank(sourceDir)) {\n                System.out.println(\"INFO: Dataloader will load data from the file specified in the command prompt (and not from the Spring XML configuration file)\");\n                fdl.setFilename(sourceDir);\n            }\n        }\n        else if (dataLoader instanceof OAIPMHDataLoader){\n            OAIPMHDataLoader fdl = (OAIPMHDataLoader) dataLoader;\n            System.out.println(sourceDir);\n            if (!StringUtils.isBlank(sourceDir)){\n                System.out.println(\"INFO: Dataloader will load data from the address specified in the command prompt (and not from the Spring XML configuration file)\");\n                fdl.setServerAddress(sourceDir);\n            }\n        }\n        if (dataLoader!=null){\n            System.out.println(\"INFO: Dataloader \" + dataLoader.toString()+\" will be used for the import!\");\n\n        \tte.setDataLoader(dataLoader);\n\n        \tDSpaceOutputGenerator outputGenerator = new DSpaceOutputGenerator(outputMap);\n        \toutputGenerator.setOutputDirectory(outputFolder);\n\n        \tte.setOutputGenerator(outputGenerator);\n\n        \ttry {\n        \t\tTransformationResult res = te.transform(new TransformationSpec());\n        \t\tList<String> output = res.getOutput();\n        \t\toutputGenerator.writeOutput(output);\n        \t} catch (Exception e) {\n        \t\tSystem.err.println(\"Exception\");\n        \t\te.printStackTrace();\n        \t\tthrow e;\n        \t}\n        \tItemImport myloader = new ItemImport();\n        \tmyloader.addItems(c, mycollections, outputFolder, mapFile, template);\n        }\n    }\n\n    public void addItemsAtomic(Context c, Collection[] mycollections, String sourceDir, String mapFile, boolean template) throws Exception {\n        try {\n            addItems(c, mycollections, sourceDir, mapFile, template);\n        } catch (Exception addException) {\n            log.error(\"AddItems encountered an error, will try to revert. Error: \" + addException.getMessage());\n            deleteItems(c, mapFile);\n            c.commit();\n            log.info(\"Attempted to delete partial (errored) import\");\n            throw addException;\n        }\n    }\n\n    public void addItems(Context c, Collection[] mycollections,\n            String sourceDir, String mapFile, boolean template) throws Exception\n    {\n        // create the mapfile\n        File outFile = null;\n\n        try {\n            Map<String, String> skipItems = new HashMap<String, String>(); // set of items to skip if in 'resume'\n            // mode\n\n            System.out.println(\"Adding items from directory: \" + sourceDir);\n            System.out.println(\"Generating mapfile: \" + mapFile);\n\n        boolean directoryFileCollections = false;\n        if (mycollections == null)\n        {\n            directoryFileCollections = true;\n        }\n\n        if (!isTest)\n        {\n            // get the directory names of items to skip (will be in keys of\n            // hash)\n            if (isResume)\n            {\n                skipItems = readMapFile(mapFile);\n            }\n\n                // sneaky isResume == true means open file in append mode\n                outFile = new File(mapFile);\n                mapOut = new PrintWriter(new FileWriter(outFile, isResume));\n\n                if (mapOut == null)\n                {\n                    throw new Exception(\"can't open mapfile: \" + mapFile);\n                }\n            }\n\n            // open and process the source directory\n            File d = new java.io.File(sourceDir);\n\n            if (d == null || !d.isDirectory())\n            {\n                throw new Exception(\"Error, cannot open source directory \" + sourceDir);\n            }\n\n            String[] dircontents = d.list(directoryFilter);\n\n            Arrays.sort(dircontents, ComparatorUtils.naturalComparator());\n\n        for (int i = 0; i < dircontents.length; i++)\n        {\n            if (skipItems.containsKey(dircontents[i]))\n            {\n                System.out.println(\"Skipping import of \" + dircontents[i]);\n            }\n            else\n            {\n                Collection [] clist;\n                if (directoryFileCollections) {\n                    String path = sourceDir + File.separatorChar + dircontents[i];\n                    try {\n                        Collection[] cols = processCollectionFile(c, path, \"collections\");\n                        if (cols == null) {\n                            System.out.println(\"No collections specified for item \" + dircontents[i] + \". Skipping.\");\n                            continue;\n                        }\n                        clist = cols;\n                    }\n                    catch (IllegalArgumentException e)\n                    {\n                        System.out.println(e.getMessage() + \" Skipping.\" );\n                        continue;\n                    }\n                }\n                else\n                {\n                    clist = mycollections;\n                }\n                addItem(c, clist, sourceDir, dircontents[i], mapOut, template);\n                System.out.println(i + \" \" + dircontents[i]);\n                c.clearCache();\n            }\n        }\n\n        } finally {\n            if(mapOut!=null) {\n                mapOut.flush();\n                mapOut.close();\n            }\n        }\n    }\n\n    private void replaceItems(Context c, Collection[] mycollections,\n            String sourceDir, String mapFile, boolean template) throws Exception\n    {\n        // verify the source directory\n        File d = new java.io.File(sourceDir);\n\n        if (d == null || !d.isDirectory())\n        {\n            throw new Exception(\"Error, cannot open source directory \"\n                    + sourceDir);\n        }\n\n        // read in HashMap first, to get list of handles & source dirs\n        Map<String, String> myHash = readMapFile(mapFile);\n\n        // for each handle, re-import the item, discard the new handle\n        // and re-assign the old handle\n        for (Map.Entry<String, String> mapEntry : myHash.entrySet())\n        {\n            // get the old handle\n            String newItemName = mapEntry.getKey();\n            String oldHandle = mapEntry.getValue();\n\n            Item oldItem = null;\n\n            if (oldHandle.indexOf('/') != -1)\n            {\n                System.out.println(\"\\tReplacing:  \" + oldHandle);\n\n                // add new item, locate old one\n                oldItem = (Item) HandleManager.resolveToObject(c, oldHandle);\n            }\n            else\n            {\n                oldItem = Item.find(c, Integer.parseInt(oldHandle));\n            }\n\n            /* Rather than exposing public item methods to change handles --\n             * two handles can't exist at the same time due to key constraints\n             * so would require temp handle being stored, old being copied to new and\n             * new being copied to old, all a bit messy -- a handle file is written to\n             * the import directory containing the old handle, the existing item is\n             * deleted and then the import runs as though it were loading an item which\n             * had already been assigned a handle (so a new handle is not even assigned).\n             * As a commit does not occur until after a successful add, it is safe to\n             * do a delete as any error results in an aborted transaction without harming\n             * the original item */\n            File handleFile = new File(sourceDir + File.separatorChar + newItemName + File.separatorChar + \"handle\");\n            PrintWriter handleOut = new PrintWriter(new FileWriter(handleFile, true));\n\n            if (handleOut == null)\n            {\n                throw new Exception(\"can't open handle file: \" + handleFile.getCanonicalPath());\n            }\n\n            handleOut.println(oldHandle);\n            handleOut.close();\n\n            deleteItem(c, oldItem);\n            addItem(c, mycollections, sourceDir, newItemName, null, template);\n            c.clearCache();\n        }\n    }\n\n    private void deleteItems(Context c, String mapFile) throws Exception\n    {\n        System.out.println(\"Deleting items listed in mapfile: \" + mapFile);\n\n        // read in the mapfile\n        Map<String, String> myhash = readMapFile(mapFile);\n\n        // now delete everything that appeared in the mapFile\n        Iterator<String> i = myhash.keySet().iterator();\n\n        while (i.hasNext())\n        {\n            String itemID = myhash.get(i.next());\n\n            if (itemID.indexOf('/') != -1)\n            {\n                String myhandle = itemID;\n                System.out.println(\"Deleting item \" + myhandle);\n                deleteItem(c, myhandle);\n            }\n            else\n            {\n                // it's an ID\n                Item myitem = Item.find(c, Integer.parseInt(itemID));\n                System.out.println(\"Deleting item \" + itemID);\n                deleteItem(c, myitem);\n            }\n            c.clearCache();\n        }\n    }\n\n    /**\n     * item? try and add it to the archive.\n     * @param mycollections - add item to these Collections.\n     * @param path - directory containing the item directories.\n     * @param itemname handle - non-null means we have a pre-defined handle already\n     * @param mapOut - mapfile we're writing\n     */\n    private Item addItem(Context c, Collection[] mycollections, String path,\n            String itemname, PrintWriter mapOut, boolean template) throws Exception\n    {\n        String mapOutputString = null;\n\n        System.out.println(\"Adding item from directory \" + itemname);\n\n        // create workspace item\n        Item myitem = null;\n        WorkspaceItem wi = null;\n\n        if (!isTest)\n        {\n            wi = WorkspaceItem.create(c, mycollections[0], template);\n            myitem = wi.getItem();\n        }\n\n        // now fill out dublin core for item\n        loadMetadata(c, myitem, path + File.separatorChar + itemname\n                + File.separatorChar);\n\n        // and the bitstreams from the contents file\n        // process contents file, add bistreams and bundles, return any\n        // non-standard permissions\n        List<String> options = processContentsFile(c, myitem, path\n                + File.separatorChar + itemname, \"contents\");\n\n        if (useWorkflow)\n        {\n            // don't process handle file\n            // start up a workflow\n            if (!isTest)\n            {\n                // Should we send a workflow alert email or not?\n                if (ConfigurationManager.getProperty(\"workflow\", \"workflow.framework\").equals(\"xmlworkflow\")) {\n                    if (useWorkflowSendEmail) {\n                        XmlWorkflowManager.start(c, wi);\n                    } else {\n                        XmlWorkflowManager.startWithoutNotify(c, wi);\n                    }\n                } else {\n                    if (useWorkflowSendEmail) {\n                        WorkflowManager.start(c, wi);\n                    }\n                    else\n                    {\n                        WorkflowManager.startWithoutNotify(c, wi);\n                    }\n                }\n\n                // send ID to the mapfile\n                mapOutputString = itemname + \" \" + myitem.getID();\n            }\n        }\n        else\n        {\n            // only process handle file if not using workflow system\n            String myhandle = processHandleFile(c, myitem, path\n                    + File.separatorChar + itemname, \"handle\");\n\n            // put item in system\n            if (!isTest)\n            {\n                try {\n                    InstallItem.installItem(c, wi, myhandle);\n                } catch (Exception e) {\n                    wi.deleteAll();\n                    log.error(\"Exception after install item, try to revert...\", e);\n                    throw e;\n                }\n\n                // find the handle, and output to map file\n                myhandle = HandleManager.findHandle(c, myitem);\n\n                mapOutputString = itemname + \" \" + myhandle;\n            }\n\n            // set permissions if specified in contents file\n            if (options.size() > 0)\n            {\n                System.out.println(\"Processing options\");\n                processOptions(c, myitem, options);\n            }\n        }\n\n        // now add to multiple collections if requested\n        if (mycollections.length > 1)\n        {\n            for (int i = 1; i < mycollections.length; i++)\n            {\n                if (!isTest)\n                {\n                    mycollections[i].addItem(myitem);\n                }\n            }\n        }\n\n        // made it this far, everything is fine, commit transaction\n        if (mapOut != null)\n        {\n            mapOut.println(mapOutputString);\n        }\n\n        c.commit();\n\n        return myitem;\n    }\n\n    // remove, given the actual item\n    private void deleteItem(Context c, Item myitem) throws Exception\n    {\n        if (!isTest)\n        {\n            Collection[] collections = myitem.getCollections();\n\n            // Remove item from all the collections it's in\n            for (int i = 0; i < collections.length; i++)\n            {\n                collections[i].removeItem(myitem);\n            }\n        }\n    }\n\n    // remove, given a handle\n    private void deleteItem(Context c, String myhandle) throws Exception\n    {\n        // bit of a hack - to remove an item, you must remove it\n        // from all collections it's a part of, then it will be removed\n        Item myitem = (Item) HandleManager.resolveToObject(c, myhandle);\n\n        if (myitem == null)\n        {\n            System.out.println(\"Error - cannot locate item - already deleted?\");\n        }\n        else\n        {\n            deleteItem(c, myitem);\n        }\n    }\n\n    ////////////////////////////////////\n    // utility methods\n    ////////////////////////////////////\n    // read in the map file and generate a hashmap of (file,handle) pairs\n    private Map<String, String> readMapFile(String filename) throws Exception\n    {\n        Map<String, String> myHash = new HashMap<String, String>();\n\n        BufferedReader is = null;\n        try\n        {\n            is = new BufferedReader(new FileReader(filename));\n\n            String line;\n\n            while ((line = is.readLine()) != null)\n            {\n                String myFile;\n                String myHandle;\n\n                // a line should be archive filename<whitespace>handle\n                StringTokenizer st = new StringTokenizer(line);\n\n                if (st.hasMoreTokens())\n                {\n                    myFile = st.nextToken();\n                }\n                else\n                {\n                    throw new Exception(\"Bad mapfile line:\\n\" + line);\n                }\n\n                if (st.hasMoreTokens())\n                {\n                    myHandle = st.nextToken();\n                }\n                else\n                {\n                    throw new Exception(\"Bad mapfile line:\\n\" + line);\n                }\n\n                myHash.put(myFile, myHandle);\n            }\n        }\n        finally\n        {\n            if (is != null)\n            {\n                is.close();\n            }\n        }\n\n        return myHash;\n    }\n\n    // Load all metadata schemas into the item.\n    private void loadMetadata(Context c, Item myitem, String path)\n            throws SQLException, IOException, ParserConfigurationException,\n            SAXException, TransformerException, AuthorizeException\n    {\n        // Load the dublin core metadata\n        loadDublinCore(c, myitem, path + \"dublin_core.xml\");\n\n        // Load any additional metadata schemas\n        File folder = new File(path);\n        File file[] = folder.listFiles(metadataFileFilter);\n        for (int i = 0; i < file.length; i++)\n        {\n            loadDublinCore(c, myitem, file[i].getAbsolutePath());\n        }\n    }\n\n    private void loadDublinCore(Context c, Item myitem, String filename)\n            throws SQLException, IOException, ParserConfigurationException,\n            SAXException, TransformerException, AuthorizeException\n    {\n        Document document = loadXML(filename);\n\n        // Get the schema, for backward compatibility we will default to the\n        // dublin core schema if the schema name is not available in the import\n        // file\n        String schema;\n        NodeList metadata = XPathAPI.selectNodeList(document, \"/dublin_core\");\n        Node schemaAttr = metadata.item(0).getAttributes().getNamedItem(\n                \"schema\");\n        if (schemaAttr == null)\n        {\n            schema = MetadataSchema.DC_SCHEMA;\n        }\n        else\n        {\n            schema = schemaAttr.getNodeValue();\n        }\n\n        // Get the nodes corresponding to formats\n        NodeList dcNodes = XPathAPI.selectNodeList(document,\n                \"/dublin_core/dcvalue\");\n\n        if (!isQuiet)\n        {\n            System.out.println(\"\\tLoading dublin core from \" + filename);\n        }\n\n        // Add each one as a new format to the registry\n        for (int i = 0; i < dcNodes.getLength(); i++)\n        {\n            Node n = dcNodes.item(i);\n            addDCValue(c, myitem, schema, n);\n        }\n    }\n\n    private void addDCValue(Context c, Item i, String schema, Node n) throws TransformerException, SQLException, AuthorizeException\n    {\n        String value = getStringValue(n); //n.getNodeValue();\n        // compensate for empty value getting read as \"null\", which won't display\n        if (value == null)\n        {\n            value = \"\";\n        }\n        else\n        {\n        \tvalue = value.trim();\n        }\n        // //getElementData(n, \"element\");\n        String element = getAttributeValue(n, \"element\");\n        String qualifier = getAttributeValue(n, \"qualifier\"); //NodeValue();\n        // //getElementData(n,\n        // \"qualifier\");\n        String language = getAttributeValue(n, \"language\");\n        if (language != null)\n        {\n            language = language.trim();\n        }\n\n        if (!isQuiet)\n        {\n            System.out.println(\"\\tSchema: \" + schema + \" Element: \" + element + \" Qualifier: \" + qualifier\n                    + \" Value: \" + value);\n        }\n\n        if (\"none\".equals(qualifier) || \"\".equals(qualifier))\n        {\n            qualifier = null;\n        }\n        // only add metadata if it is no test and there is an real value\n        if (!isTest && !value.equals(\"\"))\n        {\n            i.addMetadata(schema, element, qualifier, language, value);\n        }\n        else\n        {\n            // If we're just test the import, let's check that the actual metadata field exists.\n        \tMetadataSchema foundSchema = MetadataSchema.find(c,schema);\n\n        \tif (foundSchema == null)\n        \t{\n        \t\tSystem.out.println(\"ERROR: schema '\"+schema+\"' was not found in the registry.\");\n        \t\treturn;\n        \t}\n\n        \tint schemaID = foundSchema.getSchemaID();\n        \tMetadataField foundField = MetadataField.findByElement(c, schemaID, element, qualifier);\n\n        \tif (foundField == null)\n        \t{\n        \t\tSystem.out.println(\"ERROR: Metadata field: '\"+schema+\".\"+element+\".\"+qualifier+\"' was not found in the registry.\");\n        \t\treturn;\n            }\n        }\n    }\n\n    /**\n     * Read the collections file inside the item directory. If there\n     * is one and it is not empty return a list of collections in\n     * which the item should be inserted. If it does not exist or it\n     * is empty return null.\n     *\n     * @param c The context\n     * @param path The path to the data directory for this item\n     * @param filename The collections file filename. Should be \"collections\"\n     * @return A list of collections in which to insert the item or null\n     */\n\n    private Collection[] processCollectionFile(Context c, String path, String filename) throws IOException, SQLException\n    {\n        File file = new File(path + File.separatorChar + filename);\n        ArrayList<Collection> collections = new ArrayList<Collection>();\n        Collection[] result = null;\n        System.out.println(\"Processing collections file: \" + filename);\n\n        if(file.exists())\n        {\n            BufferedReader br = null;\n            try\n            {\n                br = new BufferedReader(new FileReader(file));\n                String line = null;\n                while ((line = br.readLine()) != null)\n                {\n                    DSpaceObject obj = null;\n                    if (line.indexOf('/') != -1)\n                    {\n                        obj = HandleManager.resolveToObject(c, line);\n                        if (obj == null || obj.getType() != Constants.COLLECTION)\n                        {\n                            obj = null;\n                        }\n                    }\n                    else\n                    {\n                        obj = Collection.find(c, Integer.parseInt(line));\n                    }\n\n                    if (obj == null) {\n                        throw new IllegalArgumentException(\"Cannot resolve \" + line + \" to a collection.\");\n                    }\n                    collections.add((Collection)obj);\n\n                }\n\n                result = new Collection[collections.size()];\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = collections.get(i);\n                }\n            }\n            catch (FileNotFoundException e)\n            {\n                System.out.println(\"No collections file found.\");\n            }\n            finally\n            {\n                if (br != null)\n                {\n                    try {\n                        br.close();\n                    } catch (IOException e) {\n                        System.out.println(\"Non-critical problem releasing resources.\");\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Read in the handle file or return null if empty or doesn't exist\n     */\n    private String processHandleFile(Context c, Item i, String path, String filename)\n    {\n        File file = new File(path + File.separatorChar + filename);\n        String result = null;\n\n        System.out.println(\"Processing handle file: \" + filename);\n        if (file.exists())\n        {\n            BufferedReader is = null;\n            try\n            {\n                is = new BufferedReader(new FileReader(file));\n\n                // result gets contents of file, or null\n                result = is.readLine();\n\n                System.out.println(\"read handle: '\" + result + \"'\");\n\n            }\n            catch (FileNotFoundException e)\n            {\n                // probably no handle file, just return null\n                System.out.println(\"It appears there is no handle file -- generating one\");\n            }\n            catch (IOException e)\n            {\n                // probably no handle file, just return null\n                System.out.println(\"It appears there is no handle file -- generating one\");\n            }\n            finally\n            {\n                if (is != null)\n                {\n                    try\n                    {\n                        is.close();\n                    }\n                    catch (IOException e1)\n                    {\n                        System.err.println(\"Non-critical problem releasing resources.\");\n                    }\n                }\n            }\n        }\n        else\n        {\n            // probably no handle file, just return null\n            System.out.println(\"It appears there is no handle file -- generating one\");\n        }\n\n        return result;\n    }\n\n    /**\n     * Given a contents file and an item, stuffing it with bitstreams from the\n     * contents file Returns a List of Strings with lines from the contents\n     * file that request non-default bitstream permission\n     */\n    private List<String> processContentsFile(Context c, Item i, String path,\n            String filename) throws SQLException, IOException,\n            AuthorizeException\n    {\n        File contentsFile = new File(path + File.separatorChar + filename);\n        String line = \"\";\n        List<String> options = new ArrayList<String>();\n\n        System.out.println(\"\\tProcessing contents file: \" + contentsFile);\n\n        if (contentsFile.exists())\n        {\n            BufferedReader is = null;\n            try\n            {\n                is = new BufferedReader(new FileReader(contentsFile));\n\n                while ((line = is.readLine()) != null)\n                {\n                    if (\"\".equals(line.trim()))\n                    {\n                        continue;\n                    }\n\n                    //\t1) registered into dspace (leading -r)\n                    //  2) imported conventionally into dspace (no -r)\n                    if (line.trim().startsWith(\"-r \"))\n                    {\n                        // line should be one of these two:\n                        // -r -s n -f filepath\n                        // -r -s n -f filepath\\tbundle:bundlename\n                        // where\n                        //\t\tn is the assetstore number\n                        //  \tfilepath is the path of the file to be registered\n                        //  \tbundlename is an optional bundle name\n                        String sRegistrationLine = line.trim();\n                        int iAssetstore = -1;\n                        String sFilePath = null;\n                        String sBundle = null;\n                        StringTokenizer tokenizer = new StringTokenizer(sRegistrationLine);\n                        while (tokenizer.hasMoreTokens())\n                        {\n                            String sToken = tokenizer.nextToken();\n                            if (\"-r\".equals(sToken))\n                            {\n                                continue;\n                            }\n                            else if (\"-s\".equals(sToken) && tokenizer.hasMoreTokens())\n                            {\n                                try\n                                {\n                                    iAssetstore =\n                                        Integer.parseInt(tokenizer.nextToken());\n                                }\n                                catch (NumberFormatException e)\n                                {\n                                    // ignore - iAssetstore remains -1\n                                }\n                            }\n                            else if (\"-f\".equals(sToken) && tokenizer.hasMoreTokens())\n                            {\n                                sFilePath = tokenizer.nextToken();\n                            }\n                            else if (sToken.startsWith(\"bundle:\"))\n                            {\n                                sBundle = sToken.substring(7);\n                            }\n                            else\n                            {\n                                // unrecognized token - should be no problem\n                            }\n                        } // while\n                        if (iAssetstore == -1 || sFilePath == null)\n                        {\n                            System.out.println(\"\\tERROR: invalid contents file line\");\n                            System.out.println(\"\\t\\tSkipping line: \"\n                                    + sRegistrationLine);\n                            continue;\n                        }\n\n                        // look for descriptions\n                        boolean descriptionExists = false;\n                        String descriptionMarker = \"\\tdescription:\";\n                        int dMarkerIndex = line.indexOf(descriptionMarker);\n                        int dEndIndex = 0;\n                        if (dMarkerIndex > 0)\n                        {\n                        \tdEndIndex = line.indexOf(\"\\t\", dMarkerIndex + 1);\n                        \tif (dEndIndex == -1)\n                        \t{\n                        \t\tdEndIndex = line.length();\n                        \t}\n                        \tdescriptionExists = true;\n                        }\n                        String sDescription = \"\";\n                        if (descriptionExists)\n                        {\n                        \tsDescription = line.substring(dMarkerIndex, dEndIndex);\n                        \tsDescription = sDescription.replaceFirst(\"description:\", \"\");\n                        }\n\n                        registerBitstream(c, i, iAssetstore, sFilePath, sBundle, sDescription);\n                        System.out.println(\"\\tRegistering Bitstream: \" + sFilePath\n                                + \"\\tAssetstore: \" + iAssetstore\n                                + \"\\tBundle: \" + sBundle\n                                + \"\\tDescription: \" + sDescription);\n                        continue;\t\t\t\t// process next line in contents file\n                    }\n\n                    int bitstreamEndIndex = line.indexOf('\\t');\n\n                    if (bitstreamEndIndex == -1)\n                    {\n                        // no extra info\n                        processContentFileEntry(c, i, path, line, null, false);\n                        System.out.println(\"\\tBitstream: \" + line);\n                    }\n                    else\n                    {\n\n                        String bitstreamName = line.substring(0, bitstreamEndIndex);\n\n                        boolean bundleExists = false;\n                        boolean permissionsExist = false;\n                        boolean descriptionExists = false;\n\n                        // look for a bundle name\n                        String bundleMarker = \"\\tbundle:\";\n                        int bMarkerIndex = line.indexOf(bundleMarker);\n                        int bEndIndex = 0;\n                        if (bMarkerIndex > 0)\n                        {\n                            bEndIndex = line.indexOf(\"\\t\", bMarkerIndex + 1);\n                            if (bEndIndex == -1)\n                            {\n                                bEndIndex = line.length();\n                            }\n                            bundleExists = true;\n                        }\n\n                        // look for permissions\n                        String permissionsMarker = \"\\tpermissions:\";\n                        int pMarkerIndex = line.indexOf(permissionsMarker);\n                        int pEndIndex = 0;\n                        if (pMarkerIndex > 0)\n                        {\n                            pEndIndex = line.indexOf(\"\\t\", pMarkerIndex + 1);\n                            if (pEndIndex == -1)\n                            {\n                                pEndIndex = line.length();\n                            }\n                            permissionsExist = true;\n                        }\n\n                        // look for descriptions\n                        String descriptionMarker = \"\\tdescription:\";\n                        int dMarkerIndex = line.indexOf(descriptionMarker);\n                        int dEndIndex = 0;\n                        if (dMarkerIndex > 0)\n                        {\n                            dEndIndex = line.indexOf(\"\\t\", dMarkerIndex + 1);\n                            if (dEndIndex == -1)\n                            {\n                                dEndIndex = line.length();\n                            }\n                            descriptionExists = true;\n                        }\n\n                        // is this the primary bitstream?\n                        String primaryBitstreamMarker = \"\\tprimary:true\";\n                        boolean primary = false;\n                        String primaryStr = \"\";\n                        if (line.contains(primaryBitstreamMarker))\n                        {\n                            primary = true;\n                            primaryStr = \"\\t **Setting as primary bitstream**\";\n                        }\n\n                        if (bundleExists)\n                        {\n                            String bundleName = line.substring(bMarkerIndex\n                                    + bundleMarker.length(), bEndIndex).trim();\n\n                            processContentFileEntry(c, i, path, bitstreamName, bundleName, primary);\n                            System.out.println(\"\\tBitstream: \" + bitstreamName +\n                                               \"\\tBundle: \" + bundleName +\n                                               primaryStr);\n                        }\n                        else\n                        {\n                            processContentFileEntry(c, i, path, bitstreamName, null, primary);\n                            System.out.println(\"\\tBitstream: \" + bitstreamName + primaryStr);\n                        }\n\n                        if (permissionsExist || descriptionExists)\n                        {\n                            String extraInfo = bitstreamName;\n\n                            if (permissionsExist)\n                            {\n                                extraInfo = extraInfo\n                                        + line.substring(pMarkerIndex, pEndIndex);\n                            }\n\n                            if (descriptionExists)\n                            {\n                                extraInfo = extraInfo\n                                        + line.substring(dMarkerIndex, dEndIndex);\n                            }\n\n                            options.add(extraInfo);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                if (is != null)\n                {\n                    is.close();\n                }\n            }\n        }\n        else\n        {\n            String[] dirListing = new File(path).list();\n            for (String fileName : dirListing)\n            {\n                if (!\"dublin_core.xml\".equals(fileName) && !fileName.equals(\"handle\") && !fileName.startsWith(\"metadata_\"))\n                {\n                    throw new FileNotFoundException(\"No contents file found\");\n                }\n            }\n\n            System.out.println(\"No contents file found - but only metadata files found. Assuming metadata only.\");\n        }\n\n        return options;\n    }\n\n    /**\n     * each entry represents a bitstream....\n     * @param c\n     * @param i\n     * @param path\n     * @param fileName\n     * @param bundleName\n     * @throws SQLException\n     * @throws IOException\n     * @throws AuthorizeException\n     */\n    private void processContentFileEntry(Context c, Item i, String path,\n            String fileName, String bundleName, boolean primary) throws SQLException,\n            IOException, AuthorizeException\n    {\n        String fullpath = path + File.separatorChar + fileName;\n\n        // get an input stream\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\n                fullpath));\n\n        Bitstream bs = null;\n        String newBundleName = bundleName;\n\n        if (bundleName == null)\n        {\n            // is it license.txt?\n            if (\"license.txt\".equals(fileName))\n            {\n                newBundleName = \"LICENSE\";\n            }\n            else\n            {\n                // call it ORIGINAL\n                newBundleName = \"ORIGINAL\";\n            }\n        }\n\n        if (!isTest)\n        {\n            // find the bundle\n            Bundle[] bundles = i.getBundles(newBundleName);\n            Bundle targetBundle = null;\n\n            if (bundles.length < 1)\n            {\n                // not found, create a new one\n                targetBundle = i.createBundle(newBundleName);\n            }\n            else\n            {\n                // put bitstreams into first bundle\n                targetBundle = bundles[0];\n            }\n\n            // now add the bitstream\n            bs = targetBundle.createBitstream(bis);\n\n            bs.setName(fileName);\n\n            // Identify the format\n            // FIXME - guessing format guesses license.txt incorrectly as a text\n            // file format!\n            BitstreamFormat bf = FormatIdentifier.guessFormat(c, bs);\n            bs.setFormat(bf);\n\n            // Is this a the primary bitstream?\n            if (primary)\n            {\n                targetBundle.setPrimaryBitstreamID(bs.getID());\n                targetBundle.update();\n            }\n\n            bs.update();\n        }\n\n        bis.close();\n    }\n\n    /**\n     * Register the bitstream file into DSpace\n     *\n     * @param c\n     * @param i\n     * @param assetstore\n     * @param bitstreamPath the full filepath expressed in the contents file\n     * @param bundleName\n     * @throws SQLException\n     * @throws IOException\n     * @throws AuthorizeException\n     */\n    private void registerBitstream(Context c, Item i, int assetstore,\n            String bitstreamPath, String bundleName, String description )\n        \tthrows SQLException, IOException, AuthorizeException\n    {\n        // TODO validate assetstore number\n        // TODO make sure the bitstream is there\n\n        Bitstream bs = null;\n        String newBundleName = bundleName;\n\n        if (bundleName == null)\n        {\n            // is it license.txt?\n            if (bitstreamPath.endsWith(\"license.txt\"))\n            {\n                newBundleName = \"LICENSE\";\n            }\n            else\n            {\n                // call it ORIGINAL\n                newBundleName = \"ORIGINAL\";\n            }\n        }\n\n        if(!isTest)\n        {\n        \t// find the bundle\n\t        Bundle[] bundles = i.getBundles(newBundleName);\n\t        Bundle targetBundle = null;\n\n\t        if( bundles.length < 1 )\n\t        {\n\t            // not found, create a new one\n\t            targetBundle = i.createBundle(newBundleName);\n\t        }\n\t        else\n\t        {\n\t            // put bitstreams into first bundle\n\t            targetBundle = bundles[0];\n\t        }\n\n\t        // now add the bitstream\n\t        bs = targetBundle.registerBitstream(assetstore, bitstreamPath);\n\n\t        // set the name to just the filename\n\t        int iLastSlash = bitstreamPath.lastIndexOf('/');\n\t        bs.setName(bitstreamPath.substring(iLastSlash + 1));\n\n\t        // Identify the format\n\t        // FIXME - guessing format guesses license.txt incorrectly as a text file format!\n\t        BitstreamFormat bf = FormatIdentifier.guessFormat(c, bs);\n\t        bs.setFormat(bf);\n\t        bs.setDescription(description);\n\n\t        bs.update();\n        }\n    }\n\n    /**\n     *\n     * Process the Options to apply to the Item. The options are tab delimited\n     *\n     * Options:\n     *      48217870-MIT.pdf        permissions: -r 'MIT Users'     description: Full printable version (MIT only)\n     *      permissions:[r|w]-['group name']\n     *      description: 'the description of the file'\n     *\n     *      where:\n     *          [r|w] (meaning: read|write)\n     *          ['MIT Users'] (the group name)\n     *\n     * @param c\n     * @param myItem\n     * @param options\n     * @throws SQLException\n     * @throws AuthorizeException\n     */\n    private void processOptions(Context c, Item myItem, List<String> options)\n            throws SQLException, AuthorizeException\n    {\n        for (String line : options)\n        {\n            System.out.println(\"\\tprocessing \" + line);\n\n            boolean permissionsExist = false;\n            boolean descriptionExists = false;\n\n            String permissionsMarker = \"\\tpermissions:\";\n            int pMarkerIndex = line.indexOf(permissionsMarker);\n            int pEndIndex = 0;\n            if (pMarkerIndex > 0)\n            {\n                pEndIndex = line.indexOf(\"\\t\", pMarkerIndex + 1);\n                if (pEndIndex == -1)\n                {\n                    pEndIndex = line.length();\n                }\n                permissionsExist = true;\n            }\n\n            String descriptionMarker = \"\\tdescription:\";\n            int dMarkerIndex = line.indexOf(descriptionMarker);\n            int dEndIndex = 0;\n            if (dMarkerIndex > 0)\n            {\n                dEndIndex = line.indexOf(\"\\t\", dMarkerIndex + 1);\n                if (dEndIndex == -1)\n                {\n                    dEndIndex = line.length();\n                }\n                descriptionExists = true;\n            }\n\n            int bsEndIndex = line.indexOf(\"\\t\");\n            String bitstreamName = line.substring(0, bsEndIndex);\n\n            int actionID = -1;\n            String groupName = \"\";\n            Group myGroup = null;\n            if (permissionsExist)\n            {\n                String thisPermission = line.substring(pMarkerIndex\n                        + permissionsMarker.length(), pEndIndex);\n\n                // get permission type (\"read\" or \"write\")\n                int pTypeIndex = thisPermission.indexOf('-');\n\n                // get permission group (should be in single quotes)\n                int groupIndex = thisPermission.indexOf('\\'', pTypeIndex);\n                int groupEndIndex = thisPermission.indexOf('\\'', groupIndex + 1);\n\n                // if not in single quotes, assume everything after type flag is\n                // group name\n                if (groupIndex == -1)\n                {\n                    groupIndex = thisPermission.indexOf(' ', pTypeIndex);\n                    groupEndIndex = thisPermission.length();\n                }\n\n                groupName = thisPermission.substring(groupIndex + 1,\n                        groupEndIndex);\n\n                if (thisPermission.toLowerCase().charAt(pTypeIndex + 1) == 'r')\n                {\n                    actionID = Constants.READ;\n                }\n                else if (thisPermission.toLowerCase().charAt(pTypeIndex + 1) == 'w')\n                {\n                    actionID = Constants.WRITE;\n                }\n\n                try\n                {\n                    myGroup = Group.findByName(c, groupName);\n                }\n                catch (SQLException sqle)\n                {\n                    System.out.println(\"SQL Exception finding group name: \"\n                            + groupName);\n                    // do nothing, will check for null group later\n                }\n            }\n\n            String thisDescription = \"\";\n            if (descriptionExists)\n            {\n                thisDescription = line.substring(\n                        dMarkerIndex + descriptionMarker.length(), dEndIndex)\n                        .trim();\n            }\n\n            Bitstream bs = null;\n            boolean notfound = true;\n            if (!isTest)\n            {\n                // find bitstream\n                Bitstream[] bitstreams = myItem.getNonInternalBitstreams();\n                for (int j = 0; j < bitstreams.length && notfound; j++)\n                {\n                    if (bitstreams[j].getName().equals(bitstreamName))\n                    {\n                        bs = bitstreams[j];\n                        notfound = false;\n                    }\n                }\n            }\n\n            if (notfound && !isTest)\n            {\n                // this should never happen\n                System.out.println(\"\\tdefault permissions set for \"\n                        + bitstreamName);\n            }\n            else if (!isTest)\n            {\n                if (permissionsExist)\n                {\n                    if (myGroup == null)\n                    {\n                        System.out.println(\"\\t\" + groupName\n                                + \" not found, permissions set to default\");\n                    }\n                    else if (actionID == -1)\n                    {\n                        System.out\n                                .println(\"\\tinvalid permissions flag, permissions set to default\");\n                    }\n                    else\n                    {\n                        System.out.println(\"\\tSetting special permissions for \"\n                                + bitstreamName);\n                        setPermission(c, myGroup, actionID, bs);\n                    }\n                }\n\n                if (descriptionExists)\n                {\n                    System.out.println(\"\\tSetting description for \"\n                            + bitstreamName);\n                    bs.setDescription(thisDescription);\n                    bs.update();\n                }\n            }\n        }\n    }\n\n    /**\n     * Set the Permission on a Bitstream.\n     *\n     * @param c\n     * @param g\n     * @param actionID\n     * @param bs\n     * @throws SQLException\n     * @throws AuthorizeException\n     */\n    private void setPermission(Context c, Group g, int actionID, Bitstream bs)\n            throws SQLException, AuthorizeException\n    {\n        if (!isTest)\n        {\n            // remove the default policy\n            AuthorizeManager.removeAllPolicies(c, bs);\n\n            // add the policy\n            ResourcePolicy rp = ResourcePolicy.create(c);\n\n            rp.setResource(bs);\n            rp.setAction(actionID);\n            rp.setGroup(g);\n\n            rp.update();\n        }\n        else\n        {\n            if (actionID == Constants.READ)\n            {\n                System.out.println(\"\\t\\tpermissions: READ for \" + g.getName());\n            }\n            else if (actionID == Constants.WRITE)\n            {\n                System.out.println(\"\\t\\tpermissions: WRITE for \" + g.getName());\n            }\n        }\n\n    }\n\n    // XML utility methods\n    /**\n     * Lookup an attribute from a DOM node.\n     * @param n\n     * @param name\n     * @return\n     */\n    private String getAttributeValue(Node n, String name)\n    {\n        NamedNodeMap nm = n.getAttributes();\n\n        for (int i = 0; i < nm.getLength(); i++)\n        {\n            Node node = nm.item(i);\n\n            if (name.equals(node.getNodeName()))\n            {\n                return node.getNodeValue();\n            }\n        }\n\n        return \"\";\n    }\n\n\n    /**\n     * Return the String value of a Node.\n     * @param node\n     * @return\n     */\n    private String getStringValue(Node node)\n    {\n        String value = node.getNodeValue();\n\n        if (node.hasChildNodes())\n        {\n            Node first = node.getFirstChild();\n\n            if (first.getNodeType() == Node.TEXT_NODE)\n            {\n                return first.getNodeValue();\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Load in the XML from file.\n     *\n     * @param filename\n     *            the filename to load from\n     *\n     * @return the DOM representation of the XML file\n     */\n    private static Document loadXML(String filename) throws IOException,\n            ParserConfigurationException, SAXException\n    {\n        DocumentBuilder builder = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder();\n\n        return builder.parse(new File(filename));\n    }\n\n    /**\n     * Delete a directory and its child files and directories\n     * @param path The directory to delete\n     * @return Whether the deletion was successful or not\n     */\n    private static boolean deleteDirectory(File path)\n    {\n        if (path.exists())\n        {\n            File[] files = path.listFiles();\n            for (int i = 0; i < files.length; i++)\n            {\n                if (files[i].isDirectory())\n                {\n                    deleteDirectory(files[i]);\n                }\n                else\n                {\n                    if (!files[i].delete())\n                    {\n                        log.error(\"Unable to delete file: \" + files[i].getName());\n                    }\n                }\n            }\n        }\n\n        boolean pathDeleted = path.delete();\n        return (pathDeleted);\n    }\n\n    public static String unzip(File zipfile) throws IOException {\n    \treturn unzip(zipfile, null);\n    }\n    \n    public static String unzip(File zipfile, String destDir) throws IOException {\n        // 2\n        // does the zip file exist and can we write to the temp directory\n        if (!zipfile.canRead())\n        {\n            log.error(\"Zip file '\" + zipfile.getAbsolutePath() + \"' does not exist, or is not readable.\");\n        }\n\n        String destinationDir = destDir;\n        if (destinationDir == null){\n        \tdestinationDir = tempWorkDir;\n        }\n\n        File tempdir = new File(destinationDir);\n        if (!tempdir.isDirectory())\n        {\n            log.error(\"'\" + ConfigurationManager.getProperty(\"org.dspace.app.itemexport.work.dir\") +\n                    \"' as defined by the key 'org.dspace.app.itemexport.work.dir' in dspace.cfg \" +\n                    \"is not a valid directory\");\n        }\n\n        if (!tempdir.exists() && !tempdir.mkdirs())\n        {\n            log.error(\"Unable to create temporary directory: \" + tempdir.getAbsolutePath());\n        }\n        String sourcedir = destinationDir + System.getProperty(\"file.separator\") + zipfile.getName();\n        String zipDir = destinationDir + System.getProperty(\"file.separator\") + zipfile.getName() + System.getProperty(\"file.separator\");\n\n\n        // 3\n        String sourceDirForZip = sourcedir;\n        ZipFile zf = new ZipFile(zipfile);\n        ZipEntry entry;\n        Enumeration<? extends ZipEntry> entries = zf.entries();\n        while (entries.hasMoreElements())\n        {\n            entry = entries.nextElement();\n            if (entry.isDirectory())\n            {\n                if (!new File(zipDir + entry.getName()).mkdir())\n                {\n                    log.error(\"Unable to create contents directory: \" + zipDir + entry.getName());\n                }\n            }\n            else\n            {\n                System.out.println(\"Extracting file: \" + entry.getName());\n                log.info(\"Extracting file: \" + entry.getName());\n\n                int index = entry.getName().lastIndexOf('/');\n                if (index == -1)\n                {\n                    // Was it created on Windows instead?\n                    index = entry.getName().lastIndexOf('\\\\');\n                }\n                if (index > 0)\n                {\n                    File dir = new File(zipDir + entry.getName().substring(0, index));\n                    if (!dir.exists() && !dir.mkdirs())\n                    {\n                        log.error(\"Unable to create directory: \" + dir.getAbsolutePath());\n                    }\n\n                    //Entries could have too many directories, and we need to adjust the sourcedir\n                    // file1.zip (SimpleArchiveFormat / item1 / contents|dublin_core|...\n                    //            SimpleArchiveFormat / item2 / contents|dublin_core|...\n                    // or\n                    // file2.zip (item1 / contents|dublin_core|...\n                    //            item2 / contents|dublin_core|...\n\n                    //regex supports either windows or *nix file paths\n                    String[] entryChunks = entry.getName().split(\"/|\\\\\\\\\");\n                    if(entryChunks.length > 2) {\n                        if(sourceDirForZip == sourcedir) {\n                            sourceDirForZip = sourcedir + \"/\" + entryChunks[0];\n                        }\n                    }\n\n\n                }\n                byte[] buffer = new byte[1024];\n                int len;\n                InputStream in = zf.getInputStream(entry);\n                BufferedOutputStream out = new BufferedOutputStream(\n                        new FileOutputStream(zipDir + entry.getName()));\n                while((len = in.read(buffer)) >= 0)\n                {\n                    out.write(buffer, 0, len);\n                }\n                in.close();\n                out.close();\n            }\n        }\n\n        //Close zip file\n        zf.close();\n        \n        if(sourceDirForZip != sourcedir) {\n            sourcedir = sourceDirForZip;\n            System.out.println(\"Set sourceDir using path inside of Zip: \" + sourcedir);\n            log.info(\"Set sourceDir using path inside of Zip: \" + sourcedir);\n        }\n\n        return sourcedir;\n    }\n\n    public static String unzip(String sourcedir, String zipfilename) throws IOException {\n        File zipfile = new File(sourcedir + File.separator + zipfilename);\n        return unzip(zipfile);\n    }\n    \n    /**\n     * Generate a random filename based on current time\n     * @param hidden: add . as a prefix to make the file hidden\n     * @return the filename\n     */\n    private static String generateRandomFilename(boolean hidden)\n    {\n    \tString filename = String.format(\"%s\", RandomStringUtils.randomAlphanumeric(8));\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd_HHmm\");\n        String datePart = sdf.format(new Date());\n        filename = datePart+\"_\"+filename;\n\n        return filename;\n    }\n\n    /**\n     * \n     * Given a local file or public URL to a zip file that has the Simple Archive Format, this method imports the contents to DSpace\n     * @param filepath The filepath to local file or the public URL of the zip file\n     * @param owningCollection The owning collection the items will belong to\n     * @param otherCollections The collections the created items will be inserted to, apart from the owning one\n     * @param resumeDir In case of a resume request, the directory that containsthe old mapfile and data \n     * @param inputType The input type of the data (bibtex, csv, etc.), in case of local file\n     * @param context The context\n     * @throws Exception\n     */\n    public static void processUIImport(String filepath, Collection owningCollection, String[] otherCollections, String resumeDir, String inputType, Context context) throws Exception\n\t{\n\t\tfinal EPerson oldEPerson = context.getCurrentUser();\n\t\tfinal String[] theOtherCollections = otherCollections;\n\t\tfinal Collection theOwningCollection = owningCollection;\n\t\tfinal String theFilePath = filepath;\n\t\tfinal String theInputType = inputType;\n\t\tfinal String theResumeDir = resumeDir;\n\t\t\n\t\tThread go = new Thread()\n\t\t{\n\t\t\tpublic void run()\n\t\t\t{\n\t\t\t\tContext context = null;\n\n\t\t\t\tString importDir = null;\n\t\t\t\tEPerson eperson = null;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\t// create a new dspace context\n\t\t\t\t\tcontext = new Context();\n\t\t\t\t\teperson = EPerson.find(context, oldEPerson.getID());\n\t\t\t\t\tcontext.setCurrentUser(eperson);\n\t\t\t\t\tcontext.turnOffAuthorisationSystem();\n\t\t\t\t\t\n\t\t\t\t\tboolean isResume = theResumeDir!=null;\n\t\t\t\t\t\n\t\t\t\t\tList<Collection> collectionList = new ArrayList<Collection>();\n\t    \t\t\tif (theOtherCollections != null){\n\t    \t\t\t\tfor (String colID : theOtherCollections){\n\t    \t\t\t\t\tint colId = Integer.parseInt(colID);\n\t    \t\t\t\t\tif (colId != theOwningCollection.getID()){\n\t    \t\t\t\t\t\tCollection col = Collection.find(context, colId);\n\t    \t\t\t\t\t\tif (col != null){\n\t    \t\t\t\t\t\t\tcollectionList.add(col);\n\t    \t\t\t\t\t\t}\n\t    \t\t\t\t\t}\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tCollection[] otherCollections = collectionList.toArray(new Collection[collectionList.size()]);\n\t    \t\t\t\n\t\t\t\t\timportDir = ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\") + File.separator + \"batchuploads\" + File.separator + context.getCurrentUser().getID() + File.separator + (isResume?theResumeDir:(new GregorianCalendar()).getTimeInMillis());\n\t\t\t\t\tFile importDirFile = new File(importDir);\n\t\t\t\t\tif (!importDirFile.exists()){\n\t\t\t\t\t\tboolean success = importDirFile.mkdirs();\n\t\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t\tlog.info(\"Cannot create batch import directory!\");\n\t\t\t\t\t\t\tthrow new Exception(\"Cannot create batch import directory!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tString dataPath = null;\n\t\t\t\t\tString dataDir = null;\n\t\t\t\t\t\n\t\t\t\t\tif (theInputType.equals(\"saf\")){ //In case of Simple Archive Format import (from remote url)\n\t\t\t\t\t\tdataPath = importDirFile + File.separator + \"data.zip\";\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped2\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\telse if (theInputType.equals(\"safupload\")){ //In case of Simple Archive Format import (from upload file)\n\t\t\t\t\t\tFileUtils.copyFileToDirectory(new File(theFilePath), importDirFile);\n\t\t\t\t\t\tdataPath = importDirFile + File.separator + (new File(theFilePath)).getName();\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped2\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\telse { // For all other imports\n\t\t\t\t\t\tdataPath = importDirFile + File.separator + (new File(theFilePath)).getName();\n    \t    \t\t\tdataDir = importDirFile + File.separator + \"data\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Clear these files, if a resume\n\t\t\t\t\tif (isResume){\n\t\t\t\t\t\tif (!theInputType.equals(\"safupload\")) {\n\t\t\t\t\t\t\t(new File(dataPath)).delete();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(new File(importDirFile + File.separator + \"error.txt\")).delete();\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(dataDir));\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(importDirFile + File.separator + \"data_unzipped\" + File.separator));\n\t\t\t\t\t}\n\n\t\t\t\t\t//In case of Simple Archive Format import we need an extra effort to download the zip file and unzip it\n\t\t\t\t\tString sourcePath = null;\n\t\t\t\t\tif (theInputType.equals(\"saf\")){ \n\t\t\t\t\t\tOutputStream os = new FileOutputStream(dataPath);\n\n\t\t\t\t\t\tbyte[] b = new byte[2048];\n\t\t\t\t\t\tint length;\n\n\t\t\t\t\t\tInputStream is = new URL(theFilePath).openStream();\n\t\t\t\t\t\twhile ((length = is.read(b)) != -1) {\n\t\t\t\t\t\t\tos.write(b, 0, length);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t\tos.close();\n\n\t\t\t\t\t\tsourcePath = unzip(new File(dataPath), dataDir);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Move files to the required folder\n\t\t\t\t\t\tFileUtils.moveDirectory(new File(sourcePath), new File(importDirFile + File.separator + \"data_unzipped\" + File.separator));\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(dataDir));\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\telse if (theInputType.equals(\"safupload\")){ \n\t\t\t\t\t\tsourcePath = unzip(new File(dataPath), dataDir);\n\t\t\t\t\t\t//Move files to the required folder\n\t\t\t\t\t\tFileUtils.moveDirectory(new File(sourcePath), new File(importDirFile + File.separator + \"data_unzipped\" + File.separator));\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(dataDir));\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Create mapfile path\n\t\t\t\t\tString mapFilePath = importDirFile + File.separator + \"mapfile\";\n\t\t\t\t\t\n\t\t\t\t\tCollection[] finalCollections = null;\n\t\t\t\t\tif (theOwningCollection != null){\n\t\t\t\t\t\tfinalCollections = new Collection[otherCollections.length + 1];\n\t\t\t\t\t\tfinalCollections[0] = theOwningCollection;\n\t\t\t\t\t\tfor (int i=0; i<otherCollections.length; i++){\n\t\t\t\t\t\t\tfinalCollections[i+1] = otherCollections[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tItemImport myloader = new ItemImport();\n\t\t\t\t\tmyloader.isResume = isResume;\n\t\t\t\t\t\n\t\t\t\t\tif (theInputType.equals(\"saf\") || theInputType.equals(\"safupload\")){ //In case of Simple Archive Format import\n\t\t\t\t\t\tmyloader.addItems(context, finalCollections, dataDir, mapFilePath, template);\n\t\t\t\t\t}\n\t\t\t\t\telse { // For all other imports (via BTE)\n\t\t\t\t\t\tmyloader.addBTEItems(context, finalCollections, theFilePath, mapFilePath, template, theInputType, dataDir);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// email message letting user know the file is ready for\n                    // download\n                    emailSuccessMessage(context, eperson, mapFilePath);\n                    \n\t\t\t\t\tcontext.complete();\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tString exceptionString = ExceptionUtils.getStackTrace(e);\n\t\t\t\t\t\n\t\t\t\t\t// abort all operations\n\t                if (mapOut != null)\n\t                {\n\t                    mapOut.close();\n\t                }\n\n\t                mapOut = null;\n\t                \n\t\t\t\t\ttry\n                    {\n\t\t\t\t\t\tFile importDirFile = new File(importDir+File.separator+\"error.txt\");\n\t\t\t\t\t\tPrintWriter errorWriter = new PrintWriter(importDirFile);\n\t\t\t\t\t\terrorWriter.print(exceptionString);\n\t\t\t\t\t\terrorWriter.close();\n\t\t\t\t\t\t\n                        emailErrorMessage(eperson, exceptionString);\n                        throw new Exception(e.getMessage());\n                    }\n                    catch (Exception e2)\n                    {\n                        // wont throw here\n                    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinally\n                {\n                    // close the mapfile writer\n                    if (mapOut != null)\n                    {\n                        mapOut.close();\n                    }\n\n                    // Make sure the database connection gets closed in all conditions.\n                \ttry {\n\t\t\t\t\t\tcontext.complete();\n\t\t\t\t\t} catch (SQLException sqle) {\n\t\t\t\t\t\tcontext.abort();\n\t\t\t\t\t}\n                }\n\t\t\t}\n\n\t\t};\n\n\t\tgo.isDaemon();\n\t\tgo.start();\n\t\t\n\t}\n\n    /**\n     * Since the BTE batch import is done in a new thread we are unable to communicate\n     * with calling method about success or failure. We accomplish this\n     * communication with email instead. Send a success email once the batch\n     * import is complete\n     *\n     * @param context\n     *            - the current Context\n     * @param eperson\n     *            - eperson to send the email to\n     * @param fileName\n     *            - the filepath to the mapfile created by the batch import\n     * @throws MessagingException\n     */\n    public static void emailSuccessMessage(Context context, EPerson eperson,\n            String fileName) throws MessagingException\n    {\n        try\n        {\n            Locale supportedLocale = I18nUtil.getEPersonLocale(eperson);\n            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, \"bte_batch_import_success\"));\n            email.addRecipient(eperson.getEmail());\n            email.addArgument(fileName);\n\n            email.send();\n        }\n        catch (Exception e)\n        {\n            log.warn(LogManager.getHeader(context, \"emailSuccessMessage\", \"cannot notify user of import\"), e);\n        }\n    }\n\n    /**\n     * Since the BTE batch import is done in a new thread we are unable to communicate\n     * with calling method about success or failure. We accomplis this\n     * communication with email instead. Send an error email if the batch\n     * import fails\n     *\n     * @param eperson\n     *            - EPerson to send the error message to\n     * @param error\n     *            - the error message\n     * @throws MessagingException\n     */\n    public static void emailErrorMessage(EPerson eperson, String error)\n            throws MessagingException\n    {\n        log.warn(\"An error occurred during item import, the user will be notified. \" + error);\n        try\n        {\n            Locale supportedLocale = I18nUtil.getEPersonLocale(eperson);\n            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, \"bte_batch_import_error\"));\n            email.addRecipient(eperson.getEmail());\n            email.addArgument(error);\n            email.addArgument(ConfigurationManager.getProperty(\"dspace.url\") + \"/feedback\");\n\n            email.send();\n        }\n        catch (Exception e)\n        {\n            log.warn(\"error during item import error notification\", e);\n        }\n    }\n    \n    \n    public static List<BatchUpload> getImportsAvailable(EPerson eperson)\n            throws Exception\n    {\n        File uploadDir = new File(getImportUploadableDirectory(eperson.getID()));\n        if (!uploadDir.exists() || !uploadDir.isDirectory())\n        {\n            return null;\n        }\n\n        Map<String, BatchUpload> fileNames = new TreeMap<String, BatchUpload>();\n\n        for (String fileName : uploadDir.list())\n        {\n            File file = new File(uploadDir + File.separator + fileName);\n            if (file.isDirectory()){\n            \t\n            \tBatchUpload upload = new BatchUpload(file);\n            \t\n            \tfileNames.put(upload.getDir().getName(), upload);\n            }\n        }\n\n        if (fileNames.size() > 0)\n        {\n            return new ArrayList<BatchUpload>(fileNames.values());\n        }\n\n        return null;\n    }\n    \n    public static String getImportUploadableDirectory(int ePersonID)\n            throws Exception\n    {\n        String uploadDir = ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\");\n        if (uploadDir == null)\n        {\n            throw new Exception(\n                    \"A dspace.cfg entry for 'org.dspace.app.batchitemimport.work.dir' does not exist.\");\n        }\n\n        return uploadDir + File.separator + \"batchuploads\" + File.separator + ePersonID;\n\n    }\n    \n    public void deleteBatchUpload(Context c, String uploadId) throws Exception\n    {\n    \tString uploadDir = null;\n    \tString mapFilePath = null;\n\n\t\tuploadDir = ItemImport.getImportUploadableDirectory(c.getCurrentUser().getID()) + File.separator + uploadId;\n\t\tmapFilePath = uploadDir + File.separator + \"mapfile\";\n\t\n\t\tthis.deleteItems(c, mapFilePath);\n\t\t// complete all transactions\n        c.commit();\n        \n\t\tFileDeleteStrategy.FORCE.delete(new File(uploadDir));\n    }\n\n    public static String getTempWorkDir() {\n        return tempWorkDir;\n    }\n\n    public static File getTempWorkDirFile() {\n        File tempDirFile = new File(getTempWorkDir());\n        if(!tempDirFile.exists()) {\n            tempDirFile.mkdirs();\n        }\n        return tempDirFile;\n    }\n\n    public static void cleanupZipTemp() {\n        System.out.println(\"Deleting temporary zip directory: \" + tempWorkDir);\n        ItemImport.deleteDirectory(new File(tempWorkDir));\n    }\n}\n"], "fixing_code": ["/**\n * The contents of this file are subject to the license and copyright\n * detailed in the LICENSE and NOTICE files at the root of the source\n * tree and available online at\n *\n * http://www.dspace.org/license/\n */\npackage org.dspace.app.itemimport;\n\nimport gr.ekt.bte.core.DataLoader;\nimport gr.ekt.bte.core.TransformationEngine;\nimport gr.ekt.bte.core.TransformationResult;\nimport gr.ekt.bte.core.TransformationSpec;\nimport gr.ekt.bte.dataloader.FileDataLoader;\nimport gr.ekt.bteio.generators.DSpaceOutputGenerator;\nimport gr.ekt.bteio.loaders.OAIPMHDataLoader;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipEntry;\n\nimport javax.mail.MessagingException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.PosixParser;\nimport org.apache.commons.collections.ComparatorUtils;\nimport org.apache.commons.io.FileDeleteStrategy;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang.RandomStringUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.log4j.Logger;\nimport org.apache.xpath.XPathAPI;\nimport org.dspace.authorize.AuthorizeException;\nimport org.dspace.authorize.AuthorizeManager;\nimport org.dspace.authorize.ResourcePolicy;\nimport org.dspace.content.*;\nimport org.dspace.content.Collection;\nimport org.dspace.core.ConfigurationManager;\nimport org.dspace.core.Constants;\nimport org.dspace.core.Context;\nimport org.dspace.core.Email;\nimport org.dspace.core.I18nUtil;\nimport org.dspace.core.LogManager;\nimport org.dspace.eperson.EPerson;\nimport org.dspace.eperson.Group;\nimport org.dspace.handle.HandleManager;\nimport org.dspace.search.DSIndexer;\nimport org.dspace.utils.DSpace;\nimport org.dspace.workflow.WorkflowManager;\nimport org.dspace.xmlworkflow.XmlWorkflowManager;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n\n/**\n * Import items into DSpace. The conventional use is upload files by copying\n * them. DSpace writes the item's bitstreams into its assetstore. Metadata is\n * also loaded to the DSpace database.\n * <P>\n * A second use assumes the bitstream files already exist in a storage\n * resource accessible to DSpace. In this case the bitstreams are 'registered'.\n * That is, the metadata is loaded to the DSpace database and DSpace is given\n * the location of the file which is subsumed into DSpace.\n * <P>\n * The distinction is controlled by the format of lines in the 'contents' file.\n * See comments in processContentsFile() below.\n * <P>\n * Modified by David Little, UCSD Libraries 12/21/04 to\n * allow the registration of files (bitstreams) into DSpace.\n */\npublic class ItemImport\n{\n    private static final Logger log = Logger.getLogger(ItemImport.class);\n\n    private static boolean useWorkflow = false;\n\n    private static boolean useWorkflowSendEmail = false;\n\n    private static boolean isTest = false;\n\n    private static boolean isResume = false;\n\n    private static boolean isQuiet = false;\n\n    private static boolean template = false;\n\n    private static PrintWriter mapOut = null;\n\n    private static final String tempWorkDir = ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\");\n\n    static {\n        //Ensure tempWorkDir exists\n        File tempWorkDirFile = new File(tempWorkDir);\n        if (!tempWorkDirFile.exists()){\n            boolean success = tempWorkDirFile.mkdir();\n            if (success) {\n                log.info(\"Created org.dspace.app.batchitemimport.work.dir of: \" + tempWorkDir);\n            } else {\n                log.error(\"Cannot create batch import directory! \" + tempWorkDir);\n            }\n        }\n    }\n\n    // File listing filter to look for metadata files\n    private static FilenameFilter metadataFileFilter = new FilenameFilter()\n    {\n        public boolean accept(File dir, String n)\n        {\n            return n.startsWith(\"metadata_\");\n        }\n    };\n\n    // File listing filter to check for folders\n    private static FilenameFilter directoryFilter = new FilenameFilter()\n    {\n        public boolean accept(File dir, String n)\n        {\n            File item = new File(dir.getAbsolutePath() + File.separatorChar + n);\n            return item.isDirectory();\n        }\n    };\n\n\n    public static void main(String[] argv) throws Exception\n    {\n        DSIndexer.setBatchProcessingMode(true);\n        Date startTime = new Date();\n        int status = 0;\n\n        try\n        {\n            // create an options object and populate it\n            CommandLineParser parser = new PosixParser();\n\n            Options options = new Options();\n\n            options.addOption(\"a\", \"add\", false, \"add items to DSpace\");\n            options.addOption(\"b\", \"add-bte\", false, \"add items to DSpace via Biblio-Transformation-Engine (BTE)\");\n            options.addOption(\"r\", \"replace\", false, \"replace items in mapfile\");\n            options.addOption(\"d\", \"delete\", false,\n                    \"delete items listed in mapfile\");\n            options.addOption(\"i\", \"inputtype\", true, \"input type in case of BTE import\");\n            options.addOption(\"s\", \"source\", true, \"source of items (directory)\");\n            options.addOption(\"z\", \"zip\", true, \"name of zip file\");\n            options.addOption(\"c\", \"collection\", true,\n                    \"destination collection(s) Handle or database ID\");\n            options.addOption(\"m\", \"mapfile\", true, \"mapfile items in mapfile\");\n            options.addOption(\"e\", \"eperson\", true,\n                    \"email of eperson doing importing\");\n            options.addOption(\"w\", \"workflow\", false,\n                    \"send submission through collection's workflow\");\n            options.addOption(\"n\", \"notify\", false,\n                            \"if sending submissions through the workflow, send notification emails\");\n            options.addOption(\"t\", \"test\", false,\n                    \"test run - do not actually import items\");\n            options.addOption(\"p\", \"template\", false, \"apply template\");\n            options.addOption(\"R\", \"resume\", false,\n                    \"resume a failed import (add only)\");\n            options.addOption(\"q\", \"quiet\", false, \"don't display metadata\");\n\n            options.addOption(\"h\", \"help\", false, \"help\");\n\n            CommandLine line = parser.parse(options, argv);\n\n            String command = null; // add replace remove, etc\n            String bteInputType = null; //ris, endnote, tsv, csv, bibtex\n            String sourcedir = null;\n            String mapfile = null;\n            String eperson = null; // db ID or email\n            String[] collections = null; // db ID or handles\n\n            if (line.hasOption('h'))\n            {\n                HelpFormatter myhelp = new HelpFormatter();\n                myhelp.printHelp(\"ItemImport\\n\", options);\n                System.out\n                       .println(\"\\nadding items:    ItemImport -a -e eperson -c collection -s sourcedir -m mapfile\");\n                System.out\n                        .println(\"\\nadding items from zip file:    ItemImport -a -e eperson -c collection -s sourcedir -z filename.zip -m mapfile\");\n                System.out\n                        .println(\"replacing items: ItemImport -r -e eperson -c collection -s sourcedir -m mapfile\");\n                System.out\n                        .println(\"deleting items:  ItemImport -d -e eperson -m mapfile\");\n                System.out\n                        .println(\"If multiple collections are specified, the first collection will be the one that owns the item.\");\n\n                System.exit(0);\n            }\n\n            if (line.hasOption('a'))\n            {\n                command = \"add\";\n            }\n\n            if (line.hasOption('r'))\n            {\n                command = \"replace\";\n            }\n\n            if (line.hasOption('d'))\n            {\n                command = \"delete\";\n            }\n\n            if (line.hasOption('b'))\n            {\n                command = \"add-bte\";\n            }\n\n            if (line.hasOption('i'))\n            {\n                bteInputType = line.getOptionValue('i');\n            }\n\n            if (line.hasOption('w'))\n            {\n                useWorkflow = true;\n                if (line.hasOption('n'))\n                {\n                    useWorkflowSendEmail = true;\n                }\n            }\n\n            if (line.hasOption('t'))\n            {\n                isTest = true;\n                System.out.println(\"**Test Run** - not actually importing items.\");\n            }\n\n            if (line.hasOption('p'))\n            {\n                template = true;\n            }\n\n            if (line.hasOption('s')) // source\n            {\n                sourcedir = line.getOptionValue('s');\n            }\n\n            if (line.hasOption('m')) // mapfile\n            {\n                mapfile = line.getOptionValue('m');\n            }\n\n            if (line.hasOption('e')) // eperson\n            {\n                eperson = line.getOptionValue('e');\n            }\n\n            if (line.hasOption('c')) // collections\n            {\n                collections = line.getOptionValues('c');\n            }\n\n            if (line.hasOption('R'))\n            {\n                isResume = true;\n                System.out\n                        .println(\"**Resume import** - attempting to import items not already imported\");\n            }\n\n            if (line.hasOption('q'))\n            {\n                isQuiet = true;\n            }\n\n            boolean zip = false;\n            String zipfilename = \"\";\n            if (line.hasOption('z'))\n            {\n                zip = true;\n                zipfilename = line.getOptionValue('z');\n            }\n\n            //By default assume collections will be given on the command line\n            boolean commandLineCollections = true;\n            // now validate\n            // must have a command set\n            if (command == null)\n            {\n                System.out\n                        .println(\"Error - must run with either add, replace, or remove (run with -h flag for details)\");\n                System.exit(1);\n            }\n            else if (\"add\".equals(command) || \"replace\".equals(command))\n            {\n                if (sourcedir == null)\n                {\n                    System.out\n                            .println(\"Error - a source directory containing items must be set\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (mapfile == null)\n                {\n                    System.out\n                            .println(\"Error - a map file to hold importing results must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (eperson == null)\n                {\n                    System.out\n                            .println(\"Error - an eperson to do the importing must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (collections == null)\n                {\n                    System.out.println(\"No collections given. Assuming 'collections' file inside item directory\");\n                    commandLineCollections = false;\n                }\n            }\n            else if (\"add-bte\".equals(command))\n            {\n            \t//Source dir can be null, the user can specify the parameters for his loader in the Spring XML configuration file\n\n                if (mapfile == null)\n                {\n                    System.out\n                            .println(\"Error - a map file to hold importing results must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (eperson == null)\n                {\n                    System.out\n                            .println(\"Error - an eperson to do the importing must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n\n                if (collections == null)\n                {\n                    System.out.println(\"No collections given. Assuming 'collections' file inside item directory\");\n                    commandLineCollections = false;\n                }\n\n                if (bteInputType == null)\n                {\n                    System.out\n                            .println(\"Error - an input type (tsv, csv, ris, endnote, bibtex or any other type you have specified in BTE Spring XML configuration file) must be specified\");\n                    System.out.println(\" (run with -h flag for details)\");\n                    System.exit(1);\n                }\n            }\n            else if (\"delete\".equals(command))\n            {\n                if (eperson == null)\n                {\n                    System.out\n                            .println(\"Error - an eperson to do the importing must be specified\");\n                    System.exit(1);\n                }\n\n                if (mapfile == null)\n                {\n                    System.out.println(\"Error - a map file must be specified\");\n                    System.exit(1);\n                }\n            }\n\n            // can only resume for adds\n            if (isResume && !\"add\".equals(command) && !\"add-bte\".equals(command))\n            {\n                System.out\n                        .println(\"Error - resume option only works with the --add or the --add-bte commands\");\n                System.exit(1);\n            }\n\n            // do checks around mapfile - if mapfile exists and 'add' is selected,\n            // resume must be chosen\n            File myFile = new File(mapfile);\n\n            if (!isResume && \"add\".equals(command) && myFile.exists())\n            {\n                System.out.println(\"Error - the mapfile \" + mapfile\n                        + \" already exists.\");\n                System.out\n                        .println(\"Either delete it or use --resume if attempting to resume an aborted import.\");\n                System.exit(1);\n            }\n\n            ItemImport myloader = new ItemImport();\n\n            // create a context\n            Context c = new Context();\n\n            // find the EPerson, assign to context\n            EPerson myEPerson = null;\n\n            if (eperson.indexOf('@') != -1)\n            {\n                // @ sign, must be an email\n                myEPerson = EPerson.findByEmail(c, eperson);\n            }\n            else\n            {\n                myEPerson = EPerson.find(c, Integer.parseInt(eperson));\n            }\n\n            if (myEPerson == null)\n            {\n                System.out.println(\"Error, eperson cannot be found: \" + eperson);\n                System.exit(1);\n            }\n\n            c.setCurrentUser(myEPerson);\n\n            // find collections\n            Collection[] mycollections = null;\n\n            // don't need to validate collections set if command is \"delete\"\n            // also if no collections are given in the command line\n            if (!\"delete\".equals(command) && commandLineCollections)\n            {\n                System.out.println(\"Destination collections:\");\n\n                mycollections = new Collection[collections.length];\n\n                // validate each collection arg to see if it's a real collection\n                for (int i = 0; i < collections.length; i++)\n                {\n                    // is the ID a handle?\n                    if (collections[i].indexOf('/') != -1)\n                    {\n                        // string has a / so it must be a handle - try and resolve\n                        // it\n                        mycollections[i] = (Collection) HandleManager\n                                .resolveToObject(c, collections[i]);\n\n                        // resolved, now make sure it's a collection\n                        if ((mycollections[i] == null)\n                                || (mycollections[i].getType() != Constants.COLLECTION))\n                        {\n                            mycollections[i] = null;\n                        }\n                    }\n                    // not a handle, try and treat it as an integer collection\n                    // database ID\n                    else if (collections[i] != null)\n                    {\n                        mycollections[i] = Collection.find(c, Integer\n                                .parseInt(collections[i]));\n                    }\n\n                    // was the collection valid?\n                    if (mycollections[i] == null)\n                    {\n                        throw new IllegalArgumentException(\"Cannot resolve \"\n                                + collections[i] + \" to collection\");\n                    }\n\n                    // print progress info\n                    String owningPrefix = \"\";\n\n                    if (i == 0)\n                    {\n                        owningPrefix = \"Owning \";\n                    }\n\n                    System.out.println(owningPrefix + \" Collection: \"\n                            + mycollections[i].getMetadata(\"name\"));\n                }\n            } // end of validating collections\n\n            try\n            {\n                // If this is a zip archive, unzip it first\n                if (zip) {\n                    sourcedir = unzip(sourcedir, zipfilename);\n                }\n\n\n                c.turnOffAuthorisationSystem();\n\n                if (\"add\".equals(command))\n                {\n                    myloader.addItems(c, mycollections, sourcedir, mapfile, template);\n                }\n                else if (\"replace\".equals(command))\n                {\n                    myloader.replaceItems(c, mycollections, sourcedir, mapfile, template);\n                }\n                else if (\"delete\".equals(command))\n                {\n                    myloader.deleteItems(c, mapfile);\n                }\n                else if (\"add-bte\".equals(command))\n                {\n                    myloader.addBTEItems(c, mycollections, sourcedir, mapfile, template, bteInputType, null);\n                }\n\n                // complete all transactions\n                c.complete();\n            }\n            catch (Exception e)\n            {\n                c.abort();\n                e.printStackTrace();\n                System.out.println(e);\n                status = 1;\n            }\n\n            // Delete the unzipped file\n            try\n            {\n                if (zip)\n                {\n                    System.gc();\n                    System.out.println(\"Deleting temporary zip directory: \" + tempWorkDir);\n                    ItemImport.deleteDirectory(new File(tempWorkDir));\n                }\n            }\n            catch (Exception ex)\n            {\n                System.out.println(\"Unable to delete temporary zip archive location: \" + tempWorkDir);\n            }\n\n\n\n            if (isTest)\n            {\n                System.out.println(\"***End of Test Run***\");\n            }\n        }\n        finally\n        {\n            DSIndexer.setBatchProcessingMode(false);\n            Date endTime = new Date();\n            System.out.println(\"Started: \" + startTime.getTime());\n            System.out.println(\"Ended: \" + endTime.getTime());\n            System.out.println(\"Elapsed time: \" + ((endTime.getTime() - startTime.getTime()) / 1000) + \" secs (\" + (endTime.getTime() - startTime.getTime()) + \" msecs)\");\n        }\n\n        System.exit(status);\n    }\n\n    /**\n     * In this method, the BTE is instantiated. THe workflow generates the DSpace files\n     * necessary for the upload, and the default item import method is called\n     * @param c The contect\n     * @param mycollections The collections the items are inserted to\n     * @param sourceDir The filepath to the file to read data from\n     * @param mapFile The filepath to mapfile to be generated\n     * @param template\n     * @param inputType The type of the input data (bibtex, csv, etc.)\n     * @param workingDir The path to create temporary files (for command line or UI based)\n     * @throws Exception\n     */\n    private void addBTEItems(Context c, Collection[] mycollections,\n            String sourceDir, String mapFile, boolean template, String inputType, String workingDir) throws Exception\n    {\n    \t//Determine the folder where BTE will output the results\n    \tString outputFolder = null;\n    \tif (workingDir == null){ //This indicates a command line import, create a random path\n    \t\tFile importDir = new File(ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\"));\n            if (!importDir.exists()){\n            \tboolean success = importDir.mkdir();\n            \tif (!success) {\n            \t\tlog.info(\"Cannot create batch import directory!\");\n            \t\tthrow new Exception(\"Cannot create batch import directory!\");\n            \t}\n            }\n            //Get a random folder in case two admins batch import data at the same time\n    \t\toutputFolder = importDir + File.separator + generateRandomFilename(true);\n    \t}\n    \telse { //This indicates a UI import, working dir is preconfigured\n    \t\toutputFolder = workingDir;\n    \t}\n\n        BTEBatchImportService dls  = new DSpace().getSingletonService(BTEBatchImportService.class);\n        DataLoader dataLoader = dls.getDataLoaders().get(inputType);\n        Map<String, String> outputMap = dls.getOutputMap();\n        TransformationEngine te = dls.getTransformationEngine();\n\n        if (dataLoader==null){\n            System.out.println(\"ERROR: The key used in -i parameter must match a valid DataLoader in the BTE Spring XML configuration file!\");\n            return;\n        }\n\n        if (outputMap==null){\n            System.out.println(\"ERROR: The key used in -i parameter must match a valid outputMapping in the BTE Spring XML configuration file!\");\n            return;\n        }\n\n        if (dataLoader instanceof FileDataLoader){\n            FileDataLoader fdl = (FileDataLoader) dataLoader;\n            if (!StringUtils.isBlank(sourceDir)) {\n                System.out.println(\"INFO: Dataloader will load data from the file specified in the command prompt (and not from the Spring XML configuration file)\");\n                fdl.setFilename(sourceDir);\n            }\n        }\n        else if (dataLoader instanceof OAIPMHDataLoader){\n            OAIPMHDataLoader fdl = (OAIPMHDataLoader) dataLoader;\n            System.out.println(sourceDir);\n            if (!StringUtils.isBlank(sourceDir)){\n                System.out.println(\"INFO: Dataloader will load data from the address specified in the command prompt (and not from the Spring XML configuration file)\");\n                fdl.setServerAddress(sourceDir);\n            }\n        }\n        if (dataLoader!=null){\n            System.out.println(\"INFO: Dataloader \" + dataLoader.toString()+\" will be used for the import!\");\n\n        \tte.setDataLoader(dataLoader);\n\n        \tDSpaceOutputGenerator outputGenerator = new DSpaceOutputGenerator(outputMap);\n        \toutputGenerator.setOutputDirectory(outputFolder);\n\n        \tte.setOutputGenerator(outputGenerator);\n\n        \ttry {\n        \t\tTransformationResult res = te.transform(new TransformationSpec());\n        \t\tList<String> output = res.getOutput();\n        \t\toutputGenerator.writeOutput(output);\n        \t} catch (Exception e) {\n        \t\tSystem.err.println(\"Exception\");\n        \t\te.printStackTrace();\n        \t\tthrow e;\n        \t}\n        \tItemImport myloader = new ItemImport();\n        \tmyloader.addItems(c, mycollections, outputFolder, mapFile, template);\n        }\n    }\n\n    public void addItemsAtomic(Context c, Collection[] mycollections, String sourceDir, String mapFile, boolean template) throws Exception {\n        try {\n            addItems(c, mycollections, sourceDir, mapFile, template);\n        } catch (Exception addException) {\n            log.error(\"AddItems encountered an error, will try to revert. Error: \" + addException.getMessage());\n            deleteItems(c, mapFile);\n            c.commit();\n            log.info(\"Attempted to delete partial (errored) import\");\n            throw addException;\n        }\n    }\n\n    public void addItems(Context c, Collection[] mycollections,\n            String sourceDir, String mapFile, boolean template) throws Exception\n    {\n        // create the mapfile\n        File outFile = null;\n\n        try {\n            Map<String, String> skipItems = new HashMap<String, String>(); // set of items to skip if in 'resume'\n            // mode\n\n            System.out.println(\"Adding items from directory: \" + sourceDir);\n            System.out.println(\"Generating mapfile: \" + mapFile);\n\n        boolean directoryFileCollections = false;\n        if (mycollections == null)\n        {\n            directoryFileCollections = true;\n        }\n\n        if (!isTest)\n        {\n            // get the directory names of items to skip (will be in keys of\n            // hash)\n            if (isResume)\n            {\n                skipItems = readMapFile(mapFile);\n            }\n\n                // sneaky isResume == true means open file in append mode\n                outFile = new File(mapFile);\n                mapOut = new PrintWriter(new FileWriter(outFile, isResume));\n\n                if (mapOut == null)\n                {\n                    throw new Exception(\"can't open mapfile: \" + mapFile);\n                }\n            }\n\n            // open and process the source directory\n            File d = new java.io.File(sourceDir);\n\n            if (d == null || !d.isDirectory())\n            {\n                throw new Exception(\"Error, cannot open source directory \" + sourceDir);\n            }\n\n            String[] dircontents = d.list(directoryFilter);\n\n            Arrays.sort(dircontents, ComparatorUtils.naturalComparator());\n\n        for (int i = 0; i < dircontents.length; i++)\n        {\n            if (skipItems.containsKey(dircontents[i]))\n            {\n                System.out.println(\"Skipping import of \" + dircontents[i]);\n            }\n            else\n            {\n                Collection [] clist;\n                if (directoryFileCollections) {\n                    String path = sourceDir + File.separatorChar + dircontents[i];\n                    try {\n                        Collection[] cols = processCollectionFile(c, path, \"collections\");\n                        if (cols == null) {\n                            System.out.println(\"No collections specified for item \" + dircontents[i] + \". Skipping.\");\n                            continue;\n                        }\n                        clist = cols;\n                    }\n                    catch (IllegalArgumentException e)\n                    {\n                        System.out.println(e.getMessage() + \" Skipping.\" );\n                        continue;\n                    }\n                }\n                else\n                {\n                    clist = mycollections;\n                }\n                addItem(c, clist, sourceDir, dircontents[i], mapOut, template);\n                System.out.println(i + \" \" + dircontents[i]);\n                c.clearCache();\n            }\n        }\n\n        } finally {\n            if(mapOut!=null) {\n                mapOut.flush();\n                mapOut.close();\n            }\n        }\n    }\n\n    private void replaceItems(Context c, Collection[] mycollections,\n            String sourceDir, String mapFile, boolean template) throws Exception\n    {\n        // verify the source directory\n        File d = new java.io.File(sourceDir);\n\n        if (d == null || !d.isDirectory())\n        {\n            throw new Exception(\"Error, cannot open source directory \"\n                    + sourceDir);\n        }\n\n        // read in HashMap first, to get list of handles & source dirs\n        Map<String, String> myHash = readMapFile(mapFile);\n\n        // for each handle, re-import the item, discard the new handle\n        // and re-assign the old handle\n        for (Map.Entry<String, String> mapEntry : myHash.entrySet())\n        {\n            // get the old handle\n            String newItemName = mapEntry.getKey();\n            String oldHandle = mapEntry.getValue();\n\n            Item oldItem = null;\n\n            if (oldHandle.indexOf('/') != -1)\n            {\n                System.out.println(\"\\tReplacing:  \" + oldHandle);\n\n                // add new item, locate old one\n                oldItem = (Item) HandleManager.resolveToObject(c, oldHandle);\n            }\n            else\n            {\n                oldItem = Item.find(c, Integer.parseInt(oldHandle));\n            }\n\n            /* Rather than exposing public item methods to change handles --\n             * two handles can't exist at the same time due to key constraints\n             * so would require temp handle being stored, old being copied to new and\n             * new being copied to old, all a bit messy -- a handle file is written to\n             * the import directory containing the old handle, the existing item is\n             * deleted and then the import runs as though it were loading an item which\n             * had already been assigned a handle (so a new handle is not even assigned).\n             * As a commit does not occur until after a successful add, it is safe to\n             * do a delete as any error results in an aborted transaction without harming\n             * the original item */\n            File handleFile = new File(sourceDir + File.separatorChar + newItemName + File.separatorChar + \"handle\");\n            PrintWriter handleOut = new PrintWriter(new FileWriter(handleFile, true));\n\n            if (handleOut == null)\n            {\n                throw new Exception(\"can't open handle file: \" + handleFile.getCanonicalPath());\n            }\n\n            handleOut.println(oldHandle);\n            handleOut.close();\n\n            deleteItem(c, oldItem);\n            addItem(c, mycollections, sourceDir, newItemName, null, template);\n            c.clearCache();\n        }\n    }\n\n    private void deleteItems(Context c, String mapFile) throws Exception\n    {\n        System.out.println(\"Deleting items listed in mapfile: \" + mapFile);\n\n        // read in the mapfile\n        Map<String, String> myhash = readMapFile(mapFile);\n\n        // now delete everything that appeared in the mapFile\n        Iterator<String> i = myhash.keySet().iterator();\n\n        while (i.hasNext())\n        {\n            String itemID = myhash.get(i.next());\n\n            if (itemID.indexOf('/') != -1)\n            {\n                String myhandle = itemID;\n                System.out.println(\"Deleting item \" + myhandle);\n                deleteItem(c, myhandle);\n            }\n            else\n            {\n                // it's an ID\n                Item myitem = Item.find(c, Integer.parseInt(itemID));\n                System.out.println(\"Deleting item \" + itemID);\n                deleteItem(c, myitem);\n            }\n            c.clearCache();\n        }\n    }\n\n    /**\n     * item? try and add it to the archive.\n     * @param mycollections - add item to these Collections.\n     * @param path - directory containing the item directories.\n     * @param itemname handle - non-null means we have a pre-defined handle already\n     * @param mapOut - mapfile we're writing\n     */\n    private Item addItem(Context c, Collection[] mycollections, String path,\n            String itemname, PrintWriter mapOut, boolean template) throws Exception\n    {\n        String mapOutputString = null;\n\n        System.out.println(\"Adding item from directory \" + itemname);\n\n        // create workspace item\n        Item myitem = null;\n        WorkspaceItem wi = null;\n\n        if (!isTest)\n        {\n            wi = WorkspaceItem.create(c, mycollections[0], template);\n            myitem = wi.getItem();\n        }\n\n        // now fill out dublin core for item\n        loadMetadata(c, myitem, path + File.separatorChar + itemname\n                + File.separatorChar);\n\n        // and the bitstreams from the contents file\n        // process contents file, add bistreams and bundles, return any\n        // non-standard permissions\n        List<String> options = processContentsFile(c, myitem, path\n                + File.separatorChar + itemname, \"contents\");\n\n        if (useWorkflow)\n        {\n            // don't process handle file\n            // start up a workflow\n            if (!isTest)\n            {\n                // Should we send a workflow alert email or not?\n                if (ConfigurationManager.getProperty(\"workflow\", \"workflow.framework\").equals(\"xmlworkflow\")) {\n                    if (useWorkflowSendEmail) {\n                        XmlWorkflowManager.start(c, wi);\n                    } else {\n                        XmlWorkflowManager.startWithoutNotify(c, wi);\n                    }\n                } else {\n                    if (useWorkflowSendEmail) {\n                        WorkflowManager.start(c, wi);\n                    }\n                    else\n                    {\n                        WorkflowManager.startWithoutNotify(c, wi);\n                    }\n                }\n\n                // send ID to the mapfile\n                mapOutputString = itemname + \" \" + myitem.getID();\n            }\n        }\n        else\n        {\n            // only process handle file if not using workflow system\n            String myhandle = processHandleFile(c, myitem, path\n                    + File.separatorChar + itemname, \"handle\");\n\n            // put item in system\n            if (!isTest)\n            {\n                try {\n                    InstallItem.installItem(c, wi, myhandle);\n                } catch (Exception e) {\n                    wi.deleteAll();\n                    log.error(\"Exception after install item, try to revert...\", e);\n                    throw e;\n                }\n\n                // find the handle, and output to map file\n                myhandle = HandleManager.findHandle(c, myitem);\n\n                mapOutputString = itemname + \" \" + myhandle;\n            }\n\n            // set permissions if specified in contents file\n            if (options.size() > 0)\n            {\n                System.out.println(\"Processing options\");\n                processOptions(c, myitem, options);\n            }\n        }\n\n        // now add to multiple collections if requested\n        if (mycollections.length > 1)\n        {\n            for (int i = 1; i < mycollections.length; i++)\n            {\n                if (!isTest)\n                {\n                    mycollections[i].addItem(myitem);\n                }\n            }\n        }\n\n        // made it this far, everything is fine, commit transaction\n        if (mapOut != null)\n        {\n            mapOut.println(mapOutputString);\n        }\n\n        c.commit();\n\n        return myitem;\n    }\n\n    // remove, given the actual item\n    private void deleteItem(Context c, Item myitem) throws Exception\n    {\n        if (!isTest)\n        {\n            Collection[] collections = myitem.getCollections();\n\n            // Remove item from all the collections it's in\n            for (int i = 0; i < collections.length; i++)\n            {\n                collections[i].removeItem(myitem);\n            }\n        }\n    }\n\n    // remove, given a handle\n    private void deleteItem(Context c, String myhandle) throws Exception\n    {\n        // bit of a hack - to remove an item, you must remove it\n        // from all collections it's a part of, then it will be removed\n        Item myitem = (Item) HandleManager.resolveToObject(c, myhandle);\n\n        if (myitem == null)\n        {\n            System.out.println(\"Error - cannot locate item - already deleted?\");\n        }\n        else\n        {\n            deleteItem(c, myitem);\n        }\n    }\n\n    ////////////////////////////////////\n    // utility methods\n    ////////////////////////////////////\n    // read in the map file and generate a hashmap of (file,handle) pairs\n    private Map<String, String> readMapFile(String filename) throws Exception\n    {\n        Map<String, String> myHash = new HashMap<String, String>();\n\n        BufferedReader is = null;\n        try\n        {\n            is = new BufferedReader(new FileReader(filename));\n\n            String line;\n\n            while ((line = is.readLine()) != null)\n            {\n                String myFile;\n                String myHandle;\n\n                // a line should be archive filename<whitespace>handle\n                StringTokenizer st = new StringTokenizer(line);\n\n                if (st.hasMoreTokens())\n                {\n                    myFile = st.nextToken();\n                }\n                else\n                {\n                    throw new Exception(\"Bad mapfile line:\\n\" + line);\n                }\n\n                if (st.hasMoreTokens())\n                {\n                    myHandle = st.nextToken();\n                }\n                else\n                {\n                    throw new Exception(\"Bad mapfile line:\\n\" + line);\n                }\n\n                myHash.put(myFile, myHandle);\n            }\n        }\n        finally\n        {\n            if (is != null)\n            {\n                is.close();\n            }\n        }\n\n        return myHash;\n    }\n\n    // Load all metadata schemas into the item.\n    private void loadMetadata(Context c, Item myitem, String path)\n            throws SQLException, IOException, ParserConfigurationException,\n            SAXException, TransformerException, AuthorizeException\n    {\n        // Load the dublin core metadata\n        loadDublinCore(c, myitem, path + \"dublin_core.xml\");\n\n        // Load any additional metadata schemas\n        File folder = new File(path);\n        File file[] = folder.listFiles(metadataFileFilter);\n        for (int i = 0; i < file.length; i++)\n        {\n            loadDublinCore(c, myitem, file[i].getAbsolutePath());\n        }\n    }\n\n    private void loadDublinCore(Context c, Item myitem, String filename)\n            throws SQLException, IOException, ParserConfigurationException,\n            SAXException, TransformerException, AuthorizeException\n    {\n        Document document = loadXML(filename);\n\n        // Get the schema, for backward compatibility we will default to the\n        // dublin core schema if the schema name is not available in the import\n        // file\n        String schema;\n        NodeList metadata = XPathAPI.selectNodeList(document, \"/dublin_core\");\n        Node schemaAttr = metadata.item(0).getAttributes().getNamedItem(\n                \"schema\");\n        if (schemaAttr == null)\n        {\n            schema = MetadataSchema.DC_SCHEMA;\n        }\n        else\n        {\n            schema = schemaAttr.getNodeValue();\n        }\n\n        // Get the nodes corresponding to formats\n        NodeList dcNodes = XPathAPI.selectNodeList(document,\n                \"/dublin_core/dcvalue\");\n\n        if (!isQuiet)\n        {\n            System.out.println(\"\\tLoading dublin core from \" + filename);\n        }\n\n        // Add each one as a new format to the registry\n        for (int i = 0; i < dcNodes.getLength(); i++)\n        {\n            Node n = dcNodes.item(i);\n            addDCValue(c, myitem, schema, n);\n        }\n    }\n\n    private void addDCValue(Context c, Item i, String schema, Node n) throws TransformerException, SQLException, AuthorizeException\n    {\n        String value = getStringValue(n); //n.getNodeValue();\n        // compensate for empty value getting read as \"null\", which won't display\n        if (value == null)\n        {\n            value = \"\";\n        }\n        else\n        {\n        \tvalue = value.trim();\n        }\n        // //getElementData(n, \"element\");\n        String element = getAttributeValue(n, \"element\");\n        String qualifier = getAttributeValue(n, \"qualifier\"); //NodeValue();\n        // //getElementData(n,\n        // \"qualifier\");\n        String language = getAttributeValue(n, \"language\");\n        if (language != null)\n        {\n            language = language.trim();\n        }\n\n        if (!isQuiet)\n        {\n            System.out.println(\"\\tSchema: \" + schema + \" Element: \" + element + \" Qualifier: \" + qualifier\n                    + \" Value: \" + value);\n        }\n\n        if (\"none\".equals(qualifier) || \"\".equals(qualifier))\n        {\n            qualifier = null;\n        }\n        // only add metadata if it is no test and there is an real value\n        if (!isTest && !value.equals(\"\"))\n        {\n            i.addMetadata(schema, element, qualifier, language, value);\n        }\n        else\n        {\n            // If we're just test the import, let's check that the actual metadata field exists.\n        \tMetadataSchema foundSchema = MetadataSchema.find(c,schema);\n\n        \tif (foundSchema == null)\n        \t{\n        \t\tSystem.out.println(\"ERROR: schema '\"+schema+\"' was not found in the registry.\");\n        \t\treturn;\n        \t}\n\n        \tint schemaID = foundSchema.getSchemaID();\n        \tMetadataField foundField = MetadataField.findByElement(c, schemaID, element, qualifier);\n\n        \tif (foundField == null)\n        \t{\n        \t\tSystem.out.println(\"ERROR: Metadata field: '\"+schema+\".\"+element+\".\"+qualifier+\"' was not found in the registry.\");\n        \t\treturn;\n            }\n        }\n    }\n\n    /**\n     * Read the collections file inside the item directory. If there\n     * is one and it is not empty return a list of collections in\n     * which the item should be inserted. If it does not exist or it\n     * is empty return null.\n     *\n     * @param c The context\n     * @param path The path to the data directory for this item\n     * @param filename The collections file filename. Should be \"collections\"\n     * @return A list of collections in which to insert the item or null\n     */\n\n    private Collection[] processCollectionFile(Context c, String path, String filename) throws IOException, SQLException\n    {\n        File file = new File(path + File.separatorChar + filename);\n        ArrayList<Collection> collections = new ArrayList<Collection>();\n        Collection[] result = null;\n        System.out.println(\"Processing collections file: \" + filename);\n\n        if(file.exists())\n        {\n            BufferedReader br = null;\n            try\n            {\n                br = new BufferedReader(new FileReader(file));\n                String line = null;\n                while ((line = br.readLine()) != null)\n                {\n                    DSpaceObject obj = null;\n                    if (line.indexOf('/') != -1)\n                    {\n                        obj = HandleManager.resolveToObject(c, line);\n                        if (obj == null || obj.getType() != Constants.COLLECTION)\n                        {\n                            obj = null;\n                        }\n                    }\n                    else\n                    {\n                        obj = Collection.find(c, Integer.parseInt(line));\n                    }\n\n                    if (obj == null) {\n                        throw new IllegalArgumentException(\"Cannot resolve \" + line + \" to a collection.\");\n                    }\n                    collections.add((Collection)obj);\n\n                }\n\n                result = new Collection[collections.size()];\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = collections.get(i);\n                }\n            }\n            catch (FileNotFoundException e)\n            {\n                System.out.println(\"No collections file found.\");\n            }\n            finally\n            {\n                if (br != null)\n                {\n                    try {\n                        br.close();\n                    } catch (IOException e) {\n                        System.out.println(\"Non-critical problem releasing resources.\");\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Read in the handle file or return null if empty or doesn't exist\n     */\n    private String processHandleFile(Context c, Item i, String path, String filename)\n    {\n        File file = new File(path + File.separatorChar + filename);\n        String result = null;\n\n        System.out.println(\"Processing handle file: \" + filename);\n        if (file.exists())\n        {\n            BufferedReader is = null;\n            try\n            {\n                is = new BufferedReader(new FileReader(file));\n\n                // result gets contents of file, or null\n                result = is.readLine();\n\n                System.out.println(\"read handle: '\" + result + \"'\");\n\n            }\n            catch (FileNotFoundException e)\n            {\n                // probably no handle file, just return null\n                System.out.println(\"It appears there is no handle file -- generating one\");\n            }\n            catch (IOException e)\n            {\n                // probably no handle file, just return null\n                System.out.println(\"It appears there is no handle file -- generating one\");\n            }\n            finally\n            {\n                if (is != null)\n                {\n                    try\n                    {\n                        is.close();\n                    }\n                    catch (IOException e1)\n                    {\n                        System.err.println(\"Non-critical problem releasing resources.\");\n                    }\n                }\n            }\n        }\n        else\n        {\n            // probably no handle file, just return null\n            System.out.println(\"It appears there is no handle file -- generating one\");\n        }\n\n        return result;\n    }\n\n    /**\n     * Given a contents file and an item, stuffing it with bitstreams from the\n     * contents file Returns a List of Strings with lines from the contents\n     * file that request non-default bitstream permission\n     */\n    private List<String> processContentsFile(Context c, Item i, String path,\n            String filename) throws SQLException, IOException,\n            AuthorizeException\n    {\n        File contentsFile = new File(path + File.separatorChar + filename);\n        String line = \"\";\n        List<String> options = new ArrayList<String>();\n\n        System.out.println(\"\\tProcessing contents file: \" + contentsFile);\n\n        if (contentsFile.exists())\n        {\n            BufferedReader is = null;\n            try\n            {\n                is = new BufferedReader(new FileReader(contentsFile));\n\n                while ((line = is.readLine()) != null)\n                {\n                    if (\"\".equals(line.trim()))\n                    {\n                        continue;\n                    }\n\n                    //\t1) registered into dspace (leading -r)\n                    //  2) imported conventionally into dspace (no -r)\n                    if (line.trim().startsWith(\"-r \"))\n                    {\n                        // line should be one of these two:\n                        // -r -s n -f filepath\n                        // -r -s n -f filepath\\tbundle:bundlename\n                        // where\n                        //\t\tn is the assetstore number\n                        //  \tfilepath is the path of the file to be registered\n                        //  \tbundlename is an optional bundle name\n                        String sRegistrationLine = line.trim();\n                        int iAssetstore = -1;\n                        String sFilePath = null;\n                        String sBundle = null;\n                        StringTokenizer tokenizer = new StringTokenizer(sRegistrationLine);\n                        while (tokenizer.hasMoreTokens())\n                        {\n                            String sToken = tokenizer.nextToken();\n                            if (\"-r\".equals(sToken))\n                            {\n                                continue;\n                            }\n                            else if (\"-s\".equals(sToken) && tokenizer.hasMoreTokens())\n                            {\n                                try\n                                {\n                                    iAssetstore =\n                                        Integer.parseInt(tokenizer.nextToken());\n                                }\n                                catch (NumberFormatException e)\n                                {\n                                    // ignore - iAssetstore remains -1\n                                }\n                            }\n                            else if (\"-f\".equals(sToken) && tokenizer.hasMoreTokens())\n                            {\n                                sFilePath = tokenizer.nextToken();\n                            }\n                            else if (sToken.startsWith(\"bundle:\"))\n                            {\n                                sBundle = sToken.substring(7);\n                            }\n                            else\n                            {\n                                // unrecognized token - should be no problem\n                            }\n                        } // while\n                        if (iAssetstore == -1 || sFilePath == null)\n                        {\n                            System.out.println(\"\\tERROR: invalid contents file line\");\n                            System.out.println(\"\\t\\tSkipping line: \"\n                                    + sRegistrationLine);\n                            continue;\n                        }\n\n                        // look for descriptions\n                        boolean descriptionExists = false;\n                        String descriptionMarker = \"\\tdescription:\";\n                        int dMarkerIndex = line.indexOf(descriptionMarker);\n                        int dEndIndex = 0;\n                        if (dMarkerIndex > 0)\n                        {\n                        \tdEndIndex = line.indexOf(\"\\t\", dMarkerIndex + 1);\n                        \tif (dEndIndex == -1)\n                        \t{\n                        \t\tdEndIndex = line.length();\n                        \t}\n                        \tdescriptionExists = true;\n                        }\n                        String sDescription = \"\";\n                        if (descriptionExists)\n                        {\n                        \tsDescription = line.substring(dMarkerIndex, dEndIndex);\n                        \tsDescription = sDescription.replaceFirst(\"description:\", \"\");\n                        }\n\n                        registerBitstream(c, i, iAssetstore, sFilePath, sBundle, sDescription);\n                        System.out.println(\"\\tRegistering Bitstream: \" + sFilePath\n                                + \"\\tAssetstore: \" + iAssetstore\n                                + \"\\tBundle: \" + sBundle\n                                + \"\\tDescription: \" + sDescription);\n                        continue;\t\t\t\t// process next line in contents file\n                    }\n\n                    int bitstreamEndIndex = line.indexOf('\\t');\n\n                    if (bitstreamEndIndex == -1)\n                    {\n                        // no extra info\n                        processContentFileEntry(c, i, path, line, null, false);\n                        System.out.println(\"\\tBitstream: \" + line);\n                    }\n                    else\n                    {\n\n                        String bitstreamName = line.substring(0, bitstreamEndIndex);\n\n                        boolean bundleExists = false;\n                        boolean permissionsExist = false;\n                        boolean descriptionExists = false;\n\n                        // look for a bundle name\n                        String bundleMarker = \"\\tbundle:\";\n                        int bMarkerIndex = line.indexOf(bundleMarker);\n                        int bEndIndex = 0;\n                        if (bMarkerIndex > 0)\n                        {\n                            bEndIndex = line.indexOf(\"\\t\", bMarkerIndex + 1);\n                            if (bEndIndex == -1)\n                            {\n                                bEndIndex = line.length();\n                            }\n                            bundleExists = true;\n                        }\n\n                        // look for permissions\n                        String permissionsMarker = \"\\tpermissions:\";\n                        int pMarkerIndex = line.indexOf(permissionsMarker);\n                        int pEndIndex = 0;\n                        if (pMarkerIndex > 0)\n                        {\n                            pEndIndex = line.indexOf(\"\\t\", pMarkerIndex + 1);\n                            if (pEndIndex == -1)\n                            {\n                                pEndIndex = line.length();\n                            }\n                            permissionsExist = true;\n                        }\n\n                        // look for descriptions\n                        String descriptionMarker = \"\\tdescription:\";\n                        int dMarkerIndex = line.indexOf(descriptionMarker);\n                        int dEndIndex = 0;\n                        if (dMarkerIndex > 0)\n                        {\n                            dEndIndex = line.indexOf(\"\\t\", dMarkerIndex + 1);\n                            if (dEndIndex == -1)\n                            {\n                                dEndIndex = line.length();\n                            }\n                            descriptionExists = true;\n                        }\n\n                        // is this the primary bitstream?\n                        String primaryBitstreamMarker = \"\\tprimary:true\";\n                        boolean primary = false;\n                        String primaryStr = \"\";\n                        if (line.contains(primaryBitstreamMarker))\n                        {\n                            primary = true;\n                            primaryStr = \"\\t **Setting as primary bitstream**\";\n                        }\n\n                        if (bundleExists)\n                        {\n                            String bundleName = line.substring(bMarkerIndex\n                                    + bundleMarker.length(), bEndIndex).trim();\n\n                            processContentFileEntry(c, i, path, bitstreamName, bundleName, primary);\n                            System.out.println(\"\\tBitstream: \" + bitstreamName +\n                                               \"\\tBundle: \" + bundleName +\n                                               primaryStr);\n                        }\n                        else\n                        {\n                            processContentFileEntry(c, i, path, bitstreamName, null, primary);\n                            System.out.println(\"\\tBitstream: \" + bitstreamName + primaryStr);\n                        }\n\n                        if (permissionsExist || descriptionExists)\n                        {\n                            String extraInfo = bitstreamName;\n\n                            if (permissionsExist)\n                            {\n                                extraInfo = extraInfo\n                                        + line.substring(pMarkerIndex, pEndIndex);\n                            }\n\n                            if (descriptionExists)\n                            {\n                                extraInfo = extraInfo\n                                        + line.substring(dMarkerIndex, dEndIndex);\n                            }\n\n                            options.add(extraInfo);\n                        }\n                    }\n                }\n            }\n            finally\n            {\n                if (is != null)\n                {\n                    is.close();\n                }\n            }\n        }\n        else\n        {\n            String[] dirListing = new File(path).list();\n            for (String fileName : dirListing)\n            {\n                if (!\"dublin_core.xml\".equals(fileName) && !fileName.equals(\"handle\") && !fileName.startsWith(\"metadata_\"))\n                {\n                    throw new FileNotFoundException(\"No contents file found\");\n                }\n            }\n\n            System.out.println(\"No contents file found - but only metadata files found. Assuming metadata only.\");\n        }\n\n        return options;\n    }\n\n    /**\n     * each entry represents a bitstream....\n     * @param c\n     * @param i\n     * @param path\n     * @param fileName\n     * @param bundleName\n     * @throws SQLException\n     * @throws IOException\n     * @throws AuthorizeException\n     */\n    private void processContentFileEntry(Context c, Item i, String path,\n            String fileName, String bundleName, boolean primary) throws SQLException,\n            IOException, AuthorizeException\n    {\n        String fullpath = path + File.separatorChar + fileName;\n\n        // get an input stream\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\n                fullpath));\n\n        Bitstream bs = null;\n        String newBundleName = bundleName;\n\n        if (bundleName == null)\n        {\n            // is it license.txt?\n            if (\"license.txt\".equals(fileName))\n            {\n                newBundleName = \"LICENSE\";\n            }\n            else\n            {\n                // call it ORIGINAL\n                newBundleName = \"ORIGINAL\";\n            }\n        }\n\n        if (!isTest)\n        {\n            // find the bundle\n            Bundle[] bundles = i.getBundles(newBundleName);\n            Bundle targetBundle = null;\n\n            if (bundles.length < 1)\n            {\n                // not found, create a new one\n                targetBundle = i.createBundle(newBundleName);\n            }\n            else\n            {\n                // put bitstreams into first bundle\n                targetBundle = bundles[0];\n            }\n\n            // now add the bitstream\n            bs = targetBundle.createBitstream(bis);\n\n            bs.setName(fileName);\n\n            // Identify the format\n            // FIXME - guessing format guesses license.txt incorrectly as a text\n            // file format!\n            BitstreamFormat bf = FormatIdentifier.guessFormat(c, bs);\n            bs.setFormat(bf);\n\n            // Is this a the primary bitstream?\n            if (primary)\n            {\n                targetBundle.setPrimaryBitstreamID(bs.getID());\n                targetBundle.update();\n            }\n\n            bs.update();\n        }\n\n        bis.close();\n    }\n\n    /**\n     * Register the bitstream file into DSpace\n     *\n     * @param c\n     * @param i\n     * @param assetstore\n     * @param bitstreamPath the full filepath expressed in the contents file\n     * @param bundleName\n     * @throws SQLException\n     * @throws IOException\n     * @throws AuthorizeException\n     */\n    private void registerBitstream(Context c, Item i, int assetstore,\n            String bitstreamPath, String bundleName, String description )\n        \tthrows SQLException, IOException, AuthorizeException\n    {\n        // TODO validate assetstore number\n        // TODO make sure the bitstream is there\n\n        Bitstream bs = null;\n        String newBundleName = bundleName;\n\n        if (bundleName == null)\n        {\n            // is it license.txt?\n            if (bitstreamPath.endsWith(\"license.txt\"))\n            {\n                newBundleName = \"LICENSE\";\n            }\n            else\n            {\n                // call it ORIGINAL\n                newBundleName = \"ORIGINAL\";\n            }\n        }\n\n        if(!isTest)\n        {\n        \t// find the bundle\n\t        Bundle[] bundles = i.getBundles(newBundleName);\n\t        Bundle targetBundle = null;\n\n\t        if( bundles.length < 1 )\n\t        {\n\t            // not found, create a new one\n\t            targetBundle = i.createBundle(newBundleName);\n\t        }\n\t        else\n\t        {\n\t            // put bitstreams into first bundle\n\t            targetBundle = bundles[0];\n\t        }\n\n\t        // now add the bitstream\n\t        bs = targetBundle.registerBitstream(assetstore, bitstreamPath);\n\n\t        // set the name to just the filename\n\t        int iLastSlash = bitstreamPath.lastIndexOf('/');\n\t        bs.setName(bitstreamPath.substring(iLastSlash + 1));\n\n\t        // Identify the format\n\t        // FIXME - guessing format guesses license.txt incorrectly as a text file format!\n\t        BitstreamFormat bf = FormatIdentifier.guessFormat(c, bs);\n\t        bs.setFormat(bf);\n\t        bs.setDescription(description);\n\n\t        bs.update();\n        }\n    }\n\n    /**\n     *\n     * Process the Options to apply to the Item. The options are tab delimited\n     *\n     * Options:\n     *      48217870-MIT.pdf        permissions: -r 'MIT Users'     description: Full printable version (MIT only)\n     *      permissions:[r|w]-['group name']\n     *      description: 'the description of the file'\n     *\n     *      where:\n     *          [r|w] (meaning: read|write)\n     *          ['MIT Users'] (the group name)\n     *\n     * @param c\n     * @param myItem\n     * @param options\n     * @throws SQLException\n     * @throws AuthorizeException\n     */\n    private void processOptions(Context c, Item myItem, List<String> options)\n            throws SQLException, AuthorizeException\n    {\n        for (String line : options)\n        {\n            System.out.println(\"\\tprocessing \" + line);\n\n            boolean permissionsExist = false;\n            boolean descriptionExists = false;\n\n            String permissionsMarker = \"\\tpermissions:\";\n            int pMarkerIndex = line.indexOf(permissionsMarker);\n            int pEndIndex = 0;\n            if (pMarkerIndex > 0)\n            {\n                pEndIndex = line.indexOf(\"\\t\", pMarkerIndex + 1);\n                if (pEndIndex == -1)\n                {\n                    pEndIndex = line.length();\n                }\n                permissionsExist = true;\n            }\n\n            String descriptionMarker = \"\\tdescription:\";\n            int dMarkerIndex = line.indexOf(descriptionMarker);\n            int dEndIndex = 0;\n            if (dMarkerIndex > 0)\n            {\n                dEndIndex = line.indexOf(\"\\t\", dMarkerIndex + 1);\n                if (dEndIndex == -1)\n                {\n                    dEndIndex = line.length();\n                }\n                descriptionExists = true;\n            }\n\n            int bsEndIndex = line.indexOf(\"\\t\");\n            String bitstreamName = line.substring(0, bsEndIndex);\n\n            int actionID = -1;\n            String groupName = \"\";\n            Group myGroup = null;\n            if (permissionsExist)\n            {\n                String thisPermission = line.substring(pMarkerIndex\n                        + permissionsMarker.length(), pEndIndex);\n\n                // get permission type (\"read\" or \"write\")\n                int pTypeIndex = thisPermission.indexOf('-');\n\n                // get permission group (should be in single quotes)\n                int groupIndex = thisPermission.indexOf('\\'', pTypeIndex);\n                int groupEndIndex = thisPermission.indexOf('\\'', groupIndex + 1);\n\n                // if not in single quotes, assume everything after type flag is\n                // group name\n                if (groupIndex == -1)\n                {\n                    groupIndex = thisPermission.indexOf(' ', pTypeIndex);\n                    groupEndIndex = thisPermission.length();\n                }\n\n                groupName = thisPermission.substring(groupIndex + 1,\n                        groupEndIndex);\n\n                if (thisPermission.toLowerCase().charAt(pTypeIndex + 1) == 'r')\n                {\n                    actionID = Constants.READ;\n                }\n                else if (thisPermission.toLowerCase().charAt(pTypeIndex + 1) == 'w')\n                {\n                    actionID = Constants.WRITE;\n                }\n\n                try\n                {\n                    myGroup = Group.findByName(c, groupName);\n                }\n                catch (SQLException sqle)\n                {\n                    System.out.println(\"SQL Exception finding group name: \"\n                            + groupName);\n                    // do nothing, will check for null group later\n                }\n            }\n\n            String thisDescription = \"\";\n            if (descriptionExists)\n            {\n                thisDescription = line.substring(\n                        dMarkerIndex + descriptionMarker.length(), dEndIndex)\n                        .trim();\n            }\n\n            Bitstream bs = null;\n            boolean notfound = true;\n            if (!isTest)\n            {\n                // find bitstream\n                Bitstream[] bitstreams = myItem.getNonInternalBitstreams();\n                for (int j = 0; j < bitstreams.length && notfound; j++)\n                {\n                    if (bitstreams[j].getName().equals(bitstreamName))\n                    {\n                        bs = bitstreams[j];\n                        notfound = false;\n                    }\n                }\n            }\n\n            if (notfound && !isTest)\n            {\n                // this should never happen\n                System.out.println(\"\\tdefault permissions set for \"\n                        + bitstreamName);\n            }\n            else if (!isTest)\n            {\n                if (permissionsExist)\n                {\n                    if (myGroup == null)\n                    {\n                        System.out.println(\"\\t\" + groupName\n                                + \" not found, permissions set to default\");\n                    }\n                    else if (actionID == -1)\n                    {\n                        System.out\n                                .println(\"\\tinvalid permissions flag, permissions set to default\");\n                    }\n                    else\n                    {\n                        System.out.println(\"\\tSetting special permissions for \"\n                                + bitstreamName);\n                        setPermission(c, myGroup, actionID, bs);\n                    }\n                }\n\n                if (descriptionExists)\n                {\n                    System.out.println(\"\\tSetting description for \"\n                            + bitstreamName);\n                    bs.setDescription(thisDescription);\n                    bs.update();\n                }\n            }\n        }\n    }\n\n    /**\n     * Set the Permission on a Bitstream.\n     *\n     * @param c\n     * @param g\n     * @param actionID\n     * @param bs\n     * @throws SQLException\n     * @throws AuthorizeException\n     */\n    private void setPermission(Context c, Group g, int actionID, Bitstream bs)\n            throws SQLException, AuthorizeException\n    {\n        if (!isTest)\n        {\n            // remove the default policy\n            AuthorizeManager.removeAllPolicies(c, bs);\n\n            // add the policy\n            ResourcePolicy rp = ResourcePolicy.create(c);\n\n            rp.setResource(bs);\n            rp.setAction(actionID);\n            rp.setGroup(g);\n\n            rp.update();\n        }\n        else\n        {\n            if (actionID == Constants.READ)\n            {\n                System.out.println(\"\\t\\tpermissions: READ for \" + g.getName());\n            }\n            else if (actionID == Constants.WRITE)\n            {\n                System.out.println(\"\\t\\tpermissions: WRITE for \" + g.getName());\n            }\n        }\n\n    }\n\n    // XML utility methods\n    /**\n     * Lookup an attribute from a DOM node.\n     * @param n\n     * @param name\n     * @return\n     */\n    private String getAttributeValue(Node n, String name)\n    {\n        NamedNodeMap nm = n.getAttributes();\n\n        for (int i = 0; i < nm.getLength(); i++)\n        {\n            Node node = nm.item(i);\n\n            if (name.equals(node.getNodeName()))\n            {\n                return node.getNodeValue();\n            }\n        }\n\n        return \"\";\n    }\n\n\n    /**\n     * Return the String value of a Node.\n     * @param node\n     * @return\n     */\n    private String getStringValue(Node node)\n    {\n        String value = node.getNodeValue();\n\n        if (node.hasChildNodes())\n        {\n            Node first = node.getFirstChild();\n\n            if (first.getNodeType() == Node.TEXT_NODE)\n            {\n                return first.getNodeValue();\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Load in the XML from file.\n     *\n     * @param filename\n     *            the filename to load from\n     *\n     * @return the DOM representation of the XML file\n     */\n    private static Document loadXML(String filename) throws IOException,\n            ParserConfigurationException, SAXException\n    {\n        DocumentBuilder builder = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder();\n\n        return builder.parse(new File(filename));\n    }\n\n    /**\n     * Delete a directory and its child files and directories\n     * @param path The directory to delete\n     * @return Whether the deletion was successful or not\n     */\n    private static boolean deleteDirectory(File path)\n    {\n        if (path.exists())\n        {\n            File[] files = path.listFiles();\n            for (int i = 0; i < files.length; i++)\n            {\n                if (files[i].isDirectory())\n                {\n                    deleteDirectory(files[i]);\n                }\n                else\n                {\n                    if (!files[i].delete())\n                    {\n                        log.error(\"Unable to delete file: \" + files[i].getName());\n                    }\n                }\n            }\n        }\n\n        boolean pathDeleted = path.delete();\n        return (pathDeleted);\n    }\n\n    public static String unzip(File zipfile) throws IOException {\n    \treturn unzip(zipfile, null);\n    }\n    \n    public static String unzip(File zipfile, String destDir) throws IOException {\n        // 2\n        // does the zip file exist and can we write to the temp directory\n        if (!zipfile.canRead())\n        {\n            log.error(\"Zip file '\" + zipfile.getAbsolutePath() + \"' does not exist, or is not readable.\");\n        }\n\n        String destinationDir = destDir;\n        if (destinationDir == null){\n        \tdestinationDir = tempWorkDir;\n        }\n        log.debug(\"Using directory \" + destinationDir + \" for zip extraction. (destDir arg is \" + destDir +\n                \", tempWorkDir is \" + tempWorkDir + \")\");\n\n        File tempdir = new File(destinationDir);\n        if (!tempdir.isDirectory())\n        {\n            log.error(\"'\" + ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\") +\n                    \"' as defined by the key 'org.dspace.app.batchitemimport.work.dir' in dspace.cfg \" +\n                    \"is not a valid directory\");\n        }\n\n        if (!tempdir.exists() && !tempdir.mkdirs())\n        {\n            log.error(\"Unable to create temporary directory: \" + tempdir.getAbsolutePath());\n        }\n\n        if(!destinationDir.endsWith(System.getProperty(\"file.separator\"))) {\n            destinationDir += System.getProperty(\"file.separator\");\n        }\n\n        String sourcedir = destinationDir + zipfile.getName();\n        String zipDir = destinationDir + zipfile.getName() + System.getProperty(\"file.separator\");\n\n        log.debug(\"zip directory to use is \" + zipDir);\n\n        // 3\n        String sourceDirForZip = sourcedir;\n        ZipFile zf = new ZipFile(zipfile);\n        ZipEntry entry;\n        Enumeration<? extends ZipEntry> entries = zf.entries();\n        while (entries.hasMoreElements())\n        {\n            entry = entries.nextElement();\n            // Check that the true path to extract files is never outside allowed temp directories\n            // without creating any actual files on disk\n            log.debug(\"Inspecting entry name: \" + entry.getName() + \" for path traversal security\");\n            File potentialExtract = new File(zipDir + entry.getName());\n            String canonicalPath = potentialExtract.getCanonicalPath();\n            log.debug(\"Canonical path to potential File is \" + canonicalPath);\n            if(!canonicalPath.startsWith(zipDir)) {\n                log.error(\"Rejecting zip file: \" + zipfile.getName() + \" as it contains an entry that would be extracted \" +\n                        \"outside the temporary unzip directory: \" + canonicalPath);\n                throw new IOException(\"Error extracting \" + zipfile + \": Canonical path of zip entry: \" +\n                        entry.getName() + \" (\" + canonicalPath + \") does not start with permissible temp \" +\n                        \"unzip directory (\" + destinationDir + \")\");\n            }\n            if (entry.isDirectory())\n            {\n                // Log error and throw IOException if a directory entry could not be created\n                File newDir = new File(zipDir + entry.getName());\n                if (!newDir.mkdirs()) {\n                    log.error(\"Unable to create contents directory: \" + zipDir + entry.getName());\n                    throw new IOException(\"Unable to create contents directory: \" + zipDir + entry.getName());\n                }\n            }\n            else\n            {\n                System.out.println(\"Extracting file: \" + entry.getName());\n                log.info(\"Extracting file: \" + entry.getName());\n\n                int index = entry.getName().lastIndexOf('/');\n                if (index == -1)\n                {\n                    // Was it created on Windows instead?\n                    index = entry.getName().lastIndexOf('\\\\');\n                }\n                if (index > 0)\n                {\n                    File dir = new File(zipDir + entry.getName().substring(0, index));\n                    if (!dir.exists() && !dir.mkdirs())\n                    {\n                        log.error(\"Unable to create directory: \" + dir.getAbsolutePath());\n                    }\n\n                    //Entries could have too many directories, and we need to adjust the sourcedir\n                    // file1.zip (SimpleArchiveFormat / item1 / contents|dublin_core|...\n                    //            SimpleArchiveFormat / item2 / contents|dublin_core|...\n                    // or\n                    // file2.zip (item1 / contents|dublin_core|...\n                    //            item2 / contents|dublin_core|...\n\n                    //regex supports either windows or *nix file paths\n                    String[] entryChunks = entry.getName().split(\"/|\\\\\\\\\");\n                    if(entryChunks.length > 2) {\n                        if(sourceDirForZip == sourcedir) {\n                            sourceDirForZip = sourcedir + \"/\" + entryChunks[0];\n                        }\n                    }\n\n\n                }\n                byte[] buffer = new byte[1024];\n                int len;\n                InputStream in = zf.getInputStream(entry);\n                log.debug(\"Reading \" + zipDir + entry.getName() + \" into InputStream\");\n                BufferedOutputStream out = new BufferedOutputStream(\n                        new FileOutputStream(zipDir + entry.getName()));\n                while((len = in.read(buffer)) >= 0)\n                {\n                    out.write(buffer, 0, len);\n                }\n                in.close();\n                out.close();\n            }\n        }\n\n        //Close zip file\n        zf.close();\n        \n        if(sourceDirForZip != sourcedir) {\n            sourcedir = sourceDirForZip;\n            System.out.println(\"Set sourceDir using path inside of Zip: \" + sourcedir);\n            log.info(\"Set sourceDir using path inside of Zip: \" + sourcedir);\n        }\n\n        return sourcedir;\n    }\n\n    public static String unzip(String sourcedir, String zipfilename) throws IOException {\n        File zipfile = new File(sourcedir + File.separator + zipfilename);\n        return unzip(zipfile);\n    }\n    \n    /**\n     * Generate a random filename based on current time\n     * @param hidden: add . as a prefix to make the file hidden\n     * @return the filename\n     */\n    private static String generateRandomFilename(boolean hidden)\n    {\n    \tString filename = String.format(\"%s\", RandomStringUtils.randomAlphanumeric(8));\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd_HHmm\");\n        String datePart = sdf.format(new Date());\n        filename = datePart+\"_\"+filename;\n\n        return filename;\n    }\n\n    /**\n     * \n     * Given a local file or public URL to a zip file that has the Simple Archive Format, this method imports the contents to DSpace\n     * @param filepath The filepath to local file or the public URL of the zip file\n     * @param owningCollection The owning collection the items will belong to\n     * @param otherCollections The collections the created items will be inserted to, apart from the owning one\n     * @param resumeDir In case of a resume request, the directory that containsthe old mapfile and data \n     * @param inputType The input type of the data (bibtex, csv, etc.), in case of local file\n     * @param context The context\n     * @throws Exception\n     */\n    public static void processUIImport(String filepath, Collection owningCollection, String[] otherCollections, String resumeDir, String inputType, Context context) throws Exception\n\t{\n\t\tfinal EPerson oldEPerson = context.getCurrentUser();\n\t\tfinal String[] theOtherCollections = otherCollections;\n\t\tfinal Collection theOwningCollection = owningCollection;\n\t\tfinal String theFilePath = filepath;\n\t\tfinal String theInputType = inputType;\n\t\tfinal String theResumeDir = resumeDir;\n\t\t\n\t\tThread go = new Thread()\n\t\t{\n\t\t\tpublic void run()\n\t\t\t{\n\t\t\t\tContext context = null;\n\n\t\t\t\tString importDir = null;\n\t\t\t\tEPerson eperson = null;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\t// create a new dspace context\n\t\t\t\t\tcontext = new Context();\n\t\t\t\t\teperson = EPerson.find(context, oldEPerson.getID());\n\t\t\t\t\tcontext.setCurrentUser(eperson);\n\t\t\t\t\tcontext.turnOffAuthorisationSystem();\n\t\t\t\t\t\n\t\t\t\t\tboolean isResume = theResumeDir!=null;\n\t\t\t\t\t\n\t\t\t\t\tList<Collection> collectionList = new ArrayList<Collection>();\n\t    \t\t\tif (theOtherCollections != null){\n\t    \t\t\t\tfor (String colID : theOtherCollections){\n\t    \t\t\t\t\tint colId = Integer.parseInt(colID);\n\t    \t\t\t\t\tif (colId != theOwningCollection.getID()){\n\t    \t\t\t\t\t\tCollection col = Collection.find(context, colId);\n\t    \t\t\t\t\t\tif (col != null){\n\t    \t\t\t\t\t\t\tcollectionList.add(col);\n\t    \t\t\t\t\t\t}\n\t    \t\t\t\t\t}\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tCollection[] otherCollections = collectionList.toArray(new Collection[collectionList.size()]);\n\t    \t\t\t\n\t\t\t\t\timportDir = ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\") + File.separator + \"batchuploads\" + File.separator + context.getCurrentUser().getID() + File.separator + (isResume?theResumeDir:(new GregorianCalendar()).getTimeInMillis());\n\t\t\t\t\tFile importDirFile = new File(importDir);\n\t\t\t\t\tif (!importDirFile.exists()){\n\t\t\t\t\t\tboolean success = importDirFile.mkdirs();\n\t\t\t\t\t\tif (!success) {\n\t\t\t\t\t\t\tlog.info(\"Cannot create batch import directory!\");\n\t\t\t\t\t\t\tthrow new Exception(\"Cannot create batch import directory!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tString dataPath = null;\n\t\t\t\t\tString dataDir = null;\n\t\t\t\t\t\n\t\t\t\t\tif (theInputType.equals(\"saf\")){ //In case of Simple Archive Format import (from remote url)\n\t\t\t\t\t\tdataPath = importDirFile + File.separator + \"data.zip\";\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped2\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\telse if (theInputType.equals(\"safupload\")){ //In case of Simple Archive Format import (from upload file)\n\t\t\t\t\t\tFileUtils.copyFileToDirectory(new File(theFilePath), importDirFile);\n\t\t\t\t\t\tdataPath = importDirFile + File.separator + (new File(theFilePath)).getName();\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped2\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\telse { // For all other imports\n\t\t\t\t\t\tdataPath = importDirFile + File.separator + (new File(theFilePath)).getName();\n    \t    \t\t\tdataDir = importDirFile + File.separator + \"data\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Clear these files, if a resume\n\t\t\t\t\tif (isResume){\n\t\t\t\t\t\tif (!theInputType.equals(\"safupload\")) {\n\t\t\t\t\t\t\t(new File(dataPath)).delete();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(new File(importDirFile + File.separator + \"error.txt\")).delete();\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(dataDir));\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(importDirFile + File.separator + \"data_unzipped\" + File.separator));\n\t\t\t\t\t}\n\n\t\t\t\t\t//In case of Simple Archive Format import we need an extra effort to download the zip file and unzip it\n\t\t\t\t\tString sourcePath = null;\n\t\t\t\t\tif (theInputType.equals(\"saf\")){ \n\t\t\t\t\t\tOutputStream os = new FileOutputStream(dataPath);\n\n\t\t\t\t\t\tbyte[] b = new byte[2048];\n\t\t\t\t\t\tint length;\n\n\t\t\t\t\t\tInputStream is = new URL(theFilePath).openStream();\n\t\t\t\t\t\twhile ((length = is.read(b)) != -1) {\n\t\t\t\t\t\t\tos.write(b, 0, length);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t\tos.close();\n\n\t\t\t\t\t\tsourcePath = unzip(new File(dataPath), dataDir);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Move files to the required folder\n\t\t\t\t\t\tFileUtils.moveDirectory(new File(sourcePath), new File(importDirFile + File.separator + \"data_unzipped\" + File.separator));\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(dataDir));\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\telse if (theInputType.equals(\"safupload\")){ \n\t\t\t\t\t\tsourcePath = unzip(new File(dataPath), dataDir);\n\t\t\t\t\t\t//Move files to the required folder\n\t\t\t\t\t\tFileUtils.moveDirectory(new File(sourcePath), new File(importDirFile + File.separator + \"data_unzipped\" + File.separator));\n\t\t\t\t\t\tFileDeleteStrategy.FORCE.delete(new File(dataDir));\n\t\t\t\t\t\tdataDir = importDirFile + File.separator + \"data_unzipped\" + File.separator;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//Create mapfile path\n\t\t\t\t\tString mapFilePath = importDirFile + File.separator + \"mapfile\";\n\t\t\t\t\t\n\t\t\t\t\tCollection[] finalCollections = null;\n\t\t\t\t\tif (theOwningCollection != null){\n\t\t\t\t\t\tfinalCollections = new Collection[otherCollections.length + 1];\n\t\t\t\t\t\tfinalCollections[0] = theOwningCollection;\n\t\t\t\t\t\tfor (int i=0; i<otherCollections.length; i++){\n\t\t\t\t\t\t\tfinalCollections[i+1] = otherCollections[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tItemImport myloader = new ItemImport();\n\t\t\t\t\tmyloader.isResume = isResume;\n\t\t\t\t\t\n\t\t\t\t\tif (theInputType.equals(\"saf\") || theInputType.equals(\"safupload\")){ //In case of Simple Archive Format import\n\t\t\t\t\t\tmyloader.addItems(context, finalCollections, dataDir, mapFilePath, template);\n\t\t\t\t\t}\n\t\t\t\t\telse { // For all other imports (via BTE)\n\t\t\t\t\t\tmyloader.addBTEItems(context, finalCollections, theFilePath, mapFilePath, template, theInputType, dataDir);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// email message letting user know the file is ready for\n                    // download\n                    emailSuccessMessage(context, eperson, mapFilePath);\n                    \n\t\t\t\t\tcontext.complete();\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tString exceptionString = ExceptionUtils.getStackTrace(e);\n\t\t\t\t\t\n\t\t\t\t\t// abort all operations\n\t                if (mapOut != null)\n\t                {\n\t                    mapOut.close();\n\t                }\n\n\t                mapOut = null;\n\t                \n\t\t\t\t\ttry\n                    {\n\t\t\t\t\t\tFile importDirFile = new File(importDir+File.separator+\"error.txt\");\n\t\t\t\t\t\tPrintWriter errorWriter = new PrintWriter(importDirFile);\n\t\t\t\t\t\terrorWriter.print(exceptionString);\n\t\t\t\t\t\terrorWriter.close();\n\t\t\t\t\t\t\n                        emailErrorMessage(eperson, exceptionString);\n                        throw new Exception(e.getMessage());\n                    }\n                    catch (Exception e2)\n                    {\n                        // wont throw here\n                    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinally\n                {\n                    // close the mapfile writer\n                    if (mapOut != null)\n                    {\n                        mapOut.close();\n                    }\n\n                    // Make sure the database connection gets closed in all conditions.\n                \ttry {\n\t\t\t\t\t\tcontext.complete();\n\t\t\t\t\t} catch (SQLException sqle) {\n\t\t\t\t\t\tcontext.abort();\n\t\t\t\t\t}\n                }\n\t\t\t}\n\n\t\t};\n\n\t\tgo.isDaemon();\n\t\tgo.start();\n\t\t\n\t}\n\n    /**\n     * Since the BTE batch import is done in a new thread we are unable to communicate\n     * with calling method about success or failure. We accomplish this\n     * communication with email instead. Send a success email once the batch\n     * import is complete\n     *\n     * @param context\n     *            - the current Context\n     * @param eperson\n     *            - eperson to send the email to\n     * @param fileName\n     *            - the filepath to the mapfile created by the batch import\n     * @throws MessagingException\n     */\n    public static void emailSuccessMessage(Context context, EPerson eperson,\n            String fileName) throws MessagingException\n    {\n        try\n        {\n            Locale supportedLocale = I18nUtil.getEPersonLocale(eperson);\n            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, \"bte_batch_import_success\"));\n            email.addRecipient(eperson.getEmail());\n            email.addArgument(fileName);\n\n            email.send();\n        }\n        catch (Exception e)\n        {\n            log.warn(LogManager.getHeader(context, \"emailSuccessMessage\", \"cannot notify user of import\"), e);\n        }\n    }\n\n    /**\n     * Since the BTE batch import is done in a new thread we are unable to communicate\n     * with calling method about success or failure. We accomplis this\n     * communication with email instead. Send an error email if the batch\n     * import fails\n     *\n     * @param eperson\n     *            - EPerson to send the error message to\n     * @param error\n     *            - the error message\n     * @throws MessagingException\n     */\n    public static void emailErrorMessage(EPerson eperson, String error)\n            throws MessagingException\n    {\n        log.warn(\"An error occurred during item import, the user will be notified. \" + error);\n        try\n        {\n            Locale supportedLocale = I18nUtil.getEPersonLocale(eperson);\n            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, \"bte_batch_import_error\"));\n            email.addRecipient(eperson.getEmail());\n            email.addArgument(error);\n            email.addArgument(ConfigurationManager.getProperty(\"dspace.url\") + \"/feedback\");\n\n            email.send();\n        }\n        catch (Exception e)\n        {\n            log.warn(\"error during item import error notification\", e);\n        }\n    }\n    \n    \n    public static List<BatchUpload> getImportsAvailable(EPerson eperson)\n            throws Exception\n    {\n        File uploadDir = new File(getImportUploadableDirectory(eperson.getID()));\n        if (!uploadDir.exists() || !uploadDir.isDirectory())\n        {\n            return null;\n        }\n\n        Map<String, BatchUpload> fileNames = new TreeMap<String, BatchUpload>();\n\n        for (String fileName : uploadDir.list())\n        {\n            File file = new File(uploadDir + File.separator + fileName);\n            if (file.isDirectory()){\n            \t\n            \tBatchUpload upload = new BatchUpload(file);\n            \t\n            \tfileNames.put(upload.getDir().getName(), upload);\n            }\n        }\n\n        if (fileNames.size() > 0)\n        {\n            return new ArrayList<BatchUpload>(fileNames.values());\n        }\n\n        return null;\n    }\n    \n    public static String getImportUploadableDirectory(int ePersonID)\n            throws Exception\n    {\n        String uploadDir = ConfigurationManager.getProperty(\"org.dspace.app.batchitemimport.work.dir\");\n        if (uploadDir == null)\n        {\n            throw new Exception(\n                    \"A dspace.cfg entry for 'org.dspace.app.batchitemimport.work.dir' does not exist.\");\n        }\n\n        return uploadDir + File.separator + \"batchuploads\" + File.separator + ePersonID;\n\n    }\n    \n    public void deleteBatchUpload(Context c, String uploadId) throws Exception\n    {\n    \tString uploadDir = null;\n    \tString mapFilePath = null;\n\n\t\tuploadDir = ItemImport.getImportUploadableDirectory(c.getCurrentUser().getID()) + File.separator + uploadId;\n\t\tmapFilePath = uploadDir + File.separator + \"mapfile\";\n\t\n\t\tthis.deleteItems(c, mapFilePath);\n\t\t// complete all transactions\n        c.commit();\n        \n\t\tFileDeleteStrategy.FORCE.delete(new File(uploadDir));\n    }\n\n    public static String getTempWorkDir() {\n        return tempWorkDir;\n    }\n\n    public static File getTempWorkDirFile() {\n        File tempDirFile = new File(getTempWorkDir());\n        if(!tempDirFile.exists()) {\n            tempDirFile.mkdirs();\n        }\n        return tempDirFile;\n    }\n\n    public static void cleanupZipTemp() {\n        System.out.println(\"Deleting temporary zip directory: \" + tempWorkDir);\n        ItemImport.deleteDirectory(new File(tempWorkDir));\n    }\n}\n"], "filenames": ["dspace-api/src/main/java/org/dspace/app/itemimport/ItemImport.java"], "buggy_code_start_loc": [2005], "buggy_code_end_loc": [2076], "fixing_code_start_loc": [2006], "fixing_code_end_loc": [2101], "type": "CWE-22", "message": "DSpace open source software is a repository application which provides durable access to digital resources. In affected versions the ItemImportServiceImpl is vulnerable to a path traversal vulnerability. This means a malicious SAF (simple archive format) package could cause a file/directory to be created anywhere the Tomcat/DSpace user can write to on the server. However, this path traversal vulnerability is only possible by a user with special privileges (either Administrators or someone with command-line access to the server). This vulnerability impacts the XMLUI, JSPUI and command-line. Users are advised to upgrade. As a basic workaround, users may block all access to the following URL paths: If you are using the XMLUI, block all access to /admin/batchimport path (this is the URL of the Admin Batch Import tool). Keep in mind, if your site uses the path \"/xmlui\", then you'd need to block access to /xmlui/admin/batchimport. If you are using the JSPUI, block all access to /dspace-admin/batchimport path (this is the URL of the Admin Batch Import tool). Keep in mind, if your site uses the path \"/jspui\", then you'd need to block access to /jspui/dspace-admin/batchimport. Keep in mind, only an Administrative user or a user with command-line access to the server is able to import/upload SAF packages. Therefore, assuming those users do not blindly upload untrusted SAF packages, then it is unlikely your site could be impacted by this vulnerability.", "other": {"cve": {"id": "CVE-2022-31195", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T21:15:13.557", "lastModified": "2022-08-08T17:16:12.553", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "DSpace open source software is a repository application which provides durable access to digital resources. In affected versions the ItemImportServiceImpl is vulnerable to a path traversal vulnerability. This means a malicious SAF (simple archive format) package could cause a file/directory to be created anywhere the Tomcat/DSpace user can write to on the server. However, this path traversal vulnerability is only possible by a user with special privileges (either Administrators or someone with command-line access to the server). This vulnerability impacts the XMLUI, JSPUI and command-line. Users are advised to upgrade. As a basic workaround, users may block all access to the following URL paths: If you are using the XMLUI, block all access to /admin/batchimport path (this is the URL of the Admin Batch Import tool). Keep in mind, if your site uses the path \"/xmlui\", then you'd need to block access to /xmlui/admin/batchimport. If you are using the JSPUI, block all access to /dspace-admin/batchimport path (this is the URL of the Admin Batch Import tool). Keep in mind, if your site uses the path \"/jspui\", then you'd need to block access to /jspui/dspace-admin/batchimport. Keep in mind, only an Administrative user or a user with command-line access to the server is able to import/upload SAF packages. Therefore, assuming those users do not blindly upload untrusted SAF packages, then it is unlikely your site could be impacted by this vulnerability."}, {"lang": "es", "value": "El software de c\u00f3digo abierto DSpace es una aplicaci\u00f3n de repositorio que proporciona acceso duradero a los recursos digitales. En las versiones afectadas el ItemImportServiceImpl es vulnerable a una vulnerabilidad de salto de ruta. Esto significa que un paquete SAF (formato de archivo simple) malicioso podr\u00eda causar la creaci\u00f3n de un archivo/directorio en cualquier lugar donde el usuario de Tomcat/DSpace pueda escribir en el servidor. Sin embargo, esta vulnerabilidad de salto de ruta s\u00f3lo es posible por un usuario con privilegios especiales (ya sea administradores o alguien con acceso a la l\u00ednea de comandos del servidor). Esta vulnerabilidad afecta a XMLUI, JSPUI y a la l\u00ednea de comandos. Es recomendado a usuarios actualizar. Como mitigaci\u00f3n b\u00e1sica, los usuarios pueden bloquear todo el acceso a las siguientes rutas URL: Si usa la XMLUI, bloquee todos los accesos a la ruta /admin/batchimport (esta es la URL de la herramienta Admin Batch Import). Ten en cuenta que si tu sitio usa la ruta \"/xmlui\", tendr\u00e1s que bloquear el acceso a /xmlui/admin/batchimport. Si usas la JSPUI, bloquea todo el acceso a la ruta /dspace-admin/batchimport (esta es la URL de la herramienta Admin Batch Import). Ten en cuenta que si tu sitio usa la ruta \"/jspui\", entonces tendr\u00e1s que bloquear el acceso a /jspui/dspace-admin/batchimport. Tenga en cuenta que s\u00f3lo un usuario administrativo o un usuario con acceso a la l\u00ednea de comandos del servidor puede importar/cargar paquetes SAF. Por lo tanto, asumiendo que esos usuarios no suben ciegamente paquetes SAF no confiables, entonces es poco probable que su sitio pueda ser impactado por esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:duraspace:dspace:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndIncluding": "5.10", "matchCriteriaId": "D0931332-ACDA-450E-BDC7-BE5D44E27F66"}, {"vulnerable": true, "criteria": "cpe:2.3:a:duraspace:dspace:*:*:*:*:*:*:*:*", "versionStartExcluding": "6.0", "versionEndExcluding": "6.4", "matchCriteriaId": "27C1503E-2C8B-43CD-8937-9ABE6C24C67F"}]}]}], "references": [{"url": "https://github.com/DSpace/DSpace/commit/56e76049185bbd87c994128a9d77735ad7af0199", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/commit/7af52a0883a9dbc475cf3001f04ed11b24c8a4c0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DSpace/DSpace/security/advisories/GHSA-8rmh-55h4-93h5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DSpace/DSpace/commit/56e76049185bbd87c994128a9d77735ad7af0199"}}