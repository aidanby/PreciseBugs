{"buggy_code": ["/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.nuprocess;\n\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\n/**\n * This class is used to create operating system processes.\n * <p>\n * Each {@code NuProcessBuilder} instance manages a collection of process\n * attributes. The {@link #start()} method creates a new {@link NuProcess}\n * instance with those attributes. The {@link #start()} method can be invoked\n * repeatedly from the same instance to create new subprocesses with identical\n * or related attributes.\n * <p>\n * Each {@code NuProcessBuilder} manages these attributes:\n * <ul>\n * <li>a <em>command</em>, a list of strings which signifies the external\n * program file to be invoked and its arguments, if any. Which string lists\n * represent a valid operating system command is system-dependent. For example,\n * it is common for each conceptual argument to be an element in this list, but\n * there are operating systems where programs are expected to tokenize command\n * line strings themselves - on such a system a Java implementation might\n * require commands to contain exactly two elements.</li>\n *\n * <li>an <em>environment</em>, which is a system-dependent mapping from\n * variables to values. The initial value is a copy of the environment of the\n * current process. See {@link System#getenv()}.</li>\n * </ul>\n * <p>\n * Modifying a process builder's attributes will affect processes subsequently\n * started by that object's {@link #start()} method, but will never affect\n * previously started processes or the Java process itself.\n *\n * @author Brett Wooldridge\n */\npublic class NuProcessBuilder\n{\n   private static final NuProcessFactory factory;\n\n   private final List<String> command;\n   private final TreeMap<String, String> environment;\n   private Path cwd;\n   private NuProcessHandler processListener;\n\n   static {\n      String factoryClassName = null;\n      String osname = System.getProperty(\"os.name\").toLowerCase();\n      if (osname.contains(\"mac\") || osname.contains(\"freebsd\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.osx.OsxProcessFactory\";\n      }\n      else if (osname.contains(\"win\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.windows.WinProcessFactory\";\n      }\n      else if (osname.contains(\"linux\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.linux.LinProcessFactory\";\n      }\n      else if (osname.contains(\"sunos\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.solaris.SolProcessFactory\";\n      }\n\n      if (factoryClassName == null) {\n         throw new RuntimeException(\"Unsupported operating system: \" + osname);\n      }\n\n      try {\n         Class<?> forName = Class.forName(factoryClassName);\n         factory = (NuProcessFactory) forName.newInstance();\n      }\n      catch (Exception e) {\n         throw new RuntimeException(e);\n      }\n   }\n\n   /**\n    * Constructs a process builder with the specified operating system program\n    * and arguments. This constructor makes a copy of the command list. Invokers\n    * of this constructor must later call\n    * {@link #setProcessListener(NuProcessHandler)} in order to set a\n    * {@link NuProcessHandler} instance.\n    *\n    * @param commands a {@link List} of commands\n    * @param environment The environment for the process\n    */\n   public NuProcessBuilder(List<String> commands, Map<String, String> environment)\n   {\n      if (commands == null || commands.isEmpty()) {\n         throw new IllegalArgumentException(\"List of commands may not be null or empty\");\n      }\n\n      this.environment = new TreeMap<String, String>(environment);\n      this.command = new ArrayList<String>(commands);\n   }\n\n   /**\n    * Constructs a process builder with the specified operating system program\n    * and arguments. This constructor makes a copy of the command list. Invokers\n    * of this constructor must later call\n    * {@link #setProcessListener(NuProcessHandler)} in order to set a\n    * {@link NuProcessHandler} instance.\n    *\n    * @param commands a {@link List} of commands\n    */\n   public NuProcessBuilder(List<String> commands)\n   {\n      if (commands == null || commands.isEmpty()) {\n         throw new IllegalArgumentException(\"List of commands may not be null or empty\");\n      }\n\n      this.environment = new TreeMap<String, String>(System.getenv());\n      this.command = new ArrayList<String>(commands);\n   }\n\n   /**\n    * Constructs a process builder with the specified operating system program\n    * and arguments. Invokers of this constructor must later call\n    * {@link #setProcessListener(NuProcessHandler)} in order to set a\n    * {@link NuProcessHandler} instance.\n    *\n    * @param commands a list of commands\n    */\n   public NuProcessBuilder(String... commands)\n   {\n      if (commands == null || commands.length == 0) {\n         throw new IllegalArgumentException(\"List of commands may not be null or empty\");\n      }\n\n      this.environment = new TreeMap<String, String>(System.getenv());\n      this.command = new ArrayList<String>(Arrays.asList(commands));\n   }\n\n   /**\n    * Constructs a process builder with the specified {@link NuProcessHandler}\n    * and operating system program and arguments.\n    *\n    * @param nuProcessHandler a {@link NuProcessHandler} instance\n    * @param commands a list of commands\n    */\n   public NuProcessBuilder(NuProcessHandler nuProcessHandler, String... commands)\n   {\n      this(commands);\n\n      if (nuProcessHandler == null) {\n         throw new IllegalArgumentException(\"A NuProcessListener must be specified\");\n      }\n\n      this.processListener = nuProcessHandler;\n   }\n\n   /**\n    * Constructs a process builder with the specified {@link NuProcessHandler}\n    * and operating system program and arguments. This constructor makes a copy\n    * of the command list.\n    *\n    * @param nuProcessHandler a {@link NuProcessHandler} instance\n    * @param commands a {@link List} of commands\n    */\n   public NuProcessBuilder(NuProcessHandler nuProcessHandler, List<String> commands)\n   {\n      this(commands);\n\n      if (nuProcessHandler == null) {\n         throw new IllegalArgumentException(\"A NuProcessListener must be specified\");\n      }\n\n      this.processListener = nuProcessHandler;\n   }\n\n   /**\n    * Get the {@link List} of commands that were used to construct this\n    * {@link NuProcessBuilder}.\n    *\n    * @return a {@link List} of commands\n    */\n   public List<String> command()\n   {\n      return command;\n   }\n\n   /**\n    * Returns a string map view of this process builder's environment. Whenever\n    * a process builder is created, the environment is initialized to a copy of\n    * the current process environment. Subprocesses subsequently started by this\n    * object's {@link #start()} method will use this map as their environment.\n    * <p>\n    * The returned object may be modified using ordinary Map operations prior to\n    * invoking the {@link #start()} method. The returned map is typically\n    * case-sensitive on all platforms.\n    *\n    * @return This process builder's environment\n    */\n   public Map<String, String> environment()\n   {\n      return environment;\n   }\n\n   /**\n    * Set the {@link NuProcessHandler} instance that will be used for the next\n    * and subsequent launch of a {@link NuProcess} when calling the\n    * {@link #start()} method.\n    *\n    * @param listener a {@link NuProcessHandler} instance\n    */\n   public void setProcessListener(NuProcessHandler listener)\n   {\n      if (listener == null) {\n         throw new IllegalArgumentException(\"A NuProcessListener must be specified\");\n      }\n\n      this.processListener = listener;\n   }\n\n   /**\n    * Set the {@link Path} to which the current working directory (cwd) of the\n    * subsequent launch of a {@link NuProcess} will be set when calling the\n    * {@link #start()} method.\n    *\n    * @param cwd a {@link Path} to use for the process's current working\n    *        directory, or {@code null} to disable setting the cwd of\n    *        subsequently launched proceses\n    */\n   public void setCwd(Path cwd)\n   {\n      this.cwd = cwd;\n   }\n\n   /**\n    * Spawn the child process with the configured commands, environment, and\n    * {@link NuProcessHandler}.\n    *\n    * @return a {@link NuProcess} instance or {@code null} if there is an\n    *         immediately detectable launch failure\n    */\n   public NuProcess start()\n   {\n      ensureListener();\n      String[] env = prepareEnvironment();\n\n      return factory.createProcess(command, env, processListener, cwd);\n   }\n\n   /**\n    * Spawn the child process with the configured commands, environment, and {@link NuProcessHandler}\n    * and wait for it to complete running.\n    *\n    * @since 1.3\n    */\n   public void run()\n   {\n      ensureListener();\n      String[] env = prepareEnvironment();\n\n      factory.runProcess(command, env, processListener, cwd);\n   }\n\n   private void ensureListener()\n   {\n      if (processListener == null) {\n         throw new IllegalArgumentException(\"NuProcessHandler not specified\");\n      }\n   }\n\n   private String[] prepareEnvironment()\n   {\n      String[] env = new String[environment.size()];\n      int i = 0;\n      for (Entry<String, String> entrySet : environment.entrySet()) {\n         env[i++] = entrySet.getKey() + \"=\" + entrySet.getValue();\n      }\n\n      return env;\n   }\n}\n", "/*\n * Copyright (C) 2019 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.nuprocess;\n\nimport com.zaxxer.nuprocess.codec.NuAbstractCharsetHandler;\nimport org.junit.*;\nimport org.junit.rules.TemporaryFolder;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.zip.Adler32;\n\n/**\n * Performs <i>synchronous</i> tests using {@link NuProcessBuilder#run}.\n */\npublic class RunTest\n{\n   private String command;\n\n   @Rule\n   public final TemporaryFolder tmp = new TemporaryFolder();\n\n   @Before\n   public void setup()\n   {\n      command = \"cat\";\n      if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n         command = \"src\\\\test\\\\java\\\\com\\\\zaxxer\\\\nuprocess\\\\cat.exe\";\n      }\n   }\n\n   @Test\n   public void lotOfProcesses() throws InterruptedException\n   {\n      int cpus = Runtime.getRuntime().availableProcessors();\n      Assume.assumeTrue(\"Skipping lotOfProcesses(); the system only has 1 CPU\", cpus > 1);\n\n      // Use at least 2 threads, to ensure concurrency, but use no more than 4 threads to avoid\n      // producing excessive system load\n      final int threadCount = Math.max(2, Math.min(4, cpus / 2));\n      System.err.println(\"Starting test lotOfProcesses() with \" + threadCount + \" threads\");\n\n      // Start threadCount threads, each running several synchronous processes in a row. This parallel\n      // execution is intended to verify synchronous pumping on concurrent threads doesn't produce any\n      // unexpected interactions \"between\" the threads\n      final Thread[] threads = new Thread[threadCount];\n      final AssertionError[] failures = new AssertionError[threadCount];\n      for (int i = 0; i < threadCount; i++) {\n         final int threadId = i + 1;\n         Thread thread = new Thread(\"RunTest-lotOfProcesses-\" + threadId) {\n            @Override\n            public void run()\n            {\n               for (int times = 0; times < 20; times++) {\n                  System.err.printf(\"Thread %d: Iteration %d\\n\", threadId, times + 1);\n\n                  LottaProcessListener listener = new LottaProcessListener();\n                  NuProcessBuilder pb = new NuProcessBuilder(listener, command);\n                  pb.run();\n\n                  try {\n                     Assert.assertTrue(\"Adler32 mismatch between written and read\", listener.checkAdlers());\n                     Assert.assertEquals(\"Exit code mismatch\", 0, listener.getExitCode());\n                  } catch (AssertionError e) {\n                     failures[threadId - 1] = e;\n                     break;\n                  }\n               }\n            }\n         };\n         thread.setDaemon(true);\n         thread.start();\n\n         threads[i] = thread;\n      }\n\n      // After all the threads are started, wait for each to finish and then check to see whether it\n      // inserted an AssertionError into the failures array\n      int failed = 0;\n      for (int i = 0; i < threadCount; i++) {\n         threads[i].join();\n         if (failures[i] != null) {\n            System.err.printf(\"Thread %d failed: %s\", threadCount + 1, failures[i].getMessage());\n            ++failed;\n         }\n      }\n\n      // If any threads failed, the test failed\n      if (failed > 0) {\n         Assert.fail(failed + \" thread(s) failed\");\n      }\n\n      System.err.println(\"Completed test lotOfProcesses()\");\n   }\n\n   @Test\n   public void lotOfData()\n   {\n      System.err.println(\"Starting test lotOfData()\");\n      for (int i = 0; i < 100; i++) {\n         LottaProcessListener processListener = new LottaProcessListener();\n         NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n         pb.run();\n\n         Assert.assertTrue(\"Adler32 mismatch between written and read\", processListener.checkAdlers());\n      }\n\n      System.err.println(\"Completed test lotOfData()\");\n   }\n\n   @Test\n   public void decodingShortUtf8Data()\n   {\n      String SHORT_UNICODE_TEXT = \"Hello \\uD83D\\uDCA9 world\";\n      System.err.println(\"Starting test decodingShortUtf8Data()\");\n      Utf8DecodingListener processListener = new Utf8DecodingListener(SHORT_UNICODE_TEXT, true);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n      pb.run();\n      Assert.assertEquals(\"Decoding mismatch\", SHORT_UNICODE_TEXT, processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      Assert.assertFalse(\"Decoder stdin should not overflow\", processListener.stdinOverflow);\n      System.err.println(\"Completed test decodingShortUtf8Data()\");\n   }\n\n   @Test\n   public void decodingLongUtf8Data()\n   {\n      // We use 3 bytes to make sure at least one UTF-8 boundary goes across two byte buffers.\n      String THREE_BYTE_UTF_8 = \"\\u2764\";\n      StringBuilder unicodeTextWhichDoesNotFitInBuffer = new StringBuilder();\n      for (int i = 0; i < NuProcess.BUFFER_CAPACITY + 1; i++) {\n         unicodeTextWhichDoesNotFitInBuffer.append(THREE_BYTE_UTF_8);\n      }\n      System.err.println(\"Starting test decodingLongUtf8Data()\");\n      Utf8DecodingListener processListener = new Utf8DecodingListener(unicodeTextWhichDoesNotFitInBuffer.toString(), true);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n      pb.run();\n      Assert.assertEquals(\"Decoding mismatch\", unicodeTextWhichDoesNotFitInBuffer.toString(), processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      Assert.assertTrue(\"Decoder stdin should overflow\", processListener.stdinOverflow);\n      System.err.println(\"Completed test decodingLongUtf8Data()\");\n   }\n\n   @Test\n   public void badExit() throws InterruptedException\n   {\n      System.err.println(\"Starting test badExit()\");\n\n      final AtomicInteger asyncExitCode = new AtomicInteger();\n      final CountDownLatch exitLatch = new CountDownLatch(1);\n\n      NuProcessHandler processListener = new NuAbstractProcessHandler() {\n         @Override\n         public void onExit(int statusCode)\n         {\n            asyncExitCode.set(statusCode);\n            exitLatch.countDown();\n         }\n      };\n\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command, \"/tmp/sdfadsf\");\n      NuProcess nuProcess = pb.start();\n      int syncExitCode = nuProcess.waitFor(5, TimeUnit.SECONDS);\n      boolean countedDown = exitLatch.await(5, TimeUnit.SECONDS);\n      Assert.assertTrue(\"Async exit latch was not triggered\", countedDown);\n\n      int expectedExitCode = System.getProperty(\"os.name\").toLowerCase().contains(\"win\") ? -1 : 1;\n      Assert.assertEquals(\"Exit code (synchronous) did not match expectation\", expectedExitCode, syncExitCode);\n      Assert.assertEquals(\"Exit code (asynchronous) did not match expectation\", expectedExitCode, asyncExitCode.get());\n\n      System.err.println(\"Completed test badExit()\");\n   }\n\n   @Test\n   public void noExecutableFound()\n   {\n      System.err.println(\"Starting test noExecutableFound()\");\n\n      final Semaphore semaphore = new Semaphore(0);\n      final AtomicInteger exitCode = new AtomicInteger();\n\n      NuProcessHandler processListener = new NuAbstractProcessHandler() {\n         @Override\n         public void onExit(int statusCode)\n         {\n            exitCode.set(statusCode);\n            semaphore.release();\n         }\n      };\n\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, \"/bin/zxczxc\");\n      NuProcess process = pb.start();\n      semaphore.acquireUninterruptibly();\n      Assert.assertFalse(\"Process incorrectly reported running\", process.isRunning());\n      Assert.assertEquals(\"Output did not matched expected result\", Integer.MIN_VALUE, exitCode.get());\n\n      System.err.println(\"Completed test noExecutableFound()\");\n   }\n\n   @Test\n   public void callbackOrder() throws InterruptedException\n   {\n      final List<String> callbacks = new CopyOnWriteArrayList<>();\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      NuProcessHandler handler = new NuProcessHandler() {\n         private NuProcess nuProcess;\n\n         @Override\n         public void onStdout(ByteBuffer buffer, boolean closed)\n         {\n            callbacks.add(\"stdout\");\n            nuProcess.closeStdin(true);\n         }\n\n         @Override\n         public boolean onStdinReady(ByteBuffer buffer)\n         {\n            callbacks.add(\"stdin\");\n            buffer.put(\"foobar\".getBytes()).flip();\n            return false;\n         }\n\n         @Override\n         public void onStderr(ByteBuffer buffer, boolean closed)\n         {\n            callbacks.add(\"stderr\");\n         }\n\n         @Override\n         public void onStart(NuProcess nuProcess)\n         {\n            callbacks.add(\"start\");\n            this.nuProcess = nuProcess;\n            nuProcess.wantWrite();\n         }\n\n         @Override\n         public void onPreStart(NuProcess nuProcess)\n         {\n            callbacks.add(\"prestart\");\n         }\n\n         @Override\n         public void onExit(int exitCode)\n         {\n            callbacks.add(\"exit\");\n            latch.countDown();\n         }\n      };\n\n      Assert.assertNotNull(\"process is null\", new NuProcessBuilder(handler, command).start());\n      latch.await();\n\n      Assert.assertEquals(\"onPreStart was not called first\", 0, callbacks.indexOf(\"prestart\"));\n      Assert.assertFalse(\"onExit was called before onStdout\", callbacks.indexOf(\"exit\") < callbacks.lastIndexOf(\"stdout\"));\n   }\n\n   @Test\n   public void changeCwd() throws IOException\n   {\n      Path javaCwd = Paths.get(System.getProperty(\"user.dir\"));\n      Path tmpPath = tmp.getRoot().toPath();\n      System.err.println(\"Starting test changeCwd() (java cwd=\" + javaCwd + \", tmp=\" + tmpPath + \")\");\n      Assert.assertNotEquals(\"java cwd should not be tmp path before process\", javaCwd.toRealPath(), tmpPath.toRealPath());\n      String message = \"Hello cwd-aware world\\n\";\n      Files.write(tmpPath.resolve(\"foo.txt\"), message.getBytes(StandardCharsets.UTF_8));\n      Utf8DecodingListener processListener = new Utf8DecodingListener(\"\", true);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command, \"foo.txt\");\n      pb.setCwd(tmpPath);\n      pb.run();\n      Assert.assertEquals(\"Output mismatch\", message, processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      javaCwd = Paths.get(System.getProperty(\"user.dir\"));\n      Assert.assertNotEquals(\"java cwd should not be tmp path after process\", javaCwd.toRealPath(), tmpPath.toRealPath());\n      System.err.println(\"Completed test changeCwd()\");\n   }\n\n   @Test\n   public void softCloseStdinAfterWrite()\n   {\n      String text = \"Hello world!\";\n      System.err.println(\"Starting test softCloseStdinAfterWrite()\");\n      Utf8DecodingListener processListener = new Utf8DecodingListener(text, false);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n      pb.run();\n      Assert.assertEquals(\"Decoding mismatch\", text, processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      Assert.assertFalse(\"Decoder stdin should not overflow\", processListener.stdinOverflow);\n      System.err.println(\"Completed test softCloseStdinAfterWrite()\");\n   }\n\n   private static byte[] getLotsOfBytes()\n   {\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < 6000; i++) {\n         sb.append(\"1234567890\");\n      }\n\n      return sb.toString().getBytes();\n   }\n\n   private static class LottaProcessListener extends NuAbstractProcessHandler\n   {\n      private static final int WRITES = 10;\n      private NuProcess nuProcess;\n      private int writes;\n      private int size;\n      private int exitCode;\n\n      private Adler32 readAdler32;\n      private Adler32 writeAdler32;\n      private byte[] bytes;\n\n      LottaProcessListener()\n      {\n         this.readAdler32 = new Adler32();\n         this.writeAdler32 = new Adler32();\n\n         bytes = getLotsOfBytes();\n         exitCode = -1;\n      }\n\n      @Override\n      public void onStart(NuProcess nuProcess)\n      {\n         this.nuProcess = nuProcess;\n         nuProcess.wantWrite();\n      }\n\n      @Override\n      public void onExit(int statusCode)\n      {\n         exitCode = statusCode;\n      }\n\n      @Override\n      public void onStdout(ByteBuffer buffer, boolean closed)\n      {\n         size += buffer.remaining();\n         if (size == (WRITES * bytes.length)) {\n            nuProcess.closeStdin(true);\n         }\n\n         byte[] bytes = new byte[buffer.remaining()];\n         buffer.get(bytes);\n         readAdler32.update(bytes);\n      }\n\n      @Override\n      public boolean onStdinReady(ByteBuffer buffer)\n      {\n         writeAdler32.update(bytes);\n\n         buffer.put(bytes);\n         buffer.flip();\n\n         return (++writes < WRITES);\n      }\n\n      int getExitCode()\n      {\n         return exitCode;\n      }\n\n      boolean checkAdlers()\n      {\n         return writes == WRITES && readAdler32.getValue() == writeAdler32.getValue();\n      }\n   }\n\n   private static class Utf8DecodingListener extends NuAbstractCharsetHandler\n   {\n      private final CharBuffer utf8Buffer;\n      private final boolean forceCloseStdin;\n      private int charsWritten;\n      private int charsRead;\n      private NuProcess nuProcess;\n      StringBuilder decodedStdout;\n      boolean stdinOverflow;\n      int exitCode;\n\n      Utf8DecodingListener(String utf8Text, boolean forceCloseStdin)\n      {\n         super(StandardCharsets.UTF_8);\n         this.utf8Buffer = CharBuffer.wrap(utf8Text);\n         this.forceCloseStdin = forceCloseStdin;\n         this.charsWritten = 0;\n         this.charsRead = 0;\n         this.decodedStdout = new StringBuilder();\n         this.stdinOverflow = false;\n         this.exitCode = -1;\n      }\n\n      @Override\n      public void onStart(NuProcess nuProcess)\n      {\n         this.nuProcess = nuProcess;\n         nuProcess.wantWrite();\n      }\n\n      @Override\n      public void onExit(int statusCode)\n      {\n         exitCode = statusCode;\n      }\n\n      @Override\n      public void onStdoutChars(CharBuffer buffer, boolean closed, CoderResult coderResult)\n      {\n         charsRead += buffer.remaining();\n         decodedStdout.append(buffer);\n         buffer.position(buffer.limit());\n\n         if (forceCloseStdin && charsRead == charsWritten) {\n            nuProcess.closeStdin(true);\n         }\n      }\n\n      @Override\n      public boolean onStdinCharsReady(CharBuffer buffer)\n      {\n         if (utf8Buffer.remaining() <= buffer.remaining()) {\n            charsWritten += utf8Buffer.remaining();\n            buffer.put(utf8Buffer);\n            buffer.flip();\n            if (!forceCloseStdin) {\n               nuProcess.closeStdin(false);\n            }\n            return false;\n         }\n         else {\n            charsWritten += buffer.remaining();\n            buffer.put(utf8Buffer.subSequence(0, buffer.remaining()));\n            buffer.flip();\n            utf8Buffer.position(utf8Buffer.position() + buffer.remaining());\n            stdinOverflow = true;\n            return true;\n         }\n      }\n   }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.nuprocess;\n\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\n/**\n * This class is used to create operating system processes.\n * <p>\n * Each {@code NuProcessBuilder} instance manages a collection of process\n * attributes. The {@link #start()} method creates a new {@link NuProcess}\n * instance with those attributes. The {@link #start()} method can be invoked\n * repeatedly from the same instance to create new subprocesses with identical\n * or related attributes.\n * <p>\n * Each {@code NuProcessBuilder} manages these attributes:\n * <ul>\n * <li>a <em>command</em>, a list of strings which signifies the external\n * program file to be invoked and its arguments, if any. Which string lists\n * represent a valid operating system command is system-dependent. For example,\n * it is common for each conceptual argument to be an element in this list, but\n * there are operating systems where programs are expected to tokenize command\n * line strings themselves - on such a system a Java implementation might\n * require commands to contain exactly two elements.</li>\n *\n * <li>an <em>environment</em>, which is a system-dependent mapping from\n * variables to values. The initial value is a copy of the environment of the\n * current process. See {@link System#getenv()}.</li>\n * </ul>\n * <p>\n * Modifying a process builder's attributes will affect processes subsequently\n * started by that object's {@link #start()} method, but will never affect\n * previously started processes or the Java process itself.\n *\n * @author Brett Wooldridge\n */\npublic class NuProcessBuilder\n{\n   private static final NuProcessFactory factory;\n\n   private final List<String> command;\n   private final TreeMap<String, String> environment;\n   private Path cwd;\n   private NuProcessHandler processListener;\n\n   static {\n      String factoryClassName = null;\n      String osname = System.getProperty(\"os.name\").toLowerCase();\n      if (osname.contains(\"mac\") || osname.contains(\"freebsd\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.osx.OsxProcessFactory\";\n      }\n      else if (osname.contains(\"win\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.windows.WinProcessFactory\";\n      }\n      else if (osname.contains(\"linux\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.linux.LinProcessFactory\";\n      }\n      else if (osname.contains(\"sunos\")) {\n         factoryClassName = \"com.zaxxer.nuprocess.solaris.SolProcessFactory\";\n      }\n\n      if (factoryClassName == null) {\n         throw new RuntimeException(\"Unsupported operating system: \" + osname);\n      }\n\n      try {\n         Class<?> forName = Class.forName(factoryClassName);\n         factory = (NuProcessFactory) forName.newInstance();\n      }\n      catch (Exception e) {\n         throw new RuntimeException(e);\n      }\n   }\n\n   /**\n    * Constructs a process builder with the specified operating system program\n    * and arguments. This constructor makes a copy of the command list. Invokers\n    * of this constructor must later call\n    * {@link #setProcessListener(NuProcessHandler)} in order to set a\n    * {@link NuProcessHandler} instance.\n    *\n    * @param commands a {@link List} of commands\n    * @param environment The environment for the process\n    */\n   public NuProcessBuilder(List<String> commands, Map<String, String> environment)\n   {\n      if (commands == null || commands.isEmpty()) {\n         throw new IllegalArgumentException(\"List of commands may not be null or empty\");\n      }\n\n      this.environment = new TreeMap<String, String>(environment);\n      this.command = new ArrayList<String>(commands);\n   }\n\n   /**\n    * Constructs a process builder with the specified operating system program\n    * and arguments. This constructor makes a copy of the command list. Invokers\n    * of this constructor must later call\n    * {@link #setProcessListener(NuProcessHandler)} in order to set a\n    * {@link NuProcessHandler} instance.\n    *\n    * @param commands a {@link List} of commands\n    */\n   public NuProcessBuilder(List<String> commands)\n   {\n      if (commands == null || commands.isEmpty()) {\n         throw new IllegalArgumentException(\"List of commands may not be null or empty\");\n      }\n\n      this.environment = new TreeMap<String, String>(System.getenv());\n      this.command = new ArrayList<String>(commands);\n   }\n\n   /**\n    * Constructs a process builder with the specified operating system program\n    * and arguments. Invokers of this constructor must later call\n    * {@link #setProcessListener(NuProcessHandler)} in order to set a\n    * {@link NuProcessHandler} instance.\n    *\n    * @param commands a list of commands\n    */\n   public NuProcessBuilder(String... commands)\n   {\n      if (commands == null || commands.length == 0) {\n         throw new IllegalArgumentException(\"List of commands may not be null or empty\");\n      }\n\n      this.environment = new TreeMap<String, String>(System.getenv());\n      this.command = new ArrayList<String>(Arrays.asList(commands));\n   }\n\n   /**\n    * Constructs a process builder with the specified {@link NuProcessHandler}\n    * and operating system program and arguments.\n    *\n    * @param nuProcessHandler a {@link NuProcessHandler} instance\n    * @param commands a list of commands\n    */\n   public NuProcessBuilder(NuProcessHandler nuProcessHandler, String... commands)\n   {\n      this(commands);\n\n      if (nuProcessHandler == null) {\n         throw new IllegalArgumentException(\"A NuProcessListener must be specified\");\n      }\n\n      this.processListener = nuProcessHandler;\n   }\n\n   /**\n    * Constructs a process builder with the specified {@link NuProcessHandler}\n    * and operating system program and arguments. This constructor makes a copy\n    * of the command list.\n    *\n    * @param nuProcessHandler a {@link NuProcessHandler} instance\n    * @param commands a {@link List} of commands\n    */\n   public NuProcessBuilder(NuProcessHandler nuProcessHandler, List<String> commands)\n   {\n      this(commands);\n\n      if (nuProcessHandler == null) {\n         throw new IllegalArgumentException(\"A NuProcessListener must be specified\");\n      }\n\n      this.processListener = nuProcessHandler;\n   }\n\n   /**\n    * Get the {@link List} of commands that were used to construct this\n    * {@link NuProcessBuilder}.\n    *\n    * @return a {@link List} of commands\n    */\n   public List<String> command()\n   {\n      return command;\n   }\n\n   /**\n    * Returns a string map view of this process builder's environment. Whenever\n    * a process builder is created, the environment is initialized to a copy of\n    * the current process environment. Subprocesses subsequently started by this\n    * object's {@link #start()} method will use this map as their environment.\n    * <p>\n    * The returned object may be modified using ordinary Map operations prior to\n    * invoking the {@link #start()} method. The returned map is typically\n    * case-sensitive on all platforms.\n    *\n    * @return This process builder's environment\n    */\n   public Map<String, String> environment()\n   {\n      return environment;\n   }\n\n   /**\n    * Set the {@link NuProcessHandler} instance that will be used for the next\n    * and subsequent launch of a {@link NuProcess} when calling the\n    * {@link #start()} method.\n    *\n    * @param listener a {@link NuProcessHandler} instance\n    */\n   public void setProcessListener(NuProcessHandler listener)\n   {\n      if (listener == null) {\n         throw new IllegalArgumentException(\"A NuProcessListener must be specified\");\n      }\n\n      this.processListener = listener;\n   }\n\n   /**\n    * Set the {@link Path} to which the current working directory (cwd) of the\n    * subsequent launch of a {@link NuProcess} will be set when calling the\n    * {@link #start()} method.\n    *\n    * @param cwd a {@link Path} to use for the process's current working\n    *        directory, or {@code null} to disable setting the cwd of\n    *        subsequently launched proceses\n    */\n   public void setCwd(Path cwd)\n   {\n      this.cwd = cwd;\n   }\n\n   /**\n    * Spawn the child process with the configured commands, environment, and\n    * {@link NuProcessHandler}.\n    *\n    * @return a {@link NuProcess} instance or {@code null} if there is an\n    *         immediately detectable launch failure\n    */\n   public NuProcess start()\n   {\n      ensureNoNullCharacters(command);\n      ensureListener();\n      String[] env = prepareEnvironment();\n\n      return factory.createProcess(command, env, processListener, cwd);\n   }\n\n   /**\n    * Spawn the child process with the configured commands, environment, and {@link NuProcessHandler}\n    * and wait for it to complete running.\n    *\n    * @since 1.3\n    */\n   public void run()\n   {\n      ensureNoNullCharacters(command);\n      ensureListener();\n      String[] env = prepareEnvironment();\n\n      factory.runProcess(command, env, processListener, cwd);\n   }\n\n   private void ensureListener()\n   {\n      if (processListener == null) {\n         throw new IllegalArgumentException(\"NuProcessHandler not specified\");\n      }\n   }\n\n   private void ensureNoNullCharacters(List<String> commands) {\n      for (String command : commands) {\n         if (command.indexOf('\\u0000') >= 0) {\n            throw new IllegalArgumentException(\"Commands may not contain null characters\");\n         }\n      }\n   }\n\n   private String[] prepareEnvironment()\n   {\n      String[] env = new String[environment.size()];\n      int i = 0;\n      for (Entry<String, String> entrySet : environment.entrySet()) {\n         env[i++] = entrySet.getKey() + \"=\" + entrySet.getValue();\n      }\n\n      return env;\n   }\n}\n", "/*\n * Copyright (C) 2019 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.nuprocess;\n\nimport com.zaxxer.nuprocess.codec.NuAbstractCharsetHandler;\nimport org.junit.*;\nimport org.junit.rules.TemporaryFolder;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.zip.Adler32;\n\n/**\n * Performs <i>synchronous</i> tests using {@link NuProcessBuilder#run}.\n */\npublic class RunTest\n{\n   private String command;\n\n   @Rule\n   public final TemporaryFolder tmp = new TemporaryFolder();\n\n   @Before\n   public void setup()\n   {\n      command = \"cat\";\n      if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n         command = \"src\\\\test\\\\java\\\\com\\\\zaxxer\\\\nuprocess\\\\cat.exe\";\n      }\n   }\n\n   @Test\n   public void lotOfProcesses() throws InterruptedException\n   {\n      int cpus = Runtime.getRuntime().availableProcessors();\n      Assume.assumeTrue(\"Skipping lotOfProcesses(); the system only has 1 CPU\", cpus > 1);\n\n      // Use at least 2 threads, to ensure concurrency, but use no more than 4 threads to avoid\n      // producing excessive system load\n      final int threadCount = Math.max(2, Math.min(4, cpus / 2));\n      System.err.println(\"Starting test lotOfProcesses() with \" + threadCount + \" threads\");\n\n      // Start threadCount threads, each running several synchronous processes in a row. This parallel\n      // execution is intended to verify synchronous pumping on concurrent threads doesn't produce any\n      // unexpected interactions \"between\" the threads\n      final Thread[] threads = new Thread[threadCount];\n      final AssertionError[] failures = new AssertionError[threadCount];\n      for (int i = 0; i < threadCount; i++) {\n         final int threadId = i + 1;\n         Thread thread = new Thread(\"RunTest-lotOfProcesses-\" + threadId) {\n            @Override\n            public void run()\n            {\n               for (int times = 0; times < 20; times++) {\n                  System.err.printf(\"Thread %d: Iteration %d\\n\", threadId, times + 1);\n\n                  LottaProcessListener listener = new LottaProcessListener();\n                  NuProcessBuilder pb = new NuProcessBuilder(listener, command);\n                  pb.run();\n\n                  try {\n                     Assert.assertTrue(\"Adler32 mismatch between written and read\", listener.checkAdlers());\n                     Assert.assertEquals(\"Exit code mismatch\", 0, listener.getExitCode());\n                  } catch (AssertionError e) {\n                     failures[threadId - 1] = e;\n                     break;\n                  }\n               }\n            }\n         };\n         thread.setDaemon(true);\n         thread.start();\n\n         threads[i] = thread;\n      }\n\n      // After all the threads are started, wait for each to finish and then check to see whether it\n      // inserted an AssertionError into the failures array\n      int failed = 0;\n      for (int i = 0; i < threadCount; i++) {\n         threads[i].join();\n         if (failures[i] != null) {\n            System.err.printf(\"Thread %d failed: %s\", threadCount + 1, failures[i].getMessage());\n            ++failed;\n         }\n      }\n\n      // If any threads failed, the test failed\n      if (failed > 0) {\n         Assert.fail(failed + \" thread(s) failed\");\n      }\n\n      System.err.println(\"Completed test lotOfProcesses()\");\n   }\n\n   @Test\n   public void lotOfData()\n   {\n      System.err.println(\"Starting test lotOfData()\");\n      for (int i = 0; i < 100; i++) {\n         LottaProcessListener processListener = new LottaProcessListener();\n         NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n         pb.run();\n\n         Assert.assertTrue(\"Adler32 mismatch between written and read\", processListener.checkAdlers());\n      }\n\n      System.err.println(\"Completed test lotOfData()\");\n   }\n\n   @Test\n   public void decodingShortUtf8Data()\n   {\n      String SHORT_UNICODE_TEXT = \"Hello \\uD83D\\uDCA9 world\";\n      System.err.println(\"Starting test decodingShortUtf8Data()\");\n      Utf8DecodingListener processListener = new Utf8DecodingListener(SHORT_UNICODE_TEXT, true);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n      pb.run();\n      Assert.assertEquals(\"Decoding mismatch\", SHORT_UNICODE_TEXT, processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      Assert.assertFalse(\"Decoder stdin should not overflow\", processListener.stdinOverflow);\n      System.err.println(\"Completed test decodingShortUtf8Data()\");\n   }\n\n   @Test\n   public void decodingLongUtf8Data()\n   {\n      // We use 3 bytes to make sure at least one UTF-8 boundary goes across two byte buffers.\n      String THREE_BYTE_UTF_8 = \"\\u2764\";\n      StringBuilder unicodeTextWhichDoesNotFitInBuffer = new StringBuilder();\n      for (int i = 0; i < NuProcess.BUFFER_CAPACITY + 1; i++) {\n         unicodeTextWhichDoesNotFitInBuffer.append(THREE_BYTE_UTF_8);\n      }\n      System.err.println(\"Starting test decodingLongUtf8Data()\");\n      Utf8DecodingListener processListener = new Utf8DecodingListener(unicodeTextWhichDoesNotFitInBuffer.toString(), true);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n      pb.run();\n      Assert.assertEquals(\"Decoding mismatch\", unicodeTextWhichDoesNotFitInBuffer.toString(), processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      Assert.assertTrue(\"Decoder stdin should overflow\", processListener.stdinOverflow);\n      System.err.println(\"Completed test decodingLongUtf8Data()\");\n   }\n\n   @Test\n   public void badExit() throws InterruptedException\n   {\n      System.err.println(\"Starting test badExit()\");\n\n      final AtomicInteger asyncExitCode = new AtomicInteger();\n      final CountDownLatch exitLatch = new CountDownLatch(1);\n\n      NuProcessHandler processListener = new NuAbstractProcessHandler() {\n         @Override\n         public void onExit(int statusCode)\n         {\n            asyncExitCode.set(statusCode);\n            exitLatch.countDown();\n         }\n      };\n\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command, \"/tmp/sdfadsf\");\n      NuProcess nuProcess = pb.start();\n      int syncExitCode = nuProcess.waitFor(5, TimeUnit.SECONDS);\n      boolean countedDown = exitLatch.await(5, TimeUnit.SECONDS);\n      Assert.assertTrue(\"Async exit latch was not triggered\", countedDown);\n\n      int expectedExitCode = System.getProperty(\"os.name\").toLowerCase().contains(\"win\") ? -1 : 1;\n      Assert.assertEquals(\"Exit code (synchronous) did not match expectation\", expectedExitCode, syncExitCode);\n      Assert.assertEquals(\"Exit code (asynchronous) did not match expectation\", expectedExitCode, asyncExitCode.get());\n\n      System.err.println(\"Completed test badExit()\");\n   }\n\n   @Test\n   public void noExecutableFound()\n   {\n      System.err.println(\"Starting test noExecutableFound()\");\n\n      final Semaphore semaphore = new Semaphore(0);\n      final AtomicInteger exitCode = new AtomicInteger();\n\n      NuProcessHandler processListener = new NuAbstractProcessHandler() {\n         @Override\n         public void onExit(int statusCode)\n         {\n            exitCode.set(statusCode);\n            semaphore.release();\n         }\n      };\n\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, \"/bin/zxczxc\");\n      NuProcess process = pb.start();\n      semaphore.acquireUninterruptibly();\n      Assert.assertFalse(\"Process incorrectly reported running\", process.isRunning());\n      Assert.assertEquals(\"Output did not matched expected result\", Integer.MIN_VALUE, exitCode.get());\n\n      System.err.println(\"Completed test noExecutableFound()\");\n   }\n\n   @Test\n   public void callbackOrder() throws InterruptedException\n   {\n      final List<String> callbacks = new CopyOnWriteArrayList<>();\n      final CountDownLatch latch = new CountDownLatch(1);\n\n      NuProcessHandler handler = new NuProcessHandler() {\n         private NuProcess nuProcess;\n\n         @Override\n         public void onStdout(ByteBuffer buffer, boolean closed)\n         {\n            callbacks.add(\"stdout\");\n            nuProcess.closeStdin(true);\n         }\n\n         @Override\n         public boolean onStdinReady(ByteBuffer buffer)\n         {\n            callbacks.add(\"stdin\");\n            buffer.put(\"foobar\".getBytes()).flip();\n            return false;\n         }\n\n         @Override\n         public void onStderr(ByteBuffer buffer, boolean closed)\n         {\n            callbacks.add(\"stderr\");\n         }\n\n         @Override\n         public void onStart(NuProcess nuProcess)\n         {\n            callbacks.add(\"start\");\n            this.nuProcess = nuProcess;\n            nuProcess.wantWrite();\n         }\n\n         @Override\n         public void onPreStart(NuProcess nuProcess)\n         {\n            callbacks.add(\"prestart\");\n         }\n\n         @Override\n         public void onExit(int exitCode)\n         {\n            callbacks.add(\"exit\");\n            latch.countDown();\n         }\n      };\n\n      Assert.assertNotNull(\"process is null\", new NuProcessBuilder(handler, command).start());\n      latch.await();\n\n      Assert.assertEquals(\"onPreStart was not called first\", 0, callbacks.indexOf(\"prestart\"));\n      Assert.assertFalse(\"onExit was called before onStdout\", callbacks.indexOf(\"exit\") < callbacks.lastIndexOf(\"stdout\"));\n   }\n\n   @Test\n   public void changeCwd() throws IOException\n   {\n      Path javaCwd = Paths.get(System.getProperty(\"user.dir\"));\n      Path tmpPath = tmp.getRoot().toPath();\n      System.err.println(\"Starting test changeCwd() (java cwd=\" + javaCwd + \", tmp=\" + tmpPath + \")\");\n      Assert.assertNotEquals(\"java cwd should not be tmp path before process\", javaCwd.toRealPath(), tmpPath.toRealPath());\n      String message = \"Hello cwd-aware world\\n\";\n      Files.write(tmpPath.resolve(\"foo.txt\"), message.getBytes(StandardCharsets.UTF_8));\n      Utf8DecodingListener processListener = new Utf8DecodingListener(\"\", true);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command, \"foo.txt\");\n      pb.setCwd(tmpPath);\n      pb.run();\n      Assert.assertEquals(\"Output mismatch\", message, processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      javaCwd = Paths.get(System.getProperty(\"user.dir\"));\n      Assert.assertNotEquals(\"java cwd should not be tmp path after process\", javaCwd.toRealPath(), tmpPath.toRealPath());\n      System.err.println(\"Completed test changeCwd()\");\n   }\n\n   @Test\n   public void softCloseStdinAfterWrite()\n   {\n      String text = \"Hello world!\";\n      System.err.println(\"Starting test softCloseStdinAfterWrite()\");\n      Utf8DecodingListener processListener = new Utf8DecodingListener(text, false);\n      NuProcessBuilder pb = new NuProcessBuilder(processListener, command);\n      pb.run();\n      Assert.assertEquals(\"Decoding mismatch\", text, processListener.decodedStdout.toString());\n      Assert.assertEquals(\"Exit code mismatch\", 0, processListener.exitCode);\n      Assert.assertFalse(\"Decoder stdin should not overflow\", processListener.stdinOverflow);\n      System.err.println(\"Completed test softCloseStdinAfterWrite()\");\n   }\n\n   @Test(expected = IllegalArgumentException.class)\n   public void nullCommandViaCommandMutationWithRun() {\n      NuProcessBuilder pb = new NuProcessBuilder(new NullProcessHandler(), command);\n      pb.command().add(\"--foo\\0--bar\");\n      pb.run();\n   }\n\n   @Test(expected = IllegalArgumentException.class)\n   public void nullCommandViaCommandMutationWithStart() {\n      NuProcessBuilder pb = new NuProcessBuilder(new NullProcessHandler(), command);\n      pb.command().add(\"--foo\\0--bar\");\n      pb.start();\n   }\n\n   @Test(expected = IllegalArgumentException.class)\n   public void nullCommandViaConstructorWithRun() {\n      NuProcessBuilder pb = new NuProcessBuilder(new NullProcessHandler(), command, \"--foo\\0--bar\");\n      pb.run();\n   }\n\n   @Test(expected = IllegalArgumentException.class)\n   public void nullCommandViaConstructorWithStart() {\n      NuProcessBuilder pb = new NuProcessBuilder(new NullProcessHandler(), command, \"--foo\\0--bar\");\n      pb.start();\n   }\n\n   private static byte[] getLotsOfBytes()\n   {\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < 6000; i++) {\n         sb.append(\"1234567890\");\n      }\n\n      return sb.toString().getBytes();\n   }\n\n   private static class LottaProcessListener extends NuAbstractProcessHandler\n   {\n      private static final int WRITES = 10;\n      private NuProcess nuProcess;\n      private int writes;\n      private int size;\n      private int exitCode;\n\n      private Adler32 readAdler32;\n      private Adler32 writeAdler32;\n      private byte[] bytes;\n\n      LottaProcessListener()\n      {\n         this.readAdler32 = new Adler32();\n         this.writeAdler32 = new Adler32();\n\n         bytes = getLotsOfBytes();\n         exitCode = -1;\n      }\n\n      @Override\n      public void onStart(NuProcess nuProcess)\n      {\n         this.nuProcess = nuProcess;\n         nuProcess.wantWrite();\n      }\n\n      @Override\n      public void onExit(int statusCode)\n      {\n         exitCode = statusCode;\n      }\n\n      @Override\n      public void onStdout(ByteBuffer buffer, boolean closed)\n      {\n         size += buffer.remaining();\n         if (size == (WRITES * bytes.length)) {\n            nuProcess.closeStdin(true);\n         }\n\n         byte[] bytes = new byte[buffer.remaining()];\n         buffer.get(bytes);\n         readAdler32.update(bytes);\n      }\n\n      @Override\n      public boolean onStdinReady(ByteBuffer buffer)\n      {\n         writeAdler32.update(bytes);\n\n         buffer.put(bytes);\n         buffer.flip();\n\n         return (++writes < WRITES);\n      }\n\n      int getExitCode()\n      {\n         return exitCode;\n      }\n\n      boolean checkAdlers()\n      {\n         return writes == WRITES && readAdler32.getValue() == writeAdler32.getValue();\n      }\n   }\n\n   private static class NullProcessHandler extends NuAbstractProcessHandler {\n   }\n\n   private static class Utf8DecodingListener extends NuAbstractCharsetHandler\n   {\n      private final CharBuffer utf8Buffer;\n      private final boolean forceCloseStdin;\n      private int charsWritten;\n      private int charsRead;\n      private NuProcess nuProcess;\n      StringBuilder decodedStdout;\n      boolean stdinOverflow;\n      int exitCode;\n\n      Utf8DecodingListener(String utf8Text, boolean forceCloseStdin)\n      {\n         super(StandardCharsets.UTF_8);\n         this.utf8Buffer = CharBuffer.wrap(utf8Text);\n         this.forceCloseStdin = forceCloseStdin;\n         this.charsWritten = 0;\n         this.charsRead = 0;\n         this.decodedStdout = new StringBuilder();\n         this.stdinOverflow = false;\n         this.exitCode = -1;\n      }\n\n      @Override\n      public void onStart(NuProcess nuProcess)\n      {\n         this.nuProcess = nuProcess;\n         nuProcess.wantWrite();\n      }\n\n      @Override\n      public void onExit(int statusCode)\n      {\n         exitCode = statusCode;\n      }\n\n      @Override\n      public void onStdoutChars(CharBuffer buffer, boolean closed, CoderResult coderResult)\n      {\n         charsRead += buffer.remaining();\n         decodedStdout.append(buffer);\n         buffer.position(buffer.limit());\n\n         if (forceCloseStdin && charsRead == charsWritten) {\n            nuProcess.closeStdin(true);\n         }\n      }\n\n      @Override\n      public boolean onStdinCharsReady(CharBuffer buffer)\n      {\n         if (utf8Buffer.remaining() <= buffer.remaining()) {\n            charsWritten += utf8Buffer.remaining();\n            buffer.put(utf8Buffer);\n            buffer.flip();\n            if (!forceCloseStdin) {\n               nuProcess.closeStdin(false);\n            }\n            return false;\n         }\n         else {\n            charsWritten += buffer.remaining();\n            buffer.put(utf8Buffer.subSequence(0, buffer.remaining()));\n            buffer.flip();\n            utf8Buffer.position(utf8Buffer.position() + buffer.remaining());\n            stdinOverflow = true;\n            return true;\n         }\n      }\n   }\n}\n"], "filenames": ["src/main/java/com/zaxxer/nuprocess/NuProcessBuilder.java", "src/test/java/com/zaxxer/nuprocess/RunTest.java"], "buggy_code_start_loc": [255, 318], "buggy_code_end_loc": [279, 395], "fixing_code_start_loc": [256, 319], "fixing_code_end_loc": [290, 425], "type": "CWE-77", "message": "NuProcess is an external process execution implementation for Java. In all the versions of NuProcess where it forks processes by using the JVM's Java_java_lang_UNIXProcess_forkAndExec method (1.2.0+), attackers can use NUL characters in their strings to perform command line injection. Java's ProcessBuilder isn't vulnerable because of a check in ProcessBuilder.start. NuProcess is missing that check. This vulnerability can only be exploited to inject command line arguments on Linux. Version 2.0.5 contains a patch. As a workaround, users of the library can sanitize command strings to remove NUL characters prior to passing them to NuProcess for execution.", "other": {"cve": {"id": "CVE-2022-39243", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-26T14:15:10.407", "lastModified": "2022-09-28T13:21:42.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NuProcess is an external process execution implementation for Java. In all the versions of NuProcess where it forks processes by using the JVM's Java_java_lang_UNIXProcess_forkAndExec method (1.2.0+), attackers can use NUL characters in their strings to perform command line injection. Java's ProcessBuilder isn't vulnerable because of a check in ProcessBuilder.start. NuProcess is missing that check. This vulnerability can only be exploited to inject command line arguments on Linux. Version 2.0.5 contains a patch. As a workaround, users of the library can sanitize command strings to remove NUL characters prior to passing them to NuProcess for execution."}, {"lang": "es", "value": "NuProcess es una implementaci\u00f3n de ejecuci\u00f3n de procesos externos para Java. En todas las versiones de NuProcess en las que bifurca procesos usando el m\u00e9todo Java_java_lang_UNIXProcess_forkAndExec de la JVM (1.2.0+), los atacantes pueden usar caracteres NUL en sus cadenas para llevar a cabo una inyecci\u00f3n en la l\u00ednea de comandos. El ProcessBuilder de Java no es vulnerable debido a una comprobaci\u00f3n en ProcessBuilder.start. NuProcess carece de esa comprobaci\u00f3n. Esta vulnerabilidad s\u00f3lo puede ser explotada para inyectar argumentos de l\u00ednea de comandos en Linux. La versi\u00f3n 2.0.5 contiene un parche. Como mitigaci\u00f3n, los usuarios de la biblioteca pueden sanear las cadenas de comandos para eliminar los caracteres NUL antes de pasarlas a NuProcess para su ejecuci\u00f3n.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nuprocess_project:nuprocess:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.2.0", "versionEndExcluding": "2.0.5", "matchCriteriaId": "7A3FB441-B053-438A-92B0-70FEDFA4A66E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "https://github.com/brettwooldridge/NuProcess/commit/29bc09de561bf00ff9bf77123756363a9709f868", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/brettwooldridge/NuProcess/pull/143", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/brettwooldridge/NuProcess/security/advisories/GHSA-cxgf-v2p8-7ph7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/brettwooldridge/NuProcess/commit/29bc09de561bf00ff9bf77123756363a9709f868"}}