{"buggy_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n  include NotificationsHelper\n  before_action :set_notification, only: [:destroy]\n\n  # DELETE /notifications/1\n  # DELETE /notifications/1.json\n  def destroy\n    @notification.destroy if @notification.present?\n\n    respond_to do |format|\n      format.html { redirect_back(fallback_location: notifications_path) }\n      format.json { head :no_content }\n    end\n  end\n\n  def clear\n    Notification.where(user_id: current_user.id).destroy_all\n    head :ok\n  end\n\n  def fetch_notifications\n    result = Notification.where(user_id: current_user.id)\n                         .order(:created_at)\n    response = {\n      fetch_notifications: result.map { |item| render_notification(item) }\n    }\n    render json: response\n  end\n\n  def signed_in\n    render json: { signed_in: current_user.id }\n  end\n\n  private\n\n  def convert_to_hash(string_obj)\n    hash = {}\n    JSON.parse(string_obj).each do |item|\n      hash[item.first.to_sym] = item.second\n    end\n    hash\n  end\n\n  def render_notification(notification)\n    uniqueid = notification[:uniqueid]\n    data = convert_to_hash(notification[:data])\n    # In case data[:name] is invalid\n    data[:email] = User.find(data[:user_id]).email\n    case data[:type]\n    when /comment/ then comment_link(uniqueid, data)\n    when /accepted_ally_request/ then accepted_ally_link(uniqueid, data)\n    when /new_ally_request/ then new_ally_request_link(uniqueid, data)\n    when /group/ then group_link(uniqueid, data)\n    when /meeting/ then meeting_link(uniqueid, data)\n    end\n  end\n\n  # Use callbacks to share common setup or constraints between actions.\n  def set_notification\n    @notification = Notification.find_by(\n      id: params[:id],\n      user_id: current_user.id\n    )\n  end\nend\n", "# frozen_string_literal: true\n\nmodule CommentsHelper\n  def generate_comments(comments)\n    result_comments = []\n    comments.each do |comment|\n      next unless CommentViewersService.viewable?(comment, current_user)\n\n      user = User.find(comment.comment_by)\n      result_comments.push(comment_hash(comment, user))\n    end\n    result_comments\n  end\n\n  def show_with_comments(subject)\n    model_name = subject.class.name.downcase\n    if current_user.id != subject.user_id && hide_page?(subject)\n      return redirect_to_path(send(\"#{model_name.pluralize}_path\"))\n    end\n\n    @page_author = page_author(subject)\n    return unless subject.comments\n\n    @comments = generate_comments(subject.comments.order(created_at: :desc))\n  end\n\n  private\n\n  def hide_page?(subject)\n    (!current_user.mutual_allies?(subject.user) \\\n    && !subject.viewer?(current_user)) \\\n    || !subject.published?\n  end\n\n  def created_at(value)\n    t('created', created_at: TimeAgo.formatted_ago(value))\n  end\n\n  def comment_hash(comment, user)\n    {\n      currentUserUid: current_user.uid,\n      commentByUid: user.uid,\n      commentByName: user.name,\n      commentByAvatar: user.avatar.url,\n      comment: sanitize(comment.comment),\n      viewers: CommentViewersService.viewers(comment, current_user),\n      createdAt: created_at(comment.created_at),\n      deleteAction: delete_action(comment)\n    }.merge(id: comment.id)\n  end\n\n  def page_author(subject)\n    return User.find(current_user.id) unless current_user.id != subject.user_id\n\n    User.find(subject.user_id)\n  end\n\n  def delete_action(comment)\n    return unless CommentViewersService.deletable?(comment, current_user)\n\n    delete_comments_path(comment_id: comment.id)\n  end\nend\n", "<% title t('allies.index.title') %>\n<%= render partial: '/search/form' %>\n<%= link_to t('allies.index.invite'), new_user_invitation_path, class: 'smallMarginTop buttonM fullWidth center' %>\n\n<% if @outgoing_ally_requests.any? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.outgoing') %></div>\n    <div class=\"gridThree\">\n    <% @outgoing_ally_requests.each do |ally| %>\n      <div class=\"gridThreeItemBoxLight ally\">\n        <%= link_to ProfilePicture.fetch(ally.avatar.url, name: ally.name), profile_index_path(uid: ally.uid) %>\n        <div class=\"subtle\"><%= ally.location %></div>\n        <%= link_to t('allies.index.cancel'), remove_allies_path(ally_id: ally.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n      </div>\n    <% end %>\n    </div>\n  </div>\n<% end %>\n\n<% if @incoming_ally_requests.any? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.incoming') %></div>\n    <div class=\"gridThree\">\n    <% @incoming_ally_requests.each do |ally| %>\n      <div class=\"gridThreeItemBoxLight ally\">\n        <%= link_to ProfilePicture.fetch(ally.avatar.url, name: ally.name), profile_index_path(uid: ally.uid) %>\n        <div class=\"subtle\"><%= ally.location %></div>\n        <%= link_to t('allies.accept'), add_allies_path(ally_id: ally.id), method: :post %> | <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: ally.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n      </div>\n    <% end %>\n    </div>\n  </div>\n<% end %>\n<% if @invited_allies.any? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.invited') %></div>\n    <div class=\"gridThree\">\n    <% @invited_allies.each do |ally| %>\n      <div class=\"gridThreeItemBoxLight ally\">\n        <div><%= mail_to \"#{ally.email}\" %></div>\n        <div class=\"subtle\"><%=t('allies.index.invited_on', date: format_date(ally.invitation_sent_at)) %></div>\n        <div class=\"subtle\"><%= ally.invitation_sent_at < 2.weeks.ago ? t('allies.index.invitation_expired') : nil %></div>\n      </div>\n    <% end %>\n    </div>\n  </div>\n<% end %>\n<% if @accepted_allies.present? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.title') %></div>\n    <div class=\"gridThree\">\n      <% @accepted_allies.each do |ally| %>\n        <div class=\"gridThreeItemBoxLight ally\">\n          <%= link_to ProfilePicture.fetch(ally.avatar.url, name: ally.name), profile_index_path(uid: ally.uid) %>\n          <div class=\"subtle\"><%= ally.location %></div>\n          <div>\n            <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: ally.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n          </div>\n          <div>\n            <%= link_to t('common.actions.report'), new_report_path(uid: ally.uid) %>\n          </div>\n        </div>\n      <% end %>\n    </div>\n  </div>\n<% end %>\n\n<% if @outgoing_ally_requests.empty? && @incoming_ally_requests.empty? && @accepted_allies.count == 0 %>\n  <div class=\"marginTop\">\n    <%= t('allies.index.none') %>\n  </div>\n<% end %>\n", "<% title @profile.name %>\n<div class=\"profile\">\n  <%= ProfilePicture.fetch(@profile.avatar.url) %>\n  <div class=\"profileInfo\">\n    <% if @profile.about %>\n      <div>\n      <%= sanitize(@profile.about) %>\n      </div>\n    <% end %>\n    <% if @profile == current_user %>\n      <div>\n        <%= link_to t('profile.index.edit_user'), edit_user_registration_path %>\n      </div>\n    <% end %>\n    <% if @profile.location.present? %>\n      <div>\n        <i class=\"fa fa-location-arrow fa-inline smallMarginRight\"></i><%= @profile.location %>\n      </div>\n    <% end %>\n    <% if @profile.id != current_user.id %>\n      <% if current_user.allies_by_status(:pending_from_ally).include? @profile %>\n        <div>\n          <%= link_to t('allies.cancel_ally_request'), remove_allies_path(ally_id: @profile.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n        </div>\n      <% elsif current_user.allies_by_status(:accepted).include? @profile %>\n        <div>\n          <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: @profile.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n        </div>\n        <div>\n          <%= link_to t('common.actions.report'), new_report_path(uid: @profile.uid) %>\n        </div>\n      <% elsif current_user.allies_by_status(:pending_from_user).include? @profile %>\n        <div>\n          <%= link_to t('allies.accept'), add_allies_path(ally_id: @profile.id), method: :post %> | <%= link_to t('allies.reject'), remove_allies_path(ally_id: @profile.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n        </div>\n      <% else %>\n        <div>\n          <%= link_to t('allies.add_ally'), add_allies_path(ally_id: @profile.id), method: :post %>\n        </div>\n      <% end %>\n    <% end %>\n    <% if current_user.admin? %>\n      <% if @profile.banned? %>\n        <div>\n          <%= link_to t('reports.remove_ban'), remove_ban_profile_index_path(user_id: @profile.id), method: :post %>\n        </div>\n      <% else %>\n        <div>\n          <%= link_to t('reports.ban_user'), add_ban_profile_index_path(user_id: @profile.id), method: :post %>\n        </div>\n      <% end %>\n    <% end %>\n  </div>\n</div>\n\n<% if !@stories.nil? && @stories.any? %>\n  <div class=\"marginTop\">\n    <%= render partial: '/shared/stats', locals: { data_type: 'categories', user: @profile } %>\n    <%= render partial: '/shared/stats', locals: { data_type: 'moods', user: @profile } %>\n    <%= render partial: '/shared/stats', locals: { data_type: 'strategies', user: @profile } %>\n  </div>\n  <div class=\"title\">\n    <%= t('pages.home.stories') %>\n  </div>\n  <%= react_component('BaseContainer', props: {\n    container: 'StoryContainer',\n    data: moments_or_strategy_props(@stories),\n    fetchUrl: data_profile_index_path(uid: params[:uid]),\n    lastPage: @stories.last_page?,\n  }) %>\n<% end %>\n", "<% title t('search.index.title') %>\n<%= render 'form' %>\n<%= link_to t('allies.index.view_all_allies'), allies_path, class: 'smallMarginTop buttonM fullWidth center' %>\n<div class=\"gridThree marginTop\">\n  <% if @matching_users.present? %>\n    <% @matching_users.each do |user| %>\n        <div class=\"gridThreeItemBoxLight ally\">\n          <%= link_to ProfilePicture.fetch(user.avatar.url, name: user.name), profile_index_path(uid: user.uid) %>\n          <div class=\"subtle\"><%= user.location %></div>\n          <% if current_user.allies_by_status(:pending_from_ally).include?(user) %>\n            <%= link_to t('allies.cancel_ally_request'), remove_allies_path(ally_id: user.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n          <% elsif current_user.allies_by_status(:pending_from_user).include?(user) %>\n            <%= link_to t('allies.accept'), add_allies_path(ally_id: user.id), method: :post %>\n          <% elsif current_user.allies_by_status(:accepted).include?(user) %>\n            <div>\n              <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: user.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n            </div>\n            <div>\n              <%= link_to t('common.actions.report'), new_report_path(uid: user.uid) %>\n            </div>\n          <% else %>\n            <%= link_to t('allies.add_ally'), add_allies_path(ally_id: user.id), method: :post %>\n          <% end %>\n        </div>\n    <% end %>\n  <% else %>\n    <%= t('search.index.user_not_found', email: @email_query) %>\n  <% end %>\n</div>\n", "// @flow\nimport React from 'react';\nimport axios from 'axios';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Comments from 'widgets/Comments';\n\nconst formProps = {\n  inputs: [\n    {\n      id: 'comment_commentable_type',\n      name: 'comment[commentable_type]',\n      type: 'hidden',\n      value: 'moment',\n    },\n    {\n      id: 'comment_comment_by',\n      name: 'comment[comment_by]',\n      type: 'hidden',\n      value: 1,\n    },\n    {\n      id: 'comment_commentable_id',\n      name: 'comment[commentable_id]',\n      type: 'hidden',\n      value: 19,\n    },\n    {\n      id: 'comment_comment',\n      name: 'comment[comment]',\n      type: 'textarea',\n      dark: true,\n    },\n    {\n      options: [\n        {\n          id: 'comment_visibility_all',\n          label: 'Share with everyone',\n          value: 'all',\n        },\n        {\n          id: 'comment_visibility_private',\n          label: 'Share with Testy 2 only',\n          value: 'private',\n        },\n      ],\n      id: 'comment_visibility',\n      name: 'comment[visibility]',\n      type: 'select',\n      value: 'all',\n      dark: true,\n    },\n    {\n      id: 'submit',\n      type: 'submit',\n      value: 'Submit',\n      dark: true,\n    },\n  ],\n  action: '/comments/create',\n};\n\nconst value = 'Hey';\n\nconst id = 1;\n\nconst comment = {\n  comment: value,\n  currentUserId: 'some-uid',\n  commentByAvatar: null,\n  commentByName: 'Kind Human',\n  commentByUid: 'uid',\n  createdAt: 'Created less than a minute ago',\n  deleteAction: '/comments/delete?comment_id=1',\n  id,\n  viewers: 'Visible only between you and Lane Kim',\n};\n\nconst component = <Comments formProps={formProps} />;\n\ndescribe('Comments', () => {\n  beforeEach(() => {\n    jest.spyOn(axios, 'post').mockResolvedValue({\n      data: { comment },\n    });\n    jest.spyOn(axios, 'delete').mockResolvedValue({\n      data: { id },\n    });\n  });\n\n  it('renders correctly', () => {\n    render(component);\n    expect(screen.getByRole('textbox')).toBeInTheDocument();\n    expect(screen.queryByRole('article')).not.toBeInTheDocument();\n    expect(screen.getByRole('button', { name: 'Submit' })).toBeInTheDocument();\n  });\n\n  it('add and delete a comment', async () => {\n    render(component);\n    expect(screen.queryByRole('article')).not.toBeInTheDocument();\n\n    userEvent.type(screen.getByRole('textbox'));\n    userEvent.selectOptions(screen.getByRole('combobox'), 'private');\n    userEvent.click(screen.getByRole('button', { name: 'Submit' }));\n\n    await waitFor(() => expect(screen.getByRole('article')).toBeInTheDocument());\n    expect(screen.getByRole('article')).toHaveTextContent('Hey');\n\n    userEvent.click(screen.getByRole('link', { name: 'Delete' }));\n\n    await waitFor(() => expect(screen.queryByRole('article')).not.toBeInTheDocument());\n  });\n});\n", "// @flow\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport renderHTML from 'react-render-html';\nimport { I18n } from 'libs/i18n';\nimport { StoryBy } from 'components/Story/StoryBy';\nimport { StoryDate } from 'components/Story/StoryDate';\nimport { StoryActions } from 'components/Story/StoryActions';\nimport DynamicForm from 'components/Form/DynamicForm';\nimport { Utils } from 'utils';\nimport type { FormProps } from 'components/Form/utils';\nimport css from './Comments.scss';\n\ntype CommentResponse = {\n  data: {\n    comment: string,\n    id: string,\n  },\n};\n\ntype Comment = {\n  id: number,\n  currentUserUid: string,\n  commentByUid: string,\n  commentByName: string,\n  commentByAvatar?: string,\n  comment: any,\n  viewers?: string,\n  createdAt: string,\n  deleteAction?: string,\n};\n\nexport type Props = {\n  comments?: Comment[],\n  formProps: FormProps,\n};\n\nexport const Comments = ({ comments, formProps }: Props) => {\n  const [commentsState, setCommentsState] = useState<(Comment | any)[]>(\n    comments || []);\n  const [key, setKey] = useState<string>('');\n\n  const onDeleteClick = (\n    e: SyntheticEvent<HTMLInputElement>,\n    action: string,\n  ) => {\n    e.preventDefault();\n    Utils.setCsrfToken();\n    axios.delete(action).then((response: CommentResponse) => {\n      const { data } = response;\n      if (data && data.id) {\n        const newComments = commentsState.filter(\n          (comment: Comment) => comment.id !== parseInt(data.id, 10),\n        );\n        setCommentsState(newComments);\n      }\n    });\n  };\n\n  const reportAction = (uid: string, id: number) => ({\n    name: I18n.t('common.actions.report'),\n    link: `/reports/new?uid=${uid}&comment_id=${id}`,\n  });\n\n  const getActions = (\n    viewers: ?string,\n    deleteAction: ?string,\n    currentUserUid: string,\n    uid: string,\n    id: number,\n  ) => {\n    const actions = {};\n    if (currentUserUid !== uid) {\n      actions.report = reportAction(uid, id);\n    }\n    if (viewers) {\n      actions.viewers = viewers;\n    }\n    if (deleteAction) {\n      actions.delete = {\n        name: I18n.t('common.actions.delete'),\n        link: deleteAction,\n        dataConfirm: I18n.t('common.actions.confirm'),\n        onClick: onDeleteClick,\n      };\n    }\n    return actions;\n  };\n\n  const displayComment = (myComment: Comment) => {\n    const {\n      id,\n      currentUserUid,\n      commentByUid,\n      commentByName,\n      commentByAvatar,\n      comment,\n      viewers,\n      createdAt,\n      deleteAction,\n    } = myComment;\n    const author = <a href={`/profile?uid=${commentByUid}`}>{commentByName}</a>;\n    return (\n      <article key={id} className={`comment ${css.comment}`}>\n        <div className={css.commentContent}>{renderHTML(comment)}</div>\n        <StoryDate date={createdAt} />\n        <div className={css.commentInfo}>\n          <StoryBy avatar={commentByAvatar} author={author} />\n          <StoryActions\n            actions={getActions(\n              viewers,\n              deleteAction,\n              currentUserUid,\n              commentByUid,\n              id,\n            )}\n            hasStory\n          />\n        </div>\n      </article>\n    );\n  };\n\n  const onSubmit = (response: CommentResponse) => {\n    const { data } = response;\n    if (data && data.comment) {\n      setCommentsState([data.comment].concat(commentsState));\n      setKey(Utils.randomString());\n    }\n  };\n\n  const displayComments = () => {\n    if (commentsState.length === 0) return null;\n    return (\n      <section className={css.comments} aria-label={I18n.t('comment.plural')}>\n        {commentsState.map((comment: Comment) => displayComment(comment))}\n      </section>\n    );\n  };\n\n  return (\n    <div id=\"comments\">\n      <DynamicForm formProps={formProps} onSubmit={onSubmit} key={key} />\n      {displayComments()}\n    </div>\n  );\n};\n\nexport default ({ comments, formProps }: Props) => (\n  <Comments comments={comments} formProps={formProps} />\n);\n", "# frozen_string_literal: true\ndescribe CommentsHelper, type: :controller do\n  let(:user1) { create(:user1) }\n  let(:user2) { create(:user2) }\n\n  controller(ApplicationController) do\n  end\n\n  describe '#generate_comments' do\n    let(:user3) { create(:user3) }\n    let(:comment) { 'Hello from the outside' }\n    let(:created_at) { 'Created less than a minute ago' }\n\n    before do\n      create(:allyships_accepted, user_id: user1.id, ally_id: user2.id)\n      create(:allyships_accepted, user_id: user1.id, ally_id: user3.id)\n    end\n\n    context 'Moments' do\n      let(:new_moment) { create(:moment, user_id: user1.id, viewers: [user2.id, user3.id]) }\n\n      context 'Comment posted by Moment creator who is logged in' do\n        before(:each) do\n          sign_in user1\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user1.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visbility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user1.id, visibility: 'private', viewers: [user2.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user2.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n\n      context 'Comment posted by Moment viewer who is logged in' do\n        before(:each) do\n          sign_in user2\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user2.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visibility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user2.id, visibility: 'private', viewers: [user1.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user1.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n    end\n\n    context 'Strategies' do\n      let(:new_strategy) { create(:strategy, user_id: user1.id, viewers: [user2.id, user3.id]) }\n\n      context 'Comment posted by Strategy creator who is logged in' do\n        before(:each) do\n          sign_in user1\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user1.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visibility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user1.id, visibility: 'private', viewers: [user2.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user2.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n\n      context 'Comment posted by Strategy viewer who is logged in' do\n        before(:each) do\n          sign_in user2\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user2.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visibility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user2.id, visibility: 'private', viewers: [user1.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user1.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n    end\n\n    context 'Meetings' do\n      let(:new_meeting) { create :meeting }\n\n      before do\n        create :meeting_member, user_id: user1.id, leader: true, meeting_id: new_meeting.id\n        create :meeting_member, user_id: user2.id, leader: false, meeting_id: new_meeting.id\n      end\n\n      context 'Comment posted by Meeting creator who is logged in' do\n        it 'generates a valid comment object' do\n          sign_in user1\n          new_comment = create(:comment, comment: comment, commentable_type: 'meeting', commentable_id: new_meeting.id, comment_by: user1.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n\n      context 'Comment posted by Meeting member who is logged in' do\n        it 'generates a valid comment object' do\n          sign_in user2\n          new_comment = create(:comment, comment: comment, commentable_type: 'meeting', commentable_id: new_meeting.id, comment_by: user2.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass NotificationsController < ApplicationController\n  include NotificationsHelper\n  before_action :set_notification, only: [:destroy]\n\n  # DELETE /notifications/1\n  # DELETE /notifications/1.json\n  def destroy\n    @notification.destroy if @notification.present?\n\n    respond_to do |format|\n      format.html { redirect_back(fallback_location: notifications_path) }\n      format.json { head :no_content }\n    end\n  end\n\n  def clear\n    Notification.where(user_id: current_user.id).destroy_all\n    head :ok\n  end\n\n  def fetch_notifications\n    result = Notification.where(user_id: current_user.id)\n                         .order(:created_at)\n    response = {\n      fetch_notifications: result.map { |item| render_notification(item) }\n    }\n    render json: response\n  end\n\n  def signed_in\n    render json: { signed_in: current_user.id }\n  end\n\n  private\n\n  def convert_to_hash(string_obj)\n    hash = {}\n    JSON.parse(string_obj).each do |item|\n      hash[item.first.to_sym] = item.second\n    end\n    hash\n  end\n\n  def render_notification(notification)\n    uniqueid = notification[:uniqueid]\n    data = convert_to_hash(notification[:data])\n    # In case data[:name] is invalid\n    if data[:user_id]\n      data[:email] = User.find(data[:user_id]).email\n    end\n    case data[:type]\n    when /comment/ then comment_link(uniqueid, data)\n    when /accepted_ally_request/ then accepted_ally_link(uniqueid, data)\n    when /new_ally_request/ then new_ally_request_link(uniqueid, data)\n    when /group/ then group_link(uniqueid, data)\n    when /meeting/ then meeting_link(uniqueid, data)\n    end\n  end\n\n  # Use callbacks to share common setup or constraints between actions.\n  def set_notification\n    @notification = Notification.find_by(\n      id: params[:id],\n      user_id: current_user.id\n    )\n  end\nend\n", "# frozen_string_literal: true\n\nmodule CommentsHelper\n  def generate_comments(comments)\n    result_comments = []\n    comments.each do |comment|\n      next unless CommentViewersService.viewable?(comment, current_user)\n\n      user = User.find(comment.comment_by)\n      result_comments.push(comment_hash(comment, user))\n    end\n    result_comments\n  end\n\n  def show_with_comments(subject)\n    model_name = subject.class.name.downcase\n    if current_user.id != subject.user_id && hide_page?(subject)\n      return redirect_to_path(send(\"#{model_name.pluralize}_path\"))\n    end\n\n    @page_author = page_author(subject)\n    return unless subject.comments\n\n    @comments = generate_comments(subject.comments.order(created_at: :desc))\n  end\n\n  private\n\n  def hide_page?(subject)\n    (!current_user.mutual_allies?(subject.user) \\\n    && !subject.viewer?(current_user)) \\\n    || !subject.published?\n  end\n\n  def created_at(value)\n    t('created', created_at: TimeAgo.formatted_ago(value))\n  end\n\n  def comment_hash(comment, user)\n    {\n      currentUserUid: current_user.uid,\n      commentByUid: user.uid,\n      commentByName: user.name,\n      commentByAvatar: user.avatar.url,\n      commentByAdmin: user.admin?,\n      comment: sanitize(comment.comment),\n      viewers: CommentViewersService.viewers(comment, current_user),\n      createdAt: created_at(comment.created_at),\n      deleteAction: delete_action(comment)\n    }.merge(id: comment.id)\n  end\n\n  def page_author(subject)\n    return User.find(current_user.id) unless current_user.id != subject.user_id\n\n    User.find(subject.user_id)\n  end\n\n  def delete_action(comment)\n    return unless CommentViewersService.deletable?(comment, current_user)\n\n    delete_comments_path(comment_id: comment.id)\n  end\nend\n", "<% title t('allies.index.title') %>\n<%= render partial: '/search/form' %>\n<%= link_to t('allies.index.invite'), new_user_invitation_path, class: 'smallMarginTop buttonM fullWidth center' %>\n\n<% if @outgoing_ally_requests.any? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.outgoing') %></div>\n    <div class=\"gridThree\">\n    <% @outgoing_ally_requests.each do |ally| %>\n      <div class=\"gridThreeItemBoxLight ally\">\n        <%= link_to ProfilePicture.fetch(ally.avatar.url, name: ally.name), profile_index_path(uid: ally.uid) %>\n        <div class=\"subtle\"><%= ally.location %></div>\n        <%= link_to t('allies.index.cancel'), remove_allies_path(ally_id: ally.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n      </div>\n    <% end %>\n    </div>\n  </div>\n<% end %>\n\n<% if @incoming_ally_requests.any? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.incoming') %></div>\n    <div class=\"gridThree\">\n    <% @incoming_ally_requests.each do |ally| %>\n      <div class=\"gridThreeItemBoxLight ally\">\n        <%= link_to ProfilePicture.fetch(ally.avatar.url, name: ally.name), profile_index_path(uid: ally.uid) %>\n        <div class=\"subtle\"><%= ally.location %></div>\n        <%= link_to t('allies.accept'), add_allies_path(ally_id: ally.id), method: :post %> | <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: ally.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n      </div>\n    <% end %>\n    </div>\n  </div>\n<% end %>\n<% if @invited_allies.any? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.invited') %></div>\n    <div class=\"gridThree\">\n    <% @invited_allies.each do |ally| %>\n      <div class=\"gridThreeItemBoxLight ally\">\n        <div><%= mail_to \"#{ally.email}\" %></div>\n        <div class=\"subtle\"><%=t('allies.index.invited_on', date: format_date(ally.invitation_sent_at)) %></div>\n        <div class=\"subtle\"><%= ally.invitation_sent_at < 2.weeks.ago ? t('allies.index.invitation_expired') : nil %></div>\n      </div>\n    <% end %>\n    </div>\n  </div>\n<% end %>\n<% if @accepted_allies.present? %>\n  <div class=\"marginTop\">\n    <div class=\"title\"><%= t('allies.index.title') %></div>\n    <div class=\"gridThree\">\n      <% @accepted_allies.each do |ally| %>\n        <div class=\"gridThreeItemBoxLight ally\">\n          <%= link_to ProfilePicture.fetch(ally.avatar.url, name: ally.name), profile_index_path(uid: ally.uid) %>\n          <div class=\"subtle\"><%= ally.location %></div>\n          <div>\n            <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: ally.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n          </div>\n          <% if !ally.admin? && ally != current_user %>\n            <div>\n              <%= link_to t('common.actions.report'), new_report_path(uid: ally.uid) %>\n            </div>\n          <% end %>\n        </div>\n      <% end %>\n    </div>\n  </div>\n<% end %>\n\n<% if @outgoing_ally_requests.empty? && @incoming_ally_requests.empty? && @accepted_allies.count == 0 %>\n  <div class=\"marginTop\">\n    <%= t('allies.index.none') %>\n  </div>\n<% end %>\n", "<% title @profile.name %>\n<div class=\"profile\">\n  <%= ProfilePicture.fetch(@profile.avatar.url) %>\n  <div class=\"profileInfo\">\n    <% if @profile.about %>\n      <div>\n      <%= sanitize(@profile.about) %>\n      </div>\n    <% end %>\n    <% if @profile == current_user %>\n      <div>\n        <%= link_to t('profile.index.edit_user'), edit_user_registration_path %>\n      </div>\n    <% end %>\n    <% if @profile.location.present? %>\n      <div>\n        <i class=\"fa fa-location-arrow fa-inline smallMarginRight\"></i><%= @profile.location %>\n      </div>\n    <% end %>\n    <% if @profile.id != current_user.id %>\n      <% if current_user.allies_by_status(:pending_from_ally).include? @profile %>\n        <div>\n          <%= link_to t('allies.cancel_ally_request'), remove_allies_path(ally_id: @profile.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n        </div>\n      <% elsif current_user.allies_by_status(:accepted).include? @profile %>\n        <div>\n          <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: @profile.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n        </div>\n        <% if !@profile.admin? && @profile != current_user %>\n          <div>\n            <%= link_to t('common.actions.report'), new_report_path(uid: @profile.uid) %>\n          </div>\n        <% end %>\n      <% elsif current_user.allies_by_status(:pending_from_user).include? @profile %>\n        <div>\n          <%= link_to t('allies.accept'), add_allies_path(ally_id: @profile.id), method: :post %> | <%= link_to t('allies.reject'), remove_allies_path(ally_id: @profile.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n        </div>\n      <% else %>\n        <div>\n          <%= link_to t('allies.add_ally'), add_allies_path(ally_id: @profile.id), method: :post %>\n        </div>\n      <% end %>\n    <% end %>\n    <% if @profile != current_user && current_user.admin? %>\n      <% if @profile.banned? %>\n        <div>\n          <%= link_to t('reports.remove_ban'), remove_ban_profile_index_path(user_id: @profile.id), method: :post %>\n        </div>\n      <% else %>\n        <div>\n          <%= link_to t('reports.ban_user'), add_ban_profile_index_path(user_id: @profile.id), method: :post %>\n        </div>\n      <% end %>\n    <% end %>\n  </div>\n</div>\n\n<% if !@stories.nil? && @stories.any? %>\n  <div class=\"marginTop\">\n    <%= render partial: '/shared/stats', locals: { data_type: 'categories', user: @profile } %>\n    <%= render partial: '/shared/stats', locals: { data_type: 'moods', user: @profile } %>\n    <%= render partial: '/shared/stats', locals: { data_type: 'strategies', user: @profile } %>\n  </div>\n  <div class=\"title\">\n    <%= t('pages.home.stories') %>\n  </div>\n  <%= react_component('BaseContainer', props: {\n    container: 'StoryContainer',\n    data: moments_or_strategy_props(@stories),\n    fetchUrl: data_profile_index_path(uid: params[:uid]),\n    lastPage: @stories.last_page?,\n  }) %>\n<% end %>\n", "<% title t('search.index.title') %>\n<%= render 'form' %>\n<%= link_to t('allies.index.view_all_allies'), allies_path, class: 'smallMarginTop buttonM fullWidth center' %>\n<div class=\"gridThree marginTop\">\n  <% if @matching_users.present? %>\n    <% @matching_users.each do |user| %>\n        <div class=\"gridThreeItemBoxLight ally\">\n          <%= link_to ProfilePicture.fetch(user.avatar.url, name: user.name), profile_index_path(uid: user.uid) %>\n          <div class=\"subtle\"><%= user.location %></div>\n          <% if current_user.allies_by_status(:pending_from_ally).include?(user) %>\n            <%= link_to t('allies.cancel_ally_request'), remove_allies_path(ally_id: user.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n          <% elsif current_user.allies_by_status(:pending_from_user).include?(user) %>\n            <%= link_to t('allies.accept'), add_allies_path(ally_id: user.id), method: :post %>\n          <% elsif current_user.allies_by_status(:accepted).include?(user) %>\n            <div>\n              <%= link_to t('common.actions.remove'), remove_allies_path(ally_id: user.id), method: :post, data: { confirm: t('common.actions.confirm') } %>\n            </div>\n            <% if !user.admin? && user != current_user %>\n              <div>\n                <%= link_to t('common.actions.report'), new_report_path(uid: user.uid) %>\n              </div>\n            <% end %>\n          <% else %>\n            <%= link_to t('allies.add_ally'), add_allies_path(ally_id: user.id), method: :post %>\n          <% end %>\n        </div>\n    <% end %>\n  <% else %>\n    <%= t('search.index.user_not_found', email: @email_query) %>\n  <% end %>\n</div>\n", "// @flow\nimport React from 'react';\nimport axios from 'axios';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Comments from 'widgets/Comments';\n\nconst formProps = {\n  inputs: [\n    {\n      id: 'comment_commentable_type',\n      name: 'comment[commentable_type]',\n      type: 'hidden',\n      value: 'moment',\n    },\n    {\n      id: 'comment_comment_by',\n      name: 'comment[comment_by]',\n      type: 'hidden',\n      value: 1,\n    },\n    {\n      id: 'comment_commentable_id',\n      name: 'comment[commentable_id]',\n      type: 'hidden',\n      value: 19,\n    },\n    {\n      id: 'comment_comment',\n      name: 'comment[comment]',\n      type: 'textarea',\n      dark: true,\n    },\n    {\n      options: [\n        {\n          id: 'comment_visibility_all',\n          label: 'Share with everyone',\n          value: 'all',\n        },\n        {\n          id: 'comment_visibility_private',\n          label: 'Share with Testy 2 only',\n          value: 'private',\n        },\n      ],\n      id: 'comment_visibility',\n      name: 'comment[visibility]',\n      type: 'select',\n      value: 'all',\n      dark: true,\n    },\n    {\n      id: 'submit',\n      type: 'submit',\n      value: 'Submit',\n      dark: true,\n    },\n  ],\n  action: '/comments/create',\n};\n\nconst value = 'Hey';\n\nconst id = 1;\n\nconst getComment = ({ commentByAdmin } = {}) => ({\n  comment: value,\n  currentUserUid: 'some-uid',\n  commentByAvatar: null,\n  commentByAdmin: Boolean(commentByAdmin),\n  commentByName: 'Kind Human',\n  commentByUid: 'uid',\n  createdAt: 'Created less than a minute ago',\n  deleteAction: '/comments/delete?comment_id=1',\n  id,\n  viewers: 'Visible only between you and Lane Kim',\n});\n\ndescribe('Comments', () => {\n  describe('when written by a non-admin user', () => {\n    it('renders correctly with a report link', () => {\n      render(<Comments formProps={formProps} comments={[getComment()]} />);\n      expect(screen.getByRole('textbox')).toBeInTheDocument();\n      expect(screen.getByRole('article')).toBeInTheDocument();\n      expect(\n        screen.getByRole('button', { name: 'Submit' }),\n      ).toBeInTheDocument();\n      expect(screen.getByRole('link', { name: 'Report' })).toBeInTheDocument();\n    });\n\n    it('add and delete a comment', async () => {\n      jest.spyOn(axios, 'post').mockResolvedValue({\n        data: { comment: getComment() },\n      });\n      jest.spyOn(axios, 'delete').mockResolvedValue({\n        data: { id },\n      });\n      render(<Comments formProps={formProps} />);\n      expect(screen.queryByRole('article')).not.toBeInTheDocument();\n\n      userEvent.type(screen.getByRole('textbox'));\n      userEvent.selectOptions(screen.getByRole('combobox'), 'private');\n      userEvent.click(screen.getByRole('button', { name: 'Submit' }));\n\n      await waitFor(() => expect(screen.getByRole('article')).toBeInTheDocument());\n      expect(screen.getByRole('article')).toHaveTextContent('Hey');\n\n      userEvent.click(screen.getByRole('link', { name: 'Delete' }));\n\n      await waitFor(() => expect(screen.queryByRole('article')).not.toBeInTheDocument());\n    });\n  });\n\n  describe('when written by an admin user', () => {\n    it('renders correctly without a report link', () => {\n      render(\n        <Comments\n          formProps={formProps}\n          comments={[getComment({ commentByAdmin: true })]}\n        />,\n      );\n      expect(screen.getByRole('textbox')).toBeInTheDocument();\n      expect(screen.getByRole('article')).toBeInTheDocument();\n      expect(\n        screen.getByRole('button', { name: 'Submit' }),\n      ).toBeInTheDocument();\n      expect(\n        screen.queryByRole('link', { name: 'Report' }),\n      ).not.toBeInTheDocument();\n    });\n\n    it('add and delete a comment', async () => {\n      jest.spyOn(axios, 'post').mockResolvedValue({\n        data: { comment: getComment({ commentByAdmin: true }) },\n      });\n      jest.spyOn(axios, 'delete').mockResolvedValue({\n        data: { id },\n      });\n      render(<Comments formProps={formProps} />);\n      expect(screen.queryByRole('article')).not.toBeInTheDocument();\n\n      userEvent.type(screen.getByRole('textbox'));\n      userEvent.selectOptions(screen.getByRole('combobox'), 'private');\n      userEvent.click(screen.getByRole('button', { name: 'Submit' }));\n\n      await waitFor(() => expect(screen.getByRole('article')).toBeInTheDocument());\n      expect(screen.getByRole('article')).toHaveTextContent('Hey');\n\n      userEvent.click(screen.getByRole('link', { name: 'Delete' }));\n\n      await waitFor(() => expect(screen.queryByRole('article')).not.toBeInTheDocument());\n    });\n  });\n});\n", "// @flow\nimport React, { useState } from 'react';\nimport axios from 'axios';\nimport renderHTML from 'react-render-html';\nimport { I18n } from 'libs/i18n';\nimport { StoryBy } from 'components/Story/StoryBy';\nimport { StoryDate } from 'components/Story/StoryDate';\nimport { StoryActions } from 'components/Story/StoryActions';\nimport DynamicForm from 'components/Form/DynamicForm';\nimport { Utils } from 'utils';\nimport type { FormProps } from 'components/Form/utils';\nimport css from './Comments.scss';\n\ntype CommentResponse = {\n  data: {\n    comment: string,\n    id: string,\n  },\n};\n\ntype Comment = {\n  id: number,\n  currentUserUid: string,\n  commentByUid: string,\n  commentByName: string,\n  commentByAvatar?: string,\n  commentByAdmin: Boolean,\n  comment: any,\n  viewers?: string,\n  createdAt: string,\n  deleteAction?: string,\n};\n\nexport type Props = {\n  comments?: Comment[],\n  formProps: FormProps,\n};\n\nexport const Comments = ({ comments, formProps }: Props) => {\n  const [commentsState, setCommentsState] = useState<(Comment | any)[]>(\n    comments || []);\n  const [key, setKey] = useState<string>('');\n\n  const onDeleteClick = (\n    e: SyntheticEvent<HTMLInputElement>,\n    action: string,\n  ) => {\n    e.preventDefault();\n    Utils.setCsrfToken();\n    axios.delete(action).then((response: CommentResponse) => {\n      const { data } = response;\n      if (data && data.id) {\n        const newComments = commentsState.filter(\n          (comment: Comment) => comment.id !== parseInt(data.id, 10),\n        );\n        setCommentsState(newComments);\n      }\n    });\n  };\n\n  const reportAction = (uid: string, id: number) => ({\n    name: I18n.t('common.actions.report'),\n    link: `/reports/new?uid=${uid}&comment_id=${id}`,\n  });\n\n  const getActions = (\n    viewers: ?string,\n    deleteAction: ?string,\n    currentUserUid: string,\n    uid: string,\n    id: number,\n    commentByAdmin: Boolean,\n  ) => {\n    const actions = {};\n    if (currentUserUid !== uid && !commentByAdmin) {\n      actions.report = reportAction(uid, id);\n    }\n    if (viewers) {\n      actions.viewers = viewers;\n    }\n    if (deleteAction) {\n      actions.delete = {\n        name: I18n.t('common.actions.delete'),\n        link: deleteAction,\n        dataConfirm: I18n.t('common.actions.confirm'),\n        onClick: onDeleteClick,\n      };\n    }\n    return actions;\n  };\n\n  const displayComment = (myComment: Comment) => {\n    const {\n      id,\n      currentUserUid,\n      commentByUid,\n      commentByName,\n      commentByAvatar,\n      commentByAdmin,\n      comment,\n      viewers,\n      createdAt,\n      deleteAction,\n    } = myComment;\n    const author = <a href={`/profile?uid=${commentByUid}`}>{commentByName}</a>;\n    return (\n      <article key={id} className={`comment ${css.comment}`}>\n        <div className={css.commentContent}>{renderHTML(comment)}</div>\n        <StoryDate date={createdAt} />\n        <div className={css.commentInfo}>\n          <StoryBy avatar={commentByAvatar} author={author} />\n          <StoryActions\n            actions={getActions(\n              viewers,\n              deleteAction,\n              currentUserUid,\n              commentByUid,\n              id,\n              commentByAdmin,\n            )}\n            hasStory\n          />\n        </div>\n      </article>\n    );\n  };\n\n  const onSubmit = (response: CommentResponse) => {\n    const { data } = response;\n    if (data && data.comment) {\n      setCommentsState([data.comment].concat(commentsState));\n      setKey(Utils.randomString());\n    }\n  };\n\n  const displayComments = () => {\n    if (commentsState.length === 0) return null;\n    return (\n      <section className={css.comments} aria-label={I18n.t('comment.plural')}>\n        {commentsState.map((comment: Comment) => displayComment(comment))}\n      </section>\n    );\n  };\n\n  return (\n    <div id=\"comments\">\n      <DynamicForm formProps={formProps} onSubmit={onSubmit} key={key} />\n      {displayComments()}\n    </div>\n  );\n};\n\nexport default ({ comments, formProps }: Props) => (\n  <Comments comments={comments} formProps={formProps} />\n);\n", "# frozen_string_literal: true\ndescribe CommentsHelper, type: :controller do\n  let(:user1) { create(:user1) }\n  let(:user2) { create(:user2) }\n\n  controller(ApplicationController) do\n  end\n\n  describe '#generate_comments' do\n    let(:user3) { create(:user3) }\n    let(:comment) { 'Hello from the outside' }\n    let(:created_at) { 'Created less than a minute ago' }\n\n    before do\n      create(:allyships_accepted, user_id: user1.id, ally_id: user2.id)\n      create(:allyships_accepted, user_id: user1.id, ally_id: user3.id)\n    end\n\n    context 'Moments' do\n      let(:new_moment) { create(:moment, user_id: user1.id, viewers: [user2.id, user3.id]) }\n\n      context 'Comment posted by Moment creator who is logged in' do\n        before(:each) do\n          sign_in user1\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user1.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visbility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user1.id, visibility: 'private', viewers: [user2.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user2.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n\n      context 'Comment posted by Moment viewer who is logged in' do\n        before(:each) do\n          sign_in user2\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user2.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visibility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'moment', commentable_id: new_moment.id, comment_by: user2.id, visibility: 'private', viewers: [user1.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user1.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n    end\n\n    context 'Strategies' do\n      let(:new_strategy) { create(:strategy, user_id: user1.id, viewers: [user2.id, user3.id]) }\n\n      context 'Comment posted by Strategy creator who is logged in' do\n        before(:each) do\n          sign_in user1\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user1.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visibility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user1.id, visibility: 'private', viewers: [user2.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user2.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n\n      context 'Comment posted by Strategy viewer who is logged in' do\n        before(:each) do\n          sign_in user2\n        end\n\n        it 'generates a valid comment object when visibility is all' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user2.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n\n        it 'generates a valid comment object when visibility is private' do\n          new_comment = create(:comment, comment: comment, commentable_type: 'strategy', commentable_id: new_strategy.id, comment_by: user2.id, visibility: 'private', viewers: [user1.id])\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: \"Visible only between you and #{user1.name}\",\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n    end\n\n    context 'Meetings' do\n      let(:new_meeting) { create :meeting }\n\n      before do\n        create :meeting_member, user_id: user1.id, leader: true, meeting_id: new_meeting.id\n        create :meeting_member, user_id: user2.id, leader: false, meeting_id: new_meeting.id\n      end\n\n      context 'Comment posted by Meeting creator who is logged in' do\n        it 'generates a valid comment object' do\n          sign_in user1\n          new_comment = create(:comment, comment: comment, commentable_type: 'meeting', commentable_id: new_meeting.id, comment_by: user1.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user1.uid,\n                                                                                          commentByUid: user1.uid,\n                                                                                          commentByName: user1.name,\n                                                                                          commentByAvatar: user1.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n\n      context 'Comment posted by Meeting member who is logged in' do\n        it 'generates a valid comment object' do\n          sign_in user2\n          new_comment = create(:comment, comment: comment, commentable_type: 'meeting', commentable_id: new_meeting.id, comment_by: user2.id, visibility: 'all')\n          expect(controller.generate_comments(Comment.where(id: new_comment.id))).to eq([{\n                                                                                          id: new_comment.id,\n                                                                                          currentUserUid: user2.uid,\n                                                                                          commentByUid: user2.uid,\n                                                                                          commentByName: user2.name,\n                                                                                          commentByAvatar: user2.avatar.url,\n                                                                                          commentByAdmin: false,\n                                                                                          comment: comment,\n                                                                                          createdAt: created_at,\n                                                                                          viewers: nil,\n                                                                                          deleteAction: delete_comments_path(comment_id: new_comment.id)\n                                                                                        }])\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/notifications_controller.rb", "app/helpers/comments_helper.rb", "app/views/allies/index.html.erb", "app/views/profile/index.html.erb", "app/views/search/index.html.erb", "client/app/widgets/Comments/__tests__/Comments.spec.jsx", "client/app/widgets/Comments/index.jsx", "spec/helpers/comments_helper_spec.rb"], "buggy_code_start_loc": [50, 44, 59, 29, 18, 67, 26, 34], "buggy_code_end_loc": [51, 44, 62, 43, 21, 112, 115, 206], "fixing_code_start_loc": [50, 45, 59, 29, 18, 67, 27, 35], "fixing_code_end_loc": [53, 46, 64, 45, 23, 154, 120, 217], "type": "NVD-CWE-Other", "message": "In Ifme, versions v5.0.0 to v7.32 are vulnerable against an improper access control, which makes it possible for admins to ban themselves leading to their deactivation from Ifme account and complete loss of admin access to Ifme.", "other": {"cve": {"id": "CVE-2021-25991", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-12-29T09:15:09.467", "lastModified": "2022-01-10T16:29:47.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Ifme, versions v5.0.0 to v7.32 are vulnerable against an improper access control, which makes it possible for admins to ban themselves leading to their deactivation from Ifme account and complete loss of admin access to Ifme."}, {"lang": "es", "value": "En \"Ifme\", versiones v5.0.0 hasta v7.32, son vulnerables frente a un control de acceso inapropiado, que hace posible que administradores se auto proh\u00edban conllevando a su deshabilitaci\u00f3n de la cuenta de \"Ifme\" y la p\u00e9rdida completa del acceso de administrador en \"Ifme\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:if-me:ifme:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndIncluding": "7.32", "matchCriteriaId": "A40185B0-74EF-455B-AF14-9AA5F3E55B88"}]}]}], "references": [{"url": "https://github.com/ifmeorg/ifme/commit/d1f570c458d41667df801fc9c40a18b181a2d923", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25991", "source": "vulnerabilitylab@mend.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ifmeorg/ifme/commit/d1f570c458d41667df801fc9c40a18b181a2d923"}}