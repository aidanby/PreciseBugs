{"buggy_code": ["import os\nimport tempfile\nimport urllib\nimport weakref\nimport webbrowser\n\nimport bs4\nimport bs4.dammit\nimport requests\n\nfrom .__version__ import __title__, __version__\nfrom .form import Form\nfrom .utils import LinkNotFoundError\n\n\nclass Browser:\n    \"\"\"Builds a low-level Browser.\n\n    It is recommended to use :class:`StatefulBrowser` for most applications,\n    since it offers more advanced features and conveniences than Browser.\n\n    :param session: Attach a pre-existing requests Session instead of\n        constructing a new one.\n    :param soup_config: Configuration passed to BeautifulSoup to affect\n        the way HTML is parsed. Defaults to ``{'features': 'lxml'}``.\n        If overridden, it is highly recommended to `specify a parser\n        <https://www.crummy.com/software/BeautifulSoup/bs4/doc/#specifying-the-parser-to-use>`__.\n        Otherwise, BeautifulSoup will issue a warning and pick one for\n        you, but the parser it chooses may be different on different\n        machines.\n    :param requests_adapters: Configuration passed to requests, to affect\n        the way HTTP requests are performed.\n    :param raise_on_404: If True, raise :class:`LinkNotFoundError`\n        when visiting a page triggers a 404 Not Found error.\n    :param user_agent: Set the user agent header to this value.\n\n    \"\"\"\n    def __init__(self, session=None, soup_config={'features': 'lxml'},\n                 requests_adapters=None,\n                 raise_on_404=False, user_agent=None):\n\n        self.raise_on_404 = raise_on_404\n        self.session = session or requests.Session()\n\n        if hasattr(weakref, 'finalize'):\n            self._finalize = weakref.finalize(self.session, self.close)\n        else:   # pragma: no cover\n            # Python < 3 does not have weakref.finalize, but these\n            # versions accept calling session.close() within __del__\n            self._finalize = self.close\n\n        self.set_user_agent(user_agent)\n\n        if requests_adapters is not None:\n            for adaptee, adapter in requests_adapters.items():\n                self.session.mount(adaptee, adapter)\n\n        self.soup_config = soup_config or dict()\n\n    @staticmethod\n    def __looks_like_html(response):\n        \"\"\"Guesses entity type when Content-Type header is missing.\n        Since Content-Type is not strictly required, some servers leave it out.\n        \"\"\"\n        text = response.text.lstrip().lower()\n        return text.startswith('<html') or text.startswith('<!doctype')\n\n    @staticmethod\n    def add_soup(response, soup_config):\n        \"\"\"Attaches a soup object to a requests response.\"\"\"\n        if (\"text/html\" in response.headers.get(\"Content-Type\", \"\") or\n                Browser.__looks_like_html(response)):\n            # Note: By default (no charset provided in HTTP headers), requests\n            # returns 'ISO-8859-1' which is the default for HTML4, even if HTML\n            # code specifies a different encoding. In this case, we want to\n            # resort to bs4 sniffing, hence the special handling here.\n            http_encoding = (\n                response.encoding\n                if 'charset' in response.headers.get(\"Content-Type\", \"\")\n                else None\n            )\n            html_encoding = bs4.dammit.EncodingDetector.find_declared_encoding(\n                response.content,\n                is_html=True\n            )\n            # See https://www.w3.org/International/questions/qa-html-encoding-declarations.en#httphead  # noqa: E501\n            # > The HTTP header has a higher precedence than the in-document\n            # > meta declarations.\n            encoding = http_encoding if http_encoding else html_encoding\n            response.soup = bs4.BeautifulSoup(\n                response.content,\n                from_encoding=encoding,\n                **soup_config\n            )\n        else:\n            response.soup = None\n\n    def set_cookiejar(self, cookiejar):\n        \"\"\"Replaces the current cookiejar in the requests session. Since the\n        session handles cookies automatically without calling this function,\n        only use this when default cookie handling is insufficient.\n\n        :param cookiejar: Any `http.cookiejar.CookieJar\n          <https://docs.python.org/3/library/http.cookiejar.html#http.cookiejar.CookieJar>`__\n          compatible object.\n        \"\"\"\n        self.session.cookies = cookiejar\n\n    def get_cookiejar(self):\n        \"\"\"Gets the cookiejar from the requests session.\"\"\"\n        return self.session.cookies\n\n    def set_user_agent(self, user_agent):\n        \"\"\"Replaces the current user agent in the requests session headers.\"\"\"\n        # set a default user_agent if not specified\n        if user_agent is None:\n            requests_ua = requests.utils.default_user_agent()\n            user_agent = f'{requests_ua} ({__title__}/{__version__})'\n\n        # the requests module uses a case-insensitive dict for session headers\n        self.session.headers['User-agent'] = user_agent\n\n    def request(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.request\n        <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n\n        This is a low-level function that should not be called for\n        basic usage (use :func:`get` or :func:`post` instead). Use it if you\n        need an HTTP verb that MechanicalSoup doesn't manage (e.g. MKCOL) for\n        example.\n        \"\"\"\n        response = self.session.request(*args, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def get(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.get\n        <http://docs.python-requests.org/en/master/api/#requests.Session.get>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        response = self.session.get(*args, **kwargs)\n        if self.raise_on_404 and response.status_code == 404:\n            raise LinkNotFoundError()\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def post(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.post\n        <http://docs.python-requests.org/en/master/api/#requests.Session.post>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        response = self.session.post(*args, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def put(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.put\n        <http://docs.python-requests.org/en/master/api/#requests.Session.put>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        response = self.session.put(*args, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    @staticmethod\n    def _get_request_kwargs(method, url, **kwargs):\n        \"\"\"This method exists to raise a TypeError when a method or url is\n        specified in the kwargs.\n        \"\"\"\n        request_kwargs = {\"method\": method, \"url\": url}\n        request_kwargs.update(kwargs)\n        return request_kwargs\n\n    @classmethod\n    def get_request_kwargs(cls, form, url=None, **kwargs):\n        \"\"\"Extract input data from the form.\"\"\"\n        method = str(form.get(\"method\", \"get\"))\n        action = form.get(\"action\")\n        url = urllib.parse.urljoin(url, action)\n        if url is None:  # This happens when both `action` and `url` are None.\n            raise ValueError('no URL to submit to')\n\n        # read https://www.w3.org/TR/html52/sec-forms.html\n        if method.lower() == \"get\":\n            data = kwargs.pop(\"params\", dict())\n        else:\n            data = kwargs.pop(\"data\", dict())\n        files = kwargs.pop(\"files\", dict())\n\n        # Use a list of 2-tuples to better reflect the behavior of browser QSL.\n        # Requests also retains order when encoding form data in 2-tuple lists.\n        data = [(k, v) for k, v in data.items()]\n\n        multipart = form.get(\"enctype\", \"\") == \"multipart/form-data\"\n\n        # Process form tags in the order that they appear on the page,\n        # skipping those tags that do not have a name-attribute.\n        selector = \",\".join(f\"{tag}[name]\" for tag in\n                            (\"input\", \"button\", \"textarea\", \"select\"))\n        for tag in form.select(selector):\n            name = tag.get(\"name\")  # name-attribute of tag\n\n            # Skip disabled elements, since they should not be submitted.\n            if tag.has_attr('disabled'):\n                continue\n\n            if tag.name == \"input\":\n                if tag.get(\"type\", \"\").lower() in (\"radio\", \"checkbox\"):\n                    if \"checked\" not in tag.attrs:\n                        continue\n                    value = tag.get(\"value\", \"on\")\n                else:\n                    # browsers use empty string for inputs with missing values\n                    value = tag.get(\"value\", \"\")\n\n                # If the enctype is not multipart, the filename is put in\n                # the form as a text input and the file is not sent.\n                if tag.get(\"type\", \"\").lower() == \"file\" and multipart:\n                    filepath = value\n                    if filepath != \"\" and isinstance(filepath, str):\n                        content = open(filepath, \"rb\")\n                    else:\n                        content = \"\"\n                    filename = os.path.basename(filepath)\n                    # If value is the empty string, we still pass it\n                    # for consistency with browsers (see\n                    # https://github.com/MechanicalSoup/MechanicalSoup/issues/250).\n                    files[name] = (filename, content)\n                else:\n                    data.append((name, value))\n\n            elif tag.name == \"button\":\n                if tag.get(\"type\", \"\").lower() in (\"button\", \"reset\"):\n                    continue\n                else:\n                    data.append((name, tag.get(\"value\", \"\")))\n\n            elif tag.name == \"textarea\":\n                data.append((name, tag.text))\n\n            elif tag.name == \"select\":\n                # If the value attribute is not specified, the content will\n                # be passed as a value instead.\n                options = tag.select(\"option\")\n                selected_values = [i.get(\"value\", i.text) for i in options\n                                   if \"selected\" in i.attrs]\n                if \"multiple\" in tag.attrs:\n                    for value in selected_values:\n                        data.append((name, value))\n                elif selected_values:\n                    # A standard select element only allows one option to be\n                    # selected, but browsers pick last if somehow multiple.\n                    data.append((name, selected_values[-1]))\n                elif options:\n                    # Selects the first option if none are selected\n                    first_value = options[0].get(\"value\", options[0].text)\n                    data.append((name, first_value))\n\n        if method.lower() == \"get\":\n            kwargs[\"params\"] = data\n        else:\n            kwargs[\"data\"] = data\n\n        # The following part of the function is here to respect the\n        # enctype specified by the form, i.e. force sending multipart\n        # content. Since Requests doesn't have yet a feature to choose\n        # enctype, we have to use tricks to make it behave as we want\n        # This code will be updated if Requests implements it.\n        if multipart and not files:\n            # Requests will switch to \"multipart/form-data\" only if\n            # files pass the `if files:` test, so in this case we use\n            # a modified dict that passes the if test even if empty.\n            class DictThatReturnsTrue(dict):\n                def __bool__(self):\n                    return True\n                __nonzero__ = __bool__\n\n            files = DictThatReturnsTrue()\n\n        return cls._get_request_kwargs(method, url, files=files, **kwargs)\n\n    def _request(self, form, url=None, **kwargs):\n        \"\"\"Extract input data from the form to pass to a Requests session.\"\"\"\n        request_kwargs = Browser.get_request_kwargs(form, url, **kwargs)\n        return self.session.request(**request_kwargs)\n\n    def submit(self, form, url=None, **kwargs):\n        \"\"\"Prepares and sends a form request.\n\n        NOTE: To submit a form with a :class:`StatefulBrowser` instance, it is\n        recommended to use :func:`StatefulBrowser.submit_selected` instead of\n        this method so that the browser state is correctly updated.\n\n        :param form: The filled-out form.\n        :param url: URL of the page the form is on. If the form action is a\n            relative path, then this must be specified.\n        :param \\\\*\\\\*kwargs: Arguments forwarded to `requests.Session.request\n            <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.\n            If `files`, `params` (with GET), or `data` (with POST) are\n            specified, they will be appended to by the contents of `form`.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        if isinstance(form, Form):\n            form = form.form\n        response = self._request(form, url, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def launch_browser(self, soup):\n        \"\"\"Launch a browser to display a page, for debugging purposes.\n\n        :param: soup: Page contents to display, supplied as a bs4 soup object.\n        \"\"\"\n        with tempfile.NamedTemporaryFile(delete=False, suffix='.html') as file:\n            file.write(soup.encode())\n        webbrowser.open('file://' + file.name)\n\n    def close(self):\n        \"\"\"Close the current session, if still open.\"\"\"\n        if self.session is not None:\n            self.session.cookies.clear()\n            self.session.close()\n            self.session = None\n\n    def __del__(self):\n        self._finalize()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.close()\n", "import copy\nimport warnings\n\nfrom bs4 import BeautifulSoup\n\nfrom .utils import LinkNotFoundError\n\n\nclass InvalidFormMethod(LinkNotFoundError):\n    \"\"\"This exception is raised when a method of :class:`Form` is used\n    for an HTML element that is of the wrong type (or is malformed).\n    It is caught within :func:`Form.set` to perform element type deduction.\n\n    It is derived from :class:`LinkNotFoundError` so that a single base class\n    can be used to catch all exceptions specific to this module.\n    \"\"\"\n    pass\n\n\nclass Form:\n    \"\"\"Build a fillable form.\n\n    :param form: A bs4.element.Tag corresponding to an HTML form element.\n\n    The Form class is responsible for preparing HTML forms for submission.\n    It handles the following types of elements:\n    input (text, checkbox, radio), select, and textarea.\n\n    Each type is set by a method named after the type (e.g.\n    :func:`~Form.set_select`), and then there are convenience methods (e.g.\n    :func:`~Form.set`) that do type-deduction and set the value using the\n    appropriate method.\n\n    It also handles submit-type elements using :func:`~Form.choose_submit`.\n    \"\"\"\n\n    def __init__(self, form):\n        if form.name != 'form':\n            warnings.warn(\n                f\"Constructed a Form from a '{form.name}' instead of a 'form' \"\n                \" element. This may be an error in a future version of \"\n                \"MechanicalSoup.\", FutureWarning)\n\n        self.form = form\n        self._submit_chosen = False\n\n        # Aliases for backwards compatibility\n        # (Included specifically in __init__ to suppress them in Sphinx docs)\n        self.attach = self.set_input\n        self.input = self.set_input\n        self.textarea = self.set_textarea\n\n    def set_input(self, data):\n        \"\"\"Fill-in a set of fields in a form.\n\n        Example: filling-in a login/password form\n\n        .. code-block:: python\n\n           form.set_input({\"login\": username, \"password\": password})\n\n        This will find the input element named \"login\" and give it the\n        value ``username``, and the input element named \"password\" and\n        give it the value ``password``.\n        \"\"\"\n\n        for (name, value) in data.items():\n            i = self.form.find(\"input\", {\"name\": name})\n            if not i:\n                raise InvalidFormMethod(\"No input field named \" + name)\n            i[\"value\"] = value\n\n    def uncheck_all(self, name):\n        \"\"\"Remove the *checked*-attribute of all input elements with\n        a *name*-attribute given by ``name``.\n        \"\"\"\n        for option in self.form.find_all(\"input\", {\"name\": name}):\n            if \"checked\" in option.attrs:\n                del option.attrs[\"checked\"]\n\n    def check(self, data):\n        \"\"\"For backwards compatibility, this method handles checkboxes\n        and radio buttons in a single call. It will not uncheck any\n        checkboxes unless explicitly specified by ``data``, in contrast\n        with the default behavior of :func:`~Form.set_checkbox`.\n        \"\"\"\n        for (name, value) in data.items():\n            try:\n                self.set_checkbox({name: value}, uncheck_other_boxes=False)\n                continue\n            except InvalidFormMethod:\n                pass\n            try:\n                self.set_radio({name: value})\n                continue\n            except InvalidFormMethod:\n                pass\n            raise LinkNotFoundError(\"No input checkbox/radio named \" + name)\n\n    def set_checkbox(self, data, uncheck_other_boxes=True):\n        \"\"\"Set the *checked*-attribute of input elements of type \"checkbox\"\n        specified by ``data`` (i.e. check boxes).\n\n        :param data: Dict of ``{name: value, ...}``.\n            In the family of checkboxes whose *name*-attribute is ``name``,\n            check the box whose *value*-attribute is ``value``. All boxes in\n            the family can be checked (unchecked) if ``value`` is True (False).\n            To check multiple specific boxes, let ``value`` be a tuple or list.\n        :param uncheck_other_boxes: If True (default), before checking any\n            boxes specified by ``data``, uncheck the entire checkbox family.\n            Consider setting to False if some boxes are checked by default when\n            the HTML is served.\n        \"\"\"\n        for (name, value) in data.items():\n            # Case-insensitive search for type=checkbox\n            selector = 'input[type=\"checkbox\" i][name=\"{}\"]'.format(name)\n            checkboxes = self.form.select(selector)\n            if not checkboxes:\n                raise InvalidFormMethod(\"No input checkbox named \" + name)\n\n            # uncheck if requested\n            if uncheck_other_boxes:\n                self.uncheck_all(name)\n\n            # Wrap individual values (e.g. int, str) in a 1-element tuple.\n            if not isinstance(value, list) and not isinstance(value, tuple):\n                value = (value,)\n\n            # Check or uncheck one or more boxes\n            for choice in value:\n                choice_str = str(choice)  # Allow for example literal numbers\n                for checkbox in checkboxes:\n                    if checkbox.attrs.get(\"value\", \"on\") == choice_str:\n                        checkbox[\"checked\"] = \"\"\n                        break\n                    # Allow specifying True or False to check/uncheck\n                    elif choice is True:\n                        checkbox[\"checked\"] = \"\"\n                        break\n                    elif choice is False:\n                        if \"checked\" in checkbox.attrs:\n                            del checkbox.attrs[\"checked\"]\n                        break\n                else:\n                    raise LinkNotFoundError(\n                        \"No input checkbox named %s with choice %s\" %\n                        (name, choice)\n                    )\n\n    def set_radio(self, data):\n        \"\"\"Set the *checked*-attribute of input elements of type \"radio\"\n        specified by ``data`` (i.e. select radio buttons).\n\n        :param data: Dict of ``{name: value, ...}``.\n            In the family of radio buttons whose *name*-attribute is ``name``,\n            check the radio button whose *value*-attribute is ``value``.\n            Only one radio button in the family can be checked.\n        \"\"\"\n        for (name, value) in data.items():\n            # Case-insensitive search for type=radio\n            selector = 'input[type=\"radio\" i][name=\"{}\"]'.format(name)\n            radios = self.form.select(selector)\n            if not radios:\n                raise InvalidFormMethod(\"No input radio named \" + name)\n\n            # only one radio button can be checked\n            self.uncheck_all(name)\n\n            # Check the appropriate radio button (value cannot be a list/tuple)\n            for radio in radios:\n                if radio.attrs.get(\"value\", \"on\") == str(value):\n                    radio[\"checked\"] = \"\"\n                    break\n            else:\n                raise LinkNotFoundError(\n                    f\"No input radio named {name} with choice {value}\"\n                )\n\n    def set_textarea(self, data):\n        \"\"\"Set the *string*-attribute of the first textarea element\n        specified by ``data`` (i.e. set the text of a textarea).\n\n        :param data: Dict of ``{name: value, ...}``.\n            The textarea whose *name*-attribute is ``name`` will have\n            its *string*-attribute set to ``value``.\n        \"\"\"\n        for (name, value) in data.items():\n            t = self.form.find(\"textarea\", {\"name\": name})\n            if not t:\n                raise InvalidFormMethod(\"No textarea named \" + name)\n            t.string = value\n\n    def set_select(self, data):\n        \"\"\"Set the *selected*-attribute of the first option element\n        specified by ``data`` (i.e. select an option from a dropdown).\n\n        :param data: Dict of ``{name: value, ...}``.\n            Find the select element whose *name*-attribute is ``name``.\n            Then select from among its children the option element whose\n            *value*-attribute is ``value``. If no matching *value*-attribute\n            is found, this will search for an option whose text matches\n            ``value``. If the select element's *multiple*-attribute is set,\n            then ``value`` can be a list or tuple to select multiple options.\n        \"\"\"\n        for (name, value) in data.items():\n            select = self.form.find(\"select\", {\"name\": name})\n            if not select:\n                raise InvalidFormMethod(\"No select named \" + name)\n\n            # Deselect all options first\n            for option in select.find_all(\"option\"):\n                if \"selected\" in option.attrs:\n                    del option.attrs[\"selected\"]\n\n            # Wrap individual values in a 1-element tuple.\n            # If value is a list/tuple, select must be a <select multiple>.\n            if not isinstance(value, list) and not isinstance(value, tuple):\n                value = (value,)\n            elif \"multiple\" not in select.attrs:\n                raise LinkNotFoundError(\"Cannot select multiple options!\")\n\n            for choice in value:\n                option = select.find(\"option\", {\"value\": choice})\n\n                # try to find with text instead of value\n                if not option:\n                    option = select.find(\"option\", string=choice)\n\n                if not option:\n                    raise LinkNotFoundError(\n                        f'Option {choice} not found for select {name}'\n                    )\n\n                option.attrs[\"selected\"] = \"selected\"\n\n    def __setitem__(self, name, value):\n        \"\"\"Forwards arguments to :func:`~Form.set`. For example,\n        :code:`form[\"name\"] = \"value\"` calls :code:`form.set(\"name\", \"value\")`.\n        \"\"\"\n        return self.set(name, value)\n\n    def set(self, name, value, force=False):\n        \"\"\"Set a form element identified by ``name`` to a specified ``value``.\n        The type of element (input, textarea, select, ...) does not\n        need to be given; it is inferred by the following methods:\n        :func:`~Form.set_checkbox`,\n        :func:`~Form.set_radio`,\n        :func:`~Form.set_input`,\n        :func:`~Form.set_textarea`,\n        :func:`~Form.set_select`.\n        If none of these methods find a matching element, then if ``force``\n        is True, a new element (``<input type=\"text\" ...>``) will be\n        added using :func:`~Form.new_control`.\n\n        Example: filling-in a login/password form with EULA checkbox\n\n        .. code-block:: python\n\n            form.set(\"login\", username)\n            form.set(\"password\", password)\n            form.set(\"eula-checkbox\", True)\n\n        Example: uploading a file through a ``<input type=\"file\"\n        name=\"tagname\">`` field (provide the path to the local file,\n        and its content will be uploaded):\n\n        .. code-block:: python\n\n            form.set(\"tagname\", path_to_local_file)\n\n        \"\"\"\n        for func in (\"checkbox\", \"radio\", \"input\", \"textarea\", \"select\"):\n            try:\n                getattr(self, \"set_\" + func)({name: value})\n                return\n            except InvalidFormMethod:\n                pass\n        if force:\n            self.new_control('text', name, value=value)\n            return\n        raise LinkNotFoundError(\"No valid element named \" + name)\n\n    def new_control(self, type, name, value, **kwargs):\n        \"\"\"Add a new input element to the form.\n\n        The arguments set the attributes of the new element.\n        \"\"\"\n        # Remove existing input-like elements with the same name\n        for tag in ('input', 'textarea', 'select'):\n            for old in self.form.find_all(tag, {'name': name}):\n                old.decompose()\n        # We don't have access to the original soup object (just the\n        # Tag), so we instantiate a new BeautifulSoup() to call\n        # new_tag(). We're only building the soup object, not parsing\n        # anything, so the parser doesn't matter. Specify the one\n        # included in Python to avoid having dependency issue.\n        control = BeautifulSoup(\"\", \"html.parser\").new_tag('input')\n        control['type'] = type\n        control['name'] = name\n        control['value'] = value\n        for k, v in kwargs.items():\n            control[k] = v\n        self.form.append(control)\n        return control\n\n    def choose_submit(self, submit):\n        \"\"\"Selects the input (or button) element to use for form submission.\n\n        :param submit: The :class:`bs4.element.Tag` (or just its\n            *name*-attribute) that identifies the submit element to use. If\n            ``None``, will choose the first valid submit element in the form,\n            if one exists. If ``False``, will not use any submit element;\n            this is useful for simulating AJAX requests, for example.\n\n        To simulate a normal web browser, only one submit element must be\n        sent. Therefore, this does not need to be called if there is only\n        one submit element in the form.\n\n        If the element is not found or if multiple elements match, raise a\n        :class:`LinkNotFoundError` exception.\n\n        Example: ::\n\n            browser = mechanicalsoup.StatefulBrowser()\n            browser.open(url)\n            form = browser.select_form()\n            form.choose_submit('form_name_attr')\n            browser.submit_selected()\n        \"\"\"\n        # Since choose_submit is destructive, it doesn't make sense to call\n        # this method twice unless no submit is specified.\n        if self._submit_chosen:\n            if submit is None:\n                return\n            else:\n                raise Exception('Submit already chosen. Cannot change submit!')\n\n        # All buttons NOT of type (button,reset) are valid submits\n        # Case-insensitive search for type=submit\n        inps = [i for i in self.form.select('input[type=\"submit\" i], button')\n                if i.get(\"type\", \"\").lower() not in ('button', 'reset')]\n\n        # If no submit specified, choose the first one\n        if submit is None and inps:\n            submit = inps[0]\n\n        found = False\n        for inp in inps:\n            if (inp.has_attr('name') and inp['name'] == submit):\n                if found:\n                    raise LinkNotFoundError(\n                        f\"Multiple submit elements match: {submit}\"\n                    )\n                found = True\n            elif inp == submit:\n                if found:\n                    # Ignore submit element since it is an exact\n                    # duplicate of the one we're looking at.\n                    del inp['name']\n                found = True\n            else:\n                # Delete any non-matching element's name so that it will be\n                # omitted from the submitted form data.\n                del inp['name']\n\n        if not found and submit is not None and submit is not False:\n            raise LinkNotFoundError(\n                f\"Specified submit element not found: {submit}\"\n            )\n        self._submit_chosen = True\n\n    def print_summary(self):\n        \"\"\"Print a summary of the form.\n\n        May help finding which fields need to be filled-in.\n        \"\"\"\n        for input in self.form.find_all(\n                (\"input\", \"textarea\", \"select\", \"button\")):\n            input_copy = copy.copy(input)\n            # Text between the opening tag and the closing tag often\n            # contains a lot of spaces that we don't want here.\n            for subtag in input_copy.find_all() + [input_copy]:\n                if subtag.string:\n                    subtag.string = subtag.string.strip()\n            print(input_copy)\n", "class LinkNotFoundError(Exception):\n    \"\"\"Exception raised when mechanicalsoup fails to find something.\n\n    This happens in situations like (non-exhaustive list):\n\n    * :func:`~mechanicalsoup.StatefulBrowser.find_link` is called, but\n      no link is found.\n\n    * The browser was configured with raise_on_404=True and a 404\n      error is triggered while browsing.\n\n    * The user tried to fill-in a field which doesn't exist in a form\n      (e.g. browser[\"name\"] = \"val\" with browser being a\n      StatefulBrowser).\n    \"\"\"\n    pass\n", "import os\nimport sys\nimport tempfile\n\nimport pytest\nimport setpath  # noqa:F401, must come before 'import mechanicalsoup'\nfrom bs4 import BeautifulSoup\nfrom requests.cookies import RequestsCookieJar\nfrom utils import mock_get, prepare_mock_browser\n\nimport mechanicalsoup\n\n\ndef test_submit_online(httpbin):\n    \"\"\"Complete and submit the pizza form at http://httpbin.org/forms/post \"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n\n    form.find(\"input\", {\"name\": \"custname\"})[\"value\"] = \"Philip J. Fry\"\n    # leave custtel blank without value\n    assert \"value\" not in form.find(\"input\", {\"name\": \"custtel\"}).attrs\n    form.find(\"input\", {\"name\": \"size\", \"value\": \"medium\"})[\"checked\"] = \"\"\n    form.find(\"input\", {\"name\": \"topping\", \"value\": \"cheese\"})[\"checked\"] = \"\"\n    form.find(\"input\", {\"name\": \"topping\", \"value\": \"onion\"})[\"checked\"] = \"\"\n    form.find(\"textarea\", {\"name\": \"comments\"}).insert(0, \"freezer\")\n\n    response = browser.submit(form, page.url)\n\n    # helpfully the form submits to http://httpbin.org/post which simply\n    # returns the request headers in json format\n    json = response.json()\n    data = json[\"form\"]\n    assert data[\"custname\"] == \"Philip J. Fry\"\n    assert data[\"custtel\"] == \"\"  # web browser submits \"\" for input left blank\n    assert data[\"size\"] == \"medium\"\n    assert data[\"topping\"] == [\"cheese\", \"onion\"]\n    assert data[\"comments\"] == \"freezer\"\n\n    assert json[\"headers\"][\"User-Agent\"].startswith('python-requests/')\n    assert 'MechanicalSoup' in json[\"headers\"][\"User-Agent\"]\n\n\ndef test_get_request_kwargs(httpbin):\n    \"\"\"Return kwargs without a submit\"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n    form.find(\"input\", {\"name\": \"custname\"})[\"value\"] = \"Philip J. Fry\"\n    request_kwargs = browser.get_request_kwargs(form, page.url)\n    assert \"method\" in request_kwargs\n    assert \"url\" in request_kwargs\n    assert \"data\" in request_kwargs\n    assert (\"custname\", \"Philip J. Fry\") in request_kwargs[\"data\"]\n\n\ndef test_get_request_kwargs_when_method_is_in_kwargs(httpbin):\n    \"\"\"Raise TypeError exception\"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n    kwargs = {\"method\": \"post\"}\n    with pytest.raises(TypeError):\n        browser.get_request_kwargs(form, page.url, **kwargs)\n\n\ndef test_get_request_kwargs_when_url_is_in_kwargs(httpbin):\n    \"\"\"Raise TypeError exception\"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n    kwargs = {\"url\": httpbin + \"/forms/post\"}\n    with pytest.raises(TypeError):\n        # pylint: disable=redundant-keyword-arg\n        browser.get_request_kwargs(form, page.url, **kwargs)\n\n\ndef test__request(httpbin):\n    form_html = f\"\"\"\n    <form method=\"post\" action=\"{httpbin.url}/post\">\n      <input name=\"customer\" value=\"Philip J. Fry\"/>\n      <input name=\"telephone\" value=\"555\"/>\n      <textarea name=\"comments\">freezer</textarea>\n      <fieldset>\n        <legend> Pizza Size </legend>\n        <p><input type=RADIO name=size value=\"small\">Small</p>\n        <p><input type=radiO name=size value=\"medium\" checked>Medium</p>\n        <p><input type=radio name=size value=\"large\">Large</p>\n      </fieldset>\n      <fieldset>\n        <legend> Pizza Toppings </legend>\n        <p><input type=CHECKBOX name=\"topping\" value=\"bacon\" checked>Bacon</p>\n        <p><input type=checkBox name=\"topping\" value=\"cheese\">Extra Cheese</p>\n        <p><input type=checkbox name=\"topping\" value=\"onion\" checked>Onion</p>\n        <p><input type=checkbox name=\"topping\" value=\"mushroom\">Mushroom</p>\n      </fieldset>\n      <select name=\"shape\">\n        <option value=\"round\">Round</option>\n        <option value=\"square\" selected>Square</option>\n      </select>\n    </form>\n    \"\"\"\n\n    form = BeautifulSoup(form_html, \"lxml\").form\n\n    browser = mechanicalsoup.Browser()\n    response = browser._request(form)\n\n    data = response.json()['form']\n    assert data[\"customer\"] == \"Philip J. Fry\"\n    assert data[\"telephone\"] == \"555\"\n    assert data[\"comments\"] == \"freezer\"\n    assert data[\"size\"] == \"medium\"\n    assert data[\"topping\"] == [\"bacon\", \"onion\"]\n    assert data[\"shape\"] == \"square\"\n\n    assert \"application/x-www-form-urlencoded\" in response.request.headers[\n        \"Content-Type\"]\n\n\nvalid_enctypes_file_submit = {\"multipart/form-data\": True,\n                              \"application/x-www-form-urlencoded\": False\n                              }\n\ndefault_enctype = \"application/x-www-form-urlencoded\"\n\n\n@pytest.mark.parametrize(\"file_field\", [\n  \"\"\"<input name=\"pic\" type=\"file\" />\"\"\",\n  \"\"])\n@pytest.mark.parametrize(\"submit_file\", [\n    True,\n    False\n])\n@pytest.mark.parametrize(\"enctype\", [\n  pytest.param(\"multipart/form-data\"),\n  pytest.param(\"application/x-www-form-urlencoded\"),\n  pytest.param(\"Invalid enctype\")\n])\ndef test_enctype_and_file_submit(httpbin, enctype, submit_file, file_field):\n    # test if enctype is respected when specified\n    # and if files are processed correctly\n    form_html = f\"\"\"\n    <form method=\"post\" action=\"{httpbin.url}/post\" enctype=\"{enctype}\">\n      <input name=\"in\" value=\"test\" />\n      {file_field}\n    </form>\n    \"\"\"\n    form = BeautifulSoup(form_html, \"lxml\").form\n\n    valid_enctype = (enctype in valid_enctypes_file_submit and\n                     valid_enctypes_file_submit[enctype])\n    expected_content = b\"\"  # default\n    if submit_file and file_field:\n        # create a temporary file for testing file upload\n        file_content = b\":-)\"\n        pic_filedescriptor, pic_path = tempfile.mkstemp()\n        pic_filename = os.path.basename(pic_path)\n        os.write(pic_filedescriptor, file_content)\n        os.close(pic_filedescriptor)\n        if valid_enctype:\n            # Correct encoding => send the content\n            expected_content = file_content\n        else:\n            # Encoding doesn't allow sending the content, we expect\n            # the filename as a normal text field.\n            expected_content = pic_path.encode()\n        form.find(\"input\", {\"name\": \"pic\"})[\"value\"] = pic_path\n\n    browser = mechanicalsoup.Browser()\n    response = browser._request(form)\n\n    if enctype not in valid_enctypes_file_submit:\n        expected_enctype = default_enctype\n    else:\n        expected_enctype = enctype\n    assert expected_enctype in response.request.headers[\"Content-Type\"]\n\n    resp = response.json()\n    assert resp[\"form\"][\"in\"] == \"test\"\n\n    found = False\n    found_in = None\n\n    for key, value in resp.items():\n        if value:\n            if \"pic\" in value:\n                content = value[\"pic\"].encode()\n                assert not found\n                assert key in (\"files\", \"form\")\n                found = True\n                found_in = key\n            if key == \"files\" and not valid_enctype:\n                assert not value\n\n    assert found == bool(file_field)\n    if file_field:\n        assert content == expected_content\n\n        if valid_enctype:\n            assert found_in == \"files\"\n            if submit_file:\n                assert (\"filename=\\\"\" + pic_filename + \"\\\"\"\n                        ).encode() in response.request.body\n            else:\n                assert b\"filename=\\\"\\\"\" in response.request.body\n        else:\n            assert found_in == \"form\"\n\n    if submit_file and file_field:\n        os.remove(pic_path)\n\n\ndef test__request_select_none(httpbin):\n    \"\"\"Make sure that a <select> with no options selected\n    submits the first option, as it does in a browser.\"\"\"\n    form_html = f\"\"\"\n    <form method=\"post\" action={httpbin.url}/post>\n      <select name=\"shape\">\n        <option value=\"round\">Round</option>\n        <option value=\"square\">Square</option>\n      </select>\n    </form>\"\"\"\n\n    form = BeautifulSoup(form_html, \"lxml\").form\n    browser = mechanicalsoup.Browser()\n    response = browser._request(form)\n    assert response.json()['form'] == {'shape': 'round'}\n\n\ndef test__request_disabled_attr(httpbin):\n    \"\"\"Make sure that disabled form controls are not submitted.\"\"\"\n    form_html = f\"\"\"\n    <form method=\"post\" action=\"{httpbin.url}/post\">\n      <input disabled name=\"nosubmit\" value=\"1\" />\n    </form>\"\"\"\n\n    browser = mechanicalsoup.Browser()\n    response = browser._request(BeautifulSoup(form_html, \"lxml\").form)\n    assert response.json()['form'] == {}\n\n\n@pytest.mark.parametrize(\"keyword\", [\n    pytest.param('method'),\n    pytest.param('url'),\n])\ndef test_request_keyword_error(keyword):\n    \"\"\"Make sure exception is raised if kwargs duplicates an arg.\"\"\"\n    form_html = \"<form></form>\"\n    browser = mechanicalsoup.Browser()\n    with pytest.raises(TypeError, match=\"multiple values for\"):\n        browser._request(BeautifulSoup(form_html, \"lxml\").form,\n                         'myurl', **{keyword: 'somevalue'})\n\n\ndef test_no_404(httpbin):\n    browser = mechanicalsoup.Browser()\n    resp = browser.get(httpbin + \"/nosuchpage\")\n    assert resp.status_code == 404\n\n\ndef test_404(httpbin):\n    browser = mechanicalsoup.Browser(raise_on_404=True)\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.get(httpbin + \"/nosuchpage\")\n    resp = browser.get(httpbin.url)\n    assert resp.status_code == 200\n\n\ndef test_set_cookiejar(httpbin):\n    \"\"\"Set cookies locally and test that they are received remotely.\"\"\"\n    # construct a phony cookiejar and attach it to the session\n    jar = RequestsCookieJar()\n    jar.set('field', 'value')\n    assert jar.get('field') == 'value'\n\n    browser = mechanicalsoup.Browser()\n    browser.set_cookiejar(jar)\n    resp = browser.get(httpbin + \"/cookies\")\n    assert resp.json() == {'cookies': {'field': 'value'}}\n\n\ndef test_get_cookiejar(httpbin):\n    \"\"\"Test that cookies set by the remote host update our session.\"\"\"\n    browser = mechanicalsoup.Browser()\n    resp = browser.get(httpbin + \"/cookies/set?k1=v1&k2=v2\")\n    assert resp.json() == {'cookies': {'k1': 'v1', 'k2': 'v2'}}\n\n    jar = browser.get_cookiejar()\n    assert jar.get('k1') == 'v1'\n    assert jar.get('k2') == 'v2'\n\n\ndef test_post(httpbin):\n    browser = mechanicalsoup.Browser()\n    data = {'color': 'blue', 'colorblind': 'True'}\n    resp = browser.post(httpbin + \"/post\", data)\n    assert resp.status_code == 200 and resp.json()['form'] == data\n\n\ndef test_put(httpbin):\n    browser = mechanicalsoup.Browser()\n    data = {'color': 'blue', 'colorblind': 'True'}\n    resp = browser.put(httpbin + \"/put\", data)\n    assert resp.status_code == 200 and resp.json()['form'] == data\n\n\n@pytest.mark.parametrize(\"http_html_expected_encoding\", [\n    pytest.param((None, 'utf-8', 'utf-8')),\n    pytest.param(('utf-8', 'utf-8', 'utf-8')),\n    pytest.param(('utf-8', None, 'utf-8')),\n    pytest.param(('utf-8', 'ISO-8859-1', 'utf-8')),\n])\ndef test_encoding(httpbin, http_html_expected_encoding):\n    http_encoding = http_html_expected_encoding[0]\n    html_encoding = http_html_expected_encoding[1]\n    expected_encoding = http_html_expected_encoding[2]\n\n    url = 'mock://encoding'\n    text = (\n        '<!doctype html>'\n        + '<html lang=\"fr\">'\n        + (\n            (\n                '<head><meta charset=\"'\n                + html_encoding\n                + '\"><title>Title\u00e9\u00e0\u00e8</title></head>'\n            ) if html_encoding\n            else ''\n        )\n        + '<body></body>'\n        + '</html>'\n    )\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(\n        adapter,\n        url=url,\n        reply=(\n            text.encode(http_encoding)\n            if http_encoding\n            else text.encode(\"utf-8\")\n        ),\n        content_type=(\n            'text/html'\n            + (\n                ';charset=' + http_encoding\n                if http_encoding\n                else ''\n            )\n        )\n    )\n    browser.open(url)\n    assert browser.page.original_encoding == expected_encoding\n\n\nif __name__ == '__main__':\n    pytest.main(sys.argv)\n", "import copy\nimport json\nimport os\nimport re\nimport sys\nimport tempfile\nimport webbrowser\n\nimport pytest\nimport setpath  # noqa:F401, must come before 'import mechanicalsoup'\nfrom bs4 import BeautifulSoup\nfrom utils import (mock_get, open_legacy_httpbin, prepare_mock_browser,\n                   setup_mock_browser)\n\nimport mechanicalsoup\nimport requests\n\n\ndef test_request_forward():\n    data = [('var1', 'val1'), ('var2', 'val2')]\n    browser, url = setup_mock_browser(expected_post=data)\n    r = browser.request('POST', url + '/post', data=data)\n    assert r.text == 'Success!'\n\n\ndef test_properties():\n    \"\"\"Check that properties return the same value as the getter.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<form></form>', url=\"http://example.com\")\n    assert browser.page == browser.get_current_page()\n    assert browser.page is not None\n    assert browser.url == browser.get_url()\n    assert browser.url is not None\n    browser.select_form()\n    assert browser.form == browser.get_current_form()\n    assert browser.form is not None\n\n\ndef test_get_selected_form_unselected():\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<form></form>')\n    with pytest.raises(AttributeError, match=\"No form has been selected yet.\"):\n        browser.form\n    assert browser.get_current_form() is None\n\n\ndef test_submit_online(httpbin):\n    \"\"\"Complete and submit the pizza form at http://httpbin.org/forms/post \"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.set_user_agent('testing MechanicalSoup')\n    browser.open(httpbin.url)\n    for link in browser.links():\n        if link[\"href\"] == \"/\":\n            browser.follow_link(link)\n            break\n    browser.follow_link(\"forms/post\")\n    assert browser.url == httpbin + \"/forms/post\"\n    browser.select_form(\"form\")\n    browser[\"custname\"] = \"Customer Name Here\"\n    browser[\"size\"] = \"medium\"\n    browser[\"topping\"] = (\"cheese\", \"bacon\")\n    # Change our mind to make sure old boxes are unticked\n    browser[\"topping\"] = (\"cheese\", \"onion\")\n    browser[\"comments\"] = \"Some comment here\"\n    browser.form.set(\"nosuchfield\", \"new value\", True)\n    response = browser.submit_selected()\n    json = response.json()\n    data = json[\"form\"]\n    assert data[\"custname\"] == \"Customer Name Here\"\n    assert data[\"custtel\"] == \"\"  # web browser submits \"\" for input left blank\n    assert data[\"size\"] == \"medium\"\n    assert set(data[\"topping\"]) == {\"cheese\", \"onion\"}\n    assert data[\"comments\"] == \"Some comment here\"\n    assert data[\"nosuchfield\"] == \"new value\"\n\n    assert json[\"headers\"][\"User-Agent\"] == 'testing MechanicalSoup'\n    # Ensure we haven't blown away any regular headers\n    expected_headers = ('Content-Length', 'Host', 'Content-Type', 'Connection',\n                        'Accept', 'User-Agent', 'Accept-Encoding')\n    assert set(expected_headers).issubset(json[\"headers\"].keys())\n\n\ndef test_no_404(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    resp = browser.open(httpbin + \"/nosuchpage\")\n    assert resp.status_code == 404\n\n\ndef test_404(httpbin):\n    browser = mechanicalsoup.StatefulBrowser(raise_on_404=True)\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.open(httpbin + \"/nosuchpage\")\n    resp = browser.open(httpbin.url)\n    assert resp.status_code == 200\n\n\ndef test_user_agent(httpbin):\n    browser = mechanicalsoup.StatefulBrowser(user_agent='007')\n    resp = browser.open(httpbin + \"/user-agent\")\n    assert resp.json() == {'user-agent': '007'}\n\n\ndef test_open_relative(httpbin):\n    # Open an arbitrary httpbin page to set the current URL\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open(httpbin + \"/html\")\n\n    # Open a relative page and make sure remote host and browser agree on URL\n    resp = browser.open_relative(\"/get\")\n    assert resp.json()['url'] == httpbin + \"/get\"\n    assert browser.url == httpbin + \"/get\"\n\n    # Test passing additional kwargs to the session\n    resp = browser.open_relative(\"/basic-auth/me/123\", auth=('me', '123'))\n    assert browser.url == httpbin + \"/basic-auth/me/123\"\n    assert resp.json() == {\"authenticated\": True, \"user\": \"me\"}\n\n\ndef test_links():\n    browser = mechanicalsoup.StatefulBrowser()\n    html = '''<a class=\"bluelink\" href=\"/blue\" id=\"blue_link\">A Blue Link</a>\n              <a class=\"redlink\" href=\"/red\" id=\"red_link\">A Red Link</a>'''\n    expected = [BeautifulSoup(html, \"lxml\").a]\n    browser.open_fake_page(html)\n\n    # Test StatefulBrowser.links url_regex argument\n    assert browser.links(url_regex=\"bl\") == expected\n    assert browser.links(url_regex=\"bluish\") == []\n\n    # Test StatefulBrowser.links link_text argument\n    assert browser.links(link_text=\"A Blue Link\") == expected\n    assert browser.links(link_text=\"Blue\") == []\n\n    # Test StatefulBrowser.links kwargs passed to BeautifulSoup.find_all\n    assert browser.links(string=re.compile('Blue')) == expected\n    assert browser.links(class_=\"bluelink\") == expected\n    assert browser.links(id=\"blue_link\") == expected\n    assert browser.links(id=\"blue\") == []\n\n    # Test returning a non-singleton\n    two_links = browser.links(id=re.compile('_link'))\n    assert len(two_links) == 2\n    assert two_links == BeautifulSoup(html, \"lxml\").find_all('a')\n\n\n@pytest.mark.parametrize(\"expected_post\", [\n    pytest.param(\n        [\n            ('text', 'Setting some text!'),\n            ('comment', 'Selecting an input submit'),\n            ('diff', 'Review Changes'),\n        ], id='input'),\n    pytest.param(\n        [\n            ('text', '= Heading =\\n\\nNew page here!\\n'),\n            ('comment', 'Selecting a button submit'),\n            ('cancel', 'Cancel'),\n        ], id='button'),\n])\ndef test_submit_btnName(expected_post):\n    '''Tests that the btnName argument chooses the submit button.'''\n    browser, url = setup_mock_browser(expected_post=expected_post)\n    browser.open(url)\n    browser.select_form('#choose-submit-form')\n    browser['text'] = dict(expected_post)['text']\n    browser['comment'] = dict(expected_post)['comment']\n    initial_state = browser._StatefulBrowser__state\n    res = browser.submit_selected(btnName=expected_post[2][0])\n    assert res.status_code == 200 and res.text == 'Success!'\n    assert initial_state != browser._StatefulBrowser__state\n\n\n@pytest.mark.parametrize(\"expected_post\", [\n    pytest.param(\n        [\n            ('text', 'Setting some text!'),\n            ('comment', 'Selecting an input submit'),\n        ], id='input'),\n    pytest.param(\n        [\n            ('text', '= Heading =\\n\\nNew page here!\\n'),\n            ('comment', 'Selecting a button submit'),\n        ], id='button'),\n])\ndef test_submit_no_btn(expected_post):\n    '''Tests that no submit inputs are posted when btnName=False.'''\n    browser, url = setup_mock_browser(expected_post=expected_post)\n    browser.open(url)\n    browser.select_form('#choose-submit-form')\n    browser['text'] = dict(expected_post)['text']\n    browser['comment'] = dict(expected_post)['comment']\n    initial_state = browser._StatefulBrowser__state\n    res = browser.submit_selected(btnName=False)\n    assert res.status_code == 200 and res.text == 'Success!'\n    assert initial_state != browser._StatefulBrowser__state\n\n\ndef test_submit_dont_modify_kwargs():\n    \"\"\"Test that submit_selected() doesn't modify the caller's passed-in\n    kwargs, for example when adding a Referer header.\n    \"\"\"\n    kwargs = {'headers': {'Content-Type': 'text/html'}}\n    saved_kwargs = copy.deepcopy(kwargs)\n\n    browser, url = setup_mock_browser(expected_post=[], text='<form></form>')\n    browser.open(url)\n    browser.select_form()\n    browser.submit_selected(**kwargs)\n\n    assert kwargs == saved_kwargs\n\n\ndef test_submit_dont_update_state():\n    expected_post = [\n            ('text', 'Bananas are good.'),\n            ('preview', 'Preview Page')]\n    browser, url = setup_mock_browser(expected_post=expected_post)\n    browser.open(url)\n    browser.select_form('#choose-submit-form')\n    browser['text'] = dict(expected_post)['text']\n    initial_state = browser._StatefulBrowser__state\n    res = browser.submit_selected(update_state=False)\n    assert res.status_code == 200 and res.text == 'Success!'\n    assert initial_state == browser._StatefulBrowser__state\n\n\ndef test_get_set_debug():\n    browser = mechanicalsoup.StatefulBrowser()\n    # Debug mode is off by default\n    assert not browser.get_debug()\n    browser.set_debug(True)\n    assert browser.get_debug()\n\n\ndef test_list_links(capsys):\n    # capsys is a pytest fixture that allows us to inspect the std{err,out}\n    browser = mechanicalsoup.StatefulBrowser()\n    links = '''\n     <a href=\"/link1\">Link #1</a>\n     <a href=\"/link2\" id=\"link2\"> Link #2</a>\n'''\n    browser.open_fake_page(f'<html>{links}</html>')\n    browser.list_links()\n    out, err = capsys.readouterr()\n    expected = f'Links in the current page:{links}'\n    assert out == expected\n\n\ndef test_launch_browser(mocker):\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.set_debug(True)\n    browser.open_fake_page('<html></html>')\n    mocker.patch('webbrowser.open')\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.follow_link('nosuchlink')\n    # mock.assert_called_once() not available on some versions :-(\n    assert webbrowser.open.call_count == 1\n    mocker.resetall()\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.select_form('nosuchlink')\n    # mock.assert_called_once() not available on some versions :-(\n    assert webbrowser.open.call_count == 1\n\n\ndef test_find_link():\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<html></html>')\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.find_link('nosuchlink')\n\n\ndef test_verbose(capsys):\n    '''Tests that the btnName argument chooses the submit button.'''\n    browser, url = setup_mock_browser()\n    browser.open(url)\n    out, err = capsys.readouterr()\n    assert out == \"\"\n    assert err == \"\"\n    assert browser.get_verbose() == 0\n    browser.set_verbose(1)\n    browser.open(url)\n    out, err = capsys.readouterr()\n    assert out == \".\"\n    assert err == \"\"\n    assert browser.get_verbose() == 1\n    browser.set_verbose(2)\n    browser.open(url)\n    out, err = capsys.readouterr()\n    assert out == \"mock://form.com\\n\"\n    assert err == \"\"\n    assert browser.get_verbose() == 2\n\n\ndef test_new_control(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open(httpbin + \"/forms/post\")\n    browser.select_form(\"form\")\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        # The control doesn't exist, yet.\n        browser[\"temperature\"] = \"cold\"\n    browser[\"size\"] = \"large\"  # Existing radio\n    browser[\"comments\"] = \"This is a comment\"  # Existing textarea\n    browser.new_control(\"text\", \"temperature\", \"warm\")\n    browser.new_control(\"textarea\", \"size\", \"Sooo big !\")\n    browser.new_control(\"text\", \"comments\", \"This is an override comment\")\n    fake_select = BeautifulSoup(\"\", \"html.parser\").new_tag('select')\n    fake_select[\"name\"] = \"foo\"\n    browser.form.form.append(fake_select)\n    browser.new_control(\"checkbox\", \"foo\", \"valval\", checked=\"checked\")\n    tag = browser.form.form.find(\"input\", {\"name\": \"foo\"})\n    assert tag.attrs[\"checked\"] == \"checked\"\n    browser[\"temperature\"] = \"hot\"\n    response = browser.submit_selected()\n    json = response.json()\n    data = json[\"form\"]\n    print(data)\n    assert data[\"temperature\"] == \"hot\"\n    assert data[\"size\"] == \"Sooo big !\"\n    assert data[\"comments\"] == \"This is an override comment\"\n    assert data[\"foo\"] == \"valval\"\n\n\nsubmit_form_noaction = '''\n<html>\n  <body>\n    <form id=\"choose-submit-form\">\n      <input type=\"text\" name=\"text1\" value=\"someValue1\" />\n      <input type=\"text\" name=\"text2\" value=\"someValue2\" />\n      <input type=\"submit\" name=\"save\" />\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_form_noaction():\n    browser, url = setup_mock_browser()\n    browser.open_fake_page(submit_form_noaction)\n    browser.select_form('#choose-submit-form')\n    with pytest.raises(ValueError, match=\"no URL to submit to\"):\n        browser.submit_selected()\n\n\nsubmit_form_noname = '''\n<html>\n  <body>\n    <form id=\"choose-submit-form\" method=\"post\" action=\"mock://form.com/post\">\n      <textarea>Value</textarea> <!-- no name -->\n      <select> <!-- no name -->\n        <option value=\"tofu\" selected=\"selected\">Tofu Stir Fry</option>\n        <option value=\"curry\">Red Curry</option>\n        <option value=\"tempeh\">Tempeh Tacos</option>\n      </select>\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_form_noname():\n    browser, url = setup_mock_browser(expected_post=[])\n    browser.open_fake_page(submit_form_noname, url=url)\n    browser.select_form('#choose-submit-form')\n    response = browser.submit_selected()\n    assert response.status_code == 200 and response.text == 'Success!'\n\n\nsubmit_form_multiple = '''\n<html>\n  <body>\n    <form id=\"choose-submit-form\" method=\"post\" action=\"mock://form.com/post\">\n      <select name=\"foo\" multiple>\n        <option value=\"tofu\" selected=\"selected\">Tofu Stir Fry</option>\n        <option value=\"curry\">Red Curry</option>\n        <option value=\"tempeh\" selected=\"selected\">Tempeh Tacos</option>\n      </select>\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_form_multiple():\n    browser, url = setup_mock_browser(expected_post=[('foo', 'tofu'),\n                                                     ('foo', 'tempeh')])\n    browser.open_fake_page(submit_form_multiple, url=url)\n    browser.select_form('#choose-submit-form')\n    response = browser.submit_selected()\n    assert response.status_code == 200 and response.text == 'Success!'\n\n\ndef test_upload_file(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open(httpbin + \"/forms/post\")\n\n    # Create two temporary files to upload\n    def make_file(content):\n        path = tempfile.mkstemp()[1]\n        with open(path, \"w\") as fd:\n            fd.write(content)\n        return path\n    path1, path2 = (make_file(content) for content in\n                    (\"first file content\", \"second file content\"))\n\n    # The form doesn't have a type=file field, but the target action\n    # does show it => add the fields ourselves, and add enctype too.\n    browser.select_form()\n    browser._StatefulBrowser__state.form.form[\n      \"enctype\"] = \"multipart/form-data\"\n    browser.new_control(\"file\", \"first\", path1)\n    browser.new_control(\"file\", \"second\", \"\")\n    browser[\"second\"] = path2\n    browser.form.print_summary()\n    response = browser.submit_selected()\n    files = response.json()[\"files\"]\n    assert files[\"first\"] == \"first file content\"\n    assert files[\"second\"] == \"second file content\"\n\n\ndef test_with():\n    \"\"\"Test that __enter__/__exit__ properly create/close the browser.\"\"\"\n    with mechanicalsoup.StatefulBrowser() as browser:\n        assert browser.session is not None\n    assert browser.session is None\n\n\ndef test_select_form_nr():\n    \"\"\"Test the nr option of select_form.\"\"\"\n    forms = \"\"\"<form id=\"a\"></form><form id=\"b\"></form><form id=\"c\"></form>\"\"\"\n    with mechanicalsoup.StatefulBrowser() as browser:\n        browser.open_fake_page(forms)\n        form = browser.select_form()\n        assert form.form['id'] == \"a\"\n        form = browser.select_form(nr=1)\n        assert form.form['id'] == \"b\"\n        form = browser.select_form(nr=2)\n        assert form.form['id'] == \"c\"\n        with pytest.raises(mechanicalsoup.LinkNotFoundError):\n            browser.select_form(nr=3)\n\n\ndef test_select_form_tag_object():\n    \"\"\"Test tag object as selector parameter type\"\"\"\n    forms = \"\"\"<form id=\"a\"></form><form id=\"b\"></form><p></p>\"\"\"\n    soup = BeautifulSoup(forms, \"lxml\")\n    with mechanicalsoup.StatefulBrowser() as browser:\n        browser.open_fake_page(forms)\n        form = browser.select_form(soup.find(\"form\", {\"id\": \"b\"}))\n        assert form.form['id'] == \"b\"\n        with pytest.raises(mechanicalsoup.LinkNotFoundError):\n            browser.select_form(soup.find(\"p\"))\n\n\ndef test_select_form_associated_elements():\n    \"\"\"Test associated elements outside the form tag\"\"\"\n    forms = \"\"\"<form id=\"a\"><input><textarea></form><input form=\"a\">\n               <textarea form=\"a\"/><input form=\"b\">\n               <form id=\"ab\" action=\"/test.php\"><input></form>\n               <textarea form=\"ab\"></textarea>\n            \"\"\"\n    with mechanicalsoup.StatefulBrowser() as browser:\n        browser.open_fake_page(forms)\n        elements_form_a = set([\n            \"<input/>\", \"<textarea></textarea>\",\n            '<input form=\"a\"/>', '<textarea form=\"a\"></textarea>'])\n        elements_form_ab = set([\"<input/>\", '<textarea form=\"ab\"></textarea>'])\n        form_by_str = browser.select_form(\"#a\")\n        form_by_tag = browser.select_form(browser.page.find(\"form\", id='a'))\n        form_by_css = browser.select_form(\"form[action$='.php']\")\n        assert set([str(element) for element in form_by_str.form.find_all((\n            \"input\", \"textarea\"))]) == elements_form_a\n        assert set([str(element) for element in form_by_tag.form.find_all((\n            \"input\", \"textarea\"))]) == elements_form_a\n        assert set([str(element) for element in form_by_css.form.find_all((\n            \"input\", \"textarea\"))]) == elements_form_ab\n\n\ndef test_referer_follow_link(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    start_url = browser.url\n    response = browser.follow_link(\"/headers\")\n    referer = response.json()[\"headers\"][\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    expected_ref = re.sub('/*$', '', start_url)\n    assert actual_ref == expected_ref\n\n\nsubmit_form_headers = '''\n<html>\n  <body>\n    <form method=\"get\" action=\"{}\" id=\"choose-submit-form\">\n      <input type=\"text\" name=\"text1\" value=\"someValue1\" />\n      <input type=\"text\" name=\"text2\" value=\"someValue2\" />\n      <input type=\"submit\" name=\"save\" />\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_referer_submit(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = \"https://example.com/my-referer\"\n    page = submit_form_headers.format(httpbin.url + \"/headers\")\n    browser.open_fake_page(page, url=ref)\n    browser.select_form()\n    response = browser.submit_selected()\n    headers = response.json()[\"headers\"]\n    referer = headers[\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    assert actual_ref == ref\n\n\n@pytest.mark.parametrize(\"referer_header\", [\"Referer\", \"referer\"])\ndef test_referer_submit_override(httpbin, referer_header):\n    \"\"\"Ensure the caller can override the Referer header that\n    mechanicalsoup would normally add. Because headers are case insensitive,\n    test with both 'Referer' and 'referer'.\n    \"\"\"\n\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = \"https://example.com/my-referer\"\n    ref_override = \"https://example.com/override\"\n    page = submit_form_headers.format(httpbin.url + \"/headers\")\n    browser.open_fake_page(page, url=ref)\n    browser.select_form()\n    response = browser.submit_selected(headers={referer_header: ref_override})\n    headers = response.json()[\"headers\"]\n    referer = headers[\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    assert actual_ref == ref_override\n\n\ndef test_referer_submit_headers(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = \"https://example.com/my-referer\"\n    page = submit_form_headers.format(httpbin.url + \"/headers\")\n    browser.open_fake_page(page, url=ref)\n    browser.select_form()\n    response = browser.submit_selected(\n        headers={'X-Test-Header': 'x-test-value'})\n    headers = response.json()[\"headers\"]\n    referer = headers[\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    assert actual_ref == ref\n    assert headers['X-Test-Header'] == 'x-test-value'\n\n\n@pytest.mark.parametrize('expected, kwargs', [\n    pytest.param('/foo', {}, id='none'),\n    pytest.param('/get', {'string': 'Link'}, id='string'),\n    pytest.param('/get', {'url_regex': 'get'}, id='regex'),\n])\ndef test_follow_link_arg(httpbin, expected, kwargs):\n    browser = mechanicalsoup.StatefulBrowser()\n    html = '<a href=\"/foo\">Bar</a><a href=\"/get\">Link</a>'\n    browser.open_fake_page(html, httpbin.url)\n    browser.follow_link(bs4_kwargs=kwargs)\n    assert browser.url == httpbin + expected\n\n\ndef test_follow_link_excess(httpbin):\n    \"\"\"Ensure that excess args are passed to BeautifulSoup\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    html = '<a href=\"/foo\">Bar</a><a href=\"/get\">Link</a>'\n    browser.open_fake_page(html, httpbin.url)\n    browser.follow_link(url_regex='get')\n    assert browser.url == httpbin + '/get'\n\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<a href=\"/get\">Link</a>', httpbin.url)\n    with pytest.raises(ValueError, match=\"link parameter cannot be .*\"):\n        browser.follow_link('foo', url_regex='bar')\n\n\ndef test_follow_link_ua(httpbin):\n    \"\"\"Tests passing requests parameters to follow_link() by\n    setting the User-Agent field.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    # html = '<a href=\"/foo\">Bar</a><a href=\"/get\">Link</a>'\n    # browser.open_fake_page(html, httpbin.url)\n    open_legacy_httpbin(browser, httpbin)\n    bs4_kwargs = {'url_regex': 'user-agent'}\n    requests_kwargs = {'headers': {\"User-Agent\": '007'}}\n    resp = browser.follow_link(bs4_kwargs=bs4_kwargs,\n                               requests_kwargs=requests_kwargs)\n    assert browser.url == httpbin + '/user-agent'\n    assert resp.json() == {'user-agent': '007'}\n    assert resp.request.headers['user-agent'] == '007'\n\n\ndef test_link_arg_multiregex(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<a href=\"/get\">Link</a>', httpbin.url)\n    with pytest.raises(ValueError, match=\"link parameter cannot be .*\"):\n        browser.follow_link('foo', bs4_kwargs={'url_regex': 'bar'})\n\n\ndef file_get_contents(filename):\n    with open(filename, \"rb\") as fd:\n        return fd.read()\n\n\ndef test_download_link(httpbin):\n    \"\"\"Test downloading the contents of a link to file.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    tmpdir = tempfile.mkdtemp()\n    tmpfile = tmpdir + '/nosuchfile.png'\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(file=tmpfile, link='image/png')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was downloaded\n    assert os.path.isfile(tmpfile)\n    assert file_get_contents(tmpfile) == response.content\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(link='image/png')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile_bs4(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(bs4_kwargs={'url_regex': 'image.png'})\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile_excess(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(url_regex='image.png')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile_ua(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    requests_kwargs = {'headers': {\"User-Agent\": '007'}}\n    response = browser.download_link(link='image/png',\n                                     requests_kwargs=requests_kwargs)\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n    # Check that we actually set the User-agent outbound\n    assert response.request.headers['user-agent'] == '007'\n\n\ndef test_download_link_to_existing_file(httpbin):\n    \"\"\"Test downloading the contents of a link to an existing file.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    tmpdir = tempfile.mkdtemp()\n    tmpfile = tmpdir + '/existing.png'\n    with open(tmpfile, \"w\") as fd:\n        fd.write(\"initial content\")\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link('image/png', tmpfile)\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was downloaded\n    assert os.path.isfile(tmpfile)\n    assert file_get_contents(tmpfile) == response.content\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_404(httpbin):\n    \"\"\"Test downloading the contents of a broken link.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser(raise_on_404=True)\n    browser.open_fake_page('<a href=\"/no-such-page-404\">Link</a>',\n                           url=httpbin.url)\n    tmpdir = tempfile.mkdtemp()\n    tmpfile = tmpdir + '/nosuchfile.txt'\n    current_url = browser.url\n    current_page = browser.page\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.download_link(file=tmpfile, link_text='Link')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was not downloaded\n    assert not os.path.exists(tmpfile)\n\n\ndef test_download_link_referer(httpbin):\n    \"\"\"Test downloading the contents of a link to file.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = httpbin + \"/my-referer\"\n    browser.open_fake_page('<a href=\"/headers\">Link</a>',\n                           url=ref)\n    tmpfile = tempfile.NamedTemporaryFile()\n    current_url = browser.url\n    current_page = browser.page\n    browser.download_link(file=tmpfile.name, link_text='Link')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was downloaded\n    with open(tmpfile.name) as fd:\n        json_data = json.load(fd)\n    headers = json_data[\"headers\"]\n    assert headers[\"Referer\"] == ref\n\n\ndef test_refresh_open():\n    url = 'mock://example.com'\n    initial_page = BeautifulSoup('<p>Fake empty page</p>', 'lxml')\n    reload_page = BeautifulSoup('<p>Fake reloaded page</p>', 'lxml')\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(adapter, url=url, reply=str(initial_page))\n    browser.open(url)\n    mock_get(adapter, url=url, reply=str(reload_page),\n             additional_matcher=lambda r: 'Referer' not in r.headers)\n\n    browser.refresh()\n\n    assert browser.url == url\n    assert browser.page == reload_page\n\n\ndef test_refresh_follow_link():\n    url = 'mock://example.com'\n    follow_url = 'mock://example.com/followed'\n    initial_content = f'<a href=\"{follow_url}\">Link</a>'\n    initial_page = BeautifulSoup(initial_content, 'lxml')\n    reload_page = BeautifulSoup('<p>Fake reloaded page</p>', 'lxml')\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(adapter, url=url, reply=str(initial_page))\n    mock_get(adapter, url=follow_url, reply=str(initial_page))\n    browser.open(url)\n    browser.follow_link()\n    refer_header = {'Referer': url}\n    mock_get(adapter, url=follow_url, reply=str(reload_page),\n             request_headers=refer_header)\n\n    browser.refresh()\n\n    assert browser.url == follow_url\n    assert browser.page == reload_page\n\n\ndef test_refresh_form_not_retained():\n    url = 'mock://example.com'\n    initial_content = '<form>Here comes the form</form>'\n    initial_page = BeautifulSoup(initial_content, 'lxml')\n    reload_page = BeautifulSoup('<p>Fake reloaded page</p>', 'lxml')\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(adapter, url=url, reply=str(initial_page))\n    browser.open(url)\n    browser.select_form()\n    mock_get(adapter, url=url, reply=str(reload_page),\n             additional_matcher=lambda r: 'Referer' not in r.headers)\n\n    browser.refresh()\n\n    assert browser.url == url\n    assert browser.page == reload_page\n    with pytest.raises(AttributeError, match=\"No form has been selected yet.\"):\n        browser.form\n\n\ndef test_refresh_error():\n    browser = mechanicalsoup.StatefulBrowser()\n\n    # Test no page\n    with pytest.raises(ValueError):\n        browser.refresh()\n\n    # Test fake page\n    with pytest.raises(ValueError):\n        browser.open_fake_page('<p>Fake empty page</p>', url='http://fake.com')\n        browser.refresh()\n\n\ndef test_requests_session_and_cookies(httpbin):\n    \"\"\"Check that the session object passed to the constructor of\n    StatefulBrowser is actually taken into account.\"\"\"\n    s = requests.Session()\n    requests.utils.add_dict_to_cookiejar(s.cookies, {'key1': 'val1'})\n    browser = mechanicalsoup.StatefulBrowser(session=s)\n    resp = browser.get(httpbin + \"/cookies\")\n    assert resp.json() == {'cookies': {'key1': 'val1'}}\n\n\nif __name__ == '__main__':\n    pytest.main(sys.argv)\n"], "fixing_code": ["import io\nimport os\nimport tempfile\nimport urllib\nimport weakref\nimport webbrowser\n\nimport bs4\nimport bs4.dammit\nimport requests\n\nfrom .__version__ import __title__, __version__\nfrom .form import Form\nfrom .utils import LinkNotFoundError, is_multipart_file_upload\n\n\nclass Browser:\n    \"\"\"Builds a low-level Browser.\n\n    It is recommended to use :class:`StatefulBrowser` for most applications,\n    since it offers more advanced features and conveniences than Browser.\n\n    :param session: Attach a pre-existing requests Session instead of\n        constructing a new one.\n    :param soup_config: Configuration passed to BeautifulSoup to affect\n        the way HTML is parsed. Defaults to ``{'features': 'lxml'}``.\n        If overridden, it is highly recommended to `specify a parser\n        <https://www.crummy.com/software/BeautifulSoup/bs4/doc/#specifying-the-parser-to-use>`__.\n        Otherwise, BeautifulSoup will issue a warning and pick one for\n        you, but the parser it chooses may be different on different\n        machines.\n    :param requests_adapters: Configuration passed to requests, to affect\n        the way HTTP requests are performed.\n    :param raise_on_404: If True, raise :class:`LinkNotFoundError`\n        when visiting a page triggers a 404 Not Found error.\n    :param user_agent: Set the user agent header to this value.\n\n    \"\"\"\n    def __init__(self, session=None, soup_config={'features': 'lxml'},\n                 requests_adapters=None,\n                 raise_on_404=False, user_agent=None):\n\n        self.raise_on_404 = raise_on_404\n        self.session = session or requests.Session()\n\n        if hasattr(weakref, 'finalize'):\n            self._finalize = weakref.finalize(self.session, self.close)\n        else:   # pragma: no cover\n            # Python < 3 does not have weakref.finalize, but these\n            # versions accept calling session.close() within __del__\n            self._finalize = self.close\n\n        self.set_user_agent(user_agent)\n\n        if requests_adapters is not None:\n            for adaptee, adapter in requests_adapters.items():\n                self.session.mount(adaptee, adapter)\n\n        self.soup_config = soup_config or dict()\n\n    @staticmethod\n    def __looks_like_html(response):\n        \"\"\"Guesses entity type when Content-Type header is missing.\n        Since Content-Type is not strictly required, some servers leave it out.\n        \"\"\"\n        text = response.text.lstrip().lower()\n        return text.startswith('<html') or text.startswith('<!doctype')\n\n    @staticmethod\n    def add_soup(response, soup_config):\n        \"\"\"Attaches a soup object to a requests response.\"\"\"\n        if (\"text/html\" in response.headers.get(\"Content-Type\", \"\") or\n                Browser.__looks_like_html(response)):\n            # Note: By default (no charset provided in HTTP headers), requests\n            # returns 'ISO-8859-1' which is the default for HTML4, even if HTML\n            # code specifies a different encoding. In this case, we want to\n            # resort to bs4 sniffing, hence the special handling here.\n            http_encoding = (\n                response.encoding\n                if 'charset' in response.headers.get(\"Content-Type\", \"\")\n                else None\n            )\n            html_encoding = bs4.dammit.EncodingDetector.find_declared_encoding(\n                response.content,\n                is_html=True\n            )\n            # See https://www.w3.org/International/questions/qa-html-encoding-declarations.en#httphead  # noqa: E501\n            # > The HTTP header has a higher precedence than the in-document\n            # > meta declarations.\n            encoding = http_encoding if http_encoding else html_encoding\n            response.soup = bs4.BeautifulSoup(\n                response.content,\n                from_encoding=encoding,\n                **soup_config\n            )\n        else:\n            response.soup = None\n\n    def set_cookiejar(self, cookiejar):\n        \"\"\"Replaces the current cookiejar in the requests session. Since the\n        session handles cookies automatically without calling this function,\n        only use this when default cookie handling is insufficient.\n\n        :param cookiejar: Any `http.cookiejar.CookieJar\n          <https://docs.python.org/3/library/http.cookiejar.html#http.cookiejar.CookieJar>`__\n          compatible object.\n        \"\"\"\n        self.session.cookies = cookiejar\n\n    def get_cookiejar(self):\n        \"\"\"Gets the cookiejar from the requests session.\"\"\"\n        return self.session.cookies\n\n    def set_user_agent(self, user_agent):\n        \"\"\"Replaces the current user agent in the requests session headers.\"\"\"\n        # set a default user_agent if not specified\n        if user_agent is None:\n            requests_ua = requests.utils.default_user_agent()\n            user_agent = f'{requests_ua} ({__title__}/{__version__})'\n\n        # the requests module uses a case-insensitive dict for session headers\n        self.session.headers['User-agent'] = user_agent\n\n    def request(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.request\n        <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n\n        This is a low-level function that should not be called for\n        basic usage (use :func:`get` or :func:`post` instead). Use it if you\n        need an HTTP verb that MechanicalSoup doesn't manage (e.g. MKCOL) for\n        example.\n        \"\"\"\n        response = self.session.request(*args, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def get(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.get\n        <http://docs.python-requests.org/en/master/api/#requests.Session.get>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        response = self.session.get(*args, **kwargs)\n        if self.raise_on_404 and response.status_code == 404:\n            raise LinkNotFoundError()\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def post(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.post\n        <http://docs.python-requests.org/en/master/api/#requests.Session.post>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        response = self.session.post(*args, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def put(self, *args, **kwargs):\n        \"\"\"Straightforward wrapper around `requests.Session.put\n        <http://docs.python-requests.org/en/master/api/#requests.Session.put>`__.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        response = self.session.put(*args, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    @staticmethod\n    def _get_request_kwargs(method, url, **kwargs):\n        \"\"\"This method exists to raise a TypeError when a method or url is\n        specified in the kwargs.\n        \"\"\"\n        request_kwargs = {\"method\": method, \"url\": url}\n        request_kwargs.update(kwargs)\n        return request_kwargs\n\n    @classmethod\n    def get_request_kwargs(cls, form, url=None, **kwargs):\n        \"\"\"Extract input data from the form.\"\"\"\n        method = str(form.get(\"method\", \"get\"))\n        action = form.get(\"action\")\n        url = urllib.parse.urljoin(url, action)\n        if url is None:  # This happens when both `action` and `url` are None.\n            raise ValueError('no URL to submit to')\n\n        # read https://www.w3.org/TR/html52/sec-forms.html\n        if method.lower() == \"get\":\n            data = kwargs.pop(\"params\", dict())\n        else:\n            data = kwargs.pop(\"data\", dict())\n        files = kwargs.pop(\"files\", dict())\n\n        # Use a list of 2-tuples to better reflect the behavior of browser QSL.\n        # Requests also retains order when encoding form data in 2-tuple lists.\n        data = [(k, v) for k, v in data.items()]\n\n        multipart = form.get(\"enctype\", \"\") == \"multipart/form-data\"\n\n        # Process form tags in the order that they appear on the page,\n        # skipping those tags that do not have a name-attribute.\n        selector = \",\".join(f\"{tag}[name]\" for tag in\n                            (\"input\", \"button\", \"textarea\", \"select\"))\n        for tag in form.select(selector):\n            name = tag.get(\"name\")  # name-attribute of tag\n\n            # Skip disabled elements, since they should not be submitted.\n            if tag.has_attr('disabled'):\n                continue\n\n            if tag.name == \"input\":\n                if tag.get(\"type\", \"\").lower() in (\"radio\", \"checkbox\"):\n                    if \"checked\" not in tag.attrs:\n                        continue\n                    value = tag.get(\"value\", \"on\")\n                else:\n                    # browsers use empty string for inputs with missing values\n                    value = tag.get(\"value\", \"\")\n\n                # If the enctype is not multipart, the filename is put in\n                # the form as a text input and the file is not sent.\n                if is_multipart_file_upload(form, tag):\n                    if isinstance(value, io.IOBase):\n                        content = value\n                        filename = os.path.basename(getattr(value, \"name\", \"\"))\n                    else:\n                        content = \"\"\n                        filename = os.path.basename(value)\n                    # If content is the empty string, we still pass it\n                    # for consistency with browsers (see\n                    # https://github.com/MechanicalSoup/MechanicalSoup/issues/250).\n                    files[name] = (filename, content)\n                else:\n                    if isinstance(value, io.IOBase):\n                        value = os.path.basename(getattr(value, \"name\", \"\"))\n                    data.append((name, value))\n\n            elif tag.name == \"button\":\n                if tag.get(\"type\", \"\").lower() in (\"button\", \"reset\"):\n                    continue\n                else:\n                    data.append((name, tag.get(\"value\", \"\")))\n\n            elif tag.name == \"textarea\":\n                data.append((name, tag.text))\n\n            elif tag.name == \"select\":\n                # If the value attribute is not specified, the content will\n                # be passed as a value instead.\n                options = tag.select(\"option\")\n                selected_values = [i.get(\"value\", i.text) for i in options\n                                   if \"selected\" in i.attrs]\n                if \"multiple\" in tag.attrs:\n                    for value in selected_values:\n                        data.append((name, value))\n                elif selected_values:\n                    # A standard select element only allows one option to be\n                    # selected, but browsers pick last if somehow multiple.\n                    data.append((name, selected_values[-1]))\n                elif options:\n                    # Selects the first option if none are selected\n                    first_value = options[0].get(\"value\", options[0].text)\n                    data.append((name, first_value))\n\n        if method.lower() == \"get\":\n            kwargs[\"params\"] = data\n        else:\n            kwargs[\"data\"] = data\n\n        # The following part of the function is here to respect the\n        # enctype specified by the form, i.e. force sending multipart\n        # content. Since Requests doesn't have yet a feature to choose\n        # enctype, we have to use tricks to make it behave as we want\n        # This code will be updated if Requests implements it.\n        if multipart and not files:\n            # Requests will switch to \"multipart/form-data\" only if\n            # files pass the `if files:` test, so in this case we use\n            # a modified dict that passes the if test even if empty.\n            class DictThatReturnsTrue(dict):\n                def __bool__(self):\n                    return True\n                __nonzero__ = __bool__\n\n            files = DictThatReturnsTrue()\n\n        return cls._get_request_kwargs(method, url, files=files, **kwargs)\n\n    def _request(self, form, url=None, **kwargs):\n        \"\"\"Extract input data from the form to pass to a Requests session.\"\"\"\n        request_kwargs = Browser.get_request_kwargs(form, url, **kwargs)\n        return self.session.request(**request_kwargs)\n\n    def submit(self, form, url=None, **kwargs):\n        \"\"\"Prepares and sends a form request.\n\n        NOTE: To submit a form with a :class:`StatefulBrowser` instance, it is\n        recommended to use :func:`StatefulBrowser.submit_selected` instead of\n        this method so that the browser state is correctly updated.\n\n        :param form: The filled-out form.\n        :param url: URL of the page the form is on. If the form action is a\n            relative path, then this must be specified.\n        :param \\\\*\\\\*kwargs: Arguments forwarded to `requests.Session.request\n            <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.\n            If `files`, `params` (with GET), or `data` (with POST) are\n            specified, they will be appended to by the contents of `form`.\n\n        :return: `requests.Response\n            <http://docs.python-requests.org/en/master/api/#requests.Response>`__\n            object with a *soup*-attribute added by :func:`add_soup`.\n        \"\"\"\n        if isinstance(form, Form):\n            form = form.form\n        response = self._request(form, url, **kwargs)\n        Browser.add_soup(response, self.soup_config)\n        return response\n\n    def launch_browser(self, soup):\n        \"\"\"Launch a browser to display a page, for debugging purposes.\n\n        :param: soup: Page contents to display, supplied as a bs4 soup object.\n        \"\"\"\n        with tempfile.NamedTemporaryFile(delete=False, suffix='.html') as file:\n            file.write(soup.encode())\n        webbrowser.open('file://' + file.name)\n\n    def close(self):\n        \"\"\"Close the current session, if still open.\"\"\"\n        if self.session is not None:\n            self.session.cookies.clear()\n            self.session.close()\n            self.session = None\n\n    def __del__(self):\n        self._finalize()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.close()\n", "import copy\nimport io\nimport warnings\n\nfrom bs4 import BeautifulSoup\n\nfrom .utils import LinkNotFoundError, is_multipart_file_upload\n\n\nclass InvalidFormMethod(LinkNotFoundError):\n    \"\"\"This exception is raised when a method of :class:`Form` is used\n    for an HTML element that is of the wrong type (or is malformed).\n    It is caught within :func:`Form.set` to perform element type deduction.\n\n    It is derived from :class:`LinkNotFoundError` so that a single base class\n    can be used to catch all exceptions specific to this module.\n    \"\"\"\n    pass\n\n\nclass Form:\n    \"\"\"Build a fillable form.\n\n    :param form: A bs4.element.Tag corresponding to an HTML form element.\n\n    The Form class is responsible for preparing HTML forms for submission.\n    It handles the following types of elements:\n    input (text, checkbox, radio), select, and textarea.\n\n    Each type is set by a method named after the type (e.g.\n    :func:`~Form.set_select`), and then there are convenience methods (e.g.\n    :func:`~Form.set`) that do type-deduction and set the value using the\n    appropriate method.\n\n    It also handles submit-type elements using :func:`~Form.choose_submit`.\n    \"\"\"\n\n    def __init__(self, form):\n        if form.name != 'form':\n            warnings.warn(\n                f\"Constructed a Form from a '{form.name}' instead of a 'form' \"\n                \" element. This may be an error in a future version of \"\n                \"MechanicalSoup.\", FutureWarning)\n\n        self.form = form\n        self._submit_chosen = False\n\n        # Aliases for backwards compatibility\n        # (Included specifically in __init__ to suppress them in Sphinx docs)\n        self.attach = self.set_input\n        self.input = self.set_input\n        self.textarea = self.set_textarea\n\n    def set_input(self, data):\n        \"\"\"Fill-in a set of fields in a form.\n\n        Example: filling-in a login/password form\n\n        .. code-block:: python\n\n           form.set_input({\"login\": username, \"password\": password})\n\n        This will find the input element named \"login\" and give it the\n        value ``username``, and the input element named \"password\" and\n        give it the value ``password``.\n        \"\"\"\n\n        for (name, value) in data.items():\n            i = self.form.find(\"input\", {\"name\": name})\n            if not i:\n                raise InvalidFormMethod(\"No input field named \" + name)\n            self._assert_valid_file_upload(i, value)\n            i[\"value\"] = value\n\n    def uncheck_all(self, name):\n        \"\"\"Remove the *checked*-attribute of all input elements with\n        a *name*-attribute given by ``name``.\n        \"\"\"\n        for option in self.form.find_all(\"input\", {\"name\": name}):\n            if \"checked\" in option.attrs:\n                del option.attrs[\"checked\"]\n\n    def check(self, data):\n        \"\"\"For backwards compatibility, this method handles checkboxes\n        and radio buttons in a single call. It will not uncheck any\n        checkboxes unless explicitly specified by ``data``, in contrast\n        with the default behavior of :func:`~Form.set_checkbox`.\n        \"\"\"\n        for (name, value) in data.items():\n            try:\n                self.set_checkbox({name: value}, uncheck_other_boxes=False)\n                continue\n            except InvalidFormMethod:\n                pass\n            try:\n                self.set_radio({name: value})\n                continue\n            except InvalidFormMethod:\n                pass\n            raise LinkNotFoundError(\"No input checkbox/radio named \" + name)\n\n    def set_checkbox(self, data, uncheck_other_boxes=True):\n        \"\"\"Set the *checked*-attribute of input elements of type \"checkbox\"\n        specified by ``data`` (i.e. check boxes).\n\n        :param data: Dict of ``{name: value, ...}``.\n            In the family of checkboxes whose *name*-attribute is ``name``,\n            check the box whose *value*-attribute is ``value``. All boxes in\n            the family can be checked (unchecked) if ``value`` is True (False).\n            To check multiple specific boxes, let ``value`` be a tuple or list.\n        :param uncheck_other_boxes: If True (default), before checking any\n            boxes specified by ``data``, uncheck the entire checkbox family.\n            Consider setting to False if some boxes are checked by default when\n            the HTML is served.\n        \"\"\"\n        for (name, value) in data.items():\n            # Case-insensitive search for type=checkbox\n            selector = 'input[type=\"checkbox\" i][name=\"{}\"]'.format(name)\n            checkboxes = self.form.select(selector)\n            if not checkboxes:\n                raise InvalidFormMethod(\"No input checkbox named \" + name)\n\n            # uncheck if requested\n            if uncheck_other_boxes:\n                self.uncheck_all(name)\n\n            # Wrap individual values (e.g. int, str) in a 1-element tuple.\n            if not isinstance(value, list) and not isinstance(value, tuple):\n                value = (value,)\n\n            # Check or uncheck one or more boxes\n            for choice in value:\n                choice_str = str(choice)  # Allow for example literal numbers\n                for checkbox in checkboxes:\n                    if checkbox.attrs.get(\"value\", \"on\") == choice_str:\n                        checkbox[\"checked\"] = \"\"\n                        break\n                    # Allow specifying True or False to check/uncheck\n                    elif choice is True:\n                        checkbox[\"checked\"] = \"\"\n                        break\n                    elif choice is False:\n                        if \"checked\" in checkbox.attrs:\n                            del checkbox.attrs[\"checked\"]\n                        break\n                else:\n                    raise LinkNotFoundError(\n                        \"No input checkbox named %s with choice %s\" %\n                        (name, choice)\n                    )\n\n    def set_radio(self, data):\n        \"\"\"Set the *checked*-attribute of input elements of type \"radio\"\n        specified by ``data`` (i.e. select radio buttons).\n\n        :param data: Dict of ``{name: value, ...}``.\n            In the family of radio buttons whose *name*-attribute is ``name``,\n            check the radio button whose *value*-attribute is ``value``.\n            Only one radio button in the family can be checked.\n        \"\"\"\n        for (name, value) in data.items():\n            # Case-insensitive search for type=radio\n            selector = 'input[type=\"radio\" i][name=\"{}\"]'.format(name)\n            radios = self.form.select(selector)\n            if not radios:\n                raise InvalidFormMethod(\"No input radio named \" + name)\n\n            # only one radio button can be checked\n            self.uncheck_all(name)\n\n            # Check the appropriate radio button (value cannot be a list/tuple)\n            for radio in radios:\n                if radio.attrs.get(\"value\", \"on\") == str(value):\n                    radio[\"checked\"] = \"\"\n                    break\n            else:\n                raise LinkNotFoundError(\n                    f\"No input radio named {name} with choice {value}\"\n                )\n\n    def set_textarea(self, data):\n        \"\"\"Set the *string*-attribute of the first textarea element\n        specified by ``data`` (i.e. set the text of a textarea).\n\n        :param data: Dict of ``{name: value, ...}``.\n            The textarea whose *name*-attribute is ``name`` will have\n            its *string*-attribute set to ``value``.\n        \"\"\"\n        for (name, value) in data.items():\n            t = self.form.find(\"textarea\", {\"name\": name})\n            if not t:\n                raise InvalidFormMethod(\"No textarea named \" + name)\n            t.string = value\n\n    def set_select(self, data):\n        \"\"\"Set the *selected*-attribute of the first option element\n        specified by ``data`` (i.e. select an option from a dropdown).\n\n        :param data: Dict of ``{name: value, ...}``.\n            Find the select element whose *name*-attribute is ``name``.\n            Then select from among its children the option element whose\n            *value*-attribute is ``value``. If no matching *value*-attribute\n            is found, this will search for an option whose text matches\n            ``value``. If the select element's *multiple*-attribute is set,\n            then ``value`` can be a list or tuple to select multiple options.\n        \"\"\"\n        for (name, value) in data.items():\n            select = self.form.find(\"select\", {\"name\": name})\n            if not select:\n                raise InvalidFormMethod(\"No select named \" + name)\n\n            # Deselect all options first\n            for option in select.find_all(\"option\"):\n                if \"selected\" in option.attrs:\n                    del option.attrs[\"selected\"]\n\n            # Wrap individual values in a 1-element tuple.\n            # If value is a list/tuple, select must be a <select multiple>.\n            if not isinstance(value, list) and not isinstance(value, tuple):\n                value = (value,)\n            elif \"multiple\" not in select.attrs:\n                raise LinkNotFoundError(\"Cannot select multiple options!\")\n\n            for choice in value:\n                option = select.find(\"option\", {\"value\": choice})\n\n                # try to find with text instead of value\n                if not option:\n                    option = select.find(\"option\", string=choice)\n\n                if not option:\n                    raise LinkNotFoundError(\n                        f'Option {choice} not found for select {name}'\n                    )\n\n                option.attrs[\"selected\"] = \"selected\"\n\n    def __setitem__(self, name, value):\n        \"\"\"Forwards arguments to :func:`~Form.set`. For example,\n        :code:`form[\"name\"] = \"value\"` calls :code:`form.set(\"name\", \"value\")`.\n        \"\"\"\n        return self.set(name, value)\n\n    def set(self, name, value, force=False):\n        \"\"\"Set a form element identified by ``name`` to a specified ``value``.\n        The type of element (input, textarea, select, ...) does not\n        need to be given; it is inferred by the following methods:\n        :func:`~Form.set_checkbox`,\n        :func:`~Form.set_radio`,\n        :func:`~Form.set_input`,\n        :func:`~Form.set_textarea`,\n        :func:`~Form.set_select`.\n        If none of these methods find a matching element, then if ``force``\n        is True, a new element (``<input type=\"text\" ...>``) will be\n        added using :func:`~Form.new_control`.\n\n        Example: filling-in a login/password form with EULA checkbox\n\n        .. code-block:: python\n\n            form.set(\"login\", username)\n            form.set(\"password\", password)\n            form.set(\"eula-checkbox\", True)\n\n        Example: uploading a file through a ``<input type=\"file\"\n        name=\"tagname\">`` field (provide an open file object,\n        and its content will be uploaded):\n\n        .. code-block:: python\n\n            form.set(\"tagname\", open(path_to_local_file, \"rb\"))\n\n        \"\"\"\n        for func in (\"checkbox\", \"radio\", \"input\", \"textarea\", \"select\"):\n            try:\n                getattr(self, \"set_\" + func)({name: value})\n                return\n            except InvalidFormMethod:\n                pass\n        if force:\n            self.new_control('text', name, value=value)\n            return\n        raise LinkNotFoundError(\"No valid element named \" + name)\n\n    def new_control(self, type, name, value, **kwargs):\n        \"\"\"Add a new input element to the form.\n\n        The arguments set the attributes of the new element.\n        \"\"\"\n        # Remove existing input-like elements with the same name\n        for tag in ('input', 'textarea', 'select'):\n            for old in self.form.find_all(tag, {'name': name}):\n                old.decompose()\n        # We don't have access to the original soup object (just the\n        # Tag), so we instantiate a new BeautifulSoup() to call\n        # new_tag(). We're only building the soup object, not parsing\n        # anything, so the parser doesn't matter. Specify the one\n        # included in Python to avoid having dependency issue.\n        control = BeautifulSoup(\"\", \"html.parser\").new_tag('input')\n        control['type'] = type\n        control['name'] = name\n        control['value'] = value\n        for k, v in kwargs.items():\n            control[k] = v\n        self._assert_valid_file_upload(control, value)\n        self.form.append(control)\n        return control\n\n    def choose_submit(self, submit):\n        \"\"\"Selects the input (or button) element to use for form submission.\n\n        :param submit: The :class:`bs4.element.Tag` (or just its\n            *name*-attribute) that identifies the submit element to use. If\n            ``None``, will choose the first valid submit element in the form,\n            if one exists. If ``False``, will not use any submit element;\n            this is useful for simulating AJAX requests, for example.\n\n        To simulate a normal web browser, only one submit element must be\n        sent. Therefore, this does not need to be called if there is only\n        one submit element in the form.\n\n        If the element is not found or if multiple elements match, raise a\n        :class:`LinkNotFoundError` exception.\n\n        Example: ::\n\n            browser = mechanicalsoup.StatefulBrowser()\n            browser.open(url)\n            form = browser.select_form()\n            form.choose_submit('form_name_attr')\n            browser.submit_selected()\n        \"\"\"\n        # Since choose_submit is destructive, it doesn't make sense to call\n        # this method twice unless no submit is specified.\n        if self._submit_chosen:\n            if submit is None:\n                return\n            else:\n                raise Exception('Submit already chosen. Cannot change submit!')\n\n        # All buttons NOT of type (button,reset) are valid submits\n        # Case-insensitive search for type=submit\n        inps = [i for i in self.form.select('input[type=\"submit\" i], button')\n                if i.get(\"type\", \"\").lower() not in ('button', 'reset')]\n\n        # If no submit specified, choose the first one\n        if submit is None and inps:\n            submit = inps[0]\n\n        found = False\n        for inp in inps:\n            if (inp.has_attr('name') and inp['name'] == submit):\n                if found:\n                    raise LinkNotFoundError(\n                        f\"Multiple submit elements match: {submit}\"\n                    )\n                found = True\n            elif inp == submit:\n                if found:\n                    # Ignore submit element since it is an exact\n                    # duplicate of the one we're looking at.\n                    del inp['name']\n                found = True\n            else:\n                # Delete any non-matching element's name so that it will be\n                # omitted from the submitted form data.\n                del inp['name']\n\n        if not found and submit is not None and submit is not False:\n            raise LinkNotFoundError(\n                f\"Specified submit element not found: {submit}\"\n            )\n        self._submit_chosen = True\n\n    def print_summary(self):\n        \"\"\"Print a summary of the form.\n\n        May help finding which fields need to be filled-in.\n        \"\"\"\n        for input in self.form.find_all(\n                (\"input\", \"textarea\", \"select\", \"button\")):\n            input_copy = copy.copy(input)\n            # Text between the opening tag and the closing tag often\n            # contains a lot of spaces that we don't want here.\n            for subtag in input_copy.find_all() + [input_copy]:\n                if subtag.string:\n                    subtag.string = subtag.string.strip()\n            print(input_copy)\n\n    def _assert_valid_file_upload(self, tag, value):\n        \"\"\"Raise an exception if a multipart file input is not an open file.\"\"\"\n        if (\n            is_multipart_file_upload(self.form, tag) and\n            not isinstance(value, io.IOBase)\n        ):\n            raise ValueError(\n                \"From v1.3.0 onwards, you must pass an open file object \"\n                'directly, e.g. `form[\"name\"] = open(\"/path/to/file\", \"rb\")`. '\n                \"This change is to remediate a security vulnerability where \"\n                \"a malicious web server could read arbitrary files from the \"\n                \"client (CVE-2023-34457).\"\n            )\n", "class LinkNotFoundError(Exception):\n    \"\"\"Exception raised when mechanicalsoup fails to find something.\n\n    This happens in situations like (non-exhaustive list):\n\n    * :func:`~mechanicalsoup.StatefulBrowser.find_link` is called, but\n      no link is found.\n\n    * The browser was configured with raise_on_404=True and a 404\n      error is triggered while browsing.\n\n    * The user tried to fill-in a field which doesn't exist in a form\n      (e.g. browser[\"name\"] = \"val\" with browser being a\n      StatefulBrowser).\n    \"\"\"\n    pass\n\n\ndef is_multipart_file_upload(form, tag):\n    return (\n        form.get(\"enctype\", \"\") == \"multipart/form-data\" and\n        tag.get(\"type\", \"\").lower() == \"file\"\n    )\n", "import os\nimport sys\nimport tempfile\n\nimport pytest\nimport setpath  # noqa:F401, must come before 'import mechanicalsoup'\nfrom bs4 import BeautifulSoup\nfrom requests.cookies import RequestsCookieJar\nfrom utils import mock_get, prepare_mock_browser\n\nimport mechanicalsoup\n\n\ndef test_submit_online(httpbin):\n    \"\"\"Complete and submit the pizza form at http://httpbin.org/forms/post \"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n\n    form.find(\"input\", {\"name\": \"custname\"})[\"value\"] = \"Philip J. Fry\"\n    # leave custtel blank without value\n    assert \"value\" not in form.find(\"input\", {\"name\": \"custtel\"}).attrs\n    form.find(\"input\", {\"name\": \"size\", \"value\": \"medium\"})[\"checked\"] = \"\"\n    form.find(\"input\", {\"name\": \"topping\", \"value\": \"cheese\"})[\"checked\"] = \"\"\n    form.find(\"input\", {\"name\": \"topping\", \"value\": \"onion\"})[\"checked\"] = \"\"\n    form.find(\"textarea\", {\"name\": \"comments\"}).insert(0, \"freezer\")\n\n    response = browser.submit(form, page.url)\n\n    # helpfully the form submits to http://httpbin.org/post which simply\n    # returns the request headers in json format\n    json = response.json()\n    data = json[\"form\"]\n    assert data[\"custname\"] == \"Philip J. Fry\"\n    assert data[\"custtel\"] == \"\"  # web browser submits \"\" for input left blank\n    assert data[\"size\"] == \"medium\"\n    assert data[\"topping\"] == [\"cheese\", \"onion\"]\n    assert data[\"comments\"] == \"freezer\"\n\n    assert json[\"headers\"][\"User-Agent\"].startswith('python-requests/')\n    assert 'MechanicalSoup' in json[\"headers\"][\"User-Agent\"]\n\n\ndef test_get_request_kwargs(httpbin):\n    \"\"\"Return kwargs without a submit\"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n    form.find(\"input\", {\"name\": \"custname\"})[\"value\"] = \"Philip J. Fry\"\n    request_kwargs = browser.get_request_kwargs(form, page.url)\n    assert \"method\" in request_kwargs\n    assert \"url\" in request_kwargs\n    assert \"data\" in request_kwargs\n    assert (\"custname\", \"Philip J. Fry\") in request_kwargs[\"data\"]\n\n\ndef test_get_request_kwargs_when_method_is_in_kwargs(httpbin):\n    \"\"\"Raise TypeError exception\"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n    kwargs = {\"method\": \"post\"}\n    with pytest.raises(TypeError):\n        browser.get_request_kwargs(form, page.url, **kwargs)\n\n\ndef test_get_request_kwargs_when_url_is_in_kwargs(httpbin):\n    \"\"\"Raise TypeError exception\"\"\"\n    browser = mechanicalsoup.Browser()\n    page = browser.get(httpbin + \"/forms/post\")\n    form = page.soup.form\n    kwargs = {\"url\": httpbin + \"/forms/post\"}\n    with pytest.raises(TypeError):\n        # pylint: disable=redundant-keyword-arg\n        browser.get_request_kwargs(form, page.url, **kwargs)\n\n\ndef test__request(httpbin):\n    form_html = f\"\"\"\n    <form method=\"post\" action=\"{httpbin.url}/post\">\n      <input name=\"customer\" value=\"Philip J. Fry\"/>\n      <input name=\"telephone\" value=\"555\"/>\n      <textarea name=\"comments\">freezer</textarea>\n      <fieldset>\n        <legend> Pizza Size </legend>\n        <p><input type=RADIO name=size value=\"small\">Small</p>\n        <p><input type=radiO name=size value=\"medium\" checked>Medium</p>\n        <p><input type=radio name=size value=\"large\">Large</p>\n      </fieldset>\n      <fieldset>\n        <legend> Pizza Toppings </legend>\n        <p><input type=CHECKBOX name=\"topping\" value=\"bacon\" checked>Bacon</p>\n        <p><input type=checkBox name=\"topping\" value=\"cheese\">Extra Cheese</p>\n        <p><input type=checkbox name=\"topping\" value=\"onion\" checked>Onion</p>\n        <p><input type=checkbox name=\"topping\" value=\"mushroom\">Mushroom</p>\n      </fieldset>\n      <select name=\"shape\">\n        <option value=\"round\">Round</option>\n        <option value=\"square\" selected>Square</option>\n      </select>\n    </form>\n    \"\"\"\n\n    form = BeautifulSoup(form_html, \"lxml\").form\n\n    browser = mechanicalsoup.Browser()\n    response = browser._request(form)\n\n    data = response.json()['form']\n    assert data[\"customer\"] == \"Philip J. Fry\"\n    assert data[\"telephone\"] == \"555\"\n    assert data[\"comments\"] == \"freezer\"\n    assert data[\"size\"] == \"medium\"\n    assert data[\"topping\"] == [\"bacon\", \"onion\"]\n    assert data[\"shape\"] == \"square\"\n\n    assert \"application/x-www-form-urlencoded\" in response.request.headers[\n        \"Content-Type\"]\n\n\nvalid_enctypes_file_submit = {\"multipart/form-data\": True,\n                              \"application/x-www-form-urlencoded\": False\n                              }\n\ndefault_enctype = \"application/x-www-form-urlencoded\"\n\n\n@pytest.mark.parametrize(\"file_field\", [\n  \"\"\"<input name=\"pic\" type=\"file\" />\"\"\",\n  \"\"])\n@pytest.mark.parametrize(\"submit_file\", [\n    True,\n    False\n])\n@pytest.mark.parametrize(\"enctype\", [\n  pytest.param(\"multipart/form-data\"),\n  pytest.param(\"application/x-www-form-urlencoded\"),\n  pytest.param(\"Invalid enctype\")\n])\ndef test_enctype_and_file_submit(httpbin, enctype, submit_file, file_field):\n    # test if enctype is respected when specified\n    # and if files are processed correctly\n    form_html = f\"\"\"\n    <form method=\"post\" action=\"{httpbin.url}/post\" enctype=\"{enctype}\">\n      <input name=\"in\" value=\"test\" />\n      {file_field}\n    </form>\n    \"\"\"\n    form = BeautifulSoup(form_html, \"lxml\").form\n\n    valid_enctype = (enctype in valid_enctypes_file_submit and\n                     valid_enctypes_file_submit[enctype])\n    expected_content = b\"\"  # default\n    if submit_file and file_field:\n        # create a temporary file for testing file upload\n        file_content = b\":-)\"\n        pic_filedescriptor, pic_path = tempfile.mkstemp()\n        pic_filename = os.path.basename(pic_path)\n        os.write(pic_filedescriptor, file_content)\n        os.close(pic_filedescriptor)\n        if valid_enctype:\n            # Correct encoding => send the content\n            expected_content = file_content\n        else:\n            # Encoding doesn't allow sending the content, we expect\n            # the filename as a normal text field.\n            expected_content = os.path.basename(pic_path.encode())\n        tag = form.find(\"input\", {\"name\": \"pic\"})\n        tag[\"value\"] = open(pic_path, \"rb\")\n\n    browser = mechanicalsoup.Browser()\n    response = browser._request(form)\n\n    if enctype not in valid_enctypes_file_submit:\n        expected_enctype = default_enctype\n    else:\n        expected_enctype = enctype\n    assert expected_enctype in response.request.headers[\"Content-Type\"]\n\n    resp = response.json()\n    assert resp[\"form\"][\"in\"] == \"test\"\n\n    found = False\n    found_in = None\n\n    for key, value in resp.items():\n        if value:\n            if \"pic\" in value:\n                content = value[\"pic\"].encode()\n                assert not found\n                assert key in (\"files\", \"form\")\n                found = True\n                found_in = key\n            if key == \"files\" and not valid_enctype:\n                assert not value\n\n    assert found == bool(file_field)\n    if file_field:\n        assert content == expected_content\n\n        if valid_enctype:\n            assert found_in == \"files\"\n            if submit_file:\n                assert (\"filename=\\\"\" + pic_filename + \"\\\"\"\n                        ).encode() in response.request.body\n            else:\n                assert b\"filename=\\\"\\\"\" in response.request.body\n        else:\n            assert found_in == \"form\"\n\n    if submit_file and file_field:\n        os.remove(pic_path)\n\n\ndef test__request_select_none(httpbin):\n    \"\"\"Make sure that a <select> with no options selected\n    submits the first option, as it does in a browser.\"\"\"\n    form_html = f\"\"\"\n    <form method=\"post\" action={httpbin.url}/post>\n      <select name=\"shape\">\n        <option value=\"round\">Round</option>\n        <option value=\"square\">Square</option>\n      </select>\n    </form>\"\"\"\n\n    form = BeautifulSoup(form_html, \"lxml\").form\n    browser = mechanicalsoup.Browser()\n    response = browser._request(form)\n    assert response.json()['form'] == {'shape': 'round'}\n\n\ndef test__request_disabled_attr(httpbin):\n    \"\"\"Make sure that disabled form controls are not submitted.\"\"\"\n    form_html = f\"\"\"\n    <form method=\"post\" action=\"{httpbin.url}/post\">\n      <input disabled name=\"nosubmit\" value=\"1\" />\n    </form>\"\"\"\n\n    browser = mechanicalsoup.Browser()\n    response = browser._request(BeautifulSoup(form_html, \"lxml\").form)\n    assert response.json()['form'] == {}\n\n\n@pytest.mark.parametrize(\"keyword\", [\n    pytest.param('method'),\n    pytest.param('url'),\n])\ndef test_request_keyword_error(keyword):\n    \"\"\"Make sure exception is raised if kwargs duplicates an arg.\"\"\"\n    form_html = \"<form></form>\"\n    browser = mechanicalsoup.Browser()\n    with pytest.raises(TypeError, match=\"multiple values for\"):\n        browser._request(BeautifulSoup(form_html, \"lxml\").form,\n                         'myurl', **{keyword: 'somevalue'})\n\n\ndef test_no_404(httpbin):\n    browser = mechanicalsoup.Browser()\n    resp = browser.get(httpbin + \"/nosuchpage\")\n    assert resp.status_code == 404\n\n\ndef test_404(httpbin):\n    browser = mechanicalsoup.Browser(raise_on_404=True)\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.get(httpbin + \"/nosuchpage\")\n    resp = browser.get(httpbin.url)\n    assert resp.status_code == 200\n\n\ndef test_set_cookiejar(httpbin):\n    \"\"\"Set cookies locally and test that they are received remotely.\"\"\"\n    # construct a phony cookiejar and attach it to the session\n    jar = RequestsCookieJar()\n    jar.set('field', 'value')\n    assert jar.get('field') == 'value'\n\n    browser = mechanicalsoup.Browser()\n    browser.set_cookiejar(jar)\n    resp = browser.get(httpbin + \"/cookies\")\n    assert resp.json() == {'cookies': {'field': 'value'}}\n\n\ndef test_get_cookiejar(httpbin):\n    \"\"\"Test that cookies set by the remote host update our session.\"\"\"\n    browser = mechanicalsoup.Browser()\n    resp = browser.get(httpbin + \"/cookies/set?k1=v1&k2=v2\")\n    assert resp.json() == {'cookies': {'k1': 'v1', 'k2': 'v2'}}\n\n    jar = browser.get_cookiejar()\n    assert jar.get('k1') == 'v1'\n    assert jar.get('k2') == 'v2'\n\n\ndef test_post(httpbin):\n    browser = mechanicalsoup.Browser()\n    data = {'color': 'blue', 'colorblind': 'True'}\n    resp = browser.post(httpbin + \"/post\", data)\n    assert resp.status_code == 200 and resp.json()['form'] == data\n\n\ndef test_put(httpbin):\n    browser = mechanicalsoup.Browser()\n    data = {'color': 'blue', 'colorblind': 'True'}\n    resp = browser.put(httpbin + \"/put\", data)\n    assert resp.status_code == 200 and resp.json()['form'] == data\n\n\n@pytest.mark.parametrize(\"http_html_expected_encoding\", [\n    pytest.param((None, 'utf-8', 'utf-8')),\n    pytest.param(('utf-8', 'utf-8', 'utf-8')),\n    pytest.param(('utf-8', None, 'utf-8')),\n    pytest.param(('utf-8', 'ISO-8859-1', 'utf-8')),\n])\ndef test_encoding(httpbin, http_html_expected_encoding):\n    http_encoding = http_html_expected_encoding[0]\n    html_encoding = http_html_expected_encoding[1]\n    expected_encoding = http_html_expected_encoding[2]\n\n    url = 'mock://encoding'\n    text = (\n        '<!doctype html>'\n        + '<html lang=\"fr\">'\n        + (\n            (\n                '<head><meta charset=\"'\n                + html_encoding\n                + '\"><title>Title\u00e9\u00e0\u00e8</title></head>'\n            ) if html_encoding\n            else ''\n        )\n        + '<body></body>'\n        + '</html>'\n    )\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(\n        adapter,\n        url=url,\n        reply=(\n            text.encode(http_encoding)\n            if http_encoding\n            else text.encode(\"utf-8\")\n        ),\n        content_type=(\n            'text/html'\n            + (\n                ';charset=' + http_encoding\n                if http_encoding\n                else ''\n            )\n        )\n    )\n    browser.open(url)\n    assert browser.page.original_encoding == expected_encoding\n\n\nif __name__ == '__main__':\n    pytest.main(sys.argv)\n", "import copy\nimport json\nimport os\nimport re\nimport sys\nimport tempfile\nimport webbrowser\n\nimport pytest\nimport setpath  # noqa:F401, must come before 'import mechanicalsoup'\nfrom bs4 import BeautifulSoup\nfrom utils import (mock_get, open_legacy_httpbin, prepare_mock_browser,\n                   setup_mock_browser)\n\nimport mechanicalsoup\nimport requests\n\n\ndef test_request_forward():\n    data = [('var1', 'val1'), ('var2', 'val2')]\n    browser, url = setup_mock_browser(expected_post=data)\n    r = browser.request('POST', url + '/post', data=data)\n    assert r.text == 'Success!'\n\n\ndef test_properties():\n    \"\"\"Check that properties return the same value as the getter.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<form></form>', url=\"http://example.com\")\n    assert browser.page == browser.get_current_page()\n    assert browser.page is not None\n    assert browser.url == browser.get_url()\n    assert browser.url is not None\n    browser.select_form()\n    assert browser.form == browser.get_current_form()\n    assert browser.form is not None\n\n\ndef test_get_selected_form_unselected():\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<form></form>')\n    with pytest.raises(AttributeError, match=\"No form has been selected yet.\"):\n        browser.form\n    assert browser.get_current_form() is None\n\n\ndef test_submit_online(httpbin):\n    \"\"\"Complete and submit the pizza form at http://httpbin.org/forms/post \"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.set_user_agent('testing MechanicalSoup')\n    browser.open(httpbin.url)\n    for link in browser.links():\n        if link[\"href\"] == \"/\":\n            browser.follow_link(link)\n            break\n    browser.follow_link(\"forms/post\")\n    assert browser.url == httpbin + \"/forms/post\"\n    browser.select_form(\"form\")\n    browser[\"custname\"] = \"Customer Name Here\"\n    browser[\"size\"] = \"medium\"\n    browser[\"topping\"] = (\"cheese\", \"bacon\")\n    # Change our mind to make sure old boxes are unticked\n    browser[\"topping\"] = (\"cheese\", \"onion\")\n    browser[\"comments\"] = \"Some comment here\"\n    browser.form.set(\"nosuchfield\", \"new value\", True)\n    response = browser.submit_selected()\n    json = response.json()\n    data = json[\"form\"]\n    assert data[\"custname\"] == \"Customer Name Here\"\n    assert data[\"custtel\"] == \"\"  # web browser submits \"\" for input left blank\n    assert data[\"size\"] == \"medium\"\n    assert set(data[\"topping\"]) == {\"cheese\", \"onion\"}\n    assert data[\"comments\"] == \"Some comment here\"\n    assert data[\"nosuchfield\"] == \"new value\"\n\n    assert json[\"headers\"][\"User-Agent\"] == 'testing MechanicalSoup'\n    # Ensure we haven't blown away any regular headers\n    expected_headers = ('Content-Length', 'Host', 'Content-Type', 'Connection',\n                        'Accept', 'User-Agent', 'Accept-Encoding')\n    assert set(expected_headers).issubset(json[\"headers\"].keys())\n\n\ndef test_no_404(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    resp = browser.open(httpbin + \"/nosuchpage\")\n    assert resp.status_code == 404\n\n\ndef test_404(httpbin):\n    browser = mechanicalsoup.StatefulBrowser(raise_on_404=True)\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.open(httpbin + \"/nosuchpage\")\n    resp = browser.open(httpbin.url)\n    assert resp.status_code == 200\n\n\ndef test_user_agent(httpbin):\n    browser = mechanicalsoup.StatefulBrowser(user_agent='007')\n    resp = browser.open(httpbin + \"/user-agent\")\n    assert resp.json() == {'user-agent': '007'}\n\n\ndef test_open_relative(httpbin):\n    # Open an arbitrary httpbin page to set the current URL\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open(httpbin + \"/html\")\n\n    # Open a relative page and make sure remote host and browser agree on URL\n    resp = browser.open_relative(\"/get\")\n    assert resp.json()['url'] == httpbin + \"/get\"\n    assert browser.url == httpbin + \"/get\"\n\n    # Test passing additional kwargs to the session\n    resp = browser.open_relative(\"/basic-auth/me/123\", auth=('me', '123'))\n    assert browser.url == httpbin + \"/basic-auth/me/123\"\n    assert resp.json() == {\"authenticated\": True, \"user\": \"me\"}\n\n\ndef test_links():\n    browser = mechanicalsoup.StatefulBrowser()\n    html = '''<a class=\"bluelink\" href=\"/blue\" id=\"blue_link\">A Blue Link</a>\n              <a class=\"redlink\" href=\"/red\" id=\"red_link\">A Red Link</a>'''\n    expected = [BeautifulSoup(html, \"lxml\").a]\n    browser.open_fake_page(html)\n\n    # Test StatefulBrowser.links url_regex argument\n    assert browser.links(url_regex=\"bl\") == expected\n    assert browser.links(url_regex=\"bluish\") == []\n\n    # Test StatefulBrowser.links link_text argument\n    assert browser.links(link_text=\"A Blue Link\") == expected\n    assert browser.links(link_text=\"Blue\") == []\n\n    # Test StatefulBrowser.links kwargs passed to BeautifulSoup.find_all\n    assert browser.links(string=re.compile('Blue')) == expected\n    assert browser.links(class_=\"bluelink\") == expected\n    assert browser.links(id=\"blue_link\") == expected\n    assert browser.links(id=\"blue\") == []\n\n    # Test returning a non-singleton\n    two_links = browser.links(id=re.compile('_link'))\n    assert len(two_links) == 2\n    assert two_links == BeautifulSoup(html, \"lxml\").find_all('a')\n\n\n@pytest.mark.parametrize(\"expected_post\", [\n    pytest.param(\n        [\n            ('text', 'Setting some text!'),\n            ('comment', 'Selecting an input submit'),\n            ('diff', 'Review Changes'),\n        ], id='input'),\n    pytest.param(\n        [\n            ('text', '= Heading =\\n\\nNew page here!\\n'),\n            ('comment', 'Selecting a button submit'),\n            ('cancel', 'Cancel'),\n        ], id='button'),\n])\ndef test_submit_btnName(expected_post):\n    '''Tests that the btnName argument chooses the submit button.'''\n    browser, url = setup_mock_browser(expected_post=expected_post)\n    browser.open(url)\n    browser.select_form('#choose-submit-form')\n    browser['text'] = dict(expected_post)['text']\n    browser['comment'] = dict(expected_post)['comment']\n    initial_state = browser._StatefulBrowser__state\n    res = browser.submit_selected(btnName=expected_post[2][0])\n    assert res.status_code == 200 and res.text == 'Success!'\n    assert initial_state != browser._StatefulBrowser__state\n\n\n@pytest.mark.parametrize(\"expected_post\", [\n    pytest.param(\n        [\n            ('text', 'Setting some text!'),\n            ('comment', 'Selecting an input submit'),\n        ], id='input'),\n    pytest.param(\n        [\n            ('text', '= Heading =\\n\\nNew page here!\\n'),\n            ('comment', 'Selecting a button submit'),\n        ], id='button'),\n])\ndef test_submit_no_btn(expected_post):\n    '''Tests that no submit inputs are posted when btnName=False.'''\n    browser, url = setup_mock_browser(expected_post=expected_post)\n    browser.open(url)\n    browser.select_form('#choose-submit-form')\n    browser['text'] = dict(expected_post)['text']\n    browser['comment'] = dict(expected_post)['comment']\n    initial_state = browser._StatefulBrowser__state\n    res = browser.submit_selected(btnName=False)\n    assert res.status_code == 200 and res.text == 'Success!'\n    assert initial_state != browser._StatefulBrowser__state\n\n\ndef test_submit_dont_modify_kwargs():\n    \"\"\"Test that submit_selected() doesn't modify the caller's passed-in\n    kwargs, for example when adding a Referer header.\n    \"\"\"\n    kwargs = {'headers': {'Content-Type': 'text/html'}}\n    saved_kwargs = copy.deepcopy(kwargs)\n\n    browser, url = setup_mock_browser(expected_post=[], text='<form></form>')\n    browser.open(url)\n    browser.select_form()\n    browser.submit_selected(**kwargs)\n\n    assert kwargs == saved_kwargs\n\n\ndef test_submit_dont_update_state():\n    expected_post = [\n            ('text', 'Bananas are good.'),\n            ('preview', 'Preview Page')]\n    browser, url = setup_mock_browser(expected_post=expected_post)\n    browser.open(url)\n    browser.select_form('#choose-submit-form')\n    browser['text'] = dict(expected_post)['text']\n    initial_state = browser._StatefulBrowser__state\n    res = browser.submit_selected(update_state=False)\n    assert res.status_code == 200 and res.text == 'Success!'\n    assert initial_state == browser._StatefulBrowser__state\n\n\ndef test_get_set_debug():\n    browser = mechanicalsoup.StatefulBrowser()\n    # Debug mode is off by default\n    assert not browser.get_debug()\n    browser.set_debug(True)\n    assert browser.get_debug()\n\n\ndef test_list_links(capsys):\n    # capsys is a pytest fixture that allows us to inspect the std{err,out}\n    browser = mechanicalsoup.StatefulBrowser()\n    links = '''\n     <a href=\"/link1\">Link #1</a>\n     <a href=\"/link2\" id=\"link2\"> Link #2</a>\n'''\n    browser.open_fake_page(f'<html>{links}</html>')\n    browser.list_links()\n    out, err = capsys.readouterr()\n    expected = f'Links in the current page:{links}'\n    assert out == expected\n\n\ndef test_launch_browser(mocker):\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.set_debug(True)\n    browser.open_fake_page('<html></html>')\n    mocker.patch('webbrowser.open')\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.follow_link('nosuchlink')\n    # mock.assert_called_once() not available on some versions :-(\n    assert webbrowser.open.call_count == 1\n    mocker.resetall()\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.select_form('nosuchlink')\n    # mock.assert_called_once() not available on some versions :-(\n    assert webbrowser.open.call_count == 1\n\n\ndef test_find_link():\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<html></html>')\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.find_link('nosuchlink')\n\n\ndef test_verbose(capsys):\n    '''Tests that the btnName argument chooses the submit button.'''\n    browser, url = setup_mock_browser()\n    browser.open(url)\n    out, err = capsys.readouterr()\n    assert out == \"\"\n    assert err == \"\"\n    assert browser.get_verbose() == 0\n    browser.set_verbose(1)\n    browser.open(url)\n    out, err = capsys.readouterr()\n    assert out == \".\"\n    assert err == \"\"\n    assert browser.get_verbose() == 1\n    browser.set_verbose(2)\n    browser.open(url)\n    out, err = capsys.readouterr()\n    assert out == \"mock://form.com\\n\"\n    assert err == \"\"\n    assert browser.get_verbose() == 2\n\n\ndef test_new_control(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open(httpbin + \"/forms/post\")\n    browser.select_form(\"form\")\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        # The control doesn't exist, yet.\n        browser[\"temperature\"] = \"cold\"\n    browser[\"size\"] = \"large\"  # Existing radio\n    browser[\"comments\"] = \"This is a comment\"  # Existing textarea\n    browser.new_control(\"text\", \"temperature\", \"warm\")\n    browser.new_control(\"textarea\", \"size\", \"Sooo big !\")\n    browser.new_control(\"text\", \"comments\", \"This is an override comment\")\n    fake_select = BeautifulSoup(\"\", \"html.parser\").new_tag('select')\n    fake_select[\"name\"] = \"foo\"\n    browser.form.form.append(fake_select)\n    browser.new_control(\"checkbox\", \"foo\", \"valval\", checked=\"checked\")\n    tag = browser.form.form.find(\"input\", {\"name\": \"foo\"})\n    assert tag.attrs[\"checked\"] == \"checked\"\n    browser[\"temperature\"] = \"hot\"\n    response = browser.submit_selected()\n    json = response.json()\n    data = json[\"form\"]\n    print(data)\n    assert data[\"temperature\"] == \"hot\"\n    assert data[\"size\"] == \"Sooo big !\"\n    assert data[\"comments\"] == \"This is an override comment\"\n    assert data[\"foo\"] == \"valval\"\n\n\nsubmit_form_noaction = '''\n<html>\n  <body>\n    <form id=\"choose-submit-form\">\n      <input type=\"text\" name=\"text1\" value=\"someValue1\" />\n      <input type=\"text\" name=\"text2\" value=\"someValue2\" />\n      <input type=\"submit\" name=\"save\" />\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_form_noaction():\n    browser, url = setup_mock_browser()\n    browser.open_fake_page(submit_form_noaction)\n    browser.select_form('#choose-submit-form')\n    with pytest.raises(ValueError, match=\"no URL to submit to\"):\n        browser.submit_selected()\n\n\nsubmit_form_noname = '''\n<html>\n  <body>\n    <form id=\"choose-submit-form\" method=\"post\" action=\"mock://form.com/post\">\n      <textarea>Value</textarea> <!-- no name -->\n      <select> <!-- no name -->\n        <option value=\"tofu\" selected=\"selected\">Tofu Stir Fry</option>\n        <option value=\"curry\">Red Curry</option>\n        <option value=\"tempeh\">Tempeh Tacos</option>\n      </select>\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_form_noname():\n    browser, url = setup_mock_browser(expected_post=[])\n    browser.open_fake_page(submit_form_noname, url=url)\n    browser.select_form('#choose-submit-form')\n    response = browser.submit_selected()\n    assert response.status_code == 200 and response.text == 'Success!'\n\n\nsubmit_form_multiple = '''\n<html>\n  <body>\n    <form id=\"choose-submit-form\" method=\"post\" action=\"mock://form.com/post\">\n      <select name=\"foo\" multiple>\n        <option value=\"tofu\" selected=\"selected\">Tofu Stir Fry</option>\n        <option value=\"curry\">Red Curry</option>\n        <option value=\"tempeh\" selected=\"selected\">Tempeh Tacos</option>\n      </select>\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_form_multiple():\n    browser, url = setup_mock_browser(expected_post=[('foo', 'tofu'),\n                                                     ('foo', 'tempeh')])\n    browser.open_fake_page(submit_form_multiple, url=url)\n    browser.select_form('#choose-submit-form')\n    response = browser.submit_selected()\n    assert response.status_code == 200 and response.text == 'Success!'\n\n\ndef test_upload_file(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    url = httpbin + \"/post\"\n    file_input_form = f\"\"\"\n    <form method=\"post\" action=\"{url}\" enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"first\" />\n    </form>\n    \"\"\"\n\n    # Create two temporary files to upload\n    def make_file(content):\n        path = tempfile.mkstemp()[1]\n        with open(path, \"w\") as fd:\n            fd.write(content)\n        return path\n    path1 = make_file(\"first file content\")\n    path2 = make_file(\"second file content\")\n\n    value1 = open(path1, \"rb\")\n    value2 = open(path2, \"rb\")\n\n    browser.open_fake_page(file_input_form)\n    browser.select_form()\n\n    # Test filling an existing input and creating a new input\n    browser[\"first\"] = value1\n    browser.new_control(\"file\", \"second\", value2)\n\n    response = browser.submit_selected()\n    files = response.json()[\"files\"]\n    assert files[\"first\"] == \"first file content\"\n    assert files[\"second\"] == \"second file content\"\n\n\ndef test_upload_file_with_malicious_default(httpbin):\n    \"\"\"Check for CVE-2023-34457 by setting the form input value directly to a\n    file that the user does not explicitly consent to upload, as a malicious\n    server might do.\n    \"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    sensitive_path = tempfile.mkstemp()[1]\n    with open(sensitive_path, \"w\") as fd:\n        fd.write(\"Some sensitive information\")\n    url = httpbin + \"/post\"\n    malicious_html = f\"\"\"\n    <form method=\"post\" action=\"{url}\" enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"malicious\" value=\"{sensitive_path}\" />\n    </form>\n    \"\"\"\n    browser.open_fake_page(malicious_html)\n    browser.select_form()\n    response = browser.submit_selected()\n    assert response.json()[\"files\"] == {\"malicious\": \"\"}\n\n\ndef test_upload_file_raise_on_string_input():\n    \"\"\"Check for use of the file upload API that was modified to remediate\n    CVE-2023-34457. Users must now open files manually to upload them.\n    \"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    file_input_form = \"\"\"\n    <form enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"upload\" />\n    </form>\n    \"\"\"\n    browser.open_fake_page(file_input_form)\n    browser.select_form()\n    with pytest.raises(ValueError, match=\"CVE-2023-34457\"):\n        browser[\"upload\"] = \"/path/to/file\"\n    with pytest.raises(ValueError, match=\"CVE-2023-34457\"):\n        browser.new_control(\"file\", \"upload2\", \"/path/to/file\")\n\n\ndef test_with():\n    \"\"\"Test that __enter__/__exit__ properly create/close the browser.\"\"\"\n    with mechanicalsoup.StatefulBrowser() as browser:\n        assert browser.session is not None\n    assert browser.session is None\n\n\ndef test_select_form_nr():\n    \"\"\"Test the nr option of select_form.\"\"\"\n    forms = \"\"\"<form id=\"a\"></form><form id=\"b\"></form><form id=\"c\"></form>\"\"\"\n    with mechanicalsoup.StatefulBrowser() as browser:\n        browser.open_fake_page(forms)\n        form = browser.select_form()\n        assert form.form['id'] == \"a\"\n        form = browser.select_form(nr=1)\n        assert form.form['id'] == \"b\"\n        form = browser.select_form(nr=2)\n        assert form.form['id'] == \"c\"\n        with pytest.raises(mechanicalsoup.LinkNotFoundError):\n            browser.select_form(nr=3)\n\n\ndef test_select_form_tag_object():\n    \"\"\"Test tag object as selector parameter type\"\"\"\n    forms = \"\"\"<form id=\"a\"></form><form id=\"b\"></form><p></p>\"\"\"\n    soup = BeautifulSoup(forms, \"lxml\")\n    with mechanicalsoup.StatefulBrowser() as browser:\n        browser.open_fake_page(forms)\n        form = browser.select_form(soup.find(\"form\", {\"id\": \"b\"}))\n        assert form.form['id'] == \"b\"\n        with pytest.raises(mechanicalsoup.LinkNotFoundError):\n            browser.select_form(soup.find(\"p\"))\n\n\ndef test_select_form_associated_elements():\n    \"\"\"Test associated elements outside the form tag\"\"\"\n    forms = \"\"\"<form id=\"a\"><input><textarea></form><input form=\"a\">\n               <textarea form=\"a\"/><input form=\"b\">\n               <form id=\"ab\" action=\"/test.php\"><input></form>\n               <textarea form=\"ab\"></textarea>\n            \"\"\"\n    with mechanicalsoup.StatefulBrowser() as browser:\n        browser.open_fake_page(forms)\n        elements_form_a = set([\n            \"<input/>\", \"<textarea></textarea>\",\n            '<input form=\"a\"/>', '<textarea form=\"a\"></textarea>'])\n        elements_form_ab = set([\"<input/>\", '<textarea form=\"ab\"></textarea>'])\n        form_by_str = browser.select_form(\"#a\")\n        form_by_tag = browser.select_form(browser.page.find(\"form\", id='a'))\n        form_by_css = browser.select_form(\"form[action$='.php']\")\n        assert set([str(element) for element in form_by_str.form.find_all((\n            \"input\", \"textarea\"))]) == elements_form_a\n        assert set([str(element) for element in form_by_tag.form.find_all((\n            \"input\", \"textarea\"))]) == elements_form_a\n        assert set([str(element) for element in form_by_css.form.find_all((\n            \"input\", \"textarea\"))]) == elements_form_ab\n\n\ndef test_referer_follow_link(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    start_url = browser.url\n    response = browser.follow_link(\"/headers\")\n    referer = response.json()[\"headers\"][\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    expected_ref = re.sub('/*$', '', start_url)\n    assert actual_ref == expected_ref\n\n\nsubmit_form_headers = '''\n<html>\n  <body>\n    <form method=\"get\" action=\"{}\" id=\"choose-submit-form\">\n      <input type=\"text\" name=\"text1\" value=\"someValue1\" />\n      <input type=\"text\" name=\"text2\" value=\"someValue2\" />\n      <input type=\"submit\" name=\"save\" />\n    </form>\n  </body>\n</html>\n'''\n\n\ndef test_referer_submit(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = \"https://example.com/my-referer\"\n    page = submit_form_headers.format(httpbin.url + \"/headers\")\n    browser.open_fake_page(page, url=ref)\n    browser.select_form()\n    response = browser.submit_selected()\n    headers = response.json()[\"headers\"]\n    referer = headers[\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    assert actual_ref == ref\n\n\n@pytest.mark.parametrize(\"referer_header\", [\"Referer\", \"referer\"])\ndef test_referer_submit_override(httpbin, referer_header):\n    \"\"\"Ensure the caller can override the Referer header that\n    mechanicalsoup would normally add. Because headers are case insensitive,\n    test with both 'Referer' and 'referer'.\n    \"\"\"\n\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = \"https://example.com/my-referer\"\n    ref_override = \"https://example.com/override\"\n    page = submit_form_headers.format(httpbin.url + \"/headers\")\n    browser.open_fake_page(page, url=ref)\n    browser.select_form()\n    response = browser.submit_selected(headers={referer_header: ref_override})\n    headers = response.json()[\"headers\"]\n    referer = headers[\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    assert actual_ref == ref_override\n\n\ndef test_referer_submit_headers(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = \"https://example.com/my-referer\"\n    page = submit_form_headers.format(httpbin.url + \"/headers\")\n    browser.open_fake_page(page, url=ref)\n    browser.select_form()\n    response = browser.submit_selected(\n        headers={'X-Test-Header': 'x-test-value'})\n    headers = response.json()[\"headers\"]\n    referer = headers[\"Referer\"]\n    actual_ref = re.sub('/*$', '', referer)\n    assert actual_ref == ref\n    assert headers['X-Test-Header'] == 'x-test-value'\n\n\n@pytest.mark.parametrize('expected, kwargs', [\n    pytest.param('/foo', {}, id='none'),\n    pytest.param('/get', {'string': 'Link'}, id='string'),\n    pytest.param('/get', {'url_regex': 'get'}, id='regex'),\n])\ndef test_follow_link_arg(httpbin, expected, kwargs):\n    browser = mechanicalsoup.StatefulBrowser()\n    html = '<a href=\"/foo\">Bar</a><a href=\"/get\">Link</a>'\n    browser.open_fake_page(html, httpbin.url)\n    browser.follow_link(bs4_kwargs=kwargs)\n    assert browser.url == httpbin + expected\n\n\ndef test_follow_link_excess(httpbin):\n    \"\"\"Ensure that excess args are passed to BeautifulSoup\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    html = '<a href=\"/foo\">Bar</a><a href=\"/get\">Link</a>'\n    browser.open_fake_page(html, httpbin.url)\n    browser.follow_link(url_regex='get')\n    assert browser.url == httpbin + '/get'\n\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<a href=\"/get\">Link</a>', httpbin.url)\n    with pytest.raises(ValueError, match=\"link parameter cannot be .*\"):\n        browser.follow_link('foo', url_regex='bar')\n\n\ndef test_follow_link_ua(httpbin):\n    \"\"\"Tests passing requests parameters to follow_link() by\n    setting the User-Agent field.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    # html = '<a href=\"/foo\">Bar</a><a href=\"/get\">Link</a>'\n    # browser.open_fake_page(html, httpbin.url)\n    open_legacy_httpbin(browser, httpbin)\n    bs4_kwargs = {'url_regex': 'user-agent'}\n    requests_kwargs = {'headers': {\"User-Agent\": '007'}}\n    resp = browser.follow_link(bs4_kwargs=bs4_kwargs,\n                               requests_kwargs=requests_kwargs)\n    assert browser.url == httpbin + '/user-agent'\n    assert resp.json() == {'user-agent': '007'}\n    assert resp.request.headers['user-agent'] == '007'\n\n\ndef test_link_arg_multiregex(httpbin):\n    browser = mechanicalsoup.StatefulBrowser()\n    browser.open_fake_page('<a href=\"/get\">Link</a>', httpbin.url)\n    with pytest.raises(ValueError, match=\"link parameter cannot be .*\"):\n        browser.follow_link('foo', bs4_kwargs={'url_regex': 'bar'})\n\n\ndef file_get_contents(filename):\n    with open(filename, \"rb\") as fd:\n        return fd.read()\n\n\ndef test_download_link(httpbin):\n    \"\"\"Test downloading the contents of a link to file.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    tmpdir = tempfile.mkdtemp()\n    tmpfile = tmpdir + '/nosuchfile.png'\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(file=tmpfile, link='image/png')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was downloaded\n    assert os.path.isfile(tmpfile)\n    assert file_get_contents(tmpfile) == response.content\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(link='image/png')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile_bs4(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(bs4_kwargs={'url_regex': 'image.png'})\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile_excess(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link(url_regex='image.png')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_nofile_ua(httpbin):\n    \"\"\"Test downloading the contents of a link without saving it.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    current_url = browser.url\n    current_page = browser.page\n    requests_kwargs = {'headers': {\"User-Agent\": '007'}}\n    response = browser.download_link(link='image/png',\n                                     requests_kwargs=requests_kwargs)\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n    # Check that we actually set the User-agent outbound\n    assert response.request.headers['user-agent'] == '007'\n\n\ndef test_download_link_to_existing_file(httpbin):\n    \"\"\"Test downloading the contents of a link to an existing file.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    open_legacy_httpbin(browser, httpbin)\n    tmpdir = tempfile.mkdtemp()\n    tmpfile = tmpdir + '/existing.png'\n    with open(tmpfile, \"w\") as fd:\n        fd.write(\"initial content\")\n    current_url = browser.url\n    current_page = browser.page\n    response = browser.download_link('image/png', tmpfile)\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was downloaded\n    assert os.path.isfile(tmpfile)\n    assert file_get_contents(tmpfile) == response.content\n    # Check that we actually downloaded a PNG file\n    assert response.content[:4] == b'\\x89PNG'\n\n\ndef test_download_link_404(httpbin):\n    \"\"\"Test downloading the contents of a broken link.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser(raise_on_404=True)\n    browser.open_fake_page('<a href=\"/no-such-page-404\">Link</a>',\n                           url=httpbin.url)\n    tmpdir = tempfile.mkdtemp()\n    tmpfile = tmpdir + '/nosuchfile.txt'\n    current_url = browser.url\n    current_page = browser.page\n    with pytest.raises(mechanicalsoup.LinkNotFoundError):\n        browser.download_link(file=tmpfile, link_text='Link')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was not downloaded\n    assert not os.path.exists(tmpfile)\n\n\ndef test_download_link_referer(httpbin):\n    \"\"\"Test downloading the contents of a link to file.\"\"\"\n    browser = mechanicalsoup.StatefulBrowser()\n    ref = httpbin + \"/my-referer\"\n    browser.open_fake_page('<a href=\"/headers\">Link</a>',\n                           url=ref)\n    tmpfile = tempfile.NamedTemporaryFile()\n    current_url = browser.url\n    current_page = browser.page\n    browser.download_link(file=tmpfile.name, link_text='Link')\n\n    # Check that the browser state has not changed\n    assert browser.url == current_url\n    assert browser.page == current_page\n\n    # Check that the file was downloaded\n    with open(tmpfile.name) as fd:\n        json_data = json.load(fd)\n    headers = json_data[\"headers\"]\n    assert headers[\"Referer\"] == ref\n\n\ndef test_refresh_open():\n    url = 'mock://example.com'\n    initial_page = BeautifulSoup('<p>Fake empty page</p>', 'lxml')\n    reload_page = BeautifulSoup('<p>Fake reloaded page</p>', 'lxml')\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(adapter, url=url, reply=str(initial_page))\n    browser.open(url)\n    mock_get(adapter, url=url, reply=str(reload_page),\n             additional_matcher=lambda r: 'Referer' not in r.headers)\n\n    browser.refresh()\n\n    assert browser.url == url\n    assert browser.page == reload_page\n\n\ndef test_refresh_follow_link():\n    url = 'mock://example.com'\n    follow_url = 'mock://example.com/followed'\n    initial_content = f'<a href=\"{follow_url}\">Link</a>'\n    initial_page = BeautifulSoup(initial_content, 'lxml')\n    reload_page = BeautifulSoup('<p>Fake reloaded page</p>', 'lxml')\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(adapter, url=url, reply=str(initial_page))\n    mock_get(adapter, url=follow_url, reply=str(initial_page))\n    browser.open(url)\n    browser.follow_link()\n    refer_header = {'Referer': url}\n    mock_get(adapter, url=follow_url, reply=str(reload_page),\n             request_headers=refer_header)\n\n    browser.refresh()\n\n    assert browser.url == follow_url\n    assert browser.page == reload_page\n\n\ndef test_refresh_form_not_retained():\n    url = 'mock://example.com'\n    initial_content = '<form>Here comes the form</form>'\n    initial_page = BeautifulSoup(initial_content, 'lxml')\n    reload_page = BeautifulSoup('<p>Fake reloaded page</p>', 'lxml')\n\n    browser, adapter = prepare_mock_browser()\n    mock_get(adapter, url=url, reply=str(initial_page))\n    browser.open(url)\n    browser.select_form()\n    mock_get(adapter, url=url, reply=str(reload_page),\n             additional_matcher=lambda r: 'Referer' not in r.headers)\n\n    browser.refresh()\n\n    assert browser.url == url\n    assert browser.page == reload_page\n    with pytest.raises(AttributeError, match=\"No form has been selected yet.\"):\n        browser.form\n\n\ndef test_refresh_error():\n    browser = mechanicalsoup.StatefulBrowser()\n\n    # Test no page\n    with pytest.raises(ValueError):\n        browser.refresh()\n\n    # Test fake page\n    with pytest.raises(ValueError):\n        browser.open_fake_page('<p>Fake empty page</p>', url='http://fake.com')\n        browser.refresh()\n\n\ndef test_requests_session_and_cookies(httpbin):\n    \"\"\"Check that the session object passed to the constructor of\n    StatefulBrowser is actually taken into account.\"\"\"\n    s = requests.Session()\n    requests.utils.add_dict_to_cookiejar(s.cookies, {'key1': 'val1'})\n    browser = mechanicalsoup.StatefulBrowser(session=s)\n    resp = browser.get(httpbin + \"/cookies\")\n    assert resp.json() == {'cookies': {'key1': 'val1'}}\n\n\nif __name__ == '__main__':\n    pytest.main(sys.argv)\n"], "filenames": ["mechanicalsoup/browser.py", "mechanicalsoup/form.py", "mechanicalsoup/utils.py", "tests/test_browser.py", "tests/test_stateful_browser.py"], "buggy_code_start_loc": [0, 1, 16, 167, 394], "buggy_code_end_loc": [242, 385, 16, 169, 417], "fixing_code_start_loc": [1, 2, 17, 167, 394], "fixing_code_end_loc": [246, 403, 24, 170, 463], "type": "CWE-20", "message": "MechanicalSoup is a Python library for automating interaction with websites. Starting in version 0.2.0 and prior to version 1.3.0, a malicious web server can read arbitrary files on the client using a `<input type=\"file\" ...>` inside HTML form. All users of MechanicalSoup's form submission are affected, unless they took very specific (and manual) steps to reset HTML form field values. Version 1.3.0 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-34457", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-05T20:15:10.343", "lastModified": "2023-08-03T15:15:24.573", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "MechanicalSoup is a Python library for automating interaction with websites. Starting in version 0.2.0 and prior to version 1.3.0, a malicious web server can read arbitrary files on the client using a `<input type=\"file\" ...>` inside HTML form. All users of MechanicalSoup's form submission are affected, unless they took very specific (and manual) steps to reset HTML form field values. Version 1.3.0 contains a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mechanicalsoup_project:mechanicalsoup:*:*:*:*:*:python:*:*", "versionEndExcluding": "1.3.0", "matchCriteriaId": "1F95051A-887C-4851-9127-7088A48E823D"}]}]}], "references": [{"url": "https://github.com/MechanicalSoup/MechanicalSoup/commit/d57c4a269bba3b9a0c5bfa20292955b849006d9e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/MechanicalSoup/MechanicalSoup/releases/tag/v1.3.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/MechanicalSoup/MechanicalSoup/security/advisories/GHSA-x456-3ccm-m6j4", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230803-0005/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/MechanicalSoup/MechanicalSoup/commit/d57c4a269bba3b9a0c5bfa20292955b849006d9e"}}