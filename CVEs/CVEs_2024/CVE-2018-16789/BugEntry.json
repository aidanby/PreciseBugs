{"buggy_code": ["shellinabox (2.20) unstable; urgency=medium\n\n  * Fixed issue #222, LOGIN service\n  * Fixed issue #360, ignore escape sequences to fix dir listing\n  * Fix for function key presses\n  * Adjusting scale on IE\n  * New option to disable peer check (#364)\n  * Add option for custom SSH port\n  * Support for APL characters\n  * PDF documentation\n  * Fix for BSD build\n  * New ready event support\n  * OpenSSL 1.1 fixes  (Closes: #828542)\n  * May build with MUSL library\n  * Documentation added that SSL support is optional and requires\n    installation of openssl on Debian. (Closes: #839067)\n  * Jessie requires explicit installation of openssl because the default\n    package does not include the necessary utilities to support creation\n    of certificates. (Closes: #839066)\n\n -- Marc Singer <elf@debian.org>  Wed, 09 Nov 2016 09:52:24 -0800\n\nshellinabox (2.19) unstable; urgency=high\n\n  * Added support for middle-click paste, #350.\n  * Improved iOS support, #354.\n  * New logic to enable soft keyboard icon, #119, #321, #354.\n  * Disable HTTP fallback using the URL /plain.  Consequently disables\n    automatic upgrades from HTTP to HTTPS, #355. (CVE-2015-8400).\n\n -- Marc Singer <elf@debian.org>  Sat, 05 Dec 2015 10:24:12 -0800\n\nshellinabox (2.18) unstable; urgency=low\n\n  * Fixed reverse vide rendering, #341.\n  * Using stdout for version information, #344.\n  * Added CGI session key in HTTP response.\n  * Child process cleanup, #103.\n  * Merged #340.\n  * Autoconf updates.\n  * Disabled utmp logging.\n  * Merge #338, killing children with HUP.\n  * Fixed handling of large HTTP requests.\n  * Enhanced logging clarity with prefix.\n\n -- Marc Singer <elf@debian.org>  Sat, 10 Oct 2015 10:53:38 -0700\n\nshellinabox (2.17) unstable; urgency=medium\n\n  * Generally, SSL updates.\n  * Disabling secure client-initiated renegotiation, an abused and\n    unnecessary feature.\n  * Added support for PFS using ECDHE.\n  * Guarding build against old versions of SSL.\n\n -- Marc Singer <elf@debian.org>  Fri, 07 Aug 2015 20:48:33 -0700\n\nshellinabox (2.16) unstable; urgency=low\n\n  * New release to guarantee upgrades for people who had installed a\n    2.15-1 release candidate.\n  * Update to About dialog to use GitHub URLs.\n\n -- Marc Singer <elf@debian.org>  Fri, 24 Jul 2015 11:45:22 -0700\n\nshellinabox (2.15) unstable; urgency=low\n\n  * Improved clean-liness so that source archive is clean.\n  * First release from GitHub. (Closes: #785181)\n  \n  [Contributions by Alexandre Detiste <alexandre.detiste@gmail.com>]\n  * Bump std version to 3.9.6, no change needed\n  * Bump debhelper compat to 9\n  * Move lintian exception in d/shellinabox.lintian\n  * Change urls to new GitHub repos\n  * Retain user preferences on upgrade (Closes: #786441)\n\n -- Marc Singer <elf@debian.org>  Fri, 24 Jul 2015 09:16:18 -0700\n\nshellinabox (2.14-1) unstable; urgency=low\n\n  * Revised install target of debian/rules.\n  * Revised postrm and prerm to fix dangling symlinks on\n    purge. (Closes: #668720.)\n\n -- Marc Singer <elf@debian.org>  Sat, 21 Apr 2012 10:26:21 -0700\n\nshellinabox (2.13-1) unstable; urgency=low\n\n  * Typo in web address.  (Closes: #668130.)\n  * Removing PATH_MAX reference which should fix Hurd build.\n\n -- Marc Singer <elf@buici.com>  Mon, 09 Apr 2012 18:34:17 -0700\n\nshellinabox (2.12-1) unstable; urgency=low\n\n  * Moved libssl from a dependency to a recommended package using a helper\n    progam.  Fixed typo in dependency to lsb-base. (Closes: #667938.)\n  * Added support for runtime naming of the libssl so library.\n\n -- Marc Singer <elf@debian.org>  Sat, 07 Apr 2012 15:39:11 -0700\n\nshellinabox (2.11-1) unstable; urgency=low\n\n  * First release into archive. (Closes: #535905.)\n  * Applied patches from the issues database.\n  * Rolled major revision so that the tarball is complete.\n\n -- Marc Singer <elf@debian.org>  Sat, 07 Apr 2012 15:01:11 -0700\n", "// url.c -- Object representing uniform resource locators\n// Copyright (C) 2008-2010 Markus Gutschke <markus@shellinabox.com>\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program; if not, write to the Free Software Foundation, Inc.,\n// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n//\n// In addition to these license terms, the author grants the following\n// additional rights:\n//\n// If you modify this program, or any covered work, by linking or\n// combining it with the OpenSSL project's OpenSSL library (or a\n// modified version of that library), containing parts covered by the\n// terms of the OpenSSL or SSLeay licenses, the author\n// grants you additional permission to convey the resulting work.\n// Corresponding Source for a non-source form of such a combination\n// shall include the source code for the parts of OpenSSL used as well\n// as that of the covered work.\n//\n// You may at your option choose to remove this additional permission from\n// the work, or from any part of it.\n//\n// It is possible to build this program in a way that it loads OpenSSL\n// libraries at run-time. If doing so, the following notices are required\n// by the OpenSSL and SSLeay licenses:\n//\n// This product includes software developed by the OpenSSL Project\n// for use in the OpenSSL Toolkit. (http://www.openssl.org/)\n//\n// This product includes cryptographic software written by Eric Young\n// (eay@cryptsoft.com)\n//\n//\n// The most up-to-date version of this program is always available from\n// http://shellinabox.com\n\n#include \"config.h\"\n\n#define _XOPEN_SOURCE 500\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_STRINGS_H\n#include <strings.h> // for strncasecmp()\n#endif\n\n#include \"libhttp/url.h\"\n\n#include \"logging/logging.h\"\n\n#ifdef HAVE_UNUSED\n#defined ATTR_UNUSED __attribute__((unused))\n#defined UNUSED(x)   do { } while (0)\n#else\n#define ATTR_UNUSED\n#define UNUSED(x)    do { (void)(x); } while (0)\n#endif\n\nstatic char *urlUnescape(char *s) {\n  int warned    = 0;\n  char *r       = s;\n  for (char *u  = s; *u; ) {\n    char ch     = *u++;\n    if (ch == '+') {\n      ch        = ' ';\n    } else if (ch == '%') {\n      char c1   = *u;\n      if ((c1 >= '0' && c1 <= '9') || ((c1 &= ~0x20) >= 'A' && c1 <= 'F')) {\n        ch      = c1 - (c1 > '9' ? 'A' - 10 : '0');\n        char c2 = *++u;\n        if ((c2 >= '0' && c2 <= '9') || ((c2 &= ~0x20) >= 'A' && c2 <= 'F')) {\n          ch    = (ch << 4) + c2 - (c2 > '9' ? 'A' - 10 : '0');\n          ++u;\n        } else if (!warned++) {\n          warn(\"[http] Malformed URL encoded data \\\"%s\\\"!\", r);\n        }\n      } else if (!warned++) {\n        warn(\"[http] Malformed URL encoded data \\\"%s\\\"!\", r);\n      }\n    }\n    *s++        = ch;\n  }\n  *s            = '\\000';\n  return r;\n}\n\nstatic void urlDestroyHashMapEntry(void *arg ATTR_UNUSED, char *key,\n                                   char *value) {\n  UNUSED(arg);\n  free(key);\n  free(value);\n}\n\nstatic char *urlMakeString(const char *buf, int len) {\n  if (!buf) {\n    return NULL;\n  } else {\n    char *s;\n    check(s = malloc(len + 1));\n    memcpy(s, buf, len);\n    s[len]  = '\\000';\n    return s;\n  }\n}\n\nstatic void urlParseQueryString(struct HashMap *hashmap, const char *query, int len) {\n  const char *key   = query;\n  const char *value = NULL;\n  for (const char *ampersand = query; len-- >= 0; ampersand++) {\n    char ch         = len >= 0 ? *ampersand : '\\000';\n    if (ch == '=' && !value) {\n      value         = ampersand + 1;\n    } else if (ch == '&' || len < 0) {\n      int kl        = (value ? value-1 : ampersand) - key;\n      int vl        = value ? ampersand - value : 0;\n      if (kl) {\n        char *k     = urlMakeString(key, kl);\n        urlUnescape(k);\n        char *v     = NULL;\n        if (value) {\n          v         = urlMakeString(value, vl);\n          urlUnescape(v);\n        }\n        addToHashMap(hashmap, k, v);\n      }\n      key           = ampersand + 1;\n      value         = NULL;\n    }\n    if (!ch) {\n      break;\n    }\n  }\n}\n\nstatic void urlParseHeaderLine(struct HashMap *hashmap, const char *s,\n                               int len) {\n  while (s && len > 0) {\n    while (len > 0 && (*s == ' ' || *s == ';')) {\n      s++;\n      len--;\n    }\n    const char *key   = s;\n    const char *value = NULL;\n    while (len > 0 && *s != ';') {\n      if (*s == '=' && value == NULL) {\n        value         = s + 1;\n      }\n      s++;\n      len--;\n    }\n    int kl            = (value ? value-1 : s) - key;\n    int vl            = value ? s - value : 0;\n    if (kl) {\n      char *k         = urlMakeString(key, kl);\n      for (char *t = k; *t; t++) {\n        if (*t >= 'a' && *t <= 'z') {\n          *t         |= 0x20;\n        }\n      }\n      char *v         = NULL;\n      if (value) {\n        if (vl >= 2 && value[0] == '\"' && value[vl-1] == '\"') {\n          value++;\n          vl--;\n        }\n        v             = urlMakeString(value, vl);\n      }\n      addToHashMap(hashmap, k, v);\n    }\n  }\n}\n\nstatic const char *urlMemstr(const char *buf, int len, const char *s) {\n  int sLen        = strlen(s);\n  if (!sLen) {\n    return buf;\n  }\n  while (len >= sLen) {\n    if (len > sLen) {\n      char *first = memchr(buf, *s, len - sLen);\n      if (!first) {\n        return NULL;\n      }\n      len        -= first - buf;\n      buf         = first;\n    }\n    if (!memcmp(buf, s, sLen)) {\n      return buf;\n    }\n    buf++;\n    len--;\n  }\n  return NULL;\n}\n\nstatic int urlMemcmp(const char *buf, int len, const char *s) {\n  int sLen = strlen(s);\n  if (len < sLen) {\n    return s[len];\n  } else {\n    return memcmp(buf, s, sLen);\n  }\n}\n\nstatic int urlMemcasecmp(const char *buf, int len, const char *s) {\n  int sLen = strlen(s);\n  if (len < sLen) {\n    return s[len];\n  } else {\n    return strncasecmp(buf, s, sLen);\n  }\n}\n\nstatic void urlParsePart(struct URL *url, const char *buf, int len) {\n  // Most browsers seem to forget quoting data in the header fields. This\n  // means, it is quite possible for an HTML form to cause the submission of\n  // unparseable \"multipart/form-data\". If this happens, we just give up\n  // and ignore the malformed data.\n  // Example:\n  // <form method=\"POST\" enctype=\"multipart/form-data\">\n  //   <input type=\"file\" name=\"&quot;&#13;&#10;X: x=&quot;\">\n  //   <input type=\"submit\">\n  // </form>\n  char *name           = NULL;\n  for (const char *eol; !!(eol = urlMemstr(buf, len, \"\\r\\n\")); ) {\n    if (buf == eol) {\n      buf             += 2;\n      len             -= 2;\n      if (name) {\n        char *value    = len ? urlMakeString(buf, len) : NULL;\n        addToHashMap(&url->args, name, value);\n        name           = NULL;\n      }\n      break;\n    } else {\n      if (!name && !urlMemcasecmp(buf, len, \"content-disposition:\")) {\n        struct HashMap fields;\n        initHashMap(&fields, urlDestroyHashMapEntry, NULL);\n        urlParseHeaderLine(&fields, buf + 20, eol - buf - 20);\n        if (getRefFromHashMap(&fields, \"form-data\")) {\n          // We currently don't bother to deal with binary files (e.g. files\n          // that include NUL characters). If this ever becomes necessary,\n          // we could check for the existence of a \"filename\" field and use\n          // that as an indicator to store the payload in something other\n          // than \"url->args\".\n          name         = (char *)getFromHashMap(&fields, \"name\");\n          if (name && *name) {\n            check(name = strdup(name));\n          }\n        }\n        destroyHashMap(&fields);\n      }\n      len             -= eol - buf + 2;\n      buf              = eol + 2;\n    }\n  }\n  free(name);\n}\n\nstatic void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}\n\nstruct URL *newURL(const struct HttpConnection *http,\n                   const char *buf, int len) {\n  struct URL *url;\n  check(url = malloc(sizeof(struct URL)));\n  initURL(url, http, buf, len);\n  return url;\n}\n\nvoid initURL(struct URL *url, const struct HttpConnection *http,\n             const char *buf, int len) {\n  url->protocol              = strdup(httpGetProtocol(http));\n  url->user                  = NULL;\n  url->password              = NULL;\n  url->host                  = strdup(httpGetHost(http));\n  url->port                  = httpGetPort(http);\n  url->path                  = strdup(httpGetPath(http));\n  url->pathinfo              = strdup(httpGetPathInfo(http));\n  url->query                 = strdup(httpGetQuery(http));\n  url->anchor                = NULL;\n  url->url                   = NULL;\n  initHashMap(&url->args, urlDestroyHashMapEntry, NULL);\n  if (!strcmp(http->method, \"GET\")) {\n    check(url->query);\n    urlParseQueryString(&url->args, url->query, strlen(url->query));\n  } else if (!strcmp(http->method, \"POST\")) {\n    urlParsePostBody(url, http, buf, len);\n  }\n}\n\nvoid destroyURL(struct URL *url) {\n  if (url) {\n    free(url->protocol);\n    free(url->user);\n    free(url->password);\n    free(url->host);\n    free(url->path);\n    free(url->pathinfo);\n    free(url->query);\n    free(url->anchor);\n    free(url->url);\n    destroyHashMap(&url->args);\n  }\n}\n\nvoid deleteURL(struct URL *url) {\n  destroyURL(url);\n  free(url);\n}\n\nconst char *urlGetProtocol(struct URL *url) {\n  return url->protocol;\n}\n\nconst char *urlGetUser(struct URL *url) {\n  return url->user;\n}\n\nconst char *urlGetPassword(struct URL *url) {\n  return url->password;\n}\n\nconst char *urlGetHost(struct URL *url) {\n  return url->host;\n}\n\nint urlGetPort(struct URL *url) {\n  return url->port;\n}\n\nconst char *urlGetPath(struct URL *url) {\n  return url->path;\n}\n\nconst char *urlGetPathInfo(struct URL *url) {\n  return url->pathinfo;\n}\n\nconst char *urlGetQuery(struct URL *url) {\n  return url->query;\n}\n\nconst char *urlGetAnchor(struct URL *url) {\n  return url->anchor;\n}\n\nconst char *urlGetURL(struct URL *url) {\n  if (!url->url) {\n    const char *host           = urlGetHost(url);\n    int s_size                 = 8 + strlen(host) + 25 + strlen(url->path);\n    check(*(char **)&url->url  = malloc(s_size + 1));\n    *url->url                  = '\\000';\n    strncat(url->url, url->protocol, s_size);\n    strncat(url->url, \"://\", s_size);\n    strncat(url->url, host, s_size);\n    if (url->port != (strcmp(url->protocol, \"http\") ? 443 : 80)) {\n      snprintf(strrchr(url->url, '\\000'), 25, \":%d\", url->port);\n    }\n    strncat(url->url, url->path, s_size);\n  }\n  return url->url;\n}\n\nconst struct HashMap *urlGetArgs(struct URL *url) {\n  return &url->args;\n}\n\nstruct HashMap *urlParseQuery(const char *buf, int len) {\n  struct HashMap *hashmap = newHashMap(urlDestroyHashMapEntry, NULL);\n  urlParseQueryString(hashmap, buf, len);\n  return hashmap;\n}\n"], "fixing_code": ["shellinabox (2.21) unstable; urgency=medium\n\n  * Patched DoS vulnerability reported by Imre Rad.\n\n -- Marc Singer <elf@debian.org>  Sun, 09 Sep 2018 12:10:40 -0700\n\nshellinabox (2.20) unstable; urgency=medium\n\n  * Fixed issue #222, LOGIN service\n  * Fixed issue #360, ignore escape sequences to fix dir listing\n  * Fix for function key presses\n  * Adjusting scale on IE\n  * New option to disable peer check (#364)\n  * Add option for custom SSH port\n  * Support for APL characters\n  * PDF documentation\n  * Fix for BSD build\n  * New ready event support\n  * OpenSSL 1.1 fixes  (Closes: #828542)\n  * May build with MUSL library\n  * Documentation added that SSL support is optional and requires\n    installation of openssl on Debian. (Closes: #839067)\n  * Jessie requires explicit installation of openssl because the default\n    package does not include the necessary utilities to support creation\n    of certificates. (Closes: #839066)\n\n -- Marc Singer <elf@debian.org>  Wed, 09 Nov 2016 09:52:24 -0800\n\nshellinabox (2.19) unstable; urgency=high\n\n  * Added support for middle-click paste, #350.\n  * Improved iOS support, #354.\n  * New logic to enable soft keyboard icon, #119, #321, #354.\n  * Disable HTTP fallback using the URL /plain.  Consequently disables\n    automatic upgrades from HTTP to HTTPS, #355. (CVE-2015-8400).\n\n -- Marc Singer <elf@debian.org>  Sat, 05 Dec 2015 10:24:12 -0800\n\nshellinabox (2.18) unstable; urgency=low\n\n  * Fixed reverse vide rendering, #341.\n  * Using stdout for version information, #344.\n  * Added CGI session key in HTTP response.\n  * Child process cleanup, #103.\n  * Merged #340.\n  * Autoconf updates.\n  * Disabled utmp logging.\n  * Merge #338, killing children with HUP.\n  * Fixed handling of large HTTP requests.\n  * Enhanced logging clarity with prefix.\n\n -- Marc Singer <elf@debian.org>  Sat, 10 Oct 2015 10:53:38 -0700\n\nshellinabox (2.17) unstable; urgency=medium\n\n  * Generally, SSL updates.\n  * Disabling secure client-initiated renegotiation, an abused and\n    unnecessary feature.\n  * Added support for PFS using ECDHE.\n  * Guarding build against old versions of SSL.\n\n -- Marc Singer <elf@debian.org>  Fri, 07 Aug 2015 20:48:33 -0700\n\nshellinabox (2.16) unstable; urgency=low\n\n  * New release to guarantee upgrades for people who had installed a\n    2.15-1 release candidate.\n  * Update to About dialog to use GitHub URLs.\n\n -- Marc Singer <elf@debian.org>  Fri, 24 Jul 2015 11:45:22 -0700\n\nshellinabox (2.15) unstable; urgency=low\n\n  * Improved clean-liness so that source archive is clean.\n  * First release from GitHub. (Closes: #785181)\n  \n  [Contributions by Alexandre Detiste <alexandre.detiste@gmail.com>]\n  * Bump std version to 3.9.6, no change needed\n  * Bump debhelper compat to 9\n  * Move lintian exception in d/shellinabox.lintian\n  * Change urls to new GitHub repos\n  * Retain user preferences on upgrade (Closes: #786441)\n\n -- Marc Singer <elf@debian.org>  Fri, 24 Jul 2015 09:16:18 -0700\n\nshellinabox (2.14-1) unstable; urgency=low\n\n  * Revised install target of debian/rules.\n  * Revised postrm and prerm to fix dangling symlinks on\n    purge. (Closes: #668720.)\n\n -- Marc Singer <elf@debian.org>  Sat, 21 Apr 2012 10:26:21 -0700\n\nshellinabox (2.13-1) unstable; urgency=low\n\n  * Typo in web address.  (Closes: #668130.)\n  * Removing PATH_MAX reference which should fix Hurd build.\n\n -- Marc Singer <elf@buici.com>  Mon, 09 Apr 2012 18:34:17 -0700\n\nshellinabox (2.12-1) unstable; urgency=low\n\n  * Moved libssl from a dependency to a recommended package using a helper\n    progam.  Fixed typo in dependency to lsb-base. (Closes: #667938.)\n  * Added support for runtime naming of the libssl so library.\n\n -- Marc Singer <elf@debian.org>  Sat, 07 Apr 2012 15:39:11 -0700\n\nshellinabox (2.11-1) unstable; urgency=low\n\n  * First release into archive. (Closes: #535905.)\n  * Applied patches from the issues database.\n  * Rolled major revision so that the tarball is complete.\n\n -- Marc Singer <elf@debian.org>  Sat, 07 Apr 2012 15:01:11 -0700\n", "// url.c -- Object representing uniform resource locators\n// Copyright (C) 2008-2010 Markus Gutschke <markus@shellinabox.com>\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program; if not, write to the Free Software Foundation, Inc.,\n// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n//\n// In addition to these license terms, the author grants the following\n// additional rights:\n//\n// If you modify this program, or any covered work, by linking or\n// combining it with the OpenSSL project's OpenSSL library (or a\n// modified version of that library), containing parts covered by the\n// terms of the OpenSSL or SSLeay licenses, the author\n// grants you additional permission to convey the resulting work.\n// Corresponding Source for a non-source form of such a combination\n// shall include the source code for the parts of OpenSSL used as well\n// as that of the covered work.\n//\n// You may at your option choose to remove this additional permission from\n// the work, or from any part of it.\n//\n// It is possible to build this program in a way that it loads OpenSSL\n// libraries at run-time. If doing so, the following notices are required\n// by the OpenSSL and SSLeay licenses:\n//\n// This product includes software developed by the OpenSSL Project\n// for use in the OpenSSL Toolkit. (http://www.openssl.org/)\n//\n// This product includes cryptographic software written by Eric Young\n// (eay@cryptsoft.com)\n//\n//\n// The most up-to-date version of this program is always available from\n// http://shellinabox.com\n\n#include \"config.h\"\n\n#define _XOPEN_SOURCE 500\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_STRINGS_H\n#include <strings.h> // for strncasecmp()\n#endif\n\n#include \"libhttp/url.h\"\n\n#include \"logging/logging.h\"\n\n#ifdef HAVE_UNUSED\n#defined ATTR_UNUSED __attribute__((unused))\n#defined UNUSED(x)   do { } while (0)\n#else\n#define ATTR_UNUSED\n#define UNUSED(x)    do { (void)(x); } while (0)\n#endif\n\nstatic char *urlUnescape(char *s) {\n  int warned    = 0;\n  char *r       = s;\n  for (char *u  = s; *u; ) {\n    char ch     = *u++;\n    if (ch == '+') {\n      ch        = ' ';\n    } else if (ch == '%') {\n      char c1   = *u;\n      if ((c1 >= '0' && c1 <= '9') || ((c1 &= ~0x20) >= 'A' && c1 <= 'F')) {\n        ch      = c1 - (c1 > '9' ? 'A' - 10 : '0');\n        char c2 = *++u;\n        if ((c2 >= '0' && c2 <= '9') || ((c2 &= ~0x20) >= 'A' && c2 <= 'F')) {\n          ch    = (ch << 4) + c2 - (c2 > '9' ? 'A' - 10 : '0');\n          ++u;\n        } else if (!warned++) {\n          warn(\"[http] Malformed URL encoded data \\\"%s\\\"!\", r);\n        }\n      } else if (!warned++) {\n        warn(\"[http] Malformed URL encoded data \\\"%s\\\"!\", r);\n      }\n    }\n    *s++        = ch;\n  }\n  *s            = '\\000';\n  return r;\n}\n\nstatic void urlDestroyHashMapEntry(void *arg ATTR_UNUSED, char *key,\n                                   char *value) {\n  UNUSED(arg);\n  free(key);\n  free(value);\n}\n\nstatic char *urlMakeString(const char *buf, int len) {\n  if (!buf) {\n    return NULL;\n  } else {\n    char *s;\n    check(s = malloc(len + 1));\n    memcpy(s, buf, len);\n    s[len]  = '\\000';\n    return s;\n  }\n}\n\nstatic void urlParseQueryString(struct HashMap *hashmap, const char *query, int len) {\n  const char *key   = query;\n  const char *value = NULL;\n  for (const char *ampersand = query; len-- >= 0; ampersand++) {\n    char ch         = len >= 0 ? *ampersand : '\\000';\n    if (ch == '=' && !value) {\n      value         = ampersand + 1;\n    } else if (ch == '&' || len < 0) {\n      int kl        = (value ? value-1 : ampersand) - key;\n      int vl        = value ? ampersand - value : 0;\n      if (kl) {\n        char *k     = urlMakeString(key, kl);\n        urlUnescape(k);\n        char *v     = NULL;\n        if (value) {\n          v         = urlMakeString(value, vl);\n          urlUnescape(v);\n        }\n        addToHashMap(hashmap, k, v);\n      }\n      key           = ampersand + 1;\n      value         = NULL;\n    }\n    if (!ch) {\n      break;\n    }\n  }\n}\n\nstatic void urlParseHeaderLine(struct HashMap *hashmap, const char *s,\n                               int len) {\n  while (s && len > 0) {\n    while (len > 0 && (*s == ' ' || *s == ';')) {\n      s++;\n      len--;\n    }\n    const char *key   = s;\n    const char *value = NULL;\n    while (len > 0 && *s != ';') {\n      if (*s == '=' && value == NULL) {\n        value         = s + 1;\n      }\n      s++;\n      len--;\n    }\n    int kl            = (value ? value-1 : s) - key;\n    int vl            = value ? s - value : 0;\n    if (kl) {\n      char *k         = urlMakeString(key, kl);\n      for (char *t = k; *t; t++) {\n        if (*t >= 'a' && *t <= 'z') {\n          *t         |= 0x20;\n        }\n      }\n      char *v         = NULL;\n      if (value) {\n        if (vl >= 2 && value[0] == '\"' && value[vl-1] == '\"') {\n          value++;\n          vl--;\n        }\n        v             = urlMakeString(value, vl);\n      }\n      addToHashMap(hashmap, k, v);\n    }\n  }\n}\n\nstatic const char *urlMemstr(const char *buf, int len, const char *s) {\n  int sLen        = strlen(s);\n  if (!sLen) {\n    return buf;\n  }\n  while (len >= sLen) {\n    if (len > sLen) {\n      char *first = memchr(buf, *s, len - sLen);\n      if (!first) {\n        return NULL;\n      }\n      len        -= first - buf;\n      buf         = first;\n    }\n    if (!memcmp(buf, s, sLen)) {\n      return buf;\n    }\n    buf++;\n    len--;\n  }\n  return NULL;\n}\n\nstatic int urlMemcmp(const char *buf, int len, const char *s) {\n  int sLen = strlen(s);\n  if (len < sLen) {\n    return s[len];\n  } else {\n    return memcmp(buf, s, sLen);\n  }\n}\n\nstatic int urlMemcasecmp(const char *buf, int len, const char *s) {\n  int sLen = strlen(s);\n  if (len < sLen) {\n    return s[len];\n  } else {\n    return strncasecmp(buf, s, sLen);\n  }\n}\n\nstatic void urlParsePart(struct URL *url, const char *buf, int len) {\n  // Most browsers seem to forget quoting data in the header fields. This\n  // means, it is quite possible for an HTML form to cause the submission of\n  // unparseable \"multipart/form-data\". If this happens, we just give up\n  // and ignore the malformed data.\n  // Example:\n  // <form method=\"POST\" enctype=\"multipart/form-data\">\n  //   <input type=\"file\" name=\"&quot;&#13;&#10;X: x=&quot;\">\n  //   <input type=\"submit\">\n  // </form>\n  char *name           = NULL;\n  for (const char *eol; !!(eol = urlMemstr(buf, len, \"\\r\\n\")); ) {\n    if (buf == eol) {\n      buf             += 2;\n      len             -= 2;\n      if (name) {\n        char *value    = len ? urlMakeString(buf, len) : NULL;\n        addToHashMap(&url->args, name, value);\n        name           = NULL;\n      }\n      break;\n    } else {\n      if (!name && !urlMemcasecmp(buf, len, \"content-disposition:\")) {\n        struct HashMap fields;\n        initHashMap(&fields, urlDestroyHashMapEntry, NULL);\n        urlParseHeaderLine(&fields, buf + 20, eol - buf - 20);\n        if (getRefFromHashMap(&fields, \"form-data\")) {\n          // We currently don't bother to deal with binary files (e.g. files\n          // that include NUL characters). If this ever becomes necessary,\n          // we could check for the existence of a \"filename\" field and use\n          // that as an indicator to store the payload in something other\n          // than \"url->args\".\n          name         = (char *)getFromHashMap(&fields, \"name\");\n          if (name && *name) {\n            check(name = strdup(name));\n          }\n        }\n        destroyHashMap(&fields);\n      }\n      len             -= eol - buf + 2;\n      buf              = eol + 2;\n    }\n  }\n  free(name);\n}\n\nstatic void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n        /* elf-2018.09.09: Detection of broken multipart/form-data\n           fixes DoS vulnerability.\n\n           On 9/9/18 10:43 AM, Imre Rad wrote:\n           Hi Markus, Marc!\n\n           I identified a vulnerability today in Shellinabox, it is\n           remote a denial of service, shellinaboxd eating up 100% cpu\n           and not processing subsequent requests after the attack was\n           mounted.\n        */\n        else {\n          warn (\"[http] Ignorning broken multipart/form-data\");\n          break;\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}\n\nstruct URL *newURL(const struct HttpConnection *http,\n                   const char *buf, int len) {\n  struct URL *url;\n  check(url = malloc(sizeof(struct URL)));\n  initURL(url, http, buf, len);\n  return url;\n}\n\nvoid initURL(struct URL *url, const struct HttpConnection *http,\n             const char *buf, int len) {\n  url->protocol              = strdup(httpGetProtocol(http));\n  url->user                  = NULL;\n  url->password              = NULL;\n  url->host                  = strdup(httpGetHost(http));\n  url->port                  = httpGetPort(http);\n  url->path                  = strdup(httpGetPath(http));\n  url->pathinfo              = strdup(httpGetPathInfo(http));\n  url->query                 = strdup(httpGetQuery(http));\n  url->anchor                = NULL;\n  url->url                   = NULL;\n  initHashMap(&url->args, urlDestroyHashMapEntry, NULL);\n  if (!strcmp(http->method, \"GET\")) {\n    check(url->query);\n    urlParseQueryString(&url->args, url->query, strlen(url->query));\n  } else if (!strcmp(http->method, \"POST\")) {\n    urlParsePostBody(url, http, buf, len);\n  }\n}\n\nvoid destroyURL(struct URL *url) {\n  if (url) {\n    free(url->protocol);\n    free(url->user);\n    free(url->password);\n    free(url->host);\n    free(url->path);\n    free(url->pathinfo);\n    free(url->query);\n    free(url->anchor);\n    free(url->url);\n    destroyHashMap(&url->args);\n  }\n}\n\nvoid deleteURL(struct URL *url) {\n  destroyURL(url);\n  free(url);\n}\n\nconst char *urlGetProtocol(struct URL *url) {\n  return url->protocol;\n}\n\nconst char *urlGetUser(struct URL *url) {\n  return url->user;\n}\n\nconst char *urlGetPassword(struct URL *url) {\n  return url->password;\n}\n\nconst char *urlGetHost(struct URL *url) {\n  return url->host;\n}\n\nint urlGetPort(struct URL *url) {\n  return url->port;\n}\n\nconst char *urlGetPath(struct URL *url) {\n  return url->path;\n}\n\nconst char *urlGetPathInfo(struct URL *url) {\n  return url->pathinfo;\n}\n\nconst char *urlGetQuery(struct URL *url) {\n  return url->query;\n}\n\nconst char *urlGetAnchor(struct URL *url) {\n  return url->anchor;\n}\n\nconst char *urlGetURL(struct URL *url) {\n  if (!url->url) {\n    const char *host           = urlGetHost(url);\n    int s_size                 = 8 + strlen(host) + 25 + strlen(url->path);\n    check(*(char **)&url->url  = malloc(s_size + 1));\n    *url->url                  = '\\000';\n    strncat(url->url, url->protocol, s_size);\n    strncat(url->url, \"://\", s_size);\n    strncat(url->url, host, s_size);\n    if (url->port != (strcmp(url->protocol, \"http\") ? 443 : 80)) {\n      snprintf(strrchr(url->url, '\\000'), 25, \":%d\", url->port);\n    }\n    strncat(url->url, url->path, s_size);\n  }\n  return url->url;\n}\n\nconst struct HashMap *urlGetArgs(struct URL *url) {\n  return &url->args;\n}\n\nstruct HashMap *urlParseQuery(const char *buf, int len) {\n  struct HashMap *hashmap = newHashMap(urlDestroyHashMapEntry, NULL);\n  urlParseQueryString(hashmap, buf, len);\n  return hashmap;\n}\n"], "filenames": ["debian/changelog", "libhttp/url.c"], "buggy_code_start_loc": [0, 315], "buggy_code_end_loc": [0, 315], "fixing_code_start_loc": [1, 316], "fixing_code_end_loc": [7, 331], "type": "CWE-835", "message": "libhttp/url.c in shellinabox through 2.20 has an implementation flaw in the HTTP request parsing logic. By sending a crafted multipart/form-data HTTP request, an attacker could exploit this to force shellinaboxd into an infinite loop, exhausting available CPU resources and taking the service down.", "other": {"cve": {"id": "CVE-2018-16789", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-21T16:00:22.547", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libhttp/url.c in shellinabox through 2.20 has an implementation flaw in the HTTP request parsing logic. By sending a crafted multipart/form-data HTTP request, an attacker could exploit this to force shellinaboxd into an infinite loop, exhausting available CPU resources and taking the service down."}, {"lang": "es", "value": "libhttp/url.c en shellinabox, hasta la versi\u00f3n 2.20, tiene un error de implementaci\u00f3n en la l\u00f3gica de an\u00e1lisis de peticiones HTTP. Mediante el env\u00edo de una petici\u00f3n HTTP multipart/form-data manipulada, un atacante podr\u00eda explotar esto para forzar a shellinaboxd a entrar en un bucle infinito, agotando los recursos de la CPU disponibles y provocando la ca\u00edda del servicio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:shellinabox_project:shellinabox:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.20", "matchCriteriaId": "BCFFFB3E-F099-463A-8799-4CC308058240"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/149978/Shell-In-A-Box-2.2.0-Denial-Of-Service.html", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2018/Oct/50", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://code.google.com/archive/p/shellinabox/issues", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/shellinabox/shellinabox/commit/4f0ecc31ac6f985e0dd3f5a52cbfc0e9251f6361", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/shellinabox/shellinabox/commit/4f0ecc31ac6f985e0dd3f5a52cbfc0e9251f6361"}}