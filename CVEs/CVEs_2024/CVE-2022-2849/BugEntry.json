{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * definition of global variables\n */\n\n/*\n * Number of Rows and Columns in the screen.\n * Must be long to be able to use them as options in option.c.\n * Note: Use screen_Rows and screen_Columns to access items in ScreenLines[].\n * They may have different values when the screen wasn't (re)allocated yet\n * after setting Rows or Columns (e.g., when starting up).\n */\nEXTERN long\tRows\t\t\t// nr of rows in the screen\n#ifdef DO_INIT\n# if defined(MSWIN)\n\t\t\t    = 25L\n# else\n\t\t\t    = 24L\n# endif\n#endif\n\t\t\t    ;\nEXTERN long\tColumns INIT(= 80);\t// nr of columns in the screen\n\n/*\n * The characters that are currently on the screen are kept in ScreenLines[].\n * It is a single block of characters, the size of the screen plus one line.\n * The attributes for those characters are kept in ScreenAttrs[].\n * The byte offset in the line is kept in ScreenCols[].\n *\n * \"LineOffset[n]\" is the offset from ScreenLines[] for the start of line 'n'.\n * The same value is used for ScreenLinesUC[], ScreenAttrs[] and ScreenCols[].\n *\n * Note: before the screen is initialized and when out of memory these can be\n * NULL.\n */\nEXTERN schar_T\t*ScreenLines INIT(= NULL);\nEXTERN sattr_T\t*ScreenAttrs INIT(= NULL);\nEXTERN colnr_T  *ScreenCols INIT(= NULL);\nEXTERN unsigned\t*LineOffset INIT(= NULL);\nEXTERN char_u\t*LineWraps INIT(= NULL);\t// line wraps to next line\n\n/*\n * When using Unicode characters (in UTF-8 encoding) the character in\n * ScreenLinesUC[] contains the Unicode for the character at this position, or\n * NUL when the character in ScreenLines[] is to be used (ASCII char).\n * The composing characters are to be drawn on top of the original character.\n * ScreenLinesC[0][off] is only to be used when ScreenLinesUC[off] != 0.\n * Note: These three are only allocated when enc_utf8 is set!\n */\nEXTERN u8char_T\t*ScreenLinesUC INIT(= NULL);\t// decoded UTF-8 characters\nEXTERN u8char_T\t*ScreenLinesC[MAX_MCO];\t\t// composing characters\nEXTERN int\tScreen_mco INIT(= 0);\t\t// value of p_mco used when\n\t\t\t\t\t\t// allocating ScreenLinesC[]\n\n// Only used for euc-jp: Second byte of a character that starts with 0x8e.\n// These are single-width.\nEXTERN schar_T\t*ScreenLines2 INIT(= NULL);\n\n/*\n * One screen line to be displayed.  Points into ScreenLines.\n */\nEXTERN schar_T\t*current_ScreenLine INIT(= NULL);\n\n/*\n * Last known cursor position.\n * Positioning the cursor is reduced by remembering the last position.\n * Mostly used by windgoto() and screen_char().\n */\nEXTERN int\tscreen_cur_row INIT(= 0);\nEXTERN int\tscreen_cur_col INIT(= 0);\n\n#ifdef FEAT_SEARCH_EXTRA\n// used for 'hlsearch' highlight matching\nEXTERN match_T\tscreen_search_hl;\n\n// last lnum where CurSearch was displayed\nEXTERN linenr_T search_hl_has_cursor_lnum INIT(= 0);\n\n// don't use 'hlsearch' temporarily\nEXTERN int\tno_hlsearch INIT(= FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\nEXTERN foldinfo_T win_foldinfo;\t// info for 'foldcolumn'\n#endif\n\n// Flag that is set when drawing for a callback, not from the main command\n// loop.\nEXTERN int redrawing_for_callback INIT(= 0);\n\n/*\n * Indexes for tab page line:\n *\tN > 0 for label of tab page N\n *\tN == 0 for no label\n *\tN < 0 for closing tab page -N\n *\tN == -999 for closing current tab page\n */\nEXTERN short\t*TabPageIdxs INIT(= NULL);\n\n#ifdef FEAT_PROP_POPUP\n// Array with size Rows x Columns containing zindex of popups.\nEXTERN short\t*popup_mask INIT(= NULL);\nEXTERN short\t*popup_mask_next INIT(= NULL);\n// Array with flags for transparent cells of current popup.\nEXTERN char\t*popup_transparent INIT(= NULL);\n\n// Flag set to TRUE when popup_mask needs to be updated.\nEXTERN int\tpopup_mask_refresh INIT(= TRUE);\n\n// Tab that was used to fill popup_mask.\nEXTERN tabpage_T *popup_mask_tab INIT(= NULL);\n\n// Zindex in for screen_char(): if lower than the value in \"popup_mask\"\n// drawing the character is skipped.\nEXTERN int\tscreen_zindex INIT(= 0);\n#endif\n\nEXTERN int\tscreen_Rows INIT(= 0);\t    // actual size of ScreenLines[]\nEXTERN int\tscreen_Columns INIT(= 0);   // actual size of ScreenLines[]\n\n/*\n * When vgetc() is called, it sets mod_mask to the set of modifiers that are\n * held down based on the MOD_MASK_* symbols that are read first.\n */\nEXTERN int\tmod_mask INIT(= 0);\t\t// current key modifiers\n\n// The value of \"mod_mask\" and the unomdified character before calling\n// merge_modifyOtherKeys().\nEXTERN int\tvgetc_mod_mask INIT(= 0);\nEXTERN int\tvgetc_char INIT(= 0);\n\n/*\n * Cmdline_row is the row where the command line starts, just below the\n * last window.\n * When the cmdline gets longer than the available space the screen gets\n * scrolled up. After a CTRL-D (show matches), after hitting ':' after\n * \"hit return\", and for the :global command, the command line is\n * temporarily moved.  The old position is restored with the next call to\n * update_screen().\n */\nEXTERN int\tcmdline_row;\n\nEXTERN int\tredraw_cmdline INIT(= FALSE);\t// cmdline must be redrawn\nEXTERN int\tredraw_mode INIT(= FALSE);\t// mode must be redrawn\nEXTERN int\tclear_cmdline INIT(= FALSE);\t// cmdline must be cleared\nEXTERN int\tmode_displayed INIT(= FALSE);\t// mode is being displayed\nEXTERN int\tno_win_do_lines_ins INIT(= FALSE); // don't insert lines\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\nEXTERN int\tcmdline_star INIT(= FALSE);\t// cmdline is crypted\n#endif\n\nEXTERN int\texec_from_reg INIT(= FALSE);\t// executing register\n\nEXTERN int\tscreen_cleared INIT(= FALSE);\t// screen has been cleared\n\n/*\n * When '$' is included in 'cpoptions' option set:\n * When a change command is given that deletes only part of a line, a dollar\n * is put at the end of the changed text. dollar_vcol is set to the virtual\n * column of this '$'.  -1 is used to indicate no $ is being displayed.\n */\nEXTERN colnr_T\tdollar_vcol INIT(= -1);\n\n/*\n * Variables for Insert mode completion.\n */\n\nEXTERN char_u\t*edit_submode INIT(= NULL); // msg for CTRL-X submode\nEXTERN char_u\t*edit_submode_pre INIT(= NULL); // prepended to edit_submode\nEXTERN char_u\t*edit_submode_extra INIT(= NULL);// appended to edit_submode\nEXTERN hlf_T\tedit_submode_highl;\t// highl. method for extra info\n\n/*\n * Functions for putting characters in the command line,\n * while keeping ScreenLines[] updated.\n */\n#ifdef FEAT_RIGHTLEFT\nEXTERN int\tcmdmsg_rl INIT(= FALSE);    // cmdline is drawn right to left\n#endif\nEXTERN int\tmsg_col;\nEXTERN int\tmsg_row;\nEXTERN int\tmsg_scrolled;\t// Number of screen lines that windows have\n\t\t\t\t// scrolled because of printing messages.\nEXTERN int\tmsg_scrolled_ign INIT(= FALSE);\n\t\t\t\t// when TRUE don't set need_wait_return in\n\t\t\t\t// msg_puts_attr() when msg_scrolled is\n\t\t\t\t// non-zero\n\nEXTERN char_u\t*keep_msg INIT(= NULL);\t    // msg to be shown after redraw\nEXTERN int\tkeep_msg_attr INIT(= 0);    // highlight attr for keep_msg\nEXTERN int\tkeep_msg_more INIT(= FALSE); // keep_msg was set by msgmore()\nEXTERN int\tneed_fileinfo INIT(= FALSE);// do fileinfo() after redraw\nEXTERN int\tmsg_scroll INIT(= FALSE);   // msg_start() will scroll\nEXTERN int\tmsg_didout INIT(= FALSE);   // msg_outstr() was used in line\nEXTERN int\tmsg_didany INIT(= FALSE);   // msg_outstr() was used at all\nEXTERN int\tmsg_nowait INIT(= FALSE);   // don't wait for this msg\nEXTERN int\temsg_off INIT(= 0);\t    // don't display errors for now,\n\t\t\t\t\t    // unless 'debug' is set.\nEXTERN int\tinfo_message INIT(= FALSE); // printing informative message\nEXTERN int      msg_hist_off INIT(= FALSE); // don't add messages to history\n#ifdef FEAT_EVAL\nEXTERN int\tneed_clr_eos INIT(= FALSE); // need to clear text before\n\t\t\t\t\t    // displaying a message.\nEXTERN int\temsg_skip INIT(= 0);\t    // don't display errors for\n\t\t\t\t\t    // expression that is skipped\nEXTERN int\temsg_severe INIT(= FALSE);  // use message of next of several\n\t\t\t\t\t    // emsg() calls for throw\n// used by assert_fails()\nEXTERN char_u\t*emsg_assert_fails_msg INIT(= NULL);\nEXTERN long\temsg_assert_fails_lnum INIT(= 0);\nEXTERN char_u\t*emsg_assert_fails_context INIT(= NULL);\n\nEXTERN int\tdid_endif INIT(= FALSE);    // just had \":endif\"\n#endif\nEXTERN int\tdid_emsg;\t\t    // set by emsg() when the message\n\t\t\t\t\t    // is displayed or thrown\n#ifdef FEAT_EVAL\nEXTERN int\tdid_emsg_silent INIT(= 0);  // incremented by emsg() when\n\t\t\t\t\t    // emsg_silent was set and did_emsg\n\t\t\t\t\t    // is not incremented\nEXTERN int\tdid_emsg_def;\t\t    // set by emsg() when emsg_silent\n\t\t\t\t\t    // is set before calling a function\nEXTERN int\tdid_emsg_cumul;\t\t    // cumulative did_emsg, increased\n\t\t\t\t\t    // when did_emsg is reset.\nEXTERN int\tcalled_vim_beep;\t    // set if vim_beep() is called\nEXTERN int\tuncaught_emsg;\t\t    // number of times emsg() was\n\t\t\t\t\t    // called and did show a message\n#endif\nEXTERN int\tdid_emsg_syntax;\t    // did_emsg set because of a\n\t\t\t\t\t    // syntax error\nEXTERN int\tcalled_emsg;\t\t    // always incremented by emsg()\nEXTERN int\tex_exitval INIT(= 0);\t    // exit value for ex mode\nEXTERN int\temsg_on_display INIT(= FALSE);\t// there is an error message\nEXTERN int\trc_did_emsg INIT(= FALSE);  // vim_regcomp() called emsg()\n\nEXTERN int\tno_wait_return INIT(= 0);   // don't wait for return for now\nEXTERN int\tneed_wait_return INIT(= 0); // need to wait for return later\nEXTERN int\tdid_wait_return INIT(= FALSE);\t// wait_return() was used and\n\t\t\t\t\t\t// nothing written since then\nEXTERN int\tneed_maketitle INIT(= TRUE); // call maketitle() soon\n\nEXTERN int\tquit_more INIT(= FALSE);    // 'q' hit at \"--more--\" msg\n#if defined(UNIX) || defined(VMS) || defined(MACOS_X)\nEXTERN int\tnewline_on_exit INIT(= FALSE);\t// did msg in altern. screen\nEXTERN int\tintr_char INIT(= 0);\t    // extra interrupt character\n#endif\n#if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)\nEXTERN int\tx_no_connect INIT(= FALSE); // don't connect to X server\n# if defined(FEAT_CLIENTSERVER)\nEXTERN int\tx_force_connect INIT(= FALSE);\t// Do connect to X server.\n\t\t\t\t\t\t// Overrules x_no_connect and\n\t\t\t\t\t\t// \"exclude\" in 'clipboard'.\n# endif\n#endif\nEXTERN int\tex_keep_indent INIT(= FALSE); // getexmodeline(): keep indent\nEXTERN int\tvgetc_busy INIT(= 0);\t      // when inside vgetc() then > 0\n\nEXTERN int\tdidset_vim INIT(= FALSE);\t    // did set $VIM ourselves\nEXTERN int\tdidset_vimruntime INIT(= FALSE);    // idem for $VIMRUNTIME\n\n/*\n * Lines left before a \"more\" message.\tEx mode needs to be able to reset this\n * after you type something.\n */\nEXTERN int\tlines_left INIT(= -1);\t    // lines left for listing\nEXTERN int\tmsg_no_more INIT(= FALSE);  // don't use more prompt, truncate\n\t\t\t\t\t    // messages\n\n/*\n * Stack of execution contexts.  Each entry is an estack_T.\n * Current context is at ga_len - 1.\n */\nEXTERN garray_T\texestack INIT5(0, 0, sizeof(estack_T), 50, NULL);\n#define HAVE_SOURCING_INFO  (exestack.ga_data != NULL && exestack.ga_len > 0)\n// name of error message source\n#define SOURCING_NAME (((estack_T *)exestack.ga_data)[exestack.ga_len - 1].es_name)\n// line number in the message source or zero\n#define SOURCING_LNUM (((estack_T *)exestack.ga_data)[exestack.ga_len - 1].es_lnum)\n\n// Script CTX being sourced or was sourced to define the current function.\nEXTERN sctx_T\tcurrent_sctx\n#ifdef FEAT_EVAL\n    INIT4(0, 0, 0, 0);\n#else\n    INIT(= {0});\n#endif\n\n#ifdef FEAT_EVAL\n// whether inside compile_def_function()\nEXTERN int\testack_compiling INIT(= FALSE);\n\nEXTERN int\tex_nesting_level INIT(= 0);\t// nesting level\nEXTERN int\tdebug_break_level INIT(= -1);\t// break below this level\nEXTERN int\tdebug_did_msg INIT(= FALSE);\t// did \"debug mode\" message\nEXTERN int\tdebug_tick INIT(= 0);\t\t// breakpoint change count\nEXTERN int\tdebug_backtrace_level INIT(= 0); // breakpoint backtrace level\n# ifdef FEAT_PROFILE\nEXTERN int\tdo_profiling INIT(= PROF_NONE);\t// PROF_ values\n# endif\nEXTERN garray_T script_items INIT5(0, 0, sizeof(scriptitem_T *), 20, NULL);\n# define SCRIPT_ITEM(id)    (((scriptitem_T **)script_items.ga_data)[(id) - 1])\n# define SCRIPT_ID_VALID(id)    ((id) > 0 && (id) <= script_items.ga_len)\n# define SCRIPT_SV(id)\t\t(SCRIPT_ITEM(id)->sn_vars)\n# define SCRIPT_VARS(id)\t(SCRIPT_SV(id)->sv_dict.dv_hashtab)\n\n# define FUNCLINE(fp, j)\t((char_u **)(fp->uf_lines.ga_data))[j]\n\n/*\n * The exception currently being thrown.  Used to pass an exception to\n * a different cstack.  Also used for discarding an exception before it is\n * caught or made pending.  Only valid when did_throw is TRUE.\n */\nEXTERN except_T *current_exception;\n\n/*\n * did_throw: An exception is being thrown.  Reset when the exception is caught\n * or as long as it is pending in a finally clause.\n */\nEXTERN int did_throw INIT(= FALSE);\n\n/*\n * need_rethrow: set to TRUE when a throw that cannot be handled in do_cmdline()\n * must be propagated to the cstack of the previously called do_cmdline().\n */\nEXTERN int need_rethrow INIT(= FALSE);\n\n/*\n * check_cstack: set to TRUE when a \":finish\" or \":return\" that cannot be\n * handled in do_cmdline() must be propagated to the cstack of the previously\n * called do_cmdline().\n */\nEXTERN int check_cstack INIT(= FALSE);\n\n/*\n * Number of nested try conditionals (across function calls and \":source\"\n * commands).\n */\nEXTERN int trylevel INIT(= 0);\n\n/*\n * When \"force_abort\" is TRUE, always skip commands after an error message,\n * even after the outermost \":endif\", \":endwhile\" or \":endfor\" or for a\n * function without the \"abort\" flag.  It is set to TRUE when \"trylevel\" is\n * non-zero (and \":silent!\" was not used) or an exception is being thrown at\n * the time an error is detected.  It is set to FALSE when \"trylevel\" gets\n * zero again and there was no error or interrupt or throw.\n */\nEXTERN int force_abort INIT(= FALSE);\n\n/*\n * \"msg_list\" points to a variable in the stack of do_cmdline() which keeps\n * the list of arguments of several emsg() calls, one of which is to be\n * converted to an error exception immediately after the failing command\n * returns.  The message to be used for the exception value is pointed to by\n * the \"throw_msg\" field of the first element in the list.  It is usually the\n * same as the \"msg\" field of that element, but can be identical to the \"msg\"\n * field of a later list element, when the \"emsg_severe\" flag was set when the\n * emsg() call was made.\n */\nEXTERN msglist_T **msg_list INIT(= NULL);\n\n/*\n * suppress_errthrow: When TRUE, don't convert an error to an exception.  Used\n * when displaying the interrupt message or reporting an exception that is still\n * uncaught at the top level (which has already been discarded then).  Also used\n * for the error message when no exception can be thrown.\n */\nEXTERN int suppress_errthrow INIT(= FALSE);\n\n/*\n * The stack of all caught and not finished exceptions.  The exception on the\n * top of the stack is the one got by evaluation of v:exception.  The complete\n * stack of all caught and pending exceptions is embedded in the various\n * cstacks; the pending exceptions, however, are not on the caught stack.\n */\nEXTERN except_T *caught_stack INIT(= NULL);\n\n/*\n * Garbage collection can only take place when we are sure there are no Lists\n * or Dictionaries being used internally.  This is flagged with\n * \"may_garbage_collect\" when we are at the toplevel.\n * \"want_garbage_collect\" is set by the garbagecollect() function, which means\n * we do garbage collection before waiting for a char at the toplevel.\n * \"garbage_collect_at_exit\" indicates garbagecollect(1) was called.\n */\nEXTERN int\tmay_garbage_collect INIT(= FALSE);\nEXTERN int\twant_garbage_collect INIT(= FALSE);\nEXTERN int\tgarbage_collect_at_exit INIT(= FALSE);\n\n\n// Commonly used types.\n// \"unknown\" is used for when the type is really unknown, e.g. global\n// variables.  Also for when a function may or may not return something.\nEXTERN type_T t_unknown INIT6(VAR_UNKNOWN, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\n// \"any\" is used for when the type is mixed.  Excludes \"void\".\nEXTERN type_T t_any INIT6(VAR_ANY, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\n// \"void\" is used for a function not returning anything.\nEXTERN type_T t_void INIT6(VAR_VOID, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\nEXTERN type_T t_bool INIT6(VAR_BOOL, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_null INIT6(VAR_SPECIAL, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_none INIT6(VAR_SPECIAL, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_number INIT6(VAR_NUMBER, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_number_bool INIT6(VAR_NUMBER, 0, 0, TTFLAG_STATIC|TTFLAG_BOOL_OK, NULL, NULL);\nEXTERN type_T t_float INIT6(VAR_FLOAT, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_string INIT6(VAR_STRING, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_blob INIT6(VAR_BLOB, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_blob_null INIT6(VAR_BLOB, 0, 0, TTFLAG_STATIC, &t_void, NULL);\nEXTERN type_T t_job INIT6(VAR_JOB, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_channel INIT6(VAR_CHANNEL, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\n// Special value used for @#.\nEXTERN type_T t_number_or_string INIT6(VAR_STRING, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\nEXTERN type_T t_func_unknown INIT6(VAR_FUNC, -1, -1, TTFLAG_STATIC, &t_unknown, NULL);\nEXTERN type_T t_func_void INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_void, NULL);\nEXTERN type_T t_func_any INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_func_number INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_func_string INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_string, NULL);\nEXTERN type_T t_func_bool INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_bool, NULL);\nEXTERN type_T t_func_0_void INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_void, NULL);\nEXTERN type_T t_func_0_any INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_func_0_number INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_func_0_string INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_string, NULL);\n\nEXTERN type_T t_list_any INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_dict_any INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_list_empty INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_unknown, NULL);\nEXTERN type_T t_dict_empty INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_unknown, NULL);\n\nEXTERN type_T t_list_bool INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_bool, NULL);\nEXTERN type_T t_list_number INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_list_string INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_string, NULL);\nEXTERN type_T t_list_job INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_job, NULL);\nEXTERN type_T t_list_dict_any INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_dict_any, NULL);\nEXTERN type_T t_list_list_any INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_list_any, NULL);\nEXTERN type_T t_list_list_string INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_list_string, NULL);\n\nEXTERN type_T t_dict_bool INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_bool, NULL);\nEXTERN type_T t_dict_number INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_dict_string INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_string, NULL);\n\n#endif\n\n#ifdef FEAT_EVAL\nEXTERN int\tdid_source_packages INIT(= FALSE);\n#endif\n\n// Magic number used for hashitem \"hi_key\" value indicating a deleted item.\n// Only the address is used.\nEXTERN char_u\thash_removed;\n\n\nEXTERN int\tscroll_region INIT(= FALSE); // term supports scroll region\nEXTERN int\tt_colors INIT(= 0);\t    // int value of T_CCO\n\n// Flags to indicate an additional string for highlight name completion.\nEXTERN int include_none INIT(= 0);\t// when 1 include \"None\"\nEXTERN int include_default INIT(= 0);\t// when 1 include \"default\"\nEXTERN int include_link INIT(= 0);\t// when 2 include \"link\" and \"clear\"\n\n/*\n * When highlight_match is TRUE, highlight a match, starting at the cursor\n * position.  Search_match_lines is the number of lines after the match (0 for\n * a match within one line), search_match_endcol the column number of the\n * character just after the match in the last line.\n */\nEXTERN int\thighlight_match INIT(= FALSE);\t// show search match pos\nEXTERN linenr_T\tsearch_match_lines;\t\t// lines of matched string\nEXTERN colnr_T\tsearch_match_endcol;\t\t// col nr of match end\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN linenr_T\tsearch_first_line INIT(= 0);\t  // for :{FIRST},{last}s/pat\nEXTERN linenr_T\tsearch_last_line INIT(= MAXLNUM); // for :{first},{LAST}s/pat\n#endif\n\nEXTERN int\tno_smartcase INIT(= FALSE);\t// don't use 'smartcase' once\n\nEXTERN int\tneed_check_timestamps INIT(= FALSE); // need to check file\n\t\t\t\t\t\t     // timestamps asap\nEXTERN int\tdid_check_timestamps INIT(= FALSE); // did check timestamps\n\t\t\t\t\t\t    // recently\nEXTERN int\tno_check_timestamps INIT(= 0);\t// Don't check timestamps\n\nEXTERN int\thighlight_attr[HLF_COUNT];  // Highl. attr for each context.\n#ifdef FEAT_STL_OPT\n# define USER_HIGHLIGHT\n#endif\n#ifdef USER_HIGHLIGHT\nEXTERN int\thighlight_user[9];\t\t// User[1-9] attributes\n# ifdef FEAT_STL_OPT\nEXTERN int\thighlight_stlnc[9];\t\t// On top of user\n#  ifdef FEAT_TERMINAL\nEXTERN int\thighlight_stlterm[9];\t\t// On top of user\nEXTERN int\thighlight_stltermnc[9];\t\t// On top of user\n#  endif\n# endif\n#endif\n#ifdef FEAT_TERMINAL\n\t\t// When TRUE skip calling terminal_loop() once.  Used when\n\t\t// typing ':' at the more prompt.\nEXTERN int\tskip_term_loop INIT(= FALSE);\n#endif\n#ifdef FEAT_GUI\nEXTERN char_u\t*use_gvimrc INIT(= NULL);\t// \"-U\" cmdline argument\n#endif\nEXTERN int\tcterm_normal_fg_color INIT(= 0);\nEXTERN int\tcterm_normal_fg_bold INIT(= 0);\nEXTERN int\tcterm_normal_bg_color INIT(= 0);\nEXTERN int\tcterm_normal_ul_color INIT(= 0);\n#ifdef FEAT_TERMGUICOLORS\nEXTERN guicolor_T cterm_normal_fg_gui_color INIT(= INVALCOLOR);\nEXTERN guicolor_T cterm_normal_bg_gui_color INIT(= INVALCOLOR);\nEXTERN guicolor_T cterm_normal_ul_gui_color INIT(= INVALCOLOR);\n#endif\n#ifdef FEAT_TERMRESPONSE\nEXTERN int\tis_mac_terminal INIT(= FALSE);  // recognized Terminal.app\n#endif\n\nEXTERN int\tautocmd_busy INIT(= FALSE);\t// Is apply_autocmds() busy?\nEXTERN int\tautocmd_no_enter INIT(= FALSE); // *Enter autocmds disabled\nEXTERN int\tautocmd_no_leave INIT(= FALSE); // *Leave autocmds disabled\n\nEXTERN int\tmodified_was_set;\t\t// did \":set modified\"\nEXTERN int\tdid_filetype INIT(= FALSE);\t// FileType event found\nEXTERN int\tkeep_filetype INIT(= FALSE);\t// value for did_filetype when\n\t\t\t\t\t\t// starting to execute\n\t\t\t\t\t\t// autocommands\n\n// Set by the apply_autocmds_group function if the given event is equal to\n// EVENT_FILETYPE. Used by the readfile function in order to determine if\n// EVENT_BUFREADPOST triggered the EVENT_FILETYPE.\n//\n// Relying on this value requires one to reset it prior calling\n// apply_autocmds_group.\nEXTERN int\tau_did_filetype INIT(= FALSE);\n\n// When deleting the current buffer, another one must be loaded.  If we know\n// which one is preferred, au_new_curbuf is set to it\nEXTERN bufref_T\tau_new_curbuf INIT3(NULL, 0, 0);\n\n// When deleting a buffer/window and autocmd_busy is TRUE, do not free the\n// buffer/window. but link it in the list starting with\n// au_pending_free_buf/ap_pending_free_win, using b_next/w_next.\n// Free the buffer/window when autocmd_busy is being set to FALSE.\nEXTERN buf_T\t*au_pending_free_buf INIT(= NULL);\nEXTERN win_T\t*au_pending_free_win INIT(= NULL);\n\n/*\n * Mouse coordinates, set by check_termcode()\n */\nEXTERN int\tmouse_row;\nEXTERN int\tmouse_col;\nEXTERN int\tmouse_past_bottom INIT(= FALSE);// mouse below last line\nEXTERN int\tmouse_past_eol INIT(= FALSE);\t// mouse right of line\nEXTERN int\tmouse_dragging INIT(= 0);\t// extending Visual area with\n\t\t\t\t\t\t// mouse dragging\n#if defined(FEAT_MOUSE_DEC)\n/*\n * When the DEC mouse has been pressed but not yet released we enable\n * automatic queries for the mouse position.\n */\nEXTERN int\tWantQueryMouse INIT(= FALSE);\n#endif\n\n#ifdef FEAT_GUI\n// When the window layout is about to be changed, need_mouse_correct is set,\n// so that gui_mouse_correct() is called afterwards, to correct the mouse\n// pointer when focus-follow-mouse is being used.\nEXTERN int\tneed_mouse_correct INIT(= FALSE);\n\n// When double clicking, topline must be the same\nEXTERN linenr_T gui_prev_topline INIT(= 0);\n# ifdef FEAT_DIFF\nEXTERN int\tgui_prev_topfill INIT(= 0);\n# endif\n#endif\n\n# ifdef FEAT_MOUSESHAPE\nEXTERN int\tdrag_status_line INIT(= FALSE);\t// dragging the status line\nEXTERN int\tpostponed_mouseshape INIT(= FALSE); // postponed updating the\n\t\t\t\t\t\t    // mouse pointer shape\nEXTERN int\tdrag_sep_line INIT(= FALSE);\t// dragging vert separator\n# endif\n\n\n#ifdef FEAT_DIFF\n// Value set from 'diffopt'.\nEXTERN int\tdiff_context INIT(= 6);\t\t// context for folds\nEXTERN int\tdiff_foldcolumn INIT(= 2);\t// 'foldcolumn' for diff mode\nEXTERN int\tdiff_need_scrollbind INIT(= FALSE);\n#endif\n\n// While redrawing the screen this flag is set.  It means the screen size\n// ('lines' and 'rows') must not be changed.\nEXTERN int\tupdating_screen INIT(= FALSE);\n\n#ifdef MESSAGE_QUEUE\n// While closing windows or buffers messages should not be handled to avoid\n// using invalid windows or buffers.\nEXTERN int\tdont_parse_messages INIT(= FALSE);\n#endif\n\n#ifdef FEAT_MENU\n// The root of the menu hierarchy.\nEXTERN vimmenu_T\t*root_menu INIT(= NULL);\n/*\n * While defining the system menu, sys_menu is TRUE.  This avoids\n * overruling of menus that the user already defined.\n */\nEXTERN int\tsys_menu INIT(= FALSE);\n\n#define FOR_ALL_MENUS(m) for ((m) = root_menu; (m) != NULL; (m) = (m)->next)\n#define FOR_ALL_CHILD_MENUS(p, c) \\\n    for ((c) = (p)->children; (c) != NULL; (c) = (c)->next)\n#endif\n\n#ifdef FEAT_GUI\n# ifdef FEAT_MENU\n// Menu item just selected, set by check_termcode()\nEXTERN vimmenu_T\t*current_menu;\n\n// Set to TRUE after adding/removing menus to ensure they are updated\nEXTERN int force_menu_update INIT(= FALSE);\n# endif\n# ifdef FEAT_GUI_TABLINE\n// Tab in tab pages line just selected, set by check_termcode()\nEXTERN int\t    current_tab;\n\n// Menu entry in tab pages line menu just selected, set by check_termcode()\nEXTERN int\t    current_tabmenu;\n#  define TABLINE_MENU_CLOSE\t1\n#  define TABLINE_MENU_NEW\t2\n#  define TABLINE_MENU_OPEN\t3\n# endif\n\n// Scrollbar moved and new value, set by check_termcode()\nEXTERN int\tcurrent_scrollbar;\nEXTERN long_u\tscrollbar_value;\n\n// found \"-rv\" or \"-reverse\" in command line args\nEXTERN int\tfound_reverse_arg INIT(= FALSE);\n\n// \"-fn\" or \"-font\" command line argument\nEXTERN char\t*font_argument INIT(= NULL);\n\n# ifdef FEAT_GUI_GTK\n// \"-bg\" or \"-background\" command line argument\nEXTERN char\t*background_argument INIT(= NULL);\n\n// \"-fg\" or \"-foreground\" command line argument\nEXTERN char\t*foreground_argument INIT(= NULL);\n# endif\n\n/*\n * While executing external commands or in Ex mode, should not insert GUI\n * events in the input buffer: Set hold_gui_events to non-zero.\n *\n * volatile because it is used in signal handler sig_sysmouse().\n */\nEXTERN volatile sig_atomic_t hold_gui_events INIT(= 0);\n\n/*\n * When resizing the shell is postponed, remember the new size, and call\n * gui_resize_shell() later.\n */\nEXTERN int\tnew_pixel_width INIT(= 0);\nEXTERN int\tnew_pixel_height INIT(= 0);\n\n// Window position from \":winpos\", to be used when opening the GUI window.\nEXTERN int\tgui_win_x INIT(= -1);\nEXTERN int\tgui_win_y INIT(= -1);\n#endif\n\n#ifdef FEAT_CLIPBOARD\nEXTERN Clipboard_T clip_star;\t// PRIMARY selection in X11\n# ifdef FEAT_X11\nEXTERN Clipboard_T clip_plus;\t// CLIPBOARD selection in X11\n# else\n#  define clip_plus clip_star\t// there is only one clipboard\n#  define ONE_CLIPBOARD\n# endif\n\n# define CLIP_UNNAMED      1\n# define CLIP_UNNAMED_PLUS 2\nEXTERN int\tclip_unnamed INIT(= 0); // above two values or'ed\n\nEXTERN int\tclip_autoselect_star INIT(= FALSE);\nEXTERN int\tclip_autoselect_plus INIT(= FALSE);\nEXTERN int\tclip_autoselectml INIT(= FALSE);\nEXTERN int\tclip_html INIT(= FALSE);\nEXTERN regprog_T *clip_exclude_prog INIT(= NULL);\nEXTERN int\tclip_unnamed_saved INIT(= 0);\n#endif\n\n/*\n * All regular windows are linked in a list. \"firstwin\" points to the first\n * entry, \"lastwin\" to the last entry (can be the same as firstwin) and\n * \"curwin\" to the currently active window.\n * When switching tabs these swapped with the pointers in \"tabpage_T\".\n */\nEXTERN win_T\t*firstwin;\t\t// first window\nEXTERN win_T\t*lastwin;\t\t// last window\nEXTERN win_T\t*prevwin INIT(= NULL);\t// previous window\n#define ONE_WINDOW (firstwin == lastwin)\n#define W_NEXT(wp) ((wp)->w_next)\n#define FOR_ALL_WINDOWS(wp) for ((wp) = firstwin; (wp) != NULL; (wp) = (wp)->w_next)\n#define FOR_ALL_FRAMES(frp, first_frame) \\\n    for ((frp) = first_frame; (frp) != NULL; (frp) = (frp)->fr_next)\n#define FOR_ALL_TABPAGES(tp) for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next)\n#define FOR_ALL_WINDOWS_IN_TAB(tp, wp) \\\n    for ((wp) = ((tp) == NULL || (tp) == curtab) \\\n\t    ? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)\n/*\n * When using this macro \"break\" only breaks out of the inner loop. Use \"goto\"\n * to break out of the tabpage loop.\n */\n#define FOR_ALL_TAB_WINDOWS(tp, wp) \\\n    for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \\\n\tfor ((wp) = ((tp) == curtab) \\\n\t\t? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)\n\n#define FOR_ALL_POPUPWINS(wp) \\\n    for ((wp) = first_popupwin; (wp) != NULL; (wp) = (wp)->w_next)\n#define FOR_ALL_POPUPWINS_IN_TAB(tp, wp) \\\n    for ((wp) = (tp)->tp_first_popupwin; (wp) != NULL; (wp) = (wp)->w_next)\n\n\nEXTERN win_T\t*curwin;\t// currently active window\n\nEXTERN win_T\t*aucmd_win;\t// window used in aucmd_prepbuf()\nEXTERN int\taucmd_win_used INIT(= FALSE);\t// aucmd_win is being used\n\n#ifdef FEAT_PROP_POPUP\nEXTERN win_T    *first_popupwin;\t\t// first global popup window\nEXTERN win_T\t*popup_dragwin INIT(= NULL);\t// popup window being dragged\n\n// Set to TRUE if there is any visible popup window.\nEXTERN int\tpopup_visible INIT(= FALSE);\n\n// Set to TRUE if a visible popup window may use a MOUSE_MOVE event\nEXTERN int\tpopup_uses_mouse_move INIT(= FALSE);\n\nEXTERN int\ttext_prop_frozen INIT(= 0);\n#endif\n\n// When set the popup menu will redraw soon using the pum_win_ values. Do not\n// draw over the poup menu area to avoid flicker.\nEXTERN int\tpum_will_redraw INIT(= FALSE);\n\n/*\n * The window layout is kept in a tree of frames.  topframe points to the top\n * of the tree.\n */\nEXTERN frame_T\t*topframe;\t// top of the window frame tree\n\n/*\n * Tab pages are alternative topframes.  \"first_tabpage\" points to the first\n * one in the list, \"curtab\" is the current one. \"lastused_tabpage\" is the\n * last used one.\n */\nEXTERN tabpage_T    *first_tabpage;\nEXTERN tabpage_T    *curtab;\nEXTERN tabpage_T    *lastused_tabpage;\nEXTERN int\t    redraw_tabline INIT(= FALSE);  // need to redraw tabline\n\n/*\n * All buffers are linked in a list. 'firstbuf' points to the first entry,\n * 'lastbuf' to the last entry and 'curbuf' to the currently active buffer.\n */\nEXTERN buf_T\t*firstbuf INIT(= NULL);\t// first buffer\nEXTERN buf_T\t*lastbuf INIT(= NULL);\t// last buffer\nEXTERN buf_T\t*curbuf INIT(= NULL);\t// currently active buffer\n\n#define FOR_ALL_BUFFERS(buf) \\\n    for ((buf) = firstbuf; (buf) != NULL; (buf) = (buf)->b_next)\n\n#define FOR_ALL_BUF_WININFO(buf, wip) \\\n    for ((wip) = (buf)->b_wininfo; (wip) != NULL; (wip) = (wip)->wi_next)\n\n// Iterate through all the signs placed in a buffer\n#define FOR_ALL_SIGNS_IN_BUF(buf, sign) \\\n\tfor ((sign) = (buf)->b_signlist; (sign) != NULL; (sign) = (sign)->se_next)\n\n// Flag that is set when switching off 'swapfile'.  It means that all blocks\n// are to be loaded into memory.  Shouldn't be global...\nEXTERN int\tmf_dont_release INIT(= FALSE);\t// don't release blocks\n\n/*\n * List of files being edited (global argument list).  curwin->w_alist points\n * to this when the window is using the global argument list.\n */\nEXTERN alist_T\tglobal_alist;\t\t    // global argument list\nEXTERN int\tmax_alist_id INIT(= 0);\t    // the previous argument list id\nEXTERN int\targ_had_last INIT(= FALSE); // accessed last file in\n\t\t\t\t\t    // global_alist\n\nEXTERN int\tru_col;\t\t// column for ruler\n#ifdef FEAT_STL_OPT\nEXTERN int\tru_wid;\t\t// 'rulerfmt' width of ruler when non-zero\n#endif\nEXTERN int\tsc_col;\t\t// column for shown command\n\n#ifdef TEMPDIRNAMES\n# if defined(UNIX) && defined(HAVE_FLOCK) \\\n\t&& (defined(HAVE_DIRFD) || defined(__hpux))\nEXTERN DIR\t*vim_tempdir_dp INIT(= NULL); // File descriptor of temp dir\n# endif\nEXTERN char_u\t*vim_tempdir INIT(= NULL); // Name of Vim's own temp dir.\n\t\t\t\t\t   // Ends in a slash.\n#endif\n\n/*\n * When starting or exiting some things are done differently (e.g. screen\n * updating).\n */\nEXTERN int\tstarting INIT(= NO_SCREEN);\n\t\t\t\t// first NO_SCREEN, then NO_BUFFERS and then\n\t\t\t\t// set to 0 when starting up finished\nEXTERN int\texiting INIT(= FALSE);\n\t\t\t\t// TRUE when planning to exit Vim.  Might\n\t\t\t\t// still keep on running if there is a changed\n\t\t\t\t// buffer.\nEXTERN int\treally_exiting INIT(= FALSE);\n\t\t\t\t// TRUE when we are sure to exit, e.g., after\n\t\t\t\t// a deadly signal\nEXTERN int\tv_dying INIT(= 0); // internal value of v:dying\nEXTERN int\tstdout_isatty INIT(= TRUE);\t// is stdout a terminal?\n\n#if defined(FEAT_AUTOCHDIR)\nEXTERN int\ttest_autochdir INIT(= FALSE);\n#endif\nEXTERN char\t*last_chdir_reason INIT(= NULL);\n#if defined(EXITFREE)\nEXTERN int\tentered_free_all_mem INIT(= FALSE);\n\t\t\t\t// TRUE when in or after free_all_mem()\n#endif\n// volatile because it is used in signal handler deathtrap().\nEXTERN volatile sig_atomic_t full_screen INIT(= FALSE);\n\t\t\t\t// TRUE when doing full-screen output\n\t\t\t\t// otherwise only writing some messages\n\nEXTERN int\trestricted INIT(= FALSE);\n\t\t\t\t// TRUE when started as \"rvim\"\nEXTERN int\tsecure INIT(= FALSE);\n\t\t\t\t// non-zero when only \"safe\" commands are\n\t\t\t\t// allowed, e.g. when sourcing .exrc or .vimrc\n\t\t\t\t// in current directory\n\nEXTERN int\ttextlock INIT(= 0);\n\t\t\t\t// non-zero when changing text and jumping to\n\t\t\t\t// another window or editing another buffer is\n\t\t\t\t// not allowed\n\nEXTERN int\tcurbuf_lock INIT(= 0);\n\t\t\t\t// non-zero when the current buffer can't be\n\t\t\t\t// changed.  Used for FileChangedRO.\nEXTERN int\tallbuf_lock INIT(= 0);\n\t\t\t\t// non-zero when no buffer name can be\n\t\t\t\t// changed, no buffer can be deleted and\n\t\t\t\t// current directory can't be changed.\n\t\t\t\t// Used for SwapExists et al.\n#ifdef HAVE_SANDBOX\nEXTERN int\tsandbox INIT(= 0);\n\t\t\t\t// Non-zero when evaluating an expression in a\n\t\t\t\t// \"sandbox\".  Several things are not allowed\n\t\t\t\t// then.\n#endif\n\nEXTERN int\tsilent_mode INIT(= FALSE);\n\t\t\t\t// set to TRUE when \"-s\" commandline argument\n\t\t\t\t// used for ex\n\nEXTERN pos_T\tVIsual;\t\t// start position of active Visual selection\nEXTERN int\tVIsual_active INIT(= FALSE);\n\t\t\t\t// whether Visual mode is active\nEXTERN int\tVIsual_select INIT(= FALSE);\n\t\t\t\t// whether Select mode is active\nEXTERN int\tVIsual_select_reg INIT(= 0);\n\t\t\t\t// register name for Select mode\nEXTERN int\trestart_VIsual_select INIT(= 0);\n\t\t\t\t// restart Select mode when next cmd finished\nEXTERN int\tVIsual_reselect;\n\t\t\t\t// whether to restart the selection after a\n\t\t\t\t// Select mode mapping or menu\n\nEXTERN int\tVIsual_mode INIT(= 'v');\n\t\t\t\t// type of Visual mode\n\nEXTERN int\tredo_VIsual_busy INIT(= FALSE);\n\t\t\t\t// TRUE when redoing Visual\n\n/*\n * The Visual area is remembered for reselection.\n */\nEXTERN int\tresel_VIsual_mode INIT(= NUL);\t// 'v', 'V', or Ctrl-V\nEXTERN linenr_T\tresel_VIsual_line_count;\t// number of lines\nEXTERN colnr_T\tresel_VIsual_vcol;\t\t// nr of cols or end col\n\n/*\n * When pasting text with the middle mouse button in visual mode with\n * restart_edit set, remember where it started so we can set Insstart.\n */\nEXTERN pos_T\twhere_paste_started;\n\n/*\n * This flag is used to make auto-indent work right on lines where only a\n * <RETURN> or <ESC> is typed. It is set when an auto-indent is done, and\n * reset when any other editing is done on the line. If an <ESC> or <RETURN>\n * is received, and did_ai is TRUE, the line is truncated.\n */\nEXTERN int     did_ai INIT(= FALSE);\n\n/*\n * Column of first char after autoindent.  0 when no autoindent done.  Used\n * when 'backspace' is 0, to avoid backspacing over autoindent.\n */\nEXTERN colnr_T\tai_col INIT(= 0);\n\n/*\n * This is a character which will end a start-middle-end comment when typed as\n * the first character on a new line.  It is taken from the last character of\n * the \"end\" comment leader when the COM_AUTO_END flag is given for that\n * comment end in 'comments'.  It is only valid when did_ai is TRUE.\n */\nEXTERN int     end_comment_pending INIT(= NUL);\n\n/*\n * This flag is set after a \":syncbind\" to let the check_scrollbind() function\n * know that it should not attempt to perform scrollbinding due to the scroll\n * that was a result of the \":syncbind.\" (Otherwise, check_scrollbind() will\n * undo some of the work done by \":syncbind.\")  -ralston\n */\nEXTERN int     did_syncbind INIT(= FALSE);\n\n/*\n * This flag is set when a smart indent has been performed. When the next typed\n * character is a '{' the inserted tab will be deleted again.\n */\nEXTERN int\tdid_si INIT(= FALSE);\n\n/*\n * This flag is set after an auto indent. If the next typed character is a '}'\n * one indent will be removed.\n */\nEXTERN int\tcan_si INIT(= FALSE);\n\n/*\n * This flag is set after an \"O\" command. If the next typed character is a '{'\n * one indent will be removed.\n */\nEXTERN int\tcan_si_back INIT(= FALSE);\n\nEXTERN int\told_indent INIT(= 0);\t// for ^^D command in insert mode\n\nEXTERN pos_T\tsaved_cursor\t\t// w_cursor before formatting text.\n#ifdef DO_INIT\n\t= {0, 0, 0}\n#endif\n\t;\n\n/*\n * Stuff for insert mode.\n */\nEXTERN pos_T\tInsstart;\t\t// This is where the latest\n\t\t\t\t\t// insert/append mode started.\n\n// This is where the latest insert/append mode started. In contrast to\n// Insstart, this won't be reset by certain keys and is needed for\n// op_insert(), to detect correctly where inserting by the user started.\nEXTERN pos_T\tInsstart_orig;\n\n/*\n * Stuff for MODE_VREPLACE state.\n */\nEXTERN int\torig_line_count INIT(= 0);  // Line count when \"gR\" started\nEXTERN int\tvr_lines_changed INIT(= 0); // #Lines changed by \"gR\" so far\n\n#if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)\n// argument to SETJMP() for handling X IO errors\nEXTERN JMP_BUF x_jump_env;\n#endif\n\n/*\n * These flags are set based upon 'fileencoding'.\n * Note that \"enc_utf8\" is also set for \"unicode\", because the characters are\n * internally stored as UTF-8 (to avoid trouble with NUL bytes).\n */\n#define DBCS_JPN\t932\t// japan\n#define DBCS_JPNU\t9932\t// euc-jp\n#define DBCS_KOR\t949\t// korea\n#define DBCS_KORU\t9949\t// euc-kr\n#define DBCS_CHS\t936\t// chinese\n#define DBCS_CHSU\t9936\t// euc-cn\n#define DBCS_CHT\t950\t// taiwan\n#define DBCS_CHTU\t9950\t// euc-tw\n#define DBCS_2BYTE\t1\t// 2byte-\n#define DBCS_DEBUG\t(-1)\n\nEXTERN int\tenc_dbcs INIT(= 0);\t\t// One of DBCS_xxx values if\n\t\t\t\t\t\t// DBCS encoding\nEXTERN int\tenc_unicode INIT(= 0);\t// 2: UCS-2 or UTF-16, 4: UCS-4\nEXTERN int\tenc_utf8 INIT(= FALSE);\t\t// UTF-8 encoded Unicode\nEXTERN int\tenc_latin1like INIT(= TRUE);\t// 'encoding' is latin1 comp.\n#if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n// Codepage nr of 'encoding'.  Negative means it's not been set yet, zero\n// means 'encoding' is not a valid codepage.\nEXTERN int\tenc_codepage INIT(= -1);\nEXTERN int\tenc_latin9 INIT(= FALSE);\t// 'encoding' is latin9\n#endif\nEXTERN int\thas_mbyte INIT(= 0);\t\t// any multi-byte encoding\n\n/*\n * To speed up BYTELEN() we fill a table with the byte lengths whenever\n * enc_utf8 or enc_dbcs changes.\n */\nEXTERN char\tmb_bytelen_tab[256];\n\n// Variables that tell what conversion is used for keyboard input and display\n// output.\nEXTERN vimconv_T input_conv;\t\t\t// type of input conversion\nEXTERN vimconv_T output_conv;\t\t\t// type of output conversion\n\n/*\n * Function pointers, used to quickly get to the right function.  Each has\n * three possible values: latin_ (8-bit), utfc_ or utf_ (utf-8) and dbcs_\n * (DBCS).\n * The value is set in mb_init();\n */\n// length of char in bytes, including following composing chars\nEXTERN int (*mb_ptr2len)(char_u *p) INIT(= latin_ptr2len);\n\n// idem, with limit on string length\nEXTERN int (*mb_ptr2len_len)(char_u *p, int size) INIT(= latin_ptr2len_len);\n\n// byte length of char\nEXTERN int (*mb_char2len)(int c) INIT(= latin_char2len);\n\n// Convert char \"c\" to bytes in \"buf\", return the length.  \"buf\" must have room\n// for at least 6 bytes.\nEXTERN int (*mb_char2bytes)(int c, char_u *buf) INIT(= latin_char2bytes);\n\nEXTERN int (*mb_ptr2cells)(char_u *p) INIT(= latin_ptr2cells);\nEXTERN int (*mb_ptr2cells_len)(char_u *p, int size) INIT(= latin_ptr2cells_len);\nEXTERN int (*mb_char2cells)(int c) INIT(= latin_char2cells);\nEXTERN int (*mb_off2cells)(unsigned off, unsigned max_off) INIT(= latin_off2cells);\nEXTERN int (*mb_ptr2char)(char_u *p) INIT(= latin_ptr2char);\n\n// Byte offset from \"p\" to the start of a character, including any composing\n// characters. \"base\" must be the start of the string, which must be NUL\n// terminated.\nEXTERN int (*mb_head_off)(char_u *base, char_u *p) INIT(= latin_head_off);\n\n# if defined(USE_ICONV) && defined(DYNAMIC_ICONV)\n// Pointers to functions and variables to be loaded at runtime\nEXTERN size_t (*iconv) (iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);\nEXTERN iconv_t (*iconv_open) (const char *tocode, const char *fromcode);\nEXTERN int (*iconv_close) (iconv_t cd);\nEXTERN int (*iconvctl) (iconv_t cd, int request, void *argument);\nEXTERN int* (*iconv_errno) (void);\n# endif\n\n\n#ifdef FEAT_XIM\n# ifdef FEAT_GUI_GTK\nEXTERN GtkIMContext\t*xic INIT(= NULL);\n/*\n * Start and end column of the preedit area in virtual columns from the start\n * of the text line.  When there is no preedit area they are set to MAXCOL.\n * \"preedit_end_col\" is needed for coloring the preedited string.  Drawing the\n * color between \"preedit_start_col\" and curpos did not work, because some XIM\n * set the cursor position to the first char of the string.\n */\nEXTERN colnr_T\t\tpreedit_start_col INIT(= MAXCOL);\nEXTERN colnr_T\t\tpreedit_end_col INIT(= MAXCOL);\n\n// \"xim_changed_while_preediting\" is set when changed() can set the 'modified'\n// flag even while preediting.\nEXTERN int\t\txim_changed_while_preediting INIT(= FALSE);\n# else\nEXTERN XIC\t\txic INIT(= NULL);\n# endif\n# ifdef FEAT_GUI\nEXTERN guicolor_T\txim_fg_color INIT(= INVALCOLOR);\nEXTERN guicolor_T\txim_bg_color INIT(= INVALCOLOR);\n# endif\n#endif\n\n/*\n * \"State\" is the main state of Vim.\n * There are other variables that modify the state:\n * \"Visual_mode\"    When State is MODE_NORMAL or MODE_INSERT.\n * \"finish_op\"\t    When State is MODE_NORMAL, after typing the operator and\n *\t\t    before typing the motion command.\n * \"motion_force\"   Last motion_force  from do_pending_operator()\n * \"debug_mode\"\t    Debug mode.\n */\nEXTERN int\tState INIT(= MODE_NORMAL);\n\n#ifdef FEAT_EVAL\nEXTERN int\tdebug_mode INIT(= FALSE);\n#endif\n\nEXTERN int\tfinish_op INIT(= FALSE);// TRUE while an operator is pending\nEXTERN long\topcount INIT(= 0);\t// count for pending operator\nEXTERN int\tmotion_force INIT(= 0); // motion force for pending operator\n\n/*\n * Ex mode (Q) state\n */\nEXTERN int exmode_active INIT(= 0);\t// zero, EXMODE_NORMAL or EXMODE_VIM\n\n// Flag set when main_loop() should exit when entering Ex mode.\nEXTERN int pending_exmode_active INIT(= FALSE);\n\nEXTERN int ex_no_reprint INIT(= FALSE); // no need to print after z or p\n\nEXTERN int reg_recording INIT(= 0);\t// register for recording  or zero\nEXTERN int reg_executing INIT(= 0);\t// register being executed or zero\n// Flag set when peeking a character and found the end of executed register\nEXTERN int pending_end_reg_executing INIT(= 0);\n\n// Set when a modifyOtherKeys sequence was seen, then simplified mappings will\n// no longer be used.\nEXTERN int seenModifyOtherKeys INIT(= FALSE);\n\nEXTERN int no_mapping INIT(= FALSE);\t// currently no mapping allowed\nEXTERN int no_zero_mapping INIT(= 0);\t// mapping zero not allowed\nEXTERN int allow_keys INIT(= FALSE);\t// allow key codes when no_mapping\n\t\t\t\t\t// is set\nEXTERN int no_reduce_keys INIT(= FALSE);  // do not apply Ctrl, Shift and Alt\n\t\t\t\t\t  // to the key\nEXTERN int no_u_sync INIT(= 0);\t\t// Don't call u_sync()\n#ifdef FEAT_EVAL\nEXTERN int u_sync_once INIT(= 0);\t// Call u_sync() once when evaluating\n\t\t\t\t\t// an expression.\n#endif\n\nEXTERN int restart_edit INIT(= 0);\t// call edit when next cmd finished\nEXTERN int arrow_used;\t\t\t// Normally FALSE, set to TRUE after\n\t\t\t\t\t// hitting cursor key in insert mode.\n\t\t\t\t\t// Used by vgetorpeek() to decide when\n\t\t\t\t\t// to call u_sync()\nEXTERN int\tins_at_eol INIT(= FALSE); // put cursor after eol when\n\t\t\t\t\t  // restarting edit after CTRL-O\n\nEXTERN int\tno_abbr INIT(= TRUE);\t// TRUE when no abbreviations loaded\n\n#ifdef USE_EXE_NAME\nEXTERN char_u\t*exe_name;\t\t// the name of the executable\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\nEXTERN int\tdont_scroll INIT(= FALSE);// don't use scrollbars when TRUE\n#endif\nEXTERN int\tmapped_ctrl_c INIT(= FALSE); // modes where CTRL-C is mapped\nEXTERN int\tctrl_c_interrupts INIT(= TRUE);\t// CTRL-C sets got_int\n\nEXTERN cmdmod_T\tcmdmod;\t\t\t// Ex command modifiers\nEXTERN int\tsticky_cmdmod_flags INIT(= 0); // used by :execute\n\n#ifdef FEAT_EVAL\nEXTERN int\tis_export INIT(= FALSE);    // :export {cmd}\n#endif\n\nEXTERN int\tmsg_silent INIT(= 0);\t// don't print messages\nEXTERN int\temsg_silent INIT(= 0);\t// don't print error messages\n#ifdef FEAT_EVAL\nEXTERN int\temsg_silent_def INIT(= 0);  // value of emsg_silent when a :def\n\t\t\t\t\t    // function is called\n#endif\nEXTERN int\temsg_noredir INIT(= 0);\t// don't redirect error messages\nEXTERN int\tcmd_silent INIT(= FALSE); // don't echo the command line\n\nEXTERN int\tin_assert_fails INIT(= FALSE);\t// assert_fails() active\n\nEXTERN int\tswap_exists_action INIT(= SEA_NONE);\n\t\t\t\t\t// For dialog when swap file already\n\t\t\t\t\t// exists.\nEXTERN int\tswap_exists_did_quit INIT(= FALSE);\n\t\t\t\t\t// Selected \"quit\" at the dialog.\n\nEXTERN char_u\t*IObuff;\t\t// sprintf's are done in this buffer,\n\t\t\t\t\t// size is IOSIZE\nEXTERN char_u\t*NameBuff;\t\t// file names are expanded in this\n\t\t\t\t\t// buffer, size is MAXPATHL\nEXTERN char\tmsg_buf[MSG_BUF_LEN];\t// small buffer for messages\n\n// When non-zero, postpone redrawing.\nEXTERN int\tRedrawingDisabled INIT(= 0);\n\nEXTERN int\treadonlymode INIT(= FALSE); // Set to TRUE for \"view\"\nEXTERN int\trecoverymode INIT(= FALSE); // Set to TRUE for \"-r\" option\n\nEXTERN typebuf_T typebuf\t\t// typeahead buffer\n#ifdef DO_INIT\n\t\t    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}\n#endif\n\t\t    ;\nEXTERN int\tex_normal_busy INIT(= 0);   // recursiveness of ex_normal()\n#ifdef FEAT_EVAL\nEXTERN int\tin_feedkeys INIT(= 0);\t    // ex_normal_busy set in feedkeys()\n#endif\nEXTERN int\tex_normal_lock INIT(= 0);   // forbid use of ex_normal()\n\n#ifdef FEAT_EVAL\nEXTERN int\tignore_script INIT(= FALSE);  // ignore script input\n#endif\nEXTERN int\tstop_insert_mode;\t// for \":stopinsert\" and 'insertmode'\n\nEXTERN int\tKeyTyped;\t\t// TRUE if user typed current char\nEXTERN int\tKeyStuffed;\t\t// TRUE if current char from stuffbuf\n#ifdef HAVE_INPUT_METHOD\nEXTERN int\tvgetc_im_active;\t// Input Method was active for last\n\t\t\t\t\t// character obtained from vgetc()\n#endif\nEXTERN int\tmaptick INIT(= 0);\t// tick for each non-mapped char\n\nEXTERN int\tmust_redraw INIT(= 0);\t    // type of redraw necessary\nEXTERN int\tskip_redraw INIT(= FALSE);  // skip redraw once\nEXTERN int\tdo_redraw INIT(= FALSE);    // extra redraw once\n#ifdef FEAT_DIFF\nEXTERN int\tneed_diff_redraw INIT(= 0); // need to call diff_redraw()\n#endif\n#ifdef FEAT_RELTIME\n// flag set when 'redrawtime' timeout has been set\nEXTERN int\tredrawtime_limit_set INIT(= FALSE);\n#endif\n\nEXTERN int\tneed_highlight_changed INIT(= TRUE);\n\n#define NSCRIPT 15\nEXTERN FILE\t*scriptin[NSCRIPT];\t    // streams to read script from\nEXTERN int\tcurscript INIT(= 0);\t    // index in scriptin[]\nEXTERN FILE\t*scriptout  INIT(= NULL);   // stream to write script to\nEXTERN int\tread_cmd_fd INIT(= 0);\t    // fd to read commands from\n\n// Set to TRUE when an interrupt signal occurred.\n// Volatile because it is used in signal handler catch_sigint().\nEXTERN volatile sig_atomic_t got_int INIT(= FALSE);\n\n// Set to TRUE when SIGUSR1 signal was detected.\n// Volatile because it is used in signal handler catch_sigint().\nEXTERN volatile sig_atomic_t got_sigusr1 INIT(= FALSE);\n\n#ifdef USE_TERM_CONSOLE\nEXTERN int\tterm_console INIT(= FALSE); // set to TRUE when console used\n#endif\nEXTERN int\ttermcap_active INIT(= FALSE);\t// set by starttermcap()\nEXTERN tmode_T\tcur_tmode INIT(= TMODE_COOK);\t// input terminal mode\nEXTERN int\tbangredo INIT(= FALSE);\t    // set to TRUE with ! command\nEXTERN int\tsearchcmdlen;\t\t    // length of previous search cmd\n#ifdef FEAT_SYN_HL\nEXTERN int\treg_do_extmatch INIT(= 0);  // Used when compiling regexp:\n\t\t\t\t\t    // REX_SET to allow \\z\\(...\\),\n\t\t\t\t\t    // REX_USE to allow \\z\\1 et al.\nEXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); // Used by vim_regexec():\n\t\t\t\t\t    // strings for \\z\\1...\\z\\9\nEXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); // Set by vim_regexec()\n\t\t\t\t\t    // to store \\z\\(...\\) matches\n#endif\n\nEXTERN int\tdid_outofmem_msg INIT(= FALSE);\n\t\t\t\t\t    // set after out of memory msg\nEXTERN int\tdid_swapwrite_msg INIT(= FALSE);\n\t\t\t\t\t    // set after swap write error msg\nEXTERN int\tundo_off INIT(= FALSE);\t    // undo switched off for now\nEXTERN int\tglobal_busy INIT(= 0);\t    // set when :global is executing\nEXTERN int\tlistcmd_busy INIT(= FALSE); // set when :argdo, :windo or\n\t\t\t\t\t    // :bufdo is executing\nEXTERN int\tneed_start_insertmode INIT(= FALSE);\n\t\t\t\t\t    // start insert mode soon\n#if defined(FEAT_EVAL) || defined(PROTO)\nEXTERN char_u\tlast_mode[MODE_MAX_LENGTH] INIT(= \"n\"); // for ModeChanged event\n#endif\nEXTERN char_u\t*last_cmdline INIT(= NULL); // last command line (for \":)\nEXTERN char_u\t*repeat_cmdline INIT(= NULL); // command line for \".\"\nEXTERN char_u\t*new_last_cmdline INIT(= NULL);\t// new value for last_cmdline\nEXTERN char_u\t*autocmd_fname INIT(= NULL); // fname for <afile> on cmdline\nEXTERN int\tautocmd_fname_full;\t     // autocmd_fname is full path\nEXTERN int\tautocmd_bufnr INIT(= 0);     // fnum for <abuf> on cmdline\nEXTERN char_u\t*autocmd_match INIT(= NULL); // name for <amatch> on cmdline\nEXTERN int\tdid_cursorhold INIT(= FALSE); // set when CursorHold t'gerd\nEXTERN pos_T\tlast_cursormoved\t      // for CursorMoved event\n# ifdef DO_INIT\n\t\t\t= {0, 0, 0}\n# endif\n\t\t\t;\n\nEXTERN int\tpostponed_split INIT(= 0);  // for CTRL-W CTRL-] command\nEXTERN int\tpostponed_split_flags INIT(= 0);  // args for win_split()\nEXTERN int\tpostponed_split_tab INIT(= 0);  // cmdmod.cmod_tab\n#ifdef FEAT_QUICKFIX\nEXTERN int\tg_do_tagpreview INIT(= 0);  // for tag preview commands:\n\t\t\t\t\t    // height of preview window\n#endif\nEXTERN int\tg_tag_at_cursor INIT(= FALSE); // whether the tag command comes\n\t\t\t\t\t    // from the command line (0) or was\n\t\t\t\t\t    // invoked as a normal command (1)\n\nEXTERN int\treplace_offset INIT(= 0);   // offset for replace_push()\n\nEXTERN char_u\t*escape_chars INIT(= (char_u *)\" \\t\\\\\\\"|\");\n\t\t\t\t\t    // need backslash in cmd line\n\nEXTERN int\tkeep_help_flag INIT(= FALSE); // doing :ta from help file\n\n/*\n * When a string option is NULL (which only happens in out-of-memory\n * situations), it is set to empty_option, to avoid having to check for NULL\n * everywhere.\n */\nEXTERN char_u\t*empty_option INIT(= (char_u *)\"\");\n\nEXTERN int  redir_off INIT(= FALSE);\t// no redirection for a moment\nEXTERN FILE *redir_fd INIT(= NULL);\t// message redirection file\n#ifdef FEAT_EVAL\nEXTERN int  redir_reg INIT(= 0);\t// message redirection register\nEXTERN int  redir_vname INIT(= 0);\t// message redirection variable\nEXTERN int  redir_execute INIT(= 0);\t// execute() redirection\n#endif\n\n#ifdef FEAT_LANGMAP\nEXTERN char_u\tlangmap_mapchar[256];\t// mapping for language keys\n#endif\n\n#ifdef FEAT_WILDMENU\nEXTERN int  save_p_ls INIT(= -1);\t// Save 'laststatus' setting\nEXTERN int  save_p_wmh INIT(= -1);\t// Save 'winminheight' setting\nEXTERN int  wild_menu_showing INIT(= 0);\n# define WM_SHOWN\t1\t\t// wildmenu showing\n# define WM_SCROLLED\t2\t\t// wildmenu showing with scroll\n#endif\n\n#ifdef MSWIN\nEXTERN char_u\ttoupper_tab[256];\t// table for toupper()\nEXTERN char_u\ttolower_tab[256];\t// table for tolower()\nEXTERN int\tfound_register_arg INIT(= FALSE);\n#endif\n\n#ifdef FEAT_LINEBREAK\nEXTERN char\tbreakat_flags[256];\t// which characters are in 'breakat'\n#endif\n\n// These are in version.c, call init_longVersion() before use.\nextern char *Version;\n#if defined(HAVE_DATE_TIME) && defined(VMS) && defined(VAXC)\nextern char longVersion[];\n#else\nextern char *longVersion;\n#endif\n\n/*\n * Some file names are stored in pathdef.c, which is generated from the\n * Makefile to make their value depend on the Makefile.\n */\n#ifdef HAVE_PATHDEF\nextern char_u *default_vim_dir;\nextern char_u *default_vimruntime_dir;\nextern char_u *all_cflags;\nextern char_u *all_lflags;\n# ifdef VMS\nextern char_u *compiler_version;\nextern char_u *compiled_arch;\n# endif\nextern char_u *compiled_user;\nextern char_u *compiled_sys;\n#endif\n\nEXTERN char_u\t*homedir INIT(= NULL);\n\n// When a window has a local directory, the absolute path of the global\n// current directory is stored here (in allocated memory).  If the current\n// directory is not a local directory, globaldir is NULL.\nEXTERN char_u\t*globaldir INIT(= NULL);\n\n#ifdef FEAT_FOLDING\nEXTERN int\tdisable_fold_update INIT(= 0);\n#endif\n\n// Whether 'keymodel' contains \"stopsel\" and \"startsel\".\nEXTERN int\tkm_stopsel INIT(= FALSE);\nEXTERN int\tkm_startsel INIT(= FALSE);\n\n#ifdef FEAT_CMDWIN\nEXTERN int\tcmdwin_type INIT(= 0);\t// type of cmdline window or 0\nEXTERN int\tcmdwin_result INIT(= 0); // result of cmdline window or 0\n#endif\n\nEXTERN char_u no_lines_msg[]\tINIT(= N_(\"--No lines in buffer--\"));\n\n/*\n * When \":global\" is used to number of substitutions and changed lines is\n * accumulated until it's finished.\n * Also used for \":spellrepall\".\n */\nEXTERN long\tsub_nsubs;\t// total number of substitutions\nEXTERN linenr_T\tsub_nlines;\t// total number of lines changed\n\n#ifdef FEAT_EVAL\n// Used when a compiled :substitute has an expression.\nEXTERN struct subs_expr_S\t*substitute_instr INIT(= NULL);\n#endif\n\n// table to store parsed 'wildmode'\nEXTERN char_u\twim_flags[4];\n\n#if defined(FEAT_STL_OPT)\n// whether titlestring and iconstring contains statusline syntax\n# define STL_IN_ICON\t1\n# define STL_IN_TITLE\t2\nEXTERN int      stl_syntax INIT(= 0);\n#endif\n\n#if defined(FEAT_BEVAL) && !defined(NO_X11_INCLUDES)\nEXTERN BalloonEval\t*balloonEval INIT(= NULL);\nEXTERN int\t\tballoonEvalForTerm INIT(= FALSE);\n# if defined(FEAT_NETBEANS_INTG)\nEXTERN int bevalServers INIT(= 0);\n#  define BEVAL_NETBEANS\t\t0x01\n# endif\n#endif\n\n#ifdef CURSOR_SHAPE\n// the table is in misc2.c, because of initializations\nextern cursorentry_T shape_table[SHAPE_IDX_COUNT];\n#endif\n\n#ifdef FEAT_PRINTER\n/*\n * Printer stuff shared between hardcopy.c and machine-specific printing code.\n */\n# define OPT_PRINT_TOP\t\t0\n# define OPT_PRINT_BOT\t\t1\n# define OPT_PRINT_LEFT\t\t2\n# define OPT_PRINT_RIGHT\t3\n# define OPT_PRINT_HEADERHEIGHT\t4\n# define OPT_PRINT_SYNTAX\t5\n# define OPT_PRINT_NUMBER\t6\n# define OPT_PRINT_WRAP\t\t7\n# define OPT_PRINT_DUPLEX\t8\n# define OPT_PRINT_PORTRAIT\t9\n# define OPT_PRINT_PAPER\t10\n# define OPT_PRINT_COLLATE\t11\n# define OPT_PRINT_JOBSPLIT\t12\n# define OPT_PRINT_FORMFEED\t13\n\n# define OPT_PRINT_NUM_OPTIONS\t14\n\nEXTERN option_table_T printer_opts[OPT_PRINT_NUM_OPTIONS]\n# ifdef DO_INIT\n =\n{\n    {\"top\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"bottom\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"left\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"right\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"header\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"syntax\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"number\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"wrap\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"duplex\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"portrait\", FALSE, 0, NULL, 0, FALSE},\n    {\"paper\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"collate\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},\n    {\"formfeed\", FALSE, 0, NULL, 0, FALSE},\n}\n# endif\n;\n\n// For prt_get_unit().\n# define PRT_UNIT_NONE\t-1\n# define PRT_UNIT_PERC\t0\n# define PRT_UNIT_INCH\t1\n# define PRT_UNIT_MM\t2\n# define PRT_UNIT_POINT\t3\n# define PRT_UNIT_NAMES {\"pc\", \"in\", \"mm\", \"pt\"}\n#endif\n\n#if (defined(FEAT_PRINTER) && defined(FEAT_STL_OPT)) \\\n\t    || defined(FEAT_GUI_TABLINE)\n// Page number used for %N in 'pageheader' and 'guitablabel'.\nEXTERN linenr_T printer_page_num;\n#endif\n\n#ifdef FEAT_XCLIPBOARD\n// xterm display name\nEXTERN char\t*xterm_display INIT(= NULL);\n\n// whether xterm_display was allocated, when FALSE it points into argv[]\nEXTERN int\txterm_display_allocated INIT(= FALSE);\n\n// xterm display pointer\nEXTERN Display\t*xterm_dpy INIT(= NULL);\n#endif\n#if defined(FEAT_XCLIPBOARD) || defined(FEAT_GUI_X11)\nEXTERN XtAppContext app_context INIT(= (XtAppContext)NULL);\n#endif\n\n#ifdef FEAT_GUI_GTK\nEXTERN guint32\tgtk_socket_id INIT(= 0);\nEXTERN int\techo_wid_arg INIT(= FALSE);\t// --echo-wid argument\n#endif\n\n#ifdef FEAT_GUI_MSWIN\n/*\n * The value of the --windowid argument.\n * For embedding gvim inside another application.\n */\nEXTERN long_u\twin_socket_id INIT(= 0);\n#endif\n\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\nEXTERN int\ttypebuf_was_filled INIT(= FALSE); // received text from client\n\t\t\t\t\t\t  // or from feedkeys()\n#endif\n\n#ifdef FEAT_CLIENTSERVER\nEXTERN char_u\t*serverName INIT(= NULL);\t// name of the server\n# ifdef FEAT_X11\nEXTERN Window\tcommWindow INIT(= None);\nEXTERN Window\tclientWindow INIT(= None);\nEXTERN Atom\tcommProperty INIT(= None);\nEXTERN char_u\t*serverDelayedStartName INIT(= NULL);\n# else\n#  ifdef PROTO\ntypedef int HWND;\n#  endif\nEXTERN HWND\tclientWindow INIT(= 0);\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\nEXTERN int\tterm_is_xterm INIT(= FALSE);\t// xterm-like 'term'\n#endif\n\n#ifdef BACKSLASH_IN_FILENAME\nEXTERN char\tpsepc INIT(= '\\\\');\t// normal path separator character\nEXTERN char\tpsepcN INIT(= '/');\t// abnormal path separator character\n// normal path separator string\nEXTERN char\tpseps[2] INIT2('\\\\', 0);\n#endif\n\n// Set to TRUE when an operator is being executed with virtual editing, MAYBE\n// when no operator is being executed, FALSE otherwise.\nEXTERN int\tvirtual_op INIT(= MAYBE);\n\n#ifdef FEAT_SYN_HL\n// Display tick, incremented for each call to update_screen()\nEXTERN disptick_T\tdisplay_tick INIT(= 0);\n#endif\n\n#ifdef FEAT_SPELL\n// Line in which spell checking wasn't highlighted because it touched the\n// cursor position in Insert mode.\nEXTERN linenr_T\t\tspell_redraw_lnum INIT(= 0);\n\n#define FOR_ALL_SPELL_LANGS(slang) \\\n    for ((slang) = first_lang; (slang) != NULL; (slang) = (slang)->sl_next)\n#endif\n\n#ifdef FEAT_CONCEAL\n// Set when the cursor line needs to be redrawn.\nEXTERN int\t\tneed_cursor_line_redraw INIT(= FALSE);\n#endif\n\n#ifdef USE_MCH_ERRMSG\n// Grow array to collect error messages in until they can be displayed.\nEXTERN garray_T error_ga\n# ifdef DO_INIT\n\t= {0, 0, 0, 0, NULL}\n# endif\n\t;\n#endif\n\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char *netbeansArg INIT(= NULL);\t// the -nb[:host:port:passwd] arg\nEXTERN int netbeansFireChanges INIT(= 1); // send buffer changes if != 0\nEXTERN int netbeansForcedQuit INIT(= 0);// don't write modified files\nEXTERN int netbeansReadFile INIT(= 1);\t// OK to read from disk if != 0\nEXTERN int netbeansSuppressNoLines INIT(= 0); // skip \"No lines in buffer\"\n#endif\n\n/*\n * Some messages that can be shared are included here.\n */\nEXTERN char top_bot_msg[]   INIT(= N_(\"search hit TOP, continuing at BOTTOM\"));\nEXTERN char bot_top_msg[]   INIT(= N_(\"search hit BOTTOM, continuing at TOP\"));\n\n#ifdef FEAT_EVAL\nEXTERN char line_msg[]\t    INIT(= N_(\" line \"));\n#endif\n\n#ifdef FEAT_CRYPT\nEXTERN char need_key_msg[]  INIT(= N_(\"Need encryption key for \\\"%s\\\"\"));\n#endif\n\n/*\n * Comms. with the session manager (XSMP)\n */\n#ifdef USE_XSMP\nEXTERN int xsmp_icefd INIT(= -1);   // The actual connection\n#endif\n\n// For undo we need to know the lowest time possible.\nEXTERN time_T starttime;\n\n#ifdef STARTUPTIME\nEXTERN FILE *time_fd INIT(= NULL);  // where to write startup timing\n#endif\n\n/*\n * Some compilers warn for not using a return value, but in some situations we\n * can't do anything useful with the value.  Assign to this variable to avoid\n * the warning.\n */\nEXTERN int vim_ignored;\nEXTERN char *vim_ignoredp;\n\n#ifdef FEAT_EVAL\n// set by alloc_fail(): ID\nEXTERN alloc_id_T  alloc_fail_id INIT(= aid_none);\n// set by alloc_fail(), when zero alloc() returns NULL\nEXTERN int  alloc_fail_countdown INIT(= -1);\n// set by alloc_fail(), number of times alloc() returns NULL\nEXTERN int  alloc_fail_repeat INIT(= 0);\n\n// flags set by test_override()\nEXTERN int  disable_char_avail_for_testing INIT(= FALSE);\nEXTERN int  disable_redraw_for_testing INIT(= FALSE);\nEXTERN int  ignore_redraw_flag_for_testing INIT(= FALSE);\nEXTERN int  nfa_fail_for_testing INIT(= FALSE);\nEXTERN int  no_query_mouse_for_testing INIT(= FALSE);\nEXTERN int  ui_delay_for_testing INIT(= 0);\nEXTERN int  reset_term_props_on_termresponse INIT(= FALSE);\nEXTERN int  disable_vterm_title_for_testing INIT(= FALSE);\nEXTERN long override_sysinfo_uptime INIT(= -1);\nEXTERN int  override_autoload INIT(= FALSE);\nEXTERN int  ml_get_alloc_lines INIT(= FALSE);\n\nEXTERN int  in_free_unref_items INIT(= FALSE);\n#endif\n\n#ifdef FEAT_TIMERS\nEXTERN int  did_add_timer INIT(= FALSE);\nEXTERN int  timer_busy INIT(= 0);   // when timer is inside vgetc() then > 0\n#endif\n#ifdef FEAT_EVAL\nEXTERN int  input_busy INIT(= 0);   // when inside get_user_input() then > 0\n\nEXTERN typval_T\t*lval_root INIT(= NULL);\n#endif\n\n#ifdef FEAT_BEVAL_TERM\nEXTERN int  bevalexpr_due_set INIT(= FALSE);\nEXTERN proftime_T bevalexpr_due;\n#endif\n\n#ifdef FEAT_EVAL\nEXTERN time_T time_for_testing INIT(= 0);\n\nEXTERN int echo_attr INIT(= 0);   // attributes used for \":echo\"\n\n// Abort conversion to string after a recursion error.\nEXTERN int  did_echo_string_emsg INIT(= FALSE);\n\n// Used for checking if local variables or arguments used in a lambda.\nEXTERN int *eval_lavars_used INIT(= NULL);\n\n// Only filled for Win32.\nEXTERN char windowsVersion[20] INIT(= {0});\n\n// Used for lv_first in a non-materialized range() list.\nEXTERN listitem_T range_list_item;\n\n// Passed to an eval() function to enable evaluation.\nEXTERN evalarg_T EVALARG_EVALUATE\n# ifdef DO_INIT\n\t= {EVAL_EVALUATE, 0, NULL, NULL, NULL, NULL, GA_EMPTY, GA_EMPTY, NULL,\n\t\t\t {0, 0, (int)sizeof(char_u *), 20, NULL}, 0, NULL}\n# endif\n\t;\n#endif\n\n#ifdef MSWIN\n# ifdef PROTO\ntypedef int HINSTANCE;\n# endif\nEXTERN int ctrl_break_was_pressed INIT(= FALSE);\nEXTERN HINSTANCE g_hinst INIT(= NULL);\n#endif\n\n#if defined(FEAT_JOB_CHANNEL)\nEXTERN int did_repeated_msg INIT(= 0);\n# define REPEATED_MSG_LOOKING\t    1\n# define REPEATED_MSG_SAFESTATE\t    2\n\n// This flag is set when outputting a terminal control code and reset in\n// out_flush() when characters have been written.\nEXTERN int ch_log_output INIT(= FALSE);\n\n// Whether a redraw is needed for appending a line to a buffer.\nEXTERN int channel_need_redraw INIT(= FALSE);\n\n#define FOR_ALL_CHANNELS(ch) \\\n    for ((ch) = first_channel; (ch) != NULL; (ch) = (ch)->ch_next)\n#define FOR_ALL_JOBS(job) \\\n    for ((job) = first_job; (job) != NULL; (job) = (job)->jv_next)\n#endif\n\n#if defined(FEAT_DIFF)\n#define FOR_ALL_DIFFBLOCKS_IN_TAB(tp, dp) \\\n    for ((dp) = (tp)->tp_first_diff; (dp) != NULL; (dp) = (dp)->df_next)\n#endif\n\n#define FOR_ALL_LIST_ITEMS(l, li) \\\n    for ((li) = (l) == NULL ? NULL : (l)->lv_first; (li) != NULL; (li) = (li)->li_next)\n\n// While executing a regexp and set to OPTION_MAGIC_ON or OPTION_MAGIC_OFF this\n// overrules p_magic.  Otherwise set to OPTION_MAGIC_NOT_SET.\nEXTERN optmagic_T magic_overruled INIT(= OPTION_MAGIC_NOT_SET);\n\n// Set when 'cmdheight' is changed from zero to one temporarily.\nEXTERN int made_cmdheight_nonzero INIT(= FALSE);\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n * Multibyte extensions partly by Sung-Hoon Baek\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * mbyte.c: Code specifically for handling multi-byte characters.\n *\n * The encoding used in the core is set with 'encoding'.  When 'encoding' is\n * changed, the following four variables are set (for speed).\n * Currently these types of character encodings are supported:\n *\n * \"enc_dbcs\"\t    When non-zero it tells the type of double byte character\n *\t\t    encoding (Chinese, Korean, Japanese, etc.).\n *\t\t    The cell width on the display is equal to the number of\n *\t\t    bytes.  (exception: DBCS_JPNU with first byte 0x8e)\n *\t\t    Recognizing the first or second byte is difficult, it\n *\t\t    requires checking a byte sequence from the start.\n * \"enc_utf8\"\t    When TRUE use Unicode characters in UTF-8 encoding.\n *\t\t    The cell width on the display needs to be determined from\n *\t\t    the character value.\n *\t\t    Recognizing bytes is easy: 0xxx.xxxx is a single-byte\n *\t\t    char, 10xx.xxxx is a trailing byte, 11xx.xxxx is a leading\n *\t\t    byte of a multi-byte character.\n *\t\t    To make things complicated, up to six composing characters\n *\t\t    are allowed.  These are drawn on top of the first char.\n *\t\t    For most editing the sequence of bytes with composing\n *\t\t    characters included is considered to be one character.\n * \"enc_unicode\"    When 2 use 16-bit Unicode characters (or UTF-16).\n *\t\t    When 4 use 32-but Unicode characters.\n *\t\t    Internally characters are stored in UTF-8 encoding to\n *\t\t    avoid NUL bytes.  Conversion happens when doing I/O.\n *\t\t    \"enc_utf8\" will also be TRUE.\n *\n * \"has_mbyte\" is set when \"enc_dbcs\" or \"enc_utf8\" is non-zero.\n *\n * If none of these is TRUE, 8-bit bytes are used for a character.  The\n * encoding isn't currently specified (TODO).\n *\n * 'encoding' specifies the encoding used in the core.  This is in registers,\n * text manipulation, buffers, etc.  Conversion has to be done when characters\n * in another encoding are received or send:\n *\n *\t\t       clipboard\n *\t\t\t   ^\n *\t\t\t   | (2)\n *\t\t\t   V\n *\t\t   +---------------+\n *\t      (1)  |\t\t   | (3)\n *  keyboard ----->|\t core\t   |-----> display\n *\t\t   |\t\t   |\n *\t\t   +---------------+\n *\t\t\t   ^\n *\t\t\t   | (4)\n *\t\t\t   V\n *\t\t\t file\n *\n * (1) Typed characters arrive in the current locale.  Conversion is to be\n *     done when 'encoding' is different from 'termencoding'.\n * (2) Text will be made available with the encoding specified with\n *     'encoding'.  If this is not sufficient, system-specific conversion\n *     might be required.\n * (3) For the GUI the correct font must be selected, no conversion done.\n *     Otherwise, conversion is to be done when 'encoding' differs from\n *     'termencoding'.  (Different in the GTK+ 2 port -- 'termencoding'\n *     is always used for both input and output and must always be set to\n *     \"utf-8\".  gui_mch_init() does this automatically.)\n * (4) The encoding of the file is specified with 'fileencoding'.  Conversion\n *     is to be done when it's different from 'encoding'.\n *\n * The viminfo file is a special case: Only text is converted, not file names.\n * Vim scripts may contain an \":encoding\" command.  This has an effect for\n * some commands, like \":menutrans\"\n */\n\n#include \"vim.h\"\n\n#ifdef WIN32UNIX\n# ifndef WIN32_LEAN_AND_MEAN\n#  define WIN32_LEAN_AND_MEAN\n# endif\n# if defined(FEAT_GUI) || defined(FEAT_XCLIPBOARD)\n#  ifdef __CYGWIN__\n    // ControlMask from <X11/X.h> (included in \"vim.h\") is conflicting with\n    // <w32api/windows.h> (included in <X11/Xwindows.h>).\n#   undef ControlMask\n#  endif\n#  include <X11/Xwindows.h>\n#  define WINBYTE wBYTE\n# else\n#  include <windows.h>\n#  define WINBYTE BYTE\n# endif\n# ifdef WIN32\n#  undef WIN32\t    // Some windows.h define WIN32, we don't want that here.\n# endif\n#else\n# define WINBYTE BYTE\n#endif\n\n#if (defined(MSWIN) || defined(WIN32UNIX)) && !defined(__MINGW32__)\n# include <winnls.h>\n#endif\n\n#ifdef FEAT_GUI_X11\n# include <X11/Intrinsic.h>\n#endif\n#ifdef X_LOCALE\n# include <X11/Xlocale.h>\n# if !defined(HAVE_MBLEN) && !defined(mblen)\n#  define mblen _Xmblen\n# endif\n#endif\n\n#ifdef HAVE_WCHAR_H\n# include <wchar.h>\n#endif\n\n#if 0\n// This has been disabled, because several people reported problems with the\n// wcwidth() and iswprint() library functions, esp. for Hebrew.\n# ifdef __STDC_ISO_10646__\n#  define USE_WCHAR_FUNCTIONS\n# endif\n#endif\n\nstatic int dbcs_char2len(int c);\nstatic int dbcs_char2bytes(int c, char_u *buf);\nstatic int dbcs_ptr2len(char_u *p);\nstatic int dbcs_ptr2len_len(char_u *p, int size);\nstatic int utf_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_char2cells(int c);\nstatic int dbcs_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_ptr2char(char_u *p);\nstatic int dbcs_head_off(char_u *base, char_u *p);\n#ifdef FEAT_EVAL\nstatic int cw_value(int c);\n#endif\n\n/*\n * Lookup table to quickly get the length in bytes of a UTF-8 character from\n * the first byte of a UTF-8 string.\n * Bytes which are illegal when used as the first byte have a 1.\n * The NUL byte has length 1.\n */\nstatic char utf8len_tab[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,\n};\n\n/*\n * Like utf8len_tab above, but using a zero for illegal lead bytes.\n */\nstatic char utf8len_tab_zero[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0,\n};\n\n\n/*\n * Canonical encoding names and their properties.\n * \"iso-8859-n\" is handled by enc_canonize() directly.\n */\nstatic struct\n{   char *name;\t\tint prop;\t\tint codepage;}\nenc_canon_table[] =\n{\n#define IDX_LATIN_1\t0\n    {\"latin1\",\t\tENC_8BIT + ENC_LATIN1,\t1252},\n#define IDX_ISO_2\t1\n    {\"iso-8859-2\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_3\t2\n    {\"iso-8859-3\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_4\t3\n    {\"iso-8859-4\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_5\t4\n    {\"iso-8859-5\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_6\t5\n    {\"iso-8859-6\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_7\t6\n    {\"iso-8859-7\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_8\t7\n    {\"iso-8859-8\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_9\t8\n    {\"iso-8859-9\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_10\t9\n    {\"iso-8859-10\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_11\t10\n    {\"iso-8859-11\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_13\t11\n    {\"iso-8859-13\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_14\t12\n    {\"iso-8859-14\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_15\t13\n    {\"iso-8859-15\",\tENC_8BIT + ENC_LATIN9,\t0},\n#define IDX_KOI8_R\t14\n    {\"koi8-r\",\t\tENC_8BIT,\t\t0},\n#define IDX_KOI8_U\t15\n    {\"koi8-u\",\t\tENC_8BIT,\t\t0},\n#define IDX_UTF8\t16\n    {\"utf-8\",\t\tENC_UNICODE,\t\t0},\n#define IDX_UCS2\t17\n    {\"ucs-2\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},\n#define IDX_UCS2LE\t18\n    {\"ucs-2le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},\n#define IDX_UTF16\t19\n    {\"utf-16\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},\n#define IDX_UTF16LE\t20\n    {\"utf-16le\",\tENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},\n#define IDX_UCS4\t21\n    {\"ucs-4\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},\n#define IDX_UCS4LE\t22\n    {\"ucs-4le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},\n\n    // For debugging DBCS encoding on Unix.\n#define IDX_DEBUG\t23\n    {\"debug\",\t\tENC_DBCS,\t\tDBCS_DEBUG},\n#define IDX_EUC_JP\t24\n    {\"euc-jp\",\t\tENC_DBCS,\t\tDBCS_JPNU},\n#define IDX_SJIS\t25\n    {\"sjis\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_EUC_KR\t26\n    {\"euc-kr\",\t\tENC_DBCS,\t\tDBCS_KORU},\n#define IDX_EUC_CN\t27\n    {\"euc-cn\",\t\tENC_DBCS,\t\tDBCS_CHSU},\n#define IDX_EUC_TW\t28\n    {\"euc-tw\",\t\tENC_DBCS,\t\tDBCS_CHTU},\n#define IDX_BIG5\t29\n    {\"big5\",\t\tENC_DBCS,\t\tDBCS_CHT},\n\n    // MS-DOS and MS-Windows codepages are included here, so that they can be\n    // used on Unix too.  Most of them are similar to ISO-8859 encodings, but\n    // not exactly the same.\n#define IDX_CP437\t30\n    {\"cp437\",\t\tENC_8BIT,\t\t437}, // like iso-8859-1\n#define IDX_CP737\t31\n    {\"cp737\",\t\tENC_8BIT,\t\t737}, // like iso-8859-7\n#define IDX_CP775\t32\n    {\"cp775\",\t\tENC_8BIT,\t\t775}, // Baltic\n#define IDX_CP850\t33\n    {\"cp850\",\t\tENC_8BIT,\t\t850}, // like iso-8859-4\n#define IDX_CP852\t34\n    {\"cp852\",\t\tENC_8BIT,\t\t852}, // like iso-8859-1\n#define IDX_CP855\t35\n    {\"cp855\",\t\tENC_8BIT,\t\t855}, // like iso-8859-2\n#define IDX_CP857\t36\n    {\"cp857\",\t\tENC_8BIT,\t\t857}, // like iso-8859-5\n#define IDX_CP860\t37\n    {\"cp860\",\t\tENC_8BIT,\t\t860}, // like iso-8859-9\n#define IDX_CP861\t38\n    {\"cp861\",\t\tENC_8BIT,\t\t861}, // like iso-8859-1\n#define IDX_CP862\t39\n    {\"cp862\",\t\tENC_8BIT,\t\t862}, // like iso-8859-1\n#define IDX_CP863\t40\n    {\"cp863\",\t\tENC_8BIT,\t\t863}, // like iso-8859-8\n#define IDX_CP865\t41\n    {\"cp865\",\t\tENC_8BIT,\t\t865}, // like iso-8859-1\n#define IDX_CP866\t42\n    {\"cp866\",\t\tENC_8BIT,\t\t866}, // like iso-8859-5\n#define IDX_CP869\t43\n    {\"cp869\",\t\tENC_8BIT,\t\t869}, // like iso-8859-7\n#define IDX_CP874\t44\n    {\"cp874\",\t\tENC_8BIT,\t\t874}, // Thai\n#define IDX_CP932\t45\n    {\"cp932\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_CP936\t46\n    {\"cp936\",\t\tENC_DBCS,\t\tDBCS_CHS},\n#define IDX_CP949\t47\n    {\"cp949\",\t\tENC_DBCS,\t\tDBCS_KOR},\n#define IDX_CP950\t48\n    {\"cp950\",\t\tENC_DBCS,\t\tDBCS_CHT},\n#define IDX_CP1250\t49\n    {\"cp1250\",\t\tENC_8BIT,\t\t1250}, // Czech, Polish, etc.\n#define IDX_CP1251\t50\n    {\"cp1251\",\t\tENC_8BIT,\t\t1251}, // Cyrillic\n    // cp1252 is considered to be equal to latin1\n#define IDX_CP1253\t51\n    {\"cp1253\",\t\tENC_8BIT,\t\t1253}, // Greek\n#define IDX_CP1254\t52\n    {\"cp1254\",\t\tENC_8BIT,\t\t1254}, // Turkish\n#define IDX_CP1255\t53\n    {\"cp1255\",\t\tENC_8BIT,\t\t1255}, // Hebrew\n#define IDX_CP1256\t54\n    {\"cp1256\",\t\tENC_8BIT,\t\t1256}, // Arabic\n#define IDX_CP1257\t55\n    {\"cp1257\",\t\tENC_8BIT,\t\t1257}, // Baltic\n#define IDX_CP1258\t56\n    {\"cp1258\",\t\tENC_8BIT,\t\t1258}, // Vietnamese\n\n#define IDX_MACROMAN\t57\n    {\"macroman\",\tENC_8BIT + ENC_MACROMAN, 0},\t// Mac OS\n#define IDX_DECMCS\t58\n    {\"dec-mcs\",\t\tENC_8BIT,\t\t0},\t// DEC MCS\n#define IDX_HPROMAN8\t59\n    {\"hp-roman8\",\tENC_8BIT,\t\t0},\t// HP Roman8\n#define IDX_COUNT\t60\n};\n\n/*\n * Aliases for encoding names.\n */\nstatic struct\n{   char *name;\t\tint canon;}\nenc_alias_table[] =\n{\n    {\"ansi\",\t\tIDX_LATIN_1},\n    {\"iso-8859-1\",\tIDX_LATIN_1},\n    {\"iso-8859\",\tIDX_LATIN_1},\n    {\"latin2\",\t\tIDX_ISO_2},\n    {\"latin3\",\t\tIDX_ISO_3},\n    {\"latin4\",\t\tIDX_ISO_4},\n    {\"cyrillic\",\tIDX_ISO_5},\n    {\"arabic\",\t\tIDX_ISO_6},\n    {\"greek\",\t\tIDX_ISO_7},\n#ifdef MSWIN\n    {\"hebrew\",\t\tIDX_CP1255},\n#else\n    {\"hebrew\",\t\tIDX_ISO_8},\n#endif\n    {\"latin5\",\t\tIDX_ISO_9},\n    {\"turkish\",\t\tIDX_ISO_9}, // ?\n    {\"latin6\",\t\tIDX_ISO_10},\n    {\"nordic\",\t\tIDX_ISO_10}, // ?\n    {\"thai\",\t\tIDX_ISO_11}, // ?\n    {\"latin7\",\t\tIDX_ISO_13},\n    {\"latin8\",\t\tIDX_ISO_14},\n    {\"latin9\",\t\tIDX_ISO_15},\n    {\"utf8\",\t\tIDX_UTF8},\n    {\"unicode\",\t\tIDX_UCS2},\n    {\"ucs2\",\t\tIDX_UCS2},\n    {\"ucs2be\",\t\tIDX_UCS2},\n    {\"ucs-2be\",\t\tIDX_UCS2},\n    {\"ucs2le\",\t\tIDX_UCS2LE},\n    {\"utf16\",\t\tIDX_UTF16},\n    {\"utf16be\",\t\tIDX_UTF16},\n    {\"utf-16be\",\tIDX_UTF16},\n    {\"utf16le\",\t\tIDX_UTF16LE},\n    {\"ucs4\",\t\tIDX_UCS4},\n    {\"ucs4be\",\t\tIDX_UCS4},\n    {\"ucs-4be\",\t\tIDX_UCS4},\n    {\"ucs4le\",\t\tIDX_UCS4LE},\n    {\"utf32\",\t\tIDX_UCS4},\n    {\"utf-32\",\t\tIDX_UCS4},\n    {\"utf32be\",\t\tIDX_UCS4},\n    {\"utf-32be\",\tIDX_UCS4},\n    {\"utf32le\",\t\tIDX_UCS4LE},\n    {\"utf-32le\",\tIDX_UCS4LE},\n    {\"932\",\t\tIDX_CP932},\n    {\"949\",\t\tIDX_CP949},\n    {\"936\",\t\tIDX_CP936},\n    {\"gbk\",\t\tIDX_CP936},\n    {\"950\",\t\tIDX_CP950},\n    {\"eucjp\",\t\tIDX_EUC_JP},\n    {\"unix-jis\",\tIDX_EUC_JP},\n    {\"ujis\",\t\tIDX_EUC_JP},\n    {\"shift-jis\",\tIDX_SJIS},\n    {\"pck\",\t\tIDX_SJIS},\t// Sun: PCK\n    {\"euckr\",\t\tIDX_EUC_KR},\n    {\"5601\",\t\tIDX_EUC_KR},\t// Sun: KS C 5601\n    {\"euccn\",\t\tIDX_EUC_CN},\n    {\"gb2312\",\t\tIDX_EUC_CN},\n    {\"euctw\",\t\tIDX_EUC_TW},\n#if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n    {\"japan\",\t\tIDX_CP932},\n    {\"korea\",\t\tIDX_CP949},\n    {\"prc\",\t\tIDX_CP936},\n    {\"chinese\",\t\tIDX_CP936},\n    {\"taiwan\",\t\tIDX_CP950},\n    {\"big5\",\t\tIDX_CP950},\n#else\n    {\"japan\",\t\tIDX_EUC_JP},\n    {\"korea\",\t\tIDX_EUC_KR},\n    {\"prc\",\t\tIDX_EUC_CN},\n    {\"chinese\",\t\tIDX_EUC_CN},\n    {\"taiwan\",\t\tIDX_EUC_TW},\n    {\"cp950\",\t\tIDX_BIG5},\n    {\"950\",\t\tIDX_BIG5},\n#endif\n    {\"mac\",\t\tIDX_MACROMAN},\n    {\"mac-roman\",\tIDX_MACROMAN},\n    {NULL,\t\t0}\n};\n\n#ifndef CP_UTF8\n# define CP_UTF8 65001\t// magic number from winnls.h\n#endif\n\n/*\n * Find encoding \"name\" in the list of canonical encoding names.\n * Returns -1 if not found.\n */\n    static int\nenc_canon_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; i < IDX_COUNT; ++i)\n\tif (STRCMP(name, enc_canon_table[i].name) == 0)\n\t    return i;\n    return -1;\n}\n\n\n/*\n * Find canonical encoding \"name\" in the list and return its properties.\n * Returns 0 if not found.\n */\n    int\nenc_canon_props(char_u *name)\n{\n    int\t\ti;\n\n    i = enc_canon_search(name);\n    if (i >= 0)\n\treturn enc_canon_table[i].prop;\n#ifdef MSWIN\n    if (name[0] == 'c' && name[1] == 'p' && VIM_ISDIGIT(name[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)name + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1) // some single-byte encoding\n\t\treturn ENC_8BIT;\n\t    if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t\t// must be a DBCS encoding\n\t\treturn ENC_DBCS;\n\t}\n\treturn 0;\n    }\n#endif\n    if (STRNCMP(name, \"2byte-\", 6) == 0)\n\treturn ENC_DBCS;\n    if (STRNCMP(name, \"8bit-\", 5) == 0 || STRNCMP(name, \"iso-8859-\", 9) == 0)\n\treturn ENC_8BIT;\n    return 0;\n}\n\n/*\n * Set up for using multi-byte characters.\n * Called in three cases:\n * - by main() to initialize (p_enc == NULL)\n * - by set_init_1() after 'encoding' was set to its default.\n * - by do_set() when 'encoding' has been set.\n * p_enc must have been passed through enc_canonize() already.\n * Sets the \"enc_unicode\", \"enc_utf8\", \"enc_dbcs\" and \"has_mbyte\" flags.\n * Fills mb_bytelen_tab[] and returns NULL when there are no problems.\n * When there is something wrong: Returns an error message and doesn't change\n * anything.\n */\n    char *\nmb_init(void)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\tn;\n    int\t\tenc_dbcs_new = 0;\n#if defined(USE_ICONV) && !defined(MSWIN) && !defined(WIN32UNIX) \\\n\t&& !defined(MACOS_CONVERT)\n# define LEN_FROM_CONV\n    vimconv_T\tvimconv;\n    char_u\t*p;\n#endif\n\n    if (p_enc == NULL)\n    {\n\t// Just starting up: set the whole table to one's.\n\tfor (i = 0; i < 256; ++i)\n\t    mb_bytelen_tab[i] = 1;\n\tinput_conv.vc_type = CONV_NONE;\n\tinput_conv.vc_factor = 1;\n\toutput_conv.vc_type = CONV_NONE;\n\treturn NULL;\n    }\n\n#ifdef MSWIN\n    if (p_enc[0] == 'c' && p_enc[1] == 'p' && VIM_ISDIGIT(p_enc[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)p_enc + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1)\n\t    {\n\t\t// some single-byte encoding\n\t\tenc_unicode = 0;\n\t\tenc_utf8 = FALSE;\n\t    }\n\t    else if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t    {\n\t\t// must be a DBCS encoding, check below\n\t\tenc_dbcs_new = atoi((char *)p_enc + 2);\n\t    }\n\t    else\n\t\tgoto codepage_invalid;\n\t}\n\telse if (GetLastError() == ERROR_INVALID_PARAMETER)\n\t{\ncodepage_invalid:\n\t    return N_(e_not_valid_codepage);\n\t}\n    }\n#endif\n    else if (STRNCMP(p_enc, \"8bit-\", 5) == 0\n\t    || STRNCMP(p_enc, \"iso-8859-\", 9) == 0)\n    {\n\t// Accept any \"8bit-\" or \"iso-8859-\" name.\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n    {\n#ifdef MSWIN\n\t// Windows: accept only valid codepage numbers, check below.\n\tif (p_enc[6] != 'c' || p_enc[7] != 'p'\n\t\t\t      || (enc_dbcs_new = atoi((char *)p_enc + 8)) == 0)\n\t    return e_invalid_argument;\n#else\n\t// Unix: accept any \"2byte-\" name, assume current locale.\n\tenc_dbcs_new = DBCS_2BYTE;\n#endif\n    }\n    else if ((idx = enc_canon_search(p_enc)) >= 0)\n    {\n\ti = enc_canon_table[idx].prop;\n\tif (i & ENC_UNICODE)\n\t{\n\t    // Unicode\n\t    enc_utf8 = TRUE;\n\t    if (i & (ENC_2BYTE | ENC_2WORD))\n\t\tenc_unicode = 2;\n\t    else if (i & ENC_4BYTE)\n\t\tenc_unicode = 4;\n\t    else\n\t\tenc_unicode = 0;\n\t}\n\telse if (i & ENC_DBCS)\n\t{\n\t    // 2byte, handle below\n\t    enc_dbcs_new = enc_canon_table[idx].codepage;\n\t}\n\telse\n\t{\n\t    // Must be 8-bit.\n\t    enc_unicode = 0;\n\t    enc_utf8 = FALSE;\n\t}\n    }\n    else    // Don't know what encoding this is, reject it.\n\treturn e_invalid_argument;\n\n    if (enc_dbcs_new != 0)\n    {\n#ifdef MSWIN\n\t// Check if the DBCS code page is OK.\n\tif (!IsValidCodePage(enc_dbcs_new))\n\t    goto codepage_invalid;\n#endif\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    enc_dbcs = enc_dbcs_new;\n    has_mbyte = (enc_dbcs != 0 || enc_utf8);\n\n#if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n    enc_codepage = encname2codepage(p_enc);\n    enc_latin9 = (STRCMP(p_enc, \"iso-8859-15\") == 0);\n#endif\n\n    // Detect an encoding that uses latin1 characters.\n    enc_latin1like = (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t|| STRCMP(p_enc, \"iso-8859-15\") == 0);\n\n    /*\n     * Set the function pointers.\n     */\n    if (enc_utf8)\n    {\n\tmb_ptr2len = utfc_ptr2len;\n\tmb_ptr2len_len = utfc_ptr2len_len;\n\tmb_char2len = utf_char2len;\n\tmb_char2bytes = utf_char2bytes;\n\tmb_ptr2cells = utf_ptr2cells;\n\tmb_ptr2cells_len = utf_ptr2cells_len;\n\tmb_char2cells = utf_char2cells;\n\tmb_off2cells = utf_off2cells;\n\tmb_ptr2char = utf_ptr2char;\n\tmb_head_off = utf_head_off;\n    }\n    else if (enc_dbcs != 0)\n    {\n\tmb_ptr2len = dbcs_ptr2len;\n\tmb_ptr2len_len = dbcs_ptr2len_len;\n\tmb_char2len = dbcs_char2len;\n\tmb_char2bytes = dbcs_char2bytes;\n\tmb_ptr2cells = dbcs_ptr2cells;\n\tmb_ptr2cells_len = dbcs_ptr2cells_len;\n\tmb_char2cells = dbcs_char2cells;\n\tmb_off2cells = dbcs_off2cells;\n\tmb_ptr2char = dbcs_ptr2char;\n\tmb_head_off = dbcs_head_off;\n    }\n    else\n    {\n\tmb_ptr2len = latin_ptr2len;\n\tmb_ptr2len_len = latin_ptr2len_len;\n\tmb_char2len = latin_char2len;\n\tmb_char2bytes = latin_char2bytes;\n\tmb_ptr2cells = latin_ptr2cells;\n\tmb_ptr2cells_len = latin_ptr2cells_len;\n\tmb_char2cells = latin_char2cells;\n\tmb_off2cells = latin_off2cells;\n\tmb_ptr2char = latin_ptr2char;\n\tmb_head_off = latin_head_off;\n    }\n\n    /*\n     * Fill the mb_bytelen_tab[] for MB_BYTE2LEN().\n     */\n#ifdef LEN_FROM_CONV\n    // When 'encoding' is different from the current locale mblen() won't\n    // work.  Use conversion to \"utf-8\" instead.\n    vimconv.vc_type = CONV_NONE;\n    if (enc_dbcs)\n    {\n\tp = enc_locale();\n\tif (p == NULL || STRCMP(p, p_enc) != 0)\n\t{\n\t    convert_setup(&vimconv, p_enc, (char_u *)\"utf-8\");\n\t    vimconv.vc_fail = TRUE;\n\t}\n\tvim_free(p);\n    }\n#endif\n\n    for (i = 0; i < 256; ++i)\n    {\n\t// Our own function to reliably check the length of UTF-8 characters,\n\t// independent of mblen().\n\tif (enc_utf8)\n\t    n = utf8len_tab[i];\n\telse if (enc_dbcs == 0)\n\t    n = 1;\n\telse\n\t{\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t    // enc_dbcs is set by setting 'fileencoding'.  It becomes a Windows\n\t    // CodePage identifier, which we can pass directly in to Windows\n\t    // API\n\t    n = IsDBCSLeadByteEx(enc_dbcs, (WINBYTE)i) ? 2 : 1;\n#else\n# if defined(__amigaos4__) || defined(__ANDROID__) || \\\n\t\t\t\t   !(defined(HAVE_MBLEN) || defined(X_LOCALE))\n\t    /*\n\t     * if mblen() is not available, character which MSB is turned on\n\t     * are treated as leading byte character. (note : This assumption\n\t     * is not always true.)\n\t     */\n\t    n = (i & 0x80) ? 2 : 1;\n# else\n\t    char buf[MB_MAXBYTES + 1];\n\n\t    if (i == NUL)\t// just in case mblen() can't handle \"\"\n\t\tn = 1;\n\t    else\n\t    {\n\t\tbuf[0] = i;\n\t\tbuf[1] = 0;\n#  ifdef LEN_FROM_CONV\n\t\tif (vimconv.vc_type != CONV_NONE)\n\t\t{\n\t\t    /*\n\t\t     * string_convert() should fail when converting the first\n\t\t     * byte of a double-byte character.\n\t\t     */\n\t\t    p = string_convert(&vimconv, (char_u *)buf, NULL);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tvim_free(p);\n\t\t\tn = 1;\n\t\t    }\n\t\t    else\n\t\t\tn = 2;\n\t\t}\n\t\telse\n#  endif\n\t\t{\n\t\t    /*\n\t\t     * mblen() should return -1 for invalid (means the leading\n\t\t     * multibyte) character.  However there are some platforms\n\t\t     * where mblen() returns 0 for invalid character.\n\t\t     * Therefore, following condition includes 0.\n\t\t     */\n\t\t    vim_ignored = mblen(NULL, 0);  // First reset the state.\n\t\t    if (mblen(buf, (size_t)1) <= 0)\n\t\t\tn = 2;\n\t\t    else\n\t\t\tn = 1;\n\t\t}\n\t    }\n# endif\n#endif\n\t}\n\n\tmb_bytelen_tab[i] = n;\n    }\n\n#ifdef LEN_FROM_CONV\n    convert_setup(&vimconv, NULL, NULL);\n#endif\n\n    // The cell width depends on the type of multi-byte characters.\n    (void)init_chartab();\n\n    // When enc_utf8 is set or reset, (de)allocate ScreenLinesUC[]\n    screenalloc(FALSE);\n\n    // When using Unicode, set default for 'fileencodings'.\n    if (enc_utf8 && !option_was_set((char_u *)\"fencs\"))\n\tset_fencs_unicode();\n\n#if defined(HAVE_BIND_TEXTDOMAIN_CODESET) && defined(FEAT_GETTEXT)\n    // GNU gettext 0.10.37 supports this feature: set the codeset used for\n    // translated messages independently from the current locale.\n    (void)bind_textdomain_codeset(VIMPACKAGE,\n\t\t\t\t\t  enc_utf8 ? \"utf-8\" : (char *)p_enc);\n#endif\n\n#ifdef MSWIN\n    // When changing 'encoding' while starting up, then convert the command\n    // line arguments from the active codepage to 'encoding'.\n    if (starting != 0)\n\tfix_arg_enc();\n#endif\n\n    // Fire an autocommand to let people do custom font setup. This must be\n    // after Vim has been setup for the new encoding.\n    apply_autocmds(EVENT_ENCODINGCHANGED, NULL, (char_u *)\"\", FALSE, curbuf);\n\n#ifdef FEAT_SPELL\n    // Need to reload spell dictionaries\n    spell_reload();\n#endif\n\n    return NULL;\n}\n\n/*\n * Return the size of the BOM for the current buffer:\n * 0 - no BOM\n * 2 - UCS-2 or UTF-16 BOM\n * 4 - UCS-4 BOM\n * 3 - UTF-8 BOM\n */\n    int\nbomb_size(void)\n{\n    int n = 0;\n\n    if (curbuf->b_p_bomb && !curbuf->b_p_bin)\n    {\n\tif (*curbuf->b_p_fenc == NUL)\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tif (enc_unicode != 0)\n\t\t    n = enc_unicode;\n\t\telse\n\t\t    n = 3;\n\t    }\n\t}\n\telse if (STRCMP(curbuf->b_p_fenc, \"utf-8\") == 0)\n\t    n = 3;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-2\", 5) == 0\n\t\t|| STRNCMP(curbuf->b_p_fenc, \"utf-16\", 6) == 0)\n\t    n = 2;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-4\", 5) == 0)\n\t    n = 4;\n    }\n    return n;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Remove all BOM from \"s\" by moving remaining text.\n */\n    void\nremove_bom(char_u *s)\n{\n    if (enc_utf8)\n    {\n\tchar_u *p = s;\n\n\twhile ((p = vim_strbyte(p, 0xef)) != NULL)\n\t{\n\t    if (p[1] == 0xbb && p[2] == 0xbf)\n\t\tSTRMOVE(p, p + 3);\n\t    else\n\t\t++p;\n\t}\n    }\n}\n#endif\n\n/*\n * Get class of pointer:\n * 0 for blank or NUL\n * 1 for punctuation\n * 2 for an (ASCII) word character\n * >2 for other word characters\n */\n    int\nmb_get_class(char_u *p)\n{\n    return mb_get_class_buf(p, curbuf);\n}\n\n    int\nmb_get_class_buf(char_u *p, buf_T *buf)\n{\n    if (MB_BYTE2LEN(p[0]) == 1)\n    {\n\tif (p[0] == NUL || VIM_ISWHITE(p[0]))\n\t    return 0;\n\tif (vim_iswordc_buf(p[0], buf))\n\t    return 2;\n\treturn 1;\n    }\n    if (enc_dbcs != 0 && p[0] != NUL && p[1] != NUL)\n\treturn dbcs_class(p[0], p[1]);\n    if (enc_utf8)\n\treturn utf_class_buf(utf_ptr2char(p), buf);\n    return 0;\n}\n\n/*\n * Get class of a double-byte character.  This always returns 3 or bigger.\n * TODO: Should return 1 for punctuation.\n */\n    int\ndbcs_class(unsigned lead, unsigned trail)\n{\n    switch (enc_dbcs)\n    {\n\t// please add classify routine for your language in here\n\n\tcase DBCS_JPNU:\t// ?\n\tcase DBCS_JPN:\n\t    {\n\t\t// JIS code classification\n\t\tunsigned char lb = lead;\n\t\tunsigned char tb = trail;\n\n\t\t// convert process code to JIS\n# if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n\t\t// process code is SJIS\n\t\tif (lb <= 0x9f)\n\t\t    lb = (lb - 0x81) * 2 + 0x21;\n\t\telse\n\t\t    lb = (lb - 0xc1) * 2 + 0x21;\n\t\tif (tb <= 0x7e)\n\t\t    tb -= 0x1f;\n\t\telse if (tb <= 0x9e)\n\t\t    tb -= 0x20;\n\t\telse\n\t\t{\n\t\t    tb -= 0x7e;\n\t\t    lb += 1;\n\t\t}\n# else\n\t\t/*\n\t\t * XXX: Code page identification can not use with all\n\t\t *\t    system! So, some other encoding information\n\t\t *\t    will be needed.\n\t\t *\t    In japanese: SJIS,EUC,UNICODE,(JIS)\n\t\t *\t    Note that JIS-code system don't use as\n\t\t *\t    process code in most system because it uses\n\t\t *\t    escape sequences(JIS is context depend encoding).\n\t\t */\n\t\t// assume process code is JAPANESE-EUC\n\t\tlb &= 0x7f;\n\t\ttb &= 0x7f;\n# endif\n\t\t// exceptions\n\t\tswitch (lb << 8 | tb)\n\t\t{\n\t\t    case 0x2121: // ZENKAKU space\n\t\t\treturn 0;\n\t\t    case 0x2122: // TOU-TEN (Japanese comma)\n\t\t    case 0x2123: // KU-TEN (Japanese period)\n\t\t    case 0x2124: // ZENKAKU comma\n\t\t    case 0x2125: // ZENKAKU period\n\t\t\treturn 1;\n\t\t    case 0x213c: // prolongedsound handled as KATAKANA\n\t\t\treturn 13;\n\t\t}\n\t\t// sieved by KU code\n\t\tswitch (lb)\n\t\t{\n\t\t    case 0x21:\n\t\t    case 0x22:\n\t\t\t// special symbols\n\t\t\treturn 10;\n\t\t    case 0x23:\n\t\t\t// alphanumeric\n\t\t\treturn 11;\n\t\t    case 0x24:\n\t\t\t// hiragana\n\t\t\treturn 12;\n\t\t    case 0x25:\n\t\t\t// katakana\n\t\t\treturn 13;\n\t\t    case 0x26:\n\t\t\t// greek\n\t\t\treturn 14;\n\t\t    case 0x27:\n\t\t\t// russian\n\t\t\treturn 15;\n\t\t    case 0x28:\n\t\t\t// lines\n\t\t\treturn 16;\n\t\t    default:\n\t\t\t// kanji\n\t\t\treturn 17;\n\t\t}\n\t    }\n\n\tcase DBCS_KORU:\t// ?\n\tcase DBCS_KOR:\n\t    {\n\t\t// KS code classification\n\t\tunsigned char c1 = lead;\n\t\tunsigned char c2 = trail;\n\n\t\t/*\n\t\t * 20 : Hangul\n\t\t * 21 : Hanja\n\t\t * 22 : Symbols\n\t\t * 23 : Alphanumeric/Roman Letter (Full width)\n\t\t * 24 : Hangul Letter(Alphabet)\n\t\t * 25 : Roman Numeral/Greek Letter\n\t\t * 26 : Box Drawings\n\t\t * 27 : Unit Symbols\n\t\t * 28 : Circled/Parenthesized Letter\n\t\t * 29 : Hiragana/Katakana\n\t\t * 30 : Cyrillic Letter\n\t\t */\n\n\t\tif (c1 >= 0xB0 && c1 <= 0xC8)\n\t\t    // Hangul\n\t\t    return 20;\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t\telse if (c1 <= 0xA0 || c2 <= 0xA0)\n\t\t    // Extended Hangul Region : MS UHC(Unified Hangul Code)\n\t\t    // c1: 0x81-0xA0 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xFE\n\t\t    // c1: 0xA1-0xC6 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xA0\n\t\t    return 20;\n#endif\n\n\t\telse if (c1 >= 0xCA && c1 <= 0xFD)\n\t\t    // Hanja\n\t\t    return 21;\n\t\telse switch (c1)\n\t\t{\n\t\t    case 0xA1:\n\t\t    case 0xA2:\n\t\t\t// Symbols\n\t\t\treturn 22;\n\t\t    case 0xA3:\n\t\t\t// Alphanumeric\n\t\t\treturn 23;\n\t\t    case 0xA4:\n\t\t\t// Hangul Letter(Alphabet)\n\t\t\treturn 24;\n\t\t    case 0xA5:\n\t\t\t// Roman Numeral/Greek Letter\n\t\t\treturn 25;\n\t\t    case 0xA6:\n\t\t\t// Box Drawings\n\t\t\treturn 26;\n\t\t    case 0xA7:\n\t\t\t// Unit Symbols\n\t\t\treturn 27;\n\t\t    case 0xA8:\n\t\t    case 0xA9:\n\t\t\tif (c2 <= 0xAF)\n\t\t\t    return 25;  // Roman Letter\n\t\t\telse if (c2 >= 0xF6)\n\t\t\t    return 22;  // Symbols\n\t\t\telse\n\t\t\t    // Circled/Parenthesized Letter\n\t\t\t    return 28;\n\t\t    case 0xAA:\n\t\t    case 0xAB:\n\t\t\t// Hiragana/Katakana\n\t\t\treturn 29;\n\t\t    case 0xAC:\n\t\t\t// Cyrillic Letter\n\t\t\treturn 30;\n\t\t}\n\t    }\n\tdefault:\n\t    break;\n    }\n    return 3;\n}\n\n/*\n * mb_char2len() function pointer.\n * Return length in bytes of character \"c\".\n * Returns 1 for a single-byte character.\n */\n    int\nlatin_char2len(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2len(\n    int\t\tc)\n{\n    if (c >= 0x100)\n\treturn 2;\n    return 1;\n}\n\n/*\n * mb_char2bytes() function pointer.\n * Convert a character to its bytes.\n * Returns the length in bytes.\n */\n    int\nlatin_char2bytes(int c, char_u *buf)\n{\n    buf[0] = c;\n    return 1;\n}\n\n    static int\ndbcs_char2bytes(int c, char_u *buf)\n{\n    if (c >= 0x100)\n    {\n\tbuf[0] = (unsigned)c >> 8;\n\tbuf[1] = c;\n\t// Never use a NUL byte, it causes lots of trouble.  It's an invalid\n\t// character anyway.\n\tif (buf[1] == NUL)\n\t    buf[1] = '\\n';\n\treturn 2;\n    }\n    buf[0] = c;\n    return 1;\n}\n\n/*\n * mb_ptr2len() function pointer.\n * Get byte length of character at \"*p\" but stop at a NUL.\n * For UTF-8 this includes following composing characters.\n * Returns 0 when *p is NUL.\n */\n    int\nlatin_ptr2len(char_u *p)\n{\n return MB_BYTE2LEN(*p);\n}\n\n    static int\ndbcs_ptr2len(\n    char_u\t*p)\n{\n    int\t\tlen;\n\n    // Check if second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\n/*\n * mb_ptr2len_len() function pointer.\n * Like mb_ptr2len(), but limit to read \"size\" bytes.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nlatin_ptr2len_len(char_u *p, int size)\n{\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    return 1;\n}\n\n    static int\ndbcs_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (size == 1)\n\treturn 1;\n    // Check that second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\nstruct interval\n{\n    long first;\n    long last;\n};\n\n/*\n * Return TRUE if \"c\" is in \"table[size / sizeof(struct interval)]\".\n */\n    static int\nintable(struct interval *table, size_t size, int c)\n{\n    int mid, bot, top;\n\n    // first quick check for Latin1 etc. characters\n    if (c < table[0].first)\n\treturn FALSE;\n\n    // binary search in table\n    bot = 0;\n    top = (int)(size / sizeof(struct interval) - 1);\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n// Sorted list of non-overlapping intervals of East Asian Ambiguous\n// characters, generated with ../runtime/tools/unicode.vim.\nstatic struct interval ambiguous[] =\n{\n    {0x00a1, 0x00a1},\n    {0x00a4, 0x00a4},\n    {0x00a7, 0x00a8},\n    {0x00aa, 0x00aa},\n    {0x00ad, 0x00ae},\n    {0x00b0, 0x00b4},\n    {0x00b6, 0x00ba},\n    {0x00bc, 0x00bf},\n    {0x00c6, 0x00c6},\n    {0x00d0, 0x00d0},\n    {0x00d7, 0x00d8},\n    {0x00de, 0x00e1},\n    {0x00e6, 0x00e6},\n    {0x00e8, 0x00ea},\n    {0x00ec, 0x00ed},\n    {0x00f0, 0x00f0},\n    {0x00f2, 0x00f3},\n    {0x00f7, 0x00fa},\n    {0x00fc, 0x00fc},\n    {0x00fe, 0x00fe},\n    {0x0101, 0x0101},\n    {0x0111, 0x0111},\n    {0x0113, 0x0113},\n    {0x011b, 0x011b},\n    {0x0126, 0x0127},\n    {0x012b, 0x012b},\n    {0x0131, 0x0133},\n    {0x0138, 0x0138},\n    {0x013f, 0x0142},\n    {0x0144, 0x0144},\n    {0x0148, 0x014b},\n    {0x014d, 0x014d},\n    {0x0152, 0x0153},\n    {0x0166, 0x0167},\n    {0x016b, 0x016b},\n    {0x01ce, 0x01ce},\n    {0x01d0, 0x01d0},\n    {0x01d2, 0x01d2},\n    {0x01d4, 0x01d4},\n    {0x01d6, 0x01d6},\n    {0x01d8, 0x01d8},\n    {0x01da, 0x01da},\n    {0x01dc, 0x01dc},\n    {0x0251, 0x0251},\n    {0x0261, 0x0261},\n    {0x02c4, 0x02c4},\n    {0x02c7, 0x02c7},\n    {0x02c9, 0x02cb},\n    {0x02cd, 0x02cd},\n    {0x02d0, 0x02d0},\n    {0x02d8, 0x02db},\n    {0x02dd, 0x02dd},\n    {0x02df, 0x02df},\n    {0x0300, 0x036f},\n    {0x0391, 0x03a1},\n    {0x03a3, 0x03a9},\n    {0x03b1, 0x03c1},\n    {0x03c3, 0x03c9},\n    {0x0401, 0x0401},\n    {0x0410, 0x044f},\n    {0x0451, 0x0451},\n    {0x2010, 0x2010},\n    {0x2013, 0x2016},\n    {0x2018, 0x2019},\n    {0x201c, 0x201d},\n    {0x2020, 0x2022},\n    {0x2024, 0x2027},\n    {0x2030, 0x2030},\n    {0x2032, 0x2033},\n    {0x2035, 0x2035},\n    {0x203b, 0x203b},\n    {0x203e, 0x203e},\n    {0x2074, 0x2074},\n    {0x207f, 0x207f},\n    {0x2081, 0x2084},\n    {0x20ac, 0x20ac},\n    {0x2103, 0x2103},\n    {0x2105, 0x2105},\n    {0x2109, 0x2109},\n    {0x2113, 0x2113},\n    {0x2116, 0x2116},\n    {0x2121, 0x2122},\n    {0x2126, 0x2126},\n    {0x212b, 0x212b},\n    {0x2153, 0x2154},\n    {0x215b, 0x215e},\n    {0x2160, 0x216b},\n    {0x2170, 0x2179},\n    {0x2189, 0x2189},\n    {0x2190, 0x2199},\n    {0x21b8, 0x21b9},\n    {0x21d2, 0x21d2},\n    {0x21d4, 0x21d4},\n    {0x21e7, 0x21e7},\n    {0x2200, 0x2200},\n    {0x2202, 0x2203},\n    {0x2207, 0x2208},\n    {0x220b, 0x220b},\n    {0x220f, 0x220f},\n    {0x2211, 0x2211},\n    {0x2215, 0x2215},\n    {0x221a, 0x221a},\n    {0x221d, 0x2220},\n    {0x2223, 0x2223},\n    {0x2225, 0x2225},\n    {0x2227, 0x222c},\n    {0x222e, 0x222e},\n    {0x2234, 0x2237},\n    {0x223c, 0x223d},\n    {0x2248, 0x2248},\n    {0x224c, 0x224c},\n    {0x2252, 0x2252},\n    {0x2260, 0x2261},\n    {0x2264, 0x2267},\n    {0x226a, 0x226b},\n    {0x226e, 0x226f},\n    {0x2282, 0x2283},\n    {0x2286, 0x2287},\n    {0x2295, 0x2295},\n    {0x2299, 0x2299},\n    {0x22a5, 0x22a5},\n    {0x22bf, 0x22bf},\n    {0x2312, 0x2312},\n    {0x2460, 0x24e9},\n    {0x24eb, 0x254b},\n    {0x2550, 0x2573},\n    {0x2580, 0x258f},\n    {0x2592, 0x2595},\n    {0x25a0, 0x25a1},\n    {0x25a3, 0x25a9},\n    {0x25b2, 0x25b3},\n    {0x25b6, 0x25b7},\n    {0x25bc, 0x25bd},\n    {0x25c0, 0x25c1},\n    {0x25c6, 0x25c8},\n    {0x25cb, 0x25cb},\n    {0x25ce, 0x25d1},\n    {0x25e2, 0x25e5},\n    {0x25ef, 0x25ef},\n    {0x2605, 0x2606},\n    {0x2609, 0x2609},\n    {0x260e, 0x260f},\n    {0x261c, 0x261c},\n    {0x261e, 0x261e},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2660, 0x2661},\n    {0x2663, 0x2665},\n    {0x2667, 0x266a},\n    {0x266c, 0x266d},\n    {0x266f, 0x266f},\n    {0x269e, 0x269f},\n    {0x26bf, 0x26bf},\n    {0x26c6, 0x26cd},\n    {0x26cf, 0x26d3},\n    {0x26d5, 0x26e1},\n    {0x26e3, 0x26e3},\n    {0x26e8, 0x26e9},\n    {0x26eb, 0x26f1},\n    {0x26f4, 0x26f4},\n    {0x26f6, 0x26f9},\n    {0x26fb, 0x26fc},\n    {0x26fe, 0x26ff},\n    {0x273d, 0x273d},\n    {0x2776, 0x277f},\n    {0x2b56, 0x2b59},\n    {0x3248, 0x324f},\n    {0xe000, 0xf8ff},\n    {0xfe00, 0xfe0f},\n    {0xfffd, 0xfffd},\n    {0x1f100, 0x1f10a},\n    {0x1f110, 0x1f12d},\n    {0x1f130, 0x1f169},\n    {0x1f170, 0x1f18d},\n    {0x1f18f, 0x1f190},\n    {0x1f19b, 0x1f1ac},\n    {0xe0100, 0xe01ef},\n    {0xf0000, 0xffffd},\n    {0x100000, 0x10fffd}\n};\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_char2cells() with different argument type for libvterm.\n */\n    int\nutf_uint2cells(UINT32_T c)\n{\n    if (c >= 0x100 && utf_iscomposing((int)c))\n\treturn 0;\n    return utf_char2cells((int)c);\n}\n#endif\n\n/*\n * For UTF-8 character \"c\" return 2 for a double-width character, 1 for others.\n * Returns 4 or 6 for an unprintable character.\n * Is only correct for characters >= 0x80.\n * When p_ambw is \"double\", return 2 for a character with East Asian Width\n * class 'A'(mbiguous).\n */\n    int\nutf_char2cells(int c)\n{\n    // Sorted list of non-overlapping intervals of East Asian double width\n    // characters, generated with ../runtime/tools/unicode.vim.\n    static struct interval doublewidth[] =\n    {\n\t{0x1100, 0x115f},\n\t{0x231a, 0x231b},\n\t{0x2329, 0x232a},\n\t{0x23e9, 0x23ec},\n\t{0x23f0, 0x23f0},\n\t{0x23f3, 0x23f3},\n\t{0x25fd, 0x25fe},\n\t{0x2614, 0x2615},\n\t{0x2648, 0x2653},\n\t{0x267f, 0x267f},\n\t{0x2693, 0x2693},\n\t{0x26a1, 0x26a1},\n\t{0x26aa, 0x26ab},\n\t{0x26bd, 0x26be},\n\t{0x26c4, 0x26c5},\n\t{0x26ce, 0x26ce},\n\t{0x26d4, 0x26d4},\n\t{0x26ea, 0x26ea},\n\t{0x26f2, 0x26f3},\n\t{0x26f5, 0x26f5},\n\t{0x26fa, 0x26fa},\n\t{0x26fd, 0x26fd},\n\t{0x2705, 0x2705},\n\t{0x270a, 0x270b},\n\t{0x2728, 0x2728},\n\t{0x274c, 0x274c},\n\t{0x274e, 0x274e},\n\t{0x2753, 0x2755},\n\t{0x2757, 0x2757},\n\t{0x2795, 0x2797},\n\t{0x27b0, 0x27b0},\n\t{0x27bf, 0x27bf},\n\t{0x2b1b, 0x2b1c},\n\t{0x2b50, 0x2b50},\n\t{0x2b55, 0x2b55},\n\t{0x2e80, 0x2e99},\n\t{0x2e9b, 0x2ef3},\n\t{0x2f00, 0x2fd5},\n\t{0x2ff0, 0x2ffb},\n\t{0x3000, 0x303e},\n\t{0x3041, 0x3096},\n\t{0x3099, 0x30ff},\n\t{0x3105, 0x312f},\n\t{0x3131, 0x318e},\n\t{0x3190, 0x31e3},\n\t{0x31f0, 0x321e},\n\t{0x3220, 0x3247},\n\t{0x3250, 0x4dbf},\n\t{0x4e00, 0xa48c},\n\t{0xa490, 0xa4c6},\n\t{0xa960, 0xa97c},\n\t{0xac00, 0xd7a3},\n\t{0xf900, 0xfaff},\n\t{0xfe10, 0xfe19},\n\t{0xfe30, 0xfe52},\n\t{0xfe54, 0xfe66},\n\t{0xfe68, 0xfe6b},\n\t{0xff01, 0xff60},\n\t{0xffe0, 0xffe6},\n\t{0x16fe0, 0x16fe3},\n\t{0x16ff0, 0x16ff1},\n\t{0x17000, 0x187f7},\n\t{0x18800, 0x18cd5},\n\t{0x18d00, 0x18d08},\n\t{0x1b000, 0x1b11e},\n\t{0x1b150, 0x1b152},\n\t{0x1b164, 0x1b167},\n\t{0x1b170, 0x1b2fb},\n\t{0x1f004, 0x1f004},\n\t{0x1f0cf, 0x1f0cf},\n\t{0x1f18e, 0x1f18e},\n\t{0x1f191, 0x1f19a},\n\t{0x1f200, 0x1f202},\n\t{0x1f210, 0x1f23b},\n\t{0x1f240, 0x1f248},\n\t{0x1f250, 0x1f251},\n\t{0x1f260, 0x1f265},\n\t{0x1f300, 0x1f320},\n\t{0x1f32d, 0x1f335},\n\t{0x1f337, 0x1f37c},\n\t{0x1f37e, 0x1f393},\n\t{0x1f3a0, 0x1f3ca},\n\t{0x1f3cf, 0x1f3d3},\n\t{0x1f3e0, 0x1f3f0},\n\t{0x1f3f4, 0x1f3f4},\n\t{0x1f3f8, 0x1f43e},\n\t{0x1f440, 0x1f440},\n\t{0x1f442, 0x1f4fc},\n\t{0x1f4ff, 0x1f53d},\n\t{0x1f54b, 0x1f54e},\n\t{0x1f550, 0x1f567},\n\t{0x1f57a, 0x1f57a},\n\t{0x1f595, 0x1f596},\n\t{0x1f5a4, 0x1f5a4},\n\t{0x1f5fb, 0x1f64f},\n\t{0x1f680, 0x1f6c5},\n\t{0x1f6cc, 0x1f6cc},\n\t{0x1f6d0, 0x1f6d2},\n\t{0x1f6d5, 0x1f6d7},\n\t{0x1f6eb, 0x1f6ec},\n\t{0x1f6f4, 0x1f6fc},\n\t{0x1f7e0, 0x1f7eb},\n\t{0x1f90c, 0x1f93a},\n\t{0x1f93c, 0x1f945},\n\t{0x1f947, 0x1f978},\n\t{0x1f97a, 0x1f9cb},\n\t{0x1f9cd, 0x1f9ff},\n\t{0x1fa70, 0x1fa74},\n\t{0x1fa78, 0x1fa7a},\n\t{0x1fa80, 0x1fa86},\n\t{0x1fa90, 0x1faa8},\n\t{0x1fab0, 0x1fab6},\n\t{0x1fac0, 0x1fac2},\n\t{0x1fad0, 0x1fad6},\n\t{0x20000, 0x2fffd},\n\t{0x30000, 0x3fffd}\n    };\n\n    // Sorted list of non-overlapping intervals of Emoji characters that don't\n    // have ambiguous or double width,\n    // based on http://unicode.org/emoji/charts/emoji-list.html\n    static struct interval emoji_wide[] =\n    {\n\t{0x23ed, 0x23ef},\n\t{0x23f1, 0x23f2},\n\t{0x23f8, 0x23fa},\n\t{0x24c2, 0x24c2},\n\t{0x261d, 0x261d},\n\t{0x26c8, 0x26c8},\n\t{0x26cf, 0x26cf},\n\t{0x26d1, 0x26d1},\n\t{0x26d3, 0x26d3},\n\t{0x26e9, 0x26e9},\n\t{0x26f0, 0x26f1},\n\t{0x26f7, 0x26f9},\n\t{0x270c, 0x270d},\n\t{0x2934, 0x2935},\n\t{0x1f170, 0x1f189},\n\t{0x1f1e6, 0x1f1ff},\n\t{0x1f321, 0x1f321},\n\t{0x1f324, 0x1f32c},\n\t{0x1f336, 0x1f336},\n\t{0x1f37d, 0x1f37d},\n\t{0x1f396, 0x1f397},\n\t{0x1f399, 0x1f39b},\n\t{0x1f39e, 0x1f39f},\n\t{0x1f3cb, 0x1f3ce},\n\t{0x1f3d4, 0x1f3df},\n\t{0x1f3f3, 0x1f3f5},\n\t{0x1f3f7, 0x1f3f7},\n\t{0x1f43f, 0x1f43f},\n\t{0x1f441, 0x1f441},\n\t{0x1f4fd, 0x1f4fd},\n\t{0x1f549, 0x1f54a},\n\t{0x1f56f, 0x1f570},\n\t{0x1f573, 0x1f579},\n\t{0x1f587, 0x1f587},\n\t{0x1f58a, 0x1f58d},\n\t{0x1f590, 0x1f590},\n\t{0x1f5a5, 0x1f5a5},\n\t{0x1f5a8, 0x1f5a8},\n\t{0x1f5b1, 0x1f5b2},\n\t{0x1f5bc, 0x1f5bc},\n\t{0x1f5c2, 0x1f5c4},\n\t{0x1f5d1, 0x1f5d3},\n\t{0x1f5dc, 0x1f5de},\n\t{0x1f5e1, 0x1f5e1},\n\t{0x1f5e3, 0x1f5e3},\n\t{0x1f5e8, 0x1f5e8},\n\t{0x1f5ef, 0x1f5ef},\n\t{0x1f5f3, 0x1f5f3},\n\t{0x1f5fa, 0x1f5fa},\n\t{0x1f6cb, 0x1f6cf},\n\t{0x1f6e0, 0x1f6e5},\n\t{0x1f6e9, 0x1f6e9},\n\t{0x1f6f0, 0x1f6f0},\n\t{0x1f6f3, 0x1f6f3}\n\n#ifdef MACOS_X\n\t// Include SF Symbols characters, which should be rendered as\n\t// double-width. All of them are in the Supplementary Private Use\n\t// Area-B range. The exact range was determined by downloading the \"SF\n\t// Symbols\" app from Apple, and then selecting all symbols, copying\n\t// them out, and inspecting the unicode values of them.\n\t, {0x100000, 0x100d7f}\n#endif\n    };\n\n    if (c >= 0x100)\n    {\n#if defined(FEAT_EVAL) || defined(USE_WCHAR_FUNCTIONS)\n\tint\tn;\n#endif\n\n#ifdef FEAT_EVAL\n\tn = cw_value(c);\n\tif (n != 0)\n\t    return n;\n#endif\n\n#ifdef USE_WCHAR_FUNCTIONS\n\t/*\n\t * Assume the library function wcwidth() works better than our own\n\t * stuff.  It should return 1 for ambiguous width chars!\n\t */\n\tn = wcwidth(c);\n\n\tif (n < 0)\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (n > 1)\n\t    return n;\n#else\n\tif (!utf_printable(c))\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (intable(doublewidth, sizeof(doublewidth), c))\n\t    return 2;\n#endif\n\tif (p_emoji && intable(emoji_wide, sizeof(emoji_wide), c))\n\t    return 2;\n    }\n\n    // Characters below 0x100 are influenced by 'isprint' option\n    else if (c >= 0x80 && !vim_isprintc(c))\n\treturn 4;\t\t// unprintable, displays <xx>\n\n    if (c >= 0x80 && *p_ambw == 'd' && intable(ambiguous, sizeof(ambiguous), c))\n\treturn 2;\n\n    return 1;\n}\n\n/*\n * mb_ptr2cells() function pointer.\n * Return the number of display cells character at \"*p\" occupies.\n * This doesn't take care of unprintable characters, use ptr2cells() for that.\n */\n    int\nlatin_ptr2cells(char_u *p UNUSED)\n{\n    return 1;\n}\n\n    int\nutf_ptr2cells(\n    char_u\t*p)\n{\n    int\t\tc;\n\n    // Need to convert to a character number.\n    if (*p >= 0x80)\n    {\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    int\ndbcs_ptr2cells(char_u *p)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_ptr2cells_len() function pointer.\n * Like mb_ptr2cells(), but limit string length to \"size\".\n * For an empty string or truncated character returns 1.\n */\n    int\nlatin_ptr2cells_len(char_u *p UNUSED, int size UNUSED)\n{\n    return 1;\n}\n\n    static int\nutf_ptr2cells_len(char_u *p, int size)\n{\n    int\t\tc;\n\n    // Need to convert to a wide character.\n    if (size > 0 && *p >= 0x80)\n    {\n\tif (utf_ptr2len_len(p, size) < utf8len_tab[*p])\n\t    return 1;  // truncated\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    static int\ndbcs_ptr2cells_len(char_u *p, int size)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (size <= 1 || (enc_dbcs == DBCS_JPNU && *p == 0x8e))\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_char2cells() function pointer.\n * Return the number of display cells character \"c\" occupies.\n * Only takes care of multi-byte chars, not \"^C\" and such.\n */\n    int\nlatin_char2cells(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2cells(int c)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ((unsigned)c >> 8) == 0x8e)\n\treturn 1;\n    // use the first byte\n    return MB_BYTE2LEN((unsigned)c >> 8);\n}\n\n/*\n * Return the number of cells occupied by string \"p\".\n * Stop at a NUL character.  When \"len\" >= 0 stop at character \"p[len]\".\n */\n    int\nmb_string2cells(char_u *p, int len)\n{\n    int i;\n    int clen = 0;\n\n    for (i = 0; (len < 0 || i < len) && p[i] != NUL; i += (*mb_ptr2len)(p + i))\n\tclen += (*mb_ptr2cells)(p + i);\n    return clen;\n}\n\n/*\n * mb_off2cells() function pointer.\n * Return number of display cells for char at ScreenLines[off].\n * We make sure that the offset used is less than \"max_off\".\n */\n    int\nlatin_off2cells(unsigned off UNUSED, unsigned max_off UNUSED)\n{\n    return 1;\n}\n\n    int\ndbcs_off2cells(unsigned off, unsigned max_off)\n{\n    // never check beyond end of the line\n    if (off >= max_off)\n\treturn 1;\n\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(ScreenLines[off]);\n}\n\n    int\nutf_off2cells(unsigned off, unsigned max_off)\n{\n    return (off + 1 < max_off && ScreenLines[off + 1] == 0) ? 2 : 1;\n}\n\n/*\n * mb_ptr2char() function pointer.\n * Convert a byte sequence into a character.\n */\n    int\nlatin_ptr2char(char_u *p)\n{\n    return *p;\n}\n\n    static int\ndbcs_ptr2char(char_u *p)\n{\n    if (MB_BYTE2LEN(*p) > 1 && p[1] != NUL)\n\treturn (p[0] << 8) + p[1];\n    return *p;\n}\n\n/*\n * Convert a UTF-8 byte sequence to a character number.\n * If the sequence is illegal or truncated by a NUL the first byte is\n * returned.\n * For an overlong sequence this may return zero.\n * Does not include composing characters, of course.\n */\n    int\nutf_ptr2char(char_u *p)\n{\n    int\t\tlen;\n\n    if (p[0] < 0x80)\t// be quick for ASCII\n\treturn p[0];\n\n    len = utf8len_tab_zero[p[0]];\n    if (len > 1 && (p[1] & 0xc0) == 0x80)\n    {\n\tif (len == 2)\n\t    return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);\n\tif ((p[2] & 0xc0) == 0x80)\n\t{\n\t    if (len == 3)\n\t\treturn ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6)\n\t\t    + (p[2] & 0x3f);\n\t    if ((p[3] & 0xc0) == 0x80)\n\t    {\n\t\tif (len == 4)\n\t\t    return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12)\n\t\t\t+ ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);\n\t\tif ((p[4] & 0xc0) == 0x80)\n\t\t{\n\t\t    if (len == 5)\n\t\t\treturn ((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18)\n\t\t\t    + ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6)\n\t\t\t    + (p[4] & 0x3f);\n\t\t    if ((p[5] & 0xc0) == 0x80 && len == 6)\n\t\t\treturn ((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24)\n\t\t\t    + ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12)\n\t\t\t    + ((p[4] & 0x3f) << 6) + (p[5] & 0x3f);\n\t\t}\n\t    }\n\t}\n    }\n    // Illegal value, just return the first byte\n    return p[0];\n}\n\n/*\n * Convert a UTF-8 byte sequence to a wide character.\n * String is assumed to be terminated by NUL or after \"n\" bytes, whichever\n * comes first.\n * The function is safe in the sense that it never accesses memory beyond the\n * first \"n\" bytes of \"s\".\n *\n * On success, returns decoded codepoint, advances \"s\" to the beginning of\n * next character and decreases \"n\" accordingly.\n *\n * If end of string was reached, returns 0 and, if \"n\" > 0, advances \"s\" past\n * NUL byte.\n *\n * If byte sequence is illegal or incomplete, returns -1 and does not advance\n * \"s\".\n */\n    static int\nutf_safe_read_char_adv(char_u **s, size_t *n)\n{\n    int\t\tc, k;\n\n    if (*n == 0) // end of buffer\n\treturn 0;\n\n    k = utf8len_tab_zero[**s];\n\n    if (k == 1)\n    {\n\t// ASCII character or NUL\n\t(*n)--;\n\treturn *(*s)++;\n    }\n\n    if ((size_t)k <= *n)\n    {\n\t// We have a multibyte sequence and it isn't truncated by buffer\n\t// limits so utf_ptr2char() is safe to use. Or the first byte is\n\t// illegal (k=0), and it's also safe to use utf_ptr2char().\n\tc = utf_ptr2char(*s);\n\n\t// On failure, utf_ptr2char() returns the first byte, so here we\n\t// check equality with the first byte. The only non-ASCII character\n\t// which equals the first byte of its own UTF-8 representation is\n\t// U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.\n\t// It's safe even if n=1, else we would have k=2 > n.\n\tif (c != (int)(**s) || (c == 0xC3 && (*s)[1] == 0x83))\n\t{\n\t    // byte sequence was successfully decoded\n\t    *s += k;\n\t    *n -= k;\n\t    return c;\n\t}\n    }\n\n    // byte sequence is incomplete or illegal\n    return -1;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are skipped!\n */\n    int\nmb_ptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    *pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are returned as separate characters.\n */\n    int\nmb_cptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    if (enc_utf8)\n\t*pp += utf_ptr2len(*pp);\n    else\n\t*pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\n/*\n * Check if the character pointed to by \"p2\" is a composing character when it\n * comes after \"p1\".  For Arabic sometimes \"ab\" is replaced with \"c\", which\n * behaves like a composing character.\n */\n    int\nutf_composinglike(char_u *p1, char_u *p2)\n{\n    int\t\tc2;\n\n    c2 = utf_ptr2char(p2);\n    if (utf_iscomposing(c2))\n\treturn TRUE;\n    if (!arabic_maycombine(c2))\n\treturn FALSE;\n    return arabic_combine(utf_ptr2char(p1), c2);\n}\n#endif\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.\n */\n    int\nutfc_ptr2char(\n    char_u\t*p,\n    int\t\t*pcc)\t// return: composing chars, last one is 0\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len(p);\n\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len(p + len);\n\t    if (p[len] < 0x80 || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.  Use no more than p[maxlen].\n */\n    int\nutfc_ptr2char_len(\n    char_u\t*p,\n    int\t\t*pcc,\t// return: composing chars, last one is 0\n    int\t\tmaxlen)\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len_len(p, maxlen);\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && len < maxlen\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len_len(p + len, maxlen - len);\n\t    if (len >= maxlen\n\t\t    || p[len] < 0x80\n\t\t    || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert the character at screen position \"off\" to a sequence of bytes.\n * Includes the composing characters.\n * \"buf\" must at least have the length MB_MAXBYTES + 1.\n * Only to be used when ScreenLinesUC[off] != 0.\n * Returns the produced number of bytes.\n */\n    int\nutfc_char2bytes(int off, char_u *buf)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    len = utf_char2bytes(ScreenLinesUC[off], buf);\n    for (i = 0; i < Screen_mco; ++i)\n    {\n\tif (ScreenLinesC[i][off] == 0)\n\t    break;\n\tlen += utf_char2bytes(ScreenLinesC[i][off], buf + len);\n    }\n    return len;\n}\n\n/*\n * Get the length of a UTF-8 byte sequence, not including any following\n * composing characters.\n * Returns 0 for \"\".\n * Returns 1 for an illegal byte sequence.\n */\n    int\nutf_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    if (*p == NUL)\n\treturn 0;\n    len = utf8len_tab[*p];\n    for (i = 1; i < len; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return length of UTF-8 character, obtained from the first byte.\n * \"b\" must be between 0 and 255!\n * Returns 1 for an invalid first byte value.\n */\n    int\nutf_byte2len(int b)\n{\n    return utf8len_tab[b];\n}\n\n/*\n * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any\n * following composing characters.\n * Returns 1 for \"\".\n * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).\n * Returns number > \"size\" for an incomplete byte sequence.\n * Never returns zero.\n */\n    int\nutf_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tm;\n\n    len = utf8len_tab[*p];\n    if (len == 1)\n\treturn 1;\t// NUL, ascii or illegal lead byte\n    if (len > size)\n\tm = size;\t// incomplete byte sequence.\n    else\n\tm = len;\n    for (i = 1; i < m; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p\" takes.\n * This includes following composing characters.\n */\n    int\nutfc_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\tb0 = *p;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (b0 == NUL)\n\treturn 0;\n    if (b0 < 0x80 && p[1] < 0x80)\t// be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len(p);\n\n    // Check for illegal byte.\n    if (len == 1 && b0 >= 0x80)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    for (;;)\n    {\n\tif (p[len] < 0x80 || !UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    return len;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += utf_ptr2len(p + len);\n    }\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\"\n * takes.  This includes following composing characters.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nutfc_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) // be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len_len(p, size);\n\n    // Check for illegal byte and incomplete byte sequence.\n    if ((len == 1 && p[0] >= 0x80) || len > size)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    while (len < size)\n    {\n\tint\tlen_next_char;\n\n\tif (p[len] < 0x80)\n\t    break;\n\n\t/*\n\t * Next character length should not go beyond size to ensure that\n\t * UTF_COMPOSINGLIKE(...) does not read beyond size.\n\t */\n\tlen_next_char = utf_ptr2len_len(p + len, size - len);\n\tif (len_next_char > size - len)\n\t    break;\n\n\tif (!UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    break;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += len_next_char;\n    }\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of character \"c\" takes.\n * This does not include composing characters.\n */\n    int\nutf_char2len(int c)\n{\n    if (c < 0x80)\n\treturn 1;\n    if (c < 0x800)\n\treturn 2;\n    if (c < 0x10000)\n\treturn 3;\n    if (c < 0x200000)\n\treturn 4;\n    if (c < 0x4000000)\n\treturn 5;\n    return 6;\n}\n\n/*\n * Convert Unicode character \"c\" to UTF-8 string in \"buf[]\".\n * Returns the number of bytes.\n */\n    int\nutf_char2bytes(int c, char_u *buf)\n{\n    if (c < 0x80)\t\t// 7 bits\n    {\n\tbuf[0] = c;\n\treturn 1;\n    }\n    if (c < 0x800)\t\t// 11 bits\n    {\n\tbuf[0] = 0xc0 + ((unsigned)c >> 6);\n\tbuf[1] = 0x80 + (c & 0x3f);\n\treturn 2;\n    }\n    if (c < 0x10000)\t\t// 16 bits\n    {\n\tbuf[0] = 0xe0 + ((unsigned)c >> 12);\n\tbuf[1] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[2] = 0x80 + (c & 0x3f);\n\treturn 3;\n    }\n    if (c < 0x200000)\t\t// 21 bits\n    {\n\tbuf[0] = 0xf0 + ((unsigned)c >> 18);\n\tbuf[1] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[3] = 0x80 + (c & 0x3f);\n\treturn 4;\n    }\n    if (c < 0x4000000)\t\t// 26 bits\n    {\n\tbuf[0] = 0xf8 + ((unsigned)c >> 24);\n\tbuf[1] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[3] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[4] = 0x80 + (c & 0x3f);\n\treturn 5;\n    }\n\t\t\t\t// 31 bits\n    buf[0] = 0xfc + ((unsigned)c >> 30);\n    buf[1] = 0x80 + (((unsigned)c >> 24) & 0x3f);\n    buf[2] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n    buf[3] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n    buf[4] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[5] = 0x80 + (c & 0x3f);\n    return 6;\n}\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_iscomposing() with different argument type for libvterm.\n */\n    int\nutf_iscomposing_uint(UINT32_T c)\n{\n    return utf_iscomposing((int)c);\n}\n#endif\n\n/*\n * Return TRUE if \"c\" is a composing UTF-8 character.  This means it will be\n * drawn on top of the preceding character.\n * Based on code from Markus Kuhn.\n */\n    int\nutf_iscomposing(int c)\n{\n    // Sorted list of non-overlapping intervals.\n    // Generated by ../runtime/tools/unicode.vim.\n    static struct interval combining[] =\n    {\n\t{0x0300, 0x036f},\n\t{0x0483, 0x0489},\n\t{0x0591, 0x05bd},\n\t{0x05bf, 0x05bf},\n\t{0x05c1, 0x05c2},\n\t{0x05c4, 0x05c5},\n\t{0x05c7, 0x05c7},\n\t{0x0610, 0x061a},\n\t{0x064b, 0x065f},\n\t{0x0670, 0x0670},\n\t{0x06d6, 0x06dc},\n\t{0x06df, 0x06e4},\n\t{0x06e7, 0x06e8},\n\t{0x06ea, 0x06ed},\n\t{0x0711, 0x0711},\n\t{0x0730, 0x074a},\n\t{0x07a6, 0x07b0},\n\t{0x07eb, 0x07f3},\n\t{0x07fd, 0x07fd},\n\t{0x0816, 0x0819},\n\t{0x081b, 0x0823},\n\t{0x0825, 0x0827},\n\t{0x0829, 0x082d},\n\t{0x0859, 0x085b},\n\t{0x08d3, 0x08e1},\n\t{0x08e3, 0x0903},\n\t{0x093a, 0x093c},\n\t{0x093e, 0x094f},\n\t{0x0951, 0x0957},\n\t{0x0962, 0x0963},\n\t{0x0981, 0x0983},\n\t{0x09bc, 0x09bc},\n\t{0x09be, 0x09c4},\n\t{0x09c7, 0x09c8},\n\t{0x09cb, 0x09cd},\n\t{0x09d7, 0x09d7},\n\t{0x09e2, 0x09e3},\n\t{0x09fe, 0x09fe},\n\t{0x0a01, 0x0a03},\n\t{0x0a3c, 0x0a3c},\n\t{0x0a3e, 0x0a42},\n\t{0x0a47, 0x0a48},\n\t{0x0a4b, 0x0a4d},\n\t{0x0a51, 0x0a51},\n\t{0x0a70, 0x0a71},\n\t{0x0a75, 0x0a75},\n\t{0x0a81, 0x0a83},\n\t{0x0abc, 0x0abc},\n\t{0x0abe, 0x0ac5},\n\t{0x0ac7, 0x0ac9},\n\t{0x0acb, 0x0acd},\n\t{0x0ae2, 0x0ae3},\n\t{0x0afa, 0x0aff},\n\t{0x0b01, 0x0b03},\n\t{0x0b3c, 0x0b3c},\n\t{0x0b3e, 0x0b44},\n\t{0x0b47, 0x0b48},\n\t{0x0b4b, 0x0b4d},\n\t{0x0b55, 0x0b57},\n\t{0x0b62, 0x0b63},\n\t{0x0b82, 0x0b82},\n\t{0x0bbe, 0x0bc2},\n\t{0x0bc6, 0x0bc8},\n\t{0x0bca, 0x0bcd},\n\t{0x0bd7, 0x0bd7},\n\t{0x0c00, 0x0c04},\n\t{0x0c3e, 0x0c44},\n\t{0x0c46, 0x0c48},\n\t{0x0c4a, 0x0c4d},\n\t{0x0c55, 0x0c56},\n\t{0x0c62, 0x0c63},\n\t{0x0c81, 0x0c83},\n\t{0x0cbc, 0x0cbc},\n\t{0x0cbe, 0x0cc4},\n\t{0x0cc6, 0x0cc8},\n\t{0x0cca, 0x0ccd},\n\t{0x0cd5, 0x0cd6},\n\t{0x0ce2, 0x0ce3},\n\t{0x0d00, 0x0d03},\n\t{0x0d3b, 0x0d3c},\n\t{0x0d3e, 0x0d44},\n\t{0x0d46, 0x0d48},\n\t{0x0d4a, 0x0d4d},\n\t{0x0d57, 0x0d57},\n\t{0x0d62, 0x0d63},\n\t{0x0d81, 0x0d83},\n\t{0x0dca, 0x0dca},\n\t{0x0dcf, 0x0dd4},\n\t{0x0dd6, 0x0dd6},\n\t{0x0dd8, 0x0ddf},\n\t{0x0df2, 0x0df3},\n\t{0x0e31, 0x0e31},\n\t{0x0e34, 0x0e3a},\n\t{0x0e47, 0x0e4e},\n\t{0x0eb1, 0x0eb1},\n\t{0x0eb4, 0x0ebc},\n\t{0x0ec8, 0x0ecd},\n\t{0x0f18, 0x0f19},\n\t{0x0f35, 0x0f35},\n\t{0x0f37, 0x0f37},\n\t{0x0f39, 0x0f39},\n\t{0x0f3e, 0x0f3f},\n\t{0x0f71, 0x0f84},\n\t{0x0f86, 0x0f87},\n\t{0x0f8d, 0x0f97},\n\t{0x0f99, 0x0fbc},\n\t{0x0fc6, 0x0fc6},\n\t{0x102b, 0x103e},\n\t{0x1056, 0x1059},\n\t{0x105e, 0x1060},\n\t{0x1062, 0x1064},\n\t{0x1067, 0x106d},\n\t{0x1071, 0x1074},\n\t{0x1082, 0x108d},\n\t{0x108f, 0x108f},\n\t{0x109a, 0x109d},\n\t{0x135d, 0x135f},\n\t{0x1712, 0x1714},\n\t{0x1732, 0x1734},\n\t{0x1752, 0x1753},\n\t{0x1772, 0x1773},\n\t{0x17b4, 0x17d3},\n\t{0x17dd, 0x17dd},\n\t{0x180b, 0x180d},\n\t{0x1885, 0x1886},\n\t{0x18a9, 0x18a9},\n\t{0x1920, 0x192b},\n\t{0x1930, 0x193b},\n\t{0x1a17, 0x1a1b},\n\t{0x1a55, 0x1a5e},\n\t{0x1a60, 0x1a7c},\n\t{0x1a7f, 0x1a7f},\n\t{0x1ab0, 0x1ac0},\n\t{0x1b00, 0x1b04},\n\t{0x1b34, 0x1b44},\n\t{0x1b6b, 0x1b73},\n\t{0x1b80, 0x1b82},\n\t{0x1ba1, 0x1bad},\n\t{0x1be6, 0x1bf3},\n\t{0x1c24, 0x1c37},\n\t{0x1cd0, 0x1cd2},\n\t{0x1cd4, 0x1ce8},\n\t{0x1ced, 0x1ced},\n\t{0x1cf4, 0x1cf4},\n\t{0x1cf7, 0x1cf9},\n\t{0x1dc0, 0x1df9},\n\t{0x1dfb, 0x1dff},\n\t{0x20d0, 0x20f0},\n\t{0x2cef, 0x2cf1},\n\t{0x2d7f, 0x2d7f},\n\t{0x2de0, 0x2dff},\n\t{0x302a, 0x302f},\n\t{0x3099, 0x309a},\n\t{0xa66f, 0xa672},\n\t{0xa674, 0xa67d},\n\t{0xa69e, 0xa69f},\n\t{0xa6f0, 0xa6f1},\n\t{0xa802, 0xa802},\n\t{0xa806, 0xa806},\n\t{0xa80b, 0xa80b},\n\t{0xa823, 0xa827},\n\t{0xa82c, 0xa82c},\n\t{0xa880, 0xa881},\n\t{0xa8b4, 0xa8c5},\n\t{0xa8e0, 0xa8f1},\n\t{0xa8ff, 0xa8ff},\n\t{0xa926, 0xa92d},\n\t{0xa947, 0xa953},\n\t{0xa980, 0xa983},\n\t{0xa9b3, 0xa9c0},\n\t{0xa9e5, 0xa9e5},\n\t{0xaa29, 0xaa36},\n\t{0xaa43, 0xaa43},\n\t{0xaa4c, 0xaa4d},\n\t{0xaa7b, 0xaa7d},\n\t{0xaab0, 0xaab0},\n\t{0xaab2, 0xaab4},\n\t{0xaab7, 0xaab8},\n\t{0xaabe, 0xaabf},\n\t{0xaac1, 0xaac1},\n\t{0xaaeb, 0xaaef},\n\t{0xaaf5, 0xaaf6},\n\t{0xabe3, 0xabea},\n\t{0xabec, 0xabed},\n\t{0xfb1e, 0xfb1e},\n\t{0xfe00, 0xfe0f},\n\t{0xfe20, 0xfe2f},\n\t{0x101fd, 0x101fd},\n\t{0x102e0, 0x102e0},\n\t{0x10376, 0x1037a},\n\t{0x10a01, 0x10a03},\n\t{0x10a05, 0x10a06},\n\t{0x10a0c, 0x10a0f},\n\t{0x10a38, 0x10a3a},\n\t{0x10a3f, 0x10a3f},\n\t{0x10ae5, 0x10ae6},\n\t{0x10d24, 0x10d27},\n\t{0x10eab, 0x10eac},\n\t{0x10f46, 0x10f50},\n\t{0x11000, 0x11002},\n\t{0x11038, 0x11046},\n\t{0x1107f, 0x11082},\n\t{0x110b0, 0x110ba},\n\t{0x11100, 0x11102},\n\t{0x11127, 0x11134},\n\t{0x11145, 0x11146},\n\t{0x11173, 0x11173},\n\t{0x11180, 0x11182},\n\t{0x111b3, 0x111c0},\n\t{0x111c9, 0x111cc},\n\t{0x111ce, 0x111cf},\n\t{0x1122c, 0x11237},\n\t{0x1123e, 0x1123e},\n\t{0x112df, 0x112ea},\n\t{0x11300, 0x11303},\n\t{0x1133b, 0x1133c},\n\t{0x1133e, 0x11344},\n\t{0x11347, 0x11348},\n\t{0x1134b, 0x1134d},\n\t{0x11357, 0x11357},\n\t{0x11362, 0x11363},\n\t{0x11366, 0x1136c},\n\t{0x11370, 0x11374},\n\t{0x11435, 0x11446},\n\t{0x1145e, 0x1145e},\n\t{0x114b0, 0x114c3},\n\t{0x115af, 0x115b5},\n\t{0x115b8, 0x115c0},\n\t{0x115dc, 0x115dd},\n\t{0x11630, 0x11640},\n\t{0x116ab, 0x116b7},\n\t{0x1171d, 0x1172b},\n\t{0x1182c, 0x1183a},\n\t{0x11930, 0x11935},\n\t{0x11937, 0x11938},\n\t{0x1193b, 0x1193e},\n\t{0x11940, 0x11940},\n\t{0x11942, 0x11943},\n\t{0x119d1, 0x119d7},\n\t{0x119da, 0x119e0},\n\t{0x119e4, 0x119e4},\n\t{0x11a01, 0x11a0a},\n\t{0x11a33, 0x11a39},\n\t{0x11a3b, 0x11a3e},\n\t{0x11a47, 0x11a47},\n\t{0x11a51, 0x11a5b},\n\t{0x11a8a, 0x11a99},\n\t{0x11c2f, 0x11c36},\n\t{0x11c38, 0x11c3f},\n\t{0x11c92, 0x11ca7},\n\t{0x11ca9, 0x11cb6},\n\t{0x11d31, 0x11d36},\n\t{0x11d3a, 0x11d3a},\n\t{0x11d3c, 0x11d3d},\n\t{0x11d3f, 0x11d45},\n\t{0x11d47, 0x11d47},\n\t{0x11d8a, 0x11d8e},\n\t{0x11d90, 0x11d91},\n\t{0x11d93, 0x11d97},\n\t{0x11ef3, 0x11ef6},\n\t{0x16af0, 0x16af4},\n\t{0x16b30, 0x16b36},\n\t{0x16f4f, 0x16f4f},\n\t{0x16f51, 0x16f87},\n\t{0x16f8f, 0x16f92},\n\t{0x16fe4, 0x16fe4},\n\t{0x16ff0, 0x16ff1},\n\t{0x1bc9d, 0x1bc9e},\n\t{0x1d165, 0x1d169},\n\t{0x1d16d, 0x1d172},\n\t{0x1d17b, 0x1d182},\n\t{0x1d185, 0x1d18b},\n\t{0x1d1aa, 0x1d1ad},\n\t{0x1d242, 0x1d244},\n\t{0x1da00, 0x1da36},\n\t{0x1da3b, 0x1da6c},\n\t{0x1da75, 0x1da75},\n\t{0x1da84, 0x1da84},\n\t{0x1da9b, 0x1da9f},\n\t{0x1daa1, 0x1daaf},\n\t{0x1e000, 0x1e006},\n\t{0x1e008, 0x1e018},\n\t{0x1e01b, 0x1e021},\n\t{0x1e023, 0x1e024},\n\t{0x1e026, 0x1e02a},\n\t{0x1e130, 0x1e136},\n\t{0x1e2ec, 0x1e2ef},\n\t{0x1e8d0, 0x1e8d6},\n\t{0x1e944, 0x1e94a},\n\t{0xe0100, 0xe01ef}\n    };\n\n    return intable(combining, sizeof(combining), c);\n}\n\n/*\n * Return TRUE for characters that can be displayed in a normal way.\n * Only for characters of 0x100 and above!\n */\n    int\nutf_printable(int c)\n{\n#ifdef USE_WCHAR_FUNCTIONS\n    /*\n     * Assume the iswprint() library function works better than our own stuff.\n     */\n    return iswprint(c);\n#else\n    // Sorted list of non-overlapping intervals.\n    // 0xd800-0xdfff is reserved for UTF-16, actually illegal.\n    static struct interval nonprint[] =\n    {\n\t{0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},\n\t{0x2060, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},\n\t{0xfffe, 0xffff}\n    };\n\n    return !intable(nonprint, sizeof(nonprint), c);\n#endif\n}\n\n// Sorted list of non-overlapping intervals of all Emoji characters,\n// based on http://unicode.org/emoji/charts/emoji-list.html\n// Generated by ../runtime/tools/unicode.vim.\n// Excludes 0x00a9 and 0x00ae because they are considered latin1.\nstatic struct interval emoji_all[] =\n{\n    {0x203c, 0x203c},\n    {0x2049, 0x2049},\n    {0x2122, 0x2122},\n    {0x2139, 0x2139},\n    {0x2194, 0x2199},\n    {0x21a9, 0x21aa},\n    {0x231a, 0x231b},\n    {0x2328, 0x2328},\n    {0x23cf, 0x23cf},\n    {0x23e9, 0x23f3},\n    {0x23f8, 0x23fa},\n    {0x24c2, 0x24c2},\n    {0x25aa, 0x25ab},\n    {0x25b6, 0x25b6},\n    {0x25c0, 0x25c0},\n    {0x25fb, 0x25fe},\n    {0x2600, 0x2604},\n    {0x260e, 0x260e},\n    {0x2611, 0x2611},\n    {0x2614, 0x2615},\n    {0x2618, 0x2618},\n    {0x261d, 0x261d},\n    {0x2620, 0x2620},\n    {0x2622, 0x2623},\n    {0x2626, 0x2626},\n    {0x262a, 0x262a},\n    {0x262e, 0x262f},\n    {0x2638, 0x263a},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2648, 0x2653},\n    {0x265f, 0x2660},\n    {0x2663, 0x2663},\n    {0x2665, 0x2666},\n    {0x2668, 0x2668},\n    {0x267b, 0x267b},\n    {0x267e, 0x267f},\n    {0x2692, 0x2697},\n    {0x2699, 0x2699},\n    {0x269b, 0x269c},\n    {0x26a0, 0x26a1},\n    {0x26a7, 0x26a7},\n    {0x26aa, 0x26ab},\n    {0x26b0, 0x26b1},\n    {0x26bd, 0x26be},\n    {0x26c4, 0x26c5},\n    {0x26c8, 0x26c8},\n    {0x26ce, 0x26cf},\n    {0x26d1, 0x26d1},\n    {0x26d3, 0x26d4},\n    {0x26e9, 0x26ea},\n    {0x26f0, 0x26f5},\n    {0x26f7, 0x26fa},\n    {0x26fd, 0x26fd},\n    {0x2702, 0x2702},\n    {0x2705, 0x2705},\n    {0x2708, 0x270d},\n    {0x270f, 0x270f},\n    {0x2712, 0x2712},\n    {0x2714, 0x2714},\n    {0x2716, 0x2716},\n    {0x271d, 0x271d},\n    {0x2721, 0x2721},\n    {0x2728, 0x2728},\n    {0x2733, 0x2734},\n    {0x2744, 0x2744},\n    {0x2747, 0x2747},\n    {0x274c, 0x274c},\n    {0x274e, 0x274e},\n    {0x2753, 0x2755},\n    {0x2757, 0x2757},\n    {0x2763, 0x2764},\n    {0x2795, 0x2797},\n    {0x27a1, 0x27a1},\n    {0x27b0, 0x27b0},\n    {0x27bf, 0x27bf},\n    {0x2934, 0x2935},\n    {0x2b05, 0x2b07},\n    {0x2b1b, 0x2b1c},\n    {0x2b50, 0x2b50},\n    {0x2b55, 0x2b55},\n    {0x3030, 0x3030},\n    {0x303d, 0x303d},\n    {0x3297, 0x3297},\n    {0x3299, 0x3299},\n    {0x1f004, 0x1f004},\n    {0x1f0cf, 0x1f0cf},\n    {0x1f170, 0x1f171},\n    {0x1f17e, 0x1f17f},\n    {0x1f18e, 0x1f18e},\n    {0x1f191, 0x1f19a},\n    {0x1f1e6, 0x1f1ff},\n    {0x1f201, 0x1f202},\n    {0x1f21a, 0x1f21a},\n    {0x1f22f, 0x1f22f},\n    {0x1f232, 0x1f23a},\n    {0x1f250, 0x1f251},\n    {0x1f300, 0x1f321},\n    {0x1f324, 0x1f393},\n    {0x1f396, 0x1f397},\n    {0x1f399, 0x1f39b},\n    {0x1f39e, 0x1f3f0},\n    {0x1f3f3, 0x1f3f5},\n    {0x1f3f7, 0x1f4fd},\n    {0x1f4ff, 0x1f53d},\n    {0x1f549, 0x1f54e},\n    {0x1f550, 0x1f567},\n    {0x1f56f, 0x1f570},\n    {0x1f573, 0x1f57a},\n    {0x1f587, 0x1f587},\n    {0x1f58a, 0x1f58d},\n    {0x1f590, 0x1f590},\n    {0x1f595, 0x1f596},\n    {0x1f5a4, 0x1f5a5},\n    {0x1f5a8, 0x1f5a8},\n    {0x1f5b1, 0x1f5b2},\n    {0x1f5bc, 0x1f5bc},\n    {0x1f5c2, 0x1f5c4},\n    {0x1f5d1, 0x1f5d3},\n    {0x1f5dc, 0x1f5de},\n    {0x1f5e1, 0x1f5e1},\n    {0x1f5e3, 0x1f5e3},\n    {0x1f5e8, 0x1f5e8},\n    {0x1f5ef, 0x1f5ef},\n    {0x1f5f3, 0x1f5f3},\n    {0x1f5fa, 0x1f64f},\n    {0x1f680, 0x1f6c5},\n    {0x1f6cb, 0x1f6d2},\n    {0x1f6d5, 0x1f6d7},\n    {0x1f6e0, 0x1f6e5},\n    {0x1f6e9, 0x1f6e9},\n    {0x1f6eb, 0x1f6ec},\n    {0x1f6f0, 0x1f6f0},\n    {0x1f6f3, 0x1f6fc},\n    {0x1f7e0, 0x1f7eb},\n    {0x1f90c, 0x1f93a},\n    {0x1f93c, 0x1f945},\n    {0x1f947, 0x1f978},\n    {0x1f97a, 0x1f9cb},\n    {0x1f9cd, 0x1f9ff},\n    {0x1fa70, 0x1fa74},\n    {0x1fa78, 0x1fa7a},\n    {0x1fa80, 0x1fa86},\n    {0x1fa90, 0x1faa8},\n    {0x1fab0, 0x1fab6},\n    {0x1fac0, 0x1fac2},\n    {0x1fad0, 0x1fad6}\n};\n\n/*\n * Get class of a Unicode character.\n * 0: white space\n * 1: punctuation\n * 2 or bigger: some class of word character.\n */\n    int\nutf_class(int c)\n{\n    return utf_class_buf(c, curbuf);\n}\n\n    int\nutf_class_buf(int c, buf_T *buf)\n{\n    // sorted list of non-overlapping intervals\n    static struct clinterval\n    {\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int class;\n    } classes[] =\n    {\n\t{0x037e, 0x037e, 1},\t\t// Greek question mark\n\t{0x0387, 0x0387, 1},\t\t// Greek ano teleia\n\t{0x055a, 0x055f, 1},\t\t// Armenian punctuation\n\t{0x0589, 0x0589, 1},\t\t// Armenian full stop\n\t{0x05be, 0x05be, 1},\n\t{0x05c0, 0x05c0, 1},\n\t{0x05c3, 0x05c3, 1},\n\t{0x05f3, 0x05f4, 1},\n\t{0x060c, 0x060c, 1},\n\t{0x061b, 0x061b, 1},\n\t{0x061f, 0x061f, 1},\n\t{0x066a, 0x066d, 1},\n\t{0x06d4, 0x06d4, 1},\n\t{0x0700, 0x070d, 1},\t\t// Syriac punctuation\n\t{0x0964, 0x0965, 1},\n\t{0x0970, 0x0970, 1},\n\t{0x0df4, 0x0df4, 1},\n\t{0x0e4f, 0x0e4f, 1},\n\t{0x0e5a, 0x0e5b, 1},\n\t{0x0f04, 0x0f12, 1},\n\t{0x0f3a, 0x0f3d, 1},\n\t{0x0f85, 0x0f85, 1},\n\t{0x104a, 0x104f, 1},\t\t// Myanmar punctuation\n\t{0x10fb, 0x10fb, 1},\t\t// Georgian punctuation\n\t{0x1361, 0x1368, 1},\t\t// Ethiopic punctuation\n\t{0x166d, 0x166e, 1},\t\t// Canadian Syl. punctuation\n\t{0x1680, 0x1680, 0},\n\t{0x169b, 0x169c, 1},\n\t{0x16eb, 0x16ed, 1},\n\t{0x1735, 0x1736, 1},\n\t{0x17d4, 0x17dc, 1},\t\t// Khmer punctuation\n\t{0x1800, 0x180a, 1},\t\t// Mongolian punctuation\n\t{0x2000, 0x200b, 0},\t\t// spaces\n\t{0x200c, 0x2027, 1},\t\t// punctuation and symbols\n\t{0x2028, 0x2029, 0},\n\t{0x202a, 0x202e, 1},\t\t// punctuation and symbols\n\t{0x202f, 0x202f, 0},\n\t{0x2030, 0x205e, 1},\t\t// punctuation and symbols\n\t{0x205f, 0x205f, 0},\n\t{0x2060, 0x27ff, 1},\t\t// punctuation and symbols\n\t{0x2070, 0x207f, 0x2070},\t// superscript\n\t{0x2080, 0x2094, 0x2080},\t// subscript\n\t{0x20a0, 0x27ff, 1},\t\t// all kinds of symbols\n\t{0x2800, 0x28ff, 0x2800},\t// braille\n\t{0x2900, 0x2998, 1},\t\t// arrows, brackets, etc.\n\t{0x29d8, 0x29db, 1},\n\t{0x29fc, 0x29fd, 1},\n\t{0x2e00, 0x2e7f, 1},\t\t// supplemental punctuation\n\t{0x3000, 0x3000, 0},\t\t// ideographic space\n\t{0x3001, 0x3020, 1},\t\t// ideographic punctuation\n\t{0x3030, 0x3030, 1},\n\t{0x303d, 0x303d, 1},\n\t{0x3040, 0x309f, 0x3040},\t// Hiragana\n\t{0x30a0, 0x30ff, 0x30a0},\t// Katakana\n\t{0x3300, 0x9fff, 0x4e00},\t// CJK Ideographs\n\t{0xac00, 0xd7a3, 0xac00},\t// Hangul Syllables\n\t{0xf900, 0xfaff, 0x4e00},\t// CJK Ideographs\n\t{0xfd3e, 0xfd3f, 1},\n\t{0xfe30, 0xfe6b, 1},\t\t// punctuation forms\n\t{0xff00, 0xff0f, 1},\t\t// half/fullwidth ASCII\n\t{0xff1a, 0xff20, 1},\t\t// half/fullwidth ASCII\n\t{0xff3b, 0xff40, 1},\t\t// half/fullwidth ASCII\n\t{0xff5b, 0xff65, 1},\t\t// half/fullwidth ASCII\n\t{0x1d000, 0x1d24f, 1},\t\t// Musical notation\n\t{0x1d400, 0x1d7ff, 1},\t\t// Mathematical Alphanumeric Symbols\n\t{0x1f000, 0x1f2ff, 1},\t\t// Game pieces; enclosed characters\n\t{0x1f300, 0x1f9ff, 1},\t\t// Many symbol blocks\n\t{0x20000, 0x2a6df, 0x4e00},\t// CJK Ideographs\n\t{0x2a700, 0x2b73f, 0x4e00},\t// CJK Ideographs\n\t{0x2b740, 0x2b81f, 0x4e00},\t// CJK Ideographs\n\t{0x2f800, 0x2fa1f, 0x4e00},\t// CJK Ideographs\n    };\n\n    int bot = 0;\n    int top = ARRAY_LENGTH(classes) - 1;\n    int mid;\n\n    // First quick check for Latin1 characters, use 'iskeyword'.\n    if (c < 0x100)\n    {\n\tif (c == ' ' || c == '\\t' || c == NUL || c == 0xa0)\n\t    return 0;\t    // blank\n\tif (vim_iswordc_buf(c, buf))\n\t    return 2;\t    // word character\n\treturn 1;\t    // punctuation\n    }\n\n    // emoji\n    if (intable(emoji_all, sizeof(emoji_all), c))\n\treturn 3;\n\n    // binary search in table\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (classes[mid].last < (unsigned int)c)\n\t    bot = mid + 1;\n\telse if (classes[mid].first > (unsigned int)c)\n\t    top = mid - 1;\n\telse\n\t    return (int)classes[mid].class;\n    }\n\n    // most other characters are \"word\" characters\n    return 2;\n}\n\n    int\nutf_ambiguous_width(int c)\n{\n    return c >= 0x80 && (intable(ambiguous, sizeof(ambiguous), c)\n\t    || intable(emoji_all, sizeof(emoji_all), c));\n}\n\n/*\n * Code for Unicode case-dependent operations.  Based on notes in\n * http://www.unicode.org/Public/UNIDATA/CaseFolding.txt\n * This code uses simple case folding, not full case folding.\n * Last updated for Unicode 5.2.\n */\n\n/*\n * The following tables are built by ../runtime/tools/unicode.vim.\n * They must be in numeric order, because we use binary search.\n * An entry such as {0x41,0x5a,1,32} means that Unicode characters in the\n * range from 0x41 to 0x5a inclusive, stepping by 1, are changed to\n * folded/upper/lower by adding 32.\n */\ntypedef struct\n{\n    int rangeStart;\n    int rangeEnd;\n    int step;\n    int offset;\n} convertStruct;\n\nstatic convertStruct foldCase[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xb5,0xb5,-1,775},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x17f,0x17f,-1,-268},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x345,0x345,-1,116},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3c2,0x3c2,-1,1},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d0,0x3d0,-1,-30},\n\t{0x3d1,0x3d1,-1,-25},\n\t{0x3d5,0x3d5,-1,-15},\n\t{0x3d6,0x3d6,-1,-22},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f0,0x3f0,-1,-54},\n\t{0x3f1,0x3f1,-1,-48},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f5,0x3f5,-1,-64},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6222},\n\t{0x1c81,0x1c81,-1,-6221},\n\t{0x1c82,0x1c82,-1,-6212},\n\t{0x1c83,0x1c84,1,-6210},\n\t{0x1c85,0x1c85,-1,-6211},\n\t{0x1c86,0x1c86,-1,-6204},\n\t{0x1c87,0x1c87,-1,-6180},\n\t{0x1c88,0x1c88,-1,35267},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9b,0x1e9b,-1,-58},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fbe,0x1fbe,-1,-7173},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\n/*\n * Generic conversion function for case operations.\n * Return the converted equivalent of \"a\", which is a UCS-4 character.  Use\n * the given conversion \"table\".  Uses binary search on \"table\".\n */\n    static int\nutf_convert(\n    int\t\t\ta,\n    convertStruct\ttable[],\n    int\t\t\ttableSize)\n{\n    int start, mid, end; // indices into table\n    int entries = tableSize / sizeof(convertStruct);\n\n    start = 0;\n    end = entries;\n    while (start < end)\n    {\n\t// need to search further\n\tmid = (end + start) / 2;\n\tif (table[mid].rangeEnd < a)\n\t    start = mid + 1;\n\telse\n\t    end = mid;\n    }\n    if (start < entries\n\t    && table[start].rangeStart <= a\n\t    && a <= table[start].rangeEnd\n\t    && (a - table[start].rangeStart) % table[start].step == 0)\n\treturn (a + table[start].offset);\n    else\n\treturn a;\n}\n\n/*\n * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses\n * simple case folding.\n */\n    int\nutf_fold(int a)\n{\n    if (a < 0x80)\n\t// be fast for ASCII\n\treturn a >= 0x41 && a <= 0x5a ? a + 32 : a;\n    return utf_convert(a, foldCase, (int)sizeof(foldCase));\n}\n\nstatic convertStruct toLower[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x130,0x130,-1,-199},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13a0,0x13ef,1,38864},\n\t{0x13f0,0x13f5,1,8},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\nstatic convertStruct toUpper[] =\n{\n\t{0x61,0x7a,1,-32},\n\t{0xb5,0xb5,-1,743},\n\t{0xe0,0xf6,1,-32},\n\t{0xf8,0xfe,1,-32},\n\t{0xff,0xff,-1,121},\n\t{0x101,0x12f,2,-1},\n\t{0x131,0x131,-1,-232},\n\t{0x133,0x137,2,-1},\n\t{0x13a,0x148,2,-1},\n\t{0x14b,0x177,2,-1},\n\t{0x17a,0x17e,2,-1},\n\t{0x17f,0x17f,-1,-300},\n\t{0x180,0x180,-1,195},\n\t{0x183,0x185,2,-1},\n\t{0x188,0x18c,4,-1},\n\t{0x192,0x192,-1,-1},\n\t{0x195,0x195,-1,97},\n\t{0x199,0x199,-1,-1},\n\t{0x19a,0x19a,-1,163},\n\t{0x19e,0x19e,-1,130},\n\t{0x1a1,0x1a5,2,-1},\n\t{0x1a8,0x1ad,5,-1},\n\t{0x1b0,0x1b4,4,-1},\n\t{0x1b6,0x1b9,3,-1},\n\t{0x1bd,0x1bd,-1,-1},\n\t{0x1bf,0x1bf,-1,56},\n\t{0x1c5,0x1c5,-1,-1},\n\t{0x1c6,0x1c6,-1,-2},\n\t{0x1c8,0x1c8,-1,-1},\n\t{0x1c9,0x1c9,-1,-2},\n\t{0x1cb,0x1cb,-1,-1},\n\t{0x1cc,0x1cc,-1,-2},\n\t{0x1ce,0x1dc,2,-1},\n\t{0x1dd,0x1dd,-1,-79},\n\t{0x1df,0x1ef,2,-1},\n\t{0x1f2,0x1f2,-1,-1},\n\t{0x1f3,0x1f3,-1,-2},\n\t{0x1f5,0x1f9,4,-1},\n\t{0x1fb,0x21f,2,-1},\n\t{0x223,0x233,2,-1},\n\t{0x23c,0x23c,-1,-1},\n\t{0x23f,0x240,1,10815},\n\t{0x242,0x247,5,-1},\n\t{0x249,0x24f,2,-1},\n\t{0x250,0x250,-1,10783},\n\t{0x251,0x251,-1,10780},\n\t{0x252,0x252,-1,10782},\n\t{0x253,0x253,-1,-210},\n\t{0x254,0x254,-1,-206},\n\t{0x256,0x257,1,-205},\n\t{0x259,0x259,-1,-202},\n\t{0x25b,0x25b,-1,-203},\n\t{0x25c,0x25c,-1,42319},\n\t{0x260,0x260,-1,-205},\n\t{0x261,0x261,-1,42315},\n\t{0x263,0x263,-1,-207},\n\t{0x265,0x265,-1,42280},\n\t{0x266,0x266,-1,42308},\n\t{0x268,0x268,-1,-209},\n\t{0x269,0x269,-1,-211},\n\t{0x26a,0x26a,-1,42308},\n\t{0x26b,0x26b,-1,10743},\n\t{0x26c,0x26c,-1,42305},\n\t{0x26f,0x26f,-1,-211},\n\t{0x271,0x271,-1,10749},\n\t{0x272,0x272,-1,-213},\n\t{0x275,0x275,-1,-214},\n\t{0x27d,0x27d,-1,10727},\n\t{0x280,0x280,-1,-218},\n\t{0x282,0x282,-1,42307},\n\t{0x283,0x283,-1,-218},\n\t{0x287,0x287,-1,42282},\n\t{0x288,0x288,-1,-218},\n\t{0x289,0x289,-1,-69},\n\t{0x28a,0x28b,1,-217},\n\t{0x28c,0x28c,-1,-71},\n\t{0x292,0x292,-1,-219},\n\t{0x29d,0x29d,-1,42261},\n\t{0x29e,0x29e,-1,42258},\n\t{0x345,0x345,-1,84},\n\t{0x371,0x373,2,-1},\n\t{0x377,0x377,-1,-1},\n\t{0x37b,0x37d,1,130},\n\t{0x3ac,0x3ac,-1,-38},\n\t{0x3ad,0x3af,1,-37},\n\t{0x3b1,0x3c1,1,-32},\n\t{0x3c2,0x3c2,-1,-31},\n\t{0x3c3,0x3cb,1,-32},\n\t{0x3cc,0x3cc,-1,-64},\n\t{0x3cd,0x3ce,1,-63},\n\t{0x3d0,0x3d0,-1,-62},\n\t{0x3d1,0x3d1,-1,-57},\n\t{0x3d5,0x3d5,-1,-47},\n\t{0x3d6,0x3d6,-1,-54},\n\t{0x3d7,0x3d7,-1,-8},\n\t{0x3d9,0x3ef,2,-1},\n\t{0x3f0,0x3f0,-1,-86},\n\t{0x3f1,0x3f1,-1,-80},\n\t{0x3f2,0x3f2,-1,7},\n\t{0x3f3,0x3f3,-1,-116},\n\t{0x3f5,0x3f5,-1,-96},\n\t{0x3f8,0x3fb,3,-1},\n\t{0x430,0x44f,1,-32},\n\t{0x450,0x45f,1,-80},\n\t{0x461,0x481,2,-1},\n\t{0x48b,0x4bf,2,-1},\n\t{0x4c2,0x4ce,2,-1},\n\t{0x4cf,0x4cf,-1,-15},\n\t{0x4d1,0x52f,2,-1},\n\t{0x561,0x586,1,-48},\n\t{0x10d0,0x10fa,1,3008},\n\t{0x10fd,0x10ff,1,3008},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6254},\n\t{0x1c81,0x1c81,-1,-6253},\n\t{0x1c82,0x1c82,-1,-6244},\n\t{0x1c83,0x1c84,1,-6242},\n\t{0x1c85,0x1c85,-1,-6243},\n\t{0x1c86,0x1c86,-1,-6236},\n\t{0x1c87,0x1c87,-1,-6181},\n\t{0x1c88,0x1c88,-1,35266},\n\t{0x1d79,0x1d79,-1,35332},\n\t{0x1d7d,0x1d7d,-1,3814},\n\t{0x1d8e,0x1d8e,-1,35384},\n\t{0x1e01,0x1e95,2,-1},\n\t{0x1e9b,0x1e9b,-1,-59},\n\t{0x1ea1,0x1eff,2,-1},\n\t{0x1f00,0x1f07,1,8},\n\t{0x1f10,0x1f15,1,8},\n\t{0x1f20,0x1f27,1,8},\n\t{0x1f30,0x1f37,1,8},\n\t{0x1f40,0x1f45,1,8},\n\t{0x1f51,0x1f57,2,8},\n\t{0x1f60,0x1f67,1,8},\n\t{0x1f70,0x1f71,1,74},\n\t{0x1f72,0x1f75,1,86},\n\t{0x1f76,0x1f77,1,100},\n\t{0x1f78,0x1f79,1,128},\n\t{0x1f7a,0x1f7b,1,112},\n\t{0x1f7c,0x1f7d,1,126},\n\t{0x1f80,0x1f87,1,8},\n\t{0x1f90,0x1f97,1,8},\n\t{0x1fa0,0x1fa7,1,8},\n\t{0x1fb0,0x1fb1,1,8},\n\t{0x1fb3,0x1fb3,-1,9},\n\t{0x1fbe,0x1fbe,-1,-7205},\n\t{0x1fc3,0x1fc3,-1,9},\n\t{0x1fd0,0x1fd1,1,8},\n\t{0x1fe0,0x1fe1,1,8},\n\t{0x1fe5,0x1fe5,-1,7},\n\t{0x1ff3,0x1ff3,-1,9},\n\t{0x214e,0x214e,-1,-28},\n\t{0x2170,0x217f,1,-16},\n\t{0x2184,0x2184,-1,-1},\n\t{0x24d0,0x24e9,1,-26},\n\t{0x2c30,0x2c5e,1,-48},\n\t{0x2c61,0x2c61,-1,-1},\n\t{0x2c65,0x2c65,-1,-10795},\n\t{0x2c66,0x2c66,-1,-10792},\n\t{0x2c68,0x2c6c,2,-1},\n\t{0x2c73,0x2c76,3,-1},\n\t{0x2c81,0x2ce3,2,-1},\n\t{0x2cec,0x2cee,2,-1},\n\t{0x2cf3,0x2cf3,-1,-1},\n\t{0x2d00,0x2d25,1,-7264},\n\t{0x2d27,0x2d2d,6,-7264},\n\t{0xa641,0xa66d,2,-1},\n\t{0xa681,0xa69b,2,-1},\n\t{0xa723,0xa72f,2,-1},\n\t{0xa733,0xa76f,2,-1},\n\t{0xa77a,0xa77c,2,-1},\n\t{0xa77f,0xa787,2,-1},\n\t{0xa78c,0xa791,5,-1},\n\t{0xa793,0xa793,-1,-1},\n\t{0xa794,0xa794,-1,48},\n\t{0xa797,0xa7a9,2,-1},\n\t{0xa7b5,0xa7bf,2,-1},\n\t{0xa7c3,0xa7c8,5,-1},\n\t{0xa7ca,0xa7f6,44,-1},\n\t{0xab53,0xab53,-1,-928},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff41,0xff5a,1,-32},\n\t{0x10428,0x1044f,1,-40},\n\t{0x104d8,0x104fb,1,-40},\n\t{0x10cc0,0x10cf2,1,-64},\n\t{0x118c0,0x118df,1,-32},\n\t{0x16e60,0x16e7f,1,-32},\n\t{0x1e922,0x1e943,1,-34}\n};\n\n/*\n * Return the upper-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_toupper(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style toupper().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOUPPER_ASC(a);\n\n#if defined(HAVE_TOWUPPER) && defined(__STDC_ISO_10646__)\n    // If towupper() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towupper(a);\n#endif\n\n    // For characters below 128 use locale sensitive toupper().\n    if (a < 128)\n\treturn TOUPPER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toUpper, (int)sizeof(toUpper));\n}\n\n    int\nutf_islower(int a)\n{\n    // German sharp s is lower case but has no upper case equivalent.\n    return (utf_toupper(a) != a) || a == 0xdf;\n}\n\n/*\n * Return the lower-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_tolower(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style tolower().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOLOWER_ASC(a);\n\n#if defined(HAVE_TOWLOWER) && defined(__STDC_ISO_10646__)\n    // If towlower() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towlower(a);\n#endif\n\n    // For characters below 128 use locale sensitive tolower().\n    if (a < 128)\n\treturn TOLOWER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toLower, (int)sizeof(toLower));\n}\n\n    int\nutf_isupper(int a)\n{\n    return (utf_tolower(a) != a);\n}\n\n    static int\nutf_strnicmp(\n    char_u      *s1,\n    char_u      *s2,\n    size_t      n1,\n    size_t      n2)\n{\n    int\t\tc1, c2, cdiff;\n    char_u\tbuffer[6];\n\n    for (;;)\n    {\n\tc1 = utf_safe_read_char_adv(&s1, &n1);\n\tc2 = utf_safe_read_char_adv(&s2, &n2);\n\n\tif (c1 <= 0 || c2 <= 0)\n\t    break;\n\n\tif (c1 == c2)\n\t    continue;\n\n\tcdiff = utf_fold(c1) - utf_fold(c2);\n\tif (cdiff != 0)\n\t    return cdiff;\n    }\n\n    // some string ended or has an incomplete/illegal character sequence\n\n    if (c1 == 0 || c2 == 0)\n    {\n\t// some string ended. shorter string is smaller\n\tif (c1 == 0 && c2 == 0)\n\t    return 0;\n\treturn c1 == 0 ? -1 : 1;\n    }\n\n    // Continue with bytewise comparison to produce some result that\n    // would make comparison operations involving this function transitive.\n    //\n    // If only one string had an error, comparison should be made with\n    // folded version of the other string. In this case it is enough\n    // to fold just one character to determine the result of comparison.\n\n    if (c1 != -1 && c2 == -1)\n    {\n\tn1 = utf_char2bytes(utf_fold(c1), buffer);\n\ts1 = buffer;\n    }\n    else if (c2 != -1 && c1 == -1)\n    {\n\tn2 = utf_char2bytes(utf_fold(c2), buffer);\n\ts2 = buffer;\n    }\n\n    while (n1 > 0 && n2 > 0 && *s1 != NUL && *s2 != NUL)\n    {\n\tcdiff = (int)(*s1) - (int)(*s2);\n\tif (cdiff != 0)\n\t    return cdiff;\n\n\ts1++;\n\ts2++;\n\tn1--;\n\tn2--;\n    }\n\n    if (n1 > 0 && *s1 == NUL)\n\tn1 = 0;\n    if (n2 > 0 && *s2 == NUL)\n\tn2 = 0;\n\n    if (n1 == 0 && n2 == 0)\n\treturn 0;\n    return n1 == 0 ? -1 : 1;\n}\n\n/*\n * Version of strnicmp() that handles multi-byte characters.\n * Needed for Big5, Shift-JIS and UTF-8 encoding.  Other DBCS encodings can\n * probably use strnicmp(), because there are no ASCII characters in the\n * second byte.\n * Returns zero if s1 and s2 are equal (ignoring case), the difference between\n * two characters otherwise.\n */\n    int\nmb_strnicmp(char_u *s1, char_u *s2, size_t nn)\n{\n    int\t\ti, l;\n    int\t\tcdiff;\n    int\t\tn = (int)nn;\n\n    if (enc_utf8)\n    {\n\treturn utf_strnicmp(s1, s2, nn, nn);\n    }\n    else\n    {\n\tfor (i = 0; i < n; i += l)\n\t{\n\t    if (s1[i] == NUL && s2[i] == NUL)\t// both strings end\n\t\treturn 0;\n\n\t    l = (*mb_ptr2len)(s1 + i);\n\t    if (l <= 1)\n\t    {\n\t\t// Single byte: first check normally, then with ignore case.\n\t\tif (s1[i] != s2[i])\n\t\t{\n\t\t    cdiff = MB_TOLOWER(s1[i]) - MB_TOLOWER(s2[i]);\n\t\t    if (cdiff != 0)\n\t\t\treturn cdiff;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// For non-Unicode multi-byte don't ignore case.\n\t\tif (l > n - i)\n\t\t    l = n - i;\n\t\tcdiff = STRNCMP(s1 + i, s2 + i, l);\n\t\tif (cdiff != 0)\n\t\t    return cdiff;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/*\n * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what\n * 'encoding' has been set to.\n */\n    void\nshow_utf8(void)\n{\n    int\t\tlen;\n    int\t\trlen = 0;\n    char_u\t*line;\n    int\t\tclen;\n    int\t\ti;\n\n    // Get the byte length of the char under the cursor, including composing\n    // characters.\n    line = ml_get_cursor();\n    len = utfc_ptr2len(line);\n    if (len == 0)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    clen = 0;\n    for (i = 0; i < len; ++i)\n    {\n\tif (clen == 0)\n\t{\n\t    // start of (composing) character, get its length\n\t    if (i > 0)\n\t    {\n\t\tSTRCPY(IObuff + rlen, \"+ \");\n\t\trlen += 2;\n\t    }\n\t    clen = utf_ptr2len(line + i);\n\t}\n\tsprintf((char *)IObuff + rlen, \"%02x \",\n\t\t(line[i] == NL) ? NUL : line[i]);  // NUL is stored as NL\n\t--clen;\n\trlen += (int)STRLEN(IObuff + rlen);\n\tif (rlen > IOSIZE - 20)\n\t    break;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * mb_head_off() function pointer.\n * Return offset from \"p\" to the first byte of the character it points into.\n * If \"p\" points to the NUL at the end of the string return 0.\n * Returns 0 when already at the first byte of a character.\n */\n    int\nlatin_head_off(char_u *base UNUSED, char_u *p UNUSED)\n{\n    return 0;\n}\n\n    static int\ndbcs_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    if (p <= base || MB_BYTE2LEN(p[-1]) == 1 || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    q = base;\n    while (q < p)\n\tq += dbcs_ptr2len(q);\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Special version of dbcs_head_off() that works for ScreenLines[], where\n * single-width DBCS_JPNU characters are stored separately.\n */\n    int\ndbcs_screen_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    // For euc-jp an 0x8e byte in the previous cell always means we have a\n    // lead byte in the current cell.\n    if (p <= base\n\t    || (enc_dbcs == DBCS_JPNU && p[-1] == 0x8e)\n\t    || MB_BYTE2LEN(p[-1]) == 1\n\t    || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    // For DBCS_JPNU look out for 0x8e, which means the second byte is not\n    // stored as the next byte.\n    q = base;\n    while (q < p)\n    {\n\tif (enc_dbcs == DBCS_JPNU && *q == 0x8e)\n\t    ++q;\n\telse\n\t    q += dbcs_ptr2len(q);\n    }\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Return offset from \"p\" to the start of a character, including composing\n * characters.  \"base\" must be the start of the string, which must be NUL\n * terminated.\n */\n    int\nutf_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    char_u\t*j;\n#endif\n\n    if (*p < 0x80)\t\t// be quick for ASCII\n\treturn 0;\n\n    // Skip backwards over trailing bytes: 10xx.xxxx\n    // Skip backwards again if on a composing char.\n    for (q = p; ; --q)\n    {\n\t// Move s to the last byte of this char.\n\tfor (s = q; (s[1] & 0xc0) == 0x80; ++s)\n\t    ;\n\t// Move q to the first byte of this char.\n\twhile (q > base && (*q & 0xc0) == 0x80)\n\t    --q;\n\t// Check for illegal sequence. Do allow an illegal byte after where we\n\t// started.\n\tlen = utf8len_tab[*q];\n\tif (len != (int)(s - q + 1) && len != (int)(p - q + 1))\n\t    return 0;\n\n\tif (q <= base)\n\t    break;\n\n\tc = utf_ptr2char(q);\n\tif (utf_iscomposing(c))\n\t    continue;\n\n#ifdef FEAT_ARABIC\n\tif (arabic_maycombine(c))\n\t{\n\t    // Advance to get a sneak-peak at the next char\n\t    j = q;\n\t    --j;\n\t    // Move j to the first byte of this char.\n\t    while (j > base && (*j & 0xc0) == 0x80)\n\t\t--j;\n\t    if (arabic_combine(utf_ptr2char(j), c))\n\t\tcontinue;\n\t}\n#endif\n\tbreak;\n    }\n\n    return (int)(p - q);\n}\n\n/*\n * Whether space is NOT allowed before/after 'c'.\n */\n    int\nutf_eat_space(int cc)\n{\n    return ((cc >= 0x2000 && cc <= 0x206F)\t// General punctuations\n\t || (cc >= 0x2e00 && cc <= 0x2e7f)\t// Supplemental punctuations\n\t || (cc >= 0x3000 && cc <= 0x303f)\t// CJK symbols and punctuations\n\t || (cc >= 0xff01 && cc <= 0xff0f)\t// Full width ASCII punctuations\n\t || (cc >= 0xff1a && cc <= 0xff20)\t// ..\n\t || (cc >= 0xff3b && cc <= 0xff40)\t// ..\n\t || (cc >= 0xff5b && cc <= 0xff65));\t// ..\n}\n\n/*\n * Whether line break is allowed before \"cc\".\n */\n    int\nutf_allow_break_before(int cc)\n{\n    static const int BOL_prohibition_punct[] =\n    {\n\t'!',\n\t'%',\n\t')',\n\t',',\n\t':',\n\t';',\n\t'>',\n\t'?',\n\t']',\n\t'}',\n\t0x2019, // \u2019 right single quotation mark\n\t0x201d, // \u201d right double quotation mark\n\t0x2020, // \u2020 dagger\n\t0x2021, // \u2021 double dagger\n\t0x2026, // \u2026 horizontal ellipsis\n\t0x2030, // \u2030 per mille sign\n\t0x2031, // \u2031 per then thousand sign\n\t0x203c, // \u203c double exclamation mark\n\t0x2047, // \u2047 double question mark\n\t0x2048, // \u2048 question exclamation mark\n\t0x2049, // \u2049 exclamation question mark\n\t0x2103, // \u2103 degree celsius\n\t0x2109, // \u2109 degree fahrenheit\n\t0x3001, // \u3001 ideographic comma\n\t0x3002, // \u3002 ideographic full stop\n\t0x3009, // \u3009 right angle bracket\n\t0x300b, // \u300b right double angle bracket\n\t0x300d, // \u300d right corner bracket\n\t0x300f, // \u300f right white corner bracket\n\t0x3011, // \u3011 right black lenticular bracket\n\t0x3015, // \u3015 right tortoise shell bracket\n\t0x3017, // \u3017 right white lenticular bracket\n\t0x3019, // \u3019 right white tortoise shell bracket\n\t0x301b, // \u301b right white square bracket\n\t0xff01, // \uff01 fullwidth exclamation mark\n\t0xff09, // \uff09 fullwidth right parenthesis\n\t0xff0c, // \uff0c fullwidth comma\n\t0xff0e, // \uff0e fullwidth full stop\n\t0xff1a, // \uff1a fullwidth colon\n\t0xff1b, // \uff1b fullwidth semicolon\n\t0xff1f, // \uff1f fullwidth question mark\n\t0xff3d, // \uff3d fullwidth right square bracket\n\t0xff5d, // \uff5d fullwidth right curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(BOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == BOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > BOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != BOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed after \"cc\".\n */\n    static int\nutf_allow_break_after(int cc)\n{\n    static const int EOL_prohibition_punct[] =\n    {\n\t'(',\n\t'<',\n\t'[',\n\t'`',\n\t'{',\n\t//0x2014, // \u2014 em dash\n\t0x2018, // \u2018 left single quotation mark\n\t0x201c, // \u201c left double quotation mark\n\t//0x2053, // \uff5e swung dash\n\t0x3008, // \u3008 left angle bracket\n\t0x300a, // \u300a left double angle bracket\n\t0x300c, // \u300c left corner bracket\n\t0x300e, // \u300e left white corner bracket\n\t0x3010, // \u3010 left black lenticular bracket\n\t0x3014, // \u3014 left tortoise shell bracket\n\t0x3016, // \u3016 left white lenticular bracket\n\t0x3018, // \u3018 left white tortoise shell bracket\n\t0x301a, // \u301a left white square bracket\n\t0xff08, // \uff08 fullwidth left parenthesis\n\t0xff3b, // \uff3b fullwidth left square bracket\n\t0xff5b, // \uff5b fullwidth left curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(EOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == EOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > EOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != EOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed between \"cc\" and \"ncc\".\n */\n    int\nutf_allow_break(int cc, int ncc)\n{\n    // don't break between two-letter punctuations\n    if (cc == ncc\n\t    && (cc == 0x2014 // em dash\n\t\t|| cc == 0x2026)) // horizontal ellipsis\n\treturn FALSE;\n\n    return utf_allow_break_after(cc) && utf_allow_break_before(ncc);\n}\n\n/*\n * Copy a character from \"*fp\" to \"*tp\" and advance the pointers.\n */\n    void\nmb_copy_char(char_u **fp, char_u **tp)\n{\n    int\t    l = (*mb_ptr2len)(*fp);\n\n    mch_memmove(*tp, *fp, (size_t)l);\n    *tp += l;\n    *fp += l;\n}\n\n/*\n * Return the offset from \"p\" to the first byte of a character.  When \"p\" is\n * at the start of a character 0 is returned, otherwise the offset to the next\n * character.  Can start anywhere in a stream of bytes.\n */\n    int\nmb_off_next(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (enc_utf8)\n    {\n\tif (*p < 0x80)\t\t// be quick for ASCII\n\t    return 0;\n\n\t// Find the next character that isn't 10xx.xxxx\n\tfor (i = 0; (p[i] & 0xc0) == 0x80; ++i)\n\t    ;\n\tif (i > 0)\n\t{\n\t    // Check for illegal sequence.\n\t    for (j = 0; p - j > base; ++j)\n\t\tif ((p[-j] & 0xc0) != 0x80)\n\t\t    break;\n\t    if (utf8len_tab[p[-j]] != i + j)\n\t\treturn 0;\n\t}\n\treturn i;\n    }\n\n    // Only need to check if we're on a trail byte, it doesn't matter if we\n    // want the offset to the next or current character.\n    return (*mb_head_off)(base, p);\n}\n\n/*\n * Return the offset from \"p\" to the last byte of the character it points\n * into.  Can start anywhere in a stream of bytes.\n * Composing characters are not included.\n */\n    int\nmb_tail_off(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (*p == NUL)\n\treturn 0;\n\n    if (enc_utf8)\n    {\n\t// Find the last character that is 10xx.xxxx\n\tfor (i = 0; (p[i + 1] & 0xc0) == 0x80; ++i)\n\t    ;\n\t// Check for illegal sequence.\n\tfor (j = 0; p - j > base; ++j)\n\t    if ((p[-j] & 0xc0) != 0x80)\n\t\tbreak;\n\tif (utf8len_tab[p[-j]] != i + j + 1)\n\t    return 0;\n\treturn i;\n    }\n\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    if (enc_dbcs == 0 || p[1] == NUL || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_head_off(base, p);\n}\n\n/*\n * Find the next illegal byte sequence.\n */\n    void\nutf_find_illegal(void)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*p;\n    int\t\tlen;\n    vimconv_T\tvimconv;\n    char_u\t*tofree = NULL;\n\n    vimconv.vc_type = CONV_NONE;\n    if (enc_utf8 && (enc_canon_props(curbuf->b_p_fenc) & ENC_8BIT))\n    {\n\t// 'encoding' is \"utf-8\" but we are editing a 8-bit encoded file,\n\t// possibly a utf-8 file with illegal bytes.  Setup for conversion\n\t// from utf-8 to 'fileencoding'.\n\tconvert_setup(&vimconv, p_enc, curbuf->b_p_fenc);\n    }\n\n    curwin->w_cursor.coladd = 0;\n    for (;;)\n    {\n\tp = ml_get_cursor();\n\tif (vimconv.vc_type != CONV_NONE)\n\t{\n\t    vim_free(tofree);\n\t    tofree = string_convert(&vimconv, p, NULL);\n\t    if (tofree == NULL)\n\t\tbreak;\n\t    p = tofree;\n\t}\n\n\twhile (*p != NUL)\n\t{\n\t    // Illegal means that there are not enough trail bytes (checked by\n\t    // utf_ptr2len()) or too many of them (overlong sequence).\n\t    len = utf_ptr2len(p);\n\t    if (*p >= 0x80 && (len == 1\n\t\t\t\t     || utf_char2len(utf_ptr2char(p)) != len))\n\t    {\n\t\tif (vimconv.vc_type == CONV_NONE)\n\t\t    curwin->w_cursor.col += (colnr_T)(p - ml_get_cursor());\n\t\telse\n\t\t{\n\t\t    int\t    l;\n\n\t\t    len = (int)(p - tofree);\n\t\t    for (p = ml_get_cursor(); *p != NUL && len-- > 0; p += l)\n\t\t    {\n\t\t\tl = utf_ptr2len(p);\n\t\t\tcurwin->w_cursor.col += l;\n\t\t    }\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    p += len;\n\t}\n\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t    break;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // didn't find it: don't move and beep\n    curwin->w_cursor = pos;\n    beep_flush();\n\ntheend:\n    vim_free(tofree);\n    convert_setup(&vimconv, NULL, NULL);\n}\n\n#if defined(FEAT_GUI_GTK) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return TRUE if string \"s\" is a valid utf-8 string.\n * When \"end\" is NULL stop at the first NUL.  Otherwise stop at \"end\".\n */\n    int\nutf_valid_string(char_u *s, char_u *end)\n{\n    int\t\tl;\n    char_u\t*p = s;\n\n    while (end == NULL ? *p != NUL : p < end)\n    {\n\tl = utf8len_tab_zero[*p];\n\tif (l == 0)\n\t    return FALSE;\t// invalid lead byte\n\tif (end != NULL && p + l > end)\n\t    return FALSE;\t// incomplete byte sequence\n\t++p;\n\twhile (--l > 0)\n\t    if ((*p++ & 0xc0) != 0x80)\n\t\treturn FALSE;\t// invalid trail byte\n    }\n    return TRUE;\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Special version of mb_tail_off() for use in ScreenLines[].\n */\n    int\ndbcs_screen_tail_off(char_u *base, char_u *p)\n{\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    // For euc-jp an 0x8e byte always means we have a lead byte in the current\n    // cell.\n    if (*p == NUL || p[1] == NUL\n\t    || (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\t    || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_screen_head_off(base, p);\n}\n#endif\n\n/*\n * If the cursor moves on an trail byte, set the cursor on the lead byte.\n * Thus it moves left if necessary.\n * Return TRUE when the cursor was adjusted.\n */\n    void\nmb_adjust_cursor(void)\n{\n    mb_adjustpos(curbuf, &curwin->w_cursor);\n}\n\n/*\n * Adjust position \"*lp\" to point to the first byte of a multi-byte character.\n * If it points to a tail byte it's moved backwards to the head byte.\n */\n    void\nmb_adjustpos(buf_T *buf, pos_T *lp)\n{\n    char_u\t*p;\n\n    if (lp->col > 0 || lp->coladd > 1)\n    {\n\tp = ml_get_buf(buf, lp->lnum, FALSE);\n\tif (*p == NUL || (int)STRLEN(p) < lp->col)\n\t    lp->col = 0;\n\telse\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\t// Reset \"coladd\" when the cursor would be on the right half of a\n\t// double-wide character.\n\tif (lp->coladd == 1\n\t\t&& p[lp->col] != TAB\n\t\t&& vim_isprintc((*mb_ptr2char)(p + lp->col))\n\t\t&& ptr2cells(p + lp->col) > 1)\n\t    lp->coladd = 0;\n    }\n}\n\n/*\n * Return a pointer to the character before \"*p\", if there is one.\n */\n    char_u *\nmb_prevptr(\n    char_u *line,\t// start of the string\n    char_u *p)\n{\n    if (p > line)\n\tMB_PTR_BACK(line, p);\n    return p;\n}\n\n/*\n * Return the character length of \"str\".  Each multi-byte character (with\n * following composing characters) counts as one.\n */\n    int\nmb_charlen(char_u *str)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    if (p == NULL)\n\treturn 0;\n\n    for (count = 0; *p != NUL; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Like mb_charlen() but for a string with specified length.\n */\n    int\nmb_charlen_len(char_u *str, int len)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    for (count = 0; *p != NUL && p < str + len; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Try to un-escape a multi-byte character.\n * Used for the \"to\" and \"from\" part of a mapping.\n * Return the un-escaped string if it is a multi-byte character, and advance\n * \"pp\" to just after the bytes that formed it.\n * Return NULL if no multi-byte char was found.\n */\n    char_u *\nmb_unescape(char_u **pp)\n{\n    static char_u\tbuf[6];\n    int\t\t\tn;\n    int\t\t\tm = 0;\n    char_u\t\t*str = *pp;\n\n    // Must translate K_SPECIAL KS_SPECIAL KE_FILLER to K_SPECIAL and CSI\n    // KS_EXTRA KE_CSI to CSI.\n    // Maximum length of a utf-8 character is 4 bytes.\n    for (n = 0; str[n] != NUL && m < 4; ++n)\n    {\n\tif (str[n] == K_SPECIAL\n\t\t&& str[n + 1] == KS_SPECIAL\n\t\t&& str[n + 2] == KE_FILLER)\n\t{\n\t    buf[m++] = K_SPECIAL;\n\t    n += 2;\n\t}\n\telse if ((str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t    || str[n] == CSI\n# endif\n\t\t )\n\t\t&& str[n + 1] == KS_EXTRA\n\t\t&& str[n + 2] == (int)KE_CSI)\n\t{\n\t    buf[m++] = CSI;\n\t    n += 2;\n\t}\n\telse if (str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t|| str[n] == CSI\n# endif\n\t\t)\n\t    break;\t\t// a special key can't be a multibyte char\n\telse\n\t    buf[m++] = str[n];\n\tbuf[m] = NUL;\n\n\t// Return a multi-byte character if it's found.  An illegal sequence\n\t// will result in a 1 here.\n\tif ((*mb_ptr2len)(buf) > 1)\n\t{\n\t    *pp = str + n + 1;\n\t    return buf;\n\t}\n\n\t// Bail out quickly for ASCII.\n\tif (buf[0] < 128)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Return TRUE if the character at \"row\"/\"col\" on the screen is the left side\n * of a double-width character.\n * Caller must make sure \"row\" and \"col\" are not invalid!\n */\n    int\nmb_lefthalve(int row, int col)\n{\n    return (*mb_off2cells)(LineOffset[row] + col,\n\t\t\t\t\tLineOffset[row] + screen_Columns) > 1;\n}\n\n/*\n * Correct a position on the screen, if it's the right half of a double-wide\n * char move it to the left half.  Returns the corrected column.\n */\n    int\nmb_fix_col(int col, int row)\n{\n    int off;\n\n    col = check_col(col);\n    row = check_row(row);\n    off = LineOffset[row] + col;\n    if (has_mbyte && ScreenLines != NULL && col > 0\n\t    && ((enc_dbcs\n\t\t    && ScreenLines[off] != NUL\n\t\t    && dbcs_screen_head_off(ScreenLines + LineOffset[row],\n\t\t\t\t\t ScreenLines + off))\n\t\t|| (enc_utf8 && ScreenLines[off] == 0\n\t\t\t\t\t\t  && ScreenLinesUC[off] == 0)))\n\treturn col - 1;\n    return col;\n}\n\nstatic int enc_alias_search(char_u *name);\n\n/*\n * Skip the Vim specific head of a 'encoding' name.\n */\n    char_u *\nenc_skip(char_u *p)\n{\n    if (STRNCMP(p, \"2byte-\", 6) == 0)\n\treturn p + 6;\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\treturn p + 5;\n    return p;\n}\n\n/*\n * Find the canonical name for encoding \"enc\".\n * When the name isn't recognized, returns \"enc\" itself, but with all lower\n * case characters and '_' replaced with '-'.\n * Returns an allocated string.  NULL for out-of-memory.\n */\n    char_u *\nenc_canonize(char_u *enc)\n{\n    char_u\t*r;\n    char_u\t*p, *s;\n    int\t\ti;\n\n    if (STRCMP(enc, \"default\") == 0)\n    {\n#ifdef MSWIN\n\t// Use the system encoding, the default is always utf-8.\n\tr = enc_locale();\n#else\n\t// Use the default encoding as it's found by set_init_1().\n\tr = get_encoding_default();\n#endif\n\tif (r == NULL)\n\t    r = (char_u *)ENC_DFLT;\n\treturn vim_strsave(r);\n    }\n\n    // copy \"enc\" to allocated memory, with room for two '-'\n    r = alloc(STRLEN(enc) + 3);\n    if (r != NULL)\n    {\n\t// Make it all lower case and replace '_' with '-'.\n\tp = r;\n\tfor (s = enc; *s != NUL; ++s)\n\t{\n\t    if (*s == '_')\n\t\t*p++ = '-';\n\t    else\n\t\t*p++ = TOLOWER_ASC(*s);\n\t}\n\t*p = NUL;\n\n\t// Skip \"2byte-\" and \"8bit-\".\n\tp = enc_skip(r);\n\n\t// Change \"microsoft-cp\" to \"cp\".  Used in some spell files.\n\tif (STRNCMP(p, \"microsoft-cp\", 12) == 0)\n\t    STRMOVE(p, p + 10);\n\n\t// \"iso8859\" -> \"iso-8859\"\n\tif (STRNCMP(p, \"iso8859\", 7) == 0)\n\t{\n\t    STRMOVE(p + 4, p + 3);\n\t    p[3] = '-';\n\t}\n\n\t// \"iso-8859n\" -> \"iso-8859-n\"\n\tif (STRNCMP(p, \"iso-8859\", 8) == 0 && isdigit(p[8]))\n\t{\n\t    STRMOVE(p + 9, p + 8);\n\t    p[8] = '-';\n\t}\n\n\t// \"latin-N\" -> \"latinN\"\n\tif (STRNCMP(p, \"latin-\", 6) == 0)\n\t    STRMOVE(p + 5, p + 6);\n\n\tif (enc_canon_search(p) >= 0)\n\t{\n\t    // canonical name can be used unmodified\n\t    if (p != r)\n\t\tSTRMOVE(r, p);\n\t}\n\telse if ((i = enc_alias_search(p)) >= 0)\n\t{\n\t    // alias recognized, get canonical name\n\t    vim_free(r);\n\t    r = vim_strsave((char_u *)enc_canon_table[i].name);\n\t}\n    }\n    return r;\n}\n\n/*\n * Search for an encoding alias of \"name\".\n * Returns -1 when not found.\n */\n    static int\nenc_alias_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; enc_alias_table[i].name != NULL; ++i)\n\tif (STRCMP(name, enc_alias_table[i].name) == 0)\n\t    return enc_alias_table[i].canon;\n    return -1;\n}\n\n\n#ifdef HAVE_LANGINFO_H\n# include <langinfo.h>\n#endif\n\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n/*\n * Get the canonicalized encoding from the specified locale string \"locale\"\n * or from the environment variables LC_ALL, LC_CTYPE and LANG.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale_env(char *locale)\n{\n    char\t*s = locale;\n    char\t*p;\n    int\t\ti;\n    char\tbuf[50];\n\n    if (s == NULL || *s == NUL)\n\tif ((s = getenv(\"LC_ALL\")) == NULL || *s == NUL)\n\t    if ((s = getenv(\"LC_CTYPE\")) == NULL || *s == NUL)\n\t\ts = getenv(\"LANG\");\n\n    if (s == NULL || *s == NUL)\n\treturn NULL;\n\n    // The most generic locale format is:\n    // language[_territory][.codeset][@modifier][+special][,[sponsor][_revision]]\n    // If there is a '.' remove the part before it.\n    // if there is something after the codeset, remove it.\n    // Make the name lowercase and replace '_' with '-'.\n    // Exception: \"ja_JP.EUC\" == \"euc-jp\", \"zh_CN.EUC\" = \"euc-cn\",\n    // \"ko_KR.EUC\" == \"euc-kr\"\n    if ((p = (char *)vim_strchr((char_u *)s, '.')) != NULL)\n    {\n\tif (p > s + 2 && STRNICMP(p + 1, \"EUC\", 3) == 0\n\t\t\t&& !isalnum((int)p[4]) && p[4] != '-' && p[-3] == '_')\n\t{\n\t    // copy \"XY.EUC\" to \"euc-XY\" to buf[10]\n\t    STRCPY(buf + 10, \"euc-\");\n\t    buf[14] = p[-2];\n\t    buf[15] = p[-1];\n\t    buf[16] = 0;\n\t    s = buf + 10;\n\t}\n\telse\n\t    s = p + 1;\n    }\n    for (i = 0; i < (int)sizeof(buf) - 1 && s[i] != NUL; ++i)\n    {\n\tif (s[i] == '_' || s[i] == '-')\n\t    buf[i] = '-';\n\telse if (isalnum((int)s[i]))\n\t    buf[i] = TOLOWER_ASC(s[i]);\n\telse\n\t    break;\n    }\n    buf[i] = NUL;\n\n    return enc_canonize((char_u *)buf);\n}\n#endif\n\n/*\n * Get the canonicalized encoding of the current locale.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale(void)\n{\n#ifdef MSWIN\n    char\tbuf[50];\n    long\tacp = GetACP();\n\n    if (acp == 1200)\n\tSTRCPY(buf, \"ucs-2le\");\n    else if (acp == 1252)\t    // cp1252 is used as latin1\n\tSTRCPY(buf, \"latin1\");\n    else if (acp == 65001)\n\tSTRCPY(buf, \"utf-8\");\n    else\n\tsprintf(buf, \"cp%ld\", acp);\n\n    return enc_canonize((char_u *)buf);\n#else\n    char\t*s;\n\n# ifdef HAVE_NL_LANGINFO_CODESET\n    if ((s = nl_langinfo(CODESET)) == NULL || *s == NUL)\n# endif\n# if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n\tif ((s = setlocale(LC_CTYPE, NULL)) == NULL || *s == NUL)\n# endif\n\t    s = NULL;\n\n    return enc_locale_env(s);\n#endif\n}\n\n# if defined(MSWIN) || defined(PROTO) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n/*\n * Convert an encoding name to an MS-Windows codepage.\n * Returns zero if no codepage can be figured out.\n */\n    int\nencname2codepage(char_u *name)\n{\n    int\t\tcp;\n    char_u\t*p = name;\n    int\t\tidx;\n\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\tp += 5;\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n\tp += 6;\n\n    if (p[0] == 'c' && p[1] == 'p')\n\tcp = atoi((char *)p + 2);\n    else if ((idx = enc_canon_search(p)) >= 0)\n\tcp = enc_canon_table[idx].codepage;\n    else\n\treturn 0;\n    if (IsValidCodePage(cp))\n\treturn cp;\n    return 0;\n}\n# endif\n\n# if defined(USE_ICONV) || defined(PROTO)\n\n/*\n * Call iconv_open() with a check if iconv() works properly (there are broken\n * versions).\n * Returns (void *)-1 if failed.\n * (should return iconv_t, but that causes problems with prototypes).\n */\n    void *\nmy_iconv_open(char_u *to, char_u *from)\n{\n    iconv_t\tfd;\n#define ICONV_TESTLEN 400\n    char_u\ttobuf[ICONV_TESTLEN];\n    char\t*p;\n    size_t\ttolen;\n    static int\ticonv_ok = -1;\n\n    if (iconv_ok == FALSE)\n\treturn (void *)-1;\t// detected a broken iconv() previously\n\n#ifdef DYNAMIC_ICONV\n    // Check if the iconv.dll can be found.\n    if (!iconv_enabled(TRUE))\n\treturn (void *)-1;\n#endif\n\n    fd = iconv_open((char *)enc_skip(to), (char *)enc_skip(from));\n\n    if (fd != (iconv_t)-1 && iconv_ok == -1)\n    {\n\t/*\n\t * Do a dummy iconv() call to check if it actually works.  There is a\n\t * version of iconv() on Linux that is broken.  We can't ignore it,\n\t * because it's wide-spread.  The symptoms are that after outputting\n\t * the initial shift state the \"to\" pointer is NULL and conversion\n\t * stops for no apparent reason after about 8160 characters.\n\t */\n\tp = (char *)tobuf;\n\ttolen = ICONV_TESTLEN;\n\t(void)iconv(fd, NULL, NULL, &p, &tolen);\n\tif (p == NULL)\n\t{\n\t    iconv_ok = FALSE;\n\t    iconv_close(fd);\n\t    fd = (iconv_t)-1;\n\t}\n\telse\n\t    iconv_ok = TRUE;\n    }\n\n    return (void *)fd;\n}\n\n/*\n * Convert the string \"str[slen]\" with iconv().\n * If \"unconvlenp\" is not NULL handle the string ending in an incomplete\n * sequence and set \"*unconvlenp\" to the length of it.\n * Returns the converted string in allocated memory.  NULL for an error.\n * If resultlenp is not NULL, sets it to the result length in bytes.\n */\n    static char_u *\niconv_string(\n    vimconv_T\t*vcp,\n    char_u\t*str,\n    int\t\tslen,\n    int\t\t*unconvlenp,\n    int\t\t*resultlenp)\n{\n    const char\t*from;\n    size_t\tfromlen;\n    char\t*to;\n    size_t\ttolen;\n    size_t\tlen = 0;\n    size_t\tdone = 0;\n    char_u\t*result = NULL;\n    char_u\t*p;\n    int\t\tl;\n\n    from = (char *)str;\n    fromlen = slen;\n    for (;;)\n    {\n\tif (len == 0 || ICONV_ERRNO == ICONV_E2BIG)\n\t{\n\t    // Allocate enough room for most conversions.  When re-allocating\n\t    // increase the buffer size.\n\t    len = len + fromlen * 2 + 40;\n\t    p = alloc(len);\n\t    if (p != NULL && done > 0)\n\t\tmch_memmove(p, result, done);\n\t    vim_free(result);\n\t    result = p;\n\t    if (result == NULL)\t// out of memory\n\t\tbreak;\n\t}\n\n\tto = (char *)result + done;\n\ttolen = len - done - 2;\n\t// Avoid a warning for systems with a wrong iconv() prototype by\n\t// casting the second argument to void *.\n\tif (iconv(vcp->vc_fd, (void *)&from, &fromlen, &to, &tolen)\n\t\t\t\t\t\t\t\t!= (size_t)-1)\n\t{\n\t    // Finished, append a NUL.\n\t    *to = NUL;\n\t    break;\n\t}\n\n\t// Check both ICONV_EINVAL and EINVAL, because the dynamically loaded\n\t// iconv library may use one of them.\n\tif (!vcp->vc_fail && unconvlenp != NULL\n\t\t&& (ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Handle an incomplete sequence at the end.\n\t    *to = NUL;\n\t    *unconvlenp = (int)fromlen;\n\t    break;\n\t}\n\n\t// Check both ICONV_EILSEQ and EILSEQ, because the dynamically loaded\n\t// iconv library may use one of them.\n\telse if (!vcp->vc_fail\n\t\t&& (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ\n\t\t    || ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Can't convert: insert a '?' and skip a character.  This assumes\n\t    // conversion from 'encoding' to something else.  In other\n\t    // situations we don't know what to skip anyway.\n\t    *to++ = '?';\n\t    if ((*mb_ptr2cells)((char_u *)from) > 1)\n\t\t*to++ = '?';\n\t    if (enc_utf8)\n\t\tl = utfc_ptr2len_len((char_u *)from, (int)fromlen);\n\t    else\n\t    {\n\t\tl = (*mb_ptr2len)((char_u *)from);\n\t\tif (l > (int)fromlen)\n\t\t    l = (int)fromlen;\n\t    }\n\t    from += l;\n\t    fromlen -= l;\n\t}\n\telse if (ICONV_ERRNO != ICONV_E2BIG)\n\t{\n\t    // conversion failed\n\t    VIM_CLEAR(result);\n\t    break;\n\t}\n\t// Not enough room or skipping illegal sequence.\n\tdone = to - (char *)result;\n    }\n\n    if (resultlenp != NULL && result != NULL)\n\t*resultlenp = (int)(to - (char *)result);\n    return result;\n}\n\n#  if defined(DYNAMIC_ICONV) || defined(PROTO)\n/*\n * Dynamically load the \"iconv.dll\" on Win32.\n */\n\n#   ifndef DYNAMIC_ICONV\t    // must be generating prototypes\n#    define HINSTANCE int\n#   endif\nstatic HINSTANCE hIconvDLL = 0;\nstatic HINSTANCE hMsvcrtDLL = 0;\n\n#   ifndef DYNAMIC_ICONV_DLL\n#    define DYNAMIC_ICONV_DLL \"iconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT1 \"libiconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT2 \"libiconv2.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT3 \"libiconv-2.dll\"\n#   endif\n#   ifndef DYNAMIC_MSVCRT_DLL\n#    define DYNAMIC_MSVCRT_DLL \"msvcrt.dll\"\n#   endif\n\n/*\n * Try opening the iconv.dll and return TRUE if iconv() can be used.\n */\n    int\niconv_enabled(int verbose)\n{\n    if (hIconvDLL != 0 && hMsvcrtDLL != 0)\n\treturn TRUE;\n\n    // The iconv DLL file goes under different names, try them all.\n    // Do the \"2\" version first, it's newer.\n#ifdef DYNAMIC_ICONV_DLL_ALT2\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT2);\n#endif\n#ifdef DYNAMIC_ICONV_DLL_ALT3\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT3);\n#endif\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL);\n#ifdef DYNAMIC_ICONV_DLL_ALT1\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT1);\n#endif\n\n    if (hIconvDLL != 0)\n\thMsvcrtDLL = vimLoadLib(DYNAMIC_MSVCRT_DLL);\n    if (hIconvDLL == 0 || hMsvcrtDLL == 0)\n    {\n\t// Only give the message when 'verbose' is set, otherwise it might be\n\t// done whenever a conversion is attempted.\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_str_str),\n\t\t    hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL,\n\t\t    GetWin32Error());\n\t    verbose_leave();\n\t}\n\ticonv_end();\n\treturn FALSE;\n    }\n\n    iconv\t= (size_t (*)(iconv_t, const char **,\n\t\t\tsize_t *, char **, size_t *))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconv\");\n    iconv_open\t= (iconv_t (*)(const char *, const char *))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconv_open\");\n    iconv_close\t= (int (*)(iconv_t))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconv_close\");\n    iconvctl\t= (int (*)(iconv_t, int, void *))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconvctl\");\n    iconv_errno\t= (int *(*)(void))get_dll_import_func(hIconvDLL, \"_errno\");\n    if (iconv_errno == NULL)\n\ticonv_errno = (int *(*)(void))GetProcAddress(hMsvcrtDLL, \"_errno\");\n    if (iconv == NULL || iconv_open == NULL || iconv_close == NULL\n\t    || iconvctl == NULL || iconv_errno == NULL)\n    {\n\ticonv_end();\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_function_str), \"for libiconv\");\n\t    verbose_leave();\n\t}\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n    void\niconv_end(void)\n{\n    // Don't use iconv() when inputting or outputting characters.\n    if (input_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&input_conv, NULL, NULL);\n    if (output_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&output_conv, NULL, NULL);\n\n    if (hIconvDLL != 0)\n\tFreeLibrary(hIconvDLL);\n    if (hMsvcrtDLL != 0)\n\tFreeLibrary(hMsvcrtDLL);\n    hIconvDLL = 0;\n    hMsvcrtDLL = 0;\n}\n#  endif // DYNAMIC_ICONV\n# endif // USE_ICONV\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getimstatus()\" function\n */\n    void\nf_getimstatus(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# if defined(HAVE_INPUT_METHOD)\n    rettv->vval.v_number = im_get_status();\n# endif\n}\n\n/*\n * iconv() function\n */\n    void\nf_iconv(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*from, *to, *str;\n    vimconv_T\tvimconv;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    str = tv_get_string(&argvars[0]);\n    from = enc_canonize(enc_skip(tv_get_string_buf(&argvars[1], buf1)));\n    to = enc_canonize(enc_skip(tv_get_string_buf(&argvars[2], buf2)));\n    vimconv.vc_type = CONV_NONE;\n    convert_setup(&vimconv, from, to);\n\n    // If the encodings are equal, no conversion needed.\n    if (vimconv.vc_type == CONV_NONE)\n\trettv->vval.v_string = vim_strsave(str);\n    else\n\trettv->vval.v_string = string_convert(&vimconv, str, NULL);\n\n    convert_setup(&vimconv, NULL, NULL);\n    vim_free(from);\n    vim_free(to);\n}\n#endif\n\n/*\n * Setup \"vcp\" for conversion from \"from\" to \"to\".\n * The names must have been made canonical with enc_canonize().\n * vcp->vc_type must have been initialized to CONV_NONE.\n * Note: cannot be used for conversion from/to ucs-2 and ucs-4 (will use utf-8\n * instead).\n * Afterwards invoke with \"from\" and \"to\" equal to NULL to cleanup.\n * Return FAIL when conversion is not supported, OK otherwise.\n */\n    int\nconvert_setup(vimconv_T *vcp, char_u *from, char_u *to)\n{\n    return convert_setup_ext(vcp, from, TRUE, to, TRUE);\n}\n\n/*\n * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all\n * \"from\" unicode charsets be considered utf-8.  Same for \"to\".\n */\n    int\nconvert_setup_ext(\n    vimconv_T\t*vcp,\n    char_u\t*from,\n    int\t\tfrom_unicode_is_utf8,\n    char_u\t*to,\n    int\t\tto_unicode_is_utf8)\n{\n    int\t\tfrom_prop;\n    int\t\tto_prop;\n    int\t\tfrom_is_utf8;\n    int\t\tto_is_utf8;\n\n    // Reset to no conversion.\n#ifdef USE_ICONV\n    if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)\n\ticonv_close(vcp->vc_fd);\n#endif\n    vcp->vc_type = CONV_NONE;\n    vcp->vc_factor = 1;\n    vcp->vc_fail = FALSE;\n\n    // No conversion when one of the names is empty or they are equal.\n    if (from == NULL || *from == NUL || to == NULL || *to == NUL\n\t\t\t\t\t\t     || STRCMP(from, to) == 0)\n\treturn OK;\n\n    from_prop = enc_canon_props(from);\n    to_prop = enc_canon_props(to);\n    if (from_unicode_is_utf8)\n\tfrom_is_utf8 = from_prop & ENC_UNICODE;\n    else\n\tfrom_is_utf8 = from_prop == ENC_UNICODE;\n    if (to_unicode_is_utf8)\n\tto_is_utf8 = to_prop & ENC_UNICODE;\n    else\n\tto_is_utf8 = to_prop == ENC_UNICODE;\n\n    if ((from_prop & ENC_LATIN1) && to_is_utf8)\n    {\n\t// Internal latin1 -> utf-8 conversion.\n\tvcp->vc_type = CONV_TO_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN9) && to_is_utf8)\n    {\n\t// Internal latin9 -> utf-8 conversion.\n\tvcp->vc_type = CONV_9_TO_UTF8;\n\tvcp->vc_factor = 3;\t// up to three as long (euro sign)\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN1))\n    {\n\t// Internal utf-8 -> latin1 conversion.\n\tvcp->vc_type = CONV_TO_LATIN1;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN9))\n    {\n\t// Internal utf-8 -> latin9 conversion.\n\tvcp->vc_type = CONV_TO_LATIN9;\n    }\n#ifdef MSWIN\n    // Win32-specific codepage <-> codepage conversion without iconv.\n    else if ((from_is_utf8 || encname2codepage(from) > 0)\n\t    && (to_is_utf8 || encname2codepage(to) > 0))\n    {\n\tvcp->vc_type = CONV_CODEPAGE;\n\tvcp->vc_factor = 2;\t// up to twice as long\n\tvcp->vc_cpfrom = from_is_utf8 ? 0 : encname2codepage(from);\n\tvcp->vc_cpto = to_is_utf8 ? 0 : encname2codepage(to);\n    }\n#endif\n#ifdef MACOS_CONVERT\n    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_LATIN1))\n    {\n\tvcp->vc_type = CONV_MAC_LATIN1;\n    }\n    else if ((from_prop & ENC_MACROMAN) && to_is_utf8)\n    {\n\tvcp->vc_type = CONV_MAC_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN1) && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_LATIN1_MAC;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_UTF8_MAC;\n    }\n#endif\n#ifdef USE_ICONV\n    else\n    {\n\t// Use iconv() for conversion.\n\tvcp->vc_fd = (iconv_t)my_iconv_open(\n\t\tto_is_utf8 ? (char_u *)\"utf-8\" : to,\n\t\tfrom_is_utf8 ? (char_u *)\"utf-8\" : from);\n\tif (vcp->vc_fd != (iconv_t)-1)\n\t{\n\t    vcp->vc_type = CONV_ICONV;\n\t    vcp->vc_factor = 4;\t// could be longer too...\n\t}\n    }\n#endif\n    if (vcp->vc_type == CONV_NONE)\n\treturn FAIL;\n\n    return OK;\n}\n\n#if defined(FEAT_GUI) || defined(AMIGA) || defined(MSWIN) \\\n\t|| defined(PROTO)\n/*\n * Do conversion on typed input characters in-place.\n * The input and output are not NUL terminated!\n * Returns the length after conversion.\n */\n    int\nconvert_input(char_u *ptr, int len, int maxlen)\n{\n    return convert_input_safe(ptr, len, maxlen, NULL, NULL);\n}\n#endif\n\n/*\n * Like convert_input(), but when there is an incomplete byte sequence at the\n * end return that as an allocated string in \"restp\" and set \"*restlenp\" to\n * the length.  If \"restp\" is NULL it is not used.\n */\n    int\nconvert_input_safe(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tmaxlen,\n    char_u\t**restp,\n    int\t\t*restlenp)\n{\n    char_u\t*d;\n    int\t\tdlen = len;\n    int\t\tunconvertlen = 0;\n\n    d = string_convert_ext(&input_conv, ptr, &dlen,\n\t\t\t\t\trestp == NULL ? NULL : &unconvertlen);\n    if (d != NULL)\n    {\n\tif (dlen <= maxlen)\n\t{\n\t    if (unconvertlen > 0)\n\t    {\n\t\t// Move the unconverted characters to allocated memory.\n\t\t*restp = alloc(unconvertlen);\n\t\tif (*restp != NULL)\n\t\t    mch_memmove(*restp, ptr + len - unconvertlen, unconvertlen);\n\t\t*restlenp = unconvertlen;\n\t    }\n\t    mch_memmove(ptr, d, dlen);\n\t}\n\telse\n\t    // result is too long, keep the unconverted text (the caller must\n\t    // have done something wrong!)\n\t    dlen = len;\n\tvim_free(d);\n    }\n    return dlen;\n}\n\n/*\n * Convert text \"ptr[*lenp]\" according to \"vcp\".\n * Returns the result in allocated memory and sets \"*lenp\".\n * When \"lenp\" is NULL, use NUL terminated strings.\n * Illegal chars are often changed to \"?\", unless vcp->vc_fail is set.\n * When something goes wrong, NULL is returned and \"*lenp\" is unchanged.\n */\n    char_u *\nstring_convert(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp)\n{\n    return string_convert_ext(vcp, ptr, lenp, NULL);\n}\n\n/*\n * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is\n * an incomplete sequence at the end it is not converted and \"*unconvlenp\" is\n * set to the number of remaining bytes.\n */\n    char_u *\nstring_convert_ext(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp,\n    int\t\t*unconvlenp)\n{\n    char_u\t*retval = NULL;\n    char_u\t*d;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tl;\n    int\t\tc;\n\n    if (lenp == NULL)\n\tlen = (int)STRLEN(ptr);\n    else\n\tlen = *lenp;\n    if (len == 0)\n\treturn vim_strsave((char_u *)\"\");\n\n    switch (vcp->vc_type)\n    {\n\tcase CONV_TO_UTF8:\t// latin1 to utf-8 conversion\n\t    retval = alloc(len * 2 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tif (c < 0x80)\n\t\t    *d++ = c;\n\t\telse\n\t\t{\n\t\t    *d++ = 0xc0 + ((unsigned)c >> 6);\n\t\t    *d++ = 0x80 + (c & 0x3f);\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_9_TO_UTF8:\t// latin9 to utf-8 conversion\n\t    retval = alloc(len * 3 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tswitch (c)\n\t\t{\n\t\t    case 0xa4: c = 0x20ac; break;   // euro\n\t\t    case 0xa6: c = 0x0160; break;   // S hat\n\t\t    case 0xa8: c = 0x0161; break;   // S -hat\n\t\t    case 0xb4: c = 0x017d; break;   // Z hat\n\t\t    case 0xb8: c = 0x017e; break;   // Z -hat\n\t\t    case 0xbc: c = 0x0152; break;   // OE\n\t\t    case 0xbd: c = 0x0153; break;   // oe\n\t\t    case 0xbe: c = 0x0178; break;   // Y\n\t\t}\n\t\td += utf_char2bytes(c, d);\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_TO_LATIN1:\t// utf-8 to latin1 conversion\n\tcase CONV_TO_LATIN9:\t// utf-8 to latin9 conversion\n\t    retval = alloc(len + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tl = utf_ptr2len_len(ptr + i, len - i);\n\t\tif (l == 0)\n\t\t    *d++ = NUL;\n\t\telse if (l == 1)\n\t\t{\n\t\t    int l_w = utf8len_tab_zero[ptr[i]];\n\n\t\t    if (l_w == 0)\n\t\t    {\n\t\t\t// Illegal utf-8 byte cannot be converted\n\t\t\tvim_free(retval);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (unconvlenp != NULL && l_w > len - i)\n\t\t    {\n\t\t\t// Incomplete sequence at the end.\n\t\t\t*unconvlenp = len - i;\n\t\t\tbreak;\n\t\t    }\n\t\t    *d++ = ptr[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = utf_ptr2char(ptr + i);\n\t\t    if (vcp->vc_type == CONV_TO_LATIN9)\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\t    case 0x20ac: c = 0xa4; break;   // euro\n\t\t\t    case 0x0160: c = 0xa6; break;   // S hat\n\t\t\t    case 0x0161: c = 0xa8; break;   // S -hat\n\t\t\t    case 0x017d: c = 0xb4; break;   // Z hat\n\t\t\t    case 0x017e: c = 0xb8; break;   // Z -hat\n\t\t\t    case 0x0152: c = 0xbc; break;   // OE\n\t\t\t    case 0x0153: c = 0xbd; break;   // oe\n\t\t\t    case 0x0178: c = 0xbe; break;   // Y\n\t\t\t    case 0xa4:\n\t\t\t    case 0xa6:\n\t\t\t    case 0xa8:\n\t\t\t    case 0xb4:\n\t\t\t    case 0xb8:\n\t\t\t    case 0xbc:\n\t\t\t    case 0xbd:\n\t\t\t    case 0xbe: c = 0x100; break; // not in latin9\n\t\t\t}\n\t\t    if (!utf_iscomposing(c))\t// skip composing chars\n\t\t    {\n\t\t\tif (c < 0x100)\n\t\t\t    *d++ = c;\n\t\t\telse if (vcp->vc_fail)\n\t\t\t{\n\t\t\t    vim_free(retval);\n\t\t\t    return NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    *d++ = 0xbf;\n\t\t\t    if (utf_char2cells(c) > 1)\n\t\t\t\t*d++ = '?';\n\t\t\t}\n\t\t    }\n\t\t    i += l - 1;\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n# ifdef MACOS_CONVERT\n\tcase CONV_MAC_LATIN1:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'l', unconvlenp);\n\t    break;\n\n\tcase CONV_LATIN1_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'l', 'm', unconvlenp);\n\t    break;\n\n\tcase CONV_MAC_UTF8:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'u', unconvlenp);\n\t    break;\n\n\tcase CONV_UTF8_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'u', 'm', unconvlenp);\n\t    break;\n# endif\n\n# ifdef USE_ICONV\n\tcase CONV_ICONV:\t// conversion with output_conv.vc_fd\n\t    retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);\n\t    break;\n# endif\n# ifdef MSWIN\n\tcase CONV_CODEPAGE:\t\t// codepage -> codepage\n\t{\n\t    int\t\tretlen;\n\t    int\t\ttmp_len;\n\t    short_u\t*tmp;\n\n\t    // 1. codepage/UTF-8  ->  ucs-2.\n\t    if (vcp->vc_cpfrom == 0)\n\t\ttmp_len = utf8_to_utf16(ptr, len, NULL, NULL);\n\t    else\n\t    {\n\t\ttmp_len = MultiByteToWideChar(vcp->vc_cpfrom,\n\t\t\t\t\tunconvlenp ? MB_ERR_INVALID_CHARS : 0,\n\t\t\t\t\t(char *)ptr, len, 0, 0);\n\t\tif (tmp_len == 0\n\t\t\t&& GetLastError() == ERROR_NO_UNICODE_TRANSLATION)\n\t\t{\n\t\t    if (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\t    if (unconvlenp != NULL)\n\t\t\t*unconvlenp = len;\n\t\t    retval = alloc(1);\n\t\t    if (retval)\n\t\t\tretval[0] = NUL;\n\t\t    return retval;\n\t\t}\n\t    }\n\t    tmp = ALLOC_MULT(short_u, tmp_len);\n\t    if (tmp == NULL)\n\t\tbreak;\n\t    if (vcp->vc_cpfrom == 0)\n\t\tutf8_to_utf16(ptr, len, tmp, unconvlenp);\n\t    else\n\t\tMultiByteToWideChar(vcp->vc_cpfrom, 0,\n\t\t\t(char *)ptr, len, tmp, tmp_len);\n\n\t    // 2. ucs-2  ->  codepage/UTF-8.\n\t    if (vcp->vc_cpto == 0)\n\t\tretlen = utf16_to_utf8(tmp, tmp_len, NULL);\n\t    else\n\t\tretlen = WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t\t    tmp, tmp_len, 0, 0, 0, 0);\n\t    retval = alloc(retlen + 1);\n\t    if (retval != NULL)\n\t    {\n\t\tif (vcp->vc_cpto == 0)\n\t\t    utf16_to_utf8(tmp, tmp_len, retval);\n\t\telse\n\t\t    WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t  tmp, tmp_len,\n\t\t\t\t\t  (char *)retval, retlen, 0, 0);\n\t\tretval[retlen] = NUL;\n\t\tif (lenp != NULL)\n\t\t    *lenp = retlen;\n\t    }\n\t    vim_free(tmp);\n\t    break;\n\t}\n# endif\n    }\n\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Table set by setcellwidths().\n */\ntypedef struct\n{\n    long    first;\n    long    last;\n    char    width;\n} cw_interval_T;\n\nstatic cw_interval_T\t*cw_table = NULL;\nstatic size_t\t\tcw_table_size = 0;\n\n/*\n * Return 1 or 2 when \"c\" is in the cellwidth table.\n * Return 0 if not.\n */\n    static int\ncw_value(int c)\n{\n    int mid, bot, top;\n\n    if (cw_table == NULL)\n\treturn 0;\n\n    // first quick check for Latin1 etc. characters\n    if (c < cw_table[0].first)\n\treturn 0;\n\n    // binary search in table\n    bot = 0;\n    top = (int)cw_table_size - 1;\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (cw_table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (cw_table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return cw_table[mid].width;\n    }\n    return 0;\n}\n\n    static int\ntv_nr_compare(const void *a1, const void *a2)\n{\n    listitem_T *li1 = *(listitem_T **)a1;\n    listitem_T *li2 = *(listitem_T **)a2;\n\n    return li1->li_tv.vval.v_number - li2->li_tv.vval.v_number;\n}\n\n    void\nf_setcellwidths(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    list_T\t    *l;\n    listitem_T\t    *li;\n    int\t\t    item;\n    int\t\t    i;\n    listitem_T\t    **ptrs;\n    cw_interval_T   *table;\n    cw_interval_T   *cw_table_save;\n    size_t\t    cw_table_size_save;\n    char\t    *error = NULL;\n\n    if (in_vim9script() && check_for_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\temsg(_(e_list_required));\n\treturn;\n    }\n    l = argvars[0].vval.v_list;\n    if (l->lv_len == 0)\n    {\n\t// Clearing the table.\n\tvim_free(cw_table);\n\tcw_table = NULL;\n\tcw_table_size = 0;\n\treturn;\n    }\n\n    ptrs = ALLOC_MULT(listitem_T *, l->lv_len);\n    if (ptrs == NULL)\n\treturn;\n\n    // Check that all entries are a list with three numbers, the range is\n    // valid and the cell width is valid.\n    item = 0;\n    for (li = l->lv_first; li != NULL; li = li->li_next)\n    {\n\tlistitem_T *lili;\n\tvarnumber_T n1;\n\n\tif (li->li_tv.v_type != VAR_LIST || li->li_tv.vval.v_list == NULL)\n\t{\n\t    semsg(_(e_list_item_nr_is_not_list), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\n\tlili = li->li_tv.vval.v_list->lv_first;\n\tptrs[item] = lili;\n\tfor (i = 0; lili != NULL; lili = lili->li_next, ++i)\n\t{\n\t    if (lili->li_tv.v_type != VAR_NUMBER)\n\t\tbreak;\n\t    if (i == 0)\n\t    {\n\t\tn1 = lili->li_tv.vval.v_number;\n\t\tif (n1 < 0x100)\n\t\t{\n\t\t    emsg(_(e_only_values_of_0x100_and_higher_supported));\n\t\t    vim_free(ptrs);\n\t\t    return;\n\t\t}\n\t    }\n\t    else if (i == 1 && lili->li_tv.vval.v_number < n1)\n\t    {\n\t\tsemsg(_(e_list_item_nr_range_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t    else if (i == 2 && (lili->li_tv.vval.v_number < 1\n\t\t\t\t\t     || lili->li_tv.vval.v_number > 2))\n\t    {\n\t\tsemsg(_(e_list_item_nr_cell_width_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t}\n\tif (i != 3)\n\t{\n\t    semsg(_(e_list_item_nr_does_not_contain_3_numbers), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\t++item;\n    }\n\n    // Sort the list on the first number.\n    qsort((void *)ptrs, (size_t)l->lv_len, sizeof(listitem_T *), tv_nr_compare);\n\n    table = ALLOC_MULT(cw_interval_T, l->lv_len);\n    if (table == NULL)\n    {\n\tvim_free(ptrs);\n\treturn;\n    }\n\n    // Store the items in the new table.\n    item = 0;\n    for (item = 0; item < l->lv_len; ++item)\n    {\n\tlistitem_T\t*lili = ptrs[item];\n\tvarnumber_T\tn1;\n\n\tn1 = lili->li_tv.vval.v_number;\n\tif (item > 0 && n1 <= table[item - 1].last)\n\t{\n\t    semsg(_(e_overlapping_ranges_for_nr), (long)n1);\n\t    vim_free(ptrs);\n\t    vim_free(table);\n\t    return;\n\t}\n\ttable[item].first = n1;\n\tlili = lili->li_next;\n\ttable[item].last = lili->li_tv.vval.v_number;\n\tlili = lili->li_next;\n\ttable[item].width = lili->li_tv.vval.v_number;\n    }\n\n    vim_free(ptrs);\n\n    cw_table_save = cw_table;\n    cw_table_size_save = cw_table_size;\n    cw_table = table;\n    cw_table_size = l->lv_len;\n\n    // Check that the new value does not conflict with 'listchars' or\n    // 'fillchars'.\n    error = check_chars_options();\n    if (error != NULL)\n    {\n\temsg(_(error));\n\tcw_table = cw_table_save;\n\tcw_table_size = cw_table_size_save;\n\tvim_free(table);\n\treturn;\n    }\n\n    vim_free(cw_table_save);\n}\n\n    void\nf_charclass(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || argvars[0].vval.v_string == NULL)\n\treturn;\n    rettv->vval.v_number = mb_get_class(argvars[0].vval.v_string);\n}\n#endif\n", "\" Tests for various eval things.\n\nsource view_util.vim\n\nfunction s:foo() abort\n  try\n    return [] == 0\n  catch\n    return 1\n  endtry\nendfunction\n\nfunc Test_catch_return_with_error()\n  call assert_equal(1, s:foo())\nendfunc\n\nfunc Test_nocatch_restore_silent_emsg()\n  silent! try\n    throw 1\n  catch\n  endtry\n  echoerr 'wrong again'\n  call assert_equal('wrong again', ScreenLine(&lines))\nendfunc\n\nfunc Test_mkdir_p()\n  call mkdir('Xmkdir/nested', 'p')\n  call assert_true(isdirectory('Xmkdir/nested'))\n  try\n    \" Trying to make existing directories doesn't error\n    call mkdir('Xmkdir', 'p')\n    call mkdir('Xmkdir/nested', 'p')\n  catch /E739:/\n    call assert_report('mkdir(..., \"p\") failed for an existing directory')\n  endtry\n  \" 'p' doesn't suppress real errors\n  call writefile([], 'Xfile')\n  call assert_fails('call mkdir(\"Xfile\", \"p\")', 'E739:')\n  call delete('Xfile')\n  call delete('Xmkdir', 'rf')\n  call assert_equal(0, mkdir(test_null_string()))\n  call assert_fails('call mkdir([])', 'E730:')\n  call assert_fails('call mkdir(\"abc\", [], [])', 'E745:')\nendfunc\n\nfunc Test_line_continuation()\n  let array = [5,\n\t\"\\ ignore this\n\t\\ 6,\n\t\"\\ more to ignore\n\t\"\\ more moreto ignore\n\t\\ ]\n\t\"\\ and some more\n  call assert_equal([5, 6], array)\nendfunc\n\nfunc Test_E963()\n  \" These commands used to cause an internal error prior to vim 8.1.0563\n  let v_e = v:errors\n  let v_o = v:oldfiles\n  call assert_fails(\"let v:errors=''\", 'E963:')\n  call assert_equal(v_e, v:errors)\n  call assert_fails(\"let v:oldfiles=''\", 'E963:')\n  call assert_equal(v_o, v:oldfiles)\nendfunc\n\nfunc Test_for_invalid()\n  call assert_fails(\"for x in 99\", 'E1098:')\n  call assert_fails(\"for x in function('winnr')\", 'E1098:')\n  call assert_fails(\"for x in {'a': 9}\", 'E1098:')\n\n  if 0\n    /1/5/2/s/\\n\n  endif\n  redraw\nendfunc\n\nfunc Test_readfile_binary()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  setlocal ff=dos\n  silent write XReadfile_bin\n  let lines = 'XReadfile_bin'->readfile()\n  call assert_equal(['one', 'two', 'three'], lines)\n  let lines = readfile('XReadfile_bin', '', 2)\n  call assert_equal(['one', 'two'], lines)\n  let lines = readfile('XReadfile_bin', 'b')\n  call assert_equal([\"one\\r\", \"two\\r\", \"three\\r\", \"\"], lines)\n  let lines = readfile('XReadfile_bin', 'b', 2)\n  call assert_equal([\"one\\r\", \"two\\r\"], lines)\n\n  bwipe!\n  call delete('XReadfile_bin')\nendfunc\n\nfunc Test_readfile_binary_empty()\n  call writefile([], 'Xempty-file')\n  \" This used to compare uninitialized memory in Vim <= 8.2.4065\n  call assert_equal([''], readfile('Xempty-file', 'b'))\n  call delete('Xempty-file')\nendfunc\n\nfunc Test_readfile_bom()\n  call writefile([\"\\ufeffFOO\", \"FOO\\ufeffBAR\"], 'XReadfile_bom')\n  call assert_equal(['FOO', 'FOOBAR'], readfile('XReadfile_bom'))\n  call delete('XReadfile_bom')\nendfunc\n\nfunc Test_readfile_max()\n  call writefile(range(1, 4), 'XReadfile_max')\n  call assert_equal(['1', '2'], readfile('XReadfile_max', '', 2))\n  call assert_equal(['3', '4'], readfile('XReadfile_max', '', -2))\n  call delete('XReadfile_max')\nendfunc\n\nfunc Test_let_errmsg()\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\nendfunc\n\nfunc Test_string_concatenation()\n  call assert_equal('ab', 'a'.'b')\n  call assert_equal('ab', 'a' .'b')\n  call assert_equal('ab', 'a'. 'b')\n  call assert_equal('ab', 'a' . 'b')\n\n  call assert_equal('ab', 'a'..'b')\n  call assert_equal('ab', 'a' ..'b')\n  call assert_equal('ab', 'a'.. 'b')\n  call assert_equal('ab', 'a' .. 'b')\n\n  let a = 'a'\n  let b = 'b'\n  let a .= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a.=b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a ..= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a..=b\n  call assert_equal('ab', a)\n\n  if has('float')\n    let a = 'A'\n    let b = 1.234\n    call assert_equal('A1.234', a .. b)\n  endif\nendfunc\n\n\" Test fix for issue #4507\nfunc Test_skip_after_throw()\n  try\n    throw 'something'\n    let x = wincol() || &ts\n  catch /something/\n  endtry\nendfunc\n\nscriptversion 2\nfunc Test_string_concat_scriptversion2()\n  call assert_true(has('vimscript-2'))\n  let a = 'a'\n  let b = 'b'\n\n  call assert_fails('echo a . b', 'E15:')\n  call assert_fails('let a .= b', 'E985:')\n  call assert_fails('let vers = 1.2.3', 'E488:')\n\n  if has('float')\n    let f = .5\n    call assert_equal(0.5, f)\n  endif\nendfunc\n\nscriptversion 1\nfunc Test_string_concat_scriptversion1()\n  call assert_true(has('vimscript-1'))\n  let a = 'a'\n  let b = 'b'\n\n  echo a . b\n  let a .= b\n  let vers = 1.2.3\n  call assert_equal('123', vers)\n\n  if has('float')\n    call assert_fails('let f = .5', 'E15:')\n  endif\nendfunc\n\nscriptversion 3\nfunc Test_vvar_scriptversion3()\n  call assert_true(has('vimscript-3'))\n  call assert_fails('echo version', 'E121:')\n  call assert_false(exists('version'))\n  let version = 1\n  call assert_equal(1, version)\nendfunc\n\nscriptversion 2\nfunc Test_vvar_scriptversion2()\n  call assert_true(exists('version'))\n  echo version\n  call assert_fails('let version = 1', 'E46:')\n  call assert_equal(v:version, version)\n\n  call assert_equal(v:version, v:versionlong / 10000)\n  call assert_true(v:versionlong > 8011525)\nendfunc\n\nfunc Test_dict_access_scriptversion2()\n  let l:x = {'foo': 1}\n\n  call assert_false(0 && l:x.foo)\n  call assert_true(1 && l:x.foo)\nendfunc\n\nscriptversion 4\nfunc Test_vvar_scriptversion4()\n  call assert_true(has('vimscript-4'))\n  call assert_equal(17, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\n  call assert_equal(64, 0b1'00'00'00)\n  call assert_equal(1048576, 0x10'00'00)\n  call assert_equal(32768, 0o10'00'00)\n  call assert_equal(1000000, 1'000'000)\n  call assert_equal(\"1234\", execute(\"echo 1'234\")->trim())\n  call assert_equal('1  234', execute(\"echo 1''234\")->trim())\n  call assert_fails(\"echo 1'''234\", 'E115:')\nendfunc\n\nscriptversion 1\nfunc Test_vvar_scriptversion1()\n  call assert_equal(15, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\nendfunc\n\nfunc Test_scriptversion_fail()\n  call writefile(['scriptversion 9'], 'Xversionscript')\n  call assert_fails('source Xversionscript', 'E999:')\n  call delete('Xversionscript')\nendfunc\n\nfunc Test_execute_cmd_with_null()\n  call assert_fails('execute test_null_list()', 'E730:')\n  call assert_fails('execute test_null_dict()', 'E731:')\n  call assert_fails('execute test_null_blob()', 'E976:')\n  execute test_null_string()\n  call assert_fails('execute test_null_partial()', 'E729:')\n  call assert_fails('execute test_unknown()', 'E908:')\n  if has('job')\n    call assert_fails('execute test_null_job()', 'E908:')\n    call assert_fails('execute test_null_channel()', 'E908:')\n  endif\nendfunc\n\nfunc Test_number_max_min_size()\n  \" This will fail on systems without 64 bit number support or when not\n  \" configured correctly.\n  call assert_equal(64, v:numbersize)\n\n  call assert_true(v:numbermin < -9999999)\n  call assert_true(v:numbermax > 9999999)\nendfunc\n\nfunc Assert_reg(name, type, value, valuestr, expr, exprstr)\n  call assert_equal(a:type, getregtype(a:name))\n  call assert_equal(a:value, getreg(a:name))\n  call assert_equal(a:valuestr, string(getreg(a:name, 0, 1)))\n  call assert_equal(a:expr, getreg(a:name, 1))\n  call assert_equal(a:exprstr, string(getreg(a:name, 1, 1)))\nendfunc\n\nfunc Test_let_register()\n  let @\" = 'abc'\n  call Assert_reg('\"', 'v', \"abc\", \"['abc']\", \"abc\", \"['abc']\")\n  let @\" = \"abc\\n\"\n  call Assert_reg('\"', 'V', \"abc\\n\", \"['abc']\", \"abc\\n\", \"['abc']\")\n  let @\" = \"abc\\<C-m>\"\n  call Assert_reg('\"', 'V', \"abc\\r\\n\", \"['abc\\r']\", \"abc\\r\\n\", \"['abc\\r']\")\n  let @= = '\"abc\"'\n  call Assert_reg('=', 'v', \"abc\", \"['abc']\", '\"abc\"', \"['\\\"abc\\\"']\")\nendfunc\n\nfunc Assert_regput(name, result)\n  new\n  execute \"silent normal! o==\\n==\\e\\\"\" . a:name . \"P\"\n  call assert_equal(a:result, getline(2, line('$')))\n  bwipe!\nendfunc\n\nfunc Test_setreg_basic()\n  call setreg('a', 'abcA', 'c')\n  call Assert_reg('a', 'v', \"abcA\", \"['abcA']\", \"abcA\", \"['abcA']\")\n  call Assert_regput('a', ['==', '=abcA='])\n\n  call setreg('A', 'abcAc', 'c')\n  call Assert_reg('A', 'v', \"abcAabcAc\", \"['abcAabcAc']\", \"abcAabcAc\", \"['abcAabcAc']\")\n  call Assert_regput('a', ['==', '=abcAabcAc='])\n\n  call setreg('A', 'abcAl', 'l')\n  call Assert_reg('A', 'V', \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\", \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\")\n  call Assert_regput('a', ['==', 'abcAabcAcabcAl', '=='])\n\n  call setreg('A', 'abcAc2','c')\n  call Assert_reg('A', 'v', \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\", \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\")\n  call Assert_regput('a', ['==', '=abcAabcAcabcAl', 'abcAc2='])\n\n  call setreg('b', 'abcB', 'v')\n  call Assert_reg('b', 'v', \"abcB\", \"['abcB']\", \"abcB\", \"['abcB']\")\n  call Assert_regput('b', ['==', '=abcB='])\n\n  call setreg('b', 'abcBc', 'ca')\n  call Assert_reg('b', 'v', \"abcBabcBc\", \"['abcBabcBc']\", \"abcBabcBc\", \"['abcBabcBc']\")\n  call Assert_regput('b', ['==', '=abcBabcBc='])\n\n  call setreg('b', 'abcBb', 'ba')\n  call Assert_reg('b', \"\\<C-V>5\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb='])\n\n  call setreg('b', 'abcBc2','ca')\n  call Assert_reg('b', \"v\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb', 'abcBc2='])\n\n  call setreg('b', 'abcBb2','b50a')\n  call Assert_reg('b', \"\\<C-V>50\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb                                    =', ' abcBc2abcBb2'])\n\n  call setreg('c', 'abcC', 'l')\n  call Assert_reg('c', 'V', \"abcC\\n\", \"['abcC']\", \"abcC\\n\", \"['abcC']\")\n  call Assert_regput('c', ['==', 'abcC', '=='])\n\n  call setreg('C', 'abcCl', 'l')\n  call Assert_reg('C', 'V', \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\", \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\")\n  call Assert_regput('c', ['==', 'abcC', 'abcCl', '=='])\n\n  call setreg('C', 'abcCc', 'c')\n  call Assert_reg('C', 'v', \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\", \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\")\n  call Assert_regput('c', ['==', '=abcC', 'abcCl', 'abcCc='])\n\n  call setreg('d', 'abcD', 'V')\n  call Assert_reg('d', 'V', \"abcD\\n\", \"['abcD']\", \"abcD\\n\", \"['abcD']\")\n  call Assert_regput('d', ['==', 'abcD', '=='])\n\n  call setreg('D', 'abcDb', 'b')\n  call Assert_reg('d', \"\\<C-V>5\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\")\n  call Assert_regput('d', ['==', '=abcD =', ' abcDb'])\n\n  call setreg('e', 'abcE', 'b')\n  call Assert_reg('e', \"\\<C-V>4\", \"abcE\", \"['abcE']\", \"abcE\", \"['abcE']\")\n  call Assert_regput('e', ['==', '=abcE='])\n\n  call setreg('E', 'abcEb', 'b')\n  call Assert_reg('E', \"\\<C-V>5\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\")\n  call Assert_regput('e', ['==', '=abcE =', ' abcEb'])\n\n  call setreg('E', 'abcEl', 'l')\n  call Assert_reg('E', \"V\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\")\n  call Assert_regput('e', ['==', 'abcE', 'abcEb', 'abcEl', '=='])\n\n  call setreg('f', 'abcF', \"\\<C-v>\")\n  call Assert_reg('f', \"\\<C-V>4\", \"abcF\", \"['abcF']\", \"abcF\", \"['abcF']\")\n  call Assert_regput('f', ['==', '=abcF='])\n\n  call setreg('F', 'abcFc', 'c')\n  call Assert_reg('F', \"v\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\")\n  call Assert_regput('f', ['==', '=abcF', 'abcFc='])\n\n  call setreg('g', 'abcG', 'b10')\n  call Assert_reg('g', \"\\<C-V>10\", \"abcG\", \"['abcG']\", \"abcG\", \"['abcG']\")\n  call Assert_regput('g', ['==', '=abcG      ='])\n\n  call setreg('h', 'abcH', \"\\<C-v>10\")\n  call Assert_reg('h', \"\\<C-V>10\", \"abcH\", \"['abcH']\", \"abcH\", \"['abcH']\")\n  call Assert_regput('h', ['==', '=abcH      ='])\n\n  call setreg('I', 'abcI')\n  call Assert_reg('I', \"v\", \"abcI\", \"['abcI']\", \"abcI\", \"['abcI']\")\n  call Assert_regput('I', ['==', '=abcI='])\n\n  \" Appending NL with setreg()\n  call setreg('a', 'abcA2', 'c')\n  call setreg('b', 'abcB2', 'v')\n  call setreg('c', 'abcC2', 'l')\n  call setreg('d', 'abcD2', 'V')\n  call setreg('e', 'abcE2', 'b')\n  call setreg('f', 'abcF2', \"\\<C-v>\")\n  call setreg('g', 'abcG2', 'b10')\n  call setreg('h', 'abcH2', \"\\<C-v>10\")\n  call setreg('I', 'abcI2')\n\n  call setreg('A', \"\\n\")\n  call Assert_reg('A', 'V', \"abcA2\\n\", \"['abcA2']\", \"abcA2\\n\", \"['abcA2']\")\n  call Assert_regput('A', ['==', 'abcA2', '=='])\n\n  call setreg('B', \"\\n\", 'c')\n  call Assert_reg('B', 'v', \"abcB2\\n\", \"['abcB2', '']\", \"abcB2\\n\", \"['abcB2', '']\")\n  call Assert_regput('B', ['==', '=abcB2', '='])\n\n  call setreg('C', \"\\n\")\n  call Assert_reg('C', 'V', \"abcC2\\n\\n\", \"['abcC2', '']\", \"abcC2\\n\\n\", \"['abcC2', '']\")\n  call Assert_regput('C', ['==', 'abcC2', '', '=='])\n\n  call setreg('D', \"\\n\", 'l')\n  call Assert_reg('D', 'V', \"abcD2\\n\\n\", \"['abcD2', '']\", \"abcD2\\n\\n\", \"['abcD2', '']\")\n  call Assert_regput('D', ['==', 'abcD2', '', '=='])\n\n  call setreg('E', \"\\n\")\n  call Assert_reg('E', 'V', \"abcE2\\n\\n\", \"['abcE2', '']\", \"abcE2\\n\\n\", \"['abcE2', '']\")\n  call Assert_regput('E', ['==', 'abcE2', '', '=='])\n\n  call setreg('F', \"\\n\", 'b')\n  call Assert_reg('F', \"\\<C-V>0\", \"abcF2\\n\", \"['abcF2', '']\", \"abcF2\\n\", \"['abcF2', '']\")\n  call Assert_regput('F', ['==', '=abcF2=', ' '])\n\n  \" Setting lists with setreg()\n  call setreg('a', ['abcA3'], 'c')\n  call Assert_reg('a', 'v', \"abcA3\", \"['abcA3']\", \"abcA3\", \"['abcA3']\")\n  call Assert_regput('a', ['==', '=abcA3='])\n\n  call setreg('b', ['abcB3'], 'l')\n  call Assert_reg('b', 'V', \"abcB3\\n\", \"['abcB3']\", \"abcB3\\n\", \"['abcB3']\")\n  call Assert_regput('b', ['==', 'abcB3', '=='])\n\n  call setreg('c', ['abcC3'], 'b')\n  call Assert_reg('c', \"\\<C-V>5\", \"abcC3\", \"['abcC3']\", \"abcC3\", \"['abcC3']\")\n  call Assert_regput('c', ['==', '=abcC3='])\n\n  call setreg('d', ['abcD3'])\n  call Assert_reg('d', 'V', \"abcD3\\n\", \"['abcD3']\", \"abcD3\\n\", \"['abcD3']\")\n  call Assert_regput('d', ['==', 'abcD3', '=='])\n\n  call setreg('e', [1, 2, 'abc', 3])\n  call Assert_reg('e', 'V', \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\", \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\")\n  call Assert_regput('e', ['==', '1', '2', 'abc', '3', '=='])\n\n  call setreg('f', [1, 2, 3])\n  call Assert_reg('f', 'V', \"1\\n2\\n3\\n\", \"['1', '2', '3']\", \"1\\n2\\n3\\n\", \"['1', '2', '3']\")\n  call Assert_regput('f', ['==', '1', '2', '3', '=='])\n\n  \" Appending lists with setreg()\n  call setreg('A', ['abcA3c'], 'c')\n  call Assert_reg('A', 'v', \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\", \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\")\n  call Assert_regput('A', ['==', '=abcA3', 'abcA3c='])\n\n  call setreg('b', ['abcB3l'], 'la')\n  call Assert_reg('b', 'V', \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\", \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\")\n  call Assert_regput('b', ['==', 'abcB3', 'abcB3l', '=='])\n\n  call setreg('C', ['abcC3b'], 'lb')\n  call Assert_reg('C', \"\\<C-V>6\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\")\n  call Assert_regput('C', ['==', '=abcC3 =', ' abcC3b'])\n\n  call setreg('D', ['abcD32'])\n  call Assert_reg('D', 'V', \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\", \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\")\n  call Assert_regput('D', ['==', 'abcD3', 'abcD32', '=='])\n\n  call setreg('A', ['abcA32'])\n  call Assert_reg('A', 'V', \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\", \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', '=='])\n\n  call setreg('B', ['abcB3c'], 'c')\n  call Assert_reg('B', 'v', \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\", \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c='])\n\n  call setreg('C', ['abcC3l'], 'l')\n  call Assert_reg('C', 'V', \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\", \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\")\n  call Assert_regput('C', ['==', 'abcC3', 'abcC3b', 'abcC3l', '=='])\n\n  call setreg('D', ['abcD3b'], 'b')\n  call Assert_reg('D', \"\\<C-V>6\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\")\n  call Assert_regput('D', ['==', '=abcD3 =', ' abcD32', ' abcD3b'])\n\n  \" Appending lists with NL with setreg()\n  call setreg('A', [\"\\n\", 'abcA3l2'], 'l')\n  call Assert_reg('A', \"V\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', \"\\n\", 'abcA3l2', '=='])\n\n  call setreg('B', [\"\\n\", 'abcB3c2'], 'c')\n  call Assert_reg('B', \"v\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c', \"\\n\", 'abcB3c2='])\n\n  call setreg('C', [\"\\n\", 'abcC3b2'], 'b')\n  call Assert_reg('C', \"\u00167\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\")\n  call Assert_regput('C', ['==', '=abcC3  =', ' abcC3b', ' abcC3l', \" \\n\", ' abcC3b2'])\n\n  call setreg('D', [\"\\n\", 'abcD3b50'],'b50')\n  call Assert_reg('D', \"\u001650\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\")\n  call Assert_regput('D', ['==', '=abcD3                                             =', ' abcD32', ' abcD3b', \" \\n\", ' abcD3b50'])\n\n  \" Setting lists with NLs with setreg()\n  call setreg('a', ['abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\"])\n  call Assert_reg('a', \"V\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\")\n  call Assert_regput('a', ['==', 'abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\", '=='])\n\n  call setreg('b', ['abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2\"], 'c')\n  call Assert_reg('b', \"v\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\")\n  call Assert_regput('b', ['==', '=abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2=\"])\n\n  call setreg('c', ['abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\"], 'l')\n  call Assert_reg('c', \"V\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\")\n  call Assert_regput('c', ['==', 'abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\", '=='])\n\n  call setreg('d', ['abcD4b-0', \"\\n\", \"abcD4b-2\\n\", \"\\nabcD4b-3\", \"abcD4b-4\\nabcD4b-4-2\"], 'b')\n  call Assert_reg('d', \"\u001619\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\")\n  call Assert_regput('d', ['==', '=abcD4b-0           =', \" \\n\", \" abcD4b-2\\n\", \" \\nabcD4b-3\", \" abcD4b-4\\nabcD4b-4-2\"])\n\n  call setreg('e', ['abcE4b10-0', \"\\n\", \"abcE4b10-2\\n\", \"\\nabcE4b10-3\", \"abcE4b10-4\\nabcE4b10-4-2\"], 'b10')\n  call Assert_reg('e', \"\u001610\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\")\n  call Assert_regput('e', ['==', '=abcE4b10-0=', \" \\n\", \" abcE4b10-2\\n\", \" \\nabcE4b10-3\", \" abcE4b10-4\\nabcE4b10-4-2\"])\n\n  \" Search and expressions\n  call setreg('/', ['abc/'])\n  call Assert_reg('/', 'v', \"abc/\", \"['abc/']\", \"abc/\", \"['abc/']\")\n  call Assert_regput('/', ['==', '=abc/='])\n\n  call setreg('/', [\"abc/\\n\"])\n  call Assert_reg('/', 'v', \"abc/\\n\", \"['abc/\\n']\", \"abc/\\n\", \"['abc/\\n']\")\n  call Assert_regput('/', ['==', \"=abc/\\n=\"])\n\n  call setreg('=', ['\"abc/\"'])\n  call Assert_reg('=', 'v', \"abc/\", \"['abc/']\", '\"abc/\"', \"['\\\"abc/\\\"']\")\n\n  call setreg('=', [\"\\\"abc/\\n\\\"\"])\n  call Assert_reg('=', 'v', \"abc/\\n\", \"['abc/\\n']\", \"\\\"abc/\\n\\\"\", \"['\\\"abc/\\n\\\"']\")\n\n  \" System clipboard\n  if has('clipboard')\n    new | only!\n    call setline(1, ['clipboard contents', 'something else'])\n    \" Save and restore system clipboard.\n    \" If no connection to X-Server is possible, test should succeed.\n    let _clipreg = ['*', getreg('*'), getregtype('*')]\n    let _clipopt = &cb\n    let &cb='unnamed'\n    1y\n    call Assert_reg('*', 'V', \"clipboard contents\\n\", \"['clipboard contents']\", \"clipboard contents\\n\", \"['clipboard contents']\")\n    tabdo :windo :echo \"hi\"\n    2y\n    call Assert_reg('*', 'V', \"something else\\n\", \"['something else']\", \"something else\\n\", \"['something else']\")\n    let &cb=_clipopt\n    call call('setreg', _clipreg)\n    enew!\n  endif\n\n  \" Error cases\n  call assert_fails('call setreg()', 'E119:')\n  call assert_fails('call setreg(1)', 'E119:')\n  call assert_fails('call setreg(1, 2, 3, 4)', 'E118:')\n  call assert_fails('call setreg([], 2)', 'E730:')\n  call assert_fails('call setreg(1, 2, [])', 'E730:')\n  call assert_fails('call setreg(\"/\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(\"=\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(1, [\"\", \"\", [], \"\"])', 'E730:')\nendfunc\n\nfunc Test_curly_assignment()\n  let s:svar = 'svar'\n  let g:gvar = 'gvar'\n  let lname = 'gvar'\n  let gname = 'gvar'\n  let {'s:'.lname} = {'g:'.gname}\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:'.lname } = { 'g:'.gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' . lname } = { 'g:' . gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' .. lname } = { 'g:' .. gname }\n  call assert_equal('gvar', s:gvar)\n\n  unlet s:svar\n  unlet s:gvar\n  unlet g:gvar\nendfunc\n\nfunc Test_deep_recursion()\n  \" this was running out of stack\n  call assert_fails(\"exe 'if ' .. repeat('(', 1002)\", 'E1169: Expression too recursive: ((')\nendfunc\n\n\" K_SPECIAL in the modified character used be escaped, which causes\n\" double-escaping with feedkeys() or as the return value of an <expr> mapping,\n\" and doesn't match what getchar() returns,\nfunc Test_modified_char_no_escape_special()\n  nnoremap <M-\u2026> <Cmd>let g:got_m_ellipsis += 1<CR>\n  call feedkeys(\"\\<M-\u2026>\", 't')\n  call assert_equal(\"\\<M-\u2026>\", getchar())\n  let g:got_m_ellipsis = 0\n  call feedkeys(\"\\<M-\u2026>\", 'xt')\n  call assert_equal(1, g:got_m_ellipsis)\n  func Func()\n    return \"\\<M-\u2026>\"\n  endfunc\n  nmap <expr> <F2> Func()\n  call feedkeys(\"\\<F2>\", 'xt')\n  call assert_equal(2, g:got_m_ellipsis)\n  delfunc Func\n  nunmap <F2>\n  unlet g:got_m_ellipsis\n  nunmap <M-\u2026>\nendfunc\n\nfunc Test_eval_string_in_special_key()\n  \" this was using the '{' inside <> as the start of an interpolated string\n  silent! echo 0{1-$\"\\<S--{>\u0017n|n\u00f6%\u0000\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n */\n\n/*\n * definition of global variables\n */\n\n/*\n * Number of Rows and Columns in the screen.\n * Must be long to be able to use them as options in option.c.\n * Note: Use screen_Rows and screen_Columns to access items in ScreenLines[].\n * They may have different values when the screen wasn't (re)allocated yet\n * after setting Rows or Columns (e.g., when starting up).\n */\nEXTERN long\tRows\t\t\t// nr of rows in the screen\n#ifdef DO_INIT\n# if defined(MSWIN)\n\t\t\t    = 25L\n# else\n\t\t\t    = 24L\n# endif\n#endif\n\t\t\t    ;\nEXTERN long\tColumns INIT(= 80);\t// nr of columns in the screen\n\n/*\n * The characters that are currently on the screen are kept in ScreenLines[].\n * It is a single block of characters, the size of the screen plus one line.\n * The attributes for those characters are kept in ScreenAttrs[].\n * The byte offset in the line is kept in ScreenCols[].\n *\n * \"LineOffset[n]\" is the offset from ScreenLines[] for the start of line 'n'.\n * The same value is used for ScreenLinesUC[], ScreenAttrs[] and ScreenCols[].\n *\n * Note: before the screen is initialized and when out of memory these can be\n * NULL.\n */\nEXTERN schar_T\t*ScreenLines INIT(= NULL);\nEXTERN sattr_T\t*ScreenAttrs INIT(= NULL);\nEXTERN colnr_T  *ScreenCols INIT(= NULL);\nEXTERN unsigned\t*LineOffset INIT(= NULL);\nEXTERN char_u\t*LineWraps INIT(= NULL);\t// line wraps to next line\n\n/*\n * When using Unicode characters (in UTF-8 encoding) the character in\n * ScreenLinesUC[] contains the Unicode for the character at this position, or\n * NUL when the character in ScreenLines[] is to be used (ASCII char).\n * The composing characters are to be drawn on top of the original character.\n * ScreenLinesC[0][off] is only to be used when ScreenLinesUC[off] != 0.\n * Note: These three are only allocated when enc_utf8 is set!\n */\nEXTERN u8char_T\t*ScreenLinesUC INIT(= NULL);\t// decoded UTF-8 characters\nEXTERN u8char_T\t*ScreenLinesC[MAX_MCO];\t\t// composing characters\nEXTERN int\tScreen_mco INIT(= 0);\t\t// value of p_mco used when\n\t\t\t\t\t\t// allocating ScreenLinesC[]\n\n// Only used for euc-jp: Second byte of a character that starts with 0x8e.\n// These are single-width.\nEXTERN schar_T\t*ScreenLines2 INIT(= NULL);\n\n/*\n * One screen line to be displayed.  Points into ScreenLines.\n */\nEXTERN schar_T\t*current_ScreenLine INIT(= NULL);\n\n/*\n * Last known cursor position.\n * Positioning the cursor is reduced by remembering the last position.\n * Mostly used by windgoto() and screen_char().\n */\nEXTERN int\tscreen_cur_row INIT(= 0);\nEXTERN int\tscreen_cur_col INIT(= 0);\n\n#ifdef FEAT_SEARCH_EXTRA\n// used for 'hlsearch' highlight matching\nEXTERN match_T\tscreen_search_hl;\n\n// last lnum where CurSearch was displayed\nEXTERN linenr_T search_hl_has_cursor_lnum INIT(= 0);\n\n// don't use 'hlsearch' temporarily\nEXTERN int\tno_hlsearch INIT(= FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\nEXTERN foldinfo_T win_foldinfo;\t// info for 'foldcolumn'\n#endif\n\n// Flag that is set when drawing for a callback, not from the main command\n// loop.\nEXTERN int redrawing_for_callback INIT(= 0);\n\n/*\n * Indexes for tab page line:\n *\tN > 0 for label of tab page N\n *\tN == 0 for no label\n *\tN < 0 for closing tab page -N\n *\tN == -999 for closing current tab page\n */\nEXTERN short\t*TabPageIdxs INIT(= NULL);\n\n#ifdef FEAT_PROP_POPUP\n// Array with size Rows x Columns containing zindex of popups.\nEXTERN short\t*popup_mask INIT(= NULL);\nEXTERN short\t*popup_mask_next INIT(= NULL);\n// Array with flags for transparent cells of current popup.\nEXTERN char\t*popup_transparent INIT(= NULL);\n\n// Flag set to TRUE when popup_mask needs to be updated.\nEXTERN int\tpopup_mask_refresh INIT(= TRUE);\n\n// Tab that was used to fill popup_mask.\nEXTERN tabpage_T *popup_mask_tab INIT(= NULL);\n\n// Zindex in for screen_char(): if lower than the value in \"popup_mask\"\n// drawing the character is skipped.\nEXTERN int\tscreen_zindex INIT(= 0);\n#endif\n\nEXTERN int\tscreen_Rows INIT(= 0);\t    // actual size of ScreenLines[]\nEXTERN int\tscreen_Columns INIT(= 0);   // actual size of ScreenLines[]\n\n/*\n * When vgetc() is called, it sets mod_mask to the set of modifiers that are\n * held down based on the MOD_MASK_* symbols that are read first.\n */\nEXTERN int\tmod_mask INIT(= 0);\t\t// current key modifiers\n\n// The value of \"mod_mask\" and the unomdified character before calling\n// merge_modifyOtherKeys().\nEXTERN int\tvgetc_mod_mask INIT(= 0);\nEXTERN int\tvgetc_char INIT(= 0);\n\n/*\n * Cmdline_row is the row where the command line starts, just below the\n * last window.\n * When the cmdline gets longer than the available space the screen gets\n * scrolled up. After a CTRL-D (show matches), after hitting ':' after\n * \"hit return\", and for the :global command, the command line is\n * temporarily moved.  The old position is restored with the next call to\n * update_screen().\n */\nEXTERN int\tcmdline_row;\n\nEXTERN int\tredraw_cmdline INIT(= FALSE);\t// cmdline must be redrawn\nEXTERN int\tredraw_mode INIT(= FALSE);\t// mode must be redrawn\nEXTERN int\tclear_cmdline INIT(= FALSE);\t// cmdline must be cleared\nEXTERN int\tmode_displayed INIT(= FALSE);\t// mode is being displayed\nEXTERN int\tno_win_do_lines_ins INIT(= FALSE); // don't insert lines\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\nEXTERN int\tcmdline_star INIT(= FALSE);\t// cmdline is crypted\n#endif\n\nEXTERN int\texec_from_reg INIT(= FALSE);\t// executing register\n\nEXTERN int\tscreen_cleared INIT(= FALSE);\t// screen has been cleared\n\n/*\n * When '$' is included in 'cpoptions' option set:\n * When a change command is given that deletes only part of a line, a dollar\n * is put at the end of the changed text. dollar_vcol is set to the virtual\n * column of this '$'.  -1 is used to indicate no $ is being displayed.\n */\nEXTERN colnr_T\tdollar_vcol INIT(= -1);\n\n/*\n * Variables for Insert mode completion.\n */\n\nEXTERN char_u\t*edit_submode INIT(= NULL); // msg for CTRL-X submode\nEXTERN char_u\t*edit_submode_pre INIT(= NULL); // prepended to edit_submode\nEXTERN char_u\t*edit_submode_extra INIT(= NULL);// appended to edit_submode\nEXTERN hlf_T\tedit_submode_highl;\t// highl. method for extra info\n\n/*\n * Functions for putting characters in the command line,\n * while keeping ScreenLines[] updated.\n */\n#ifdef FEAT_RIGHTLEFT\nEXTERN int\tcmdmsg_rl INIT(= FALSE);    // cmdline is drawn right to left\n#endif\nEXTERN int\tmsg_col;\nEXTERN int\tmsg_row;\nEXTERN int\tmsg_scrolled;\t// Number of screen lines that windows have\n\t\t\t\t// scrolled because of printing messages.\nEXTERN int\tmsg_scrolled_ign INIT(= FALSE);\n\t\t\t\t// when TRUE don't set need_wait_return in\n\t\t\t\t// msg_puts_attr() when msg_scrolled is\n\t\t\t\t// non-zero\n\nEXTERN char_u\t*keep_msg INIT(= NULL);\t    // msg to be shown after redraw\nEXTERN int\tkeep_msg_attr INIT(= 0);    // highlight attr for keep_msg\nEXTERN int\tkeep_msg_more INIT(= FALSE); // keep_msg was set by msgmore()\nEXTERN int\tneed_fileinfo INIT(= FALSE);// do fileinfo() after redraw\nEXTERN int\tmsg_scroll INIT(= FALSE);   // msg_start() will scroll\nEXTERN int\tmsg_didout INIT(= FALSE);   // msg_outstr() was used in line\nEXTERN int\tmsg_didany INIT(= FALSE);   // msg_outstr() was used at all\nEXTERN int\tmsg_nowait INIT(= FALSE);   // don't wait for this msg\nEXTERN int\temsg_off INIT(= 0);\t    // don't display errors for now,\n\t\t\t\t\t    // unless 'debug' is set.\nEXTERN int\tinfo_message INIT(= FALSE); // printing informative message\nEXTERN int      msg_hist_off INIT(= FALSE); // don't add messages to history\n#ifdef FEAT_EVAL\nEXTERN int\tneed_clr_eos INIT(= FALSE); // need to clear text before\n\t\t\t\t\t    // displaying a message.\nEXTERN int\temsg_skip INIT(= 0);\t    // don't display errors for\n\t\t\t\t\t    // expression that is skipped\nEXTERN int\temsg_severe INIT(= FALSE);  // use message of next of several\n\t\t\t\t\t    // emsg() calls for throw\n// used by assert_fails()\nEXTERN char_u\t*emsg_assert_fails_msg INIT(= NULL);\nEXTERN long\temsg_assert_fails_lnum INIT(= 0);\nEXTERN char_u\t*emsg_assert_fails_context INIT(= NULL);\n\nEXTERN int\tdid_endif INIT(= FALSE);    // just had \":endif\"\n#endif\nEXTERN int\tdid_emsg;\t\t    // set by emsg() when the message\n\t\t\t\t\t    // is displayed or thrown\n#ifdef FEAT_EVAL\nEXTERN int\tdid_emsg_silent INIT(= 0);  // incremented by emsg() when\n\t\t\t\t\t    // emsg_silent was set and did_emsg\n\t\t\t\t\t    // is not incremented\nEXTERN int\tdid_emsg_def;\t\t    // set by emsg() when emsg_silent\n\t\t\t\t\t    // is set before calling a function\nEXTERN int\tdid_emsg_cumul;\t\t    // cumulative did_emsg, increased\n\t\t\t\t\t    // when did_emsg is reset.\nEXTERN int\tcalled_vim_beep;\t    // set if vim_beep() is called\nEXTERN int\tuncaught_emsg;\t\t    // number of times emsg() was\n\t\t\t\t\t    // called and did show a message\n#endif\nEXTERN int\tdid_emsg_syntax;\t    // did_emsg set because of a\n\t\t\t\t\t    // syntax error\nEXTERN int\tcalled_emsg;\t\t    // always incremented by emsg()\nEXTERN int\tex_exitval INIT(= 0);\t    // exit value for ex mode\nEXTERN int\temsg_on_display INIT(= FALSE);\t// there is an error message\nEXTERN int\trc_did_emsg INIT(= FALSE);  // vim_regcomp() called emsg()\n\nEXTERN int\tno_wait_return INIT(= 0);   // don't wait for return for now\nEXTERN int\tneed_wait_return INIT(= 0); // need to wait for return later\nEXTERN int\tdid_wait_return INIT(= FALSE);\t// wait_return() was used and\n\t\t\t\t\t\t// nothing written since then\nEXTERN int\tneed_maketitle INIT(= TRUE); // call maketitle() soon\n\nEXTERN int\tquit_more INIT(= FALSE);    // 'q' hit at \"--more--\" msg\n#if defined(UNIX) || defined(VMS) || defined(MACOS_X)\nEXTERN int\tnewline_on_exit INIT(= FALSE);\t// did msg in altern. screen\nEXTERN int\tintr_char INIT(= 0);\t    // extra interrupt character\n#endif\n#if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)\nEXTERN int\tx_no_connect INIT(= FALSE); // don't connect to X server\n# if defined(FEAT_CLIENTSERVER)\nEXTERN int\tx_force_connect INIT(= FALSE);\t// Do connect to X server.\n\t\t\t\t\t\t// Overrules x_no_connect and\n\t\t\t\t\t\t// \"exclude\" in 'clipboard'.\n# endif\n#endif\nEXTERN int\tex_keep_indent INIT(= FALSE); // getexmodeline(): keep indent\nEXTERN int\tvgetc_busy INIT(= 0);\t      // when inside vgetc() then > 0\n\nEXTERN int\tdidset_vim INIT(= FALSE);\t    // did set $VIM ourselves\nEXTERN int\tdidset_vimruntime INIT(= FALSE);    // idem for $VIMRUNTIME\n\n/*\n * Lines left before a \"more\" message.\tEx mode needs to be able to reset this\n * after you type something.\n */\nEXTERN int\tlines_left INIT(= -1);\t    // lines left for listing\nEXTERN int\tmsg_no_more INIT(= FALSE);  // don't use more prompt, truncate\n\t\t\t\t\t    // messages\n\n/*\n * Stack of execution contexts.  Each entry is an estack_T.\n * Current context is at ga_len - 1.\n */\nEXTERN garray_T\texestack INIT5(0, 0, sizeof(estack_T), 50, NULL);\n#define HAVE_SOURCING_INFO  (exestack.ga_data != NULL && exestack.ga_len > 0)\n// name of error message source\n#define SOURCING_NAME (((estack_T *)exestack.ga_data)[exestack.ga_len - 1].es_name)\n// line number in the message source or zero\n#define SOURCING_LNUM (((estack_T *)exestack.ga_data)[exestack.ga_len - 1].es_lnum)\n\n// Script CTX being sourced or was sourced to define the current function.\nEXTERN sctx_T\tcurrent_sctx\n#ifdef FEAT_EVAL\n    INIT4(0, 0, 0, 0);\n#else\n    INIT(= {0});\n#endif\n\n#ifdef FEAT_EVAL\n// whether inside compile_def_function()\nEXTERN int\testack_compiling INIT(= FALSE);\n\nEXTERN int\tex_nesting_level INIT(= 0);\t// nesting level\nEXTERN int\tdebug_break_level INIT(= -1);\t// break below this level\nEXTERN int\tdebug_did_msg INIT(= FALSE);\t// did \"debug mode\" message\nEXTERN int\tdebug_tick INIT(= 0);\t\t// breakpoint change count\nEXTERN int\tdebug_backtrace_level INIT(= 0); // breakpoint backtrace level\n# ifdef FEAT_PROFILE\nEXTERN int\tdo_profiling INIT(= PROF_NONE);\t// PROF_ values\n# endif\nEXTERN garray_T script_items INIT5(0, 0, sizeof(scriptitem_T *), 20, NULL);\n# define SCRIPT_ITEM(id)    (((scriptitem_T **)script_items.ga_data)[(id) - 1])\n# define SCRIPT_ID_VALID(id)    ((id) > 0 && (id) <= script_items.ga_len)\n# define SCRIPT_SV(id)\t\t(SCRIPT_ITEM(id)->sn_vars)\n# define SCRIPT_VARS(id)\t(SCRIPT_SV(id)->sv_dict.dv_hashtab)\n\n# define FUNCLINE(fp, j)\t((char_u **)(fp->uf_lines.ga_data))[j]\n\n/*\n * The exception currently being thrown.  Used to pass an exception to\n * a different cstack.  Also used for discarding an exception before it is\n * caught or made pending.  Only valid when did_throw is TRUE.\n */\nEXTERN except_T *current_exception;\n\n/*\n * did_throw: An exception is being thrown.  Reset when the exception is caught\n * or as long as it is pending in a finally clause.\n */\nEXTERN int did_throw INIT(= FALSE);\n\n/*\n * need_rethrow: set to TRUE when a throw that cannot be handled in do_cmdline()\n * must be propagated to the cstack of the previously called do_cmdline().\n */\nEXTERN int need_rethrow INIT(= FALSE);\n\n/*\n * check_cstack: set to TRUE when a \":finish\" or \":return\" that cannot be\n * handled in do_cmdline() must be propagated to the cstack of the previously\n * called do_cmdline().\n */\nEXTERN int check_cstack INIT(= FALSE);\n\n/*\n * Number of nested try conditionals (across function calls and \":source\"\n * commands).\n */\nEXTERN int trylevel INIT(= 0);\n\n/*\n * When \"force_abort\" is TRUE, always skip commands after an error message,\n * even after the outermost \":endif\", \":endwhile\" or \":endfor\" or for a\n * function without the \"abort\" flag.  It is set to TRUE when \"trylevel\" is\n * non-zero (and \":silent!\" was not used) or an exception is being thrown at\n * the time an error is detected.  It is set to FALSE when \"trylevel\" gets\n * zero again and there was no error or interrupt or throw.\n */\nEXTERN int force_abort INIT(= FALSE);\n\n/*\n * \"msg_list\" points to a variable in the stack of do_cmdline() which keeps\n * the list of arguments of several emsg() calls, one of which is to be\n * converted to an error exception immediately after the failing command\n * returns.  The message to be used for the exception value is pointed to by\n * the \"throw_msg\" field of the first element in the list.  It is usually the\n * same as the \"msg\" field of that element, but can be identical to the \"msg\"\n * field of a later list element, when the \"emsg_severe\" flag was set when the\n * emsg() call was made.\n */\nEXTERN msglist_T **msg_list INIT(= NULL);\n\n/*\n * suppress_errthrow: When TRUE, don't convert an error to an exception.  Used\n * when displaying the interrupt message or reporting an exception that is still\n * uncaught at the top level (which has already been discarded then).  Also used\n * for the error message when no exception can be thrown.\n */\nEXTERN int suppress_errthrow INIT(= FALSE);\n\n/*\n * The stack of all caught and not finished exceptions.  The exception on the\n * top of the stack is the one got by evaluation of v:exception.  The complete\n * stack of all caught and pending exceptions is embedded in the various\n * cstacks; the pending exceptions, however, are not on the caught stack.\n */\nEXTERN except_T *caught_stack INIT(= NULL);\n\n/*\n * Garbage collection can only take place when we are sure there are no Lists\n * or Dictionaries being used internally.  This is flagged with\n * \"may_garbage_collect\" when we are at the toplevel.\n * \"want_garbage_collect\" is set by the garbagecollect() function, which means\n * we do garbage collection before waiting for a char at the toplevel.\n * \"garbage_collect_at_exit\" indicates garbagecollect(1) was called.\n */\nEXTERN int\tmay_garbage_collect INIT(= FALSE);\nEXTERN int\twant_garbage_collect INIT(= FALSE);\nEXTERN int\tgarbage_collect_at_exit INIT(= FALSE);\n\n\n// Commonly used types.\n// \"unknown\" is used for when the type is really unknown, e.g. global\n// variables.  Also for when a function may or may not return something.\nEXTERN type_T t_unknown INIT6(VAR_UNKNOWN, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\n// \"any\" is used for when the type is mixed.  Excludes \"void\".\nEXTERN type_T t_any INIT6(VAR_ANY, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\n// \"void\" is used for a function not returning anything.\nEXTERN type_T t_void INIT6(VAR_VOID, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\nEXTERN type_T t_bool INIT6(VAR_BOOL, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_null INIT6(VAR_SPECIAL, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_none INIT6(VAR_SPECIAL, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_number INIT6(VAR_NUMBER, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_number_bool INIT6(VAR_NUMBER, 0, 0, TTFLAG_STATIC|TTFLAG_BOOL_OK, NULL, NULL);\nEXTERN type_T t_float INIT6(VAR_FLOAT, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_string INIT6(VAR_STRING, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_blob INIT6(VAR_BLOB, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_blob_null INIT6(VAR_BLOB, 0, 0, TTFLAG_STATIC, &t_void, NULL);\nEXTERN type_T t_job INIT6(VAR_JOB, 0, 0, TTFLAG_STATIC, NULL, NULL);\nEXTERN type_T t_channel INIT6(VAR_CHANNEL, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\n// Special value used for @#.\nEXTERN type_T t_number_or_string INIT6(VAR_STRING, 0, 0, TTFLAG_STATIC, NULL, NULL);\n\nEXTERN type_T t_func_unknown INIT6(VAR_FUNC, -1, -1, TTFLAG_STATIC, &t_unknown, NULL);\nEXTERN type_T t_func_void INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_void, NULL);\nEXTERN type_T t_func_any INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_func_number INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_func_string INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_string, NULL);\nEXTERN type_T t_func_bool INIT6(VAR_FUNC, -1, 0, TTFLAG_STATIC, &t_bool, NULL);\nEXTERN type_T t_func_0_void INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_void, NULL);\nEXTERN type_T t_func_0_any INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_func_0_number INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_func_0_string INIT6(VAR_FUNC, 0, 0, TTFLAG_STATIC, &t_string, NULL);\n\nEXTERN type_T t_list_any INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_dict_any INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_any, NULL);\nEXTERN type_T t_list_empty INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_unknown, NULL);\nEXTERN type_T t_dict_empty INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_unknown, NULL);\n\nEXTERN type_T t_list_bool INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_bool, NULL);\nEXTERN type_T t_list_number INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_list_string INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_string, NULL);\nEXTERN type_T t_list_job INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_job, NULL);\nEXTERN type_T t_list_dict_any INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_dict_any, NULL);\nEXTERN type_T t_list_list_any INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_list_any, NULL);\nEXTERN type_T t_list_list_string INIT6(VAR_LIST, 0, 0, TTFLAG_STATIC, &t_list_string, NULL);\n\nEXTERN type_T t_dict_bool INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_bool, NULL);\nEXTERN type_T t_dict_number INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_number, NULL);\nEXTERN type_T t_dict_string INIT6(VAR_DICT, 0, 0, TTFLAG_STATIC, &t_string, NULL);\n\n#endif\n\n#ifdef FEAT_EVAL\nEXTERN int\tdid_source_packages INIT(= FALSE);\n#endif\n\n// Magic number used for hashitem \"hi_key\" value indicating a deleted item.\n// Only the address is used.\nEXTERN char_u\thash_removed;\n\n\nEXTERN int\tscroll_region INIT(= FALSE); // term supports scroll region\nEXTERN int\tt_colors INIT(= 0);\t    // int value of T_CCO\n\n// Flags to indicate an additional string for highlight name completion.\nEXTERN int include_none INIT(= 0);\t// when 1 include \"None\"\nEXTERN int include_default INIT(= 0);\t// when 1 include \"default\"\nEXTERN int include_link INIT(= 0);\t// when 2 include \"link\" and \"clear\"\n\n/*\n * When highlight_match is TRUE, highlight a match, starting at the cursor\n * position.  Search_match_lines is the number of lines after the match (0 for\n * a match within one line), search_match_endcol the column number of the\n * character just after the match in the last line.\n */\nEXTERN int\thighlight_match INIT(= FALSE);\t// show search match pos\nEXTERN linenr_T\tsearch_match_lines;\t\t// lines of matched string\nEXTERN colnr_T\tsearch_match_endcol;\t\t// col nr of match end\n#ifdef FEAT_SEARCH_EXTRA\nEXTERN linenr_T\tsearch_first_line INIT(= 0);\t  // for :{FIRST},{last}s/pat\nEXTERN linenr_T\tsearch_last_line INIT(= MAXLNUM); // for :{first},{LAST}s/pat\n#endif\n\nEXTERN int\tno_smartcase INIT(= FALSE);\t// don't use 'smartcase' once\n\nEXTERN int\tneed_check_timestamps INIT(= FALSE); // need to check file\n\t\t\t\t\t\t     // timestamps asap\nEXTERN int\tdid_check_timestamps INIT(= FALSE); // did check timestamps\n\t\t\t\t\t\t    // recently\nEXTERN int\tno_check_timestamps INIT(= 0);\t// Don't check timestamps\n\nEXTERN int\thighlight_attr[HLF_COUNT];  // Highl. attr for each context.\n#ifdef FEAT_STL_OPT\n# define USER_HIGHLIGHT\n#endif\n#ifdef USER_HIGHLIGHT\nEXTERN int\thighlight_user[9];\t\t// User[1-9] attributes\n# ifdef FEAT_STL_OPT\nEXTERN int\thighlight_stlnc[9];\t\t// On top of user\n#  ifdef FEAT_TERMINAL\nEXTERN int\thighlight_stlterm[9];\t\t// On top of user\nEXTERN int\thighlight_stltermnc[9];\t\t// On top of user\n#  endif\n# endif\n#endif\n#ifdef FEAT_TERMINAL\n\t\t// When TRUE skip calling terminal_loop() once.  Used when\n\t\t// typing ':' at the more prompt.\nEXTERN int\tskip_term_loop INIT(= FALSE);\n#endif\n#ifdef FEAT_GUI\nEXTERN char_u\t*use_gvimrc INIT(= NULL);\t// \"-U\" cmdline argument\n#endif\nEXTERN int\tcterm_normal_fg_color INIT(= 0);\nEXTERN int\tcterm_normal_fg_bold INIT(= 0);\nEXTERN int\tcterm_normal_bg_color INIT(= 0);\nEXTERN int\tcterm_normal_ul_color INIT(= 0);\n#ifdef FEAT_TERMGUICOLORS\nEXTERN guicolor_T cterm_normal_fg_gui_color INIT(= INVALCOLOR);\nEXTERN guicolor_T cterm_normal_bg_gui_color INIT(= INVALCOLOR);\nEXTERN guicolor_T cterm_normal_ul_gui_color INIT(= INVALCOLOR);\n#endif\n#ifdef FEAT_TERMRESPONSE\nEXTERN int\tis_mac_terminal INIT(= FALSE);  // recognized Terminal.app\n#endif\n\nEXTERN int\tautocmd_busy INIT(= FALSE);\t// Is apply_autocmds() busy?\nEXTERN int\tautocmd_no_enter INIT(= FALSE); // *Enter autocmds disabled\nEXTERN int\tautocmd_no_leave INIT(= FALSE); // *Leave autocmds disabled\n\nEXTERN int\tmodified_was_set;\t\t// did \":set modified\"\nEXTERN int\tdid_filetype INIT(= FALSE);\t// FileType event found\nEXTERN int\tkeep_filetype INIT(= FALSE);\t// value for did_filetype when\n\t\t\t\t\t\t// starting to execute\n\t\t\t\t\t\t// autocommands\n\n// Set by the apply_autocmds_group function if the given event is equal to\n// EVENT_FILETYPE. Used by the readfile function in order to determine if\n// EVENT_BUFREADPOST triggered the EVENT_FILETYPE.\n//\n// Relying on this value requires one to reset it prior calling\n// apply_autocmds_group.\nEXTERN int\tau_did_filetype INIT(= FALSE);\n\n// When deleting the current buffer, another one must be loaded.  If we know\n// which one is preferred, au_new_curbuf is set to it\nEXTERN bufref_T\tau_new_curbuf INIT3(NULL, 0, 0);\n\n// When deleting a buffer/window and autocmd_busy is TRUE, do not free the\n// buffer/window. but link it in the list starting with\n// au_pending_free_buf/ap_pending_free_win, using b_next/w_next.\n// Free the buffer/window when autocmd_busy is being set to FALSE.\nEXTERN buf_T\t*au_pending_free_buf INIT(= NULL);\nEXTERN win_T\t*au_pending_free_win INIT(= NULL);\n\n/*\n * Mouse coordinates, set by check_termcode()\n */\nEXTERN int\tmouse_row;\nEXTERN int\tmouse_col;\nEXTERN int\tmouse_past_bottom INIT(= FALSE);// mouse below last line\nEXTERN int\tmouse_past_eol INIT(= FALSE);\t// mouse right of line\nEXTERN int\tmouse_dragging INIT(= 0);\t// extending Visual area with\n\t\t\t\t\t\t// mouse dragging\n#if defined(FEAT_MOUSE_DEC)\n/*\n * When the DEC mouse has been pressed but not yet released we enable\n * automatic queries for the mouse position.\n */\nEXTERN int\tWantQueryMouse INIT(= FALSE);\n#endif\n\n#ifdef FEAT_GUI\n// When the window layout is about to be changed, need_mouse_correct is set,\n// so that gui_mouse_correct() is called afterwards, to correct the mouse\n// pointer when focus-follow-mouse is being used.\nEXTERN int\tneed_mouse_correct INIT(= FALSE);\n\n// When double clicking, topline must be the same\nEXTERN linenr_T gui_prev_topline INIT(= 0);\n# ifdef FEAT_DIFF\nEXTERN int\tgui_prev_topfill INIT(= 0);\n# endif\n#endif\n\n# ifdef FEAT_MOUSESHAPE\nEXTERN int\tdrag_status_line INIT(= FALSE);\t// dragging the status line\nEXTERN int\tpostponed_mouseshape INIT(= FALSE); // postponed updating the\n\t\t\t\t\t\t    // mouse pointer shape\nEXTERN int\tdrag_sep_line INIT(= FALSE);\t// dragging vert separator\n# endif\n\n\n#ifdef FEAT_DIFF\n// Value set from 'diffopt'.\nEXTERN int\tdiff_context INIT(= 6);\t\t// context for folds\nEXTERN int\tdiff_foldcolumn INIT(= 2);\t// 'foldcolumn' for diff mode\nEXTERN int\tdiff_need_scrollbind INIT(= FALSE);\n#endif\n\n// While redrawing the screen this flag is set.  It means the screen size\n// ('lines' and 'rows') must not be changed.\nEXTERN int\tupdating_screen INIT(= FALSE);\n\n#ifdef MESSAGE_QUEUE\n// While closing windows or buffers messages should not be handled to avoid\n// using invalid windows or buffers.\nEXTERN int\tdont_parse_messages INIT(= FALSE);\n#endif\n\n#ifdef FEAT_MENU\n// The root of the menu hierarchy.\nEXTERN vimmenu_T\t*root_menu INIT(= NULL);\n/*\n * While defining the system menu, sys_menu is TRUE.  This avoids\n * overruling of menus that the user already defined.\n */\nEXTERN int\tsys_menu INIT(= FALSE);\n\n#define FOR_ALL_MENUS(m) for ((m) = root_menu; (m) != NULL; (m) = (m)->next)\n#define FOR_ALL_CHILD_MENUS(p, c) \\\n    for ((c) = (p)->children; (c) != NULL; (c) = (c)->next)\n#endif\n\n#ifdef FEAT_GUI\n# ifdef FEAT_MENU\n// Menu item just selected, set by check_termcode()\nEXTERN vimmenu_T\t*current_menu;\n\n// Set to TRUE after adding/removing menus to ensure they are updated\nEXTERN int force_menu_update INIT(= FALSE);\n# endif\n# ifdef FEAT_GUI_TABLINE\n// Tab in tab pages line just selected, set by check_termcode()\nEXTERN int\t    current_tab;\n\n// Menu entry in tab pages line menu just selected, set by check_termcode()\nEXTERN int\t    current_tabmenu;\n#  define TABLINE_MENU_CLOSE\t1\n#  define TABLINE_MENU_NEW\t2\n#  define TABLINE_MENU_OPEN\t3\n# endif\n\n// Scrollbar moved and new value, set by check_termcode()\nEXTERN int\tcurrent_scrollbar;\nEXTERN long_u\tscrollbar_value;\n\n// found \"-rv\" or \"-reverse\" in command line args\nEXTERN int\tfound_reverse_arg INIT(= FALSE);\n\n// \"-fn\" or \"-font\" command line argument\nEXTERN char\t*font_argument INIT(= NULL);\n\n# ifdef FEAT_GUI_GTK\n// \"-bg\" or \"-background\" command line argument\nEXTERN char\t*background_argument INIT(= NULL);\n\n// \"-fg\" or \"-foreground\" command line argument\nEXTERN char\t*foreground_argument INIT(= NULL);\n# endif\n\n/*\n * While executing external commands or in Ex mode, should not insert GUI\n * events in the input buffer: Set hold_gui_events to non-zero.\n *\n * volatile because it is used in signal handler sig_sysmouse().\n */\nEXTERN volatile sig_atomic_t hold_gui_events INIT(= 0);\n\n/*\n * When resizing the shell is postponed, remember the new size, and call\n * gui_resize_shell() later.\n */\nEXTERN int\tnew_pixel_width INIT(= 0);\nEXTERN int\tnew_pixel_height INIT(= 0);\n\n// Window position from \":winpos\", to be used when opening the GUI window.\nEXTERN int\tgui_win_x INIT(= -1);\nEXTERN int\tgui_win_y INIT(= -1);\n#endif\n\n#ifdef FEAT_CLIPBOARD\nEXTERN Clipboard_T clip_star;\t// PRIMARY selection in X11\n# ifdef FEAT_X11\nEXTERN Clipboard_T clip_plus;\t// CLIPBOARD selection in X11\n# else\n#  define clip_plus clip_star\t// there is only one clipboard\n#  define ONE_CLIPBOARD\n# endif\n\n# define CLIP_UNNAMED      1\n# define CLIP_UNNAMED_PLUS 2\nEXTERN int\tclip_unnamed INIT(= 0); // above two values or'ed\n\nEXTERN int\tclip_autoselect_star INIT(= FALSE);\nEXTERN int\tclip_autoselect_plus INIT(= FALSE);\nEXTERN int\tclip_autoselectml INIT(= FALSE);\nEXTERN int\tclip_html INIT(= FALSE);\nEXTERN regprog_T *clip_exclude_prog INIT(= NULL);\nEXTERN int\tclip_unnamed_saved INIT(= 0);\n#endif\n\n/*\n * All regular windows are linked in a list. \"firstwin\" points to the first\n * entry, \"lastwin\" to the last entry (can be the same as firstwin) and\n * \"curwin\" to the currently active window.\n * When switching tabs these swapped with the pointers in \"tabpage_T\".\n */\nEXTERN win_T\t*firstwin;\t\t// first window\nEXTERN win_T\t*lastwin;\t\t// last window\nEXTERN win_T\t*prevwin INIT(= NULL);\t// previous window\n#define ONE_WINDOW (firstwin == lastwin)\n#define W_NEXT(wp) ((wp)->w_next)\n#define FOR_ALL_WINDOWS(wp) for ((wp) = firstwin; (wp) != NULL; (wp) = (wp)->w_next)\n#define FOR_ALL_FRAMES(frp, first_frame) \\\n    for ((frp) = first_frame; (frp) != NULL; (frp) = (frp)->fr_next)\n#define FOR_ALL_TABPAGES(tp) for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next)\n#define FOR_ALL_WINDOWS_IN_TAB(tp, wp) \\\n    for ((wp) = ((tp) == NULL || (tp) == curtab) \\\n\t    ? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)\n/*\n * When using this macro \"break\" only breaks out of the inner loop. Use \"goto\"\n * to break out of the tabpage loop.\n */\n#define FOR_ALL_TAB_WINDOWS(tp, wp) \\\n    for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \\\n\tfor ((wp) = ((tp) == curtab) \\\n\t\t? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)\n\n#define FOR_ALL_POPUPWINS(wp) \\\n    for ((wp) = first_popupwin; (wp) != NULL; (wp) = (wp)->w_next)\n#define FOR_ALL_POPUPWINS_IN_TAB(tp, wp) \\\n    for ((wp) = (tp)->tp_first_popupwin; (wp) != NULL; (wp) = (wp)->w_next)\n\n\nEXTERN win_T\t*curwin;\t// currently active window\n\nEXTERN win_T\t*aucmd_win;\t// window used in aucmd_prepbuf()\nEXTERN int\taucmd_win_used INIT(= FALSE);\t// aucmd_win is being used\n\n#ifdef FEAT_PROP_POPUP\nEXTERN win_T    *first_popupwin;\t\t// first global popup window\nEXTERN win_T\t*popup_dragwin INIT(= NULL);\t// popup window being dragged\n\n// Set to TRUE if there is any visible popup window.\nEXTERN int\tpopup_visible INIT(= FALSE);\n\n// Set to TRUE if a visible popup window may use a MOUSE_MOVE event\nEXTERN int\tpopup_uses_mouse_move INIT(= FALSE);\n\nEXTERN int\ttext_prop_frozen INIT(= 0);\n#endif\n\n// When set the popup menu will redraw soon using the pum_win_ values. Do not\n// draw over the poup menu area to avoid flicker.\nEXTERN int\tpum_will_redraw INIT(= FALSE);\n\n/*\n * The window layout is kept in a tree of frames.  topframe points to the top\n * of the tree.\n */\nEXTERN frame_T\t*topframe;\t// top of the window frame tree\n\n/*\n * Tab pages are alternative topframes.  \"first_tabpage\" points to the first\n * one in the list, \"curtab\" is the current one. \"lastused_tabpage\" is the\n * last used one.\n */\nEXTERN tabpage_T    *first_tabpage;\nEXTERN tabpage_T    *curtab;\nEXTERN tabpage_T    *lastused_tabpage;\nEXTERN int\t    redraw_tabline INIT(= FALSE);  // need to redraw tabline\n\n/*\n * All buffers are linked in a list. 'firstbuf' points to the first entry,\n * 'lastbuf' to the last entry and 'curbuf' to the currently active buffer.\n */\nEXTERN buf_T\t*firstbuf INIT(= NULL);\t// first buffer\nEXTERN buf_T\t*lastbuf INIT(= NULL);\t// last buffer\nEXTERN buf_T\t*curbuf INIT(= NULL);\t// currently active buffer\n\n#define FOR_ALL_BUFFERS(buf) \\\n    for ((buf) = firstbuf; (buf) != NULL; (buf) = (buf)->b_next)\n\n#define FOR_ALL_BUF_WININFO(buf, wip) \\\n    for ((wip) = (buf)->b_wininfo; (wip) != NULL; (wip) = (wip)->wi_next)\n\n// Iterate through all the signs placed in a buffer\n#define FOR_ALL_SIGNS_IN_BUF(buf, sign) \\\n\tfor ((sign) = (buf)->b_signlist; (sign) != NULL; (sign) = (sign)->se_next)\n\n// Flag that is set when switching off 'swapfile'.  It means that all blocks\n// are to be loaded into memory.  Shouldn't be global...\nEXTERN int\tmf_dont_release INIT(= FALSE);\t// don't release blocks\n\n/*\n * List of files being edited (global argument list).  curwin->w_alist points\n * to this when the window is using the global argument list.\n */\nEXTERN alist_T\tglobal_alist;\t\t    // global argument list\nEXTERN int\tmax_alist_id INIT(= 0);\t    // the previous argument list id\nEXTERN int\targ_had_last INIT(= FALSE); // accessed last file in\n\t\t\t\t\t    // global_alist\n\nEXTERN int\tru_col;\t\t// column for ruler\n#ifdef FEAT_STL_OPT\nEXTERN int\tru_wid;\t\t// 'rulerfmt' width of ruler when non-zero\n#endif\nEXTERN int\tsc_col;\t\t// column for shown command\n\n#ifdef TEMPDIRNAMES\n# if defined(UNIX) && defined(HAVE_FLOCK) \\\n\t&& (defined(HAVE_DIRFD) || defined(__hpux))\nEXTERN DIR\t*vim_tempdir_dp INIT(= NULL); // File descriptor of temp dir\n# endif\nEXTERN char_u\t*vim_tempdir INIT(= NULL); // Name of Vim's own temp dir.\n\t\t\t\t\t   // Ends in a slash.\n#endif\n\n/*\n * When starting or exiting some things are done differently (e.g. screen\n * updating).\n */\nEXTERN int\tstarting INIT(= NO_SCREEN);\n\t\t\t\t// first NO_SCREEN, then NO_BUFFERS and then\n\t\t\t\t// set to 0 when starting up finished\nEXTERN int\texiting INIT(= FALSE);\n\t\t\t\t// TRUE when planning to exit Vim.  Might\n\t\t\t\t// still keep on running if there is a changed\n\t\t\t\t// buffer.\nEXTERN int\treally_exiting INIT(= FALSE);\n\t\t\t\t// TRUE when we are sure to exit, e.g., after\n\t\t\t\t// a deadly signal\nEXTERN int\tv_dying INIT(= 0); // internal value of v:dying\nEXTERN int\tstdout_isatty INIT(= TRUE);\t// is stdout a terminal?\n\n#if defined(FEAT_AUTOCHDIR)\nEXTERN int\ttest_autochdir INIT(= FALSE);\n#endif\nEXTERN char\t*last_chdir_reason INIT(= NULL);\n#if defined(EXITFREE)\nEXTERN int\tentered_free_all_mem INIT(= FALSE);\n\t\t\t\t// TRUE when in or after free_all_mem()\n#endif\n// volatile because it is used in signal handler deathtrap().\nEXTERN volatile sig_atomic_t full_screen INIT(= FALSE);\n\t\t\t\t// TRUE when doing full-screen output\n\t\t\t\t// otherwise only writing some messages\n\nEXTERN int\trestricted INIT(= FALSE);\n\t\t\t\t// TRUE when started as \"rvim\"\nEXTERN int\tsecure INIT(= FALSE);\n\t\t\t\t// non-zero when only \"safe\" commands are\n\t\t\t\t// allowed, e.g. when sourcing .exrc or .vimrc\n\t\t\t\t// in current directory\n\nEXTERN int\ttextlock INIT(= 0);\n\t\t\t\t// non-zero when changing text and jumping to\n\t\t\t\t// another window or editing another buffer is\n\t\t\t\t// not allowed\n\nEXTERN int\tcurbuf_lock INIT(= 0);\n\t\t\t\t// non-zero when the current buffer can't be\n\t\t\t\t// changed.  Used for FileChangedRO.\nEXTERN int\tallbuf_lock INIT(= 0);\n\t\t\t\t// non-zero when no buffer name can be\n\t\t\t\t// changed, no buffer can be deleted and\n\t\t\t\t// current directory can't be changed.\n\t\t\t\t// Used for SwapExists et al.\n#ifdef HAVE_SANDBOX\nEXTERN int\tsandbox INIT(= 0);\n\t\t\t\t// Non-zero when evaluating an expression in a\n\t\t\t\t// \"sandbox\".  Several things are not allowed\n\t\t\t\t// then.\n#endif\n\nEXTERN int\tsilent_mode INIT(= FALSE);\n\t\t\t\t// set to TRUE when \"-s\" commandline argument\n\t\t\t\t// used for ex\n\nEXTERN pos_T\tVIsual;\t\t// start position of active Visual selection\nEXTERN int\tVIsual_active INIT(= FALSE);\n\t\t\t\t// whether Visual mode is active\nEXTERN int\tVIsual_select INIT(= FALSE);\n\t\t\t\t// whether Select mode is active\nEXTERN int\tVIsual_select_reg INIT(= 0);\n\t\t\t\t// register name for Select mode\nEXTERN int\trestart_VIsual_select INIT(= 0);\n\t\t\t\t// restart Select mode when next cmd finished\nEXTERN int\tVIsual_reselect;\n\t\t\t\t// whether to restart the selection after a\n\t\t\t\t// Select mode mapping or menu\n\nEXTERN int\tVIsual_mode INIT(= 'v');\n\t\t\t\t// type of Visual mode\n\nEXTERN int\tredo_VIsual_busy INIT(= FALSE);\n\t\t\t\t// TRUE when redoing Visual\n\n/*\n * The Visual area is remembered for reselection.\n */\nEXTERN int\tresel_VIsual_mode INIT(= NUL);\t// 'v', 'V', or Ctrl-V\nEXTERN linenr_T\tresel_VIsual_line_count;\t// number of lines\nEXTERN colnr_T\tresel_VIsual_vcol;\t\t// nr of cols or end col\n\n/*\n * When pasting text with the middle mouse button in visual mode with\n * restart_edit set, remember where it started so we can set Insstart.\n */\nEXTERN pos_T\twhere_paste_started;\n\n/*\n * This flag is used to make auto-indent work right on lines where only a\n * <RETURN> or <ESC> is typed. It is set when an auto-indent is done, and\n * reset when any other editing is done on the line. If an <ESC> or <RETURN>\n * is received, and did_ai is TRUE, the line is truncated.\n */\nEXTERN int     did_ai INIT(= FALSE);\n\n/*\n * Column of first char after autoindent.  0 when no autoindent done.  Used\n * when 'backspace' is 0, to avoid backspacing over autoindent.\n */\nEXTERN colnr_T\tai_col INIT(= 0);\n\n/*\n * This is a character which will end a start-middle-end comment when typed as\n * the first character on a new line.  It is taken from the last character of\n * the \"end\" comment leader when the COM_AUTO_END flag is given for that\n * comment end in 'comments'.  It is only valid when did_ai is TRUE.\n */\nEXTERN int     end_comment_pending INIT(= NUL);\n\n/*\n * This flag is set after a \":syncbind\" to let the check_scrollbind() function\n * know that it should not attempt to perform scrollbinding due to the scroll\n * that was a result of the \":syncbind.\" (Otherwise, check_scrollbind() will\n * undo some of the work done by \":syncbind.\")  -ralston\n */\nEXTERN int     did_syncbind INIT(= FALSE);\n\n/*\n * This flag is set when a smart indent has been performed. When the next typed\n * character is a '{' the inserted tab will be deleted again.\n */\nEXTERN int\tdid_si INIT(= FALSE);\n\n/*\n * This flag is set after an auto indent. If the next typed character is a '}'\n * one indent will be removed.\n */\nEXTERN int\tcan_si INIT(= FALSE);\n\n/*\n * This flag is set after an \"O\" command. If the next typed character is a '{'\n * one indent will be removed.\n */\nEXTERN int\tcan_si_back INIT(= FALSE);\n\nEXTERN int\told_indent INIT(= 0);\t// for ^^D command in insert mode\n\nEXTERN pos_T\tsaved_cursor\t\t// w_cursor before formatting text.\n#ifdef DO_INIT\n\t= {0, 0, 0}\n#endif\n\t;\n\n/*\n * Stuff for insert mode.\n */\nEXTERN pos_T\tInsstart;\t\t// This is where the latest\n\t\t\t\t\t// insert/append mode started.\n\n// This is where the latest insert/append mode started. In contrast to\n// Insstart, this won't be reset by certain keys and is needed for\n// op_insert(), to detect correctly where inserting by the user started.\nEXTERN pos_T\tInsstart_orig;\n\n/*\n * Stuff for MODE_VREPLACE state.\n */\nEXTERN int\torig_line_count INIT(= 0);  // Line count when \"gR\" started\nEXTERN int\tvr_lines_changed INIT(= 0); // #Lines changed by \"gR\" so far\n\n#if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)\n// argument to SETJMP() for handling X IO errors\nEXTERN JMP_BUF x_jump_env;\n#endif\n\n/*\n * These flags are set based upon 'fileencoding'.\n * Note that \"enc_utf8\" is also set for \"unicode\", because the characters are\n * internally stored as UTF-8 (to avoid trouble with NUL bytes).\n */\n#define DBCS_JPN\t932\t// japan\n#define DBCS_JPNU\t9932\t// euc-jp\n#define DBCS_KOR\t949\t// korea\n#define DBCS_KORU\t9949\t// euc-kr\n#define DBCS_CHS\t936\t// chinese\n#define DBCS_CHSU\t9936\t// euc-cn\n#define DBCS_CHT\t950\t// taiwan\n#define DBCS_CHTU\t9950\t// euc-tw\n#define DBCS_2BYTE\t1\t// 2byte-\n#define DBCS_DEBUG\t(-1)\n\nEXTERN int\tenc_dbcs INIT(= 0);\t\t// One of DBCS_xxx values if\n\t\t\t\t\t\t// DBCS encoding\nEXTERN int\tenc_unicode INIT(= 0);\t// 2: UCS-2 or UTF-16, 4: UCS-4\nEXTERN int\tenc_utf8 INIT(= FALSE);\t\t// UTF-8 encoded Unicode\nEXTERN int\tenc_latin1like INIT(= TRUE);\t// 'encoding' is latin1 comp.\n#if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n// Codepage nr of 'encoding'.  Negative means it's not been set yet, zero\n// means 'encoding' is not a valid codepage.\nEXTERN int\tenc_codepage INIT(= -1);\nEXTERN int\tenc_latin9 INIT(= FALSE);\t// 'encoding' is latin9\n#endif\nEXTERN int\thas_mbyte INIT(= 0);\t\t// any multi-byte encoding\n\n/*\n * To speed up BYTELEN() we fill a table with the byte lengths whenever\n * enc_utf8 or enc_dbcs changes.\n */\nEXTERN char\tmb_bytelen_tab[256];\n\n// Variables that tell what conversion is used for keyboard input and display\n// output.\nEXTERN vimconv_T input_conv;\t\t\t// type of input conversion\nEXTERN vimconv_T output_conv;\t\t\t// type of output conversion\n\n/*\n * Function pointers, used to quickly get to the right function.  Each has\n * three possible values: latin_ (8-bit), utfc_ or utf_ (utf-8) and dbcs_\n * (DBCS).\n * The value is set in mb_init();\n */\n// Length of char in bytes, including any following composing chars.\n// NUL has length zero.\nEXTERN int (*mb_ptr2len)(char_u *p) INIT(= latin_ptr2len);\n\n// idem, with limit on string length\nEXTERN int (*mb_ptr2len_len)(char_u *p, int size) INIT(= latin_ptr2len_len);\n\n// byte length of char\nEXTERN int (*mb_char2len)(int c) INIT(= latin_char2len);\n\n// Convert char \"c\" to bytes in \"buf\", return the length.  \"buf\" must have room\n// for at least 6 bytes.\nEXTERN int (*mb_char2bytes)(int c, char_u *buf) INIT(= latin_char2bytes);\n\nEXTERN int (*mb_ptr2cells)(char_u *p) INIT(= latin_ptr2cells);\nEXTERN int (*mb_ptr2cells_len)(char_u *p, int size) INIT(= latin_ptr2cells_len);\nEXTERN int (*mb_char2cells)(int c) INIT(= latin_char2cells);\nEXTERN int (*mb_off2cells)(unsigned off, unsigned max_off) INIT(= latin_off2cells);\nEXTERN int (*mb_ptr2char)(char_u *p) INIT(= latin_ptr2char);\n\n// Byte offset from \"p\" to the start of a character, including any composing\n// characters. \"base\" must be the start of the string, which must be NUL\n// terminated.\nEXTERN int (*mb_head_off)(char_u *base, char_u *p) INIT(= latin_head_off);\n\n# if defined(USE_ICONV) && defined(DYNAMIC_ICONV)\n// Pointers to functions and variables to be loaded at runtime\nEXTERN size_t (*iconv) (iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);\nEXTERN iconv_t (*iconv_open) (const char *tocode, const char *fromcode);\nEXTERN int (*iconv_close) (iconv_t cd);\nEXTERN int (*iconvctl) (iconv_t cd, int request, void *argument);\nEXTERN int* (*iconv_errno) (void);\n# endif\n\n\n#ifdef FEAT_XIM\n# ifdef FEAT_GUI_GTK\nEXTERN GtkIMContext\t*xic INIT(= NULL);\n/*\n * Start and end column of the preedit area in virtual columns from the start\n * of the text line.  When there is no preedit area they are set to MAXCOL.\n * \"preedit_end_col\" is needed for coloring the preedited string.  Drawing the\n * color between \"preedit_start_col\" and curpos did not work, because some XIM\n * set the cursor position to the first char of the string.\n */\nEXTERN colnr_T\t\tpreedit_start_col INIT(= MAXCOL);\nEXTERN colnr_T\t\tpreedit_end_col INIT(= MAXCOL);\n\n// \"xim_changed_while_preediting\" is set when changed() can set the 'modified'\n// flag even while preediting.\nEXTERN int\t\txim_changed_while_preediting INIT(= FALSE);\n# else\nEXTERN XIC\t\txic INIT(= NULL);\n# endif\n# ifdef FEAT_GUI\nEXTERN guicolor_T\txim_fg_color INIT(= INVALCOLOR);\nEXTERN guicolor_T\txim_bg_color INIT(= INVALCOLOR);\n# endif\n#endif\n\n/*\n * \"State\" is the main state of Vim.\n * There are other variables that modify the state:\n * \"Visual_mode\"    When State is MODE_NORMAL or MODE_INSERT.\n * \"finish_op\"\t    When State is MODE_NORMAL, after typing the operator and\n *\t\t    before typing the motion command.\n * \"motion_force\"   Last motion_force  from do_pending_operator()\n * \"debug_mode\"\t    Debug mode.\n */\nEXTERN int\tState INIT(= MODE_NORMAL);\n\n#ifdef FEAT_EVAL\nEXTERN int\tdebug_mode INIT(= FALSE);\n#endif\n\nEXTERN int\tfinish_op INIT(= FALSE);// TRUE while an operator is pending\nEXTERN long\topcount INIT(= 0);\t// count for pending operator\nEXTERN int\tmotion_force INIT(= 0); // motion force for pending operator\n\n/*\n * Ex mode (Q) state\n */\nEXTERN int exmode_active INIT(= 0);\t// zero, EXMODE_NORMAL or EXMODE_VIM\n\n// Flag set when main_loop() should exit when entering Ex mode.\nEXTERN int pending_exmode_active INIT(= FALSE);\n\nEXTERN int ex_no_reprint INIT(= FALSE); // no need to print after z or p\n\nEXTERN int reg_recording INIT(= 0);\t// register for recording  or zero\nEXTERN int reg_executing INIT(= 0);\t// register being executed or zero\n// Flag set when peeking a character and found the end of executed register\nEXTERN int pending_end_reg_executing INIT(= 0);\n\n// Set when a modifyOtherKeys sequence was seen, then simplified mappings will\n// no longer be used.\nEXTERN int seenModifyOtherKeys INIT(= FALSE);\n\nEXTERN int no_mapping INIT(= FALSE);\t// currently no mapping allowed\nEXTERN int no_zero_mapping INIT(= 0);\t// mapping zero not allowed\nEXTERN int allow_keys INIT(= FALSE);\t// allow key codes when no_mapping\n\t\t\t\t\t// is set\nEXTERN int no_reduce_keys INIT(= FALSE);  // do not apply Ctrl, Shift and Alt\n\t\t\t\t\t  // to the key\nEXTERN int no_u_sync INIT(= 0);\t\t// Don't call u_sync()\n#ifdef FEAT_EVAL\nEXTERN int u_sync_once INIT(= 0);\t// Call u_sync() once when evaluating\n\t\t\t\t\t// an expression.\n#endif\n\nEXTERN int restart_edit INIT(= 0);\t// call edit when next cmd finished\nEXTERN int arrow_used;\t\t\t// Normally FALSE, set to TRUE after\n\t\t\t\t\t// hitting cursor key in insert mode.\n\t\t\t\t\t// Used by vgetorpeek() to decide when\n\t\t\t\t\t// to call u_sync()\nEXTERN int\tins_at_eol INIT(= FALSE); // put cursor after eol when\n\t\t\t\t\t  // restarting edit after CTRL-O\n\nEXTERN int\tno_abbr INIT(= TRUE);\t// TRUE when no abbreviations loaded\n\n#ifdef USE_EXE_NAME\nEXTERN char_u\t*exe_name;\t\t// the name of the executable\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\nEXTERN int\tdont_scroll INIT(= FALSE);// don't use scrollbars when TRUE\n#endif\nEXTERN int\tmapped_ctrl_c INIT(= FALSE); // modes where CTRL-C is mapped\nEXTERN int\tctrl_c_interrupts INIT(= TRUE);\t// CTRL-C sets got_int\n\nEXTERN cmdmod_T\tcmdmod;\t\t\t// Ex command modifiers\nEXTERN int\tsticky_cmdmod_flags INIT(= 0); // used by :execute\n\n#ifdef FEAT_EVAL\nEXTERN int\tis_export INIT(= FALSE);    // :export {cmd}\n#endif\n\nEXTERN int\tmsg_silent INIT(= 0);\t// don't print messages\nEXTERN int\temsg_silent INIT(= 0);\t// don't print error messages\n#ifdef FEAT_EVAL\nEXTERN int\temsg_silent_def INIT(= 0);  // value of emsg_silent when a :def\n\t\t\t\t\t    // function is called\n#endif\nEXTERN int\temsg_noredir INIT(= 0);\t// don't redirect error messages\nEXTERN int\tcmd_silent INIT(= FALSE); // don't echo the command line\n\nEXTERN int\tin_assert_fails INIT(= FALSE);\t// assert_fails() active\n\nEXTERN int\tswap_exists_action INIT(= SEA_NONE);\n\t\t\t\t\t// For dialog when swap file already\n\t\t\t\t\t// exists.\nEXTERN int\tswap_exists_did_quit INIT(= FALSE);\n\t\t\t\t\t// Selected \"quit\" at the dialog.\n\nEXTERN char_u\t*IObuff;\t\t// sprintf's are done in this buffer,\n\t\t\t\t\t// size is IOSIZE\nEXTERN char_u\t*NameBuff;\t\t// file names are expanded in this\n\t\t\t\t\t// buffer, size is MAXPATHL\nEXTERN char\tmsg_buf[MSG_BUF_LEN];\t// small buffer for messages\n\n// When non-zero, postpone redrawing.\nEXTERN int\tRedrawingDisabled INIT(= 0);\n\nEXTERN int\treadonlymode INIT(= FALSE); // Set to TRUE for \"view\"\nEXTERN int\trecoverymode INIT(= FALSE); // Set to TRUE for \"-r\" option\n\nEXTERN typebuf_T typebuf\t\t// typeahead buffer\n#ifdef DO_INIT\n\t\t    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}\n#endif\n\t\t    ;\nEXTERN int\tex_normal_busy INIT(= 0);   // recursiveness of ex_normal()\n#ifdef FEAT_EVAL\nEXTERN int\tin_feedkeys INIT(= 0);\t    // ex_normal_busy set in feedkeys()\n#endif\nEXTERN int\tex_normal_lock INIT(= 0);   // forbid use of ex_normal()\n\n#ifdef FEAT_EVAL\nEXTERN int\tignore_script INIT(= FALSE);  // ignore script input\n#endif\nEXTERN int\tstop_insert_mode;\t// for \":stopinsert\" and 'insertmode'\n\nEXTERN int\tKeyTyped;\t\t// TRUE if user typed current char\nEXTERN int\tKeyStuffed;\t\t// TRUE if current char from stuffbuf\n#ifdef HAVE_INPUT_METHOD\nEXTERN int\tvgetc_im_active;\t// Input Method was active for last\n\t\t\t\t\t// character obtained from vgetc()\n#endif\nEXTERN int\tmaptick INIT(= 0);\t// tick for each non-mapped char\n\nEXTERN int\tmust_redraw INIT(= 0);\t    // type of redraw necessary\nEXTERN int\tskip_redraw INIT(= FALSE);  // skip redraw once\nEXTERN int\tdo_redraw INIT(= FALSE);    // extra redraw once\n#ifdef FEAT_DIFF\nEXTERN int\tneed_diff_redraw INIT(= 0); // need to call diff_redraw()\n#endif\n#ifdef FEAT_RELTIME\n// flag set when 'redrawtime' timeout has been set\nEXTERN int\tredrawtime_limit_set INIT(= FALSE);\n#endif\n\nEXTERN int\tneed_highlight_changed INIT(= TRUE);\n\n#define NSCRIPT 15\nEXTERN FILE\t*scriptin[NSCRIPT];\t    // streams to read script from\nEXTERN int\tcurscript INIT(= 0);\t    // index in scriptin[]\nEXTERN FILE\t*scriptout  INIT(= NULL);   // stream to write script to\nEXTERN int\tread_cmd_fd INIT(= 0);\t    // fd to read commands from\n\n// Set to TRUE when an interrupt signal occurred.\n// Volatile because it is used in signal handler catch_sigint().\nEXTERN volatile sig_atomic_t got_int INIT(= FALSE);\n\n// Set to TRUE when SIGUSR1 signal was detected.\n// Volatile because it is used in signal handler catch_sigint().\nEXTERN volatile sig_atomic_t got_sigusr1 INIT(= FALSE);\n\n#ifdef USE_TERM_CONSOLE\nEXTERN int\tterm_console INIT(= FALSE); // set to TRUE when console used\n#endif\nEXTERN int\ttermcap_active INIT(= FALSE);\t// set by starttermcap()\nEXTERN tmode_T\tcur_tmode INIT(= TMODE_COOK);\t// input terminal mode\nEXTERN int\tbangredo INIT(= FALSE);\t    // set to TRUE with ! command\nEXTERN int\tsearchcmdlen;\t\t    // length of previous search cmd\n#ifdef FEAT_SYN_HL\nEXTERN int\treg_do_extmatch INIT(= 0);  // Used when compiling regexp:\n\t\t\t\t\t    // REX_SET to allow \\z\\(...\\),\n\t\t\t\t\t    // REX_USE to allow \\z\\1 et al.\nEXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); // Used by vim_regexec():\n\t\t\t\t\t    // strings for \\z\\1...\\z\\9\nEXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); // Set by vim_regexec()\n\t\t\t\t\t    // to store \\z\\(...\\) matches\n#endif\n\nEXTERN int\tdid_outofmem_msg INIT(= FALSE);\n\t\t\t\t\t    // set after out of memory msg\nEXTERN int\tdid_swapwrite_msg INIT(= FALSE);\n\t\t\t\t\t    // set after swap write error msg\nEXTERN int\tundo_off INIT(= FALSE);\t    // undo switched off for now\nEXTERN int\tglobal_busy INIT(= 0);\t    // set when :global is executing\nEXTERN int\tlistcmd_busy INIT(= FALSE); // set when :argdo, :windo or\n\t\t\t\t\t    // :bufdo is executing\nEXTERN int\tneed_start_insertmode INIT(= FALSE);\n\t\t\t\t\t    // start insert mode soon\n#if defined(FEAT_EVAL) || defined(PROTO)\nEXTERN char_u\tlast_mode[MODE_MAX_LENGTH] INIT(= \"n\"); // for ModeChanged event\n#endif\nEXTERN char_u\t*last_cmdline INIT(= NULL); // last command line (for \":)\nEXTERN char_u\t*repeat_cmdline INIT(= NULL); // command line for \".\"\nEXTERN char_u\t*new_last_cmdline INIT(= NULL);\t// new value for last_cmdline\nEXTERN char_u\t*autocmd_fname INIT(= NULL); // fname for <afile> on cmdline\nEXTERN int\tautocmd_fname_full;\t     // autocmd_fname is full path\nEXTERN int\tautocmd_bufnr INIT(= 0);     // fnum for <abuf> on cmdline\nEXTERN char_u\t*autocmd_match INIT(= NULL); // name for <amatch> on cmdline\nEXTERN int\tdid_cursorhold INIT(= FALSE); // set when CursorHold t'gerd\nEXTERN pos_T\tlast_cursormoved\t      // for CursorMoved event\n# ifdef DO_INIT\n\t\t\t= {0, 0, 0}\n# endif\n\t\t\t;\n\nEXTERN int\tpostponed_split INIT(= 0);  // for CTRL-W CTRL-] command\nEXTERN int\tpostponed_split_flags INIT(= 0);  // args for win_split()\nEXTERN int\tpostponed_split_tab INIT(= 0);  // cmdmod.cmod_tab\n#ifdef FEAT_QUICKFIX\nEXTERN int\tg_do_tagpreview INIT(= 0);  // for tag preview commands:\n\t\t\t\t\t    // height of preview window\n#endif\nEXTERN int\tg_tag_at_cursor INIT(= FALSE); // whether the tag command comes\n\t\t\t\t\t    // from the command line (0) or was\n\t\t\t\t\t    // invoked as a normal command (1)\n\nEXTERN int\treplace_offset INIT(= 0);   // offset for replace_push()\n\nEXTERN char_u\t*escape_chars INIT(= (char_u *)\" \\t\\\\\\\"|\");\n\t\t\t\t\t    // need backslash in cmd line\n\nEXTERN int\tkeep_help_flag INIT(= FALSE); // doing :ta from help file\n\n/*\n * When a string option is NULL (which only happens in out-of-memory\n * situations), it is set to empty_option, to avoid having to check for NULL\n * everywhere.\n */\nEXTERN char_u\t*empty_option INIT(= (char_u *)\"\");\n\nEXTERN int  redir_off INIT(= FALSE);\t// no redirection for a moment\nEXTERN FILE *redir_fd INIT(= NULL);\t// message redirection file\n#ifdef FEAT_EVAL\nEXTERN int  redir_reg INIT(= 0);\t// message redirection register\nEXTERN int  redir_vname INIT(= 0);\t// message redirection variable\nEXTERN int  redir_execute INIT(= 0);\t// execute() redirection\n#endif\n\n#ifdef FEAT_LANGMAP\nEXTERN char_u\tlangmap_mapchar[256];\t// mapping for language keys\n#endif\n\n#ifdef FEAT_WILDMENU\nEXTERN int  save_p_ls INIT(= -1);\t// Save 'laststatus' setting\nEXTERN int  save_p_wmh INIT(= -1);\t// Save 'winminheight' setting\nEXTERN int  wild_menu_showing INIT(= 0);\n# define WM_SHOWN\t1\t\t// wildmenu showing\n# define WM_SCROLLED\t2\t\t// wildmenu showing with scroll\n#endif\n\n#ifdef MSWIN\nEXTERN char_u\ttoupper_tab[256];\t// table for toupper()\nEXTERN char_u\ttolower_tab[256];\t// table for tolower()\nEXTERN int\tfound_register_arg INIT(= FALSE);\n#endif\n\n#ifdef FEAT_LINEBREAK\nEXTERN char\tbreakat_flags[256];\t// which characters are in 'breakat'\n#endif\n\n// These are in version.c, call init_longVersion() before use.\nextern char *Version;\n#if defined(HAVE_DATE_TIME) && defined(VMS) && defined(VAXC)\nextern char longVersion[];\n#else\nextern char *longVersion;\n#endif\n\n/*\n * Some file names are stored in pathdef.c, which is generated from the\n * Makefile to make their value depend on the Makefile.\n */\n#ifdef HAVE_PATHDEF\nextern char_u *default_vim_dir;\nextern char_u *default_vimruntime_dir;\nextern char_u *all_cflags;\nextern char_u *all_lflags;\n# ifdef VMS\nextern char_u *compiler_version;\nextern char_u *compiled_arch;\n# endif\nextern char_u *compiled_user;\nextern char_u *compiled_sys;\n#endif\n\nEXTERN char_u\t*homedir INIT(= NULL);\n\n// When a window has a local directory, the absolute path of the global\n// current directory is stored here (in allocated memory).  If the current\n// directory is not a local directory, globaldir is NULL.\nEXTERN char_u\t*globaldir INIT(= NULL);\n\n#ifdef FEAT_FOLDING\nEXTERN int\tdisable_fold_update INIT(= 0);\n#endif\n\n// Whether 'keymodel' contains \"stopsel\" and \"startsel\".\nEXTERN int\tkm_stopsel INIT(= FALSE);\nEXTERN int\tkm_startsel INIT(= FALSE);\n\n#ifdef FEAT_CMDWIN\nEXTERN int\tcmdwin_type INIT(= 0);\t// type of cmdline window or 0\nEXTERN int\tcmdwin_result INIT(= 0); // result of cmdline window or 0\n#endif\n\nEXTERN char_u no_lines_msg[]\tINIT(= N_(\"--No lines in buffer--\"));\n\n/*\n * When \":global\" is used to number of substitutions and changed lines is\n * accumulated until it's finished.\n * Also used for \":spellrepall\".\n */\nEXTERN long\tsub_nsubs;\t// total number of substitutions\nEXTERN linenr_T\tsub_nlines;\t// total number of lines changed\n\n#ifdef FEAT_EVAL\n// Used when a compiled :substitute has an expression.\nEXTERN struct subs_expr_S\t*substitute_instr INIT(= NULL);\n#endif\n\n// table to store parsed 'wildmode'\nEXTERN char_u\twim_flags[4];\n\n#if defined(FEAT_STL_OPT)\n// whether titlestring and iconstring contains statusline syntax\n# define STL_IN_ICON\t1\n# define STL_IN_TITLE\t2\nEXTERN int      stl_syntax INIT(= 0);\n#endif\n\n#if defined(FEAT_BEVAL) && !defined(NO_X11_INCLUDES)\nEXTERN BalloonEval\t*balloonEval INIT(= NULL);\nEXTERN int\t\tballoonEvalForTerm INIT(= FALSE);\n# if defined(FEAT_NETBEANS_INTG)\nEXTERN int bevalServers INIT(= 0);\n#  define BEVAL_NETBEANS\t\t0x01\n# endif\n#endif\n\n#ifdef CURSOR_SHAPE\n// the table is in misc2.c, because of initializations\nextern cursorentry_T shape_table[SHAPE_IDX_COUNT];\n#endif\n\n#ifdef FEAT_PRINTER\n/*\n * Printer stuff shared between hardcopy.c and machine-specific printing code.\n */\n# define OPT_PRINT_TOP\t\t0\n# define OPT_PRINT_BOT\t\t1\n# define OPT_PRINT_LEFT\t\t2\n# define OPT_PRINT_RIGHT\t3\n# define OPT_PRINT_HEADERHEIGHT\t4\n# define OPT_PRINT_SYNTAX\t5\n# define OPT_PRINT_NUMBER\t6\n# define OPT_PRINT_WRAP\t\t7\n# define OPT_PRINT_DUPLEX\t8\n# define OPT_PRINT_PORTRAIT\t9\n# define OPT_PRINT_PAPER\t10\n# define OPT_PRINT_COLLATE\t11\n# define OPT_PRINT_JOBSPLIT\t12\n# define OPT_PRINT_FORMFEED\t13\n\n# define OPT_PRINT_NUM_OPTIONS\t14\n\nEXTERN option_table_T printer_opts[OPT_PRINT_NUM_OPTIONS]\n# ifdef DO_INIT\n =\n{\n    {\"top\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"bottom\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"left\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"right\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"header\",\tTRUE, 0, NULL, 0, FALSE},\n    {\"syntax\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"number\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"wrap\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"duplex\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"portrait\", FALSE, 0, NULL, 0, FALSE},\n    {\"paper\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"collate\",\tFALSE, 0, NULL, 0, FALSE},\n    {\"jobsplit\", FALSE, 0, NULL, 0, FALSE},\n    {\"formfeed\", FALSE, 0, NULL, 0, FALSE},\n}\n# endif\n;\n\n// For prt_get_unit().\n# define PRT_UNIT_NONE\t-1\n# define PRT_UNIT_PERC\t0\n# define PRT_UNIT_INCH\t1\n# define PRT_UNIT_MM\t2\n# define PRT_UNIT_POINT\t3\n# define PRT_UNIT_NAMES {\"pc\", \"in\", \"mm\", \"pt\"}\n#endif\n\n#if (defined(FEAT_PRINTER) && defined(FEAT_STL_OPT)) \\\n\t    || defined(FEAT_GUI_TABLINE)\n// Page number used for %N in 'pageheader' and 'guitablabel'.\nEXTERN linenr_T printer_page_num;\n#endif\n\n#ifdef FEAT_XCLIPBOARD\n// xterm display name\nEXTERN char\t*xterm_display INIT(= NULL);\n\n// whether xterm_display was allocated, when FALSE it points into argv[]\nEXTERN int\txterm_display_allocated INIT(= FALSE);\n\n// xterm display pointer\nEXTERN Display\t*xterm_dpy INIT(= NULL);\n#endif\n#if defined(FEAT_XCLIPBOARD) || defined(FEAT_GUI_X11)\nEXTERN XtAppContext app_context INIT(= (XtAppContext)NULL);\n#endif\n\n#ifdef FEAT_GUI_GTK\nEXTERN guint32\tgtk_socket_id INIT(= 0);\nEXTERN int\techo_wid_arg INIT(= FALSE);\t// --echo-wid argument\n#endif\n\n#ifdef FEAT_GUI_MSWIN\n/*\n * The value of the --windowid argument.\n * For embedding gvim inside another application.\n */\nEXTERN long_u\twin_socket_id INIT(= 0);\n#endif\n\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\nEXTERN int\ttypebuf_was_filled INIT(= FALSE); // received text from client\n\t\t\t\t\t\t  // or from feedkeys()\n#endif\n\n#ifdef FEAT_CLIENTSERVER\nEXTERN char_u\t*serverName INIT(= NULL);\t// name of the server\n# ifdef FEAT_X11\nEXTERN Window\tcommWindow INIT(= None);\nEXTERN Window\tclientWindow INIT(= None);\nEXTERN Atom\tcommProperty INIT(= None);\nEXTERN char_u\t*serverDelayedStartName INIT(= NULL);\n# else\n#  ifdef PROTO\ntypedef int HWND;\n#  endif\nEXTERN HWND\tclientWindow INIT(= 0);\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\nEXTERN int\tterm_is_xterm INIT(= FALSE);\t// xterm-like 'term'\n#endif\n\n#ifdef BACKSLASH_IN_FILENAME\nEXTERN char\tpsepc INIT(= '\\\\');\t// normal path separator character\nEXTERN char\tpsepcN INIT(= '/');\t// abnormal path separator character\n// normal path separator string\nEXTERN char\tpseps[2] INIT2('\\\\', 0);\n#endif\n\n// Set to TRUE when an operator is being executed with virtual editing, MAYBE\n// when no operator is being executed, FALSE otherwise.\nEXTERN int\tvirtual_op INIT(= MAYBE);\n\n#ifdef FEAT_SYN_HL\n// Display tick, incremented for each call to update_screen()\nEXTERN disptick_T\tdisplay_tick INIT(= 0);\n#endif\n\n#ifdef FEAT_SPELL\n// Line in which spell checking wasn't highlighted because it touched the\n// cursor position in Insert mode.\nEXTERN linenr_T\t\tspell_redraw_lnum INIT(= 0);\n\n#define FOR_ALL_SPELL_LANGS(slang) \\\n    for ((slang) = first_lang; (slang) != NULL; (slang) = (slang)->sl_next)\n#endif\n\n#ifdef FEAT_CONCEAL\n// Set when the cursor line needs to be redrawn.\nEXTERN int\t\tneed_cursor_line_redraw INIT(= FALSE);\n#endif\n\n#ifdef USE_MCH_ERRMSG\n// Grow array to collect error messages in until they can be displayed.\nEXTERN garray_T error_ga\n# ifdef DO_INIT\n\t= {0, 0, 0, 0, NULL}\n# endif\n\t;\n#endif\n\n#ifdef FEAT_NETBEANS_INTG\nEXTERN char *netbeansArg INIT(= NULL);\t// the -nb[:host:port:passwd] arg\nEXTERN int netbeansFireChanges INIT(= 1); // send buffer changes if != 0\nEXTERN int netbeansForcedQuit INIT(= 0);// don't write modified files\nEXTERN int netbeansReadFile INIT(= 1);\t// OK to read from disk if != 0\nEXTERN int netbeansSuppressNoLines INIT(= 0); // skip \"No lines in buffer\"\n#endif\n\n/*\n * Some messages that can be shared are included here.\n */\nEXTERN char top_bot_msg[]   INIT(= N_(\"search hit TOP, continuing at BOTTOM\"));\nEXTERN char bot_top_msg[]   INIT(= N_(\"search hit BOTTOM, continuing at TOP\"));\n\n#ifdef FEAT_EVAL\nEXTERN char line_msg[]\t    INIT(= N_(\" line \"));\n#endif\n\n#ifdef FEAT_CRYPT\nEXTERN char need_key_msg[]  INIT(= N_(\"Need encryption key for \\\"%s\\\"\"));\n#endif\n\n/*\n * Comms. with the session manager (XSMP)\n */\n#ifdef USE_XSMP\nEXTERN int xsmp_icefd INIT(= -1);   // The actual connection\n#endif\n\n// For undo we need to know the lowest time possible.\nEXTERN time_T starttime;\n\n#ifdef STARTUPTIME\nEXTERN FILE *time_fd INIT(= NULL);  // where to write startup timing\n#endif\n\n/*\n * Some compilers warn for not using a return value, but in some situations we\n * can't do anything useful with the value.  Assign to this variable to avoid\n * the warning.\n */\nEXTERN int vim_ignored;\nEXTERN char *vim_ignoredp;\n\n#ifdef FEAT_EVAL\n// set by alloc_fail(): ID\nEXTERN alloc_id_T  alloc_fail_id INIT(= aid_none);\n// set by alloc_fail(), when zero alloc() returns NULL\nEXTERN int  alloc_fail_countdown INIT(= -1);\n// set by alloc_fail(), number of times alloc() returns NULL\nEXTERN int  alloc_fail_repeat INIT(= 0);\n\n// flags set by test_override()\nEXTERN int  disable_char_avail_for_testing INIT(= FALSE);\nEXTERN int  disable_redraw_for_testing INIT(= FALSE);\nEXTERN int  ignore_redraw_flag_for_testing INIT(= FALSE);\nEXTERN int  nfa_fail_for_testing INIT(= FALSE);\nEXTERN int  no_query_mouse_for_testing INIT(= FALSE);\nEXTERN int  ui_delay_for_testing INIT(= 0);\nEXTERN int  reset_term_props_on_termresponse INIT(= FALSE);\nEXTERN int  disable_vterm_title_for_testing INIT(= FALSE);\nEXTERN long override_sysinfo_uptime INIT(= -1);\nEXTERN int  override_autoload INIT(= FALSE);\nEXTERN int  ml_get_alloc_lines INIT(= FALSE);\n\nEXTERN int  in_free_unref_items INIT(= FALSE);\n#endif\n\n#ifdef FEAT_TIMERS\nEXTERN int  did_add_timer INIT(= FALSE);\nEXTERN int  timer_busy INIT(= 0);   // when timer is inside vgetc() then > 0\n#endif\n#ifdef FEAT_EVAL\nEXTERN int  input_busy INIT(= 0);   // when inside get_user_input() then > 0\n\nEXTERN typval_T\t*lval_root INIT(= NULL);\n#endif\n\n#ifdef FEAT_BEVAL_TERM\nEXTERN int  bevalexpr_due_set INIT(= FALSE);\nEXTERN proftime_T bevalexpr_due;\n#endif\n\n#ifdef FEAT_EVAL\nEXTERN time_T time_for_testing INIT(= 0);\n\nEXTERN int echo_attr INIT(= 0);   // attributes used for \":echo\"\n\n// Abort conversion to string after a recursion error.\nEXTERN int  did_echo_string_emsg INIT(= FALSE);\n\n// Used for checking if local variables or arguments used in a lambda.\nEXTERN int *eval_lavars_used INIT(= NULL);\n\n// Only filled for Win32.\nEXTERN char windowsVersion[20] INIT(= {0});\n\n// Used for lv_first in a non-materialized range() list.\nEXTERN listitem_T range_list_item;\n\n// Passed to an eval() function to enable evaluation.\nEXTERN evalarg_T EVALARG_EVALUATE\n# ifdef DO_INIT\n\t= {EVAL_EVALUATE, 0, NULL, NULL, NULL, NULL, GA_EMPTY, GA_EMPTY, NULL,\n\t\t\t {0, 0, (int)sizeof(char_u *), 20, NULL}, 0, NULL}\n# endif\n\t;\n#endif\n\n#ifdef MSWIN\n# ifdef PROTO\ntypedef int HINSTANCE;\n# endif\nEXTERN int ctrl_break_was_pressed INIT(= FALSE);\nEXTERN HINSTANCE g_hinst INIT(= NULL);\n#endif\n\n#if defined(FEAT_JOB_CHANNEL)\nEXTERN int did_repeated_msg INIT(= 0);\n# define REPEATED_MSG_LOOKING\t    1\n# define REPEATED_MSG_SAFESTATE\t    2\n\n// This flag is set when outputting a terminal control code and reset in\n// out_flush() when characters have been written.\nEXTERN int ch_log_output INIT(= FALSE);\n\n// Whether a redraw is needed for appending a line to a buffer.\nEXTERN int channel_need_redraw INIT(= FALSE);\n\n#define FOR_ALL_CHANNELS(ch) \\\n    for ((ch) = first_channel; (ch) != NULL; (ch) = (ch)->ch_next)\n#define FOR_ALL_JOBS(job) \\\n    for ((job) = first_job; (job) != NULL; (job) = (job)->jv_next)\n#endif\n\n#if defined(FEAT_DIFF)\n#define FOR_ALL_DIFFBLOCKS_IN_TAB(tp, dp) \\\n    for ((dp) = (tp)->tp_first_diff; (dp) != NULL; (dp) = (dp)->df_next)\n#endif\n\n#define FOR_ALL_LIST_ITEMS(l, li) \\\n    for ((li) = (l) == NULL ? NULL : (l)->lv_first; (li) != NULL; (li) = (li)->li_next)\n\n// While executing a regexp and set to OPTION_MAGIC_ON or OPTION_MAGIC_OFF this\n// overrules p_magic.  Otherwise set to OPTION_MAGIC_NOT_SET.\nEXTERN optmagic_T magic_overruled INIT(= OPTION_MAGIC_NOT_SET);\n\n// Set when 'cmdheight' is changed from zero to one temporarily.\nEXTERN int made_cmdheight_nonzero INIT(= FALSE);\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n * Multibyte extensions partly by Sung-Hoon Baek\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * mbyte.c: Code specifically for handling multi-byte characters.\n *\n * The encoding used in the core is set with 'encoding'.  When 'encoding' is\n * changed, the following four variables are set (for speed).\n * Currently these types of character encodings are supported:\n *\n * \"enc_dbcs\"\t    When non-zero it tells the type of double byte character\n *\t\t    encoding (Chinese, Korean, Japanese, etc.).\n *\t\t    The cell width on the display is equal to the number of\n *\t\t    bytes.  (exception: DBCS_JPNU with first byte 0x8e)\n *\t\t    Recognizing the first or second byte is difficult, it\n *\t\t    requires checking a byte sequence from the start.\n * \"enc_utf8\"\t    When TRUE use Unicode characters in UTF-8 encoding.\n *\t\t    The cell width on the display needs to be determined from\n *\t\t    the character value.\n *\t\t    Recognizing bytes is easy: 0xxx.xxxx is a single-byte\n *\t\t    char, 10xx.xxxx is a trailing byte, 11xx.xxxx is a leading\n *\t\t    byte of a multi-byte character.\n *\t\t    To make things complicated, up to six composing characters\n *\t\t    are allowed.  These are drawn on top of the first char.\n *\t\t    For most editing the sequence of bytes with composing\n *\t\t    characters included is considered to be one character.\n * \"enc_unicode\"    When 2 use 16-bit Unicode characters (or UTF-16).\n *\t\t    When 4 use 32-but Unicode characters.\n *\t\t    Internally characters are stored in UTF-8 encoding to\n *\t\t    avoid NUL bytes.  Conversion happens when doing I/O.\n *\t\t    \"enc_utf8\" will also be TRUE.\n *\n * \"has_mbyte\" is set when \"enc_dbcs\" or \"enc_utf8\" is non-zero.\n *\n * If none of these is TRUE, 8-bit bytes are used for a character.  The\n * encoding isn't currently specified (TODO).\n *\n * 'encoding' specifies the encoding used in the core.  This is in registers,\n * text manipulation, buffers, etc.  Conversion has to be done when characters\n * in another encoding are received or send:\n *\n *\t\t       clipboard\n *\t\t\t   ^\n *\t\t\t   | (2)\n *\t\t\t   V\n *\t\t   +---------------+\n *\t      (1)  |\t\t   | (3)\n *  keyboard ----->|\t core\t   |-----> display\n *\t\t   |\t\t   |\n *\t\t   +---------------+\n *\t\t\t   ^\n *\t\t\t   | (4)\n *\t\t\t   V\n *\t\t\t file\n *\n * (1) Typed characters arrive in the current locale.  Conversion is to be\n *     done when 'encoding' is different from 'termencoding'.\n * (2) Text will be made available with the encoding specified with\n *     'encoding'.  If this is not sufficient, system-specific conversion\n *     might be required.\n * (3) For the GUI the correct font must be selected, no conversion done.\n *     Otherwise, conversion is to be done when 'encoding' differs from\n *     'termencoding'.  (Different in the GTK+ 2 port -- 'termencoding'\n *     is always used for both input and output and must always be set to\n *     \"utf-8\".  gui_mch_init() does this automatically.)\n * (4) The encoding of the file is specified with 'fileencoding'.  Conversion\n *     is to be done when it's different from 'encoding'.\n *\n * The viminfo file is a special case: Only text is converted, not file names.\n * Vim scripts may contain an \":encoding\" command.  This has an effect for\n * some commands, like \":menutrans\"\n */\n\n#include \"vim.h\"\n\n#ifdef WIN32UNIX\n# ifndef WIN32_LEAN_AND_MEAN\n#  define WIN32_LEAN_AND_MEAN\n# endif\n# if defined(FEAT_GUI) || defined(FEAT_XCLIPBOARD)\n#  ifdef __CYGWIN__\n    // ControlMask from <X11/X.h> (included in \"vim.h\") is conflicting with\n    // <w32api/windows.h> (included in <X11/Xwindows.h>).\n#   undef ControlMask\n#  endif\n#  include <X11/Xwindows.h>\n#  define WINBYTE wBYTE\n# else\n#  include <windows.h>\n#  define WINBYTE BYTE\n# endif\n# ifdef WIN32\n#  undef WIN32\t    // Some windows.h define WIN32, we don't want that here.\n# endif\n#else\n# define WINBYTE BYTE\n#endif\n\n#if (defined(MSWIN) || defined(WIN32UNIX)) && !defined(__MINGW32__)\n# include <winnls.h>\n#endif\n\n#ifdef FEAT_GUI_X11\n# include <X11/Intrinsic.h>\n#endif\n#ifdef X_LOCALE\n# include <X11/Xlocale.h>\n# if !defined(HAVE_MBLEN) && !defined(mblen)\n#  define mblen _Xmblen\n# endif\n#endif\n\n#ifdef HAVE_WCHAR_H\n# include <wchar.h>\n#endif\n\n#if 0\n// This has been disabled, because several people reported problems with the\n// wcwidth() and iswprint() library functions, esp. for Hebrew.\n# ifdef __STDC_ISO_10646__\n#  define USE_WCHAR_FUNCTIONS\n# endif\n#endif\n\nstatic int dbcs_char2len(int c);\nstatic int dbcs_char2bytes(int c, char_u *buf);\nstatic int dbcs_ptr2len(char_u *p);\nstatic int dbcs_ptr2len_len(char_u *p, int size);\nstatic int utf_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_char2cells(int c);\nstatic int dbcs_ptr2cells_len(char_u *p, int size);\nstatic int dbcs_ptr2char(char_u *p);\nstatic int dbcs_head_off(char_u *base, char_u *p);\n#ifdef FEAT_EVAL\nstatic int cw_value(int c);\n#endif\n\n/*\n * Lookup table to quickly get the length in bytes of a UTF-8 character from\n * the first byte of a UTF-8 string.\n * Bytes which are illegal when used as the first byte have a 1.\n * The NUL byte has length 1.\n */\nstatic char utf8len_tab[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1,\n};\n\n/*\n * Like utf8len_tab above, but using a zero for illegal lead bytes.\n */\nstatic char utf8len_tab_zero[256] =\n{\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0,\n};\n\n\n/*\n * Canonical encoding names and their properties.\n * \"iso-8859-n\" is handled by enc_canonize() directly.\n */\nstatic struct\n{   char *name;\t\tint prop;\t\tint codepage;}\nenc_canon_table[] =\n{\n#define IDX_LATIN_1\t0\n    {\"latin1\",\t\tENC_8BIT + ENC_LATIN1,\t1252},\n#define IDX_ISO_2\t1\n    {\"iso-8859-2\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_3\t2\n    {\"iso-8859-3\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_4\t3\n    {\"iso-8859-4\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_5\t4\n    {\"iso-8859-5\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_6\t5\n    {\"iso-8859-6\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_7\t6\n    {\"iso-8859-7\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_8\t7\n    {\"iso-8859-8\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_9\t8\n    {\"iso-8859-9\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_10\t9\n    {\"iso-8859-10\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_11\t10\n    {\"iso-8859-11\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_13\t11\n    {\"iso-8859-13\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_14\t12\n    {\"iso-8859-14\",\tENC_8BIT,\t\t0},\n#define IDX_ISO_15\t13\n    {\"iso-8859-15\",\tENC_8BIT + ENC_LATIN9,\t0},\n#define IDX_KOI8_R\t14\n    {\"koi8-r\",\t\tENC_8BIT,\t\t0},\n#define IDX_KOI8_U\t15\n    {\"koi8-u\",\t\tENC_8BIT,\t\t0},\n#define IDX_UTF8\t16\n    {\"utf-8\",\t\tENC_UNICODE,\t\t0},\n#define IDX_UCS2\t17\n    {\"ucs-2\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE, 0},\n#define IDX_UCS2LE\t18\n    {\"ucs-2le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE, 0},\n#define IDX_UTF16\t19\n    {\"utf-16\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD, 0},\n#define IDX_UTF16LE\t20\n    {\"utf-16le\",\tENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD, 0},\n#define IDX_UCS4\t21\n    {\"ucs-4\",\t\tENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE, 0},\n#define IDX_UCS4LE\t22\n    {\"ucs-4le\",\t\tENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE, 0},\n\n    // For debugging DBCS encoding on Unix.\n#define IDX_DEBUG\t23\n    {\"debug\",\t\tENC_DBCS,\t\tDBCS_DEBUG},\n#define IDX_EUC_JP\t24\n    {\"euc-jp\",\t\tENC_DBCS,\t\tDBCS_JPNU},\n#define IDX_SJIS\t25\n    {\"sjis\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_EUC_KR\t26\n    {\"euc-kr\",\t\tENC_DBCS,\t\tDBCS_KORU},\n#define IDX_EUC_CN\t27\n    {\"euc-cn\",\t\tENC_DBCS,\t\tDBCS_CHSU},\n#define IDX_EUC_TW\t28\n    {\"euc-tw\",\t\tENC_DBCS,\t\tDBCS_CHTU},\n#define IDX_BIG5\t29\n    {\"big5\",\t\tENC_DBCS,\t\tDBCS_CHT},\n\n    // MS-DOS and MS-Windows codepages are included here, so that they can be\n    // used on Unix too.  Most of them are similar to ISO-8859 encodings, but\n    // not exactly the same.\n#define IDX_CP437\t30\n    {\"cp437\",\t\tENC_8BIT,\t\t437}, // like iso-8859-1\n#define IDX_CP737\t31\n    {\"cp737\",\t\tENC_8BIT,\t\t737}, // like iso-8859-7\n#define IDX_CP775\t32\n    {\"cp775\",\t\tENC_8BIT,\t\t775}, // Baltic\n#define IDX_CP850\t33\n    {\"cp850\",\t\tENC_8BIT,\t\t850}, // like iso-8859-4\n#define IDX_CP852\t34\n    {\"cp852\",\t\tENC_8BIT,\t\t852}, // like iso-8859-1\n#define IDX_CP855\t35\n    {\"cp855\",\t\tENC_8BIT,\t\t855}, // like iso-8859-2\n#define IDX_CP857\t36\n    {\"cp857\",\t\tENC_8BIT,\t\t857}, // like iso-8859-5\n#define IDX_CP860\t37\n    {\"cp860\",\t\tENC_8BIT,\t\t860}, // like iso-8859-9\n#define IDX_CP861\t38\n    {\"cp861\",\t\tENC_8BIT,\t\t861}, // like iso-8859-1\n#define IDX_CP862\t39\n    {\"cp862\",\t\tENC_8BIT,\t\t862}, // like iso-8859-1\n#define IDX_CP863\t40\n    {\"cp863\",\t\tENC_8BIT,\t\t863}, // like iso-8859-8\n#define IDX_CP865\t41\n    {\"cp865\",\t\tENC_8BIT,\t\t865}, // like iso-8859-1\n#define IDX_CP866\t42\n    {\"cp866\",\t\tENC_8BIT,\t\t866}, // like iso-8859-5\n#define IDX_CP869\t43\n    {\"cp869\",\t\tENC_8BIT,\t\t869}, // like iso-8859-7\n#define IDX_CP874\t44\n    {\"cp874\",\t\tENC_8BIT,\t\t874}, // Thai\n#define IDX_CP932\t45\n    {\"cp932\",\t\tENC_DBCS,\t\tDBCS_JPN},\n#define IDX_CP936\t46\n    {\"cp936\",\t\tENC_DBCS,\t\tDBCS_CHS},\n#define IDX_CP949\t47\n    {\"cp949\",\t\tENC_DBCS,\t\tDBCS_KOR},\n#define IDX_CP950\t48\n    {\"cp950\",\t\tENC_DBCS,\t\tDBCS_CHT},\n#define IDX_CP1250\t49\n    {\"cp1250\",\t\tENC_8BIT,\t\t1250}, // Czech, Polish, etc.\n#define IDX_CP1251\t50\n    {\"cp1251\",\t\tENC_8BIT,\t\t1251}, // Cyrillic\n    // cp1252 is considered to be equal to latin1\n#define IDX_CP1253\t51\n    {\"cp1253\",\t\tENC_8BIT,\t\t1253}, // Greek\n#define IDX_CP1254\t52\n    {\"cp1254\",\t\tENC_8BIT,\t\t1254}, // Turkish\n#define IDX_CP1255\t53\n    {\"cp1255\",\t\tENC_8BIT,\t\t1255}, // Hebrew\n#define IDX_CP1256\t54\n    {\"cp1256\",\t\tENC_8BIT,\t\t1256}, // Arabic\n#define IDX_CP1257\t55\n    {\"cp1257\",\t\tENC_8BIT,\t\t1257}, // Baltic\n#define IDX_CP1258\t56\n    {\"cp1258\",\t\tENC_8BIT,\t\t1258}, // Vietnamese\n\n#define IDX_MACROMAN\t57\n    {\"macroman\",\tENC_8BIT + ENC_MACROMAN, 0},\t// Mac OS\n#define IDX_DECMCS\t58\n    {\"dec-mcs\",\t\tENC_8BIT,\t\t0},\t// DEC MCS\n#define IDX_HPROMAN8\t59\n    {\"hp-roman8\",\tENC_8BIT,\t\t0},\t// HP Roman8\n#define IDX_COUNT\t60\n};\n\n/*\n * Aliases for encoding names.\n */\nstatic struct\n{   char *name;\t\tint canon;}\nenc_alias_table[] =\n{\n    {\"ansi\",\t\tIDX_LATIN_1},\n    {\"iso-8859-1\",\tIDX_LATIN_1},\n    {\"iso-8859\",\tIDX_LATIN_1},\n    {\"latin2\",\t\tIDX_ISO_2},\n    {\"latin3\",\t\tIDX_ISO_3},\n    {\"latin4\",\t\tIDX_ISO_4},\n    {\"cyrillic\",\tIDX_ISO_5},\n    {\"arabic\",\t\tIDX_ISO_6},\n    {\"greek\",\t\tIDX_ISO_7},\n#ifdef MSWIN\n    {\"hebrew\",\t\tIDX_CP1255},\n#else\n    {\"hebrew\",\t\tIDX_ISO_8},\n#endif\n    {\"latin5\",\t\tIDX_ISO_9},\n    {\"turkish\",\t\tIDX_ISO_9}, // ?\n    {\"latin6\",\t\tIDX_ISO_10},\n    {\"nordic\",\t\tIDX_ISO_10}, // ?\n    {\"thai\",\t\tIDX_ISO_11}, // ?\n    {\"latin7\",\t\tIDX_ISO_13},\n    {\"latin8\",\t\tIDX_ISO_14},\n    {\"latin9\",\t\tIDX_ISO_15},\n    {\"utf8\",\t\tIDX_UTF8},\n    {\"unicode\",\t\tIDX_UCS2},\n    {\"ucs2\",\t\tIDX_UCS2},\n    {\"ucs2be\",\t\tIDX_UCS2},\n    {\"ucs-2be\",\t\tIDX_UCS2},\n    {\"ucs2le\",\t\tIDX_UCS2LE},\n    {\"utf16\",\t\tIDX_UTF16},\n    {\"utf16be\",\t\tIDX_UTF16},\n    {\"utf-16be\",\tIDX_UTF16},\n    {\"utf16le\",\t\tIDX_UTF16LE},\n    {\"ucs4\",\t\tIDX_UCS4},\n    {\"ucs4be\",\t\tIDX_UCS4},\n    {\"ucs-4be\",\t\tIDX_UCS4},\n    {\"ucs4le\",\t\tIDX_UCS4LE},\n    {\"utf32\",\t\tIDX_UCS4},\n    {\"utf-32\",\t\tIDX_UCS4},\n    {\"utf32be\",\t\tIDX_UCS4},\n    {\"utf-32be\",\tIDX_UCS4},\n    {\"utf32le\",\t\tIDX_UCS4LE},\n    {\"utf-32le\",\tIDX_UCS4LE},\n    {\"932\",\t\tIDX_CP932},\n    {\"949\",\t\tIDX_CP949},\n    {\"936\",\t\tIDX_CP936},\n    {\"gbk\",\t\tIDX_CP936},\n    {\"950\",\t\tIDX_CP950},\n    {\"eucjp\",\t\tIDX_EUC_JP},\n    {\"unix-jis\",\tIDX_EUC_JP},\n    {\"ujis\",\t\tIDX_EUC_JP},\n    {\"shift-jis\",\tIDX_SJIS},\n    {\"pck\",\t\tIDX_SJIS},\t// Sun: PCK\n    {\"euckr\",\t\tIDX_EUC_KR},\n    {\"5601\",\t\tIDX_EUC_KR},\t// Sun: KS C 5601\n    {\"euccn\",\t\tIDX_EUC_CN},\n    {\"gb2312\",\t\tIDX_EUC_CN},\n    {\"euctw\",\t\tIDX_EUC_TW},\n#if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n    {\"japan\",\t\tIDX_CP932},\n    {\"korea\",\t\tIDX_CP949},\n    {\"prc\",\t\tIDX_CP936},\n    {\"chinese\",\t\tIDX_CP936},\n    {\"taiwan\",\t\tIDX_CP950},\n    {\"big5\",\t\tIDX_CP950},\n#else\n    {\"japan\",\t\tIDX_EUC_JP},\n    {\"korea\",\t\tIDX_EUC_KR},\n    {\"prc\",\t\tIDX_EUC_CN},\n    {\"chinese\",\t\tIDX_EUC_CN},\n    {\"taiwan\",\t\tIDX_EUC_TW},\n    {\"cp950\",\t\tIDX_BIG5},\n    {\"950\",\t\tIDX_BIG5},\n#endif\n    {\"mac\",\t\tIDX_MACROMAN},\n    {\"mac-roman\",\tIDX_MACROMAN},\n    {NULL,\t\t0}\n};\n\n#ifndef CP_UTF8\n# define CP_UTF8 65001\t// magic number from winnls.h\n#endif\n\n/*\n * Find encoding \"name\" in the list of canonical encoding names.\n * Returns -1 if not found.\n */\n    static int\nenc_canon_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; i < IDX_COUNT; ++i)\n\tif (STRCMP(name, enc_canon_table[i].name) == 0)\n\t    return i;\n    return -1;\n}\n\n\n/*\n * Find canonical encoding \"name\" in the list and return its properties.\n * Returns 0 if not found.\n */\n    int\nenc_canon_props(char_u *name)\n{\n    int\t\ti;\n\n    i = enc_canon_search(name);\n    if (i >= 0)\n\treturn enc_canon_table[i].prop;\n#ifdef MSWIN\n    if (name[0] == 'c' && name[1] == 'p' && VIM_ISDIGIT(name[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)name + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1) // some single-byte encoding\n\t\treturn ENC_8BIT;\n\t    if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t\t// must be a DBCS encoding\n\t\treturn ENC_DBCS;\n\t}\n\treturn 0;\n    }\n#endif\n    if (STRNCMP(name, \"2byte-\", 6) == 0)\n\treturn ENC_DBCS;\n    if (STRNCMP(name, \"8bit-\", 5) == 0 || STRNCMP(name, \"iso-8859-\", 9) == 0)\n\treturn ENC_8BIT;\n    return 0;\n}\n\n/*\n * Set up for using multi-byte characters.\n * Called in three cases:\n * - by main() to initialize (p_enc == NULL)\n * - by set_init_1() after 'encoding' was set to its default.\n * - by do_set() when 'encoding' has been set.\n * p_enc must have been passed through enc_canonize() already.\n * Sets the \"enc_unicode\", \"enc_utf8\", \"enc_dbcs\" and \"has_mbyte\" flags.\n * Fills mb_bytelen_tab[] and returns NULL when there are no problems.\n * When there is something wrong: Returns an error message and doesn't change\n * anything.\n */\n    char *\nmb_init(void)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\tn;\n    int\t\tenc_dbcs_new = 0;\n#if defined(USE_ICONV) && !defined(MSWIN) && !defined(WIN32UNIX) \\\n\t&& !defined(MACOS_CONVERT)\n# define LEN_FROM_CONV\n    vimconv_T\tvimconv;\n    char_u\t*p;\n#endif\n\n    if (p_enc == NULL)\n    {\n\t// Just starting up: set the whole table to one's.\n\tfor (i = 0; i < 256; ++i)\n\t    mb_bytelen_tab[i] = 1;\n\tinput_conv.vc_type = CONV_NONE;\n\tinput_conv.vc_factor = 1;\n\toutput_conv.vc_type = CONV_NONE;\n\treturn NULL;\n    }\n\n#ifdef MSWIN\n    if (p_enc[0] == 'c' && p_enc[1] == 'p' && VIM_ISDIGIT(p_enc[2]))\n    {\n\tCPINFO\tcpinfo;\n\n\t// Get info on this codepage to find out what it is.\n\tif (GetCPInfo(atoi((char *)p_enc + 2), &cpinfo) != 0)\n\t{\n\t    if (cpinfo.MaxCharSize == 1)\n\t    {\n\t\t// some single-byte encoding\n\t\tenc_unicode = 0;\n\t\tenc_utf8 = FALSE;\n\t    }\n\t    else if (cpinfo.MaxCharSize == 2\n\t\t    && (cpinfo.LeadByte[0] != 0 || cpinfo.LeadByte[1] != 0))\n\t    {\n\t\t// must be a DBCS encoding, check below\n\t\tenc_dbcs_new = atoi((char *)p_enc + 2);\n\t    }\n\t    else\n\t\tgoto codepage_invalid;\n\t}\n\telse if (GetLastError() == ERROR_INVALID_PARAMETER)\n\t{\ncodepage_invalid:\n\t    return N_(e_not_valid_codepage);\n\t}\n    }\n#endif\n    else if (STRNCMP(p_enc, \"8bit-\", 5) == 0\n\t    || STRNCMP(p_enc, \"iso-8859-\", 9) == 0)\n    {\n\t// Accept any \"8bit-\" or \"iso-8859-\" name.\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n    {\n#ifdef MSWIN\n\t// Windows: accept only valid codepage numbers, check below.\n\tif (p_enc[6] != 'c' || p_enc[7] != 'p'\n\t\t\t      || (enc_dbcs_new = atoi((char *)p_enc + 8)) == 0)\n\t    return e_invalid_argument;\n#else\n\t// Unix: accept any \"2byte-\" name, assume current locale.\n\tenc_dbcs_new = DBCS_2BYTE;\n#endif\n    }\n    else if ((idx = enc_canon_search(p_enc)) >= 0)\n    {\n\ti = enc_canon_table[idx].prop;\n\tif (i & ENC_UNICODE)\n\t{\n\t    // Unicode\n\t    enc_utf8 = TRUE;\n\t    if (i & (ENC_2BYTE | ENC_2WORD))\n\t\tenc_unicode = 2;\n\t    else if (i & ENC_4BYTE)\n\t\tenc_unicode = 4;\n\t    else\n\t\tenc_unicode = 0;\n\t}\n\telse if (i & ENC_DBCS)\n\t{\n\t    // 2byte, handle below\n\t    enc_dbcs_new = enc_canon_table[idx].codepage;\n\t}\n\telse\n\t{\n\t    // Must be 8-bit.\n\t    enc_unicode = 0;\n\t    enc_utf8 = FALSE;\n\t}\n    }\n    else    // Don't know what encoding this is, reject it.\n\treturn e_invalid_argument;\n\n    if (enc_dbcs_new != 0)\n    {\n#ifdef MSWIN\n\t// Check if the DBCS code page is OK.\n\tif (!IsValidCodePage(enc_dbcs_new))\n\t    goto codepage_invalid;\n#endif\n\tenc_unicode = 0;\n\tenc_utf8 = FALSE;\n    }\n    enc_dbcs = enc_dbcs_new;\n    has_mbyte = (enc_dbcs != 0 || enc_utf8);\n\n#if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n    enc_codepage = encname2codepage(p_enc);\n    enc_latin9 = (STRCMP(p_enc, \"iso-8859-15\") == 0);\n#endif\n\n    // Detect an encoding that uses latin1 characters.\n    enc_latin1like = (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t|| STRCMP(p_enc, \"iso-8859-15\") == 0);\n\n    /*\n     * Set the function pointers.\n     */\n    if (enc_utf8)\n    {\n\tmb_ptr2len = utfc_ptr2len;\n\tmb_ptr2len_len = utfc_ptr2len_len;\n\tmb_char2len = utf_char2len;\n\tmb_char2bytes = utf_char2bytes;\n\tmb_ptr2cells = utf_ptr2cells;\n\tmb_ptr2cells_len = utf_ptr2cells_len;\n\tmb_char2cells = utf_char2cells;\n\tmb_off2cells = utf_off2cells;\n\tmb_ptr2char = utf_ptr2char;\n\tmb_head_off = utf_head_off;\n    }\n    else if (enc_dbcs != 0)\n    {\n\tmb_ptr2len = dbcs_ptr2len;\n\tmb_ptr2len_len = dbcs_ptr2len_len;\n\tmb_char2len = dbcs_char2len;\n\tmb_char2bytes = dbcs_char2bytes;\n\tmb_ptr2cells = dbcs_ptr2cells;\n\tmb_ptr2cells_len = dbcs_ptr2cells_len;\n\tmb_char2cells = dbcs_char2cells;\n\tmb_off2cells = dbcs_off2cells;\n\tmb_ptr2char = dbcs_ptr2char;\n\tmb_head_off = dbcs_head_off;\n    }\n    else\n    {\n\tmb_ptr2len = latin_ptr2len;\n\tmb_ptr2len_len = latin_ptr2len_len;\n\tmb_char2len = latin_char2len;\n\tmb_char2bytes = latin_char2bytes;\n\tmb_ptr2cells = latin_ptr2cells;\n\tmb_ptr2cells_len = latin_ptr2cells_len;\n\tmb_char2cells = latin_char2cells;\n\tmb_off2cells = latin_off2cells;\n\tmb_ptr2char = latin_ptr2char;\n\tmb_head_off = latin_head_off;\n    }\n\n    /*\n     * Fill the mb_bytelen_tab[] for MB_BYTE2LEN().\n     */\n#ifdef LEN_FROM_CONV\n    // When 'encoding' is different from the current locale mblen() won't\n    // work.  Use conversion to \"utf-8\" instead.\n    vimconv.vc_type = CONV_NONE;\n    if (enc_dbcs)\n    {\n\tp = enc_locale();\n\tif (p == NULL || STRCMP(p, p_enc) != 0)\n\t{\n\t    convert_setup(&vimconv, p_enc, (char_u *)\"utf-8\");\n\t    vimconv.vc_fail = TRUE;\n\t}\n\tvim_free(p);\n    }\n#endif\n\n    for (i = 0; i < 256; ++i)\n    {\n\t// Our own function to reliably check the length of UTF-8 characters,\n\t// independent of mblen().\n\tif (enc_utf8)\n\t    n = utf8len_tab[i];\n\telse if (enc_dbcs == 0)\n\t    n = 1;\n\telse\n\t{\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t    // enc_dbcs is set by setting 'fileencoding'.  It becomes a Windows\n\t    // CodePage identifier, which we can pass directly in to Windows\n\t    // API\n\t    n = IsDBCSLeadByteEx(enc_dbcs, (WINBYTE)i) ? 2 : 1;\n#else\n# if defined(__amigaos4__) || defined(__ANDROID__) || \\\n\t\t\t\t   !(defined(HAVE_MBLEN) || defined(X_LOCALE))\n\t    /*\n\t     * if mblen() is not available, character which MSB is turned on\n\t     * are treated as leading byte character. (note : This assumption\n\t     * is not always true.)\n\t     */\n\t    n = (i & 0x80) ? 2 : 1;\n# else\n\t    char buf[MB_MAXBYTES + 1];\n\n\t    if (i == NUL)\t// just in case mblen() can't handle \"\"\n\t\tn = 1;\n\t    else\n\t    {\n\t\tbuf[0] = i;\n\t\tbuf[1] = 0;\n#  ifdef LEN_FROM_CONV\n\t\tif (vimconv.vc_type != CONV_NONE)\n\t\t{\n\t\t    /*\n\t\t     * string_convert() should fail when converting the first\n\t\t     * byte of a double-byte character.\n\t\t     */\n\t\t    p = string_convert(&vimconv, (char_u *)buf, NULL);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tvim_free(p);\n\t\t\tn = 1;\n\t\t    }\n\t\t    else\n\t\t\tn = 2;\n\t\t}\n\t\telse\n#  endif\n\t\t{\n\t\t    /*\n\t\t     * mblen() should return -1 for invalid (means the leading\n\t\t     * multibyte) character.  However there are some platforms\n\t\t     * where mblen() returns 0 for invalid character.\n\t\t     * Therefore, following condition includes 0.\n\t\t     */\n\t\t    vim_ignored = mblen(NULL, 0);  // First reset the state.\n\t\t    if (mblen(buf, (size_t)1) <= 0)\n\t\t\tn = 2;\n\t\t    else\n\t\t\tn = 1;\n\t\t}\n\t    }\n# endif\n#endif\n\t}\n\n\tmb_bytelen_tab[i] = n;\n    }\n\n#ifdef LEN_FROM_CONV\n    convert_setup(&vimconv, NULL, NULL);\n#endif\n\n    // The cell width depends on the type of multi-byte characters.\n    (void)init_chartab();\n\n    // When enc_utf8 is set or reset, (de)allocate ScreenLinesUC[]\n    screenalloc(FALSE);\n\n    // When using Unicode, set default for 'fileencodings'.\n    if (enc_utf8 && !option_was_set((char_u *)\"fencs\"))\n\tset_fencs_unicode();\n\n#if defined(HAVE_BIND_TEXTDOMAIN_CODESET) && defined(FEAT_GETTEXT)\n    // GNU gettext 0.10.37 supports this feature: set the codeset used for\n    // translated messages independently from the current locale.\n    (void)bind_textdomain_codeset(VIMPACKAGE,\n\t\t\t\t\t  enc_utf8 ? \"utf-8\" : (char *)p_enc);\n#endif\n\n#ifdef MSWIN\n    // When changing 'encoding' while starting up, then convert the command\n    // line arguments from the active codepage to 'encoding'.\n    if (starting != 0)\n\tfix_arg_enc();\n#endif\n\n    // Fire an autocommand to let people do custom font setup. This must be\n    // after Vim has been setup for the new encoding.\n    apply_autocmds(EVENT_ENCODINGCHANGED, NULL, (char_u *)\"\", FALSE, curbuf);\n\n#ifdef FEAT_SPELL\n    // Need to reload spell dictionaries\n    spell_reload();\n#endif\n\n    return NULL;\n}\n\n/*\n * Return the size of the BOM for the current buffer:\n * 0 - no BOM\n * 2 - UCS-2 or UTF-16 BOM\n * 4 - UCS-4 BOM\n * 3 - UTF-8 BOM\n */\n    int\nbomb_size(void)\n{\n    int n = 0;\n\n    if (curbuf->b_p_bomb && !curbuf->b_p_bin)\n    {\n\tif (*curbuf->b_p_fenc == NUL)\n\t{\n\t    if (enc_utf8)\n\t    {\n\t\tif (enc_unicode != 0)\n\t\t    n = enc_unicode;\n\t\telse\n\t\t    n = 3;\n\t    }\n\t}\n\telse if (STRCMP(curbuf->b_p_fenc, \"utf-8\") == 0)\n\t    n = 3;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-2\", 5) == 0\n\t\t|| STRNCMP(curbuf->b_p_fenc, \"utf-16\", 6) == 0)\n\t    n = 2;\n\telse if (STRNCMP(curbuf->b_p_fenc, \"ucs-4\", 5) == 0)\n\t    n = 4;\n    }\n    return n;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Remove all BOM from \"s\" by moving remaining text.\n */\n    void\nremove_bom(char_u *s)\n{\n    if (enc_utf8)\n    {\n\tchar_u *p = s;\n\n\twhile ((p = vim_strbyte(p, 0xef)) != NULL)\n\t{\n\t    if (p[1] == 0xbb && p[2] == 0xbf)\n\t\tSTRMOVE(p, p + 3);\n\t    else\n\t\t++p;\n\t}\n    }\n}\n#endif\n\n/*\n * Get class of pointer:\n * 0 for blank or NUL\n * 1 for punctuation\n * 2 for an (ASCII) word character\n * >2 for other word characters\n */\n    int\nmb_get_class(char_u *p)\n{\n    return mb_get_class_buf(p, curbuf);\n}\n\n    int\nmb_get_class_buf(char_u *p, buf_T *buf)\n{\n    if (MB_BYTE2LEN(p[0]) == 1)\n    {\n\tif (p[0] == NUL || VIM_ISWHITE(p[0]))\n\t    return 0;\n\tif (vim_iswordc_buf(p[0], buf))\n\t    return 2;\n\treturn 1;\n    }\n    if (enc_dbcs != 0 && p[0] != NUL && p[1] != NUL)\n\treturn dbcs_class(p[0], p[1]);\n    if (enc_utf8)\n\treturn utf_class_buf(utf_ptr2char(p), buf);\n    return 0;\n}\n\n/*\n * Get class of a double-byte character.  This always returns 3 or bigger.\n * TODO: Should return 1 for punctuation.\n */\n    int\ndbcs_class(unsigned lead, unsigned trail)\n{\n    switch (enc_dbcs)\n    {\n\t// please add classify routine for your language in here\n\n\tcase DBCS_JPNU:\t// ?\n\tcase DBCS_JPN:\n\t    {\n\t\t// JIS code classification\n\t\tunsigned char lb = lead;\n\t\tunsigned char tb = trail;\n\n\t\t// convert process code to JIS\n# if defined(MSWIN) || defined(WIN32UNIX) || defined(MACOS_X)\n\t\t// process code is SJIS\n\t\tif (lb <= 0x9f)\n\t\t    lb = (lb - 0x81) * 2 + 0x21;\n\t\telse\n\t\t    lb = (lb - 0xc1) * 2 + 0x21;\n\t\tif (tb <= 0x7e)\n\t\t    tb -= 0x1f;\n\t\telse if (tb <= 0x9e)\n\t\t    tb -= 0x20;\n\t\telse\n\t\t{\n\t\t    tb -= 0x7e;\n\t\t    lb += 1;\n\t\t}\n# else\n\t\t/*\n\t\t * XXX: Code page identification can not use with all\n\t\t *\t    system! So, some other encoding information\n\t\t *\t    will be needed.\n\t\t *\t    In japanese: SJIS,EUC,UNICODE,(JIS)\n\t\t *\t    Note that JIS-code system don't use as\n\t\t *\t    process code in most system because it uses\n\t\t *\t    escape sequences(JIS is context depend encoding).\n\t\t */\n\t\t// assume process code is JAPANESE-EUC\n\t\tlb &= 0x7f;\n\t\ttb &= 0x7f;\n# endif\n\t\t// exceptions\n\t\tswitch (lb << 8 | tb)\n\t\t{\n\t\t    case 0x2121: // ZENKAKU space\n\t\t\treturn 0;\n\t\t    case 0x2122: // TOU-TEN (Japanese comma)\n\t\t    case 0x2123: // KU-TEN (Japanese period)\n\t\t    case 0x2124: // ZENKAKU comma\n\t\t    case 0x2125: // ZENKAKU period\n\t\t\treturn 1;\n\t\t    case 0x213c: // prolongedsound handled as KATAKANA\n\t\t\treturn 13;\n\t\t}\n\t\t// sieved by KU code\n\t\tswitch (lb)\n\t\t{\n\t\t    case 0x21:\n\t\t    case 0x22:\n\t\t\t// special symbols\n\t\t\treturn 10;\n\t\t    case 0x23:\n\t\t\t// alphanumeric\n\t\t\treturn 11;\n\t\t    case 0x24:\n\t\t\t// hiragana\n\t\t\treturn 12;\n\t\t    case 0x25:\n\t\t\t// katakana\n\t\t\treturn 13;\n\t\t    case 0x26:\n\t\t\t// greek\n\t\t\treturn 14;\n\t\t    case 0x27:\n\t\t\t// russian\n\t\t\treturn 15;\n\t\t    case 0x28:\n\t\t\t// lines\n\t\t\treturn 16;\n\t\t    default:\n\t\t\t// kanji\n\t\t\treturn 17;\n\t\t}\n\t    }\n\n\tcase DBCS_KORU:\t// ?\n\tcase DBCS_KOR:\n\t    {\n\t\t// KS code classification\n\t\tunsigned char c1 = lead;\n\t\tunsigned char c2 = trail;\n\n\t\t/*\n\t\t * 20 : Hangul\n\t\t * 21 : Hanja\n\t\t * 22 : Symbols\n\t\t * 23 : Alphanumeric/Roman Letter (Full width)\n\t\t * 24 : Hangul Letter(Alphabet)\n\t\t * 25 : Roman Numeral/Greek Letter\n\t\t * 26 : Box Drawings\n\t\t * 27 : Unit Symbols\n\t\t * 28 : Circled/Parenthesized Letter\n\t\t * 29 : Hiragana/Katakana\n\t\t * 30 : Cyrillic Letter\n\t\t */\n\n\t\tif (c1 >= 0xB0 && c1 <= 0xC8)\n\t\t    // Hangul\n\t\t    return 20;\n#if defined(MSWIN) || defined(WIN32UNIX)\n\t\telse if (c1 <= 0xA0 || c2 <= 0xA0)\n\t\t    // Extended Hangul Region : MS UHC(Unified Hangul Code)\n\t\t    // c1: 0x81-0xA0 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xFE\n\t\t    // c1: 0xA1-0xC6 with c2: 0x41-0x5A, 0x61-0x7A, 0x81-0xA0\n\t\t    return 20;\n#endif\n\n\t\telse if (c1 >= 0xCA && c1 <= 0xFD)\n\t\t    // Hanja\n\t\t    return 21;\n\t\telse switch (c1)\n\t\t{\n\t\t    case 0xA1:\n\t\t    case 0xA2:\n\t\t\t// Symbols\n\t\t\treturn 22;\n\t\t    case 0xA3:\n\t\t\t// Alphanumeric\n\t\t\treturn 23;\n\t\t    case 0xA4:\n\t\t\t// Hangul Letter(Alphabet)\n\t\t\treturn 24;\n\t\t    case 0xA5:\n\t\t\t// Roman Numeral/Greek Letter\n\t\t\treturn 25;\n\t\t    case 0xA6:\n\t\t\t// Box Drawings\n\t\t\treturn 26;\n\t\t    case 0xA7:\n\t\t\t// Unit Symbols\n\t\t\treturn 27;\n\t\t    case 0xA8:\n\t\t    case 0xA9:\n\t\t\tif (c2 <= 0xAF)\n\t\t\t    return 25;  // Roman Letter\n\t\t\telse if (c2 >= 0xF6)\n\t\t\t    return 22;  // Symbols\n\t\t\telse\n\t\t\t    // Circled/Parenthesized Letter\n\t\t\t    return 28;\n\t\t    case 0xAA:\n\t\t    case 0xAB:\n\t\t\t// Hiragana/Katakana\n\t\t\treturn 29;\n\t\t    case 0xAC:\n\t\t\t// Cyrillic Letter\n\t\t\treturn 30;\n\t\t}\n\t    }\n\tdefault:\n\t    break;\n    }\n    return 3;\n}\n\n/*\n * mb_char2len() function pointer.\n * Return length in bytes of character \"c\".\n * Returns 1 for a single-byte character.\n */\n    int\nlatin_char2len(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2len(\n    int\t\tc)\n{\n    if (c >= 0x100)\n\treturn 2;\n    return 1;\n}\n\n/*\n * mb_char2bytes() function pointer.\n * Convert a character to its bytes.\n * Returns the length in bytes.\n */\n    int\nlatin_char2bytes(int c, char_u *buf)\n{\n    buf[0] = c;\n    return 1;\n}\n\n    static int\ndbcs_char2bytes(int c, char_u *buf)\n{\n    if (c >= 0x100)\n    {\n\tbuf[0] = (unsigned)c >> 8;\n\tbuf[1] = c;\n\t// Never use a NUL byte, it causes lots of trouble.  It's an invalid\n\t// character anyway.\n\tif (buf[1] == NUL)\n\t    buf[1] = '\\n';\n\treturn 2;\n    }\n    buf[0] = c;\n    return 1;\n}\n\n/*\n * Get byte length of character at \"*p\".  Returns zero when \"*p\" is NUL.\n * Used for mb_ptr2len() when 'encoding' latin.\n */\n    int\nlatin_ptr2len(char_u *p)\n{\n    return *p == NUL ? 0 : 1;\n}\n\n/*\n * Get byte length of character at \"*p\".  Returns zero when \"*p\" is NUL.\n * Used for mb_ptr2len() when 'encoding' DBCS.\n */\n    static int\ndbcs_ptr2len(char_u *p)\n{\n    int\t\tlen;\n\n    if (*p == NUL)\n\treturn 0;\n\n    // if the second byte is missing the length is 1\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\n/*\n * mb_ptr2len_len() function pointer.\n * Like mb_ptr2len(), but limit to read \"size\" bytes.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nlatin_ptr2len_len(char_u *p, int size)\n{\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    return 1;\n}\n\n    static int\ndbcs_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (size == 1)\n\treturn 1;\n    // Check that second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}\n\nstruct interval\n{\n    long first;\n    long last;\n};\n\n/*\n * Return TRUE if \"c\" is in \"table[size / sizeof(struct interval)]\".\n */\n    static int\nintable(struct interval *table, size_t size, int c)\n{\n    int mid, bot, top;\n\n    // first quick check for Latin1 etc. characters\n    if (c < table[0].first)\n\treturn FALSE;\n\n    // binary search in table\n    bot = 0;\n    top = (int)(size / sizeof(struct interval) - 1);\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n// Sorted list of non-overlapping intervals of East Asian Ambiguous\n// characters, generated with ../runtime/tools/unicode.vim.\nstatic struct interval ambiguous[] =\n{\n    {0x00a1, 0x00a1},\n    {0x00a4, 0x00a4},\n    {0x00a7, 0x00a8},\n    {0x00aa, 0x00aa},\n    {0x00ad, 0x00ae},\n    {0x00b0, 0x00b4},\n    {0x00b6, 0x00ba},\n    {0x00bc, 0x00bf},\n    {0x00c6, 0x00c6},\n    {0x00d0, 0x00d0},\n    {0x00d7, 0x00d8},\n    {0x00de, 0x00e1},\n    {0x00e6, 0x00e6},\n    {0x00e8, 0x00ea},\n    {0x00ec, 0x00ed},\n    {0x00f0, 0x00f0},\n    {0x00f2, 0x00f3},\n    {0x00f7, 0x00fa},\n    {0x00fc, 0x00fc},\n    {0x00fe, 0x00fe},\n    {0x0101, 0x0101},\n    {0x0111, 0x0111},\n    {0x0113, 0x0113},\n    {0x011b, 0x011b},\n    {0x0126, 0x0127},\n    {0x012b, 0x012b},\n    {0x0131, 0x0133},\n    {0x0138, 0x0138},\n    {0x013f, 0x0142},\n    {0x0144, 0x0144},\n    {0x0148, 0x014b},\n    {0x014d, 0x014d},\n    {0x0152, 0x0153},\n    {0x0166, 0x0167},\n    {0x016b, 0x016b},\n    {0x01ce, 0x01ce},\n    {0x01d0, 0x01d0},\n    {0x01d2, 0x01d2},\n    {0x01d4, 0x01d4},\n    {0x01d6, 0x01d6},\n    {0x01d8, 0x01d8},\n    {0x01da, 0x01da},\n    {0x01dc, 0x01dc},\n    {0x0251, 0x0251},\n    {0x0261, 0x0261},\n    {0x02c4, 0x02c4},\n    {0x02c7, 0x02c7},\n    {0x02c9, 0x02cb},\n    {0x02cd, 0x02cd},\n    {0x02d0, 0x02d0},\n    {0x02d8, 0x02db},\n    {0x02dd, 0x02dd},\n    {0x02df, 0x02df},\n    {0x0300, 0x036f},\n    {0x0391, 0x03a1},\n    {0x03a3, 0x03a9},\n    {0x03b1, 0x03c1},\n    {0x03c3, 0x03c9},\n    {0x0401, 0x0401},\n    {0x0410, 0x044f},\n    {0x0451, 0x0451},\n    {0x2010, 0x2010},\n    {0x2013, 0x2016},\n    {0x2018, 0x2019},\n    {0x201c, 0x201d},\n    {0x2020, 0x2022},\n    {0x2024, 0x2027},\n    {0x2030, 0x2030},\n    {0x2032, 0x2033},\n    {0x2035, 0x2035},\n    {0x203b, 0x203b},\n    {0x203e, 0x203e},\n    {0x2074, 0x2074},\n    {0x207f, 0x207f},\n    {0x2081, 0x2084},\n    {0x20ac, 0x20ac},\n    {0x2103, 0x2103},\n    {0x2105, 0x2105},\n    {0x2109, 0x2109},\n    {0x2113, 0x2113},\n    {0x2116, 0x2116},\n    {0x2121, 0x2122},\n    {0x2126, 0x2126},\n    {0x212b, 0x212b},\n    {0x2153, 0x2154},\n    {0x215b, 0x215e},\n    {0x2160, 0x216b},\n    {0x2170, 0x2179},\n    {0x2189, 0x2189},\n    {0x2190, 0x2199},\n    {0x21b8, 0x21b9},\n    {0x21d2, 0x21d2},\n    {0x21d4, 0x21d4},\n    {0x21e7, 0x21e7},\n    {0x2200, 0x2200},\n    {0x2202, 0x2203},\n    {0x2207, 0x2208},\n    {0x220b, 0x220b},\n    {0x220f, 0x220f},\n    {0x2211, 0x2211},\n    {0x2215, 0x2215},\n    {0x221a, 0x221a},\n    {0x221d, 0x2220},\n    {0x2223, 0x2223},\n    {0x2225, 0x2225},\n    {0x2227, 0x222c},\n    {0x222e, 0x222e},\n    {0x2234, 0x2237},\n    {0x223c, 0x223d},\n    {0x2248, 0x2248},\n    {0x224c, 0x224c},\n    {0x2252, 0x2252},\n    {0x2260, 0x2261},\n    {0x2264, 0x2267},\n    {0x226a, 0x226b},\n    {0x226e, 0x226f},\n    {0x2282, 0x2283},\n    {0x2286, 0x2287},\n    {0x2295, 0x2295},\n    {0x2299, 0x2299},\n    {0x22a5, 0x22a5},\n    {0x22bf, 0x22bf},\n    {0x2312, 0x2312},\n    {0x2460, 0x24e9},\n    {0x24eb, 0x254b},\n    {0x2550, 0x2573},\n    {0x2580, 0x258f},\n    {0x2592, 0x2595},\n    {0x25a0, 0x25a1},\n    {0x25a3, 0x25a9},\n    {0x25b2, 0x25b3},\n    {0x25b6, 0x25b7},\n    {0x25bc, 0x25bd},\n    {0x25c0, 0x25c1},\n    {0x25c6, 0x25c8},\n    {0x25cb, 0x25cb},\n    {0x25ce, 0x25d1},\n    {0x25e2, 0x25e5},\n    {0x25ef, 0x25ef},\n    {0x2605, 0x2606},\n    {0x2609, 0x2609},\n    {0x260e, 0x260f},\n    {0x261c, 0x261c},\n    {0x261e, 0x261e},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2660, 0x2661},\n    {0x2663, 0x2665},\n    {0x2667, 0x266a},\n    {0x266c, 0x266d},\n    {0x266f, 0x266f},\n    {0x269e, 0x269f},\n    {0x26bf, 0x26bf},\n    {0x26c6, 0x26cd},\n    {0x26cf, 0x26d3},\n    {0x26d5, 0x26e1},\n    {0x26e3, 0x26e3},\n    {0x26e8, 0x26e9},\n    {0x26eb, 0x26f1},\n    {0x26f4, 0x26f4},\n    {0x26f6, 0x26f9},\n    {0x26fb, 0x26fc},\n    {0x26fe, 0x26ff},\n    {0x273d, 0x273d},\n    {0x2776, 0x277f},\n    {0x2b56, 0x2b59},\n    {0x3248, 0x324f},\n    {0xe000, 0xf8ff},\n    {0xfe00, 0xfe0f},\n    {0xfffd, 0xfffd},\n    {0x1f100, 0x1f10a},\n    {0x1f110, 0x1f12d},\n    {0x1f130, 0x1f169},\n    {0x1f170, 0x1f18d},\n    {0x1f18f, 0x1f190},\n    {0x1f19b, 0x1f1ac},\n    {0xe0100, 0xe01ef},\n    {0xf0000, 0xffffd},\n    {0x100000, 0x10fffd}\n};\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_char2cells() with different argument type for libvterm.\n */\n    int\nutf_uint2cells(UINT32_T c)\n{\n    if (c >= 0x100 && utf_iscomposing((int)c))\n\treturn 0;\n    return utf_char2cells((int)c);\n}\n#endif\n\n/*\n * For UTF-8 character \"c\" return 2 for a double-width character, 1 for others.\n * Returns 4 or 6 for an unprintable character.\n * Is only correct for characters >= 0x80.\n * When p_ambw is \"double\", return 2 for a character with East Asian Width\n * class 'A'(mbiguous).\n */\n    int\nutf_char2cells(int c)\n{\n    // Sorted list of non-overlapping intervals of East Asian double width\n    // characters, generated with ../runtime/tools/unicode.vim.\n    static struct interval doublewidth[] =\n    {\n\t{0x1100, 0x115f},\n\t{0x231a, 0x231b},\n\t{0x2329, 0x232a},\n\t{0x23e9, 0x23ec},\n\t{0x23f0, 0x23f0},\n\t{0x23f3, 0x23f3},\n\t{0x25fd, 0x25fe},\n\t{0x2614, 0x2615},\n\t{0x2648, 0x2653},\n\t{0x267f, 0x267f},\n\t{0x2693, 0x2693},\n\t{0x26a1, 0x26a1},\n\t{0x26aa, 0x26ab},\n\t{0x26bd, 0x26be},\n\t{0x26c4, 0x26c5},\n\t{0x26ce, 0x26ce},\n\t{0x26d4, 0x26d4},\n\t{0x26ea, 0x26ea},\n\t{0x26f2, 0x26f3},\n\t{0x26f5, 0x26f5},\n\t{0x26fa, 0x26fa},\n\t{0x26fd, 0x26fd},\n\t{0x2705, 0x2705},\n\t{0x270a, 0x270b},\n\t{0x2728, 0x2728},\n\t{0x274c, 0x274c},\n\t{0x274e, 0x274e},\n\t{0x2753, 0x2755},\n\t{0x2757, 0x2757},\n\t{0x2795, 0x2797},\n\t{0x27b0, 0x27b0},\n\t{0x27bf, 0x27bf},\n\t{0x2b1b, 0x2b1c},\n\t{0x2b50, 0x2b50},\n\t{0x2b55, 0x2b55},\n\t{0x2e80, 0x2e99},\n\t{0x2e9b, 0x2ef3},\n\t{0x2f00, 0x2fd5},\n\t{0x2ff0, 0x2ffb},\n\t{0x3000, 0x303e},\n\t{0x3041, 0x3096},\n\t{0x3099, 0x30ff},\n\t{0x3105, 0x312f},\n\t{0x3131, 0x318e},\n\t{0x3190, 0x31e3},\n\t{0x31f0, 0x321e},\n\t{0x3220, 0x3247},\n\t{0x3250, 0x4dbf},\n\t{0x4e00, 0xa48c},\n\t{0xa490, 0xa4c6},\n\t{0xa960, 0xa97c},\n\t{0xac00, 0xd7a3},\n\t{0xf900, 0xfaff},\n\t{0xfe10, 0xfe19},\n\t{0xfe30, 0xfe52},\n\t{0xfe54, 0xfe66},\n\t{0xfe68, 0xfe6b},\n\t{0xff01, 0xff60},\n\t{0xffe0, 0xffe6},\n\t{0x16fe0, 0x16fe3},\n\t{0x16ff0, 0x16ff1},\n\t{0x17000, 0x187f7},\n\t{0x18800, 0x18cd5},\n\t{0x18d00, 0x18d08},\n\t{0x1b000, 0x1b11e},\n\t{0x1b150, 0x1b152},\n\t{0x1b164, 0x1b167},\n\t{0x1b170, 0x1b2fb},\n\t{0x1f004, 0x1f004},\n\t{0x1f0cf, 0x1f0cf},\n\t{0x1f18e, 0x1f18e},\n\t{0x1f191, 0x1f19a},\n\t{0x1f200, 0x1f202},\n\t{0x1f210, 0x1f23b},\n\t{0x1f240, 0x1f248},\n\t{0x1f250, 0x1f251},\n\t{0x1f260, 0x1f265},\n\t{0x1f300, 0x1f320},\n\t{0x1f32d, 0x1f335},\n\t{0x1f337, 0x1f37c},\n\t{0x1f37e, 0x1f393},\n\t{0x1f3a0, 0x1f3ca},\n\t{0x1f3cf, 0x1f3d3},\n\t{0x1f3e0, 0x1f3f0},\n\t{0x1f3f4, 0x1f3f4},\n\t{0x1f3f8, 0x1f43e},\n\t{0x1f440, 0x1f440},\n\t{0x1f442, 0x1f4fc},\n\t{0x1f4ff, 0x1f53d},\n\t{0x1f54b, 0x1f54e},\n\t{0x1f550, 0x1f567},\n\t{0x1f57a, 0x1f57a},\n\t{0x1f595, 0x1f596},\n\t{0x1f5a4, 0x1f5a4},\n\t{0x1f5fb, 0x1f64f},\n\t{0x1f680, 0x1f6c5},\n\t{0x1f6cc, 0x1f6cc},\n\t{0x1f6d0, 0x1f6d2},\n\t{0x1f6d5, 0x1f6d7},\n\t{0x1f6eb, 0x1f6ec},\n\t{0x1f6f4, 0x1f6fc},\n\t{0x1f7e0, 0x1f7eb},\n\t{0x1f90c, 0x1f93a},\n\t{0x1f93c, 0x1f945},\n\t{0x1f947, 0x1f978},\n\t{0x1f97a, 0x1f9cb},\n\t{0x1f9cd, 0x1f9ff},\n\t{0x1fa70, 0x1fa74},\n\t{0x1fa78, 0x1fa7a},\n\t{0x1fa80, 0x1fa86},\n\t{0x1fa90, 0x1faa8},\n\t{0x1fab0, 0x1fab6},\n\t{0x1fac0, 0x1fac2},\n\t{0x1fad0, 0x1fad6},\n\t{0x20000, 0x2fffd},\n\t{0x30000, 0x3fffd}\n    };\n\n    // Sorted list of non-overlapping intervals of Emoji characters that don't\n    // have ambiguous or double width,\n    // based on http://unicode.org/emoji/charts/emoji-list.html\n    static struct interval emoji_wide[] =\n    {\n\t{0x23ed, 0x23ef},\n\t{0x23f1, 0x23f2},\n\t{0x23f8, 0x23fa},\n\t{0x24c2, 0x24c2},\n\t{0x261d, 0x261d},\n\t{0x26c8, 0x26c8},\n\t{0x26cf, 0x26cf},\n\t{0x26d1, 0x26d1},\n\t{0x26d3, 0x26d3},\n\t{0x26e9, 0x26e9},\n\t{0x26f0, 0x26f1},\n\t{0x26f7, 0x26f9},\n\t{0x270c, 0x270d},\n\t{0x2934, 0x2935},\n\t{0x1f170, 0x1f189},\n\t{0x1f1e6, 0x1f1ff},\n\t{0x1f321, 0x1f321},\n\t{0x1f324, 0x1f32c},\n\t{0x1f336, 0x1f336},\n\t{0x1f37d, 0x1f37d},\n\t{0x1f396, 0x1f397},\n\t{0x1f399, 0x1f39b},\n\t{0x1f39e, 0x1f39f},\n\t{0x1f3cb, 0x1f3ce},\n\t{0x1f3d4, 0x1f3df},\n\t{0x1f3f3, 0x1f3f5},\n\t{0x1f3f7, 0x1f3f7},\n\t{0x1f43f, 0x1f43f},\n\t{0x1f441, 0x1f441},\n\t{0x1f4fd, 0x1f4fd},\n\t{0x1f549, 0x1f54a},\n\t{0x1f56f, 0x1f570},\n\t{0x1f573, 0x1f579},\n\t{0x1f587, 0x1f587},\n\t{0x1f58a, 0x1f58d},\n\t{0x1f590, 0x1f590},\n\t{0x1f5a5, 0x1f5a5},\n\t{0x1f5a8, 0x1f5a8},\n\t{0x1f5b1, 0x1f5b2},\n\t{0x1f5bc, 0x1f5bc},\n\t{0x1f5c2, 0x1f5c4},\n\t{0x1f5d1, 0x1f5d3},\n\t{0x1f5dc, 0x1f5de},\n\t{0x1f5e1, 0x1f5e1},\n\t{0x1f5e3, 0x1f5e3},\n\t{0x1f5e8, 0x1f5e8},\n\t{0x1f5ef, 0x1f5ef},\n\t{0x1f5f3, 0x1f5f3},\n\t{0x1f5fa, 0x1f5fa},\n\t{0x1f6cb, 0x1f6cf},\n\t{0x1f6e0, 0x1f6e5},\n\t{0x1f6e9, 0x1f6e9},\n\t{0x1f6f0, 0x1f6f0},\n\t{0x1f6f3, 0x1f6f3}\n\n#ifdef MACOS_X\n\t// Include SF Symbols characters, which should be rendered as\n\t// double-width. All of them are in the Supplementary Private Use\n\t// Area-B range. The exact range was determined by downloading the \"SF\n\t// Symbols\" app from Apple, and then selecting all symbols, copying\n\t// them out, and inspecting the unicode values of them.\n\t, {0x100000, 0x100d7f}\n#endif\n    };\n\n    if (c >= 0x100)\n    {\n#if defined(FEAT_EVAL) || defined(USE_WCHAR_FUNCTIONS)\n\tint\tn;\n#endif\n\n#ifdef FEAT_EVAL\n\tn = cw_value(c);\n\tif (n != 0)\n\t    return n;\n#endif\n\n#ifdef USE_WCHAR_FUNCTIONS\n\t/*\n\t * Assume the library function wcwidth() works better than our own\n\t * stuff.  It should return 1 for ambiguous width chars!\n\t */\n\tn = wcwidth(c);\n\n\tif (n < 0)\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (n > 1)\n\t    return n;\n#else\n\tif (!utf_printable(c))\n\t    return 6;\t\t// unprintable, displays <xxxx>\n\tif (intable(doublewidth, sizeof(doublewidth), c))\n\t    return 2;\n#endif\n\tif (p_emoji && intable(emoji_wide, sizeof(emoji_wide), c))\n\t    return 2;\n    }\n\n    // Characters below 0x100 are influenced by 'isprint' option\n    else if (c >= 0x80 && !vim_isprintc(c))\n\treturn 4;\t\t// unprintable, displays <xx>\n\n    if (c >= 0x80 && *p_ambw == 'd' && intable(ambiguous, sizeof(ambiguous), c))\n\treturn 2;\n\n    return 1;\n}\n\n/*\n * mb_ptr2cells() function pointer.\n * Return the number of display cells character at \"*p\" occupies.\n * This doesn't take care of unprintable characters, use ptr2cells() for that.\n */\n    int\nlatin_ptr2cells(char_u *p UNUSED)\n{\n    return 1;\n}\n\n    int\nutf_ptr2cells(\n    char_u\t*p)\n{\n    int\t\tc;\n\n    // Need to convert to a character number.\n    if (*p >= 0x80)\n    {\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    int\ndbcs_ptr2cells(char_u *p)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_ptr2cells_len() function pointer.\n * Like mb_ptr2cells(), but limit string length to \"size\".\n * For an empty string or truncated character returns 1.\n */\n    int\nlatin_ptr2cells_len(char_u *p UNUSED, int size UNUSED)\n{\n    return 1;\n}\n\n    static int\nutf_ptr2cells_len(char_u *p, int size)\n{\n    int\t\tc;\n\n    // Need to convert to a wide character.\n    if (size > 0 && *p >= 0x80)\n    {\n\tif (utf_ptr2len_len(p, size) < utf8len_tab[*p])\n\t    return 1;  // truncated\n\tc = utf_ptr2char(p);\n\t// An illegal byte is displayed as <xx>.\n\tif (utf_ptr2len(p) == 1 || c == NUL)\n\t    return 4;\n\t// If the char is ASCII it must be an overlong sequence.\n\tif (c < 0x80)\n\t    return char2cells(c);\n\treturn utf_char2cells(c);\n    }\n    return 1;\n}\n\n    static int\ndbcs_ptr2cells_len(char_u *p, int size)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (size <= 1 || (enc_dbcs == DBCS_JPNU && *p == 0x8e))\n\treturn 1;\n    return MB_BYTE2LEN(*p);\n}\n\n/*\n * mb_char2cells() function pointer.\n * Return the number of display cells character \"c\" occupies.\n * Only takes care of multi-byte chars, not \"^C\" and such.\n */\n    int\nlatin_char2cells(int c UNUSED)\n{\n    return 1;\n}\n\n    static int\ndbcs_char2cells(int c)\n{\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ((unsigned)c >> 8) == 0x8e)\n\treturn 1;\n    // use the first byte\n    return MB_BYTE2LEN((unsigned)c >> 8);\n}\n\n/*\n * Return the number of cells occupied by string \"p\".\n * Stop at a NUL character.  When \"len\" >= 0 stop at character \"p[len]\".\n */\n    int\nmb_string2cells(char_u *p, int len)\n{\n    int i;\n    int clen = 0;\n\n    for (i = 0; (len < 0 || i < len) && p[i] != NUL; i += (*mb_ptr2len)(p + i))\n\tclen += (*mb_ptr2cells)(p + i);\n    return clen;\n}\n\n/*\n * mb_off2cells() function pointer.\n * Return number of display cells for char at ScreenLines[off].\n * We make sure that the offset used is less than \"max_off\".\n */\n    int\nlatin_off2cells(unsigned off UNUSED, unsigned max_off UNUSED)\n{\n    return 1;\n}\n\n    int\ndbcs_off2cells(unsigned off, unsigned max_off)\n{\n    // never check beyond end of the line\n    if (off >= max_off)\n\treturn 1;\n\n    // Number of cells is equal to number of bytes, except for euc-jp when\n    // the first byte is 0x8e.\n    if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)\n\treturn 1;\n    return MB_BYTE2LEN(ScreenLines[off]);\n}\n\n    int\nutf_off2cells(unsigned off, unsigned max_off)\n{\n    return (off + 1 < max_off && ScreenLines[off + 1] == 0) ? 2 : 1;\n}\n\n/*\n * mb_ptr2char() function pointer.\n * Convert a byte sequence into a character.\n */\n    int\nlatin_ptr2char(char_u *p)\n{\n    return *p;\n}\n\n    static int\ndbcs_ptr2char(char_u *p)\n{\n    if (MB_BYTE2LEN(*p) > 1 && p[1] != NUL)\n\treturn (p[0] << 8) + p[1];\n    return *p;\n}\n\n/*\n * Convert a UTF-8 byte sequence to a character number.\n * If the sequence is illegal or truncated by a NUL the first byte is\n * returned.\n * For an overlong sequence this may return zero.\n * Does not include composing characters, of course.\n */\n    int\nutf_ptr2char(char_u *p)\n{\n    int\t\tlen;\n\n    if (p[0] < 0x80)\t// be quick for ASCII\n\treturn p[0];\n\n    len = utf8len_tab_zero[p[0]];\n    if (len > 1 && (p[1] & 0xc0) == 0x80)\n    {\n\tif (len == 2)\n\t    return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);\n\tif ((p[2] & 0xc0) == 0x80)\n\t{\n\t    if (len == 3)\n\t\treturn ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6)\n\t\t    + (p[2] & 0x3f);\n\t    if ((p[3] & 0xc0) == 0x80)\n\t    {\n\t\tif (len == 4)\n\t\t    return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12)\n\t\t\t+ ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);\n\t\tif ((p[4] & 0xc0) == 0x80)\n\t\t{\n\t\t    if (len == 5)\n\t\t\treturn ((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18)\n\t\t\t    + ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6)\n\t\t\t    + (p[4] & 0x3f);\n\t\t    if ((p[5] & 0xc0) == 0x80 && len == 6)\n\t\t\treturn ((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24)\n\t\t\t    + ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12)\n\t\t\t    + ((p[4] & 0x3f) << 6) + (p[5] & 0x3f);\n\t\t}\n\t    }\n\t}\n    }\n    // Illegal value, just return the first byte\n    return p[0];\n}\n\n/*\n * Convert a UTF-8 byte sequence to a wide character.\n * String is assumed to be terminated by NUL or after \"n\" bytes, whichever\n * comes first.\n * The function is safe in the sense that it never accesses memory beyond the\n * first \"n\" bytes of \"s\".\n *\n * On success, returns decoded codepoint, advances \"s\" to the beginning of\n * next character and decreases \"n\" accordingly.\n *\n * If end of string was reached, returns 0 and, if \"n\" > 0, advances \"s\" past\n * NUL byte.\n *\n * If byte sequence is illegal or incomplete, returns -1 and does not advance\n * \"s\".\n */\n    static int\nutf_safe_read_char_adv(char_u **s, size_t *n)\n{\n    int\t\tc, k;\n\n    if (*n == 0) // end of buffer\n\treturn 0;\n\n    k = utf8len_tab_zero[**s];\n\n    if (k == 1)\n    {\n\t// ASCII character or NUL\n\t(*n)--;\n\treturn *(*s)++;\n    }\n\n    if ((size_t)k <= *n)\n    {\n\t// We have a multibyte sequence and it isn't truncated by buffer\n\t// limits so utf_ptr2char() is safe to use. Or the first byte is\n\t// illegal (k=0), and it's also safe to use utf_ptr2char().\n\tc = utf_ptr2char(*s);\n\n\t// On failure, utf_ptr2char() returns the first byte, so here we\n\t// check equality with the first byte. The only non-ASCII character\n\t// which equals the first byte of its own UTF-8 representation is\n\t// U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.\n\t// It's safe even if n=1, else we would have k=2 > n.\n\tif (c != (int)(**s) || (c == 0xC3 && (*s)[1] == 0x83))\n\t{\n\t    // byte sequence was successfully decoded\n\t    *s += k;\n\t    *n -= k;\n\t    return c;\n\t}\n    }\n\n    // byte sequence is incomplete or illegal\n    return -1;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are skipped!\n */\n    int\nmb_ptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    *pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n/*\n * Get character at **pp and advance *pp to the next character.\n * Note: composing characters are returned as separate characters.\n */\n    int\nmb_cptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    if (enc_utf8)\n\t*pp += utf_ptr2len(*pp);\n    else\n\t*pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\n/*\n * Check if the character pointed to by \"p2\" is a composing character when it\n * comes after \"p1\".  For Arabic sometimes \"ab\" is replaced with \"c\", which\n * behaves like a composing character.\n */\n    int\nutf_composinglike(char_u *p1, char_u *p2)\n{\n    int\t\tc2;\n\n    c2 = utf_ptr2char(p2);\n    if (utf_iscomposing(c2))\n\treturn TRUE;\n    if (!arabic_maycombine(c2))\n\treturn FALSE;\n    return arabic_combine(utf_ptr2char(p1), c2);\n}\n#endif\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.\n */\n    int\nutfc_ptr2char(\n    char_u\t*p,\n    int\t\t*pcc)\t// return: composing chars, last one is 0\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len(p);\n\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len(p + len);\n\t    if (p[len] < 0x80 || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO\n * composing characters.  Use no more than p[maxlen].\n */\n    int\nutfc_ptr2char_len(\n    char_u\t*p,\n    int\t\t*pcc,\t// return: composing chars, last one is 0\n    int\t\tmaxlen)\n{\n    int\t\tlen;\n    int\t\tc;\n    int\t\tcc;\n    int\t\ti = 0;\n\n    c = utf_ptr2char(p);\n    len = utf_ptr2len_len(p, maxlen);\n    // Only accept a composing char when the first char isn't illegal.\n    if ((len > 1 || *p < 0x80)\n\t    && len < maxlen\n\t    && p[len] >= 0x80\n\t    && UTF_COMPOSINGLIKE(p, p + len))\n    {\n\tcc = utf_ptr2char(p + len);\n\tfor (;;)\n\t{\n\t    pcc[i++] = cc;\n\t    if (i == MAX_MCO)\n\t\tbreak;\n\t    len += utf_ptr2len_len(p + len, maxlen - len);\n\t    if (len >= maxlen\n\t\t    || p[len] < 0x80\n\t\t    || !utf_iscomposing(cc = utf_ptr2char(p + len)))\n\t\tbreak;\n\t}\n    }\n\n    if (i < MAX_MCO)\t// last composing char must be 0\n\tpcc[i] = 0;\n\n    return c;\n}\n\n/*\n * Convert the character at screen position \"off\" to a sequence of bytes.\n * Includes the composing characters.\n * \"buf\" must at least have the length MB_MAXBYTES + 1.\n * Only to be used when ScreenLinesUC[off] != 0.\n * Returns the produced number of bytes.\n */\n    int\nutfc_char2bytes(int off, char_u *buf)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    len = utf_char2bytes(ScreenLinesUC[off], buf);\n    for (i = 0; i < Screen_mco; ++i)\n    {\n\tif (ScreenLinesC[i][off] == 0)\n\t    break;\n\tlen += utf_char2bytes(ScreenLinesC[i][off], buf + len);\n    }\n    return len;\n}\n\n/*\n * Get the length of a UTF-8 byte sequence, not including any following\n * composing characters.\n * Returns 0 for \"\".\n * Returns 1 for an illegal byte sequence.\n */\n    int\nutf_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\ti;\n\n    if (*p == NUL)\n\treturn 0;\n    len = utf8len_tab[*p];\n    for (i = 1; i < len; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return length of UTF-8 character, obtained from the first byte.\n * \"b\" must be between 0 and 255!\n * Returns 1 for an invalid first byte value.\n */\n    int\nutf_byte2len(int b)\n{\n    return utf8len_tab[b];\n}\n\n/*\n * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any\n * following composing characters.\n * Returns 1 for \"\".\n * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).\n * Returns number > \"size\" for an incomplete byte sequence.\n * Never returns zero.\n */\n    int\nutf_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n    int\t\ti;\n    int\t\tm;\n\n    len = utf8len_tab[*p];\n    if (len == 1)\n\treturn 1;\t// NUL, ascii or illegal lead byte\n    if (len > size)\n\tm = size;\t// incomplete byte sequence.\n    else\n\tm = len;\n    for (i = 1; i < m; ++i)\n\tif ((p[i] & 0xc0) != 0x80)\n\t    return 1;\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p\" takes.\n * This includes following composing characters.\n * Returns zero for NUL.\n */\n    int\nutfc_ptr2len(char_u *p)\n{\n    int\t\tlen;\n    int\t\tb0 = *p;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (b0 == NUL)\n\treturn 0;\n    if (b0 < 0x80 && p[1] < 0x80)\t// be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len(p);\n\n    // Check for illegal byte.\n    if (len == 1 && b0 >= 0x80)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    for (;;)\n    {\n\tif (p[len] < 0x80 || !UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    return len;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += utf_ptr2len(p + len);\n    }\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\"\n * takes.  This includes following composing characters.\n * Returns 0 for an empty string.\n * Returns 1 for an illegal char or an incomplete byte sequence.\n */\n    int\nutfc_ptr2len_len(char_u *p, int size)\n{\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    int\t\tprevlen;\n#endif\n\n    if (size < 1 || *p == NUL)\n\treturn 0;\n    if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) // be quick for ASCII\n\treturn 1;\n\n    // Skip over first UTF-8 char, stopping at a NUL byte.\n    len = utf_ptr2len_len(p, size);\n\n    // Check for illegal byte and incomplete byte sequence.\n    if ((len == 1 && p[0] >= 0x80) || len > size)\n\treturn 1;\n\n    /*\n     * Check for composing characters.  We can handle only the first six, but\n     * skip all of them (otherwise the cursor would get stuck).\n     */\n#ifdef FEAT_ARABIC\n    prevlen = 0;\n#endif\n    while (len < size)\n    {\n\tint\tlen_next_char;\n\n\tif (p[len] < 0x80)\n\t    break;\n\n\t/*\n\t * Next character length should not go beyond size to ensure that\n\t * UTF_COMPOSINGLIKE(...) does not read beyond size.\n\t */\n\tlen_next_char = utf_ptr2len_len(p + len, size - len);\n\tif (len_next_char > size - len)\n\t    break;\n\n\tif (!UTF_COMPOSINGLIKE(p + prevlen, p + len))\n\t    break;\n\n\t// Skip over composing char\n#ifdef FEAT_ARABIC\n\tprevlen = len;\n#endif\n\tlen += len_next_char;\n    }\n    return len;\n}\n\n/*\n * Return the number of bytes the UTF-8 encoding of character \"c\" takes.\n * This does not include composing characters.\n */\n    int\nutf_char2len(int c)\n{\n    if (c < 0x80)\n\treturn 1;\n    if (c < 0x800)\n\treturn 2;\n    if (c < 0x10000)\n\treturn 3;\n    if (c < 0x200000)\n\treturn 4;\n    if (c < 0x4000000)\n\treturn 5;\n    return 6;\n}\n\n/*\n * Convert Unicode character \"c\" to UTF-8 string in \"buf[]\".\n * Returns the number of bytes.\n */\n    int\nutf_char2bytes(int c, char_u *buf)\n{\n    if (c < 0x80)\t\t// 7 bits\n    {\n\tbuf[0] = c;\n\treturn 1;\n    }\n    if (c < 0x800)\t\t// 11 bits\n    {\n\tbuf[0] = 0xc0 + ((unsigned)c >> 6);\n\tbuf[1] = 0x80 + (c & 0x3f);\n\treturn 2;\n    }\n    if (c < 0x10000)\t\t// 16 bits\n    {\n\tbuf[0] = 0xe0 + ((unsigned)c >> 12);\n\tbuf[1] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[2] = 0x80 + (c & 0x3f);\n\treturn 3;\n    }\n    if (c < 0x200000)\t\t// 21 bits\n    {\n\tbuf[0] = 0xf0 + ((unsigned)c >> 18);\n\tbuf[1] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[3] = 0x80 + (c & 0x3f);\n\treturn 4;\n    }\n    if (c < 0x4000000)\t\t// 26 bits\n    {\n\tbuf[0] = 0xf8 + ((unsigned)c >> 24);\n\tbuf[1] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n\tbuf[2] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n\tbuf[3] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n\tbuf[4] = 0x80 + (c & 0x3f);\n\treturn 5;\n    }\n\t\t\t\t// 31 bits\n    buf[0] = 0xfc + ((unsigned)c >> 30);\n    buf[1] = 0x80 + (((unsigned)c >> 24) & 0x3f);\n    buf[2] = 0x80 + (((unsigned)c >> 18) & 0x3f);\n    buf[3] = 0x80 + (((unsigned)c >> 12) & 0x3f);\n    buf[4] = 0x80 + (((unsigned)c >> 6) & 0x3f);\n    buf[5] = 0x80 + (c & 0x3f);\n    return 6;\n}\n\n#if defined(FEAT_TERMINAL) || defined(PROTO)\n/*\n * utf_iscomposing() with different argument type for libvterm.\n */\n    int\nutf_iscomposing_uint(UINT32_T c)\n{\n    return utf_iscomposing((int)c);\n}\n#endif\n\n/*\n * Return TRUE if \"c\" is a composing UTF-8 character.  This means it will be\n * drawn on top of the preceding character.\n * Based on code from Markus Kuhn.\n */\n    int\nutf_iscomposing(int c)\n{\n    // Sorted list of non-overlapping intervals.\n    // Generated by ../runtime/tools/unicode.vim.\n    static struct interval combining[] =\n    {\n\t{0x0300, 0x036f},\n\t{0x0483, 0x0489},\n\t{0x0591, 0x05bd},\n\t{0x05bf, 0x05bf},\n\t{0x05c1, 0x05c2},\n\t{0x05c4, 0x05c5},\n\t{0x05c7, 0x05c7},\n\t{0x0610, 0x061a},\n\t{0x064b, 0x065f},\n\t{0x0670, 0x0670},\n\t{0x06d6, 0x06dc},\n\t{0x06df, 0x06e4},\n\t{0x06e7, 0x06e8},\n\t{0x06ea, 0x06ed},\n\t{0x0711, 0x0711},\n\t{0x0730, 0x074a},\n\t{0x07a6, 0x07b0},\n\t{0x07eb, 0x07f3},\n\t{0x07fd, 0x07fd},\n\t{0x0816, 0x0819},\n\t{0x081b, 0x0823},\n\t{0x0825, 0x0827},\n\t{0x0829, 0x082d},\n\t{0x0859, 0x085b},\n\t{0x08d3, 0x08e1},\n\t{0x08e3, 0x0903},\n\t{0x093a, 0x093c},\n\t{0x093e, 0x094f},\n\t{0x0951, 0x0957},\n\t{0x0962, 0x0963},\n\t{0x0981, 0x0983},\n\t{0x09bc, 0x09bc},\n\t{0x09be, 0x09c4},\n\t{0x09c7, 0x09c8},\n\t{0x09cb, 0x09cd},\n\t{0x09d7, 0x09d7},\n\t{0x09e2, 0x09e3},\n\t{0x09fe, 0x09fe},\n\t{0x0a01, 0x0a03},\n\t{0x0a3c, 0x0a3c},\n\t{0x0a3e, 0x0a42},\n\t{0x0a47, 0x0a48},\n\t{0x0a4b, 0x0a4d},\n\t{0x0a51, 0x0a51},\n\t{0x0a70, 0x0a71},\n\t{0x0a75, 0x0a75},\n\t{0x0a81, 0x0a83},\n\t{0x0abc, 0x0abc},\n\t{0x0abe, 0x0ac5},\n\t{0x0ac7, 0x0ac9},\n\t{0x0acb, 0x0acd},\n\t{0x0ae2, 0x0ae3},\n\t{0x0afa, 0x0aff},\n\t{0x0b01, 0x0b03},\n\t{0x0b3c, 0x0b3c},\n\t{0x0b3e, 0x0b44},\n\t{0x0b47, 0x0b48},\n\t{0x0b4b, 0x0b4d},\n\t{0x0b55, 0x0b57},\n\t{0x0b62, 0x0b63},\n\t{0x0b82, 0x0b82},\n\t{0x0bbe, 0x0bc2},\n\t{0x0bc6, 0x0bc8},\n\t{0x0bca, 0x0bcd},\n\t{0x0bd7, 0x0bd7},\n\t{0x0c00, 0x0c04},\n\t{0x0c3e, 0x0c44},\n\t{0x0c46, 0x0c48},\n\t{0x0c4a, 0x0c4d},\n\t{0x0c55, 0x0c56},\n\t{0x0c62, 0x0c63},\n\t{0x0c81, 0x0c83},\n\t{0x0cbc, 0x0cbc},\n\t{0x0cbe, 0x0cc4},\n\t{0x0cc6, 0x0cc8},\n\t{0x0cca, 0x0ccd},\n\t{0x0cd5, 0x0cd6},\n\t{0x0ce2, 0x0ce3},\n\t{0x0d00, 0x0d03},\n\t{0x0d3b, 0x0d3c},\n\t{0x0d3e, 0x0d44},\n\t{0x0d46, 0x0d48},\n\t{0x0d4a, 0x0d4d},\n\t{0x0d57, 0x0d57},\n\t{0x0d62, 0x0d63},\n\t{0x0d81, 0x0d83},\n\t{0x0dca, 0x0dca},\n\t{0x0dcf, 0x0dd4},\n\t{0x0dd6, 0x0dd6},\n\t{0x0dd8, 0x0ddf},\n\t{0x0df2, 0x0df3},\n\t{0x0e31, 0x0e31},\n\t{0x0e34, 0x0e3a},\n\t{0x0e47, 0x0e4e},\n\t{0x0eb1, 0x0eb1},\n\t{0x0eb4, 0x0ebc},\n\t{0x0ec8, 0x0ecd},\n\t{0x0f18, 0x0f19},\n\t{0x0f35, 0x0f35},\n\t{0x0f37, 0x0f37},\n\t{0x0f39, 0x0f39},\n\t{0x0f3e, 0x0f3f},\n\t{0x0f71, 0x0f84},\n\t{0x0f86, 0x0f87},\n\t{0x0f8d, 0x0f97},\n\t{0x0f99, 0x0fbc},\n\t{0x0fc6, 0x0fc6},\n\t{0x102b, 0x103e},\n\t{0x1056, 0x1059},\n\t{0x105e, 0x1060},\n\t{0x1062, 0x1064},\n\t{0x1067, 0x106d},\n\t{0x1071, 0x1074},\n\t{0x1082, 0x108d},\n\t{0x108f, 0x108f},\n\t{0x109a, 0x109d},\n\t{0x135d, 0x135f},\n\t{0x1712, 0x1714},\n\t{0x1732, 0x1734},\n\t{0x1752, 0x1753},\n\t{0x1772, 0x1773},\n\t{0x17b4, 0x17d3},\n\t{0x17dd, 0x17dd},\n\t{0x180b, 0x180d},\n\t{0x1885, 0x1886},\n\t{0x18a9, 0x18a9},\n\t{0x1920, 0x192b},\n\t{0x1930, 0x193b},\n\t{0x1a17, 0x1a1b},\n\t{0x1a55, 0x1a5e},\n\t{0x1a60, 0x1a7c},\n\t{0x1a7f, 0x1a7f},\n\t{0x1ab0, 0x1ac0},\n\t{0x1b00, 0x1b04},\n\t{0x1b34, 0x1b44},\n\t{0x1b6b, 0x1b73},\n\t{0x1b80, 0x1b82},\n\t{0x1ba1, 0x1bad},\n\t{0x1be6, 0x1bf3},\n\t{0x1c24, 0x1c37},\n\t{0x1cd0, 0x1cd2},\n\t{0x1cd4, 0x1ce8},\n\t{0x1ced, 0x1ced},\n\t{0x1cf4, 0x1cf4},\n\t{0x1cf7, 0x1cf9},\n\t{0x1dc0, 0x1df9},\n\t{0x1dfb, 0x1dff},\n\t{0x20d0, 0x20f0},\n\t{0x2cef, 0x2cf1},\n\t{0x2d7f, 0x2d7f},\n\t{0x2de0, 0x2dff},\n\t{0x302a, 0x302f},\n\t{0x3099, 0x309a},\n\t{0xa66f, 0xa672},\n\t{0xa674, 0xa67d},\n\t{0xa69e, 0xa69f},\n\t{0xa6f0, 0xa6f1},\n\t{0xa802, 0xa802},\n\t{0xa806, 0xa806},\n\t{0xa80b, 0xa80b},\n\t{0xa823, 0xa827},\n\t{0xa82c, 0xa82c},\n\t{0xa880, 0xa881},\n\t{0xa8b4, 0xa8c5},\n\t{0xa8e0, 0xa8f1},\n\t{0xa8ff, 0xa8ff},\n\t{0xa926, 0xa92d},\n\t{0xa947, 0xa953},\n\t{0xa980, 0xa983},\n\t{0xa9b3, 0xa9c0},\n\t{0xa9e5, 0xa9e5},\n\t{0xaa29, 0xaa36},\n\t{0xaa43, 0xaa43},\n\t{0xaa4c, 0xaa4d},\n\t{0xaa7b, 0xaa7d},\n\t{0xaab0, 0xaab0},\n\t{0xaab2, 0xaab4},\n\t{0xaab7, 0xaab8},\n\t{0xaabe, 0xaabf},\n\t{0xaac1, 0xaac1},\n\t{0xaaeb, 0xaaef},\n\t{0xaaf5, 0xaaf6},\n\t{0xabe3, 0xabea},\n\t{0xabec, 0xabed},\n\t{0xfb1e, 0xfb1e},\n\t{0xfe00, 0xfe0f},\n\t{0xfe20, 0xfe2f},\n\t{0x101fd, 0x101fd},\n\t{0x102e0, 0x102e0},\n\t{0x10376, 0x1037a},\n\t{0x10a01, 0x10a03},\n\t{0x10a05, 0x10a06},\n\t{0x10a0c, 0x10a0f},\n\t{0x10a38, 0x10a3a},\n\t{0x10a3f, 0x10a3f},\n\t{0x10ae5, 0x10ae6},\n\t{0x10d24, 0x10d27},\n\t{0x10eab, 0x10eac},\n\t{0x10f46, 0x10f50},\n\t{0x11000, 0x11002},\n\t{0x11038, 0x11046},\n\t{0x1107f, 0x11082},\n\t{0x110b0, 0x110ba},\n\t{0x11100, 0x11102},\n\t{0x11127, 0x11134},\n\t{0x11145, 0x11146},\n\t{0x11173, 0x11173},\n\t{0x11180, 0x11182},\n\t{0x111b3, 0x111c0},\n\t{0x111c9, 0x111cc},\n\t{0x111ce, 0x111cf},\n\t{0x1122c, 0x11237},\n\t{0x1123e, 0x1123e},\n\t{0x112df, 0x112ea},\n\t{0x11300, 0x11303},\n\t{0x1133b, 0x1133c},\n\t{0x1133e, 0x11344},\n\t{0x11347, 0x11348},\n\t{0x1134b, 0x1134d},\n\t{0x11357, 0x11357},\n\t{0x11362, 0x11363},\n\t{0x11366, 0x1136c},\n\t{0x11370, 0x11374},\n\t{0x11435, 0x11446},\n\t{0x1145e, 0x1145e},\n\t{0x114b0, 0x114c3},\n\t{0x115af, 0x115b5},\n\t{0x115b8, 0x115c0},\n\t{0x115dc, 0x115dd},\n\t{0x11630, 0x11640},\n\t{0x116ab, 0x116b7},\n\t{0x1171d, 0x1172b},\n\t{0x1182c, 0x1183a},\n\t{0x11930, 0x11935},\n\t{0x11937, 0x11938},\n\t{0x1193b, 0x1193e},\n\t{0x11940, 0x11940},\n\t{0x11942, 0x11943},\n\t{0x119d1, 0x119d7},\n\t{0x119da, 0x119e0},\n\t{0x119e4, 0x119e4},\n\t{0x11a01, 0x11a0a},\n\t{0x11a33, 0x11a39},\n\t{0x11a3b, 0x11a3e},\n\t{0x11a47, 0x11a47},\n\t{0x11a51, 0x11a5b},\n\t{0x11a8a, 0x11a99},\n\t{0x11c2f, 0x11c36},\n\t{0x11c38, 0x11c3f},\n\t{0x11c92, 0x11ca7},\n\t{0x11ca9, 0x11cb6},\n\t{0x11d31, 0x11d36},\n\t{0x11d3a, 0x11d3a},\n\t{0x11d3c, 0x11d3d},\n\t{0x11d3f, 0x11d45},\n\t{0x11d47, 0x11d47},\n\t{0x11d8a, 0x11d8e},\n\t{0x11d90, 0x11d91},\n\t{0x11d93, 0x11d97},\n\t{0x11ef3, 0x11ef6},\n\t{0x16af0, 0x16af4},\n\t{0x16b30, 0x16b36},\n\t{0x16f4f, 0x16f4f},\n\t{0x16f51, 0x16f87},\n\t{0x16f8f, 0x16f92},\n\t{0x16fe4, 0x16fe4},\n\t{0x16ff0, 0x16ff1},\n\t{0x1bc9d, 0x1bc9e},\n\t{0x1d165, 0x1d169},\n\t{0x1d16d, 0x1d172},\n\t{0x1d17b, 0x1d182},\n\t{0x1d185, 0x1d18b},\n\t{0x1d1aa, 0x1d1ad},\n\t{0x1d242, 0x1d244},\n\t{0x1da00, 0x1da36},\n\t{0x1da3b, 0x1da6c},\n\t{0x1da75, 0x1da75},\n\t{0x1da84, 0x1da84},\n\t{0x1da9b, 0x1da9f},\n\t{0x1daa1, 0x1daaf},\n\t{0x1e000, 0x1e006},\n\t{0x1e008, 0x1e018},\n\t{0x1e01b, 0x1e021},\n\t{0x1e023, 0x1e024},\n\t{0x1e026, 0x1e02a},\n\t{0x1e130, 0x1e136},\n\t{0x1e2ec, 0x1e2ef},\n\t{0x1e8d0, 0x1e8d6},\n\t{0x1e944, 0x1e94a},\n\t{0xe0100, 0xe01ef}\n    };\n\n    return intable(combining, sizeof(combining), c);\n}\n\n/*\n * Return TRUE for characters that can be displayed in a normal way.\n * Only for characters of 0x100 and above!\n */\n    int\nutf_printable(int c)\n{\n#ifdef USE_WCHAR_FUNCTIONS\n    /*\n     * Assume the iswprint() library function works better than our own stuff.\n     */\n    return iswprint(c);\n#else\n    // Sorted list of non-overlapping intervals.\n    // 0xd800-0xdfff is reserved for UTF-16, actually illegal.\n    static struct interval nonprint[] =\n    {\n\t{0x070f, 0x070f}, {0x180b, 0x180e}, {0x200b, 0x200f}, {0x202a, 0x202e},\n\t{0x2060, 0x206f}, {0xd800, 0xdfff}, {0xfeff, 0xfeff}, {0xfff9, 0xfffb},\n\t{0xfffe, 0xffff}\n    };\n\n    return !intable(nonprint, sizeof(nonprint), c);\n#endif\n}\n\n// Sorted list of non-overlapping intervals of all Emoji characters,\n// based on http://unicode.org/emoji/charts/emoji-list.html\n// Generated by ../runtime/tools/unicode.vim.\n// Excludes 0x00a9 and 0x00ae because they are considered latin1.\nstatic struct interval emoji_all[] =\n{\n    {0x203c, 0x203c},\n    {0x2049, 0x2049},\n    {0x2122, 0x2122},\n    {0x2139, 0x2139},\n    {0x2194, 0x2199},\n    {0x21a9, 0x21aa},\n    {0x231a, 0x231b},\n    {0x2328, 0x2328},\n    {0x23cf, 0x23cf},\n    {0x23e9, 0x23f3},\n    {0x23f8, 0x23fa},\n    {0x24c2, 0x24c2},\n    {0x25aa, 0x25ab},\n    {0x25b6, 0x25b6},\n    {0x25c0, 0x25c0},\n    {0x25fb, 0x25fe},\n    {0x2600, 0x2604},\n    {0x260e, 0x260e},\n    {0x2611, 0x2611},\n    {0x2614, 0x2615},\n    {0x2618, 0x2618},\n    {0x261d, 0x261d},\n    {0x2620, 0x2620},\n    {0x2622, 0x2623},\n    {0x2626, 0x2626},\n    {0x262a, 0x262a},\n    {0x262e, 0x262f},\n    {0x2638, 0x263a},\n    {0x2640, 0x2640},\n    {0x2642, 0x2642},\n    {0x2648, 0x2653},\n    {0x265f, 0x2660},\n    {0x2663, 0x2663},\n    {0x2665, 0x2666},\n    {0x2668, 0x2668},\n    {0x267b, 0x267b},\n    {0x267e, 0x267f},\n    {0x2692, 0x2697},\n    {0x2699, 0x2699},\n    {0x269b, 0x269c},\n    {0x26a0, 0x26a1},\n    {0x26a7, 0x26a7},\n    {0x26aa, 0x26ab},\n    {0x26b0, 0x26b1},\n    {0x26bd, 0x26be},\n    {0x26c4, 0x26c5},\n    {0x26c8, 0x26c8},\n    {0x26ce, 0x26cf},\n    {0x26d1, 0x26d1},\n    {0x26d3, 0x26d4},\n    {0x26e9, 0x26ea},\n    {0x26f0, 0x26f5},\n    {0x26f7, 0x26fa},\n    {0x26fd, 0x26fd},\n    {0x2702, 0x2702},\n    {0x2705, 0x2705},\n    {0x2708, 0x270d},\n    {0x270f, 0x270f},\n    {0x2712, 0x2712},\n    {0x2714, 0x2714},\n    {0x2716, 0x2716},\n    {0x271d, 0x271d},\n    {0x2721, 0x2721},\n    {0x2728, 0x2728},\n    {0x2733, 0x2734},\n    {0x2744, 0x2744},\n    {0x2747, 0x2747},\n    {0x274c, 0x274c},\n    {0x274e, 0x274e},\n    {0x2753, 0x2755},\n    {0x2757, 0x2757},\n    {0x2763, 0x2764},\n    {0x2795, 0x2797},\n    {0x27a1, 0x27a1},\n    {0x27b0, 0x27b0},\n    {0x27bf, 0x27bf},\n    {0x2934, 0x2935},\n    {0x2b05, 0x2b07},\n    {0x2b1b, 0x2b1c},\n    {0x2b50, 0x2b50},\n    {0x2b55, 0x2b55},\n    {0x3030, 0x3030},\n    {0x303d, 0x303d},\n    {0x3297, 0x3297},\n    {0x3299, 0x3299},\n    {0x1f004, 0x1f004},\n    {0x1f0cf, 0x1f0cf},\n    {0x1f170, 0x1f171},\n    {0x1f17e, 0x1f17f},\n    {0x1f18e, 0x1f18e},\n    {0x1f191, 0x1f19a},\n    {0x1f1e6, 0x1f1ff},\n    {0x1f201, 0x1f202},\n    {0x1f21a, 0x1f21a},\n    {0x1f22f, 0x1f22f},\n    {0x1f232, 0x1f23a},\n    {0x1f250, 0x1f251},\n    {0x1f300, 0x1f321},\n    {0x1f324, 0x1f393},\n    {0x1f396, 0x1f397},\n    {0x1f399, 0x1f39b},\n    {0x1f39e, 0x1f3f0},\n    {0x1f3f3, 0x1f3f5},\n    {0x1f3f7, 0x1f4fd},\n    {0x1f4ff, 0x1f53d},\n    {0x1f549, 0x1f54e},\n    {0x1f550, 0x1f567},\n    {0x1f56f, 0x1f570},\n    {0x1f573, 0x1f57a},\n    {0x1f587, 0x1f587},\n    {0x1f58a, 0x1f58d},\n    {0x1f590, 0x1f590},\n    {0x1f595, 0x1f596},\n    {0x1f5a4, 0x1f5a5},\n    {0x1f5a8, 0x1f5a8},\n    {0x1f5b1, 0x1f5b2},\n    {0x1f5bc, 0x1f5bc},\n    {0x1f5c2, 0x1f5c4},\n    {0x1f5d1, 0x1f5d3},\n    {0x1f5dc, 0x1f5de},\n    {0x1f5e1, 0x1f5e1},\n    {0x1f5e3, 0x1f5e3},\n    {0x1f5e8, 0x1f5e8},\n    {0x1f5ef, 0x1f5ef},\n    {0x1f5f3, 0x1f5f3},\n    {0x1f5fa, 0x1f64f},\n    {0x1f680, 0x1f6c5},\n    {0x1f6cb, 0x1f6d2},\n    {0x1f6d5, 0x1f6d7},\n    {0x1f6e0, 0x1f6e5},\n    {0x1f6e9, 0x1f6e9},\n    {0x1f6eb, 0x1f6ec},\n    {0x1f6f0, 0x1f6f0},\n    {0x1f6f3, 0x1f6fc},\n    {0x1f7e0, 0x1f7eb},\n    {0x1f90c, 0x1f93a},\n    {0x1f93c, 0x1f945},\n    {0x1f947, 0x1f978},\n    {0x1f97a, 0x1f9cb},\n    {0x1f9cd, 0x1f9ff},\n    {0x1fa70, 0x1fa74},\n    {0x1fa78, 0x1fa7a},\n    {0x1fa80, 0x1fa86},\n    {0x1fa90, 0x1faa8},\n    {0x1fab0, 0x1fab6},\n    {0x1fac0, 0x1fac2},\n    {0x1fad0, 0x1fad6}\n};\n\n/*\n * Get class of a Unicode character.\n * 0: white space\n * 1: punctuation\n * 2 or bigger: some class of word character.\n */\n    int\nutf_class(int c)\n{\n    return utf_class_buf(c, curbuf);\n}\n\n    int\nutf_class_buf(int c, buf_T *buf)\n{\n    // sorted list of non-overlapping intervals\n    static struct clinterval\n    {\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int class;\n    } classes[] =\n    {\n\t{0x037e, 0x037e, 1},\t\t// Greek question mark\n\t{0x0387, 0x0387, 1},\t\t// Greek ano teleia\n\t{0x055a, 0x055f, 1},\t\t// Armenian punctuation\n\t{0x0589, 0x0589, 1},\t\t// Armenian full stop\n\t{0x05be, 0x05be, 1},\n\t{0x05c0, 0x05c0, 1},\n\t{0x05c3, 0x05c3, 1},\n\t{0x05f3, 0x05f4, 1},\n\t{0x060c, 0x060c, 1},\n\t{0x061b, 0x061b, 1},\n\t{0x061f, 0x061f, 1},\n\t{0x066a, 0x066d, 1},\n\t{0x06d4, 0x06d4, 1},\n\t{0x0700, 0x070d, 1},\t\t// Syriac punctuation\n\t{0x0964, 0x0965, 1},\n\t{0x0970, 0x0970, 1},\n\t{0x0df4, 0x0df4, 1},\n\t{0x0e4f, 0x0e4f, 1},\n\t{0x0e5a, 0x0e5b, 1},\n\t{0x0f04, 0x0f12, 1},\n\t{0x0f3a, 0x0f3d, 1},\n\t{0x0f85, 0x0f85, 1},\n\t{0x104a, 0x104f, 1},\t\t// Myanmar punctuation\n\t{0x10fb, 0x10fb, 1},\t\t// Georgian punctuation\n\t{0x1361, 0x1368, 1},\t\t// Ethiopic punctuation\n\t{0x166d, 0x166e, 1},\t\t// Canadian Syl. punctuation\n\t{0x1680, 0x1680, 0},\n\t{0x169b, 0x169c, 1},\n\t{0x16eb, 0x16ed, 1},\n\t{0x1735, 0x1736, 1},\n\t{0x17d4, 0x17dc, 1},\t\t// Khmer punctuation\n\t{0x1800, 0x180a, 1},\t\t// Mongolian punctuation\n\t{0x2000, 0x200b, 0},\t\t// spaces\n\t{0x200c, 0x2027, 1},\t\t// punctuation and symbols\n\t{0x2028, 0x2029, 0},\n\t{0x202a, 0x202e, 1},\t\t// punctuation and symbols\n\t{0x202f, 0x202f, 0},\n\t{0x2030, 0x205e, 1},\t\t// punctuation and symbols\n\t{0x205f, 0x205f, 0},\n\t{0x2060, 0x27ff, 1},\t\t// punctuation and symbols\n\t{0x2070, 0x207f, 0x2070},\t// superscript\n\t{0x2080, 0x2094, 0x2080},\t// subscript\n\t{0x20a0, 0x27ff, 1},\t\t// all kinds of symbols\n\t{0x2800, 0x28ff, 0x2800},\t// braille\n\t{0x2900, 0x2998, 1},\t\t// arrows, brackets, etc.\n\t{0x29d8, 0x29db, 1},\n\t{0x29fc, 0x29fd, 1},\n\t{0x2e00, 0x2e7f, 1},\t\t// supplemental punctuation\n\t{0x3000, 0x3000, 0},\t\t// ideographic space\n\t{0x3001, 0x3020, 1},\t\t// ideographic punctuation\n\t{0x3030, 0x3030, 1},\n\t{0x303d, 0x303d, 1},\n\t{0x3040, 0x309f, 0x3040},\t// Hiragana\n\t{0x30a0, 0x30ff, 0x30a0},\t// Katakana\n\t{0x3300, 0x9fff, 0x4e00},\t// CJK Ideographs\n\t{0xac00, 0xd7a3, 0xac00},\t// Hangul Syllables\n\t{0xf900, 0xfaff, 0x4e00},\t// CJK Ideographs\n\t{0xfd3e, 0xfd3f, 1},\n\t{0xfe30, 0xfe6b, 1},\t\t// punctuation forms\n\t{0xff00, 0xff0f, 1},\t\t// half/fullwidth ASCII\n\t{0xff1a, 0xff20, 1},\t\t// half/fullwidth ASCII\n\t{0xff3b, 0xff40, 1},\t\t// half/fullwidth ASCII\n\t{0xff5b, 0xff65, 1},\t\t// half/fullwidth ASCII\n\t{0x1d000, 0x1d24f, 1},\t\t// Musical notation\n\t{0x1d400, 0x1d7ff, 1},\t\t// Mathematical Alphanumeric Symbols\n\t{0x1f000, 0x1f2ff, 1},\t\t// Game pieces; enclosed characters\n\t{0x1f300, 0x1f9ff, 1},\t\t// Many symbol blocks\n\t{0x20000, 0x2a6df, 0x4e00},\t// CJK Ideographs\n\t{0x2a700, 0x2b73f, 0x4e00},\t// CJK Ideographs\n\t{0x2b740, 0x2b81f, 0x4e00},\t// CJK Ideographs\n\t{0x2f800, 0x2fa1f, 0x4e00},\t// CJK Ideographs\n    };\n\n    int bot = 0;\n    int top = ARRAY_LENGTH(classes) - 1;\n    int mid;\n\n    // First quick check for Latin1 characters, use 'iskeyword'.\n    if (c < 0x100)\n    {\n\tif (c == ' ' || c == '\\t' || c == NUL || c == 0xa0)\n\t    return 0;\t    // blank\n\tif (vim_iswordc_buf(c, buf))\n\t    return 2;\t    // word character\n\treturn 1;\t    // punctuation\n    }\n\n    // emoji\n    if (intable(emoji_all, sizeof(emoji_all), c))\n\treturn 3;\n\n    // binary search in table\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (classes[mid].last < (unsigned int)c)\n\t    bot = mid + 1;\n\telse if (classes[mid].first > (unsigned int)c)\n\t    top = mid - 1;\n\telse\n\t    return (int)classes[mid].class;\n    }\n\n    // most other characters are \"word\" characters\n    return 2;\n}\n\n    int\nutf_ambiguous_width(int c)\n{\n    return c >= 0x80 && (intable(ambiguous, sizeof(ambiguous), c)\n\t    || intable(emoji_all, sizeof(emoji_all), c));\n}\n\n/*\n * Code for Unicode case-dependent operations.  Based on notes in\n * http://www.unicode.org/Public/UNIDATA/CaseFolding.txt\n * This code uses simple case folding, not full case folding.\n * Last updated for Unicode 5.2.\n */\n\n/*\n * The following tables are built by ../runtime/tools/unicode.vim.\n * They must be in numeric order, because we use binary search.\n * An entry such as {0x41,0x5a,1,32} means that Unicode characters in the\n * range from 0x41 to 0x5a inclusive, stepping by 1, are changed to\n * folded/upper/lower by adding 32.\n */\ntypedef struct\n{\n    int rangeStart;\n    int rangeEnd;\n    int step;\n    int offset;\n} convertStruct;\n\nstatic convertStruct foldCase[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xb5,0xb5,-1,775},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x17f,0x17f,-1,-268},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x345,0x345,-1,116},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3c2,0x3c2,-1,1},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d0,0x3d0,-1,-30},\n\t{0x3d1,0x3d1,-1,-25},\n\t{0x3d5,0x3d5,-1,-15},\n\t{0x3d6,0x3d6,-1,-22},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f0,0x3f0,-1,-54},\n\t{0x3f1,0x3f1,-1,-48},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f5,0x3f5,-1,-64},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6222},\n\t{0x1c81,0x1c81,-1,-6221},\n\t{0x1c82,0x1c82,-1,-6212},\n\t{0x1c83,0x1c84,1,-6210},\n\t{0x1c85,0x1c85,-1,-6211},\n\t{0x1c86,0x1c86,-1,-6204},\n\t{0x1c87,0x1c87,-1,-6180},\n\t{0x1c88,0x1c88,-1,35267},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9b,0x1e9b,-1,-58},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fbe,0x1fbe,-1,-7173},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\n/*\n * Generic conversion function for case operations.\n * Return the converted equivalent of \"a\", which is a UCS-4 character.  Use\n * the given conversion \"table\".  Uses binary search on \"table\".\n */\n    static int\nutf_convert(\n    int\t\t\ta,\n    convertStruct\ttable[],\n    int\t\t\ttableSize)\n{\n    int start, mid, end; // indices into table\n    int entries = tableSize / sizeof(convertStruct);\n\n    start = 0;\n    end = entries;\n    while (start < end)\n    {\n\t// need to search further\n\tmid = (end + start) / 2;\n\tif (table[mid].rangeEnd < a)\n\t    start = mid + 1;\n\telse\n\t    end = mid;\n    }\n    if (start < entries\n\t    && table[start].rangeStart <= a\n\t    && a <= table[start].rangeEnd\n\t    && (a - table[start].rangeStart) % table[start].step == 0)\n\treturn (a + table[start].offset);\n    else\n\treturn a;\n}\n\n/*\n * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses\n * simple case folding.\n */\n    int\nutf_fold(int a)\n{\n    if (a < 0x80)\n\t// be fast for ASCII\n\treturn a >= 0x41 && a <= 0x5a ? a + 32 : a;\n    return utf_convert(a, foldCase, (int)sizeof(foldCase));\n}\n\nstatic convertStruct toLower[] =\n{\n\t{0x41,0x5a,1,32},\n\t{0xc0,0xd6,1,32},\n\t{0xd8,0xde,1,32},\n\t{0x100,0x12e,2,1},\n\t{0x130,0x130,-1,-199},\n\t{0x132,0x136,2,1},\n\t{0x139,0x147,2,1},\n\t{0x14a,0x176,2,1},\n\t{0x178,0x178,-1,-121},\n\t{0x179,0x17d,2,1},\n\t{0x181,0x181,-1,210},\n\t{0x182,0x184,2,1},\n\t{0x186,0x186,-1,206},\n\t{0x187,0x187,-1,1},\n\t{0x189,0x18a,1,205},\n\t{0x18b,0x18b,-1,1},\n\t{0x18e,0x18e,-1,79},\n\t{0x18f,0x18f,-1,202},\n\t{0x190,0x190,-1,203},\n\t{0x191,0x191,-1,1},\n\t{0x193,0x193,-1,205},\n\t{0x194,0x194,-1,207},\n\t{0x196,0x196,-1,211},\n\t{0x197,0x197,-1,209},\n\t{0x198,0x198,-1,1},\n\t{0x19c,0x19c,-1,211},\n\t{0x19d,0x19d,-1,213},\n\t{0x19f,0x19f,-1,214},\n\t{0x1a0,0x1a4,2,1},\n\t{0x1a6,0x1a6,-1,218},\n\t{0x1a7,0x1a7,-1,1},\n\t{0x1a9,0x1a9,-1,218},\n\t{0x1ac,0x1ac,-1,1},\n\t{0x1ae,0x1ae,-1,218},\n\t{0x1af,0x1af,-1,1},\n\t{0x1b1,0x1b2,1,217},\n\t{0x1b3,0x1b5,2,1},\n\t{0x1b7,0x1b7,-1,219},\n\t{0x1b8,0x1bc,4,1},\n\t{0x1c4,0x1c4,-1,2},\n\t{0x1c5,0x1c5,-1,1},\n\t{0x1c7,0x1c7,-1,2},\n\t{0x1c8,0x1c8,-1,1},\n\t{0x1ca,0x1ca,-1,2},\n\t{0x1cb,0x1db,2,1},\n\t{0x1de,0x1ee,2,1},\n\t{0x1f1,0x1f1,-1,2},\n\t{0x1f2,0x1f4,2,1},\n\t{0x1f6,0x1f6,-1,-97},\n\t{0x1f7,0x1f7,-1,-56},\n\t{0x1f8,0x21e,2,1},\n\t{0x220,0x220,-1,-130},\n\t{0x222,0x232,2,1},\n\t{0x23a,0x23a,-1,10795},\n\t{0x23b,0x23b,-1,1},\n\t{0x23d,0x23d,-1,-163},\n\t{0x23e,0x23e,-1,10792},\n\t{0x241,0x241,-1,1},\n\t{0x243,0x243,-1,-195},\n\t{0x244,0x244,-1,69},\n\t{0x245,0x245,-1,71},\n\t{0x246,0x24e,2,1},\n\t{0x370,0x372,2,1},\n\t{0x376,0x376,-1,1},\n\t{0x37f,0x37f,-1,116},\n\t{0x386,0x386,-1,38},\n\t{0x388,0x38a,1,37},\n\t{0x38c,0x38c,-1,64},\n\t{0x38e,0x38f,1,63},\n\t{0x391,0x3a1,1,32},\n\t{0x3a3,0x3ab,1,32},\n\t{0x3cf,0x3cf,-1,8},\n\t{0x3d8,0x3ee,2,1},\n\t{0x3f4,0x3f4,-1,-60},\n\t{0x3f7,0x3f7,-1,1},\n\t{0x3f9,0x3f9,-1,-7},\n\t{0x3fa,0x3fa,-1,1},\n\t{0x3fd,0x3ff,1,-130},\n\t{0x400,0x40f,1,80},\n\t{0x410,0x42f,1,32},\n\t{0x460,0x480,2,1},\n\t{0x48a,0x4be,2,1},\n\t{0x4c0,0x4c0,-1,15},\n\t{0x4c1,0x4cd,2,1},\n\t{0x4d0,0x52e,2,1},\n\t{0x531,0x556,1,48},\n\t{0x10a0,0x10c5,1,7264},\n\t{0x10c7,0x10cd,6,7264},\n\t{0x13a0,0x13ef,1,38864},\n\t{0x13f0,0x13f5,1,8},\n\t{0x1c90,0x1cba,1,-3008},\n\t{0x1cbd,0x1cbf,1,-3008},\n\t{0x1e00,0x1e94,2,1},\n\t{0x1e9e,0x1e9e,-1,-7615},\n\t{0x1ea0,0x1efe,2,1},\n\t{0x1f08,0x1f0f,1,-8},\n\t{0x1f18,0x1f1d,1,-8},\n\t{0x1f28,0x1f2f,1,-8},\n\t{0x1f38,0x1f3f,1,-8},\n\t{0x1f48,0x1f4d,1,-8},\n\t{0x1f59,0x1f5f,2,-8},\n\t{0x1f68,0x1f6f,1,-8},\n\t{0x1f88,0x1f8f,1,-8},\n\t{0x1f98,0x1f9f,1,-8},\n\t{0x1fa8,0x1faf,1,-8},\n\t{0x1fb8,0x1fb9,1,-8},\n\t{0x1fba,0x1fbb,1,-74},\n\t{0x1fbc,0x1fbc,-1,-9},\n\t{0x1fc8,0x1fcb,1,-86},\n\t{0x1fcc,0x1fcc,-1,-9},\n\t{0x1fd8,0x1fd9,1,-8},\n\t{0x1fda,0x1fdb,1,-100},\n\t{0x1fe8,0x1fe9,1,-8},\n\t{0x1fea,0x1feb,1,-112},\n\t{0x1fec,0x1fec,-1,-7},\n\t{0x1ff8,0x1ff9,1,-128},\n\t{0x1ffa,0x1ffb,1,-126},\n\t{0x1ffc,0x1ffc,-1,-9},\n\t{0x2126,0x2126,-1,-7517},\n\t{0x212a,0x212a,-1,-8383},\n\t{0x212b,0x212b,-1,-8262},\n\t{0x2132,0x2132,-1,28},\n\t{0x2160,0x216f,1,16},\n\t{0x2183,0x2183,-1,1},\n\t{0x24b6,0x24cf,1,26},\n\t{0x2c00,0x2c2e,1,48},\n\t{0x2c60,0x2c60,-1,1},\n\t{0x2c62,0x2c62,-1,-10743},\n\t{0x2c63,0x2c63,-1,-3814},\n\t{0x2c64,0x2c64,-1,-10727},\n\t{0x2c67,0x2c6b,2,1},\n\t{0x2c6d,0x2c6d,-1,-10780},\n\t{0x2c6e,0x2c6e,-1,-10749},\n\t{0x2c6f,0x2c6f,-1,-10783},\n\t{0x2c70,0x2c70,-1,-10782},\n\t{0x2c72,0x2c75,3,1},\n\t{0x2c7e,0x2c7f,1,-10815},\n\t{0x2c80,0x2ce2,2,1},\n\t{0x2ceb,0x2ced,2,1},\n\t{0x2cf2,0xa640,31054,1},\n\t{0xa642,0xa66c,2,1},\n\t{0xa680,0xa69a,2,1},\n\t{0xa722,0xa72e,2,1},\n\t{0xa732,0xa76e,2,1},\n\t{0xa779,0xa77b,2,1},\n\t{0xa77d,0xa77d,-1,-35332},\n\t{0xa77e,0xa786,2,1},\n\t{0xa78b,0xa78b,-1,1},\n\t{0xa78d,0xa78d,-1,-42280},\n\t{0xa790,0xa792,2,1},\n\t{0xa796,0xa7a8,2,1},\n\t{0xa7aa,0xa7aa,-1,-42308},\n\t{0xa7ab,0xa7ab,-1,-42319},\n\t{0xa7ac,0xa7ac,-1,-42315},\n\t{0xa7ad,0xa7ad,-1,-42305},\n\t{0xa7ae,0xa7ae,-1,-42308},\n\t{0xa7b0,0xa7b0,-1,-42258},\n\t{0xa7b1,0xa7b1,-1,-42282},\n\t{0xa7b2,0xa7b2,-1,-42261},\n\t{0xa7b3,0xa7b3,-1,928},\n\t{0xa7b4,0xa7be,2,1},\n\t{0xa7c2,0xa7c2,-1,1},\n\t{0xa7c4,0xa7c4,-1,-48},\n\t{0xa7c5,0xa7c5,-1,-42307},\n\t{0xa7c6,0xa7c6,-1,-35384},\n\t{0xa7c7,0xa7c9,2,1},\n\t{0xa7f5,0xa7f5,-1,1},\n\t{0xff21,0xff3a,1,32},\n\t{0x10400,0x10427,1,40},\n\t{0x104b0,0x104d3,1,40},\n\t{0x10c80,0x10cb2,1,64},\n\t{0x118a0,0x118bf,1,32},\n\t{0x16e40,0x16e5f,1,32},\n\t{0x1e900,0x1e921,1,34}\n};\n\nstatic convertStruct toUpper[] =\n{\n\t{0x61,0x7a,1,-32},\n\t{0xb5,0xb5,-1,743},\n\t{0xe0,0xf6,1,-32},\n\t{0xf8,0xfe,1,-32},\n\t{0xff,0xff,-1,121},\n\t{0x101,0x12f,2,-1},\n\t{0x131,0x131,-1,-232},\n\t{0x133,0x137,2,-1},\n\t{0x13a,0x148,2,-1},\n\t{0x14b,0x177,2,-1},\n\t{0x17a,0x17e,2,-1},\n\t{0x17f,0x17f,-1,-300},\n\t{0x180,0x180,-1,195},\n\t{0x183,0x185,2,-1},\n\t{0x188,0x18c,4,-1},\n\t{0x192,0x192,-1,-1},\n\t{0x195,0x195,-1,97},\n\t{0x199,0x199,-1,-1},\n\t{0x19a,0x19a,-1,163},\n\t{0x19e,0x19e,-1,130},\n\t{0x1a1,0x1a5,2,-1},\n\t{0x1a8,0x1ad,5,-1},\n\t{0x1b0,0x1b4,4,-1},\n\t{0x1b6,0x1b9,3,-1},\n\t{0x1bd,0x1bd,-1,-1},\n\t{0x1bf,0x1bf,-1,56},\n\t{0x1c5,0x1c5,-1,-1},\n\t{0x1c6,0x1c6,-1,-2},\n\t{0x1c8,0x1c8,-1,-1},\n\t{0x1c9,0x1c9,-1,-2},\n\t{0x1cb,0x1cb,-1,-1},\n\t{0x1cc,0x1cc,-1,-2},\n\t{0x1ce,0x1dc,2,-1},\n\t{0x1dd,0x1dd,-1,-79},\n\t{0x1df,0x1ef,2,-1},\n\t{0x1f2,0x1f2,-1,-1},\n\t{0x1f3,0x1f3,-1,-2},\n\t{0x1f5,0x1f9,4,-1},\n\t{0x1fb,0x21f,2,-1},\n\t{0x223,0x233,2,-1},\n\t{0x23c,0x23c,-1,-1},\n\t{0x23f,0x240,1,10815},\n\t{0x242,0x247,5,-1},\n\t{0x249,0x24f,2,-1},\n\t{0x250,0x250,-1,10783},\n\t{0x251,0x251,-1,10780},\n\t{0x252,0x252,-1,10782},\n\t{0x253,0x253,-1,-210},\n\t{0x254,0x254,-1,-206},\n\t{0x256,0x257,1,-205},\n\t{0x259,0x259,-1,-202},\n\t{0x25b,0x25b,-1,-203},\n\t{0x25c,0x25c,-1,42319},\n\t{0x260,0x260,-1,-205},\n\t{0x261,0x261,-1,42315},\n\t{0x263,0x263,-1,-207},\n\t{0x265,0x265,-1,42280},\n\t{0x266,0x266,-1,42308},\n\t{0x268,0x268,-1,-209},\n\t{0x269,0x269,-1,-211},\n\t{0x26a,0x26a,-1,42308},\n\t{0x26b,0x26b,-1,10743},\n\t{0x26c,0x26c,-1,42305},\n\t{0x26f,0x26f,-1,-211},\n\t{0x271,0x271,-1,10749},\n\t{0x272,0x272,-1,-213},\n\t{0x275,0x275,-1,-214},\n\t{0x27d,0x27d,-1,10727},\n\t{0x280,0x280,-1,-218},\n\t{0x282,0x282,-1,42307},\n\t{0x283,0x283,-1,-218},\n\t{0x287,0x287,-1,42282},\n\t{0x288,0x288,-1,-218},\n\t{0x289,0x289,-1,-69},\n\t{0x28a,0x28b,1,-217},\n\t{0x28c,0x28c,-1,-71},\n\t{0x292,0x292,-1,-219},\n\t{0x29d,0x29d,-1,42261},\n\t{0x29e,0x29e,-1,42258},\n\t{0x345,0x345,-1,84},\n\t{0x371,0x373,2,-1},\n\t{0x377,0x377,-1,-1},\n\t{0x37b,0x37d,1,130},\n\t{0x3ac,0x3ac,-1,-38},\n\t{0x3ad,0x3af,1,-37},\n\t{0x3b1,0x3c1,1,-32},\n\t{0x3c2,0x3c2,-1,-31},\n\t{0x3c3,0x3cb,1,-32},\n\t{0x3cc,0x3cc,-1,-64},\n\t{0x3cd,0x3ce,1,-63},\n\t{0x3d0,0x3d0,-1,-62},\n\t{0x3d1,0x3d1,-1,-57},\n\t{0x3d5,0x3d5,-1,-47},\n\t{0x3d6,0x3d6,-1,-54},\n\t{0x3d7,0x3d7,-1,-8},\n\t{0x3d9,0x3ef,2,-1},\n\t{0x3f0,0x3f0,-1,-86},\n\t{0x3f1,0x3f1,-1,-80},\n\t{0x3f2,0x3f2,-1,7},\n\t{0x3f3,0x3f3,-1,-116},\n\t{0x3f5,0x3f5,-1,-96},\n\t{0x3f8,0x3fb,3,-1},\n\t{0x430,0x44f,1,-32},\n\t{0x450,0x45f,1,-80},\n\t{0x461,0x481,2,-1},\n\t{0x48b,0x4bf,2,-1},\n\t{0x4c2,0x4ce,2,-1},\n\t{0x4cf,0x4cf,-1,-15},\n\t{0x4d1,0x52f,2,-1},\n\t{0x561,0x586,1,-48},\n\t{0x10d0,0x10fa,1,3008},\n\t{0x10fd,0x10ff,1,3008},\n\t{0x13f8,0x13fd,1,-8},\n\t{0x1c80,0x1c80,-1,-6254},\n\t{0x1c81,0x1c81,-1,-6253},\n\t{0x1c82,0x1c82,-1,-6244},\n\t{0x1c83,0x1c84,1,-6242},\n\t{0x1c85,0x1c85,-1,-6243},\n\t{0x1c86,0x1c86,-1,-6236},\n\t{0x1c87,0x1c87,-1,-6181},\n\t{0x1c88,0x1c88,-1,35266},\n\t{0x1d79,0x1d79,-1,35332},\n\t{0x1d7d,0x1d7d,-1,3814},\n\t{0x1d8e,0x1d8e,-1,35384},\n\t{0x1e01,0x1e95,2,-1},\n\t{0x1e9b,0x1e9b,-1,-59},\n\t{0x1ea1,0x1eff,2,-1},\n\t{0x1f00,0x1f07,1,8},\n\t{0x1f10,0x1f15,1,8},\n\t{0x1f20,0x1f27,1,8},\n\t{0x1f30,0x1f37,1,8},\n\t{0x1f40,0x1f45,1,8},\n\t{0x1f51,0x1f57,2,8},\n\t{0x1f60,0x1f67,1,8},\n\t{0x1f70,0x1f71,1,74},\n\t{0x1f72,0x1f75,1,86},\n\t{0x1f76,0x1f77,1,100},\n\t{0x1f78,0x1f79,1,128},\n\t{0x1f7a,0x1f7b,1,112},\n\t{0x1f7c,0x1f7d,1,126},\n\t{0x1f80,0x1f87,1,8},\n\t{0x1f90,0x1f97,1,8},\n\t{0x1fa0,0x1fa7,1,8},\n\t{0x1fb0,0x1fb1,1,8},\n\t{0x1fb3,0x1fb3,-1,9},\n\t{0x1fbe,0x1fbe,-1,-7205},\n\t{0x1fc3,0x1fc3,-1,9},\n\t{0x1fd0,0x1fd1,1,8},\n\t{0x1fe0,0x1fe1,1,8},\n\t{0x1fe5,0x1fe5,-1,7},\n\t{0x1ff3,0x1ff3,-1,9},\n\t{0x214e,0x214e,-1,-28},\n\t{0x2170,0x217f,1,-16},\n\t{0x2184,0x2184,-1,-1},\n\t{0x24d0,0x24e9,1,-26},\n\t{0x2c30,0x2c5e,1,-48},\n\t{0x2c61,0x2c61,-1,-1},\n\t{0x2c65,0x2c65,-1,-10795},\n\t{0x2c66,0x2c66,-1,-10792},\n\t{0x2c68,0x2c6c,2,-1},\n\t{0x2c73,0x2c76,3,-1},\n\t{0x2c81,0x2ce3,2,-1},\n\t{0x2cec,0x2cee,2,-1},\n\t{0x2cf3,0x2cf3,-1,-1},\n\t{0x2d00,0x2d25,1,-7264},\n\t{0x2d27,0x2d2d,6,-7264},\n\t{0xa641,0xa66d,2,-1},\n\t{0xa681,0xa69b,2,-1},\n\t{0xa723,0xa72f,2,-1},\n\t{0xa733,0xa76f,2,-1},\n\t{0xa77a,0xa77c,2,-1},\n\t{0xa77f,0xa787,2,-1},\n\t{0xa78c,0xa791,5,-1},\n\t{0xa793,0xa793,-1,-1},\n\t{0xa794,0xa794,-1,48},\n\t{0xa797,0xa7a9,2,-1},\n\t{0xa7b5,0xa7bf,2,-1},\n\t{0xa7c3,0xa7c8,5,-1},\n\t{0xa7ca,0xa7f6,44,-1},\n\t{0xab53,0xab53,-1,-928},\n\t{0xab70,0xabbf,1,-38864},\n\t{0xff41,0xff5a,1,-32},\n\t{0x10428,0x1044f,1,-40},\n\t{0x104d8,0x104fb,1,-40},\n\t{0x10cc0,0x10cf2,1,-64},\n\t{0x118c0,0x118df,1,-32},\n\t{0x16e60,0x16e7f,1,-32},\n\t{0x1e922,0x1e943,1,-34}\n};\n\n/*\n * Return the upper-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_toupper(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style toupper().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOUPPER_ASC(a);\n\n#if defined(HAVE_TOWUPPER) && defined(__STDC_ISO_10646__)\n    // If towupper() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towupper(a);\n#endif\n\n    // For characters below 128 use locale sensitive toupper().\n    if (a < 128)\n\treturn TOUPPER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toUpper, (int)sizeof(toUpper));\n}\n\n    int\nutf_islower(int a)\n{\n    // German sharp s is lower case but has no upper case equivalent.\n    return (utf_toupper(a) != a) || a == 0xdf;\n}\n\n/*\n * Return the lower-case equivalent of \"a\", which is a UCS-4 character.  Use\n * simple case folding.\n */\n    int\nutf_tolower(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style tolower().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOLOWER_ASC(a);\n\n#if defined(HAVE_TOWLOWER) && defined(__STDC_ISO_10646__)\n    // If towlower() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towlower(a);\n#endif\n\n    // For characters below 128 use locale sensitive tolower().\n    if (a < 128)\n\treturn TOLOWER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toLower, (int)sizeof(toLower));\n}\n\n    int\nutf_isupper(int a)\n{\n    return (utf_tolower(a) != a);\n}\n\n    static int\nutf_strnicmp(\n    char_u      *s1,\n    char_u      *s2,\n    size_t      n1,\n    size_t      n2)\n{\n    int\t\tc1, c2, cdiff;\n    char_u\tbuffer[6];\n\n    for (;;)\n    {\n\tc1 = utf_safe_read_char_adv(&s1, &n1);\n\tc2 = utf_safe_read_char_adv(&s2, &n2);\n\n\tif (c1 <= 0 || c2 <= 0)\n\t    break;\n\n\tif (c1 == c2)\n\t    continue;\n\n\tcdiff = utf_fold(c1) - utf_fold(c2);\n\tif (cdiff != 0)\n\t    return cdiff;\n    }\n\n    // some string ended or has an incomplete/illegal character sequence\n\n    if (c1 == 0 || c2 == 0)\n    {\n\t// some string ended. shorter string is smaller\n\tif (c1 == 0 && c2 == 0)\n\t    return 0;\n\treturn c1 == 0 ? -1 : 1;\n    }\n\n    // Continue with bytewise comparison to produce some result that\n    // would make comparison operations involving this function transitive.\n    //\n    // If only one string had an error, comparison should be made with\n    // folded version of the other string. In this case it is enough\n    // to fold just one character to determine the result of comparison.\n\n    if (c1 != -1 && c2 == -1)\n    {\n\tn1 = utf_char2bytes(utf_fold(c1), buffer);\n\ts1 = buffer;\n    }\n    else if (c2 != -1 && c1 == -1)\n    {\n\tn2 = utf_char2bytes(utf_fold(c2), buffer);\n\ts2 = buffer;\n    }\n\n    while (n1 > 0 && n2 > 0 && *s1 != NUL && *s2 != NUL)\n    {\n\tcdiff = (int)(*s1) - (int)(*s2);\n\tif (cdiff != 0)\n\t    return cdiff;\n\n\ts1++;\n\ts2++;\n\tn1--;\n\tn2--;\n    }\n\n    if (n1 > 0 && *s1 == NUL)\n\tn1 = 0;\n    if (n2 > 0 && *s2 == NUL)\n\tn2 = 0;\n\n    if (n1 == 0 && n2 == 0)\n\treturn 0;\n    return n1 == 0 ? -1 : 1;\n}\n\n/*\n * Version of strnicmp() that handles multi-byte characters.\n * Needed for Big5, Shift-JIS and UTF-8 encoding.  Other DBCS encodings can\n * probably use strnicmp(), because there are no ASCII characters in the\n * second byte.\n * Returns zero if s1 and s2 are equal (ignoring case), the difference between\n * two characters otherwise.\n */\n    int\nmb_strnicmp(char_u *s1, char_u *s2, size_t nn)\n{\n    int\t\ti, l;\n    int\t\tcdiff;\n    int\t\tn = (int)nn;\n\n    if (enc_utf8)\n    {\n\treturn utf_strnicmp(s1, s2, nn, nn);\n    }\n    else\n    {\n\tfor (i = 0; i < n; i += l)\n\t{\n\t    if (s1[i] == NUL && s2[i] == NUL)\t// both strings end\n\t\treturn 0;\n\n\t    l = (*mb_ptr2len)(s1 + i);\n\t    if (l <= 1)\n\t    {\n\t\t// Single byte: first check normally, then with ignore case.\n\t\tif (s1[i] != s2[i])\n\t\t{\n\t\t    cdiff = MB_TOLOWER(s1[i]) - MB_TOLOWER(s2[i]);\n\t\t    if (cdiff != 0)\n\t\t\treturn cdiff;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// For non-Unicode multi-byte don't ignore case.\n\t\tif (l > n - i)\n\t\t    l = n - i;\n\t\tcdiff = STRNCMP(s1 + i, s2 + i, l);\n\t\tif (cdiff != 0)\n\t\t    return cdiff;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/*\n * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what\n * 'encoding' has been set to.\n */\n    void\nshow_utf8(void)\n{\n    int\t\tlen;\n    int\t\trlen = 0;\n    char_u\t*line;\n    int\t\tclen;\n    int\t\ti;\n\n    // Get the byte length of the char under the cursor, including composing\n    // characters.\n    line = ml_get_cursor();\n    len = utfc_ptr2len(line);\n    if (len == 0)\n    {\n\tmsg(\"NUL\");\n\treturn;\n    }\n\n    clen = 0;\n    for (i = 0; i < len; ++i)\n    {\n\tif (clen == 0)\n\t{\n\t    // start of (composing) character, get its length\n\t    if (i > 0)\n\t    {\n\t\tSTRCPY(IObuff + rlen, \"+ \");\n\t\trlen += 2;\n\t    }\n\t    clen = utf_ptr2len(line + i);\n\t}\n\tsprintf((char *)IObuff + rlen, \"%02x \",\n\t\t(line[i] == NL) ? NUL : line[i]);  // NUL is stored as NL\n\t--clen;\n\trlen += (int)STRLEN(IObuff + rlen);\n\tif (rlen > IOSIZE - 20)\n\t    break;\n    }\n\n    msg((char *)IObuff);\n}\n\n/*\n * mb_head_off() function pointer.\n * Return offset from \"p\" to the first byte of the character it points into.\n * If \"p\" points to the NUL at the end of the string return 0.\n * Returns 0 when already at the first byte of a character.\n */\n    int\nlatin_head_off(char_u *base UNUSED, char_u *p UNUSED)\n{\n    return 0;\n}\n\n    static int\ndbcs_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    if (p <= base || MB_BYTE2LEN(p[-1]) == 1 || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    q = base;\n    while (q < p)\n\tq += dbcs_ptr2len(q);\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Special version of dbcs_head_off() that works for ScreenLines[], where\n * single-width DBCS_JPNU characters are stored separately.\n */\n    int\ndbcs_screen_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n\n    // It can't be a trailing byte when not using DBCS, at the start of the\n    // string or the previous byte can't start a double-byte.\n    // For euc-jp an 0x8e byte in the previous cell always means we have a\n    // lead byte in the current cell.\n    if (p <= base\n\t    || (enc_dbcs == DBCS_JPNU && p[-1] == 0x8e)\n\t    || MB_BYTE2LEN(p[-1]) == 1\n\t    || *p == NUL)\n\treturn 0;\n\n    // This is slow: need to start at the base and go forward until the\n    // byte we are looking for.  Return 1 when we went past it, 0 otherwise.\n    // For DBCS_JPNU look out for 0x8e, which means the second byte is not\n    // stored as the next byte.\n    q = base;\n    while (q < p)\n    {\n\tif (enc_dbcs == DBCS_JPNU && *q == 0x8e)\n\t    ++q;\n\telse\n\t    q += dbcs_ptr2len(q);\n    }\n    return (q == p) ? 0 : 1;\n}\n\n/*\n * Return offset from \"p\" to the start of a character, including composing\n * characters.  \"base\" must be the start of the string, which must be NUL\n * terminated.\n */\n    int\nutf_head_off(char_u *base, char_u *p)\n{\n    char_u\t*q;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tlen;\n#ifdef FEAT_ARABIC\n    char_u\t*j;\n#endif\n\n    if (*p < 0x80)\t\t// be quick for ASCII\n\treturn 0;\n\n    // Skip backwards over trailing bytes: 10xx.xxxx\n    // Skip backwards again if on a composing char.\n    for (q = p; ; --q)\n    {\n\t// Move s to the last byte of this char.\n\tfor (s = q; (s[1] & 0xc0) == 0x80; ++s)\n\t    ;\n\t// Move q to the first byte of this char.\n\twhile (q > base && (*q & 0xc0) == 0x80)\n\t    --q;\n\t// Check for illegal sequence. Do allow an illegal byte after where we\n\t// started.\n\tlen = utf8len_tab[*q];\n\tif (len != (int)(s - q + 1) && len != (int)(p - q + 1))\n\t    return 0;\n\n\tif (q <= base)\n\t    break;\n\n\tc = utf_ptr2char(q);\n\tif (utf_iscomposing(c))\n\t    continue;\n\n#ifdef FEAT_ARABIC\n\tif (arabic_maycombine(c))\n\t{\n\t    // Advance to get a sneak-peak at the next char\n\t    j = q;\n\t    --j;\n\t    // Move j to the first byte of this char.\n\t    while (j > base && (*j & 0xc0) == 0x80)\n\t\t--j;\n\t    if (arabic_combine(utf_ptr2char(j), c))\n\t\tcontinue;\n\t}\n#endif\n\tbreak;\n    }\n\n    return (int)(p - q);\n}\n\n/*\n * Whether space is NOT allowed before/after 'c'.\n */\n    int\nutf_eat_space(int cc)\n{\n    return ((cc >= 0x2000 && cc <= 0x206F)\t// General punctuations\n\t || (cc >= 0x2e00 && cc <= 0x2e7f)\t// Supplemental punctuations\n\t || (cc >= 0x3000 && cc <= 0x303f)\t// CJK symbols and punctuations\n\t || (cc >= 0xff01 && cc <= 0xff0f)\t// Full width ASCII punctuations\n\t || (cc >= 0xff1a && cc <= 0xff20)\t// ..\n\t || (cc >= 0xff3b && cc <= 0xff40)\t// ..\n\t || (cc >= 0xff5b && cc <= 0xff65));\t// ..\n}\n\n/*\n * Whether line break is allowed before \"cc\".\n */\n    int\nutf_allow_break_before(int cc)\n{\n    static const int BOL_prohibition_punct[] =\n    {\n\t'!',\n\t'%',\n\t')',\n\t',',\n\t':',\n\t';',\n\t'>',\n\t'?',\n\t']',\n\t'}',\n\t0x2019, // \u2019 right single quotation mark\n\t0x201d, // \u201d right double quotation mark\n\t0x2020, // \u2020 dagger\n\t0x2021, // \u2021 double dagger\n\t0x2026, // \u2026 horizontal ellipsis\n\t0x2030, // \u2030 per mille sign\n\t0x2031, // \u2031 per then thousand sign\n\t0x203c, // \u203c double exclamation mark\n\t0x2047, // \u2047 double question mark\n\t0x2048, // \u2048 question exclamation mark\n\t0x2049, // \u2049 exclamation question mark\n\t0x2103, // \u2103 degree celsius\n\t0x2109, // \u2109 degree fahrenheit\n\t0x3001, // \u3001 ideographic comma\n\t0x3002, // \u3002 ideographic full stop\n\t0x3009, // \u3009 right angle bracket\n\t0x300b, // \u300b right double angle bracket\n\t0x300d, // \u300d right corner bracket\n\t0x300f, // \u300f right white corner bracket\n\t0x3011, // \u3011 right black lenticular bracket\n\t0x3015, // \u3015 right tortoise shell bracket\n\t0x3017, // \u3017 right white lenticular bracket\n\t0x3019, // \u3019 right white tortoise shell bracket\n\t0x301b, // \u301b right white square bracket\n\t0xff01, // \uff01 fullwidth exclamation mark\n\t0xff09, // \uff09 fullwidth right parenthesis\n\t0xff0c, // \uff0c fullwidth comma\n\t0xff0e, // \uff0e fullwidth full stop\n\t0xff1a, // \uff1a fullwidth colon\n\t0xff1b, // \uff1b fullwidth semicolon\n\t0xff1f, // \uff1f fullwidth question mark\n\t0xff3d, // \uff3d fullwidth right square bracket\n\t0xff5d, // \uff5d fullwidth right curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(BOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == BOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > BOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != BOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed after \"cc\".\n */\n    static int\nutf_allow_break_after(int cc)\n{\n    static const int EOL_prohibition_punct[] =\n    {\n\t'(',\n\t'<',\n\t'[',\n\t'`',\n\t'{',\n\t//0x2014, // \u2014 em dash\n\t0x2018, // \u2018 left single quotation mark\n\t0x201c, // \u201c left double quotation mark\n\t//0x2053, // \uff5e swung dash\n\t0x3008, // \u3008 left angle bracket\n\t0x300a, // \u300a left double angle bracket\n\t0x300c, // \u300c left corner bracket\n\t0x300e, // \u300e left white corner bracket\n\t0x3010, // \u3010 left black lenticular bracket\n\t0x3014, // \u3014 left tortoise shell bracket\n\t0x3016, // \u3016 left white lenticular bracket\n\t0x3018, // \u3018 left white tortoise shell bracket\n\t0x301a, // \u301a left white square bracket\n\t0xff08, // \uff08 fullwidth left parenthesis\n\t0xff3b, // \uff3b fullwidth left square bracket\n\t0xff5b, // \uff5b fullwidth left curly bracket\n    };\n\n    int first = 0;\n    int last  = ARRAY_LENGTH(EOL_prohibition_punct) - 1;\n    int mid   = 0;\n\n    while (first < last)\n    {\n\tmid = (first + last)/2;\n\n\tif (cc == EOL_prohibition_punct[mid])\n\t    return FALSE;\n\telse if (cc > EOL_prohibition_punct[mid])\n\t    first = mid + 1;\n\telse\n\t    last = mid - 1;\n    }\n\n    return cc != EOL_prohibition_punct[first];\n}\n\n/*\n * Whether line break is allowed between \"cc\" and \"ncc\".\n */\n    int\nutf_allow_break(int cc, int ncc)\n{\n    // don't break between two-letter punctuations\n    if (cc == ncc\n\t    && (cc == 0x2014 // em dash\n\t\t|| cc == 0x2026)) // horizontal ellipsis\n\treturn FALSE;\n\n    return utf_allow_break_after(cc) && utf_allow_break_before(ncc);\n}\n\n/*\n * Copy a character from \"*fp\" to \"*tp\" and advance the pointers.\n */\n    void\nmb_copy_char(char_u **fp, char_u **tp)\n{\n    int\t    l = (*mb_ptr2len)(*fp);\n\n    mch_memmove(*tp, *fp, (size_t)l);\n    *tp += l;\n    *fp += l;\n}\n\n/*\n * Return the offset from \"p\" to the first byte of a character.  When \"p\" is\n * at the start of a character 0 is returned, otherwise the offset to the next\n * character.  Can start anywhere in a stream of bytes.\n */\n    int\nmb_off_next(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (enc_utf8)\n    {\n\tif (*p < 0x80)\t\t// be quick for ASCII\n\t    return 0;\n\n\t// Find the next character that isn't 10xx.xxxx\n\tfor (i = 0; (p[i] & 0xc0) == 0x80; ++i)\n\t    ;\n\tif (i > 0)\n\t{\n\t    // Check for illegal sequence.\n\t    for (j = 0; p - j > base; ++j)\n\t\tif ((p[-j] & 0xc0) != 0x80)\n\t\t    break;\n\t    if (utf8len_tab[p[-j]] != i + j)\n\t\treturn 0;\n\t}\n\treturn i;\n    }\n\n    // Only need to check if we're on a trail byte, it doesn't matter if we\n    // want the offset to the next or current character.\n    return (*mb_head_off)(base, p);\n}\n\n/*\n * Return the offset from \"p\" to the last byte of the character it points\n * into.  Can start anywhere in a stream of bytes.\n * Composing characters are not included.\n */\n    int\nmb_tail_off(char_u *base, char_u *p)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (*p == NUL)\n\treturn 0;\n\n    if (enc_utf8)\n    {\n\t// Find the last character that is 10xx.xxxx\n\tfor (i = 0; (p[i + 1] & 0xc0) == 0x80; ++i)\n\t    ;\n\t// Check for illegal sequence.\n\tfor (j = 0; p - j > base; ++j)\n\t    if ((p[-j] & 0xc0) != 0x80)\n\t\tbreak;\n\tif (utf8len_tab[p[-j]] != i + j + 1)\n\t    return 0;\n\treturn i;\n    }\n\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    if (enc_dbcs == 0 || p[1] == NUL || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_head_off(base, p);\n}\n\n/*\n * Find the next illegal byte sequence.\n */\n    void\nutf_find_illegal(void)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*p;\n    int\t\tlen;\n    vimconv_T\tvimconv;\n    char_u\t*tofree = NULL;\n\n    vimconv.vc_type = CONV_NONE;\n    if (enc_utf8 && (enc_canon_props(curbuf->b_p_fenc) & ENC_8BIT))\n    {\n\t// 'encoding' is \"utf-8\" but we are editing a 8-bit encoded file,\n\t// possibly a utf-8 file with illegal bytes.  Setup for conversion\n\t// from utf-8 to 'fileencoding'.\n\tconvert_setup(&vimconv, p_enc, curbuf->b_p_fenc);\n    }\n\n    curwin->w_cursor.coladd = 0;\n    for (;;)\n    {\n\tp = ml_get_cursor();\n\tif (vimconv.vc_type != CONV_NONE)\n\t{\n\t    vim_free(tofree);\n\t    tofree = string_convert(&vimconv, p, NULL);\n\t    if (tofree == NULL)\n\t\tbreak;\n\t    p = tofree;\n\t}\n\n\twhile (*p != NUL)\n\t{\n\t    // Illegal means that there are not enough trail bytes (checked by\n\t    // utf_ptr2len()) or too many of them (overlong sequence).\n\t    len = utf_ptr2len(p);\n\t    if (*p >= 0x80 && (len == 1\n\t\t\t\t     || utf_char2len(utf_ptr2char(p)) != len))\n\t    {\n\t\tif (vimconv.vc_type == CONV_NONE)\n\t\t    curwin->w_cursor.col += (colnr_T)(p - ml_get_cursor());\n\t\telse\n\t\t{\n\t\t    int\t    l;\n\n\t\t    len = (int)(p - tofree);\n\t\t    for (p = ml_get_cursor(); *p != NUL && len-- > 0; p += l)\n\t\t    {\n\t\t\tl = utf_ptr2len(p);\n\t\t\tcurwin->w_cursor.col += l;\n\t\t    }\n\t\t}\n\t\tgoto theend;\n\t    }\n\t    p += len;\n\t}\n\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t    break;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // didn't find it: don't move and beep\n    curwin->w_cursor = pos;\n    beep_flush();\n\ntheend:\n    vim_free(tofree);\n    convert_setup(&vimconv, NULL, NULL);\n}\n\n#if defined(FEAT_GUI_GTK) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return TRUE if string \"s\" is a valid utf-8 string.\n * When \"end\" is NULL stop at the first NUL.  Otherwise stop at \"end\".\n */\n    int\nutf_valid_string(char_u *s, char_u *end)\n{\n    int\t\tl;\n    char_u\t*p = s;\n\n    while (end == NULL ? *p != NUL : p < end)\n    {\n\tl = utf8len_tab_zero[*p];\n\tif (l == 0)\n\t    return FALSE;\t// invalid lead byte\n\tif (end != NULL && p + l > end)\n\t    return FALSE;\t// incomplete byte sequence\n\t++p;\n\twhile (--l > 0)\n\t    if ((*p++ & 0xc0) != 0x80)\n\t\treturn FALSE;\t// invalid trail byte\n    }\n    return TRUE;\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Special version of mb_tail_off() for use in ScreenLines[].\n */\n    int\ndbcs_screen_tail_off(char_u *base, char_u *p)\n{\n    // It can't be the first byte if a double-byte when not using DBCS, at the\n    // end of the string or the byte can't start a double-byte.\n    // For euc-jp an 0x8e byte always means we have a lead byte in the current\n    // cell.\n    if (*p == NUL || p[1] == NUL\n\t    || (enc_dbcs == DBCS_JPNU && *p == 0x8e)\n\t    || MB_BYTE2LEN(*p) == 1)\n\treturn 0;\n\n    // Return 1 when on the lead byte, 0 when on the tail byte.\n    return 1 - dbcs_screen_head_off(base, p);\n}\n#endif\n\n/*\n * If the cursor moves on an trail byte, set the cursor on the lead byte.\n * Thus it moves left if necessary.\n * Return TRUE when the cursor was adjusted.\n */\n    void\nmb_adjust_cursor(void)\n{\n    mb_adjustpos(curbuf, &curwin->w_cursor);\n}\n\n/*\n * Adjust position \"*lp\" to point to the first byte of a multi-byte character.\n * If it points to a tail byte it's moved backwards to the head byte.\n */\n    void\nmb_adjustpos(buf_T *buf, pos_T *lp)\n{\n    char_u\t*p;\n\n    if (lp->col > 0 || lp->coladd > 1)\n    {\n\tp = ml_get_buf(buf, lp->lnum, FALSE);\n\tif (*p == NUL || (int)STRLEN(p) < lp->col)\n\t    lp->col = 0;\n\telse\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\t// Reset \"coladd\" when the cursor would be on the right half of a\n\t// double-wide character.\n\tif (lp->coladd == 1\n\t\t&& p[lp->col] != TAB\n\t\t&& vim_isprintc((*mb_ptr2char)(p + lp->col))\n\t\t&& ptr2cells(p + lp->col) > 1)\n\t    lp->coladd = 0;\n    }\n}\n\n/*\n * Return a pointer to the character before \"*p\", if there is one.\n */\n    char_u *\nmb_prevptr(\n    char_u *line,\t// start of the string\n    char_u *p)\n{\n    if (p > line)\n\tMB_PTR_BACK(line, p);\n    return p;\n}\n\n/*\n * Return the character length of \"str\".  Each multi-byte character (with\n * following composing characters) counts as one.\n */\n    int\nmb_charlen(char_u *str)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    if (p == NULL)\n\treturn 0;\n\n    for (count = 0; *p != NUL; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Like mb_charlen() but for a string with specified length.\n */\n    int\nmb_charlen_len(char_u *str, int len)\n{\n    char_u\t*p = str;\n    int\t\tcount;\n\n    for (count = 0; *p != NUL && p < str + len; count++)\n\tp += (*mb_ptr2len)(p);\n\n    return count;\n}\n\n/*\n * Try to un-escape a multi-byte character.\n * Used for the \"to\" and \"from\" part of a mapping.\n * Return the un-escaped string if it is a multi-byte character, and advance\n * \"pp\" to just after the bytes that formed it.\n * Return NULL if no multi-byte char was found.\n */\n    char_u *\nmb_unescape(char_u **pp)\n{\n    static char_u\tbuf[6];\n    int\t\t\tn;\n    int\t\t\tm = 0;\n    char_u\t\t*str = *pp;\n\n    // Must translate K_SPECIAL KS_SPECIAL KE_FILLER to K_SPECIAL and CSI\n    // KS_EXTRA KE_CSI to CSI.\n    // Maximum length of a utf-8 character is 4 bytes.\n    for (n = 0; str[n] != NUL && m < 4; ++n)\n    {\n\tif (str[n] == K_SPECIAL\n\t\t&& str[n + 1] == KS_SPECIAL\n\t\t&& str[n + 2] == KE_FILLER)\n\t{\n\t    buf[m++] = K_SPECIAL;\n\t    n += 2;\n\t}\n\telse if ((str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t    || str[n] == CSI\n# endif\n\t\t )\n\t\t&& str[n + 1] == KS_EXTRA\n\t\t&& str[n + 2] == (int)KE_CSI)\n\t{\n\t    buf[m++] = CSI;\n\t    n += 2;\n\t}\n\telse if (str[n] == K_SPECIAL\n# ifdef FEAT_GUI\n\t\t|| str[n] == CSI\n# endif\n\t\t)\n\t    break;\t\t// a special key can't be a multibyte char\n\telse\n\t    buf[m++] = str[n];\n\tbuf[m] = NUL;\n\n\t// Return a multi-byte character if it's found.  An illegal sequence\n\t// will result in a 1 here.\n\tif ((*mb_ptr2len)(buf) > 1)\n\t{\n\t    *pp = str + n + 1;\n\t    return buf;\n\t}\n\n\t// Bail out quickly for ASCII.\n\tif (buf[0] < 128)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Return TRUE if the character at \"row\"/\"col\" on the screen is the left side\n * of a double-width character.\n * Caller must make sure \"row\" and \"col\" are not invalid!\n */\n    int\nmb_lefthalve(int row, int col)\n{\n    return (*mb_off2cells)(LineOffset[row] + col,\n\t\t\t\t\tLineOffset[row] + screen_Columns) > 1;\n}\n\n/*\n * Correct a position on the screen, if it's the right half of a double-wide\n * char move it to the left half.  Returns the corrected column.\n */\n    int\nmb_fix_col(int col, int row)\n{\n    int off;\n\n    col = check_col(col);\n    row = check_row(row);\n    off = LineOffset[row] + col;\n    if (has_mbyte && ScreenLines != NULL && col > 0\n\t    && ((enc_dbcs\n\t\t    && ScreenLines[off] != NUL\n\t\t    && dbcs_screen_head_off(ScreenLines + LineOffset[row],\n\t\t\t\t\t ScreenLines + off))\n\t\t|| (enc_utf8 && ScreenLines[off] == 0\n\t\t\t\t\t\t  && ScreenLinesUC[off] == 0)))\n\treturn col - 1;\n    return col;\n}\n\nstatic int enc_alias_search(char_u *name);\n\n/*\n * Skip the Vim specific head of a 'encoding' name.\n */\n    char_u *\nenc_skip(char_u *p)\n{\n    if (STRNCMP(p, \"2byte-\", 6) == 0)\n\treturn p + 6;\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\treturn p + 5;\n    return p;\n}\n\n/*\n * Find the canonical name for encoding \"enc\".\n * When the name isn't recognized, returns \"enc\" itself, but with all lower\n * case characters and '_' replaced with '-'.\n * Returns an allocated string.  NULL for out-of-memory.\n */\n    char_u *\nenc_canonize(char_u *enc)\n{\n    char_u\t*r;\n    char_u\t*p, *s;\n    int\t\ti;\n\n    if (STRCMP(enc, \"default\") == 0)\n    {\n#ifdef MSWIN\n\t// Use the system encoding, the default is always utf-8.\n\tr = enc_locale();\n#else\n\t// Use the default encoding as it's found by set_init_1().\n\tr = get_encoding_default();\n#endif\n\tif (r == NULL)\n\t    r = (char_u *)ENC_DFLT;\n\treturn vim_strsave(r);\n    }\n\n    // copy \"enc\" to allocated memory, with room for two '-'\n    r = alloc(STRLEN(enc) + 3);\n    if (r != NULL)\n    {\n\t// Make it all lower case and replace '_' with '-'.\n\tp = r;\n\tfor (s = enc; *s != NUL; ++s)\n\t{\n\t    if (*s == '_')\n\t\t*p++ = '-';\n\t    else\n\t\t*p++ = TOLOWER_ASC(*s);\n\t}\n\t*p = NUL;\n\n\t// Skip \"2byte-\" and \"8bit-\".\n\tp = enc_skip(r);\n\n\t// Change \"microsoft-cp\" to \"cp\".  Used in some spell files.\n\tif (STRNCMP(p, \"microsoft-cp\", 12) == 0)\n\t    STRMOVE(p, p + 10);\n\n\t// \"iso8859\" -> \"iso-8859\"\n\tif (STRNCMP(p, \"iso8859\", 7) == 0)\n\t{\n\t    STRMOVE(p + 4, p + 3);\n\t    p[3] = '-';\n\t}\n\n\t// \"iso-8859n\" -> \"iso-8859-n\"\n\tif (STRNCMP(p, \"iso-8859\", 8) == 0 && isdigit(p[8]))\n\t{\n\t    STRMOVE(p + 9, p + 8);\n\t    p[8] = '-';\n\t}\n\n\t// \"latin-N\" -> \"latinN\"\n\tif (STRNCMP(p, \"latin-\", 6) == 0)\n\t    STRMOVE(p + 5, p + 6);\n\n\tif (enc_canon_search(p) >= 0)\n\t{\n\t    // canonical name can be used unmodified\n\t    if (p != r)\n\t\tSTRMOVE(r, p);\n\t}\n\telse if ((i = enc_alias_search(p)) >= 0)\n\t{\n\t    // alias recognized, get canonical name\n\t    vim_free(r);\n\t    r = vim_strsave((char_u *)enc_canon_table[i].name);\n\t}\n    }\n    return r;\n}\n\n/*\n * Search for an encoding alias of \"name\".\n * Returns -1 when not found.\n */\n    static int\nenc_alias_search(char_u *name)\n{\n    int\t\ti;\n\n    for (i = 0; enc_alias_table[i].name != NULL; ++i)\n\tif (STRCMP(name, enc_alias_table[i].name) == 0)\n\t    return enc_alias_table[i].canon;\n    return -1;\n}\n\n\n#ifdef HAVE_LANGINFO_H\n# include <langinfo.h>\n#endif\n\n#if !defined(FEAT_GUI_MSWIN) || defined(VIMDLL)\n/*\n * Get the canonicalized encoding from the specified locale string \"locale\"\n * or from the environment variables LC_ALL, LC_CTYPE and LANG.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale_env(char *locale)\n{\n    char\t*s = locale;\n    char\t*p;\n    int\t\ti;\n    char\tbuf[50];\n\n    if (s == NULL || *s == NUL)\n\tif ((s = getenv(\"LC_ALL\")) == NULL || *s == NUL)\n\t    if ((s = getenv(\"LC_CTYPE\")) == NULL || *s == NUL)\n\t\ts = getenv(\"LANG\");\n\n    if (s == NULL || *s == NUL)\n\treturn NULL;\n\n    // The most generic locale format is:\n    // language[_territory][.codeset][@modifier][+special][,[sponsor][_revision]]\n    // If there is a '.' remove the part before it.\n    // if there is something after the codeset, remove it.\n    // Make the name lowercase and replace '_' with '-'.\n    // Exception: \"ja_JP.EUC\" == \"euc-jp\", \"zh_CN.EUC\" = \"euc-cn\",\n    // \"ko_KR.EUC\" == \"euc-kr\"\n    if ((p = (char *)vim_strchr((char_u *)s, '.')) != NULL)\n    {\n\tif (p > s + 2 && STRNICMP(p + 1, \"EUC\", 3) == 0\n\t\t\t&& !isalnum((int)p[4]) && p[4] != '-' && p[-3] == '_')\n\t{\n\t    // copy \"XY.EUC\" to \"euc-XY\" to buf[10]\n\t    STRCPY(buf + 10, \"euc-\");\n\t    buf[14] = p[-2];\n\t    buf[15] = p[-1];\n\t    buf[16] = 0;\n\t    s = buf + 10;\n\t}\n\telse\n\t    s = p + 1;\n    }\n    for (i = 0; i < (int)sizeof(buf) - 1 && s[i] != NUL; ++i)\n    {\n\tif (s[i] == '_' || s[i] == '-')\n\t    buf[i] = '-';\n\telse if (isalnum((int)s[i]))\n\t    buf[i] = TOLOWER_ASC(s[i]);\n\telse\n\t    break;\n    }\n    buf[i] = NUL;\n\n    return enc_canonize((char_u *)buf);\n}\n#endif\n\n/*\n * Get the canonicalized encoding of the current locale.\n * Returns an allocated string when successful, NULL when not.\n */\n    char_u *\nenc_locale(void)\n{\n#ifdef MSWIN\n    char\tbuf[50];\n    long\tacp = GetACP();\n\n    if (acp == 1200)\n\tSTRCPY(buf, \"ucs-2le\");\n    else if (acp == 1252)\t    // cp1252 is used as latin1\n\tSTRCPY(buf, \"latin1\");\n    else if (acp == 65001)\n\tSTRCPY(buf, \"utf-8\");\n    else\n\tsprintf(buf, \"cp%ld\", acp);\n\n    return enc_canonize((char_u *)buf);\n#else\n    char\t*s;\n\n# ifdef HAVE_NL_LANGINFO_CODESET\n    if ((s = nl_langinfo(CODESET)) == NULL || *s == NUL)\n# endif\n# if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n\tif ((s = setlocale(LC_CTYPE, NULL)) == NULL || *s == NUL)\n# endif\n\t    s = NULL;\n\n    return enc_locale_env(s);\n#endif\n}\n\n# if defined(MSWIN) || defined(PROTO) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)\n/*\n * Convert an encoding name to an MS-Windows codepage.\n * Returns zero if no codepage can be figured out.\n */\n    int\nencname2codepage(char_u *name)\n{\n    int\t\tcp;\n    char_u\t*p = name;\n    int\t\tidx;\n\n    if (STRNCMP(p, \"8bit-\", 5) == 0)\n\tp += 5;\n    else if (STRNCMP(p_enc, \"2byte-\", 6) == 0)\n\tp += 6;\n\n    if (p[0] == 'c' && p[1] == 'p')\n\tcp = atoi((char *)p + 2);\n    else if ((idx = enc_canon_search(p)) >= 0)\n\tcp = enc_canon_table[idx].codepage;\n    else\n\treturn 0;\n    if (IsValidCodePage(cp))\n\treturn cp;\n    return 0;\n}\n# endif\n\n# if defined(USE_ICONV) || defined(PROTO)\n\n/*\n * Call iconv_open() with a check if iconv() works properly (there are broken\n * versions).\n * Returns (void *)-1 if failed.\n * (should return iconv_t, but that causes problems with prototypes).\n */\n    void *\nmy_iconv_open(char_u *to, char_u *from)\n{\n    iconv_t\tfd;\n#define ICONV_TESTLEN 400\n    char_u\ttobuf[ICONV_TESTLEN];\n    char\t*p;\n    size_t\ttolen;\n    static int\ticonv_ok = -1;\n\n    if (iconv_ok == FALSE)\n\treturn (void *)-1;\t// detected a broken iconv() previously\n\n#ifdef DYNAMIC_ICONV\n    // Check if the iconv.dll can be found.\n    if (!iconv_enabled(TRUE))\n\treturn (void *)-1;\n#endif\n\n    fd = iconv_open((char *)enc_skip(to), (char *)enc_skip(from));\n\n    if (fd != (iconv_t)-1 && iconv_ok == -1)\n    {\n\t/*\n\t * Do a dummy iconv() call to check if it actually works.  There is a\n\t * version of iconv() on Linux that is broken.  We can't ignore it,\n\t * because it's wide-spread.  The symptoms are that after outputting\n\t * the initial shift state the \"to\" pointer is NULL and conversion\n\t * stops for no apparent reason after about 8160 characters.\n\t */\n\tp = (char *)tobuf;\n\ttolen = ICONV_TESTLEN;\n\t(void)iconv(fd, NULL, NULL, &p, &tolen);\n\tif (p == NULL)\n\t{\n\t    iconv_ok = FALSE;\n\t    iconv_close(fd);\n\t    fd = (iconv_t)-1;\n\t}\n\telse\n\t    iconv_ok = TRUE;\n    }\n\n    return (void *)fd;\n}\n\n/*\n * Convert the string \"str[slen]\" with iconv().\n * If \"unconvlenp\" is not NULL handle the string ending in an incomplete\n * sequence and set \"*unconvlenp\" to the length of it.\n * Returns the converted string in allocated memory.  NULL for an error.\n * If resultlenp is not NULL, sets it to the result length in bytes.\n */\n    static char_u *\niconv_string(\n    vimconv_T\t*vcp,\n    char_u\t*str,\n    int\t\tslen,\n    int\t\t*unconvlenp,\n    int\t\t*resultlenp)\n{\n    const char\t*from;\n    size_t\tfromlen;\n    char\t*to;\n    size_t\ttolen;\n    size_t\tlen = 0;\n    size_t\tdone = 0;\n    char_u\t*result = NULL;\n    char_u\t*p;\n    int\t\tl;\n\n    from = (char *)str;\n    fromlen = slen;\n    for (;;)\n    {\n\tif (len == 0 || ICONV_ERRNO == ICONV_E2BIG)\n\t{\n\t    // Allocate enough room for most conversions.  When re-allocating\n\t    // increase the buffer size.\n\t    len = len + fromlen * 2 + 40;\n\t    p = alloc(len);\n\t    if (p != NULL && done > 0)\n\t\tmch_memmove(p, result, done);\n\t    vim_free(result);\n\t    result = p;\n\t    if (result == NULL)\t// out of memory\n\t\tbreak;\n\t}\n\n\tto = (char *)result + done;\n\ttolen = len - done - 2;\n\t// Avoid a warning for systems with a wrong iconv() prototype by\n\t// casting the second argument to void *.\n\tif (iconv(vcp->vc_fd, (void *)&from, &fromlen, &to, &tolen)\n\t\t\t\t\t\t\t\t!= (size_t)-1)\n\t{\n\t    // Finished, append a NUL.\n\t    *to = NUL;\n\t    break;\n\t}\n\n\t// Check both ICONV_EINVAL and EINVAL, because the dynamically loaded\n\t// iconv library may use one of them.\n\tif (!vcp->vc_fail && unconvlenp != NULL\n\t\t&& (ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Handle an incomplete sequence at the end.\n\t    *to = NUL;\n\t    *unconvlenp = (int)fromlen;\n\t    break;\n\t}\n\n\t// Check both ICONV_EILSEQ and EILSEQ, because the dynamically loaded\n\t// iconv library may use one of them.\n\telse if (!vcp->vc_fail\n\t\t&& (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ\n\t\t    || ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL))\n\t{\n\t    // Can't convert: insert a '?' and skip a character.  This assumes\n\t    // conversion from 'encoding' to something else.  In other\n\t    // situations we don't know what to skip anyway.\n\t    *to++ = '?';\n\t    if ((*mb_ptr2cells)((char_u *)from) > 1)\n\t\t*to++ = '?';\n\t    if (enc_utf8)\n\t\tl = utfc_ptr2len_len((char_u *)from, (int)fromlen);\n\t    else\n\t    {\n\t\tl = (*mb_ptr2len)((char_u *)from);\n\t\tif (l > (int)fromlen)\n\t\t    l = (int)fromlen;\n\t    }\n\t    from += l;\n\t    fromlen -= l;\n\t}\n\telse if (ICONV_ERRNO != ICONV_E2BIG)\n\t{\n\t    // conversion failed\n\t    VIM_CLEAR(result);\n\t    break;\n\t}\n\t// Not enough room or skipping illegal sequence.\n\tdone = to - (char *)result;\n    }\n\n    if (resultlenp != NULL && result != NULL)\n\t*resultlenp = (int)(to - (char *)result);\n    return result;\n}\n\n#  if defined(DYNAMIC_ICONV) || defined(PROTO)\n/*\n * Dynamically load the \"iconv.dll\" on Win32.\n */\n\n#   ifndef DYNAMIC_ICONV\t    // must be generating prototypes\n#    define HINSTANCE int\n#   endif\nstatic HINSTANCE hIconvDLL = 0;\nstatic HINSTANCE hMsvcrtDLL = 0;\n\n#   ifndef DYNAMIC_ICONV_DLL\n#    define DYNAMIC_ICONV_DLL \"iconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT1 \"libiconv.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT2 \"libiconv2.dll\"\n#    define DYNAMIC_ICONV_DLL_ALT3 \"libiconv-2.dll\"\n#   endif\n#   ifndef DYNAMIC_MSVCRT_DLL\n#    define DYNAMIC_MSVCRT_DLL \"msvcrt.dll\"\n#   endif\n\n/*\n * Try opening the iconv.dll and return TRUE if iconv() can be used.\n */\n    int\niconv_enabled(int verbose)\n{\n    if (hIconvDLL != 0 && hMsvcrtDLL != 0)\n\treturn TRUE;\n\n    // The iconv DLL file goes under different names, try them all.\n    // Do the \"2\" version first, it's newer.\n#ifdef DYNAMIC_ICONV_DLL_ALT2\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT2);\n#endif\n#ifdef DYNAMIC_ICONV_DLL_ALT3\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT3);\n#endif\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL);\n#ifdef DYNAMIC_ICONV_DLL_ALT1\n    if (hIconvDLL == 0)\n\thIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT1);\n#endif\n\n    if (hIconvDLL != 0)\n\thMsvcrtDLL = vimLoadLib(DYNAMIC_MSVCRT_DLL);\n    if (hIconvDLL == 0 || hMsvcrtDLL == 0)\n    {\n\t// Only give the message when 'verbose' is set, otherwise it might be\n\t// done whenever a conversion is attempted.\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_str_str),\n\t\t    hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL,\n\t\t    GetWin32Error());\n\t    verbose_leave();\n\t}\n\ticonv_end();\n\treturn FALSE;\n    }\n\n    iconv\t= (size_t (*)(iconv_t, const char **,\n\t\t\tsize_t *, char **, size_t *))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconv\");\n    iconv_open\t= (iconv_t (*)(const char *, const char *))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconv_open\");\n    iconv_close\t= (int (*)(iconv_t))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconv_close\");\n    iconvctl\t= (int (*)(iconv_t, int, void *))\n\t\t\t\tGetProcAddress(hIconvDLL, \"libiconvctl\");\n    iconv_errno\t= (int *(*)(void))get_dll_import_func(hIconvDLL, \"_errno\");\n    if (iconv_errno == NULL)\n\ticonv_errno = (int *(*)(void))GetProcAddress(hMsvcrtDLL, \"_errno\");\n    if (iconv == NULL || iconv_open == NULL || iconv_close == NULL\n\t    || iconvctl == NULL || iconv_errno == NULL)\n    {\n\ticonv_end();\n\tif (verbose && p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    semsg(_(e_could_not_load_library_function_str), \"for libiconv\");\n\t    verbose_leave();\n\t}\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n    void\niconv_end(void)\n{\n    // Don't use iconv() when inputting or outputting characters.\n    if (input_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&input_conv, NULL, NULL);\n    if (output_conv.vc_type == CONV_ICONV)\n\tconvert_setup(&output_conv, NULL, NULL);\n\n    if (hIconvDLL != 0)\n\tFreeLibrary(hIconvDLL);\n    if (hMsvcrtDLL != 0)\n\tFreeLibrary(hMsvcrtDLL);\n    hIconvDLL = 0;\n    hMsvcrtDLL = 0;\n}\n#  endif // DYNAMIC_ICONV\n# endif // USE_ICONV\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"getimstatus()\" function\n */\n    void\nf_getimstatus(typval_T *argvars UNUSED, typval_T *rettv)\n{\n# if defined(HAVE_INPUT_METHOD)\n    rettv->vval.v_number = im_get_status();\n# endif\n}\n\n/*\n * iconv() function\n */\n    void\nf_iconv(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    char_u\tbuf1[NUMBUFLEN];\n    char_u\tbuf2[NUMBUFLEN];\n    char_u\t*from, *to, *str;\n    vimconv_T\tvimconv;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    str = tv_get_string(&argvars[0]);\n    from = enc_canonize(enc_skip(tv_get_string_buf(&argvars[1], buf1)));\n    to = enc_canonize(enc_skip(tv_get_string_buf(&argvars[2], buf2)));\n    vimconv.vc_type = CONV_NONE;\n    convert_setup(&vimconv, from, to);\n\n    // If the encodings are equal, no conversion needed.\n    if (vimconv.vc_type == CONV_NONE)\n\trettv->vval.v_string = vim_strsave(str);\n    else\n\trettv->vval.v_string = string_convert(&vimconv, str, NULL);\n\n    convert_setup(&vimconv, NULL, NULL);\n    vim_free(from);\n    vim_free(to);\n}\n#endif\n\n/*\n * Setup \"vcp\" for conversion from \"from\" to \"to\".\n * The names must have been made canonical with enc_canonize().\n * vcp->vc_type must have been initialized to CONV_NONE.\n * Note: cannot be used for conversion from/to ucs-2 and ucs-4 (will use utf-8\n * instead).\n * Afterwards invoke with \"from\" and \"to\" equal to NULL to cleanup.\n * Return FAIL when conversion is not supported, OK otherwise.\n */\n    int\nconvert_setup(vimconv_T *vcp, char_u *from, char_u *to)\n{\n    return convert_setup_ext(vcp, from, TRUE, to, TRUE);\n}\n\n/*\n * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all\n * \"from\" unicode charsets be considered utf-8.  Same for \"to\".\n */\n    int\nconvert_setup_ext(\n    vimconv_T\t*vcp,\n    char_u\t*from,\n    int\t\tfrom_unicode_is_utf8,\n    char_u\t*to,\n    int\t\tto_unicode_is_utf8)\n{\n    int\t\tfrom_prop;\n    int\t\tto_prop;\n    int\t\tfrom_is_utf8;\n    int\t\tto_is_utf8;\n\n    // Reset to no conversion.\n#ifdef USE_ICONV\n    if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)\n\ticonv_close(vcp->vc_fd);\n#endif\n    vcp->vc_type = CONV_NONE;\n    vcp->vc_factor = 1;\n    vcp->vc_fail = FALSE;\n\n    // No conversion when one of the names is empty or they are equal.\n    if (from == NULL || *from == NUL || to == NULL || *to == NUL\n\t\t\t\t\t\t     || STRCMP(from, to) == 0)\n\treturn OK;\n\n    from_prop = enc_canon_props(from);\n    to_prop = enc_canon_props(to);\n    if (from_unicode_is_utf8)\n\tfrom_is_utf8 = from_prop & ENC_UNICODE;\n    else\n\tfrom_is_utf8 = from_prop == ENC_UNICODE;\n    if (to_unicode_is_utf8)\n\tto_is_utf8 = to_prop & ENC_UNICODE;\n    else\n\tto_is_utf8 = to_prop == ENC_UNICODE;\n\n    if ((from_prop & ENC_LATIN1) && to_is_utf8)\n    {\n\t// Internal latin1 -> utf-8 conversion.\n\tvcp->vc_type = CONV_TO_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN9) && to_is_utf8)\n    {\n\t// Internal latin9 -> utf-8 conversion.\n\tvcp->vc_type = CONV_9_TO_UTF8;\n\tvcp->vc_factor = 3;\t// up to three as long (euro sign)\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN1))\n    {\n\t// Internal utf-8 -> latin1 conversion.\n\tvcp->vc_type = CONV_TO_LATIN1;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_LATIN9))\n    {\n\t// Internal utf-8 -> latin9 conversion.\n\tvcp->vc_type = CONV_TO_LATIN9;\n    }\n#ifdef MSWIN\n    // Win32-specific codepage <-> codepage conversion without iconv.\n    else if ((from_is_utf8 || encname2codepage(from) > 0)\n\t    && (to_is_utf8 || encname2codepage(to) > 0))\n    {\n\tvcp->vc_type = CONV_CODEPAGE;\n\tvcp->vc_factor = 2;\t// up to twice as long\n\tvcp->vc_cpfrom = from_is_utf8 ? 0 : encname2codepage(from);\n\tvcp->vc_cpto = to_is_utf8 ? 0 : encname2codepage(to);\n    }\n#endif\n#ifdef MACOS_CONVERT\n    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_LATIN1))\n    {\n\tvcp->vc_type = CONV_MAC_LATIN1;\n    }\n    else if ((from_prop & ENC_MACROMAN) && to_is_utf8)\n    {\n\tvcp->vc_type = CONV_MAC_UTF8;\n\tvcp->vc_factor = 2;\t// up to twice as long\n    }\n    else if ((from_prop & ENC_LATIN1) && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_LATIN1_MAC;\n    }\n    else if (from_is_utf8 && (to_prop & ENC_MACROMAN))\n    {\n\tvcp->vc_type = CONV_UTF8_MAC;\n    }\n#endif\n#ifdef USE_ICONV\n    else\n    {\n\t// Use iconv() for conversion.\n\tvcp->vc_fd = (iconv_t)my_iconv_open(\n\t\tto_is_utf8 ? (char_u *)\"utf-8\" : to,\n\t\tfrom_is_utf8 ? (char_u *)\"utf-8\" : from);\n\tif (vcp->vc_fd != (iconv_t)-1)\n\t{\n\t    vcp->vc_type = CONV_ICONV;\n\t    vcp->vc_factor = 4;\t// could be longer too...\n\t}\n    }\n#endif\n    if (vcp->vc_type == CONV_NONE)\n\treturn FAIL;\n\n    return OK;\n}\n\n#if defined(FEAT_GUI) || defined(AMIGA) || defined(MSWIN) \\\n\t|| defined(PROTO)\n/*\n * Do conversion on typed input characters in-place.\n * The input and output are not NUL terminated!\n * Returns the length after conversion.\n */\n    int\nconvert_input(char_u *ptr, int len, int maxlen)\n{\n    return convert_input_safe(ptr, len, maxlen, NULL, NULL);\n}\n#endif\n\n/*\n * Like convert_input(), but when there is an incomplete byte sequence at the\n * end return that as an allocated string in \"restp\" and set \"*restlenp\" to\n * the length.  If \"restp\" is NULL it is not used.\n */\n    int\nconvert_input_safe(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tmaxlen,\n    char_u\t**restp,\n    int\t\t*restlenp)\n{\n    char_u\t*d;\n    int\t\tdlen = len;\n    int\t\tunconvertlen = 0;\n\n    d = string_convert_ext(&input_conv, ptr, &dlen,\n\t\t\t\t\trestp == NULL ? NULL : &unconvertlen);\n    if (d != NULL)\n    {\n\tif (dlen <= maxlen)\n\t{\n\t    if (unconvertlen > 0)\n\t    {\n\t\t// Move the unconverted characters to allocated memory.\n\t\t*restp = alloc(unconvertlen);\n\t\tif (*restp != NULL)\n\t\t    mch_memmove(*restp, ptr + len - unconvertlen, unconvertlen);\n\t\t*restlenp = unconvertlen;\n\t    }\n\t    mch_memmove(ptr, d, dlen);\n\t}\n\telse\n\t    // result is too long, keep the unconverted text (the caller must\n\t    // have done something wrong!)\n\t    dlen = len;\n\tvim_free(d);\n    }\n    return dlen;\n}\n\n/*\n * Convert text \"ptr[*lenp]\" according to \"vcp\".\n * Returns the result in allocated memory and sets \"*lenp\".\n * When \"lenp\" is NULL, use NUL terminated strings.\n * Illegal chars are often changed to \"?\", unless vcp->vc_fail is set.\n * When something goes wrong, NULL is returned and \"*lenp\" is unchanged.\n */\n    char_u *\nstring_convert(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp)\n{\n    return string_convert_ext(vcp, ptr, lenp, NULL);\n}\n\n/*\n * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is\n * an incomplete sequence at the end it is not converted and \"*unconvlenp\" is\n * set to the number of remaining bytes.\n */\n    char_u *\nstring_convert_ext(\n    vimconv_T\t*vcp,\n    char_u\t*ptr,\n    int\t\t*lenp,\n    int\t\t*unconvlenp)\n{\n    char_u\t*retval = NULL;\n    char_u\t*d;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tl;\n    int\t\tc;\n\n    if (lenp == NULL)\n\tlen = (int)STRLEN(ptr);\n    else\n\tlen = *lenp;\n    if (len == 0)\n\treturn vim_strsave((char_u *)\"\");\n\n    switch (vcp->vc_type)\n    {\n\tcase CONV_TO_UTF8:\t// latin1 to utf-8 conversion\n\t    retval = alloc(len * 2 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tif (c < 0x80)\n\t\t    *d++ = c;\n\t\telse\n\t\t{\n\t\t    *d++ = 0xc0 + ((unsigned)c >> 6);\n\t\t    *d++ = 0x80 + (c & 0x3f);\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_9_TO_UTF8:\t// latin9 to utf-8 conversion\n\t    retval = alloc(len * 3 + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tc = ptr[i];\n\t\tswitch (c)\n\t\t{\n\t\t    case 0xa4: c = 0x20ac; break;   // euro\n\t\t    case 0xa6: c = 0x0160; break;   // S hat\n\t\t    case 0xa8: c = 0x0161; break;   // S -hat\n\t\t    case 0xb4: c = 0x017d; break;   // Z hat\n\t\t    case 0xb8: c = 0x017e; break;   // Z -hat\n\t\t    case 0xbc: c = 0x0152; break;   // OE\n\t\t    case 0xbd: c = 0x0153; break;   // oe\n\t\t    case 0xbe: c = 0x0178; break;   // Y\n\t\t}\n\t\td += utf_char2bytes(c, d);\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n\tcase CONV_TO_LATIN1:\t// utf-8 to latin1 conversion\n\tcase CONV_TO_LATIN9:\t// utf-8 to latin9 conversion\n\t    retval = alloc(len + 1);\n\t    if (retval == NULL)\n\t\tbreak;\n\t    d = retval;\n\t    for (i = 0; i < len; ++i)\n\t    {\n\t\tl = utf_ptr2len_len(ptr + i, len - i);\n\t\tif (l == 0)\n\t\t    *d++ = NUL;\n\t\telse if (l == 1)\n\t\t{\n\t\t    int l_w = utf8len_tab_zero[ptr[i]];\n\n\t\t    if (l_w == 0)\n\t\t    {\n\t\t\t// Illegal utf-8 byte cannot be converted\n\t\t\tvim_free(retval);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (unconvlenp != NULL && l_w > len - i)\n\t\t    {\n\t\t\t// Incomplete sequence at the end.\n\t\t\t*unconvlenp = len - i;\n\t\t\tbreak;\n\t\t    }\n\t\t    *d++ = ptr[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = utf_ptr2char(ptr + i);\n\t\t    if (vcp->vc_type == CONV_TO_LATIN9)\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\t    case 0x20ac: c = 0xa4; break;   // euro\n\t\t\t    case 0x0160: c = 0xa6; break;   // S hat\n\t\t\t    case 0x0161: c = 0xa8; break;   // S -hat\n\t\t\t    case 0x017d: c = 0xb4; break;   // Z hat\n\t\t\t    case 0x017e: c = 0xb8; break;   // Z -hat\n\t\t\t    case 0x0152: c = 0xbc; break;   // OE\n\t\t\t    case 0x0153: c = 0xbd; break;   // oe\n\t\t\t    case 0x0178: c = 0xbe; break;   // Y\n\t\t\t    case 0xa4:\n\t\t\t    case 0xa6:\n\t\t\t    case 0xa8:\n\t\t\t    case 0xb4:\n\t\t\t    case 0xb8:\n\t\t\t    case 0xbc:\n\t\t\t    case 0xbd:\n\t\t\t    case 0xbe: c = 0x100; break; // not in latin9\n\t\t\t}\n\t\t    if (!utf_iscomposing(c))\t// skip composing chars\n\t\t    {\n\t\t\tif (c < 0x100)\n\t\t\t    *d++ = c;\n\t\t\telse if (vcp->vc_fail)\n\t\t\t{\n\t\t\t    vim_free(retval);\n\t\t\t    return NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    *d++ = 0xbf;\n\t\t\t    if (utf_char2cells(c) > 1)\n\t\t\t\t*d++ = '?';\n\t\t\t}\n\t\t    }\n\t\t    i += l - 1;\n\t\t}\n\t    }\n\t    *d = NUL;\n\t    if (lenp != NULL)\n\t\t*lenp = (int)(d - retval);\n\t    break;\n\n# ifdef MACOS_CONVERT\n\tcase CONV_MAC_LATIN1:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'l', unconvlenp);\n\t    break;\n\n\tcase CONV_LATIN1_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'l', 'm', unconvlenp);\n\t    break;\n\n\tcase CONV_MAC_UTF8:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'm', 'u', unconvlenp);\n\t    break;\n\n\tcase CONV_UTF8_MAC:\n\t    retval = mac_string_convert(ptr, len, lenp, vcp->vc_fail,\n\t\t\t\t\t'u', 'm', unconvlenp);\n\t    break;\n# endif\n\n# ifdef USE_ICONV\n\tcase CONV_ICONV:\t// conversion with output_conv.vc_fd\n\t    retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);\n\t    break;\n# endif\n# ifdef MSWIN\n\tcase CONV_CODEPAGE:\t\t// codepage -> codepage\n\t{\n\t    int\t\tretlen;\n\t    int\t\ttmp_len;\n\t    short_u\t*tmp;\n\n\t    // 1. codepage/UTF-8  ->  ucs-2.\n\t    if (vcp->vc_cpfrom == 0)\n\t\ttmp_len = utf8_to_utf16(ptr, len, NULL, NULL);\n\t    else\n\t    {\n\t\ttmp_len = MultiByteToWideChar(vcp->vc_cpfrom,\n\t\t\t\t\tunconvlenp ? MB_ERR_INVALID_CHARS : 0,\n\t\t\t\t\t(char *)ptr, len, 0, 0);\n\t\tif (tmp_len == 0\n\t\t\t&& GetLastError() == ERROR_NO_UNICODE_TRANSLATION)\n\t\t{\n\t\t    if (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\t    if (unconvlenp != NULL)\n\t\t\t*unconvlenp = len;\n\t\t    retval = alloc(1);\n\t\t    if (retval)\n\t\t\tretval[0] = NUL;\n\t\t    return retval;\n\t\t}\n\t    }\n\t    tmp = ALLOC_MULT(short_u, tmp_len);\n\t    if (tmp == NULL)\n\t\tbreak;\n\t    if (vcp->vc_cpfrom == 0)\n\t\tutf8_to_utf16(ptr, len, tmp, unconvlenp);\n\t    else\n\t\tMultiByteToWideChar(vcp->vc_cpfrom, 0,\n\t\t\t(char *)ptr, len, tmp, tmp_len);\n\n\t    // 2. ucs-2  ->  codepage/UTF-8.\n\t    if (vcp->vc_cpto == 0)\n\t\tretlen = utf16_to_utf8(tmp, tmp_len, NULL);\n\t    else\n\t\tretlen = WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t\t    tmp, tmp_len, 0, 0, 0, 0);\n\t    retval = alloc(retlen + 1);\n\t    if (retval != NULL)\n\t    {\n\t\tif (vcp->vc_cpto == 0)\n\t\t    utf16_to_utf8(tmp, tmp_len, retval);\n\t\telse\n\t\t    WideCharToMultiByte(vcp->vc_cpto, 0,\n\t\t\t\t\t  tmp, tmp_len,\n\t\t\t\t\t  (char *)retval, retlen, 0, 0);\n\t\tretval[retlen] = NUL;\n\t\tif (lenp != NULL)\n\t\t    *lenp = retlen;\n\t    }\n\t    vim_free(tmp);\n\t    break;\n\t}\n# endif\n    }\n\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Table set by setcellwidths().\n */\ntypedef struct\n{\n    long    first;\n    long    last;\n    char    width;\n} cw_interval_T;\n\nstatic cw_interval_T\t*cw_table = NULL;\nstatic size_t\t\tcw_table_size = 0;\n\n/*\n * Return 1 or 2 when \"c\" is in the cellwidth table.\n * Return 0 if not.\n */\n    static int\ncw_value(int c)\n{\n    int mid, bot, top;\n\n    if (cw_table == NULL)\n\treturn 0;\n\n    // first quick check for Latin1 etc. characters\n    if (c < cw_table[0].first)\n\treturn 0;\n\n    // binary search in table\n    bot = 0;\n    top = (int)cw_table_size - 1;\n    while (top >= bot)\n    {\n\tmid = (bot + top) / 2;\n\tif (cw_table[mid].last < c)\n\t    bot = mid + 1;\n\telse if (cw_table[mid].first > c)\n\t    top = mid - 1;\n\telse\n\t    return cw_table[mid].width;\n    }\n    return 0;\n}\n\n    static int\ntv_nr_compare(const void *a1, const void *a2)\n{\n    listitem_T *li1 = *(listitem_T **)a1;\n    listitem_T *li2 = *(listitem_T **)a2;\n\n    return li1->li_tv.vval.v_number - li2->li_tv.vval.v_number;\n}\n\n    void\nf_setcellwidths(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    list_T\t    *l;\n    listitem_T\t    *li;\n    int\t\t    item;\n    int\t\t    i;\n    listitem_T\t    **ptrs;\n    cw_interval_T   *table;\n    cw_interval_T   *cw_table_save;\n    size_t\t    cw_table_size_save;\n    char\t    *error = NULL;\n\n    if (in_vim9script() && check_for_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\temsg(_(e_list_required));\n\treturn;\n    }\n    l = argvars[0].vval.v_list;\n    if (l->lv_len == 0)\n    {\n\t// Clearing the table.\n\tvim_free(cw_table);\n\tcw_table = NULL;\n\tcw_table_size = 0;\n\treturn;\n    }\n\n    ptrs = ALLOC_MULT(listitem_T *, l->lv_len);\n    if (ptrs == NULL)\n\treturn;\n\n    // Check that all entries are a list with three numbers, the range is\n    // valid and the cell width is valid.\n    item = 0;\n    for (li = l->lv_first; li != NULL; li = li->li_next)\n    {\n\tlistitem_T *lili;\n\tvarnumber_T n1;\n\n\tif (li->li_tv.v_type != VAR_LIST || li->li_tv.vval.v_list == NULL)\n\t{\n\t    semsg(_(e_list_item_nr_is_not_list), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\n\tlili = li->li_tv.vval.v_list->lv_first;\n\tptrs[item] = lili;\n\tfor (i = 0; lili != NULL; lili = lili->li_next, ++i)\n\t{\n\t    if (lili->li_tv.v_type != VAR_NUMBER)\n\t\tbreak;\n\t    if (i == 0)\n\t    {\n\t\tn1 = lili->li_tv.vval.v_number;\n\t\tif (n1 < 0x100)\n\t\t{\n\t\t    emsg(_(e_only_values_of_0x100_and_higher_supported));\n\t\t    vim_free(ptrs);\n\t\t    return;\n\t\t}\n\t    }\n\t    else if (i == 1 && lili->li_tv.vval.v_number < n1)\n\t    {\n\t\tsemsg(_(e_list_item_nr_range_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t    else if (i == 2 && (lili->li_tv.vval.v_number < 1\n\t\t\t\t\t     || lili->li_tv.vval.v_number > 2))\n\t    {\n\t\tsemsg(_(e_list_item_nr_cell_width_invalid), item);\n\t\tvim_free(ptrs);\n\t\treturn;\n\t    }\n\t}\n\tif (i != 3)\n\t{\n\t    semsg(_(e_list_item_nr_does_not_contain_3_numbers), item);\n\t    vim_free(ptrs);\n\t    return;\n\t}\n\t++item;\n    }\n\n    // Sort the list on the first number.\n    qsort((void *)ptrs, (size_t)l->lv_len, sizeof(listitem_T *), tv_nr_compare);\n\n    table = ALLOC_MULT(cw_interval_T, l->lv_len);\n    if (table == NULL)\n    {\n\tvim_free(ptrs);\n\treturn;\n    }\n\n    // Store the items in the new table.\n    item = 0;\n    for (item = 0; item < l->lv_len; ++item)\n    {\n\tlistitem_T\t*lili = ptrs[item];\n\tvarnumber_T\tn1;\n\n\tn1 = lili->li_tv.vval.v_number;\n\tif (item > 0 && n1 <= table[item - 1].last)\n\t{\n\t    semsg(_(e_overlapping_ranges_for_nr), (long)n1);\n\t    vim_free(ptrs);\n\t    vim_free(table);\n\t    return;\n\t}\n\ttable[item].first = n1;\n\tlili = lili->li_next;\n\ttable[item].last = lili->li_tv.vval.v_number;\n\tlili = lili->li_next;\n\ttable[item].width = lili->li_tv.vval.v_number;\n    }\n\n    vim_free(ptrs);\n\n    cw_table_save = cw_table;\n    cw_table_size_save = cw_table_size;\n    cw_table = table;\n    cw_table_size = l->lv_len;\n\n    // Check that the new value does not conflict with 'listchars' or\n    // 'fillchars'.\n    error = check_chars_options();\n    if (error != NULL)\n    {\n\temsg(_(error));\n\tcw_table = cw_table_save;\n\tcw_table_size = cw_table_size_save;\n\tvim_free(table);\n\treturn;\n    }\n\n    vim_free(cw_table_save);\n}\n\n    void\nf_charclass(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || argvars[0].vval.v_string == NULL)\n\treturn;\n    rettv->vval.v_number = mb_get_class(argvars[0].vval.v_string);\n}\n#endif\n", "\" Tests for various eval things.\n\nsource view_util.vim\n\nfunction s:foo() abort\n  try\n    return [] == 0\n  catch\n    return 1\n  endtry\nendfunction\n\nfunc Test_catch_return_with_error()\n  call assert_equal(1, s:foo())\nendfunc\n\nfunc Test_nocatch_restore_silent_emsg()\n  silent! try\n    throw 1\n  catch\n  endtry\n  echoerr 'wrong again'\n  call assert_equal('wrong again', ScreenLine(&lines))\nendfunc\n\nfunc Test_mkdir_p()\n  call mkdir('Xmkdir/nested', 'p')\n  call assert_true(isdirectory('Xmkdir/nested'))\n  try\n    \" Trying to make existing directories doesn't error\n    call mkdir('Xmkdir', 'p')\n    call mkdir('Xmkdir/nested', 'p')\n  catch /E739:/\n    call assert_report('mkdir(..., \"p\") failed for an existing directory')\n  endtry\n  \" 'p' doesn't suppress real errors\n  call writefile([], 'Xfile')\n  call assert_fails('call mkdir(\"Xfile\", \"p\")', 'E739:')\n  call delete('Xfile')\n  call delete('Xmkdir', 'rf')\n  call assert_equal(0, mkdir(test_null_string()))\n  call assert_fails('call mkdir([])', 'E730:')\n  call assert_fails('call mkdir(\"abc\", [], [])', 'E745:')\nendfunc\n\nfunc Test_line_continuation()\n  let array = [5,\n\t\"\\ ignore this\n\t\\ 6,\n\t\"\\ more to ignore\n\t\"\\ more moreto ignore\n\t\\ ]\n\t\"\\ and some more\n  call assert_equal([5, 6], array)\nendfunc\n\nfunc Test_E963()\n  \" These commands used to cause an internal error prior to vim 8.1.0563\n  let v_e = v:errors\n  let v_o = v:oldfiles\n  call assert_fails(\"let v:errors=''\", 'E963:')\n  call assert_equal(v_e, v:errors)\n  call assert_fails(\"let v:oldfiles=''\", 'E963:')\n  call assert_equal(v_o, v:oldfiles)\nendfunc\n\nfunc Test_for_invalid()\n  call assert_fails(\"for x in 99\", 'E1098:')\n  call assert_fails(\"for x in function('winnr')\", 'E1098:')\n  call assert_fails(\"for x in {'a': 9}\", 'E1098:')\n\n  if 0\n    /1/5/2/s/\\n\n  endif\n  redraw\nendfunc\n\nfunc Test_for_over_null_string()\n  let save_enc = &enc\n  set enc=iso8859\n  let cnt = 0\n  for c in test_null_string()\n    let cnt += 1\n  endfor\n  call assert_equal(0, cnt)\n\n  let &enc = save_enc\nendfunc\n\nfunc Test_readfile_binary()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  setlocal ff=dos\n  silent write XReadfile_bin\n  let lines = 'XReadfile_bin'->readfile()\n  call assert_equal(['one', 'two', 'three'], lines)\n  let lines = readfile('XReadfile_bin', '', 2)\n  call assert_equal(['one', 'two'], lines)\n  let lines = readfile('XReadfile_bin', 'b')\n  call assert_equal([\"one\\r\", \"two\\r\", \"three\\r\", \"\"], lines)\n  let lines = readfile('XReadfile_bin', 'b', 2)\n  call assert_equal([\"one\\r\", \"two\\r\"], lines)\n\n  bwipe!\n  call delete('XReadfile_bin')\nendfunc\n\nfunc Test_readfile_binary_empty()\n  call writefile([], 'Xempty-file')\n  \" This used to compare uninitialized memory in Vim <= 8.2.4065\n  call assert_equal([''], readfile('Xempty-file', 'b'))\n  call delete('Xempty-file')\nendfunc\n\nfunc Test_readfile_bom()\n  call writefile([\"\\ufeffFOO\", \"FOO\\ufeffBAR\"], 'XReadfile_bom')\n  call assert_equal(['FOO', 'FOOBAR'], readfile('XReadfile_bom'))\n  call delete('XReadfile_bom')\nendfunc\n\nfunc Test_readfile_max()\n  call writefile(range(1, 4), 'XReadfile_max')\n  call assert_equal(['1', '2'], readfile('XReadfile_max', '', 2))\n  call assert_equal(['3', '4'], readfile('XReadfile_max', '', -2))\n  call delete('XReadfile_max')\nendfunc\n\nfunc Test_let_errmsg()\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\n  call assert_fails('let v:errmsg = []', 'E730:')\n  let v:errmsg = ''\nendfunc\n\nfunc Test_string_concatenation()\n  call assert_equal('ab', 'a'.'b')\n  call assert_equal('ab', 'a' .'b')\n  call assert_equal('ab', 'a'. 'b')\n  call assert_equal('ab', 'a' . 'b')\n\n  call assert_equal('ab', 'a'..'b')\n  call assert_equal('ab', 'a' ..'b')\n  call assert_equal('ab', 'a'.. 'b')\n  call assert_equal('ab', 'a' .. 'b')\n\n  let a = 'a'\n  let b = 'b'\n  let a .= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a.=b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a ..= b\n  call assert_equal('ab', a)\n\n  let a = 'a'\n  let a..=b\n  call assert_equal('ab', a)\n\n  if has('float')\n    let a = 'A'\n    let b = 1.234\n    call assert_equal('A1.234', a .. b)\n  endif\nendfunc\n\n\" Test fix for issue #4507\nfunc Test_skip_after_throw()\n  try\n    throw 'something'\n    let x = wincol() || &ts\n  catch /something/\n  endtry\nendfunc\n\nscriptversion 2\nfunc Test_string_concat_scriptversion2()\n  call assert_true(has('vimscript-2'))\n  let a = 'a'\n  let b = 'b'\n\n  call assert_fails('echo a . b', 'E15:')\n  call assert_fails('let a .= b', 'E985:')\n  call assert_fails('let vers = 1.2.3', 'E488:')\n\n  if has('float')\n    let f = .5\n    call assert_equal(0.5, f)\n  endif\nendfunc\n\nscriptversion 1\nfunc Test_string_concat_scriptversion1()\n  call assert_true(has('vimscript-1'))\n  let a = 'a'\n  let b = 'b'\n\n  echo a . b\n  let a .= b\n  let vers = 1.2.3\n  call assert_equal('123', vers)\n\n  if has('float')\n    call assert_fails('let f = .5', 'E15:')\n  endif\nendfunc\n\nscriptversion 3\nfunc Test_vvar_scriptversion3()\n  call assert_true(has('vimscript-3'))\n  call assert_fails('echo version', 'E121:')\n  call assert_false(exists('version'))\n  let version = 1\n  call assert_equal(1, version)\nendfunc\n\nscriptversion 2\nfunc Test_vvar_scriptversion2()\n  call assert_true(exists('version'))\n  echo version\n  call assert_fails('let version = 1', 'E46:')\n  call assert_equal(v:version, version)\n\n  call assert_equal(v:version, v:versionlong / 10000)\n  call assert_true(v:versionlong > 8011525)\nendfunc\n\nfunc Test_dict_access_scriptversion2()\n  let l:x = {'foo': 1}\n\n  call assert_false(0 && l:x.foo)\n  call assert_true(1 && l:x.foo)\nendfunc\n\nscriptversion 4\nfunc Test_vvar_scriptversion4()\n  call assert_true(has('vimscript-4'))\n  call assert_equal(17, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\n  call assert_equal(64, 0b1'00'00'00)\n  call assert_equal(1048576, 0x10'00'00)\n  call assert_equal(32768, 0o10'00'00)\n  call assert_equal(1000000, 1'000'000)\n  call assert_equal(\"1234\", execute(\"echo 1'234\")->trim())\n  call assert_equal('1  234', execute(\"echo 1''234\")->trim())\n  call assert_fails(\"echo 1'''234\", 'E115:')\nendfunc\n\nscriptversion 1\nfunc Test_vvar_scriptversion1()\n  call assert_equal(15, 017)\n  call assert_equal(15, 0o17)\n  call assert_equal(15, 0O17)\n  call assert_equal(18, 018)\n  call assert_equal(511, 0o777)\nendfunc\n\nfunc Test_scriptversion_fail()\n  call writefile(['scriptversion 9'], 'Xversionscript')\n  call assert_fails('source Xversionscript', 'E999:')\n  call delete('Xversionscript')\nendfunc\n\nfunc Test_execute_cmd_with_null()\n  call assert_fails('execute test_null_list()', 'E730:')\n  call assert_fails('execute test_null_dict()', 'E731:')\n  call assert_fails('execute test_null_blob()', 'E976:')\n  execute test_null_string()\n  call assert_fails('execute test_null_partial()', 'E729:')\n  call assert_fails('execute test_unknown()', 'E908:')\n  if has('job')\n    call assert_fails('execute test_null_job()', 'E908:')\n    call assert_fails('execute test_null_channel()', 'E908:')\n  endif\nendfunc\n\nfunc Test_number_max_min_size()\n  \" This will fail on systems without 64 bit number support or when not\n  \" configured correctly.\n  call assert_equal(64, v:numbersize)\n\n  call assert_true(v:numbermin < -9999999)\n  call assert_true(v:numbermax > 9999999)\nendfunc\n\nfunc Assert_reg(name, type, value, valuestr, expr, exprstr)\n  call assert_equal(a:type, getregtype(a:name))\n  call assert_equal(a:value, getreg(a:name))\n  call assert_equal(a:valuestr, string(getreg(a:name, 0, 1)))\n  call assert_equal(a:expr, getreg(a:name, 1))\n  call assert_equal(a:exprstr, string(getreg(a:name, 1, 1)))\nendfunc\n\nfunc Test_let_register()\n  let @\" = 'abc'\n  call Assert_reg('\"', 'v', \"abc\", \"['abc']\", \"abc\", \"['abc']\")\n  let @\" = \"abc\\n\"\n  call Assert_reg('\"', 'V', \"abc\\n\", \"['abc']\", \"abc\\n\", \"['abc']\")\n  let @\" = \"abc\\<C-m>\"\n  call Assert_reg('\"', 'V', \"abc\\r\\n\", \"['abc\\r']\", \"abc\\r\\n\", \"['abc\\r']\")\n  let @= = '\"abc\"'\n  call Assert_reg('=', 'v', \"abc\", \"['abc']\", '\"abc\"', \"['\\\"abc\\\"']\")\nendfunc\n\nfunc Assert_regput(name, result)\n  new\n  execute \"silent normal! o==\\n==\\e\\\"\" . a:name . \"P\"\n  call assert_equal(a:result, getline(2, line('$')))\n  bwipe!\nendfunc\n\nfunc Test_setreg_basic()\n  call setreg('a', 'abcA', 'c')\n  call Assert_reg('a', 'v', \"abcA\", \"['abcA']\", \"abcA\", \"['abcA']\")\n  call Assert_regput('a', ['==', '=abcA='])\n\n  call setreg('A', 'abcAc', 'c')\n  call Assert_reg('A', 'v', \"abcAabcAc\", \"['abcAabcAc']\", \"abcAabcAc\", \"['abcAabcAc']\")\n  call Assert_regput('a', ['==', '=abcAabcAc='])\n\n  call setreg('A', 'abcAl', 'l')\n  call Assert_reg('A', 'V', \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\", \"abcAabcAcabcAl\\n\", \"['abcAabcAcabcAl']\")\n  call Assert_regput('a', ['==', 'abcAabcAcabcAl', '=='])\n\n  call setreg('A', 'abcAc2','c')\n  call Assert_reg('A', 'v', \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\", \"abcAabcAcabcAl\\nabcAc2\", \"['abcAabcAcabcAl', 'abcAc2']\")\n  call Assert_regput('a', ['==', '=abcAabcAcabcAl', 'abcAc2='])\n\n  call setreg('b', 'abcB', 'v')\n  call Assert_reg('b', 'v', \"abcB\", \"['abcB']\", \"abcB\", \"['abcB']\")\n  call Assert_regput('b', ['==', '=abcB='])\n\n  call setreg('b', 'abcBc', 'ca')\n  call Assert_reg('b', 'v', \"abcBabcBc\", \"['abcBabcBc']\", \"abcBabcBc\", \"['abcBabcBc']\")\n  call Assert_regput('b', ['==', '=abcBabcBc='])\n\n  call setreg('b', 'abcBb', 'ba')\n  call Assert_reg('b', \"\\<C-V>5\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\", \"abcBabcBcabcBb\", \"['abcBabcBcabcBb']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb='])\n\n  call setreg('b', 'abcBc2','ca')\n  call Assert_reg('b', \"v\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\", \"abcBabcBcabcBb\\nabcBc2\", \"['abcBabcBcabcBb', 'abcBc2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb', 'abcBc2='])\n\n  call setreg('b', 'abcBb2','b50a')\n  call Assert_reg('b', \"\\<C-V>50\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\", \"abcBabcBcabcBb\\nabcBc2abcBb2\", \"['abcBabcBcabcBb', 'abcBc2abcBb2']\")\n  call Assert_regput('b', ['==', '=abcBabcBcabcBb                                    =', ' abcBc2abcBb2'])\n\n  call setreg('c', 'abcC', 'l')\n  call Assert_reg('c', 'V', \"abcC\\n\", \"['abcC']\", \"abcC\\n\", \"['abcC']\")\n  call Assert_regput('c', ['==', 'abcC', '=='])\n\n  call setreg('C', 'abcCl', 'l')\n  call Assert_reg('C', 'V', \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\", \"abcC\\nabcCl\\n\", \"['abcC', 'abcCl']\")\n  call Assert_regput('c', ['==', 'abcC', 'abcCl', '=='])\n\n  call setreg('C', 'abcCc', 'c')\n  call Assert_reg('C', 'v', \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\", \"abcC\\nabcCl\\nabcCc\", \"['abcC', 'abcCl', 'abcCc']\")\n  call Assert_regput('c', ['==', '=abcC', 'abcCl', 'abcCc='])\n\n  call setreg('d', 'abcD', 'V')\n  call Assert_reg('d', 'V', \"abcD\\n\", \"['abcD']\", \"abcD\\n\", \"['abcD']\")\n  call Assert_regput('d', ['==', 'abcD', '=='])\n\n  call setreg('D', 'abcDb', 'b')\n  call Assert_reg('d', \"\\<C-V>5\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\", \"abcD\\nabcDb\", \"['abcD', 'abcDb']\")\n  call Assert_regput('d', ['==', '=abcD =', ' abcDb'])\n\n  call setreg('e', 'abcE', 'b')\n  call Assert_reg('e', \"\\<C-V>4\", \"abcE\", \"['abcE']\", \"abcE\", \"['abcE']\")\n  call Assert_regput('e', ['==', '=abcE='])\n\n  call setreg('E', 'abcEb', 'b')\n  call Assert_reg('E', \"\\<C-V>5\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\", \"abcE\\nabcEb\", \"['abcE', 'abcEb']\")\n  call Assert_regput('e', ['==', '=abcE =', ' abcEb'])\n\n  call setreg('E', 'abcEl', 'l')\n  call Assert_reg('E', \"V\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\", \"abcE\\nabcEb\\nabcEl\\n\", \"['abcE', 'abcEb', 'abcEl']\")\n  call Assert_regput('e', ['==', 'abcE', 'abcEb', 'abcEl', '=='])\n\n  call setreg('f', 'abcF', \"\\<C-v>\")\n  call Assert_reg('f', \"\\<C-V>4\", \"abcF\", \"['abcF']\", \"abcF\", \"['abcF']\")\n  call Assert_regput('f', ['==', '=abcF='])\n\n  call setreg('F', 'abcFc', 'c')\n  call Assert_reg('F', \"v\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\", \"abcF\\nabcFc\", \"['abcF', 'abcFc']\")\n  call Assert_regput('f', ['==', '=abcF', 'abcFc='])\n\n  call setreg('g', 'abcG', 'b10')\n  call Assert_reg('g', \"\\<C-V>10\", \"abcG\", \"['abcG']\", \"abcG\", \"['abcG']\")\n  call Assert_regput('g', ['==', '=abcG      ='])\n\n  call setreg('h', 'abcH', \"\\<C-v>10\")\n  call Assert_reg('h', \"\\<C-V>10\", \"abcH\", \"['abcH']\", \"abcH\", \"['abcH']\")\n  call Assert_regput('h', ['==', '=abcH      ='])\n\n  call setreg('I', 'abcI')\n  call Assert_reg('I', \"v\", \"abcI\", \"['abcI']\", \"abcI\", \"['abcI']\")\n  call Assert_regput('I', ['==', '=abcI='])\n\n  \" Appending NL with setreg()\n  call setreg('a', 'abcA2', 'c')\n  call setreg('b', 'abcB2', 'v')\n  call setreg('c', 'abcC2', 'l')\n  call setreg('d', 'abcD2', 'V')\n  call setreg('e', 'abcE2', 'b')\n  call setreg('f', 'abcF2', \"\\<C-v>\")\n  call setreg('g', 'abcG2', 'b10')\n  call setreg('h', 'abcH2', \"\\<C-v>10\")\n  call setreg('I', 'abcI2')\n\n  call setreg('A', \"\\n\")\n  call Assert_reg('A', 'V', \"abcA2\\n\", \"['abcA2']\", \"abcA2\\n\", \"['abcA2']\")\n  call Assert_regput('A', ['==', 'abcA2', '=='])\n\n  call setreg('B', \"\\n\", 'c')\n  call Assert_reg('B', 'v', \"abcB2\\n\", \"['abcB2', '']\", \"abcB2\\n\", \"['abcB2', '']\")\n  call Assert_regput('B', ['==', '=abcB2', '='])\n\n  call setreg('C', \"\\n\")\n  call Assert_reg('C', 'V', \"abcC2\\n\\n\", \"['abcC2', '']\", \"abcC2\\n\\n\", \"['abcC2', '']\")\n  call Assert_regput('C', ['==', 'abcC2', '', '=='])\n\n  call setreg('D', \"\\n\", 'l')\n  call Assert_reg('D', 'V', \"abcD2\\n\\n\", \"['abcD2', '']\", \"abcD2\\n\\n\", \"['abcD2', '']\")\n  call Assert_regput('D', ['==', 'abcD2', '', '=='])\n\n  call setreg('E', \"\\n\")\n  call Assert_reg('E', 'V', \"abcE2\\n\\n\", \"['abcE2', '']\", \"abcE2\\n\\n\", \"['abcE2', '']\")\n  call Assert_regput('E', ['==', 'abcE2', '', '=='])\n\n  call setreg('F', \"\\n\", 'b')\n  call Assert_reg('F', \"\\<C-V>0\", \"abcF2\\n\", \"['abcF2', '']\", \"abcF2\\n\", \"['abcF2', '']\")\n  call Assert_regput('F', ['==', '=abcF2=', ' '])\n\n  \" Setting lists with setreg()\n  call setreg('a', ['abcA3'], 'c')\n  call Assert_reg('a', 'v', \"abcA3\", \"['abcA3']\", \"abcA3\", \"['abcA3']\")\n  call Assert_regput('a', ['==', '=abcA3='])\n\n  call setreg('b', ['abcB3'], 'l')\n  call Assert_reg('b', 'V', \"abcB3\\n\", \"['abcB3']\", \"abcB3\\n\", \"['abcB3']\")\n  call Assert_regput('b', ['==', 'abcB3', '=='])\n\n  call setreg('c', ['abcC3'], 'b')\n  call Assert_reg('c', \"\\<C-V>5\", \"abcC3\", \"['abcC3']\", \"abcC3\", \"['abcC3']\")\n  call Assert_regput('c', ['==', '=abcC3='])\n\n  call setreg('d', ['abcD3'])\n  call Assert_reg('d', 'V', \"abcD3\\n\", \"['abcD3']\", \"abcD3\\n\", \"['abcD3']\")\n  call Assert_regput('d', ['==', 'abcD3', '=='])\n\n  call setreg('e', [1, 2, 'abc', 3])\n  call Assert_reg('e', 'V', \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\", \"1\\n2\\nabc\\n3\\n\", \"['1', '2', 'abc', '3']\")\n  call Assert_regput('e', ['==', '1', '2', 'abc', '3', '=='])\n\n  call setreg('f', [1, 2, 3])\n  call Assert_reg('f', 'V', \"1\\n2\\n3\\n\", \"['1', '2', '3']\", \"1\\n2\\n3\\n\", \"['1', '2', '3']\")\n  call Assert_regput('f', ['==', '1', '2', '3', '=='])\n\n  \" Appending lists with setreg()\n  call setreg('A', ['abcA3c'], 'c')\n  call Assert_reg('A', 'v', \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\", \"abcA3\\nabcA3c\", \"['abcA3', 'abcA3c']\")\n  call Assert_regput('A', ['==', '=abcA3', 'abcA3c='])\n\n  call setreg('b', ['abcB3l'], 'la')\n  call Assert_reg('b', 'V', \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\", \"abcB3\\nabcB3l\\n\", \"['abcB3', 'abcB3l']\")\n  call Assert_regput('b', ['==', 'abcB3', 'abcB3l', '=='])\n\n  call setreg('C', ['abcC3b'], 'lb')\n  call Assert_reg('C', \"\\<C-V>6\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\", \"abcC3\\nabcC3b\", \"['abcC3', 'abcC3b']\")\n  call Assert_regput('C', ['==', '=abcC3 =', ' abcC3b'])\n\n  call setreg('D', ['abcD32'])\n  call Assert_reg('D', 'V', \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\", \"abcD3\\nabcD32\\n\", \"['abcD3', 'abcD32']\")\n  call Assert_regput('D', ['==', 'abcD3', 'abcD32', '=='])\n\n  call setreg('A', ['abcA32'])\n  call Assert_reg('A', 'V', \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\", \"abcA3\\nabcA3c\\nabcA32\\n\", \"['abcA3', 'abcA3c', 'abcA32']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', '=='])\n\n  call setreg('B', ['abcB3c'], 'c')\n  call Assert_reg('B', 'v', \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\", \"abcB3\\nabcB3l\\nabcB3c\", \"['abcB3', 'abcB3l', 'abcB3c']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c='])\n\n  call setreg('C', ['abcC3l'], 'l')\n  call Assert_reg('C', 'V', \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\", \"abcC3\\nabcC3b\\nabcC3l\\n\", \"['abcC3', 'abcC3b', 'abcC3l']\")\n  call Assert_regput('C', ['==', 'abcC3', 'abcC3b', 'abcC3l', '=='])\n\n  call setreg('D', ['abcD3b'], 'b')\n  call Assert_reg('D', \"\\<C-V>6\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\", \"abcD3\\nabcD32\\nabcD3b\", \"['abcD3', 'abcD32', 'abcD3b']\")\n  call Assert_regput('D', ['==', '=abcD3 =', ' abcD32', ' abcD3b'])\n\n  \" Appending lists with NL with setreg()\n  call setreg('A', [\"\\n\", 'abcA3l2'], 'l')\n  call Assert_reg('A', \"V\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\", \"abcA3\\nabcA3c\\nabcA32\\n\\n\\nabcA3l2\\n\", \"['abcA3', 'abcA3c', 'abcA32', '\\n', 'abcA3l2']\")\n  call Assert_regput('A', ['==', 'abcA3', 'abcA3c', 'abcA32', \"\\n\", 'abcA3l2', '=='])\n\n  call setreg('B', [\"\\n\", 'abcB3c2'], 'c')\n  call Assert_reg('B', \"v\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\", \"abcB3\\nabcB3l\\nabcB3c\\n\\n\\nabcB3c2\", \"['abcB3', 'abcB3l', 'abcB3c', '\\n', 'abcB3c2']\")\n  call Assert_regput('B', ['==', '=abcB3', 'abcB3l', 'abcB3c', \"\\n\", 'abcB3c2='])\n\n  call setreg('C', [\"\\n\", 'abcC3b2'], 'b')\n  call Assert_reg('C', \"\u00167\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\", \"abcC3\\nabcC3b\\nabcC3l\\n\\n\\nabcC3b2\", \"['abcC3', 'abcC3b', 'abcC3l', '\\n', 'abcC3b2']\")\n  call Assert_regput('C', ['==', '=abcC3  =', ' abcC3b', ' abcC3l', \" \\n\", ' abcC3b2'])\n\n  call setreg('D', [\"\\n\", 'abcD3b50'],'b50')\n  call Assert_reg('D', \"\u001650\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\", \"abcD3\\nabcD32\\nabcD3b\\n\\n\\nabcD3b50\", \"['abcD3', 'abcD32', 'abcD3b', '\\n', 'abcD3b50']\")\n  call Assert_regput('D', ['==', '=abcD3                                             =', ' abcD32', ' abcD3b', \" \\n\", ' abcD3b50'])\n\n  \" Setting lists with NLs with setreg()\n  call setreg('a', ['abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\"])\n  call Assert_reg('a', \"V\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\", \"abcA4-0\\n\\n\\nabcA4-2\\n\\n\\nabcA4-3\\nabcA4-4\\nabcA4-4-2\\n\", \"['abcA4-0', '\\n', 'abcA4-2\\n', '\\nabcA4-3', 'abcA4-4\\nabcA4-4-2']\")\n  call Assert_regput('a', ['==', 'abcA4-0', \"\\n\", \"abcA4-2\\n\", \"\\nabcA4-3\", \"abcA4-4\\nabcA4-4-2\", '=='])\n\n  call setreg('b', ['abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2\"], 'c')\n  call Assert_reg('b', \"v\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\", \"abcB4c-0\\n\\n\\nabcB4c-2\\n\\n\\nabcB4c-3\\nabcB4c-4\\nabcB4c-4-2\", \"['abcB4c-0', '\\n', 'abcB4c-2\\n', '\\nabcB4c-3', 'abcB4c-4\\nabcB4c-4-2']\")\n  call Assert_regput('b', ['==', '=abcB4c-0', \"\\n\", \"abcB4c-2\\n\", \"\\nabcB4c-3\", \"abcB4c-4\\nabcB4c-4-2=\"])\n\n  call setreg('c', ['abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\"], 'l')\n  call Assert_reg('c', \"V\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\", \"abcC4l-0\\n\\n\\nabcC4l-2\\n\\n\\nabcC4l-3\\nabcC4l-4\\nabcC4l-4-2\\n\", \"['abcC4l-0', '\\n', 'abcC4l-2\\n', '\\nabcC4l-3', 'abcC4l-4\\nabcC4l-4-2']\")\n  call Assert_regput('c', ['==', 'abcC4l-0', \"\\n\", \"abcC4l-2\\n\", \"\\nabcC4l-3\", \"abcC4l-4\\nabcC4l-4-2\", '=='])\n\n  call setreg('d', ['abcD4b-0', \"\\n\", \"abcD4b-2\\n\", \"\\nabcD4b-3\", \"abcD4b-4\\nabcD4b-4-2\"], 'b')\n  call Assert_reg('d', \"\u001619\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\", \"abcD4b-0\\n\\n\\nabcD4b-2\\n\\n\\nabcD4b-3\\nabcD4b-4\\nabcD4b-4-2\", \"['abcD4b-0', '\\n', 'abcD4b-2\\n', '\\nabcD4b-3', 'abcD4b-4\\nabcD4b-4-2']\")\n  call Assert_regput('d', ['==', '=abcD4b-0           =', \" \\n\", \" abcD4b-2\\n\", \" \\nabcD4b-3\", \" abcD4b-4\\nabcD4b-4-2\"])\n\n  call setreg('e', ['abcE4b10-0', \"\\n\", \"abcE4b10-2\\n\", \"\\nabcE4b10-3\", \"abcE4b10-4\\nabcE4b10-4-2\"], 'b10')\n  call Assert_reg('e', \"\u001610\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\", \"abcE4b10-0\\n\\n\\nabcE4b10-2\\n\\n\\nabcE4b10-3\\nabcE4b10-4\\nabcE4b10-4-2\", \"['abcE4b10-0', '\\n', 'abcE4b10-2\\n', '\\nabcE4b10-3', 'abcE4b10-4\\nabcE4b10-4-2']\")\n  call Assert_regput('e', ['==', '=abcE4b10-0=', \" \\n\", \" abcE4b10-2\\n\", \" \\nabcE4b10-3\", \" abcE4b10-4\\nabcE4b10-4-2\"])\n\n  \" Search and expressions\n  call setreg('/', ['abc/'])\n  call Assert_reg('/', 'v', \"abc/\", \"['abc/']\", \"abc/\", \"['abc/']\")\n  call Assert_regput('/', ['==', '=abc/='])\n\n  call setreg('/', [\"abc/\\n\"])\n  call Assert_reg('/', 'v', \"abc/\\n\", \"['abc/\\n']\", \"abc/\\n\", \"['abc/\\n']\")\n  call Assert_regput('/', ['==', \"=abc/\\n=\"])\n\n  call setreg('=', ['\"abc/\"'])\n  call Assert_reg('=', 'v', \"abc/\", \"['abc/']\", '\"abc/\"', \"['\\\"abc/\\\"']\")\n\n  call setreg('=', [\"\\\"abc/\\n\\\"\"])\n  call Assert_reg('=', 'v', \"abc/\\n\", \"['abc/\\n']\", \"\\\"abc/\\n\\\"\", \"['\\\"abc/\\n\\\"']\")\n\n  \" System clipboard\n  if has('clipboard')\n    new | only!\n    call setline(1, ['clipboard contents', 'something else'])\n    \" Save and restore system clipboard.\n    \" If no connection to X-Server is possible, test should succeed.\n    let _clipreg = ['*', getreg('*'), getregtype('*')]\n    let _clipopt = &cb\n    let &cb='unnamed'\n    1y\n    call Assert_reg('*', 'V', \"clipboard contents\\n\", \"['clipboard contents']\", \"clipboard contents\\n\", \"['clipboard contents']\")\n    tabdo :windo :echo \"hi\"\n    2y\n    call Assert_reg('*', 'V', \"something else\\n\", \"['something else']\", \"something else\\n\", \"['something else']\")\n    let &cb=_clipopt\n    call call('setreg', _clipreg)\n    enew!\n  endif\n\n  \" Error cases\n  call assert_fails('call setreg()', 'E119:')\n  call assert_fails('call setreg(1)', 'E119:')\n  call assert_fails('call setreg(1, 2, 3, 4)', 'E118:')\n  call assert_fails('call setreg([], 2)', 'E730:')\n  call assert_fails('call setreg(1, 2, [])', 'E730:')\n  call assert_fails('call setreg(\"/\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(\"=\", [\"1\", \"2\"])', 'E883:')\n  call assert_fails('call setreg(1, [\"\", \"\", [], \"\"])', 'E730:')\nendfunc\n\nfunc Test_curly_assignment()\n  let s:svar = 'svar'\n  let g:gvar = 'gvar'\n  let lname = 'gvar'\n  let gname = 'gvar'\n  let {'s:'.lname} = {'g:'.gname}\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:'.lname } = { 'g:'.gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' . lname } = { 'g:' . gname }\n  call assert_equal('gvar', s:gvar)\n  let s:gvar = ''\n  let { 's:' .. lname } = { 'g:' .. gname }\n  call assert_equal('gvar', s:gvar)\n\n  unlet s:svar\n  unlet s:gvar\n  unlet g:gvar\nendfunc\n\nfunc Test_deep_recursion()\n  \" this was running out of stack\n  call assert_fails(\"exe 'if ' .. repeat('(', 1002)\", 'E1169: Expression too recursive: ((')\nendfunc\n\n\" K_SPECIAL in the modified character used be escaped, which causes\n\" double-escaping with feedkeys() or as the return value of an <expr> mapping,\n\" and doesn't match what getchar() returns,\nfunc Test_modified_char_no_escape_special()\n  nnoremap <M-\u2026> <Cmd>let g:got_m_ellipsis += 1<CR>\n  call feedkeys(\"\\<M-\u2026>\", 't')\n  call assert_equal(\"\\<M-\u2026>\", getchar())\n  let g:got_m_ellipsis = 0\n  call feedkeys(\"\\<M-\u2026>\", 'xt')\n  call assert_equal(1, g:got_m_ellipsis)\n  func Func()\n    return \"\\<M-\u2026>\"\n  endfunc\n  nmap <expr> <F2> Func()\n  call feedkeys(\"\\<F2>\", 'xt')\n  call assert_equal(2, g:got_m_ellipsis)\n  delfunc Func\n  nunmap <F2>\n  unlet g:got_m_ellipsis\n  nunmap <M-\u2026>\nendfunc\n\nfunc Test_eval_string_in_special_key()\n  \" this was using the '{' inside <> as the start of an interpolated string\n  silent! echo 0{1-$\"\\<S--{>\u0017n|n\u00f6%\u0000\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/globals.h", "src/mbyte.c", "src/testdir/test_eval_stuff.vim", "src/version.c"], "buggy_code_start_loc": [1038, 1080, 75, 737], "buggy_code_end_loc": [1039, 2107, 75, 737], "fixing_code_start_loc": [1038, 1080, 76, 738], "fixing_code_end_loc": [1040, 2113, 88, 740], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0220.", "other": {"cve": {"id": "CVE-2022-2849", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-17T18:15:08.173", "lastModified": "2023-05-03T12:16:04.687", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0220."}, {"lang": "es", "value": "Desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria en el repositorio de GitHub vim/vim anterior a la versi\u00f3n 9.0.0220."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0220", "matchCriteriaId": "8D8F29F0-C5F6-420C-8A1E-ED8CB98B919D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/f6d39c31d2177549a986d170e192d8351bd571e2", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/389aeccd-deb9-49ae-9b6a-24c12d79b02e", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/f6d39c31d2177549a986d170e192d8351bd571e2"}}