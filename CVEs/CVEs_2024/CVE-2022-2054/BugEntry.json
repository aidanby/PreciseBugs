{"buggy_code": ["#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\"\nThis is the main program of Nuitka, it checks the options and then translates\none or more modules to a C source code using Python C/API in a \"*.build\"\ndirectory and then compiles that to either an executable or an extension module\nor package, that can contain all used modules too.\n\"\"\"\n\n# Note: This avoids imports at all costs, such that initial startup doesn't do more\n# than necessary, until re-execution has been decided.\n\nimport os\nimport sys\n\n\ndef main():\n    # PyLint for Python3 thinks we import from ourselves if we really\n    # import from package, pylint: disable=I0021,no-name-in-module\n\n    # Also high complexity.\n    # pylint: disable=too-many-branches,too-many-locals,too-many-statements\n\n    if \"NUITKA_BINARY_NAME\" in os.environ:\n        sys.argv[0] = os.environ[\"NUITKA_BINARY_NAME\"]\n\n    if \"NUITKA_PYTHONPATH\" in os.environ:\n        # Restore the PYTHONPATH gained from the site module, that we chose not\n        # to have imported. pylint: disable=eval-used\n        sys.path = eval(os.environ[\"NUITKA_PYTHONPATH\"])\n        del os.environ[\"NUITKA_PYTHONPATH\"]\n    else:\n        # Remove path element added for being called via \"__main__.py\", this can\n        # only lead to trouble, having e.g. a \"distutils\" in sys.path that comes\n        # from \"nuitka.distutils\".\n        sys.path = [\n            path_element\n            for path_element in sys.path\n            if os.path.dirname(os.path.abspath(__file__)) != path_element\n        ]\n\n    # We will run with the Python configuration as specified by the user, if it does\n    # not match, we restart ourselves with matching configuration.\n    needs_re_execution = False\n\n    if sys.flags.no_site == 0:\n        needs_re_execution = True\n\n    # The hash randomization totally changes the created source code created,\n    # changing it every single time Nuitka is run. This kills any attempt at\n    # caching it, and comparing generated source code. While the created binary\n    # actually may still use it, during compilation we don't want to. So lets\n    # disable it.\n    if os.environ.get(\"PYTHONHASHSEED\", \"-1\") != \"0\":\n        needs_re_execution = True\n\n    # In case we need to re-execute.\n    if needs_re_execution:\n        from nuitka.utils.ReExecute import reExecuteNuitka  # isort:skip\n\n        # Does not return\n        reExecuteNuitka(pgo_filename=None)\n\n    # We don't care about deprecations in any version, and these are triggered\n    # by run time calculations of \"range\" and others, while on python2.7 they\n    # are disabled by default.\n    import warnings\n\n    warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n    from nuitka import Options  # isort:skip\n\n    Options.parseArgs()\n\n    Options.commentArgs()\n\n    # Load plugins after we know, we don't execute again.\n    from nuitka.plugins.Plugins import activatePlugins\n\n    activatePlugins()\n\n    if Options.isShowMemory():\n        from nuitka.utils import MemoryUsage\n\n        MemoryUsage.startMemoryTracing()\n\n    if \"NUITKA_NAMESPACES\" in os.environ:\n        # Restore the detected name space packages, that were force loaded in\n        # site.py, and will need a free pass later on. pylint: disable=eval-used\n\n        from nuitka.importing.PreloadedPackages import setPreloadedPackagePaths\n\n        setPreloadedPackagePaths(eval(os.environ[\"NUITKA_NAMESPACES\"]))\n        del os.environ[\"NUITKA_NAMESPACES\"]\n\n    if \"NUITKA_PTH_IMPORTED\" in os.environ:\n        # Restore the packages that the \".pth\" files asked to import.\n        # pylint: disable=eval-used\n\n        from nuitka.importing.PreloadedPackages import setPthImportedPackages\n\n        setPthImportedPackages(eval(os.environ[\"NUITKA_PTH_IMPORTED\"]))\n        del os.environ[\"NUITKA_PTH_IMPORTED\"]\n\n    # Now the real main program of Nuitka can take over.\n    from nuitka import MainControl  # isort:skip\n\n    MainControl.main()\n\n    if Options.isShowMemory():\n        MemoryUsage.showMemoryTrace()\n\n\nif __name__ == \"__main__\":\n    if \"NUITKA_PACKAGE_HOME\" in os.environ:\n        sys.path.insert(0, os.environ[\"NUITKA_PACKAGE_HOME\"])\n\n        import nuitka  # just to have it loaded from there, pylint: disable=unused-import\n\n        del sys.path[0]\n\n    main()\n", "#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\" Caching of C compiler output.\n\n\"\"\"\n\nimport os\nimport platform\nimport re\nimport sys\nfrom collections import defaultdict\n\nfrom nuitka.Tracing import scons_details_logger, scons_logger\nfrom nuitka.utils.AppDirs import getCacheDir\nfrom nuitka.utils.Download import getCachedDownload\nfrom nuitka.utils.FileOperations import (\n    areSamePaths,\n    getExternalUsePath,\n    getFileContentByLine,\n    getFileContents,\n    getLinkTarget,\n    makePath,\n)\nfrom nuitka.utils.Importing import importFromInlineCopy\nfrom nuitka.utils.Utils import isMacOS, isWin32Windows\n\nfrom .SconsProgress import updateSconsProgressBar\nfrom .SconsUtils import (\n    getExecutablePath,\n    getSconsReportValue,\n    setEnvironmentVariable,\n)\n\n\ndef _getPythonDirCandidates(python_prefix):\n    result = [python_prefix]\n\n    for python_dir in (\n        sys.prefix,\n        os.environ.get(\"CONDA_PREFIX\"),\n        os.environ.get(\"CONDA\"),\n    ):\n        if python_dir and python_dir not in result:\n            result.append(python_dir)\n\n    return result\n\n\ndef _getCcacheGuessedPaths(python_prefix):\n    if isWin32Windows():\n        # Search the compiling Python, the Scons Python (likely the same, but not necessarily)\n        # and then Anaconda, if an environment variable present from activated, or installed in\n        # CI like GitHub actions.\n        for python_dir in _getPythonDirCandidates(python_prefix):\n            yield os.path.join(python_dir, \"bin\", \"ccache.exe\")\n            yield os.path.join(python_dir, \"scripts\", \"ccache.exe\")\n\n    elif isMacOS():\n        # For macOS, we might find Homebrew ccache installed but not in PATH.\n        yield \"/usr/local/opt/ccache\"\n        yield \"/opt/homebrew/bin/ccache\"\n\n\ndef _injectCcache(env, cc_path, python_prefix, target_arch, assume_yes_for_downloads):\n    ccache_binary = os.environ.get(\"NUITKA_CCACHE_BINARY\")\n\n    # If not provided, search it in PATH and guessed directories.\n    if ccache_binary is None:\n        ccache_binary = getExecutablePath(\"ccache\", env=env)\n\n        if ccache_binary is None:\n            for candidate in _getCcacheGuessedPaths(python_prefix):\n                scons_details_logger.info(\n                    \"Checking if ccache is at '%s' guessed path.\" % candidate\n                )\n\n                if os.path.exists(candidate):\n                    ccache_binary = candidate\n\n                    scons_details_logger.info(\n                        \"Using ccache '%s' from guessed path.\" % ccache_binary\n                    )\n\n                    break\n\n        if ccache_binary is None:\n            if isWin32Windows():\n                url = \"https://github.com/ccache/ccache/releases/download/v4.6/ccache-4.6-windows-32.zip\"\n                ccache_binary = getCachedDownload(\n                    url=url,\n                    is_arch_specific=False,\n                    specificity=url.rsplit(\"/\", 2)[1],\n                    flatten=True,\n                    binary=\"ccache.exe\",\n                    message=\"Nuitka will make use of ccache to speed up repeated compilation.\",\n                    reject=None,\n                    assume_yes_for_downloads=assume_yes_for_downloads,\n                )\n            elif isMacOS():\n                # TODO: Do not yet have M1 access to create one and 10.14 is minimum\n                # we managed to compile ccache for.\n                if target_arch != \"arm64\" and tuple(\n                    int(d) for d in platform.release().split(\".\")\n                ) >= (18, 2):\n                    url = \"https://nuitka.net/ccache/v4.2.1/ccache-4.2.1.zip\"\n\n                    ccache_binary = getCachedDownload(\n                        url=url,\n                        is_arch_specific=False,\n                        specificity=url.rsplit(\"/\", 2)[1],\n                        flatten=True,\n                        binary=\"ccache\",\n                        message=\"Nuitka will make use of ccache to speed up repeated compilation.\",\n                        reject=None,\n                        assume_yes_for_downloads=assume_yes_for_downloads,\n                    )\n\n    else:\n        scons_details_logger.info(\n            \"Using ccache '%s' from NUITKA_CCACHE_BINARY environment variable.\"\n            % ccache_binary\n        )\n\n    if ccache_binary is not None and os.path.exists(ccache_binary):\n        # Make sure the\n        # In case we are on Windows, make sure the Anaconda form runs outside of Anaconda\n        # environment, by adding DLL folder to PATH.\n        assert areSamePaths(\n            getExecutablePath(os.path.basename(env.the_compiler), env=env), cc_path\n        )\n\n        # We use absolute paths for CC, pass it like this, as ccache does not like absolute.\n        env[\"CXX\"] = env[\"CC\"] = '\"%s\" \"%s\"' % (ccache_binary, cc_path)\n\n        # Spare ccache the detection of the compiler, seems it will also misbehave when it's\n        # prefixed with \"ccache\" on old gcc versions in terms of detecting need for C++ linkage.\n        env[\"LINK\"] = cc_path\n\n        scons_details_logger.info(\n            \"Found ccache '%s' to cache C compilation result.\" % ccache_binary\n        )\n        scons_details_logger.info(\n            \"Providing real CC path '%s' via PATH extension.\" % cc_path\n        )\n\n\ndef enableCcache(\n    env,\n    source_dir,\n    python_prefix,\n    target_arch,\n    assume_yes_for_downloads,\n):\n    # The ccache needs absolute path, otherwise it will not work.\n    ccache_logfile = os.path.abspath(\n        os.path.join(source_dir, \"ccache-%d.txt\" % os.getpid())\n    )\n\n    setEnvironmentVariable(env, \"CCACHE_LOGFILE\", ccache_logfile)\n    env[\"CCACHE_LOGFILE\"] = ccache_logfile\n\n    # Unless asked to do otherwise, store ccache files in our own directory.\n    if \"CCACHE_DIR\" not in os.environ:\n        ccache_dir = os.path.join(getCacheDir(), \"ccache\")\n        makePath(ccache_dir)\n        ccache_dir = getExternalUsePath(ccache_dir)\n        setEnvironmentVariable(env, \"CCACHE_DIR\", ccache_dir)\n        env[\"CCACHE_DIR\"] = ccache_dir\n\n    # We know the include files we created are safe to use.\n    setEnvironmentVariable(\n        env, \"CCACHE_SLOPPINESS\", \"include_file_ctime,include_file_mtime\"\n    )\n\n    # First check if it's not already supposed to be a ccache, then do nothing.\n    cc_path = getExecutablePath(env.the_compiler, env=env)\n\n    cc_is_link, cc_link_path = getLinkTarget(cc_path)\n    if cc_is_link and os.path.basename(cc_link_path) == \"ccache\":\n        scons_details_logger.info(\n            \"Chosen compiler %s is pointing to ccache %s already.\"\n            % (cc_path, cc_link_path)\n        )\n\n        return True\n\n    return _injectCcache(\n        env=env,\n        cc_path=cc_path,\n        python_prefix=python_prefix,\n        target_arch=target_arch,\n        assume_yes_for_downloads=assume_yes_for_downloads,\n    )\n\n\ndef enableClcache(env, source_dir):\n    importFromInlineCopy(\"atomicwrites\", must_exist=True)\n    importFromInlineCopy(\"clcache\", must_exist=True)\n\n    # Avoid importing this in threads, triggers CPython 3.9 importing bugs at least,\n    # do it now, so it's not a race issue.\n    import concurrent.futures.thread  # pylint: disable=I0021,unused-import,unused-variable\n\n    cl_binary = getExecutablePath(env.the_compiler, env)\n\n    # The compiler is passed via environment.\n    setEnvironmentVariable(env, \"CLCACHE_CL\", cl_binary)\n    env[\"CXX\"] = env[\"CC\"] = \"<clcache>\"\n\n    setEnvironmentVariable(env, \"CLCACHE_HIDE_OUTPUTS\", \"1\")\n\n    # Use the mode of clcache that is not dependent on MSVC filenames output\n    if \"CLCACHE_NODIRECT\" not in os.environ:\n        setEnvironmentVariable(env, \"CLCACHE_NODIRECT\", \"1\")\n\n    # The clcache stats filename needs absolute path, otherwise it will not work.\n    clcache_stats_filename = os.path.abspath(\n        os.path.join(source_dir, \"clcache-stats.%d.txt\" % os.getpid())\n    )\n\n    setEnvironmentVariable(env, \"CLCACHE_STATS\", clcache_stats_filename)\n    env[\"CLCACHE_STATS\"] = clcache_stats_filename\n\n    # Unless asked to do otherwise, store ccache files in our own directory.\n    if \"CLCACHE_DIR\" not in os.environ:\n        clcache_dir = os.path.join(getCacheDir(), \"clcache\")\n        makePath(clcache_dir)\n        clcache_dir = getExternalUsePath(clcache_dir)\n        setEnvironmentVariable(env, \"CLCACHE_DIR\", clcache_dir)\n        env[\"CLCACHE_DIR\"] = clcache_dir\n\n    scons_details_logger.info(\n        \"Using inline copy of clcache with %r cl binary.\" % cl_binary\n    )\n\n    import atexit\n\n    atexit.register(_writeClcacheStatistics)\n\n\ndef _writeClcacheStatistics():\n    try:\n        # pylint: disable=I0021,import-error,no-name-in-module,redefined-outer-name\n        from clcache.caching import stats\n\n        if stats is not None:\n            stats.save()\n\n    except IOError:\n        raise\n    except Exception:  # Catch all the things, pylint: disable=broad-except\n        # This is run in \"atexit\" even without the module being loaded, or\n        # the stats being begun or usable.\n        pass\n\n\ndef _getCcacheStatistics(ccache_logfile):\n    data = {}\n\n    if os.path.exists(ccache_logfile):\n        re_command = re.compile(r\"\\[.*? (\\d+) *\\] Command line: (.*)$\")\n        re_result = re.compile(r\"\\[.*? (\\d+) *\\] Result: (.*)$\")\n        re_anything = re.compile(r\"\\[.*? (\\d+) *\\] (.*)$\")\n\n        # Remember command from the pid, so later decision logged against pid\n        # can be matched against it.\n        commands = {}\n\n        for line in getFileContentByLine(ccache_logfile):\n            match = re_command.match(line)\n\n            if match:\n                pid, command = match.groups()\n                commands[pid] = command\n\n            match = re_result.match(line)\n            if match:\n                pid, result = match.groups()\n                result = result.strip()\n\n                try:\n                    command = data[commands[pid]]\n                except KeyError:\n                    # It seems writing to the file can be lossy, so we can have results for\n                    # unknown commands, but we don't use the command yet anyway, so just\n                    # be unique.\n                    command = \"unknown command leading to \" + line\n\n                # Older ccache on e.g. RHEL6 wasn't explicit about linking.\n                if result == \"unsupported compiler option\":\n                    if \" -o \" in command or \"unknown command\" in command:\n                        result = \"called for link\"\n\n                # But still try to catch this with log output if it happens.\n                if result == \"unsupported compiler option\":\n                    scons_logger.warning(\n                        \"Encountered unsupported compiler option for ccache in '%s'.\"\n                        % command\n                    )\n\n                    all_text = []\n\n                    for line2 in getFileContentByLine(ccache_logfile):\n                        match = re_anything.match(line2)\n\n                        if match:\n                            pid2, result = match.groups()\n                            if pid == pid2:\n                                all_text.append(result)\n\n                    scons_logger.warning(\"Full scons output: %s\" % all_text)\n\n                if result != \"called for link\":\n                    data[command] = result\n\n    return data\n\n\ndef checkCachingSuccess(source_dir):\n    ccache_logfile = getSconsReportValue(source_dir=source_dir, key=\"CCACHE_LOGFILE\")\n\n    if ccache_logfile is not None:\n        stats = _getCcacheStatistics(ccache_logfile)\n\n        if not stats:\n            scons_logger.warning(\"You are not using ccache.\")\n        else:\n            counts = defaultdict(int)\n\n            for _command, result in stats.items():\n                # These are not important to our users, time based decisions differentiate these.\n                if result in (\"cache hit (direct)\", \"cache hit (preprocessed)\"):\n                    result = \"cache hit\"\n\n                # Newer ccache has these, but they duplicate:\n                if result in (\n                    \"direct_cache_hit\",\n                    \"direct_cache_miss\",\n                    \"preprocessed_cache_hit\",\n                    \"preprocessed_cache_miss\",\n                    \"primary_storage_miss\",\n                ):\n                    continue\n                if result == \"primary_storage_hit\":\n                    result = \"cache hit\"\n                if result == \"cache_miss\":\n                    result = \"cache miss\"\n\n                # Usage of incbin causes this for the constants blob integration.\n                if result in (\"unsupported code directive\", \"disabled\"):\n                    continue\n\n                counts[result] += 1\n\n            scons_logger.info(\"Compiled %d C files using ccache.\" % len(stats))\n            for result, count in counts.items():\n                scons_logger.info(\n                    \"Cached C files (using ccache) with result '%s': %d\"\n                    % (result, count)\n                )\n\n    if os.name == \"nt\":\n        clcache_stats_filename = getSconsReportValue(\n            source_dir=source_dir, key=\"CLCACHE_STATS\"\n        )\n\n        if clcache_stats_filename is not None and os.path.exists(\n            clcache_stats_filename\n        ):\n            stats = eval(  # lazy, pylint: disable=eval-used\n                getFileContents(clcache_stats_filename)\n            )\n\n            clcache_hit = stats[\"CacheHits\"]\n            clcache_miss = stats[\"CacheMisses\"]\n\n            scons_logger.info(\n                \"Compiled %d C files using clcache with %d cache hits and %d cache misses.\"\n                % (clcache_hit + clcache_miss, clcache_hit, clcache_miss)\n            )\n\n\ndef runClCache(args, env):\n    # pylint: disable=I0021,import-error,no-name-in-module,redefined-outer-name\n    from clcache.caching import runClCache\n\n    # No Python2 compatibility\n    if str is bytes:\n        scons_logger.sysexit(\"Error, cannot use Python2 for scons when using MSVC.\")\n\n    # The first argument is \"<clcache>\" and should not be used.\n    result = runClCache(\n        os.environ[\"CLCACHE_CL\"], [arg.strip('\"') for arg in args[1:]], env\n    )\n\n    updateSconsProgressBar()\n\n    return result\n", "#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\" Node base classes.\n\nThese classes provide the generic base classes available for nodes,\nstatements or expressions alike. There is a dedicated module for\nexpression only stuff.\n\n\"\"\"\n\n# from abc import abstractmethod\n\nfrom abc import abstractmethod\n\nfrom nuitka import Options, Tracing, TreeXML, Variables\nfrom nuitka.__past__ import iterItems\nfrom nuitka.Errors import NuitkaNodeDesignError, NuitkaNodeError\nfrom nuitka.PythonVersions import python_version\nfrom nuitka.SourceCodeReferences import SourceCodeReference\nfrom nuitka.utils.InstanceCounters import (\n    counted_del,\n    counted_init,\n    isCountingInstances,\n)\n\nfrom .FutureSpecs import fromFlags\nfrom .NodeMakingHelpers import makeStatementOnlyNodesFromExpressions\nfrom .NodeMetaClasses import NodeCheckMetaClass, NodeMetaClassBase\n\n\nclass NodeBase(NodeMetaClassBase):\n    __slots__ = \"parent\", \"source_ref\"\n\n    # This can trigger if this is included to early.\n    assert Options.is_fullcompat is not None\n\n    # Avoid the attribute unless it's really necessary.\n    if Options.is_fullcompat:\n        __slots__ += (\"effective_source_ref\",)\n\n    # String to identify the node class, to be consistent with its name.\n    kind = None\n\n    @counted_init\n    def __init__(self, source_ref):\n        # The base class has no __init__ worth calling.\n\n        # Check source reference to meet basic standards, so we note errors\n        # when they occur.\n        assert source_ref is not None\n        assert source_ref.line is not None\n\n        self.parent = None\n\n        self.source_ref = source_ref\n\n    if isCountingInstances():\n        __del__ = counted_del()\n\n    @abstractmethod\n    def finalize(self):\n        pass\n\n    def __repr__(self):\n        return \"<Node %s>\" % (self.getDescription())\n\n    def getDescription(self):\n        \"\"\"Description of the node, intended for use in __repr__ and\n        graphical display.\n\n        \"\"\"\n        details = self.getDetailsForDisplay()\n\n        if details:\n            return \"'%s' with %s\" % (self.kind, details)\n        else:\n            return \"'%s'\" % self.kind\n\n    def getDetails(self):\n        \"\"\"Details of the node, intended for re-creation.\n\n        We are not using the pickle mechanisms, but this is basically\n        part of what the constructor call needs. Real children will\n        also be added.\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use\n        return {}\n\n    def getDetailsForDisplay(self):\n        \"\"\"Details of the node, intended for use in __repr__ and dumps.\n\n        This is also used for XML.\n        \"\"\"\n        return self.getDetails()\n\n    def getCloneArgs(self):\n        return self.getDetails()\n\n    def makeClone(self):\n        try:\n            # Using star dictionary arguments here for generic use.\n            result = self.__class__(source_ref=self.source_ref, **self.getCloneArgs())\n        except TypeError as e:\n            raise NuitkaNodeError(\"Problem cloning node\", self, e)\n\n        effective_source_ref = self.getCompatibleSourceReference()\n\n        if effective_source_ref is not self.source_ref:\n            result.setCompatibleSourceReference(effective_source_ref)\n\n        return result\n\n    def makeCloneShallow(self):\n        args = self.getDetails()\n        args.update(self.getVisitableNodesNamed())\n\n        try:\n            # Using star dictionary arguments here for generic use.\n            result = self.__class__(source_ref=self.source_ref, **args)\n        except TypeError as e:\n            raise NuitkaNodeError(\"Problem cloning node\", self, e)\n\n        effective_source_ref = self.getCompatibleSourceReference()\n\n        if effective_source_ref is not self.source_ref:\n            result.setCompatibleSourceReference(effective_source_ref)\n\n        return result\n\n    def getParent(self):\n        \"\"\"Parent of the node. Every node except modules has to have a parent.\"\"\"\n\n        if self.parent is None and not self.isCompiledPythonModule():\n            assert False, (self, self.source_ref)\n\n        return self.parent\n\n    def getChildName(self):\n        \"\"\"Return the role in the current parent, subject to changes.\"\"\"\n        parent = self.getParent()\n\n        for key, value in parent.getVisitableNodesNamed():\n            if self is value:\n                return key\n\n            if type(value) is tuple:\n                if self in value:\n                    return key, value.index(self)\n\n        return None\n\n    def getChildNameNice(self):\n        child_name = self.getChildName()\n\n        if hasattr(self.parent, \"nice_children\"):\n            return self.parent.nice_children[\n                self.parent.named_children.index(child_name)\n            ]\n        elif hasattr(self.parent, \"nice_child\"):\n            return self.parent.nice_child\n        else:\n            return child_name\n\n    def getParentFunction(self):\n        \"\"\"Return the parent that is a function.\"\"\"\n\n        parent = self.getParent()\n\n        while parent is not None and not parent.isExpressionFunctionBodyBase():\n            parent = parent.getParent()\n\n        return parent\n\n    def getParentModule(self):\n        \"\"\"Return the parent that is module.\"\"\"\n        parent = self\n\n        while not parent.isCompiledPythonModule():\n            if hasattr(parent, \"provider\"):\n                # After we checked, we can use it, will be much faster route\n                # to take.\n                parent = parent.provider\n            else:\n                parent = parent.getParent()\n\n        return parent\n\n    def isParentVariableProvider(self):\n        # Check if it's a closure giver, in which cases it can provide variables,\n        return isinstance(self, ClosureGiverNodeMixin)\n\n    def getParentVariableProvider(self):\n        parent = self.getParent()\n\n        while not parent.isParentVariableProvider():\n            parent = parent.getParent()\n\n        return parent\n\n    def getParentReturnConsumer(self):\n        parent = self.getParent()\n\n        while (\n            not parent.isParentVariableProvider()\n            and not parent.isExpressionOutlineBody()\n        ):\n            parent = parent.getParent()\n\n        return parent\n\n    def getParentStatementsFrame(self):\n        current = self.getParent()\n\n        while True:\n            if current.isStatementsFrame():\n                return current\n\n            if current.isParentVariableProvider():\n                return None\n\n            if current.isExpressionOutlineBody():\n                return None\n\n            current = current.getParent()\n\n    def getSourceReference(self):\n        return self.source_ref\n\n    def setCompatibleSourceReference(self, source_ref):\n        \"\"\"Bug compatible line numbers information.\n\n        As CPython outputs the last bit of bytecode executed, and not the\n        line of the operation. For example calls, output the line of the\n        last argument, as opposed to the line of the operation start.\n\n        For tests, we wants to be compatible. In improved more, we are\n        not being fully compatible, and just drop it altogether.\n        \"\"\"\n\n        # Getting the same source reference can be dealt with quickly, so do\n        # this first.\n        if (\n            self.source_ref is not source_ref\n            and Options.is_fullcompat\n            and self.source_ref != source_ref\n        ):\n            # An attribute outside of \"__init__\", so we save one memory for the\n            # most cases. Very few cases involve splitting across lines.\n            # false alarm for non-slot:\n            # pylint: disable=I0021,assigning-non-slot,attribute-defined-outside-init\n            self.effective_source_ref = source_ref\n\n    def getCompatibleSourceReference(self):\n        \"\"\"Bug compatible line numbers information.\n\n        See above.\n        \"\"\"\n        return getattr(self, \"effective_source_ref\", self.source_ref)\n\n    def asXml(self):\n        line = self.source_ref.getLineNumber()\n\n        result = TreeXML.Element(\"node\", kind=self.__class__.__name__, line=str(line))\n\n        compat_line = self.getCompatibleSourceReference().getLineNumber()\n\n        if compat_line != line:\n            result.attrib[\"compat_line\"] = str(compat_line)\n\n        for key, value in iterItems(self.getDetailsForDisplay()):\n            result.set(key, str(value))\n\n        for name, children in self.getVisitableNodesNamed():\n            role = TreeXML.Element(\"role\", name=name)\n\n            result.append(role)\n\n            if children is None:\n                role.attrib[\"type\"] = \"none\"\n            elif type(children) not in (list, tuple):\n                role.append(children.asXml())\n            else:\n                role.attrib[\"type\"] = \"list\"\n\n                for child in children:\n                    role.append(child.asXml())\n\n        return result\n\n    @classmethod\n    def fromXML(cls, provider, source_ref, **args):\n        # Only some things need a provider, pylint: disable=unused-argument\n        return cls(source_ref=source_ref, **args)\n\n    def asXmlText(self):\n        xml = self.asXml()\n\n        return TreeXML.toString(xml)\n\n    def dump(self, level=0):\n        Tracing.printIndented(level, self)\n        Tracing.printSeparator(level)\n\n        for visitable in self.getVisitableNodes():\n            visitable.dump(level + 1)\n\n        Tracing.printSeparator(level)\n\n    @staticmethod\n    def isStatementsFrame():\n        return False\n\n    @staticmethod\n    def isCompiledPythonModule():\n        # For overload by module nodes\n        return False\n\n    def isExpression(self):\n        return self.kind.startswith(\"EXPRESSION_\")\n\n    def isStatement(self):\n        return self.kind.startswith(\"STATEMENT_\")\n\n    def isExpressionBuiltin(self):\n        return self.kind.startswith(\"EXPRESSION_BUILTIN_\")\n\n    @staticmethod\n    def isStatementAssignmentVariable():\n        return False\n\n    @staticmethod\n    def isStatementDelVariable():\n        return False\n\n    @staticmethod\n    def isExpressionConstantRef():\n        return False\n\n    @staticmethod\n    def isExpressionConstantBoolRef():\n        return False\n\n    @staticmethod\n    def isExpressionOperationUnary():\n        return False\n\n    @staticmethod\n    def isExpressionOperationBinary():\n        return False\n\n    @staticmethod\n    def isExpressionOperationInplace():\n        return False\n\n    @staticmethod\n    def isExpressionComparison():\n        return False\n\n    @staticmethod\n    def isExpressionSideEffects():\n        return False\n\n    @staticmethod\n    def isExpressionMakeSequence():\n        return False\n\n    @staticmethod\n    def isNumberConstant():\n        return False\n\n    @staticmethod\n    def isExpressionCall():\n        return False\n\n    @staticmethod\n    def isExpressionFunctionBodyBase():\n        return False\n\n    @staticmethod\n    def isExpressionOutlineFunctionBase():\n        return False\n\n    @staticmethod\n    def isExpressionImportModuleNameHard():\n        return False\n\n    def visit(self, context, visitor):\n        visitor(self)\n\n        for visitable in self.getVisitableNodes():\n            visitable.visit(context, visitor)\n\n    @staticmethod\n    def getVisitableNodes():\n\n        return ()\n\n    @staticmethod\n    def getVisitableNodesNamed():\n        \"\"\"Named children dictionary.\n\n        For use in debugging and XML output.\n        \"\"\"\n\n        return ()\n\n    @staticmethod\n    def getName():\n        \"\"\"Name of the node if any.\"\"\"\n\n        return None\n\n    @staticmethod\n    def mayHaveSideEffects():\n        \"\"\"Unless we are told otherwise, everything may have a side effect.\"\"\"\n\n        return True\n\n    def isOrderRelevant(self):\n        return self.mayHaveSideEffects()\n\n    def extractSideEffects(self):\n        \"\"\"Unless defined otherwise, the expression is the side effect.\"\"\"\n\n        return (self,)\n\n    @staticmethod\n    def mayRaiseException(exception_type):\n        \"\"\"Unless we are told otherwise, everything may raise everything.\"\"\"\n        # Virtual method, pylint: disable=unused-argument\n\n        return True\n\n    @staticmethod\n    def mayReturn():\n        \"\"\"May this node do a return exit, to be overloaded for things that might.\"\"\"\n        return False\n\n    @staticmethod\n    def mayBreak():\n        return False\n\n    @staticmethod\n    def mayContinue():\n        return False\n\n    def needsFrame(self):\n        \"\"\"Unless we are tolder otherwise, this depends on exception raise.\"\"\"\n\n        return self.mayRaiseException(BaseException)\n\n    @staticmethod\n    def willRaiseException(exception_type):\n        \"\"\"Unless we are told otherwise, nothing may raise anything.\"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return False\n\n    @staticmethod\n    def isStatementAborting():\n        \"\"\"Is the node aborting, control flow doesn't continue after this node.\"\"\"\n        return False\n\n\nclass CodeNodeMixin(object):\n    # Mixins are not allow to specify slots, pylint: disable=assigning-non-slot\n    __slots__ = ()\n\n    def __init__(self, name, code_prefix):\n        assert name is not None\n\n        self.name = name\n        self.code_prefix = code_prefix\n\n        # The code name is determined on demand only.\n        self.code_name = None\n\n        # The \"UID\" values of children kinds are kept here.\n        self.uids = {}\n\n    def getName(self):\n        return self.name\n\n    def getCodeName(self):\n        if self.code_name is None:\n            provider = self.getParentVariableProvider().getEntryPoint()\n            parent_name = provider.getCodeName()\n\n            uid = \"_%d\" % provider.getChildUID(self)\n\n            assert isinstance(self, CodeNodeMixin)\n\n            if self.name:\n                name = uid + \"_\" + self.name.strip(\"<>\")\n            else:\n                name = uid\n\n            if str is not bytes:\n                name = name.encode(\"ascii\", \"c_identifier\").decode()\n\n            self.code_name = \"%s$$$%s_%s\" % (parent_name, self.code_prefix, name)\n\n        return self.code_name\n\n    def getChildUID(self, node):\n        if node.kind not in self.uids:\n            self.uids[node.kind] = 0\n\n        self.uids[node.kind] += 1\n\n        return self.uids[node.kind]\n\n\nclass ChildrenHavingMixin(object):\n    # Mixins are not allow to specify slots.\n    __slots__ = ()\n\n    named_children = ()\n\n    checkers = {}\n\n    def __init__(self, values):\n        assert (\n            type(self.named_children) is tuple and self.named_children\n        ), self.named_children\n\n        # TODO: Make this true.\n        # assert len(self.named_children) > 1, self.kind\n\n        # Check for completeness of given values, everything should be there\n        # but of course, might be put to None.\n        if set(values.keys()) != set(self.named_children):\n            raise NuitkaNodeDesignError(\n                \"Must pass named children in value dictionary\",\n                set(values.keys()),\n                set(self.named_children),\n            )\n\n        for name, value in values.items():\n            if name in self.checkers:\n                value = self.checkers[name](value)\n\n            if type(value) is tuple:\n                assert None not in value, name\n\n                for val in value:\n                    val.parent = self\n            elif value is None:\n                pass\n            else:\n                value.parent = self\n\n            attr_name = \"subnode_\" + name\n            setattr(self, attr_name, value)\n\n    def setChild(self, name, value):\n        \"\"\"Set a child value.\n\n        Do not overload, provider self.checkers instead.\n        \"\"\"\n        # Only accept legal child names\n        assert name in self.named_children, name\n\n        # Lists as inputs are OK, but turn them into tuples.\n        if type(value) is list:\n            value = tuple(value)\n\n        if name in self.checkers:\n            value = self.checkers[name](value)\n\n        # Re-parent value to us.\n        if type(value) is tuple:\n            for val in value:\n                val.parent = self\n        elif value is not None:\n            value.parent = self\n\n        attr_name = \"subnode_\" + name\n\n        # Determine old value, and inform it about losing its parent.\n        old_value = getattr(self, attr_name)\n\n        assert old_value is not value, value\n\n        setattr(self, attr_name, value)\n\n    def clearChild(self, name):\n        # Only accept legal child names\n        assert name in self.named_children, name\n\n        if name in self.checkers:\n            self.checkers[name](None)\n\n        attr_name = \"subnode_\" + name\n\n        # Determine old value, and inform it about losing its parent.\n        old_value = getattr(self, attr_name)\n\n        assert old_value is not None\n\n        setattr(self, attr_name, None)\n\n    def getChild(self, name):\n        attr_name = \"subnode_\" + name\n        return getattr(self, attr_name)\n\n    def getVisitableNodes(self):\n        # TODO: Consider if a generator would be faster.\n        result = []\n\n        for name in self.named_children:\n            attr_name = \"subnode_\" + name\n\n            value = getattr(self, attr_name)\n\n            if value is None:\n                pass\n            elif type(value) is tuple:\n                result += list(value)\n            elif isinstance(value, NodeBase):\n                result.append(value)\n            else:\n                raise AssertionError(\n                    self, \"has illegal child\", name, value, value.__class__\n                )\n\n        return tuple(result)\n\n    def getVisitableNodesNamed(self):\n        \"\"\"Named children dictionary.\n\n        For use in debugging and XML output.\n        \"\"\"\n        for name in self.named_children:\n            attr_name = \"subnode_\" + name\n            value = getattr(self, attr_name)\n\n            yield name, value\n\n    def replaceChild(self, old_node, new_node):\n        if new_node is not None and not isinstance(new_node, NodeBase):\n            raise AssertionError(\n                \"Cannot replace with\", new_node, \"old\", old_node, \"in\", self\n            )\n\n        # Find the replaced node, as an added difficulty, what might be\n        # happening, is that the old node is an element of a tuple, in which we\n        # may also remove that element, by setting it to None.\n        for key in self.named_children:\n            value = self.getChild(key)\n\n            if value is None:\n                pass\n            elif type(value) is tuple:\n                if old_node in value:\n                    if new_node is not None:\n                        self.setChild(\n                            key,\n                            tuple(\n                                (val if val is not old_node else new_node)\n                                for val in value\n                            ),\n                        )\n                    else:\n                        self.setChild(\n                            key, tuple(val for val in value if val is not old_node)\n                        )\n\n                    return key\n            elif isinstance(value, NodeBase):\n                if old_node is value:\n                    self.setChild(key, new_node)\n\n                    return key\n            else:\n                assert False, (key, value, value.__class__)\n\n        raise AssertionError(\"Didn't find child\", old_node, \"in\", self)\n\n    def getCloneArgs(self):\n        values = {}\n\n        for key in self.named_children:\n            value = self.getChild(key)\n\n            assert type(value) is not list, key\n\n            if value is None:\n                values[key] = None\n            elif type(value) is tuple:\n                values[key] = tuple(v.makeClone() for v in value)\n            else:\n                values[key] = value.makeClone()\n\n        values.update(self.getDetails())\n\n        return values\n\n    def finalize(self):\n        del self.parent\n\n        for c in self.getVisitableNodes():\n            c.finalize()\n\n\nclass ClosureGiverNodeMixin(CodeNodeMixin):\n    \"\"\"Base class for nodes that provide variables for closure takers.\"\"\"\n\n    # Mixins are not allow to specify slots, pylint: disable=assigning-non-slot\n    __slots__ = ()\n\n    def __init__(self, name, code_prefix):\n        CodeNodeMixin.__init__(self, name=name, code_prefix=code_prefix)\n\n        self.temp_variables = {}\n\n        self.temp_scopes = {}\n\n        self.preserver_id = 0\n\n    def hasProvidedVariable(self, variable_name):\n        return self.locals_scope.hasProvidedVariable(variable_name)\n\n    def getProvidedVariable(self, variable_name):\n        if not self.locals_scope.hasProvidedVariable(variable_name):\n            variable = self.createProvidedVariable(variable_name=variable_name)\n            self.locals_scope.registerProvidedVariable(variable)\n\n        return self.locals_scope.getProvidedVariable(variable_name)\n\n    @abstractmethod\n    def createProvidedVariable(self, variable_name):\n        \"\"\"Create a variable provided by this function.\"\"\"\n\n    def allocateTempScope(self, name):\n        self.temp_scopes[name] = self.temp_scopes.get(name, 0) + 1\n\n        return \"%s_%d\" % (name, self.temp_scopes[name])\n\n    def allocateTempVariable(self, temp_scope, name, temp_type=None):\n        if temp_scope is not None:\n            full_name = \"%s__%s\" % (temp_scope, name)\n        else:\n            assert name != \"result\"\n\n            full_name = name\n\n        # No duplicates please.\n        assert full_name not in self.temp_variables, full_name\n\n        result = self.createTempVariable(temp_name=full_name, temp_type=temp_type)\n\n        # Late added temp variables should be treated with care for the\n        # remaining trace.\n        if self.trace_collection is not None:\n            self.trace_collection.initVariableUnknown(result).addUsage()\n\n        return result\n\n    def createTempVariable(self, temp_name, temp_type):\n        if temp_name in self.temp_variables:\n            return self.temp_variables[temp_name]\n\n        if temp_type is None:\n            temp_class = Variables.TempVariable\n        elif temp_type == \"bool\":\n            temp_class = Variables.TempVariableBool\n        else:\n            assert False, temp_type\n\n        result = temp_class(owner=self, variable_name=temp_name)\n\n        self.temp_variables[temp_name] = result\n\n        return result\n\n    def getTempVariable(self, temp_scope, name):\n        if temp_scope is not None:\n            full_name = \"%s__%s\" % (temp_scope, name)\n        else:\n            full_name = name\n\n        return self.temp_variables[full_name]\n\n    def getTempVariables(self):\n        return self.temp_variables.values()\n\n    def _removeTempVariable(self, variable):\n        del self.temp_variables[variable.getName()]\n\n    def optimizeUnusedTempVariables(self):\n        remove = []\n\n        for temp_variable in self.getTempVariables():\n            empty = self.trace_collection.hasEmptyTraces(variable=temp_variable)\n\n            if empty:\n                remove.append(temp_variable)\n\n        for temp_variable in remove:\n            self._removeTempVariable(temp_variable)\n\n    def allocatePreserverId(self):\n        if python_version >= 0x300:\n            self.preserver_id += 1\n\n        return self.preserver_id\n\n\nclass ClosureTakerMixin(object):\n    \"\"\"Mixin for nodes that accept variables from closure givers.\"\"\"\n\n    # Mixins are not allow to specify slots, pylint: disable=assigning-non-slot\n    __slots__ = ()\n\n    def __init__(self, provider):\n        self.provider = provider\n\n        self.taken = set()\n\n    def getParentVariableProvider(self):\n        return self.provider\n\n    def getClosureVariable(self, variable_name):\n        result = self.provider.getVariableForClosure(variable_name=variable_name)\n        assert result is not None, variable_name\n\n        if not result.isModuleVariable():\n            self.addClosureVariable(result)\n\n        return result\n\n    def addClosureVariable(self, variable):\n        self.taken.add(variable)\n\n        return variable\n\n    def getClosureVariables(self):\n        return tuple(\n            sorted(\n                [take for take in self.taken if not take.isModuleVariable()],\n                key=lambda x: x.getName(),\n            )\n        )\n\n    def getClosureVariableIndex(self, variable):\n        closure_variables = self.getClosureVariables()\n\n        for count, closure_variable in enumerate(closure_variables):\n            if variable is closure_variable:\n                return count\n\n        raise IndexError(variable)\n\n    def hasTakenVariable(self, variable_name):\n        for variable in self.taken:\n            if variable.getName() == variable_name:\n                return True\n\n        return False\n\n    def getTakenVariable(self, variable_name):\n        for variable in self.taken:\n            if variable.getName() == variable_name:\n                return variable\n\n        return None\n\n\nclass StatementBase(NodeBase):\n    \"\"\"Base class for all statements.\"\"\"\n\n    # Base classes can be abstract, pylint: disable=abstract-method\n\n    # TODO: Have them all.\n    # @abstractmethod\n    @staticmethod\n    def getStatementNiceName():\n        return \"undescribed statement\"\n\n    def computeStatementSubExpressions(self, trace_collection):\n        \"\"\"Compute a statement.\n\n        Default behavior is to just visit the child expressions first, and\n        then the node \"computeStatement\". For a few cases this needs to\n        be overloaded.\n        \"\"\"\n        expressions = self.getVisitableNodes()\n\n        for count, expression in enumerate(expressions):\n            assert expression.isExpression(), (self, expression)\n\n            expression = trace_collection.onExpression(expression=expression)\n\n            if expression.willRaiseException(BaseException):\n                wrapped_expression = makeStatementOnlyNodesFromExpressions(\n                    expressions[: count + 1]\n                )\n\n                assert wrapped_expression is not None\n\n                return (\n                    wrapped_expression,\n                    \"new_raise\",\n                    lambda: \"For %s the child expression '%s' will raise.\"\n                    % (self.getStatementNiceName(), expression.getChildNameNice()),\n                )\n\n        return self, None, None\n\n\nclass StatementChildrenHavingBase(ChildrenHavingMixin, StatementBase):\n    def __init__(self, values, source_ref):\n        StatementBase.__init__(self, source_ref=source_ref)\n\n        ChildrenHavingMixin.__init__(self, values=values)\n\n\nclass StatementChildHavingBase(StatementBase):\n    named_child = \"\"\n\n    checker = None\n\n    def __init__(self, value, source_ref):\n        StatementBase.__init__(self, source_ref=source_ref)\n\n        if self.checker is not None:\n            value = self.checker(value)  # False alarm, pylint: disable=not-callable\n\n        assert type(value) is not list, self.named_child\n\n        if type(value) is tuple:\n            assert None not in value, self.named_child\n\n            for val in value:\n                val.parent = self\n        elif value is not None:\n            value.parent = self\n        elif value is None:\n            pass\n        else:\n            assert False, type(value)\n\n        attr_name = \"subnode_\" + self.named_child\n        setattr(self, attr_name, value)\n\n    def setChild(self, name, value):\n        \"\"\"Set a child value.\n\n        Do not overload, provider self.checkers instead.\n        \"\"\"\n        # Only accept legal child names\n        assert name == self.named_child, name\n\n        # Lists as inputs are OK, but turn them into tuples.\n        if type(value) is list:\n            value = tuple(value)\n\n        if self.checker is not None:\n            value = self.checker(value)  # False alarm, pylint: disable=not-callable\n\n        # Re-parent value to us.\n        if type(value) is tuple:\n            for val in value:\n                val.parent = self\n        elif value is not None:\n            value.parent = self\n\n        attr_name = \"subnode_\" + name\n\n        # Determine old value, and inform it about losing its parent.\n        old_value = getattr(self, attr_name)\n\n        assert old_value is not value, value\n\n        setattr(self, attr_name, value)\n\n    def getChild(self, name):\n        # Only accept legal child names\n        attr_name = \"subnode_\" + name\n        return getattr(self, attr_name)\n\n    def getVisitableNodes(self):\n        # TODO: Consider if a generator would be faster.\n        attr_name = \"subnode_\" + self.named_child\n        value = getattr(self, attr_name)\n\n        if value is None:\n            return ()\n        elif type(value) is tuple:\n            return value\n        elif isinstance(value, NodeBase):\n            return (value,)\n        else:\n            raise AssertionError(self, \"has illegal child\", value, value.__class__)\n\n    def getVisitableNodesNamed(self):\n        \"\"\"Named children dictionary.\n\n        For use in debugging and XML output.\n        \"\"\"\n        attr_name = \"subnode_\" + self.named_child\n        value = getattr(self, attr_name)\n\n        yield self.named_child, value\n\n    def replaceChild(self, old_node, new_node):\n        if new_node is not None and not isinstance(new_node, NodeBase):\n            raise AssertionError(\n                \"Cannot replace with\", new_node, \"old\", old_node, \"in\", self\n            )\n\n        # Find the replaced node, as an added difficulty, what might be\n        # happening, is that the old node is an element of a tuple, in which we\n        # may also remove that element, by setting it to None.\n        key = self.named_child\n        value = self.getChild(key)\n\n        if value is None:\n            pass\n        elif type(value) is tuple:\n            if old_node in value:\n                if new_node is not None:\n                    self.setChild(\n                        key,\n                        tuple(\n                            (val if val is not old_node else new_node) for val in value\n                        ),\n                    )\n                else:\n                    self.setChild(\n                        key, tuple(val for val in value if val is not old_node)\n                    )\n\n                return key\n        elif isinstance(value, NodeBase):\n            if old_node is value:\n                self.setChild(key, new_node)\n\n                return key\n        else:\n            assert False, (key, value, value.__class__)\n\n        raise AssertionError(\"Didn't find child\", old_node, \"in\", self)\n\n    def getCloneArgs(self):\n        # Make clones of child nodes too.\n        values = {}\n        key = self.named_child\n\n        value = self.getChild(key)\n\n        assert type(value) is not list, key\n\n        if value is None:\n            values[key] = None\n        elif type(value) is tuple:\n            values[key] = tuple(v.makeClone() for v in value)\n        else:\n            values[key] = value.makeClone()\n\n        values.update(self.getDetails())\n\n        return values\n\n    def finalize(self):\n        del self.parent\n\n        attr_name = \"subnode_\" + self.named_child\n        child = getattr(self, attr_name)\n        if child is not None:\n            child.finalize()\n        delattr(self, attr_name)\n\n\nclass SideEffectsFromChildrenMixin(object):\n    # Mixins are not allow to specify slots.\n    __slots__ = ()\n\n    def mayHaveSideEffects(self):\n        for child in self.getVisitableNodes():\n            if child.mayHaveSideEffects():\n                return True\n        return False\n\n    def extractSideEffects(self):\n        # No side effects at all but from the children.\n        result = []\n\n        for child in self.getVisitableNodes():\n            result.extend(child.extractSideEffects())\n\n        return tuple(result)\n\n    def computeExpressionDrop(self, statement, trace_collection):\n        # Expression only statement plays no role, pylint: disable=unused-argument\n\n        side_effects = self.extractSideEffects()\n\n        # TODO: Have a method for nicer output and remove existing overloads\n        # by using classes and prefer generic implementation here.\n        if side_effects:\n            return (\n                makeStatementOnlyNodesFromExpressions(side_effects),\n                \"new_statements\",\n                \"Lowered unused expression %s to its side effects.\" % self.kind,\n            )\n        else:\n            return (\n                None,\n                \"new_statements\",\n                \"Removed %s without side effects.\" % self.kind,\n            )\n\n\ndef makeChild(provider, child, source_ref):\n    child_type = child.attrib.get(\"type\")\n\n    if child_type == \"list\":\n        return [\n            fromXML(provider=provider, xml=sub_child, source_ref=source_ref)\n            for sub_child in child\n        ]\n    elif child_type == \"none\":\n        return None\n    else:\n        return fromXML(provider=provider, xml=child[0], source_ref=source_ref)\n\n\ndef getNodeClassFromKind(kind):\n    return NodeCheckMetaClass.kinds[kind]\n\n\ndef extractKindAndArgsFromXML(xml, source_ref):\n    kind = xml.attrib[\"kind\"]\n\n    args = dict(xml.attrib)\n    del args[\"kind\"]\n\n    if source_ref is None:\n        source_ref = SourceCodeReference.fromFilenameAndLine(\n            args[\"filename\"], int(args[\"line\"])\n        )\n\n        del args[\"filename\"]\n        del args[\"line\"]\n\n    else:\n        source_ref = source_ref.atLineNumber(int(args[\"line\"]))\n        del args[\"line\"]\n\n    node_class = getNodeClassFromKind(kind)\n\n    return kind, node_class, args, source_ref\n\n\ndef fromXML(provider, xml, source_ref=None):\n    assert xml.tag == \"node\", xml\n\n    kind, node_class, args, source_ref = extractKindAndArgsFromXML(xml, source_ref)\n\n    if \"constant\" in args:\n        # TODO: Try and reduce/avoid this, use marshal and/or pickle from a file\n        # global stream     instead. For now, this will do. pylint: disable=eval-used\n        args[\"constant\"] = eval(args[\"constant\"])\n\n    if kind in (\n        \"ExpressionFunctionBody\",\n        \"PythonMainModule\",\n        \"PythonCompiledModule\",\n        \"PythonCompiledPackage\",\n        \"PythonInternalModule\",\n    ):\n        delayed = node_class.named_children\n\n        if \"code_flags\" in args:\n            args[\"future_spec\"] = fromFlags(args[\"code_flags\"])\n    else:\n        delayed = ()\n\n    for child in xml:\n        assert child.tag == \"role\", child.tag\n\n        child_name = child.attrib[\"name\"]\n\n        # Might want to want until provider is updated with some\n        # children. In these cases, we pass the XML node, rather\n        # than a Nuitka node.\n        if child_name not in delayed:\n            args[child_name] = makeChild(provider, child, source_ref)\n        else:\n            args[child_name] = child\n\n    try:\n        return node_class.fromXML(provider=provider, source_ref=source_ref, **args)\n    except (TypeError, AttributeError):\n        Tracing.printLine(node_class, args, source_ref)\n        raise\n", "#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\"\nPlugins: Welcome to Nuitka! This is your shortest way to become part of it.\n\nThis is to provide the base class for all plugins. Some of which are part of\nproper Nuitka, and some of which are waiting to be created and submitted for\ninclusion by you.\n\nThe base class will serve as documentation. And it will point to examples of\nit being used.\n\"\"\"\n\nimport inspect\nimport os\nimport sys\nfrom collections import namedtuple\n\nfrom nuitka.__past__ import getMetaClassBase\nfrom nuitka.freezer.IncludedDataFiles import (\n    makeIncludedDataDirectory,\n    makeIncludedDataFile,\n    makeIncludedEmptyDirectories,\n    makeIncludedGeneratedDataFile,\n    makeIncludedPackageDataFiles,\n)\nfrom nuitka.freezer.IncludedEntryPoints import makeDllEntryPoint\nfrom nuitka.ModuleRegistry import getModuleInclusionInfoByName\nfrom nuitka.Options import isStandaloneMode\nfrom nuitka.Tracing import plugins_logger\nfrom nuitka.utils.Execution import NuitkaCalledProcessError, check_output\nfrom nuitka.utils.FileOperations import copyFile, makePath\nfrom nuitka.utils.ModuleNames import ModuleName\nfrom nuitka.utils.SharedLibraries import locateDLL, locateDLLsInDirectory\n\nwarned_unused_plugins = set()\n\n# Trigger names for shared use.\npostload_trigger_name = \"postLoad\"\npreload_trigger_name = \"preLoad\"\n\n\ndef makeTriggerModuleName(module_name, trigger_name):\n    return ModuleName(module_name + \"-\" + trigger_name)\n\n\nclass NuitkaPluginBase(getMetaClassBase(\"Plugin\")):\n    \"\"\"Nuitka base class for all plugins.\n\n    Derive your plugin from \"NuitkaPluginBase\" please.\n    For instructions, see https://github.com/Nuitka/Nuitka/blob/orsiris/UserPlugin-Creation.rst\n\n    Plugins allow to adapt Nuitka's behaviour in a number of ways as explained\n    below at the individual methods.\n\n    It is used to deal with special requirements some packages may have (e.g. PyQt\n    and tkinter), data files to be included (e.g. certifi), inserting hidden\n    code, coping with otherwise undetectable needs, or issuing messages in\n    certain situations.\n\n    A plugin in general must be enabled to be used by Nuitka. This happens by\n    specifying \"--enable-plugin\" (standard plugins) or by \"--user-plugin\" (user\n    plugins) in the Nuitka command line. However, some plugins are always enabled\n    and invisible to the user.\n\n    Nuitka comes with a number of \"standard\" plugins to be enabled as needed.\n    What they are can be displayed using \"nuitka --plugin-list file.py\" (filename\n    required but ignored).\n\n    User plugins may be specified (and implicitly enabled) using their Python\n    script pathname.\n    \"\"\"\n\n    # Standard plugins must provide this as a unique string which Nuitka\n    # then uses to identify them.\n    #\n    # User plugins are identified by their path and implicitly activated.\n    # They however still need to specify some arbitrary non-blank string here,\n    # which does not equal the name of an inactivated standard plugin.\n    # For working with options, user plugins must set this variable to\n    # the script's path (use __file__, __module__ or __name__).\n    plugin_name = None\n\n    @staticmethod\n    def isAlwaysEnabled():\n        \"\"\"Request to be always enabled.\n\n        Notes:\n            Setting this to true is only applicable to standard plugins. In\n            this case, the plugin will be enabled upon Nuitka start-up. Any\n            plugin detector class will then be ignored. Method isRelevant() may\n            also be present and can be used to fine-control enabling the\n            plugin: A to-be-enabled, but irrelevant plugin will still not be\n            activated.\n        Returns:\n            True or False\n        \"\"\"\n        return False\n\n    @classmethod\n    def isRelevant(cls):\n        \"\"\"Consider if the plugin is relevant.\n\n        Notes:\n            A plugin may only be a needed on a certain OS, or with some options,\n            but this is only a class method, so you will not have much run time\n            information.\n\n        Returns:\n            True or False\n\n        \"\"\"\n        return True\n\n    @classmethod\n    def addPluginCommandLineOptions(cls, group):\n        # Call group.add_option() here.\n        pass\n\n    @classmethod\n    def getPluginDefaultOptionValues(cls):\n        \"\"\"This method is used to get a values to use as defaults.\n\n        Since the defaults are in the command line options, we call\n        that and extract them.\n        \"\"\"\n\n        from optparse import OptionGroup, OptionParser\n\n        parser = OptionParser()\n        group = OptionGroup(parser, \"Pseudo Target\")\n        cls.addPluginCommandLineOptions(group)\n\n        result = {}\n        for option in group.option_list:\n            result[option.dest] = option.default\n\n        return result\n\n    def isRequiredImplicitImport(self, module, full_name):\n        \"\"\"Indicate whether an implicitly imported module should be accepted.\n\n        Notes:\n            You may negate importing a module specified as \"implicit import\",\n            although this is an unexpected event.\n\n        Args:\n            module: the module object\n            full_name: of the implicitly import module\n        Returns:\n            True or False\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return True\n\n    def getImplicitImports(self, module):\n        \"\"\"Return the implicit imports for a given module (iterator).\n\n        Args:\n            module: the module object\n        Yields:\n            implicit imports for the module\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def onModuleSourceCode(self, module_name, source_code):\n        \"\"\"Inspect or modify source code.\n\n        Args:\n            module_name: (str) name of module\n            source_code: (str) its source code\n        Returns:\n            source_code (str)\n        Notes:\n            Default implementation forwards to `checkModuleSourceCode` which is\n            going to allow simply checking the source code without the need to\n            pass it back.\n        \"\"\"\n        self.checkModuleSourceCode(module_name, source_code)\n\n        return source_code\n\n    def checkModuleSourceCode(self, module_name, source_code):\n        \"\"\"Inspect source code.\n\n        Args:\n            module_name: (str) name of module\n            source_code: (str) its source code\n        Returns:\n            None\n        \"\"\"\n\n    def onFrozenModuleSourceCode(self, module_name, is_package, source_code):\n        \"\"\"Inspect or modify frozen module source code.\n\n        Args:\n            module_name: (str) full name of module\n            is_package: (bool) True indicates a package\n            source_code: (str) its source code\n        Returns:\n            source_code (str)\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return source_code\n\n    def onFrozenModuleBytecode(self, module_name, is_package, bytecode):\n        \"\"\"Inspect or modify frozen module byte code.\n\n        Args:\n            module_name: (str) name of module\n            is_package: (bool) True indicates a package\n            bytecode: (bytes) byte code\n        Returns:\n            bytecode (bytes)\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return bytecode\n\n    @staticmethod\n    def createPreModuleLoadCode(module):\n        \"\"\"Create code to execute before importing a module.\n\n        Notes:\n            Called by @onModuleDiscovered.\n\n        Args:\n            module: the module object\n        Returns:\n            None (does not apply, default)\n            tuple (code, documentary string)\n            tuple (code, documentary string, flags)\n        \"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return None\n\n    @staticmethod\n    def createPostModuleLoadCode(module):\n        \"\"\"Create code to execute after loading to a module.\n\n        Notes:\n            Called by @onModuleDiscovered.\n\n        Args:\n            module: the module object\n\n        Returns:\n            None (does not apply, default)\n            tuple (code, documentary string)\n            tuple (code, documentary string, flags)\n        \"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return None\n\n    @staticmethod\n    def createFakeModuleDependency(module):\n        \"\"\"Create module to depend on.\n\n        Notes:\n            Called by @onModuleDiscovered.\n\n        Args:\n            module: the module object\n\n        Returns:\n            None (does not apply, default)\n            tuple (code, reason)\n            tuple (code, reason, flags)\n        \"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return None\n\n    @staticmethod\n    def hasPreModuleLoadCode(module_name):\n        return (\n            getModuleInclusionInfoByName(\n                makeTriggerModuleName(module_name, preload_trigger_name)\n            )\n            is not None\n        )\n\n    @staticmethod\n    def hasPostModuleLoadCode(module_name):\n        return (\n            getModuleInclusionInfoByName(\n                makeTriggerModuleName(module_name, postload_trigger_name)\n            )\n            is not None\n        )\n\n    def onModuleDiscovered(self, module):\n        \"\"\"Called with a module to be loaded.\n\n        Notes:\n            We may specify code to be prepended and/or appended to this module.\n            This code is stored in the appropriate dict.\n            For every imported module and each of these two options, only one plugin may do this.\n            We check this condition here.\n\n        Args:\n            module: the module object\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onModuleEncounter(self, module_name, module_filename, module_kind):\n        \"\"\"Help decide whether to include a module.\n\n        Args:\n            module_name: full module name\n            module_filename: filename\n            module_kind: one of \"py\", \"extension\" (shared library)\n        Returns:\n            True or False\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onModuleRecursion(self, module_name, module_filename, module_kind):\n        \"\"\"React to recursion to a module coming up.\n\n        Args:\n            module_name: full module name\n            module_filename: filename\n            module_kind: one of \"py\", \"extension\" (shared library)\n        Returns:\n            None\n        \"\"\"\n\n    def onModuleInitialSet(self):\n        \"\"\"Provide extra modules to the initial root module set.\n\n        Args:\n            None\n        Returns:\n            Iterable of modules, may yield.\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use\n        return ()\n\n    def onModuleCompleteSet(self, module_set):\n        \"\"\"Provide extra modules to the initial root module set.\n\n        Args:\n            module_set - tuple of module objects\n        Returns:\n            None\n        Notes:\n            You must not change anything, this is purely for warning\n            and error checking, and potentially for later stages to\n            prepare.\n        \"\"\"\n\n    @staticmethod\n    def locateModule(module_name):\n        \"\"\"Provide a filename / -path for a to-be-imported module.\n\n        Args:\n            importing: module object that asked for it (tracing only)\n            module_name: (str or ModuleName) full name of module\n        Returns:\n            filename for module\n        \"\"\"\n\n        from nuitka.importing.Importing import locateModule\n\n        _module_name, module_filename, _finding = locateModule(\n            module_name=ModuleName(module_name), parent_package=None, level=0\n        )\n\n        return module_filename\n\n    @staticmethod\n    def locateModules(module_name):\n        \"\"\"Provide a filename / -path for a to-be-imported module.\n\n        Args:\n            module_name: (str or ModuleName) full name of module\n        Returns:\n            list of ModuleName\n        \"\"\"\n\n        from nuitka.importing.Importing import locateModules\n\n        return locateModules(module_name)\n\n    @classmethod\n    def locateDLL(cls, dll_name):\n        \"\"\"Locate a DLL by name.\"\"\"\n        return locateDLL(dll_name)\n\n    @classmethod\n    def locateDLLsInDirectory(cls, directory):\n        \"\"\"Locate all DLLs in a folder\n\n        Returns:\n            list of (filename, filename_relative, dll_extension)\n        \"\"\"\n        return locateDLLsInDirectory(directory)\n\n    @classmethod\n    def makeDllEntryPoint(cls, source_path, dest_path, package_name):\n        \"\"\"Create an entry point, as expected to be provided by getExtraDlls.\"\"\"\n        return makeDllEntryPoint(\n            source_path=source_path, dest_path=dest_path, package_name=package_name\n        )\n\n    def reportFileCount(self, module_name, count, section=None):\n        if count:\n            msg = \"Found %d %s DLLs from %s%s installation.\" % (\n                count,\n                \"file\" if count < 2 else \"files\",\n                \"\" if not section else (\" '%s' \" % section),\n                module_name.asString(),\n            )\n\n            self.info(msg)\n\n    def considerExtraDlls(self, dist_dir, module):\n        \"\"\"Provide a tuple of names of binaries to be included.\n\n        Args:\n            dist_dir: the distribution folder\n            module: the module object needing the binaries\n        Returns:\n            tuple\n        \"\"\"\n        # TODO: This should no longer be here, as this API is obsolete, pylint: disable=unused-argument\n        for included_entry_point in self.getExtraDlls(module):\n            # Copy to the dist directory, which normally should not be a plugin task, but is for now.\n            makePath(os.path.dirname(included_entry_point.dest_path))\n\n            copyFile(included_entry_point.source_path, included_entry_point.dest_path)\n\n            yield included_entry_point\n\n    def getExtraDlls(self, module):\n        \"\"\"Provide IncludedEntryPoint named tuples describing extra needs of the module.\n\n        Args:\n            module: the module object needing the binaries\n        Returns:\n            yields IncludedEntryPoint objects\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def onCopiedDLL(self, dll_filename):\n        \"\"\"Chance for a plugin to modify DLLs after copy, e.g. to compress it, remove attributes, etc.\n\n        Args:\n            dll_filename: the filename of the DLL\n\n        Notes:\n            Do not remove or add any files in this method, this will not work well, there\n            is e.g. getExtraDLLs API to add things. This is only for post processing as\n            described above.\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def getModuleSpecificDllPaths(self, module_name):\n        \"\"\"Provide a list of directories, where DLLs should be searched for this package (or module).\n\n        Args:\n            module_name: name of a package or module, for which the DLL path addition applies.\n        Returns:\n            iterable of paths\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def removeDllDependencies(self, dll_filename, dll_filenames):\n        \"\"\"Yield any DLLs / shared libraries not to be included in distribution.\n\n        Args:\n            dll_filename: DLL name\n            dll_filenames: list of DLLs\n        Yields:\n            yielded filenames to exclude\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def considerDataFiles(self, module):\n        \"\"\"Yield data file names (source|func, target) for inclusion (iterator).\n\n        Args:\n            module: module object that may need extra data files\n        Yields:\n            Data file description pairs, either (source, dest) or (func, dest)\n            where the func will be called to create the content dynamically.\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def makeIncludedDataFile(self, source_path, dest_path, reason, tags=\"\"):\n        return makeIncludedDataFile(\n            source_path=source_path,\n            dest_path=dest_path,\n            reason=reason,\n            tracer=self,\n            tags=tags,\n        )\n\n    def makeIncludedGeneratedDataFile(self, data, dest_path, reason, tags=\"\"):\n        return makeIncludedGeneratedDataFile(\n            data=data, dest_path=dest_path, reason=reason, tracer=self, tags=tags\n        )\n\n    def makeIncludedDataDirectory(\n        self,\n        source_path,\n        dest_path,\n        reason,\n        tags=\"\",\n        ignore_dirs=(),\n        ignore_filenames=(),\n        ignore_suffixes=(),\n        only_suffixes=(),\n        normalize=True,\n    ):\n        return makeIncludedDataDirectory(\n            source_path=source_path,\n            dest_path=dest_path,\n            reason=reason,\n            tracer=self,\n            tags=tags,\n            ignore_dirs=ignore_dirs,\n            ignore_filenames=ignore_filenames,\n            ignore_suffixes=ignore_suffixes,\n            only_suffixes=only_suffixes,\n            normalize=normalize,\n        )\n\n    def makeIncludedEmptyDirectories(self, source_path, dest_paths, reason, tags):\n        return makeIncludedEmptyDirectories(\n            source_path=source_path,\n            dest_paths=dest_paths,\n            reason=reason,\n            tracer=self,\n            tags=tags,\n        )\n\n    def makeIncludedPackageDataFiles(\n        self, package_name, package_directory, pattern, reason, tags\n    ):\n        return makeIncludedPackageDataFiles(\n            tracer=self,\n            package_name=ModuleName(package_name),\n            package_directory=package_directory,\n            pattern=pattern,\n            reason=reason,\n            tags=tags,\n        )\n\n    def updateDataFileTags(self, included_datafile):\n        \"\"\"Add or remove data file tags.\"\"\"\n\n    def onDataFileTags(self, included_datafile):\n        \"\"\"Action on data file tags.\"\"\"\n\n    def onBeforeCodeParsing(self):\n        \"\"\"Prepare for code parsing, normally not needed.\"\"\"\n\n    def onStandaloneDistributionFinished(self, dist_dir):\n        \"\"\"Called after successfully creating a standalone distribution.\n\n        Note:\n            It is up to the plugin to take subsequent action. Examples are:\n            insert additional information (license, copyright, company or\n            application description), create installation material, further\n            folder clean-up, start downstream applications etc.\n\n        Args:\n            dist_dir: the created distribution folder\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onOnefileFinished(self, filename):\n        \"\"\"Called after successfully creating a onefile executable.\n\n        Note:\n            It is up to the plugin to take subsequent action. Examples are:\n            insert additional information (license, copyright, company or\n            application description), create installation material, further\n            folder clean-up, start downstream applications etc.\n\n        Args:\n            filename: the created onefile executable\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onBootstrapBinary(self, filename):\n        \"\"\"Called after successfully creating a bootstrap binary, but without payload.\n\n        Args:\n            filename: the created bootstrap binary, will be modified later\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onFinalResult(self, filename):\n        \"\"\"Called after successfully finishing a compilation.\n\n        Note:\n            Plugins normally don't need this, and what filename is will be\n            heavily dependent on compilation modes. Actions can be take here,\n            e.g. commercial plugins output generated keys near that executable\n            path.\n        Args:\n            filename: the created binary (module, accelerated exe, dist exe, onefile exe)\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def suppressUnknownImportWarning(self, importing, module_name, source_ref):\n        \"\"\"Suppress import warnings for unknown modules.\n\n        Args:\n            importing: the module object\n            module_name: name of module\n            source_ref: ???\n        Returns:\n            True or False\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return False\n\n    def decideCompilation(self, module_name):\n        \"\"\"Decide whether to compile a module (or just use its bytecode).\n\n        Notes:\n            The first plugin not returning None makes the decision. Thereafter,\n            no other plugins will be checked. If all plugins return None, the\n            module will be compiled.\n\n        Args:\n            module_name: name of module\n\n        Returns:\n            \"compiled\" or \"bytecode\" or None (no opinion, use by default)\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def getPreprocessorSymbols(self):\n        \"\"\"Decide which C defines to be used in compilation.\n\n        Notes:\n            The plugins can each contribute, but are hopefully using\n            a namespace for their defines.\n\n        Returns:\n            None for no defines, otherwise dictionary of key to be\n            defined, and non-None values if any, i.e. no \"-Dkey\" only\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraIncludeDirectories(self):\n        \"\"\"Decide which extra directories to use for C includes in compilation.\n\n        Returns:\n            List of directories or None by default\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraCodeFiles(self):\n        \"\"\"Add extra code files to the compilation.\n\n        Notes:\n            This is generally a bad idea to use unless you absolutely\n            know what you are doing.\n\n        Returns:\n            None for no extra codes, otherwise dictionary of key to be\n            filename, and value to be source code.\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraLinkLibraries(self):\n        \"\"\"Decide which link library should be added.\n\n        Notes:\n            Names provided multiple times, e.g. by multiple plugins are\n            only added once.\n\n        Returns:\n            None for no extra link library, otherwise the name as a **str**\n            or an iterable of names of link libraries.\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraLinkDirectories(self):\n        \"\"\"Decide which link directories should be added.\n\n        Notes:\n            Directories provided multiple times, e.g. by multiple plugins are\n            only added once.\n\n        Returns:\n            None for no extra link directory, otherwise the name as a **str**\n            or an iterable of names of link directories.\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def warnUnusedPlugin(self, message):\n        \"\"\"An inactive plugin may issue a warning if it believes this may be wrong.\n\n        Returns:\n            None\n        \"\"\"\n        if self.plugin_name not in warned_unused_plugins:\n            warned_unused_plugins.add(self.plugin_name)\n\n            plugins_logger.warning(\n                \"Use '--enable-plugin=%s' for: %s\" % (self.plugin_name, message)\n            )\n\n    def onDataComposerRun(self):\n        \"\"\"Internal use only.\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def onDataComposerResult(self, blob_filename):\n        \"\"\"Internal use only.\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def encodeDataComposerName(self, data_name):\n        \"\"\"Internal use only.\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    _runtime_information_cache = {}\n\n    def queryRuntimeInformationMultiple(self, info_name, setup_codes, values):\n        info_name = self.plugin_name.replace(\"-\", \"_\") + \"_\" + info_name\n\n        if info_name in self._runtime_information_cache:\n            return self._runtime_information_cache[info_name]\n\n        keys = []\n        query_codes = []\n\n        for key, value_expression in values:\n            keys.append(key)\n\n            query_codes.append(\"print(repr(%s))\" % value_expression)\n            query_codes.append('print(\"-\" * 27)')\n\n        if type(setup_codes) is str:\n            setup_codes = setup_codes.split(\"\\n\")\n\n        cmd = r\"\"\"\\\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\ntry:\n    %(setup_codes)s\nexcept ImportError:\n    import sys\n    sys.exit(38)\n%(query_codes)s\n\"\"\" % {\n            \"setup_codes\": \"\\n   \".join(setup_codes),\n            \"query_codes\": \"\\n\".join(query_codes),\n        }\n\n        try:\n            feedback = check_output([sys.executable, \"-c\", cmd])\n        except NuitkaCalledProcessError as e:\n            if e.returncode == 38:\n                return None\n            raise\n\n        if str is not bytes:  # We want to work with strings, that's hopefully OK.\n            feedback = feedback.decode(\"utf8\")\n\n        # Ignore Windows newlines difference.\n        feedback = [line.strip() for line in feedback.splitlines()]\n\n        if feedback.count(\"-\" * 27) != len(keys):\n            self.sysexit(\n                \"Error, mismatch in output retrieving %r information.\" % info_name\n            )\n\n        feedback = [line for line in feedback if line != \"-\" * 27]\n\n        NamedTupleResult = namedtuple(info_name, keys)\n\n        # We are being lazy here, the code is trusted, pylint: disable=eval-used\n        self._runtime_information_cache[info_name] = NamedTupleResult(\n            *(eval(value) for value in feedback)\n        )\n\n        return self._runtime_information_cache[info_name]\n\n    def queryRuntimeInformationSingle(self, setup_codes, value):\n        return self.queryRuntimeInformationMultiple(\n            info_name=\"temp_info_for_\" + self.plugin_name.replace(\"-\", \"_\"),\n            setup_codes=setup_codes,\n            values=((\"key\", value),),\n        ).key\n\n    def onFunctionBodyParsing(self, module_name, function_name, body):\n        \"\"\"Provide a different function body for the function of that module.\"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def getCacheContributionValues(self, module_name):\n        \"\"\"Provide values that represent the include of a plugin on the compilation.\n\n        This must be used to invalidate cache results, e.g. when using the\n        onFunctionBodyParsing function, and other things, that do not directly\n        affect the source code.\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    @classmethod\n    def warning(cls, message):\n        plugins_logger.warning(cls.plugin_name + \": \" + message)\n\n    @classmethod\n    def info(cls, message):\n        plugins_logger.info(cls.plugin_name + \": \" + message)\n\n    @classmethod\n    def sysexit(cls, message):\n        plugins_logger.sysexit(cls.plugin_name + \": \" + message)\n\n\nimport functools\n\n\ndef standalone_only(func):\n    \"\"\"For plugins that have functionality that should be done in standalone mode only.\"\"\"\n\n    @functools.wraps(func)\n    def wrapped(*args, **kwargs):\n        if isStandaloneMode():\n            return func(*args, **kwargs)\n        else:\n            if inspect.isgeneratorfunction(func):\n                return ()\n            else:\n                return None\n\n    return wrapped\n"], "fixing_code": ["#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\"\nThis is the main program of Nuitka, it checks the options and then translates\none or more modules to a C source code using Python C/API in a \"*.build\"\ndirectory and then compiles that to either an executable or an extension module\nor package, that can contain all used modules too.\n\"\"\"\n\n# Note: This avoids imports at all costs, such that initial startup doesn't do more\n# than necessary, until re-execution has been decided.\n\nimport ast\nimport os\nimport sys\n\n\ndef main():\n    # PyLint for Python3 thinks we import from ourselves if we really\n    # import from package, pylint: disable=I0021,no-name-in-module\n\n    # Also high complexity.\n    # pylint: disable=too-many-branches,too-many-locals,too-many-statements\n\n    if \"NUITKA_BINARY_NAME\" in os.environ:\n        sys.argv[0] = os.environ[\"NUITKA_BINARY_NAME\"]\n\n    if \"NUITKA_PYTHONPATH\" in os.environ:\n        # Restore the PYTHONPATH gained from the site module, that we chose not\n        # to have imported during compilation.\n        sys.path = ast.literal_eval(os.environ[\"NUITKA_PYTHONPATH\"])\n        del os.environ[\"NUITKA_PYTHONPATH\"]\n    else:\n        # Remove path element added for being called via \"__main__.py\", this can\n        # only lead to trouble, having e.g. a \"distutils\" in sys.path that comes\n        # from \"nuitka.distutils\".\n        sys.path = [\n            path_element\n            for path_element in sys.path\n            if os.path.dirname(os.path.abspath(__file__)) != path_element\n        ]\n\n    # We will run with the Python configuration as specified by the user, if it does\n    # not match, we restart ourselves with matching configuration.\n    needs_re_execution = False\n\n    if sys.flags.no_site == 0:\n        needs_re_execution = True\n\n    # The hash randomization totally changes the created source code created,\n    # changing it every single time Nuitka is run. This kills any attempt at\n    # caching it, and comparing generated source code. While the created binary\n    # actually may still use it, during compilation we don't want to. So lets\n    # disable it.\n    if os.environ.get(\"PYTHONHASHSEED\", \"-1\") != \"0\":\n        needs_re_execution = True\n\n    # In case we need to re-execute.\n    if needs_re_execution:\n        from nuitka.utils.ReExecute import reExecuteNuitka  # isort:skip\n\n        # Does not return\n        reExecuteNuitka(pgo_filename=None)\n\n    # We don't care about deprecations in any version, and these are triggered\n    # by run time calculations of \"range\" and others, while on python2.7 they\n    # are disabled by default.\n    import warnings\n\n    warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n    from nuitka import Options  # isort:skip\n\n    Options.parseArgs()\n\n    Options.commentArgs()\n\n    # Load plugins after we know, we don't execute again.\n    from nuitka.plugins.Plugins import activatePlugins\n\n    activatePlugins()\n\n    if Options.isShowMemory():\n        from nuitka.utils import MemoryUsage\n\n        MemoryUsage.startMemoryTracing()\n\n    if \"NUITKA_NAMESPACES\" in os.environ:\n        # Restore the detected name space packages, that were force loaded in\n        # site.py, and will need a free pass later on\n        from nuitka.importing.PreloadedPackages import setPreloadedPackagePaths\n\n        setPreloadedPackagePaths(ast.literal_eval(os.environ[\"NUITKA_NAMESPACES\"]))\n        del os.environ[\"NUITKA_NAMESPACES\"]\n\n    if \"NUITKA_PTH_IMPORTED\" in os.environ:\n        # Restore the packages that the \".pth\" files asked to import.\n        from nuitka.importing.PreloadedPackages import setPthImportedPackages\n\n        setPthImportedPackages(ast.literal_eval(os.environ[\"NUITKA_PTH_IMPORTED\"]))\n        del os.environ[\"NUITKA_PTH_IMPORTED\"]\n\n    # Now the real main program of Nuitka can take over.\n    from nuitka import MainControl  # isort:skip\n\n    MainControl.main()\n\n    if Options.isShowMemory():\n        MemoryUsage.showMemoryTrace()\n\n\nif __name__ == \"__main__\":\n    if \"NUITKA_PACKAGE_HOME\" in os.environ:\n        sys.path.insert(0, os.environ[\"NUITKA_PACKAGE_HOME\"])\n\n        import nuitka  # just to have it loaded from there, pylint: disable=unused-import\n\n        del sys.path[0]\n\n    main()\n", "#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\" Caching of C compiler output.\n\n\"\"\"\n\nimport ast\nimport os\nimport platform\nimport re\nimport sys\nfrom collections import defaultdict\n\nfrom nuitka.Tracing import scons_details_logger, scons_logger\nfrom nuitka.utils.AppDirs import getCacheDir\nfrom nuitka.utils.Download import getCachedDownload\nfrom nuitka.utils.FileOperations import (\n    areSamePaths,\n    getExternalUsePath,\n    getFileContentByLine,\n    getFileContents,\n    getLinkTarget,\n    makePath,\n)\nfrom nuitka.utils.Importing import importFromInlineCopy\nfrom nuitka.utils.Utils import isMacOS, isWin32Windows\n\nfrom .SconsProgress import updateSconsProgressBar\nfrom .SconsUtils import (\n    getExecutablePath,\n    getSconsReportValue,\n    setEnvironmentVariable,\n)\n\n\ndef _getPythonDirCandidates(python_prefix):\n    result = [python_prefix]\n\n    for python_dir in (\n        sys.prefix,\n        os.environ.get(\"CONDA_PREFIX\"),\n        os.environ.get(\"CONDA\"),\n    ):\n        if python_dir and python_dir not in result:\n            result.append(python_dir)\n\n    return result\n\n\ndef _getCcacheGuessedPaths(python_prefix):\n    if isWin32Windows():\n        # Search the compiling Python, the Scons Python (likely the same, but not necessarily)\n        # and then Anaconda, if an environment variable present from activated, or installed in\n        # CI like GitHub actions.\n        for python_dir in _getPythonDirCandidates(python_prefix):\n            yield os.path.join(python_dir, \"bin\", \"ccache.exe\")\n            yield os.path.join(python_dir, \"scripts\", \"ccache.exe\")\n\n    elif isMacOS():\n        # For macOS, we might find Homebrew ccache installed but not in PATH.\n        yield \"/usr/local/opt/ccache\"\n        yield \"/opt/homebrew/bin/ccache\"\n\n\ndef _injectCcache(env, cc_path, python_prefix, target_arch, assume_yes_for_downloads):\n    ccache_binary = os.environ.get(\"NUITKA_CCACHE_BINARY\")\n\n    # If not provided, search it in PATH and guessed directories.\n    if ccache_binary is None:\n        ccache_binary = getExecutablePath(\"ccache\", env=env)\n\n        if ccache_binary is None:\n            for candidate in _getCcacheGuessedPaths(python_prefix):\n                scons_details_logger.info(\n                    \"Checking if ccache is at '%s' guessed path.\" % candidate\n                )\n\n                if os.path.exists(candidate):\n                    ccache_binary = candidate\n\n                    scons_details_logger.info(\n                        \"Using ccache '%s' from guessed path.\" % ccache_binary\n                    )\n\n                    break\n\n        if ccache_binary is None:\n            if isWin32Windows():\n                url = \"https://github.com/ccache/ccache/releases/download/v4.6/ccache-4.6-windows-32.zip\"\n                ccache_binary = getCachedDownload(\n                    url=url,\n                    is_arch_specific=False,\n                    specificity=url.rsplit(\"/\", 2)[1],\n                    flatten=True,\n                    binary=\"ccache.exe\",\n                    message=\"Nuitka will make use of ccache to speed up repeated compilation.\",\n                    reject=None,\n                    assume_yes_for_downloads=assume_yes_for_downloads,\n                )\n            elif isMacOS():\n                # TODO: Do not yet have M1 access to create one and 10.14 is minimum\n                # we managed to compile ccache for.\n                if target_arch != \"arm64\" and tuple(\n                    int(d) for d in platform.release().split(\".\")\n                ) >= (18, 2):\n                    url = \"https://nuitka.net/ccache/v4.2.1/ccache-4.2.1.zip\"\n\n                    ccache_binary = getCachedDownload(\n                        url=url,\n                        is_arch_specific=False,\n                        specificity=url.rsplit(\"/\", 2)[1],\n                        flatten=True,\n                        binary=\"ccache\",\n                        message=\"Nuitka will make use of ccache to speed up repeated compilation.\",\n                        reject=None,\n                        assume_yes_for_downloads=assume_yes_for_downloads,\n                    )\n\n    else:\n        scons_details_logger.info(\n            \"Using ccache '%s' from NUITKA_CCACHE_BINARY environment variable.\"\n            % ccache_binary\n        )\n\n    if ccache_binary is not None and os.path.exists(ccache_binary):\n        # Make sure the\n        # In case we are on Windows, make sure the Anaconda form runs outside of Anaconda\n        # environment, by adding DLL folder to PATH.\n        assert areSamePaths(\n            getExecutablePath(os.path.basename(env.the_compiler), env=env), cc_path\n        )\n\n        # We use absolute paths for CC, pass it like this, as ccache does not like absolute.\n        env[\"CXX\"] = env[\"CC\"] = '\"%s\" \"%s\"' % (ccache_binary, cc_path)\n\n        # Spare ccache the detection of the compiler, seems it will also misbehave when it's\n        # prefixed with \"ccache\" on old gcc versions in terms of detecting need for C++ linkage.\n        env[\"LINK\"] = cc_path\n\n        scons_details_logger.info(\n            \"Found ccache '%s' to cache C compilation result.\" % ccache_binary\n        )\n        scons_details_logger.info(\n            \"Providing real CC path '%s' via PATH extension.\" % cc_path\n        )\n\n\ndef enableCcache(\n    env,\n    source_dir,\n    python_prefix,\n    target_arch,\n    assume_yes_for_downloads,\n):\n    # The ccache needs absolute path, otherwise it will not work.\n    ccache_logfile = os.path.abspath(\n        os.path.join(source_dir, \"ccache-%d.txt\" % os.getpid())\n    )\n\n    setEnvironmentVariable(env, \"CCACHE_LOGFILE\", ccache_logfile)\n    env[\"CCACHE_LOGFILE\"] = ccache_logfile\n\n    # Unless asked to do otherwise, store ccache files in our own directory.\n    if \"CCACHE_DIR\" not in os.environ:\n        ccache_dir = os.path.join(getCacheDir(), \"ccache\")\n        makePath(ccache_dir)\n        ccache_dir = getExternalUsePath(ccache_dir)\n        setEnvironmentVariable(env, \"CCACHE_DIR\", ccache_dir)\n        env[\"CCACHE_DIR\"] = ccache_dir\n\n    # We know the include files we created are safe to use.\n    setEnvironmentVariable(\n        env, \"CCACHE_SLOPPINESS\", \"include_file_ctime,include_file_mtime\"\n    )\n\n    # First check if it's not already supposed to be a ccache, then do nothing.\n    cc_path = getExecutablePath(env.the_compiler, env=env)\n\n    cc_is_link, cc_link_path = getLinkTarget(cc_path)\n    if cc_is_link and os.path.basename(cc_link_path) == \"ccache\":\n        scons_details_logger.info(\n            \"Chosen compiler %s is pointing to ccache %s already.\"\n            % (cc_path, cc_link_path)\n        )\n\n        return True\n\n    return _injectCcache(\n        env=env,\n        cc_path=cc_path,\n        python_prefix=python_prefix,\n        target_arch=target_arch,\n        assume_yes_for_downloads=assume_yes_for_downloads,\n    )\n\n\ndef enableClcache(env, source_dir):\n    importFromInlineCopy(\"atomicwrites\", must_exist=True)\n    importFromInlineCopy(\"clcache\", must_exist=True)\n\n    # Avoid importing this in threads, triggers CPython 3.9 importing bugs at least,\n    # do it now, so it's not a race issue.\n    import concurrent.futures.thread  # pylint: disable=I0021,unused-import,unused-variable\n\n    cl_binary = getExecutablePath(env.the_compiler, env)\n\n    # The compiler is passed via environment.\n    setEnvironmentVariable(env, \"CLCACHE_CL\", cl_binary)\n    env[\"CXX\"] = env[\"CC\"] = \"<clcache>\"\n\n    setEnvironmentVariable(env, \"CLCACHE_HIDE_OUTPUTS\", \"1\")\n\n    # Use the mode of clcache that is not dependent on MSVC filenames output\n    if \"CLCACHE_NODIRECT\" not in os.environ:\n        setEnvironmentVariable(env, \"CLCACHE_NODIRECT\", \"1\")\n\n    # The clcache stats filename needs absolute path, otherwise it will not work.\n    clcache_stats_filename = os.path.abspath(\n        os.path.join(source_dir, \"clcache-stats.%d.txt\" % os.getpid())\n    )\n\n    setEnvironmentVariable(env, \"CLCACHE_STATS\", clcache_stats_filename)\n    env[\"CLCACHE_STATS\"] = clcache_stats_filename\n\n    # Unless asked to do otherwise, store ccache files in our own directory.\n    if \"CLCACHE_DIR\" not in os.environ:\n        clcache_dir = os.path.join(getCacheDir(), \"clcache\")\n        makePath(clcache_dir)\n        clcache_dir = getExternalUsePath(clcache_dir)\n        setEnvironmentVariable(env, \"CLCACHE_DIR\", clcache_dir)\n        env[\"CLCACHE_DIR\"] = clcache_dir\n\n    scons_details_logger.info(\n        \"Using inline copy of clcache with %r cl binary.\" % cl_binary\n    )\n\n    import atexit\n\n    atexit.register(_writeClcacheStatistics)\n\n\ndef _writeClcacheStatistics():\n    try:\n        # pylint: disable=I0021,import-error,no-name-in-module,redefined-outer-name\n        from clcache.caching import stats\n\n        if stats is not None:\n            stats.save()\n\n    except IOError:\n        raise\n    except Exception:  # Catch all the things, pylint: disable=broad-except\n        # This is run in \"atexit\" even without the module being loaded, or\n        # the stats being begun or usable.\n        pass\n\n\ndef _getCcacheStatistics(ccache_logfile):\n    data = {}\n\n    if os.path.exists(ccache_logfile):\n        re_command = re.compile(r\"\\[.*? (\\d+) *\\] Command line: (.*)$\")\n        re_result = re.compile(r\"\\[.*? (\\d+) *\\] Result: (.*)$\")\n        re_anything = re.compile(r\"\\[.*? (\\d+) *\\] (.*)$\")\n\n        # Remember command from the pid, so later decision logged against pid\n        # can be matched against it.\n        commands = {}\n\n        for line in getFileContentByLine(ccache_logfile):\n            match = re_command.match(line)\n\n            if match:\n                pid, command = match.groups()\n                commands[pid] = command\n\n            match = re_result.match(line)\n            if match:\n                pid, result = match.groups()\n                result = result.strip()\n\n                try:\n                    command = data[commands[pid]]\n                except KeyError:\n                    # It seems writing to the file can be lossy, so we can have results for\n                    # unknown commands, but we don't use the command yet anyway, so just\n                    # be unique.\n                    command = \"unknown command leading to \" + line\n\n                # Older ccache on e.g. RHEL6 wasn't explicit about linking.\n                if result == \"unsupported compiler option\":\n                    if \" -o \" in command or \"unknown command\" in command:\n                        result = \"called for link\"\n\n                # But still try to catch this with log output if it happens.\n                if result == \"unsupported compiler option\":\n                    scons_logger.warning(\n                        \"Encountered unsupported compiler option for ccache in '%s'.\"\n                        % command\n                    )\n\n                    all_text = []\n\n                    for line2 in getFileContentByLine(ccache_logfile):\n                        match = re_anything.match(line2)\n\n                        if match:\n                            pid2, result = match.groups()\n                            if pid == pid2:\n                                all_text.append(result)\n\n                    scons_logger.warning(\"Full scons output: %s\" % all_text)\n\n                if result != \"called for link\":\n                    data[command] = result\n\n    return data\n\n\ndef checkCachingSuccess(source_dir):\n    ccache_logfile = getSconsReportValue(source_dir=source_dir, key=\"CCACHE_LOGFILE\")\n\n    if ccache_logfile is not None:\n        stats = _getCcacheStatistics(ccache_logfile)\n\n        if not stats:\n            scons_logger.warning(\"You are not using ccache.\")\n        else:\n            counts = defaultdict(int)\n\n            for _command, result in stats.items():\n                # These are not important to our users, time based decisions differentiate these.\n                if result in (\"cache hit (direct)\", \"cache hit (preprocessed)\"):\n                    result = \"cache hit\"\n\n                # Newer ccache has these, but they duplicate:\n                if result in (\n                    \"direct_cache_hit\",\n                    \"direct_cache_miss\",\n                    \"preprocessed_cache_hit\",\n                    \"preprocessed_cache_miss\",\n                    \"primary_storage_miss\",\n                ):\n                    continue\n                if result == \"primary_storage_hit\":\n                    result = \"cache hit\"\n                if result == \"cache_miss\":\n                    result = \"cache miss\"\n\n                # Usage of incbin causes this for the constants blob integration.\n                if result in (\"unsupported code directive\", \"disabled\"):\n                    continue\n\n                counts[result] += 1\n\n            scons_logger.info(\"Compiled %d C files using ccache.\" % len(stats))\n            for result, count in counts.items():\n                scons_logger.info(\n                    \"Cached C files (using ccache) with result '%s': %d\"\n                    % (result, count)\n                )\n\n    if os.name == \"nt\":\n        clcache_stats_filename = getSconsReportValue(\n            source_dir=source_dir, key=\"CLCACHE_STATS\"\n        )\n\n        if clcache_stats_filename is not None and os.path.exists(\n            clcache_stats_filename\n        ):\n            stats = ast.literal_eval(getFileContents(clcache_stats_filename))\n\n            clcache_hit = stats[\"CacheHits\"]\n            clcache_miss = stats[\"CacheMisses\"]\n\n            scons_logger.info(\n                \"Compiled %d C files using clcache with %d cache hits and %d cache misses.\"\n                % (clcache_hit + clcache_miss, clcache_hit, clcache_miss)\n            )\n\n\ndef runClCache(args, env):\n    # pylint: disable=I0021,import-error,no-name-in-module,redefined-outer-name\n    from clcache.caching import runClCache\n\n    # No Python2 compatibility\n    if str is bytes:\n        scons_logger.sysexit(\"Error, cannot use Python2 for scons when using MSVC.\")\n\n    # The first argument is \"<clcache>\" and should not be used.\n    result = runClCache(\n        os.environ[\"CLCACHE_CL\"], [arg.strip('\"') for arg in args[1:]], env\n    )\n\n    updateSconsProgressBar()\n\n    return result\n", "#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\" Node base classes.\n\nThese classes provide the generic base classes available for nodes,\nstatements or expressions alike. There is a dedicated module for\nexpression only stuff.\n\n\"\"\"\n\n# from abc import abstractmethod\n\nimport ast\nfrom abc import abstractmethod\n\nfrom nuitka import Options, Tracing, TreeXML, Variables\nfrom nuitka.__past__ import iterItems\nfrom nuitka.Errors import NuitkaNodeDesignError, NuitkaNodeError\nfrom nuitka.PythonVersions import python_version\nfrom nuitka.SourceCodeReferences import SourceCodeReference\nfrom nuitka.utils.InstanceCounters import (\n    counted_del,\n    counted_init,\n    isCountingInstances,\n)\n\nfrom .FutureSpecs import fromFlags\nfrom .NodeMakingHelpers import makeStatementOnlyNodesFromExpressions\nfrom .NodeMetaClasses import NodeCheckMetaClass, NodeMetaClassBase\n\n\nclass NodeBase(NodeMetaClassBase):\n    __slots__ = \"parent\", \"source_ref\"\n\n    # This can trigger if this is included to early.\n    assert Options.is_fullcompat is not None\n\n    # Avoid the attribute unless it's really necessary.\n    if Options.is_fullcompat:\n        __slots__ += (\"effective_source_ref\",)\n\n    # String to identify the node class, to be consistent with its name.\n    kind = None\n\n    @counted_init\n    def __init__(self, source_ref):\n        # The base class has no __init__ worth calling.\n\n        # Check source reference to meet basic standards, so we note errors\n        # when they occur.\n        assert source_ref is not None\n        assert source_ref.line is not None\n\n        self.parent = None\n\n        self.source_ref = source_ref\n\n    if isCountingInstances():\n        __del__ = counted_del()\n\n    @abstractmethod\n    def finalize(self):\n        pass\n\n    def __repr__(self):\n        return \"<Node %s>\" % (self.getDescription())\n\n    def getDescription(self):\n        \"\"\"Description of the node, intended for use in __repr__ and\n        graphical display.\n\n        \"\"\"\n        details = self.getDetailsForDisplay()\n\n        if details:\n            return \"'%s' with %s\" % (self.kind, details)\n        else:\n            return \"'%s'\" % self.kind\n\n    def getDetails(self):\n        \"\"\"Details of the node, intended for re-creation.\n\n        We are not using the pickle mechanisms, but this is basically\n        part of what the constructor call needs. Real children will\n        also be added.\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use\n        return {}\n\n    def getDetailsForDisplay(self):\n        \"\"\"Details of the node, intended for use in __repr__ and dumps.\n\n        This is also used for XML.\n        \"\"\"\n        return self.getDetails()\n\n    def getCloneArgs(self):\n        return self.getDetails()\n\n    def makeClone(self):\n        try:\n            # Using star dictionary arguments here for generic use.\n            result = self.__class__(source_ref=self.source_ref, **self.getCloneArgs())\n        except TypeError as e:\n            raise NuitkaNodeError(\"Problem cloning node\", self, e)\n\n        effective_source_ref = self.getCompatibleSourceReference()\n\n        if effective_source_ref is not self.source_ref:\n            result.setCompatibleSourceReference(effective_source_ref)\n\n        return result\n\n    def makeCloneShallow(self):\n        args = self.getDetails()\n        args.update(self.getVisitableNodesNamed())\n\n        try:\n            # Using star dictionary arguments here for generic use.\n            result = self.__class__(source_ref=self.source_ref, **args)\n        except TypeError as e:\n            raise NuitkaNodeError(\"Problem cloning node\", self, e)\n\n        effective_source_ref = self.getCompatibleSourceReference()\n\n        if effective_source_ref is not self.source_ref:\n            result.setCompatibleSourceReference(effective_source_ref)\n\n        return result\n\n    def getParent(self):\n        \"\"\"Parent of the node. Every node except modules has to have a parent.\"\"\"\n\n        if self.parent is None and not self.isCompiledPythonModule():\n            assert False, (self, self.source_ref)\n\n        return self.parent\n\n    def getChildName(self):\n        \"\"\"Return the role in the current parent, subject to changes.\"\"\"\n        parent = self.getParent()\n\n        for key, value in parent.getVisitableNodesNamed():\n            if self is value:\n                return key\n\n            if type(value) is tuple:\n                if self in value:\n                    return key, value.index(self)\n\n        return None\n\n    def getChildNameNice(self):\n        child_name = self.getChildName()\n\n        if hasattr(self.parent, \"nice_children\"):\n            return self.parent.nice_children[\n                self.parent.named_children.index(child_name)\n            ]\n        elif hasattr(self.parent, \"nice_child\"):\n            return self.parent.nice_child\n        else:\n            return child_name\n\n    def getParentFunction(self):\n        \"\"\"Return the parent that is a function.\"\"\"\n\n        parent = self.getParent()\n\n        while parent is not None and not parent.isExpressionFunctionBodyBase():\n            parent = parent.getParent()\n\n        return parent\n\n    def getParentModule(self):\n        \"\"\"Return the parent that is module.\"\"\"\n        parent = self\n\n        while not parent.isCompiledPythonModule():\n            if hasattr(parent, \"provider\"):\n                # After we checked, we can use it, will be much faster route\n                # to take.\n                parent = parent.provider\n            else:\n                parent = parent.getParent()\n\n        return parent\n\n    def isParentVariableProvider(self):\n        # Check if it's a closure giver, in which cases it can provide variables,\n        return isinstance(self, ClosureGiverNodeMixin)\n\n    def getParentVariableProvider(self):\n        parent = self.getParent()\n\n        while not parent.isParentVariableProvider():\n            parent = parent.getParent()\n\n        return parent\n\n    def getParentReturnConsumer(self):\n        parent = self.getParent()\n\n        while (\n            not parent.isParentVariableProvider()\n            and not parent.isExpressionOutlineBody()\n        ):\n            parent = parent.getParent()\n\n        return parent\n\n    def getParentStatementsFrame(self):\n        current = self.getParent()\n\n        while True:\n            if current.isStatementsFrame():\n                return current\n\n            if current.isParentVariableProvider():\n                return None\n\n            if current.isExpressionOutlineBody():\n                return None\n\n            current = current.getParent()\n\n    def getSourceReference(self):\n        return self.source_ref\n\n    def setCompatibleSourceReference(self, source_ref):\n        \"\"\"Bug compatible line numbers information.\n\n        As CPython outputs the last bit of bytecode executed, and not the\n        line of the operation. For example calls, output the line of the\n        last argument, as opposed to the line of the operation start.\n\n        For tests, we wants to be compatible. In improved more, we are\n        not being fully compatible, and just drop it altogether.\n        \"\"\"\n\n        # Getting the same source reference can be dealt with quickly, so do\n        # this first.\n        if (\n            self.source_ref is not source_ref\n            and Options.is_fullcompat\n            and self.source_ref != source_ref\n        ):\n            # An attribute outside of \"__init__\", so we save one memory for the\n            # most cases. Very few cases involve splitting across lines.\n            # false alarm for non-slot:\n            # pylint: disable=I0021,assigning-non-slot,attribute-defined-outside-init\n            self.effective_source_ref = source_ref\n\n    def getCompatibleSourceReference(self):\n        \"\"\"Bug compatible line numbers information.\n\n        See above.\n        \"\"\"\n        return getattr(self, \"effective_source_ref\", self.source_ref)\n\n    def asXml(self):\n        line = self.source_ref.getLineNumber()\n\n        result = TreeXML.Element(\"node\", kind=self.__class__.__name__, line=str(line))\n\n        compat_line = self.getCompatibleSourceReference().getLineNumber()\n\n        if compat_line != line:\n            result.attrib[\"compat_line\"] = str(compat_line)\n\n        for key, value in iterItems(self.getDetailsForDisplay()):\n            result.set(key, str(value))\n\n        for name, children in self.getVisitableNodesNamed():\n            role = TreeXML.Element(\"role\", name=name)\n\n            result.append(role)\n\n            if children is None:\n                role.attrib[\"type\"] = \"none\"\n            elif type(children) not in (list, tuple):\n                role.append(children.asXml())\n            else:\n                role.attrib[\"type\"] = \"list\"\n\n                for child in children:\n                    role.append(child.asXml())\n\n        return result\n\n    @classmethod\n    def fromXML(cls, provider, source_ref, **args):\n        # Only some things need a provider, pylint: disable=unused-argument\n        return cls(source_ref=source_ref, **args)\n\n    def asXmlText(self):\n        xml = self.asXml()\n\n        return TreeXML.toString(xml)\n\n    def dump(self, level=0):\n        Tracing.printIndented(level, self)\n        Tracing.printSeparator(level)\n\n        for visitable in self.getVisitableNodes():\n            visitable.dump(level + 1)\n\n        Tracing.printSeparator(level)\n\n    @staticmethod\n    def isStatementsFrame():\n        return False\n\n    @staticmethod\n    def isCompiledPythonModule():\n        # For overload by module nodes\n        return False\n\n    def isExpression(self):\n        return self.kind.startswith(\"EXPRESSION_\")\n\n    def isStatement(self):\n        return self.kind.startswith(\"STATEMENT_\")\n\n    def isExpressionBuiltin(self):\n        return self.kind.startswith(\"EXPRESSION_BUILTIN_\")\n\n    @staticmethod\n    def isStatementAssignmentVariable():\n        return False\n\n    @staticmethod\n    def isStatementDelVariable():\n        return False\n\n    @staticmethod\n    def isExpressionConstantRef():\n        return False\n\n    @staticmethod\n    def isExpressionConstantBoolRef():\n        return False\n\n    @staticmethod\n    def isExpressionOperationUnary():\n        return False\n\n    @staticmethod\n    def isExpressionOperationBinary():\n        return False\n\n    @staticmethod\n    def isExpressionOperationInplace():\n        return False\n\n    @staticmethod\n    def isExpressionComparison():\n        return False\n\n    @staticmethod\n    def isExpressionSideEffects():\n        return False\n\n    @staticmethod\n    def isExpressionMakeSequence():\n        return False\n\n    @staticmethod\n    def isNumberConstant():\n        return False\n\n    @staticmethod\n    def isExpressionCall():\n        return False\n\n    @staticmethod\n    def isExpressionFunctionBodyBase():\n        return False\n\n    @staticmethod\n    def isExpressionOutlineFunctionBase():\n        return False\n\n    @staticmethod\n    def isExpressionImportModuleNameHard():\n        return False\n\n    def visit(self, context, visitor):\n        visitor(self)\n\n        for visitable in self.getVisitableNodes():\n            visitable.visit(context, visitor)\n\n    @staticmethod\n    def getVisitableNodes():\n\n        return ()\n\n    @staticmethod\n    def getVisitableNodesNamed():\n        \"\"\"Named children dictionary.\n\n        For use in debugging and XML output.\n        \"\"\"\n\n        return ()\n\n    @staticmethod\n    def getName():\n        \"\"\"Name of the node if any.\"\"\"\n\n        return None\n\n    @staticmethod\n    def mayHaveSideEffects():\n        \"\"\"Unless we are told otherwise, everything may have a side effect.\"\"\"\n\n        return True\n\n    def isOrderRelevant(self):\n        return self.mayHaveSideEffects()\n\n    def extractSideEffects(self):\n        \"\"\"Unless defined otherwise, the expression is the side effect.\"\"\"\n\n        return (self,)\n\n    @staticmethod\n    def mayRaiseException(exception_type):\n        \"\"\"Unless we are told otherwise, everything may raise everything.\"\"\"\n        # Virtual method, pylint: disable=unused-argument\n\n        return True\n\n    @staticmethod\n    def mayReturn():\n        \"\"\"May this node do a return exit, to be overloaded for things that might.\"\"\"\n        return False\n\n    @staticmethod\n    def mayBreak():\n        return False\n\n    @staticmethod\n    def mayContinue():\n        return False\n\n    def needsFrame(self):\n        \"\"\"Unless we are tolder otherwise, this depends on exception raise.\"\"\"\n\n        return self.mayRaiseException(BaseException)\n\n    @staticmethod\n    def willRaiseException(exception_type):\n        \"\"\"Unless we are told otherwise, nothing may raise anything.\"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return False\n\n    @staticmethod\n    def isStatementAborting():\n        \"\"\"Is the node aborting, control flow doesn't continue after this node.\"\"\"\n        return False\n\n\nclass CodeNodeMixin(object):\n    # Mixins are not allow to specify slots, pylint: disable=assigning-non-slot\n    __slots__ = ()\n\n    def __init__(self, name, code_prefix):\n        assert name is not None\n\n        self.name = name\n        self.code_prefix = code_prefix\n\n        # The code name is determined on demand only.\n        self.code_name = None\n\n        # The \"UID\" values of children kinds are kept here.\n        self.uids = {}\n\n    def getName(self):\n        return self.name\n\n    def getCodeName(self):\n        if self.code_name is None:\n            provider = self.getParentVariableProvider().getEntryPoint()\n            parent_name = provider.getCodeName()\n\n            uid = \"_%d\" % provider.getChildUID(self)\n\n            assert isinstance(self, CodeNodeMixin)\n\n            if self.name:\n                name = uid + \"_\" + self.name.strip(\"<>\")\n            else:\n                name = uid\n\n            if str is not bytes:\n                name = name.encode(\"ascii\", \"c_identifier\").decode()\n\n            self.code_name = \"%s$$$%s_%s\" % (parent_name, self.code_prefix, name)\n\n        return self.code_name\n\n    def getChildUID(self, node):\n        if node.kind not in self.uids:\n            self.uids[node.kind] = 0\n\n        self.uids[node.kind] += 1\n\n        return self.uids[node.kind]\n\n\nclass ChildrenHavingMixin(object):\n    # Mixins are not allow to specify slots.\n    __slots__ = ()\n\n    named_children = ()\n\n    checkers = {}\n\n    def __init__(self, values):\n        assert (\n            type(self.named_children) is tuple and self.named_children\n        ), self.named_children\n\n        # TODO: Make this true.\n        # assert len(self.named_children) > 1, self.kind\n\n        # Check for completeness of given values, everything should be there\n        # but of course, might be put to None.\n        if set(values.keys()) != set(self.named_children):\n            raise NuitkaNodeDesignError(\n                \"Must pass named children in value dictionary\",\n                set(values.keys()),\n                set(self.named_children),\n            )\n\n        for name, value in values.items():\n            if name in self.checkers:\n                value = self.checkers[name](value)\n\n            if type(value) is tuple:\n                assert None not in value, name\n\n                for val in value:\n                    val.parent = self\n            elif value is None:\n                pass\n            else:\n                value.parent = self\n\n            attr_name = \"subnode_\" + name\n            setattr(self, attr_name, value)\n\n    def setChild(self, name, value):\n        \"\"\"Set a child value.\n\n        Do not overload, provider self.checkers instead.\n        \"\"\"\n        # Only accept legal child names\n        assert name in self.named_children, name\n\n        # Lists as inputs are OK, but turn them into tuples.\n        if type(value) is list:\n            value = tuple(value)\n\n        if name in self.checkers:\n            value = self.checkers[name](value)\n\n        # Re-parent value to us.\n        if type(value) is tuple:\n            for val in value:\n                val.parent = self\n        elif value is not None:\n            value.parent = self\n\n        attr_name = \"subnode_\" + name\n\n        # Determine old value, and inform it about losing its parent.\n        old_value = getattr(self, attr_name)\n\n        assert old_value is not value, value\n\n        setattr(self, attr_name, value)\n\n    def clearChild(self, name):\n        # Only accept legal child names\n        assert name in self.named_children, name\n\n        if name in self.checkers:\n            self.checkers[name](None)\n\n        attr_name = \"subnode_\" + name\n\n        # Determine old value, and inform it about losing its parent.\n        old_value = getattr(self, attr_name)\n\n        assert old_value is not None\n\n        setattr(self, attr_name, None)\n\n    def getChild(self, name):\n        attr_name = \"subnode_\" + name\n        return getattr(self, attr_name)\n\n    def getVisitableNodes(self):\n        # TODO: Consider if a generator would be faster.\n        result = []\n\n        for name in self.named_children:\n            attr_name = \"subnode_\" + name\n\n            value = getattr(self, attr_name)\n\n            if value is None:\n                pass\n            elif type(value) is tuple:\n                result += list(value)\n            elif isinstance(value, NodeBase):\n                result.append(value)\n            else:\n                raise AssertionError(\n                    self, \"has illegal child\", name, value, value.__class__\n                )\n\n        return tuple(result)\n\n    def getVisitableNodesNamed(self):\n        \"\"\"Named children dictionary.\n\n        For use in debugging and XML output.\n        \"\"\"\n        for name in self.named_children:\n            attr_name = \"subnode_\" + name\n            value = getattr(self, attr_name)\n\n            yield name, value\n\n    def replaceChild(self, old_node, new_node):\n        if new_node is not None and not isinstance(new_node, NodeBase):\n            raise AssertionError(\n                \"Cannot replace with\", new_node, \"old\", old_node, \"in\", self\n            )\n\n        # Find the replaced node, as an added difficulty, what might be\n        # happening, is that the old node is an element of a tuple, in which we\n        # may also remove that element, by setting it to None.\n        for key in self.named_children:\n            value = self.getChild(key)\n\n            if value is None:\n                pass\n            elif type(value) is tuple:\n                if old_node in value:\n                    if new_node is not None:\n                        self.setChild(\n                            key,\n                            tuple(\n                                (val if val is not old_node else new_node)\n                                for val in value\n                            ),\n                        )\n                    else:\n                        self.setChild(\n                            key, tuple(val for val in value if val is not old_node)\n                        )\n\n                    return key\n            elif isinstance(value, NodeBase):\n                if old_node is value:\n                    self.setChild(key, new_node)\n\n                    return key\n            else:\n                assert False, (key, value, value.__class__)\n\n        raise AssertionError(\"Didn't find child\", old_node, \"in\", self)\n\n    def getCloneArgs(self):\n        values = {}\n\n        for key in self.named_children:\n            value = self.getChild(key)\n\n            assert type(value) is not list, key\n\n            if value is None:\n                values[key] = None\n            elif type(value) is tuple:\n                values[key] = tuple(v.makeClone() for v in value)\n            else:\n                values[key] = value.makeClone()\n\n        values.update(self.getDetails())\n\n        return values\n\n    def finalize(self):\n        del self.parent\n\n        for c in self.getVisitableNodes():\n            c.finalize()\n\n\nclass ClosureGiverNodeMixin(CodeNodeMixin):\n    \"\"\"Base class for nodes that provide variables for closure takers.\"\"\"\n\n    # Mixins are not allow to specify slots, pylint: disable=assigning-non-slot\n    __slots__ = ()\n\n    def __init__(self, name, code_prefix):\n        CodeNodeMixin.__init__(self, name=name, code_prefix=code_prefix)\n\n        self.temp_variables = {}\n\n        self.temp_scopes = {}\n\n        self.preserver_id = 0\n\n    def hasProvidedVariable(self, variable_name):\n        return self.locals_scope.hasProvidedVariable(variable_name)\n\n    def getProvidedVariable(self, variable_name):\n        if not self.locals_scope.hasProvidedVariable(variable_name):\n            variable = self.createProvidedVariable(variable_name=variable_name)\n            self.locals_scope.registerProvidedVariable(variable)\n\n        return self.locals_scope.getProvidedVariable(variable_name)\n\n    @abstractmethod\n    def createProvidedVariable(self, variable_name):\n        \"\"\"Create a variable provided by this function.\"\"\"\n\n    def allocateTempScope(self, name):\n        self.temp_scopes[name] = self.temp_scopes.get(name, 0) + 1\n\n        return \"%s_%d\" % (name, self.temp_scopes[name])\n\n    def allocateTempVariable(self, temp_scope, name, temp_type=None):\n        if temp_scope is not None:\n            full_name = \"%s__%s\" % (temp_scope, name)\n        else:\n            assert name != \"result\"\n\n            full_name = name\n\n        # No duplicates please.\n        assert full_name not in self.temp_variables, full_name\n\n        result = self.createTempVariable(temp_name=full_name, temp_type=temp_type)\n\n        # Late added temp variables should be treated with care for the\n        # remaining trace.\n        if self.trace_collection is not None:\n            self.trace_collection.initVariableUnknown(result).addUsage()\n\n        return result\n\n    def createTempVariable(self, temp_name, temp_type):\n        if temp_name in self.temp_variables:\n            return self.temp_variables[temp_name]\n\n        if temp_type is None:\n            temp_class = Variables.TempVariable\n        elif temp_type == \"bool\":\n            temp_class = Variables.TempVariableBool\n        else:\n            assert False, temp_type\n\n        result = temp_class(owner=self, variable_name=temp_name)\n\n        self.temp_variables[temp_name] = result\n\n        return result\n\n    def getTempVariable(self, temp_scope, name):\n        if temp_scope is not None:\n            full_name = \"%s__%s\" % (temp_scope, name)\n        else:\n            full_name = name\n\n        return self.temp_variables[full_name]\n\n    def getTempVariables(self):\n        return self.temp_variables.values()\n\n    def _removeTempVariable(self, variable):\n        del self.temp_variables[variable.getName()]\n\n    def optimizeUnusedTempVariables(self):\n        remove = []\n\n        for temp_variable in self.getTempVariables():\n            empty = self.trace_collection.hasEmptyTraces(variable=temp_variable)\n\n            if empty:\n                remove.append(temp_variable)\n\n        for temp_variable in remove:\n            self._removeTempVariable(temp_variable)\n\n    def allocatePreserverId(self):\n        if python_version >= 0x300:\n            self.preserver_id += 1\n\n        return self.preserver_id\n\n\nclass ClosureTakerMixin(object):\n    \"\"\"Mixin for nodes that accept variables from closure givers.\"\"\"\n\n    # Mixins are not allow to specify slots, pylint: disable=assigning-non-slot\n    __slots__ = ()\n\n    def __init__(self, provider):\n        self.provider = provider\n\n        self.taken = set()\n\n    def getParentVariableProvider(self):\n        return self.provider\n\n    def getClosureVariable(self, variable_name):\n        result = self.provider.getVariableForClosure(variable_name=variable_name)\n        assert result is not None, variable_name\n\n        if not result.isModuleVariable():\n            self.addClosureVariable(result)\n\n        return result\n\n    def addClosureVariable(self, variable):\n        self.taken.add(variable)\n\n        return variable\n\n    def getClosureVariables(self):\n        return tuple(\n            sorted(\n                [take for take in self.taken if not take.isModuleVariable()],\n                key=lambda x: x.getName(),\n            )\n        )\n\n    def getClosureVariableIndex(self, variable):\n        closure_variables = self.getClosureVariables()\n\n        for count, closure_variable in enumerate(closure_variables):\n            if variable is closure_variable:\n                return count\n\n        raise IndexError(variable)\n\n    def hasTakenVariable(self, variable_name):\n        for variable in self.taken:\n            if variable.getName() == variable_name:\n                return True\n\n        return False\n\n    def getTakenVariable(self, variable_name):\n        for variable in self.taken:\n            if variable.getName() == variable_name:\n                return variable\n\n        return None\n\n\nclass StatementBase(NodeBase):\n    \"\"\"Base class for all statements.\"\"\"\n\n    # Base classes can be abstract, pylint: disable=abstract-method\n\n    # TODO: Have them all.\n    # @abstractmethod\n    @staticmethod\n    def getStatementNiceName():\n        return \"undescribed statement\"\n\n    def computeStatementSubExpressions(self, trace_collection):\n        \"\"\"Compute a statement.\n\n        Default behavior is to just visit the child expressions first, and\n        then the node \"computeStatement\". For a few cases this needs to\n        be overloaded.\n        \"\"\"\n        expressions = self.getVisitableNodes()\n\n        for count, expression in enumerate(expressions):\n            assert expression.isExpression(), (self, expression)\n\n            expression = trace_collection.onExpression(expression=expression)\n\n            if expression.willRaiseException(BaseException):\n                wrapped_expression = makeStatementOnlyNodesFromExpressions(\n                    expressions[: count + 1]\n                )\n\n                assert wrapped_expression is not None\n\n                return (\n                    wrapped_expression,\n                    \"new_raise\",\n                    lambda: \"For %s the child expression '%s' will raise.\"\n                    % (self.getStatementNiceName(), expression.getChildNameNice()),\n                )\n\n        return self, None, None\n\n\nclass StatementChildrenHavingBase(ChildrenHavingMixin, StatementBase):\n    def __init__(self, values, source_ref):\n        StatementBase.__init__(self, source_ref=source_ref)\n\n        ChildrenHavingMixin.__init__(self, values=values)\n\n\nclass StatementChildHavingBase(StatementBase):\n    named_child = \"\"\n\n    checker = None\n\n    def __init__(self, value, source_ref):\n        StatementBase.__init__(self, source_ref=source_ref)\n\n        if self.checker is not None:\n            value = self.checker(value)  # False alarm, pylint: disable=not-callable\n\n        assert type(value) is not list, self.named_child\n\n        if type(value) is tuple:\n            assert None not in value, self.named_child\n\n            for val in value:\n                val.parent = self\n        elif value is not None:\n            value.parent = self\n        elif value is None:\n            pass\n        else:\n            assert False, type(value)\n\n        attr_name = \"subnode_\" + self.named_child\n        setattr(self, attr_name, value)\n\n    def setChild(self, name, value):\n        \"\"\"Set a child value.\n\n        Do not overload, provider self.checkers instead.\n        \"\"\"\n        # Only accept legal child names\n        assert name == self.named_child, name\n\n        # Lists as inputs are OK, but turn them into tuples.\n        if type(value) is list:\n            value = tuple(value)\n\n        if self.checker is not None:\n            value = self.checker(value)  # False alarm, pylint: disable=not-callable\n\n        # Re-parent value to us.\n        if type(value) is tuple:\n            for val in value:\n                val.parent = self\n        elif value is not None:\n            value.parent = self\n\n        attr_name = \"subnode_\" + name\n\n        # Determine old value, and inform it about losing its parent.\n        old_value = getattr(self, attr_name)\n\n        assert old_value is not value, value\n\n        setattr(self, attr_name, value)\n\n    def getChild(self, name):\n        # Only accept legal child names\n        attr_name = \"subnode_\" + name\n        return getattr(self, attr_name)\n\n    def getVisitableNodes(self):\n        # TODO: Consider if a generator would be faster.\n        attr_name = \"subnode_\" + self.named_child\n        value = getattr(self, attr_name)\n\n        if value is None:\n            return ()\n        elif type(value) is tuple:\n            return value\n        elif isinstance(value, NodeBase):\n            return (value,)\n        else:\n            raise AssertionError(self, \"has illegal child\", value, value.__class__)\n\n    def getVisitableNodesNamed(self):\n        \"\"\"Named children dictionary.\n\n        For use in debugging and XML output.\n        \"\"\"\n        attr_name = \"subnode_\" + self.named_child\n        value = getattr(self, attr_name)\n\n        yield self.named_child, value\n\n    def replaceChild(self, old_node, new_node):\n        if new_node is not None and not isinstance(new_node, NodeBase):\n            raise AssertionError(\n                \"Cannot replace with\", new_node, \"old\", old_node, \"in\", self\n            )\n\n        # Find the replaced node, as an added difficulty, what might be\n        # happening, is that the old node is an element of a tuple, in which we\n        # may also remove that element, by setting it to None.\n        key = self.named_child\n        value = self.getChild(key)\n\n        if value is None:\n            pass\n        elif type(value) is tuple:\n            if old_node in value:\n                if new_node is not None:\n                    self.setChild(\n                        key,\n                        tuple(\n                            (val if val is not old_node else new_node) for val in value\n                        ),\n                    )\n                else:\n                    self.setChild(\n                        key, tuple(val for val in value if val is not old_node)\n                    )\n\n                return key\n        elif isinstance(value, NodeBase):\n            if old_node is value:\n                self.setChild(key, new_node)\n\n                return key\n        else:\n            assert False, (key, value, value.__class__)\n\n        raise AssertionError(\"Didn't find child\", old_node, \"in\", self)\n\n    def getCloneArgs(self):\n        # Make clones of child nodes too.\n        values = {}\n        key = self.named_child\n\n        value = self.getChild(key)\n\n        assert type(value) is not list, key\n\n        if value is None:\n            values[key] = None\n        elif type(value) is tuple:\n            values[key] = tuple(v.makeClone() for v in value)\n        else:\n            values[key] = value.makeClone()\n\n        values.update(self.getDetails())\n\n        return values\n\n    def finalize(self):\n        del self.parent\n\n        attr_name = \"subnode_\" + self.named_child\n        child = getattr(self, attr_name)\n        if child is not None:\n            child.finalize()\n        delattr(self, attr_name)\n\n\nclass SideEffectsFromChildrenMixin(object):\n    # Mixins are not allow to specify slots.\n    __slots__ = ()\n\n    def mayHaveSideEffects(self):\n        for child in self.getVisitableNodes():\n            if child.mayHaveSideEffects():\n                return True\n        return False\n\n    def extractSideEffects(self):\n        # No side effects at all but from the children.\n        result = []\n\n        for child in self.getVisitableNodes():\n            result.extend(child.extractSideEffects())\n\n        return tuple(result)\n\n    def computeExpressionDrop(self, statement, trace_collection):\n        # Expression only statement plays no role, pylint: disable=unused-argument\n\n        side_effects = self.extractSideEffects()\n\n        # TODO: Have a method for nicer output and remove existing overloads\n        # by using classes and prefer generic implementation here.\n        if side_effects:\n            return (\n                makeStatementOnlyNodesFromExpressions(side_effects),\n                \"new_statements\",\n                \"Lowered unused expression %s to its side effects.\" % self.kind,\n            )\n        else:\n            return (\n                None,\n                \"new_statements\",\n                \"Removed %s without side effects.\" % self.kind,\n            )\n\n\ndef makeChild(provider, child, source_ref):\n    child_type = child.attrib.get(\"type\")\n\n    if child_type == \"list\":\n        return [\n            fromXML(provider=provider, xml=sub_child, source_ref=source_ref)\n            for sub_child in child\n        ]\n    elif child_type == \"none\":\n        return None\n    else:\n        return fromXML(provider=provider, xml=child[0], source_ref=source_ref)\n\n\ndef getNodeClassFromKind(kind):\n    return NodeCheckMetaClass.kinds[kind]\n\n\ndef extractKindAndArgsFromXML(xml, source_ref):\n    kind = xml.attrib[\"kind\"]\n\n    args = dict(xml.attrib)\n    del args[\"kind\"]\n\n    if source_ref is None:\n        source_ref = SourceCodeReference.fromFilenameAndLine(\n            args[\"filename\"], int(args[\"line\"])\n        )\n\n        del args[\"filename\"]\n        del args[\"line\"]\n\n    else:\n        source_ref = source_ref.atLineNumber(int(args[\"line\"]))\n        del args[\"line\"]\n\n    node_class = getNodeClassFromKind(kind)\n\n    return kind, node_class, args, source_ref\n\n\ndef fromXML(provider, xml, source_ref=None):\n    assert xml.tag == \"node\", xml\n\n    kind, node_class, args, source_ref = extractKindAndArgsFromXML(xml, source_ref)\n\n    if \"constant\" in args:\n        args[\"constant\"] = ast.literal_eval(args[\"constant\"])\n\n    if kind in (\n        \"ExpressionFunctionBody\",\n        \"PythonMainModule\",\n        \"PythonCompiledModule\",\n        \"PythonCompiledPackage\",\n        \"PythonInternalModule\",\n    ):\n        delayed = node_class.named_children\n\n        if \"code_flags\" in args:\n            args[\"future_spec\"] = fromFlags(args[\"code_flags\"])\n    else:\n        delayed = ()\n\n    for child in xml:\n        assert child.tag == \"role\", child.tag\n\n        child_name = child.attrib[\"name\"]\n\n        # Might want to want until provider is updated with some\n        # children. In these cases, we pass the XML node, rather\n        # than a Nuitka node.\n        if child_name not in delayed:\n            args[child_name] = makeChild(provider, child, source_ref)\n        else:\n            args[child_name] = child\n\n    try:\n        return node_class.fromXML(provider=provider, source_ref=source_ref, **args)\n    except (TypeError, AttributeError):\n        Tracing.printLine(node_class, args, source_ref)\n        raise\n", "#     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com\n#\n#     Part of \"Nuitka\", an optimizing Python compiler that is compatible and\n#     integrates with CPython, but also works on its own.\n#\n#     Licensed under the Apache License, Version 2.0 (the \"License\");\n#     you may not use this file except in compliance with the License.\n#     You may obtain a copy of the License at\n#\n#        http://www.apache.org/licenses/LICENSE-2.0\n#\n#     Unless required by applicable law or agreed to in writing, software\n#     distributed under the License is distributed on an \"AS IS\" BASIS,\n#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#     See the License for the specific language governing permissions and\n#     limitations under the License.\n#\n\"\"\"\nPlugins: Welcome to Nuitka! This is your shortest way to become part of it.\n\nThis is to provide the base class for all plugins. Some of which are part of\nproper Nuitka, and some of which are waiting to be created and submitted for\ninclusion by you.\n\nThe base class will serve as documentation. And it will point to examples of\nit being used.\n\"\"\"\n\nimport ast\nimport inspect\nimport os\nimport sys\nfrom collections import namedtuple\n\nfrom nuitka.__past__ import getMetaClassBase\nfrom nuitka.freezer.IncludedDataFiles import (\n    makeIncludedDataDirectory,\n    makeIncludedDataFile,\n    makeIncludedEmptyDirectories,\n    makeIncludedGeneratedDataFile,\n    makeIncludedPackageDataFiles,\n)\nfrom nuitka.freezer.IncludedEntryPoints import makeDllEntryPoint\nfrom nuitka.ModuleRegistry import getModuleInclusionInfoByName\nfrom nuitka.Options import isStandaloneMode\nfrom nuitka.Tracing import plugins_logger\nfrom nuitka.utils.Execution import NuitkaCalledProcessError, check_output\nfrom nuitka.utils.FileOperations import copyFile, makePath\nfrom nuitka.utils.ModuleNames import ModuleName\nfrom nuitka.utils.SharedLibraries import locateDLL, locateDLLsInDirectory\n\nwarned_unused_plugins = set()\n\n# Trigger names for shared use.\npostload_trigger_name = \"postLoad\"\npreload_trigger_name = \"preLoad\"\n\n\ndef makeTriggerModuleName(module_name, trigger_name):\n    return ModuleName(module_name + \"-\" + trigger_name)\n\n\nclass NuitkaPluginBase(getMetaClassBase(\"Plugin\")):\n    \"\"\"Nuitka base class for all plugins.\n\n    Derive your plugin from \"NuitkaPluginBase\" please.\n    For instructions, see https://github.com/Nuitka/Nuitka/blob/orsiris/UserPlugin-Creation.rst\n\n    Plugins allow to adapt Nuitka's behaviour in a number of ways as explained\n    below at the individual methods.\n\n    It is used to deal with special requirements some packages may have (e.g. PyQt\n    and tkinter), data files to be included (e.g. certifi), inserting hidden\n    code, coping with otherwise undetectable needs, or issuing messages in\n    certain situations.\n\n    A plugin in general must be enabled to be used by Nuitka. This happens by\n    specifying \"--enable-plugin\" (standard plugins) or by \"--user-plugin\" (user\n    plugins) in the Nuitka command line. However, some plugins are always enabled\n    and invisible to the user.\n\n    Nuitka comes with a number of \"standard\" plugins to be enabled as needed.\n    What they are can be displayed using \"nuitka --plugin-list file.py\" (filename\n    required but ignored).\n\n    User plugins may be specified (and implicitly enabled) using their Python\n    script pathname.\n    \"\"\"\n\n    # Standard plugins must provide this as a unique string which Nuitka\n    # then uses to identify them.\n    #\n    # User plugins are identified by their path and implicitly activated.\n    # They however still need to specify some arbitrary non-blank string here,\n    # which does not equal the name of an inactivated standard plugin.\n    # For working with options, user plugins must set this variable to\n    # the script's path (use __file__, __module__ or __name__).\n    plugin_name = None\n\n    @staticmethod\n    def isAlwaysEnabled():\n        \"\"\"Request to be always enabled.\n\n        Notes:\n            Setting this to true is only applicable to standard plugins. In\n            this case, the plugin will be enabled upon Nuitka start-up. Any\n            plugin detector class will then be ignored. Method isRelevant() may\n            also be present and can be used to fine-control enabling the\n            plugin: A to-be-enabled, but irrelevant plugin will still not be\n            activated.\n        Returns:\n            True or False\n        \"\"\"\n        return False\n\n    @classmethod\n    def isRelevant(cls):\n        \"\"\"Consider if the plugin is relevant.\n\n        Notes:\n            A plugin may only be a needed on a certain OS, or with some options,\n            but this is only a class method, so you will not have much run time\n            information.\n\n        Returns:\n            True or False\n\n        \"\"\"\n        return True\n\n    @classmethod\n    def addPluginCommandLineOptions(cls, group):\n        # Call group.add_option() here.\n        pass\n\n    @classmethod\n    def getPluginDefaultOptionValues(cls):\n        \"\"\"This method is used to get a values to use as defaults.\n\n        Since the defaults are in the command line options, we call\n        that and extract them.\n        \"\"\"\n\n        from optparse import OptionGroup, OptionParser\n\n        parser = OptionParser()\n        group = OptionGroup(parser, \"Pseudo Target\")\n        cls.addPluginCommandLineOptions(group)\n\n        result = {}\n        for option in group.option_list:\n            result[option.dest] = option.default\n\n        return result\n\n    def isRequiredImplicitImport(self, module, full_name):\n        \"\"\"Indicate whether an implicitly imported module should be accepted.\n\n        Notes:\n            You may negate importing a module specified as \"implicit import\",\n            although this is an unexpected event.\n\n        Args:\n            module: the module object\n            full_name: of the implicitly import module\n        Returns:\n            True or False\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return True\n\n    def getImplicitImports(self, module):\n        \"\"\"Return the implicit imports for a given module (iterator).\n\n        Args:\n            module: the module object\n        Yields:\n            implicit imports for the module\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def onModuleSourceCode(self, module_name, source_code):\n        \"\"\"Inspect or modify source code.\n\n        Args:\n            module_name: (str) name of module\n            source_code: (str) its source code\n        Returns:\n            source_code (str)\n        Notes:\n            Default implementation forwards to `checkModuleSourceCode` which is\n            going to allow simply checking the source code without the need to\n            pass it back.\n        \"\"\"\n        self.checkModuleSourceCode(module_name, source_code)\n\n        return source_code\n\n    def checkModuleSourceCode(self, module_name, source_code):\n        \"\"\"Inspect source code.\n\n        Args:\n            module_name: (str) name of module\n            source_code: (str) its source code\n        Returns:\n            None\n        \"\"\"\n\n    def onFrozenModuleSourceCode(self, module_name, is_package, source_code):\n        \"\"\"Inspect or modify frozen module source code.\n\n        Args:\n            module_name: (str) full name of module\n            is_package: (bool) True indicates a package\n            source_code: (str) its source code\n        Returns:\n            source_code (str)\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return source_code\n\n    def onFrozenModuleBytecode(self, module_name, is_package, bytecode):\n        \"\"\"Inspect or modify frozen module byte code.\n\n        Args:\n            module_name: (str) name of module\n            is_package: (bool) True indicates a package\n            bytecode: (bytes) byte code\n        Returns:\n            bytecode (bytes)\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return bytecode\n\n    @staticmethod\n    def createPreModuleLoadCode(module):\n        \"\"\"Create code to execute before importing a module.\n\n        Notes:\n            Called by @onModuleDiscovered.\n\n        Args:\n            module: the module object\n        Returns:\n            None (does not apply, default)\n            tuple (code, documentary string)\n            tuple (code, documentary string, flags)\n        \"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return None\n\n    @staticmethod\n    def createPostModuleLoadCode(module):\n        \"\"\"Create code to execute after loading to a module.\n\n        Notes:\n            Called by @onModuleDiscovered.\n\n        Args:\n            module: the module object\n\n        Returns:\n            None (does not apply, default)\n            tuple (code, documentary string)\n            tuple (code, documentary string, flags)\n        \"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return None\n\n    @staticmethod\n    def createFakeModuleDependency(module):\n        \"\"\"Create module to depend on.\n\n        Notes:\n            Called by @onModuleDiscovered.\n\n        Args:\n            module: the module object\n\n        Returns:\n            None (does not apply, default)\n            tuple (code, reason)\n            tuple (code, reason, flags)\n        \"\"\"\n        # Virtual method, pylint: disable=unused-argument\n        return None\n\n    @staticmethod\n    def hasPreModuleLoadCode(module_name):\n        return (\n            getModuleInclusionInfoByName(\n                makeTriggerModuleName(module_name, preload_trigger_name)\n            )\n            is not None\n        )\n\n    @staticmethod\n    def hasPostModuleLoadCode(module_name):\n        return (\n            getModuleInclusionInfoByName(\n                makeTriggerModuleName(module_name, postload_trigger_name)\n            )\n            is not None\n        )\n\n    def onModuleDiscovered(self, module):\n        \"\"\"Called with a module to be loaded.\n\n        Notes:\n            We may specify code to be prepended and/or appended to this module.\n            This code is stored in the appropriate dict.\n            For every imported module and each of these two options, only one plugin may do this.\n            We check this condition here.\n\n        Args:\n            module: the module object\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onModuleEncounter(self, module_name, module_filename, module_kind):\n        \"\"\"Help decide whether to include a module.\n\n        Args:\n            module_name: full module name\n            module_filename: filename\n            module_kind: one of \"py\", \"extension\" (shared library)\n        Returns:\n            True or False\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onModuleRecursion(self, module_name, module_filename, module_kind):\n        \"\"\"React to recursion to a module coming up.\n\n        Args:\n            module_name: full module name\n            module_filename: filename\n            module_kind: one of \"py\", \"extension\" (shared library)\n        Returns:\n            None\n        \"\"\"\n\n    def onModuleInitialSet(self):\n        \"\"\"Provide extra modules to the initial root module set.\n\n        Args:\n            None\n        Returns:\n            Iterable of modules, may yield.\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use\n        return ()\n\n    def onModuleCompleteSet(self, module_set):\n        \"\"\"Provide extra modules to the initial root module set.\n\n        Args:\n            module_set - tuple of module objects\n        Returns:\n            None\n        Notes:\n            You must not change anything, this is purely for warning\n            and error checking, and potentially for later stages to\n            prepare.\n        \"\"\"\n\n    @staticmethod\n    def locateModule(module_name):\n        \"\"\"Provide a filename / -path for a to-be-imported module.\n\n        Args:\n            importing: module object that asked for it (tracing only)\n            module_name: (str or ModuleName) full name of module\n        Returns:\n            filename for module\n        \"\"\"\n\n        from nuitka.importing.Importing import locateModule\n\n        _module_name, module_filename, _finding = locateModule(\n            module_name=ModuleName(module_name), parent_package=None, level=0\n        )\n\n        return module_filename\n\n    @staticmethod\n    def locateModules(module_name):\n        \"\"\"Provide a filename / -path for a to-be-imported module.\n\n        Args:\n            module_name: (str or ModuleName) full name of module\n        Returns:\n            list of ModuleName\n        \"\"\"\n\n        from nuitka.importing.Importing import locateModules\n\n        return locateModules(module_name)\n\n    @classmethod\n    def locateDLL(cls, dll_name):\n        \"\"\"Locate a DLL by name.\"\"\"\n        return locateDLL(dll_name)\n\n    @classmethod\n    def locateDLLsInDirectory(cls, directory):\n        \"\"\"Locate all DLLs in a folder\n\n        Returns:\n            list of (filename, filename_relative, dll_extension)\n        \"\"\"\n        return locateDLLsInDirectory(directory)\n\n    @classmethod\n    def makeDllEntryPoint(cls, source_path, dest_path, package_name):\n        \"\"\"Create an entry point, as expected to be provided by getExtraDlls.\"\"\"\n        return makeDllEntryPoint(\n            source_path=source_path, dest_path=dest_path, package_name=package_name\n        )\n\n    def reportFileCount(self, module_name, count, section=None):\n        if count:\n            msg = \"Found %d %s DLLs from %s%s installation.\" % (\n                count,\n                \"file\" if count < 2 else \"files\",\n                \"\" if not section else (\" '%s' \" % section),\n                module_name.asString(),\n            )\n\n            self.info(msg)\n\n    def considerExtraDlls(self, dist_dir, module):\n        \"\"\"Provide a tuple of names of binaries to be included.\n\n        Args:\n            dist_dir: the distribution folder\n            module: the module object needing the binaries\n        Returns:\n            tuple\n        \"\"\"\n        # TODO: This should no longer be here, as this API is obsolete, pylint: disable=unused-argument\n        for included_entry_point in self.getExtraDlls(module):\n            # Copy to the dist directory, which normally should not be a plugin task, but is for now.\n            makePath(os.path.dirname(included_entry_point.dest_path))\n\n            copyFile(included_entry_point.source_path, included_entry_point.dest_path)\n\n            yield included_entry_point\n\n    def getExtraDlls(self, module):\n        \"\"\"Provide IncludedEntryPoint named tuples describing extra needs of the module.\n\n        Args:\n            module: the module object needing the binaries\n        Returns:\n            yields IncludedEntryPoint objects\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def onCopiedDLL(self, dll_filename):\n        \"\"\"Chance for a plugin to modify DLLs after copy, e.g. to compress it, remove attributes, etc.\n\n        Args:\n            dll_filename: the filename of the DLL\n\n        Notes:\n            Do not remove or add any files in this method, this will not work well, there\n            is e.g. getExtraDLLs API to add things. This is only for post processing as\n            described above.\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def getModuleSpecificDllPaths(self, module_name):\n        \"\"\"Provide a list of directories, where DLLs should be searched for this package (or module).\n\n        Args:\n            module_name: name of a package or module, for which the DLL path addition applies.\n        Returns:\n            iterable of paths\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def removeDllDependencies(self, dll_filename, dll_filenames):\n        \"\"\"Yield any DLLs / shared libraries not to be included in distribution.\n\n        Args:\n            dll_filename: DLL name\n            dll_filenames: list of DLLs\n        Yields:\n            yielded filenames to exclude\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def considerDataFiles(self, module):\n        \"\"\"Yield data file names (source|func, target) for inclusion (iterator).\n\n        Args:\n            module: module object that may need extra data files\n        Yields:\n            Data file description pairs, either (source, dest) or (func, dest)\n            where the func will be called to create the content dynamically.\n\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    def makeIncludedDataFile(self, source_path, dest_path, reason, tags=\"\"):\n        return makeIncludedDataFile(\n            source_path=source_path,\n            dest_path=dest_path,\n            reason=reason,\n            tracer=self,\n            tags=tags,\n        )\n\n    def makeIncludedGeneratedDataFile(self, data, dest_path, reason, tags=\"\"):\n        return makeIncludedGeneratedDataFile(\n            data=data, dest_path=dest_path, reason=reason, tracer=self, tags=tags\n        )\n\n    def makeIncludedDataDirectory(\n        self,\n        source_path,\n        dest_path,\n        reason,\n        tags=\"\",\n        ignore_dirs=(),\n        ignore_filenames=(),\n        ignore_suffixes=(),\n        only_suffixes=(),\n        normalize=True,\n    ):\n        return makeIncludedDataDirectory(\n            source_path=source_path,\n            dest_path=dest_path,\n            reason=reason,\n            tracer=self,\n            tags=tags,\n            ignore_dirs=ignore_dirs,\n            ignore_filenames=ignore_filenames,\n            ignore_suffixes=ignore_suffixes,\n            only_suffixes=only_suffixes,\n            normalize=normalize,\n        )\n\n    def makeIncludedEmptyDirectories(self, source_path, dest_paths, reason, tags):\n        return makeIncludedEmptyDirectories(\n            source_path=source_path,\n            dest_paths=dest_paths,\n            reason=reason,\n            tracer=self,\n            tags=tags,\n        )\n\n    def makeIncludedPackageDataFiles(\n        self, package_name, package_directory, pattern, reason, tags\n    ):\n        return makeIncludedPackageDataFiles(\n            tracer=self,\n            package_name=ModuleName(package_name),\n            package_directory=package_directory,\n            pattern=pattern,\n            reason=reason,\n            tags=tags,\n        )\n\n    def updateDataFileTags(self, included_datafile):\n        \"\"\"Add or remove data file tags.\"\"\"\n\n    def onDataFileTags(self, included_datafile):\n        \"\"\"Action on data file tags.\"\"\"\n\n    def onBeforeCodeParsing(self):\n        \"\"\"Prepare for code parsing, normally not needed.\"\"\"\n\n    def onStandaloneDistributionFinished(self, dist_dir):\n        \"\"\"Called after successfully creating a standalone distribution.\n\n        Note:\n            It is up to the plugin to take subsequent action. Examples are:\n            insert additional information (license, copyright, company or\n            application description), create installation material, further\n            folder clean-up, start downstream applications etc.\n\n        Args:\n            dist_dir: the created distribution folder\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onOnefileFinished(self, filename):\n        \"\"\"Called after successfully creating a onefile executable.\n\n        Note:\n            It is up to the plugin to take subsequent action. Examples are:\n            insert additional information (license, copyright, company or\n            application description), create installation material, further\n            folder clean-up, start downstream applications etc.\n\n        Args:\n            filename: the created onefile executable\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onBootstrapBinary(self, filename):\n        \"\"\"Called after successfully creating a bootstrap binary, but without payload.\n\n        Args:\n            filename: the created bootstrap binary, will be modified later\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def onFinalResult(self, filename):\n        \"\"\"Called after successfully finishing a compilation.\n\n        Note:\n            Plugins normally don't need this, and what filename is will be\n            heavily dependent on compilation modes. Actions can be take here,\n            e.g. commercial plugins output generated keys near that executable\n            path.\n        Args:\n            filename: the created binary (module, accelerated exe, dist exe, onefile exe)\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def suppressUnknownImportWarning(self, importing, module_name, source_ref):\n        \"\"\"Suppress import warnings for unknown modules.\n\n        Args:\n            importing: the module object\n            module_name: name of module\n            source_ref: ???\n        Returns:\n            True or False\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return False\n\n    def decideCompilation(self, module_name):\n        \"\"\"Decide whether to compile a module (or just use its bytecode).\n\n        Notes:\n            The first plugin not returning None makes the decision. Thereafter,\n            no other plugins will be checked. If all plugins return None, the\n            module will be compiled.\n\n        Args:\n            module_name: name of module\n\n        Returns:\n            \"compiled\" or \"bytecode\" or None (no opinion, use by default)\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def getPreprocessorSymbols(self):\n        \"\"\"Decide which C defines to be used in compilation.\n\n        Notes:\n            The plugins can each contribute, but are hopefully using\n            a namespace for their defines.\n\n        Returns:\n            None for no defines, otherwise dictionary of key to be\n            defined, and non-None values if any, i.e. no \"-Dkey\" only\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraIncludeDirectories(self):\n        \"\"\"Decide which extra directories to use for C includes in compilation.\n\n        Returns:\n            List of directories or None by default\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraCodeFiles(self):\n        \"\"\"Add extra code files to the compilation.\n\n        Notes:\n            This is generally a bad idea to use unless you absolutely\n            know what you are doing.\n\n        Returns:\n            None for no extra codes, otherwise dictionary of key to be\n            filename, and value to be source code.\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraLinkLibraries(self):\n        \"\"\"Decide which link library should be added.\n\n        Notes:\n            Names provided multiple times, e.g. by multiple plugins are\n            only added once.\n\n        Returns:\n            None for no extra link library, otherwise the name as a **str**\n            or an iterable of names of link libraries.\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def getExtraLinkDirectories(self):\n        \"\"\"Decide which link directories should be added.\n\n        Notes:\n            Directories provided multiple times, e.g. by multiple plugins are\n            only added once.\n\n        Returns:\n            None for no extra link directory, otherwise the name as a **str**\n            or an iterable of names of link directories.\n        \"\"\"\n\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def warnUnusedPlugin(self, message):\n        \"\"\"An inactive plugin may issue a warning if it believes this may be wrong.\n\n        Returns:\n            None\n        \"\"\"\n        if self.plugin_name not in warned_unused_plugins:\n            warned_unused_plugins.add(self.plugin_name)\n\n            plugins_logger.warning(\n                \"Use '--enable-plugin=%s' for: %s\" % (self.plugin_name, message)\n            )\n\n    def onDataComposerRun(self):\n        \"\"\"Internal use only.\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use\n        return None\n\n    def onDataComposerResult(self, blob_filename):\n        \"\"\"Internal use only.\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def encodeDataComposerName(self, data_name):\n        \"\"\"Internal use only.\n\n        Returns:\n            None\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    _runtime_information_cache = {}\n\n    def queryRuntimeInformationMultiple(self, info_name, setup_codes, values):\n        info_name = self.plugin_name.replace(\"-\", \"_\") + \"_\" + info_name\n\n        if info_name in self._runtime_information_cache:\n            return self._runtime_information_cache[info_name]\n\n        keys = []\n        query_codes = []\n\n        for key, value_expression in values:\n            keys.append(key)\n\n            query_codes.append(\"print(repr(%s))\" % value_expression)\n            query_codes.append('print(\"-\" * 27)')\n\n        if type(setup_codes) is str:\n            setup_codes = setup_codes.split(\"\\n\")\n\n        cmd = r\"\"\"\\\nfrom __future__ import print_function\nfrom __future__ import absolute_import\n\ntry:\n    %(setup_codes)s\nexcept ImportError:\n    import sys\n    sys.exit(38)\n%(query_codes)s\n\"\"\" % {\n            \"setup_codes\": \"\\n   \".join(setup_codes),\n            \"query_codes\": \"\\n\".join(query_codes),\n        }\n\n        try:\n            feedback = check_output([sys.executable, \"-c\", cmd])\n        except NuitkaCalledProcessError as e:\n            if e.returncode == 38:\n                return None\n            raise\n\n        if str is not bytes:  # We want to work with strings, that's hopefully OK.\n            feedback = feedback.decode(\"utf8\")\n\n        # Ignore Windows newlines difference.\n        feedback = [line.strip() for line in feedback.splitlines()]\n\n        if feedback.count(\"-\" * 27) != len(keys):\n            self.sysexit(\n                \"Error, mismatch in output retrieving %r information.\" % info_name\n            )\n\n        feedback = [line for line in feedback if line != \"-\" * 27]\n\n        NamedTupleResult = namedtuple(info_name, keys)\n\n        self._runtime_information_cache[info_name] = NamedTupleResult(\n            *(ast.literal_eval(value) for value in feedback)\n        )\n\n        return self._runtime_information_cache[info_name]\n\n    def queryRuntimeInformationSingle(self, setup_codes, value):\n        return self.queryRuntimeInformationMultiple(\n            info_name=\"temp_info_for_\" + self.plugin_name.replace(\"-\", \"_\"),\n            setup_codes=setup_codes,\n            values=((\"key\", value),),\n        ).key\n\n    def onFunctionBodyParsing(self, module_name, function_name, body):\n        \"\"\"Provide a different function body for the function of that module.\"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return None\n\n    def getCacheContributionValues(self, module_name):\n        \"\"\"Provide values that represent the include of a plugin on the compilation.\n\n        This must be used to invalidate cache results, e.g. when using the\n        onFunctionBodyParsing function, and other things, that do not directly\n        affect the source code.\n        \"\"\"\n        # Virtual method, pylint: disable=no-self-use,unused-argument\n        return ()\n\n    @classmethod\n    def warning(cls, message):\n        plugins_logger.warning(cls.plugin_name + \": \" + message)\n\n    @classmethod\n    def info(cls, message):\n        plugins_logger.info(cls.plugin_name + \": \" + message)\n\n    @classmethod\n    def sysexit(cls, message):\n        plugins_logger.sysexit(cls.plugin_name + \": \" + message)\n\n\nimport functools\n\n\ndef standalone_only(func):\n    \"\"\"For plugins that have functionality that should be done in standalone mode only.\"\"\"\n\n    @functools.wraps(func)\n    def wrapped(*args, **kwargs):\n        if isStandaloneMode():\n            return func(*args, **kwargs)\n        else:\n            if inspect.isgeneratorfunction(func):\n                return ()\n            else:\n                return None\n\n    return wrapped\n"], "filenames": ["nuitka/__main__.py", "nuitka/build/SconsCaching.py", "nuitka/nodes/NodeBases.py", "nuitka/plugins/PluginBase.py"], "buggy_code_start_loc": [27, 21, 27, 28], "buggy_code_end_loc": [118, 388, 1181, 851], "fixing_code_start_loc": [28, 22, 28, 29], "fixing_code_end_loc": [116, 387, 1180, 851], "type": "CWE-77", "message": "Command Injection in GitHub repository nuitka/nuitka prior to 0.9.", "other": {"cve": {"id": "CVE-2022-2054", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-12T14:15:08.527", "lastModified": "2022-06-21T15:21:11.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Command Injection in GitHub repository nuitka/nuitka prior to 0.9."}, {"lang": "es", "value": "Una Inyecci\u00f3n de Comandos en el repositorio de GitHub nuitka/nuitka versiones anteriores a 0.9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nuitka:nuitka:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9", "matchCriteriaId": "8A8F1476-DF3E-4933-8B1D-8F19762C826B"}]}]}], "references": [{"url": "https://github.com/nuitka/nuitka/commit/09647745d7cbb6ff32f9fa948f19d5558b32bcad", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ea4a842c-c48c-4aae-a599-3305125c63a7", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nuitka/nuitka/commit/09647745d7cbb6ff32f9fa948f19d5558b32bcad"}}