{"buggy_code": ["//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's ALU                                                ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  ALU                                                         ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_alu.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Minor update: \n// Defines added, flags are corrected. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_alu(\n\ta, b, mult_mac_result, macrc_op,\n\talu_op, alu_op2, comp_op,\n\tcust5_op, cust5_limm,\n\tresult, flagforw, flag_we,\n\tcyforw, cy_we, carry, flag\n);\n\nparameter width = `OR1200_OPERAND_WIDTH;\n\n//\n// I/O\n//\ninput\t[width-1:0]\t\ta;\ninput\t[width-1:0]\t\tb;\ninput\t[width-1:0]\t\tmult_mac_result;\ninput\t\t\t\tmacrc_op;\ninput\t[`OR1200_ALUOP_WIDTH-1:0]\talu_op;\ninput\t[`OR1200_ALUOP2_WIDTH-1:0]\talu_op2;\ninput\t[`OR1200_COMPOP_WIDTH-1:0]\tcomp_op;\ninput\t[4:0]\t\t\tcust5_op;\ninput\t[5:0]\t\t\tcust5_limm;\noutput\t[width-1:0]\t\tresult;\noutput\t\t\t\tflagforw;\noutput\t\t\t\tflag_we;\noutput\t\t\t\tcyforw;\noutput\t\t\t\tcy_we;\ninput\t\t\t\tcarry;\ninput         flag;\n\n//\n// Internal wires and regs\n//\nreg\t[width-1:0]\t\tresult;\nreg\t[width-1:0]\t\tshifted_rotated;\nreg\t[width-1:0]\t\textended;   \nreg\t[width-1:0]\t\tresult_cust5;\nreg\t\t\t\tflagforw;\nreg\t\t\t\tflagcomp;\nreg\t\t\t\tflag_we;\nreg\t\t\t\tcy_we;\nwire\t[width-1:0]\t\tcomp_a;\nwire\t[width-1:0]\t\tcomp_b;\n`ifdef OR1200_IMPL_ALU_COMP1\nwire\t\t\t\ta_eq_b;\nwire\t\t\t\ta_lt_b;\n`endif\nwire\t[width-1:0]\t\tresult_sum;\n`ifdef OR1200_IMPL_ADDC\nwire\t[width-1:0]\t\tresult_csum;\nwire\t\t\t\tcy_csum;\n`endif\nwire\t[width-1:0]\t\tresult_and;\nwire\t\t\t\tcy_sum;\n`ifdef OR1200_IMPL_SUB\nwire\t\t\t\tcy_sub;\n`endif\nreg\t\t\t\tcyforw;\n\n//\n// Combinatorial logic\n//\nassign comp_a = {a[width-1] ^ comp_op[3] , a[width-2:0]};\nassign comp_b = {b[width-1] ^ comp_op[3] , b[width-2:0]};\n`ifdef OR1200_IMPL_ALU_COMP1\nassign a_eq_b = (comp_a == comp_b);\nassign a_lt_b = (comp_a < comp_b);\n`endif\n`ifdef OR1200_IMPL_SUB\nassign cy_sub = a < b;\n`endif\nassign {cy_sum, result_sum} = a + b;\n`ifdef OR1200_IMPL_ADDC\nassign {cy_csum, result_csum} = a + b + {`OR1200_OPERAND_WIDTH'd0, carry};\n`endif\nassign result_and = a & b;\n\n//\n// Simulation check for bad ALU behavior\n//\n`ifdef OR1200_WARNINGS\n// synopsys translate_off\nalways @(result) begin\n\tif (result === 32'bx)\n\t\t$display(\"%t: WARNING: 32'bx detected on ALU result bus. Please check !\", $time);\nend\n// synopsys translate_on\n`endif\n\n//\n// Central part of the ALU\n//\nalways @(alu_op or alu_op2 or a or b or result_sum or result_and or macrc_op\n\t or shifted_rotated or mult_mac_result or flag or result_cust5 or carry\n`ifdef OR1200_IMPL_ADDC\n         or result_csum\n`endif\n`ifdef OR1200_IMPL_ALU_EXT\n         or extended\n`endif\t \n) begin\n`ifdef OR1200_CASE_DEFAULT\n\tcasez (alu_op)\t\t// synopsys parallel_case\n`else\n\tcasez (alu_op)\t\t// synopsys full_case parallel_case\n`endif\n`ifdef OR1200_IMPL_ALU_FFL1\t  \n\t\t`OR1200_ALUOP_FFL1: begin\n`ifdef OR1200_CASE_DEFAULT\n\t\t   casez (alu_op2) // synopsys parallel_case\n`else\n\t\t   casez (alu_op2) // synopsys full_case parallel_case\n`endif\n\t\t     0: begin // FF1\n\t\t\tresult = a[0] ? 1 : a[1] ? 2 : a[2] ? 3 : a[3] ? 4 : a[4] ? 5 : a[5] ? 6 : a[6] ? 7 : a[7] ? 8 : a[8] ? 9 : a[9] ? 10 : a[10] ? 11 : a[11] ? 12 : a[12] ? 13 : a[13] ? 14 : a[14] ? 15 : a[15] ? 16 : a[16] ? 17 : a[17] ? 18 : a[18] ? 19 : a[19] ? 20 : a[20] ? 21 : a[21] ? 22 : a[22] ? 23 : a[23] ? 24 : a[24] ? 25 : a[25] ? 26 : a[26] ? 27 : a[27] ? 28 : a[28] ? 29 : a[29] ? 30 : a[30] ? 31 : a[31] ? 32 : 0;\n\t\t     end\n\t\t     default: begin // FL1\n\t\t\tresult = a[31] ? 32 : a[30] ? 31 : a[29] ? 30 : a[28] ? 29 : a[27] ? 28 : a[26] ? 27 : a[25] ? 26 : a[24] ? 25 : a[23] ? 24 : a[22] ? 23 : a[21] ? 22 : a[20] ? 21 : a[19] ? 20 : a[18] ? 19 : a[17] ? 18 : a[16] ? 17 : a[15] ? 16 : a[14] ? 15 : a[13] ? 14 : a[12] ? 13 : a[11] ? 12 : a[10] ? 11 : a[9] ? 10 : a[8] ? 9 : a[7] ? 8 : a[6] ? 7 : a[5] ? 6 : a[4] ? 5 : a[3] ? 4 : a[2] ? 3 : a[1] ? 2 : a[0] ? 1 : 0 ;\n\t\t     end\n\t\t   endcase // casez (alu_op2)\n\t\tend // case: `OR1200_ALUOP_FFL1\n`endif //  `ifdef OR1200_IMPL_ALU_FFL1\n`ifdef OR1200_IMPL_ALU_CUST5\n\t  \n\t\t`OR1200_ALUOP_CUST5 : begin \n\t\t\t\tresult = result_cust5;\n\t\tend\n`endif\t\t     \n\t\t`OR1200_ALUOP_SHROT : begin \n\t\t\t\tresult = shifted_rotated;\n\t\tend\n\t\t`OR1200_ALUOP_ADD : begin\n\t\t\t\tresult = result_sum;\n\t\tend\n`ifdef OR1200_IMPL_ADDC\n\t\t`OR1200_ALUOP_ADDC : begin\n\t\t\t\tresult = result_csum;\n\t\tend\n`endif\n`ifdef OR1200_IMPL_SUB\n\t\t`OR1200_ALUOP_SUB : begin\n\t\t\t\tresult = a - b;\n\t\tend\n`endif\n\t\t`OR1200_ALUOP_XOR : begin\n\t\t\t\tresult = a ^ b;\n\t\tend\n\t\t`OR1200_ALUOP_OR  : begin\n\t\t\t\tresult = a | b;\n\t\tend\n`ifdef OR1200_IMPL_ALU_EXT\t\t     \n\t\t`OR1200_ALUOP_EXTHB  : begin\n\t\t                result = extended;\n\t\tend\n\t\t`OR1200_ALUOP_EXTW  : begin\n\t\t                result = extended;\n\t\tend\t\t\n`endif     \n\t\t`OR1200_ALUOP_MOVHI : begin\n\t\t\t\tif (macrc_op) begin\n\t\t\t\t\tresult = mult_mac_result;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tresult = b << 16;\n\t\t\t\tend\n\t\tend\n`ifdef OR1200_MULT_IMPLEMENTED\n`ifdef OR1200_DIV_IMPLEMENTED\n\t\t`OR1200_ALUOP_DIV,\n\t\t`OR1200_ALUOP_DIVU,\n`endif\n\t\t`OR1200_ALUOP_MUL,\n\t\t`OR1200_ALUOP_MULU : begin\n\t\t\t\tresult = mult_mac_result;\n\t\tend\n`endif\n\t\t`OR1200_ALUOP_CMOV: begin\n\t\t\tresult = flag ? a : b;\n\t\tend\n\n`ifdef OR1200_CASE_DEFAULT\n\t\tdefault: begin\n`else\n\t\t`OR1200_ALUOP_COMP, `OR1200_ALUOP_AND: begin\n`endif\n\t\t\tresult=result_and;\n\t\tend \n\tendcase\nend\n\n//\n// Generate flag and flag write enable\n//\nalways @(alu_op or result_sum or result_and or flagcomp\n`ifdef OR1200_IMPL_ADDC\n         or result_csum\n`endif\n) begin\n\tcasez (alu_op)\t\t// synopsys parallel_case\n`ifdef OR1200_ADDITIONAL_FLAG_MODIFIERS\n\t\t`OR1200_ALUOP_ADD : begin\n\t\t\tflagforw = (result_sum == 32'h0000_0000);\n\t\t\tflag_we = 1'b1;\n\t\tend\n`ifdef OR1200_IMPL_ADDC\n\t\t`OR1200_ALUOP_ADDC : begin\n\t\t\tflagforw = (result_csum == 32'h0000_0000);\n\t\t\tflag_we = 1'b1;\n\t\tend\n`endif\n\t\t`OR1200_ALUOP_AND: begin\n\t\t\tflagforw = (result_and == 32'h0000_0000);\n\t\t\tflag_we = 1'b1;\n\t\tend\n`endif\n\t\t`OR1200_ALUOP_COMP: begin\n\t\t\tflagforw = flagcomp;\n\t\t\tflag_we = 1'b1;\n\t\tend\n\t\tdefault: begin\n\t\t\tflagforw = flagcomp;\n\t\t\tflag_we = 1'b0;\n\t\tend\n\tendcase\nend\n\n//\n// Generate SR[CY] write enable\n//\nalways @(alu_op or cy_sum\n`ifdef OR1200_IMPL_CY\n`ifdef OR1200_IMPL_ADDC\n\tor cy_csum\n`endif\n`ifdef OR1200_IMPL_SUB\n\tor cy_sub\n`endif\n`endif\n) begin\n\tcasez (alu_op)\t\t// synopsys parallel_case\n`ifdef OR1200_IMPL_CY\n\t\t`OR1200_ALUOP_ADD : begin\n\t\t\tcyforw = cy_sum;\n\t\t\tcy_we = 1'b1;\n\t\tend\n`ifdef OR1200_IMPL_ADDC\n\t\t`OR1200_ALUOP_ADDC: begin\n\t\t\tcyforw = cy_csum;\n\t\t\tcy_we = 1'b1;\n\t\tend\n`endif\n`ifdef OR1200_IMPL_SUB\n\t\t`OR1200_ALUOP_SUB: begin\n\t\t\tcyforw = cy_sub;\n\t\t\tcy_we = 1'b1;\n\t\tend\n`endif\n`endif\n\t\tdefault: begin\n\t\t\tcyforw = 1'b0;\n\t\t\tcy_we = 1'b0;\n\t\tend\n\tendcase\nend\n\n//\n// Shifts and rotation\n//\nalways @(alu_op2 or a or b) begin\n\tcase (alu_op2)\t\t// synopsys parallel_case\n\t  `OR1200_SHROTOP_SLL :\n\t\t\t\tshifted_rotated = (a << b[4:0]);\n\t  `OR1200_SHROTOP_SRL :\n\t\t\t\tshifted_rotated = (a >> b[4:0]);\n\n`ifdef OR1200_IMPL_ALU_ROTATE\n\t  `OR1200_SHROTOP_ROR :\n\t                        shifted_rotated = (a << (6'd32-{1'b0,b[4:0]})) |\n\t\t\t\t\t\t  (a >> b[4:0]);\n`endif\n\t  default:\n\t                        shifted_rotated = ({32{a[31]}} << \n\t\t\t\t\t\t   (6'd32-{1'b0, b[4:0]})) | \n\t\t\t\t\t\t  a >> b[4:0];\n\tendcase\nend\n\n//\n// First type of compare implementation\n//\n`ifdef OR1200_IMPL_ALU_COMP1\nalways @(comp_op or a_eq_b or a_lt_b) begin\n\tcase(comp_op[2:0])\t// synopsys parallel_case\n\t\t`OR1200_COP_SFEQ:\n\t\t\tflagcomp = a_eq_b;\n\t\t`OR1200_COP_SFNE:\n\t\t\tflagcomp = ~a_eq_b;\n\t\t`OR1200_COP_SFGT:\n\t\t\tflagcomp = ~(a_eq_b | a_lt_b);\n\t\t`OR1200_COP_SFGE:\n\t\t\tflagcomp = ~a_lt_b;\n\t\t`OR1200_COP_SFLT:\n\t\t\tflagcomp = a_lt_b;\n\t\t`OR1200_COP_SFLE:\n\t\t\tflagcomp = a_eq_b | a_lt_b;\n\t\tdefault:\n\t\t\tflagcomp = 1'b0;\n\tendcase\nend\n`endif\n\n//\n// Second type of compare implementation\n//\n`ifdef OR1200_IMPL_ALU_COMP2\nalways @(comp_op or comp_a or comp_b) begin\n\tcase(comp_op[2:0])\t// synopsys parallel_case\n\t\t`OR1200_COP_SFEQ:\n\t\t\tflagcomp = (comp_a == comp_b);\n\t\t`OR1200_COP_SFNE:\n\t\t\tflagcomp = (comp_a != comp_b);\n\t\t`OR1200_COP_SFGT:\n\t\t\tflagcomp = (comp_a > comp_b);\n\t\t`OR1200_COP_SFGE:\n\t\t\tflagcomp = (comp_a >= comp_b);\n\t\t`OR1200_COP_SFLT:\n\t\t\tflagcomp = (comp_a < comp_b);\n\t\t`OR1200_COP_SFLE:\n\t\t\tflagcomp = (comp_a <= comp_b);\n\t\tdefault:\n\t\t\tflagcomp = 1'b0;\n\tendcase\nend\n`endif\n\n`ifdef OR1200_IMPL_ALU_EXT\n   always @(alu_op or alu_op2 or a) begin\n      casez (alu_op2)\n\t`OR1200_EXTHBOP_HS : extended = {{16{a[15]}},a[15:0]};\n\t`OR1200_EXTHBOP_BS : extended = {{24{a[7]}},a[7:0]};\n\t`OR1200_EXTHBOP_HZ : extended = {16'd0,a[15:0]};\n\t`OR1200_EXTHBOP_BZ : extended = {24'd0,a[7:0]};\n\tdefault: extended = a; // Used for l.extw instructions\n      endcase // casez (alu_op2)\n   end\n`endif \n\t     \n\n//\n// l.cust5 custom instructions\n//\n`ifdef OR1200_IMPL_ALU_CUST5\n// Examples for move byte, set bit and clear bit\n//\nalways @(cust5_op or cust5_limm or a or b) begin\n\tcasez (cust5_op)\t\t// synopsys parallel_case\n\t\t5'h1 : begin \n\t\t\tcasez (cust5_limm[1:0])\n\t\t\t  2'h0: result_cust5 = {a[31:8], b[7:0]};\n\t\t\t  2'h1: result_cust5 = {a[31:16], b[7:0], a[7:0]};\n\t\t\t  2'h2: result_cust5 = {a[31:24], b[7:0], a[15:0]};\n\t\t\t  2'h3: result_cust5 = {b[7:0], a[23:0]};\n\t\t\tendcase\n\t\tend\n\t\t5'h2 :\n\t\t\tresult_cust5 = a | (1 << cust5_limm);\n\t\t5'h3 :\n\t\t\tresult_cust5 = a & (32'hffffffff ^ (1 << cust5_limm));\n//\n// *** Put here new l.cust5 custom instructions ***\n//\n\t\tdefault: begin\n\t\t\tresult_cust5 = a;\n\t\tend\n\tendcase\nend // always @ (cust5_op or cust5_limm or a or b)\n`endif   \n\nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's CPU                                                ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  Instantiation of internal CPU blocks. IFETCH, SPRS, FRZ,    ////\n////  ALU, EXCEPT, ID, WBMUX, OPERANDMUX, RF etc.                 ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_cpu.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Major update: \n// Structure reordered and bugs fixed. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_cpu(\n\t// Clk & Rst\n\tclk, rst,\n\n\t// Insn interface\n\tic_en,\n\ticpu_adr_o, icpu_cycstb_o, icpu_sel_o, icpu_tag_o,\n\ticpu_dat_i, icpu_ack_i, icpu_rty_i, icpu_err_i, icpu_adr_i, icpu_tag_i,\n\timmu_en,\n\n\t// Debug unit\n\tid_void, id_insn, ex_void, \n\tex_insn, ex_freeze, wb_insn, wb_freeze, id_pc, ex_pc, wb_pc, branch_op,\n\tspr_dat_npc, rf_dataw, ex_flushpipe, \n\tdu_stall, du_addr, du_dat_du, du_read, du_write, du_except_stop, \n\tdu_except_trig, du_dsr, du_dmr1, du_hwbkpt, du_hwbkpt_ls_r, du_dat_cpu,\n\tdu_lsu_store_dat, du_lsu_load_dat, \n\tabort_mvspr, abort_ex,\n\t\n\t// Data interface\n\tdc_en,\n\tdcpu_adr_o, dcpu_cycstb_o, dcpu_we_o, dcpu_sel_o, dcpu_tag_o, \n        dcpu_dat_o, dcpu_dat_i, dcpu_ack_i, dcpu_rty_i, dcpu_err_i, dcpu_tag_i,\n\tsb_en, dmmu_en, dc_no_writethrough,\n\n\t// SR Interface\n\tboot_adr_sel_i,\n\n\t// Interrupt & tick exceptions\n\tsig_int, sig_tick,\n\n\t// SPR interface\n\tsupv, spr_addr, spr_dat_cpu, spr_dat_pic, spr_dat_tt, spr_dat_pm,\n\tspr_dat_dmmu, spr_dat_immu, spr_dat_du, spr_cs, spr_we, mtspr_dc_done\n);\n\nparameter dw = `OR1200_OPERAND_WIDTH;\nparameter aw = `OR1200_REGFILE_ADDR_WIDTH;\n\n//\n// I/O ports\n//\n\n//\n// Clk & Rst\n//\ninput \t\t\t\tclk;\ninput \t\t\t\trst;\n\n//\n// Insn (IC) interface\n//\noutput\t\t\t\tic_en;\noutput\t[31:0]\t\t\ticpu_adr_o;\noutput\t\t\t\ticpu_cycstb_o;\noutput\t[3:0]\t\t\ticpu_sel_o;\noutput\t[3:0]\t\t\ticpu_tag_o;\ninput\t[31:0]\t\t\ticpu_dat_i;\ninput\t\t\t\ticpu_ack_i;\ninput\t\t\t\ticpu_rty_i;\ninput\t\t\t\ticpu_err_i;\ninput\t[31:0]\t\t\ticpu_adr_i;\ninput\t[3:0]\t\t\ticpu_tag_i;\n\n//\n// Insn (IMMU) interface\n//\noutput\t\t\t\timmu_en;\n\n//\n// Debug interface\n//\noutput                          id_void;\noutput\t[31:0]\t\t\tid_insn;\noutput                          ex_void;\noutput\t[31:0]\t\t\tex_insn;\noutput\t\t\t\tex_freeze;\noutput\t[31:0]\t\t\twb_insn;\noutput\t\t\t\twb_freeze;\noutput\t[31:0]\t\t\tid_pc;\noutput\t[31:0]\t\t\tex_pc;\noutput\t[31:0]\t\t\twb_pc;\noutput                          ex_flushpipe;\noutput\t[`OR1200_BRANCHOP_WIDTH-1:0]\tbranch_op;\n\ninput\t\t\t\tdu_stall;\ninput\t[dw-1:0]\t\tdu_addr;\ninput\t[dw-1:0]\t\tdu_dat_du;\ninput\t\t\t\tdu_read;\ninput\t\t\t\tdu_write;\ninput\t[`OR1200_DU_DSR_WIDTH-1:0]\tdu_dsr;\ninput\t[24:0]\t\t\tdu_dmr1;\ninput\t\t\t\tdu_hwbkpt;\ninput\t\t\t\tdu_hwbkpt_ls_r;\noutput\t[13:0]\t\t\tdu_except_trig;\noutput\t[13:0]\t\t\tdu_except_stop;\noutput\t[dw-1:0]\t\tdu_dat_cpu;\noutput\t[dw-1:0]\t\trf_dataw;\noutput\t[dw-1:0]\t\tdu_lsu_store_dat;\noutput\t[dw-1:0]\t\tdu_lsu_load_dat;\n\n//\n// Data (DC) interface\n//\noutput\t[31:0]\t\t\tdcpu_adr_o;\noutput\t\t\t\tdcpu_cycstb_o;\noutput\t\t\t\tdcpu_we_o;\noutput\t[3:0]\t\t\tdcpu_sel_o;\noutput\t[3:0]\t\t\tdcpu_tag_o;\noutput\t[31:0]\t\t\tdcpu_dat_o;\ninput\t[31:0]\t\t\tdcpu_dat_i;\ninput\t\t\t\tdcpu_ack_i;\ninput\t\t\t\tdcpu_rty_i;\ninput\t\t\t\tdcpu_err_i;\ninput\t[3:0]\t\t\tdcpu_tag_i;\noutput\t\t\t\tdc_en;\noutput  \t\t\tdc_no_writethrough;\n   \n//\n// Data (DMMU) interface\n//\noutput\t\t\t\tsb_en;\noutput\t\t\t\tdmmu_en;\noutput\t\t\t\tabort_ex;\noutput\t\t\t\tabort_mvspr;\n\n//\n// SR Interface \n//\ninput\t\t\t\tboot_adr_sel_i;\n\n//\n// SPR interface\n//\noutput\t\t\t\tsupv;\ninput\t[dw-1:0]\t\tspr_dat_pic;\ninput\t[dw-1:0]\t\tspr_dat_tt;\ninput\t[dw-1:0]\t\tspr_dat_pm;\ninput\t[dw-1:0]\t\tspr_dat_dmmu;\ninput\t[dw-1:0]\t\tspr_dat_immu;\ninput\t[dw-1:0]\t\tspr_dat_du;\noutput\t[dw-1:0]\t\tspr_addr;\noutput\t[dw-1:0]\t\tspr_dat_cpu;\noutput\t[dw-1:0]\t\tspr_dat_npc;\noutput\t[31:0]\t\t\tspr_cs;\noutput\t\t\t\tspr_we;\ninput   \t\t\tmtspr_dc_done;\n   \n//\n// Interrupt exceptions\n//\ninput\t\t\t\tsig_int;\ninput\t\t\t\tsig_tick;\n\n//\n// Internal wires\n//\nwire\t[31:0]\t\t\tif_insn;\nwire\t\t\t\tsaving_if_insn;\nwire\t[31:0]\t\t\tif_pc;\nwire\t[aw-1:0]\t\trf_addrw;\nwire\t[aw-1:0] \t\trf_addra;\nwire\t[aw-1:0] \t\trf_addrb;\nwire\t\t\t\trf_rda;\nwire\t\t\t\trf_rdb;\nwire\t[dw-1:0]\t\tid_simm;\nwire\t[dw-1:2]\t\tid_branch_addrtarget;\nwire\t[dw-1:2]\t\tex_branch_addrtarget;\nwire\t[`OR1200_ALUOP_WIDTH-1:0]\talu_op;\nwire\t[`OR1200_ALUOP2_WIDTH-1:0]\talu_op2;\nwire\t[`OR1200_COMPOP_WIDTH-1:0]\tcomp_op;\nwire\t[`OR1200_BRANCHOP_WIDTH-1:0]\tpre_branch_op;\nwire\t[`OR1200_BRANCHOP_WIDTH-1:0]\tbranch_op;\nwire\t[`OR1200_LSUOP_WIDTH-1:0]\tid_lsu_op;\nwire\t\t\t\tgenpc_freeze;\nwire\t\t\t\tif_freeze;\nwire\t\t\t\tid_freeze;\nwire\t\t\t\tex_freeze;\nwire\t\t\t\twb_freeze;\nwire\t[`OR1200_SEL_WIDTH-1:0]\tsel_a;\nwire\t[`OR1200_SEL_WIDTH-1:0]\tsel_b;\nwire\t[`OR1200_RFWBOP_WIDTH-1:0]\trfwb_op;\nwire    [`OR1200_FPUOP_WIDTH-1:0]       fpu_op;\nwire\t[dw-1:0]\t\trf_dataw;\nwire\t[dw-1:0]\t\trf_dataa;\nwire\t[dw-1:0]\t\trf_datab;\nwire\t[dw-1:0]\t\tmuxed_a;\nwire\t[dw-1:0]\t\tmuxed_b;\nwire\t[dw-1:0]\t\twb_forw;\nwire\t\t\t\twbforw_valid;\nwire\t[dw-1:0]\t\toperand_a;\nwire\t[dw-1:0]\t\toperand_b;\nwire\t[dw-1:0]\t\talu_dataout;\nwire\t[dw-1:0]\t\tlsu_dataout;\nwire\t[dw-1:0]\t\tsprs_dataout;\nwire\t[dw-1:0]\t\tfpu_dataout;\nwire     \t\t\tfpu_done;\nwire\t[31:0]\t\t\tex_simm;\nwire\t[`OR1200_MULTICYCLE_WIDTH-1:0]\tmulticycle;\nwire    [`OR1200_WAIT_ON_WIDTH-1:0]\twait_on;      \nwire\t[`OR1200_EXCEPT_WIDTH-1:0]\texcept_type;\nwire\t[4:0]\t\t\tcust5_op;\nwire\t[5:0]\t\t\tcust5_limm;\nwire\t\t\t\tif_flushpipe;\nwire\t\t\t\tid_flushpipe;\nwire\t\t\t\tex_flushpipe;\nwire\t\t\t\twb_flushpipe;\nwire\t\t\t\textend_flush;\nwire\t\t\t\tex_branch_taken;\nwire\t\t\t\tflag;\nwire\t\t\t\tflagforw;\nwire\t\t\t\tflag_we;\nwire\t\t\t\tflagforw_alu;   \nwire\t\t\t\tflag_we_alu;\nwire\t\t\t\tflagforw_fpu;\nwire\t\t\t\tflag_we_fpu;\nwire\t\t\t\tcarry;\nwire\t\t\t\tcyforw;\nwire\t\t\t\tcy_we_alu;\nwire\t\t\t\tcy_we_rf;\nwire\t\t\t\tlsu_stall;\nwire\t\t\t\tepcr_we;\nwire\t\t\t\teear_we;\nwire\t\t\t\tesr_we;\nwire\t\t\t\tpc_we;\nwire\t[31:0]\t\t\tepcr;\nwire\t[31:0]\t\t\teear;\nwire\t[`OR1200_SR_WIDTH-1:0]\tesr;\nwire \t[`OR1200_FPCSR_WIDTH-1:0]       fpcsr;\nwire \t\t\t\tfpcsr_we;   \nwire\t\t\t\tsr_we;\nwire\t[`OR1200_SR_WIDTH-1:0]\tto_sr;\nwire\t[`OR1200_SR_WIDTH-1:0]\tsr;\nwire\t\t\t\texcept_flushpipe;\nwire\t\t\t\texcept_start;\nwire\t\t\t\texcept_started;\nwire    \t\t\tfpu_except_started;   \nwire\t[31:0]\t\t\twb_insn;\nwire\t\t\t\tsig_syscall;\nwire\t\t\t\tsig_trap;\nwire\t\t\t\tsig_fp;\nwire\t[31:0]\t\t\tspr_dat_cfgr;\nwire\t[31:0]\t\t\tspr_dat_rf;\nwire    [31:0]                  spr_dat_npc;\nwire\t[31:0]\t\t\tspr_dat_ppc;\nwire\t[31:0]\t\t\tspr_dat_mac;\nwire [31:0] \t\t\tspr_dat_fpu;\nwire     \t\t\tmtspr_done;\nwire\t\t\t\tforce_dslot_fetch;\nwire\t\t\t\tno_more_dslot;\nwire\t\t\t\tex_void;\nwire\t\t\t\tex_spr_read;\nwire\t\t\t\tex_spr_write;\nwire\t\t\t\tif_stall;\nwire\t\t\t\tid_macrc_op;\nwire\t\t\t\tex_macrc_op;\nwire\t[`OR1200_MACOP_WIDTH-1:0] id_mac_op;\nwire\t[`OR1200_MACOP_WIDTH-1:0] mac_op;\nwire\t[31:0]\t\t\tmult_mac_result;\nwire\t\t\t\tmult_mac_stall;\nwire\t[13:0]\t\t\texcept_trig;\nwire\t[13:0]\t\t\texcept_stop;\nwire\t\t\t\tgenpc_refetch;\nwire\t\t\t\trfe;\nwire\t\t\t\tlsu_unstall;\nwire\t\t\t\texcept_align;\nwire\t\t\t\texcept_dtlbmiss;\nwire\t\t\t\texcept_dmmufault;\nwire\t\t\t\texcept_illegal;\nwire\t\t\t\texcept_itlbmiss;\nwire\t\t\t\texcept_immufault;\nwire\t\t\t\texcept_ibuserr;\nwire\t\t\t\texcept_dbuserr;\nwire\t\t\t\tabort_ex;\nwire\t\t\t\tabort_mvspr;\n\n//\n// Send exceptions to Debug Unit\n//\nassign du_except_trig = except_trig;\nassign du_except_stop = except_stop;\nassign du_lsu_store_dat = operand_b;\nassign du_lsu_load_dat  = lsu_dataout;\n\n//\n// Data cache enable\n//\n`ifdef OR1200_NO_DC\nassign dc_en = 1'b0;\n`else\n   assign dc_en = sr[`OR1200_SR_DCE];\n`endif\n\n//\n// Instruction cache enable\n//\n`ifdef OR1200_NO_IC\nassign ic_en = 1'b0;\n`else\nassign ic_en = sr[`OR1200_SR_ICE];\n`endif\n\n//\n// SB enable\n//\n`ifdef OR1200_SB_IMPLEMENTED\n//assign sb_en = sr[`OR1200_SR_SBE]; // SBE not defined  -- jb\n`else\nassign sb_en = 1'b0;\n`endif\n\n//\n// DMMU enable\n//\n`ifdef OR1200_NO_DMMU\nassign dmmu_en = 1'b0;\n`else\nassign dmmu_en = sr[`OR1200_SR_DME];\n`endif\n\n//\n// IMMU enable\n//\n`ifdef OR1200_NO_IMMU\nassign immu_en = 1'b0;\n`else\nassign immu_en = sr[`OR1200_SR_IME] & ~except_started;\n`endif\n\n//\n// SUPV bit\n//\nassign supv = sr[`OR1200_SR_SM];\n\n//\n// FLAG write enable\n//\nassign flagforw = (flag_we_alu & flagforw_alu) | (flagforw_fpu & flag_we_fpu);\nassign flag_we = (flag_we_alu | flag_we_fpu) & ~abort_mvspr;\n\n//\n//  Flag for any MTSPR instructions, that must block execution, to indicate done\n//\nassign mtspr_done = mtspr_dc_done;\n   \n   \n//\n// Instantiation of instruction fetch block\n//\nor1200_genpc or1200_genpc(\n\t.clk(clk),\n\t.rst(rst),\n\t.icpu_adr_o(icpu_adr_o),\n\t.icpu_cycstb_o(icpu_cycstb_o),\n\t.icpu_sel_o(icpu_sel_o),\n\t.icpu_tag_o(icpu_tag_o),\n\t.icpu_rty_i(icpu_rty_i),\n\t.icpu_adr_i(icpu_adr_i),\n\n\t.pre_branch_op(pre_branch_op),\n\t.branch_op(branch_op),\n\t.except_type(except_type),\n\t.except_start(except_start),\n\t.except_prefix(sr[`OR1200_SR_EPH]),\n\t.id_branch_addrtarget(id_branch_addrtarget),\n\t.ex_branch_addrtarget(ex_branch_addrtarget),\n\t.muxed_b(muxed_b),\n\t.operand_b(operand_b),\n\t.flag(flag),\n\t.flagforw(flagforw),\n\t.ex_branch_taken(ex_branch_taken),\n\t.epcr(epcr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_pc_we(pc_we),\n\t.genpc_refetch(genpc_refetch),\n\t.genpc_freeze(genpc_freeze),\n\t.no_more_dslot(no_more_dslot)\n);\n\n//\n// Instantiation of instruction fetch block\n//\nor1200_if or1200_if(\n\t.clk(clk),\n\t.rst(rst),\n\t.icpu_dat_i(icpu_dat_i),\n\t.icpu_ack_i(icpu_ack_i),\n\t.icpu_err_i(icpu_err_i),\n\t.icpu_adr_i(icpu_adr_i),\n\t.icpu_tag_i(icpu_tag_i),\n\n\t.if_freeze(if_freeze),\n\t.if_insn(if_insn),\n\t.if_pc(if_pc),\n\t.saving_if_insn(saving_if_insn),\n\t.if_flushpipe(if_flushpipe),\n\t.if_stall(if_stall),\n\t.no_more_dslot(no_more_dslot),\n\t.genpc_refetch(genpc_refetch),\n\t.rfe(rfe),\n\t.except_itlbmiss(except_itlbmiss),\n\t.except_immufault(except_immufault),\n\t.except_ibuserr(except_ibuserr)\n);\n\n//\n// Instantiation of instruction decode/control logic\n//\nor1200_ctrl or1200_ctrl(\n\t.clk(clk),\n\t.rst(rst),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.wb_freeze(wb_freeze),\n\t.if_flushpipe(if_flushpipe),\n\t.id_flushpipe(id_flushpipe),\n\t.ex_flushpipe(ex_flushpipe),\n\t.wb_flushpipe(wb_flushpipe),\n\t.extend_flush(extend_flush),\n\t.except_flushpipe(except_flushpipe),\n\t.abort_mvspr(abort_mvspr),\n\t.if_insn(if_insn),\n\t.id_insn(id_insn),\n\t.ex_insn(ex_insn),\n\t.id_branch_op(pre_branch_op),\n\t.ex_branch_op(branch_op),\n\t.ex_branch_taken(ex_branch_taken),\n\t.rf_addra(rf_addra),\n\t.rf_addrb(rf_addrb),\n\t.rf_rda(rf_rda),\n\t.rf_rdb(rf_rdb),\n\t.alu_op(alu_op),\n\t.alu_op2(alu_op2),\t\t\t\n\t.mac_op(mac_op),\n\t.comp_op(comp_op),\n\t.rf_addrw(rf_addrw),\n\t.rfwb_op(rfwb_op),\n\t.fpu_op(fpu_op),\t\t\t\n\t.pc_we(pc_we),\n\t.wb_insn(wb_insn),\n\t.id_simm(id_simm),\n\t.id_branch_addrtarget(id_branch_addrtarget),\n\t.ex_branch_addrtarget(ex_branch_addrtarget),\n\t.ex_simm(ex_simm),\n\t.sel_a(sel_a),\n\t.sel_b(sel_b),\n\t.id_lsu_op(id_lsu_op),\n\t.cust5_op(cust5_op),\n\t.cust5_limm(cust5_limm),\n\t.id_pc(id_pc),\n\t.ex_pc(ex_pc),\n\t.multicycle(multicycle),\n        .wait_on(wait_on),\t\t\t\n\t.wbforw_valid(wbforw_valid),\n\t.sig_syscall(sig_syscall),\n\t.sig_trap(sig_trap),\n\t.force_dslot_fetch(force_dslot_fetch),\n\t.no_more_dslot(no_more_dslot),\n\t.id_void(id_void),\n\t.ex_void(ex_void),\n\t.ex_spr_read(ex_spr_read),\n\t.ex_spr_write(ex_spr_write),\n\t.id_mac_op(id_mac_op),\n\t.id_macrc_op(id_macrc_op),\n\t.ex_macrc_op(ex_macrc_op),\n\t.rfe(rfe),\n\t.du_hwbkpt(du_hwbkpt),\n\t.except_illegal(except_illegal),\n\t.dc_no_writethrough(dc_no_writethrough)\n);\n\n//\n// Instantiation of register file\n//\nor1200_rf or1200_rf(\n\t.clk(clk),\n\t.rst(rst),\n\t.cy_we_i(cy_we_alu),\n\t.cy_we_o(cy_we_rf),\n\t.supv(sr[`OR1200_SR_SM]),\n\t.wb_freeze(wb_freeze),\n\t.addrw(rf_addrw),\n\t.dataw(rf_dataw),\n\t.id_freeze(id_freeze),\n\t.we(rfwb_op[0]),\n\t.flushpipe(wb_flushpipe),\n\t.addra(rf_addra),\n\t.rda(rf_rda),\n\t.dataa(rf_dataa),\n\t.addrb(rf_addrb),\n\t.rdb(rf_rdb),\n\t.datab(rf_datab),\n\t.spr_cs(spr_cs[`OR1200_SPR_GROUP_SYS]),\n\t.spr_write(spr_we),\n\t.spr_addr(spr_addr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_dat_o(spr_dat_rf),\n\t.du_read(du_read)\n);\n\n//\n// Instantiation of operand muxes\n//\nor1200_operandmuxes or1200_operandmuxes(\n\t.clk(clk),\n\t.rst(rst),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.rf_dataa(rf_dataa),\n\t.rf_datab(rf_datab),\n\t.ex_forw(rf_dataw),\n\t.wb_forw(wb_forw),\n\t.simm(id_simm),\n\t.sel_a(sel_a),\n\t.sel_b(sel_b),\n\t.operand_a(operand_a),\n\t.operand_b(operand_b),\n\t.muxed_a(muxed_a),\n\t.muxed_b(muxed_b)\n);\n\n//\n// Instantiation of CPU's ALU\n//\nor1200_alu or1200_alu(\n\t.a(operand_a),\n\t.b(operand_b),\n\t.mult_mac_result(mult_mac_result),\n\t.macrc_op(ex_macrc_op),\n\t.alu_op(alu_op),\n\t.alu_op2(alu_op2),\t\t      \n\t.comp_op(comp_op),\n\t.cust5_op(cust5_op),\n\t.cust5_limm(cust5_limm),\n\t.result(alu_dataout),\n\t.flagforw(flagforw_alu),\n\t.flag_we(flag_we_alu),\n\t.cyforw(cyforw),\n\t.cy_we(cy_we_alu),\n\t.flag(flag),\n\t.carry(carry)\n);\n\n   \n//\n// FPU's exception is being dealt with\n//    \nassign fpu_except_started = except_started && (except_type == `OR1200_EXCEPT_FLOAT);\n   \n//\n// Instantiation of FPU\n//\nor1200_fpu or1200_fpu(\n\t.clk(clk),\n\t.rst(rst),\n\t.ex_freeze(ex_freeze),\n\t.a(operand_a),\n\t.b(operand_b),\n\t.fpu_op(fpu_op),\n\t.result(fpu_dataout),\n\t.done(fpu_done),\n\t.flagforw(flagforw_fpu),\n\t.flag_we(flag_we_fpu),\n        .sig_fp(sig_fp),\n\t.except_started(fpu_except_started),\n\t.fpcsr_we(fpcsr_we),\n\t.fpcsr(fpcsr),\t\t      \n\t.spr_cs(spr_cs[`OR1200_SPR_GROUP_FPU]),\n\t.spr_write(spr_we),\n\t.spr_addr(spr_addr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_dat_o(spr_dat_fpu)\n);\n\n   \n//\n// Instantiation of CPU's multiply unit\n//\nor1200_mult_mac or1200_mult_mac(\n\t.clk(clk),\n\t.rst(rst),\n\t.ex_freeze(ex_freeze),\n\t.id_macrc_op(id_macrc_op),\n\t.macrc_op(ex_macrc_op),\n\t.a(operand_a),\n\t.b(operand_b),\n\t.mac_op(mac_op),\n\t.alu_op(alu_op),\n\t.result(mult_mac_result),\n\t.mult_mac_stall(mult_mac_stall),\n\t.spr_cs(spr_cs[`OR1200_SPR_GROUP_MAC]),\n\t.spr_write(spr_we),\n\t.spr_addr(spr_addr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_dat_o(spr_dat_mac)\n);\n\n//\n// Instantiation of CPU's SPRS block\n//\nor1200_sprs or1200_sprs(\n\t.clk(clk),\n\t.rst(rst),\n\t.addrbase(operand_a),\n\t.addrofs(ex_simm[15:0]),\n\t.dat_i(operand_b),\n\t.ex_spr_read(ex_spr_read),\n\t.ex_spr_write(ex_spr_write),\n\t.flagforw(flagforw),\n\t.flag_we(flag_we),\n\t.flag(flag),\n\t.cyforw(cyforw),\n\t.cy_we(cy_we_rf),\n\t.carry(carry),\n\t.to_wbmux(sprs_dataout),\n\n\t.du_addr(du_addr),\n\t.du_dat_du(du_dat_du),\n\t.du_read(du_read),\n\t.du_write(du_write),\n\t.du_dat_cpu(du_dat_cpu),\n\t.boot_adr_sel_i(boot_adr_sel_i),\n\t.spr_addr(spr_addr),\n\t.spr_dat_pic(spr_dat_pic),\n\t.spr_dat_tt(spr_dat_tt),\n\t.spr_dat_pm(spr_dat_pm),\n\t.spr_dat_cfgr(spr_dat_cfgr),\n\t.spr_dat_rf(spr_dat_rf),\n\t.spr_dat_npc(spr_dat_npc),\n        .spr_dat_ppc(spr_dat_ppc),\n\t.spr_dat_mac(spr_dat_mac),\n\t.spr_dat_dmmu(spr_dat_dmmu),\n\t.spr_dat_immu(spr_dat_immu),\n\t.spr_dat_du(spr_dat_du),\n\t.spr_dat_o(spr_dat_cpu),\n\t.spr_cs(spr_cs),\n\t.spr_we(spr_we),\n\n\t.epcr_we(epcr_we),\n\t.eear_we(eear_we),\n\t.esr_we(esr_we),\n\t.pc_we(pc_we),\n\t.epcr(epcr),\n\t.eear(eear),\n\t.esr(esr),\n\t.except_started(except_started),\n\n\t.fpcsr(fpcsr),\n\t.fpcsr_we(fpcsr_we),\t\t\t\n\t.spr_dat_fpu(spr_dat_fpu),\n\t\t\t\n\t.sr_we(sr_we),\n\t.to_sr(to_sr),\n\t.sr(sr),\n\t.branch_op(branch_op)\n);\n\n//\n// Instantiation of load/store unit\n//\nor1200_lsu or1200_lsu(\n\t.clk(clk),\n\t.rst(rst),\n\t.id_addrbase(muxed_a),\n\t.id_addrofs(id_simm),\n\t.ex_addrbase(operand_a),\n\t.ex_addrofs(ex_simm),\n\t.id_lsu_op(id_lsu_op),\n\t.lsu_datain(operand_b),\n\t.lsu_dataout(lsu_dataout),\n\t.lsu_stall(lsu_stall),\n\t.lsu_unstall(lsu_unstall),\n\t.du_stall(du_stall),\n\t.except_align(except_align),\n\t.except_dtlbmiss(except_dtlbmiss),\n\t.except_dmmufault(except_dmmufault),\n\t.except_dbuserr(except_dbuserr),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.flushpipe(ex_flushpipe),\n\n\t.dcpu_adr_o(dcpu_adr_o),\n\t.dcpu_cycstb_o(dcpu_cycstb_o),\n\t.dcpu_we_o(dcpu_we_o),\n\t.dcpu_sel_o(dcpu_sel_o),\n\t.dcpu_tag_o(dcpu_tag_o),\n\t.dcpu_dat_o(dcpu_dat_o),\n\t.dcpu_dat_i(dcpu_dat_i),\n\t.dcpu_ack_i(dcpu_ack_i),\n\t.dcpu_rty_i(dcpu_rty_i),\n\t.dcpu_err_i(dcpu_err_i),\n\t.dcpu_tag_i(dcpu_tag_i)\n);\n\n//\n// Instantiation of write-back muxes\n//\nor1200_wbmux or1200_wbmux(\n\t.clk(clk),\n\t.rst(rst),\n\t.wb_freeze(wb_freeze),\n\t.rfwb_op(rfwb_op),\n\t.muxin_a(alu_dataout),\n\t.muxin_b(lsu_dataout),\n\t.muxin_c(sprs_dataout),\n\t.muxin_d(ex_pc),\n        .muxin_e(fpu_dataout),\n\t.muxout(rf_dataw),\n\t.muxreg(wb_forw),\n\t.muxreg_valid(wbforw_valid)\n);\n\n//\n// Instantiation of freeze logic\n//\nor1200_freeze or1200_freeze(\n\t.clk(clk),\n\t.rst(rst),\n\t.multicycle(multicycle),\n        .wait_on(wait_on),\n\t.fpu_done(fpu_done),\n\t.mtspr_done(mtspr_done),\n\t.flushpipe(wb_flushpipe),\n\t.extend_flush(extend_flush),\n\t.lsu_stall(lsu_stall),\n\t.if_stall(if_stall),\n\t.lsu_unstall(lsu_unstall),\n\t.force_dslot_fetch(force_dslot_fetch),\n\t.abort_ex(abort_ex),\n\t.du_stall(du_stall),\n\t.mac_stall(mult_mac_stall),\n\t.saving_if_insn(saving_if_insn),\n\t.genpc_freeze(genpc_freeze),\n\t.if_freeze(if_freeze),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.wb_freeze(wb_freeze),\n\t.icpu_ack_i(icpu_ack_i),\n\t.icpu_err_i(icpu_err_i)\n);\n\n//\n// Instantiation of exception block\n//\nor1200_except or1200_except(\n\t.clk(clk),\n\t.rst(rst),\n\t.sig_ibuserr(except_ibuserr),\n\t.sig_dbuserr(except_dbuserr),\n\t.sig_illegal(except_illegal),\n\t.sig_align(except_align),\n\t.sig_range(1'b0),\n\t.sig_dtlbmiss(except_dtlbmiss),\n\t.sig_dmmufault(except_dmmufault),\n\t.sig_int(sig_int),\n\t.sig_syscall(sig_syscall),\n\t.sig_trap(sig_trap),\n\t.sig_itlbmiss(except_itlbmiss),\n\t.sig_immufault(except_immufault),\n\t.sig_tick(sig_tick),\n\t.sig_fp(sig_fp),\n\t.fpcsr_fpee(fpcsr[`OR1200_FPCSR_FPEE]),\n\t.ex_branch_taken(ex_branch_taken),\n\t.icpu_ack_i(icpu_ack_i),\n\t.icpu_err_i(icpu_err_i),\n\t.dcpu_ack_i(dcpu_ack_i),\n\t.dcpu_err_i(dcpu_err_i),\n\t.genpc_freeze(genpc_freeze),\n        .id_freeze(id_freeze),\n        .ex_freeze(ex_freeze),\n        .wb_freeze(wb_freeze),\n\t.if_stall(if_stall),\n\t.if_pc(if_pc),\n\t.id_pc(id_pc),\n\t.ex_pc(ex_pc),\n\t.wb_pc(wb_pc),\n\t.id_flushpipe(id_flushpipe),\n\t.ex_flushpipe(ex_flushpipe),\n\t.extend_flush(extend_flush),\n\t.except_flushpipe(except_flushpipe),\n\t.abort_mvspr(abort_mvspr),\n\t.except_type(except_type),\n\t.except_start(except_start),\n\t.except_started(except_started),\n\t.except_stop(except_stop),\n\t.except_trig(except_trig),\n\t.ex_void(ex_void),\n\t.spr_dat_ppc(spr_dat_ppc),\n\t.spr_dat_npc(spr_dat_npc),\n\n\t.datain(spr_dat_cpu),\n\t.branch_op(branch_op),\n\t.du_dsr(du_dsr),\n\t.du_dmr1(du_dmr1),\n\t.du_hwbkpt(du_hwbkpt),\n\t.du_hwbkpt_ls_r(du_hwbkpt_ls_r),\n\t.epcr_we(epcr_we),\n\t.eear_we(eear_we),\n\t.esr_we(esr_we),\n\t.pc_we(pc_we),\n        .epcr(epcr),\n\t.eear(eear),\n\t.esr(esr),\n\n\t.lsu_addr(dcpu_adr_o),\n\t.sr_we(sr_we),\n\t.to_sr(to_sr),\n\t.sr(sr),\n\t.abort_ex(abort_ex)\n);\n\n//\n// Instantiation of configuration registers\n//\nor1200_cfgr or1200_cfgr(\n\t.spr_addr(spr_addr),\n\t.spr_dat_o(spr_dat_cfgr)\n);\n\nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's definitions                                        ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://opencores.org/project,or1k                           ////\n////                                                              ////\n////  Description                                                 ////\n////  Defines for the OR1200 core                                 ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - add parameters that are missing                          ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_defines.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Minor update: \n// Defines added, bugs fixed. \n\n//\n// Dump VCD\n//\n//`define OR1200_VCD_DUMP\n\n//\n// Generate debug messages during simulation\n//\n//`define OR1200_VERBOSE\n\n//  `define OR1200_ASIC\n////////////////////////////////////////////////////////\n//\n// Typical configuration for an ASIC\n//\n`ifdef OR1200_ASIC\n\n//\n// Target ASIC memories\n//\n//`define OR1200_ARTISAN_SSP\n//`define OR1200_ARTISAN_SDP\n//`define OR1200_ARTISAN_STP\n`define OR1200_VIRTUALSILICON_SSP\n//`define OR1200_VIRTUALSILICON_STP_T1\n//`define OR1200_VIRTUALSILICON_STP_T2\n\n//\n// Do not implement Data cache\n//\n//`define OR1200_NO_DC\n\n//\n// Do not implement Insn cache\n//\n//`define OR1200_NO_IC\n\n//\n// Do not implement Data MMU\n//\n//`define OR1200_NO_DMMU\n\n//\n// Do not implement Insn MMU\n//\n//`define OR1200_NO_IMMU\n\n//\n// Select between ASIC optimized and generic multiplier\n//\n//`define OR1200_ASIC_MULTP2_32X32\n`define OR1200_GENERIC_MULTP2_32X32\n\n//\n// Size/type of insn/data cache if implemented\n//\n// `define OR1200_IC_1W_512B\n// `define OR1200_IC_1W_4KB\n`define OR1200_IC_1W_8KB\n// `define OR1200_DC_1W_4KB\n`define OR1200_DC_1W_8KB\n\n`else\n\n\n/////////////////////////////////////////////////////////\n//\n// Typical configuration for an FPGA\n//\n\n//\n// Target FPGA memories\n//\n//`define OR1200_ALTERA_LPM\n//`define OR1200_XILINX_RAMB16\n//`define OR1200_XILINX_RAMB4\n//`define OR1200_XILINX_RAM32X1D\n//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D\n// Generic models should infer RAM blocks at synthesis time (not only effects \n// single port ram.)\n`define OR1200_GENERIC\n\n//\n// Do not implement Data cache\n//\n//`define OR1200_NO_DC\n\n//\n// Do not implement Insn cache\n//\n//`define OR1200_NO_IC\n\n//\n// Do not implement Data MMU\n//\n//`define OR1200_NO_DMMU\n\n//\n// Do not implement Insn MMU\n//\n//`define OR1200_NO_IMMU\n\n//\n// Select between ASIC and generic multiplier\n//\n// (Generic seems to trigger a bug in the Cadence Ncsim simulator)\n//\n//`define OR1200_ASIC_MULTP2_32X32\n`define OR1200_GENERIC_MULTP2_32X32\n\n//\n// Size/type of insn/data cache if implemented\n// (consider available FPGA memory resources)\n//\n//`define OR1200_IC_1W_512B\n//`define OR1200_IC_1W_4KB\n`define OR1200_IC_1W_8KB\n//`define OR1200_IC_1W_16KB\n//`define OR1200_IC_1W_32KB\n//`define OR1200_DC_1W_4KB\n`define OR1200_DC_1W_8KB\n//`define OR1200_DC_1W_16KB\n//`define OR1200_DC_1W_32KB\n\n`endif\n\n\n//////////////////////////////////////////////////////////\n//\n// Do not change below unless you know what you are doing\n//\n\n//\n// Reset active low\n//\n//`define OR1200_RST_ACT_LOW\n\n//\n// Enable RAM BIST\n//\n// At the moment this only works for Virtual Silicon\n// single port RAMs. For other RAMs it has not effect.\n// Special wrapper for VS RAMs needs to be provided\n// with scan flops to facilitate bist scan.\n//\n//`define OR1200_BIST\n\n//\n// Register OR1200 WISHBONE outputs\n// (must be defined/enabled)\n//\n`define OR1200_REGISTERED_OUTPUTS\n\n//\n// Register OR1200 WISHBONE inputs\n//\n// (must be undefined/disabled)\n//\n//`define OR1200_REGISTERED_INPUTS\n\n//\n// Disable bursts if they are not supported by the\n// memory subsystem (only affect cache line fill)\n//\n//`define OR1200_NO_BURSTS\n//\n\n//\n// WISHBONE retry counter range\n//\n// 2^value range for retry counter. Retry counter\n// is activated whenever *wb_rty_i is asserted and\n// until retry counter expires, corresponding\n// WISHBONE interface is deactivated.\n//\n// To disable retry counters and *wb_rty_i all together,\n// undefine this macro.\n//\n//`define OR1200_WB_RETRY 7\n\n//\n// WISHBONE Consecutive Address Burst\n//\n// This was used prior to WISHBONE B3 specification\n// to identify bursts. It is no longer needed but\n// remains enabled for compatibility with old designs.\n//\n// To remove *wb_cab_o ports undefine this macro.\n//\n//`define OR1200_WB_CAB\n\n//\n// WISHBONE B3 compatible interface\n//\n// This follows the WISHBONE B3 specification.\n// It is not enabled by default because most\n// designs still don't use WB b3.\n//\n// To enable *wb_cti_o/*wb_bte_o ports,\n// define this macro.\n//\n`define OR1200_WB_B3\n\n//\n// LOG all WISHBONE accesses\n//\n`define OR1200_LOG_WB_ACCESS\n\n//\n// Enable additional synthesis directives if using\n// _Synopsys_ synthesis tool\n//\n//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES\n\n//\n// Enables default statement in some case blocks\n// and disables Synopsys synthesis directive full_case\n//\n// By default it is enabled. When disabled it\n// can increase clock frequency.\n//\n`define OR1200_CASE_DEFAULT\n\n//\n// Operand width / register file address width\n//\n// (DO NOT CHANGE)\n//\n`define OR1200_OPERAND_WIDTH\t\t32\n`define OR1200_REGFILE_ADDR_WIDTH\t5\n\n//\n// l.add/l.addi/l.and and optional l.addc/l.addic\n// also set (compare) flag when result of their\n// operation equals zero\n//\n// At the time of writing this, default or32\n// C/C++ compiler doesn't generate code that\n// would benefit from this optimization.\n//\n// By default this optimization is disabled to\n// save area.\n//\n//`define OR1200_ADDITIONAL_FLAG_MODIFIERS\n\n//\n// Implement l.addc/l.addic instructions\n//\n// By default implementation of l.addc/l.addic\n// instructions is enabled in case you need them.\n// If you don't use them, then disable implementation\n// to save area.\n//\n//`define OR1200_IMPL_ADDC\n\n//\n// Implement l.sub instruction\n//\n// By default implementation of l.sub instructions\n// is enabled to be compliant with the simulator.\n// If you don't use carry bit, then disable\n// implementation to save area.\n//\n`define OR1200_IMPL_SUB\n\n//\n// Implement carry bit SR[CY]\n//\n//\n// By default implementation of SR[CY] is enabled\n// to be compliant with the simulator. However SR[CY]\n// is explicitly only used by l.addc/l.addic/l.sub\n// instructions and if these three insns are not\n// implemented there is not much point having SR[CY].\n//\n//`define OR1200_IMPL_CY\n\n//\n// Implement rotate in the ALU\n//\n// At the time of writing this, or32\n// C/C++ compiler doesn't generate rotate\n// instructions. However or32 assembler\n// can assemble code that uses rotate insn.\n// This means that rotate instructions\n// must be used manually inserted.\n//\n// By default implementation of rotate\n// is disabled to save area and increase\n// clock frequency.\n//\n//`define OR1200_IMPL_ALU_ROTATE\n\n//\n// Type of ALU compare to implement\n//\n// Try either one to find what yields\n// higher clock frequencyin your case.\n//\n//`define OR1200_IMPL_ALU_COMP1\n`define OR1200_IMPL_ALU_COMP2\n\n//\n// Implement Find First/Last '1'\n//\n`define OR1200_IMPL_ALU_FFL1\n\n//\n// Implement l.cust5 ALU instruction\n//\n//`define OR1200_IMPL_ALU_CUST5\n\n//\n// Implement l.extXs and l.extXz instructions\n//\n`define OR1200_IMPL_ALU_EXT\n\n//\n// Implement multiplier\n//\n// By default multiplier is implemented\n//\n`define OR1200_MULT_IMPLEMENTED\n\n//\n// Implement multiply-and-accumulate\n//\n// By default MAC is implemented. To\n// implement MAC, multiplier (non-serial) needs to be\n// implemented.\n//\n//`define OR1200_MAC_IMPLEMENTED\n\n//\n// Implement optional l.div/l.divu instructions\n//\n// By default divide instructions are not implemented\n// to save area.\n//\n//\n`define OR1200_DIV_IMPLEMENTED\n\n//\n// Serial multiplier.\n//\n//`define OR1200_MULT_SERIAL\n\n//\n// Serial divider.\n// Uncomment to use a serial divider, otherwise will\n// be a generic parallel implementation.\n//\n`define OR1200_DIV_SERIAL\n\n//\n// Implement HW Single Precision FPU\n//\n//`define OR1200_FPU_IMPLEMENTED\n\n//\n// Clock ratio RISC clock versus WB clock\n//\n// If you plan to run WB:RISC clock fixed to 1:1, disable\n// both defines\n//\n// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED\n// and use clmode to set ratio\n//\n// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use\n// clmode to set ratio\n//\n//`define OR1200_CLKDIV_2_SUPPORTED\n//`define OR1200_CLKDIV_4_SUPPORTED\n\n//\n// Type of register file RAM\n//\n// Memory macro w/ two ports (see or1200_tpram_32x32.v)\n//`define OR1200_RFRAM_TWOPORT\n//\n// Memory macro dual port (see or1200_dpram.v)\n`define OR1200_RFRAM_DUALPORT\n\n//\n// Generic (flip-flop based) register file (see or1200_rfram_generic.v)\n//`define OR1200_RFRAM_GENERIC\n//  Generic register file supports - 16 registers \n`ifdef OR1200_RFRAM_GENERIC\n//    `define OR1200_RFRAM_16REG\n`endif\n\n//\n// Type of mem2reg aligner to implement.\n//\n// Once OR1200_IMPL_MEM2REG2 yielded faster\n// circuit, however with today tools it will\n// most probably give you slower circuit.\n//\n`define OR1200_IMPL_MEM2REG1\n//`define OR1200_IMPL_MEM2REG2\n\n//\n// Reset value and event\n//\n`ifdef OR1200_RST_ACT_LOW\n  `define OR1200_RST_VALUE      (1'b0)\n  `define OR1200_RST_EVENT      negedge\n`else\n  `define OR1200_RST_VALUE      (1'b1)\n  `define OR1200_RST_EVENT      posedge\n`endif\n\n//\n// ALUOPs\n//\n`define OR1200_ALUOP_WIDTH\t5\n`define OR1200_ALUOP_NOP\t5'b0_0100\n/* LS-nibble encodings correspond to bits [3:0] of instruction */\n`define OR1200_ALUOP_ADD\t5'b0_0000 // 0\n`define OR1200_ALUOP_ADDC\t5'b0_0001 // 1\n`define OR1200_ALUOP_SUB\t5'b0_0010 // 2\n`define OR1200_ALUOP_AND\t5'b0_0011 // 3\n`define OR1200_ALUOP_OR\t\t5'b0_0100 // 4\n`define OR1200_ALUOP_XOR\t5'b0_0101 // 5\n`define OR1200_ALUOP_MUL\t5'b0_0110 // 6\n`define OR1200_ALUOP_RESERVED\t5'b0_0111 // 7\n`define OR1200_ALUOP_SHROT\t5'b0_1000 // 8\n`define OR1200_ALUOP_DIV\t5'b0_1001 // 9\n`define OR1200_ALUOP_DIVU\t5'b0_1010 // a\n`define OR1200_ALUOP_MULU\t5'b0_1011 // b\n`define OR1200_ALUOP_EXTHB\t5'b0_1100 // c\n`define OR1200_ALUOP_EXTW\t5'b0_1101 // d\n`define OR1200_ALUOP_CMOV\t5'b0_1110 // e\n`define OR1200_ALUOP_FFL1\t5'b0_1111 // f\n\n/* Values sent to ALU from decode unit - not defined by ISA */\n`define OR1200_ALUOP_COMP       5'b1_0000 // Comparison\n`define OR1200_ALUOP_MOVHI      5'b1_0001 // Move-high\n`define OR1200_ALUOP_CUST5\t5'b1_0010 // l.cust5\n\n// ALU instructions second opcode field\n`define OR1200_ALUOP2_POS\t9:6\n`define OR1200_ALUOP2_WIDTH\t4\n\n//\n// MACOPs\n//\n`define OR1200_MACOP_WIDTH\t3\n`define OR1200_MACOP_NOP\t3'b000\n`define OR1200_MACOP_MAC\t3'b001\n`define OR1200_MACOP_MSB\t3'b010\n\n//\n// Shift/rotate ops\n//\n`define OR1200_SHROTOP_WIDTH\t4\n`define OR1200_SHROTOP_NOP\t4'd0\n`define OR1200_SHROTOP_SLL\t4'd0\n`define OR1200_SHROTOP_SRL\t4'd1\n`define OR1200_SHROTOP_SRA\t4'd2\n`define OR1200_SHROTOP_ROR\t4'd3\n\n//\n// Zero/Sign Extend ops\n//\n`define OR1200_EXTHBOP_WIDTH      4\n`define OR1200_EXTHBOP_BS         4'h1\n`define OR1200_EXTHBOP_HS         4'h0\n`define OR1200_EXTHBOP_BZ         4'h3\n`define OR1200_EXTHBOP_HZ         4'h2\n`define OR1200_EXTWOP_WIDTH       4\n`define OR1200_EXTWOP_WS          4'h0\n`define OR1200_EXTWOP_WZ          4'h1\n\n// Execution cycles per instruction\n`define OR1200_MULTICYCLE_WIDTH\t3\n`define OR1200_ONE_CYCLE\t\t3'd0\n`define OR1200_TWO_CYCLES\t\t3'd1\n\n// Execution control which will \"wait on\" a module to finish\n`define OR1200_WAIT_ON_WIDTH 2\n`define OR1200_WAIT_ON_NOTHING    `OR1200_WAIT_ON_WIDTH'd0\n`define OR1200_WAIT_ON_MULTMAC    `OR1200_WAIT_ON_WIDTH'd1\n`define OR1200_WAIT_ON_FPU        `OR1200_WAIT_ON_WIDTH'd2\n`define OR1200_WAIT_ON_MTSPR      `OR1200_WAIT_ON_WIDTH'd3\n\n\n// Operand MUX selects\n`define OR1200_SEL_WIDTH\t\t2\n`define OR1200_SEL_RF\t\t\t2'd0\n`define OR1200_SEL_IMM\t\t\t2'd1\n`define OR1200_SEL_EX_FORW\t\t2'd2\n`define OR1200_SEL_WB_FORW\t\t2'd3\n\n//\n// BRANCHOPs\n//\n`define OR1200_BRANCHOP_WIDTH\t\t3\n`define OR1200_BRANCHOP_NOP\t\t3'd0\n`define OR1200_BRANCHOP_J\t\t3'd1\n`define OR1200_BRANCHOP_JR\t\t3'd2\n`define OR1200_BRANCHOP_BAL\t\t3'd3\n`define OR1200_BRANCHOP_BF\t\t3'd4\n`define OR1200_BRANCHOP_BNF\t\t3'd5\n`define OR1200_BRANCHOP_RFE\t\t3'd6\n\n//\n// LSUOPs\n//\n// Bit 0: sign extend\n// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword\n// Bit 3: 0 load, 1 store\n`define OR1200_LSUOP_WIDTH\t\t4\n`define OR1200_LSUOP_NOP\t\t4'b0000\n`define OR1200_LSUOP_LBZ\t\t4'b0010\n`define OR1200_LSUOP_LBS\t\t4'b0011\n`define OR1200_LSUOP_LHZ\t\t4'b0100\n`define OR1200_LSUOP_LHS\t\t4'b0101\n`define OR1200_LSUOP_LWZ\t\t4'b0110\n`define OR1200_LSUOP_LWS\t\t4'b0111\n`define OR1200_LSUOP_LD\t\t\t4'b0001\n`define OR1200_LSUOP_SD\t\t\t4'b1000\n`define OR1200_LSUOP_SB\t\t\t4'b1010\n`define OR1200_LSUOP_SH\t\t\t4'b1100\n`define OR1200_LSUOP_SW\t\t\t4'b1110\n\n// Number of bits of load/store EA precalculated in ID stage\n// for balancing ID and EX stages.\n//\n// Valid range: 2,3,...,30,31\n`define OR1200_LSUEA_PRECALC\t\t2\n\n// FETCHOPs\n`define OR1200_FETCHOP_WIDTH\t\t1\n`define OR1200_FETCHOP_NOP\t\t1'b0\n`define OR1200_FETCHOP_LW\t\t1'b1\n\n//\n// Register File Write-Back OPs\n//\n// Bit 0: register file write enable\n// Bits 3-1: write-back mux selects\n//\n`define OR1200_RFWBOP_WIDTH\t\t4\n`define OR1200_RFWBOP_NOP\t\t4'b0000\n`define OR1200_RFWBOP_ALU\t\t3'b000\n`define OR1200_RFWBOP_LSU\t\t3'b001\n`define OR1200_RFWBOP_SPRS\t\t3'b010\n`define OR1200_RFWBOP_LR\t\t3'b011\n`define OR1200_RFWBOP_FPU\t\t3'b100\n\n// Compare instructions\n`define OR1200_COP_SFEQ       3'b000\n`define OR1200_COP_SFNE       3'b001\n`define OR1200_COP_SFGT       3'b010\n`define OR1200_COP_SFGE       3'b011\n`define OR1200_COP_SFLT       3'b100\n`define OR1200_COP_SFLE       3'b101\n`define OR1200_COP_X          3'b111\n`define OR1200_SIGNED_COMPARE 'd3\n`define OR1200_COMPOP_WIDTH\t4\n\n//\n// FP OPs\n//\n// MSbit indicates FPU operation valid\n//\n`define OR1200_FPUOP_WIDTH\t8\n// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles\n`define OR1200_FPUOP_CYCLES 3'd4\n// FP instruction is double precision if bit 4 is set. We're a 32-bit \n// implementation thus do not support double precision FP \n`define OR1200_FPUOP_DOUBLE_BIT 4\n`define OR1200_FPUOP_ADD  8'b0000_0000\n`define OR1200_FPUOP_SUB  8'b0000_0001\n`define OR1200_FPUOP_MUL  8'b0000_0010\n`define OR1200_FPUOP_DIV  8'b0000_0011\n`define OR1200_FPUOP_ITOF 8'b0000_0100\n`define OR1200_FPUOP_FTOI 8'b0000_0101\n`define OR1200_FPUOP_REM  8'b0000_0110\n`define OR1200_FPUOP_RESERVED  8'b0000_0111\n// FP Compare instructions\n`define OR1200_FPCOP_SFEQ 8'b0000_1000\n`define OR1200_FPCOP_SFNE 8'b0000_1001\n`define OR1200_FPCOP_SFGT 8'b0000_1010\n`define OR1200_FPCOP_SFGE 8'b0000_1011\n`define OR1200_FPCOP_SFLT 8'b0000_1100\n`define OR1200_FPCOP_SFLE 8'b0000_1101\n\n//\n// TAGs for instruction bus\n//\n`define OR1200_ITAG_IDLE\t4'h0\t// idle bus\n`define\tOR1200_ITAG_NI\t\t4'h1\t// normal insn\n`define OR1200_ITAG_BE\t\t4'hb\t// Bus error exception\n`define OR1200_ITAG_PE\t\t4'hc\t// Page fault exception\n`define OR1200_ITAG_TE\t\t4'hd\t// TLB miss exception\n\n//\n// TAGs for data bus\n//\n`define OR1200_DTAG_IDLE\t4'h0\t// idle bus\n`define\tOR1200_DTAG_ND\t\t4'h1\t// normal data\n`define OR1200_DTAG_AE\t\t4'ha\t// Alignment exception\n`define OR1200_DTAG_BE\t\t4'hb\t// Bus error exception\n`define OR1200_DTAG_PE\t\t4'hc\t// Page fault exception\n`define OR1200_DTAG_TE\t\t4'hd\t// TLB miss exception\n\n\n//////////////////////////////////////////////\n//\n// ORBIS32 ISA specifics\n//\n\n// SHROT_OP position in machine word\n`define OR1200_SHROTOP_POS\t\t7:6\n\n//\n// Instruction opcode groups (basic)\n//\n`define OR1200_OR32_J                 6'b000000\n`define OR1200_OR32_JAL               6'b000001\n`define OR1200_OR32_BNF               6'b000011\n`define OR1200_OR32_BF                6'b000100\n`define OR1200_OR32_NOP               6'b000101\n`define OR1200_OR32_MOVHI             6'b000110\n`define OR1200_OR32_MACRC             6'b000110\n`define OR1200_OR32_XSYNC             6'b001000\n`define OR1200_OR32_RFE               6'b001001\n/* */\n`define OR1200_OR32_JR                6'b010001\n`define OR1200_OR32_JALR              6'b010010\n`define OR1200_OR32_MACI              6'b010011\n/* */\n`define OR1200_OR32_LWZ               6'b100001\n`define OR1200_OR32_LBZ               6'b100011\n`define OR1200_OR32_LBS               6'b100100\n`define OR1200_OR32_LHZ               6'b100101\n`define OR1200_OR32_LHS               6'b100110\n`define OR1200_OR32_ADDI              6'b100111\n`define OR1200_OR32_ADDIC             6'b101000\n`define OR1200_OR32_ANDI              6'b101001\n`define OR1200_OR32_ORI               6'b101010\n`define OR1200_OR32_XORI              6'b101011\n`define OR1200_OR32_MULI              6'b101100\n`define OR1200_OR32_MFSPR             6'b101101\n`define OR1200_OR32_SH_ROTI \t      6'b101110\n`define OR1200_OR32_SFXXI             6'b101111\n/* */\n`define OR1200_OR32_MTSPR             6'b110000\n`define OR1200_OR32_MACMSB            6'b110001\n`define OR1200_OR32_FLOAT             6'b110010\n/* */\n`define OR1200_OR32_SW                6'b110101\n`define OR1200_OR32_SB                6'b110110\n`define OR1200_OR32_SH                6'b110111\n`define OR1200_OR32_ALU               6'b111000\n`define OR1200_OR32_SFXX              6'b111001\n`define OR1200_OR32_CUST5             6'b111100\n\n/////////////////////////////////////////////////////\n//\n// Exceptions\n//\n\n//\n// Exception vectors per OR1K architecture:\n// 0xPPPPP100 - reset\n// 0xPPPPP200 - bus error\n// ... etc\n// where P represents exception prefix.\n//\n// Exception vectors can be customized as per\n// the following formula:\n// 0xPPPPPNVV - exception N\n//\n// P represents exception prefix\n// N represents exception N\n// VV represents length of the individual vector space,\n//   usually it is 8 bits wide and starts with all bits zero\n//\n\n//\n// PPPPP and VV parts\n//\n// Sum of these two defines needs to be 28\n//\n`define OR1200_EXCEPT_EPH0_P    20'h00000\n`define OR1200_EXCEPT_EPH1_P    20'hF0000\n`define OR1200_EXCEPT_V\t\t    8'h00\n\n//\n// N part width\n//\n`define OR1200_EXCEPT_WIDTH 4\n\n//\n// Definition of exception vectors\n//\n// To avoid implementation of a certain exception,\n// simply comment out corresponding line\n//\n`define OR1200_EXCEPT_UNUSED\t\t`OR1200_EXCEPT_WIDTH'hf\n`define OR1200_EXCEPT_TRAP\t\t`OR1200_EXCEPT_WIDTH'he\n`define OR1200_EXCEPT_FLOAT\t\t`OR1200_EXCEPT_WIDTH'hd\n`define OR1200_EXCEPT_SYSCALL\t\t`OR1200_EXCEPT_WIDTH'hc\n`define OR1200_EXCEPT_RANGE\t\t`OR1200_EXCEPT_WIDTH'hb\n`define OR1200_EXCEPT_ITLBMISS\t\t`OR1200_EXCEPT_WIDTH'ha\n`define OR1200_EXCEPT_DTLBMISS\t\t`OR1200_EXCEPT_WIDTH'h9\n`define OR1200_EXCEPT_INT\t\t`OR1200_EXCEPT_WIDTH'h8\n`define OR1200_EXCEPT_ILLEGAL\t\t`OR1200_EXCEPT_WIDTH'h7\n`define OR1200_EXCEPT_ALIGN\t\t`OR1200_EXCEPT_WIDTH'h6\n`define OR1200_EXCEPT_TICK\t\t`OR1200_EXCEPT_WIDTH'h5\n`define OR1200_EXCEPT_IPF\t\t`OR1200_EXCEPT_WIDTH'h4\n`define OR1200_EXCEPT_DPF\t\t`OR1200_EXCEPT_WIDTH'h3\n`define OR1200_EXCEPT_BUSERR\t\t`OR1200_EXCEPT_WIDTH'h2\n`define OR1200_EXCEPT_RESET\t\t`OR1200_EXCEPT_WIDTH'h1\n`define OR1200_EXCEPT_NONE\t\t`OR1200_EXCEPT_WIDTH'h0\n\n\n/////////////////////////////////////////////////////\n//\n// SPR groups\n//\n\n// Bits that define the group\n`define OR1200_SPR_GROUP_BITS\t15:11\n\n// Width of the group bits\n`define OR1200_SPR_GROUP_WIDTH \t5\n\n// Bits that define offset inside the group\n`define OR1200_SPR_OFS_BITS 10:0\n\n// List of groups\n`define OR1200_SPR_GROUP_SYS\t5'd00\n`define OR1200_SPR_GROUP_DMMU\t5'd01\n`define OR1200_SPR_GROUP_IMMU\t5'd02\n`define OR1200_SPR_GROUP_DC\t5'd03\n`define OR1200_SPR_GROUP_IC\t5'd04\n`define OR1200_SPR_GROUP_MAC\t5'd05\n`define OR1200_SPR_GROUP_DU\t5'd06\n`define OR1200_SPR_GROUP_PM\t5'd08\n`define OR1200_SPR_GROUP_PIC\t5'd09\n`define OR1200_SPR_GROUP_TT\t5'd10\n`define OR1200_SPR_GROUP_FPU    5'd11\n\n/////////////////////////////////////////////////////\n//\n// System group\n//\n\n//\n// System registers\n//\n`define OR1200_SPR_CFGR\t\t7'd0\n`define OR1200_SPR_RF\t\t6'd32\t// 1024 >> 5\n`define OR1200_SPR_NPC\t\t11'd16\n`define OR1200_SPR_SR\t\t11'd17\n`define OR1200_SPR_PPC\t\t11'd18\n`define OR1200_SPR_FPCSR        11'd20\n`define OR1200_SPR_EPCR\t\t11'd32\n`define OR1200_SPR_EEAR\t\t11'd48\n`define OR1200_SPR_ESR\t\t11'd64\n\n//\n// SR bits\n//\n`define OR1200_SR_WIDTH 17\n`define OR1200_SR_SM   0\n`define OR1200_SR_TEE  1\n`define OR1200_SR_IEE  2\n`define OR1200_SR_DCE  3\n`define OR1200_SR_ICE  4\n`define OR1200_SR_DME  5\n`define OR1200_SR_IME  6\n`define OR1200_SR_LEE  7\n`define OR1200_SR_CE   8\n`define OR1200_SR_F    9\n`define OR1200_SR_CY   10\t// Unused\n`define OR1200_SR_OV   11\t// Unused\n`define OR1200_SR_OVE  12\t// Unused\n`define OR1200_SR_DSX  13\t// Unused\n`define OR1200_SR_EPH  14\n`define OR1200_SR_FO   15\n`define OR1200_SR_TED  16\n`define OR1200_SR_CID  31:28\t// Unimplemented\n\n//\n// Bits that define offset inside the group\n//\n`define OR1200_SPROFS_BITS 10:0\n\n//\n// Default Exception Prefix\n//\n// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)\n// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)\n//\n`define OR1200_SR_EPH_DEF\t1'b0\n\n\n//\n// FPCSR bits\n//\n`define OR1200_FPCSR_WIDTH 12\n`define OR1200_FPCSR_FPEE  0\n`define OR1200_FPCSR_RM    2:1\n`define OR1200_FPCSR_OVF   3\n`define OR1200_FPCSR_UNF   4\n`define OR1200_FPCSR_SNF   5\n`define OR1200_FPCSR_QNF   6\n`define OR1200_FPCSR_ZF    7\n`define OR1200_FPCSR_IXF   8\n`define OR1200_FPCSR_IVF   9\n`define OR1200_FPCSR_INF   10\n`define OR1200_FPCSR_DZF   11\n`define OR1200_FPCSR_RES   31:12\n\n/////////////////////////////////////////////////////\n//\n// Power Management (PM)\n//\n\n// Define it if you want PM implemented\n//`define OR1200_PM_IMPLEMENTED\n\n// Bit positions inside PMR (don't change)\n`define OR1200_PM_PMR_SDF 3:0\n`define OR1200_PM_PMR_DME 4\n`define OR1200_PM_PMR_SME 5\n`define OR1200_PM_PMR_DCGE 6\n`define OR1200_PM_PMR_UNUSED 31:7\n\n// PMR offset inside PM group of registers\n`define OR1200_PM_OFS_PMR 11'b0\n\n// PM group\n`define OR1200_SPRGRP_PM 5'd8\n\n// Define if PMR can be read/written at any address inside PM group\n`define OR1200_PM_PARTIAL_DECODING\n\n// Define if reading PMR is allowed\n`define OR1200_PM_READREGS\n\n// Define if unused PMR bits should be zero\n`define OR1200_PM_UNUSED_ZERO\n\n\n/////////////////////////////////////////////////////\n//\n// Debug Unit (DU)\n//\n\n// Define it if you want DU implemented\n`define OR1200_DU_IMPLEMENTED\n\n//\n// Define if you want HW Breakpoints\n// (if HW breakpoints are not implemented\n// only default software trapping is\n// possible with l.trap insn - this is\n// however already enough for use\n// with or32 gdb)\n//\n//`define OR1200_DU_HWBKPTS\n\n// Number of DVR/DCR pairs if HW breakpoints enabled\n//\tComment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! \n//\tDU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS \n`define OR1200_DU_DVRDCR_PAIRS 8\n\n// Define if you want trace buffer\n//\t(for now only available for Xilinx Virtex FPGAs)\n//`define OR1200_DU_TB_IMPLEMENTED\n\n\n//\n// Address offsets of DU registers inside DU group\n//\n// To not implement a register, doq not define its address\n//\n`ifdef OR1200_DU_HWBKPTS\n`define OR1200_DU_DVR0\t\t11'd0\n`define OR1200_DU_DVR1\t\t11'd1\n`define OR1200_DU_DVR2\t\t11'd2\n`define OR1200_DU_DVR3\t\t11'd3\n`define OR1200_DU_DVR4\t\t11'd4\n`define OR1200_DU_DVR5\t\t11'd5\n`define OR1200_DU_DVR6\t\t11'd6\n`define OR1200_DU_DVR7\t\t11'd7\n`define OR1200_DU_DCR0\t\t11'd8\n`define OR1200_DU_DCR1\t\t11'd9\n`define OR1200_DU_DCR2\t\t11'd10\n`define OR1200_DU_DCR3\t\t11'd11\n`define OR1200_DU_DCR4\t\t11'd12\n`define OR1200_DU_DCR5\t\t11'd13\n`define OR1200_DU_DCR6\t\t11'd14\n`define OR1200_DU_DCR7\t\t11'd15\n`endif\n`define OR1200_DU_DMR1\t\t11'd16\n`ifdef OR1200_DU_HWBKPTS\n`define OR1200_DU_DMR2\t\t11'd17\n`define OR1200_DU_DWCR0\t\t11'd18\n`define OR1200_DU_DWCR1\t\t11'd19\n`endif\n`define OR1200_DU_DSR\t\t11'd20\n`define OR1200_DU_DRR\t\t11'd21\n`ifdef OR1200_DU_TB_IMPLEMENTED\n`define OR1200_DU_TBADR\t\t11'h0ff\n`define OR1200_DU_TBIA\t\t11'h1??\n`define OR1200_DU_TBIM\t\t11'h2??\n`define OR1200_DU_TBAR\t\t11'h3??\n`define OR1200_DU_TBTS\t\t11'h4??\n`endif\n\n// Position of offset bits inside SPR address\n`define OR1200_DUOFS_BITS\t10:0\n\n// DCR bits\n`define OR1200_DU_DCR_DP\t0\n`define OR1200_DU_DCR_CC\t3:1\n`define OR1200_DU_DCR_SC\t4\n`define OR1200_DU_DCR_CT\t7:5\n\n// DMR1 bits\n`define OR1200_DU_DMR1_CW0\t1:0\n`define OR1200_DU_DMR1_CW1\t3:2\n`define OR1200_DU_DMR1_CW2\t5:4\n`define OR1200_DU_DMR1_CW3\t7:6\n`define OR1200_DU_DMR1_CW4\t9:8\n`define OR1200_DU_DMR1_CW5\t11:10\n`define OR1200_DU_DMR1_CW6\t13:12\n`define OR1200_DU_DMR1_CW7\t15:14\n`define OR1200_DU_DMR1_CW8\t17:16\n`define OR1200_DU_DMR1_CW9\t19:18\n`define OR1200_DU_DMR1_CW10\t21:20\n`define OR1200_DU_DMR1_ST\t22\n`define OR1200_DU_DMR1_BT\t23\n`define OR1200_DU_DMR1_DXFW\t24\n`define OR1200_DU_DMR1_ETE\t25\n\n// DMR2 bits\n`define OR1200_DU_DMR2_WCE0\t0\n`define OR1200_DU_DMR2_WCE1\t1\n`define OR1200_DU_DMR2_AWTC\t12:2\n`define OR1200_DU_DMR2_WGB\t23:13\n\n// DWCR bits\n`define OR1200_DU_DWCR_COUNT\t15:0\n`define OR1200_DU_DWCR_MATCH\t31:16\n\n// DSR bits\n`define OR1200_DU_DSR_WIDTH\t14\n`define OR1200_DU_DSR_RSTE\t0\n`define OR1200_DU_DSR_BUSEE\t1\n`define OR1200_DU_DSR_DPFE\t2\n`define OR1200_DU_DSR_IPFE\t3\n`define OR1200_DU_DSR_TTE\t4\n`define OR1200_DU_DSR_AE\t5\n`define OR1200_DU_DSR_IIE\t6\n`define OR1200_DU_DSR_IE\t7\n`define OR1200_DU_DSR_DME\t8\n`define OR1200_DU_DSR_IME\t9\n`define OR1200_DU_DSR_RE\t10\n`define OR1200_DU_DSR_SCE\t11\n`define OR1200_DU_DSR_FPE\t12\n`define OR1200_DU_DSR_TE\t13\n\n// DRR bits\n`define OR1200_DU_DRR_RSTE\t0\n`define OR1200_DU_DRR_BUSEE\t1\n`define OR1200_DU_DRR_DPFE\t2\n`define OR1200_DU_DRR_IPFE\t3\n`define OR1200_DU_DRR_TTE\t4\n`define OR1200_DU_DRR_AE\t5\n`define OR1200_DU_DRR_IIE\t6\n`define OR1200_DU_DRR_IE\t7\n`define OR1200_DU_DRR_DME\t8\n`define OR1200_DU_DRR_IME\t9\n`define OR1200_DU_DRR_RE\t10\n`define OR1200_DU_DRR_SCE\t11\n`define OR1200_DU_DRR_FPE\t12\n`define OR1200_DU_DRR_TE\t13\n\n// Define if reading DU regs is allowed\n`define OR1200_DU_READREGS\n\n// Define if unused DU registers bits should be zero\n`define OR1200_DU_UNUSED_ZERO\n\n// Define if IF/LSU status is not needed by devel i/f\n`define OR1200_DU_STATUS_UNIMPLEMENTED\n\n/////////////////////////////////////////////////////\n//\n// Programmable Interrupt Controller (PIC)\n//\n\n// Define it if you want PIC implemented\n`define OR1200_PIC_IMPLEMENTED\n\n// Define number of interrupt inputs (2-31)\n`define OR1200_PIC_INTS 20\n\n// Address offsets of PIC registers inside PIC group\n`define OR1200_PIC_OFS_PICMR 2'd0\n`define OR1200_PIC_OFS_PICSR 2'd2\n\n// Position of offset bits inside SPR address\n`define OR1200_PICOFS_BITS 1:0\n\n// Define if you want these PIC registers to be implemented\n`define OR1200_PIC_PICMR\n`define OR1200_PIC_PICSR\n\n// Define if reading PIC registers is allowed\n`define OR1200_PIC_READREGS\n\n// Define if unused PIC register bits should be zero\n`define OR1200_PIC_UNUSED_ZERO\n\n\n/////////////////////////////////////////////////////\n//\n// Tick Timer (TT)\n//\n\n// Define it if you want TT implemented\n`define OR1200_TT_IMPLEMENTED\n\n// Address offsets of TT registers inside TT group\n`define OR1200_TT_OFS_TTMR 1'd0\n`define OR1200_TT_OFS_TTCR 1'd1\n\n// Position of offset bits inside SPR group\n`define OR1200_TTOFS_BITS 0\n\n// Define if you want these TT registers to be implemented\n`define OR1200_TT_TTMR\n`define OR1200_TT_TTCR\n\n// TTMR bits\n`define OR1200_TT_TTMR_TP 27:0\n`define OR1200_TT_TTMR_IP 28\n`define OR1200_TT_TTMR_IE 29\n`define OR1200_TT_TTMR_M 31:30\n\n// Define if reading TT registers is allowed\n`define OR1200_TT_READREGS\n\n\n//////////////////////////////////////////////\n//\n// MAC\n//\n`define OR1200_MAC_ADDR\t\t0\t// MACLO 0xxxxxxxx1, MACHI 0xxxxxxxx0\n`define OR1200_MAC_SPR_WE\t\t// Define if MACLO/MACHI are SPR writable\n\n//\n// Shift {MACHI,MACLO} into destination register when executing l.macrc\n//\n// According to architecture manual there is no shift, so default value is 0.\n// However the implementation has deviated in this from the arch manual and had\n// hard coded shift by 28 bits which is a useful optimization for MP3 decoding \n// (if using libmad fixed point library). Shifts are no longer default setup, \n// but if you need to remain backward compatible, define your shift bits, which\n// were normally\n// dest_GPR = {MACHI,MACLO}[59:28]\n`define OR1200_MAC_SHIFTBY\t0\t// 0 = According to arch manual, 28 = obsolete backward compatibility\n\n\n//////////////////////////////////////////////\n//\n// Data MMU (DMMU)\n//\n\n//\n// Address that selects between TLB TR and MR\n//\n`define OR1200_DTLB_TM_ADDR\t7\n\n//\n// DTLBMR fields\n//\n`define\tOR1200_DTLBMR_V_BITS\t0\n`define\tOR1200_DTLBMR_CID_BITS\t4:1\n`define\tOR1200_DTLBMR_RES_BITS\t11:5\n`define OR1200_DTLBMR_VPN_BITS\t31:13\n\n//\n// DTLBTR fields\n//\n`define\tOR1200_DTLBTR_CC_BITS\t0\n`define\tOR1200_DTLBTR_CI_BITS\t1\n`define\tOR1200_DTLBTR_WBC_BITS\t2\n`define\tOR1200_DTLBTR_WOM_BITS\t3\n`define\tOR1200_DTLBTR_A_BITS\t4\n`define\tOR1200_DTLBTR_D_BITS\t5\n`define\tOR1200_DTLBTR_URE_BITS\t6\n`define\tOR1200_DTLBTR_UWE_BITS\t7\n`define\tOR1200_DTLBTR_SRE_BITS\t8\n`define\tOR1200_DTLBTR_SWE_BITS\t9\n`define\tOR1200_DTLBTR_RES_BITS\t11:10\n`define OR1200_DTLBTR_PPN_BITS\t31:13\n\n//\n// DTLB configuration\n//\n`define\tOR1200_DMMU_PS\t\t13\t\t\t\t\t// 13 for 8KB page size\n`define\tOR1200_DTLB_INDXW\t6\t\t\t\t\t// 6 for 64 entry DTLB\t7 for 128 entries\n`define OR1200_DTLB_INDXL\t`OR1200_DMMU_PS\t\t\t\t// 13\t\t\t13\n`define OR1200_DTLB_INDXH\t`OR1200_DMMU_PS+`OR1200_DTLB_INDXW-1\t// 18\t\t\t19\n`define\tOR1200_DTLB_INDX\t`OR1200_DTLB_INDXH:`OR1200_DTLB_INDXL\t// 18:13\t\t19:13\n`define OR1200_DTLB_TAGW\t32-`OR1200_DTLB_INDXW-`OR1200_DMMU_PS\t// 13\t\t\t12\n`define OR1200_DTLB_TAGL\t`OR1200_DTLB_INDXH+1\t\t\t// 19\t\t\t20\n`define\tOR1200_DTLB_TAG\t\t31:`OR1200_DTLB_TAGL\t\t\t// 31:19\t\t31:20\n`define\tOR1200_DTLBMRW\t\t`OR1200_DTLB_TAGW+1\t\t\t// +1 because of V bit\n`define\tOR1200_DTLBTRW\t\t32-`OR1200_DMMU_PS+5\t\t\t// +5 because of protection bits and CI\n\n//\n// Cache inhibit while DMMU is not enabled/implemented\n//\n// cache inhibited 0GB-4GB\t\t1'b1\n// cache inhibited 0GB-2GB\t\t!dcpu_adr_i[31]\n// cache inhibited 0GB-1GB 2GB-3GB\t!dcpu_adr_i[30]\n// cache inhibited 1GB-2GB 3GB-4GB\tdcpu_adr_i[30]\n// cache inhibited 2GB-4GB (default)\tdcpu_adr_i[31]\n// cached 0GB-4GB\t\t\t1'b0\n//\n`define OR1200_DMMU_CI\t\t\tdcpu_adr_i[31]\n\n\n//////////////////////////////////////////////\n//\n// Insn MMU (IMMU)\n//\n\n//\n// Address that selects between TLB TR and MR\n//\n`define OR1200_ITLB_TM_ADDR\t7\n\n//\n// ITLBMR fields\n//\n`define\tOR1200_ITLBMR_V_BITS\t0\n`define\tOR1200_ITLBMR_CID_BITS\t4:1\n`define\tOR1200_ITLBMR_RES_BITS\t11:5\n`define OR1200_ITLBMR_VPN_BITS\t31:13\n\n//\n// ITLBTR fields\n//\n`define\tOR1200_ITLBTR_CC_BITS\t0\n`define\tOR1200_ITLBTR_CI_BITS\t1\n`define\tOR1200_ITLBTR_WBC_BITS\t2\n`define\tOR1200_ITLBTR_WOM_BITS\t3\n`define\tOR1200_ITLBTR_A_BITS\t4\n`define\tOR1200_ITLBTR_D_BITS\t5\n`define\tOR1200_ITLBTR_SXE_BITS\t6\n`define\tOR1200_ITLBTR_UXE_BITS\t7\n`define\tOR1200_ITLBTR_RES_BITS\t11:8\n`define OR1200_ITLBTR_PPN_BITS\t31:13\n\n//\n// ITLB configuration\n//\n`define\tOR1200_IMMU_PS\t\t13\t\t\t\t\t// 13 for 8KB page size\n`define\tOR1200_ITLB_INDXW\t6\t\t\t\t\t// 6 for 64 entry ITLB\t7 for 128 entries\n`define OR1200_ITLB_INDXL\t`OR1200_IMMU_PS\t\t\t\t// 13\t\t\t13\n`define OR1200_ITLB_INDXH\t`OR1200_IMMU_PS+`OR1200_ITLB_INDXW-1\t// 18\t\t\t19\n`define\tOR1200_ITLB_INDX\t`OR1200_ITLB_INDXH:`OR1200_ITLB_INDXL\t// 18:13\t\t19:13\n`define OR1200_ITLB_TAGW\t32-`OR1200_ITLB_INDXW-`OR1200_IMMU_PS\t// 13\t\t\t12\n`define OR1200_ITLB_TAGL\t`OR1200_ITLB_INDXH+1\t\t\t// 19\t\t\t20\n`define\tOR1200_ITLB_TAG\t\t31:`OR1200_ITLB_TAGL\t\t\t// 31:19\t\t31:20\n`define\tOR1200_ITLBMRW\t\t`OR1200_ITLB_TAGW+1\t\t\t// +1 because of V bit\n`define\tOR1200_ITLBTRW\t\t32-`OR1200_IMMU_PS+3\t\t\t// +3 because of protection bits and CI\n\n//\n// Cache inhibit while IMMU is not enabled/implemented\n// Note: all combinations that use icpu_adr_i cause async loop\n//\n// cache inhibited 0GB-4GB\t\t1'b1\n// cache inhibited 0GB-2GB\t\t!icpu_adr_i[31]\n// cache inhibited 0GB-1GB 2GB-3GB\t!icpu_adr_i[30]\n// cache inhibited 1GB-2GB 3GB-4GB\ticpu_adr_i[30]\n// cache inhibited 2GB-4GB (default)\ticpu_adr_i[31]\n// cached 0GB-4GB\t\t\t1'b0\n//\n`define OR1200_IMMU_CI\t\t\t1'b0\n\n\n/////////////////////////////////////////////////\n//\n// Insn cache (IC)\n//\n\n// 4 for 16 byte line, 5 for 32 byte lines.\n`ifdef OR1200_IC_1W_32KB\n `define OR1200_ICLS\t\t5\n`else\n `define OR1200_ICLS\t\t4\n`endif\n\n//\n// IC configurations\n//\n`ifdef OR1200_IC_1W_512B\n`define OR1200_ICSIZE                   9                       // 512\n`define OR1200_ICINDX                   `OR1200_ICSIZE-2        // 7\n`define OR1200_ICINDXH                  `OR1200_ICSIZE-1        // 8\n`define OR1200_ICTAGL                   `OR1200_ICINDXH+1       // 9\n`define OR1200_ICTAG                    `OR1200_ICSIZE-`OR1200_ICLS // 5\n`define OR1200_ICTAG_W                  24\n`endif\n`ifdef OR1200_IC_1W_4KB\n`define OR1200_ICSIZE\t\t\t12\t\t\t// 4096\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 10\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 11\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 12\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 8\n`define\tOR1200_ICTAG_W\t\t\t21\n`endif\n`ifdef OR1200_IC_1W_8KB\n`define OR1200_ICSIZE\t\t\t13\t\t\t// 8192\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 11\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 12\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 13\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 9\n`define\tOR1200_ICTAG_W\t\t\t20\n`endif\n`ifdef OR1200_IC_1W_16KB\n`define OR1200_ICSIZE\t\t\t14\t\t\t// 16384\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 12\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 13\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 14\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 10\n`define\tOR1200_ICTAG_W\t\t\t19\n`endif\n`ifdef OR1200_IC_1W_32KB\n`define OR1200_ICSIZE\t\t\t15\t\t\t// 32768\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 13\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 14\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 14\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 10\n`define\tOR1200_ICTAG_W\t\t\t18\n`endif\n\n\n/////////////////////////////////////////////////\n//\n// Data cache (DC)\n//\n\n// 4 for 16 bytes, 5 for 32 bytes\n`ifdef OR1200_DC_1W_32KB\n `define OR1200_DCLS\t\t5\n`else\n `define OR1200_DCLS\t\t4\n`endif\n\n// Define to enable default behavior of cache as write through\n// Turning this off enabled write back statergy\n//\n`define OR1200_DC_WRITETHROUGH\n\n// Define to enable stores from the stack not doing writethrough.\n// EXPERIMENTAL\n//`define OR1200_DC_NOSTACKWRITETHROUGH\n\n// Data cache SPR definitions\n`define OR1200_SPRGRP_DC_ADR_WIDTH 3\n// Data cache group SPR addresses\n`define OR1200_SPRGRP_DC_DCCR\t\t3'd0 // Not implemented\n`define OR1200_SPRGRP_DC_DCBPR\t\t3'd1 // Not implemented\n`define OR1200_SPRGRP_DC_DCBFR\t\t3'd2\n`define OR1200_SPRGRP_DC_DCBIR\t\t3'd3\n`define OR1200_SPRGRP_DC_DCBWR\t\t3'd4 // Not implemented\n`define OR1200_SPRGRP_DC_DCBLR\t\t3'd5 // Not implemented\n\n//\n// DC configurations\n//\n`ifdef OR1200_DC_1W_4KB\n`define OR1200_DCSIZE\t\t\t12\t\t\t// 4096\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 10\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 11\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 12\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 8\n`define\tOR1200_DCTAG_W\t\t\t21\n`endif\n`ifdef OR1200_DC_1W_8KB\n`define OR1200_DCSIZE\t\t\t13\t\t\t// 8192\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 11\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 12\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 13\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 9\n`define\tOR1200_DCTAG_W\t\t\t20\n`endif\n`ifdef OR1200_DC_1W_16KB\n`define OR1200_DCSIZE\t\t\t14\t\t\t// 16384\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 12\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 13\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 14\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 10\n`define\tOR1200_DCTAG_W\t\t\t19\n`endif\n`ifdef OR1200_DC_1W_32KB\n`define OR1200_DCSIZE\t\t\t15\t\t\t// 32768\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 13\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 14\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 15\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 10\n`define\tOR1200_DCTAG_W\t\t\t18\n`endif\n\n\n/////////////////////////////////////////////////\n//\n// Store buffer (SB)\n//\n\n//\n// Store buffer\n//\n// It will improve performance by \"caching\" CPU stores\n// using store buffer. This is most important for function\n// prologues because DC can only work in write though mode\n// and all stores would have to complete external WB writes\n// to memory.\n// Store buffer is between DC and data BIU.\n// All stores will be stored into store buffer and immediately\n// completed by the CPU, even though actual external writes\n// will be performed later. As a consequence store buffer masks\n// all data bus errors related to stores (data bus errors\n// related to loads are delivered normally).\n// All pending CPU loads will wait until store buffer is empty to\n// ensure strict memory model. Right now this is necessary because\n// we don't make destinction between cached and cache inhibited\n// address space, so we simply empty store buffer until loads\n// can begin.\n//\n// It makes design a bit bigger, depending what is the number of\n// entries in SB FIFO. Number of entries can be changed further\n// down.\n//\n//`define OR1200_SB_IMPLEMENTED\n\n//\n// Number of store buffer entries\n//\n// Verified number of entries are 4 and 8 entries\n// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must\n// always match 2**OR1200_SB_LOG.\n// To disable store buffer, undefine\n// OR1200_SB_IMPLEMENTED.\n//\n`define OR1200_SB_LOG\t\t2\t// 2 or 3\n`define OR1200_SB_ENTRIES\t4\t// 4 or 8\n\n\n/////////////////////////////////////////////////\n//\n// Quick Embedded Memory (QMEM)\n//\n\n//\n// Quick Embedded Memory\n//\n// Instantiation of dedicated insn/data memory (RAM or ROM).\n// Insn fetch has effective throughput 1insn / clock cycle.\n// Data load takes two clock cycles / access, data store\n// takes 1 clock cycle / access (if there is no insn fetch)).\n// Memory instantiation is shared between insn and data,\n// meaning if insn fetch are performed, data load/store\n// performance will be lower.\n//\n// Main reason for QMEM is to put some time critical functions\n// into this memory and to have predictable and fast access\n// to these functions. (soft fpu, context switch, exception\n// handlers, stack, etc)\n//\n// It makes design a bit bigger and slower. QMEM sits behind\n// IMMU/DMMU so all addresses are physical (so the MMUs can be\n// used with QMEM and QMEM is seen by the CPU just like any other\n// memory in the system). IC/DC are sitting behind QMEM so the\n// whole design timing might be worse with QMEM implemented.\n//\n//`define OR1200_QMEM_IMPLEMENTED\n\n//\n// Base address and mask of QMEM\n//\n// Base address defines first address of QMEM. Mask defines\n// QMEM range in address space. Actual size of QMEM is however\n// determined with instantiated RAM/ROM. However bigger\n// mask will reserve more address space for QMEM, but also\n// make design faster, while more tight mask will take\n// less address space but also make design slower. If\n// instantiated RAM/ROM is smaller than space reserved with\n// the mask, instatiated RAM/ROM will also be shadowed\n// at higher addresses in reserved space.\n//\n`define OR1200_QMEM_IADDR\t32'h0080_0000\n`define OR1200_QMEM_IMASK\t32'hfff0_0000 // Max QMEM size 1MB\n`define OR1200_QMEM_DADDR\t32'h0080_0000\n`define OR1200_QMEM_DMASK\t32'hfff0_0000 // Max QMEM size 1MB\n\n//\n// QMEM interface byte-select capability\n//\n// To enable qmem_sel* ports, define this macro.\n//\n//`define OR1200_QMEM_BSEL\n\n//\n// QMEM interface acknowledge\n//\n// To enable qmem_ack port, define this macro.\n//\n//`define OR1200_QMEM_ACK\n\n/////////////////////////////////////////////////////\n//\n// VR, UPR and Configuration Registers\n//\n//\n// VR, UPR and configuration registers are optional. If \n// implemented, operating system can automatically figure\n// out how to use the processor because it knows \n// what units are available in the processor and how they\n// are configured.\n//\n// This section must be last in or1200_defines.v file so\n// that all units are already configured and thus\n// configuration registers are properly set.\n// \n\n// Define if you want configuration registers implemented\n`define OR1200_CFGR_IMPLEMENTED\n\n// Define if you want full address decode inside SYS group\n`define OR1200_SYS_FULL_DECODE\n\n// Offsets of VR, UPR and CFGR registers\n`define OR1200_SPRGRP_SYS_VR\t\t4'h0\n`define OR1200_SPRGRP_SYS_UPR\t\t4'h1\n`define OR1200_SPRGRP_SYS_CPUCFGR\t4'h2\n`define OR1200_SPRGRP_SYS_DMMUCFGR\t4'h3\n`define OR1200_SPRGRP_SYS_IMMUCFGR\t4'h4\n`define OR1200_SPRGRP_SYS_DCCFGR\t4'h5\n`define OR1200_SPRGRP_SYS_ICCFGR\t4'h6\n`define OR1200_SPRGRP_SYS_DCFGR\t4'h7\n\n// VR fields\n`define OR1200_VR_REV_BITS\t\t5:0\n`define OR1200_VR_RES1_BITS\t\t15:6\n`define OR1200_VR_CFG_BITS\t\t23:16\n`define OR1200_VR_VER_BITS\t\t31:24\n\n// VR values\n`define OR1200_VR_REV\t\t\t6'h08\n`define OR1200_VR_RES1\t\t\t10'h000\n`define OR1200_VR_CFG\t\t\t8'h00\n`define OR1200_VR_VER\t\t\t8'h12\n\n// UPR fields\n`define OR1200_UPR_UP_BITS\t\t0\n`define OR1200_UPR_DCP_BITS\t\t1\n`define OR1200_UPR_ICP_BITS\t\t2\n`define OR1200_UPR_DMP_BITS\t\t3\n`define OR1200_UPR_IMP_BITS\t\t4\n`define OR1200_UPR_MP_BITS\t\t5\n`define OR1200_UPR_DUP_BITS\t\t6\n`define OR1200_UPR_PCUP_BITS\t\t7\n`define OR1200_UPR_PMP_BITS\t\t8\n`define OR1200_UPR_PICP_BITS\t\t9\n`define OR1200_UPR_TTP_BITS\t\t10\n`define OR1200_UPR_FPP_BITS\t\t11\n`define OR1200_UPR_RES1_BITS\t\t23:12\n`define OR1200_UPR_CUP_BITS\t\t31:24\n\n// UPR values\n`define OR1200_UPR_UP\t\t\t1'b1\n`ifdef OR1200_NO_DC\n`define OR1200_UPR_DCP\t\t\t1'b0\n`else\n`define OR1200_UPR_DCP\t\t\t1'b1\n`endif\n`ifdef OR1200_NO_IC\n`define OR1200_UPR_ICP\t\t\t1'b0\n`else\n`define OR1200_UPR_ICP\t\t\t1'b1\n`endif\n`ifdef OR1200_NO_DMMU\n`define OR1200_UPR_DMP\t\t\t1'b0\n`else\n`define OR1200_UPR_DMP\t\t\t1'b1\n`endif\n`ifdef OR1200_NO_IMMU\n`define OR1200_UPR_IMP\t\t\t1'b0\n`else\n`define OR1200_UPR_IMP\t\t\t1'b1\n`endif\n`ifdef OR1200_MAC_IMPLEMENTED\n`define OR1200_UPR_MP\t\t\t1'b1\n`else\n`define OR1200_UPR_MP\t\t\t1'b0\n`endif\n`ifdef OR1200_DU_IMPLEMENTED\n`define OR1200_UPR_DUP\t\t\t1'b1\n`else\n`define OR1200_UPR_DUP\t\t\t1'b0\n`endif\n`define OR1200_UPR_PCUP\t\t\t1'b0\t// Performance counters not present\n`ifdef OR1200_PM_IMPLEMENTED\n`define OR1200_UPR_PMP\t\t\t1'b1\n`else\n`define OR1200_UPR_PMP\t\t\t1'b0\n`endif\n`ifdef OR1200_PIC_IMPLEMENTED\n`define OR1200_UPR_PICP\t\t\t1'b1\n`else\n`define OR1200_UPR_PICP\t\t\t1'b0\n`endif\n`ifdef OR1200_TT_IMPLEMENTED\n`define OR1200_UPR_TTP\t\t\t1'b1\n`else\n`define OR1200_UPR_TTP\t\t\t1'b0\n`endif\n`ifdef OR1200_FPU_IMPLEMENTED\n`define OR1200_UPR_FPP\t\t\t1'b1\n`else\n`define OR1200_UPR_FPP\t\t\t1'b0\n`endif\n`define OR1200_UPR_RES1\t\t\t12'h000\n`define OR1200_UPR_CUP\t\t\t8'h00\n\n// CPUCFGR fields\n`define OR1200_CPUCFGR_NSGF_BITS\t3:0\n`define OR1200_CPUCFGR_HGF_BITS     4\n`define OR1200_CPUCFGR_OB32S_BITS\t5\n`define OR1200_CPUCFGR_OB64S_BITS\t6\n`define OR1200_CPUCFGR_OF32S_BITS\t7\n`define OR1200_CPUCFGR_OF64S_BITS\t8\n`define OR1200_CPUCFGR_OV64S_BITS\t9\n`define OR1200_CPUCFGR_RES1_BITS\t31:10\n\n// CPUCFGR values\n`define OR1200_CPUCFGR_NSGF\t\t    4'h0\n`ifdef OR1200_RFRAM_16REG\n    `define OR1200_CPUCFGR_HGF  \t\t1'b1\n`else\n    `define OR1200_CPUCFGR_HGF  \t\t1'b0\n`endif\n`define OR1200_CPUCFGR_OB32S\t\t1'b1\n`define OR1200_CPUCFGR_OB64S\t\t1'b0\n`ifdef OR1200_FPU_IMPLEMENTED\n `define OR1200_CPUCFGR_OF32S\t\t1'b1\n`else\n `define OR1200_CPUCFGR_OF32S\t\t1'b0\n`endif\n\n`define OR1200_CPUCFGR_OF64S\t\t1'b0\n`define OR1200_CPUCFGR_OV64S\t\t1'b0\n`define OR1200_CPUCFGR_RES1\t\t22'h000000\n\n// DMMUCFGR fields\n`define OR1200_DMMUCFGR_NTW_BITS\t1:0\n`define OR1200_DMMUCFGR_NTS_BITS\t4:2\n`define OR1200_DMMUCFGR_NAE_BITS\t7:5\n`define OR1200_DMMUCFGR_CRI_BITS\t8\n`define OR1200_DMMUCFGR_PRI_BITS\t9\n`define OR1200_DMMUCFGR_TEIRI_BITS\t10\n`define OR1200_DMMUCFGR_HTR_BITS\t11\n`define OR1200_DMMUCFGR_RES1_BITS\t31:12\n\n// DMMUCFGR values\n`ifdef OR1200_NO_DMMU\n`define OR1200_DMMUCFGR_NTW\t\t2'h0\t// Irrelevant\n`define OR1200_DMMUCFGR_NTS\t\t3'h0\t// Irrelevant\n`define OR1200_DMMUCFGR_NAE\t\t3'h0\t// Irrelevant\n`define OR1200_DMMUCFGR_CRI\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_PRI\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_TEIRI\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_HTR\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_RES1\t\t20'h00000\n`else\n`define OR1200_DMMUCFGR_NTW\t\t2'h0\t// 1 TLB way\n`define OR1200_DMMUCFGR_NTS 3'h`OR1200_DTLB_INDXW\t// Num TLB sets\n`define OR1200_DMMUCFGR_NAE\t\t3'h0\t// No ATB entries\n`define OR1200_DMMUCFGR_CRI\t\t1'b0\t// No control register\n`define OR1200_DMMUCFGR_PRI\t\t1'b0\t// No protection reg\n`define OR1200_DMMUCFGR_TEIRI\t\t1'b1\t// TLB entry inv reg impl.\n`define OR1200_DMMUCFGR_HTR\t\t1'b0\t// No HW TLB reload\n`define OR1200_DMMUCFGR_RES1\t\t20'h00000\n`endif\n\n// IMMUCFGR fields\n`define OR1200_IMMUCFGR_NTW_BITS\t1:0\n`define OR1200_IMMUCFGR_NTS_BITS\t4:2\n`define OR1200_IMMUCFGR_NAE_BITS\t7:5\n`define OR1200_IMMUCFGR_CRI_BITS\t8\n`define OR1200_IMMUCFGR_PRI_BITS\t9\n`define OR1200_IMMUCFGR_TEIRI_BITS\t10\n`define OR1200_IMMUCFGR_HTR_BITS\t11\n`define OR1200_IMMUCFGR_RES1_BITS\t31:12\n\n// IMMUCFGR values\n`ifdef OR1200_NO_IMMU\n`define OR1200_IMMUCFGR_NTW\t\t2'h0\t// Irrelevant\n`define OR1200_IMMUCFGR_NTS\t\t3'h0\t// Irrelevant\n`define OR1200_IMMUCFGR_NAE\t\t3'h0\t// Irrelevant\n`define OR1200_IMMUCFGR_CRI\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_PRI\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_TEIRI\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_HTR\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_RES1\t\t20'h00000\n`else\n`define OR1200_IMMUCFGR_NTW\t\t2'h0\t// 1 TLB way\n`define OR1200_IMMUCFGR_NTS 3'h`OR1200_ITLB_INDXW\t// Num TLB sets\n`define OR1200_IMMUCFGR_NAE\t\t3'h0\t// No ATB entry\n`define OR1200_IMMUCFGR_CRI\t\t1'b0\t// No control reg\n`define OR1200_IMMUCFGR_PRI\t\t1'b0\t// No protection reg\n`define OR1200_IMMUCFGR_TEIRI\t\t1'b1\t// TLB entry inv reg impl\n`define OR1200_IMMUCFGR_HTR\t\t1'b0\t// No HW TLB reload\n`define OR1200_IMMUCFGR_RES1\t\t20'h00000\n`endif\n\n// DCCFGR fields\n`define OR1200_DCCFGR_NCW_BITS\t\t2:0\n`define OR1200_DCCFGR_NCS_BITS\t\t6:3\n`define OR1200_DCCFGR_CBS_BITS\t\t7\n`define OR1200_DCCFGR_CWS_BITS\t\t8\n`define OR1200_DCCFGR_CCRI_BITS\t\t9\n`define OR1200_DCCFGR_CBIRI_BITS\t10\n`define OR1200_DCCFGR_CBPRI_BITS\t11\n`define OR1200_DCCFGR_CBLRI_BITS\t12\n`define OR1200_DCCFGR_CBFRI_BITS\t13\n`define OR1200_DCCFGR_CBWBRI_BITS\t14\n`define OR1200_DCCFGR_RES1_BITS\t31:15\n\n// DCCFGR values\n`ifdef OR1200_NO_DC\n`define OR1200_DCCFGR_NCW\t\t3'h0\t// Irrelevant\n`define OR1200_DCCFGR_NCS\t\t4'h0\t// Irrelevant\n`define OR1200_DCCFGR_CBS\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CWS\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CCRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBIRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBPRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBLRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBFRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBWBRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_RES1\t\t17'h00000\n`else\n`define OR1200_DCCFGR_NCW\t\t3'h0\t// 1 cache way\n`define OR1200_DCCFGR_NCS (`OR1200_DCTAG)\t// Num cache sets\n`define OR1200_DCCFGR_CBS `OR1200_DCLS==4 ? 1'b0 : 1'b1 // 16 byte cache block\n`ifdef OR1200_DC_WRITETHROUGH\n `define OR1200_DCCFGR_CWS\t\t1'b0\t// Write-through strategy\n`else\n `define OR1200_DCCFGR_CWS\t\t1'b1\t// Write-back strategy\n`endif\n`define OR1200_DCCFGR_CCRI\t\t1'b1\t// Cache control reg impl.\n`define OR1200_DCCFGR_CBIRI\t\t1'b1\t// Cache block inv reg impl.\n`define OR1200_DCCFGR_CBPRI\t\t1'b0\t// Cache block prefetch reg not impl.\n`define OR1200_DCCFGR_CBLRI\t\t1'b0\t// Cache block lock reg not impl.\n`define OR1200_DCCFGR_CBFRI\t\t1'b1\t// Cache block flush reg impl.\n`ifdef OR1200_DC_WRITETHROUGH\n `define OR1200_DCCFGR_CBWBRI\t\t1'b0\t// Cache block WB reg not impl.\n`else\n `define OR1200_DCCFGR_CBWBRI\t\t1'b1\t// Cache block WB reg impl.\n`endif\n`define OR1200_DCCFGR_RES1\t\t17'h00000\n`endif\n\n// ICCFGR fields\n`define OR1200_ICCFGR_NCW_BITS\t\t2:0\n`define OR1200_ICCFGR_NCS_BITS\t\t6:3\n`define OR1200_ICCFGR_CBS_BITS\t\t7\n`define OR1200_ICCFGR_CWS_BITS\t\t8\n`define OR1200_ICCFGR_CCRI_BITS\t\t9\n`define OR1200_ICCFGR_CBIRI_BITS\t10\n`define OR1200_ICCFGR_CBPRI_BITS\t11\n`define OR1200_ICCFGR_CBLRI_BITS\t12\n`define OR1200_ICCFGR_CBFRI_BITS\t13\n`define OR1200_ICCFGR_CBWBRI_BITS\t14\n`define OR1200_ICCFGR_RES1_BITS\t31:15\n\n// ICCFGR values\n`ifdef OR1200_NO_IC\n`define OR1200_ICCFGR_NCW\t\t3'h0\t// Irrelevant\n`define OR1200_ICCFGR_NCS \t\t4'h0\t// Irrelevant\n`define OR1200_ICCFGR_CBS \t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CWS\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CCRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBIRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBPRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBLRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBFRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBWBRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_RES1\t\t17'h00000\n`else\n`define OR1200_ICCFGR_NCW\t\t3'h0\t// 1 cache way\n`define OR1200_ICCFGR_NCS (`OR1200_ICTAG)\t// Num cache sets\n`define OR1200_ICCFGR_CBS `OR1200_ICLS==4 ? 1'b0: 1'b1\t// 16 byte cache block\n`define OR1200_ICCFGR_CWS\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CCRI\t\t1'b1\t// Cache control reg impl.\n`define OR1200_ICCFGR_CBIRI\t\t1'b1\t// Cache block inv reg impl.\n`define OR1200_ICCFGR_CBPRI\t\t1'b0\t// Cache block prefetch reg not impl.\n`define OR1200_ICCFGR_CBLRI\t\t1'b0\t// Cache block lock reg not impl.\n`define OR1200_ICCFGR_CBFRI\t\t1'b1\t// Cache block flush reg impl.\n`define OR1200_ICCFGR_CBWBRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_RES1\t\t17'h00000\n`endif\n\n// DCFGR fields\n`define OR1200_DCFGR_NDP_BITS\t\t3:0\n`define OR1200_DCFGR_WPCI_BITS\t\t4\n`define OR1200_DCFGR_RES1_BITS\t\t31:5\n\n// DCFGR values\n`ifdef OR1200_DU_HWBKPTS\n`define OR1200_DCFGR_NDP\t\t4'h`OR1200_DU_DVRDCR_PAIRS // # of DVR/DCR pairs\n`ifdef OR1200_DU_DWCR0\n`define OR1200_DCFGR_WPCI\t\t1'b1\n`else\n`define OR1200_DCFGR_WPCI\t\t1'b0\t// WP counters not impl.\n`endif\n`else\n`define OR1200_DCFGR_NDP\t\t4'h0\t// Zero DVR/DCR pairs\n`define OR1200_DCFGR_WPCI\t\t1'b0\t// WP counters not impl.\n`endif\n`define OR1200_DCFGR_RES1\t\t27'd0\n\n///////////////////////////////////////////////////////////////////////////////\n// Boot Address Selection                                                    //\n//                                                                           //\n// Allows a definable boot address, potentially different to the usual reset //\n// vector to allow for power-on code to be run, if desired.                  //\n//                                                                           //\n// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //\n// OR1200_BOOT_PCREG_DEFAULT should be ((OR1200_BOOT_ADR-4)>>2)              //\n//                                                                           //\n// For default reset behavior uncomment the settings under the \"Boot 0x100\"  //\n// comment below.                                                            //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n// Boot from 0xf0000100\n//`define OR1200_BOOT_PCREG_DEFAULT 30'h3c00003f\n//`define OR1200_BOOT_ADR 32'hf0000100\n// Boot from 0x100\n `define OR1200_BOOT_PCREG_DEFAULT 30'h0000003f\n `define OR1200_BOOT_ADR 32'h00000100\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's Exception logic                                    ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  Handles all OR1K exceptions inside CPU block.               ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_except.v,v $\n//\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Major update: \n// Structure reordered and bugs fixed. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\n`define OR1200_EXCEPTFSM_WIDTH 3\n`define OR1200_EXCEPTFSM_IDLE\t`OR1200_EXCEPTFSM_WIDTH'd0\n`define OR1200_EXCEPTFSM_FLU1 \t`OR1200_EXCEPTFSM_WIDTH'd1\n`define OR1200_EXCEPTFSM_FLU2 \t`OR1200_EXCEPTFSM_WIDTH'd2\n`define OR1200_EXCEPTFSM_FLU3 \t`OR1200_EXCEPTFSM_WIDTH'd3\n`define OR1200_EXCEPTFSM_FLU4 \t`OR1200_EXCEPTFSM_WIDTH'd4\n`define OR1200_EXCEPTFSM_FLU5 \t`OR1200_EXCEPTFSM_WIDTH'd5\n\n//\n// Exception recognition and sequencing\n//\n\nmodule or1200_except\n  (\n   // Clock and reset\n   clk, rst, \n   \n   // Internal i/f\n   sig_ibuserr, sig_dbuserr, sig_illegal, sig_align, sig_range, sig_dtlbmiss, \n   sig_dmmufault, sig_int, sig_syscall, sig_trap, sig_itlbmiss, sig_immufault, \n   sig_tick, ex_branch_taken, genpc_freeze, id_freeze, ex_freeze, wb_freeze,  \n   if_stall,  if_pc, id_pc, ex_pc, wb_pc, id_flushpipe, ex_flushpipe, \n   extend_flush, except_flushpipe, except_type, except_start, except_started, \n   except_stop, except_trig, ex_void, abort_mvspr, branch_op, spr_dat_ppc, \n   spr_dat_npc, datain, du_dsr, epcr_we, eear_we, esr_we, pc_we, epcr, eear, \n   du_dmr1, du_hwbkpt, du_hwbkpt_ls_r, esr, sr_we, to_sr, sr, lsu_addr, \n   abort_ex, icpu_ack_i, icpu_err_i, dcpu_ack_i, dcpu_err_i, sig_fp, fpcsr_fpee\n   \n);\n\n//\n// I/O\n//\ninput\t\t\t\tclk;\ninput\t\t\t\trst;\ninput\t\t\t\tsig_ibuserr;\ninput\t\t\t\tsig_dbuserr;\ninput\t\t\t\tsig_illegal;\ninput\t\t\t\tsig_align;\ninput\t\t\t\tsig_range;\ninput\t\t\t\tsig_dtlbmiss;\ninput\t\t\t\tsig_dmmufault;\ninput\t\t\t\tsig_int;\ninput\t\t\t\tsig_syscall;\ninput\t\t\t\tsig_trap;\ninput\t\t\t\tsig_itlbmiss;\ninput\t\t\t\tsig_immufault;\ninput\t\t\t\tsig_tick;\ninput   \t\t\tsig_fp;\ninput    \t\t\tfpcsr_fpee;   \ninput\t\t\t\tex_branch_taken;\ninput\t\t\t\tgenpc_freeze;\ninput\t\t\t\tid_freeze;\ninput\t\t\t\tex_freeze;\ninput\t\t\t\twb_freeze;\ninput\t\t\t\tif_stall;\ninput\t[31:0]\t\tif_pc;\noutput\t[31:0]\t\tid_pc;\noutput  [31:0]      ex_pc;\noutput  [31:0]      wb_pc;\ninput\t[31:0]\t\tdatain;\ninput   [`OR1200_DU_DSR_WIDTH-1:0]     du_dsr;\ninput   [24:0]                       du_dmr1;\ninput\t\t\tdu_hwbkpt;\ninput\t\t\tdu_hwbkpt_ls_r;\ninput\t\t\t\tepcr_we;\ninput\t\t\t\teear_we;\ninput\t\t\t\tesr_we;\ninput\t\t\t\tpc_we;\noutput\t[31:0]\t\t\tepcr;\noutput\t[31:0]\t\t\teear;\noutput\t[`OR1200_SR_WIDTH-1:0]\tesr;\ninput\t[`OR1200_SR_WIDTH-1:0]\tto_sr;\ninput\t\t\t\tsr_we;\ninput\t[`OR1200_SR_WIDTH-1:0]\tsr;\ninput\t[31:0]\t\t\tlsu_addr;\ninput              \tid_flushpipe;\ninput              \tex_flushpipe;\noutput\t\t\t\texcept_flushpipe;\noutput\t\t\t\textend_flush;\noutput\t[`OR1200_EXCEPT_WIDTH-1:0]\texcept_type;\noutput\t\t\t\texcept_start;\noutput\t\t\t\texcept_started;\noutput\t[13:0]\t\texcept_stop;\noutput\t[13:0]\t\texcept_trig;\ninput\t\t\t\tex_void;\ninput   [`OR1200_BRANCHOP_WIDTH-1:0]    branch_op; \noutput\t[31:0]\t\t\tspr_dat_ppc;\noutput\t[31:0]\t\t\tspr_dat_npc;\noutput\t\t\t\tabort_ex;\noutput              abort_mvspr;\ninput\t\t\t\ticpu_ack_i;\ninput\t\t\t\ticpu_err_i;\ninput\t\t\t\tdcpu_ack_i;\ninput\t\t\t\tdcpu_err_i;\n\n//\n// Internal regs and wires\n//\nreg\t[`OR1200_EXCEPT_WIDTH-1:0]\texcept_type /* verilator public */;\nreg\t[31:0]\t\t\tid_pc /* verilator public */;\nreg                 id_pc_val;\nreg\t[31:0]\t\t\tex_pc /* verilator public */;\nreg                 ex_pc_val;\nreg\t[31:0]\t\t\twb_pc /* verilator public */;\nreg [31:0]          dl_pc;\nreg\t[31:0]\t\t\tepcr;\nreg\t[31:0]\t\t\teear;\nreg\t[`OR1200_SR_WIDTH-1:0]\t\tesr;\nreg\t[2:0]\t\t\tid_exceptflags;\nreg\t[2:0]\t\t\tex_exceptflags;\nreg\t[`OR1200_EXCEPTFSM_WIDTH-1:0]\tstate;\nreg\t\t\t\textend_flush;\nreg\t\t\t\textend_flush_last;\nreg\t\t\t\tex_dslot /* verilator public */;\nreg\t\t\t\tdelayed1_ex_dslot;\nreg\t\t\t\tdelayed2_ex_dslot;\nwire\t\t\t\texcept_started;\nwire\t\t\t\texcept_flushpipe /* verilator public */;\nreg\t[2:0]\t\t\tdelayed_iee;\nreg\t[2:0]\t\t\tdelayed_tee;\nwire\t\t\t\tint_pending;\nwire\t\t\t\ttick_pending;\nwire    \t\t\tfp_pending;\n   \nreg trace_trap      ;\nreg ex_freeze_prev;\nreg sr_ted_prev;\nreg dsr_te_prev;\nreg dmr1_st_prev    ;\nreg dmr1_bt_prev    ;\nwire dsr_te = ex_freeze_prev ? dsr_te_prev : du_dsr[`OR1200_DU_DSR_TE];\nwire sr_ted = ex_freeze_prev ? sr_ted_prev : sr[`OR1200_SR_TED];\nwire dmr1_st = ex_freeze_prev ? dmr1_st_prev: du_dmr1[`OR1200_DU_DMR1_ST] ;\nwire dmr1_bt = ex_freeze_prev ? dmr1_bt_prev: du_dmr1[`OR1200_DU_DMR1_BT] ;\n\n//\n// Simple combinatorial logic\n//\nassign except_started = extend_flush & except_start;\n   \nassign except_start = (except_type != `OR1200_EXCEPT_NONE) & extend_flush;\n   \nassign int_pending = sig_int & (sr[`OR1200_SR_IEE] | \n\t\t\t\t(sr_we & to_sr[`OR1200_SR_IEE])) \n\t\t    & id_pc_val & delayed_iee[2] & ~ex_freeze & ~ex_branch_taken\n\t\t     & ~ex_dslot & ~(sr_we & ~to_sr[`OR1200_SR_IEE]);\n   \nassign tick_pending = sig_tick & (sr[`OR1200_SR_TEE] | \n\t\t\t\t  (sr_we & to_sr[`OR1200_SR_TEE])) & id_pc_val\n\t\t      & delayed_tee[2] & ~ex_freeze & ~ex_branch_taken \n\t\t      & ~ex_dslot & ~(sr_we & ~to_sr[`OR1200_SR_TEE]);\n\nassign fp_pending = sig_fp & fpcsr_fpee & ~ex_freeze & ~ex_branch_taken \n\t\t    & ~ex_dslot;\n   \n// Abort write into RF by load & other instructions   \nassign abort_ex = sig_dbuserr | sig_dmmufault | sig_dtlbmiss | sig_align | \n\t\t  sig_illegal | ((du_hwbkpt | trace_trap) & ex_pc_val \n\t\t\t\t & !sr_ted & !dsr_te);\n\n// abort spr read/writes   \nassign abort_mvspr  = sig_illegal | ((du_hwbkpt | trace_trap) & ex_pc_val \n\t\t\t\t     & !sr_ted & !dsr_te) ; \nassign spr_dat_ppc = wb_pc;\n   \nassign spr_dat_npc = ex_void ? id_pc : ex_pc;\n\n//\n// Order defines exception detection priority\n//\nassign except_trig = {\n\t\t      ex_exceptflags[1]\t& ~du_dsr[`OR1200_DU_DSR_IME],\n\t\t      ex_exceptflags[0]\t& ~du_dsr[`OR1200_DU_DSR_IPFE],\n\t\t      ex_exceptflags[2]\t& ~du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t      sig_illegal       & ~du_dsr[`OR1200_DU_DSR_IIE],\n\t\t      sig_align\t\t& ~du_dsr[`OR1200_DU_DSR_AE],\n\t\t      sig_dtlbmiss\t& ~du_dsr[`OR1200_DU_DSR_DME],\n\t\t      sig_trap\t\t& ~du_dsr[`OR1200_DU_DSR_TE],\n\t\t      sig_syscall       & ~du_dsr[`OR1200_DU_DSR_SCE] & ~ex_freeze,\n\t\t      sig_dmmufault\t& ~du_dsr[`OR1200_DU_DSR_DPFE],\n\t\t      sig_dbuserr\t& ~du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t      sig_range\t\t& ~du_dsr[`OR1200_DU_DSR_RE],\n\t\t      fp_pending\t& ~du_dsr[`OR1200_DU_DSR_FPE],\n\t\t      int_pending \t& ~du_dsr[`OR1200_DU_DSR_IE],\n\t\t      tick_pending\t& ~du_dsr[`OR1200_DU_DSR_TTE]\n\t\t      };\n\nwire    trace_cond  = !ex_freeze && !ex_void && (1'b0\n`ifdef OR1200_DU_DMR1_ST\n    ||  dmr1_st\n`endif\n`ifdef OR1200_DU_DMR1_BT\n    ||  ((branch_op != `OR1200_BRANCHOP_NOP) && (branch_op != `OR1200_BRANCHOP_RFE) && dmr1_bt)\n`endif\n    );\n\nassign except_stop = {\n\t\t\ttick_pending\t\t& du_dsr[`OR1200_DU_DSR_TTE],\n\t\t\tint_pending \t\t& du_dsr[`OR1200_DU_DSR_IE],\n\t\t\tex_exceptflags[1]\t& du_dsr[`OR1200_DU_DSR_IME],\n\t\t\tex_exceptflags[0]\t& du_dsr[`OR1200_DU_DSR_IPFE],\n\t\t\tex_exceptflags[2]\t& du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t\tsig_illegal\t\t& du_dsr[`OR1200_DU_DSR_IIE],\n\t\t\tsig_align\t\t& du_dsr[`OR1200_DU_DSR_AE],\n\t\t\tsig_dtlbmiss\t\t& du_dsr[`OR1200_DU_DSR_DME],\n\t\t\tsig_dmmufault\t\t& du_dsr[`OR1200_DU_DSR_DPFE],\n\t\t\tsig_dbuserr\t\t& du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t\tsig_range\t\t& du_dsr[`OR1200_DU_DSR_RE],\n\t\t\tsig_trap\t\t& du_dsr[`OR1200_DU_DSR_TE],\n\t\t        fp_pending  \t\t& du_dsr[`OR1200_DU_DSR_FPE],\n\t\t\tsig_syscall\t\t& du_dsr[`OR1200_DU_DSR_SCE] & ~ex_freeze\n\t\t};\n\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\ttrace_trap  <=  1'b0 ;\n\tend \n\telse if (!(trace_trap && !ex_pc_val)) begin\n\t\ttrace_trap  <=  trace_cond & !dsr_te & !sr_ted ;\n\tend\nend\n\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n        ex_freeze_prev  <=  1'b0 ;\n        sr_ted_prev     <=  1'b0 ;\n        dsr_te_prev     <=  1'b0 ;\n        dmr1_st_prev    <=  1'b0 ;\n        dmr1_bt_prev    <=  1'b0 ;\n    end \n    else begin\n        ex_freeze_prev  <=  ex_freeze ;\n        if (!ex_freeze_prev || ex_void) begin\n            sr_ted_prev     <=  sr     [`OR1200_SR_TED    ] ;\n            dsr_te_prev     <=  du_dsr [`OR1200_DU_DSR_TE ] ;\n            dmr1_st_prev    <=  du_dmr1[`OR1200_DU_DMR1_ST] ;\n            dmr1_bt_prev    <=  du_dmr1[`OR1200_DU_DMR1_BT] ;\n        end\n    end\nend\n\n`ifdef verilator\n   // Function to access wb_pc (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [31:0] get_wb_pc;\n      // verilator public\n      get_wb_pc = wb_pc;\n   endfunction // get_wb_pc\n\n   // Function to access id_pc (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [31:0] get_id_pc;\n      // verilator public\n      get_id_pc = id_pc;\n   endfunction // get_id_pc\n\n   // Function to access ex_pc (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [31:0] get_ex_pc;\n      // verilator public\n      get_ex_pc = ex_pc;\n   endfunction // get_ex_pc\n   // Function to access except_type[3:0] (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [3:0] get_except_type;\n      // verilator public\n      get_except_type = except_type;\n   endfunction // get_except_type\n   \n`endif\n   \n   \n//\n// PC and Exception flags pipelines\n//\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\tid_pc <=  32'd0;\n        id_pc_val <=  1'b0 ;\n\t\tid_exceptflags <=  3'b000;\n\tend\n\telse if (id_flushpipe) begin\n        id_pc_val <=  1'b0 ;\n\t\tid_exceptflags <=  3'b000;\n\tend\n\telse if (!id_freeze) begin\n\t\tid_pc <=  if_pc;\n        id_pc_val <=  1'b1 ;\n\t\tid_exceptflags <=  { sig_ibuserr, sig_itlbmiss, sig_immufault };\n\tend\nend\n\n//\n// delayed_iee\n//\n// SR[IEE] should not enable interrupts right away\n// when it is restored with l.rfe. Instead delayed_iee\n// together with SR[IEE] enables interrupts once\n// pipeline is again ready.\n//\nalways @(`OR1200_RST_EVENT rst or posedge clk)\n\tif (rst == `OR1200_RST_VALUE)\n\t\tdelayed_iee <=  3'b000;\n\telse if (!sr[`OR1200_SR_IEE])\n\t\tdelayed_iee <=  3'b000;\n\telse\n\t\tdelayed_iee <=  {delayed_iee[1:0], 1'b1};\n\n//\n// delayed_tee\n//\n// SR[TEE] should not enable tick exceptions right away\n// when it is restored with l.rfe. Instead delayed_tee\n// together with SR[TEE] enables tick exceptions once\n// pipeline is again ready.\n//\nalways @(`OR1200_RST_EVENT rst or posedge clk)\n\tif (rst == `OR1200_RST_VALUE)\n\t\tdelayed_tee <=  3'b000;\n\telse if (!sr[`OR1200_SR_TEE])\n\t\tdelayed_tee <=  3'b000;\n\telse\n\t\tdelayed_tee <=  {delayed_tee[1:0], 1'b1};\n\n//\n// PC and Exception flags pipelines\n//\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\tex_dslot <=  1'b0;\n\t\tex_pc <=  32'd0;\n                ex_pc_val <=  1'b0 ;\n\t\tex_exceptflags <=  3'b000;\n\t\tdelayed1_ex_dslot <=  1'b0;\n\t\tdelayed2_ex_dslot <=  1'b0;\n\tend\n\telse if (ex_flushpipe) begin\n\t\tex_dslot <=  1'b0;\n                ex_pc_val <=  1'b0 ;\n\t\tex_exceptflags <=  3'b000;\n\t\tdelayed1_ex_dslot <=  1'b0;\n\t\tdelayed2_ex_dslot <=  1'b0;\n\tend\n\telse if (!ex_freeze & id_freeze) begin\n\t\tex_dslot <=  1'b0;\n\t\tex_pc <=  id_pc;\n                ex_pc_val <=  id_pc_val ;\n\t\tex_exceptflags <=  3'b000;\n\t\tdelayed1_ex_dslot <=  ex_dslot;\n\t\tdelayed2_ex_dslot <=  delayed1_ex_dslot;\n\tend\n\telse if (!ex_freeze) begin\n\t\tex_dslot <=  ex_branch_taken;\n\t\tex_pc <=  id_pc;\n                ex_pc_val <=  id_pc_val ;\n\t\tex_exceptflags <=  id_exceptflags;\n\t\tdelayed1_ex_dslot <=  ex_dslot;\n\t\tdelayed2_ex_dslot <=  delayed1_ex_dslot;\n\tend\nend\n\n//\n// PC and Exception flags pipelines\n//\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\twb_pc <=  32'd0;\n        dl_pc <=  32'd0;\n\tend\n\telse if (!wb_freeze) begin\n\t\twb_pc <=  ex_pc;\n        dl_pc <=  wb_pc;\n\tend\nend\n\n//\n// We have started execution of exception handler:\n//  1. Asserted for 3 clock cycles\n//  2. Don't execute any instruction that is still in pipeline and is not part of exception handler\n//\nassign except_flushpipe = |except_trig & ~|state;\n\n//\n// Exception FSM that sequences execution of exception handler\n//\n// except_type signals which exception handler we start fetching in:\n//  1. Asserted in next clock cycle after exception is recognized\n//\n   always @(posedge clk or `OR1200_RST_EVENT rst) begin\n      if (rst == `OR1200_RST_VALUE) begin\n\t state <=  `OR1200_EXCEPTFSM_IDLE;\n\t except_type <=  `OR1200_EXCEPT_NONE;\n\t extend_flush <=  1'b0;\n\t epcr <=  32'b0;\n\t eear <=  32'b0;\n\t esr <=  {2'h1, {`OR1200_SR_WIDTH-3{1'b0}}, 1'b1};\n\t extend_flush_last <=  1'b0;\n      end\n      else begin\n`ifdef OR1200_CASE_DEFAULT\n\t case (state)\t// synopsys parallel_case\n`else\n\t   case (state)\t// synopsys full_case parallel_case\n`endif\n\t     `OR1200_EXCEPTFSM_IDLE:\n\t       if (except_flushpipe) begin\n\t\t  state <=  `OR1200_EXCEPTFSM_FLU1;\n\t\t  extend_flush <=  1'b1;\n\t\t  esr <=  sr_we ? to_sr : sr;\n\t\t  casez (except_trig)\n`ifdef OR1200_EXCEPT_ITLBMISS\n\t\t    14'b1?_????_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_ITLBMISS;\n\t\t       eear <=  ex_dslot ? \n\t\t\t       ex_pc : ex_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_IPF\n\t\t    14'b01_????_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_IPF;\n\t\t       eear <=  ex_dslot ? \n\t\t\t       ex_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_BUSERR\n\t\t    14'b00_1???_????_????: begin\t// Insn. Bus Error\n\t\t       except_type <=  `OR1200_EXCEPT_BUSERR;\n\t\t       eear <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_ILLEGAL\n\t\t    14'b00_01??_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_ILLEGAL;\n\t\t       eear <=  ex_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_ALIGN\n\t\t    14'b00_001?_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_ALIGN;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_DTLBMISS\n\t\t    14'b00_0001_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_DTLBMISS;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       dl_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_TRAP\t\t\t\n\t\t    14'b00_0000_1???_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_TRAP;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_SYSCALL\n\t\t    14'b00_0000_01??_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_SYSCALL;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_DPF\n\t\t    14'b00_0000_001?_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_DPF;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       dl_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_BUSERR\n\t\t    14'b00_0000_0001_????: begin\t// Data Bus Error\n\t\t       except_type <=  `OR1200_EXCEPT_BUSERR;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       dl_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_RANGE\n\t\t    14'b00_0000_0000_1???: begin\n\t\t       except_type <=  `OR1200_EXCEPT_RANGE;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_FLOAT\n\t\t    14'b00_0000_0000_01??: begin\n\t\t       except_type <=  `OR1200_EXCEPT_FLOAT;\n\t\t       epcr <=  id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_INT\n\t\t    14'b00_0000_0000_001?: begin\n\t\t       except_type <=  `OR1200_EXCEPT_INT;\n\t\t       epcr <=  id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_TICK\n\t\t    14'b00_0000_0000_0001: begin\n\t\t       except_type <=  `OR1200_EXCEPT_TICK;\n\t\t       epcr <=  id_pc;\n\t\t    end\n`endif\n\t\t    default:\n\t\t      except_type <=  `OR1200_EXCEPT_NONE;\n\t\t  endcase\n\t       end\n\t       else if (pc_we) begin\n\t\t  state <=  `OR1200_EXCEPTFSM_FLU1;\n\t\t  extend_flush <=  1'b1;\n\t       end\n\t       else begin\n\t\t  if (epcr_we)\n\t\t    epcr <=  datain;\n\t\t  if (eear_we)\n\t\t    eear <=  datain;\n\t\t  if (esr_we)\n\t\t    esr <=  {datain[`OR1200_SR_WIDTH-1], 1'b1, datain[`OR1200_SR_WIDTH-3:0]};\n\t       end\n\t     `OR1200_EXCEPTFSM_FLU1:\n\t       if (icpu_ack_i | icpu_err_i | genpc_freeze)\n\t\t state <=  `OR1200_EXCEPTFSM_FLU2;\n\t     `OR1200_EXCEPTFSM_FLU2:\n`ifdef OR1200_EXCEPT_TRAP\n\t       if (except_type == `OR1200_EXCEPT_TRAP) begin\n\t\t  state <=  `OR1200_EXCEPTFSM_IDLE;\n\t\t  extend_flush <=  1'b0;\n\t\t  extend_flush_last <=  1'b0;\n\t\t  except_type <=  `OR1200_EXCEPT_NONE;\n\t       end\n               else\n`endif\n\t\t state <=  `OR1200_EXCEPTFSM_FLU3;\n\t     `OR1200_EXCEPTFSM_FLU3:\n\t       begin\n\t\t  state <=  `OR1200_EXCEPTFSM_FLU4;\n\t       end\n\t     `OR1200_EXCEPTFSM_FLU4: begin\n\t\tstate <=  `OR1200_EXCEPTFSM_FLU5;\n\t\textend_flush <=  1'b0;\n\t\textend_flush_last <=  1'b0; // damjan\n\t     end\n`ifdef OR1200_CASE_DEFAULT\n\t     default: begin\n`else\n\t\t`OR1200_EXCEPTFSM_FLU5: begin\n`endif\n\t\t   if (!if_stall && !id_freeze) begin\n\t\t      state <=  `OR1200_EXCEPTFSM_IDLE;\n\t\t      except_type <=  `OR1200_EXCEPT_NONE;\n\t\t      extend_flush_last <=  1'b0;\n\t\t   end\n\t\tend\n\t   endcase\n\t end\n   end\n\nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's Top level multiplier, divider and MAC              ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://opencores.org/project,or1k                           ////\n////                                                              ////\n////  Description                                                 ////\n////  Multiplier is 32x32 however multiply instructions only      ////\n////  use lower 32 bits of the result. MAC is 32x32=64+64.        ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make signed division better, w/o negating the operands   ////\n////   - implement non-serial divider that is synthesizable       ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////      - Julius Baxter, julius@opencores.org                   ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000, 2010 Authors and OPENCORES.ORG           ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// CVS Revision History\n//\n// $Log: or1200_mult_mac.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Minor update: \n// Bugs fixed. \n//\n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_mult_mac(\n\t\t       // Clock and reset\n\t\t       clk, rst,\n\n\t\t       // Multiplier/MAC interface\n\t\t       ex_freeze, id_macrc_op, macrc_op, a, b, mac_op, alu_op, \n\t\t       result, mult_mac_stall,\n\n\t\t       // SPR interface\n\t\t       spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o\n\t\t       );\n\n   parameter width = `OR1200_OPERAND_WIDTH;\n\n   //\n   // I/O\n   //\n\n   //\n   // Clock and reset\n   //\n   input\t\t\t\tclk;\n   input\t\t\t\trst;\n\n   //\n   // Multiplier/MAC interface\n   //\n   input\t\t\t\tex_freeze;\n   input\t\t\t\tid_macrc_op;\n   input\t\t\t\tmacrc_op;\n   input [width-1:0] \t\t\ta;\n   input [width-1:0] \t\t\tb;\n   input [`OR1200_MACOP_WIDTH-1:0] \tmac_op;\n   input [`OR1200_ALUOP_WIDTH-1:0] \talu_op;\n   output [width-1:0] \t\t\tresult;\n   output\t\t\t\tmult_mac_stall;\n\n   //\n   // SPR interface\n   //\n   input\t\t\t\tspr_cs;\n   input\t\t\t\tspr_write;\n   input [31:0] \t\t\tspr_addr;\n   input [31:0] \t\t\tspr_dat_i;\n   output [31:0] \t\t\tspr_dat_o;\n\n   //\n   // Internal wires and regs\n   //\n   reg [width-1:0] \t\t\tresult;\n   reg \t\t\t\t\tex_freeze_r;\n`ifdef OR1200_MULT_IMPLEMENTED\n   reg [2*width-1:0] \t\t\tmul_prod_r;\n   wire \t\t\t\talu_op_smul;   \n   wire \t\t\t\talu_op_umul;   \n   wire \t\t\t\talu_op_mul;      \n `ifdef OR1200_MULT_SERIAL\n   reg [5:0] \t\t\t\tserial_mul_cnt;   \n   reg \t\t\t\t\tmul_free;   \n `endif\n`else\n   wire [2*width-1:0] \t\t\tmul_prod_r;\n`endif\n   wire [2*width-1:0] \t\t\tmul_prod;\n   wire \t\t\t\tmul_stall;\n   reg [1:0] \t\t\t\tmul_stall_count;   \n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op;\n`ifdef OR1200_MAC_IMPLEMENTED\n   reg [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r1;\n   reg [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r2;\n   reg [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r3;\n   reg \t\t\t\t\tmac_stall_r;\n   reg [63:0] \t\t\t\tmac_r;\n`else\n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r1;\n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r2;\n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r3;\n   wire \t\t\t\tmac_stall_r;\n   wire [63:0] \t\t\t\tmac_r;\n`endif\n   wire [width-1:0] \t\t\tx;\n   wire [width-1:0] \t\t\ty;\n   wire \t\t\t\tspr_maclo_we;\n   wire \t\t\t\tspr_machi_we; \n   wire \t\t\t\talu_op_div;  \n   wire \t\t\t\talu_op_udiv;\n   wire \t\t\t\talu_op_sdiv;\n   reg \t\t\t\t\tdiv_free;\n   wire \t\t\t        div_stall;\n`ifdef OR1200_DIV_IMPLEMENTED\n `ifdef OR1200_DIV_SERIAL\n   reg [2*width-1:0] \t\t\tdiv_quot_r;   \n   wire [width-1:0] \t\t\tdiv_tmp;\n   reg [5:0] \t\t\t\tdiv_cntr;\n `else\n   reg [width-1:0] \t\t\tdiv_quot_r;      \n   reg [width-1:0] \t\t\tdiv_quot_generic;   \n `endif   \n`endif\n\n   //\n   // Combinatorial logic\n   //\n`ifdef OR1200_MULT_IMPLEMENTED\n   assign alu_op_smul = (alu_op == `OR1200_ALUOP_MUL);\n   assign alu_op_umul = (alu_op == `OR1200_ALUOP_MULU);\n   assign alu_op_mul = alu_op_smul | alu_op_umul;\n`endif   \n`ifdef OR1200_MAC_IMPLEMENTED\n   assign spr_maclo_we = spr_cs & spr_write & spr_addr[`OR1200_MAC_ADDR];\n   assign spr_machi_we = spr_cs & spr_write & !spr_addr[`OR1200_MAC_ADDR];\n   assign spr_dat_o = spr_addr[`OR1200_MAC_ADDR] ? mac_r[31:0] : mac_r[63:32];\n`else\n   assign spr_maclo_we = 1'b0;\n   assign spr_machi_we = 1'b0;\n   assign spr_dat_o = 32'h0000_0000;\n`endif\n`ifdef OR1200_DIV_IMPLEMENTED\n   assign alu_op_sdiv = (alu_op == `OR1200_ALUOP_DIV);\n   assign alu_op_udiv = (alu_op == `OR1200_ALUOP_DIVU);\n   assign alu_op_div = alu_op_sdiv | alu_op_udiv;   \n`else\n   assign alu_op_udiv = 1'b0;\n   assign alu_op_sdiv = 1'b0;\n   assign alu_op_div = 1'b0;   \n`endif\n\n   assign x = (alu_op_sdiv | alu_op_smul) & a[31] ? ~a + 32'b1 : \n\t      alu_op_div | alu_op_mul | (|mac_op) ? a : 32'd0;\n   assign y = (alu_op_sdiv | alu_op_smul) & b[31] ? ~b + 32'b1 : \n\t      alu_op_div | alu_op_mul | (|mac_op) ? b : 32'd0;\n\n   // Used to indicate when we should check for new multiply or MAC ops\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       ex_freeze_r <= 1'b1;\n     else\n       ex_freeze_r <= ex_freeze;\n\n   //\n   // Select result of current ALU operation to be forwarded\n   // to next instruction and to WB stage\n   //\n   always @*\n     casez(alu_op)\t// synopsys parallel_case\n`ifdef OR1200_DIV_IMPLEMENTED\n       `OR1200_ALUOP_DIV: begin\n\t  result = a[31] ^ b[31] ? ~div_quot_r[31:0] + 32'd1 : div_quot_r[31:0];\n       end\n       `OR1200_ALUOP_DIVU: begin\n\t  result = div_quot_r[31:0];\n       end\n`endif\n`ifdef OR1200_MULT_IMPLEMENTED    \n       `OR1200_ALUOP_MUL: begin\n\t  result = a[31] ^ b[31] ? ~mul_prod_r[31:0] + 32'd1 : mul_prod_r[31:0];\n       end\n\t `OR1200_ALUOP_MULU: begin\n\t  result = mul_prod_r[31:0];\n       end\n`endif    \n       default:\n`ifdef OR1200_MAC_IMPLEMENTED      \n `ifdef OR1200_MAC_SHIFTBY\n\t result = mac_r[`OR1200_MAC_SHIFTBY+31:`OR1200_MAC_SHIFTBY];\n `else\n       result = mac_r[31:0];\n `endif\n`else\n       result = {width{1'b0}};    \n`endif    \n     endcase\n\n`ifdef OR1200_MULT_IMPLEMENTED\n `ifdef OR1200_MULT_SERIAL\n\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE) begin\n\tmul_prod_r <=  64'h0000_0000_0000_0000;\n\tserial_mul_cnt <= 6'd0;\n\tmul_free <= 1'b1;\n\t\n     end\n     else if (|serial_mul_cnt) begin\n\tserial_mul_cnt <= serial_mul_cnt - 6'd1;\n\tif (mul_prod_r[0])\n\t  mul_prod_r[(width*2)-1:width-1] <= mul_prod_r[(width*2)-1:width] + x;\n\telse\n\t  mul_prod_r[(width*2)-1:width-1] <= {1'b0,mul_prod_r[(width*2)-1:\n\t\t\t\t\t\t\t      width]};\n\tmul_prod_r[width-2:0] <= mul_prod_r[width-1:1];\n\t\n     end\n     else if (alu_op_mul && mul_free) begin\n\tmul_prod_r <= {32'd0, y};\n\tmul_free <= 0;\n\tserial_mul_cnt <= 6'b10_0000;\n     end\n     else if (!ex_freeze | mul_free) begin\n\tmul_free <= 1'b1;\t\n     end\n\n   assign mul_stall = (|serial_mul_cnt) | (alu_op_mul & !ex_freeze_r);\n   \n `else\n   \n   //\n   // Instantiation of the multiplier\n   //\n  `ifdef OR1200_ASIC_MULTP2_32X32\n   or1200_amultp2_32x32 or1200_amultp2_32x32(\n\t\t\t\t\t     .X(x),\n\t\t\t\t\t     .Y(y),\n\t\t\t\t\t     .RST(rst),\n\t\t\t\t\t     .CLK(clk),\n\t\t\t\t\t     .P(mul_prod)\n\t\t\t\t\t     );\n  `else // OR1200_ASIC_MULTP2_32X32\n   or1200_gmultp2_32x32 or1200_gmultp2_32x32(\n\t\t\t\t\t     .X(x),\n\t\t\t\t\t     .Y(y),\n\t\t\t\t\t     .RST(rst),\n\t\t\t\t\t     .CLK(clk),\n\t\t\t\t\t     .P(mul_prod)\n\t\t\t\t\t     );\n  `endif // OR1200_ASIC_MULTP2_32X32   \n   \n   //\n   // Registered output from the multiplier\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE) begin\n\tmul_prod_r <=  64'h0000_0000_0000_0000;\n     end\n     else begin\n\tmul_prod_r <=  mul_prod[63:0];\n     end\n\n   //\n   // Generate stall signal during multiplication\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE)\n       mul_stall_count <= 0;\n     else if (!(|mul_stall_count))\n       mul_stall_count <= {mul_stall_count[0], alu_op_mul & !ex_freeze_r};\n     else \n       mul_stall_count <= {mul_stall_count[0],1'b0};\n       \n   assign mul_stall = (|mul_stall_count) | \n\t\t      (!(|mul_stall_count) & alu_op_mul & !ex_freeze_r);\n   \n `endif // !`ifdef OR1200_MULT_SERIAL   \n   \n`else // OR1200_MULT_IMPLEMENTED\n   assign mul_prod = {2*width{1'b0}};\n   assign mul_prod_r = {2*width{1'b0}};\n   assign mul_stall = 0;   \n`endif // OR1200_MULT_IMPLEMENTED\n\n`ifdef OR1200_MAC_IMPLEMENTED\n   \n   //\n   // Propagation of l.mac opcode, only register it for one cycle\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       mac_op_r1 <=  `OR1200_MACOP_WIDTH'b0;\n     else\n       mac_op_r1 <=  !ex_freeze_r ? mac_op : `OR1200_MACOP_WIDTH'b0;\n\n   //\n   // Propagation of l.mac opcode\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       mac_op_r2 <=  `OR1200_MACOP_WIDTH'b0;\n     else\n       mac_op_r2 <=  mac_op_r1;\n\n   //\n   // Propagation of l.mac opcode\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       mac_op_r3 <=  `OR1200_MACOP_WIDTH'b0;\n     else\n       mac_op_r3 <=  mac_op_r2;\n\n   //\n   // Implementation of MAC\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE)\n       mac_r <=  64'h0000_0000_0000_0000;\n `ifdef OR1200_MAC_SPR_WE\n     else if (spr_maclo_we)\n       mac_r[31:0] <=  spr_dat_i;\n     else if (spr_machi_we)\n       mac_r[63:32] <=  spr_dat_i;\n `endif\n     else if (mac_op_r3 == `OR1200_MACOP_MAC)\n       mac_r <=  mac_r + mul_prod_r;\n     else if (mac_op_r3 == `OR1200_MACOP_MSB)\n       mac_r <=  mac_r - mul_prod_r;\n     else if (macrc_op && !ex_freeze)\n       mac_r <=  64'h0000_0000_0000_0000;\n\n   //\n   // Stall CPU if l.macrc is in ID and MAC still has to process l.mac \n   // instructions in EX stage (e.g. inside multiplier)\n   // This stall signal is also used by the divider.\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE)\n       mac_stall_r <=  1'b0;\n     else\n       mac_stall_r <=  (|mac_op | (|mac_op_r1) | (|mac_op_r2)) & \n\t\t       (id_macrc_op | mac_stall_r);\n   \n`else // OR1200_MAC_IMPLEMENTED\n   assign mac_stall_r = 1'b0;\n   assign mac_r = {2*width{1'b0}};\n   assign mac_op_r1 = `OR1200_MACOP_WIDTH'b0;\n   assign mac_op_r2 = `OR1200_MACOP_WIDTH'b0;\n   assign mac_op_r3 = `OR1200_MACOP_WIDTH'b0;\n`endif // OR1200_MAC_IMPLEMENTED\n\n`ifdef OR1200_DIV_IMPLEMENTED   \n   \n   //\n   // Serial division\n   //\n `ifdef OR1200_DIV_SERIAL\n   assign div_tmp = div_quot_r[63:32] - y;   \n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE) begin\n\tdiv_quot_r <=  64'h0000_0000_0000_0000;\n\tdiv_free <=  1'b1;\n\tdiv_cntr <=  6'b00_0000;\n     end\n     else if (|div_cntr) begin\n\tif (div_tmp[31])\n\t  div_quot_r <=  {div_quot_r[62:0], 1'b0};\n\telse\n\t  div_quot_r <=  {div_tmp[30:0], div_quot_r[31:0], 1'b1};\n\tdiv_cntr <=  div_cntr - 6'd1;\n     end\n     else if (alu_op_div && div_free) begin\n\tdiv_quot_r <=  {31'b0, x[31:0], 1'b0};\n\tdiv_cntr <=  6'b10_0000;\n\tdiv_free <=  1'b0;\n     end\n     else if (div_free | !ex_freeze) begin\n\tdiv_free <=  1'b1;\n     end\n\n   assign div_stall = (|div_cntr) | (!ex_freeze_r & alu_op_div);\n\n\n `else // !`ifdef OR1200_DIV_SERIAL\n\n   // Full divider\n   // TODO: Perhaps provide module that can be technology dependent.\n   always @(`OR1200_RST_EVENT rst or posedge clk) begin     \n      if (rst == `OR1200_RST_VALUE) begin\n\t div_quot_r <=  32'd0;\t   \n\t div_quot_generic <= 32'd0;\t   \n      end\n      else begin\n\t if (alu_op_udiv & !(|y)) // unsigned divide by 0 - force to MAX\n\t   div_quot_generic[31:0] <= 32'hffff_ffff;\t   \n\t else if (alu_op_div)\n\t   div_quot_generic[31:0] <= x / y;\n      end\n\n      // Add any additional statges of pipelining as required here. Ensure\n      // ends with div_quot_r.\n      // Then add logic to ensure div_stall stays high for as long as the\n      // division should take.      \n      \n      div_quot_r[31:0] <= div_quot_generic;\n\n   end     \n   \n   assign div_stall = 0;\n   \n `endif   \n\n`else // !`ifdef OR1200_DIV_IMPLEMENTED\n\n   assign div_stall = 0;\n\n`endif // !`ifdef OR1200_DIV_IMPLEMENTED\n   \n   \n   //   \n   // Stall output\n   //\n   assign mult_mac_stall = mac_stall_r | div_stall | mul_stall;\n   \nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's interface to SPRs                                  ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  Decoding of SPR addresses and access to SPRs                ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_sprs.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Major update: \n// Structure reordered and bugs fixed. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_sprs(\n\t\t   // Clk & Rst\n\t\t   clk, rst,\n\n\t\t   // Internal CPU interface\n\t\t   flagforw, flag_we, flag, cyforw, cy_we, carry,\n\t\t   addrbase, addrofs, dat_i, branch_op, ex_spr_read, \n\t\t   ex_spr_write, \n\t\t   epcr, eear, esr, except_started,\n\t\t   to_wbmux, epcr_we, eear_we, esr_we, pc_we, sr_we, to_sr, sr,\n\t\t   spr_dat_cfgr, spr_dat_rf, spr_dat_npc, spr_dat_ppc, \n\t\t   spr_dat_mac,\n\t\t   \n\t\t   boot_adr_sel_i,\n\n\t\t   // Floating point SPR input\n\t\t   fpcsr, fpcsr_we, spr_dat_fpu,\n\n\t\t   // From/to other RISC units\n\t\t   spr_dat_pic, spr_dat_tt, spr_dat_pm,\n\t\t   spr_dat_dmmu, spr_dat_immu, spr_dat_du,\n\t\t   spr_addr, spr_dat_o, spr_cs, spr_we,\n\n\t\t   du_addr, du_dat_du, du_read,\n\t\t   du_write, du_dat_cpu\n\n\t\t   );\n\n   parameter width = `OR1200_OPERAND_WIDTH;\n\n   //\n   // I/O Ports\n   //\n\n   //\n   // Internal CPU interface\n   //\n   input\t\t\t\tclk; \t\t// Clock\n   input \t\t\t\trst;\t\t// Reset\n   input \t\t\t\tflagforw;\t// From ALU\n   input \t\t\t\tflag_we;\t// From ALU\n   output \t\t\t\tflag;\t\t// SR[F]\n   input \t\t\t\tcyforw;\t\t// From ALU\n   input \t\t\t\tcy_we;\t\t// From ALU\n   output \t\t\t\tcarry;\t\t// SR[CY]\n   input [width-1:0] \t\t\taddrbase;\t// SPR base address\n   input [15:0] \t\t\taddrofs;\t// SPR offset\n   input [width-1:0] \t\t\tdat_i;\t\t// SPR write data\n   input \t\t\t\tex_spr_read;\t// l.mfspr in EX\n   input \t\t\t\tex_spr_write;\t// l.mtspr in EX\n   input [`OR1200_BRANCHOP_WIDTH-1:0] \tbranch_op;\t// Branch operation\n   input [width-1:0] \t\t\tepcr /* verilator public */;// EPCR0\n   input [width-1:0] \t\t\teear /* verilator public */;// EEAR0\n   input [`OR1200_SR_WIDTH-1:0] \tesr /* verilator public */; // ESR0\n   input \t\t\t\texcept_started; // Exception was started\n   output [width-1:0] \t\t\tto_wbmux;\t// For l.mfspr\n   output\t\t\t\tepcr_we;\t// EPCR0 write enable\n   output\t\t\t\teear_we;\t// EEAR0 write enable\n   output\t\t\t\tesr_we;\t\t// ESR0 write enable\n   output\t\t\t\tpc_we;\t\t// PC write enable\n   output \t\t\t\tsr_we;\t\t// Write enable SR\n   output [`OR1200_SR_WIDTH-1:0] \tto_sr;\t\t// Data to SR\n   output [`OR1200_SR_WIDTH-1:0] \tsr /* verilator public */;// SR\n   input [31:0] \t\t\tspr_dat_cfgr;\t// Data from CFGR\n   input [31:0] \t\t\tspr_dat_rf;\t// Data from RF\n   input [31:0] \t\t\tspr_dat_npc;\t// Data from NPC\n   input [31:0] \t\t\tspr_dat_ppc;\t// Data from PPC   \n   input [31:0] \t\t\tspr_dat_mac;\t// Data from MAC\n   input\t\t\t\tboot_adr_sel_i;\n\n   input [`OR1200_FPCSR_WIDTH-1:0] \tfpcsr;\t// FPCSR\n   output \t\t\t\tfpcsr_we;\t// Write enable FPCSR   \n   input [31:0] \t\t\tspr_dat_fpu;    // Data from FPU\n   \n   //\n   // To/from other RISC units\n   //\n   input [31:0] \t\t\tspr_dat_pic;\t// Data from PIC\n   input [31:0] \t\t\tspr_dat_tt;\t// Data from TT\n   input [31:0] \t\t\tspr_dat_pm;\t// Data from PM\n   input [31:0] \t\t\tspr_dat_dmmu;\t// Data from DMMU\n   input [31:0] \t\t\tspr_dat_immu;\t// Data from IMMU\n   input [31:0] \t\t\tspr_dat_du;\t// Data from DU\n   output [31:0] \t\t\tspr_addr;\t// SPR Address\n   output [31:0] \t\t\tspr_dat_o;\t// Data to unit\n   output [31:0] \t\t\tspr_cs;\t\t// Unit select\n   output\t\t\t\tspr_we;\t\t// SPR write enable\n\n   //\n   // To/from Debug Unit\n   //\n   input [width-1:0] \t\t\tdu_addr;\t// Address\n   input [width-1:0] \t\t\tdu_dat_du;\t// Data from DU to SPRS\n   input\t\t\t\tdu_read;\t// Read qualifier\n   input\t\t\t\tdu_write;\t// Write qualifier\n   output [width-1:0] \t\t\tdu_dat_cpu;\t// Data from SPRS to DU\n\n   //\n   // Internal regs & wires\n   //\n   reg [`OR1200_SR_WIDTH-1:0] \t\tsr_reg;\t\t// SR\n   reg \t\t\t\t\tsr_reg_bit_eph;\t// SR_EPH bit\n   reg \t\t\t\t\tsr_reg_bit_eph_select;// SR_EPH select\n   wire \t\t\t\tsr_reg_bit_eph_muxed;// SR_EPH muxed bit\n   reg [`OR1200_SR_WIDTH-1:0] \t\tsr;\t\t\t// SR\n   reg [width-1:0] \t\t\tto_wbmux;\t// For l.mfspr\n   wire \t\t\t\tcfgr_sel;\t// Select for cfg regs\n   wire \t\t\t\trf_sel;\t\t// Select for RF\n   wire \t\t\t\tnpc_sel;\t// Select for NPC\n   wire \t\t\t\tppc_sel;\t// Select for PPC\n   wire \t\t\t\tsr_sel;\t\t// Select for SR\t\n   wire \t\t\t\tepcr_sel;\t// Select for EPCR0\n   wire \t\t\t\teear_sel;\t// Select for EEAR0\n   wire \t\t\t\tesr_sel;\t// Select for ESR0\n   wire \t\t\t\tfpcsr_sel;\t// Select for FPCSR   \n   wire [31:0] \t\t\t\tsys_data;// Read data from system SPRs\n   wire \t\t\t\tdu_access;// Debug unit access\n   reg [31:0] \t\t\t\tunqualified_cs;\t// Unqualified selects\n   wire \t\t\t\tex_spr_write; // jb\n   \n   //\n   // Decide if it is debug unit access\n   //\n   assign du_access = du_read | du_write;\n\n   //\n   // Generate SPR address from base address and offset\n   // OR from debug unit address\n   //\n   assign spr_addr = du_access ? du_addr : (addrbase | {16'h0000, addrofs});\n\n   //\n   // SPR is written by debug unit or by l.mtspr\n   //\n   assign spr_dat_o = du_write ? du_dat_du : dat_i;\n\n   //\n   // debug unit data input:\n   //  - read of SPRS by debug unit\n   //  - write into debug unit SPRs by debug unit itself\n   //  - write into debug unit SPRs by l.mtspr\n   //\n   assign du_dat_cpu = du_read ? to_wbmux : du_write ? du_dat_du : dat_i;\n\n   //\n   // Write into SPRs when DU or l.mtspr\n   //\n   assign spr_we = du_write | ( ex_spr_write & !du_access );\n\n\n   //\n   // Qualify chip selects\n   //\n   assign spr_cs = unqualified_cs & {32{du_read | du_write | ex_spr_read | \n\t\t\t\t\t(ex_spr_write & sr[`OR1200_SR_SM])}};\n\n   //\n   // Decoding of groups\n   //\n   always @(spr_addr)\n     case (spr_addr[`OR1200_SPR_GROUP_BITS])\t// synopsys parallel_case\n       `OR1200_SPR_GROUP_WIDTH'd00: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00000001;\n       `OR1200_SPR_GROUP_WIDTH'd01: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00000010;\n       `OR1200_SPR_GROUP_WIDTH'd02: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00000100;\n       `OR1200_SPR_GROUP_WIDTH'd03: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00001000;\n       `OR1200_SPR_GROUP_WIDTH'd04: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00010000;\n       `OR1200_SPR_GROUP_WIDTH'd05: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00100000;\n       `OR1200_SPR_GROUP_WIDTH'd06: unqualified_cs \n\t = 32'b00000000_00000000_00000000_01000000;\n       `OR1200_SPR_GROUP_WIDTH'd07: unqualified_cs \n\t = 32'b00000000_00000000_00000000_10000000;\n       `OR1200_SPR_GROUP_WIDTH'd08: unqualified_cs \n\t = 32'b00000000_00000000_00000001_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd09: unqualified_cs \n\t = 32'b00000000_00000000_00000010_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd10: unqualified_cs \n\t = 32'b00000000_00000000_00000100_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd11: unqualified_cs \n\t = 32'b00000000_00000000_00001000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd12: unqualified_cs \n\t = 32'b00000000_00000000_00010000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd13: unqualified_cs \n\t = 32'b00000000_00000000_00100000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd14: unqualified_cs \n\t = 32'b00000000_00000000_01000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd15: unqualified_cs \n\t = 32'b00000000_00000000_10000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd16: unqualified_cs \n\t = 32'b00000000_00000001_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd17: unqualified_cs \n\t = 32'b00000000_00000010_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd18: unqualified_cs \n\t = 32'b00000000_00000100_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd19: unqualified_cs \n\t = 32'b00000000_00001000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd20: unqualified_cs \n\t = 32'b00000000_00010000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd21: unqualified_cs \n\t = 32'b00000000_00100000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd22: unqualified_cs \n\t = 32'b00000000_01000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd23: unqualified_cs \n\t = 32'b00000000_10000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd24: unqualified_cs \n\t = 32'b00000001_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd25: unqualified_cs \n\t = 32'b00000010_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd26: unqualified_cs \n\t = 32'b00000100_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd27: unqualified_cs \n\t = 32'b00001000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd28: unqualified_cs \n\t = 32'b00010000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd29: unqualified_cs \n\t = 32'b00100000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd30: unqualified_cs \n\t = 32'b01000000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd31: unqualified_cs \n\t = 32'b10000000_00000000_00000000_00000000;\n     endcase\n\n   //\n   // SPRs System Group\n   //\n\n   //\n   // What to write into SR\n   //\n   assign to_sr[`OR1200_SR_FO:`OR1200_SR_OV] \n\t    = (except_started) ? sr[`OR1200_SR_FO:`OR1200_SR_OV] :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? \n\t      esr[`OR1200_SR_FO:`OR1200_SR_OV] : (spr_we && sr_sel) ? \n\t      {1'b1, spr_dat_o[`OR1200_SR_FO-1:`OR1200_SR_OV]} :\n\t      sr[`OR1200_SR_FO:`OR1200_SR_OV];\n   assign to_sr[`OR1200_SR_TED] \n\t    = (except_started) ? 1'b1 :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? esr[`OR1200_SR_TED] :\n\t      (spr_we && sr_sel) ? spr_dat_o[`OR1200_SR_TED] :\n\t      sr[`OR1200_SR_TED];\n   \n   assign to_sr[`OR1200_SR_CY] \n\t    = (except_started) ? sr[`OR1200_SR_CY] :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? esr[`OR1200_SR_CY] :\n\t      cy_we ? cyforw :\n\t      (spr_we && sr_sel) ? spr_dat_o[`OR1200_SR_CY] :\n\t      sr[`OR1200_SR_CY];\n   assign to_sr[`OR1200_SR_F] \n\t    = (except_started) ? sr[`OR1200_SR_F] :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? esr[`OR1200_SR_F] :\n\t      flag_we ? flagforw :\n\t      (spr_we && sr_sel) ? spr_dat_o[`OR1200_SR_F] :\n\t      sr[`OR1200_SR_F];\n   \n   assign to_sr[`OR1200_SR_CE:`OR1200_SR_SM] \n\t    = (except_started) ? {sr[`OR1200_SR_CE:`OR1200_SR_LEE], 2'b00, \n\t\t\t\t  sr[`OR1200_SR_ICE:`OR1200_SR_DCE], 3'b001} :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? \n\t      esr[`OR1200_SR_CE:`OR1200_SR_SM] : (spr_we && sr_sel) ? \n\t      spr_dat_o[`OR1200_SR_CE:`OR1200_SR_SM] :\n\t      sr[`OR1200_SR_CE:`OR1200_SR_SM];\n\n   //\n   // Selects for system SPRs\n   //\n   assign cfgr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t      (spr_addr[10:4] == `OR1200_SPR_CFGR));\n   assign rf_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t    (spr_addr[10:5] == `OR1200_SPR_RF));\n   assign npc_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t     (spr_addr[10:0] == `OR1200_SPR_NPC));\n   assign ppc_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t     (spr_addr[10:0] == `OR1200_SPR_PPC));\n   assign sr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t    (spr_addr[10:0] == `OR1200_SPR_SR));\n   assign epcr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t      (spr_addr[10:0] == `OR1200_SPR_EPCR));\n   assign eear_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t      (spr_addr[10:0] == `OR1200_SPR_EEAR));\n   assign esr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t     (spr_addr[10:0] == `OR1200_SPR_ESR));\n   assign fpcsr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t       (spr_addr[10:0] == `OR1200_SPR_FPCSR));\n\n\n   //\n   // Write enables for system SPRs\n   //\n   assign sr_we = (spr_we && sr_sel) | (branch_op == `OR1200_BRANCHOP_RFE) | \n\t\t  flag_we | cy_we;\n   assign pc_we = (du_write && (npc_sel | ppc_sel));\n   assign epcr_we = (spr_we && epcr_sel);\n   assign eear_we = (spr_we && eear_sel);\n   assign esr_we = (spr_we && esr_sel);\n   assign fpcsr_we = (spr_we && fpcsr_sel);\n   \n   //\n   // Output from system SPRs\n   //\n   assign sys_data = (spr_dat_cfgr & {32{cfgr_sel}}) |\n\t\t     (spr_dat_rf & {32{rf_sel}}) |\n\t\t     (spr_dat_npc & {32{npc_sel}}) |\n\t\t     (spr_dat_ppc & {32{ppc_sel}}) |\n\t\t     ({{32-`OR1200_SR_WIDTH{1'b0}},sr} & {32{sr_sel}}) |\n\t\t     (epcr & {32{epcr_sel}}) |\n\t\t     (eear & {32{eear_sel}}) |\n\t\t     ({{32-`OR1200_FPCSR_WIDTH{1'b0}},fpcsr} & \n\t\t      {32{fpcsr_sel}}) |\n\t\t     ({{32-`OR1200_SR_WIDTH{1'b0}},esr} & {32{esr_sel}});\n\n   //\n   // Flag alias\n   //\n   assign flag = sr[`OR1200_SR_F];\n\n   //\n   // Carry alias\n   //\n   assign carry = sr[`OR1200_SR_CY];\n\n   //\n   // Supervision register\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       sr_reg <=  {2'b01, // Fixed one.\n\t\t   `OR1200_SR_EPH_DEF, {`OR1200_SR_WIDTH-4{1'b0}}, 1'b1};\n     else if (except_started)\n       sr_reg <=  to_sr[`OR1200_SR_WIDTH-1:0];\n     else if (sr_we)\n       sr_reg <=  to_sr[`OR1200_SR_WIDTH-1:0];\n\n   // EPH part of Supervision register\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     // default value \n     if (rst == `OR1200_RST_VALUE) begin\n\tsr_reg_bit_eph <=  `OR1200_SR_EPH_DEF;\n\t// select async. value due to reset state\n\tsr_reg_bit_eph_select <=  1'b1;\t\n     end\n   // selected value (different from default) is written into FF after reset \n   // state\n     else if (sr_reg_bit_eph_select) begin\n\t// dynamic value can only be assigned to FF out of reset!\n\tsr_reg_bit_eph <=  boot_adr_sel_i;\n\tsr_reg_bit_eph_select <=  1'b0;\t// select FF value\n     end\n     else if (sr_we) begin\n\tsr_reg_bit_eph <=  to_sr[`OR1200_SR_EPH];\n     end\n\n   // select async. value of EPH bit after reset \n   assign\tsr_reg_bit_eph_muxed = (sr_reg_bit_eph_select) ? \n\t\t\t\t       boot_adr_sel_i : sr_reg_bit_eph;\n\n   // EPH part joined together with rest of Supervision register\n   always @(sr_reg or sr_reg_bit_eph_muxed)\n     sr = {sr_reg[`OR1200_SR_WIDTH-1:`OR1200_SR_WIDTH-2], sr_reg_bit_eph_muxed,\n\t   sr_reg[`OR1200_SR_WIDTH-4:0]};\n\n`ifdef verilator\n   // Function to access various sprs (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n\n   function [31:0] get_sr;\n      // verilator public\n      get_sr = {{32-`OR1200_SR_WIDTH{1'b0}},sr};\n   endfunction // get_sr\n\n   function [31:0] get_epcr;\n      // verilator public\n      get_epcr = epcr;\n   endfunction // get_epcr\n\n   function [31:0] get_eear;\n      // verilator public\n      get_eear = eear;\n   endfunction // get_eear\n\n   function [31:0] get_esr;\n      // verilator public\n      get_esr = {{32-`OR1200_SR_WIDTH{1'b0}},esr};\n   endfunction // get_esr\n\n`endif\n   \n   //\n   // MTSPR/MFSPR interface\n   //\n   always @(spr_addr or sys_data or spr_dat_mac or spr_dat_pic or spr_dat_pm or\n\t    spr_dat_fpu or\n\t    spr_dat_dmmu or spr_dat_immu or spr_dat_du or spr_dat_tt) begin\n      casez (spr_addr[`OR1200_SPR_GROUP_BITS]) // synopsys parallel_case\n\t`OR1200_SPR_GROUP_SYS:\n\t  to_wbmux = sys_data;\n\t`OR1200_SPR_GROUP_TT:\n\t  to_wbmux = spr_dat_tt;\n\t`OR1200_SPR_GROUP_PIC:\n\t  to_wbmux = spr_dat_pic;\n\t`OR1200_SPR_GROUP_PM:\n\t  to_wbmux = spr_dat_pm;\n\t`OR1200_SPR_GROUP_DMMU:\n\t  to_wbmux = spr_dat_dmmu;\n\t`OR1200_SPR_GROUP_IMMU:\n\t  to_wbmux = spr_dat_immu;\n\t`OR1200_SPR_GROUP_MAC:\n\t  to_wbmux = spr_dat_mac;\n\t`OR1200_SPR_GROUP_FPU:\n\t  to_wbmux = spr_dat_fpu;\n\tdefault: //`OR1200_SPR_GROUP_DU:\n\t  to_wbmux = spr_dat_du;\n      endcase\n   end\n\nendmodule\n"], "fixing_code": ["//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's ALU                                                ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  ALU                                                         ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_alu.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Minor update: \n// Defines added, flags are corrected. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_alu(\n\ta, b, mult_mac_result, macrc_op,\n\talu_op, alu_op2, comp_op,\n\tcust5_op, cust5_limm,\n\tresult, flagforw, flag_we,\n\tovforw, ov_we,\n\tcyforw, cy_we, carry, flag\n);\n\nparameter width = `OR1200_OPERAND_WIDTH;\n\n//\n// I/O\n//\ninput\t[width-1:0]\t\ta;\ninput\t[width-1:0]\t\tb;\ninput\t[width-1:0]\t\tmult_mac_result;\ninput\t\t\t\tmacrc_op;\ninput\t[`OR1200_ALUOP_WIDTH-1:0]\talu_op;\ninput\t[`OR1200_ALUOP2_WIDTH-1:0]\talu_op2;\ninput\t[`OR1200_COMPOP_WIDTH-1:0]\tcomp_op;\ninput\t[4:0]\t\t\tcust5_op;\ninput\t[5:0]\t\t\tcust5_limm;\noutput\t[width-1:0]\t\tresult;\noutput\t\t\t\tflagforw;\noutput\t\t\t\tflag_we;\noutput\t\t\t\tcyforw;\noutput\t\t\t\tcy_we;\noutput\t\t\t\tovforw;\noutput\t\t\t\tov_we;\ninput\t\t\t\tcarry;\ninput         flag;\n\n//\n// Internal wires and regs\n//\nreg\t[width-1:0]\t\tresult;\nreg\t[width-1:0]\t\tshifted_rotated;\nreg\t[width-1:0]\t\textended;   \nreg\t[width-1:0]\t\tresult_cust5;\nreg\t\t\t\tflagforw;\nreg\t\t\t\tflagcomp;\nreg\t\t\t\tflag_we;\nreg\t\t\t\tcyforw;\nreg\t\t\t\tcy_we;\nreg\t\t\t\tovforw;\nreg\t\t\t\tov_we;   \nwire\t[width-1:0]\t\tcomp_a;\nwire\t[width-1:0]\t\tcomp_b;\n`ifdef OR1200_IMPL_ALU_COMP1\nwire\t\t\t\ta_eq_b;\nwire\t\t\t\ta_lt_b;\n`endif\nwire\t[width-1:0]\t\tresult_sum;\nwire\t[width-1:0]\t\tresult_and;\nwire\t\t\t\tcy_sum;\n`ifdef OR1200_IMPL_SUB\nwire\t\t\t\tcy_sub;\n`endif\nwire    \t\t\tov_sum;\nwire    [width-1:0] \t\tcarry_in;\n\nwire    [width-1:0]\t\tb_mux;\n   \n   \n\n//\n// Combinatorial logic\n//\nassign comp_a = {a[width-1] ^ comp_op[3] , a[width-2:0]};\nassign comp_b = {b[width-1] ^ comp_op[3] , b[width-2:0]};\n`ifdef OR1200_IMPL_ALU_COMP1\nassign a_eq_b = (comp_a == comp_b);\nassign a_lt_b = (comp_a < comp_b);\n`endif\n`ifdef OR1200_IMPL_SUB\nassign cy_sub = (comp_a < comp_b);\n`endif\n`ifdef OR1200_IMPL_ADDC   \nassign carry_in = (alu_op==`OR1200_ALUOP_ADDC) ? \n\t\t  {{width-1{1'b0}},carry} : {width{1'b0}};\n`else\nassign carry_in = {width-1{1'b0}};\n`endif\n`ifdef OR1200_IMPL_SUB\nassign b_mux = (alu_op==`OR1200_ALUOP_SUB) ? (~b)+1 : b;\n`else\nassign b_mux = b;\n`endif   \nassign {cy_sum, result_sum} = (a + b_mux) + carry_in;\n// Numbers either both +ve and bit 31 of result set\nassign ov_sum = ((!a[width-1] & !b_mux[width-1]) & result_sum[width-1]) |\n// or both -ve and bit 31 of result clear\n\t\t((a[width-1] & b_mux[width-1]) & !result_sum[width-1]);  \nassign result_and = a & b;\n\n//\n// Simulation check for bad ALU behavior\n//\n`ifdef OR1200_WARNINGS\n// synopsys translate_off\nalways @(result) begin\n\tif (result === 32'bx)\n\t\t$display(\"%t: WARNING: 32'bx detected on ALU result bus. Please check !\", $time);\nend\n// synopsys translate_on\n`endif\n\n//\n// Central part of the ALU\n//\nalways @(alu_op or alu_op2 or a or b or result_sum or result_and or macrc_op\n\t or shifted_rotated or mult_mac_result or flag or result_cust5 or carry\n`ifdef OR1200_IMPL_ALU_EXT\n         or extended\n`endif\t \n) begin\n`ifdef OR1200_CASE_DEFAULT\n\tcasez (alu_op)\t\t// synopsys parallel_case\n`else\n\tcasez (alu_op)\t\t// synopsys full_case parallel_case\n`endif\n`ifdef OR1200_IMPL_ALU_FFL1\t  \n\t\t`OR1200_ALUOP_FFL1: begin\n`ifdef OR1200_CASE_DEFAULT\n\t\t   casez (alu_op2) // synopsys parallel_case\n`else\n\t\t   casez (alu_op2) // synopsys full_case parallel_case\n`endif\n\t\t     0: begin // FF1\n\t\t\tresult = a[0] ? 1 : a[1] ? 2 : a[2] ? 3 : a[3] ? 4 : a[4] ? 5 : a[5] ? 6 : a[6] ? 7 : a[7] ? 8 : a[8] ? 9 : a[9] ? 10 : a[10] ? 11 : a[11] ? 12 : a[12] ? 13 : a[13] ? 14 : a[14] ? 15 : a[15] ? 16 : a[16] ? 17 : a[17] ? 18 : a[18] ? 19 : a[19] ? 20 : a[20] ? 21 : a[21] ? 22 : a[22] ? 23 : a[23] ? 24 : a[24] ? 25 : a[25] ? 26 : a[26] ? 27 : a[27] ? 28 : a[28] ? 29 : a[29] ? 30 : a[30] ? 31 : a[31] ? 32 : 0;\n\t\t     end\n\t\t     default: begin // FL1\n\t\t\tresult = a[31] ? 32 : a[30] ? 31 : a[29] ? 30 : a[28] ? 29 : a[27] ? 28 : a[26] ? 27 : a[25] ? 26 : a[24] ? 25 : a[23] ? 24 : a[22] ? 23 : a[21] ? 22 : a[20] ? 21 : a[19] ? 20 : a[18] ? 19 : a[17] ? 18 : a[16] ? 17 : a[15] ? 16 : a[14] ? 15 : a[13] ? 14 : a[12] ? 13 : a[11] ? 12 : a[10] ? 11 : a[9] ? 10 : a[8] ? 9 : a[7] ? 8 : a[6] ? 7 : a[5] ? 6 : a[4] ? 5 : a[3] ? 4 : a[2] ? 3 : a[1] ? 2 : a[0] ? 1 : 0 ;\n\t\t     end\n\t\t   endcase // casez (alu_op2)\n\t\tend // case: `OR1200_ALUOP_FFL1\n`endif //  `ifdef OR1200_IMPL_ALU_FFL1\n`ifdef OR1200_IMPL_ALU_CUST5\n\t  \n\t\t`OR1200_ALUOP_CUST5 : begin \n\t\t\t\tresult = result_cust5;\n\t\tend\n`endif\t\t     \n\t\t`OR1200_ALUOP_SHROT : begin \n\t\t\t\tresult = shifted_rotated;\n\t\tend\n`ifdef OR1200_IMPL_ADDC\n\t\t`OR1200_ALUOP_ADDC,\n`endif\n`ifdef OR1200_IMPL_SUB\n\t\t`OR1200_ALUOP_SUB,\n`endif\t \n\t\t`OR1200_ALUOP_ADD : begin\n\t\t\t\tresult = result_sum;\n\t\tend\n\t\t`OR1200_ALUOP_XOR : begin\n\t\t\t\tresult = a ^ b;\n\t\tend\n\t\t`OR1200_ALUOP_OR  : begin\n\t\t\t\tresult = a | b;\n\t\tend\n`ifdef OR1200_IMPL_ALU_EXT\t\t     \n\t\t`OR1200_ALUOP_EXTHB  : begin\n\t\t                result = extended;\n\t\tend\n\t\t`OR1200_ALUOP_EXTW  : begin\n\t\t                result = extended;\n\t\tend\t\t\n`endif     \n\t\t`OR1200_ALUOP_MOVHI : begin\n\t\t\t\tif (macrc_op) begin\n\t\t\t\t\tresult = mult_mac_result;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tresult = b << 16;\n\t\t\t\tend\n\t\tend\n`ifdef OR1200_MULT_IMPLEMENTED\n`ifdef OR1200_DIV_IMPLEMENTED\n\t\t`OR1200_ALUOP_DIV,\n\t\t`OR1200_ALUOP_DIVU,\n`endif\n\t\t`OR1200_ALUOP_MUL,\n\t\t`OR1200_ALUOP_MULU : begin\n\t\t\t\tresult = mult_mac_result;\n\t\tend\n`endif\n\t\t`OR1200_ALUOP_CMOV: begin\n\t\t\tresult = flag ? a : b;\n\t\tend\n\n`ifdef OR1200_CASE_DEFAULT\n\t\tdefault: begin\n`else\n\t\t`OR1200_ALUOP_COMP, `OR1200_ALUOP_AND: begin\n`endif\n\t\t\tresult=result_and;\n\t\tend \n\tendcase\nend\n\n//\n// Generate flag and flag write enable\n//\nalways @(alu_op or result_sum or result_and or flagcomp\n) begin\n\tcasez (alu_op)\t\t// synopsys parallel_case\n`ifdef OR1200_ADDITIONAL_FLAG_MODIFIERS\n`ifdef OR1200_IMPL_ADDC\n\t\t`OR1200_ALUOP_ADDC,\n`endif\t \n\t\t`OR1200_ALUOP_ADD : begin\n\t\t\tflagforw = (result_sum == 32'h0000_0000);\n\t\t\tflag_we = 1'b1;\n\t\tend\n\t\t`OR1200_ALUOP_AND: begin\n\t\t\tflagforw = (result_and == 32'h0000_0000);\n\t\t\tflag_we = 1'b1;\n\t\tend\n`endif\n\t\t`OR1200_ALUOP_COMP: begin\n\t\t\tflagforw = flagcomp;\n\t\t\tflag_we = 1'b1;\n\t\tend\n\t\tdefault: begin\n\t\t\tflagforw = flagcomp;\n\t\t\tflag_we = 1'b0;\n\t\tend\n\tendcase\nend\n\n//\n// Generate SR[CY] write enable\n//\nalways @(alu_op or cy_sum\n`ifdef OR1200_IMPL_CY\n`ifdef OR1200_IMPL_SUB\n\tor cy_sub\n`endif\n`endif\n) begin\n\tcasez (alu_op)\t\t// synopsys parallel_case\n`ifdef OR1200_IMPL_CY\n`ifdef OR1200_IMPL_ADDC\n\t\t`OR1200_ALUOP_ADDC,\n`endif\t  \n\t\t`OR1200_ALUOP_ADD : begin\n\t\t\tcyforw = cy_sum;\n\t\t\tcy_we = 1'b1;\n\t\tend\n`ifdef OR1200_IMPL_SUB\n\t\t`OR1200_ALUOP_SUB: begin\n\t\t\tcyforw = cy_sub;\n\t\t\tcy_we = 1'b1;\n\t\tend\n`endif\n`endif\n\t\tdefault: begin\n\t\t\tcyforw = 1'b0;\n\t\t\tcy_we = 1'b0;\n\t\tend\n\tendcase\nend\n\n\n//\n// Generate SR[OV] write enable\n//\nalways @(alu_op or ov_sum) begin\n\tcasez (alu_op)\t\t// synopsys parallel_case\n`ifdef OR1200_IMPL_OV\n`ifdef OR1200_IMPL_ADDC\n\t\t`OR1200_ALUOP_ADDC,\n`endif\n`ifdef OR1200_IMPL_SUB\n\t\t`OR1200_ALUOP_SUB,\n`endif\t \n\t\t`OR1200_ALUOP_ADD : begin\n\t\t\tovforw = ov_sum;\n\t\t\tov_we = 1'b1;\n\t\tend\n`endif\t  \n\t\tdefault: begin\n\t\t\tovforw = 1'b0;\n\t\t\tov_we = 1'b0;\n\t\tend\n\tendcase\nend\n   \n//\n// Shifts and rotation\n//\nalways @(alu_op2 or a or b) begin\n\tcase (alu_op2)\t\t// synopsys parallel_case\n\t  `OR1200_SHROTOP_SLL :\n\t\t\t\tshifted_rotated = (a << b[4:0]);\n\t  `OR1200_SHROTOP_SRL :\n\t\t\t\tshifted_rotated = (a >> b[4:0]);\n\n`ifdef OR1200_IMPL_ALU_ROTATE\n\t  `OR1200_SHROTOP_ROR :\n\t                        shifted_rotated = (a << (6'd32-{1'b0,b[4:0]})) |\n\t\t\t\t\t\t  (a >> b[4:0]);\n`endif\n\t  default:\n\t                        shifted_rotated = ({32{a[31]}} << \n\t\t\t\t\t\t   (6'd32-{1'b0, b[4:0]})) | \n\t\t\t\t\t\t  a >> b[4:0];\n\tendcase\nend\n\n//\n// First type of compare implementation\n//\n`ifdef OR1200_IMPL_ALU_COMP1\nalways @(comp_op or a_eq_b or a_lt_b) begin\n\tcase(comp_op[2:0])\t// synopsys parallel_case\n\t\t`OR1200_COP_SFEQ:\n\t\t\tflagcomp = a_eq_b;\n\t\t`OR1200_COP_SFNE:\n\t\t\tflagcomp = ~a_eq_b;\n\t\t`OR1200_COP_SFGT:\n\t\t\tflagcomp = ~(a_eq_b | a_lt_b);\n\t\t`OR1200_COP_SFGE:\n\t\t\tflagcomp = ~a_lt_b;\n\t\t`OR1200_COP_SFLT:\n\t\t\tflagcomp = a_lt_b;\n\t\t`OR1200_COP_SFLE:\n\t\t\tflagcomp = a_eq_b | a_lt_b;\n\t\tdefault:\n\t\t\tflagcomp = 1'b0;\n\tendcase\nend\n`endif\n\n//\n// Second type of compare implementation\n//\n`ifdef OR1200_IMPL_ALU_COMP2\nalways @(comp_op or comp_a or comp_b) begin\n\tcase(comp_op[2:0])\t// synopsys parallel_case\n\t\t`OR1200_COP_SFEQ:\n\t\t\tflagcomp = (comp_a == comp_b);\n\t\t`OR1200_COP_SFNE:\n\t\t\tflagcomp = (comp_a != comp_b);\n\t\t`OR1200_COP_SFGT:\n\t\t\tflagcomp = (comp_a > comp_b);\n\t\t`OR1200_COP_SFGE:\n\t\t\tflagcomp = (comp_a >= comp_b);\n\t\t`OR1200_COP_SFLT:\n\t\t\tflagcomp = (comp_a < comp_b);\n\t\t`OR1200_COP_SFLE:\n\t\t\tflagcomp = (comp_a <= comp_b);\n\t\tdefault:\n\t\t\tflagcomp = 1'b0;\n\tendcase\nend\n`endif\n\n`ifdef OR1200_IMPL_ALU_EXT\n   always @(alu_op or alu_op2 or a) begin\n      casez (alu_op2)\n\t`OR1200_EXTHBOP_HS : extended = {{16{a[15]}},a[15:0]};\n\t`OR1200_EXTHBOP_BS : extended = {{24{a[7]}},a[7:0]};\n\t`OR1200_EXTHBOP_HZ : extended = {16'd0,a[15:0]};\n\t`OR1200_EXTHBOP_BZ : extended = {24'd0,a[7:0]};\n\tdefault: extended = a; // Used for l.extw instructions\n      endcase // casez (alu_op2)\n   end\n`endif \n\t     \n\n//\n// l.cust5 custom instructions\n//\n`ifdef OR1200_IMPL_ALU_CUST5\n// Examples for move byte, set bit and clear bit\n//\nalways @(cust5_op or cust5_limm or a or b) begin\n\tcasez (cust5_op)\t\t// synopsys parallel_case\n\t\t5'h1 : begin \n\t\t\tcasez (cust5_limm[1:0])\n\t\t\t  2'h0: result_cust5 = {a[31:8], b[7:0]};\n\t\t\t  2'h1: result_cust5 = {a[31:16], b[7:0], a[7:0]};\n\t\t\t  2'h2: result_cust5 = {a[31:24], b[7:0], a[15:0]};\n\t\t\t  2'h3: result_cust5 = {b[7:0], a[23:0]};\n\t\t\tendcase\n\t\tend\n\t\t5'h2 :\n\t\t\tresult_cust5 = a | (1 << cust5_limm);\n\t\t5'h3 :\n\t\t\tresult_cust5 = a & (32'hffffffff ^ (1 << cust5_limm));\n//\n// *** Put here new l.cust5 custom instructions ***\n//\n\t\tdefault: begin\n\t\t\tresult_cust5 = a;\n\t\tend\n\tendcase\nend // always @ (cust5_op or cust5_limm or a or b)\n`endif   \n\nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's CPU                                                ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  Instantiation of internal CPU blocks. IFETCH, SPRS, FRZ,    ////\n////  ALU, EXCEPT, ID, WBMUX, OPERANDMUX, RF etc.                 ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_cpu.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Major update: \n// Structure reordered and bugs fixed. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_cpu(\n\t// Clk & Rst\n\tclk, rst,\n\n\t// Insn interface\n\tic_en,\n\ticpu_adr_o, icpu_cycstb_o, icpu_sel_o, icpu_tag_o,\n\ticpu_dat_i, icpu_ack_i, icpu_rty_i, icpu_err_i, icpu_adr_i, icpu_tag_i,\n\timmu_en,\n\n\t// Debug unit\n\tid_void, id_insn, ex_void, \n\tex_insn, ex_freeze, wb_insn, wb_freeze, id_pc, ex_pc, wb_pc, branch_op,\n\tspr_dat_npc, rf_dataw, ex_flushpipe, \n\tdu_stall, du_addr, du_dat_du, du_read, du_write, du_except_stop, \n\tdu_except_trig, du_dsr, du_dmr1, du_hwbkpt, du_hwbkpt_ls_r, du_dat_cpu,\n\tdu_lsu_store_dat, du_lsu_load_dat, \n\tabort_mvspr, abort_ex,\n\t\n\t// Data interface\n\tdc_en,\n\tdcpu_adr_o, dcpu_cycstb_o, dcpu_we_o, dcpu_sel_o, dcpu_tag_o, \n        dcpu_dat_o, dcpu_dat_i, dcpu_ack_i, dcpu_rty_i, dcpu_err_i, dcpu_tag_i,\n\tsb_en, dmmu_en, dc_no_writethrough,\n\n\t// SR Interface\n\tboot_adr_sel_i,\n\n\t// Interrupt & tick exceptions\n\tsig_int, sig_tick,\n\n\t// SPR interface\n\tsupv, spr_addr, spr_dat_cpu, spr_dat_pic, spr_dat_tt, spr_dat_pm,\n\tspr_dat_dmmu, spr_dat_immu, spr_dat_du, spr_cs, spr_we, mtspr_dc_done\n);\n\nparameter dw = `OR1200_OPERAND_WIDTH;\nparameter aw = `OR1200_REGFILE_ADDR_WIDTH;\n\n//\n// I/O ports\n//\n\n//\n// Clk & Rst\n//\ninput \t\t\t\tclk;\ninput \t\t\t\trst;\n\n//\n// Insn (IC) interface\n//\noutput\t\t\t\tic_en;\noutput\t[31:0]\t\t\ticpu_adr_o;\noutput\t\t\t\ticpu_cycstb_o;\noutput\t[3:0]\t\t\ticpu_sel_o;\noutput\t[3:0]\t\t\ticpu_tag_o;\ninput\t[31:0]\t\t\ticpu_dat_i;\ninput\t\t\t\ticpu_ack_i;\ninput\t\t\t\ticpu_rty_i;\ninput\t\t\t\ticpu_err_i;\ninput\t[31:0]\t\t\ticpu_adr_i;\ninput\t[3:0]\t\t\ticpu_tag_i;\n\n//\n// Insn (IMMU) interface\n//\noutput\t\t\t\timmu_en;\n\n//\n// Debug interface\n//\noutput                          id_void;\noutput\t[31:0]\t\t\tid_insn;\noutput                          ex_void;\noutput\t[31:0]\t\t\tex_insn;\noutput\t\t\t\tex_freeze;\noutput\t[31:0]\t\t\twb_insn;\noutput\t\t\t\twb_freeze;\noutput\t[31:0]\t\t\tid_pc;\noutput\t[31:0]\t\t\tex_pc;\noutput\t[31:0]\t\t\twb_pc;\noutput                          ex_flushpipe;\noutput\t[`OR1200_BRANCHOP_WIDTH-1:0]\tbranch_op;\n\ninput\t\t\t\tdu_stall;\ninput\t[dw-1:0]\t\tdu_addr;\ninput\t[dw-1:0]\t\tdu_dat_du;\ninput\t\t\t\tdu_read;\ninput\t\t\t\tdu_write;\ninput\t[`OR1200_DU_DSR_WIDTH-1:0]\tdu_dsr;\ninput\t[24:0]\t\t\tdu_dmr1;\ninput\t\t\t\tdu_hwbkpt;\ninput\t\t\t\tdu_hwbkpt_ls_r;\noutput\t[13:0]\t\t\tdu_except_trig;\noutput\t[13:0]\t\t\tdu_except_stop;\noutput\t[dw-1:0]\t\tdu_dat_cpu;\noutput\t[dw-1:0]\t\trf_dataw;\noutput\t[dw-1:0]\t\tdu_lsu_store_dat;\noutput\t[dw-1:0]\t\tdu_lsu_load_dat;\n\n//\n// Data (DC) interface\n//\noutput\t[31:0]\t\t\tdcpu_adr_o;\noutput\t\t\t\tdcpu_cycstb_o;\noutput\t\t\t\tdcpu_we_o;\noutput\t[3:0]\t\t\tdcpu_sel_o;\noutput\t[3:0]\t\t\tdcpu_tag_o;\noutput\t[31:0]\t\t\tdcpu_dat_o;\ninput\t[31:0]\t\t\tdcpu_dat_i;\ninput\t\t\t\tdcpu_ack_i;\ninput\t\t\t\tdcpu_rty_i;\ninput\t\t\t\tdcpu_err_i;\ninput\t[3:0]\t\t\tdcpu_tag_i;\noutput\t\t\t\tdc_en;\noutput  \t\t\tdc_no_writethrough;\n   \n//\n// Data (DMMU) interface\n//\noutput\t\t\t\tsb_en;\noutput\t\t\t\tdmmu_en;\noutput\t\t\t\tabort_ex;\noutput\t\t\t\tabort_mvspr;\n\n//\n// SR Interface \n//\ninput\t\t\t\tboot_adr_sel_i;\n\n//\n// SPR interface\n//\noutput\t\t\t\tsupv;\ninput\t[dw-1:0]\t\tspr_dat_pic;\ninput\t[dw-1:0]\t\tspr_dat_tt;\ninput\t[dw-1:0]\t\tspr_dat_pm;\ninput\t[dw-1:0]\t\tspr_dat_dmmu;\ninput\t[dw-1:0]\t\tspr_dat_immu;\ninput\t[dw-1:0]\t\tspr_dat_du;\noutput\t[dw-1:0]\t\tspr_addr;\noutput\t[dw-1:0]\t\tspr_dat_cpu;\noutput\t[dw-1:0]\t\tspr_dat_npc;\noutput\t[31:0]\t\t\tspr_cs;\noutput\t\t\t\tspr_we;\ninput   \t\t\tmtspr_dc_done;\n   \n//\n// Interrupt exceptions\n//\ninput\t\t\t\tsig_int;\ninput\t\t\t\tsig_tick;\n\n//\n// Internal wires\n//\nwire\t[31:0]\t\t\tif_insn;\nwire\t\t\t\tsaving_if_insn;\nwire\t[31:0]\t\t\tif_pc;\nwire\t[aw-1:0]\t\trf_addrw;\nwire\t[aw-1:0] \t\trf_addra;\nwire\t[aw-1:0] \t\trf_addrb;\nwire\t\t\t\trf_rda;\nwire\t\t\t\trf_rdb;\nwire\t[dw-1:0]\t\tid_simm;\nwire\t[dw-1:2]\t\tid_branch_addrtarget;\nwire\t[dw-1:2]\t\tex_branch_addrtarget;\nwire\t[`OR1200_ALUOP_WIDTH-1:0]\talu_op;\nwire\t[`OR1200_ALUOP2_WIDTH-1:0]\talu_op2;\nwire\t[`OR1200_COMPOP_WIDTH-1:0]\tcomp_op;\nwire\t[`OR1200_BRANCHOP_WIDTH-1:0]\tpre_branch_op;\nwire\t[`OR1200_BRANCHOP_WIDTH-1:0]\tbranch_op;\nwire\t[`OR1200_LSUOP_WIDTH-1:0]\tid_lsu_op;\nwire\t\t\t\tgenpc_freeze;\nwire\t\t\t\tif_freeze;\nwire\t\t\t\tid_freeze;\nwire\t\t\t\tex_freeze;\nwire\t\t\t\twb_freeze;\nwire\t[`OR1200_SEL_WIDTH-1:0]\tsel_a;\nwire\t[`OR1200_SEL_WIDTH-1:0]\tsel_b;\nwire\t[`OR1200_RFWBOP_WIDTH-1:0]\trfwb_op;\nwire    [`OR1200_FPUOP_WIDTH-1:0]       fpu_op;\nwire\t[dw-1:0]\t\trf_dataw;\nwire\t[dw-1:0]\t\trf_dataa;\nwire\t[dw-1:0]\t\trf_datab;\nwire\t[dw-1:0]\t\tmuxed_a;\nwire\t[dw-1:0]\t\tmuxed_b;\nwire\t[dw-1:0]\t\twb_forw;\nwire\t\t\t\twbforw_valid;\nwire\t[dw-1:0]\t\toperand_a;\nwire\t[dw-1:0]\t\toperand_b;\nwire\t[dw-1:0]\t\talu_dataout;\nwire\t[dw-1:0]\t\tlsu_dataout;\nwire\t[dw-1:0]\t\tsprs_dataout;\nwire\t[dw-1:0]\t\tfpu_dataout;\nwire     \t\t\tfpu_done;\nwire\t[31:0]\t\t\tex_simm;\nwire\t[`OR1200_MULTICYCLE_WIDTH-1:0]\tmulticycle;\nwire    [`OR1200_WAIT_ON_WIDTH-1:0]\twait_on;      \nwire\t[`OR1200_EXCEPT_WIDTH-1:0]\texcept_type;\nwire\t[4:0]\t\t\tcust5_op;\nwire\t[5:0]\t\t\tcust5_limm;\nwire\t\t\t\tif_flushpipe;\nwire\t\t\t\tid_flushpipe;\nwire\t\t\t\tex_flushpipe;\nwire\t\t\t\twb_flushpipe;\nwire\t\t\t\textend_flush;\nwire\t\t\t\tex_branch_taken;\nwire\t\t\t\tflag;\nwire\t\t\t\tflagforw;\nwire\t\t\t\tflag_we;\nwire\t\t\t\tflagforw_alu;   \nwire\t\t\t\tflag_we_alu;\nwire\t\t\t\tflagforw_fpu;\nwire\t\t\t\tflag_we_fpu;\nwire\t\t\t\tcarry;\nwire\t\t\t\tcyforw;\nwire\t\t\t\tcy_we_alu;\nwire\t\t\t\tovforw;\nwire\t\t\t\tov_we_alu;\nwire\t\t\t\tovforw_mult_mac;\nwire\t\t\t\tov_we_mult_mac;   \nwire\t\t\t\tcy_we_rf;\nwire\t\t\t\tlsu_stall;\nwire\t\t\t\tepcr_we;\nwire\t\t\t\teear_we;\nwire\t\t\t\tesr_we;\nwire\t\t\t\tpc_we;\nwire\t[31:0]\t\t\tepcr;\nwire\t[31:0]\t\t\teear;\nwire\t[`OR1200_SR_WIDTH-1:0]\tesr;\nwire \t[`OR1200_FPCSR_WIDTH-1:0]       fpcsr;\nwire \t\t\t\tfpcsr_we;   \nwire\t\t\t\tsr_we;\nwire\t[`OR1200_SR_WIDTH-1:0]\tto_sr;\nwire\t[`OR1200_SR_WIDTH-1:0]\tsr;\nwire\t\t\t\texcept_flushpipe;\nwire\t\t\t\texcept_start;\nwire\t\t\t\texcept_started;\nwire    \t\t\tfpu_except_started;   \nwire\t[31:0]\t\t\twb_insn;\nwire\t\t\t\tsig_syscall;\nwire\t\t\t\tsig_trap;\nwire    \t\t\tsig_range;\nwire\t\t\t\tsig_fp;\nwire\t[31:0]\t\t\tspr_dat_cfgr;\nwire\t[31:0]\t\t\tspr_dat_rf;\nwire    [31:0]                  spr_dat_npc;\nwire\t[31:0]\t\t\tspr_dat_ppc;\nwire\t[31:0]\t\t\tspr_dat_mac;\nwire [31:0] \t\t\tspr_dat_fpu;\nwire     \t\t\tmtspr_done;\nwire\t\t\t\tforce_dslot_fetch;\nwire\t\t\t\tno_more_dslot;\nwire\t\t\t\tex_void;\nwire\t\t\t\tex_spr_read;\nwire\t\t\t\tex_spr_write;\nwire\t\t\t\tif_stall;\nwire\t\t\t\tid_macrc_op;\nwire\t\t\t\tex_macrc_op;\nwire\t[`OR1200_MACOP_WIDTH-1:0] id_mac_op;\nwire\t[`OR1200_MACOP_WIDTH-1:0] mac_op;\nwire\t[31:0]\t\t\tmult_mac_result;\nwire\t\t\t\tmult_mac_stall;\nwire\t[13:0]\t\t\texcept_trig;\nwire\t[13:0]\t\t\texcept_stop;\nwire\t\t\t\tgenpc_refetch;\nwire\t\t\t\trfe;\nwire\t\t\t\tlsu_unstall;\nwire\t\t\t\texcept_align;\nwire\t\t\t\texcept_dtlbmiss;\nwire\t\t\t\texcept_dmmufault;\nwire\t\t\t\texcept_illegal;\nwire\t\t\t\texcept_itlbmiss;\nwire\t\t\t\texcept_immufault;\nwire\t\t\t\texcept_ibuserr;\nwire\t\t\t\texcept_dbuserr;\nwire\t\t\t\tabort_ex;\nwire\t\t\t\tabort_mvspr;\n\n//\n// Send exceptions to Debug Unit\n//\nassign du_except_trig = except_trig;\nassign du_except_stop = except_stop;\nassign du_lsu_store_dat = operand_b;\nassign du_lsu_load_dat  = lsu_dataout;\n\n//\n// Data cache enable\n//\n`ifdef OR1200_NO_DC\nassign dc_en = 1'b0;\n`else\n   assign dc_en = sr[`OR1200_SR_DCE];\n`endif\n\n//\n// Instruction cache enable\n//\n`ifdef OR1200_NO_IC\nassign ic_en = 1'b0;\n`else\nassign ic_en = sr[`OR1200_SR_ICE];\n`endif\n\n//\n// SB enable\n//\n`ifdef OR1200_SB_IMPLEMENTED\n//assign sb_en = sr[`OR1200_SR_SBE]; // SBE not defined  -- jb\n`else\nassign sb_en = 1'b0;\n`endif\n\n//\n// DMMU enable\n//\n`ifdef OR1200_NO_DMMU\nassign dmmu_en = 1'b0;\n`else\nassign dmmu_en = sr[`OR1200_SR_DME];\n`endif\n\n//\n// IMMU enable\n//\n`ifdef OR1200_NO_IMMU\nassign immu_en = 1'b0;\n`else\nassign immu_en = sr[`OR1200_SR_IME] & ~except_started;\n`endif\n\n//\n// SUPV bit\n//\nassign supv = sr[`OR1200_SR_SM];\n\n//\n// FLAG write enable\n//\nassign flagforw = (flag_we_alu & flagforw_alu) | (flagforw_fpu & flag_we_fpu);\nassign flag_we = (flag_we_alu | flag_we_fpu) & ~abort_mvspr;\n\n//\n// Flag for any MTSPR instructions, that must block execution, to indicate done\n//\nassign mtspr_done = mtspr_dc_done;\n\n//\n// Range exception\n//\nassign sig_range = sr[`OR1200_SR_OV];\n   \n   \n   \n//\n// Instantiation of instruction fetch block\n//\nor1200_genpc or1200_genpc(\n\t.clk(clk),\n\t.rst(rst),\n\t.icpu_adr_o(icpu_adr_o),\n\t.icpu_cycstb_o(icpu_cycstb_o),\n\t.icpu_sel_o(icpu_sel_o),\n\t.icpu_tag_o(icpu_tag_o),\n\t.icpu_rty_i(icpu_rty_i),\n\t.icpu_adr_i(icpu_adr_i),\n\n\t.pre_branch_op(pre_branch_op),\n\t.branch_op(branch_op),\n\t.except_type(except_type),\n\t.except_start(except_start),\n\t.except_prefix(sr[`OR1200_SR_EPH]),\n\t.id_branch_addrtarget(id_branch_addrtarget),\n\t.ex_branch_addrtarget(ex_branch_addrtarget),\n\t.muxed_b(muxed_b),\n\t.operand_b(operand_b),\n\t.flag(flag),\n\t.flagforw(flagforw),\n\t.ex_branch_taken(ex_branch_taken),\n\t.epcr(epcr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_pc_we(pc_we),\n\t.genpc_refetch(genpc_refetch),\n\t.genpc_freeze(genpc_freeze),\n\t.no_more_dslot(no_more_dslot)\n);\n\n//\n// Instantiation of instruction fetch block\n//\nor1200_if or1200_if(\n\t.clk(clk),\n\t.rst(rst),\n\t.icpu_dat_i(icpu_dat_i),\n\t.icpu_ack_i(icpu_ack_i),\n\t.icpu_err_i(icpu_err_i),\n\t.icpu_adr_i(icpu_adr_i),\n\t.icpu_tag_i(icpu_tag_i),\n\n\t.if_freeze(if_freeze),\n\t.if_insn(if_insn),\n\t.if_pc(if_pc),\n\t.saving_if_insn(saving_if_insn),\n\t.if_flushpipe(if_flushpipe),\n\t.if_stall(if_stall),\n\t.no_more_dslot(no_more_dslot),\n\t.genpc_refetch(genpc_refetch),\n\t.rfe(rfe),\n\t.except_itlbmiss(except_itlbmiss),\n\t.except_immufault(except_immufault),\n\t.except_ibuserr(except_ibuserr)\n);\n\n//\n// Instantiation of instruction decode/control logic\n//\nor1200_ctrl or1200_ctrl(\n\t.clk(clk),\n\t.rst(rst),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.wb_freeze(wb_freeze),\n\t.if_flushpipe(if_flushpipe),\n\t.id_flushpipe(id_flushpipe),\n\t.ex_flushpipe(ex_flushpipe),\n\t.wb_flushpipe(wb_flushpipe),\n\t.extend_flush(extend_flush),\n\t.except_flushpipe(except_flushpipe),\n\t.abort_mvspr(abort_mvspr),\n\t.if_insn(if_insn),\n\t.id_insn(id_insn),\n\t.ex_insn(ex_insn),\n\t.id_branch_op(pre_branch_op),\n\t.ex_branch_op(branch_op),\n\t.ex_branch_taken(ex_branch_taken),\n\t.rf_addra(rf_addra),\n\t.rf_addrb(rf_addrb),\n\t.rf_rda(rf_rda),\n\t.rf_rdb(rf_rdb),\n\t.alu_op(alu_op),\n\t.alu_op2(alu_op2),\t\t\t\n\t.mac_op(mac_op),\n\t.comp_op(comp_op),\n\t.rf_addrw(rf_addrw),\n\t.rfwb_op(rfwb_op),\n\t.fpu_op(fpu_op),\t\t\t\n\t.pc_we(pc_we),\n\t.wb_insn(wb_insn),\n\t.id_simm(id_simm),\n\t.id_branch_addrtarget(id_branch_addrtarget),\n\t.ex_branch_addrtarget(ex_branch_addrtarget),\n\t.ex_simm(ex_simm),\n\t.sel_a(sel_a),\n\t.sel_b(sel_b),\n\t.id_lsu_op(id_lsu_op),\n\t.cust5_op(cust5_op),\n\t.cust5_limm(cust5_limm),\n\t.id_pc(id_pc),\n\t.ex_pc(ex_pc),\n\t.multicycle(multicycle),\n        .wait_on(wait_on),\t\t\t\n\t.wbforw_valid(wbforw_valid),\n\t.sig_syscall(sig_syscall),\n\t.sig_trap(sig_trap),\n\t.force_dslot_fetch(force_dslot_fetch),\n\t.no_more_dslot(no_more_dslot),\n\t.id_void(id_void),\n\t.ex_void(ex_void),\n\t.ex_spr_read(ex_spr_read),\n\t.ex_spr_write(ex_spr_write),\n\t.id_mac_op(id_mac_op),\n\t.id_macrc_op(id_macrc_op),\n\t.ex_macrc_op(ex_macrc_op),\n\t.rfe(rfe),\n\t.du_hwbkpt(du_hwbkpt),\n\t.except_illegal(except_illegal),\n\t.dc_no_writethrough(dc_no_writethrough)\n);\n\n//\n// Instantiation of register file\n//\nor1200_rf or1200_rf(\n\t.clk(clk),\n\t.rst(rst),\n\t.cy_we_i(cy_we_alu),\n\t.cy_we_o(cy_we_rf),\n\t.supv(sr[`OR1200_SR_SM]),\n\t.wb_freeze(wb_freeze),\n\t.addrw(rf_addrw),\n\t.dataw(rf_dataw),\n\t.id_freeze(id_freeze),\n\t.we(rfwb_op[0]),\n\t.flushpipe(wb_flushpipe),\n\t.addra(rf_addra),\n\t.rda(rf_rda),\n\t.dataa(rf_dataa),\n\t.addrb(rf_addrb),\n\t.rdb(rf_rdb),\n\t.datab(rf_datab),\n\t.spr_cs(spr_cs[`OR1200_SPR_GROUP_SYS]),\n\t.spr_write(spr_we),\n\t.spr_addr(spr_addr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_dat_o(spr_dat_rf),\n\t.du_read(du_read)\n);\n\n//\n// Instantiation of operand muxes\n//\nor1200_operandmuxes or1200_operandmuxes(\n\t.clk(clk),\n\t.rst(rst),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.rf_dataa(rf_dataa),\n\t.rf_datab(rf_datab),\n\t.ex_forw(rf_dataw),\n\t.wb_forw(wb_forw),\n\t.simm(id_simm),\n\t.sel_a(sel_a),\n\t.sel_b(sel_b),\n\t.operand_a(operand_a),\n\t.operand_b(operand_b),\n\t.muxed_a(muxed_a),\n\t.muxed_b(muxed_b)\n);\n\n//\n// Instantiation of CPU's ALU\n//\nor1200_alu or1200_alu(\n\t.a(operand_a),\n\t.b(operand_b),\n\t.mult_mac_result(mult_mac_result),\n\t.macrc_op(ex_macrc_op),\n\t.alu_op(alu_op),\n\t.alu_op2(alu_op2),\t\t      \n\t.comp_op(comp_op),\n\t.cust5_op(cust5_op),\n\t.cust5_limm(cust5_limm),\n\t.result(alu_dataout),\n\t.flagforw(flagforw_alu),\n\t.flag_we(flag_we_alu),\n\t.cyforw(cyforw),\n\t.cy_we(cy_we_alu),\n\t.ovforw(ovforw),\n\t.ov_we(ov_we_alu),\t\t      \n\t.flag(flag),\n\t.carry(carry)\n);\n\n   \n//\n// FPU's exception is being dealt with\n//    \nassign fpu_except_started = except_started && (except_type == `OR1200_EXCEPT_FLOAT);\n   \n//\n// Instantiation of FPU\n//\nor1200_fpu or1200_fpu(\n\t.clk(clk),\n\t.rst(rst),\n\t.ex_freeze(ex_freeze),\n\t.a(operand_a),\n\t.b(operand_b),\n\t.fpu_op(fpu_op),\n\t.result(fpu_dataout),\n\t.done(fpu_done),\n\t.flagforw(flagforw_fpu),\n\t.flag_we(flag_we_fpu),\n        .sig_fp(sig_fp),\n\t.except_started(fpu_except_started),\n\t.fpcsr_we(fpcsr_we),\n\t.fpcsr(fpcsr),\t\t      \n\t.spr_cs(spr_cs[`OR1200_SPR_GROUP_FPU]),\n\t.spr_write(spr_we),\n\t.spr_addr(spr_addr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_dat_o(spr_dat_fpu)\n);\n\n   \n//\n// Instantiation of CPU's multiply unit\n//\nor1200_mult_mac or1200_mult_mac(\n\t.clk(clk),\n\t.rst(rst),\n\t.ex_freeze(ex_freeze),\n\t.id_macrc_op(id_macrc_op),\n\t.macrc_op(ex_macrc_op),\n\t.a(operand_a),\n\t.b(operand_b),\n\t.mac_op(mac_op),\n\t.alu_op(alu_op),\n\t.result(mult_mac_result),\n\t.ovforw(ovforw_mult_mac), \n\t.ov_we(ov_we_mult_mac),\n\t.mult_mac_stall(mult_mac_stall),\n\t.spr_cs(spr_cs[`OR1200_SPR_GROUP_MAC]),\n\t.spr_write(spr_we),\n\t.spr_addr(spr_addr),\n\t.spr_dat_i(spr_dat_cpu),\n\t.spr_dat_o(spr_dat_mac)\n);\n\n//\n// Instantiation of CPU's SPRS block\n//\nor1200_sprs or1200_sprs(\n\t.clk(clk),\n\t.rst(rst),\n\t.addrbase(operand_a),\n\t.addrofs(ex_simm[15:0]),\n\t.dat_i(operand_b),\n\t.ex_spr_read(ex_spr_read),\n\t.ex_spr_write(ex_spr_write),\n\t.flagforw(flagforw),\n\t.flag_we(flag_we),\n\t.flag(flag),\n\t.cyforw(cyforw),\n\t.cy_we(cy_we_rf),\n\t.carry(carry),\n\t.ovforw(ovforw | ovforw_mult_mac),\n\t.ov_we(ov_we_alu | ov_we_mult_mac),\n\t.to_wbmux(sprs_dataout),\n\n\t.du_addr(du_addr),\n\t.du_dat_du(du_dat_du),\n\t.du_read(du_read),\n\t.du_write(du_write),\n\t.du_dat_cpu(du_dat_cpu),\n\t.boot_adr_sel_i(boot_adr_sel_i),\n\t.spr_addr(spr_addr),\n\t.spr_dat_pic(spr_dat_pic),\n\t.spr_dat_tt(spr_dat_tt),\n\t.spr_dat_pm(spr_dat_pm),\n\t.spr_dat_cfgr(spr_dat_cfgr),\n\t.spr_dat_rf(spr_dat_rf),\n\t.spr_dat_npc(spr_dat_npc),\n        .spr_dat_ppc(spr_dat_ppc),\n\t.spr_dat_mac(spr_dat_mac),\n\t.spr_dat_dmmu(spr_dat_dmmu),\n\t.spr_dat_immu(spr_dat_immu),\n\t.spr_dat_du(spr_dat_du),\n\t.spr_dat_o(spr_dat_cpu),\n\t.spr_cs(spr_cs),\n\t.spr_we(spr_we),\n\n\t.epcr_we(epcr_we),\n\t.eear_we(eear_we),\n\t.esr_we(esr_we),\n\t.pc_we(pc_we),\n\t.epcr(epcr),\n\t.eear(eear),\n\t.esr(esr),\n\t.except_started(except_started),\n\n\t.fpcsr(fpcsr),\n\t.fpcsr_we(fpcsr_we),\t\t\t\n\t.spr_dat_fpu(spr_dat_fpu),\n\t\t\t\n\t.sr_we(sr_we),\n\t.to_sr(to_sr),\n\t.sr(sr),\n\t.branch_op(branch_op)\n);\n\n//\n// Instantiation of load/store unit\n//\nor1200_lsu or1200_lsu(\n\t.clk(clk),\n\t.rst(rst),\n\t.id_addrbase(muxed_a),\n\t.id_addrofs(id_simm),\n\t.ex_addrbase(operand_a),\n\t.ex_addrofs(ex_simm),\n\t.id_lsu_op(id_lsu_op),\n\t.lsu_datain(operand_b),\n\t.lsu_dataout(lsu_dataout),\n\t.lsu_stall(lsu_stall),\n\t.lsu_unstall(lsu_unstall),\n\t.du_stall(du_stall),\n\t.except_align(except_align),\n\t.except_dtlbmiss(except_dtlbmiss),\n\t.except_dmmufault(except_dmmufault),\n\t.except_dbuserr(except_dbuserr),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.flushpipe(ex_flushpipe),\n\n\t.dcpu_adr_o(dcpu_adr_o),\n\t.dcpu_cycstb_o(dcpu_cycstb_o),\n\t.dcpu_we_o(dcpu_we_o),\n\t.dcpu_sel_o(dcpu_sel_o),\n\t.dcpu_tag_o(dcpu_tag_o),\n\t.dcpu_dat_o(dcpu_dat_o),\n\t.dcpu_dat_i(dcpu_dat_i),\n\t.dcpu_ack_i(dcpu_ack_i),\n\t.dcpu_rty_i(dcpu_rty_i),\n\t.dcpu_err_i(dcpu_err_i),\n\t.dcpu_tag_i(dcpu_tag_i)\n);\n\n//\n// Instantiation of write-back muxes\n//\nor1200_wbmux or1200_wbmux(\n\t.clk(clk),\n\t.rst(rst),\n\t.wb_freeze(wb_freeze),\n\t.rfwb_op(rfwb_op),\n\t.muxin_a(alu_dataout),\n\t.muxin_b(lsu_dataout),\n\t.muxin_c(sprs_dataout),\n\t.muxin_d(ex_pc),\n        .muxin_e(fpu_dataout),\n\t.muxout(rf_dataw),\n\t.muxreg(wb_forw),\n\t.muxreg_valid(wbforw_valid)\n);\n\n//\n// Instantiation of freeze logic\n//\nor1200_freeze or1200_freeze(\n\t.clk(clk),\n\t.rst(rst),\n\t.multicycle(multicycle),\n        .wait_on(wait_on),\n\t.fpu_done(fpu_done),\n\t.mtspr_done(mtspr_done),\n\t.flushpipe(wb_flushpipe),\n\t.extend_flush(extend_flush),\n\t.lsu_stall(lsu_stall),\n\t.if_stall(if_stall),\n\t.lsu_unstall(lsu_unstall),\n\t.force_dslot_fetch(force_dslot_fetch),\n\t.abort_ex(abort_ex),\n\t.du_stall(du_stall),\n\t.mac_stall(mult_mac_stall),\n\t.saving_if_insn(saving_if_insn),\n\t.genpc_freeze(genpc_freeze),\n\t.if_freeze(if_freeze),\n\t.id_freeze(id_freeze),\n\t.ex_freeze(ex_freeze),\n\t.wb_freeze(wb_freeze),\n\t.icpu_ack_i(icpu_ack_i),\n\t.icpu_err_i(icpu_err_i)\n);\n\n//\n// Instantiation of exception block\n//\nor1200_except or1200_except(\n\t.clk(clk),\n\t.rst(rst),\n\t.sig_ibuserr(except_ibuserr),\n\t.sig_dbuserr(except_dbuserr),\n\t.sig_illegal(except_illegal),\n\t.sig_align(except_align),\n\t.sig_range(sig_range),\n\t.sig_dtlbmiss(except_dtlbmiss),\n\t.sig_dmmufault(except_dmmufault),\n\t.sig_int(sig_int),\n\t.sig_syscall(sig_syscall),\n\t.sig_trap(sig_trap),\n\t.sig_itlbmiss(except_itlbmiss),\n\t.sig_immufault(except_immufault),\n\t.sig_tick(sig_tick),\n\t.sig_fp(sig_fp),\n\t.fpcsr_fpee(fpcsr[`OR1200_FPCSR_FPEE]),\n\t.ex_branch_taken(ex_branch_taken),\n\t.icpu_ack_i(icpu_ack_i),\n\t.icpu_err_i(icpu_err_i),\n\t.dcpu_ack_i(dcpu_ack_i),\n\t.dcpu_err_i(dcpu_err_i),\n\t.genpc_freeze(genpc_freeze),\n        .id_freeze(id_freeze),\n        .ex_freeze(ex_freeze),\n        .wb_freeze(wb_freeze),\n\t.if_stall(if_stall),\n\t.if_pc(if_pc),\n\t.id_pc(id_pc),\n\t.ex_pc(ex_pc),\n\t.wb_pc(wb_pc),\n\t.id_flushpipe(id_flushpipe),\n\t.ex_flushpipe(ex_flushpipe),\n\t.extend_flush(extend_flush),\n\t.except_flushpipe(except_flushpipe),\n\t.abort_mvspr(abort_mvspr),\n\t.except_type(except_type),\n\t.except_start(except_start),\n\t.except_started(except_started),\n\t.except_stop(except_stop),\n\t.except_trig(except_trig),\n\t.ex_void(ex_void),\n\t.spr_dat_ppc(spr_dat_ppc),\n\t.spr_dat_npc(spr_dat_npc),\n\n\t.datain(spr_dat_cpu),\n\t.branch_op(branch_op),\n\t.du_dsr(du_dsr),\n\t.du_dmr1(du_dmr1),\n\t.du_hwbkpt(du_hwbkpt),\n\t.du_hwbkpt_ls_r(du_hwbkpt_ls_r),\n\t.epcr_we(epcr_we),\n\t.eear_we(eear_we),\n\t.esr_we(esr_we),\n\t.pc_we(pc_we),\n        .epcr(epcr),\n\t.eear(eear),\n\t.esr(esr),\n\n\t.lsu_addr(dcpu_adr_o),\n\t.sr_we(sr_we),\n\t.to_sr(to_sr),\n\t.sr(sr),\n\t.abort_ex(abort_ex)\n);\n\n//\n// Instantiation of configuration registers\n//\nor1200_cfgr or1200_cfgr(\n\t.spr_addr(spr_addr),\n\t.spr_dat_o(spr_dat_cfgr)\n);\n\nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's definitions                                        ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://opencores.org/project,or1k                           ////\n////                                                              ////\n////  Description                                                 ////\n////  Defines for the OR1200 core                                 ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - add parameters that are missing                          ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_defines.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Minor update: \n// Defines added, bugs fixed. \n\n//\n// Dump VCD\n//\n//`define OR1200_VCD_DUMP\n\n//\n// Generate debug messages during simulation\n//\n//`define OR1200_VERBOSE\n\n//  `define OR1200_ASIC\n////////////////////////////////////////////////////////\n//\n// Typical configuration for an ASIC\n//\n`ifdef OR1200_ASIC\n\n//\n// Target ASIC memories\n//\n//`define OR1200_ARTISAN_SSP\n//`define OR1200_ARTISAN_SDP\n//`define OR1200_ARTISAN_STP\n`define OR1200_VIRTUALSILICON_SSP\n//`define OR1200_VIRTUALSILICON_STP_T1\n//`define OR1200_VIRTUALSILICON_STP_T2\n\n//\n// Do not implement Data cache\n//\n//`define OR1200_NO_DC\n\n//\n// Do not implement Insn cache\n//\n//`define OR1200_NO_IC\n\n//\n// Do not implement Data MMU\n//\n//`define OR1200_NO_DMMU\n\n//\n// Do not implement Insn MMU\n//\n//`define OR1200_NO_IMMU\n\n//\n// Select between ASIC optimized and generic multiplier\n//\n//`define OR1200_ASIC_MULTP2_32X32\n`define OR1200_GENERIC_MULTP2_32X32\n\n//\n// Size/type of insn/data cache if implemented\n//\n// `define OR1200_IC_1W_512B\n// `define OR1200_IC_1W_4KB\n`define OR1200_IC_1W_8KB\n// `define OR1200_DC_1W_4KB\n`define OR1200_DC_1W_8KB\n\n`else\n\n\n/////////////////////////////////////////////////////////\n//\n// Typical configuration for an FPGA\n//\n\n//\n// Target FPGA memories\n//\n//`define OR1200_ALTERA_LPM\n//`define OR1200_XILINX_RAMB16\n//`define OR1200_XILINX_RAMB4\n//`define OR1200_XILINX_RAM32X1D\n//`define OR1200_USE_RAM16X1D_FOR_RAM32X1D\n// Generic models should infer RAM blocks at synthesis time (not only effects \n// single port ram.)\n`define OR1200_GENERIC\n\n//\n// Do not implement Data cache\n//\n//`define OR1200_NO_DC\n\n//\n// Do not implement Insn cache\n//\n//`define OR1200_NO_IC\n\n//\n// Do not implement Data MMU\n//\n//`define OR1200_NO_DMMU\n\n//\n// Do not implement Insn MMU\n//\n//`define OR1200_NO_IMMU\n\n//\n// Select between ASIC and generic multiplier\n//\n// (Generic seems to trigger a bug in the Cadence Ncsim simulator)\n//\n//`define OR1200_ASIC_MULTP2_32X32\n`define OR1200_GENERIC_MULTP2_32X32\n\n//\n// Size/type of insn/data cache if implemented\n// (consider available FPGA memory resources)\n//\n//`define OR1200_IC_1W_512B\n//`define OR1200_IC_1W_4KB\n`define OR1200_IC_1W_8KB\n//`define OR1200_IC_1W_16KB\n//`define OR1200_IC_1W_32KB\n//`define OR1200_DC_1W_4KB\n`define OR1200_DC_1W_8KB\n//`define OR1200_DC_1W_16KB\n//`define OR1200_DC_1W_32KB\n\n`endif\n\n\n//////////////////////////////////////////////////////////\n//\n// Do not change below unless you know what you are doing\n//\n\n//\n// Reset active low\n//\n//`define OR1200_RST_ACT_LOW\n\n//\n// Enable RAM BIST\n//\n// At the moment this only works for Virtual Silicon\n// single port RAMs. For other RAMs it has not effect.\n// Special wrapper for VS RAMs needs to be provided\n// with scan flops to facilitate bist scan.\n//\n//`define OR1200_BIST\n\n//\n// Register OR1200 WISHBONE outputs\n// (must be defined/enabled)\n//\n`define OR1200_REGISTERED_OUTPUTS\n\n//\n// Register OR1200 WISHBONE inputs\n//\n// (must be undefined/disabled)\n//\n//`define OR1200_REGISTERED_INPUTS\n\n//\n// Disable bursts if they are not supported by the\n// memory subsystem (only affect cache line fill)\n//\n//`define OR1200_NO_BURSTS\n//\n\n//\n// WISHBONE retry counter range\n//\n// 2^value range for retry counter. Retry counter\n// is activated whenever *wb_rty_i is asserted and\n// until retry counter expires, corresponding\n// WISHBONE interface is deactivated.\n//\n// To disable retry counters and *wb_rty_i all together,\n// undefine this macro.\n//\n//`define OR1200_WB_RETRY 7\n\n//\n// WISHBONE Consecutive Address Burst\n//\n// This was used prior to WISHBONE B3 specification\n// to identify bursts. It is no longer needed but\n// remains enabled for compatibility with old designs.\n//\n// To remove *wb_cab_o ports undefine this macro.\n//\n//`define OR1200_WB_CAB\n\n//\n// WISHBONE B3 compatible interface\n//\n// This follows the WISHBONE B3 specification.\n// It is not enabled by default because most\n// designs still don't use WB b3.\n//\n// To enable *wb_cti_o/*wb_bte_o ports,\n// define this macro.\n//\n`define OR1200_WB_B3\n\n//\n// LOG all WISHBONE accesses\n//\n`define OR1200_LOG_WB_ACCESS\n\n//\n// Enable additional synthesis directives if using\n// _Synopsys_ synthesis tool\n//\n//`define OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES\n\n//\n// Enables default statement in some case blocks\n// and disables Synopsys synthesis directive full_case\n//\n// By default it is enabled. When disabled it\n// can increase clock frequency.\n//\n`define OR1200_CASE_DEFAULT\n\n//\n// Operand width / register file address width\n//\n// (DO NOT CHANGE)\n//\n`define OR1200_OPERAND_WIDTH\t\t32\n`define OR1200_REGFILE_ADDR_WIDTH\t5\n\n//\n// l.add/l.addi/l.and and optional l.addc/l.addic\n// also set (compare) flag when result of their\n// operation equals zero\n//\n// At the time of writing this, default or32\n// C/C++ compiler doesn't generate code that\n// would benefit from this optimization.\n//\n// By default this optimization is disabled to\n// save area.\n//\n//`define OR1200_ADDITIONAL_FLAG_MODIFIERS\n\n//\n// Implement l.addc/l.addic instructions\n//\n// By default implementation of l.addc/l.addic\n// instructions is enabled in case you need them.\n// If you don't use them, then disable implementation\n// to save area.\n//\n`define OR1200_IMPL_ADDC\n\n//\n// Implement l.sub instruction\n//\n// By default implementation of l.sub instructions\n// is enabled to be compliant with the simulator.\n// If you don't use carry bit, then disable\n// implementation to save area.\n//\n`define OR1200_IMPL_SUB\n\n//\n// Implement carry bit SR[CY]\n//\n//\n// By default implementation of SR[CY] is enabled\n// to be compliant with the simulator. However SR[CY]\n// is explicitly only used by l.addc/l.addic/l.sub\n// instructions and if these three insns are not\n// implemented there is not much point having SR[CY].\n//\n`define OR1200_IMPL_CY\n\n//\n// Implement carry bit SR[OV]\n//\n// Compiler doesn't use this, but other code may like\n// to.\n//\n`define OR1200_IMPL_OV\n\n//\n// Implement carry bit SR[OVE]\n//\n// Overflow interrupt indicator. When enabled, SR[OV] flag\n// does not remain asserted after exception.\n//\n`define OR1200_IMPL_OVE\n\n\n//\n// Implement rotate in the ALU\n//\n// At the time of writing this, or32\n// C/C++ compiler doesn't generate rotate\n// instructions. However or32 assembler\n// can assemble code that uses rotate insn.\n// This means that rotate instructions\n// must be used manually inserted.\n//\n// By default implementation of rotate\n// is disabled to save area and increase\n// clock frequency.\n//\n//`define OR1200_IMPL_ALU_ROTATE\n\n//\n// Type of ALU compare to implement\n//\n// Try either one to find what yields\n// higher clock frequencyin your case.\n//\n//`define OR1200_IMPL_ALU_COMP1\n`define OR1200_IMPL_ALU_COMP2\n\n//\n// Implement Find First/Last '1'\n//\n`define OR1200_IMPL_ALU_FFL1\n\n//\n// Implement l.cust5 ALU instruction\n//\n//`define OR1200_IMPL_ALU_CUST5\n\n//\n// Implement l.extXs and l.extXz instructions\n//\n`define OR1200_IMPL_ALU_EXT\n\n//\n// Implement multiplier\n//\n// By default multiplier is implemented\n//\n`define OR1200_MULT_IMPLEMENTED\n\n//\n// Implement multiply-and-accumulate\n//\n// By default MAC is implemented. To\n// implement MAC, multiplier (non-serial) needs to be\n// implemented.\n//\n//`define OR1200_MAC_IMPLEMENTED\n\n//\n// Implement optional l.div/l.divu instructions\n//\n// By default divide instructions are not implemented\n// to save area.\n//\n//\n`define OR1200_DIV_IMPLEMENTED\n\n//\n// Serial multiplier.\n//\n//`define OR1200_MULT_SERIAL\n\n//\n// Serial divider.\n// Uncomment to use a serial divider, otherwise will\n// be a generic parallel implementation.\n//\n`define OR1200_DIV_SERIAL\n\n//\n// Implement HW Single Precision FPU\n//\n//`define OR1200_FPU_IMPLEMENTED\n\n//\n// Clock ratio RISC clock versus WB clock\n//\n// If you plan to run WB:RISC clock fixed to 1:1, disable\n// both defines\n//\n// For WB:RISC 1:2 or 1:1, enable OR1200_CLKDIV_2_SUPPORTED\n// and use clmode to set ratio\n//\n// For WB:RISC 1:4, 1:2 or 1:1, enable both defines and use\n// clmode to set ratio\n//\n//`define OR1200_CLKDIV_2_SUPPORTED\n//`define OR1200_CLKDIV_4_SUPPORTED\n\n//\n// Type of register file RAM\n//\n// Memory macro w/ two ports (see or1200_tpram_32x32.v)\n//`define OR1200_RFRAM_TWOPORT\n//\n// Memory macro dual port (see or1200_dpram.v)\n`define OR1200_RFRAM_DUALPORT\n\n//\n// Generic (flip-flop based) register file (see or1200_rfram_generic.v)\n//`define OR1200_RFRAM_GENERIC\n//  Generic register file supports - 16 registers \n`ifdef OR1200_RFRAM_GENERIC\n//    `define OR1200_RFRAM_16REG\n`endif\n\n//\n// Type of mem2reg aligner to implement.\n//\n// Once OR1200_IMPL_MEM2REG2 yielded faster\n// circuit, however with today tools it will\n// most probably give you slower circuit.\n//\n`define OR1200_IMPL_MEM2REG1\n//`define OR1200_IMPL_MEM2REG2\n\n//\n// Reset value and event\n//\n`ifdef OR1200_RST_ACT_LOW\n  `define OR1200_RST_VALUE      (1'b0)\n  `define OR1200_RST_EVENT      negedge\n`else\n  `define OR1200_RST_VALUE      (1'b1)\n  `define OR1200_RST_EVENT      posedge\n`endif\n\n//\n// ALUOPs\n//\n`define OR1200_ALUOP_WIDTH\t5\n`define OR1200_ALUOP_NOP\t5'b0_0100\n/* LS-nibble encodings correspond to bits [3:0] of instruction */\n`define OR1200_ALUOP_ADD\t5'b0_0000 // 0\n`define OR1200_ALUOP_ADDC\t5'b0_0001 // 1\n`define OR1200_ALUOP_SUB\t5'b0_0010 // 2\n`define OR1200_ALUOP_AND\t5'b0_0011 // 3\n`define OR1200_ALUOP_OR\t\t5'b0_0100 // 4\n`define OR1200_ALUOP_XOR\t5'b0_0101 // 5\n`define OR1200_ALUOP_MUL\t5'b0_0110 // 6\n`define OR1200_ALUOP_RESERVED\t5'b0_0111 // 7\n`define OR1200_ALUOP_SHROT\t5'b0_1000 // 8\n`define OR1200_ALUOP_DIV\t5'b0_1001 // 9\n`define OR1200_ALUOP_DIVU\t5'b0_1010 // a\n`define OR1200_ALUOP_MULU\t5'b0_1011 // b\n`define OR1200_ALUOP_EXTHB\t5'b0_1100 // c\n`define OR1200_ALUOP_EXTW\t5'b0_1101 // d\n`define OR1200_ALUOP_CMOV\t5'b0_1110 // e\n`define OR1200_ALUOP_FFL1\t5'b0_1111 // f\n\n/* Values sent to ALU from decode unit - not defined by ISA */\n`define OR1200_ALUOP_COMP       5'b1_0000 // Comparison\n`define OR1200_ALUOP_MOVHI      5'b1_0001 // Move-high\n`define OR1200_ALUOP_CUST5\t5'b1_0010 // l.cust5\n\n// ALU instructions second opcode field\n`define OR1200_ALUOP2_POS\t9:6\n`define OR1200_ALUOP2_WIDTH\t4\n\n//\n// MACOPs\n//\n`define OR1200_MACOP_WIDTH\t3\n`define OR1200_MACOP_NOP\t3'b000\n`define OR1200_MACOP_MAC\t3'b001\n`define OR1200_MACOP_MSB\t3'b010\n\n//\n// Shift/rotate ops\n//\n`define OR1200_SHROTOP_WIDTH\t4\n`define OR1200_SHROTOP_NOP\t4'd0\n`define OR1200_SHROTOP_SLL\t4'd0\n`define OR1200_SHROTOP_SRL\t4'd1\n`define OR1200_SHROTOP_SRA\t4'd2\n`define OR1200_SHROTOP_ROR\t4'd3\n\n//\n// Zero/Sign Extend ops\n//\n`define OR1200_EXTHBOP_WIDTH      4\n`define OR1200_EXTHBOP_BS         4'h1\n`define OR1200_EXTHBOP_HS         4'h0\n`define OR1200_EXTHBOP_BZ         4'h3\n`define OR1200_EXTHBOP_HZ         4'h2\n`define OR1200_EXTWOP_WIDTH       4\n`define OR1200_EXTWOP_WS          4'h0\n`define OR1200_EXTWOP_WZ          4'h1\n\n// Execution cycles per instruction\n`define OR1200_MULTICYCLE_WIDTH\t3\n`define OR1200_ONE_CYCLE\t\t3'd0\n`define OR1200_TWO_CYCLES\t\t3'd1\n\n// Execution control which will \"wait on\" a module to finish\n`define OR1200_WAIT_ON_WIDTH 2\n`define OR1200_WAIT_ON_NOTHING    `OR1200_WAIT_ON_WIDTH'd0\n`define OR1200_WAIT_ON_MULTMAC    `OR1200_WAIT_ON_WIDTH'd1\n`define OR1200_WAIT_ON_FPU        `OR1200_WAIT_ON_WIDTH'd2\n`define OR1200_WAIT_ON_MTSPR      `OR1200_WAIT_ON_WIDTH'd3\n\n\n// Operand MUX selects\n`define OR1200_SEL_WIDTH\t\t2\n`define OR1200_SEL_RF\t\t\t2'd0\n`define OR1200_SEL_IMM\t\t\t2'd1\n`define OR1200_SEL_EX_FORW\t\t2'd2\n`define OR1200_SEL_WB_FORW\t\t2'd3\n\n//\n// BRANCHOPs\n//\n`define OR1200_BRANCHOP_WIDTH\t\t3\n`define OR1200_BRANCHOP_NOP\t\t3'd0\n`define OR1200_BRANCHOP_J\t\t3'd1\n`define OR1200_BRANCHOP_JR\t\t3'd2\n`define OR1200_BRANCHOP_BAL\t\t3'd3\n`define OR1200_BRANCHOP_BF\t\t3'd4\n`define OR1200_BRANCHOP_BNF\t\t3'd5\n`define OR1200_BRANCHOP_RFE\t\t3'd6\n\n//\n// LSUOPs\n//\n// Bit 0: sign extend\n// Bits 1-2: 00 doubleword, 01 byte, 10 halfword, 11 singleword\n// Bit 3: 0 load, 1 store\n`define OR1200_LSUOP_WIDTH\t\t4\n`define OR1200_LSUOP_NOP\t\t4'b0000\n`define OR1200_LSUOP_LBZ\t\t4'b0010\n`define OR1200_LSUOP_LBS\t\t4'b0011\n`define OR1200_LSUOP_LHZ\t\t4'b0100\n`define OR1200_LSUOP_LHS\t\t4'b0101\n`define OR1200_LSUOP_LWZ\t\t4'b0110\n`define OR1200_LSUOP_LWS\t\t4'b0111\n`define OR1200_LSUOP_LD\t\t\t4'b0001\n`define OR1200_LSUOP_SD\t\t\t4'b1000\n`define OR1200_LSUOP_SB\t\t\t4'b1010\n`define OR1200_LSUOP_SH\t\t\t4'b1100\n`define OR1200_LSUOP_SW\t\t\t4'b1110\n\n// Number of bits of load/store EA precalculated in ID stage\n// for balancing ID and EX stages.\n//\n// Valid range: 2,3,...,30,31\n`define OR1200_LSUEA_PRECALC\t\t2\n\n// FETCHOPs\n`define OR1200_FETCHOP_WIDTH\t\t1\n`define OR1200_FETCHOP_NOP\t\t1'b0\n`define OR1200_FETCHOP_LW\t\t1'b1\n\n//\n// Register File Write-Back OPs\n//\n// Bit 0: register file write enable\n// Bits 3-1: write-back mux selects\n//\n`define OR1200_RFWBOP_WIDTH\t\t4\n`define OR1200_RFWBOP_NOP\t\t4'b0000\n`define OR1200_RFWBOP_ALU\t\t3'b000\n`define OR1200_RFWBOP_LSU\t\t3'b001\n`define OR1200_RFWBOP_SPRS\t\t3'b010\n`define OR1200_RFWBOP_LR\t\t3'b011\n`define OR1200_RFWBOP_FPU\t\t3'b100\n\n// Compare instructions\n`define OR1200_COP_SFEQ       3'b000\n`define OR1200_COP_SFNE       3'b001\n`define OR1200_COP_SFGT       3'b010\n`define OR1200_COP_SFGE       3'b011\n`define OR1200_COP_SFLT       3'b100\n`define OR1200_COP_SFLE       3'b101\n`define OR1200_COP_X          3'b111\n`define OR1200_SIGNED_COMPARE 'd3\n`define OR1200_COMPOP_WIDTH\t4\n\n//\n// FP OPs\n//\n// MSbit indicates FPU operation valid\n//\n`define OR1200_FPUOP_WIDTH\t8\n// FPU unit from Usselman takes 5 cycles from decode, so 4 ex. cycles\n`define OR1200_FPUOP_CYCLES 3'd4\n// FP instruction is double precision if bit 4 is set. We're a 32-bit \n// implementation thus do not support double precision FP \n`define OR1200_FPUOP_DOUBLE_BIT 4\n`define OR1200_FPUOP_ADD  8'b0000_0000\n`define OR1200_FPUOP_SUB  8'b0000_0001\n`define OR1200_FPUOP_MUL  8'b0000_0010\n`define OR1200_FPUOP_DIV  8'b0000_0011\n`define OR1200_FPUOP_ITOF 8'b0000_0100\n`define OR1200_FPUOP_FTOI 8'b0000_0101\n`define OR1200_FPUOP_REM  8'b0000_0110\n`define OR1200_FPUOP_RESERVED  8'b0000_0111\n// FP Compare instructions\n`define OR1200_FPCOP_SFEQ 8'b0000_1000\n`define OR1200_FPCOP_SFNE 8'b0000_1001\n`define OR1200_FPCOP_SFGT 8'b0000_1010\n`define OR1200_FPCOP_SFGE 8'b0000_1011\n`define OR1200_FPCOP_SFLT 8'b0000_1100\n`define OR1200_FPCOP_SFLE 8'b0000_1101\n\n//\n// TAGs for instruction bus\n//\n`define OR1200_ITAG_IDLE\t4'h0\t// idle bus\n`define\tOR1200_ITAG_NI\t\t4'h1\t// normal insn\n`define OR1200_ITAG_BE\t\t4'hb\t// Bus error exception\n`define OR1200_ITAG_PE\t\t4'hc\t// Page fault exception\n`define OR1200_ITAG_TE\t\t4'hd\t// TLB miss exception\n\n//\n// TAGs for data bus\n//\n`define OR1200_DTAG_IDLE\t4'h0\t// idle bus\n`define\tOR1200_DTAG_ND\t\t4'h1\t// normal data\n`define OR1200_DTAG_AE\t\t4'ha\t// Alignment exception\n`define OR1200_DTAG_BE\t\t4'hb\t// Bus error exception\n`define OR1200_DTAG_PE\t\t4'hc\t// Page fault exception\n`define OR1200_DTAG_TE\t\t4'hd\t// TLB miss exception\n\n\n//////////////////////////////////////////////\n//\n// ORBIS32 ISA specifics\n//\n\n// SHROT_OP position in machine word\n`define OR1200_SHROTOP_POS\t\t7:6\n\n//\n// Instruction opcode groups (basic)\n//\n`define OR1200_OR32_J                 6'b000000\n`define OR1200_OR32_JAL               6'b000001\n`define OR1200_OR32_BNF               6'b000011\n`define OR1200_OR32_BF                6'b000100\n`define OR1200_OR32_NOP               6'b000101\n`define OR1200_OR32_MOVHI             6'b000110\n`define OR1200_OR32_MACRC             6'b000110\n`define OR1200_OR32_XSYNC             6'b001000\n`define OR1200_OR32_RFE               6'b001001\n/* */\n`define OR1200_OR32_JR                6'b010001\n`define OR1200_OR32_JALR              6'b010010\n`define OR1200_OR32_MACI              6'b010011\n/* */\n`define OR1200_OR32_LWZ               6'b100001\n`define OR1200_OR32_LBZ               6'b100011\n`define OR1200_OR32_LBS               6'b100100\n`define OR1200_OR32_LHZ               6'b100101\n`define OR1200_OR32_LHS               6'b100110\n`define OR1200_OR32_ADDI              6'b100111\n`define OR1200_OR32_ADDIC             6'b101000\n`define OR1200_OR32_ANDI              6'b101001\n`define OR1200_OR32_ORI               6'b101010\n`define OR1200_OR32_XORI              6'b101011\n`define OR1200_OR32_MULI              6'b101100\n`define OR1200_OR32_MFSPR             6'b101101\n`define OR1200_OR32_SH_ROTI \t      6'b101110\n`define OR1200_OR32_SFXXI             6'b101111\n/* */\n`define OR1200_OR32_MTSPR             6'b110000\n`define OR1200_OR32_MACMSB            6'b110001\n`define OR1200_OR32_FLOAT             6'b110010\n/* */\n`define OR1200_OR32_SW                6'b110101\n`define OR1200_OR32_SB                6'b110110\n`define OR1200_OR32_SH                6'b110111\n`define OR1200_OR32_ALU               6'b111000\n`define OR1200_OR32_SFXX              6'b111001\n`define OR1200_OR32_CUST5             6'b111100\n\n/////////////////////////////////////////////////////\n//\n// Exceptions\n//\n\n//\n// Exception vectors per OR1K architecture:\n// 0xPPPPP100 - reset\n// 0xPPPPP200 - bus error\n// ... etc\n// where P represents exception prefix.\n//\n// Exception vectors can be customized as per\n// the following formula:\n// 0xPPPPPNVV - exception N\n//\n// P represents exception prefix\n// N represents exception N\n// VV represents length of the individual vector space,\n//   usually it is 8 bits wide and starts with all bits zero\n//\n\n//\n// PPPPP and VV parts\n//\n// Sum of these two defines needs to be 28\n//\n`define OR1200_EXCEPT_EPH0_P    20'h00000\n`define OR1200_EXCEPT_EPH1_P    20'hF0000\n`define OR1200_EXCEPT_V\t\t    8'h00\n\n//\n// N part width\n//\n`define OR1200_EXCEPT_WIDTH 4\n\n//\n// Definition of exception vectors\n//\n// To avoid implementation of a certain exception,\n// simply comment out corresponding line\n//\n`define OR1200_EXCEPT_UNUSED\t\t`OR1200_EXCEPT_WIDTH'hf\n`define OR1200_EXCEPT_TRAP\t\t`OR1200_EXCEPT_WIDTH'he\n`define OR1200_EXCEPT_FLOAT\t\t`OR1200_EXCEPT_WIDTH'hd\n`define OR1200_EXCEPT_SYSCALL\t\t`OR1200_EXCEPT_WIDTH'hc\n`define OR1200_EXCEPT_RANGE\t\t`OR1200_EXCEPT_WIDTH'hb\n`define OR1200_EXCEPT_ITLBMISS\t\t`OR1200_EXCEPT_WIDTH'ha\n`define OR1200_EXCEPT_DTLBMISS\t\t`OR1200_EXCEPT_WIDTH'h9\n`define OR1200_EXCEPT_INT\t\t`OR1200_EXCEPT_WIDTH'h8\n`define OR1200_EXCEPT_ILLEGAL\t\t`OR1200_EXCEPT_WIDTH'h7\n`define OR1200_EXCEPT_ALIGN\t\t`OR1200_EXCEPT_WIDTH'h6\n`define OR1200_EXCEPT_TICK\t\t`OR1200_EXCEPT_WIDTH'h5\n`define OR1200_EXCEPT_IPF\t\t`OR1200_EXCEPT_WIDTH'h4\n`define OR1200_EXCEPT_DPF\t\t`OR1200_EXCEPT_WIDTH'h3\n`define OR1200_EXCEPT_BUSERR\t\t`OR1200_EXCEPT_WIDTH'h2\n`define OR1200_EXCEPT_RESET\t\t`OR1200_EXCEPT_WIDTH'h1\n`define OR1200_EXCEPT_NONE\t\t`OR1200_EXCEPT_WIDTH'h0\n\n\n/////////////////////////////////////////////////////\n//\n// SPR groups\n//\n\n// Bits that define the group\n`define OR1200_SPR_GROUP_BITS\t15:11\n\n// Width of the group bits\n`define OR1200_SPR_GROUP_WIDTH \t5\n\n// Bits that define offset inside the group\n`define OR1200_SPR_OFS_BITS 10:0\n\n// List of groups\n`define OR1200_SPR_GROUP_SYS\t5'd00\n`define OR1200_SPR_GROUP_DMMU\t5'd01\n`define OR1200_SPR_GROUP_IMMU\t5'd02\n`define OR1200_SPR_GROUP_DC\t5'd03\n`define OR1200_SPR_GROUP_IC\t5'd04\n`define OR1200_SPR_GROUP_MAC\t5'd05\n`define OR1200_SPR_GROUP_DU\t5'd06\n`define OR1200_SPR_GROUP_PM\t5'd08\n`define OR1200_SPR_GROUP_PIC\t5'd09\n`define OR1200_SPR_GROUP_TT\t5'd10\n`define OR1200_SPR_GROUP_FPU    5'd11\n\n/////////////////////////////////////////////////////\n//\n// System group\n//\n\n//\n// System registers\n//\n`define OR1200_SPR_CFGR\t\t7'd0\n`define OR1200_SPR_RF\t\t6'd32\t// 1024 >> 5\n`define OR1200_SPR_NPC\t\t11'd16\n`define OR1200_SPR_SR\t\t11'd17\n`define OR1200_SPR_PPC\t\t11'd18\n`define OR1200_SPR_FPCSR        11'd20\n`define OR1200_SPR_EPCR\t\t11'd32\n`define OR1200_SPR_EEAR\t\t11'd48\n`define OR1200_SPR_ESR\t\t11'd64\n\n//\n// SR bits\n//\n`define OR1200_SR_WIDTH 17\n`define OR1200_SR_SM   0\n`define OR1200_SR_TEE  1\n`define OR1200_SR_IEE  2\n`define OR1200_SR_DCE  3\n`define OR1200_SR_ICE  4\n`define OR1200_SR_DME  5\n`define OR1200_SR_IME  6\n`define OR1200_SR_LEE  7\n`define OR1200_SR_CE   8\n`define OR1200_SR_F    9\n`define OR1200_SR_CY   10\t// Optional\n`define OR1200_SR_OV   11\t// Optional\n`define OR1200_SR_OVE  12\t// Optional\n`define OR1200_SR_DSX  13\t// Unused\n`define OR1200_SR_EPH  14\n`define OR1200_SR_FO   15\n`define OR1200_SR_TED  16\n`define OR1200_SR_CID  31:28\t// Unimplemented\n\n//\n// Bits that define offset inside the group\n//\n`define OR1200_SPROFS_BITS 10:0\n\n//\n// Default Exception Prefix\n//\n// 1'b0 - OR1200_EXCEPT_EPH0_P (0x0000_0000)\n// 1'b1 - OR1200_EXCEPT_EPH1_P (0xF000_0000)\n//\n`define OR1200_SR_EPH_DEF\t1'b0\n\n\n//\n// FPCSR bits\n//\n`define OR1200_FPCSR_WIDTH 12\n`define OR1200_FPCSR_FPEE  0\n`define OR1200_FPCSR_RM    2:1\n`define OR1200_FPCSR_OVF   3\n`define OR1200_FPCSR_UNF   4\n`define OR1200_FPCSR_SNF   5\n`define OR1200_FPCSR_QNF   6\n`define OR1200_FPCSR_ZF    7\n`define OR1200_FPCSR_IXF   8\n`define OR1200_FPCSR_IVF   9\n`define OR1200_FPCSR_INF   10\n`define OR1200_FPCSR_DZF   11\n`define OR1200_FPCSR_RES   31:12\n\n/////////////////////////////////////////////////////\n//\n// Power Management (PM)\n//\n\n// Define it if you want PM implemented\n//`define OR1200_PM_IMPLEMENTED\n\n// Bit positions inside PMR (don't change)\n`define OR1200_PM_PMR_SDF 3:0\n`define OR1200_PM_PMR_DME 4\n`define OR1200_PM_PMR_SME 5\n`define OR1200_PM_PMR_DCGE 6\n`define OR1200_PM_PMR_UNUSED 31:7\n\n// PMR offset inside PM group of registers\n`define OR1200_PM_OFS_PMR 11'b0\n\n// PM group\n`define OR1200_SPRGRP_PM 5'd8\n\n// Define if PMR can be read/written at any address inside PM group\n`define OR1200_PM_PARTIAL_DECODING\n\n// Define if reading PMR is allowed\n`define OR1200_PM_READREGS\n\n// Define if unused PMR bits should be zero\n`define OR1200_PM_UNUSED_ZERO\n\n\n/////////////////////////////////////////////////////\n//\n// Debug Unit (DU)\n//\n\n// Define it if you want DU implemented\n`define OR1200_DU_IMPLEMENTED\n\n//\n// Define if you want HW Breakpoints\n// (if HW breakpoints are not implemented\n// only default software trapping is\n// possible with l.trap insn - this is\n// however already enough for use\n// with or32 gdb)\n//\n//`define OR1200_DU_HWBKPTS\n\n// Number of DVR/DCR pairs if HW breakpoints enabled\n//\tComment / uncomment DU_DVRn / DU_DCRn pairs bellow according to this number ! \n//\tDU_DVR0..DU_DVR7 should be uncommented for 8 DU_DVRDCR_PAIRS \n`define OR1200_DU_DVRDCR_PAIRS 8\n\n// Define if you want trace buffer\n//\t(for now only available for Xilinx Virtex FPGAs)\n//`define OR1200_DU_TB_IMPLEMENTED\n\n\n//\n// Address offsets of DU registers inside DU group\n//\n// To not implement a register, doq not define its address\n//\n`ifdef OR1200_DU_HWBKPTS\n`define OR1200_DU_DVR0\t\t11'd0\n`define OR1200_DU_DVR1\t\t11'd1\n`define OR1200_DU_DVR2\t\t11'd2\n`define OR1200_DU_DVR3\t\t11'd3\n`define OR1200_DU_DVR4\t\t11'd4\n`define OR1200_DU_DVR5\t\t11'd5\n`define OR1200_DU_DVR6\t\t11'd6\n`define OR1200_DU_DVR7\t\t11'd7\n`define OR1200_DU_DCR0\t\t11'd8\n`define OR1200_DU_DCR1\t\t11'd9\n`define OR1200_DU_DCR2\t\t11'd10\n`define OR1200_DU_DCR3\t\t11'd11\n`define OR1200_DU_DCR4\t\t11'd12\n`define OR1200_DU_DCR5\t\t11'd13\n`define OR1200_DU_DCR6\t\t11'd14\n`define OR1200_DU_DCR7\t\t11'd15\n`endif\n`define OR1200_DU_DMR1\t\t11'd16\n`ifdef OR1200_DU_HWBKPTS\n`define OR1200_DU_DMR2\t\t11'd17\n`define OR1200_DU_DWCR0\t\t11'd18\n`define OR1200_DU_DWCR1\t\t11'd19\n`endif\n`define OR1200_DU_DSR\t\t11'd20\n`define OR1200_DU_DRR\t\t11'd21\n`ifdef OR1200_DU_TB_IMPLEMENTED\n`define OR1200_DU_TBADR\t\t11'h0ff\n`define OR1200_DU_TBIA\t\t11'h1??\n`define OR1200_DU_TBIM\t\t11'h2??\n`define OR1200_DU_TBAR\t\t11'h3??\n`define OR1200_DU_TBTS\t\t11'h4??\n`endif\n\n// Position of offset bits inside SPR address\n`define OR1200_DUOFS_BITS\t10:0\n\n// DCR bits\n`define OR1200_DU_DCR_DP\t0\n`define OR1200_DU_DCR_CC\t3:1\n`define OR1200_DU_DCR_SC\t4\n`define OR1200_DU_DCR_CT\t7:5\n\n// DMR1 bits\n`define OR1200_DU_DMR1_CW0\t1:0\n`define OR1200_DU_DMR1_CW1\t3:2\n`define OR1200_DU_DMR1_CW2\t5:4\n`define OR1200_DU_DMR1_CW3\t7:6\n`define OR1200_DU_DMR1_CW4\t9:8\n`define OR1200_DU_DMR1_CW5\t11:10\n`define OR1200_DU_DMR1_CW6\t13:12\n`define OR1200_DU_DMR1_CW7\t15:14\n`define OR1200_DU_DMR1_CW8\t17:16\n`define OR1200_DU_DMR1_CW9\t19:18\n`define OR1200_DU_DMR1_CW10\t21:20\n`define OR1200_DU_DMR1_ST\t22\n`define OR1200_DU_DMR1_BT\t23\n`define OR1200_DU_DMR1_DXFW\t24\n`define OR1200_DU_DMR1_ETE\t25\n\n// DMR2 bits\n`define OR1200_DU_DMR2_WCE0\t0\n`define OR1200_DU_DMR2_WCE1\t1\n`define OR1200_DU_DMR2_AWTC\t12:2\n`define OR1200_DU_DMR2_WGB\t23:13\n\n// DWCR bits\n`define OR1200_DU_DWCR_COUNT\t15:0\n`define OR1200_DU_DWCR_MATCH\t31:16\n\n// DSR bits\n`define OR1200_DU_DSR_WIDTH\t14\n`define OR1200_DU_DSR_RSTE\t0\n`define OR1200_DU_DSR_BUSEE\t1\n`define OR1200_DU_DSR_DPFE\t2\n`define OR1200_DU_DSR_IPFE\t3\n`define OR1200_DU_DSR_TTE\t4\n`define OR1200_DU_DSR_AE\t5\n`define OR1200_DU_DSR_IIE\t6\n`define OR1200_DU_DSR_IE\t7\n`define OR1200_DU_DSR_DME\t8\n`define OR1200_DU_DSR_IME\t9\n`define OR1200_DU_DSR_RE\t10\n`define OR1200_DU_DSR_SCE\t11\n`define OR1200_DU_DSR_FPE\t12\n`define OR1200_DU_DSR_TE\t13\n\n// DRR bits\n`define OR1200_DU_DRR_RSTE\t0\n`define OR1200_DU_DRR_BUSEE\t1\n`define OR1200_DU_DRR_DPFE\t2\n`define OR1200_DU_DRR_IPFE\t3\n`define OR1200_DU_DRR_TTE\t4\n`define OR1200_DU_DRR_AE\t5\n`define OR1200_DU_DRR_IIE\t6\n`define OR1200_DU_DRR_IE\t7\n`define OR1200_DU_DRR_DME\t8\n`define OR1200_DU_DRR_IME\t9\n`define OR1200_DU_DRR_RE\t10\n`define OR1200_DU_DRR_SCE\t11\n`define OR1200_DU_DRR_FPE\t12\n`define OR1200_DU_DRR_TE\t13\n\n// Define if reading DU regs is allowed\n`define OR1200_DU_READREGS\n\n// Define if unused DU registers bits should be zero\n`define OR1200_DU_UNUSED_ZERO\n\n// Define if IF/LSU status is not needed by devel i/f\n`define OR1200_DU_STATUS_UNIMPLEMENTED\n\n/////////////////////////////////////////////////////\n//\n// Programmable Interrupt Controller (PIC)\n//\n\n// Define it if you want PIC implemented\n`define OR1200_PIC_IMPLEMENTED\n\n// Define number of interrupt inputs (2-31)\n`define OR1200_PIC_INTS 20\n\n// Address offsets of PIC registers inside PIC group\n`define OR1200_PIC_OFS_PICMR 2'd0\n`define OR1200_PIC_OFS_PICSR 2'd2\n\n// Position of offset bits inside SPR address\n`define OR1200_PICOFS_BITS 1:0\n\n// Define if you want these PIC registers to be implemented\n`define OR1200_PIC_PICMR\n`define OR1200_PIC_PICSR\n\n// Define if reading PIC registers is allowed\n`define OR1200_PIC_READREGS\n\n// Define if unused PIC register bits should be zero\n`define OR1200_PIC_UNUSED_ZERO\n\n\n/////////////////////////////////////////////////////\n//\n// Tick Timer (TT)\n//\n\n// Define it if you want TT implemented\n`define OR1200_TT_IMPLEMENTED\n\n// Address offsets of TT registers inside TT group\n`define OR1200_TT_OFS_TTMR 1'd0\n`define OR1200_TT_OFS_TTCR 1'd1\n\n// Position of offset bits inside SPR group\n`define OR1200_TTOFS_BITS 0\n\n// Define if you want these TT registers to be implemented\n`define OR1200_TT_TTMR\n`define OR1200_TT_TTCR\n\n// TTMR bits\n`define OR1200_TT_TTMR_TP 27:0\n`define OR1200_TT_TTMR_IP 28\n`define OR1200_TT_TTMR_IE 29\n`define OR1200_TT_TTMR_M 31:30\n\n// Define if reading TT registers is allowed\n`define OR1200_TT_READREGS\n\n\n//////////////////////////////////////////////\n//\n// MAC\n//\n`define OR1200_MAC_ADDR\t\t0\t// MACLO 0xxxxxxxx1, MACHI 0xxxxxxxx0\n`define OR1200_MAC_SPR_WE\t\t// Define if MACLO/MACHI are SPR writable\n\n//\n// Shift {MACHI,MACLO} into destination register when executing l.macrc\n//\n// According to architecture manual there is no shift, so default value is 0.\n// However the implementation has deviated in this from the arch manual and had\n// hard coded shift by 28 bits which is a useful optimization for MP3 decoding \n// (if using libmad fixed point library). Shifts are no longer default setup, \n// but if you need to remain backward compatible, define your shift bits, which\n// were normally\n// dest_GPR = {MACHI,MACLO}[59:28]\n`define OR1200_MAC_SHIFTBY\t0\t// 0 = According to arch manual, 28 = obsolete backward compatibility\n\n\n//////////////////////////////////////////////\n//\n// Data MMU (DMMU)\n//\n\n//\n// Address that selects between TLB TR and MR\n//\n`define OR1200_DTLB_TM_ADDR\t7\n\n//\n// DTLBMR fields\n//\n`define\tOR1200_DTLBMR_V_BITS\t0\n`define\tOR1200_DTLBMR_CID_BITS\t4:1\n`define\tOR1200_DTLBMR_RES_BITS\t11:5\n`define OR1200_DTLBMR_VPN_BITS\t31:13\n\n//\n// DTLBTR fields\n//\n`define\tOR1200_DTLBTR_CC_BITS\t0\n`define\tOR1200_DTLBTR_CI_BITS\t1\n`define\tOR1200_DTLBTR_WBC_BITS\t2\n`define\tOR1200_DTLBTR_WOM_BITS\t3\n`define\tOR1200_DTLBTR_A_BITS\t4\n`define\tOR1200_DTLBTR_D_BITS\t5\n`define\tOR1200_DTLBTR_URE_BITS\t6\n`define\tOR1200_DTLBTR_UWE_BITS\t7\n`define\tOR1200_DTLBTR_SRE_BITS\t8\n`define\tOR1200_DTLBTR_SWE_BITS\t9\n`define\tOR1200_DTLBTR_RES_BITS\t11:10\n`define OR1200_DTLBTR_PPN_BITS\t31:13\n\n//\n// DTLB configuration\n//\n`define\tOR1200_DMMU_PS\t\t13\t\t\t\t\t// 13 for 8KB page size\n`define\tOR1200_DTLB_INDXW\t6\t\t\t\t\t// 6 for 64 entry DTLB\t7 for 128 entries\n`define OR1200_DTLB_INDXL\t`OR1200_DMMU_PS\t\t\t\t// 13\t\t\t13\n`define OR1200_DTLB_INDXH\t`OR1200_DMMU_PS+`OR1200_DTLB_INDXW-1\t// 18\t\t\t19\n`define\tOR1200_DTLB_INDX\t`OR1200_DTLB_INDXH:`OR1200_DTLB_INDXL\t// 18:13\t\t19:13\n`define OR1200_DTLB_TAGW\t32-`OR1200_DTLB_INDXW-`OR1200_DMMU_PS\t// 13\t\t\t12\n`define OR1200_DTLB_TAGL\t`OR1200_DTLB_INDXH+1\t\t\t// 19\t\t\t20\n`define\tOR1200_DTLB_TAG\t\t31:`OR1200_DTLB_TAGL\t\t\t// 31:19\t\t31:20\n`define\tOR1200_DTLBMRW\t\t`OR1200_DTLB_TAGW+1\t\t\t// +1 because of V bit\n`define\tOR1200_DTLBTRW\t\t32-`OR1200_DMMU_PS+5\t\t\t// +5 because of protection bits and CI\n\n//\n// Cache inhibit while DMMU is not enabled/implemented\n//\n// cache inhibited 0GB-4GB\t\t1'b1\n// cache inhibited 0GB-2GB\t\t!dcpu_adr_i[31]\n// cache inhibited 0GB-1GB 2GB-3GB\t!dcpu_adr_i[30]\n// cache inhibited 1GB-2GB 3GB-4GB\tdcpu_adr_i[30]\n// cache inhibited 2GB-4GB (default)\tdcpu_adr_i[31]\n// cached 0GB-4GB\t\t\t1'b0\n//\n`define OR1200_DMMU_CI\t\t\tdcpu_adr_i[31]\n\n\n//////////////////////////////////////////////\n//\n// Insn MMU (IMMU)\n//\n\n//\n// Address that selects between TLB TR and MR\n//\n`define OR1200_ITLB_TM_ADDR\t7\n\n//\n// ITLBMR fields\n//\n`define\tOR1200_ITLBMR_V_BITS\t0\n`define\tOR1200_ITLBMR_CID_BITS\t4:1\n`define\tOR1200_ITLBMR_RES_BITS\t11:5\n`define OR1200_ITLBMR_VPN_BITS\t31:13\n\n//\n// ITLBTR fields\n//\n`define\tOR1200_ITLBTR_CC_BITS\t0\n`define\tOR1200_ITLBTR_CI_BITS\t1\n`define\tOR1200_ITLBTR_WBC_BITS\t2\n`define\tOR1200_ITLBTR_WOM_BITS\t3\n`define\tOR1200_ITLBTR_A_BITS\t4\n`define\tOR1200_ITLBTR_D_BITS\t5\n`define\tOR1200_ITLBTR_SXE_BITS\t6\n`define\tOR1200_ITLBTR_UXE_BITS\t7\n`define\tOR1200_ITLBTR_RES_BITS\t11:8\n`define OR1200_ITLBTR_PPN_BITS\t31:13\n\n//\n// ITLB configuration\n//\n`define\tOR1200_IMMU_PS\t\t13\t\t\t\t\t// 13 for 8KB page size\n`define\tOR1200_ITLB_INDXW\t6\t\t\t\t\t// 6 for 64 entry ITLB\t7 for 128 entries\n`define OR1200_ITLB_INDXL\t`OR1200_IMMU_PS\t\t\t\t// 13\t\t\t13\n`define OR1200_ITLB_INDXH\t`OR1200_IMMU_PS+`OR1200_ITLB_INDXW-1\t// 18\t\t\t19\n`define\tOR1200_ITLB_INDX\t`OR1200_ITLB_INDXH:`OR1200_ITLB_INDXL\t// 18:13\t\t19:13\n`define OR1200_ITLB_TAGW\t32-`OR1200_ITLB_INDXW-`OR1200_IMMU_PS\t// 13\t\t\t12\n`define OR1200_ITLB_TAGL\t`OR1200_ITLB_INDXH+1\t\t\t// 19\t\t\t20\n`define\tOR1200_ITLB_TAG\t\t31:`OR1200_ITLB_TAGL\t\t\t// 31:19\t\t31:20\n`define\tOR1200_ITLBMRW\t\t`OR1200_ITLB_TAGW+1\t\t\t// +1 because of V bit\n`define\tOR1200_ITLBTRW\t\t32-`OR1200_IMMU_PS+3\t\t\t// +3 because of protection bits and CI\n\n//\n// Cache inhibit while IMMU is not enabled/implemented\n// Note: all combinations that use icpu_adr_i cause async loop\n//\n// cache inhibited 0GB-4GB\t\t1'b1\n// cache inhibited 0GB-2GB\t\t!icpu_adr_i[31]\n// cache inhibited 0GB-1GB 2GB-3GB\t!icpu_adr_i[30]\n// cache inhibited 1GB-2GB 3GB-4GB\ticpu_adr_i[30]\n// cache inhibited 2GB-4GB (default)\ticpu_adr_i[31]\n// cached 0GB-4GB\t\t\t1'b0\n//\n`define OR1200_IMMU_CI\t\t\t1'b0\n\n\n/////////////////////////////////////////////////\n//\n// Insn cache (IC)\n//\n\n// 4 for 16 byte line, 5 for 32 byte lines.\n`ifdef OR1200_IC_1W_32KB\n `define OR1200_ICLS\t\t5\n`else\n `define OR1200_ICLS\t\t4\n`endif\n\n//\n// IC configurations\n//\n`ifdef OR1200_IC_1W_512B\n`define OR1200_ICSIZE                   9                       // 512\n`define OR1200_ICINDX                   `OR1200_ICSIZE-2        // 7\n`define OR1200_ICINDXH                  `OR1200_ICSIZE-1        // 8\n`define OR1200_ICTAGL                   `OR1200_ICINDXH+1       // 9\n`define OR1200_ICTAG                    `OR1200_ICSIZE-`OR1200_ICLS // 5\n`define OR1200_ICTAG_W                  24\n`endif\n`ifdef OR1200_IC_1W_4KB\n`define OR1200_ICSIZE\t\t\t12\t\t\t// 4096\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 10\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 11\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 12\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 8\n`define\tOR1200_ICTAG_W\t\t\t21\n`endif\n`ifdef OR1200_IC_1W_8KB\n`define OR1200_ICSIZE\t\t\t13\t\t\t// 8192\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 11\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 12\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 13\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 9\n`define\tOR1200_ICTAG_W\t\t\t20\n`endif\n`ifdef OR1200_IC_1W_16KB\n`define OR1200_ICSIZE\t\t\t14\t\t\t// 16384\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 12\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 13\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 14\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 10\n`define\tOR1200_ICTAG_W\t\t\t19\n`endif\n`ifdef OR1200_IC_1W_32KB\n`define OR1200_ICSIZE\t\t\t15\t\t\t// 32768\n`define OR1200_ICINDX\t\t\t`OR1200_ICSIZE-2\t// 13\n`define OR1200_ICINDXH\t\t\t`OR1200_ICSIZE-1\t// 14\n`define OR1200_ICTAGL\t\t\t`OR1200_ICINDXH+1\t// 14\n`define\tOR1200_ICTAG\t\t\t`OR1200_ICSIZE-`OR1200_ICLS\t// 10\n`define\tOR1200_ICTAG_W\t\t\t18\n`endif\n\n\n/////////////////////////////////////////////////\n//\n// Data cache (DC)\n//\n\n// 4 for 16 bytes, 5 for 32 bytes\n`ifdef OR1200_DC_1W_32KB\n `define OR1200_DCLS\t\t5\n`else\n `define OR1200_DCLS\t\t4\n`endif\n\n// Define to enable default behavior of cache as write through\n// Turning this off enabled write back statergy\n//\n`define OR1200_DC_WRITETHROUGH\n\n// Define to enable stores from the stack not doing writethrough.\n// EXPERIMENTAL\n//`define OR1200_DC_NOSTACKWRITETHROUGH\n\n// Data cache SPR definitions\n`define OR1200_SPRGRP_DC_ADR_WIDTH 3\n// Data cache group SPR addresses\n`define OR1200_SPRGRP_DC_DCCR\t\t3'd0 // Not implemented\n`define OR1200_SPRGRP_DC_DCBPR\t\t3'd1 // Not implemented\n`define OR1200_SPRGRP_DC_DCBFR\t\t3'd2\n`define OR1200_SPRGRP_DC_DCBIR\t\t3'd3\n`define OR1200_SPRGRP_DC_DCBWR\t\t3'd4 // Not implemented\n`define OR1200_SPRGRP_DC_DCBLR\t\t3'd5 // Not implemented\n\n//\n// DC configurations\n//\n`ifdef OR1200_DC_1W_4KB\n`define OR1200_DCSIZE\t\t\t12\t\t\t// 4096\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 10\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 11\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 12\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 8\n`define\tOR1200_DCTAG_W\t\t\t21\n`endif\n`ifdef OR1200_DC_1W_8KB\n`define OR1200_DCSIZE\t\t\t13\t\t\t// 8192\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 11\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 12\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 13\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 9\n`define\tOR1200_DCTAG_W\t\t\t20\n`endif\n`ifdef OR1200_DC_1W_16KB\n`define OR1200_DCSIZE\t\t\t14\t\t\t// 16384\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 12\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 13\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 14\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 10\n`define\tOR1200_DCTAG_W\t\t\t19\n`endif\n`ifdef OR1200_DC_1W_32KB\n`define OR1200_DCSIZE\t\t\t15\t\t\t// 32768\n`define OR1200_DCINDX\t\t\t`OR1200_DCSIZE-2\t// 13\n`define OR1200_DCINDXH\t\t\t`OR1200_DCSIZE-1\t// 14\n`define OR1200_DCTAGL\t\t\t`OR1200_DCINDXH+1\t// 15\n`define\tOR1200_DCTAG\t\t\t`OR1200_DCSIZE-`OR1200_DCLS\t// 10\n`define\tOR1200_DCTAG_W\t\t\t18\n`endif\n\n\n/////////////////////////////////////////////////\n//\n// Store buffer (SB)\n//\n\n//\n// Store buffer\n//\n// It will improve performance by \"caching\" CPU stores\n// using store buffer. This is most important for function\n// prologues because DC can only work in write though mode\n// and all stores would have to complete external WB writes\n// to memory.\n// Store buffer is between DC and data BIU.\n// All stores will be stored into store buffer and immediately\n// completed by the CPU, even though actual external writes\n// will be performed later. As a consequence store buffer masks\n// all data bus errors related to stores (data bus errors\n// related to loads are delivered normally).\n// All pending CPU loads will wait until store buffer is empty to\n// ensure strict memory model. Right now this is necessary because\n// we don't make destinction between cached and cache inhibited\n// address space, so we simply empty store buffer until loads\n// can begin.\n//\n// It makes design a bit bigger, depending what is the number of\n// entries in SB FIFO. Number of entries can be changed further\n// down.\n//\n//`define OR1200_SB_IMPLEMENTED\n\n//\n// Number of store buffer entries\n//\n// Verified number of entries are 4 and 8 entries\n// (2 and 3 for OR1200_SB_LOG). OR1200_SB_ENTRIES must\n// always match 2**OR1200_SB_LOG.\n// To disable store buffer, undefine\n// OR1200_SB_IMPLEMENTED.\n//\n`define OR1200_SB_LOG\t\t2\t// 2 or 3\n`define OR1200_SB_ENTRIES\t4\t// 4 or 8\n\n\n/////////////////////////////////////////////////\n//\n// Quick Embedded Memory (QMEM)\n//\n\n//\n// Quick Embedded Memory\n//\n// Instantiation of dedicated insn/data memory (RAM or ROM).\n// Insn fetch has effective throughput 1insn / clock cycle.\n// Data load takes two clock cycles / access, data store\n// takes 1 clock cycle / access (if there is no insn fetch)).\n// Memory instantiation is shared between insn and data,\n// meaning if insn fetch are performed, data load/store\n// performance will be lower.\n//\n// Main reason for QMEM is to put some time critical functions\n// into this memory and to have predictable and fast access\n// to these functions. (soft fpu, context switch, exception\n// handlers, stack, etc)\n//\n// It makes design a bit bigger and slower. QMEM sits behind\n// IMMU/DMMU so all addresses are physical (so the MMUs can be\n// used with QMEM and QMEM is seen by the CPU just like any other\n// memory in the system). IC/DC are sitting behind QMEM so the\n// whole design timing might be worse with QMEM implemented.\n//\n//`define OR1200_QMEM_IMPLEMENTED\n\n//\n// Base address and mask of QMEM\n//\n// Base address defines first address of QMEM. Mask defines\n// QMEM range in address space. Actual size of QMEM is however\n// determined with instantiated RAM/ROM. However bigger\n// mask will reserve more address space for QMEM, but also\n// make design faster, while more tight mask will take\n// less address space but also make design slower. If\n// instantiated RAM/ROM is smaller than space reserved with\n// the mask, instatiated RAM/ROM will also be shadowed\n// at higher addresses in reserved space.\n//\n`define OR1200_QMEM_IADDR\t32'h0080_0000\n`define OR1200_QMEM_IMASK\t32'hfff0_0000 // Max QMEM size 1MB\n`define OR1200_QMEM_DADDR\t32'h0080_0000\n`define OR1200_QMEM_DMASK\t32'hfff0_0000 // Max QMEM size 1MB\n\n//\n// QMEM interface byte-select capability\n//\n// To enable qmem_sel* ports, define this macro.\n//\n//`define OR1200_QMEM_BSEL\n\n//\n// QMEM interface acknowledge\n//\n// To enable qmem_ack port, define this macro.\n//\n//`define OR1200_QMEM_ACK\n\n/////////////////////////////////////////////////////\n//\n// VR, UPR and Configuration Registers\n//\n//\n// VR, UPR and configuration registers are optional. If \n// implemented, operating system can automatically figure\n// out how to use the processor because it knows \n// what units are available in the processor and how they\n// are configured.\n//\n// This section must be last in or1200_defines.v file so\n// that all units are already configured and thus\n// configuration registers are properly set.\n// \n\n// Define if you want configuration registers implemented\n`define OR1200_CFGR_IMPLEMENTED\n\n// Define if you want full address decode inside SYS group\n`define OR1200_SYS_FULL_DECODE\n\n// Offsets of VR, UPR and CFGR registers\n`define OR1200_SPRGRP_SYS_VR\t\t4'h0\n`define OR1200_SPRGRP_SYS_UPR\t\t4'h1\n`define OR1200_SPRGRP_SYS_CPUCFGR\t4'h2\n`define OR1200_SPRGRP_SYS_DMMUCFGR\t4'h3\n`define OR1200_SPRGRP_SYS_IMMUCFGR\t4'h4\n`define OR1200_SPRGRP_SYS_DCCFGR\t4'h5\n`define OR1200_SPRGRP_SYS_ICCFGR\t4'h6\n`define OR1200_SPRGRP_SYS_DCFGR\t4'h7\n\n// VR fields\n`define OR1200_VR_REV_BITS\t\t5:0\n`define OR1200_VR_RES1_BITS\t\t15:6\n`define OR1200_VR_CFG_BITS\t\t23:16\n`define OR1200_VR_VER_BITS\t\t31:24\n\n// VR values\n`define OR1200_VR_REV\t\t\t6'h08\n`define OR1200_VR_RES1\t\t\t10'h000\n`define OR1200_VR_CFG\t\t\t8'h00\n`define OR1200_VR_VER\t\t\t8'h12\n\n// UPR fields\n`define OR1200_UPR_UP_BITS\t\t0\n`define OR1200_UPR_DCP_BITS\t\t1\n`define OR1200_UPR_ICP_BITS\t\t2\n`define OR1200_UPR_DMP_BITS\t\t3\n`define OR1200_UPR_IMP_BITS\t\t4\n`define OR1200_UPR_MP_BITS\t\t5\n`define OR1200_UPR_DUP_BITS\t\t6\n`define OR1200_UPR_PCUP_BITS\t\t7\n`define OR1200_UPR_PMP_BITS\t\t8\n`define OR1200_UPR_PICP_BITS\t\t9\n`define OR1200_UPR_TTP_BITS\t\t10\n`define OR1200_UPR_FPP_BITS\t\t11\n`define OR1200_UPR_RES1_BITS\t\t23:12\n`define OR1200_UPR_CUP_BITS\t\t31:24\n\n// UPR values\n`define OR1200_UPR_UP\t\t\t1'b1\n`ifdef OR1200_NO_DC\n`define OR1200_UPR_DCP\t\t\t1'b0\n`else\n`define OR1200_UPR_DCP\t\t\t1'b1\n`endif\n`ifdef OR1200_NO_IC\n`define OR1200_UPR_ICP\t\t\t1'b0\n`else\n`define OR1200_UPR_ICP\t\t\t1'b1\n`endif\n`ifdef OR1200_NO_DMMU\n`define OR1200_UPR_DMP\t\t\t1'b0\n`else\n`define OR1200_UPR_DMP\t\t\t1'b1\n`endif\n`ifdef OR1200_NO_IMMU\n`define OR1200_UPR_IMP\t\t\t1'b0\n`else\n`define OR1200_UPR_IMP\t\t\t1'b1\n`endif\n`ifdef OR1200_MAC_IMPLEMENTED\n`define OR1200_UPR_MP\t\t\t1'b1\n`else\n`define OR1200_UPR_MP\t\t\t1'b0\n`endif\n`ifdef OR1200_DU_IMPLEMENTED\n`define OR1200_UPR_DUP\t\t\t1'b1\n`else\n`define OR1200_UPR_DUP\t\t\t1'b0\n`endif\n`define OR1200_UPR_PCUP\t\t\t1'b0\t// Performance counters not present\n`ifdef OR1200_PM_IMPLEMENTED\n`define OR1200_UPR_PMP\t\t\t1'b1\n`else\n`define OR1200_UPR_PMP\t\t\t1'b0\n`endif\n`ifdef OR1200_PIC_IMPLEMENTED\n`define OR1200_UPR_PICP\t\t\t1'b1\n`else\n`define OR1200_UPR_PICP\t\t\t1'b0\n`endif\n`ifdef OR1200_TT_IMPLEMENTED\n`define OR1200_UPR_TTP\t\t\t1'b1\n`else\n`define OR1200_UPR_TTP\t\t\t1'b0\n`endif\n`ifdef OR1200_FPU_IMPLEMENTED\n`define OR1200_UPR_FPP\t\t\t1'b1\n`else\n`define OR1200_UPR_FPP\t\t\t1'b0\n`endif\n`define OR1200_UPR_RES1\t\t\t12'h000\n`define OR1200_UPR_CUP\t\t\t8'h00\n\n// CPUCFGR fields\n`define OR1200_CPUCFGR_NSGF_BITS\t3:0\n`define OR1200_CPUCFGR_HGF_BITS     4\n`define OR1200_CPUCFGR_OB32S_BITS\t5\n`define OR1200_CPUCFGR_OB64S_BITS\t6\n`define OR1200_CPUCFGR_OF32S_BITS\t7\n`define OR1200_CPUCFGR_OF64S_BITS\t8\n`define OR1200_CPUCFGR_OV64S_BITS\t9\n`define OR1200_CPUCFGR_RES1_BITS\t31:10\n\n// CPUCFGR values\n`define OR1200_CPUCFGR_NSGF\t\t    4'h0\n`ifdef OR1200_RFRAM_16REG\n    `define OR1200_CPUCFGR_HGF  \t\t1'b1\n`else\n    `define OR1200_CPUCFGR_HGF  \t\t1'b0\n`endif\n`define OR1200_CPUCFGR_OB32S\t\t1'b1\n`define OR1200_CPUCFGR_OB64S\t\t1'b0\n`ifdef OR1200_FPU_IMPLEMENTED\n `define OR1200_CPUCFGR_OF32S\t\t1'b1\n`else\n `define OR1200_CPUCFGR_OF32S\t\t1'b0\n`endif\n\n`define OR1200_CPUCFGR_OF64S\t\t1'b0\n`define OR1200_CPUCFGR_OV64S\t\t1'b0\n`define OR1200_CPUCFGR_RES1\t\t22'h000000\n\n// DMMUCFGR fields\n`define OR1200_DMMUCFGR_NTW_BITS\t1:0\n`define OR1200_DMMUCFGR_NTS_BITS\t4:2\n`define OR1200_DMMUCFGR_NAE_BITS\t7:5\n`define OR1200_DMMUCFGR_CRI_BITS\t8\n`define OR1200_DMMUCFGR_PRI_BITS\t9\n`define OR1200_DMMUCFGR_TEIRI_BITS\t10\n`define OR1200_DMMUCFGR_HTR_BITS\t11\n`define OR1200_DMMUCFGR_RES1_BITS\t31:12\n\n// DMMUCFGR values\n`ifdef OR1200_NO_DMMU\n`define OR1200_DMMUCFGR_NTW\t\t2'h0\t// Irrelevant\n`define OR1200_DMMUCFGR_NTS\t\t3'h0\t// Irrelevant\n`define OR1200_DMMUCFGR_NAE\t\t3'h0\t// Irrelevant\n`define OR1200_DMMUCFGR_CRI\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_PRI\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_TEIRI\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_HTR\t\t1'b0\t// Irrelevant\n`define OR1200_DMMUCFGR_RES1\t\t20'h00000\n`else\n`define OR1200_DMMUCFGR_NTW\t\t2'h0\t// 1 TLB way\n`define OR1200_DMMUCFGR_NTS 3'h`OR1200_DTLB_INDXW\t// Num TLB sets\n`define OR1200_DMMUCFGR_NAE\t\t3'h0\t// No ATB entries\n`define OR1200_DMMUCFGR_CRI\t\t1'b0\t// No control register\n`define OR1200_DMMUCFGR_PRI\t\t1'b0\t// No protection reg\n`define OR1200_DMMUCFGR_TEIRI\t\t1'b1\t// TLB entry inv reg impl.\n`define OR1200_DMMUCFGR_HTR\t\t1'b0\t// No HW TLB reload\n`define OR1200_DMMUCFGR_RES1\t\t20'h00000\n`endif\n\n// IMMUCFGR fields\n`define OR1200_IMMUCFGR_NTW_BITS\t1:0\n`define OR1200_IMMUCFGR_NTS_BITS\t4:2\n`define OR1200_IMMUCFGR_NAE_BITS\t7:5\n`define OR1200_IMMUCFGR_CRI_BITS\t8\n`define OR1200_IMMUCFGR_PRI_BITS\t9\n`define OR1200_IMMUCFGR_TEIRI_BITS\t10\n`define OR1200_IMMUCFGR_HTR_BITS\t11\n`define OR1200_IMMUCFGR_RES1_BITS\t31:12\n\n// IMMUCFGR values\n`ifdef OR1200_NO_IMMU\n`define OR1200_IMMUCFGR_NTW\t\t2'h0\t// Irrelevant\n`define OR1200_IMMUCFGR_NTS\t\t3'h0\t// Irrelevant\n`define OR1200_IMMUCFGR_NAE\t\t3'h0\t// Irrelevant\n`define OR1200_IMMUCFGR_CRI\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_PRI\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_TEIRI\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_HTR\t\t1'b0\t// Irrelevant\n`define OR1200_IMMUCFGR_RES1\t\t20'h00000\n`else\n`define OR1200_IMMUCFGR_NTW\t\t2'h0\t// 1 TLB way\n`define OR1200_IMMUCFGR_NTS 3'h`OR1200_ITLB_INDXW\t// Num TLB sets\n`define OR1200_IMMUCFGR_NAE\t\t3'h0\t// No ATB entry\n`define OR1200_IMMUCFGR_CRI\t\t1'b0\t// No control reg\n`define OR1200_IMMUCFGR_PRI\t\t1'b0\t// No protection reg\n`define OR1200_IMMUCFGR_TEIRI\t\t1'b1\t// TLB entry inv reg impl\n`define OR1200_IMMUCFGR_HTR\t\t1'b0\t// No HW TLB reload\n`define OR1200_IMMUCFGR_RES1\t\t20'h00000\n`endif\n\n// DCCFGR fields\n`define OR1200_DCCFGR_NCW_BITS\t\t2:0\n`define OR1200_DCCFGR_NCS_BITS\t\t6:3\n`define OR1200_DCCFGR_CBS_BITS\t\t7\n`define OR1200_DCCFGR_CWS_BITS\t\t8\n`define OR1200_DCCFGR_CCRI_BITS\t\t9\n`define OR1200_DCCFGR_CBIRI_BITS\t10\n`define OR1200_DCCFGR_CBPRI_BITS\t11\n`define OR1200_DCCFGR_CBLRI_BITS\t12\n`define OR1200_DCCFGR_CBFRI_BITS\t13\n`define OR1200_DCCFGR_CBWBRI_BITS\t14\n`define OR1200_DCCFGR_RES1_BITS\t31:15\n\n// DCCFGR values\n`ifdef OR1200_NO_DC\n`define OR1200_DCCFGR_NCW\t\t3'h0\t// Irrelevant\n`define OR1200_DCCFGR_NCS\t\t4'h0\t// Irrelevant\n`define OR1200_DCCFGR_CBS\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CWS\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CCRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBIRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBPRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBLRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBFRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_CBWBRI\t\t1'b0\t// Irrelevant\n`define OR1200_DCCFGR_RES1\t\t17'h00000\n`else\n`define OR1200_DCCFGR_NCW\t\t3'h0\t// 1 cache way\n`define OR1200_DCCFGR_NCS (`OR1200_DCTAG)\t// Num cache sets\n`define OR1200_DCCFGR_CBS `OR1200_DCLS==4 ? 1'b0 : 1'b1 // 16 byte cache block\n`ifdef OR1200_DC_WRITETHROUGH\n `define OR1200_DCCFGR_CWS\t\t1'b0\t// Write-through strategy\n`else\n `define OR1200_DCCFGR_CWS\t\t1'b1\t// Write-back strategy\n`endif\n`define OR1200_DCCFGR_CCRI\t\t1'b1\t// Cache control reg impl.\n`define OR1200_DCCFGR_CBIRI\t\t1'b1\t// Cache block inv reg impl.\n`define OR1200_DCCFGR_CBPRI\t\t1'b0\t// Cache block prefetch reg not impl.\n`define OR1200_DCCFGR_CBLRI\t\t1'b0\t// Cache block lock reg not impl.\n`define OR1200_DCCFGR_CBFRI\t\t1'b1\t// Cache block flush reg impl.\n`ifdef OR1200_DC_WRITETHROUGH\n `define OR1200_DCCFGR_CBWBRI\t\t1'b0\t// Cache block WB reg not impl.\n`else\n `define OR1200_DCCFGR_CBWBRI\t\t1'b1\t// Cache block WB reg impl.\n`endif\n`define OR1200_DCCFGR_RES1\t\t17'h00000\n`endif\n\n// ICCFGR fields\n`define OR1200_ICCFGR_NCW_BITS\t\t2:0\n`define OR1200_ICCFGR_NCS_BITS\t\t6:3\n`define OR1200_ICCFGR_CBS_BITS\t\t7\n`define OR1200_ICCFGR_CWS_BITS\t\t8\n`define OR1200_ICCFGR_CCRI_BITS\t\t9\n`define OR1200_ICCFGR_CBIRI_BITS\t10\n`define OR1200_ICCFGR_CBPRI_BITS\t11\n`define OR1200_ICCFGR_CBLRI_BITS\t12\n`define OR1200_ICCFGR_CBFRI_BITS\t13\n`define OR1200_ICCFGR_CBWBRI_BITS\t14\n`define OR1200_ICCFGR_RES1_BITS\t31:15\n\n// ICCFGR values\n`ifdef OR1200_NO_IC\n`define OR1200_ICCFGR_NCW\t\t3'h0\t// Irrelevant\n`define OR1200_ICCFGR_NCS \t\t4'h0\t// Irrelevant\n`define OR1200_ICCFGR_CBS \t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CWS\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CCRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBIRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBPRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBLRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBFRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CBWBRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_RES1\t\t17'h00000\n`else\n`define OR1200_ICCFGR_NCW\t\t3'h0\t// 1 cache way\n`define OR1200_ICCFGR_NCS (`OR1200_ICTAG)\t// Num cache sets\n`define OR1200_ICCFGR_CBS `OR1200_ICLS==4 ? 1'b0: 1'b1\t// 16 byte cache block\n`define OR1200_ICCFGR_CWS\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_CCRI\t\t1'b1\t// Cache control reg impl.\n`define OR1200_ICCFGR_CBIRI\t\t1'b1\t// Cache block inv reg impl.\n`define OR1200_ICCFGR_CBPRI\t\t1'b0\t// Cache block prefetch reg not impl.\n`define OR1200_ICCFGR_CBLRI\t\t1'b0\t// Cache block lock reg not impl.\n`define OR1200_ICCFGR_CBFRI\t\t1'b1\t// Cache block flush reg impl.\n`define OR1200_ICCFGR_CBWBRI\t\t1'b0\t// Irrelevant\n`define OR1200_ICCFGR_RES1\t\t17'h00000\n`endif\n\n// DCFGR fields\n`define OR1200_DCFGR_NDP_BITS\t\t3:0\n`define OR1200_DCFGR_WPCI_BITS\t\t4\n`define OR1200_DCFGR_RES1_BITS\t\t31:5\n\n// DCFGR values\n`ifdef OR1200_DU_HWBKPTS\n`define OR1200_DCFGR_NDP\t\t4'h`OR1200_DU_DVRDCR_PAIRS // # of DVR/DCR pairs\n`ifdef OR1200_DU_DWCR0\n`define OR1200_DCFGR_WPCI\t\t1'b1\n`else\n`define OR1200_DCFGR_WPCI\t\t1'b0\t// WP counters not impl.\n`endif\n`else\n`define OR1200_DCFGR_NDP\t\t4'h0\t// Zero DVR/DCR pairs\n`define OR1200_DCFGR_WPCI\t\t1'b0\t// WP counters not impl.\n`endif\n`define OR1200_DCFGR_RES1\t\t27'd0\n\n///////////////////////////////////////////////////////////////////////////////\n// Boot Address Selection                                                    //\n//                                                                           //\n// Allows a definable boot address, potentially different to the usual reset //\n// vector to allow for power-on code to be run, if desired.                  //\n//                                                                           //\n// OR1200_BOOT_ADR should be the 32-bit address of the boot location         //\n// OR1200_BOOT_PCREG_DEFAULT should be ((OR1200_BOOT_ADR-4)>>2)              //\n//                                                                           //\n// For default reset behavior uncomment the settings under the \"Boot 0x100\"  //\n// comment below.                                                            //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n// Boot from 0xf0000100\n//`define OR1200_BOOT_PCREG_DEFAULT 30'h3c00003f\n//`define OR1200_BOOT_ADR 32'hf0000100\n// Boot from 0x100\n `define OR1200_BOOT_PCREG_DEFAULT 30'h0000003f\n `define OR1200_BOOT_ADR 32'h00000100\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's Exception logic                                    ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  Handles all OR1K exceptions inside CPU block.               ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_except.v,v $\n//\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Major update: \n// Structure reordered and bugs fixed. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\n`define OR1200_EXCEPTFSM_WIDTH 3\n`define OR1200_EXCEPTFSM_IDLE\t`OR1200_EXCEPTFSM_WIDTH'd0\n`define OR1200_EXCEPTFSM_FLU1 \t`OR1200_EXCEPTFSM_WIDTH'd1\n`define OR1200_EXCEPTFSM_FLU2 \t`OR1200_EXCEPTFSM_WIDTH'd2\n`define OR1200_EXCEPTFSM_FLU3 \t`OR1200_EXCEPTFSM_WIDTH'd3\n`define OR1200_EXCEPTFSM_FLU4 \t`OR1200_EXCEPTFSM_WIDTH'd4\n`define OR1200_EXCEPTFSM_FLU5 \t`OR1200_EXCEPTFSM_WIDTH'd5\n\n//\n// Exception recognition and sequencing\n//\n\nmodule or1200_except\n  (\n   // Clock and reset\n   clk, rst, \n   \n   // Internal i/f\n   sig_ibuserr, sig_dbuserr, sig_illegal, sig_align, sig_range, sig_dtlbmiss, \n   sig_dmmufault, sig_int, sig_syscall, sig_trap, sig_itlbmiss, sig_immufault, \n   sig_tick, ex_branch_taken, genpc_freeze, id_freeze, ex_freeze, wb_freeze,  \n   if_stall,  if_pc, id_pc, ex_pc, wb_pc, id_flushpipe, ex_flushpipe, \n   extend_flush, except_flushpipe, except_type, except_start, except_started, \n   except_stop, except_trig, ex_void, abort_mvspr, branch_op, spr_dat_ppc, \n   spr_dat_npc, datain, du_dsr, epcr_we, eear_we, esr_we, pc_we, epcr, eear, \n   du_dmr1, du_hwbkpt, du_hwbkpt_ls_r, esr, sr_we, to_sr, sr, lsu_addr, \n   abort_ex, icpu_ack_i, icpu_err_i, dcpu_ack_i, dcpu_err_i, sig_fp, fpcsr_fpee\n   \n);\n\n//\n// I/O\n//\ninput\t\t\t\tclk;\ninput\t\t\t\trst;\ninput\t\t\t\tsig_ibuserr;\ninput\t\t\t\tsig_dbuserr;\ninput\t\t\t\tsig_illegal;\ninput\t\t\t\tsig_align;\ninput\t\t\t\tsig_range;\ninput\t\t\t\tsig_dtlbmiss;\ninput\t\t\t\tsig_dmmufault;\ninput\t\t\t\tsig_int;\ninput\t\t\t\tsig_syscall;\ninput\t\t\t\tsig_trap;\ninput\t\t\t\tsig_itlbmiss;\ninput\t\t\t\tsig_immufault;\ninput\t\t\t\tsig_tick;\ninput   \t\t\tsig_fp;\ninput    \t\t\tfpcsr_fpee;   \ninput\t\t\t\tex_branch_taken;\ninput\t\t\t\tgenpc_freeze;\ninput\t\t\t\tid_freeze;\ninput\t\t\t\tex_freeze;\ninput\t\t\t\twb_freeze;\ninput\t\t\t\tif_stall;\ninput\t[31:0]\t\tif_pc;\noutput\t[31:0]\t\tid_pc;\noutput  [31:0]      ex_pc;\noutput  [31:0]      wb_pc;\ninput\t[31:0]\t\tdatain;\ninput   [`OR1200_DU_DSR_WIDTH-1:0]     du_dsr;\ninput   [24:0]                       du_dmr1;\ninput\t\t\tdu_hwbkpt;\ninput\t\t\tdu_hwbkpt_ls_r;\ninput\t\t\t\tepcr_we;\ninput\t\t\t\teear_we;\ninput\t\t\t\tesr_we;\ninput\t\t\t\tpc_we;\noutput\t[31:0]\t\t\tepcr;\noutput\t[31:0]\t\t\teear;\noutput\t[`OR1200_SR_WIDTH-1:0]\tesr;\ninput\t[`OR1200_SR_WIDTH-1:0]\tto_sr;\ninput\t\t\t\tsr_we;\ninput\t[`OR1200_SR_WIDTH-1:0]\tsr;\ninput\t[31:0]\t\t\tlsu_addr;\ninput              \tid_flushpipe;\ninput              \tex_flushpipe;\noutput\t\t\t\texcept_flushpipe;\noutput\t\t\t\textend_flush;\noutput\t[`OR1200_EXCEPT_WIDTH-1:0]\texcept_type;\noutput\t\t\t\texcept_start;\noutput\t\t\t\texcept_started;\noutput\t[13:0]\t\texcept_stop;\noutput\t[13:0]\t\texcept_trig;\ninput\t\t\t\tex_void;\ninput   [`OR1200_BRANCHOP_WIDTH-1:0]    branch_op; \noutput\t[31:0]\t\t\tspr_dat_ppc;\noutput\t[31:0]\t\t\tspr_dat_npc;\noutput\t\t\t\tabort_ex;\noutput              abort_mvspr;\ninput\t\t\t\ticpu_ack_i;\ninput\t\t\t\ticpu_err_i;\ninput\t\t\t\tdcpu_ack_i;\ninput\t\t\t\tdcpu_err_i;\n\n//\n// Internal regs and wires\n//\nreg\t[`OR1200_EXCEPT_WIDTH-1:0]\texcept_type /* verilator public */;\nreg\t[31:0]\t\t\tid_pc /* verilator public */;\nreg                 id_pc_val;\nreg\t[31:0]\t\t\tex_pc /* verilator public */;\nreg                 ex_pc_val;\nreg\t[31:0]\t\t\twb_pc /* verilator public */;\nreg [31:0]          dl_pc;\nreg\t[31:0]\t\t\tepcr;\nreg\t[31:0]\t\t\teear;\nreg\t[`OR1200_SR_WIDTH-1:0]\t\tesr;\nreg\t[2:0]\t\t\tid_exceptflags;\nreg\t[2:0]\t\t\tex_exceptflags;\nreg\t[`OR1200_EXCEPTFSM_WIDTH-1:0]\tstate;\nreg\t\t\t\textend_flush;\nreg\t\t\t\textend_flush_last;\nreg\t\t\t\tex_dslot /* verilator public */;\nreg\t\t\t\tdelayed1_ex_dslot;\nreg\t\t\t\tdelayed2_ex_dslot;\nwire\t\t\t\texcept_started;\nwire\t\t\t\texcept_flushpipe /* verilator public */;\nreg\t[2:0]\t\t\tdelayed_iee;\nreg\t[2:0]\t\t\tdelayed_tee;\nwire\t\t\t\tint_pending;\nwire\t\t\t\ttick_pending;\nwire    \t\t\tfp_pending;\nwire    \t\t\trange_pending;\n\t\t\t\nreg trace_trap      ;\nreg ex_freeze_prev;\nreg sr_ted_prev;\nreg dsr_te_prev;\nreg dmr1_st_prev    ;\nreg dmr1_bt_prev    ;\nwire dsr_te = ex_freeze_prev ? dsr_te_prev : du_dsr[`OR1200_DU_DSR_TE];\nwire sr_ted = ex_freeze_prev ? sr_ted_prev : sr[`OR1200_SR_TED];\nwire dmr1_st = ex_freeze_prev ? dmr1_st_prev: du_dmr1[`OR1200_DU_DMR1_ST] ;\nwire dmr1_bt = ex_freeze_prev ? dmr1_bt_prev: du_dmr1[`OR1200_DU_DMR1_BT] ;\n\n//\n// Simple combinatorial logic\n//\nassign except_started = extend_flush & except_start;\n   \nassign except_start = (except_type != `OR1200_EXCEPT_NONE) & extend_flush;\n   \nassign int_pending = sig_int & (sr[`OR1200_SR_IEE] | \n\t\t\t\t(sr_we & to_sr[`OR1200_SR_IEE])) \n\t\t    & id_pc_val & delayed_iee[2] & ~ex_freeze & ~ex_branch_taken\n\t\t     & ~ex_dslot & ~(sr_we & ~to_sr[`OR1200_SR_IEE]);\n   \nassign tick_pending = sig_tick & (sr[`OR1200_SR_TEE] | \n\t\t\t\t  (sr_we & to_sr[`OR1200_SR_TEE])) & id_pc_val\n\t\t      & delayed_tee[2] & ~ex_freeze & ~ex_branch_taken \n\t\t      & ~ex_dslot & ~(sr_we & ~to_sr[`OR1200_SR_TEE]);\n\nassign fp_pending = sig_fp & fpcsr_fpee & ~ex_freeze & ~ex_branch_taken \n\t\t    & ~ex_dslot;\n\n`ifdef OR1200_IMPL_OVE   \nassign range_pending =  sig_range & sr[`OR1200_SR_OVE] & ~ex_freeze & \n\t\t       ~ex_branch_taken & ~ex_dslot;\n`else\nassign range_pending = 0;\n`endif   \n   \n// Abort write into RF by load & other instructions   \nassign abort_ex = sig_dbuserr | sig_dmmufault | sig_dtlbmiss | sig_align | \n\t\t  sig_illegal | ((du_hwbkpt | trace_trap) & ex_pc_val \n\t\t\t\t & !sr_ted & !dsr_te);\n\n// abort spr read/writes   \nassign abort_mvspr  = sig_illegal | ((du_hwbkpt | trace_trap) & ex_pc_val \n\t\t\t\t     & !sr_ted & !dsr_te) ; \nassign spr_dat_ppc = wb_pc;\n   \nassign spr_dat_npc = ex_void ? id_pc : ex_pc;\n\n//\n// Order defines exception detection priority\n//\nassign except_trig = {\n\t\t      ex_exceptflags[1]\t& ~du_dsr[`OR1200_DU_DSR_IME],\n\t\t      ex_exceptflags[0]\t& ~du_dsr[`OR1200_DU_DSR_IPFE],\n\t\t      ex_exceptflags[2]\t& ~du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t      sig_illegal       & ~du_dsr[`OR1200_DU_DSR_IIE],\n\t\t      sig_align\t\t& ~du_dsr[`OR1200_DU_DSR_AE],\n\t\t      sig_dtlbmiss\t& ~du_dsr[`OR1200_DU_DSR_DME],\n\t\t      sig_trap\t\t& ~du_dsr[`OR1200_DU_DSR_TE],\n\t\t      sig_syscall       & ~du_dsr[`OR1200_DU_DSR_SCE] & ~ex_freeze,\n\t\t      sig_dmmufault\t& ~du_dsr[`OR1200_DU_DSR_DPFE],\n\t\t      sig_dbuserr\t& ~du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t      range_pending\t& ~du_dsr[`OR1200_DU_DSR_RE],\n\t\t      fp_pending\t& ~du_dsr[`OR1200_DU_DSR_FPE],\n\t\t      int_pending \t& ~du_dsr[`OR1200_DU_DSR_IE],\n\t\t      tick_pending\t& ~du_dsr[`OR1200_DU_DSR_TTE]\n\t\t      };\n\nwire    trace_cond  = !ex_freeze && !ex_void && (1'b0\n`ifdef OR1200_DU_DMR1_ST\n    ||  dmr1_st\n`endif\n`ifdef OR1200_DU_DMR1_BT\n    ||  ((branch_op != `OR1200_BRANCHOP_NOP) && (branch_op != `OR1200_BRANCHOP_RFE) && dmr1_bt)\n`endif\n    );\n\nassign except_stop = {\n\t\t\ttick_pending\t\t& du_dsr[`OR1200_DU_DSR_TTE],\n\t\t\tint_pending \t\t& du_dsr[`OR1200_DU_DSR_IE],\n\t\t\tex_exceptflags[1]\t& du_dsr[`OR1200_DU_DSR_IME],\n\t\t\tex_exceptflags[0]\t& du_dsr[`OR1200_DU_DSR_IPFE],\n\t\t\tex_exceptflags[2]\t& du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t\tsig_illegal\t\t& du_dsr[`OR1200_DU_DSR_IIE],\n\t\t\tsig_align\t\t& du_dsr[`OR1200_DU_DSR_AE],\n\t\t\tsig_dtlbmiss\t\t& du_dsr[`OR1200_DU_DSR_DME],\n\t\t\tsig_dmmufault\t\t& du_dsr[`OR1200_DU_DSR_DPFE],\n\t\t\tsig_dbuserr\t\t& du_dsr[`OR1200_DU_DSR_BUSEE],\n\t\t\trange_pending\t\t& du_dsr[`OR1200_DU_DSR_RE],\n\t\t\tsig_trap\t\t& du_dsr[`OR1200_DU_DSR_TE],\n\t\t        fp_pending  \t\t& du_dsr[`OR1200_DU_DSR_FPE],\n\t\t\tsig_syscall\t\t& du_dsr[`OR1200_DU_DSR_SCE] & ~ex_freeze\n\t\t};\n\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\ttrace_trap  <=  1'b0 ;\n\tend \n\telse if (!(trace_trap && !ex_pc_val)) begin\n\t\ttrace_trap  <=  trace_cond & !dsr_te & !sr_ted ;\n\tend\nend\n\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n        ex_freeze_prev  <=  1'b0 ;\n        sr_ted_prev     <=  1'b0 ;\n        dsr_te_prev     <=  1'b0 ;\n        dmr1_st_prev    <=  1'b0 ;\n        dmr1_bt_prev    <=  1'b0 ;\n    end \n    else begin\n        ex_freeze_prev  <=  ex_freeze ;\n        if (!ex_freeze_prev || ex_void) begin\n            sr_ted_prev     <=  sr     [`OR1200_SR_TED    ] ;\n            dsr_te_prev     <=  du_dsr [`OR1200_DU_DSR_TE ] ;\n            dmr1_st_prev    <=  du_dmr1[`OR1200_DU_DMR1_ST] ;\n            dmr1_bt_prev    <=  du_dmr1[`OR1200_DU_DMR1_BT] ;\n        end\n    end\nend\n\n`ifdef verilator\n   // Function to access wb_pc (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [31:0] get_wb_pc;\n      // verilator public\n      get_wb_pc = wb_pc;\n   endfunction // get_wb_pc\n\n   // Function to access id_pc (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [31:0] get_id_pc;\n      // verilator public\n      get_id_pc = id_pc;\n   endfunction // get_id_pc\n\n   // Function to access ex_pc (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [31:0] get_ex_pc;\n      // verilator public\n      get_ex_pc = ex_pc;\n   endfunction // get_ex_pc\n   // Function to access except_type[3:0] (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n   function [3:0] get_except_type;\n      // verilator public\n      get_except_type = except_type;\n   endfunction // get_except_type\n   \n`endif\n   \n   \n//\n// PC and Exception flags pipelines\n//\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\tid_pc <=  32'd0;\n        id_pc_val <=  1'b0 ;\n\t\tid_exceptflags <=  3'b000;\n\tend\n\telse if (id_flushpipe) begin\n        id_pc_val <=  1'b0 ;\n\t\tid_exceptflags <=  3'b000;\n\tend\n\telse if (!id_freeze) begin\n\t\tid_pc <=  if_pc;\n        id_pc_val <=  1'b1 ;\n\t\tid_exceptflags <=  { sig_ibuserr, sig_itlbmiss, sig_immufault };\n\tend\nend\n\n//\n// delayed_iee\n//\n// SR[IEE] should not enable interrupts right away\n// when it is restored with l.rfe. Instead delayed_iee\n// together with SR[IEE] enables interrupts once\n// pipeline is again ready.\n//\nalways @(`OR1200_RST_EVENT rst or posedge clk)\n\tif (rst == `OR1200_RST_VALUE)\n\t\tdelayed_iee <=  3'b000;\n\telse if (!sr[`OR1200_SR_IEE])\n\t\tdelayed_iee <=  3'b000;\n\telse\n\t\tdelayed_iee <=  {delayed_iee[1:0], 1'b1};\n\n//\n// delayed_tee\n//\n// SR[TEE] should not enable tick exceptions right away\n// when it is restored with l.rfe. Instead delayed_tee\n// together with SR[TEE] enables tick exceptions once\n// pipeline is again ready.\n//\nalways @(`OR1200_RST_EVENT rst or posedge clk)\n\tif (rst == `OR1200_RST_VALUE)\n\t\tdelayed_tee <=  3'b000;\n\telse if (!sr[`OR1200_SR_TEE])\n\t\tdelayed_tee <=  3'b000;\n\telse\n\t\tdelayed_tee <=  {delayed_tee[1:0], 1'b1};\n\n//\n// PC and Exception flags pipelines\n//\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\tex_dslot <=  1'b0;\n\t\tex_pc <=  32'd0;\n                ex_pc_val <=  1'b0 ;\n\t\tex_exceptflags <=  3'b000;\n\t\tdelayed1_ex_dslot <=  1'b0;\n\t\tdelayed2_ex_dslot <=  1'b0;\n\tend\n\telse if (ex_flushpipe) begin\n\t\tex_dslot <=  1'b0;\n                ex_pc_val <=  1'b0 ;\n\t\tex_exceptflags <=  3'b000;\n\t\tdelayed1_ex_dslot <=  1'b0;\n\t\tdelayed2_ex_dslot <=  1'b0;\n\tend\n\telse if (!ex_freeze & id_freeze) begin\n\t\tex_dslot <=  1'b0;\n\t\tex_pc <=  id_pc;\n                ex_pc_val <=  id_pc_val ;\n\t\tex_exceptflags <=  3'b000;\n\t\tdelayed1_ex_dslot <=  ex_dslot;\n\t\tdelayed2_ex_dslot <=  delayed1_ex_dslot;\n\tend\n\telse if (!ex_freeze) begin\n\t\tex_dslot <=  ex_branch_taken;\n\t\tex_pc <=  id_pc;\n                ex_pc_val <=  id_pc_val ;\n\t\tex_exceptflags <=  id_exceptflags;\n\t\tdelayed1_ex_dslot <=  ex_dslot;\n\t\tdelayed2_ex_dslot <=  delayed1_ex_dslot;\n\tend\nend\n\n//\n// PC and Exception flags pipelines\n//\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\twb_pc <=  32'd0;\n        dl_pc <=  32'd0;\n\tend\n\telse if (!wb_freeze) begin\n\t\twb_pc <=  ex_pc;\n        dl_pc <=  wb_pc;\n\tend\nend\n\n//\n// We have started execution of exception handler:\n//  1. Asserted for 3 clock cycles\n//  2. Don't execute any instruction that is still in pipeline and is not part of exception handler\n//\nassign except_flushpipe = |except_trig & ~|state;\n\n//\n// Exception FSM that sequences execution of exception handler\n//\n// except_type signals which exception handler we start fetching in:\n//  1. Asserted in next clock cycle after exception is recognized\n//\n   always @(posedge clk or `OR1200_RST_EVENT rst) begin\n      if (rst == `OR1200_RST_VALUE) begin\n\t state <=  `OR1200_EXCEPTFSM_IDLE;\n\t except_type <=  `OR1200_EXCEPT_NONE;\n\t extend_flush <=  1'b0;\n\t epcr <=  32'b0;\n\t eear <=  32'b0;\n\t esr <=  {2'h1, {`OR1200_SR_WIDTH-3{1'b0}}, 1'b1};\n\t extend_flush_last <=  1'b0;\n      end\n      else begin\n`ifdef OR1200_CASE_DEFAULT\n\t case (state)\t// synopsys parallel_case\n`else\n\t   case (state)\t// synopsys full_case parallel_case\n`endif\n\t     `OR1200_EXCEPTFSM_IDLE:\n\t       if (except_flushpipe) begin\n\t\t  state <=  `OR1200_EXCEPTFSM_FLU1;\n\t\t  extend_flush <=  1'b1;\n\t\t  esr <=  sr_we ? to_sr : sr;\n\t\t  casez (except_trig)\n`ifdef OR1200_EXCEPT_ITLBMISS\n\t\t    14'b1?_????_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_ITLBMISS;\n\t\t       eear <=  ex_dslot ? \n\t\t\t       ex_pc : ex_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_IPF\n\t\t    14'b01_????_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_IPF;\n\t\t       eear <=  ex_dslot ? \n\t\t\t       ex_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_BUSERR\n\t\t    14'b00_1???_????_????: begin\t// Insn. Bus Error\n\t\t       except_type <=  `OR1200_EXCEPT_BUSERR;\n\t\t       eear <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_ILLEGAL\n\t\t    14'b00_01??_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_ILLEGAL;\n\t\t       eear <=  ex_pc;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_ALIGN\n\t\t    14'b00_001?_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_ALIGN;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_DTLBMISS\n\t\t    14'b00_0001_????_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_DTLBMISS;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       dl_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_TRAP\t\t\t\n\t\t    14'b00_0000_1???_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_TRAP;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_SYSCALL\n\t\t    14'b00_0000_01??_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_SYSCALL;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_DPF\n\t\t    14'b00_0000_001?_????: begin\n\t\t       except_type <=  `OR1200_EXCEPT_DPF;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       dl_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_BUSERR\n\t\t    14'b00_0000_0001_????: begin\t// Data Bus Error\n\t\t       except_type <=  `OR1200_EXCEPT_BUSERR;\n\t\t       eear <=  lsu_addr;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       dl_pc : ex_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_RANGE\n\t\t    14'b00_0000_0000_1???: begin\n\t\t       except_type <=  `OR1200_EXCEPT_RANGE;\n\t\t       epcr <=  ex_dslot ? \n\t\t\t       wb_pc : delayed1_ex_dslot ? \n\t\t\t       id_pc : delayed2_ex_dslot ? \n\t\t\t       id_pc : id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_FLOAT\n\t\t    14'b00_0000_0000_01??: begin\n\t\t       except_type <=  `OR1200_EXCEPT_FLOAT;\n\t\t       epcr <=  id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_INT\n\t\t    14'b00_0000_0000_001?: begin\n\t\t       except_type <=  `OR1200_EXCEPT_INT;\n\t\t       epcr <=  id_pc;\n\t\t    end\n`endif\n`ifdef OR1200_EXCEPT_TICK\n\t\t    14'b00_0000_0000_0001: begin\n\t\t       except_type <=  `OR1200_EXCEPT_TICK;\n\t\t       epcr <=  id_pc;\n\t\t    end\n`endif\n\t\t    default:\n\t\t      except_type <=  `OR1200_EXCEPT_NONE;\n\t\t  endcase\n\t       end\n\t       else if (pc_we) begin\n\t\t  state <=  `OR1200_EXCEPTFSM_FLU1;\n\t\t  extend_flush <=  1'b1;\n\t       end\n\t       else begin\n\t\t  if (epcr_we)\n\t\t    epcr <=  datain;\n\t\t  if (eear_we)\n\t\t    eear <=  datain;\n\t\t  if (esr_we)\n\t\t    esr <=  {datain[`OR1200_SR_WIDTH-1], 1'b1, datain[`OR1200_SR_WIDTH-3:0]};\n\t       end\n\t     `OR1200_EXCEPTFSM_FLU1:\n\t       if (icpu_ack_i | icpu_err_i | genpc_freeze)\n\t\t state <=  `OR1200_EXCEPTFSM_FLU2;\n\t     `OR1200_EXCEPTFSM_FLU2:\n`ifdef OR1200_EXCEPT_TRAP\n\t       if (except_type == `OR1200_EXCEPT_TRAP) begin\n\t\t  state <=  `OR1200_EXCEPTFSM_IDLE;\n\t\t  extend_flush <=  1'b0;\n\t\t  extend_flush_last <=  1'b0;\n\t\t  except_type <=  `OR1200_EXCEPT_NONE;\n\t       end\n               else\n`endif\n\t\t state <=  `OR1200_EXCEPTFSM_FLU3;\n\t     `OR1200_EXCEPTFSM_FLU3:\n\t       begin\n\t\t  state <=  `OR1200_EXCEPTFSM_FLU4;\n\t       end\n\t     `OR1200_EXCEPTFSM_FLU4: begin\n\t\tstate <=  `OR1200_EXCEPTFSM_FLU5;\n\t\textend_flush <=  1'b0;\n\t\textend_flush_last <=  1'b0; // damjan\n\t     end\n`ifdef OR1200_CASE_DEFAULT\n\t     default: begin\n`else\n\t\t`OR1200_EXCEPTFSM_FLU5: begin\n`endif\n\t\t   if (!if_stall && !id_freeze) begin\n\t\t      state <=  `OR1200_EXCEPTFSM_IDLE;\n\t\t      except_type <=  `OR1200_EXCEPT_NONE;\n\t\t      extend_flush_last <=  1'b0;\n\t\t   end\n\t\tend\n\t   endcase\n\t end\n   end\n\nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's Top level multiplier, divider and MAC              ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://opencores.org/project,or1k                           ////\n////                                                              ////\n////  Description                                                 ////\n////  Multiplier is 32x32 however multiply instructions only      ////\n////  use lower 32 bits of the result. MAC is 32x32=64+64.        ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make signed division better, w/o negating the operands   ////\n////   - implement non-serial divider that is synthesizable       ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////      - Julius Baxter, julius@opencores.org                   ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000, 2010 Authors and OPENCORES.ORG           ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// CVS Revision History\n//\n// $Log: or1200_mult_mac.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Minor update: \n// Bugs fixed. \n//\n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_mult_mac(\n\t\t       // Clock and reset\n\t\t       clk, rst,\n\n\t\t       // Multiplier/MAC interface\n\t\t       ex_freeze, id_macrc_op, macrc_op, a, b, mac_op, alu_op, \n\t\t       result, mult_mac_stall,\n\n\t\t       // Overflow\n\t\t       ovforw, ov_we,\n\t\t       \n\t\t       // SPR interface\n\t\t       spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o\n\t\t       );\n\n   parameter width = `OR1200_OPERAND_WIDTH;\n\n   //\n   // I/O\n   //\n\n   //\n   // Clock and reset\n   //\n   input\t\t\t\tclk;\n   input\t\t\t\trst;\n\n   //\n   // Multiplier/MAC interface\n   //\n   input\t\t\t\tex_freeze;\n   input\t\t\t\tid_macrc_op;\n   input\t\t\t\tmacrc_op;\n   input [width-1:0] \t\t\ta;\n   input [width-1:0] \t\t\tb;\n   input [`OR1200_MACOP_WIDTH-1:0] \tmac_op;\n   input [`OR1200_ALUOP_WIDTH-1:0] \talu_op;\n   output [width-1:0] \t\t\tresult;\n   output\t\t\t\tmult_mac_stall;\n   output \t\t\t\tovforw, ov_we;\n   \n   //\n   // SPR interface\n   //\n   input\t\t\t\tspr_cs;\n   input\t\t\t\tspr_write;\n   input [31:0] \t\t\tspr_addr;\n   input [31:0] \t\t\tspr_dat_i;\n   output [31:0] \t\t\tspr_dat_o;\n\n   //\n   // Internal wires and regs\n   //\n   reg [width-1:0] \t\t\tresult;\n   reg \t\t\t\t\tex_freeze_r;\n`ifdef OR1200_MULT_IMPLEMENTED\n   reg [2*width-1:0] \t\t\tmul_prod_r;\n   wire \t\t\t\talu_op_smul;   \n   wire \t\t\t\talu_op_umul;   \n   wire \t\t\t\talu_op_mul;      \n `ifdef OR1200_MULT_SERIAL\n   reg [5:0] \t\t\t\tserial_mul_cnt;   \n   reg \t\t\t\t\tmul_free;   \n `endif\n`else\n   wire [2*width-1:0] \t\t\tmul_prod_r;\n`endif\n   wire [2*width-1:0] \t\t\tmul_prod;\n   wire \t\t\t\tmul_stall;\n   reg [1:0] \t\t\t\tmul_stall_count;   \n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op;\n`ifdef OR1200_MAC_IMPLEMENTED\n   reg [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r1;\n   reg [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r2;\n   reg [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r3;\n   reg \t\t\t\t\tmac_stall_r;\n   reg [63:0] \t\t\t\tmac_r;\n`else\n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r1;\n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r2;\n   wire [`OR1200_MACOP_WIDTH-1:0] \tmac_op_r3;\n   wire \t\t\t\tmac_stall_r;\n   wire [63:0] \t\t\t\tmac_r;\n`endif\n   wire [width-1:0] \t\t\tx;\n   wire [width-1:0] \t\t\ty;\n   wire \t\t\t\tspr_maclo_we;\n   wire \t\t\t\tspr_machi_we; \n   wire \t\t\t\talu_op_div;  \n   wire \t\t\t\talu_op_udiv;\n   wire \t\t\t\talu_op_sdiv;\n   reg \t\t\t\t\tdiv_free;\n   wire \t\t\t        div_stall;\n`ifdef OR1200_DIV_IMPLEMENTED\n `ifdef OR1200_DIV_SERIAL\n   reg [2*width-1:0] \t\t\tdiv_quot_r;   \n   wire [width-1:0] \t\t\tdiv_tmp;\n   reg [5:0] \t\t\t\tdiv_cntr;\n `else\n   reg [width-1:0] \t\t\tdiv_quot_r;      \n   reg [width-1:0] \t\t\tdiv_quot_generic;   \n `endif\n   wire \t\t\t\tdiv_by_zero;\n`endif\n   reg \t\t\t\t\tovforw, ov_we;\n   \n   //\n   // Combinatorial logic\n   //\n`ifdef OR1200_MULT_IMPLEMENTED\n   assign alu_op_smul = (alu_op == `OR1200_ALUOP_MUL);\n   assign alu_op_umul = (alu_op == `OR1200_ALUOP_MULU);\n   assign alu_op_mul = alu_op_smul | alu_op_umul;\n`endif   \n`ifdef OR1200_MAC_IMPLEMENTED\n   assign spr_maclo_we = spr_cs & spr_write & spr_addr[`OR1200_MAC_ADDR];\n   assign spr_machi_we = spr_cs & spr_write & !spr_addr[`OR1200_MAC_ADDR];\n   assign spr_dat_o = spr_addr[`OR1200_MAC_ADDR] ? mac_r[31:0] : mac_r[63:32];\n`else\n   assign spr_maclo_we = 1'b0;\n   assign spr_machi_we = 1'b0;\n   assign spr_dat_o = 32'h0000_0000;\n`endif\n`ifdef OR1200_DIV_IMPLEMENTED\n   assign alu_op_sdiv = (alu_op == `OR1200_ALUOP_DIV);\n   assign alu_op_udiv = (alu_op == `OR1200_ALUOP_DIVU);\n   assign alu_op_div = alu_op_sdiv | alu_op_udiv;   \n`else\n   assign alu_op_udiv = 1'b0;\n   assign alu_op_sdiv = 1'b0;\n   assign alu_op_div = 1'b0;   \n`endif\n\n   assign x = (alu_op_sdiv | alu_op_smul) & a[31] ? ~a + 32'b1 : \n\t      alu_op_div | alu_op_mul | (|mac_op) ? a : 32'd0;\n   assign y = (alu_op_sdiv | alu_op_smul) & b[31] ? ~b + 32'b1 : \n\t      alu_op_div | alu_op_mul | (|mac_op) ? b : 32'd0;\n\n   assign div_by_zero = !(|b) & alu_op_div;\n   \n\n   // Used to indicate when we should check for new multiply or MAC ops\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       ex_freeze_r <= 1'b1;\n     else\n       ex_freeze_r <= ex_freeze;\n\n   //\n   // Select result of current ALU operation to be forwarded\n   // to next instruction and to WB stage\n   //\n   always @*\n     casez(alu_op)\t// synopsys parallel_case\n`ifdef OR1200_DIV_IMPLEMENTED\n       `OR1200_ALUOP_DIV: begin\n\t  result = a[31] ^ b[31] ? ~div_quot_r[31:0] + 32'd1 : div_quot_r[31:0];\n       end\n       `OR1200_ALUOP_DIVU: begin\n\t  result = div_quot_r[31:0];\n       end\n`endif\n`ifdef OR1200_MULT_IMPLEMENTED    \n       `OR1200_ALUOP_MUL: begin\n\t  result = a[31] ^ b[31] ? ~mul_prod_r[31:0] + 32'd1 : mul_prod_r[31:0];\n       end\n\t `OR1200_ALUOP_MULU: begin\n\t  result = mul_prod_r[31:0];\n       end\n`endif    \n       default:\n`ifdef OR1200_MAC_IMPLEMENTED      \n `ifdef OR1200_MAC_SHIFTBY\n\t result = mac_r[`OR1200_MAC_SHIFTBY+31:`OR1200_MAC_SHIFTBY];\n `else\n       result = mac_r[31:0];\n `endif\n`else\n       result = {width{1'b0}};    \n`endif    \n     endcase // casez (alu_op)\n\n\n   //\n   // Overflow generation\n   //\n   always @*\n     casez(alu_op)\t// synopsys parallel_case\n`ifdef OR1200_IMPL_OV       \n `ifdef OR1200_MULT_IMPLEMENTED\n       `OR1200_ALUOP_MUL: begin\n\t  // Actually doing unsigned multiply internally, and then negate on\n\t  // output as appropriate, so if sign bit is set, then is overflow\n\t  ovforw = mul_prod_r[31];\n\t  ov_we = 1;\n       end\n       `OR1200_ALUOP_MULU : begin\n\t  // Overflow on unsigned multiply is simpler.\n\t  ovforw = mul_prod_r[32];\n\t  ov_we = 1;\n       end\n `endif //  `ifdef OR1200_MULT_IMPLEMENTED\n `ifdef OR1200_DIV_IMPLEMENTED\n       `OR1200_ALUOP_DIVU,\n       `OR1200_ALUOP_DIV: begin\n\t  // Overflow on divide by zero\n\t  ovforw = div_by_zero;\n\t  ov_we = 1;\n       end\n `endif\n`endif //  `ifdef OR1200_IMPL_OV\n       default: begin\n\t  ovforw = 0;\n\t  ov_we = 0;\n       end\n     endcase // casez (alu_op)\n   \n\n`ifdef OR1200_MULT_IMPLEMENTED\n `ifdef OR1200_MULT_SERIAL\n\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE) begin\n\tmul_prod_r <=  64'h0000_0000_0000_0000;\n\tserial_mul_cnt <= 6'd0;\n\tmul_free <= 1'b1;\n\t\n     end\n     else if (|serial_mul_cnt) begin\n\tserial_mul_cnt <= serial_mul_cnt - 6'd1;\n\tif (mul_prod_r[0])\n\t  mul_prod_r[(width*2)-1:width-1] <= mul_prod_r[(width*2)-1:width] + x;\n\telse\n\t  mul_prod_r[(width*2)-1:width-1] <= {1'b0,mul_prod_r[(width*2)-1:\n\t\t\t\t\t\t\t      width]};\n\tmul_prod_r[width-2:0] <= mul_prod_r[width-1:1];\n\t\n     end\n     else if (alu_op_mul && mul_free) begin\n\tmul_prod_r <= {32'd0, y};\n\tmul_free <= 0;\n\tserial_mul_cnt <= 6'b10_0000;\n     end\n     else if (!ex_freeze | mul_free) begin\n\tmul_free <= 1'b1;\t\n     end\n\n   assign mul_stall = (|serial_mul_cnt) | (alu_op_mul & !ex_freeze_r);\n   \n `else\n   \n   //\n   // Instantiation of the multiplier\n   //\n  `ifdef OR1200_ASIC_MULTP2_32X32\n   or1200_amultp2_32x32 or1200_amultp2_32x32(\n\t\t\t\t\t     .X(x),\n\t\t\t\t\t     .Y(y),\n\t\t\t\t\t     .RST(rst),\n\t\t\t\t\t     .CLK(clk),\n\t\t\t\t\t     .P(mul_prod)\n\t\t\t\t\t     );\n  `else // OR1200_ASIC_MULTP2_32X32\n   or1200_gmultp2_32x32 or1200_gmultp2_32x32(\n\t\t\t\t\t     .X(x),\n\t\t\t\t\t     .Y(y),\n\t\t\t\t\t     .RST(rst),\n\t\t\t\t\t     .CLK(clk),\n\t\t\t\t\t     .P(mul_prod)\n\t\t\t\t\t     );\n  `endif // OR1200_ASIC_MULTP2_32X32   \n   \n   //\n   // Registered output from the multiplier\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE) begin\n\tmul_prod_r <=  64'h0000_0000_0000_0000;\n     end\n     else begin\n\tmul_prod_r <=  mul_prod[63:0];\n     end\n\n   //\n   // Generate stall signal during multiplication\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE)\n       mul_stall_count <= 0;\n     else if (!(|mul_stall_count))\n       mul_stall_count <= {mul_stall_count[0], alu_op_mul & !ex_freeze_r};\n     else \n       mul_stall_count <= {mul_stall_count[0],1'b0};\n       \n   assign mul_stall = (|mul_stall_count) | \n\t\t      (!(|mul_stall_count) & alu_op_mul & !ex_freeze_r);\n   \n `endif // !`ifdef OR1200_MULT_SERIAL   \n   \n`else // OR1200_MULT_IMPLEMENTED\n   assign mul_prod = {2*width{1'b0}};\n   assign mul_prod_r = {2*width{1'b0}};\n   assign mul_stall = 0;   \n`endif // OR1200_MULT_IMPLEMENTED\n\n`ifdef OR1200_MAC_IMPLEMENTED\n   \n   //\n   // Propagation of l.mac opcode, only register it for one cycle\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       mac_op_r1 <=  `OR1200_MACOP_WIDTH'b0;\n     else\n       mac_op_r1 <=  !ex_freeze_r ? mac_op : `OR1200_MACOP_WIDTH'b0;\n\n   //\n   // Propagation of l.mac opcode\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       mac_op_r2 <=  `OR1200_MACOP_WIDTH'b0;\n     else\n       mac_op_r2 <=  mac_op_r1;\n\n   //\n   // Propagation of l.mac opcode\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       mac_op_r3 <=  `OR1200_MACOP_WIDTH'b0;\n     else\n       mac_op_r3 <=  mac_op_r2;\n\n   //\n   // Implementation of MAC\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE)\n       mac_r <=  64'h0000_0000_0000_0000;\n `ifdef OR1200_MAC_SPR_WE\n     else if (spr_maclo_we)\n       mac_r[31:0] <=  spr_dat_i;\n     else if (spr_machi_we)\n       mac_r[63:32] <=  spr_dat_i;\n `endif\n     else if (mac_op_r3 == `OR1200_MACOP_MAC)\n       mac_r <=  mac_r + mul_prod_r;\n     else if (mac_op_r3 == `OR1200_MACOP_MSB)\n       mac_r <=  mac_r - mul_prod_r;\n     else if (macrc_op && !ex_freeze)\n       mac_r <=  64'h0000_0000_0000_0000;\n\n   //\n   // Stall CPU if l.macrc is in ID and MAC still has to process l.mac \n   // instructions in EX stage (e.g. inside multiplier)\n   // This stall signal is also used by the divider.\n   //\n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE)\n       mac_stall_r <=  1'b0;\n     else\n       mac_stall_r <=  (|mac_op | (|mac_op_r1) | (|mac_op_r2)) & \n\t\t       (id_macrc_op | mac_stall_r);\n   \n`else // OR1200_MAC_IMPLEMENTED\n   assign mac_stall_r = 1'b0;\n   assign mac_r = {2*width{1'b0}};\n   assign mac_op_r1 = `OR1200_MACOP_WIDTH'b0;\n   assign mac_op_r2 = `OR1200_MACOP_WIDTH'b0;\n   assign mac_op_r3 = `OR1200_MACOP_WIDTH'b0;\n`endif // OR1200_MAC_IMPLEMENTED\n\n`ifdef OR1200_DIV_IMPLEMENTED   \n   \n   //\n   // Serial division\n   //\n `ifdef OR1200_DIV_SERIAL\n   assign div_tmp = div_quot_r[63:32] - y;   \n   always @(`OR1200_RST_EVENT rst or posedge clk)\n     if (rst == `OR1200_RST_VALUE) begin\n\tdiv_quot_r <=  64'h0000_0000_0000_0000;\n\tdiv_free <=  1'b1;\n\tdiv_cntr <=  6'b00_0000;\n     end\n     else if (div_by_zero) begin\n\tdiv_quot_r <=  64'h0000_0000_0000_0000;\n\tdiv_free <=  1'b1;\n\tdiv_cntr <=  6'b00_0000;\n     end\n     else if (|div_cntr) begin\n\tif (div_tmp[31])\n\t  div_quot_r <=  {div_quot_r[62:0], 1'b0};\n\telse\n\t  div_quot_r <=  {div_tmp[30:0], div_quot_r[31:0], 1'b1};\n\tdiv_cntr <=  div_cntr - 6'd1;\n     end\n     else if (alu_op_div && div_free) begin\n\tdiv_quot_r <=  {31'b0, x[31:0], 1'b0};\n\tdiv_cntr <=  6'b10_0000;\n\tdiv_free <=  1'b0;\n     end\n     else if (div_free | !ex_freeze) begin\n\tdiv_free <=  1'b1;\n     end\n\n   assign div_stall = (|div_cntr) | (!ex_freeze_r & alu_op_div);\n\n\n `else // !`ifdef OR1200_DIV_SERIAL\n\n   // Full divider\n   // TODO: Perhaps provide module that can be technology dependent.\n   always @(`OR1200_RST_EVENT rst or posedge clk) begin     \n      if (rst == `OR1200_RST_VALUE) begin\n\t div_quot_r <=  32'd0;\t   \n\t div_quot_generic <= 32'd0;\t   \n      end\n      else begin\n\t if (alu_op_udiv & !(|y)) // unsigned divide by 0 - force to MAX\n\t   div_quot_generic[31:0] <= 32'hffff_ffff;\t   \n\t else if (alu_op_div)\n\t   div_quot_generic[31:0] <= x / y;\n      end\n\n      // Add any additional statges of pipelining as required here. Ensure\n      // ends with div_quot_r.\n      // Then add logic to ensure div_stall stays high for as long as the\n      // division should take.      \n      \n      div_quot_r[31:0] <= div_quot_generic;\n\n   end     \n   \n   assign div_stall = 0;\n   \n `endif   \n\n`else // !`ifdef OR1200_DIV_IMPLEMENTED\n\n   assign div_stall = 0;\n\n`endif // !`ifdef OR1200_DIV_IMPLEMENTED\n   \n   \n   //   \n   // Stall output\n   //\n   assign mult_mac_stall = mac_stall_r | div_stall | mul_stall;\n   \nendmodule\n", "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  OR1200's interface to SPRs                                  ////\n////                                                              ////\n////  This file is part of the OpenRISC 1200 project              ////\n////  http://www.opencores.org/project,or1k                       ////\n////                                                              ////\n////  Description                                                 ////\n////  Decoding of SPR addresses and access to SPRs                ////\n////                                                              ////\n////  To Do:                                                      ////\n////   - make it smaller and faster                               ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - Damjan Lampret, lampret@opencores.org                 ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// $Log: or1200_sprs.v,v $\n// Revision 2.0  2010/06/30 11:00:00  ORSoC\n// Major update: \n// Structure reordered and bugs fixed. \n\n// synopsys translate_off\n`include \"timescale.v\"\n// synopsys translate_on\n`include \"or1200_defines.v\"\n\nmodule or1200_sprs(\n\t\t   // Clk & Rst\n\t\t   clk, rst,\n\n\t\t   // Internal CPU interface\n\t\t   flagforw, flag_we, flag, cyforw, cy_we, carry,\n\t\t   ovforw, ov_we,\n\t\t   addrbase, addrofs, dat_i, branch_op, ex_spr_read, \n\t\t   ex_spr_write, \n\t\t   epcr, eear, esr, except_started,\n\t\t   to_wbmux, epcr_we, eear_we, esr_we, pc_we, sr_we, to_sr, sr,\n\t\t   spr_dat_cfgr, spr_dat_rf, spr_dat_npc, spr_dat_ppc, \n\t\t   spr_dat_mac,\n\t\t   \n\t\t   boot_adr_sel_i,\n\n\t\t   // Floating point SPR input\n\t\t   fpcsr, fpcsr_we, spr_dat_fpu,\n\n\t\t   // From/to other RISC units\n\t\t   spr_dat_pic, spr_dat_tt, spr_dat_pm,\n\t\t   spr_dat_dmmu, spr_dat_immu, spr_dat_du,\n\t\t   spr_addr, spr_dat_o, spr_cs, spr_we,\n\n\t\t   du_addr, du_dat_du, du_read,\n\t\t   du_write, du_dat_cpu\n\n\t\t   );\n\n   parameter width = `OR1200_OPERAND_WIDTH;\n\n   //\n   // I/O Ports\n   //\n\n   //\n   // Internal CPU interface\n   //\n   input\t\t\t\tclk; \t\t// Clock\n   input \t\t\t\trst;\t\t// Reset\n   input \t\t\t\tflagforw;\t// From ALU\n   input \t\t\t\tflag_we;\t// From ALU\n   output \t\t\t\tflag;\t\t// SR[F]\n   input \t\t\t\tcyforw;\t\t// From ALU\n   input \t\t\t\tcy_we;\t\t// From ALU\n   output \t\t\t\tcarry;\t\t// SR[CY]\n   input \t\t\t\tovforw;\t\t// From ALU\n   input \t\t\t\tov_we;\t\t// From ALU\n   input [width-1:0] \t\t\taddrbase;\t// SPR base address\n   input [15:0] \t\t\taddrofs;\t// SPR offset\n   input [width-1:0] \t\t\tdat_i;\t\t// SPR write data\n   input \t\t\t\tex_spr_read;\t// l.mfspr in EX\n   input \t\t\t\tex_spr_write;\t// l.mtspr in EX\n   input [`OR1200_BRANCHOP_WIDTH-1:0] \tbranch_op;\t// Branch operation\n   input [width-1:0] \t\t\tepcr /* verilator public */;// EPCR0\n   input [width-1:0] \t\t\teear /* verilator public */;// EEAR0\n   input [`OR1200_SR_WIDTH-1:0] \tesr /* verilator public */; // ESR0\n   input \t\t\t\texcept_started; // Exception was started\n   output [width-1:0] \t\t\tto_wbmux;\t// For l.mfspr\n   output\t\t\t\tepcr_we;\t// EPCR0 write enable\n   output\t\t\t\teear_we;\t// EEAR0 write enable\n   output\t\t\t\tesr_we;\t\t// ESR0 write enable\n   output\t\t\t\tpc_we;\t\t// PC write enable\n   output \t\t\t\tsr_we;\t\t// Write enable SR\n   output [`OR1200_SR_WIDTH-1:0] \tto_sr;\t\t// Data to SR\n   output [`OR1200_SR_WIDTH-1:0] \tsr /* verilator public */;// SR\n   input [31:0] \t\t\tspr_dat_cfgr;\t// Data from CFGR\n   input [31:0] \t\t\tspr_dat_rf;\t// Data from RF\n   input [31:0] \t\t\tspr_dat_npc;\t// Data from NPC\n   input [31:0] \t\t\tspr_dat_ppc;\t// Data from PPC   \n   input [31:0] \t\t\tspr_dat_mac;\t// Data from MAC\n   input\t\t\t\tboot_adr_sel_i;\n\n   input [`OR1200_FPCSR_WIDTH-1:0] \tfpcsr;\t// FPCSR\n   output \t\t\t\tfpcsr_we;\t// Write enable FPCSR   \n   input [31:0] \t\t\tspr_dat_fpu;    // Data from FPU\n   \n   //\n   // To/from other RISC units\n   //\n   input [31:0] \t\t\tspr_dat_pic;\t// Data from PIC\n   input [31:0] \t\t\tspr_dat_tt;\t// Data from TT\n   input [31:0] \t\t\tspr_dat_pm;\t// Data from PM\n   input [31:0] \t\t\tspr_dat_dmmu;\t// Data from DMMU\n   input [31:0] \t\t\tspr_dat_immu;\t// Data from IMMU\n   input [31:0] \t\t\tspr_dat_du;\t// Data from DU\n   output [31:0] \t\t\tspr_addr;\t// SPR Address\n   output [31:0] \t\t\tspr_dat_o;\t// Data to unit\n   output [31:0] \t\t\tspr_cs;\t\t// Unit select\n   output\t\t\t\tspr_we;\t\t// SPR write enable\n\n   //\n   // To/from Debug Unit\n   //\n   input [width-1:0] \t\t\tdu_addr;\t// Address\n   input [width-1:0] \t\t\tdu_dat_du;\t// Data from DU to SPRS\n   input\t\t\t\tdu_read;\t// Read qualifier\n   input\t\t\t\tdu_write;\t// Write qualifier\n   output [width-1:0] \t\t\tdu_dat_cpu;\t// Data from SPRS to DU\n\n   //\n   // Internal regs & wires\n   //\n   reg [`OR1200_SR_WIDTH-1:0] \t\tsr_reg;\t\t// SR\n   reg \t\t\t\t\tsr_reg_bit_eph;\t// SR_EPH bit\n   reg \t\t\t\t\tsr_reg_bit_eph_select;// SR_EPH select\n   wire \t\t\t\tsr_reg_bit_eph_muxed;// SR_EPH muxed bit\n   reg [`OR1200_SR_WIDTH-1:0] \t\tsr;\t\t\t// SR\n   reg [width-1:0] \t\t\tto_wbmux;\t// For l.mfspr\n   wire \t\t\t\tcfgr_sel;\t// Select for cfg regs\n   wire \t\t\t\trf_sel;\t\t// Select for RF\n   wire \t\t\t\tnpc_sel;\t// Select for NPC\n   wire \t\t\t\tppc_sel;\t// Select for PPC\n   wire \t\t\t\tsr_sel;\t\t// Select for SR\t\n   wire \t\t\t\tepcr_sel;\t// Select for EPCR0\n   wire \t\t\t\teear_sel;\t// Select for EEAR0\n   wire \t\t\t\tesr_sel;\t// Select for ESR0\n   wire \t\t\t\tfpcsr_sel;\t// Select for FPCSR   \n   wire [31:0] \t\t\t\tsys_data;// Read data from system SPRs\n   wire \t\t\t\tdu_access;// Debug unit access\n   reg [31:0] \t\t\t\tunqualified_cs;\t// Unqualified selects\n   wire \t\t\t\tex_spr_write; // jb\n   \n   //\n   // Decide if it is debug unit access\n   //\n   assign du_access = du_read | du_write;\n\n   //\n   // Generate SPR address from base address and offset\n   // OR from debug unit address\n   //\n   assign spr_addr = du_access ? du_addr : (addrbase | {16'h0000, addrofs});\n\n   //\n   // SPR is written by debug unit or by l.mtspr\n   //\n   assign spr_dat_o = du_write ? du_dat_du : dat_i;\n\n   //\n   // debug unit data input:\n   //  - read of SPRS by debug unit\n   //  - write into debug unit SPRs by debug unit itself\n   //  - write into debug unit SPRs by l.mtspr\n   //\n   assign du_dat_cpu = du_read ? to_wbmux : du_write ? du_dat_du : dat_i;\n\n   //\n   // Write into SPRs when DU or l.mtspr\n   //\n   assign spr_we = du_write | ( ex_spr_write & !du_access );\n\n\n   //\n   // Qualify chip selects\n   //\n   assign spr_cs = unqualified_cs & {32{du_read | du_write | ex_spr_read | \n\t\t\t\t\t(ex_spr_write & sr[`OR1200_SR_SM])}};\n\n   //\n   // Decoding of groups\n   //\n   always @(spr_addr)\n     case (spr_addr[`OR1200_SPR_GROUP_BITS])\t// synopsys parallel_case\n       `OR1200_SPR_GROUP_WIDTH'd00: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00000001;\n       `OR1200_SPR_GROUP_WIDTH'd01: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00000010;\n       `OR1200_SPR_GROUP_WIDTH'd02: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00000100;\n       `OR1200_SPR_GROUP_WIDTH'd03: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00001000;\n       `OR1200_SPR_GROUP_WIDTH'd04: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00010000;\n       `OR1200_SPR_GROUP_WIDTH'd05: unqualified_cs \n\t = 32'b00000000_00000000_00000000_00100000;\n       `OR1200_SPR_GROUP_WIDTH'd06: unqualified_cs \n\t = 32'b00000000_00000000_00000000_01000000;\n       `OR1200_SPR_GROUP_WIDTH'd07: unqualified_cs \n\t = 32'b00000000_00000000_00000000_10000000;\n       `OR1200_SPR_GROUP_WIDTH'd08: unqualified_cs \n\t = 32'b00000000_00000000_00000001_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd09: unqualified_cs \n\t = 32'b00000000_00000000_00000010_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd10: unqualified_cs \n\t = 32'b00000000_00000000_00000100_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd11: unqualified_cs \n\t = 32'b00000000_00000000_00001000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd12: unqualified_cs \n\t = 32'b00000000_00000000_00010000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd13: unqualified_cs \n\t = 32'b00000000_00000000_00100000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd14: unqualified_cs \n\t = 32'b00000000_00000000_01000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd15: unqualified_cs \n\t = 32'b00000000_00000000_10000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd16: unqualified_cs \n\t = 32'b00000000_00000001_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd17: unqualified_cs \n\t = 32'b00000000_00000010_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd18: unqualified_cs \n\t = 32'b00000000_00000100_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd19: unqualified_cs \n\t = 32'b00000000_00001000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd20: unqualified_cs \n\t = 32'b00000000_00010000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd21: unqualified_cs \n\t = 32'b00000000_00100000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd22: unqualified_cs \n\t = 32'b00000000_01000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd23: unqualified_cs \n\t = 32'b00000000_10000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd24: unqualified_cs \n\t = 32'b00000001_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd25: unqualified_cs \n\t = 32'b00000010_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd26: unqualified_cs \n\t = 32'b00000100_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd27: unqualified_cs \n\t = 32'b00001000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd28: unqualified_cs \n\t = 32'b00010000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd29: unqualified_cs \n\t = 32'b00100000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd30: unqualified_cs \n\t = 32'b01000000_00000000_00000000_00000000;\n       `OR1200_SPR_GROUP_WIDTH'd31: unqualified_cs \n\t = 32'b10000000_00000000_00000000_00000000;\n     endcase\n\n   //\n   // SPRs System Group\n   //\n\n   //\n   // What to write into SR\n   //\n   assign to_sr[`OR1200_SR_FO:`OR1200_SR_OVE] \n\t    = (except_started) ? {sr[`OR1200_SR_FO:`OR1200_SR_DSX],1'b0} :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? \n\t      esr[`OR1200_SR_FO:`OR1200_SR_OVE] : (spr_we && sr_sel) ? \n\t      {1'b1, spr_dat_o[`OR1200_SR_FO-1:`OR1200_SR_OVE]} :\n\t      sr[`OR1200_SR_FO:`OR1200_SR_OVE];\n   assign to_sr[`OR1200_SR_TED] \n\t    = (except_started) ? 1'b1 :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? esr[`OR1200_SR_TED] :\n\t      (spr_we && sr_sel) ? spr_dat_o[`OR1200_SR_TED] :\n\t      sr[`OR1200_SR_TED];\n   assign to_sr[`OR1200_SR_OV] \n\t    = (except_started) ? sr[`OR1200_SR_OV] :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? esr[`OR1200_SR_OV] :\n\t      ov_we ? ovforw :\n\t      (spr_we && sr_sel) ? spr_dat_o[`OR1200_SR_OV] :\n\t      sr[`OR1200_SR_OV];\n   assign to_sr[`OR1200_SR_CY] \n\t    = (except_started) ? sr[`OR1200_SR_CY] :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? esr[`OR1200_SR_CY] :\n\t      cy_we ? cyforw :\n\t      (spr_we && sr_sel) ? spr_dat_o[`OR1200_SR_CY] :\n\t      sr[`OR1200_SR_CY];\n   assign to_sr[`OR1200_SR_F] \n\t    = (except_started) ? sr[`OR1200_SR_F] :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? esr[`OR1200_SR_F] :\n\t      flag_we ? flagforw :\n\t      (spr_we && sr_sel) ? spr_dat_o[`OR1200_SR_F] :\n\t      sr[`OR1200_SR_F];\n   \n   assign to_sr[`OR1200_SR_CE:`OR1200_SR_SM] \n\t    = (except_started) ? {sr[`OR1200_SR_CE:`OR1200_SR_LEE], 2'b00, \n\t\t\t\t  sr[`OR1200_SR_ICE:`OR1200_SR_DCE], 3'b001} :\n\t      (branch_op == `OR1200_BRANCHOP_RFE) ? \n\t      esr[`OR1200_SR_CE:`OR1200_SR_SM] : (spr_we && sr_sel) ? \n\t      spr_dat_o[`OR1200_SR_CE:`OR1200_SR_SM] :\n\t      sr[`OR1200_SR_CE:`OR1200_SR_SM];\n\n   //\n   // Selects for system SPRs\n   //\n   assign cfgr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t      (spr_addr[10:4] == `OR1200_SPR_CFGR));\n   assign rf_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t    (spr_addr[10:5] == `OR1200_SPR_RF));\n   assign npc_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t     (spr_addr[10:0] == `OR1200_SPR_NPC));\n   assign ppc_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t     (spr_addr[10:0] == `OR1200_SPR_PPC));\n   assign sr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t    (spr_addr[10:0] == `OR1200_SPR_SR));\n   assign epcr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t      (spr_addr[10:0] == `OR1200_SPR_EPCR));\n   assign eear_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t      (spr_addr[10:0] == `OR1200_SPR_EEAR));\n   assign esr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t     (spr_addr[10:0] == `OR1200_SPR_ESR));\n   assign fpcsr_sel = (spr_cs[`OR1200_SPR_GROUP_SYS] && \n\t\t       (spr_addr[10:0] == `OR1200_SPR_FPCSR));\n\n\n   //\n   // Write enables for system SPRs\n   //\n   assign sr_we = (spr_we && sr_sel) | (branch_op == `OR1200_BRANCHOP_RFE) | \n\t\t  flag_we | cy_we | ov_we;\n   assign pc_we = (du_write && (npc_sel | ppc_sel));\n   assign epcr_we = (spr_we && epcr_sel);\n   assign eear_we = (spr_we && eear_sel);\n   assign esr_we = (spr_we && esr_sel);\n   assign fpcsr_we = (spr_we && fpcsr_sel);\n   \n   //\n   // Output from system SPRs\n   //\n   assign sys_data = (spr_dat_cfgr & {32{cfgr_sel}}) |\n\t\t     (spr_dat_rf & {32{rf_sel}}) |\n\t\t     (spr_dat_npc & {32{npc_sel}}) |\n\t\t     (spr_dat_ppc & {32{ppc_sel}}) |\n\t\t     ({{32-`OR1200_SR_WIDTH{1'b0}},sr} & {32{sr_sel}}) |\n\t\t     (epcr & {32{epcr_sel}}) |\n\t\t     (eear & {32{eear_sel}}) |\n\t\t     ({{32-`OR1200_FPCSR_WIDTH{1'b0}},fpcsr} & \n\t\t      {32{fpcsr_sel}}) |\n\t\t     ({{32-`OR1200_SR_WIDTH{1'b0}},esr} & {32{esr_sel}});\n\n   //\n   // Flag alias\n   //\n   assign flag = sr[`OR1200_SR_F];\n\n   //\n   // Carry alias\n   //\n   assign carry = sr[`OR1200_SR_CY];\n   \n   //\n   // Supervision register\n   //\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     if (rst == `OR1200_RST_VALUE)\n       sr_reg <=  {2'b01, // Fixed one.\n\t\t   `OR1200_SR_EPH_DEF, {`OR1200_SR_WIDTH-4{1'b0}}, 1'b1};\n     else if (except_started)\n       sr_reg <=  to_sr[`OR1200_SR_WIDTH-1:0];\n     else if (sr_we)\n       sr_reg <=  to_sr[`OR1200_SR_WIDTH-1:0];\n\n   // EPH part of Supervision register\n   always @(posedge clk or `OR1200_RST_EVENT rst)\n     // default value \n     if (rst == `OR1200_RST_VALUE) begin\n\tsr_reg_bit_eph <=  `OR1200_SR_EPH_DEF;\n\t// select async. value due to reset state\n\tsr_reg_bit_eph_select <=  1'b1;\t\n     end\n   // selected value (different from default) is written into FF after reset \n   // state\n     else if (sr_reg_bit_eph_select) begin\n\t// dynamic value can only be assigned to FF out of reset!\n\tsr_reg_bit_eph <=  boot_adr_sel_i;\n\tsr_reg_bit_eph_select <=  1'b0;\t// select FF value\n     end\n     else if (sr_we) begin\n\tsr_reg_bit_eph <=  to_sr[`OR1200_SR_EPH];\n     end\n\n   // select async. value of EPH bit after reset \n   assign\tsr_reg_bit_eph_muxed = (sr_reg_bit_eph_select) ? \n\t\t\t\t       boot_adr_sel_i : sr_reg_bit_eph;\n\n   // EPH part joined together with rest of Supervision register\n   always @(sr_reg or sr_reg_bit_eph_muxed)\n     sr = {sr_reg[`OR1200_SR_WIDTH-1:`OR1200_SR_WIDTH-2], sr_reg_bit_eph_muxed,\n\t   sr_reg[`OR1200_SR_WIDTH-4:0]};\n\n`ifdef verilator\n   // Function to access various sprs (for Verilator). Have to hide this from\n   // simulator, since functions with no inputs are not allowed in IEEE\n   // 1364-2001.\n\n   function [31:0] get_sr;\n      // verilator public\n      get_sr = {{32-`OR1200_SR_WIDTH{1'b0}},sr};\n   endfunction // get_sr\n\n   function [31:0] get_epcr;\n      // verilator public\n      get_epcr = epcr;\n   endfunction // get_epcr\n\n   function [31:0] get_eear;\n      // verilator public\n      get_eear = eear;\n   endfunction // get_eear\n\n   function [31:0] get_esr;\n      // verilator public\n      get_esr = {{32-`OR1200_SR_WIDTH{1'b0}},esr};\n   endfunction // get_esr\n\n`endif\n   \n   //\n   // MTSPR/MFSPR interface\n   //\n   always @(spr_addr or sys_data or spr_dat_mac or spr_dat_pic or spr_dat_pm or\n\t    spr_dat_fpu or\n\t    spr_dat_dmmu or spr_dat_immu or spr_dat_du or spr_dat_tt) begin\n      casez (spr_addr[`OR1200_SPR_GROUP_BITS]) // synopsys parallel_case\n\t`OR1200_SPR_GROUP_SYS:\n\t  to_wbmux = sys_data;\n\t`OR1200_SPR_GROUP_TT:\n\t  to_wbmux = spr_dat_tt;\n\t`OR1200_SPR_GROUP_PIC:\n\t  to_wbmux = spr_dat_pic;\n\t`OR1200_SPR_GROUP_PM:\n\t  to_wbmux = spr_dat_pm;\n\t`OR1200_SPR_GROUP_DMMU:\n\t  to_wbmux = spr_dat_dmmu;\n\t`OR1200_SPR_GROUP_IMMU:\n\t  to_wbmux = spr_dat_immu;\n\t`OR1200_SPR_GROUP_MAC:\n\t  to_wbmux = spr_dat_mac;\n\t`OR1200_SPR_GROUP_FPU:\n\t  to_wbmux = spr_dat_fpu;\n\tdefault: //`OR1200_SPR_GROUP_DU:\n\t  to_wbmux = spr_dat_du;\n      endcase\n   end\n\nendmodule\n"], "filenames": ["rtl/verilog/or1200_alu.v", "rtl/verilog/or1200_cpu.v", "rtl/verilog/or1200_defines.v", "rtl/verilog/or1200_except.v", "rtl/verilog/or1200_mult_mac.v", "rtl/verilog/or1200_sprs.v"], "buggy_code_start_loc": [58, 273, 302, 179, 67, 59], "buggy_code_end_loc": [318, 807, 831, 264, 400, 379], "fixing_code_start_loc": [59, 274, 302, 179, 68, 60], "fixing_code_end_loc": [344, 824, 848, 272, 451, 387], "type": "CWE-287", "message": "An issue was discovered in the ALU unit of the OR1200 (aka OpenRISC 1200) processor 2011-09-10 through 2015-11-11. The overflow flag is not being updated correctly for the subtract instruction, which results in an incorrect value in the overflow flag. Any software that relies on this flag may experience corruption in execution.", "other": {"cve": {"id": "CVE-2021-40507", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-18T12:15:07.307", "lastModified": "2023-04-27T15:41:19.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the ALU unit of the OR1200 (aka OpenRISC 1200) processor 2011-09-10 through 2015-11-11. The overflow flag is not being updated correctly for the subtract instruction, which results in an incorrect value in the overflow flag. Any software that relies on this flag may experience corruption in execution."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:openrisc:or1200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "2011-09-10", "versionEndIncluding": "2015-11-11", "matchCriteriaId": "A483ADB7-281E-4BFE-91A7-2F3FA5415A9E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:openrisc:or1200:-:*:*:*:*:*:*:*", "matchCriteriaId": "62C84E8E-52D8-43A5-9303-BAB92EBE2445"}]}]}], "references": [{"url": "https://github.com/openrisc/or1200/commit/2c0765d7ba12813df273cd693a99c4e744f0fbd5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://seth.engr.tamu.edu/software-releases/thehuzz/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openrisc/or1200/commit/2c0765d7ba12813df273cd693a99c4e744f0fbd5"}}