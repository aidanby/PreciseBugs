{"buggy_code": ["import { logger, SlpTransactionDetails, SlpTransactionType } from \"../index\";\nimport { Slp, SlpValidator } from \"./slp\";\n\nimport BigNumber from \"bignumber.js\";\nimport { BITBOX } from \"bitbox-sdk\";\nimport * as Bitcore from \"bitcore-lib-cash\";\n\nimport { Crypto } from \"./crypto\";\n\nexport interface Validation { validity: boolean|null; parents: Parent[]; details: SlpTransactionDetails|null; invalidReason: string|null; waiting: boolean; }\nexport type GetRawTransactionsAsync = (txid: string[]) => Promise<string[]>;\n\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\ninterface Parent {\n    txid: string;\n    vout: number;\n    versionType: number;\n    valid: boolean|null;\n    inputQty: BigNumber|null;\n}\n\nexport class LocalValidator implements SlpValidator {\n    public BITBOX: BITBOX;\n    public cachedRawTransactions: { [txid: string]: string };\n    public cachedValidations: { [txid: string]: Validation };\n    public getRawTransactions: GetRawTransactionsAsync;\n    public slp: Slp;\n    public logger: logger = { log: (s: string) => null };\n\n    constructor(BITBOX: BITBOX, getRawTransactions: GetRawTransactionsAsync, logger?: logger) {\n        if (!BITBOX) {\n            throw Error(\"Must provide BITBOX instance to class constructor.\");\n        }\n        if (!getRawTransactions) {\n            throw Error(\"Must provide method getRawTransactions to class constructor.\");\n        }\n        if (logger) {\n            this.logger = logger;\n        }\n        this.BITBOX = BITBOX;\n        this.getRawTransactions = getRawTransactions;\n        this.slp = new Slp(BITBOX);\n        this.cachedValidations = {};\n        this.cachedRawTransactions = {};\n    }\n\n    public addValidationFromStore(hex: string, isValid: boolean) {\n        const id = Crypto.txid(Buffer.from(hex, \"hex\")).toString(\"hex\");\n        if (!this.cachedValidations[id]) {\n            this.cachedValidations[id] = { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false };\n        }\n        if (!this.cachedRawTransactions[id]) {\n            this.cachedRawTransactions[id] = hex;\n        }\n    }\n\n    public async waitForCurrentValidationProcessing(txid: string) {\n        const cached: Validation = this.cachedValidations[txid];\n\n        while (true) {\n            if (typeof cached.validity === \"boolean\") {\n                cached.waiting = false;\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async waitForTransactionDownloadToComplete(txid: string){\n        while (true) {\n            if (this.cachedRawTransactions[txid] && this.cachedRawTransactions[txid] !== \"waiting\") {\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async retrieveRawTransaction(txid: string) {\n        const checkTxnRegex = (txn: string) => {\n            const re = /^([A-Fa-f0-9]{2}){61,}$/;\n            if (!re.test(txn)) {\n                throw Error(`Regex failed for retrieved transaction, got: ${txn}`);\n            }\n        };\n        if (!this.cachedRawTransactions[txid]) {\n            this.cachedRawTransactions[txid] = \"waiting\";\n            const txns = await this.getRawTransactions([txid]);\n            if (!txns || txns.length === 0 || typeof txns[0] !== \"string\") {\n                throw Error(`Response error in getRawTransactions, got: ${txns}`);\n            }\n            checkTxnRegex(txns[0]);\n            this.cachedRawTransactions[txid] = txns[0];\n            return txns[0];\n        } else {\n            checkTxnRegex(this.cachedRawTransactions[txid]);\n            return this.cachedRawTransactions[txid];\n        }\n    }\n\n    public async isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {\n        this.logger.log(\"SLPJS Validating: \" + txid);\n        const valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);\n        this.logger.log(\"SLPJS Result: \" + valid + \" (\" + txid + \")\");\n        if (!valid && this.cachedValidations[txid].invalidReason) {\n            this.logger.log(\"SLPJS Invalid Reason: \" + this.cachedValidations[txid].invalidReason);\n        } else if (!valid) {\n            this.logger.log(\"SLPJS Invalid Reason: unknown (result is user supplied)\");\n        }\n        return valid;\n    }\n\n    //\n    // This method uses recursion to do a Depth-First-Search with the node result being\n    // computed in Postorder Traversal (left/right/root) order.  A validation cache\n    // is used to keep track of the results for nodes that have already been evaluated.\n    //\n    // Each call to this method evaluates node validity with respect to\n    // its parent node(s), so it walks backwards until the\n    // validation cache provides a result or the GENESIS node is evaluated.\n    // Root nodes await the validation result of their upstream parent.\n    //\n    // In the case of NFT1 the search continues to the group/parent NFT DAG after the Genesis\n    // of the NFT child is discovered.\n    //\n    public async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {\n        // Check to see if this txn has been processed by looking at shared cache, if doesn't exist then download txn.\n        if (!this.cachedValidations[txid]) {\n            this.cachedValidations[txid] = {\n                validity: null,\n                parents: [],\n                details: null,\n                invalidReason: null,\n                waiting: false,\n            };\n            await this.retrieveRawTransaction(txid);\n        }\n        // Otherwise, we can use the cached result as long as a special filter isn't being applied.\n        else if (typeof this.cachedValidations[txid].validity === \"boolean\") {\n            return this.cachedValidations[txid].validity!;\n        }\n\n        //\n        // Handle the case where neither branch of the previous if/else statement was\n        // executed and the raw transaction has never been downloaded.\n        //\n        // Also handle case where a 2nd request of same txid comes in\n        // during the download of a previous request.\n        //\n        if (!this.cachedRawTransactions[txid] || this.cachedRawTransactions[txid] === \"waiting\") {\n            if (this.cachedRawTransactions[txid] !== \"waiting\") {\n                this.retrieveRawTransaction(txid);\n            }\n\n            // Wait for previously a initiated download to completed\n            await this.waitForTransactionDownloadToComplete(txid);\n        }\n\n        // Handle case where txid is already in the process of being validated from a previous call\n        if (this.cachedValidations[txid].waiting) {\n            await this.waitForCurrentValidationProcessing(txid);\n            if (typeof this.cachedValidations[txid].validity === \"boolean\") {\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        this.cachedValidations[txid].waiting = true;\n\n        // Check SLP message validity\n        const txn: Bitcore.Transaction = new Bitcore.Transaction(this.cachedRawTransactions[txid]);\n        let slpmsg: SlpTransactionDetails;\n        try {\n            slpmsg = this.cachedValidations[txid].details = this.slp.parseSlpOutputScript(txn.outputs[0]._scriptBuffer);\n            if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                slpmsg.tokenIdHex = txid;\n            }\n        } catch (e) {\n            this.cachedValidations[txid].validity = false;\n            this.cachedValidations[txid].waiting = false;\n            this.cachedValidations[txid].invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\";\n            return this.cachedValidations[txid].validity!;\n        }\n\n        // Check for tokenId filter\n        if (tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {\n            this.cachedValidations[txid].waiting = false;\n            this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.\n        } else {\n            if (this.cachedValidations[txid].validity !== false) {\n                this.cachedValidations[txid].invalidReason = null;\n            }\n        }\n\n        // Check specified token type is being respected\n        if (tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {\n            this.cachedValidations[txid].validity = null;\n            this.cachedValidations[txid].waiting = false;\n            this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used with different token type.\n        } else {\n            if (this.cachedValidations[txid].validity !== false) {\n                this.cachedValidations[txid].invalidReason = null;\n            }\n        }\n\n        // Check DAG validity\n        if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n            // Check for NFT1 child (type 0x41)\n            if (slpmsg.versionType === 0x41) {\n                // An NFT1 parent should be provided at input index 0,\n                // so we check this first before checking the whole parent DAG\n                let input_txid = txn.inputs[0].prevTxId.toString(\"hex\");\n                let input_txhex = await this.retrieveRawTransaction(input_txid);\n                let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);\n                let input_slpmsg;\n                try {\n                    input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);\n                } catch (_) { }\n                if (!input_slpmsg || input_slpmsg.versionType !== 0x81) {\n                    this.cachedValidations[txid].validity = false;\n                    this.cachedValidations[txid].waiting = false;\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";\n                    return this.cachedValidations[txid].validity!;\n                }\n                // Check that the there is a burned output >0 in the parent txn SLP message\n                if (input_slpmsg.transactionType === SlpTransactionType.SEND &&\n                    (!input_slpmsg.sendOutputs![1].isGreaterThan(0)))\n                {\n                    this.cachedValidations[txid].validity = false;\n                    this.cachedValidations[txid].waiting = false;\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return this.cachedValidations[txid].validity!;\n                } else if ((input_slpmsg.transactionType === SlpTransactionType.GENESIS ||\n                            input_slpmsg.transactionType === SlpTransactionType.MINT) &&\n                            !input_slpmsg.genesisOrMintQuantity!.isGreaterThan(0))\n                {\n                    this.cachedValidations[txid].validity = false;\n                    this.cachedValidations[txid].waiting = false;\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return this.cachedValidations[txid].validity!;\n                }\n                // Continue to check the NFT1 parent DAG\n                let nft_parent_dag_validity = await this.isValidSlpTxid(input_txid, undefined, 0x81);\n                this.cachedValidations[txid].validity = nft_parent_dag_validity;\n                this.cachedValidations[txid].waiting = false;\n                if (!nft_parent_dag_validity) {\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\";\n                }\n                return this.cachedValidations[txid].validity!;\n            }\n            // All other supported token types (includes 0x01 and 0x81)\n            // No need to check type here since op_return parser throws on other types.\n            else {\n                this.cachedValidations[txid].validity = true;\n                this.cachedValidations[txid].waiting = false;\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n        else if (slpmsg.transactionType === SlpTransactionType.MINT) {\n            for (let i = 0; i < txn.inputs.length; i++) {\n                let input_txid = txn.inputs[i].prevTxId.toString(\"hex\");\n                let input_txhex = await this.retrieveRawTransaction(input_txid);\n                let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);\n                try {\n                    let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);\n                    if (input_slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                        input_slpmsg.tokenIdHex = input_txid;\n                    }\n                    if (input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].outputIndex === input_slpmsg.batonVout) {\n                                this.cachedValidations[txid].parents.push({\n                                    txid: txn.inputs[i].prevTxId.toString(\"hex\"),\n                                    vout: txn.inputs[i].outputIndex!,\n                                    versionType: input_slpmsg.versionType,\n                                    valid: null,\n                                    inputQty: null,\n                                });\n                            }\n                        }\n                    }\n                } catch (_) {}\n            }\n            if (this.cachedValidations[txid].parents.length !== 1) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"MINT transaction must have 1 valid baton parent.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n        else if (slpmsg.transactionType === SlpTransactionType.SEND) {\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => { return t.plus(v); }, new BigNumber(0));\n            let tokenInQty = new BigNumber(0);\n            for (let i = 0; i < txn.inputs.length; i++) {\n                let input_txid = txn.inputs[i].prevTxId.toString(\"hex\");\n                let input_txhex = await this.retrieveRawTransaction(input_txid);\n                let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);\n                try {\n                    let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);\n                    if (input_slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                        input_slpmsg.tokenIdHex = input_txid;\n                    }\n                    if (input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (input_slpmsg.transactionType === SlpTransactionType.SEND) {\n                            if (txn.inputs[i].outputIndex! <= input_slpmsg.sendOutputs!.length - 1) {\n                                tokenInQty = tokenInQty.plus(input_slpmsg.sendOutputs![txn.inputs[i].outputIndex!]);\n                                this.cachedValidations[txid].parents.push({\n                                    txid: txn.inputs[i].prevTxId.toString(\"hex\"),\n                                    vout: txn.inputs[i].outputIndex!,\n                                    versionType: input_slpmsg.versionType,\n                                    valid: null,\n                                    inputQty: input_slpmsg.sendOutputs![txn.inputs[i].outputIndex!]\n                                });\n                            }\n                        }\n                        else if (input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].outputIndex === 1) {\n                                tokenInQty = tokenInQty.plus(input_slpmsg.genesisOrMintQuantity!);\n                                this.cachedValidations[txid].parents.push({\n                                    txid: txn.inputs[i].prevTxId.toString(\"hex\"),\n                                    vout: txn.inputs[i].outputIndex!,\n                                    versionType: input_slpmsg.versionType,\n                                    valid: null,\n                                    inputQty: input_slpmsg.genesisOrMintQuantity\n                                });\n                            }\n                        }\n                    }\n                } catch (_) {}\n            }\n\n            // Check token inputs are greater than token outputs (includes valid and invalid inputs)\n            if (tokenOutQty.isGreaterThan(tokenInQty)) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"Token outputs are greater than possible token inputs.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        // Set validity validation-cache for parents, and handle MINT condition with no valid input\n        // we don't need to check proper token id since we only added parents with same ID in above steps.\n        const parentTxids = [...new Set(this.cachedValidations[txid].parents.map(p => p.txid))];\n        for (let i = 0; i < parentTxids.length; i++) {\n            const valid = await this.isValidSlpTxid(parentTxids[i]);\n            this.cachedValidations[txid].parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);\n            if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.MINT && !valid) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"MINT transaction with invalid baton parent.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        // Check valid inputs are greater than token outputs\n        if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.SEND) {\n            const validInputQty = this.cachedValidations[txid].parents.reduce((t, v) => { return v.valid ? t.plus(v.inputQty!) : t; }, new BigNumber(0));\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => { return t.plus(v); }, new BigNumber(0));\n            if (tokenOutQty.isGreaterThan(validInputQty)) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"Token outputs are greater than valid token inputs.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        // Check versionType is not different from valid parents\n        if (this.cachedValidations[txid].parents.filter(p => p.valid).length > 0) {\n            const validVersionType = this.cachedValidations[txid].parents.find(p => p.valid!)!.versionType;\n            if (this.cachedValidations[txid].details!.versionType !== validVersionType) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"SLP version/type mismatch from valid parent.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n        this.cachedValidations[txid].validity = true;\n        this.cachedValidations[txid].waiting = false;\n        return this.cachedValidations[txid].validity!;\n    }\n\n    public async validateSlpTransactions(txids: string[]): Promise<string[]> {\n        const res = [];\n        for (let i = 0; i < txids.length; i++) {\n            res.push((await this.isValidSlpTxid(txids[i])) ? txids[i] : \"\");\n        }\n        return res.filter((id: string) => id.length > 0);\n    }\n}"], "fixing_code": ["import { logger, SlpTransactionDetails, SlpTransactionType } from \"../index\";\nimport { Slp, SlpValidator } from \"./slp\";\n\nimport BigNumber from \"bignumber.js\";\nimport { BITBOX } from \"bitbox-sdk\";\nimport * as Bitcore from \"bitcore-lib-cash\";\n\nimport { Crypto } from \"./crypto\";\n\nexport interface Validation { validity: boolean|null; parents: Parent[]; details: SlpTransactionDetails|null; invalidReason: string|null; waiting: boolean; }\nexport type GetRawTransactionsAsync = (txid: string[]) => Promise<string[]>;\n\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\ninterface Parent {\n    txid: string;\n    vout: number;\n    versionType: number;\n    valid: boolean|null;\n    inputQty: BigNumber|null;\n}\n\nexport class LocalValidator implements SlpValidator {\n    public BITBOX: BITBOX;\n    public cachedRawTransactions: { [txid: string]: string };\n    public cachedValidations: { [txid: string]: Validation };\n    public getRawTransactions: GetRawTransactionsAsync;\n    public slp: Slp;\n    public logger: logger = { log: (s: string) => null };\n\n    constructor(BITBOX: BITBOX, getRawTransactions: GetRawTransactionsAsync, logger?: logger) {\n        if (!BITBOX) {\n            throw Error(\"Must provide BITBOX instance to class constructor.\");\n        }\n        if (!getRawTransactions) {\n            throw Error(\"Must provide method getRawTransactions to class constructor.\");\n        }\n        if (logger) {\n            this.logger = logger;\n        }\n        this.BITBOX = BITBOX;\n        this.getRawTransactions = getRawTransactions;\n        this.slp = new Slp(BITBOX);\n        this.cachedValidations = {};\n        this.cachedRawTransactions = {};\n    }\n\n    public addValidationFromStore(hex: string, isValid: boolean) {\n        const id = Crypto.txid(Buffer.from(hex, \"hex\")).toString(\"hex\");\n        if (!this.cachedValidations[id]) {\n            this.cachedValidations[id] = { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false };\n        }\n        if (!this.cachedRawTransactions[id]) {\n            this.cachedRawTransactions[id] = hex;\n        }\n    }\n\n    public async waitForCurrentValidationProcessing(txid: string) {\n        const cached: Validation = this.cachedValidations[txid];\n\n        while (true) {\n            if (typeof cached.validity === \"boolean\") {\n                cached.waiting = false;\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async waitForTransactionDownloadToComplete(txid: string){\n        while (true) {\n            if (this.cachedRawTransactions[txid] && this.cachedRawTransactions[txid] !== \"waiting\") {\n                break;\n            }\n            await sleep(10);\n        }\n    }\n\n    public async retrieveRawTransaction(txid: string) {\n        const checkTxnRegex = (txn: string) => {\n            const re = /^([A-Fa-f0-9]{2}){61,}$/;\n            if (!re.test(txn)) {\n                throw Error(`Regex failed for retrieved transaction, got: ${txn}`);\n            }\n        };\n        if (!this.cachedRawTransactions[txid]) {\n            this.cachedRawTransactions[txid] = \"waiting\";\n            const txns = await this.getRawTransactions([txid]);\n            if (!txns || txns.length === 0 || typeof txns[0] !== \"string\") {\n                throw Error(`Response error in getRawTransactions, got: ${txns}`);\n            }\n            checkTxnRegex(txns[0]);\n            this.cachedRawTransactions[txid] = txns[0];\n            return txns[0];\n        } else {\n            checkTxnRegex(this.cachedRawTransactions[txid]);\n            return this.cachedRawTransactions[txid];\n        }\n    }\n\n    public async isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {\n        this.logger.log(\"SLPJS Validating: \" + txid);\n        const valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);\n        this.logger.log(\"SLPJS Result: \" + valid + \" (\" + txid + \")\");\n        if (!valid && this.cachedValidations[txid].invalidReason) {\n            this.logger.log(\"SLPJS Invalid Reason: \" + this.cachedValidations[txid].invalidReason);\n        } else if (!valid) {\n            this.logger.log(\"SLPJS Invalid Reason: unknown (result is user supplied)\");\n        }\n        return valid;\n    }\n\n    //\n    // This method uses recursion to do a Depth-First-Search with the node result being\n    // computed in Postorder Traversal (left/right/root) order.  A validation cache\n    // is used to keep track of the results for nodes that have already been evaluated.\n    //\n    // Each call to this method evaluates node validity with respect to\n    // its parent node(s), so it walks backwards until the\n    // validation cache provides a result or the GENESIS node is evaluated.\n    // Root nodes await the validation result of their upstream parent.\n    //\n    // In the case of NFT1 the search continues to the group/parent NFT DAG after the Genesis\n    // of the NFT child is discovered.\n    //\n    public async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {\n        // Check to see if this txn has been processed by looking at shared cache, if doesn't exist then download txn.\n        if (!this.cachedValidations[txid]) {\n            this.cachedValidations[txid] = {\n                validity: null,\n                parents: [],\n                details: null,\n                invalidReason: null,\n                waiting: false,\n            };\n            await this.retrieveRawTransaction(txid);\n        }\n        // Otherwise, we can use the cached result as long as a special filter isn't being applied.\n        else if (typeof this.cachedValidations[txid].validity === \"boolean\") {\n            return this.cachedValidations[txid].validity!;\n        }\n\n        //\n        // Handle the case where neither branch of the previous if/else statement was\n        // executed and the raw transaction has never been downloaded.\n        //\n        // Also handle case where a 2nd request of same txid comes in\n        // during the download of a previous request.\n        //\n        if (!this.cachedRawTransactions[txid] || this.cachedRawTransactions[txid] === \"waiting\") {\n            if (this.cachedRawTransactions[txid] !== \"waiting\") {\n                this.retrieveRawTransaction(txid);\n            }\n\n            // Wait for previously a initiated download to completed\n            await this.waitForTransactionDownloadToComplete(txid);\n        }\n\n        // Handle case where txid is already in the process of being validated from a previous call\n        if (this.cachedValidations[txid].waiting) {\n            await this.waitForCurrentValidationProcessing(txid);\n            if (typeof this.cachedValidations[txid].validity === \"boolean\") {\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        this.cachedValidations[txid].waiting = true;\n\n        // Check SLP message validity\n        const txn: Bitcore.Transaction = new Bitcore.Transaction(this.cachedRawTransactions[txid]);\n        let slpmsg: SlpTransactionDetails;\n        try {\n            slpmsg = this.cachedValidations[txid].details = this.slp.parseSlpOutputScript(txn.outputs[0]._scriptBuffer);\n            if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                slpmsg.tokenIdHex = txid;\n            }\n        } catch (e) {\n            this.cachedValidations[txid].validity = false;\n            this.cachedValidations[txid].waiting = false;\n            this.cachedValidations[txid].invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\";\n            return this.cachedValidations[txid].validity!;\n        }\n\n        // Check for tokenId filter\n        if (tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {\n            this.cachedValidations[txid].waiting = false;\n            this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.\n        } else {\n            if (this.cachedValidations[txid].validity !== false) {\n                this.cachedValidations[txid].invalidReason = null;\n            }\n        }\n\n        // Check specified token type is being respected\n        if (tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {\n            this.cachedValidations[txid].validity = null;\n            this.cachedValidations[txid].waiting = false;\n            this.cachedValidations[txid].invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";\n            return false; // Don't save boolean result to cache incase cache is ever used with different token type.\n        } else {\n            if (this.cachedValidations[txid].validity !== false) {\n                this.cachedValidations[txid].invalidReason = null;\n            }\n        }\n\n        // Check DAG validity\n        if (slpmsg.transactionType === SlpTransactionType.GENESIS) {\n            // Check for NFT1 child (type 0x41)\n            if (slpmsg.versionType === 0x41) {\n                // An NFT1 parent should be provided at input index 0,\n                // so we check this first before checking the whole parent DAG\n                let input_txid = txn.inputs[0].prevTxId.toString(\"hex\");\n                let input_txhex = await this.retrieveRawTransaction(input_txid);\n                let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);\n                let input_slpmsg;\n                try {\n                    input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);\n                } catch (_) { }\n                if (!input_slpmsg || input_slpmsg.versionType !== 0x81) {\n                    this.cachedValidations[txid].validity = false;\n                    this.cachedValidations[txid].waiting = false;\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";\n                    return this.cachedValidations[txid].validity!;\n                }\n                // Check that the there is a burned output >0 in the parent txn SLP message\n                if (input_slpmsg.transactionType === SlpTransactionType.SEND &&\n                    (!input_slpmsg.sendOutputs![1].isGreaterThan(0)))\n                {\n                    this.cachedValidations[txid].validity = false;\n                    this.cachedValidations[txid].waiting = false;\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return this.cachedValidations[txid].validity!;\n                } else if ((input_slpmsg.transactionType === SlpTransactionType.GENESIS ||\n                            input_slpmsg.transactionType === SlpTransactionType.MINT) &&\n                            !input_slpmsg.genesisOrMintQuantity!.isGreaterThan(0))\n                {\n                    this.cachedValidations[txid].validity = false;\n                    this.cachedValidations[txid].waiting = false;\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";\n                    return this.cachedValidations[txid].validity!;\n                }\n                // Continue to check the NFT1 parent DAG\n                let nft_parent_dag_validity = await this.isValidSlpTxid(input_txid, undefined, 0x81);\n                this.cachedValidations[txid].validity = nft_parent_dag_validity;\n                this.cachedValidations[txid].waiting = false;\n                if (!nft_parent_dag_validity) {\n                    this.cachedValidations[txid].invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\";\n                }\n                return this.cachedValidations[txid].validity!;\n            }\n            // All other supported token types (includes 0x01 and 0x81)\n            // No need to check type here since op_return parser throws on other types.\n            else {\n                this.cachedValidations[txid].validity = true;\n                this.cachedValidations[txid].waiting = false;\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n        else if (slpmsg.transactionType === SlpTransactionType.MINT) {\n            for (let i = 0; i < txn.inputs.length; i++) {\n                let input_txid = txn.inputs[i].prevTxId.toString(\"hex\");\n                let input_txhex = await this.retrieveRawTransaction(input_txid);\n                let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);\n                try {\n                    let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);\n                    if (input_slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                        input_slpmsg.tokenIdHex = input_txid;\n                    }\n                    if (input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].outputIndex === input_slpmsg.batonVout) {\n                                this.cachedValidations[txid].parents.push({\n                                    txid: txn.inputs[i].prevTxId.toString(\"hex\"),\n                                    vout: txn.inputs[i].outputIndex!,\n                                    versionType: input_slpmsg.versionType,\n                                    valid: null,\n                                    inputQty: null,\n                                });\n                            }\n                        }\n                    }\n                } catch (_) {}\n            }\n            if (this.cachedValidations[txid].parents.length < 1) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"MINT transaction must have at least 1 candidate baton parent input.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n        else if (slpmsg.transactionType === SlpTransactionType.SEND) {\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => { return t.plus(v); }, new BigNumber(0));\n            let tokenInQty = new BigNumber(0);\n            for (let i = 0; i < txn.inputs.length; i++) {\n                let input_txid = txn.inputs[i].prevTxId.toString(\"hex\");\n                let input_txhex = await this.retrieveRawTransaction(input_txid);\n                let input_tx: Bitcore.Transaction = new Bitcore.Transaction(input_txhex);\n                try {\n                    let input_slpmsg = this.slp.parseSlpOutputScript(input_tx.outputs[0]._scriptBuffer);\n                    if (input_slpmsg.transactionType === SlpTransactionType.GENESIS) {\n                        input_slpmsg.tokenIdHex = input_txid;\n                    }\n                    if (input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {\n                        if (input_slpmsg.transactionType === SlpTransactionType.SEND) {\n                            if (txn.inputs[i].outputIndex! <= input_slpmsg.sendOutputs!.length - 1) {\n                                tokenInQty = tokenInQty.plus(input_slpmsg.sendOutputs![txn.inputs[i].outputIndex!]);\n                                this.cachedValidations[txid].parents.push({\n                                    txid: txn.inputs[i].prevTxId.toString(\"hex\"),\n                                    vout: txn.inputs[i].outputIndex!,\n                                    versionType: input_slpmsg.versionType,\n                                    valid: null,\n                                    inputQty: input_slpmsg.sendOutputs![txn.inputs[i].outputIndex!]\n                                });\n                            }\n                        }\n                        else if (input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {\n                            if (txn.inputs[i].outputIndex === 1) {\n                                tokenInQty = tokenInQty.plus(input_slpmsg.genesisOrMintQuantity!);\n                                this.cachedValidations[txid].parents.push({\n                                    txid: txn.inputs[i].prevTxId.toString(\"hex\"),\n                                    vout: txn.inputs[i].outputIndex!,\n                                    versionType: input_slpmsg.versionType,\n                                    valid: null,\n                                    inputQty: input_slpmsg.genesisOrMintQuantity\n                                });\n                            }\n                        }\n                    }\n                } catch (_) {}\n            }\n\n            // Check token inputs are greater than token outputs (includes valid and invalid inputs)\n            if (tokenOutQty.isGreaterThan(tokenInQty)) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"Token outputs are greater than possible token inputs.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        // Set validity validation-cache for parents, and handle MINT condition with no valid input\n        // we don't need to check proper token id since we only added parents with same ID in above steps.\n        const parentTxids = [...new Set(this.cachedValidations[txid].parents.map(p => p.txid))];\n        for (const id of parentTxids) {\n            const valid = await this.isValidSlpTxid(id);\n            this.cachedValidations[txid].parents.filter(p => p.txid === id).map(p => p.valid = valid);\n        }\n\n        // Check MINT for exactly 1 valid MINT baton\n        if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.MINT) {\n            if (this.cachedValidations[txid].parents.filter(p => p.valid && p.inputQty === null).length !== 1) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"MINT transaction with invalid baton parent.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        // Check valid inputs are greater than token outputs\n        if (this.cachedValidations[txid].details!.transactionType === SlpTransactionType.SEND) {\n            const validInputQty = this.cachedValidations[txid].parents.reduce((t, v) => { return v.valid ? t.plus(v.inputQty!) : t; }, new BigNumber(0));\n            const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => { return t.plus(v); }, new BigNumber(0));\n            if (tokenOutQty.isGreaterThan(validInputQty)) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"Token outputs are greater than valid token inputs.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n\n        // Check versionType is not different from valid parents\n        if (this.cachedValidations[txid].parents.filter(p => p.valid).length > 0) {\n            const validVersionType = this.cachedValidations[txid].parents.find(p => p.valid!)!.versionType;\n            if (this.cachedValidations[txid].details!.versionType !== validVersionType) {\n                this.cachedValidations[txid].validity = false;\n                this.cachedValidations[txid].waiting = false;\n                this.cachedValidations[txid].invalidReason = \"SLP version/type mismatch from valid parent.\";\n                return this.cachedValidations[txid].validity!;\n            }\n        }\n        this.cachedValidations[txid].validity = true;\n        this.cachedValidations[txid].waiting = false;\n        return this.cachedValidations[txid].validity!;\n    }\n\n    public async validateSlpTransactions(txids: string[]): Promise<string[]> {\n        const res = [];\n        for (let i = 0; i < txids.length; i++) {\n            res.push((await this.isValidSlpTxid(txids[i])) ? txids[i] : \"\");\n        }\n        return res.filter((id: string) => id.length > 0);\n    }\n}"], "filenames": ["lib/localvalidator.ts"], "buggy_code_start_loc": [285], "buggy_code_end_loc": [349], "fixing_code_start_loc": [285], "fixing_code_end_loc": [353], "type": "CWE-697", "message": "SLPJS (npm package slpjs) before version 0.27.2, has a vulnerability where users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This is fixed in version 0.27.2.", "other": {"cve": {"id": "CVE-2020-11071", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-12T01:15:11.150", "lastModified": "2020-05-19T16:18:03.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SLPJS (npm package slpjs) before version 0.27.2, has a vulnerability where users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This is fixed in version 0.27.2."}, {"lang": "es", "value": "SLPJS (paquete slpjs de npm) versiones anteriores a 0.27.2, presenta una vulnerabilidad donde los usuarios podr\u00edan experimentar resultados de comprobaci\u00f3n falsos negativos para las operaciones de transacci\u00f3n MINT. Una billetera SLP mal implementada podr\u00eda permitir el gasto de los tokens afectados, lo que resultar\u00eda en la destrucci\u00f3n minting baton del usuario. Esto es corrigido en la versi\u00f3n 0.27.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-697"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-697"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simpleledger:slpjs:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.27.2", "matchCriteriaId": "035AB245-62DC-434B-A63F-D1AC45D95DFC"}]}]}], "references": [{"url": "https://github.com/simpleledger/slpjs/commit/3671be2ffb6d4cfa94c00c6dc8649d1ba1d75754", "source": "security-advisories@github.com", "tags": ["Patch", "Tool Signature"]}, {"url": "https://github.com/simpleledger/slpjs/security/advisories/GHSA-jc83-cpf9-q7c6", "source": "security-advisories@github.com", "tags": ["Tool Signature"]}]}, "github_commit_url": "https://github.com/simpleledger/slpjs/commit/3671be2ffb6d4cfa94c00c6dc8649d1ba1d75754"}}