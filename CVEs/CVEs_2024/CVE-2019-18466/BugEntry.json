{"buggy_code": ["package main\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/containers/buildah/pkg/chrootuser\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/libpod/cmd/podman/cliconfig\"\n\t\"github.com/containers/libpod/cmd/podman/libpodruntime\"\n\t\"github.com/containers/libpod/libpod\"\n\t\"github.com/containers/libpod/libpod/define\"\n\t\"github.com/containers/libpod/pkg/rootless\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/archive\"\n\t\"github.com/containers/storage/pkg/chrootarchive\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar (\n\tcpCommand cliconfig.CpValues\n\n\tcpDescription = `Command copies the contents of SRC_PATH to the DEST_PATH.\n\n  You can copy from the container's file system to the local machine or the reverse, from the local filesystem to the container. If \"-\" is specified for either the SRC_PATH or DEST_PATH, you can also stream a tar archive from STDIN or to STDOUT. The CONTAINER can be a running or stopped container.  The SRC_PATH or DEST_PATH can be a file or directory.\n`\n\t_cpCommand = &cobra.Command{\n\t\tUse:   \"cp [flags] SRC_PATH DEST_PATH\",\n\t\tShort: \"Copy files/folders between a container and the local filesystem\",\n\t\tLong:  cpDescription,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tcpCommand.InputArgs = args\n\t\t\tcpCommand.GlobalFlags = MainGlobalOpts\n\t\t\tcpCommand.Remote = remoteclient\n\t\t\treturn cpCmd(&cpCommand)\n\t\t},\n\t\tExample: \"[CONTAINER:]SRC_PATH [CONTAINER:]DEST_PATH\",\n\t}\n)\n\nfunc init() {\n\tcpCommand.Command = _cpCommand\n\tflags := cpCommand.Flags()\n\tflags.BoolVar(&cpCommand.Extract, \"extract\", false, \"Extract the tar file into the destination directory.\")\n\tflags.BoolVar(&cpCommand.Pause, \"pause\", false, \"Pause the container while copying\")\n\tcpCommand.SetHelpTemplate(HelpTemplate())\n\tcpCommand.SetUsageTemplate(UsageTemplate())\n}\n\nfunc cpCmd(c *cliconfig.CpValues) error {\n\targs := c.InputArgs\n\tif len(args) != 2 {\n\t\treturn errors.Errorf(\"you must provide a source path and a destination path\")\n\t}\n\n\truntime, err := libpodruntime.GetRuntime(getContext(), &c.PodmanCommand)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"could not get runtime\")\n\t}\n\tdefer runtime.DeferredShutdown(false)\n\n\treturn copyBetweenHostAndContainer(runtime, args[0], args[1], c.Extract, c.Pause)\n}\n\nfunc copyBetweenHostAndContainer(runtime *libpod.Runtime, src string, dest string, extract bool, pause bool) error {\n\n\tsrcCtr, srcPath := parsePath(runtime, src)\n\tdestCtr, destPath := parsePath(runtime, dest)\n\n\tif (srcCtr == nil && destCtr == nil) || (srcCtr != nil && destCtr != nil) {\n\t\treturn errors.Errorf(\"invalid arguments %s, %s you must use just one container\", src, dest)\n\t}\n\n\tif len(srcPath) == 0 || len(destPath) == 0 {\n\t\treturn errors.Errorf(\"invalid arguments %s, %s you must specify paths\", src, dest)\n\t}\n\tctr := srcCtr\n\tisFromHostToCtr := ctr == nil\n\tif isFromHostToCtr {\n\t\tctr = destCtr\n\t}\n\n\tmountPoint, err := ctr.Mount()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err := ctr.Unmount(false); err != nil {\n\t\t\tlogrus.Errorf(\"unable to umount container '%s': %q\", ctr.ID(), err)\n\t\t}\n\t}()\n\n\t// We can't pause rootless containers.\n\tif pause && rootless.IsRootless() {\n\t\tstate, err := ctr.State()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif state == define.ContainerStateRunning {\n\t\t\treturn errors.Errorf(\"cannot copy into running rootless container with pause set - pass --pause=false to force copying\")\n\t\t}\n\t}\n\n\tif pause && !rootless.IsRootless() {\n\t\tif err := ctr.Pause(); err != nil {\n\t\t\t// An invalid state error is fine.\n\t\t\t// The container isn't running or is already paused.\n\t\t\t// TODO: We can potentially start the container while\n\t\t\t// the copy is running, which still allows a race where\n\t\t\t// malicious code could mess with the symlink.\n\t\t\tif errors.Cause(err) != define.ErrCtrStateInvalid {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\t// Only add the defer if we actually paused\n\t\t\tdefer func() {\n\t\t\t\tif err := ctr.Unpause(); err != nil {\n\t\t\t\t\tlogrus.Errorf(\"Error unpausing container after copying: %v\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t}\n\n\tuser, err := getUser(mountPoint, ctr.User())\n\tif err != nil {\n\t\treturn err\n\t}\n\tidMappingOpts, err := ctr.IDMappings()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error getting IDMappingOptions\")\n\t}\n\tdestOwner := idtools.IDPair{UID: int(user.UID), GID: int(user.GID)}\n\thostUID, hostGID, err := util.GetHostIDs(convertIDMap(idMappingOpts.UIDMap), convertIDMap(idMappingOpts.GIDMap), user.UID, user.GID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thostOwner := idtools.IDPair{UID: int(hostUID), GID: int(hostGID)}\n\n\tvar glob []string\n\tif isFromHostToCtr {\n\t\tif isVol, volDestName, volName := isVolumeDestName(destPath, ctr); isVol {\n\t\t\tpath, err := pathWithVolumeMount(ctr, runtime, volDestName, volName, destPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting destination path from volume %s\", volDestName)\n\t\t\t}\n\t\t\tdestPath = path\n\t\t} else if isBindMount, mount := isBindMountDestName(destPath, ctr); isBindMount {\n\t\t\tpath, err := pathWithBindMountSource(mount, destPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting destination path from bind mount %s\", mount.Destination)\n\t\t\t}\n\t\t\tdestPath = path\n\t\t} else if filepath.IsAbs(destPath) {\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, destPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdestPath = cleanedPath\n\t\t} else {\n\t\t\tctrWorkDir, err := securejoin.SecureJoin(mountPoint, ctr.WorkingDir())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err = idtools.MkdirAllAndChownNew(ctrWorkDir, 0755, hostOwner); err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error creating directory %q\", destPath)\n\t\t\t}\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, filepath.Join(ctr.WorkingDir(), destPath))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdestPath = cleanedPath\n\t\t}\n\t} else {\n\t\tdestOwner = idtools.IDPair{UID: os.Getuid(), GID: os.Getgid()}\n\t\tif isVol, volDestName, volName := isVolumeDestName(srcPath, ctr); isVol {\n\t\t\tpath, err := pathWithVolumeMount(ctr, runtime, volDestName, volName, srcPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting source path from volume %s\", volDestName)\n\t\t\t}\n\t\t\tsrcPath = path\n\t\t} else if isBindMount, mount := isBindMountDestName(srcPath, ctr); isBindMount {\n\t\t\tpath, err := pathWithBindMountSource(mount, srcPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting source path from bind moutn %s\", mount.Destination)\n\t\t\t}\n\t\t\tsrcPath = path\n\t\t} else if filepath.IsAbs(srcPath) {\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, srcPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsrcPath = cleanedPath\n\t\t} else {\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, filepath.Join(ctr.WorkingDir(), srcPath))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsrcPath = cleanedPath\n\t\t}\n\t}\n\tglob, err = filepath.Glob(srcPath)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"invalid glob %q\", srcPath)\n\t}\n\tif len(glob) == 0 {\n\t\tglob = append(glob, srcPath)\n\t}\n\tif !filepath.IsAbs(destPath) {\n\t\tdir, err := os.Getwd()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"err getting current working directory\")\n\t\t}\n\t\tdestPath = filepath.Join(dir, destPath)\n\t}\n\n\tvar lastError error\n\tfor _, src := range glob {\n\t\tif src == \"-\" {\n\t\t\tsrc = os.Stdin.Name()\n\t\t\textract = true\n\t\t}\n\t\terr := copy(src, destPath, dest, idMappingOpts, &destOwner, extract, isFromHostToCtr)\n\t\tif lastError != nil {\n\t\t\tlogrus.Error(lastError)\n\t\t}\n\t\tlastError = err\n\t}\n\treturn lastError\n}\n\nfunc getUser(mountPoint string, userspec string) (specs.User, error) {\n\tuid, gid, _, err := chrootuser.GetUser(mountPoint, userspec)\n\tu := specs.User{\n\t\tUID:      uid,\n\t\tGID:      gid,\n\t\tUsername: userspec,\n\t}\n\tif !strings.Contains(userspec, \":\") {\n\t\tgroups, err2 := chrootuser.GetAdditionalGroupsForUser(mountPoint, uint64(u.UID))\n\t\tif err2 != nil {\n\t\t\tif errors.Cause(err2) != chrootuser.ErrNoSuchUser && err == nil {\n\t\t\t\terr = err2\n\t\t\t}\n\t\t} else {\n\t\t\tu.AdditionalGids = groups\n\t\t}\n\n\t}\n\treturn u, err\n}\n\nfunc parsePath(runtime *libpod.Runtime, path string) (*libpod.Container, string) {\n\tpathArr := strings.SplitN(path, \":\", 2)\n\tif len(pathArr) == 2 {\n\t\tctr, err := runtime.LookupContainer(pathArr[0])\n\t\tif err == nil {\n\t\t\treturn ctr, pathArr[1]\n\t\t}\n\t}\n\treturn nil, path\n}\n\nfunc getPathInfo(path string) (string, os.FileInfo, error) {\n\tpath, err := filepath.EvalSymlinks(path)\n\tif err != nil {\n\t\treturn \"\", nil, errors.Wrapf(err, \"error evaluating symlinks %q\", path)\n\t}\n\tsrcfi, err := os.Stat(path)\n\tif err != nil {\n\t\treturn \"\", nil, errors.Wrapf(err, \"error reading path %q\", path)\n\t}\n\treturn path, srcfi, nil\n}\n\nfunc copy(src, destPath, dest string, idMappingOpts storage.IDMappingOptions, chownOpts *idtools.IDPair, extract, isFromHostToCtr bool) error {\n\tsrcPath, err := filepath.EvalSymlinks(src)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error evaluating symlinks %q\", srcPath)\n\t}\n\n\tsrcPath, srcfi, err := getPathInfo(srcPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfilename := filepath.Base(destPath)\n\tif filename == \"-\" && !isFromHostToCtr {\n\t\terr := streamFileToStdout(srcPath, srcfi)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error streaming source file %s to Stdout\", srcPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\tdestdir := destPath\n\tif !srcfi.IsDir() && !strings.HasSuffix(dest, string(os.PathSeparator)) {\n\t\tdestdir = filepath.Dir(destPath)\n\t}\n\t_, err = os.Stat(destdir)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn errors.Wrapf(err, \"error checking directory %q\", destdir)\n\t}\n\tdestDirIsExist := err == nil\n\tif err = os.MkdirAll(destdir, 0755); err != nil {\n\t\treturn errors.Wrapf(err, \"error creating directory %q\", destdir)\n\t}\n\n\t// return functions for copying items\n\tcopyFileWithTar := chrootarchive.CopyFileWithTarAndChown(chownOpts, digest.Canonical.Digester().Hash(), idMappingOpts.UIDMap, idMappingOpts.GIDMap)\n\tcopyWithTar := chrootarchive.CopyWithTarAndChown(chownOpts, digest.Canonical.Digester().Hash(), idMappingOpts.UIDMap, idMappingOpts.GIDMap)\n\tuntarPath := chrootarchive.UntarPathAndChown(chownOpts, digest.Canonical.Digester().Hash(), idMappingOpts.UIDMap, idMappingOpts.GIDMap)\n\n\tif srcfi.IsDir() {\n\t\tlogrus.Debugf(\"copying %q to %q\", srcPath+string(os.PathSeparator)+\"*\", dest+string(os.PathSeparator)+\"*\")\n\t\tif destDirIsExist && !strings.HasSuffix(src, fmt.Sprintf(\"%s.\", string(os.PathSeparator))) {\n\t\t\tdestPath = filepath.Join(destPath, filepath.Base(srcPath))\n\t\t}\n\t\tif err = copyWithTar(srcPath, destPath); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error copying %q to %q\", srcPath, dest)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif extract {\n\t\t// We're extracting an archive into the destination directory.\n\t\tlogrus.Debugf(\"extracting contents of %q into %q\", srcPath, destPath)\n\t\tif err = untarPath(srcPath, destPath); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error extracting %q into %q\", srcPath, destPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\tdestfi, err := os.Stat(destPath)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn errors.Wrapf(err, \"failed to get stat of dest path %s\", destPath)\n\t\t}\n\t}\n\tif destfi != nil && destfi.IsDir() {\n\t\tdestPath = filepath.Join(destPath, filepath.Base(srcPath))\n\t}\n\n\t// Copy the file, preserving attributes.\n\tlogrus.Debugf(\"copying %q to %q\", srcPath, destPath)\n\tif err = copyFileWithTar(srcPath, destPath); err != nil {\n\t\treturn errors.Wrapf(err, \"error copying %q to %q\", srcPath, destPath)\n\t}\n\treturn nil\n}\n\nfunc convertIDMap(idMaps []idtools.IDMap) (convertedIDMap []specs.LinuxIDMapping) {\n\tfor _, idmap := range idMaps {\n\t\ttempIDMap := specs.LinuxIDMapping{\n\t\t\tContainerID: uint32(idmap.ContainerID),\n\t\t\tHostID:      uint32(idmap.HostID),\n\t\t\tSize:        uint32(idmap.Size),\n\t\t}\n\t\tconvertedIDMap = append(convertedIDMap, tempIDMap)\n\t}\n\treturn convertedIDMap\n}\n\nfunc streamFileToStdout(srcPath string, srcfi os.FileInfo) error {\n\tif srcfi.IsDir() {\n\t\ttw := tar.NewWriter(os.Stdout)\n\t\terr := filepath.Walk(srcPath, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil || !info.Mode().IsRegular() || path == srcPath {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thdr, err := tar.FileInfoHeader(info, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = tw.WriteHeader(hdr); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfh, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer fh.Close()\n\n\t\t\t_, err = io.Copy(tw, fh)\n\t\t\treturn err\n\t\t})\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error streaming directory %s to Stdout\", srcPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\tfile, err := os.Open(srcPath)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error opening file %s\", srcPath)\n\t}\n\tdefer file.Close()\n\tif !archive.IsArchivePath(srcPath) {\n\t\ttw := tar.NewWriter(os.Stdout)\n\t\thdr, err := tar.FileInfoHeader(srcfi, \"\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = tw.WriteHeader(hdr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = io.Copy(tw, file)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error streaming archive %s to Stdout\", srcPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\t_, err = io.Copy(os.Stdout, file)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error streaming file to Stdout\")\n\t}\n\treturn nil\n}\n\nfunc isVolumeDestName(path string, ctr *libpod.Container) (bool, string, string) {\n\tseparator := string(os.PathSeparator)\n\tif filepath.IsAbs(path) {\n\t\tpath = strings.TrimPrefix(path, separator)\n\t}\n\tif path == \"\" {\n\t\treturn false, \"\", \"\"\n\t}\n\tfor _, vol := range ctr.Config().NamedVolumes {\n\t\tvolNamePath := strings.TrimPrefix(vol.Dest, separator)\n\t\tif matchVolumePath(path, volNamePath) {\n\t\t\treturn true, vol.Dest, vol.Name\n\t\t}\n\t}\n\treturn false, \"\", \"\"\n}\n\n// if SRCPATH or DESTPATH is from volume mount's destination -v or --mount type=volume, generates the path with volume mount point\nfunc pathWithVolumeMount(ctr *libpod.Container, runtime *libpod.Runtime, volDestName, volName, path string) (string, error) {\n\tdestVolume, err := runtime.GetVolume(volName)\n\tif err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"error getting volume destination %s\", volName)\n\t}\n\tif !filepath.IsAbs(path) {\n\t\tpath = filepath.Join(string(os.PathSeparator), path)\n\t}\n\tpath, err = securejoin.SecureJoin(destVolume.MountPoint(), strings.TrimPrefix(path, volDestName))\n\treturn path, err\n}\n\nfunc isBindMountDestName(path string, ctr *libpod.Container) (bool, specs.Mount) {\n\tseparator := string(os.PathSeparator)\n\tif filepath.IsAbs(path) {\n\t\tpath = strings.TrimPrefix(path, string(os.PathSeparator))\n\t}\n\tif path == \"\" {\n\t\treturn false, specs.Mount{}\n\t}\n\tfor _, m := range ctr.Config().Spec.Mounts {\n\t\tif m.Type != \"bind\" {\n\t\t\tcontinue\n\t\t}\n\t\tmDest := strings.TrimPrefix(m.Destination, separator)\n\t\tif matchVolumePath(path, mDest) {\n\t\t\treturn true, m\n\t\t}\n\t}\n\treturn false, specs.Mount{}\n}\n\nfunc matchVolumePath(path, target string) bool {\n\tpathStr := filepath.Clean(path)\n\ttarget = filepath.Clean(target)\n\tfor len(pathStr) > len(target) && strings.Contains(pathStr, string(os.PathSeparator)) {\n\t\tpathStr = pathStr[:strings.LastIndex(pathStr, string(os.PathSeparator))]\n\t}\n\treturn pathStr == target\n}\n\nfunc pathWithBindMountSource(m specs.Mount, path string) (string, error) {\n\tif !filepath.IsAbs(path) {\n\t\tpath = filepath.Join(string(os.PathSeparator), path)\n\t}\n\treturn securejoin.SecureJoin(m.Source, strings.TrimPrefix(path, m.Destination))\n}\n", "// +build !remoteclient\n\npackage integration\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t. \"github.com/containers/libpod/test/utils\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Podman cp\", func() {\n\tvar (\n\t\ttempdir    string\n\t\terr        error\n\t\tpodmanTest *PodmanTestIntegration\n\t)\n\n\tBeforeEach(func() {\n\t\ttempdir, err = CreateTempDirInTempDir()\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpodmanTest = PodmanTestCreate(tempdir)\n\t\tpodmanTest.Setup()\n\t\tpodmanTest.SeedImages()\n\t})\n\n\tAfterEach(func() {\n\t\tpodmanTest.Cleanup()\n\t\tf := CurrentGinkgoTestDescription()\n\t\tprocessTestResult(f)\n\n\t})\n\n\tIt(\"podman cp file\", func() {\n\t\tsrcPath := filepath.Join(podmanTest.RunRoot, \"cp_test.txt\")\n\t\tdstPath := filepath.Join(podmanTest.RunRoot, \"cp_from_container\")\n\t\tfromHostToContainer := []byte(\"copy from host to container\")\n\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"cat\", \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\terr := ioutil.WriteFile(srcPath, fromHostToContainer, 0644)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", srcPath, name + \":foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", name + \":foo\", dstPath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"start\", name})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp file to dir\", func() {\n\t\tsrcPath := filepath.Join(podmanTest.RunRoot, \"cp_test.txt\")\n\t\tdstDir := filepath.Join(podmanTest.RunRoot, \"receive\")\n\t\tfromHostToContainer := []byte(\"copy from host to container directory\")\n\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"ls\", \"foodir/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\terr := ioutil.WriteFile(srcPath, fromHostToContainer, 0644)\n\t\tExpect(err).To(BeNil())\n\t\terr = os.Mkdir(dstDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", srcPath, name + \":foodir/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", name + \":foodir/cp_test.txt\", dstDir})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tos.Remove(\"cp_test.txt\")\n\t\tos.RemoveAll(\"receive\")\n\t})\n\n\tIt(\"podman cp dir to dir\", func() {\n\t\ttestDirPath := filepath.Join(podmanTest.RunRoot, \"TestDir\")\n\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"ls\", \"/foodir\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\terr := os.Mkdir(testDirPath, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", testDirPath, name + \":/foodir\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", testDirPath, name + \":/foodir\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp stdin/stdout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"ls\", \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\ttestDirPath := filepath.Join(podmanTest.RunRoot, \"TestDir\")\n\t\terr := os.Mkdir(testDirPath, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tcmd := exec.Command(\"tar\", \"-zcvf\", \"file.tar.gz\", testDirPath)\n\t\t_, err = cmd.Output()\n\t\tExpect(err).To(BeNil())\n\n\t\tdata, err := ioutil.ReadFile(\"foo.tar.gz\")\n\t\treader := strings.NewReader(string(data))\n\t\tcmd.Stdin = reader\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"-\", name + \":/foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"file.tar.gz\", name + \":/foo.tar.gz\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tsession = podmanTest.Podman([]string{\"cp\", name + \":/foo.tar.gz\", \"-\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp tar\", func() {\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--name\", \"testctr\", ALPINE, \"ls\", \"-l\", \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tpath, err := os.Getwd()\n\t\tExpect(err).To(BeNil())\n\t\ttestDirPath := filepath.Join(path, \"TestDir\")\n\t\terr = os.Mkdir(testDirPath, 0777)\n\t\tExpect(err).To(BeNil())\n\t\tcmd := exec.Command(\"tar\", \"-cvf\", \"file.tar\", testDirPath)\n\t\t_, err = cmd.Output()\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"file.tar\", \"testctr:/foo/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"start\", \"-a\", \"testctr\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"file.tar\"))\n\n\t\tos.Remove(\"file.tar\")\n\t\tos.RemoveAll(testDirPath)\n\t})\n\n\tIt(\"podman cp symlink\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\tsrcPath := filepath.Join(podmanTest.RunRoot, \"cp_test.txt\")\n\t\tfromHostToContainer := []byte(\"copy from host to container\")\n\t\terr := ioutil.WriteFile(srcPath, fromHostToContainer, 0644)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"exec\", name, \"ln\", \"-s\", \"/tmp\", \"/test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"--pause=false\", srcPath, name + \":/test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t_, err = os.Stat(\"/tmp/cp_test.txt\")\n\t\tExpect(err).To(Not(BeNil()))\n\t})\n\tIt(\"podman cp volume\", func() {\n\t\tsession := podmanTest.Podman([]string{\"volume\", \"create\", \"data\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"create\", \"-v\", \"data:/data\", \"--name\", \"container1\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\terr = ioutil.WriteFile(\"cp_vol\", []byte(\"copy to the volume\"), 0644)\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"cp_vol\", \"container1\" + \":/data/cp_vol1\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"container1\" + \":/data/cp_vol1\", \"cp_vol2\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp from ctr chown \", func() {\n\t\tsetup := podmanTest.RunTopContainer(\"testctr\")\n\t\tsetup.WaitWithDefaultTimeout()\n\t\tExpect(setup.ExitCode()).To(Equal(0))\n\n\t\tsession := podmanTest.Podman([]string{\"exec\", \"testctr\", \"adduser\", \"-S\", \"testuser\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"-u\", \"testuser\", \"testctr\", \"touch\", \"testfile\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"testctr:testfile\", \"testfile1\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t// owner of the file copied to local machine is not testuser\n\t\tcmd := exec.Command(\"ls\", \"-l\", \"testfile1\")\n\t\tcmdRet, err := cmd.Output()\n\t\tExpect(err).To(BeNil())\n\t\tExpect(strings.Contains(string(cmdRet), \"testuser\")).To(BeFalse())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"testfile1\", \"testctr:testfile2\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t// owner of the file copied to a container is the root user\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"-it\", \"testctr\", \"ls\", \"-l\", \"testfile2\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"root\"))\n\n\t\tos.Remove(\"testfile1\")\n\t})\n})\n", "#!/usr/bin/env bats   -*- bats -*-\n#\n# Tests for 'podman cp'\n#\n# ASSUMPTION FOR ALL THESE TESTS: /tmp in the container starts off empty\n#\n\nload helpers\n\n# Create two random-name random-content files in /tmp in the container\n# podman-cp them into the host using '/tmp/*', i.e. asking podman to\n# perform wildcard expansion in the container. We should get both\n# files copied into the host.\n@test \"podman cp * - wildcard copy multiple files from container to host\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n\n    rand_filename1=$(random_string 20)\n    rand_content1=$(random_string 50)\n    rand_filename2=$(random_string 20)\n    rand_content2=$(random_string 50)\n\n    run_podman run --name cpcontainer $IMAGE sh -c \\\n               \"echo $rand_content1 >/tmp/$rand_filename1;\n                echo $rand_content2 >/tmp/$rand_filename2\"\n\n    run_podman cp 'cpcontainer:/tmp/*' $dstdir\n\n    test -e $dstdir/$rand_filename1 || die \"file 1 not copied from container\"\n    test -e $dstdir/$rand_filename2 || die \"file 2 not copied from container\"\n\n    is \"$(<$dstdir/$rand_filename1)\" \"$rand_content1\" \"content of file 1\"\n    is \"$(<$dstdir/$rand_filename2)\" \"$rand_content2\" \"content of file 2\"\n\n    run_podman rm cpcontainer\n}\n\n\n# Create a file on the host; make a symlink in the container pointing\n# into host-only space. Try to podman-cp that symlink. It should fail.\n@test \"podman cp - will not recognize symlink pointing into host space\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n    skip \"BROKEN: PLEASE ENABLE ONCE #3829 GETS FIXED\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n    echo \"this file is on the host\" >$srcdir/hostfile\n\n    run_podman run --name cpcontainer $IMAGE \\\n               sh -c \"ln -s $srcdir/hostfile /tmp/badlink\"\n    # This should fail because, from the container's perspective, the symlink\n    # points to a nonexistent file\n    run_podman 125 cp 'cpcontainer:/tmp/*' $dstdir/\n\n    # FIXME: this might not be the exactly correct error message\n    is \"$output\" \".*error evaluating symlinks.*lstat.*no such file or dir\" \\\n       \"Expected error from copying invalid symlink\"\n\n    # make sure there are no files in dstdir\n    is \"$(/bin/ls -1 $dstdir)\" \"\" \"incorrectly copied symlink from host\"\n\n    run_podman rm cpcontainer\n}\n\n\n# Issue #3829 - like the above, but with a level of indirection in the\n# wildcard expansion: create a file on the host; create a symlink in\n# the container named 'file1' pointing to this file; then another symlink\n# in the container pointing to 'file*' (file star). Try to podman-cp\n# this invalid double symlink. It must fail.\n@test \"podman cp - will not expand globs in host space (#3829)\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n    skip \"BROKEN: PLEASE ENABLE ONCE #3829 GETS FIXED\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n    echo \"This file is on the host\" > $srcdir/hostfile\n\n    run_podman run --name cpcontainer $IMAGE \\\n               sh -c \"ln -s $srcdir/hostfile file1;ln -s file\\* copyme\"\n    run_podman 125 cp cpcontainer:copyme $dstdir\n\n    is \"$output\" \".*error evaluating symlinks.*lstat.*no such file or dir\" \\\n       \"Expected error from copying invalid symlink\"\n\n    # make sure there are no files in dstdir\n    is \"$(/bin/ls -1 $dstdir)\" \"\" \"incorrectly copied symlink from host\"\n\n    run_podman rm cpcontainer\n}\n\n\n# Another symlink into host space, this one named '*' (star). cp should fail.\n@test \"podman cp - will not expand wildcard\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n    echo \"This file lives on the host\" > $srcdir/hostfile\n\n    run_podman run --name cpcontainer $IMAGE \\\n               sh -c \"ln -s $srcdir/hostfile /tmp/\\*\"\n    run_podman 125 cp 'cpcontainer:/tmp/*' $dstdir\n\n    is \"$output\" \".*error evaluating symlinks.*lstat.*no such file or dir\" \\\n       \"Expected error from copying invalid symlink\"\n\n    # dstdir must be empty\n    is \"$(/bin/ls -1 $dstdir)\" \"\" \"incorrectly copied symlink from host\"\n\n    run_podman rm cpcontainer\n}\n\n###############################################################################\n# cp INTO container\n\n# THIS IS EXTREMELY WEIRD. Podman expands symlinks in weird ways.\n@test \"podman cp into container: weird symlink expansion\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n\n    rand_filename1=$(random_string 20)\n    rand_content1=$(random_string 50)\n    echo $rand_content1 > $srcdir/$rand_filename1\n\n    rand_filename2=$(random_string 20)\n    rand_content2=$(random_string 50)\n    echo $rand_content2 > $srcdir/$rand_filename2\n\n    rand_filename3=$(random_string 20)\n    rand_content3=$(random_string 50)\n    echo $rand_content3 > $srcdir/$rand_filename3\n\n    # Create tmp subdirectories in container, most with an invalid 'x' symlink\n    # Keep container running so we can exec into it.\n    run_podman run -d --name cpcontainer $IMAGE \\\n               sh -c \"mkdir /tmp/d1;ln -s /tmp/nonesuch1 /tmp/d1/x;\n                      mkdir /tmp/d2;ln -s /tmp/nonesuch2 /tmp/d2/x;\n                      mkdir /tmp/d3;\n                      trap 'exit 0' 15;while :;do sleep 0.5;done\"\n\n    # Copy file from host into container, into a file named 'x'\n    # Note that the second has a trailing slash; this will trigger mkdir\n    run_podman cp $srcdir/$rand_filename1 cpcontainer:/tmp/d1/x\n    is \"$output\" \"\" \"output from podman cp 1\"\n\n    run_podman cp $srcdir/$rand_filename2 cpcontainer:/tmp/d2/x/\n    is \"$output\" \"\" \"output from podman cp 3\"\n\n    run_podman cp $srcdir/$rand_filename3 cpcontainer:/tmp/d3/x\n    is \"$output\" \"\" \"output from podman cp 3\"\n\n    # Read back.\n    # In the first case, podman actually creates the file nonesuch1 (i.e.\n    # podman expands 'x -> nonesuch1' and, instead of overwriting x,\n    # creates an actual file).\n    run_podman exec cpcontainer cat /tmp/nonesuch1\n    is \"$output\" \"$rand_content1\" \"cp creates destination file\"\n\n    # In the second case, podman creates a directory nonesuch2, then\n    # creates a file with the same name as the input file. THIS IS WEIRD!\n    run_podman exec cpcontainer cat /tmp/nonesuch2/$rand_filename2\n    is \"$output\" \"$rand_content2\" \"cp creates destination dir and file\"\n\n    # In the third case, podman (correctly imo) creates a file named 'x'\n    run_podman exec cpcontainer cat /tmp/d3/x\n    is \"$output\" \"$rand_content3\" \"cp creates file named x\"\n\n    run_podman rm -f cpcontainer\n\n\n}\n\n\n# rhbz1741718 : file copied into container:/var/lib/foo appears as /foo\n# (docker only, never seems to have affected podman. Make sure it never does).\n@test \"podman cp into a subdirectory matching GraphRoot\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    # Create tempfile with random name and content\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    mkdir -p $srcdir\n    rand_filename=$(random_string 20)\n    rand_content=$(random_string 50)\n    echo $rand_content > $srcdir/$rand_filename\n    chmod 644 $srcdir/$rand_filename\n\n    # Determine path to podman storage (eg /var/lib/c/s, or $HOME/.local/...)\n    run_podman info --format '{{.store.GraphRoot}}'\n    graphroot=$output\n\n    # Create that directory in the container, and sleep (to keep container\n    # running, so we can exec into it). The trap/while is so podman-rm will\n    # run quickly instead of taking 10 seconds.\n    run_podman run -d --name cpcontainer $IMAGE sh -c \\\n               \"mkdir -p $graphroot; trap 'exit 0' 15;while :;do sleep 0.5;done\"\n\n    # Copy from host into container.\n    run_podman cp $srcdir/$rand_filename cpcontainer:$graphroot/$rand_filename\n\n    # ls, and confirm it's there.\n    run_podman exec cpcontainer ls -l $graphroot/$rand_filename\n    is \"$output\" \"-rw-r--r-- .* 1 .* root .* 51 .* $graphroot/$rand_filename\" \\\n       \"File is copied into container in the correct (full) path\"\n\n    # Confirm it has the expected content (this is unlikely to ever fail)\n    run_podman exec cpcontainer cat $graphroot/$rand_filename\n    is \"$output\" \"$rand_content\" \"Contents of file copied into container\"\n\n    run_podman rm -f cpcontainer\n}\n\n\nfunction teardown() {\n    # In case any test fails, clean up the container we left behind\n    run_podman rm -f cpcontainer\n    basic_teardown\n}\n\n# vim: filetype=sh\n"], "fixing_code": ["package main\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/containers/buildah/pkg/chrootuser\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/libpod/cmd/podman/cliconfig\"\n\t\"github.com/containers/libpod/cmd/podman/libpodruntime\"\n\t\"github.com/containers/libpod/libpod\"\n\t\"github.com/containers/libpod/libpod/define\"\n\t\"github.com/containers/libpod/pkg/rootless\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/archive\"\n\t\"github.com/containers/storage/pkg/chrootarchive\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar (\n\tcpCommand cliconfig.CpValues\n\n\tcpDescription = `Command copies the contents of SRC_PATH to the DEST_PATH.\n\n  You can copy from the container's file system to the local machine or the reverse, from the local filesystem to the container. If \"-\" is specified for either the SRC_PATH or DEST_PATH, you can also stream a tar archive from STDIN or to STDOUT. The CONTAINER can be a running or stopped container.  The SRC_PATH or DEST_PATH can be a file or directory.\n`\n\t_cpCommand = &cobra.Command{\n\t\tUse:   \"cp [flags] SRC_PATH DEST_PATH\",\n\t\tShort: \"Copy files/folders between a container and the local filesystem\",\n\t\tLong:  cpDescription,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tcpCommand.InputArgs = args\n\t\t\tcpCommand.GlobalFlags = MainGlobalOpts\n\t\t\tcpCommand.Remote = remoteclient\n\t\t\treturn cpCmd(&cpCommand)\n\t\t},\n\t\tExample: \"[CONTAINER:]SRC_PATH [CONTAINER:]DEST_PATH\",\n\t}\n)\n\nfunc init() {\n\tcpCommand.Command = _cpCommand\n\tflags := cpCommand.Flags()\n\tflags.BoolVar(&cpCommand.Extract, \"extract\", false, \"Extract the tar file into the destination directory.\")\n\tflags.BoolVar(&cpCommand.Pause, \"pause\", true, \"Pause the container while copying\")\n\tcpCommand.SetHelpTemplate(HelpTemplate())\n\tcpCommand.SetUsageTemplate(UsageTemplate())\n}\n\nfunc cpCmd(c *cliconfig.CpValues) error {\n\targs := c.InputArgs\n\tif len(args) != 2 {\n\t\treturn errors.Errorf(\"you must provide a source path and a destination path\")\n\t}\n\n\truntime, err := libpodruntime.GetRuntime(getContext(), &c.PodmanCommand)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"could not get runtime\")\n\t}\n\tdefer runtime.DeferredShutdown(false)\n\n\treturn copyBetweenHostAndContainer(runtime, args[0], args[1], c.Extract, c.Pause)\n}\n\nfunc copyBetweenHostAndContainer(runtime *libpod.Runtime, src string, dest string, extract bool, pause bool) error {\n\n\tsrcCtr, srcPath := parsePath(runtime, src)\n\tdestCtr, destPath := parsePath(runtime, dest)\n\n\tif (srcCtr == nil && destCtr == nil) || (srcCtr != nil && destCtr != nil) {\n\t\treturn errors.Errorf(\"invalid arguments %s, %s you must use just one container\", src, dest)\n\t}\n\n\tif len(srcPath) == 0 || len(destPath) == 0 {\n\t\treturn errors.Errorf(\"invalid arguments %s, %s you must specify paths\", src, dest)\n\t}\n\tctr := srcCtr\n\tisFromHostToCtr := ctr == nil\n\tif isFromHostToCtr {\n\t\tctr = destCtr\n\t}\n\n\tmountPoint, err := ctr.Mount()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err := ctr.Unmount(false); err != nil {\n\t\t\tlogrus.Errorf(\"unable to umount container '%s': %q\", ctr.ID(), err)\n\t\t}\n\t}()\n\n\t// We can't pause rootless containers.\n\tif pause && rootless.IsRootless() {\n\t\tstate, err := ctr.State()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif state == define.ContainerStateRunning {\n\t\t\treturn errors.Errorf(\"cannot copy into running rootless container with pause set - pass --pause=false to force copying\")\n\t\t}\n\t}\n\n\tif pause && !rootless.IsRootless() {\n\t\tif err := ctr.Pause(); err != nil {\n\t\t\t// An invalid state error is fine.\n\t\t\t// The container isn't running or is already paused.\n\t\t\t// TODO: We can potentially start the container while\n\t\t\t// the copy is running, which still allows a race where\n\t\t\t// malicious code could mess with the symlink.\n\t\t\tif errors.Cause(err) != define.ErrCtrStateInvalid {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\t// Only add the defer if we actually paused\n\t\t\tdefer func() {\n\t\t\t\tif err := ctr.Unpause(); err != nil {\n\t\t\t\t\tlogrus.Errorf(\"Error unpausing container after copying: %v\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t}\n\n\tuser, err := getUser(mountPoint, ctr.User())\n\tif err != nil {\n\t\treturn err\n\t}\n\tidMappingOpts, err := ctr.IDMappings()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error getting IDMappingOptions\")\n\t}\n\tdestOwner := idtools.IDPair{UID: int(user.UID), GID: int(user.GID)}\n\thostUID, hostGID, err := util.GetHostIDs(convertIDMap(idMappingOpts.UIDMap), convertIDMap(idMappingOpts.GIDMap), user.UID, user.GID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thostOwner := idtools.IDPair{UID: int(hostUID), GID: int(hostGID)}\n\n\tif isFromHostToCtr {\n\t\tif isVol, volDestName, volName := isVolumeDestName(destPath, ctr); isVol {\n\t\t\tpath, err := pathWithVolumeMount(ctr, runtime, volDestName, volName, destPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting destination path from volume %s\", volDestName)\n\t\t\t}\n\t\t\tdestPath = path\n\t\t} else if isBindMount, mount := isBindMountDestName(destPath, ctr); isBindMount {\n\t\t\tpath, err := pathWithBindMountSource(mount, destPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting destination path from bind mount %s\", mount.Destination)\n\t\t\t}\n\t\t\tdestPath = path\n\t\t} else if filepath.IsAbs(destPath) {\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, destPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdestPath = cleanedPath\n\t\t} else {\n\t\t\tctrWorkDir, err := securejoin.SecureJoin(mountPoint, ctr.WorkingDir())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err = idtools.MkdirAllAndChownNew(ctrWorkDir, 0755, hostOwner); err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error creating directory %q\", destPath)\n\t\t\t}\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, filepath.Join(ctr.WorkingDir(), destPath))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdestPath = cleanedPath\n\t\t}\n\t} else {\n\t\tdestOwner = idtools.IDPair{UID: os.Getuid(), GID: os.Getgid()}\n\t\tif isVol, volDestName, volName := isVolumeDestName(srcPath, ctr); isVol {\n\t\t\tpath, err := pathWithVolumeMount(ctr, runtime, volDestName, volName, srcPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting source path from volume %s\", volDestName)\n\t\t\t}\n\t\t\tsrcPath = path\n\t\t} else if isBindMount, mount := isBindMountDestName(srcPath, ctr); isBindMount {\n\t\t\tpath, err := pathWithBindMountSource(mount, srcPath)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error getting source path from bind moutn %s\", mount.Destination)\n\t\t\t}\n\t\t\tsrcPath = path\n\t\t} else if filepath.IsAbs(srcPath) {\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, srcPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsrcPath = cleanedPath\n\t\t} else {\n\t\t\tcleanedPath, err := securejoin.SecureJoin(mountPoint, filepath.Join(ctr.WorkingDir(), srcPath))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsrcPath = cleanedPath\n\t\t}\n\t}\n\n\tif !filepath.IsAbs(destPath) {\n\t\tdir, err := os.Getwd()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"err getting current working directory\")\n\t\t}\n\t\tdestPath = filepath.Join(dir, destPath)\n\t}\n\n\tif src == \"-\" {\n\t\tsrcPath = os.Stdin.Name()\n\t\textract = true\n\t}\n\treturn copy(srcPath, destPath, dest, idMappingOpts, &destOwner, extract, isFromHostToCtr)\n}\n\nfunc getUser(mountPoint string, userspec string) (specs.User, error) {\n\tuid, gid, _, err := chrootuser.GetUser(mountPoint, userspec)\n\tu := specs.User{\n\t\tUID:      uid,\n\t\tGID:      gid,\n\t\tUsername: userspec,\n\t}\n\tif !strings.Contains(userspec, \":\") {\n\t\tgroups, err2 := chrootuser.GetAdditionalGroupsForUser(mountPoint, uint64(u.UID))\n\t\tif err2 != nil {\n\t\t\tif errors.Cause(err2) != chrootuser.ErrNoSuchUser && err == nil {\n\t\t\t\terr = err2\n\t\t\t}\n\t\t} else {\n\t\t\tu.AdditionalGids = groups\n\t\t}\n\n\t}\n\treturn u, err\n}\n\nfunc parsePath(runtime *libpod.Runtime, path string) (*libpod.Container, string) {\n\tpathArr := strings.SplitN(path, \":\", 2)\n\tif len(pathArr) == 2 {\n\t\tctr, err := runtime.LookupContainer(pathArr[0])\n\t\tif err == nil {\n\t\t\treturn ctr, pathArr[1]\n\t\t}\n\t}\n\treturn nil, path\n}\n\nfunc getPathInfo(path string) (string, os.FileInfo, error) {\n\tpath, err := filepath.EvalSymlinks(path)\n\tif err != nil {\n\t\treturn \"\", nil, errors.Wrapf(err, \"error evaluating symlinks %q\", path)\n\t}\n\tsrcfi, err := os.Stat(path)\n\tif err != nil {\n\t\treturn \"\", nil, errors.Wrapf(err, \"error reading path %q\", path)\n\t}\n\treturn path, srcfi, nil\n}\n\nfunc copy(src, destPath, dest string, idMappingOpts storage.IDMappingOptions, chownOpts *idtools.IDPair, extract, isFromHostToCtr bool) error {\n\tsrcPath, err := filepath.EvalSymlinks(src)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error evaluating symlinks %q\", srcPath)\n\t}\n\n\tsrcPath, srcfi, err := getPathInfo(srcPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfilename := filepath.Base(destPath)\n\tif filename == \"-\" && !isFromHostToCtr {\n\t\terr := streamFileToStdout(srcPath, srcfi)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error streaming source file %s to Stdout\", srcPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\tdestdir := destPath\n\tif !srcfi.IsDir() && !strings.HasSuffix(dest, string(os.PathSeparator)) {\n\t\tdestdir = filepath.Dir(destPath)\n\t}\n\t_, err = os.Stat(destdir)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn errors.Wrapf(err, \"error checking directory %q\", destdir)\n\t}\n\tdestDirIsExist := err == nil\n\tif err = os.MkdirAll(destdir, 0755); err != nil {\n\t\treturn errors.Wrapf(err, \"error creating directory %q\", destdir)\n\t}\n\n\t// return functions for copying items\n\tcopyFileWithTar := chrootarchive.CopyFileWithTarAndChown(chownOpts, digest.Canonical.Digester().Hash(), idMappingOpts.UIDMap, idMappingOpts.GIDMap)\n\tcopyWithTar := chrootarchive.CopyWithTarAndChown(chownOpts, digest.Canonical.Digester().Hash(), idMappingOpts.UIDMap, idMappingOpts.GIDMap)\n\tuntarPath := chrootarchive.UntarPathAndChown(chownOpts, digest.Canonical.Digester().Hash(), idMappingOpts.UIDMap, idMappingOpts.GIDMap)\n\n\tif srcfi.IsDir() {\n\t\tlogrus.Debugf(\"copying %q to %q\", srcPath+string(os.PathSeparator)+\"*\", dest+string(os.PathSeparator)+\"*\")\n\t\tif destDirIsExist && !strings.HasSuffix(src, fmt.Sprintf(\"%s.\", string(os.PathSeparator))) {\n\t\t\tdestPath = filepath.Join(destPath, filepath.Base(srcPath))\n\t\t}\n\t\tif err = copyWithTar(srcPath, destPath); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error copying %q to %q\", srcPath, dest)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif extract {\n\t\t// We're extracting an archive into the destination directory.\n\t\tlogrus.Debugf(\"extracting contents of %q into %q\", srcPath, destPath)\n\t\tif err = untarPath(srcPath, destPath); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error extracting %q into %q\", srcPath, destPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\tdestfi, err := os.Stat(destPath)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn errors.Wrapf(err, \"failed to get stat of dest path %s\", destPath)\n\t\t}\n\t}\n\tif destfi != nil && destfi.IsDir() {\n\t\tdestPath = filepath.Join(destPath, filepath.Base(srcPath))\n\t}\n\n\t// Copy the file, preserving attributes.\n\tlogrus.Debugf(\"copying %q to %q\", srcPath, destPath)\n\tif err = copyFileWithTar(srcPath, destPath); err != nil {\n\t\treturn errors.Wrapf(err, \"error copying %q to %q\", srcPath, destPath)\n\t}\n\treturn nil\n}\n\nfunc convertIDMap(idMaps []idtools.IDMap) (convertedIDMap []specs.LinuxIDMapping) {\n\tfor _, idmap := range idMaps {\n\t\ttempIDMap := specs.LinuxIDMapping{\n\t\t\tContainerID: uint32(idmap.ContainerID),\n\t\t\tHostID:      uint32(idmap.HostID),\n\t\t\tSize:        uint32(idmap.Size),\n\t\t}\n\t\tconvertedIDMap = append(convertedIDMap, tempIDMap)\n\t}\n\treturn convertedIDMap\n}\n\nfunc streamFileToStdout(srcPath string, srcfi os.FileInfo) error {\n\tif srcfi.IsDir() {\n\t\ttw := tar.NewWriter(os.Stdout)\n\t\terr := filepath.Walk(srcPath, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil || !info.Mode().IsRegular() || path == srcPath {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thdr, err := tar.FileInfoHeader(info, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = tw.WriteHeader(hdr); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfh, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer fh.Close()\n\n\t\t\t_, err = io.Copy(tw, fh)\n\t\t\treturn err\n\t\t})\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error streaming directory %s to Stdout\", srcPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\tfile, err := os.Open(srcPath)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error opening file %s\", srcPath)\n\t}\n\tdefer file.Close()\n\tif !archive.IsArchivePath(srcPath) {\n\t\ttw := tar.NewWriter(os.Stdout)\n\t\thdr, err := tar.FileInfoHeader(srcfi, \"\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = tw.WriteHeader(hdr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = io.Copy(tw, file)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error streaming archive %s to Stdout\", srcPath)\n\t\t}\n\t\treturn nil\n\t}\n\n\t_, err = io.Copy(os.Stdout, file)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error streaming file to Stdout\")\n\t}\n\treturn nil\n}\n\nfunc isVolumeDestName(path string, ctr *libpod.Container) (bool, string, string) {\n\tseparator := string(os.PathSeparator)\n\tif filepath.IsAbs(path) {\n\t\tpath = strings.TrimPrefix(path, separator)\n\t}\n\tif path == \"\" {\n\t\treturn false, \"\", \"\"\n\t}\n\tfor _, vol := range ctr.Config().NamedVolumes {\n\t\tvolNamePath := strings.TrimPrefix(vol.Dest, separator)\n\t\tif matchVolumePath(path, volNamePath) {\n\t\t\treturn true, vol.Dest, vol.Name\n\t\t}\n\t}\n\treturn false, \"\", \"\"\n}\n\n// if SRCPATH or DESTPATH is from volume mount's destination -v or --mount type=volume, generates the path with volume mount point\nfunc pathWithVolumeMount(ctr *libpod.Container, runtime *libpod.Runtime, volDestName, volName, path string) (string, error) {\n\tdestVolume, err := runtime.GetVolume(volName)\n\tif err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"error getting volume destination %s\", volName)\n\t}\n\tif !filepath.IsAbs(path) {\n\t\tpath = filepath.Join(string(os.PathSeparator), path)\n\t}\n\tpath, err = securejoin.SecureJoin(destVolume.MountPoint(), strings.TrimPrefix(path, volDestName))\n\treturn path, err\n}\n\nfunc isBindMountDestName(path string, ctr *libpod.Container) (bool, specs.Mount) {\n\tseparator := string(os.PathSeparator)\n\tif filepath.IsAbs(path) {\n\t\tpath = strings.TrimPrefix(path, string(os.PathSeparator))\n\t}\n\tif path == \"\" {\n\t\treturn false, specs.Mount{}\n\t}\n\tfor _, m := range ctr.Config().Spec.Mounts {\n\t\tif m.Type != \"bind\" {\n\t\t\tcontinue\n\t\t}\n\t\tmDest := strings.TrimPrefix(m.Destination, separator)\n\t\tif matchVolumePath(path, mDest) {\n\t\t\treturn true, m\n\t\t}\n\t}\n\treturn false, specs.Mount{}\n}\n\nfunc matchVolumePath(path, target string) bool {\n\tpathStr := filepath.Clean(path)\n\ttarget = filepath.Clean(target)\n\tfor len(pathStr) > len(target) && strings.Contains(pathStr, string(os.PathSeparator)) {\n\t\tpathStr = pathStr[:strings.LastIndex(pathStr, string(os.PathSeparator))]\n\t}\n\treturn pathStr == target\n}\n\nfunc pathWithBindMountSource(m specs.Mount, path string) (string, error) {\n\tif !filepath.IsAbs(path) {\n\t\tpath = filepath.Join(string(os.PathSeparator), path)\n\t}\n\treturn securejoin.SecureJoin(m.Source, strings.TrimPrefix(path, m.Destination))\n}\n", "// +build !remoteclient\n\npackage integration\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t. \"github.com/containers/libpod/test/utils\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Podman cp\", func() {\n\tvar (\n\t\ttempdir    string\n\t\terr        error\n\t\tpodmanTest *PodmanTestIntegration\n\t)\n\n\tBeforeEach(func() {\n\t\ttempdir, err = CreateTempDirInTempDir()\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpodmanTest = PodmanTestCreate(tempdir)\n\t\tpodmanTest.Setup()\n\t\tpodmanTest.SeedImages()\n\t})\n\n\tAfterEach(func() {\n\t\tpodmanTest.Cleanup()\n\t\tf := CurrentGinkgoTestDescription()\n\t\tprocessTestResult(f)\n\n\t})\n\n\tIt(\"podman cp file\", func() {\n\t\tsrcPath := filepath.Join(podmanTest.RunRoot, \"cp_test.txt\")\n\t\tdstPath := filepath.Join(podmanTest.RunRoot, \"cp_from_container\")\n\t\tfromHostToContainer := []byte(\"copy from host to container\")\n\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"cat\", \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\terr := ioutil.WriteFile(srcPath, fromHostToContainer, 0644)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", srcPath, name + \":foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", name + \":foo\", dstPath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"start\", name})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp file to dir\", func() {\n\t\tsrcPath := filepath.Join(podmanTest.RunRoot, \"cp_test.txt\")\n\t\tdstDir := filepath.Join(podmanTest.RunRoot, \"receive\")\n\t\tfromHostToContainer := []byte(\"copy from host to container directory\")\n\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"ls\", \"foodir/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\terr := ioutil.WriteFile(srcPath, fromHostToContainer, 0644)\n\t\tExpect(err).To(BeNil())\n\t\terr = os.Mkdir(dstDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", srcPath, name + \":foodir/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", name + \":foodir/cp_test.txt\", dstDir})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tos.Remove(\"cp_test.txt\")\n\t\tos.RemoveAll(\"receive\")\n\t})\n\n\tIt(\"podman cp dir to dir\", func() {\n\t\ttestDirPath := filepath.Join(podmanTest.RunRoot, \"TestDir\")\n\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"ls\", \"/foodir\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\terr := os.Mkdir(testDirPath, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", testDirPath, name + \":/foodir\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", testDirPath, name + \":/foodir\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp stdin/stdout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"create\", ALPINE, \"ls\", \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\ttestDirPath := filepath.Join(podmanTest.RunRoot, \"TestDir\")\n\t\terr := os.Mkdir(testDirPath, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tcmd := exec.Command(\"tar\", \"-zcvf\", \"file.tar.gz\", testDirPath)\n\t\t_, err = cmd.Output()\n\t\tExpect(err).To(BeNil())\n\n\t\tdata, err := ioutil.ReadFile(\"foo.tar.gz\")\n\t\treader := strings.NewReader(string(data))\n\t\tcmd.Stdin = reader\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"-\", name + \":/foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"file.tar.gz\", name + \":/foo.tar.gz\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tsession = podmanTest.Podman([]string{\"cp\", name + \":/foo.tar.gz\", \"-\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp tar\", func() {\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--name\", \"testctr\", ALPINE, \"ls\", \"-l\", \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tpath, err := os.Getwd()\n\t\tExpect(err).To(BeNil())\n\t\ttestDirPath := filepath.Join(path, \"TestDir\")\n\t\terr = os.Mkdir(testDirPath, 0777)\n\t\tExpect(err).To(BeNil())\n\t\tcmd := exec.Command(\"tar\", \"-cvf\", \"file.tar\", testDirPath)\n\t\t_, err = cmd.Output()\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"file.tar\", \"testctr:/foo/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"start\", \"-a\", \"testctr\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"file.tar\"))\n\n\t\tos.Remove(\"file.tar\")\n\t\tos.RemoveAll(testDirPath)\n\t})\n\n\tIt(\"podman cp symlink\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tname := session.OutputToString()\n\n\t\tsrcPath := filepath.Join(podmanTest.RunRoot, \"cp_test.txt\")\n\t\tfromHostToContainer := []byte(\"copy from host to container\")\n\t\terr := ioutil.WriteFile(srcPath, fromHostToContainer, 0644)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"exec\", name, \"ln\", \"-s\", \"/tmp\", \"/test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"--pause=false\", srcPath, name + \":/test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t_, err = os.Stat(\"/tmp/cp_test.txt\")\n\t\tExpect(err).To(Not(BeNil()))\n\t})\n\tIt(\"podman cp volume\", func() {\n\t\tsession := podmanTest.Podman([]string{\"volume\", \"create\", \"data\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"create\", \"-v\", \"data:/data\", \"--name\", \"container1\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\terr = ioutil.WriteFile(\"cp_vol\", []byte(\"copy to the volume\"), 0644)\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"cp_vol\", \"container1\" + \":/data/cp_vol1\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"container1\" + \":/data/cp_vol1\", \"cp_vol2\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman cp from ctr chown \", func() {\n\t\tsetup := podmanTest.RunTopContainer(\"testctr\")\n\t\tsetup.WaitWithDefaultTimeout()\n\t\tExpect(setup.ExitCode()).To(Equal(0))\n\n\t\tsession := podmanTest.Podman([]string{\"exec\", \"testctr\", \"adduser\", \"-S\", \"testuser\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"-u\", \"testuser\", \"testctr\", \"touch\", \"testfile\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"--pause=false\", \"testctr:testfile\", \"testfile1\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t// owner of the file copied to local machine is not testuser\n\t\tcmd := exec.Command(\"ls\", \"-l\", \"testfile1\")\n\t\tcmdRet, err := cmd.Output()\n\t\tExpect(err).To(BeNil())\n\t\tExpect(strings.Contains(string(cmdRet), \"testuser\")).To(BeFalse())\n\n\t\tsession = podmanTest.Podman([]string{\"cp\", \"--pause=false\", \"testfile1\", \"testctr:testfile2\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t// owner of the file copied to a container is the root user\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"-it\", \"testctr\", \"ls\", \"-l\", \"testfile2\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"root\"))\n\n\t\tos.Remove(\"testfile1\")\n\t})\n})\n", "#!/usr/bin/env bats   -*- bats -*-\n#\n# Tests for 'podman cp'\n#\n# ASSUMPTION FOR ALL THESE TESTS: /tmp in the container starts off empty\n#\n\nload helpers\n\n# Create two random-name random-content files in /tmp in the container\n# podman-cp them into the host using '/tmp/*', i.e. asking podman to\n# perform wildcard expansion in the container. We should get both\n# files copied into the host.\n@test \"podman cp * - wildcard copy multiple files from container to host\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n\n    rand_filename1=$(random_string 20)\n    rand_content1=$(random_string 50)\n    rand_filename2=$(random_string 20)\n    rand_content2=$(random_string 50)\n\n    run_podman run --name cpcontainer $IMAGE sh -c \\\n               \"echo $rand_content1 >/tmp/$rand_filename1;\n                echo $rand_content2 >/tmp/$rand_filename2\"\n\n    # cp no longer supports wildcarding\n    run_podman 125 cp 'cpcontainer:/tmp/*' $dstdir\n\n    run_podman rm cpcontainer\n}\n\n\n# Create a file on the host; make a symlink in the container pointing\n# into host-only space. Try to podman-cp that symlink. It should fail.\n@test \"podman cp - will not recognize symlink pointing into host space\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n    skip \"BROKEN: PLEASE ENABLE ONCE #3829 GETS FIXED\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n    echo \"this file is on the host\" >$srcdir/hostfile\n\n    run_podman run --name cpcontainer $IMAGE \\\n               sh -c \"ln -s $srcdir/hostfile /tmp/badlink\"\n    # This should fail because, from the container's perspective, the symlink\n    # points to a nonexistent file\n    run_podman 125 cp 'cpcontainer:/tmp/*' $dstdir/\n\n    # FIXME: this might not be the exactly correct error message\n    is \"$output\" \".*error evaluating symlinks.*lstat.*no such file or dir\" \\\n       \"Expected error from copying invalid symlink\"\n\n    # make sure there are no files in dstdir\n    is \"$(/bin/ls -1 $dstdir)\" \"\" \"incorrectly copied symlink from host\"\n\n    run_podman rm cpcontainer\n}\n\n\n# Issue #3829 - like the above, but with a level of indirection in the\n# wildcard expansion: create a file on the host; create a symlink in\n# the container named 'file1' pointing to this file; then another symlink\n# in the container pointing to 'file*' (file star). Try to podman-cp\n# this invalid double symlink. It must fail.\n@test \"podman cp - will not expand globs in host space (#3829)\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n    skip \"BROKEN: PLEASE ENABLE ONCE #3829 GETS FIXED\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n    echo \"This file is on the host\" > $srcdir/hostfile\n\n    run_podman run --name cpcontainer $IMAGE \\\n               sh -c \"ln -s $srcdir/hostfile file1;ln -s file\\* copyme\"\n    run_podman 125 cp cpcontainer:copyme $dstdir\n\n    is \"$output\" \".*error evaluating symlinks.*lstat.*no such file or dir\" \\\n       \"Expected error from copying invalid symlink\"\n\n    # make sure there are no files in dstdir\n    is \"$(/bin/ls -1 $dstdir)\" \"\" \"incorrectly copied symlink from host\"\n\n    run_podman rm cpcontainer\n}\n\n\n# Another symlink into host space, this one named '*' (star). cp should fail.\n@test \"podman cp - will not expand wildcard\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n    echo \"This file lives on the host\" > $srcdir/hostfile\n\n    run_podman run --name cpcontainer $IMAGE \\\n               sh -c \"ln -s $srcdir/hostfile /tmp/\\*\"\n    run_podman 125 cp 'cpcontainer:/tmp/*' $dstdir\n\n    is \"$output\" \".*error evaluating symlinks.*lstat.*no such file or dir\" \\\n       \"Expected error from copying invalid symlink\"\n\n    # dstdir must be empty\n    is \"$(/bin/ls -1 $dstdir)\" \"\" \"incorrectly copied symlink from host\"\n\n    run_podman rm cpcontainer\n}\n\n###############################################################################\n# cp INTO container\n\n# THIS IS EXTREMELY WEIRD. Podman expands symlinks in weird ways.\n@test \"podman cp into container: weird symlink expansion\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    dstdir=$PODMAN_TMPDIR/cp-test-out\n    mkdir -p $srcdir $dstdir\n\n    rand_filename1=$(random_string 20)\n    rand_content1=$(random_string 50)\n    echo $rand_content1 > $srcdir/$rand_filename1\n\n    rand_filename2=$(random_string 20)\n    rand_content2=$(random_string 50)\n    echo $rand_content2 > $srcdir/$rand_filename2\n\n    rand_filename3=$(random_string 20)\n    rand_content3=$(random_string 50)\n    echo $rand_content3 > $srcdir/$rand_filename3\n\n    # Create tmp subdirectories in container, most with an invalid 'x' symlink\n    # Keep container running so we can exec into it.\n    run_podman run -d --name cpcontainer $IMAGE \\\n               sh -c \"mkdir /tmp/d1;ln -s /tmp/nonesuch1 /tmp/d1/x;\n                      mkdir /tmp/d2;ln -s /tmp/nonesuch2 /tmp/d2/x;\n                      mkdir /tmp/d3;\n                      trap 'exit 0' 15;while :;do sleep 0.5;done\"\n\n    # Copy file from host into container, into a file named 'x'\n    # Note that the second has a trailing slash; this will trigger mkdir\n    run_podman cp --pause=false $srcdir/$rand_filename1 cpcontainer:/tmp/d1/x\n    is \"$output\" \"\" \"output from podman cp 1\"\n\n    run_podman cp --pause=false $srcdir/$rand_filename2 cpcontainer:/tmp/d2/x/\n    is \"$output\" \"\" \"output from podman cp 3\"\n\n    run_podman cp --pause=false $srcdir/$rand_filename3 cpcontainer:/tmp/d3/x\n    is \"$output\" \"\" \"output from podman cp 3\"\n\n    # Read back.\n    # In the first case, podman actually creates the file nonesuch1 (i.e.\n    # podman expands 'x -> nonesuch1' and, instead of overwriting x,\n    # creates an actual file).\n    run_podman exec cpcontainer cat /tmp/nonesuch1\n    is \"$output\" \"$rand_content1\" \"cp creates destination file\"\n\n    # In the second case, podman creates a directory nonesuch2, then\n    # creates a file with the same name as the input file. THIS IS WEIRD!\n    run_podman exec cpcontainer cat /tmp/nonesuch2/$rand_filename2\n    is \"$output\" \"$rand_content2\" \"cp creates destination dir and file\"\n\n    # In the third case, podman (correctly imo) creates a file named 'x'\n    run_podman exec cpcontainer cat /tmp/d3/x\n    is \"$output\" \"$rand_content3\" \"cp creates file named x\"\n\n    run_podman rm -f cpcontainer\n\n\n}\n\n\n# rhbz1741718 : file copied into container:/var/lib/foo appears as /foo\n# (docker only, never seems to have affected podman. Make sure it never does).\n@test \"podman cp into a subdirectory matching GraphRoot\" {\n    skip_if_remote \"podman-remote does not yet handle cp\"\n\n    # Create tempfile with random name and content\n    srcdir=$PODMAN_TMPDIR/cp-test-in\n    mkdir -p $srcdir\n    rand_filename=$(random_string 20)\n    rand_content=$(random_string 50)\n    echo $rand_content > $srcdir/$rand_filename\n    chmod 644 $srcdir/$rand_filename\n\n    # Determine path to podman storage (eg /var/lib/c/s, or $HOME/.local/...)\n    run_podman info --format '{{.store.GraphRoot}}'\n    graphroot=$output\n\n    # Create that directory in the container, and sleep (to keep container\n    # running, so we can exec into it). The trap/while is so podman-rm will\n    # run quickly instead of taking 10 seconds.\n    run_podman run -d --name cpcontainer $IMAGE sh -c \\\n               \"mkdir -p $graphroot; trap 'exit 0' 15;while :;do sleep 0.5;done\"\n\n    # Copy from host into container.\n    run_podman cp --pause=false $srcdir/$rand_filename cpcontainer:$graphroot/$rand_filename\n\n    # ls, and confirm it's there.\n    run_podman exec cpcontainer ls -l $graphroot/$rand_filename\n    is \"$output\" \"-rw-r--r-- .* 1 .* root .* 51 .* $graphroot/$rand_filename\" \\\n       \"File is copied into container in the correct (full) path\"\n\n    # Confirm it has the expected content (this is unlikely to ever fail)\n    run_podman exec cpcontainer cat $graphroot/$rand_filename\n    is \"$output\" \"$rand_content\" \"Contents of file copied into container\"\n\n    run_podman rm -f cpcontainer\n}\n\n\nfunction teardown() {\n    # In case any test fails, clean up the container we left behind\n    run_podman rm -f cpcontainer\n    basic_teardown\n}\n\n# vim: filetype=sh\n"], "filenames": ["cmd/podman/cp.go", "test/e2e/cp_test.go", "test/system/065-cp.bats"], "buggy_code_start_loc": [55, 226, 30], "buggy_code_end_loc": [240, 237, 209], "fixing_code_start_loc": [55, 226, 30], "fixing_code_end_loc": [225, 237, 204], "type": "CWE-59", "message": "An issue was discovered in Podman in libpod before 1.6.0. It resolves a symlink in the host context during a copy operation from the container to the host, because an undesired glob operation occurs. An attacker could create a container image containing particular symlinks that, when copied by a victim user to the host filesystem, may overwrite existing files with others from the host.", "other": {"cve": {"id": "CVE-2019-18466", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-28T13:15:11.430", "lastModified": "2020-01-15T14:15:11.857", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Podman in libpod before 1.6.0. It resolves a symlink in the host context during a copy operation from the container to the host, because an undesired glob operation occurs. An attacker could create a container image containing particular symlinks that, when copied by a victim user to the host filesystem, may overwrite existing files with others from the host."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en Podman en libpod versiones anteriores a la versi\u00f3n  1.6.0. Resuelve un enlace simb\u00f3lico (symlink) en el contexto del host durante una operaci\u00f3n de copia desde el contenedor hacia el host, porque se produce una operaci\u00f3n glob no deseada. Un atacante podr\u00eda crear una imagen de contenedor que contenga enlaces simb\u00f3licos particulares que, cuando sean copiados por parte de un usuario v\u00edctima hacia el sistema de archivos del host, pueden sobrescribir los archivos existentes con otros del host."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libpod_project:libpod:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.0", "matchCriteriaId": "49E75E62-0DB3-4D8F-A9E9-18450BE6723E"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00040.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4269", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1744588", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/containers/libpod/commit/5c09c4d2947a759724f9d5aef6bac04317e03f7e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/containers/libpod/compare/v1.5.1...v1.6.0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/containers/libpod/issues/3829", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containers/libpod/commit/5c09c4d2947a759724f9d5aef6bac04317e03f7e"}}