{"buggy_code": ["/*\n * JPEG 2000 image decoder\n * Copyright (c) 2007 Kamil Nowosad\n * Copyright (c) 2013 Nicolas Bertrand <nicoinattendu@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * JPEG 2000 image decoder\n */\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"thread.h\"\n#include \"jpeg2000.h\"\n\n#define JP2_SIG_TYPE    0x6A502020\n#define JP2_SIG_VALUE   0x0D0A870A\n#define JP2_CODESTREAM  0x6A703263\n#define JP2_HEADER      0x6A703268\n\n#define HAD_COC 0x01\n#define HAD_QCC 0x02\n\ntypedef struct Jpeg2000TilePart {\n    uint8_t tile_index;                 // Tile index who refers the tile-part\n    const uint8_t *tp_end;\n    GetByteContext tpg;                 // bit stream in tile-part\n} Jpeg2000TilePart;\n\n/* RMK: For JPEG2000 DCINEMA 3 tile-parts in a tile\n * one per component, so tile_part elements have a size of 3 */\ntypedef struct Jpeg2000Tile {\n    Jpeg2000Component   *comp;\n    uint8_t             properties[4];\n    Jpeg2000CodingStyle codsty[4];\n    Jpeg2000QuantStyle  qntsty[4];\n    Jpeg2000TilePart    tile_part[4];\n    uint16_t tp_idx;                    // Tile-part index\n} Jpeg2000Tile;\n\ntypedef struct Jpeg2000DecoderContext {\n    AVClass         *class;\n    AVCodecContext  *avctx;\n    GetByteContext  g;\n\n    int             width, height;\n    int             image_offset_x, image_offset_y;\n    int             tile_offset_x, tile_offset_y;\n    uint8_t         cbps[4];    // bits per sample in particular components\n    uint8_t         sgnd[4];    // if a component is signed\n    uint8_t         properties[4];\n    int             cdx[4], cdy[4];\n    int             precision;\n    int             ncomponents;\n    int             colour_space;\n    uint32_t        palette[256];\n    int8_t          pal8;\n    int             cdef[4];\n    int             tile_width, tile_height;\n    unsigned        numXtiles, numYtiles;\n    int             maxtilelen;\n\n    Jpeg2000CodingStyle codsty[4];\n    Jpeg2000QuantStyle  qntsty[4];\n\n    int             bit_index;\n\n    int             curtileno;\n\n    Jpeg2000Tile    *tile;\n\n    /*options parameters*/\n    int             reduction_factor;\n} Jpeg2000DecoderContext;\n\n/* get_bits functions for JPEG2000 packet bitstream\n * It is a get_bit function with a bit-stuffing routine. If the value of the\n * byte is 0xFF, the next byte includes an extra zero bit stuffed into the MSB.\n * cf. ISO-15444-1:2002 / B.10.1 Bit-stuffing routine */\nstatic int get_bits(Jpeg2000DecoderContext *s, int n)\n{\n    int res = 0;\n\n    while (--n >= 0) {\n        res <<= 1;\n        if (s->bit_index == 0) {\n            s->bit_index = 7 + (bytestream2_get_byte(&s->g) != 0xFFu);\n        }\n        s->bit_index--;\n        res |= (bytestream2_peek_byte(&s->g) >> s->bit_index) & 1;\n    }\n    return res;\n}\n\nstatic void jpeg2000_flush(Jpeg2000DecoderContext *s)\n{\n    if (bytestream2_get_byte(&s->g) == 0xff)\n        bytestream2_skip(&s->g, 1);\n    s->bit_index = 8;\n}\n\n/* decode the value stored in node */\nstatic int tag_tree_decode(Jpeg2000DecoderContext *s, Jpeg2000TgtNode *node,\n                           int threshold)\n{\n    Jpeg2000TgtNode *stack[30];\n    int sp = -1, curval = 0;\n\n    if (!node)\n        return AVERROR_INVALIDDATA;\n\n    while (node && !node->vis) {\n        stack[++sp] = node;\n        node        = node->parent;\n    }\n\n    if (node)\n        curval = node->val;\n    else\n        curval = stack[sp]->val;\n\n    while (curval < threshold && sp >= 0) {\n        if (curval < stack[sp]->val)\n            curval = stack[sp]->val;\n        while (curval < threshold) {\n            int ret;\n            if ((ret = get_bits(s, 1)) > 0) {\n                stack[sp]->vis++;\n                break;\n            } else if (!ret)\n                curval++;\n            else\n                return ret;\n        }\n        stack[sp]->val = curval;\n        sp--;\n    }\n    return curval;\n}\n\nstatic int pix_fmt_match(enum AVPixelFormat pix_fmt, int components,\n                         int bpc, uint32_t log2_chroma_wh, int pal8)\n{\n    int match = 1;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n\n    if (desc->nb_components != components) {\n        return 0;\n    }\n\n    switch (components) {\n    case 4:\n        match = match && desc->comp[3].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 14 & 3) == 0 &&\n                         (log2_chroma_wh >> 12 & 3) == 0;\n    case 3:\n        match = match && desc->comp[2].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 10 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  8 & 3) == desc->log2_chroma_h;\n    case 2:\n        match = match && desc->comp[1].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  6 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  4 & 3) == desc->log2_chroma_h;\n\n    case 1:\n        match = match && desc->comp[0].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  2 & 3) == 0 &&\n                         (log2_chroma_wh       & 3) == 0 &&\n                         (desc->flags & AV_PIX_FMT_FLAG_PAL) == pal8 * AV_PIX_FMT_FLAG_PAL;\n    }\n    return match;\n}\n\n// pix_fmts with lower bpp have to be listed before\n// similar pix_fmts with higher bpp.\n#define RGB_PIXEL_FORMATS   AV_PIX_FMT_PAL8,AV_PIX_FMT_RGB24,AV_PIX_FMT_RGBA,AV_PIX_FMT_RGB48,AV_PIX_FMT_RGBA64\n#define GRAY_PIXEL_FORMATS  AV_PIX_FMT_GRAY8,AV_PIX_FMT_GRAY8A,AV_PIX_FMT_GRAY16\n#define YUV_PIXEL_FORMATS   AV_PIX_FMT_YUV410P,AV_PIX_FMT_YUV411P,AV_PIX_FMT_YUVA420P, \\\n                            AV_PIX_FMT_YUV420P,AV_PIX_FMT_YUV422P,AV_PIX_FMT_YUVA422P, \\\n                            AV_PIX_FMT_YUV440P,AV_PIX_FMT_YUV444P,AV_PIX_FMT_YUVA444P, \\\n                            AV_PIX_FMT_YUV420P9,AV_PIX_FMT_YUV422P9,AV_PIX_FMT_YUV444P9, \\\n                            AV_PIX_FMT_YUVA420P9,AV_PIX_FMT_YUVA422P9,AV_PIX_FMT_YUVA444P9, \\\n                            AV_PIX_FMT_YUV420P10,AV_PIX_FMT_YUV422P10,AV_PIX_FMT_YUV444P10, \\\n                            AV_PIX_FMT_YUVA420P10,AV_PIX_FMT_YUVA422P10,AV_PIX_FMT_YUVA444P10, \\\n                            AV_PIX_FMT_YUV420P12,AV_PIX_FMT_YUV422P12,AV_PIX_FMT_YUV444P12, \\\n                            AV_PIX_FMT_YUV420P14,AV_PIX_FMT_YUV422P14,AV_PIX_FMT_YUV444P14, \\\n                            AV_PIX_FMT_YUV420P16,AV_PIX_FMT_YUV422P16,AV_PIX_FMT_YUV444P16, \\\n                            AV_PIX_FMT_YUVA420P16,AV_PIX_FMT_YUVA422P16,AV_PIX_FMT_YUVA444P16\n#define XYZ_PIXEL_FORMATS   AV_PIX_FMT_XYZ12\n\nstatic const enum AVPixelFormat rgb_pix_fmts[]  = {RGB_PIXEL_FORMATS};\nstatic const enum AVPixelFormat gray_pix_fmts[] = {GRAY_PIXEL_FORMATS};\nstatic const enum AVPixelFormat yuv_pix_fmts[]  = {YUV_PIXEL_FORMATS};\nstatic const enum AVPixelFormat xyz_pix_fmts[]  = {XYZ_PIXEL_FORMATS};\nstatic const enum AVPixelFormat all_pix_fmts[]  = {RGB_PIXEL_FORMATS,\n                                                   GRAY_PIXEL_FORMATS,\n                                                   YUV_PIXEL_FORMATS,\n                                                   XYZ_PIXEL_FORMATS};\n\n/* marker segments */\n/* get sizes and offsets of image, tiles; number of components */\nstatic int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n               s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}\n\n/* get common part for COD and COC segments */\nstatic int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n{\n    uint8_t byte;\n\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n\n    /*  nreslevels = number of resolution levels\n                   = number of decomposition level +1 */\n    c->nreslevels = bytestream2_get_byteu(&s->g) + 1;\n    if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {\n        av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* compute number of resolution levels to decode */\n    if (c->nreslevels < s->reduction_factor)\n        c->nreslevels2decode = 1;\n    else\n        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n\n    c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk width\n    c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk height\n\n    if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||\n        c->log2_cblk_width + c->log2_cblk_height > 12) {\n        av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {\n        avpriv_request_sample(s->avctx, \"cblk size > 64\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    c->cblk_style = bytestream2_get_byteu(&s->g);\n    if (c->cblk_style != 0) { // cblk style\n        av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);\n    }\n    c->transform = bytestream2_get_byteu(&s->g); // DWT transformation type\n    /* set integer 9/7 DWT in case of BITEXACT flag */\n    if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))\n        c->transform = FF_DWT97_INT;\n\n    if (c->csty & JPEG2000_CSTY_PREC) {\n        int i;\n        for (i = 0; i < c->nreslevels; i++) {\n            byte = bytestream2_get_byte(&s->g);\n            c->log2_prec_widths[i]  =  byte       & 0x0F;    // precinct PPx\n            c->log2_prec_heights[i] = (byte >> 4) & 0x0F;    // precinct PPy\n        }\n    } else {\n        memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));\n        memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));\n    }\n    return 0;\n}\n\n/* get coding parameters for a particular tile or whole image*/\nstatic int get_cod(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n                   uint8_t *properties)\n{\n    Jpeg2000CodingStyle tmp;\n    int compno, ret;\n\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n\n    tmp.csty = bytestream2_get_byteu(&s->g);\n\n    // get progression order\n    tmp.prog_order = bytestream2_get_byteu(&s->g);\n\n    tmp.nlayers    = bytestream2_get_be16u(&s->g);\n    tmp.mct        = bytestream2_get_byteu(&s->g); // multiple component transformation\n\n    if (tmp.mct && s->ncomponents < 3) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"MCT %d with too few components (%d)\\n\",\n               tmp.mct, s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = get_cox(s, &tmp)) < 0)\n        return ret;\n\n    for (compno = 0; compno < s->ncomponents; compno++)\n        if (!(properties[compno] & HAD_COC))\n            memcpy(c + compno, &tmp, sizeof(tmp));\n    return 0;\n}\n\n/* Get coding parameters for a component in the whole image or a\n * particular tile. */\nstatic int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n                   uint8_t *properties)\n{\n    int compno, ret;\n\n    if (bytestream2_get_bytes_left(&s->g) < 2)\n        return AVERROR_INVALIDDATA;\n\n    compno = bytestream2_get_byteu(&s->g);\n\n    if (compno >= s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Invalid compno %d. There are %d components in the image.\\n\",\n               compno, s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c      += compno;\n    c->csty = bytestream2_get_byteu(&s->g);\n\n    if ((ret = get_cox(s, c)) < 0)\n        return ret;\n\n    properties[compno] |= HAD_COC;\n    return 0;\n}\n\n/* Get common part for QCD and QCC segments. */\nstatic int get_qcx(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q)\n{\n    int i, x;\n\n    if (bytestream2_get_bytes_left(&s->g) < 1)\n        return AVERROR_INVALIDDATA;\n\n    x = bytestream2_get_byteu(&s->g); // Sqcd\n\n    q->nguardbits = x >> 5;\n    q->quantsty   = x & 0x1f;\n\n    if (q->quantsty == JPEG2000_QSTY_NONE) {\n        n -= 3;\n        if (bytestream2_get_bytes_left(&s->g) < n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++)\n            q->expn[i] = bytestream2_get_byteu(&s->g) >> 3;\n    } else if (q->quantsty == JPEG2000_QSTY_SI) {\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n            return AVERROR_INVALIDDATA;\n        x          = bytestream2_get_be16u(&s->g);\n        q->expn[0] = x >> 11;\n        q->mant[0] = x & 0x7ff;\n        for (i = 1; i < JPEG2000_MAX_DECLEVELS * 3; i++) {\n            int curexpn = FFMAX(0, q->expn[0] - (i - 1) / 3);\n            q->expn[i] = curexpn;\n            q->mant[i] = q->mant[0];\n        }\n    } else {\n        n = (n - 3) >> 1;\n        if (bytestream2_get_bytes_left(&s->g) < 2 * n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++) {\n            x          = bytestream2_get_be16u(&s->g);\n            q->expn[i] = x >> 11;\n            q->mant[i] = x & 0x7ff;\n        }\n    }\n    return 0;\n}\n\n/* Get quantization parameters for a particular tile or a whole image. */\nstatic int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,\n                   uint8_t *properties)\n{\n    Jpeg2000QuantStyle tmp;\n    int compno, ret;\n\n    if ((ret = get_qcx(s, n, &tmp)) < 0)\n        return ret;\n    for (compno = 0; compno < s->ncomponents; compno++)\n        if (!(properties[compno] & HAD_QCC))\n            memcpy(q + compno, &tmp, sizeof(tmp));\n    return 0;\n}\n\n/* Get quantization parameters for a component in the whole image\n * on in a particular tile. */\nstatic int get_qcc(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,\n                   uint8_t *properties)\n{\n    int compno;\n\n    if (bytestream2_get_bytes_left(&s->g) < 1)\n        return AVERROR_INVALIDDATA;\n\n    compno = bytestream2_get_byteu(&s->g);\n\n    if (compno >= s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Invalid compno %d. There are %d components in the image.\\n\",\n               compno, s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    properties[compno] |= HAD_QCC;\n    return get_qcx(s, n - 1, q + compno);\n}\n\n/* Get start of tile segment. */\nstatic int get_sot(Jpeg2000DecoderContext *s, int n)\n{\n    Jpeg2000TilePart *tp;\n    uint16_t Isot;\n    uint32_t Psot;\n    uint8_t TPsot;\n\n    if (bytestream2_get_bytes_left(&s->g) < 8)\n        return AVERROR_INVALIDDATA;\n\n    s->curtileno = 0;\n    Isot = bytestream2_get_be16u(&s->g);        // Isot\n    if (Isot >= s->numXtiles * s->numYtiles)\n        return AVERROR_INVALIDDATA;\n\n    s->curtileno = Isot;\n    Psot  = bytestream2_get_be32u(&s->g);       // Psot\n    TPsot = bytestream2_get_byteu(&s->g);       // TPsot\n\n    /* Read TNSot but not used */\n    bytestream2_get_byteu(&s->g);               // TNsot\n\n    if (Psot > bytestream2_get_bytes_left(&s->g) + n + 2) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Psot %d too big\\n\", Psot);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (TPsot >= FF_ARRAY_ELEMS(s->tile[Isot].tile_part)) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\", TPsot);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->tile[Isot].tp_idx = TPsot;\n    tp             = s->tile[Isot].tile_part + TPsot;\n    tp->tile_index = Isot;\n    tp->tp_end     = s->g.buffer + Psot - n - 2;\n\n    if (!TPsot) {\n        Jpeg2000Tile *tile = s->tile + s->curtileno;\n\n        /* copy defaults */\n        memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(Jpeg2000CodingStyle));\n        memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(Jpeg2000QuantStyle));\n    }\n\n    return 0;\n}\n\n/* Tile-part lengths: see ISO 15444-1:2002, section A.7.1\n * Used to know the number of tile parts and lengths.\n * There may be multiple TLMs in the header.\n * TODO: The function is not used for tile-parts management, nor anywhere else.\n * It can be useful to allocate memory for tile parts, before managing the SOT\n * markers. Parsing the TLM header is needed to increment the input header\n * buffer.\n * This marker is mandatory for DCI. */\nstatic uint8_t get_tlm(Jpeg2000DecoderContext *s, int n)\n{\n    uint8_t Stlm, ST, SP, tile_tlm, i;\n    bytestream2_get_byte(&s->g);               /* Ztlm: skipped */\n    Stlm = bytestream2_get_byte(&s->g);\n\n    // too complex ? ST = ((Stlm >> 4) & 0x01) + ((Stlm >> 4) & 0x02);\n    ST = (Stlm >> 4) & 0x03;\n    // TODO: Manage case of ST = 0b11 --> raise error\n    SP       = (Stlm >> 6) & 0x01;\n    tile_tlm = (n - 4) / ((SP + 1) * 2 + ST);\n    for (i = 0; i < tile_tlm; i++) {\n        switch (ST) {\n        case 0:\n            break;\n        case 1:\n            bytestream2_get_byte(&s->g);\n            break;\n        case 2:\n            bytestream2_get_be16(&s->g);\n            break;\n        case 3:\n            bytestream2_get_be32(&s->g);\n            break;\n        }\n        if (SP == 0) {\n            bytestream2_get_be16(&s->g);\n        } else {\n            bytestream2_get_be32(&s->g);\n        }\n    }\n    return 0;\n}\n\nstatic int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno / s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; // global bandno\n\n        comp->coord_o[0][0] = FFMAX(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x);\n        comp->coord_o[0][1] = FFMIN((tilex + 1) * s->tile_width  + s->tile_offset_x, s->width);\n        comp->coord_o[1][0] = FFMAX(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y);\n        comp->coord_o[1][1] = FFMIN((tiley + 1) * s->tile_height + s->tile_offset_y, s->height);\n\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}\n\n/* Read the number of coding passes. */\nstatic int getnpasses(Jpeg2000DecoderContext *s)\n{\n    int num;\n    if (!get_bits(s, 1))\n        return 1;\n    if (!get_bits(s, 1))\n        return 2;\n    if ((num = get_bits(s, 2)) != 3)\n        return num < 0 ? num : 3 + num;\n    if ((num = get_bits(s, 5)) != 31)\n        return num < 0 ? num : 6 + num;\n    num = get_bits(s, 7);\n    return num < 0 ? num : 37 + num;\n}\n\nstatic int getlblockinc(Jpeg2000DecoderContext *s)\n{\n    int res = 0, ret;\n    while (ret = get_bits(s, 1)) {\n        if (ret < 0)\n            return ret;\n        res++;\n    }\n    return res;\n}\n\nstatic int jpeg2000_decode_packet(Jpeg2000DecoderContext *s,\n                                  Jpeg2000CodingStyle *codsty,\n                                  Jpeg2000ResLevel *rlevel, int precno,\n                                  int layno, uint8_t *expn, int numgbits)\n{\n    int bandno, cblkno, ret, nb_code_blocks;\n\n    if (!(ret = get_bits(s, 1))) {\n        jpeg2000_flush(s);\n        return 0;\n    } else if (ret < 0)\n        return ret;\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n        Jpeg2000Band *band = rlevel->band + bandno;\n        Jpeg2000Prec *prec = band->prec + precno;\n\n        if (band->coord[0][0] == band->coord[0][1] ||\n            band->coord[1][0] == band->coord[1][1])\n            continue;\n        nb_code_blocks =  prec->nb_codeblocks_height *\n                          prec->nb_codeblocks_width;\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n            int incl, newpasses, llen;\n\n            if (cblk->npasses)\n                incl = get_bits(s, 1);\n            else\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n            if (!incl)\n                continue;\n            else if (incl < 0)\n                return incl;\n\n            if (!cblk->npasses) {\n                int v = expn[bandno] + numgbits - 1 -\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n                if (v < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"nonzerobits %d invalid\\n\", v);\n                    return AVERROR_INVALIDDATA;\n                }\n                cblk->nonzerobits = v;\n            }\n            if ((newpasses = getnpasses(s)) < 0)\n                return newpasses;\n            if ((llen = getlblockinc(s)) < 0)\n                return llen;\n            cblk->lblock += llen;\n            if ((ret = get_bits(s, av_log2(newpasses) + cblk->lblock)) < 0)\n                return ret;\n            if (ret > sizeof(cblk->data)) {\n                avpriv_request_sample(s->avctx,\n                                      \"Block with lengthinc greater than %zu\",\n                                      sizeof(cblk->data));\n                return AVERROR_PATCHWELCOME;\n            }\n            cblk->lengthinc = ret;\n            cblk->npasses  += newpasses;\n        }\n    }\n    jpeg2000_flush(s);\n\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n            bytestream2_skip(&s->g, 2);\n        else\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found.\\n\");\n    }\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n        Jpeg2000Band *band = rlevel->band + bandno;\n        Jpeg2000Prec *prec = band->prec + precno;\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n            if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc\n                || sizeof(cblk->data) < cblk->length + cblk->lengthinc + 2\n            ) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Block length %d or lengthinc %d is too large\\n\",\n                       cblk->length, cblk->lengthinc);\n                return AVERROR_INVALIDDATA;\n            }\n\n            bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc);\n            cblk->length   += cblk->lengthinc;\n            cblk->lengthinc = 0;\n        }\n    }\n    return 0;\n}\n\nstatic int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int ret = 0;\n    int layno, reslevelno, compno, precno, ok_reslevel;\n    int x, y;\n\n    s->bit_index = 8;\n    switch (tile->codsty[0].prog_order) {\n    case JPEG2000_PGOD_RLCP:\n        avpriv_request_sample(s->avctx, \"Progression order RLCP\");\n\n    case JPEG2000_PGOD_LRCP:\n        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n            ok_reslevel = 1;\n            for (reslevelno = 0; ok_reslevel; reslevelno++) {\n                ok_reslevel = 0;\n                for (compno = 0; compno < s->ncomponents; compno++) {\n                    Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n                    Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n                    if (reslevelno < codsty->nreslevels) {\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel +\n                                                reslevelno;\n                        ok_reslevel = 1;\n                        for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++)\n                            if ((ret = jpeg2000_decode_packet(s,\n                                                              codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                    }\n                }\n            }\n        }\n        break;\n\n    case JPEG2000_PGOD_CPRL:\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n\n            /* Set bit stream buffer address according to tile-part.\n             * For DCinema one tile-part per component, so can be\n             * indexed by component. */\n            s->g = tile->tile_part[compno].tpg;\n\n            /* Position loop (y axis)\n             * TODO: Automate computing of step 256.\n             * Fixed here, but to be computed before entering here. */\n            for (y = 0; y < s->height; y += 256) {\n                /* Position loop (y axis)\n                 * TODO: automate computing of step 256.\n                 * Fixed here, but to be computed before entering here. */\n                for (x = 0; x < s->width; x += 256) {\n                    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n                        uint16_t prcx, prcy;\n                        uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; //  ==> N_L - r\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno;\n\n                        if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) ||\n                              (y == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) ||\n                              (x == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        // check if a precinct exists\n                        prcx   = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width;\n                        prcy   = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height;\n                        precno = prcx + rlevel->num_precincts_x * prcy;\n                        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n                            if ((ret = jpeg2000_decode_packet(s, codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                        }\n                    }\n                }\n            }\n        }\n        break;\n\n    case JPEG2000_PGOD_RPCL:\n        avpriv_request_sample(s->avctx, \"Progression order RPCL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n\n    case JPEG2000_PGOD_PCRL:\n        avpriv_request_sample(s->avctx, \"Progression order PCRL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n\n    default:\n        break;\n    }\n\n    /* EOC marker reached */\n    bytestream2_skip(&s->g, 2);\n\n    return ret;\n}\n\n/* TIER-1 routines */\nstatic void decode_sigpass(Jpeg2000T1Context *t1, int width, int height,\n                           int bpno, int bandno, int bpass_csty_symbol,\n                           int vert_causal_ctx_csty_symbol)\n{\n    int mask = 3 << (bpno - 1), y0, x, y;\n\n    for (y0 = 0; y0 < height; y0 += 4)\n        for (x = 0; x < width; x++)\n            for (y = y0; y < height && y < y0 + 4; y++) {\n                if ((t1->flags[y+1][x+1] & JPEG2000_T1_SIG_NB)\n                && !(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {\n                    int flags_mask = -1;\n                    if (vert_causal_ctx_csty_symbol && y == y0 + 3)\n                        flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);\n                    if (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask, bandno))) {\n                        int xorbit, ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n                        if (bpass_csty_symbol)\n                             t1->data[y][x] = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ? -mask : mask;\n                        else\n                             t1->data[y][x] = (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ^ xorbit) ?\n                                               -mask : mask;\n\n                        ff_jpeg2000_set_significance(t1, x, y,\n                                                     t1->data[y][x] < 0);\n                    }\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_VIS;\n                }\n            }\n}\n\nstatic void decode_refpass(Jpeg2000T1Context *t1, int width, int height,\n                           int bpno)\n{\n    int phalf, nhalf;\n    int y0, x, y;\n\n    phalf = 1 << (bpno - 1);\n    nhalf = -phalf;\n\n    for (y0 = 0; y0 < height; y0 += 4)\n        for (x = 0; x < width; x++)\n            for (y = y0; y < height && y < y0 + 4; y++)\n                if ((t1->flags[y + 1][x + 1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS)) == JPEG2000_T1_SIG) {\n                    int ctxno = ff_jpeg2000_getrefctxno(t1->flags[y + 1][x + 1]);\n                    int r     = ff_mqc_decode(&t1->mqc,\n                                              t1->mqc.cx_states + ctxno)\n                                ? phalf : nhalf;\n                    t1->data[y][x]          += t1->data[y][x] < 0 ? -r : r;\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_REF;\n                }\n}\n\nstatic void decode_clnpass(Jpeg2000DecoderContext *s, Jpeg2000T1Context *t1,\n                           int width, int height, int bpno, int bandno,\n                           int seg_symbols, int vert_causal_ctx_csty_symbol)\n{\n    int mask = 3 << (bpno - 1), y0, x, y, runlen, dec;\n\n    for (y0 = 0; y0 < height; y0 += 4) {\n        for (x = 0; x < width; x++) {\n            if (y0 + 3 < height &&\n                !((t1->flags[y0 + 1][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 2][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 3][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 4][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)))) {\n                if (!ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL))\n                    continue;\n                runlen = ff_mqc_decode(&t1->mqc,\n                                       t1->mqc.cx_states + MQC_CX_UNI);\n                runlen = (runlen << 1) | ff_mqc_decode(&t1->mqc,\n                                                       t1->mqc.cx_states +\n                                                       MQC_CX_UNI);\n                dec = 1;\n            } else {\n                runlen = 0;\n                dec    = 0;\n            }\n\n            for (y = y0 + runlen; y < y0 + 4 && y < height; y++) {\n                if (!dec) {\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {\n                        int flags_mask = -1;\n                        if (vert_causal_ctx_csty_symbol && y == y0 + 3)\n                            flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);\n                        dec = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask,\n                                                                                             bandno));\n                    }\n                }\n                if (dec) {\n                    int xorbit;\n                    int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y + 1][x + 1],\n                                                        &xorbit);\n                    t1->data[y][x] = (ff_mqc_decode(&t1->mqc,\n                                                    t1->mqc.cx_states + ctxno) ^\n                                      xorbit)\n                                     ? -mask : mask;\n                    ff_jpeg2000_set_significance(t1, x, y, t1->data[y][x] < 0);\n                }\n                dec = 0;\n                t1->flags[y + 1][x + 1] &= ~JPEG2000_T1_VIS;\n            }\n        }\n    }\n    if (seg_symbols) {\n        int val;\n        val = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        if (val != 0xa)\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Segmentation symbol value incorrect\\n\");\n    }\n}\n\nstatic int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n\n    /* If code-block contains no compressed data: nothing to do. */\n    if (!cblk->length)\n        return 0;\n\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}\n\n/* TODO: Verify dequantization for lossless case\n * comp->data can be float or int\n * band->stepsize can be float or int\n * depending on the type of DWT transformation.\n * see ISO/IEC 15444-1:2002 A.6.1 */\n\n/* Float dequantization of a codeblock.*/\nstatic void dequantization_float(int x, int y, Jpeg2000Cblk *cblk,\n                                 Jpeg2000Component *comp,\n                                 Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        float *datap = &comp->f_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = src[i] * band->f_stepsize;\n    }\n}\n\n/* Integer dequantization of a codeblock.*/\nstatic void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n                               Jpeg2000Component *comp,\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = (src[i] * band->i_stepsize + (1 << 14)) >> 15;\n    }\n}\n\n/* Inverse ICT parameters in float and integer.\n * int value = (float value) * (1<<16) */\nstatic const float f_ict_params[4] = {\n    1.402f,\n    0.34413f,\n    0.71414f,\n    1.772f\n};\nstatic const int   i_ict_params[4] = {\n     91881,\n     22553,\n     46802,\n    116130\n};\n\nstatic void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int i, csize = 1;\n    int32_t *src[3],  i0,  i1,  i2;\n    float   *srcf[3], i0f, i1f, i2f;\n\n    for (i = 1; i < 3; i++)\n        if (tile->codsty[0].transform != tile->codsty[i].transform) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Transforms mismatch, MCT not supported\\n\");\n            return;\n        }\n\n    for (i = 0; i < 3; i++)\n        if (tile->codsty[0].transform == FF_DWT97)\n            srcf[i] = tile->comp[i].f_data;\n        else\n            src [i] = tile->comp[i].i_data;\n\n    for (i = 0; i < 2; i++)\n        csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];\n\n    switch (tile->codsty[0].transform) {\n    case FF_DWT97:\n        for (i = 0; i < csize; i++) {\n            i0f = *srcf[0] + (f_ict_params[0] * *srcf[2]);\n            i1f = *srcf[0] - (f_ict_params[1] * *srcf[1])\n                           - (f_ict_params[2] * *srcf[2]);\n            i2f = *srcf[0] + (f_ict_params[3] * *srcf[1]);\n            *srcf[0]++ = i0f;\n            *srcf[1]++ = i1f;\n            *srcf[2]++ = i2f;\n        }\n        break;\n    case FF_DWT97_INT:\n        for (i = 0; i < csize; i++) {\n            i0 = *src[0] + (((i_ict_params[0] * *src[2]) + (1 << 15)) >> 16);\n            i1 = *src[0] - (((i_ict_params[1] * *src[1]) + (1 << 15)) >> 16)\n                         - (((i_ict_params[2] * *src[2]) + (1 << 15)) >> 16);\n            i2 = *src[0] + (((i_ict_params[3] * *src[1]) + (1 << 15)) >> 16);\n            *src[0]++ = i0;\n            *src[1]++ = i1;\n            *src[2]++ = i2;\n        }\n        break;\n    case FF_DWT53:\n        for (i = 0; i < csize; i++) {\n            i1 = *src[0] - (*src[2] + *src[1] >> 2);\n            i0 = i1 + *src[2];\n            i2 = i1 + *src[1];\n            *src[0]++ = i0;\n            *src[1]++ = i1;\n            *src[2]++ = i2;\n        }\n        break;\n    }\n}\n\nstatic int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n                                AVFrame *picture)\n{\n    int compno, reslevelno, bandno;\n    int x, y;\n\n    uint8_t *line;\n    Jpeg2000T1Context t1;\n\n    /* Loop on tile components */\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp     = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n        /* Loop on resolution levels */\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n            /* Loop on bands */\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n                int nb_precincts, precno;\n                Jpeg2000Band *band = rlevel->band + bandno;\n                int cblkno = 0, bandpos;\n\n                bandpos = bandno + (reslevelno > 0);\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n                    band->coord[1][0] == band->coord[1][1])\n                    continue;\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n                /* Loop on precincts */\n                for (precno = 0; precno < nb_precincts; precno++) {\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n                    /* Loop on codeblocks */\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                        int x, y;\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                        decode_cblk(s, codsty, &t1, cblk,\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n                                    bandpos);\n\n                        x = cblk->coord[0][0];\n                        y = cblk->coord[1][0];\n\n                        if (codsty->transform == FF_DWT97)\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n                        else\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n                   } /* end cblk */\n                } /*end prec */\n            } /* end band */\n        } /* end reslevel */\n\n        /* inverse DWT */\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n    } /*end comp */\n\n    /* inverse MCT transformation */\n    if (tile->codsty[0].mct)\n        mct_decode(s, tile);\n\n    if (s->cdef[0] < 0) {\n        for (x = 0; x < s->ncomponents; x++)\n            s->cdef[x] = x + 1;\n        if ((s->ncomponents & 1) == 0)\n            s->cdef[s->ncomponents-1] = 0;\n    }\n\n    if (s->precision <= 8) {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            line = picture->data[plane] + y * picture->linesize[plane];\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint8_t *dst;\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = line + x * pixelsize + compno*!planar;\n\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                line += picture->linesize[plane];\n            }\n        }\n    } else {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            uint16_t *linel;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint16_t *dst;\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = linel + (x * pixelsize + compno*!planar);\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        /* align 12 bit values in little-endian mode */\n                        *dst = val << (16 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        /* align 12 bit values in little-endian mode */\n                        *dst = val << (16 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                linel += picture->linesize[plane] >> 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic void jpeg2000_dec_cleanup(Jpeg2000DecoderContext *s)\n{\n    int tileno, compno;\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++) {\n        if (s->tile[tileno].comp) {\n            for (compno = 0; compno < s->ncomponents; compno++) {\n                Jpeg2000Component *comp     = s->tile[tileno].comp   + compno;\n                Jpeg2000CodingStyle *codsty = s->tile[tileno].codsty + compno;\n\n                ff_jpeg2000_cleanup(comp, codsty);\n            }\n            av_freep(&s->tile[tileno].comp);\n        }\n    }\n    av_freep(&s->tile);\n    memset(s->codsty, 0, sizeof(s->codsty));\n    memset(s->qntsty, 0, sizeof(s->qntsty));\n    s->numXtiles = s->numYtiles = 0;\n}\n\nstatic int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s)\n{\n    Jpeg2000CodingStyle *codsty = s->codsty;\n    Jpeg2000QuantStyle *qntsty  = s->qntsty;\n    uint8_t *properties         = s->properties;\n\n    for (;;) {\n        int len, ret = 0;\n        uint16_t marker;\n        int oldpos;\n\n        if (bytestream2_get_bytes_left(&s->g) < 2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n            break;\n        }\n\n        marker = bytestream2_get_be16u(&s->g);\n        oldpos = bytestream2_tell(&s->g);\n\n        if (marker == JPEG2000_SOD) {\n            Jpeg2000Tile *tile;\n            Jpeg2000TilePart *tp;\n\n            if (!s->tile) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing SIZ\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->curtileno < 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing SOT\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            tile = s->tile + s->curtileno;\n            tp = tile->tile_part + tile->tp_idx;\n            if (tp->tp_end < s->g.buffer) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Invalid tpend\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_init(&tp->tpg, s->g.buffer, tp->tp_end - s->g.buffer);\n            bytestream2_skip(&s->g, tp->tp_end - s->g.buffer);\n\n            continue;\n        }\n        if (marker == JPEG2000_EOC)\n            break;\n\n        len = bytestream2_get_be16(&s->g);\n        if (len < 2 || bytestream2_get_bytes_left(&s->g) < len - 2)\n            return AVERROR_INVALIDDATA;\n\n        switch (marker) {\n        case JPEG2000_SIZ:\n            ret = get_siz(s);\n            if (!s->tile)\n                s->numXtiles = s->numYtiles = 0;\n            break;\n        case JPEG2000_COC:\n            ret = get_coc(s, codsty, properties);\n            break;\n        case JPEG2000_COD:\n            ret = get_cod(s, codsty, properties);\n            break;\n        case JPEG2000_QCC:\n            ret = get_qcc(s, len, qntsty, properties);\n            break;\n        case JPEG2000_QCD:\n            ret = get_qcd(s, len, qntsty, properties);\n            break;\n        case JPEG2000_SOT:\n            if (!(ret = get_sot(s, len))) {\n                av_assert1(s->curtileno >= 0);\n                codsty = s->tile[s->curtileno].codsty;\n                qntsty = s->tile[s->curtileno].qntsty;\n                properties = s->tile[s->curtileno].properties;\n            }\n            break;\n        case JPEG2000_COM:\n            // the comment is ignored\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        case JPEG2000_TLM:\n            // Tile-part lengths\n            ret = get_tlm(s, len);\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"unsupported marker 0x%.4X at pos 0x%X\\n\",\n                   marker, bytestream2_tell(&s->g) - 4);\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        }\n        if (bytestream2_tell(&s->g) - oldpos != len || ret) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"error during processing marker segment %.4x\\n\", marker);\n            return ret ? ret : -1;\n        }\n    }\n    return 0;\n}\n\n/* Read bit stream packets --> T2 operation. */\nstatic int jpeg2000_read_bitstream_packets(Jpeg2000DecoderContext *s)\n{\n    int ret = 0;\n    int tileno;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++) {\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (ret = init_tile(s, tileno))\n            return ret;\n\n        s->g = tile->tile_part[0].tpg;\n        if (ret = jpeg2000_decode_packets(s, tile))\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int jp2_find_codestream(Jpeg2000DecoderContext *s)\n{\n    uint32_t atom_size, atom, atom_end;\n    int search_range = 10;\n\n    while (search_range\n           &&\n           bytestream2_get_bytes_left(&s->g) >= 8) {\n        atom_size = bytestream2_get_be32u(&s->g);\n        atom      = bytestream2_get_be32u(&s->g);\n        atom_end  = bytestream2_tell(&s->g) + atom_size - 8;\n\n        if (atom == JP2_CODESTREAM)\n            return 1;\n\n        if (bytestream2_get_bytes_left(&s->g) < atom_size || atom_end < atom_size)\n            return 0;\n\n        if (atom == JP2_HEADER &&\n                   atom_size >= 16) {\n            uint32_t atom2_size, atom2, atom2_end;\n            do {\n                atom2_size = bytestream2_get_be32u(&s->g);\n                atom2      = bytestream2_get_be32u(&s->g);\n                atom2_end  = bytestream2_tell(&s->g) + atom2_size - 8;\n                if (atom2_size < 8 || atom2_end > atom_end || atom2_end < atom2_size)\n                    break;\n                if (atom2 == JP2_CODESTREAM) {\n                    return 1;\n                } else if (atom2 == MKBETAG('c','o','l','r') && atom2_size >= 7) {\n                    int method = bytestream2_get_byteu(&s->g);\n                    bytestream2_skipu(&s->g, 2);\n                    if (method == 1) {\n                        s->colour_space = bytestream2_get_be32u(&s->g);\n                    }\n                } else if (atom2 == MKBETAG('p','c','l','r') && atom2_size >= 6) {\n                    int i, size, colour_count, colour_channels, colour_depth[3];\n                    uint32_t r, g, b;\n                    colour_count = bytestream2_get_be16u(&s->g);\n                    colour_channels = bytestream2_get_byteu(&s->g);\n                    // FIXME: Do not ignore channel_sign\n                    colour_depth[0] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[1] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[2] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    size = (colour_depth[0] + 7 >> 3) * colour_count +\n                           (colour_depth[1] + 7 >> 3) * colour_count +\n                           (colour_depth[2] + 7 >> 3) * colour_count;\n                    if (colour_count > 256   ||\n                        colour_channels != 3 ||\n                        colour_depth[0] > 16 ||\n                        colour_depth[1] > 16 ||\n                        colour_depth[2] > 16 ||\n                        atom2_size < size) {\n                        avpriv_request_sample(s->avctx, \"Unknown palette\");\n                        bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n                        continue;\n                    }\n                    s->pal8 = 1;\n                    for (i = 0; i < colour_count; i++) {\n                        if (colour_depth[0] <= 8) {\n                            r = bytestream2_get_byteu(&s->g) << 8 - colour_depth[0];\n                            r |= r >> colour_depth[0];\n                        } else {\n                            r = bytestream2_get_be16u(&s->g) >> colour_depth[0] - 8;\n                        }\n                        if (colour_depth[1] <= 8) {\n                            g = bytestream2_get_byteu(&s->g) << 8 - colour_depth[1];\n                            r |= r >> colour_depth[1];\n                        } else {\n                            g = bytestream2_get_be16u(&s->g) >> colour_depth[1] - 8;\n                        }\n                        if (colour_depth[2] <= 8) {\n                            b = bytestream2_get_byteu(&s->g) << 8 - colour_depth[2];\n                            r |= r >> colour_depth[2];\n                        } else {\n                            b = bytestream2_get_be16u(&s->g) >> colour_depth[2] - 8;\n                        }\n                        s->palette[i] = 0xffu << 24 | r << 16 | g << 8 | b;\n                    }\n                } else if (atom2 == MKBETAG('c','d','e','f') && atom2_size >= 2) {\n                    int n = bytestream2_get_be16u(&s->g);\n                    for (; n>0; n--) {\n                        int cn   = bytestream2_get_be16(&s->g);\n                        int av_unused typ  = bytestream2_get_be16(&s->g);\n                        int asoc = bytestream2_get_be16(&s->g);\n                        if (cn < 4 || asoc < 4)\n                            s->cdef[cn] = asoc;\n                    }\n                }\n                bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n            } while (atom_end - atom2_end >= 8);\n        } else {\n            search_range--;\n        }\n        bytestream2_seek(&s->g, atom_end, SEEK_SET);\n    }\n\n    return 0;\n}\n\nstatic int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n                                 int *got_frame, AVPacket *avpkt)\n{\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    int tileno, ret;\n\n    s->avctx     = avctx;\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n    s->curtileno = -1;\n    memset(s->cdef, -1, sizeof(s->cdef));\n\n    if (bytestream2_get_bytes_left(&s->g) < 2) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    // check if the image is in jp2 format\n    if (bytestream2_get_bytes_left(&s->g) >= 12 &&\n       (bytestream2_get_be32u(&s->g) == 12) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_TYPE) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_VALUE)) {\n        if (!jp2_find_codestream(s)) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Could not find Jpeg2000 codestream atom.\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n    } else {\n        bytestream2_seek(&s->g, 0, SEEK_SET);\n    }\n\n    while (bytestream2_get_bytes_left(&s->g) >= 3 && bytestream2_peek_be16(&s->g) != JPEG2000_SOC)\n        bytestream2_skip(&s->g, 1);\n\n    if (bytestream2_get_be16u(&s->g) != JPEG2000_SOC) {\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    if (ret = jpeg2000_read_main_headers(s))\n        goto end;\n\n    /* get picture buffer */\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        goto end;\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    picture->key_frame = 1;\n\n    if (ret = jpeg2000_read_bitstream_packets(s))\n        goto end;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n            goto end;\n\n    jpeg2000_dec_cleanup(s);\n\n    *got_frame = 1;\n\n    if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n        memcpy(picture->data[1], s->palette, 256 * sizeof(uint32_t));\n\n    return bytestream2_tell(&s->g);\n\nend:\n    jpeg2000_dec_cleanup(s);\n    return ret;\n}\n\nstatic void jpeg2000_init_static_data(AVCodec *codec)\n{\n    ff_jpeg2000_init_tier1_luts();\n    ff_mqc_init_context_tables();\n}\n\n#define OFFSET(x) offsetof(Jpeg2000DecoderContext, x)\n#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\n\nstatic const AVOption options[] = {\n    { \"lowres\",  \"Lower the decoding resolution by a power of two\",\n        OFFSET(reduction_factor), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, JPEG2000_MAX_RESLEVELS - 1, VD },\n    { NULL },\n};\n\nstatic const AVProfile profiles[] = {\n    { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0,  \"JPEG 2000 codestream restriction 0\"   },\n    { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1,  \"JPEG 2000 codestream restriction 1\"   },\n    { FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION, \"JPEG 2000 no codestream restrictions\" },\n    { FF_PROFILE_JPEG2000_DCINEMA_2K,             \"JPEG 2000 digital cinema 2K\"          },\n    { FF_PROFILE_JPEG2000_DCINEMA_4K,             \"JPEG 2000 digital cinema 4K\"          },\n    { FF_PROFILE_UNKNOWN },\n};\n\nstatic const AVClass jpeg2000_class = {\n    .class_name = \"jpeg2000\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_jpeg2000_decoder = {\n    .name             = \"jpeg2000\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"JPEG 2000\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_JPEG2000,\n    .capabilities     = CODEC_CAP_FRAME_THREADS,\n    .priv_data_size   = sizeof(Jpeg2000DecoderContext),\n    .init_static_data = jpeg2000_init_static_data,\n    .decode           = jpeg2000_decode_frame,\n    .priv_class       = &jpeg2000_class,\n    .max_lowres       = 5,\n    .profiles         = NULL_IF_CONFIG_SMALL(profiles)\n};\n"], "fixing_code": ["/*\n * JPEG 2000 image decoder\n * Copyright (c) 2007 Kamil Nowosad\n * Copyright (c) 2013 Nicolas Bertrand <nicoinattendu@gmail.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * JPEG 2000 image decoder\n */\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include \"thread.h\"\n#include \"jpeg2000.h\"\n\n#define JP2_SIG_TYPE    0x6A502020\n#define JP2_SIG_VALUE   0x0D0A870A\n#define JP2_CODESTREAM  0x6A703263\n#define JP2_HEADER      0x6A703268\n\n#define HAD_COC 0x01\n#define HAD_QCC 0x02\n\ntypedef struct Jpeg2000TilePart {\n    uint8_t tile_index;                 // Tile index who refers the tile-part\n    const uint8_t *tp_end;\n    GetByteContext tpg;                 // bit stream in tile-part\n} Jpeg2000TilePart;\n\n/* RMK: For JPEG2000 DCINEMA 3 tile-parts in a tile\n * one per component, so tile_part elements have a size of 3 */\ntypedef struct Jpeg2000Tile {\n    Jpeg2000Component   *comp;\n    uint8_t             properties[4];\n    Jpeg2000CodingStyle codsty[4];\n    Jpeg2000QuantStyle  qntsty[4];\n    Jpeg2000TilePart    tile_part[4];\n    uint16_t tp_idx;                    // Tile-part index\n} Jpeg2000Tile;\n\ntypedef struct Jpeg2000DecoderContext {\n    AVClass         *class;\n    AVCodecContext  *avctx;\n    GetByteContext  g;\n\n    int             width, height;\n    int             image_offset_x, image_offset_y;\n    int             tile_offset_x, tile_offset_y;\n    uint8_t         cbps[4];    // bits per sample in particular components\n    uint8_t         sgnd[4];    // if a component is signed\n    uint8_t         properties[4];\n    int             cdx[4], cdy[4];\n    int             precision;\n    int             ncomponents;\n    int             colour_space;\n    uint32_t        palette[256];\n    int8_t          pal8;\n    int             cdef[4];\n    int             tile_width, tile_height;\n    unsigned        numXtiles, numYtiles;\n    int             maxtilelen;\n\n    Jpeg2000CodingStyle codsty[4];\n    Jpeg2000QuantStyle  qntsty[4];\n\n    int             bit_index;\n\n    int             curtileno;\n\n    Jpeg2000Tile    *tile;\n\n    /*options parameters*/\n    int             reduction_factor;\n} Jpeg2000DecoderContext;\n\n/* get_bits functions for JPEG2000 packet bitstream\n * It is a get_bit function with a bit-stuffing routine. If the value of the\n * byte is 0xFF, the next byte includes an extra zero bit stuffed into the MSB.\n * cf. ISO-15444-1:2002 / B.10.1 Bit-stuffing routine */\nstatic int get_bits(Jpeg2000DecoderContext *s, int n)\n{\n    int res = 0;\n\n    while (--n >= 0) {\n        res <<= 1;\n        if (s->bit_index == 0) {\n            s->bit_index = 7 + (bytestream2_get_byte(&s->g) != 0xFFu);\n        }\n        s->bit_index--;\n        res |= (bytestream2_peek_byte(&s->g) >> s->bit_index) & 1;\n    }\n    return res;\n}\n\nstatic void jpeg2000_flush(Jpeg2000DecoderContext *s)\n{\n    if (bytestream2_get_byte(&s->g) == 0xff)\n        bytestream2_skip(&s->g, 1);\n    s->bit_index = 8;\n}\n\n/* decode the value stored in node */\nstatic int tag_tree_decode(Jpeg2000DecoderContext *s, Jpeg2000TgtNode *node,\n                           int threshold)\n{\n    Jpeg2000TgtNode *stack[30];\n    int sp = -1, curval = 0;\n\n    if (!node)\n        return AVERROR_INVALIDDATA;\n\n    while (node && !node->vis) {\n        stack[++sp] = node;\n        node        = node->parent;\n    }\n\n    if (node)\n        curval = node->val;\n    else\n        curval = stack[sp]->val;\n\n    while (curval < threshold && sp >= 0) {\n        if (curval < stack[sp]->val)\n            curval = stack[sp]->val;\n        while (curval < threshold) {\n            int ret;\n            if ((ret = get_bits(s, 1)) > 0) {\n                stack[sp]->vis++;\n                break;\n            } else if (!ret)\n                curval++;\n            else\n                return ret;\n        }\n        stack[sp]->val = curval;\n        sp--;\n    }\n    return curval;\n}\n\nstatic int pix_fmt_match(enum AVPixelFormat pix_fmt, int components,\n                         int bpc, uint32_t log2_chroma_wh, int pal8)\n{\n    int match = 1;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n\n    if (desc->nb_components != components) {\n        return 0;\n    }\n\n    switch (components) {\n    case 4:\n        match = match && desc->comp[3].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 14 & 3) == 0 &&\n                         (log2_chroma_wh >> 12 & 3) == 0;\n    case 3:\n        match = match && desc->comp[2].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >> 10 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  8 & 3) == desc->log2_chroma_h;\n    case 2:\n        match = match && desc->comp[1].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  6 & 3) == desc->log2_chroma_w &&\n                         (log2_chroma_wh >>  4 & 3) == desc->log2_chroma_h;\n\n    case 1:\n        match = match && desc->comp[0].depth_minus1 + 1 >= bpc &&\n                         (log2_chroma_wh >>  2 & 3) == 0 &&\n                         (log2_chroma_wh       & 3) == 0 &&\n                         (desc->flags & AV_PIX_FMT_FLAG_PAL) == pal8 * AV_PIX_FMT_FLAG_PAL;\n    }\n    return match;\n}\n\n// pix_fmts with lower bpp have to be listed before\n// similar pix_fmts with higher bpp.\n#define RGB_PIXEL_FORMATS   AV_PIX_FMT_PAL8,AV_PIX_FMT_RGB24,AV_PIX_FMT_RGBA,AV_PIX_FMT_RGB48,AV_PIX_FMT_RGBA64\n#define GRAY_PIXEL_FORMATS  AV_PIX_FMT_GRAY8,AV_PIX_FMT_GRAY8A,AV_PIX_FMT_GRAY16\n#define YUV_PIXEL_FORMATS   AV_PIX_FMT_YUV410P,AV_PIX_FMT_YUV411P,AV_PIX_FMT_YUVA420P, \\\n                            AV_PIX_FMT_YUV420P,AV_PIX_FMT_YUV422P,AV_PIX_FMT_YUVA422P, \\\n                            AV_PIX_FMT_YUV440P,AV_PIX_FMT_YUV444P,AV_PIX_FMT_YUVA444P, \\\n                            AV_PIX_FMT_YUV420P9,AV_PIX_FMT_YUV422P9,AV_PIX_FMT_YUV444P9, \\\n                            AV_PIX_FMT_YUVA420P9,AV_PIX_FMT_YUVA422P9,AV_PIX_FMT_YUVA444P9, \\\n                            AV_PIX_FMT_YUV420P10,AV_PIX_FMT_YUV422P10,AV_PIX_FMT_YUV444P10, \\\n                            AV_PIX_FMT_YUVA420P10,AV_PIX_FMT_YUVA422P10,AV_PIX_FMT_YUVA444P10, \\\n                            AV_PIX_FMT_YUV420P12,AV_PIX_FMT_YUV422P12,AV_PIX_FMT_YUV444P12, \\\n                            AV_PIX_FMT_YUV420P14,AV_PIX_FMT_YUV422P14,AV_PIX_FMT_YUV444P14, \\\n                            AV_PIX_FMT_YUV420P16,AV_PIX_FMT_YUV422P16,AV_PIX_FMT_YUV444P16, \\\n                            AV_PIX_FMT_YUVA420P16,AV_PIX_FMT_YUVA422P16,AV_PIX_FMT_YUVA444P16\n#define XYZ_PIXEL_FORMATS   AV_PIX_FMT_XYZ12\n\nstatic const enum AVPixelFormat rgb_pix_fmts[]  = {RGB_PIXEL_FORMATS};\nstatic const enum AVPixelFormat gray_pix_fmts[] = {GRAY_PIXEL_FORMATS};\nstatic const enum AVPixelFormat yuv_pix_fmts[]  = {YUV_PIXEL_FORMATS};\nstatic const enum AVPixelFormat xyz_pix_fmts[]  = {XYZ_PIXEL_FORMATS};\nstatic const enum AVPixelFormat all_pix_fmts[]  = {RGB_PIXEL_FORMATS,\n                                                   GRAY_PIXEL_FORMATS,\n                                                   YUV_PIXEL_FORMATS,\n                                                   XYZ_PIXEL_FORMATS};\n\n/* marker segments */\n/* get sizes and offsets of image, tiles; number of components */\nstatic int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n               s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}\n\n/* get common part for COD and COC segments */\nstatic int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n{\n    uint8_t byte;\n\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n\n    /*  nreslevels = number of resolution levels\n                   = number of decomposition level +1 */\n    c->nreslevels = bytestream2_get_byteu(&s->g) + 1;\n    if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {\n        av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* compute number of resolution levels to decode */\n    if (c->nreslevels < s->reduction_factor)\n        c->nreslevels2decode = 1;\n    else\n        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n\n    c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk width\n    c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk height\n\n    if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||\n        c->log2_cblk_width + c->log2_cblk_height > 12) {\n        av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {\n        avpriv_request_sample(s->avctx, \"cblk size > 64\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    c->cblk_style = bytestream2_get_byteu(&s->g);\n    if (c->cblk_style != 0) { // cblk style\n        av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);\n    }\n    c->transform = bytestream2_get_byteu(&s->g); // DWT transformation type\n    /* set integer 9/7 DWT in case of BITEXACT flag */\n    if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))\n        c->transform = FF_DWT97_INT;\n\n    if (c->csty & JPEG2000_CSTY_PREC) {\n        int i;\n        for (i = 0; i < c->nreslevels; i++) {\n            byte = bytestream2_get_byte(&s->g);\n            c->log2_prec_widths[i]  =  byte       & 0x0F;    // precinct PPx\n            c->log2_prec_heights[i] = (byte >> 4) & 0x0F;    // precinct PPy\n        }\n    } else {\n        memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));\n        memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));\n    }\n    return 0;\n}\n\n/* get coding parameters for a particular tile or whole image*/\nstatic int get_cod(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n                   uint8_t *properties)\n{\n    Jpeg2000CodingStyle tmp;\n    int compno, ret;\n\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n\n    tmp.csty = bytestream2_get_byteu(&s->g);\n\n    // get progression order\n    tmp.prog_order = bytestream2_get_byteu(&s->g);\n\n    tmp.nlayers    = bytestream2_get_be16u(&s->g);\n    tmp.mct        = bytestream2_get_byteu(&s->g); // multiple component transformation\n\n    if (tmp.mct && s->ncomponents < 3) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"MCT %d with too few components (%d)\\n\",\n               tmp.mct, s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = get_cox(s, &tmp)) < 0)\n        return ret;\n\n    for (compno = 0; compno < s->ncomponents; compno++)\n        if (!(properties[compno] & HAD_COC))\n            memcpy(c + compno, &tmp, sizeof(tmp));\n    return 0;\n}\n\n/* Get coding parameters for a component in the whole image or a\n * particular tile. */\nstatic int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n                   uint8_t *properties)\n{\n    int compno, ret;\n\n    if (bytestream2_get_bytes_left(&s->g) < 2)\n        return AVERROR_INVALIDDATA;\n\n    compno = bytestream2_get_byteu(&s->g);\n\n    if (compno >= s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Invalid compno %d. There are %d components in the image.\\n\",\n               compno, s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c      += compno;\n    c->csty = bytestream2_get_byteu(&s->g);\n\n    if ((ret = get_cox(s, c)) < 0)\n        return ret;\n\n    properties[compno] |= HAD_COC;\n    return 0;\n}\n\n/* Get common part for QCD and QCC segments. */\nstatic int get_qcx(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q)\n{\n    int i, x;\n\n    if (bytestream2_get_bytes_left(&s->g) < 1)\n        return AVERROR_INVALIDDATA;\n\n    x = bytestream2_get_byteu(&s->g); // Sqcd\n\n    q->nguardbits = x >> 5;\n    q->quantsty   = x & 0x1f;\n\n    if (q->quantsty == JPEG2000_QSTY_NONE) {\n        n -= 3;\n        if (bytestream2_get_bytes_left(&s->g) < n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++)\n            q->expn[i] = bytestream2_get_byteu(&s->g) >> 3;\n    } else if (q->quantsty == JPEG2000_QSTY_SI) {\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n            return AVERROR_INVALIDDATA;\n        x          = bytestream2_get_be16u(&s->g);\n        q->expn[0] = x >> 11;\n        q->mant[0] = x & 0x7ff;\n        for (i = 1; i < JPEG2000_MAX_DECLEVELS * 3; i++) {\n            int curexpn = FFMAX(0, q->expn[0] - (i - 1) / 3);\n            q->expn[i] = curexpn;\n            q->mant[i] = q->mant[0];\n        }\n    } else {\n        n = (n - 3) >> 1;\n        if (bytestream2_get_bytes_left(&s->g) < 2 * n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++) {\n            x          = bytestream2_get_be16u(&s->g);\n            q->expn[i] = x >> 11;\n            q->mant[i] = x & 0x7ff;\n        }\n    }\n    return 0;\n}\n\n/* Get quantization parameters for a particular tile or a whole image. */\nstatic int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,\n                   uint8_t *properties)\n{\n    Jpeg2000QuantStyle tmp;\n    int compno, ret;\n\n    if ((ret = get_qcx(s, n, &tmp)) < 0)\n        return ret;\n    for (compno = 0; compno < s->ncomponents; compno++)\n        if (!(properties[compno] & HAD_QCC))\n            memcpy(q + compno, &tmp, sizeof(tmp));\n    return 0;\n}\n\n/* Get quantization parameters for a component in the whole image\n * on in a particular tile. */\nstatic int get_qcc(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,\n                   uint8_t *properties)\n{\n    int compno;\n\n    if (bytestream2_get_bytes_left(&s->g) < 1)\n        return AVERROR_INVALIDDATA;\n\n    compno = bytestream2_get_byteu(&s->g);\n\n    if (compno >= s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Invalid compno %d. There are %d components in the image.\\n\",\n               compno, s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    properties[compno] |= HAD_QCC;\n    return get_qcx(s, n - 1, q + compno);\n}\n\n/* Get start of tile segment. */\nstatic int get_sot(Jpeg2000DecoderContext *s, int n)\n{\n    Jpeg2000TilePart *tp;\n    uint16_t Isot;\n    uint32_t Psot;\n    uint8_t TPsot;\n\n    if (bytestream2_get_bytes_left(&s->g) < 8)\n        return AVERROR_INVALIDDATA;\n\n    s->curtileno = 0;\n    Isot = bytestream2_get_be16u(&s->g);        // Isot\n    if (Isot >= s->numXtiles * s->numYtiles)\n        return AVERROR_INVALIDDATA;\n\n    s->curtileno = Isot;\n    Psot  = bytestream2_get_be32u(&s->g);       // Psot\n    TPsot = bytestream2_get_byteu(&s->g);       // TPsot\n\n    /* Read TNSot but not used */\n    bytestream2_get_byteu(&s->g);               // TNsot\n\n    if (Psot > bytestream2_get_bytes_left(&s->g) + n + 2) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Psot %d too big\\n\", Psot);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (TPsot >= FF_ARRAY_ELEMS(s->tile[Isot].tile_part)) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\", TPsot);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->tile[Isot].tp_idx = TPsot;\n    tp             = s->tile[Isot].tile_part + TPsot;\n    tp->tile_index = Isot;\n    tp->tp_end     = s->g.buffer + Psot - n - 2;\n\n    if (!TPsot) {\n        Jpeg2000Tile *tile = s->tile + s->curtileno;\n\n        /* copy defaults */\n        memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(Jpeg2000CodingStyle));\n        memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(Jpeg2000QuantStyle));\n    }\n\n    return 0;\n}\n\n/* Tile-part lengths: see ISO 15444-1:2002, section A.7.1\n * Used to know the number of tile parts and lengths.\n * There may be multiple TLMs in the header.\n * TODO: The function is not used for tile-parts management, nor anywhere else.\n * It can be useful to allocate memory for tile parts, before managing the SOT\n * markers. Parsing the TLM header is needed to increment the input header\n * buffer.\n * This marker is mandatory for DCI. */\nstatic uint8_t get_tlm(Jpeg2000DecoderContext *s, int n)\n{\n    uint8_t Stlm, ST, SP, tile_tlm, i;\n    bytestream2_get_byte(&s->g);               /* Ztlm: skipped */\n    Stlm = bytestream2_get_byte(&s->g);\n\n    // too complex ? ST = ((Stlm >> 4) & 0x01) + ((Stlm >> 4) & 0x02);\n    ST = (Stlm >> 4) & 0x03;\n    // TODO: Manage case of ST = 0b11 --> raise error\n    SP       = (Stlm >> 6) & 0x01;\n    tile_tlm = (n - 4) / ((SP + 1) * 2 + ST);\n    for (i = 0; i < tile_tlm; i++) {\n        switch (ST) {\n        case 0:\n            break;\n        case 1:\n            bytestream2_get_byte(&s->g);\n            break;\n        case 2:\n            bytestream2_get_be16(&s->g);\n            break;\n        case 3:\n            bytestream2_get_be32(&s->g);\n            break;\n        }\n        if (SP == 0) {\n            bytestream2_get_be16(&s->g);\n        } else {\n            bytestream2_get_be32(&s->g);\n        }\n    }\n    return 0;\n}\n\nstatic int init_tile(Jpeg2000DecoderContext *s, int tileno)\n{\n    int compno;\n    int tilex = tileno % s->numXtiles;\n    int tiley = tileno / s->numXtiles;\n    Jpeg2000Tile *tile = s->tile + tileno;\n\n    if (!tile->comp)\n        return AVERROR(ENOMEM);\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n        Jpeg2000QuantStyle  *qntsty = tile->qntsty + compno;\n        int ret; // global bandno\n\n        comp->coord_o[0][0] = FFMAX(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x);\n        comp->coord_o[0][1] = FFMIN((tilex + 1) * s->tile_width  + s->tile_offset_x, s->width);\n        comp->coord_o[1][0] = FFMAX(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y);\n        comp->coord_o[1][1] = FFMIN((tiley + 1) * s->tile_height + s->tile_offset_y, s->height);\n\n        comp->coord[0][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][0], s->reduction_factor);\n        comp->coord[0][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[0][1], s->reduction_factor);\n        comp->coord[1][0] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][0], s->reduction_factor);\n        comp->coord[1][1] = ff_jpeg2000_ceildivpow2(comp->coord_o[1][1], s->reduction_factor);\n\n        if (ret = ff_jpeg2000_init_component(comp, codsty, qntsty,\n                                             s->cbps[compno], s->cdx[compno],\n                                             s->cdy[compno], s->avctx))\n            return ret;\n    }\n    return 0;\n}\n\n/* Read the number of coding passes. */\nstatic int getnpasses(Jpeg2000DecoderContext *s)\n{\n    int num;\n    if (!get_bits(s, 1))\n        return 1;\n    if (!get_bits(s, 1))\n        return 2;\n    if ((num = get_bits(s, 2)) != 3)\n        return num < 0 ? num : 3 + num;\n    if ((num = get_bits(s, 5)) != 31)\n        return num < 0 ? num : 6 + num;\n    num = get_bits(s, 7);\n    return num < 0 ? num : 37 + num;\n}\n\nstatic int getlblockinc(Jpeg2000DecoderContext *s)\n{\n    int res = 0, ret;\n    while (ret = get_bits(s, 1)) {\n        if (ret < 0)\n            return ret;\n        res++;\n    }\n    return res;\n}\n\nstatic int jpeg2000_decode_packet(Jpeg2000DecoderContext *s,\n                                  Jpeg2000CodingStyle *codsty,\n                                  Jpeg2000ResLevel *rlevel, int precno,\n                                  int layno, uint8_t *expn, int numgbits)\n{\n    int bandno, cblkno, ret, nb_code_blocks;\n\n    if (!(ret = get_bits(s, 1))) {\n        jpeg2000_flush(s);\n        return 0;\n    } else if (ret < 0)\n        return ret;\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n        Jpeg2000Band *band = rlevel->band + bandno;\n        Jpeg2000Prec *prec = band->prec + precno;\n\n        if (band->coord[0][0] == band->coord[0][1] ||\n            band->coord[1][0] == band->coord[1][1])\n            continue;\n        nb_code_blocks =  prec->nb_codeblocks_height *\n                          prec->nb_codeblocks_width;\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n            int incl, newpasses, llen;\n\n            if (cblk->npasses)\n                incl = get_bits(s, 1);\n            else\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n            if (!incl)\n                continue;\n            else if (incl < 0)\n                return incl;\n\n            if (!cblk->npasses) {\n                int v = expn[bandno] + numgbits - 1 -\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n                if (v < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"nonzerobits %d invalid\\n\", v);\n                    return AVERROR_INVALIDDATA;\n                }\n                cblk->nonzerobits = v;\n            }\n            if ((newpasses = getnpasses(s)) < 0)\n                return newpasses;\n            if ((llen = getlblockinc(s)) < 0)\n                return llen;\n            cblk->lblock += llen;\n            if ((ret = get_bits(s, av_log2(newpasses) + cblk->lblock)) < 0)\n                return ret;\n            if (ret > sizeof(cblk->data)) {\n                avpriv_request_sample(s->avctx,\n                                      \"Block with lengthinc greater than %zu\",\n                                      sizeof(cblk->data));\n                return AVERROR_PATCHWELCOME;\n            }\n            cblk->lengthinc = ret;\n            cblk->npasses  += newpasses;\n        }\n    }\n    jpeg2000_flush(s);\n\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n            bytestream2_skip(&s->g, 2);\n        else\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found.\\n\");\n    }\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n        Jpeg2000Band *band = rlevel->band + bandno;\n        Jpeg2000Prec *prec = band->prec + precno;\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n            if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc\n                || sizeof(cblk->data) < cblk->length + cblk->lengthinc + 2\n            ) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Block length %d or lengthinc %d is too large\\n\",\n                       cblk->length, cblk->lengthinc);\n                return AVERROR_INVALIDDATA;\n            }\n\n            bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc);\n            cblk->length   += cblk->lengthinc;\n            cblk->lengthinc = 0;\n        }\n    }\n    return 0;\n}\n\nstatic int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int ret = 0;\n    int layno, reslevelno, compno, precno, ok_reslevel;\n    int x, y;\n\n    s->bit_index = 8;\n    switch (tile->codsty[0].prog_order) {\n    case JPEG2000_PGOD_RLCP:\n        avpriv_request_sample(s->avctx, \"Progression order RLCP\");\n\n    case JPEG2000_PGOD_LRCP:\n        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n            ok_reslevel = 1;\n            for (reslevelno = 0; ok_reslevel; reslevelno++) {\n                ok_reslevel = 0;\n                for (compno = 0; compno < s->ncomponents; compno++) {\n                    Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n                    Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n                    if (reslevelno < codsty->nreslevels) {\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel +\n                                                reslevelno;\n                        ok_reslevel = 1;\n                        for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++)\n                            if ((ret = jpeg2000_decode_packet(s,\n                                                              codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                    }\n                }\n            }\n        }\n        break;\n\n    case JPEG2000_PGOD_CPRL:\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n\n            /* Set bit stream buffer address according to tile-part.\n             * For DCinema one tile-part per component, so can be\n             * indexed by component. */\n            s->g = tile->tile_part[compno].tpg;\n\n            /* Position loop (y axis)\n             * TODO: Automate computing of step 256.\n             * Fixed here, but to be computed before entering here. */\n            for (y = 0; y < s->height; y += 256) {\n                /* Position loop (y axis)\n                 * TODO: automate computing of step 256.\n                 * Fixed here, but to be computed before entering here. */\n                for (x = 0; x < s->width; x += 256) {\n                    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n                        uint16_t prcx, prcy;\n                        uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; //  ==> N_L - r\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno;\n\n                        if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) ||\n                              (y == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) ||\n                              (x == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        // check if a precinct exists\n                        prcx   = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width;\n                        prcy   = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height;\n                        precno = prcx + rlevel->num_precincts_x * prcy;\n                        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n                            if ((ret = jpeg2000_decode_packet(s, codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                        }\n                    }\n                }\n            }\n        }\n        break;\n\n    case JPEG2000_PGOD_RPCL:\n        avpriv_request_sample(s->avctx, \"Progression order RPCL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n\n    case JPEG2000_PGOD_PCRL:\n        avpriv_request_sample(s->avctx, \"Progression order PCRL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n\n    default:\n        break;\n    }\n\n    /* EOC marker reached */\n    bytestream2_skip(&s->g, 2);\n\n    return ret;\n}\n\n/* TIER-1 routines */\nstatic void decode_sigpass(Jpeg2000T1Context *t1, int width, int height,\n                           int bpno, int bandno, int bpass_csty_symbol,\n                           int vert_causal_ctx_csty_symbol)\n{\n    int mask = 3 << (bpno - 1), y0, x, y;\n\n    for (y0 = 0; y0 < height; y0 += 4)\n        for (x = 0; x < width; x++)\n            for (y = y0; y < height && y < y0 + 4; y++) {\n                if ((t1->flags[y+1][x+1] & JPEG2000_T1_SIG_NB)\n                && !(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {\n                    int flags_mask = -1;\n                    if (vert_causal_ctx_csty_symbol && y == y0 + 3)\n                        flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);\n                    if (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask, bandno))) {\n                        int xorbit, ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n                        if (bpass_csty_symbol)\n                             t1->data[y][x] = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ? -mask : mask;\n                        else\n                             t1->data[y][x] = (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ^ xorbit) ?\n                                               -mask : mask;\n\n                        ff_jpeg2000_set_significance(t1, x, y,\n                                                     t1->data[y][x] < 0);\n                    }\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_VIS;\n                }\n            }\n}\n\nstatic void decode_refpass(Jpeg2000T1Context *t1, int width, int height,\n                           int bpno)\n{\n    int phalf, nhalf;\n    int y0, x, y;\n\n    phalf = 1 << (bpno - 1);\n    nhalf = -phalf;\n\n    for (y0 = 0; y0 < height; y0 += 4)\n        for (x = 0; x < width; x++)\n            for (y = y0; y < height && y < y0 + 4; y++)\n                if ((t1->flags[y + 1][x + 1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS)) == JPEG2000_T1_SIG) {\n                    int ctxno = ff_jpeg2000_getrefctxno(t1->flags[y + 1][x + 1]);\n                    int r     = ff_mqc_decode(&t1->mqc,\n                                              t1->mqc.cx_states + ctxno)\n                                ? phalf : nhalf;\n                    t1->data[y][x]          += t1->data[y][x] < 0 ? -r : r;\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_REF;\n                }\n}\n\nstatic void decode_clnpass(Jpeg2000DecoderContext *s, Jpeg2000T1Context *t1,\n                           int width, int height, int bpno, int bandno,\n                           int seg_symbols, int vert_causal_ctx_csty_symbol)\n{\n    int mask = 3 << (bpno - 1), y0, x, y, runlen, dec;\n\n    for (y0 = 0; y0 < height; y0 += 4) {\n        for (x = 0; x < width; x++) {\n            if (y0 + 3 < height &&\n                !((t1->flags[y0 + 1][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 2][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 3][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n                  (t1->flags[y0 + 4][x + 1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)))) {\n                if (!ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL))\n                    continue;\n                runlen = ff_mqc_decode(&t1->mqc,\n                                       t1->mqc.cx_states + MQC_CX_UNI);\n                runlen = (runlen << 1) | ff_mqc_decode(&t1->mqc,\n                                                       t1->mqc.cx_states +\n                                                       MQC_CX_UNI);\n                dec = 1;\n            } else {\n                runlen = 0;\n                dec    = 0;\n            }\n\n            for (y = y0 + runlen; y < y0 + 4 && y < height; y++) {\n                if (!dec) {\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {\n                        int flags_mask = -1;\n                        if (vert_causal_ctx_csty_symbol && y == y0 + 3)\n                            flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);\n                        dec = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask,\n                                                                                             bandno));\n                    }\n                }\n                if (dec) {\n                    int xorbit;\n                    int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y + 1][x + 1],\n                                                        &xorbit);\n                    t1->data[y][x] = (ff_mqc_decode(&t1->mqc,\n                                                    t1->mqc.cx_states + ctxno) ^\n                                      xorbit)\n                                     ? -mask : mask;\n                    ff_jpeg2000_set_significance(t1, x, y, t1->data[y][x] < 0);\n                }\n                dec = 0;\n                t1->flags[y + 1][x + 1] &= ~JPEG2000_T1_VIS;\n            }\n        }\n    }\n    if (seg_symbols) {\n        int val;\n        val = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        val = (val << 1) + ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI);\n        if (val != 0xa)\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Segmentation symbol value incorrect\\n\");\n    }\n}\n\nstatic int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n\n    /* If code-block contains no compressed data: nothing to do. */\n    if (!cblk->length)\n        return 0;\n\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}\n\n/* TODO: Verify dequantization for lossless case\n * comp->data can be float or int\n * band->stepsize can be float or int\n * depending on the type of DWT transformation.\n * see ISO/IEC 15444-1:2002 A.6.1 */\n\n/* Float dequantization of a codeblock.*/\nstatic void dequantization_float(int x, int y, Jpeg2000Cblk *cblk,\n                                 Jpeg2000Component *comp,\n                                 Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        float *datap = &comp->f_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = src[i] * band->f_stepsize;\n    }\n}\n\n/* Integer dequantization of a codeblock.*/\nstatic void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n                               Jpeg2000Component *comp,\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = (src[i] * band->i_stepsize + (1 << 14)) >> 15;\n    }\n}\n\n/* Inverse ICT parameters in float and integer.\n * int value = (float value) * (1<<16) */\nstatic const float f_ict_params[4] = {\n    1.402f,\n    0.34413f,\n    0.71414f,\n    1.772f\n};\nstatic const int   i_ict_params[4] = {\n     91881,\n     22553,\n     46802,\n    116130\n};\n\nstatic void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int i, csize = 1;\n    int32_t *src[3],  i0,  i1,  i2;\n    float   *srcf[3], i0f, i1f, i2f;\n\n    for (i = 1; i < 3; i++)\n        if (tile->codsty[0].transform != tile->codsty[i].transform) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Transforms mismatch, MCT not supported\\n\");\n            return;\n        }\n\n    for (i = 0; i < 3; i++)\n        if (tile->codsty[0].transform == FF_DWT97)\n            srcf[i] = tile->comp[i].f_data;\n        else\n            src [i] = tile->comp[i].i_data;\n\n    for (i = 0; i < 2; i++)\n        csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];\n\n    switch (tile->codsty[0].transform) {\n    case FF_DWT97:\n        for (i = 0; i < csize; i++) {\n            i0f = *srcf[0] + (f_ict_params[0] * *srcf[2]);\n            i1f = *srcf[0] - (f_ict_params[1] * *srcf[1])\n                           - (f_ict_params[2] * *srcf[2]);\n            i2f = *srcf[0] + (f_ict_params[3] * *srcf[1]);\n            *srcf[0]++ = i0f;\n            *srcf[1]++ = i1f;\n            *srcf[2]++ = i2f;\n        }\n        break;\n    case FF_DWT97_INT:\n        for (i = 0; i < csize; i++) {\n            i0 = *src[0] + (((i_ict_params[0] * *src[2]) + (1 << 15)) >> 16);\n            i1 = *src[0] - (((i_ict_params[1] * *src[1]) + (1 << 15)) >> 16)\n                         - (((i_ict_params[2] * *src[2]) + (1 << 15)) >> 16);\n            i2 = *src[0] + (((i_ict_params[3] * *src[1]) + (1 << 15)) >> 16);\n            *src[0]++ = i0;\n            *src[1]++ = i1;\n            *src[2]++ = i2;\n        }\n        break;\n    case FF_DWT53:\n        for (i = 0; i < csize; i++) {\n            i1 = *src[0] - (*src[2] + *src[1] >> 2);\n            i0 = i1 + *src[2];\n            i2 = i1 + *src[1];\n            *src[0]++ = i0;\n            *src[1]++ = i1;\n            *src[2]++ = i2;\n        }\n        break;\n    }\n}\n\nstatic int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n                                AVFrame *picture)\n{\n    int compno, reslevelno, bandno;\n    int x, y;\n\n    uint8_t *line;\n    Jpeg2000T1Context t1;\n\n    /* Loop on tile components */\n    for (compno = 0; compno < s->ncomponents; compno++) {\n        Jpeg2000Component *comp     = tile->comp + compno;\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n        /* Loop on resolution levels */\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n            /* Loop on bands */\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n                int nb_precincts, precno;\n                Jpeg2000Band *band = rlevel->band + bandno;\n                int cblkno = 0, bandpos;\n\n                bandpos = bandno + (reslevelno > 0);\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n                    band->coord[1][0] == band->coord[1][1])\n                    continue;\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n                /* Loop on precincts */\n                for (precno = 0; precno < nb_precincts; precno++) {\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n                    /* Loop on codeblocks */\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                        int x, y;\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                        decode_cblk(s, codsty, &t1, cblk,\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n                                    bandpos);\n\n                        x = cblk->coord[0][0];\n                        y = cblk->coord[1][0];\n\n                        if (codsty->transform == FF_DWT97)\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n                        else\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n                   } /* end cblk */\n                } /*end prec */\n            } /* end band */\n        } /* end reslevel */\n\n        /* inverse DWT */\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n    } /*end comp */\n\n    /* inverse MCT transformation */\n    if (tile->codsty[0].mct)\n        mct_decode(s, tile);\n\n    if (s->cdef[0] < 0) {\n        for (x = 0; x < s->ncomponents; x++)\n            s->cdef[x] = x + 1;\n        if ((s->ncomponents & 1) == 0)\n            s->cdef[s->ncomponents-1] = 0;\n    }\n\n    if (s->precision <= 8) {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            line = picture->data[plane] + y / s->cdy[compno] * picture->linesize[plane];\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint8_t *dst;\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = line + x / s->cdx[compno] * pixelsize + compno*!planar;\n\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s->cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        *dst = val << (8 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                line += picture->linesize[plane];\n            }\n        }\n    } else {\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000Component *comp = tile->comp + compno;\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            float *datap = comp->f_data;\n            int32_t *i_datap = comp->i_data;\n            uint16_t *linel;\n            int cbps = s->cbps[compno];\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n            int planar = !!picture->data[2];\n            int pixelsize = planar ? 1 : s->ncomponents;\n            int plane = 0;\n\n            if (planar)\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n            linel = (uint16_t *)picture->data[plane] + y / s->cdy[compno] * (picture->linesize[plane] >> 1);\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                uint16_t *dst;\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n                dst = linel + (x / s->cdx[compno] * pixelsize + compno*!planar);\n                if (codsty->transform == FF_DWT97) {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        /* align 12 bit values in little-endian mode */\n                        *dst = val << (16 - cbps);\n                        datap++;\n                        dst += pixelsize;\n                    }\n                } else {\n                    for (; x < w; x += s-> cdx[compno]) {\n                        int val = *i_datap + (1 << (cbps - 1));\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n                        /* align 12 bit values in little-endian mode */\n                        *dst = val << (16 - cbps);\n                        i_datap++;\n                        dst += pixelsize;\n                    }\n                }\n                linel += picture->linesize[plane] >> 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic void jpeg2000_dec_cleanup(Jpeg2000DecoderContext *s)\n{\n    int tileno, compno;\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++) {\n        if (s->tile[tileno].comp) {\n            for (compno = 0; compno < s->ncomponents; compno++) {\n                Jpeg2000Component *comp     = s->tile[tileno].comp   + compno;\n                Jpeg2000CodingStyle *codsty = s->tile[tileno].codsty + compno;\n\n                ff_jpeg2000_cleanup(comp, codsty);\n            }\n            av_freep(&s->tile[tileno].comp);\n        }\n    }\n    av_freep(&s->tile);\n    memset(s->codsty, 0, sizeof(s->codsty));\n    memset(s->qntsty, 0, sizeof(s->qntsty));\n    s->numXtiles = s->numYtiles = 0;\n}\n\nstatic int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s)\n{\n    Jpeg2000CodingStyle *codsty = s->codsty;\n    Jpeg2000QuantStyle *qntsty  = s->qntsty;\n    uint8_t *properties         = s->properties;\n\n    for (;;) {\n        int len, ret = 0;\n        uint16_t marker;\n        int oldpos;\n\n        if (bytestream2_get_bytes_left(&s->g) < 2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n            break;\n        }\n\n        marker = bytestream2_get_be16u(&s->g);\n        oldpos = bytestream2_tell(&s->g);\n\n        if (marker == JPEG2000_SOD) {\n            Jpeg2000Tile *tile;\n            Jpeg2000TilePart *tp;\n\n            if (!s->tile) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing SIZ\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->curtileno < 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing SOT\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            tile = s->tile + s->curtileno;\n            tp = tile->tile_part + tile->tp_idx;\n            if (tp->tp_end < s->g.buffer) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Invalid tpend\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            bytestream2_init(&tp->tpg, s->g.buffer, tp->tp_end - s->g.buffer);\n            bytestream2_skip(&s->g, tp->tp_end - s->g.buffer);\n\n            continue;\n        }\n        if (marker == JPEG2000_EOC)\n            break;\n\n        len = bytestream2_get_be16(&s->g);\n        if (len < 2 || bytestream2_get_bytes_left(&s->g) < len - 2)\n            return AVERROR_INVALIDDATA;\n\n        switch (marker) {\n        case JPEG2000_SIZ:\n            ret = get_siz(s);\n            if (!s->tile)\n                s->numXtiles = s->numYtiles = 0;\n            break;\n        case JPEG2000_COC:\n            ret = get_coc(s, codsty, properties);\n            break;\n        case JPEG2000_COD:\n            ret = get_cod(s, codsty, properties);\n            break;\n        case JPEG2000_QCC:\n            ret = get_qcc(s, len, qntsty, properties);\n            break;\n        case JPEG2000_QCD:\n            ret = get_qcd(s, len, qntsty, properties);\n            break;\n        case JPEG2000_SOT:\n            if (!(ret = get_sot(s, len))) {\n                av_assert1(s->curtileno >= 0);\n                codsty = s->tile[s->curtileno].codsty;\n                qntsty = s->tile[s->curtileno].qntsty;\n                properties = s->tile[s->curtileno].properties;\n            }\n            break;\n        case JPEG2000_COM:\n            // the comment is ignored\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        case JPEG2000_TLM:\n            // Tile-part lengths\n            ret = get_tlm(s, len);\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"unsupported marker 0x%.4X at pos 0x%X\\n\",\n                   marker, bytestream2_tell(&s->g) - 4);\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        }\n        if (bytestream2_tell(&s->g) - oldpos != len || ret) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"error during processing marker segment %.4x\\n\", marker);\n            return ret ? ret : -1;\n        }\n    }\n    return 0;\n}\n\n/* Read bit stream packets --> T2 operation. */\nstatic int jpeg2000_read_bitstream_packets(Jpeg2000DecoderContext *s)\n{\n    int ret = 0;\n    int tileno;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++) {\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (ret = init_tile(s, tileno))\n            return ret;\n\n        s->g = tile->tile_part[0].tpg;\n        if (ret = jpeg2000_decode_packets(s, tile))\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int jp2_find_codestream(Jpeg2000DecoderContext *s)\n{\n    uint32_t atom_size, atom, atom_end;\n    int search_range = 10;\n\n    while (search_range\n           &&\n           bytestream2_get_bytes_left(&s->g) >= 8) {\n        atom_size = bytestream2_get_be32u(&s->g);\n        atom      = bytestream2_get_be32u(&s->g);\n        atom_end  = bytestream2_tell(&s->g) + atom_size - 8;\n\n        if (atom == JP2_CODESTREAM)\n            return 1;\n\n        if (bytestream2_get_bytes_left(&s->g) < atom_size || atom_end < atom_size)\n            return 0;\n\n        if (atom == JP2_HEADER &&\n                   atom_size >= 16) {\n            uint32_t atom2_size, atom2, atom2_end;\n            do {\n                atom2_size = bytestream2_get_be32u(&s->g);\n                atom2      = bytestream2_get_be32u(&s->g);\n                atom2_end  = bytestream2_tell(&s->g) + atom2_size - 8;\n                if (atom2_size < 8 || atom2_end > atom_end || atom2_end < atom2_size)\n                    break;\n                if (atom2 == JP2_CODESTREAM) {\n                    return 1;\n                } else if (atom2 == MKBETAG('c','o','l','r') && atom2_size >= 7) {\n                    int method = bytestream2_get_byteu(&s->g);\n                    bytestream2_skipu(&s->g, 2);\n                    if (method == 1) {\n                        s->colour_space = bytestream2_get_be32u(&s->g);\n                    }\n                } else if (atom2 == MKBETAG('p','c','l','r') && atom2_size >= 6) {\n                    int i, size, colour_count, colour_channels, colour_depth[3];\n                    uint32_t r, g, b;\n                    colour_count = bytestream2_get_be16u(&s->g);\n                    colour_channels = bytestream2_get_byteu(&s->g);\n                    // FIXME: Do not ignore channel_sign\n                    colour_depth[0] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[1] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    colour_depth[2] = (bytestream2_get_byteu(&s->g) & 0x7f) + 1;\n                    size = (colour_depth[0] + 7 >> 3) * colour_count +\n                           (colour_depth[1] + 7 >> 3) * colour_count +\n                           (colour_depth[2] + 7 >> 3) * colour_count;\n                    if (colour_count > 256   ||\n                        colour_channels != 3 ||\n                        colour_depth[0] > 16 ||\n                        colour_depth[1] > 16 ||\n                        colour_depth[2] > 16 ||\n                        atom2_size < size) {\n                        avpriv_request_sample(s->avctx, \"Unknown palette\");\n                        bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n                        continue;\n                    }\n                    s->pal8 = 1;\n                    for (i = 0; i < colour_count; i++) {\n                        if (colour_depth[0] <= 8) {\n                            r = bytestream2_get_byteu(&s->g) << 8 - colour_depth[0];\n                            r |= r >> colour_depth[0];\n                        } else {\n                            r = bytestream2_get_be16u(&s->g) >> colour_depth[0] - 8;\n                        }\n                        if (colour_depth[1] <= 8) {\n                            g = bytestream2_get_byteu(&s->g) << 8 - colour_depth[1];\n                            r |= r >> colour_depth[1];\n                        } else {\n                            g = bytestream2_get_be16u(&s->g) >> colour_depth[1] - 8;\n                        }\n                        if (colour_depth[2] <= 8) {\n                            b = bytestream2_get_byteu(&s->g) << 8 - colour_depth[2];\n                            r |= r >> colour_depth[2];\n                        } else {\n                            b = bytestream2_get_be16u(&s->g) >> colour_depth[2] - 8;\n                        }\n                        s->palette[i] = 0xffu << 24 | r << 16 | g << 8 | b;\n                    }\n                } else if (atom2 == MKBETAG('c','d','e','f') && atom2_size >= 2) {\n                    int n = bytestream2_get_be16u(&s->g);\n                    for (; n>0; n--) {\n                        int cn   = bytestream2_get_be16(&s->g);\n                        int av_unused typ  = bytestream2_get_be16(&s->g);\n                        int asoc = bytestream2_get_be16(&s->g);\n                        if (cn < 4 || asoc < 4)\n                            s->cdef[cn] = asoc;\n                    }\n                }\n                bytestream2_seek(&s->g, atom2_end, SEEK_SET);\n            } while (atom_end - atom2_end >= 8);\n        } else {\n            search_range--;\n        }\n        bytestream2_seek(&s->g, atom_end, SEEK_SET);\n    }\n\n    return 0;\n}\n\nstatic int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,\n                                 int *got_frame, AVPacket *avpkt)\n{\n    Jpeg2000DecoderContext *s = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    int tileno, ret;\n\n    s->avctx     = avctx;\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n    s->curtileno = -1;\n    memset(s->cdef, -1, sizeof(s->cdef));\n\n    if (bytestream2_get_bytes_left(&s->g) < 2) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    // check if the image is in jp2 format\n    if (bytestream2_get_bytes_left(&s->g) >= 12 &&\n       (bytestream2_get_be32u(&s->g) == 12) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_TYPE) &&\n       (bytestream2_get_be32u(&s->g) == JP2_SIG_VALUE)) {\n        if (!jp2_find_codestream(s)) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Could not find Jpeg2000 codestream atom.\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto end;\n        }\n    } else {\n        bytestream2_seek(&s->g, 0, SEEK_SET);\n    }\n\n    while (bytestream2_get_bytes_left(&s->g) >= 3 && bytestream2_peek_be16(&s->g) != JPEG2000_SOC)\n        bytestream2_skip(&s->g, 1);\n\n    if (bytestream2_get_be16u(&s->g) != JPEG2000_SOC) {\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    if (ret = jpeg2000_read_main_headers(s))\n        goto end;\n\n    /* get picture buffer */\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        goto end;\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    picture->key_frame = 1;\n\n    if (ret = jpeg2000_read_bitstream_packets(s))\n        goto end;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n            goto end;\n\n    jpeg2000_dec_cleanup(s);\n\n    *got_frame = 1;\n\n    if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n        memcpy(picture->data[1], s->palette, 256 * sizeof(uint32_t));\n\n    return bytestream2_tell(&s->g);\n\nend:\n    jpeg2000_dec_cleanup(s);\n    return ret;\n}\n\nstatic void jpeg2000_init_static_data(AVCodec *codec)\n{\n    ff_jpeg2000_init_tier1_luts();\n    ff_mqc_init_context_tables();\n}\n\n#define OFFSET(x) offsetof(Jpeg2000DecoderContext, x)\n#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\n\nstatic const AVOption options[] = {\n    { \"lowres\",  \"Lower the decoding resolution by a power of two\",\n        OFFSET(reduction_factor), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, JPEG2000_MAX_RESLEVELS - 1, VD },\n    { NULL },\n};\n\nstatic const AVProfile profiles[] = {\n    { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0,  \"JPEG 2000 codestream restriction 0\"   },\n    { FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1,  \"JPEG 2000 codestream restriction 1\"   },\n    { FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION, \"JPEG 2000 no codestream restrictions\" },\n    { FF_PROFILE_JPEG2000_DCINEMA_2K,             \"JPEG 2000 digital cinema 2K\"          },\n    { FF_PROFILE_JPEG2000_DCINEMA_4K,             \"JPEG 2000 digital cinema 4K\"          },\n    { FF_PROFILE_UNKNOWN },\n};\n\nstatic const AVClass jpeg2000_class = {\n    .class_name = \"jpeg2000\",\n    .item_name  = av_default_item_name,\n    .option     = options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_jpeg2000_decoder = {\n    .name             = \"jpeg2000\",\n    .long_name        = NULL_IF_CONFIG_SMALL(\"JPEG 2000\"),\n    .type             = AVMEDIA_TYPE_VIDEO,\n    .id               = AV_CODEC_ID_JPEG2000,\n    .capabilities     = CODEC_CAP_FRAME_THREADS,\n    .priv_data_size   = sizeof(Jpeg2000DecoderContext),\n    .init_static_data = jpeg2000_init_static_data,\n    .decode           = jpeg2000_decode_frame,\n    .priv_class       = &jpeg2000_class,\n    .max_lowres       = 5,\n    .profiles         = NULL_IF_CONFIG_SMALL(profiles)\n};\n"], "filenames": ["libavcodec/jpeg2000dec.c"], "buggy_code_start_loc": [1281], "buggy_code_end_loc": [1333], "fixing_code_start_loc": [1281], "fixing_code_end_loc": [1333], "type": "CWE-119", "message": "The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not consider the component number in certain calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data.", "other": {"cve": {"id": "CVE-2013-7024", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:50.223", "lastModified": "2016-12-03T03:00:48.833", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not consider the component number in certain calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data."}, {"lang": "es", "value": "La funci\u00f3n jpeg2000_decode_tile en libavcodec/jpeg2000dec.c en FFmpeg anterior a v2.1 no tiene en cuenta el n\u00famero de componente en ciertos c\u00e1lculos, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (acceso a array fuera de rango) o posiblemente otro impacto no especificado a trav\u00e9s de informaci\u00f3n JPEG2000 manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/fe448cd28d674c3eff3072552eae366d0b659ce9", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}, {"url": "https://trac.ffmpeg.org/ticket/2921", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/fe448cd28d674c3eff3072552eae366d0b659ce9"}}