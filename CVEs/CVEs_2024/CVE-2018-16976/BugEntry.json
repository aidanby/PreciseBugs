{"buggy_code": ["#!/usr/bin/perl\n\n# gitolite shell, invoked from ~/.ssh/authorized_keys\n# ----------------------------------------------------------------------\n\nuse FindBin;\n\nBEGIN { $ENV{GL_BINDIR} = $FindBin::RealBin; }\nBEGIN { $ENV{GL_LIBDIR} = \"$ENV{GL_BINDIR}/lib\"; }\nuse lib $ENV{GL_LIBDIR};\n\n# set HOME\nBEGIN { $ENV{HOME} = $ENV{GITOLITE_HTTP_HOME} if $ENV{GITOLITE_HTTP_HOME}; }\n\nuse Gitolite::Rc;\nuse Gitolite::Common;\nuse Gitolite::Conf::Load;\n\nuse strict;\nuse warnings;\n\n# the main() sub expects ssh-ish things; set them up...\nmy $id = '';\nif ( exists $ENV{G3T_USER} ) {\n    $id = in_file();    # file:// masquerading as ssh:// for easy testing\n} elsif ( exists $ENV{SSH_CONNECTION} ) {\n    $id = in_ssh();\n} elsif ( exists $ENV{REQUEST_URI} ) {\n    $id = in_http();\n} else {\n    _die \"who the *heck* are you?\";\n}\n\n# sanity...\nmy $soc = $ENV{SSH_ORIGINAL_COMMAND};\n$soc =~ s/[\\n\\r]+/<<newline>>/g;\n_die \"I don't like newlines in the command: '$soc'\\n\" if $ENV{SSH_ORIGINAL_COMMAND} ne $soc;\n\n# allow gitolite-shell to be used as \"$SHELL\".  Experts only; no support, no docs\nif (@ARGV and $ARGV[0] eq '-c') {\n    shift;\n    $ARGV[0] =~ s/^$0 // or _die \"unknown git/gitolite command: '$ARGV[0]'\";\n}\n\n# the INPUT trigger massages @ARGV and $ENV{SSH_ORIGINAL_COMMAND} as needed\ntrigger('INPUT');\n\nmain($id);\n\ngl_log('END') if $$ == $ENV{GL_TID};\n\nexit 0;\n\n# ----------------------------------------------------------------------\n\nsub in_file {\n    gl_log( 'file', \"ARGV=\" . join( \",\", @ARGV ), \"SOC=$ENV{SSH_ORIGINAL_COMMAND}\" );\n\n    if ( $ENV{SSH_ORIGINAL_COMMAND} =~ /git-\\w+-pack/ ) {\n        print STDERR \"TRACE: gsh(\", join( \")(\", @ARGV ), \")\\n\";\n        print STDERR \"TRACE: gsh(SOC=$ENV{SSH_ORIGINAL_COMMAND})\\n\";\n    }\n    return 'file';\n}\n\nsub in_http {\n    http_setup_die_handler();\n\n    _die \"GITOLITE_HTTP_HOME not set\" unless $ENV{GITOLITE_HTTP_HOME};\n\n    _die \"fallback to DAV not supported\" if $ENV{REQUEST_METHOD} eq 'PROPFIND';\n\n    # fake out SSH_ORIGINAL_COMMAND and SSH_CONNECTION when called via http,\n    # so the rest of the code stays the same (except the exec at the end).\n    http_simulate_ssh_connection();\n    $ENV{SSH_ORIGINAL_COMMAND} ||= '';\n\n    $ENV{REMOTE_USER} ||= $rc{HTTP_ANON_USER};\n    @ARGV = ( $ENV{REMOTE_USER} );\n\n    my $ip;\n    ( $ip = $ENV{SSH_CONNECTION} || '(no-IP)' ) =~ s/ .*//;\n\n    gl_log( 'http', \"ARGV=\" . join( \",\", @ARGV ), \"SOC=\" . ( $ENV{SSH_ORIGINAL_COMMAND} || '' ), \"FROM=$ip\" );\n\n    return 'http';\n}\n\nsub in_ssh {\n    my $ip;\n    ( $ip = $ENV{SSH_CONNECTION} || '(no-IP)' ) =~ s/ .*//;\n\n    gl_log( 'ssh', \"ARGV=\" . join( \",\", @ARGV ), \"SOC=\" . ( $ENV{SSH_ORIGINAL_COMMAND} || '' ), \"FROM=$ip\" );\n\n    $ENV{SSH_ORIGINAL_COMMAND} ||= '';\n\n    return $ip;\n}\n\n# ----------------------------------------------------------------------\n\n# call this once you are sure arg-1 is the username and SSH_ORIGINAL_COMMAND\n# has been setup (even if it's not actually coming via ssh).\nsub main {\n    my $id = shift;\n\n    # set up the user\n    my $user = $ENV{GL_USER} = shift @ARGV;\n\n    # set up the repo and the attempted access\n    my ( $verb, $repo ) = parse_soc();    # returns only for git commands\n    Gitolite::Conf::Load::sanity($repo, $REPONAME_PATT);\n    $ENV{GL_REPO} = $repo;\n    my $aa = ( $verb =~ 'upload' ? 'R' : 'W' );\n\n    # set up env vars from options set for this repo\n    env_options($repo);\n\n    # auto-create?\n    if ( repo_missing($repo) and access( $repo, $user, '^C', 'any' ) !~ /DENIED/ ) {\n        require Gitolite::Conf::Store;\n        Gitolite::Conf::Store->import;\n        new_wild_repo( $repo, $user, $aa );\n        gl_log( 'create', $repo, $user, $aa );\n    }\n\n    # a ref of 'any' signifies that this is a pre-git check, where we don't\n    # yet know the ref that will be eventually pushed (and even that won't\n    # apply if it's a read operation).  See the matching code in access() for\n    # more information.\n    unless ( $ENV{GL_BYPASS_ACCESS_CHECKS} ) {\n        my $ret = access( $repo, $user, $aa, 'any' );\n        trigger( 'ACCESS_1', $repo, $user, $aa, 'any', $ret );\n        _die $ret . \"\\n(or you mis-spelled the reponame)\" if $ret =~ /DENIED/;\n\n        gl_log( \"pre_git\", $repo, $user, $aa, 'any', $ret );\n    }\n\n    trigger( 'PRE_GIT', $repo, $user, $aa, 'any', $verb );\n    if ( $ENV{REQUEST_URI} ) {\n        _system( \"git\", \"http-backend\" );\n    } else {\n        my $repodir = \"'$rc{GL_REPO_BASE}/$repo.git'\";\n        _system( \"git\", \"shell\", \"-c\", \"$verb $repodir\" );\n    }\n    trigger( 'POST_GIT', $repo, $user, $aa, 'any', $verb );\n}\n\n# ----------------------------------------------------------------------\n\nsub parse_soc {\n    my $soc = $ENV{SSH_ORIGINAL_COMMAND};\n    $soc ||= 'info';\n\n    my $git_commands = \"git-upload-pack|git-receive-pack|git-upload-archive\";\n    # simplify the regex; we'll handle all the reponame nuances later\n    if ( $soc =~ m(^($git_commands) '?/?(.*?)'?$) ) {\n        my ( $verb, $repo ) = ( $1, $2 );\n        trace( 2, \"git command\", $soc );\n\n        # clean up the repo name; first extract the trace level if supplied\n        # (and no, you can't have a trace level *and* a trailing slash).\n        $ENV{D} = $1 if $repo =~ s/\\.git(\\d)$//;\n        # and then the git-daemon-compatibility trailers\n        $repo =~ s(/$)();\n        $repo =~ s(\\.git$)();\n\n        _die \"invalid repo name: '$repo'\" if $repo !~ $REPONAME_PATT;\n        return ( $verb, $repo );\n    }\n\n    # after this we should not return; caller expects us to handle it all here\n    # and exit out\n\n    my @words = split ' ', $soc;\n    if ( $rc{COMMANDS}{ $words[0] } ) {\n        if ( $rc{COMMANDS}{ $words[0] } ne 'ua' ) {\n            _die \"suspicious characters loitering about '$soc'\" if $soc !~ $REMOTE_COMMAND_PATT;\n            _die \"no relative paths allowed anywhere!\" if $soc =~ m(\\.\\./);\n        }\n        trace( 2, \"gitolite command\", $soc );\n        _system( \"gitolite\", @words );\n        exit 0;\n    }\n\n    _die \"unknown git/gitolite command: '$soc'\";\n}\n\n# ----------------------------------------------------------------------\n# helper functions for \"in_http\"\n\nsub http_setup_die_handler {\n\n    $SIG{__DIE__} = sub {\n        my $service = ( $ENV{SSH_ORIGINAL_COMMAND} =~ /git-receive-pack/ ? 'git-receive-pack' : 'git-upload-pack' );\n        my $message = shift; chomp($message);\n        print STDERR \"$message\\n\";\n\n        http_print_headers($service);\n\n        # format the service response, then the message.  With initial\n        # help from Ilari and then a more detailed email from Shawn...\n        $service = \"# service=$service\\n\"; $message = \"ERR $message\\n\";\n        $service = sprintf( \"%04X\", length($service) + 4 ) . \"$service\";    # no CRLF on this one\n        $message = sprintf( \"%04X\", length($message) + 4 ) . \"$message\";\n\n        print $service;\n        print \"0000\";                                                       # flush-pkt, apparently\n        print $message;\n        print STDERR $service;\n        print STDERR $message;\n        exit 0;                                                             # if it's ok for die_webcgi in git.git/http-backend.c, it's ok for me ;-)\n      }\n}\n\nsub http_simulate_ssh_connection {\n    # these patterns indicate normal git usage; see \"services[]\" in\n    # http-backend.c for how I got that.  Also note that \"info\" is overloaded;\n    # git uses \"info/refs...\", while gitolite uses \"info\" or \"info?...\".  So\n    # there's a \"/\" after info in the list below\n    if ( $ENV{PATH_INFO} =~ m(^/(.*)/(HEAD$|info/refs$|objects/|git-(?:upload|receive)-pack$)) ) {\n        my $repo = $1;\n        my $verb = ( $ENV{REQUEST_URI} =~ /git-receive-pack/ ) ? 'git-receive-pack' : 'git-upload-pack';\n        $ENV{SSH_ORIGINAL_COMMAND} = \"$verb '$repo'\";\n    } else {\n        # this is one of our custom commands; could be anything really,\n        # because of the adc feature\n        my ($verb) = ( $ENV{PATH_INFO} =~ m(^/(\\S+)) );\n        my $args = $ENV{QUERY_STRING};\n        $args =~ s/\\+/ /g;\n        $args =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;\n        $ENV{SSH_ORIGINAL_COMMAND} = $verb;\n        $ENV{SSH_ORIGINAL_COMMAND} .= \" $args\" if $args;\n        http_print_headers();    # in preparation for the eventual output!\n\n        # we also need to pipe STDERR out via STDOUT, else the user doesn't see those messages!\n        open(STDERR, \">&STDOUT\") or _die \"Can't dup STDOUT: $!\";\n    }\n    $ENV{SSH_CONNECTION} = \"$ENV{REMOTE_ADDR} $ENV{REMOTE_PORT} $ENV{SERVER_ADDR} $ENV{SERVER_PORT}\";\n}\n\nmy $http_headers_printed = 0;\n\nsub http_print_headers {\n    my ( $service, $code, $text ) = @_;\n\n    return if $http_headers_printed++;\n    $code ||= 200;\n    $text ||= \"OK - gitolite\";\n\n    $|++;\n    print \"Status: $code $text\\r\\n\";\n    print \"Expires: Fri, 01 Jan 1980 00:00:00 GMT\\r\\n\";\n    print \"Pragma: no-cache\\r\\n\";\n    print \"Cache-Control: no-cache, max-age=0, must-revalidate\\r\\n\";\n    if ($service) {\n        print \"Content-Type: application/x-$service-advertisement\\r\\n\";\n    } else {\n        print \"Content-Type: text/plain\\r\\n\";\n    }\n    print \"\\r\\n\";\n}\n", "package Gitolite::Common;\n\n# common (non-gitolite-specific) functions\n# ----------------------------------------------------------------------\n\n#<<<\n@EXPORT = qw(\n  print2  dbg     _mkdir  _open   ln_sf     tsh_rc      sort_u\n  say     _warn   _chdir  _print            tsh_text    list_phy_repos\n  say2    _die    _system slurp             tsh_lines\n          trace           cleanup_conf_line tsh_try\n          usage                             tsh_run\n          gen_lfn\n          gl_log\n\n          dd\n          t_start\n          t_lap\n\n          ssh_fingerprint_file\n          ssh_fingerprint_line\n);\n#>>>\nuse Exporter 'import';\nuse File::Path qw(mkpath);\nuse File::Temp qw(tempfile);\nuse Carp qw(carp cluck croak confess);\n\nuse strict;\nuse warnings;\n\n# ----------------------------------------------------------------------\n\nsub print2 {\n    local $/ = \"\\n\";\n    print STDERR @_;\n}\n\nsub say {\n    local $/ = \"\\n\";\n    print @_, \"\\n\";\n}\n\nsub say2 {\n    local $/ = \"\\n\";\n    print STDERR @_, \"\\n\";\n}\n\nsub trace {\n    gl_log( \"\\t\" . join( \",\", @_[ 1 .. $#_ ] ) ) if $_[0] <= 1 and defined $Gitolite::Rc::rc{LOG_EXTRA};\n\n    return unless defined( $ENV{D} );\n\n    my $level = shift; return if $ENV{D} < $level;\n    my $sub = ( caller 1 )[3] || ''; $sub =~ s/.*://;\n    if ( not $sub ) {\n        $sub = (caller)[1];\n        $sub =~ s(.*/(.*))(($1));\n    }\n    $sub .= ' ' x ( 31 - length($sub) );\n    say2 \"$level\\t$sub\\t\", join( \"\\t\", @_ );\n}\n\nsub dbg {\n    use Data::Dumper;\n    return unless defined( $ENV{D} );\n    for my $i (@_) {\n        print STDERR \"DBG: \" . Dumper($i);\n    }\n}\n\nsub dd {\n    local $ENV{D} = 1;\n    dbg(@_);\n}\n\n{\n    my %start_times;\n\n    eval \"require Time::HiRes\";\n    # we just ignore any errors from this; nothing needs to be done as long as\n    # no code *calls* either of the next two functions.\n\n    sub t_start {\n        my $name = shift || 'default';\n        $start_times{$name} = [ Time::HiRes::gettimeofday() ];\n    }\n\n    sub t_lap {\n        my $name = shift || 'default';\n        return Time::HiRes::tv_interval( $start_times{$name} );\n    }\n}\n\nsub _warn {\n    gl_log( 'warn', @_ );\n    if ( $ENV{D} and $ENV{D} >= 3 ) {\n        cluck \"WARNING: \", @_, \"\\n\";\n    } elsif ( defined( $ENV{D} ) ) {\n        carp \"WARNING: \", @_, \"\\n\";\n    } else {\n        warn \"WARNING: \", @_, \"\\n\";\n    }\n}\n$SIG{__WARN__} = \\&_warn;\n\nsub _die {\n    gl_log( 'die', @_ );\n    if ( $ENV{D} and $ENV{D} >= 3 ) {\n        confess \"FATAL: \" . join( \",\", @_ ) . \"\\n\" if defined( $ENV{D} );\n    } elsif ( defined( $ENV{D} ) ) {\n        croak \"FATAL: \" . join( \",\", @_ ) . \"\\n\";\n    } else {\n        die \"FATAL: \" . join( \",\", @_ ) . \"\\n\";\n    }\n}\n$SIG{__DIE__} = \\&_die;\n\nsub usage {\n    my $script = (caller)[1];\n    my $function = shift if @_ and $_[0] =~ /^[\\w-]+$/;\n    $function ||= ( ( ( caller(1) )[3] ) || ( ( caller(0) )[3] ) );\n    $function =~ s/.*:://;\n    my $code = slurp($script);\n    $code =~ /^=for $function\\b(.*?)^=cut/sm;\n    say( $1 ? $1 : \"...no usage message for '$function' in $script\" );\n    exit 1;\n}\n\nsub _mkdir {\n    # It's not an error if the directory exists, but it is an error if it\n    # doesn't exist and we can't create it. This includes not guaranteeing\n    # dead symlinks or if mkpath traversal is blocked by a file.\n    my $dir  = shift;\n    my $perm = shift;    # optional\n    return if -d $dir;\n    mkpath($dir);\n    chmod $perm, $dir if $perm;\n    return 1;\n}\n\nsub _chdir {\n    chdir( $_[0] || $ENV{HOME} ) or _die \"chdir $_[0] failed: $!\\n\";\n}\n\nsub _system {\n    # run system(), catch errors.  Be verbose only if $ENV{D} exists.  If not,\n    # exit with <rc of system()> if it applies, else just \"exit 1\".\n    trace( 1, 'system', @_ );\n    if ( system(@_) != 0 ) {\n        trace( 1, \"system() failed\", @_, \"-> $?\" );\n        if ( $? == -1 ) {\n            die \"failed to execute: $!\\n\" if $ENV{D};\n        } elsif ( $? & 127 ) {\n            die \"child died with signal \" . ( $? & 127 ) . \"\\n\" if $ENV{D};\n        } else {\n            die \"child exited with value \" . ( $? >> 8 ) . \"\\n\" if $ENV{D};\n            exit( $? >> 8 );\n        }\n        exit 1;\n    }\n}\n\nsub _open {\n    open( my $fh, $_[0], $_[1] ) or _die \"open $_[1] failed: $!\\n\";\n    return $fh;\n}\n\nsub _print {\n    my ( $file, @text ) = @_;\n    my $fh = _open( \">\", \"$file.$$\" );\n    print $fh @text;\n    close($fh) or _die \"close $file failed: $! at \", (caller)[1], \" line \", (caller)[2], \"\\n\";\n    my $oldmode = ( ( stat $file )[2] );\n    rename \"$file.$$\", $file;\n    chmod $oldmode, $file if $oldmode;\n}\n\nsub slurp {\n    return unless defined wantarray;\n    local $/ = undef unless wantarray;\n    my $fh = _open( \"<\", $_[0] );\n    return <$fh>;\n}\n\nsub dos2unix {\n    # WARNING: when calling this, make sure you supply a list context\n    s/\\r\\n/\\n/g for @_;\n    return @_;\n}\n\nsub ln_sf {\n    trace( 3, @_ );\n    my ( $srcdir, $glob, $dstdir ) = @_;\n    for my $hook ( glob(\"$srcdir/$glob\") ) {\n        $hook =~ s/$srcdir\\///;\n        unlink \"$dstdir/$hook\";\n        symlink \"$srcdir/$hook\", \"$dstdir/$hook\" or croak \"could not symlink $srcdir/$hook to $dstdir\\n\";\n    }\n}\n\nsub sort_u {\n    my %uniq;\n    my $listref = shift;\n    return [] unless @{$listref};\n    undef @uniq{ @{$listref} };    # expect a listref\n    my @sort_u = sort keys %uniq;\n    return \\@sort_u;\n}\n\nsub cleanup_conf_line {\n    my $line = shift;\n    return $line if $line =~ /^# \\S+ \\d+$/;\n\n    # kill comments, but take care of \"#\" inside *simple* strings\n    $line =~ s/^((\".*?\"|[^#\"])*)#.*/$1/;\n    # normalise whitespace; keeps later regexes very simple\n    $line =~ s/=/ = /;\n    $line =~ s/\\s+/ /g;\n    $line =~ s/^ //;\n    $line =~ s/ $//;\n    return $line;\n}\n\n{\n    my @phy_repos = ();\n\n    sub list_phy_repos {\n        # use cached value only if it exists *and* no arg was received (i.e.,\n        # receiving *any* arg invalidates cache)\n        return \\@phy_repos if ( @phy_repos and not @_ );\n\n        my $cmd = 'find . ' . ($Gitolite::Rc::rc{REPO_SYMLINKS} || '') . ' -name \"*.git\" -prune';\n        for my $repo (`$cmd`) {\n            chomp($repo);\n            $repo =~ s/\\.git$//;\n            $repo =~ s(^\\./)();\n            push @phy_repos, $repo unless $repo =~ m(/$);\n                # tolerate bare repos within ~/repositories but silently ignore them\n        }\n        trace( 3, scalar(@phy_repos) . \" physical repos found\" );\n        return sort_u( \\@phy_repos );\n    }\n}\n\n# generate a timestamp\nsub gen_ts {\n    my ( $s, $min, $h, $d, $m, $y ) = (localtime)[ 0 .. 5 ];\n    $y += 1900; $m++;    # usual adjustments\n    for ( $s, $min, $h, $d, $m ) {\n        $_ = \"0$_\" if $_ < 10;\n    }\n    my $ts = \"$y-$m-$d.$h:$min:$s\";\n\n    return $ts;\n}\n\n# generate a log file name\nsub gen_lfn {\n    my ( $s, $min, $h, $d, $m, $y ) = (localtime)[ 0 .. 5 ];\n    $y += 1900; $m++;    # usual adjustments\n    for ( $s, $min, $h, $d, $m ) {\n        $_ = \"0$_\" if $_ < 10;\n    }\n\n    my ($template) = shift;\n    # substitute template parameters and set the logfile name\n    $template =~ s/%y/$y/g;\n    $template =~ s/%m/$m/g;\n    $template =~ s/%d/$d/g;\n\n    return $template;\n}\n\nmy $log_dest;\nmy $syslog_opened = 0;\nEND { closelog() if $syslog_opened; }\nsub gl_log {\n    # the log filename and the timestamp come from the environment.  If we get\n    # called even before they are set, we have no choice but to dump to STDERR\n    # (and probably call \"logger\").\n\n    # tab sep if there's more than one field\n    my $msg = join( \"\\t\", @_ );\n    $msg =~ s/[\\n\\r]+/<<newline>>/g;\n\n    my $ts = gen_ts();\n    my $tid = $ENV{GL_TID} ||= $$;\n\n    $log_dest = $Gitolite::Rc::rc{LOG_DEST} || '' if not defined $log_dest;\n\n    # log (update records only) to \"gl-log\" in the bare repo dir; this is to\n    # make 'who-pushed' more efficient.  Since this is only for the update\n    # records, it is not a replacement for the other two types of logging.\n    if ($log_dest =~ /repo-log/ and $_[0] eq 'update') {\n        # if the log line is 'update', we're already in the bare repo dir\n        open my $lfh, \">>\", \"gl-log\" or _die \"open gl-log failed: $!\";\n        print $lfh \"$ts\\t$tid\\t$msg\\n\";\n        close $lfh;\n    }\n\n    # syslog\n    if ($log_dest =~ /syslog/) {            # log_dest *includes* syslog\n        if ($syslog_opened == 0) {\n            require Sys::Syslog;\n            Sys::Syslog->import(qw(:standard));\n\n            openlog(\"gitolite\" . ( $ENV{GL_TID} ? \"[$ENV{GL_TID}]\" : \"\" ), \"pid\", $Gitolite::Rc::rc{LOG_FACILITY} || 'local0');\n            $syslog_opened = 1;\n        }\n\n        # gl_log is called either directly, or, if the rc variable LOG_EXTRA\n        # is set, from trace(1, ...).  The latter use is considered additional\n        # info for troubleshooting.  Trace prefixes a tab to the arguments\n        # before calling gl_log, to visually set off such lines in the log\n        # file.  Although syslog eats up that leading tab, we use it to decide\n        # the priority/level of the syslog message.\n        syslog( ( $msg =~ /^\\t/ ? 'debug' : 'info' ), \"%s\", $msg);\n\n        return if $log_dest !~ /normal/;\n    }\n\n    my $fh;\n    logger_plus_stderr( \"errors found before logging could be setup\", \"$msg\" ) if not $ENV{GL_LOGFILE};\n    open my $lfh, \">>\", $ENV{GL_LOGFILE}\n      or logger_plus_stderr( \"errors found but logfile could not be created\", \"$ENV{GL_LOGFILE}: $!\", \"$msg\" );\n    print $lfh \"$ts\\t$tid\\t$msg\\n\";\n    close $lfh;\n}\n\nsub logger_plus_stderr {\n    open my $fh, \"|-\", \"logger\" or confess \"it's really not my day is it...?\\n\";\n    for (@_) {\n        print STDERR \"FATAL: $_\\n\";\n        print $fh \"FATAL: $_\\n\";\n    }\n    exit 1;\n}\n\n# ----------------------------------------------------------------------\n# Get the SSH fingerprint of a file\n# If the fingerprint cannot be parsed, it will be undef\n# In a scalar context, returns the fingerprint\n# In a list context, returns (fingerprint, output) where output\n# is the raw output of the ssh-keygen command\nsub ssh_fingerprint_file {\n    my $in = shift;\n    -f $in or die \"file not found: $in\\n\";\n    my $fh;\n    open( $fh, \"ssh-keygen -l -f $in |\" ) or die \"could not fork: $!\\n\";\n    my $output = <$fh>;\n    chomp $output;\n    # dbg(\"fp = $fp\");\n    close $fh;\n    # Return a valid fingerprint or undef\n    my $fp = undef;\n    if($output =~ /((?:MD5:)?(?:[0-9a-f]{2}:){15}[0-9a-f]{2})/i or\n       $output =~ m{((?:RIPEMD|SHA)\\d+:[A-Za-z0-9+/=]+)}i) {\n        $fp = $1;\n    }\n    return wantarray ? ($fp, $output) : $fp;\n}\n\n# Get the SSH fingerprint of a line of text\n# If the fingerprint cannot be parsed, it will be undef\n# In a scalar context, returns the fingerprint\n# In a list context, returns (fingerprint, output) where output\n# is the raw output of the ssh-keygen command\nsub ssh_fingerprint_line {\n    my ( $fh, $fn ) = tempfile();\n    print $fh shift() . \"\\n\";\n    close $fh;\n    my ($fp,$output) = ssh_fingerprint_file($fn);\n    unlink $fn;\n    return wantarray ? ($fp,$output) : $fp;\n}\n\n# ----------------------------------------------------------------------\n\n# bare-minimum subset of 'Tsh' (see github.com/sitaramc/tsh)\n{\n    my ( $rc, $text );\n    sub tsh_rc   { return $rc   || 0; }\n    sub tsh_text { return $text || ''; }\n    sub tsh_lines { return split /\\n/, $text; }\n\n    sub tsh_try {\n        my $cmd = shift; die \"try: expects only one argument\" if @_;\n        $text = `( $cmd ) 2>&1; printf RC=\\$?`;\n        if ( $text =~ s/RC=(\\d+)$// ) {\n            $rc = $1;\n            trace( 3, $text );\n            return ( not $rc );\n        }\n        die \"couldnt find RC= in result; this should not happen:\\n$text\\n\\n...\\n\";\n    }\n\n    sub tsh_run {\n        open( my $fh, \"-|\", @_ ) or die \"popen failed: $!\";\n        local $/ = undef; $text = <$fh>;\n        close $fh; warn \"pclose failed: $!\" if $!;\n        $rc = ( $? >> 8 );\n        trace( 3, $text );\n        return $text;\n    }\n}\n\n1;\n"], "fixing_code": ["#!/usr/bin/perl\n\n# gitolite shell, invoked from ~/.ssh/authorized_keys\n# ----------------------------------------------------------------------\n\nuse FindBin;\n\nBEGIN { $ENV{GL_BINDIR} = $FindBin::RealBin; }\nBEGIN { $ENV{GL_LIBDIR} = \"$ENV{GL_BINDIR}/lib\"; }\nuse lib $ENV{GL_LIBDIR};\n\n# set HOME\nBEGIN { $ENV{HOME} = $ENV{GITOLITE_HTTP_HOME} if $ENV{GITOLITE_HTTP_HOME}; }\n\nuse Gitolite::Rc;\nuse Gitolite::Common;\nuse Gitolite::Conf::Load;\n\nuse strict;\nuse warnings;\n\n# the main() sub expects ssh-ish things; set them up...\nmy $id = '';\nif ( exists $ENV{G3T_USER} ) {\n    $id = in_file();    # file:// masquerading as ssh:// for easy testing\n} elsif ( exists $ENV{SSH_CONNECTION} ) {\n    $id = in_ssh();\n} elsif ( exists $ENV{REQUEST_URI} ) {\n    $id = in_http();\n} else {\n    _die \"who the *heck* are you?\";\n}\n\n# sanity...\nmy $soc = $ENV{SSH_ORIGINAL_COMMAND};\n$soc =~ s/[\\n\\r]+/<<newline>>/g;\n_die \"I don't like newlines in the command: '$soc'\\n\" if $ENV{SSH_ORIGINAL_COMMAND} ne $soc;\n\n# allow gitolite-shell to be used as \"$SHELL\".  Experts only; no support, no docs\nif (@ARGV and $ARGV[0] eq '-c') {\n    shift;\n    $ARGV[0] =~ s/^$0 // or _die \"unknown git/gitolite command: '$ARGV[0]'\";\n}\n\n# the INPUT trigger massages @ARGV and $ENV{SSH_ORIGINAL_COMMAND} as needed\ntrigger('INPUT');\n\nmain($id);\n\ngl_log('END') if $$ == $ENV{GL_TID};\n\nexit 0;\n\n# ----------------------------------------------------------------------\n\nsub in_file {\n    gl_log( 'file', \"ARGV=\" . join( \",\", @ARGV ), \"SOC=$ENV{SSH_ORIGINAL_COMMAND}\" );\n\n    if ( $ENV{SSH_ORIGINAL_COMMAND} =~ /git-\\w+-pack/ ) {\n        print STDERR \"TRACE: gsh(\", join( \")(\", @ARGV ), \")\\n\";\n        print STDERR \"TRACE: gsh(SOC=$ENV{SSH_ORIGINAL_COMMAND})\\n\";\n    }\n    return 'file';\n}\n\nsub in_http {\n    http_setup_die_handler();\n\n    _die \"GITOLITE_HTTP_HOME not set\" unless $ENV{GITOLITE_HTTP_HOME};\n\n    _die \"fallback to DAV not supported\" if $ENV{REQUEST_METHOD} eq 'PROPFIND';\n\n    # fake out SSH_ORIGINAL_COMMAND and SSH_CONNECTION when called via http,\n    # so the rest of the code stays the same (except the exec at the end).\n    http_simulate_ssh_connection();\n    $ENV{SSH_ORIGINAL_COMMAND} ||= '';\n\n    $ENV{REMOTE_USER} ||= $rc{HTTP_ANON_USER};\n    @ARGV = ( $ENV{REMOTE_USER} );\n\n    my $ip;\n    ( $ip = $ENV{SSH_CONNECTION} || '(no-IP)' ) =~ s/ .*//;\n\n    gl_log( 'http', \"ARGV=\" . join( \",\", @ARGV ), \"SOC=\" . ( $ENV{SSH_ORIGINAL_COMMAND} || '' ), \"FROM=$ip\" );\n\n    return 'http';\n}\n\nsub in_ssh {\n    my $ip;\n    ( $ip = $ENV{SSH_CONNECTION} || '(no-IP)' ) =~ s/ .*//;\n\n    gl_log( 'ssh', \"ARGV=\" . join( \",\", @ARGV ), \"SOC=\" . ( $ENV{SSH_ORIGINAL_COMMAND} || '' ), \"FROM=$ip\" );\n\n    $ENV{SSH_ORIGINAL_COMMAND} ||= '';\n\n    return $ip;\n}\n\n# ----------------------------------------------------------------------\n\n# call this once you are sure arg-1 is the username and SSH_ORIGINAL_COMMAND\n# has been setup (even if it's not actually coming via ssh).\nsub main {\n    my $id = shift;\n\n    # set up the user\n    my $user = $ENV{GL_USER} = shift @ARGV;\n\n    # set up the repo and the attempted access\n    my ( $verb, $repo ) = parse_soc();    # returns only for git commands\n    Gitolite::Conf::Load::sanity($repo, $REPONAME_PATT);\n    $ENV{GL_REPO} = $repo;\n    my $aa = ( $verb =~ 'upload' ? 'R' : 'W' );\n\n    # catch rare race when moving repos into gitolite control\n    _die \"$aa any $repo $user DENIED by fallthru\" .\n            \"\\n(or you mis-spelled the reponame)\"\n        unless update_hook_present($repo);\n    # this error message is exactly the same as that from elsewhere in the\n    # code, for the usual reasons (avoid leaking information)\n\n    # set up env vars from options set for this repo\n    env_options($repo);\n\n    # auto-create?\n    if ( repo_missing($repo) and access( $repo, $user, '^C', 'any' ) !~ /DENIED/ ) {\n        require Gitolite::Conf::Store;\n        Gitolite::Conf::Store->import;\n        new_wild_repo( $repo, $user, $aa );\n        gl_log( 'create', $repo, $user, $aa );\n    }\n\n    # a ref of 'any' signifies that this is a pre-git check, where we don't\n    # yet know the ref that will be eventually pushed (and even that won't\n    # apply if it's a read operation).  See the matching code in access() for\n    # more information.\n    unless ( $ENV{GL_BYPASS_ACCESS_CHECKS} ) {\n        my $ret = access( $repo, $user, $aa, 'any' );\n        trigger( 'ACCESS_1', $repo, $user, $aa, 'any', $ret );\n        _die $ret . \"\\n(or you mis-spelled the reponame)\" if $ret =~ /DENIED/;\n\n        gl_log( \"pre_git\", $repo, $user, $aa, 'any', $ret );\n    }\n\n    trigger( 'PRE_GIT', $repo, $user, $aa, 'any', $verb );\n    if ( $ENV{REQUEST_URI} ) {\n        _system( \"git\", \"http-backend\" );\n    } else {\n        my $repodir = \"'$rc{GL_REPO_BASE}/$repo.git'\";\n        _system( \"git\", \"shell\", \"-c\", \"$verb $repodir\" );\n    }\n    trigger( 'POST_GIT', $repo, $user, $aa, 'any', $verb );\n}\n\n# ----------------------------------------------------------------------\n\nsub parse_soc {\n    my $soc = $ENV{SSH_ORIGINAL_COMMAND};\n    $soc ||= 'info';\n\n    my $git_commands = \"git-upload-pack|git-receive-pack|git-upload-archive\";\n    # simplify the regex; we'll handle all the reponame nuances later\n    if ( $soc =~ m(^($git_commands) '?/?(.*?)'?$) ) {\n        my ( $verb, $repo ) = ( $1, $2 );\n        trace( 2, \"git command\", $soc );\n\n        # clean up the repo name; first extract the trace level if supplied\n        # (and no, you can't have a trace level *and* a trailing slash).\n        $ENV{D} = $1 if $repo =~ s/\\.git(\\d)$//;\n        # and then the git-daemon-compatibility trailers\n        $repo =~ s(/$)();\n        $repo =~ s(\\.git$)();\n\n        _die \"invalid repo name: '$repo'\" if $repo !~ $REPONAME_PATT;\n        return ( $verb, $repo );\n    }\n\n    # after this we should not return; caller expects us to handle it all here\n    # and exit out\n\n    my @words = split ' ', $soc;\n    if ( $rc{COMMANDS}{ $words[0] } ) {\n        if ( $rc{COMMANDS}{ $words[0] } ne 'ua' ) {\n            _die \"suspicious characters loitering about '$soc'\" if $soc !~ $REMOTE_COMMAND_PATT;\n            _die \"no relative paths allowed anywhere!\" if $soc =~ m(\\.\\./);\n        }\n        trace( 2, \"gitolite command\", $soc );\n        _system( \"gitolite\", @words );\n        exit 0;\n    }\n\n    _die \"unknown git/gitolite command: '$soc'\";\n}\n\n# ----------------------------------------------------------------------\n# helper functions for \"in_http\"\n\nsub http_setup_die_handler {\n\n    $SIG{__DIE__} = sub {\n        my $service = ( $ENV{SSH_ORIGINAL_COMMAND} =~ /git-receive-pack/ ? 'git-receive-pack' : 'git-upload-pack' );\n        my $message = shift; chomp($message);\n        print STDERR \"$message\\n\";\n\n        http_print_headers($service);\n\n        # format the service response, then the message.  With initial\n        # help from Ilari and then a more detailed email from Shawn...\n        $service = \"# service=$service\\n\"; $message = \"ERR $message\\n\";\n        $service = sprintf( \"%04X\", length($service) + 4 ) . \"$service\";    # no CRLF on this one\n        $message = sprintf( \"%04X\", length($message) + 4 ) . \"$message\";\n\n        print $service;\n        print \"0000\";                                                       # flush-pkt, apparently\n        print $message;\n        print STDERR $service;\n        print STDERR $message;\n        exit 0;                                                             # if it's ok for die_webcgi in git.git/http-backend.c, it's ok for me ;-)\n      }\n}\n\nsub http_simulate_ssh_connection {\n    # these patterns indicate normal git usage; see \"services[]\" in\n    # http-backend.c for how I got that.  Also note that \"info\" is overloaded;\n    # git uses \"info/refs...\", while gitolite uses \"info\" or \"info?...\".  So\n    # there's a \"/\" after info in the list below\n    if ( $ENV{PATH_INFO} =~ m(^/(.*)/(HEAD$|info/refs$|objects/|git-(?:upload|receive)-pack$)) ) {\n        my $repo = $1;\n        my $verb = ( $ENV{REQUEST_URI} =~ /git-receive-pack/ ) ? 'git-receive-pack' : 'git-upload-pack';\n        $ENV{SSH_ORIGINAL_COMMAND} = \"$verb '$repo'\";\n    } else {\n        # this is one of our custom commands; could be anything really,\n        # because of the adc feature\n        my ($verb) = ( $ENV{PATH_INFO} =~ m(^/(\\S+)) );\n        my $args = $ENV{QUERY_STRING};\n        $args =~ s/\\+/ /g;\n        $args =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;\n        $ENV{SSH_ORIGINAL_COMMAND} = $verb;\n        $ENV{SSH_ORIGINAL_COMMAND} .= \" $args\" if $args;\n        http_print_headers();    # in preparation for the eventual output!\n\n        # we also need to pipe STDERR out via STDOUT, else the user doesn't see those messages!\n        open(STDERR, \">&STDOUT\") or _die \"Can't dup STDOUT: $!\";\n    }\n    $ENV{SSH_CONNECTION} = \"$ENV{REMOTE_ADDR} $ENV{REMOTE_PORT} $ENV{SERVER_ADDR} $ENV{SERVER_PORT}\";\n}\n\nmy $http_headers_printed = 0;\n\nsub http_print_headers {\n    my ( $service, $code, $text ) = @_;\n\n    return if $http_headers_printed++;\n    $code ||= 200;\n    $text ||= \"OK - gitolite\";\n\n    $|++;\n    print \"Status: $code $text\\r\\n\";\n    print \"Expires: Fri, 01 Jan 1980 00:00:00 GMT\\r\\n\";\n    print \"Pragma: no-cache\\r\\n\";\n    print \"Cache-Control: no-cache, max-age=0, must-revalidate\\r\\n\";\n    if ($service) {\n        print \"Content-Type: application/x-$service-advertisement\\r\\n\";\n    } else {\n        print \"Content-Type: text/plain\\r\\n\";\n    }\n    print \"\\r\\n\";\n}\n", "package Gitolite::Common;\n\n# common (non-gitolite-specific) functions\n# ----------------------------------------------------------------------\n\n#<<<\n@EXPORT = qw(\n  print2  dbg     _mkdir  _open   ln_sf     tsh_rc      sort_u\n  say     _warn   _chdir  _print            tsh_text    list_phy_repos\n  say2    _die    _system slurp             tsh_lines\n          trace           cleanup_conf_line tsh_try\n          usage                             tsh_run\n          gen_lfn\n          gl_log\n\n          dd\n          t_start\n          t_lap\n\n          ssh_fingerprint_file\n          ssh_fingerprint_line\n\n          update_hook_present\n);\n#>>>\nuse Exporter 'import';\nuse File::Path qw(mkpath);\nuse File::Temp qw(tempfile);\nuse Carp qw(carp cluck croak confess);\n\nuse strict;\nuse warnings;\n\n# ----------------------------------------------------------------------\n\nsub print2 {\n    local $/ = \"\\n\";\n    print STDERR @_;\n}\n\nsub say {\n    local $/ = \"\\n\";\n    print @_, \"\\n\";\n}\n\nsub say2 {\n    local $/ = \"\\n\";\n    print STDERR @_, \"\\n\";\n}\n\nsub trace {\n    gl_log( \"\\t\" . join( \",\", @_[ 1 .. $#_ ] ) ) if $_[0] <= 1 and defined $Gitolite::Rc::rc{LOG_EXTRA};\n\n    return unless defined( $ENV{D} );\n\n    my $level = shift; return if $ENV{D} < $level;\n    my $sub = ( caller 1 )[3] || ''; $sub =~ s/.*://;\n    if ( not $sub ) {\n        $sub = (caller)[1];\n        $sub =~ s(.*/(.*))(($1));\n    }\n    $sub .= ' ' x ( 31 - length($sub) );\n    say2 \"$level\\t$sub\\t\", join( \"\\t\", @_ );\n}\n\nsub dbg {\n    use Data::Dumper;\n    return unless defined( $ENV{D} );\n    for my $i (@_) {\n        print STDERR \"DBG: \" . Dumper($i);\n    }\n}\n\nsub dd {\n    local $ENV{D} = 1;\n    dbg(@_);\n}\n\n{\n    my %start_times;\n\n    eval \"require Time::HiRes\";\n    # we just ignore any errors from this; nothing needs to be done as long as\n    # no code *calls* either of the next two functions.\n\n    sub t_start {\n        my $name = shift || 'default';\n        $start_times{$name} = [ Time::HiRes::gettimeofday() ];\n    }\n\n    sub t_lap {\n        my $name = shift || 'default';\n        return Time::HiRes::tv_interval( $start_times{$name} );\n    }\n}\n\nsub _warn {\n    gl_log( 'warn', @_ );\n    if ( $ENV{D} and $ENV{D} >= 3 ) {\n        cluck \"WARNING: \", @_, \"\\n\";\n    } elsif ( defined( $ENV{D} ) ) {\n        carp \"WARNING: \", @_, \"\\n\";\n    } else {\n        warn \"WARNING: \", @_, \"\\n\";\n    }\n}\n$SIG{__WARN__} = \\&_warn;\n\nsub _die {\n    gl_log( 'die', @_ );\n    if ( $ENV{D} and $ENV{D} >= 3 ) {\n        confess \"FATAL: \" . join( \",\", @_ ) . \"\\n\" if defined( $ENV{D} );\n    } elsif ( defined( $ENV{D} ) ) {\n        croak \"FATAL: \" . join( \",\", @_ ) . \"\\n\";\n    } else {\n        die \"FATAL: \" . join( \",\", @_ ) . \"\\n\";\n    }\n}\n$SIG{__DIE__} = \\&_die;\n\nsub usage {\n    my $script = (caller)[1];\n    my $function = shift if @_ and $_[0] =~ /^[\\w-]+$/;\n    $function ||= ( ( ( caller(1) )[3] ) || ( ( caller(0) )[3] ) );\n    $function =~ s/.*:://;\n    my $code = slurp($script);\n    $code =~ /^=for $function\\b(.*?)^=cut/sm;\n    say( $1 ? $1 : \"...no usage message for '$function' in $script\" );\n    exit 1;\n}\n\nsub _mkdir {\n    # It's not an error if the directory exists, but it is an error if it\n    # doesn't exist and we can't create it. This includes not guaranteeing\n    # dead symlinks or if mkpath traversal is blocked by a file.\n    my $dir  = shift;\n    my $perm = shift;    # optional\n    return if -d $dir;\n    mkpath($dir);\n    chmod $perm, $dir if $perm;\n    return 1;\n}\n\nsub _chdir {\n    chdir( $_[0] || $ENV{HOME} ) or _die \"chdir $_[0] failed: $!\\n\";\n}\n\nsub _system {\n    # run system(), catch errors.  Be verbose only if $ENV{D} exists.  If not,\n    # exit with <rc of system()> if it applies, else just \"exit 1\".\n    trace( 1, 'system', @_ );\n    if ( system(@_) != 0 ) {\n        trace( 1, \"system() failed\", @_, \"-> $?\" );\n        if ( $? == -1 ) {\n            die \"failed to execute: $!\\n\" if $ENV{D};\n        } elsif ( $? & 127 ) {\n            die \"child died with signal \" . ( $? & 127 ) . \"\\n\" if $ENV{D};\n        } else {\n            die \"child exited with value \" . ( $? >> 8 ) . \"\\n\" if $ENV{D};\n            exit( $? >> 8 );\n        }\n        exit 1;\n    }\n}\n\nsub _open {\n    open( my $fh, $_[0], $_[1] ) or _die \"open $_[1] failed: $!\\n\";\n    return $fh;\n}\n\nsub _print {\n    my ( $file, @text ) = @_;\n    my $fh = _open( \">\", \"$file.$$\" );\n    print $fh @text;\n    close($fh) or _die \"close $file failed: $! at \", (caller)[1], \" line \", (caller)[2], \"\\n\";\n    my $oldmode = ( ( stat $file )[2] );\n    rename \"$file.$$\", $file;\n    chmod $oldmode, $file if $oldmode;\n}\n\nsub slurp {\n    return unless defined wantarray;\n    local $/ = undef unless wantarray;\n    my $fh = _open( \"<\", $_[0] );\n    return <$fh>;\n}\n\nsub dos2unix {\n    # WARNING: when calling this, make sure you supply a list context\n    s/\\r\\n/\\n/g for @_;\n    return @_;\n}\n\nsub ln_sf {\n    trace( 3, @_ );\n    my ( $srcdir, $glob, $dstdir ) = @_;\n    for my $hook ( glob(\"$srcdir/$glob\") ) {\n        $hook =~ s/$srcdir\\///;\n        unlink \"$dstdir/$hook\";\n        symlink \"$srcdir/$hook\", \"$dstdir/$hook\" or croak \"could not symlink $srcdir/$hook to $dstdir\\n\";\n    }\n}\n\nsub sort_u {\n    my %uniq;\n    my $listref = shift;\n    return [] unless @{$listref};\n    undef @uniq{ @{$listref} };    # expect a listref\n    my @sort_u = sort keys %uniq;\n    return \\@sort_u;\n}\n\nsub cleanup_conf_line {\n    my $line = shift;\n    return $line if $line =~ /^# \\S+ \\d+$/;\n\n    # kill comments, but take care of \"#\" inside *simple* strings\n    $line =~ s/^((\".*?\"|[^#\"])*)#.*/$1/;\n    # normalise whitespace; keeps later regexes very simple\n    $line =~ s/=/ = /;\n    $line =~ s/\\s+/ /g;\n    $line =~ s/^ //;\n    $line =~ s/ $//;\n    return $line;\n}\n\n{\n    my @phy_repos = ();\n\n    sub list_phy_repos {\n        # use cached value only if it exists *and* no arg was received (i.e.,\n        # receiving *any* arg invalidates cache)\n        return \\@phy_repos if ( @phy_repos and not @_ );\n\n        my $cmd = 'find . ' . ($Gitolite::Rc::rc{REPO_SYMLINKS} || '') . ' -name \"*.git\" -prune';\n        for my $repo (`$cmd`) {\n            chomp($repo);\n            $repo =~ s/\\.git$//;\n            $repo =~ s(^\\./)();\n            next if $repo =~ m(/$);\n                # tolerate non-bare repos within ~/repositories but silently ignore them\n            next unless update_hook_present($repo);\n                # ignore repos that don't yet have the update hook\n            push @phy_repos, $repo;\n        }\n        trace( 3, scalar(@phy_repos) . \" physical repos found\" );\n        return sort_u( \\@phy_repos );\n    }\n}\n\nsub update_hook_present {\n    my $repo = shift;\n\n    return 1 unless -d \"$ENV{GL_REPO_BASE}/$repo.git\";  # non-existent repo is fine\n\n    my $x = readlink(\"$ENV{GL_REPO_BASE}/$repo.git/hooks/update\");\n    return 1 if $x and $x eq \"$ENV{GL_ADMIN_BASE}/hooks/common/update\";\n\n    return 0;\n}\n\n# generate a timestamp\nsub gen_ts {\n    my ( $s, $min, $h, $d, $m, $y ) = (localtime)[ 0 .. 5 ];\n    $y += 1900; $m++;    # usual adjustments\n    for ( $s, $min, $h, $d, $m ) {\n        $_ = \"0$_\" if $_ < 10;\n    }\n    my $ts = \"$y-$m-$d.$h:$min:$s\";\n\n    return $ts;\n}\n\n# generate a log file name\nsub gen_lfn {\n    my ( $s, $min, $h, $d, $m, $y ) = (localtime)[ 0 .. 5 ];\n    $y += 1900; $m++;    # usual adjustments\n    for ( $s, $min, $h, $d, $m ) {\n        $_ = \"0$_\" if $_ < 10;\n    }\n\n    my ($template) = shift;\n    # substitute template parameters and set the logfile name\n    $template =~ s/%y/$y/g;\n    $template =~ s/%m/$m/g;\n    $template =~ s/%d/$d/g;\n\n    return $template;\n}\n\nmy $log_dest;\nmy $syslog_opened = 0;\nEND { closelog() if $syslog_opened; }\nsub gl_log {\n    # the log filename and the timestamp come from the environment.  If we get\n    # called even before they are set, we have no choice but to dump to STDERR\n    # (and probably call \"logger\").\n\n    # tab sep if there's more than one field\n    my $msg = join( \"\\t\", @_ );\n    $msg =~ s/[\\n\\r]+/<<newline>>/g;\n\n    my $ts = gen_ts();\n    my $tid = $ENV{GL_TID} ||= $$;\n\n    $log_dest = $Gitolite::Rc::rc{LOG_DEST} || '' if not defined $log_dest;\n\n    # log (update records only) to \"gl-log\" in the bare repo dir; this is to\n    # make 'who-pushed' more efficient.  Since this is only for the update\n    # records, it is not a replacement for the other two types of logging.\n    if ($log_dest =~ /repo-log/ and $_[0] eq 'update') {\n        # if the log line is 'update', we're already in the bare repo dir\n        open my $lfh, \">>\", \"gl-log\" or _die \"open gl-log failed: $!\";\n        print $lfh \"$ts\\t$tid\\t$msg\\n\";\n        close $lfh;\n    }\n\n    # syslog\n    if ($log_dest =~ /syslog/) {            # log_dest *includes* syslog\n        if ($syslog_opened == 0) {\n            require Sys::Syslog;\n            Sys::Syslog->import(qw(:standard));\n\n            openlog(\"gitolite\" . ( $ENV{GL_TID} ? \"[$ENV{GL_TID}]\" : \"\" ), \"pid\", $Gitolite::Rc::rc{LOG_FACILITY} || 'local0');\n            $syslog_opened = 1;\n        }\n\n        # gl_log is called either directly, or, if the rc variable LOG_EXTRA\n        # is set, from trace(1, ...).  The latter use is considered additional\n        # info for troubleshooting.  Trace prefixes a tab to the arguments\n        # before calling gl_log, to visually set off such lines in the log\n        # file.  Although syslog eats up that leading tab, we use it to decide\n        # the priority/level of the syslog message.\n        syslog( ( $msg =~ /^\\t/ ? 'debug' : 'info' ), \"%s\", $msg);\n\n        return if $log_dest !~ /normal/;\n    }\n\n    my $fh;\n    logger_plus_stderr( \"errors found before logging could be setup\", \"$msg\" ) if not $ENV{GL_LOGFILE};\n    open my $lfh, \">>\", $ENV{GL_LOGFILE}\n      or logger_plus_stderr( \"errors found but logfile could not be created\", \"$ENV{GL_LOGFILE}: $!\", \"$msg\" );\n    print $lfh \"$ts\\t$tid\\t$msg\\n\";\n    close $lfh;\n}\n\nsub logger_plus_stderr {\n    open my $fh, \"|-\", \"logger\" or confess \"it's really not my day is it...?\\n\";\n    for (@_) {\n        print STDERR \"FATAL: $_\\n\";\n        print $fh \"FATAL: $_\\n\";\n    }\n    exit 1;\n}\n\n# ----------------------------------------------------------------------\n# Get the SSH fingerprint of a file\n# If the fingerprint cannot be parsed, it will be undef\n# In a scalar context, returns the fingerprint\n# In a list context, returns (fingerprint, output) where output\n# is the raw output of the ssh-keygen command\nsub ssh_fingerprint_file {\n    my $in = shift;\n    -f $in or die \"file not found: $in\\n\";\n    my $fh;\n    open( $fh, \"ssh-keygen -l -f $in |\" ) or die \"could not fork: $!\\n\";\n    my $output = <$fh>;\n    chomp $output;\n    # dbg(\"fp = $fp\");\n    close $fh;\n    # Return a valid fingerprint or undef\n    my $fp = undef;\n    if($output =~ /((?:MD5:)?(?:[0-9a-f]{2}:){15}[0-9a-f]{2})/i or\n       $output =~ m{((?:RIPEMD|SHA)\\d+:[A-Za-z0-9+/=]+)}i) {\n        $fp = $1;\n    }\n    return wantarray ? ($fp, $output) : $fp;\n}\n\n# Get the SSH fingerprint of a line of text\n# If the fingerprint cannot be parsed, it will be undef\n# In a scalar context, returns the fingerprint\n# In a list context, returns (fingerprint, output) where output\n# is the raw output of the ssh-keygen command\nsub ssh_fingerprint_line {\n    my ( $fh, $fn ) = tempfile();\n    print $fh shift() . \"\\n\";\n    close $fh;\n    my ($fp,$output) = ssh_fingerprint_file($fn);\n    unlink $fn;\n    return wantarray ? ($fp,$output) : $fp;\n}\n\n# ----------------------------------------------------------------------\n\n# bare-minimum subset of 'Tsh' (see github.com/sitaramc/tsh)\n{\n    my ( $rc, $text );\n    sub tsh_rc   { return $rc   || 0; }\n    sub tsh_text { return $text || ''; }\n    sub tsh_lines { return split /\\n/, $text; }\n\n    sub tsh_try {\n        my $cmd = shift; die \"try: expects only one argument\" if @_;\n        $text = `( $cmd ) 2>&1; printf RC=\\$?`;\n        if ( $text =~ s/RC=(\\d+)$// ) {\n            $rc = $1;\n            trace( 3, $text );\n            return ( not $rc );\n        }\n        die \"couldnt find RC= in result; this should not happen:\\n$text\\n\\n...\\n\";\n    }\n\n    sub tsh_run {\n        open( my $fh, \"-|\", @_ ) or die \"popen failed: $!\";\n        local $/ = undef; $text = <$fh>;\n        close $fh; warn \"pclose failed: $!\" if $!;\n        $rc = ( $? >> 8 );\n        trace( 3, $text );\n        return $text;\n    }\n}\n\n1;\n"], "filenames": ["src/gitolite-shell", "src/lib/Gitolite/Common.pm"], "buggy_code_start_loc": [114, 21], "buggy_code_end_loc": [114, 243], "fixing_code_start_loc": [115, 22], "fixing_code_end_loc": [122, 260], "type": "CWE-362", "message": "Gitolite before 3.6.9 does not (in certain configurations involving @all or a regex) properly restrict access to a Git repository that is in the process of being migrated until the full set of migration steps has been completed. This can allow valid users to obtain unintended access.", "other": {"cve": {"id": "CVE-2018-16976", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-12T22:29:00.517", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Gitolite before 3.6.9 does not (in certain configurations involving @all or a regex) properly restrict access to a Git repository that is in the process of being migrated until the full set of migration steps has been completed. This can allow valid users to obtain unintended access."}, {"lang": "es", "value": "Gitolite en versiones anteriores a la 3.6.9 no restringe (en determinadas configuraciones relacionadas con @all o un regex) correctamente el acceso a un repositorio de Git que est\u00e1 en proceso de migraci\u00f3n hasta que se hayan completado todos los pasos de la migraci\u00f3n. Esto puede permitir que usuarios v\u00e1lidos obtengan acceso no planeado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitolite:gitolite:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.9", "matchCriteriaId": "0C0D0F94-896F-4723-A488-11391CAD9C97"}]}]}], "references": [{"url": "https://bugs.debian.org/908699", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/sitaramc/gitolite/commit/dc13dfca8fdae5634bb0865f7e9822d2a268ed59", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!topic/gitolite-announce/WrwDTYdbfRg", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sitaramc/gitolite/commit/dc13dfca8fdae5634bb0865f7e9822d2a268ed59"}}