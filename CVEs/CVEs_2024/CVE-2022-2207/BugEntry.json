{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * edit.c: functions for Insert mode\n */\n\n#include \"vim.h\"\n\n#define BACKSPACE_CHAR\t\t    1\n#define BACKSPACE_WORD\t\t    2\n#define BACKSPACE_WORD_NOT_SPACE    3\n#define BACKSPACE_LINE\t\t    4\n\n// Set when doing something for completion that may call edit() recursively,\n// which is not allowed.\nstatic int\tcompl_busy = FALSE;\n\n\nstatic void ins_ctrl_v(void);\nstatic void insert_special(int, int, int);\nstatic void redo_literal(int c);\nstatic void start_arrow_common(pos_T *end_insert_pos, int change);\n#ifdef FEAT_SPELL\nstatic void check_spell_redraw(void);\n#endif\nstatic void stop_insert(pos_T *end_insert_pos, int esc, int nomove);\nstatic int  echeck_abbr(int);\nstatic void mb_replace_pop_ins(int cc);\nstatic void replace_flush(void);\nstatic void replace_do_bs(int limit_col);\nstatic int del_char_after_col(int limit_col);\nstatic void ins_reg(void);\nstatic void ins_ctrl_g(void);\nstatic void ins_ctrl_hat(void);\nstatic int  ins_esc(long *count, int cmdchar, int nomove);\n#ifdef FEAT_RIGHTLEFT\nstatic void ins_ctrl_(void);\n#endif\nstatic int ins_start_select(int c);\nstatic void ins_insert(int replaceState);\nstatic void ins_ctrl_o(void);\nstatic void ins_shift(int c, int lastc);\nstatic void ins_del(void);\nstatic int  ins_bs(int c, int mode, int *inserted_space_p);\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\nstatic void ins_tabline(int c);\n#endif\nstatic void ins_left(void);\nstatic void ins_home(int c);\nstatic void ins_end(int c);\nstatic void ins_s_left(void);\nstatic void ins_right(void);\nstatic void ins_s_right(void);\nstatic void ins_up(int startcol);\nstatic void ins_pageup(void);\nstatic void ins_down(int startcol);\nstatic void ins_pagedown(void);\n#ifdef FEAT_DND\nstatic void ins_drop(void);\n#endif\nstatic int  ins_tab(void);\n#ifdef FEAT_DIGRAPHS\nstatic int  ins_digraph(void);\n#endif\nstatic int  ins_ctrl_ey(int tc);\n#if defined(FEAT_EVAL)\nstatic char_u *do_insert_char_pre(int c);\n#endif\n\nstatic colnr_T\tInsstart_textlen;\t// length of line when insert started\nstatic colnr_T\tInsstart_blank_vcol;\t// vcol for first inserted blank\nstatic int\tupdate_Insstart_orig = TRUE; // set Insstart_orig to Insstart\n\nstatic char_u\t*last_insert = NULL;\t// the text of the previous insert,\n\t\t\t\t\t// K_SPECIAL and CSI are escaped\nstatic int\tlast_insert_skip; // nr of chars in front of previous insert\nstatic int\tnew_insert_skip;  // nr of chars in front of current insert\nstatic int\tdid_restart_edit;\t// \"restart_edit\" when calling edit()\n\nstatic int\tcan_cindent;\t\t// may do cindenting on this line\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\trevins_on;\t\t// reverse insert mode on\nstatic int\trevins_chars;\t\t// how much to skip after edit\nstatic int\trevins_legal;\t\t// was the last char 'legal'?\nstatic int\trevins_scol;\t\t// start column of revins session\n#endif\n\nstatic int\tins_need_undo;\t\t// call u_save() before inserting a\n\t\t\t\t\t// char.  Set when edit() is called.\n\t\t\t\t\t// after that arrow_used is used.\n\nstatic int\tdont_sync_undo = FALSE;\t// CTRL-G U prevents syncing undo for\n\t\t\t\t\t// the next left/right cursor key\n\n/*\n * edit(): Start inserting text.\n *\n * \"cmdchar\" can be:\n * 'i'\tnormal insert command\n * 'a'\tnormal append command\n * K_PS bracketed paste\n * 'R'\treplace command\n * 'r'\t\"r<CR>\" command: insert one <CR>.  Note: count can be > 1, for redo,\n *\tbut still only one <CR> is inserted.  The <Esc> is not used for redo.\n * 'g'\t\"gI\" command.\n * 'V'\t\"gR\" command for Virtual Replace mode.\n * 'v'\t\"gr\" command for single character Virtual Replace mode.\n *\n * This function is not called recursively.  For CTRL-O commands, it returns\n * and lets the caller handle the Normal-mode command.\n *\n * Return TRUE if a CTRL-O command caused the return (insert mode pending).\n */\n    int\nedit(\n    int\t\tcmdchar,\n    int\t\tstartln,\t// if set, insert at start of line\n    long\tcount)\n{\n    int\t\tc = 0;\n    char_u\t*ptr;\n    int\t\tlastc = 0;\n    int\t\tmincol;\n    static linenr_T o_lnum = 0;\n    int\t\ti;\n    int\t\tdid_backspace = TRUE;\t    // previous char was backspace\n    int\t\tline_is_white = FALSE;\t    // line is empty before insert\n    linenr_T\told_topline = 0;\t    // topline before insertion\n#ifdef FEAT_DIFF\n    int\t\told_topfill = -1;\n#endif\n    int\t\tinserted_space = FALSE;     // just inserted a space\n    int\t\treplaceState = MODE_REPLACE;\n    int\t\tnomove = FALSE;\t\t    // don't move cursor on return\n#ifdef FEAT_JOB_CHANNEL\n    int\t\tcmdchar_todo = cmdchar;\n#endif\n#ifdef FEAT_CONCEAL\n    int\t\tcursor_line_was_concealed;\n#endif\n\n    // Remember whether editing was restarted after CTRL-O.\n    did_restart_edit = restart_edit;\n\n    // sleep before redrawing, needed for \"CTRL-O :\" that results in an\n    // error message\n    check_for_delay(TRUE);\n\n    // set Insstart_orig to Insstart\n    update_Insstart_orig = TRUE;\n\n#ifdef HAVE_SANDBOX\n    // Don't allow inserting in the sandbox.\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn FALSE;\n    }\n#endif\n    // Don't allow changes in the buffer while editing the cmdline.  The\n    // caller of getcmdline() may get confused.\n    // Don't allow recursive insert mode when busy with completion.\n    if (textlock != 0 || ins_compl_active() || compl_busy || pum_visible())\n    {\n\temsg(_(e_not_allowed_to_change_text_or_change_window));\n\treturn FALSE;\n    }\n    ins_compl_clear();\t    // clear stuff for CTRL-X mode\n\n    /*\n     * Trigger InsertEnter autocommands.  Do not do this for \"r<CR>\" or \"grx\".\n     */\n    if (cmdchar != 'r' && cmdchar != 'v')\n    {\n\tpos_T   save_cursor = curwin->w_cursor;\n\n#ifdef FEAT_EVAL\n\tif (cmdchar == 'R')\n\t    ptr = (char_u *)\"r\";\n\telse if (cmdchar == 'V')\n\t    ptr = (char_u *)\"v\";\n\telse\n\t    ptr = (char_u *)\"i\";\n\tset_vim_var_string(VV_INSERTMODE, ptr, 1);\n\tset_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n#endif\n\tins_apply_autocmds(EVENT_INSERTENTER);\n\n\t// Check for changed highlighting, e.g. for ModeMsg.\n\tif (need_highlight_changed)\n\t    highlight_changed();\n\n\t// Make sure the cursor didn't move.  Do call check_cursor_col() in\n\t// case the text was modified.  Since Insert mode was not started yet\n\t// a call to check_cursor_col() may move the cursor, especially with\n\t// the \"A\" command, thus set State to avoid that. Also check that the\n\t// line number is still valid (lines may have been deleted).\n\t// Do not restore if v:char was set to a non-empty string.\n\tif (!EQUAL_POS(curwin->w_cursor, save_cursor)\n#ifdef FEAT_EVAL\n\t\t&& *get_vim_var_str(VV_CHAR) == NUL\n#endif\n\t\t&& save_cursor.lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    int save_state = State;\n\n\t    curwin->w_cursor = save_cursor;\n\t    State = MODE_INSERT;\n\t    check_cursor_col();\n\t    State = save_state;\n\t}\n    }\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line was concealed before changing State.\n    cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    /*\n     * When doing a paste with the middle mouse button, Insstart is set to\n     * where the paste started.\n     */\n    if (where_paste_started.lnum != 0)\n\tInsstart = where_paste_started;\n    else\n    {\n\tInsstart = curwin->w_cursor;\n\tif (startln)\n\t    Insstart.col = 0;\n    }\n    Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n    Insstart_blank_vcol = MAXCOL;\n    if (!did_ai)\n\tai_col = 0;\n\n    if (cmdchar != NUL && restart_edit == 0)\n    {\n\tResetRedobuff();\n\tAppendNumberToRedobuff(count);\n\tif (cmdchar == 'V' || cmdchar == 'v')\n\t{\n\t    // \"gR\" or \"gr\" command\n\t    AppendCharToRedobuff('g');\n\t    AppendCharToRedobuff((cmdchar == 'v') ? 'r' : 'R');\n\t}\n\telse\n\t{\n\t    if (cmdchar == K_PS)\n\t\tAppendCharToRedobuff('a');\n\t    else\n\t\tAppendCharToRedobuff(cmdchar);\n\t    if (cmdchar == 'g')\t\t    // \"gI\" command\n\t\tAppendCharToRedobuff('I');\n\t    else if (cmdchar == 'r')\t    // \"r<CR>\" command\n\t\tcount = 1;\t\t    // insert only one <CR>\n\t}\n    }\n\n    if (cmdchar == 'R')\n    {\n\tState = MODE_REPLACE;\n    }\n    else if (cmdchar == 'V' || cmdchar == 'v')\n    {\n\tState = MODE_VREPLACE;\n\treplaceState = MODE_VREPLACE;\n\torig_line_count = curbuf->b_ml.ml_line_count;\n\tvr_lines_changed = 1;\n    }\n    else\n\tState = MODE_INSERT;\n\n    may_trigger_modechanged();\n    stop_insert_mode = FALSE;\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"n\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    /*\n     * Enable langmap or IME, indicated by 'iminsert'.\n     * Note that IME may enabled/disabled without us noticing here, thus the\n     * 'iminsert' value may not reflect what is actually used.  It is updated\n     * when hitting <Esc>.\n     */\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n#endif\n\n    setmouse();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // there is no reverse replace mode\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n\tundisplay_dollar();\n    revins_chars = 0;\n    revins_legal = 0;\n    revins_scol = -1;\n#endif\n    if (!p_ek)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\n\t// Disable bracketed paste mode, we won't recognize the escape\n\t// sequences.\n\tout_str(T_BD);\n\n\t// Disable modifyOtherKeys, keys with modifiers would cause exiting\n\t// Insert mode.\n\tout_str(T_CTE);\n    }\n\n    /*\n     * Handle restarting Insert mode.\n     * Don't do this for \"CTRL-O .\" (repeat an insert): In that case we get\n     * here with something in the stuff buffer.\n     */\n    if (restart_edit != 0 && stuff_empty())\n    {\n\t/*\n\t * After a paste we consider text typed to be part of the insert for\n\t * the pasted text. You can backspace over the pasted text too.\n\t */\n\tif (where_paste_started.lnum)\n\t    arrow_used = FALSE;\n\telse\n\t    arrow_used = TRUE;\n\trestart_edit = 0;\n\n\t/*\n\t * If the cursor was after the end-of-line before the CTRL-O and it is\n\t * now at the end-of-line, put it after the end-of-line (this is not\n\t * correct in very rare cases).\n\t * Also do this if curswant is greater than the current virtual\n\t * column.  Eg after \"^O$\" or \"^O80|\".\n\t */\n\tvalidate_virtcol();\n\tupdate_curswant();\n\tif (((ins_at_eol && curwin->w_cursor.lnum == o_lnum)\n\t\t    || curwin->w_curswant > curwin->w_virtcol)\n\t\t&& *(ptr = ml_get_curline() + curwin->w_cursor.col) != NUL)\n\t{\n\t    if (ptr[1] == NUL)\n\t\t++curwin->w_cursor.col;\n\t    else if (has_mbyte)\n\t    {\n\t\ti = (*mb_ptr2len)(ptr);\n\t\tif (ptr[i] == NUL)\n\t\t    curwin->w_cursor.col += i;\n\t    }\n\t}\n\tins_at_eol = FALSE;\n    }\n    else\n\tarrow_used = FALSE;\n\n    // we are in insert mode now, don't need to start it anymore\n    need_start_insertmode = FALSE;\n\n    // Need to save the line for undo before inserting the first char.\n    ins_need_undo = TRUE;\n\n    where_paste_started.lnum = 0;\n    can_cindent = TRUE;\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold, unless 'insertmode' is set or\n    // restarting.\n    if (!p_im && did_restart_edit == 0)\n\tfoldOpenCursor();\n#endif\n\n    /*\n     * If 'showmode' is set, show the current (insert/replace/..) mode.\n     * A warning message for changing a readonly file is given here, before\n     * actually changing anything.  It's put after the mode, if any.\n     */\n    i = 0;\n    if (p_smd && msg_silent == 0)\n\ti = showmode();\n\n    if (!p_im && did_restart_edit == 0)\n\tchange_warning(i == 0 ? 0 : i + 1);\n\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// clear digraphs\n#endif\n\n    /*\n     * Get the current length of the redo buffer, those characters have to be\n     * skipped if we want to get to the inserted characters.\n     */\n    ptr = get_inserted();\n    if (ptr == NULL)\n\tnew_insert_skip = 0;\n    else\n    {\n\tnew_insert_skip = (int)STRLEN(ptr);\n\tvim_free(ptr);\n    }\n\n    old_indent = 0;\n\n    /*\n     * Main loop in Insert mode: repeat until Insert mode is left.\n     */\n    for (;;)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (!revins_legal)\n\t    revins_scol = -1;\t    // reset on illegal motions\n\telse\n\t    revins_legal = 0;\n#endif\n\tif (arrow_used)\t    // don't repeat insert when arrow key used\n\t    count = 0;\n\n\tif (update_Insstart_orig)\n\t    Insstart_orig = Insstart;\n\n\tif (stop_insert_mode && !ins_compl_active())\n\t{\n\t    // \":stopinsert\" used or 'insertmode' reset\n\t    count = 0;\n\t    goto doESCkey;\n\t}\n\n\t// set curwin->w_curswant for next K_DOWN or K_UP\n\tif (!arrow_used)\n\t    curwin->w_set_curswant = TRUE;\n\n\t// If there is no typeahead may check for timestamps (e.g., for when a\n\t// menu invoked a shell command).\n\tif (stuff_empty())\n\t{\n\t    did_check_timestamps = FALSE;\n\t    if (need_check_timestamps)\n\t\tcheck_timestamps(FALSE);\n\t}\n\n\t/*\n\t * When emsg() was called msg_scroll will have been set.\n\t */\n\tmsg_scroll = FALSE;\n\n#ifdef FEAT_GUI\n\t// When 'mousefocus' is set a mouse movement may have taken us to\n\t// another window.  \"need_mouse_correct\" may then be set because of an\n\t// autocommand.\n\tif (need_mouse_correct)\n\t    gui_mouse_correct();\n#endif\n\n#ifdef FEAT_FOLDING\n\t// Open fold at the cursor line, according to 'foldopen'.\n\tif (fdo_flags & FDO_INSERT)\n\t    foldOpenCursor();\n\t// Close folds where the cursor isn't, according to 'foldclose'\n\tif (!char_avail())\n\t    foldCheckClose();\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    init_prompt(cmdchar_todo);\n\t    cmdchar_todo = NUL;\n\t}\n#endif\n\n\t/*\n\t * If we inserted a character at the last position of the last line in\n\t * the window, scroll the window one line up. This avoids an extra\n\t * redraw.\n\t * This is detected when the cursor column is smaller after inserting\n\t * something.\n\t * Don't do this when the topline changed already, it has\n\t * already been adjusted (by insertchar() calling open_line())).\n\t */\n\tif (curbuf->b_mod_set\n\t\t&& curwin->w_p_wrap\n\t\t&& !did_backspace\n\t\t&& curwin->w_topline == old_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == old_topfill\n#endif\n\t\t)\n\t{\n\t    mincol = curwin->w_wcol;\n\t    validate_cursor_col();\n\n\t    if (\n#ifdef FEAT_VARTABS\n\t\tcurwin->w_wcol < mincol - tabstop_at(\n\t\t\t\t\t  get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t\t curbuf->b_p_vts_array)\n#else\n\t\t(int)curwin->w_wcol < mincol - curbuf->b_p_ts\n#endif\n\t\t    && curwin->w_wrow == W_WINROW(curwin)\n\t\t\t\t + curwin->w_height - 1 - get_scrolloff_value()\n\t\t    && (curwin->w_cursor.lnum != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill > 0\n#endif\n\t\t    ))\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    --curwin->w_topfill;\n\t\telse\n#endif\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline, NULL, &old_topline))\n\t\t    set_topline(curwin, old_topline + 1);\n\t\telse\n#endif\n\t\t    set_topline(curwin, curwin->w_topline + 1);\n\t    }\n\t}\n\n\t// May need to adjust w_topline to show the cursor.\n\tupdate_topline();\n\n\tdid_backspace = FALSE;\n\n\tvalidate_cursor();\t\t// may set must_redraw\n\n\t/*\n\t * Redraw the display when no characters are waiting.\n\t * Also shows mode, ruler and positions cursor.\n\t */\n\tins_redraw(TRUE);\n\n\tif (curwin->w_p_scb)\n\t    do_check_scrollbind(TRUE);\n\n\tif (curwin->w_p_crb)\n\t    do_check_cursorbind();\n\tupdate_curswant();\n\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n\told_topfill = curwin->w_topfill;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n\t/*\n\t * Get a character for Insert mode.  Ignore K_IGNORE and K_NOP.\n\t */\n\tif (c != K_CURSORHOLD)\n\t    lastc = c;\t\t// remember the previous char for CTRL-D\n\n\t// After using CTRL-G U the next cursor key will not break undo.\n\tif (dont_sync_undo == MAYBE)\n\t    dont_sync_undo = TRUE;\n\telse\n\t    dont_sync_undo = FALSE;\n\tif (cmdchar == K_PS)\n\t    // Got here from normal mode when bracketed paste started.\n\t    c = K_PS;\n\telse\n\t    do\n\t    {\n\t\tc = safe_vgetc();\n\n\t\tif (stop_insert_mode\n#ifdef FEAT_TERMINAL\n\t\t\t|| (c == K_IGNORE && term_use_loop())\n#endif\n\t\t   )\n\t\t{\n\t\t    // Insert mode ended, possibly from a callback, or a timer\n\t\t    // must have opened a terminal window.\n\t\t    if (c != K_IGNORE && c != K_NOP)\n\t\t\tvungetc(c);\n\t\t    count = 0;\n\t\t    nomove = TRUE;\n\t\t    ins_compl_prep(ESC);\n\t\t    goto doESCkey;\n\t\t}\n\t    } while (c == K_IGNORE || c == K_NOP);\n\n\t// Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.\n\tdid_cursorhold = TRUE;\n\n#ifdef FEAT_RIGHTLEFT\n\tif (p_hkmap && KeyTyped)\n\t    c = hkmap(c);\t\t// Hebrew mode mapping\n#endif\n\n\t// If the window was made so small that nothing shows, make it at least\n\t// one line and one column when typing.\n\tif (KeyTyped && !KeyStuffed)\n\t    win_ensure_size();\n\n\t/*\n\t * Special handling of keys while the popup menu is visible or wanted\n\t * and the cursor is still in the completed word.  Only when there is\n\t * a match, skip this when no matches were found.\n\t */\n\tif (ins_compl_active()\n\t\t&& pum_wanted()\n\t\t&& curwin->w_cursor.col >= ins_compl_col()\n\t\t&& ins_compl_has_shown_match())\n\t{\n\t    // BS: Delete one character from \"compl_leader\".\n\t    if ((c == K_BS || c == Ctrl_H)\n\t\t\t&& curwin->w_cursor.col > ins_compl_col()\n\t\t\t&& (c = ins_compl_bs()) == NUL)\n\t\tcontinue;\n\n\t    // When no match was selected or it was edited.\n\t    if (!ins_compl_used_match())\n\t    {\n\t\t// CTRL-L: Add one character from the current match to\n\t\t// \"compl_leader\".  Except when at the original match and\n\t\t// there is nothing to add, CTRL-L works like CTRL-P then.\n\t\tif (c == Ctrl_L\n\t\t\t&& (!ctrl_x_mode_line_or_eval()\n\t\t\t    || ins_compl_long_shown_match()))\n\t\t{\n\t\t    ins_compl_addfrommatch();\n\t\t    continue;\n\t\t}\n\n\t\t// A non-white character that fits in with the current\n\t\t// completion: Add to \"compl_leader\".\n\t\tif (ins_compl_accept_char(c))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    // Trigger InsertCharPre.\n\t\t    char_u *str = do_insert_char_pre(c);\n\t\t    char_u *p;\n\n\t\t    if (str != NULL)\n\t\t    {\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t    ins_compl_addleader(PTR2CHAR(p));\n\t\t\tvim_free(str);\n\t\t    }\n\t\t    else\n#endif\n\t\t\tins_compl_addleader(c);\n\t\t    continue;\n\t\t}\n\n\t\t// Pressing CTRL-Y selects the current match.  When\n\t\t// ins_compl_enter_selects() is set the Enter key does the\n\t\t// same.\n\t\tif ((c == Ctrl_Y || (ins_compl_enter_selects()\n\t\t\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t\t\t&& stop_arrow() == OK)\n\t\t{\n\t\t    ins_compl_delete();\n\t\t    ins_compl_insert(FALSE);\n\t\t}\n\t    }\n\t}\n\n\t// Prepare for or stop CTRL-X mode.  This doesn't do completion, but\n\t// it does fix up the text when finishing completion.\n\tins_compl_init_get_longest();\n\tif (ins_compl_prep(c))\n\t    continue;\n\n\t// CTRL-\\ CTRL-N goes to Normal mode,\n\t// CTRL-\\ CTRL-G goes to mode selected with 'insertmode',\n\t// CTRL-\\ CTRL-O is like CTRL-O but without moving the cursor.\n\tif (c == Ctrl_BSL)\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    c = plain_vgetc();\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (c != Ctrl_N && c != Ctrl_G && c != Ctrl_O)\n\t    {\n\t\t// it's something else\n\t\tvungetc(c);\n\t\tc = Ctrl_BSL;\n\t    }\n\t    else if (c == Ctrl_G && p_im)\n\t\tcontinue;\n\t    else\n\t    {\n\t\tif (c == Ctrl_O)\n\t\t{\n\t\t    ins_ctrl_o();\n\t\t    ins_at_eol = FALSE;\t// cursor keeps its column\n\t\t    nomove = TRUE;\n\t\t}\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tc = do_digraph(c);\n#endif\n\n\tif ((c == Ctrl_V || c == Ctrl_Q) && ctrl_x_mode_cmdline())\n\t    goto docomplete;\n\tif (c == Ctrl_V || c == Ctrl_Q)\n\t{\n\t    ins_ctrl_v();\n\t    c = Ctrl_V;\t// pretend CTRL-V is last typed character\n\t    continue;\n\t}\n\n\tif (cindent_on() && ctrl_x_mode_none())\n\t{\n\t    // A key name preceded by a bang means this key is not to be\n\t    // inserted.  Skip ahead to the re-indenting below.\n\t    // A key name preceded by a star means that indenting has to be\n\t    // done before inserting the key.\n\t    line_is_white = inindent(0);\n\t    if (in_cinkeys(c, '!', line_is_white))\n\t\tgoto force_cindent;\n\t    if (can_cindent && in_cinkeys(c, '*', line_is_white)\n\t\t\t\t\t\t\t&& stop_arrow() == OK)\n\t\tdo_c_expr_indent();\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t    switch (c)\n\t    {\n\t\tcase K_LEFT:\tc = K_RIGHT; break;\n\t\tcase K_S_LEFT:\tc = K_S_RIGHT; break;\n\t\tcase K_C_LEFT:\tc = K_C_RIGHT; break;\n\t\tcase K_RIGHT:\tc = K_LEFT; break;\n\t\tcase K_S_RIGHT: c = K_S_LEFT; break;\n\t\tcase K_C_RIGHT: c = K_C_LEFT; break;\n\t    }\n#endif\n\n\t/*\n\t * If 'keymodel' contains \"startsel\", may start selection.  If it\n\t * does, a CTRL-O and c will be stuffed, we need to get these\n\t * characters.\n\t */\n\tif (ins_start_select(c))\n\t    continue;\n\n\t/*\n\t * The big switch to handle a character in insert mode.\n\t */\n\tswitch (c)\n\t{\n\tcase ESC:\t// End input mode\n\t    if (echeck_abbr(ESC + ABBR_OFF))\n\t\tbreak;\n\t    // FALLTHROUGH\n\n\tcase Ctrl_C:\t// End input mode\n#ifdef FEAT_CMDWIN\n\t    if (c == Ctrl_C && cmdwin_type != 0)\n\t    {\n\t\t// Close the cmdline window.\n\t\tcmdwin_result = K_IGNORE;\n\t\tgot_int = FALSE; // don't stop executing autocommands et al.\n\t\tnomove = TRUE;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (c == Ctrl_C && bt_prompt(curbuf))\n\t    {\n\t\tif (invoke_prompt_interrupt())\n\t\t{\n\t\t    if (!bt_prompt(curbuf))\n\t\t\t// buffer changed to a non-prompt buffer, get out of\n\t\t\t// Insert mode\n\t\t\tgoto doESCkey;\n\t\t    break;\n\t\t}\n\t    }\n#endif\n\n#ifdef UNIX\ndo_intr:\n#endif\n\t    // when 'insertmode' set, and not halfway a mapping, don't leave\n\t    // Insert mode\n\t    if (goto_im())\n\t    {\n\t\tif (got_int)\n\t\t{\n\t\t    (void)vgetc();\t\t// flush all buffers\n\t\t    got_int = FALSE;\n\t\t}\n\t\telse\n\t\t    vim_beep(BO_IM);\n\t\tbreak;\n\t    }\ndoESCkey:\n\t    /*\n\t     * This is the ONLY return from edit()!\n\t     */\n\t    // Always update o_lnum, so that a \"CTRL-O .\" that adds a line\n\t    // still puts the cursor back after the inserted text.\n\t    if (ins_at_eol && gchar_cursor() == NUL)\n\t\to_lnum = curwin->w_cursor.lnum;\n\n\t    if (ins_esc(&count, cmdchar, nomove))\n\t    {\n\t\t// When CTRL-C was typed got_int will be set, with the result\n\t\t// that the autocommands won't be executed. When mapped got_int\n\t\t// is not set, but let's keep the behavior the same.\n\t\tif (cmdchar != 'r' && cmdchar != 'v' && c != Ctrl_C)\n\t\t    ins_apply_autocmds(EVENT_INSERTLEAVE);\n\t\tdid_cursorhold = FALSE;\n\t\treturn (c == Ctrl_O);\n\t    }\n\t    continue;\n\n\tcase Ctrl_Z:\t// suspend when 'insertmode' set\n\t    if (!p_im)\n\t\tgoto normalchar;\t// insert CTRL-Z as normal char\n\t    do_cmdline_cmd((char_u *)\"stop\");\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t\t// may need to update cursor shape\n#endif\n\t    continue;\n\n\tcase Ctrl_O:\t// execute one command\n#ifdef FEAT_COMPL_FUNC\n\t    if (ctrl_x_mode_omni())\n\t\tgoto docomplete;\n#endif\n\t    if (echeck_abbr(Ctrl_O + ABBR_OFF))\n\t\tbreak;\n\t    ins_ctrl_o();\n\n\t    // don't move the cursor left when 'virtualedit' has \"onemore\".\n\t    if (get_ve_flags() & VE_ONEMORE)\n\t    {\n\t\tins_at_eol = FALSE;\n\t\tnomove = TRUE;\n\t    }\n\t    count = 0;\n\t    goto doESCkey;\n\n\tcase K_INS:\t// toggle insert/replace mode\n\tcase K_KINS:\n\t    ins_insert(replaceState);\n\t    break;\n\n\tcase K_SELECT:\t// end of Select mode mapping - ignore\n\t    break;\n\n\tcase K_HELP:\t// Help key works like <ESC> <Help>\n\tcase K_F1:\n\tcase K_XF1:\n\t    stuffcharReadbuff(K_HELP);\n\t    if (p_im)\n\t\tneed_start_insertmode = TRUE;\n\t    goto doESCkey;\n\n#ifdef FEAT_NETBEANS_INTG\n\tcase K_F21:\t// NetBeans command\n\t    ++no_mapping;\t\t// don't map the next key hits\n\t    i = plain_vgetc();\n\t    --no_mapping;\n\t    netbeans_keycommand(i);\n\t    break;\n#endif\n\n\tcase K_ZERO:\t// Insert the previously inserted text.\n\tcase NUL:\n\tcase Ctrl_A:\n\t    // For ^@ the trailing ESC will end the insert, unless there is an\n\t    // error.\n\t    if (stuff_inserted(NUL, 1L, (c == Ctrl_A)) == FAIL\n\t\t\t\t\t\t   && c != Ctrl_A && !p_im)\n\t\tgoto doESCkey;\t\t// quit insert mode\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_R:\t// insert the contents of a register\n\t    ins_reg();\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_G:\t// commands starting with CTRL-G\n\t    ins_ctrl_g();\n\t    break;\n\n\tcase Ctrl_HAT:\t// switch input mode and/or langmap\n\t    ins_ctrl_hat();\n\t    break;\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t// switch between languages\n\t    if (!p_ari)\n\t\tgoto normalchar;\n\t    ins_ctrl_();\n\t    break;\n#endif\n\n\tcase Ctrl_D:\t// Make indent one shiftwidth smaller.\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_defines())\n\t\tgoto docomplete;\n#endif\n\t    // FALLTHROUGH\n\n\tcase Ctrl_T:\t// Make indent one shiftwidth greater.\n\t    if (c == Ctrl_T && ctrl_x_mode_thesaurus())\n\t    {\n\t\tif (has_compl_option(FALSE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n\n\t    ins_shift(c, lastc);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_DEL:\t// delete character under the cursor\n\tcase K_KDEL:\n\t    ins_del();\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_BS:\t// delete character before the cursor\n\tcase K_S_BS:\n\tcase Ctrl_H:\n\t    did_backspace = ins_bs(c, BACKSPACE_CHAR, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_W:\t// delete word before the cursor\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf) && (mod_mask & MOD_MASK_SHIFT) == 0)\n\t    {\n\t\t// In a prompt window CTRL-W is used for window commands.\n\t\t// Use Shift-CTRL-W to delete a word.\n\t\tstuffcharReadbuff(Ctrl_W);\n\t\trestart_edit = 'A';\n\t\tnomove = TRUE;\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n#endif\n\t    did_backspace = ins_bs(c, BACKSPACE_WORD, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_U:\t// delete all inserted text in current line\n# ifdef FEAT_COMPL_FUNC\n\t    // CTRL-X CTRL-U completes with 'completefunc'.\n\t    if (ctrl_x_mode_function())\n\t\tgoto docomplete;\n# endif\n\t    did_backspace = ins_bs(c, BACKSPACE_LINE, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_LEFTMOUSE:   // mouse keys\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\t    ins_mouse(c);\n\t    break;\n\n\tcase K_MOUSEDOWN: // Default action for scroll wheel up: scroll up\n\t    ins_mousescroll(MSCR_DOWN);\n\t    break;\n\n\tcase K_MOUSEUP:\t// Default action for scroll wheel down: scroll down\n\t    ins_mousescroll(MSCR_UP);\n\t    break;\n\n\tcase K_MOUSELEFT: // Scroll wheel left\n\t    ins_mousescroll(MSCR_LEFT);\n\t    break;\n\n\tcase K_MOUSERIGHT: // Scroll wheel right\n\t    ins_mousescroll(MSCR_RIGHT);\n\t    break;\n\n\tcase K_PS:\n\t    bracketed_paste(PASTE_INSERT, FALSE, NULL);\n\t    if (cmdchar == K_PS)\n\t\t// invoked from normal mode, bail out\n\t\tgoto doESCkey;\n\t    break;\n\tcase K_PE:\n\t    // Got K_PE without K_PS, ignore.\n\t    break;\n\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t    ins_tabline(c);\n\t    break;\n#endif\n\n\tcase K_IGNORE:\t// Something mapped to nothing\n\t    break;\n\n\tcase K_COMMAND:\t\t    // <Cmd>command<CR>\n\tcase K_SCRIPT_COMMAND:\t    // <ScriptCmd>command<CR>\n\t    do_cmdkey_command(c, 0);\n#ifdef FEAT_TERMINAL\n\t    if (term_use_loop())\n\t\t// Started a terminal that gets the input, exit Insert mode.\n\t\tgoto doESCkey;\n#endif\n\t    break;\n\n\tcase K_CURSORHOLD:\t// Didn't type something for a while.\n\t    ins_apply_autocmds(EVENT_CURSORHOLDI);\n\t    did_cursorhold = TRUE;\n\t    // If CTRL-G U was used apply it to the next typed key.\n\t    if (dont_sync_undo == TRUE)\n\t\tdont_sync_undo = MAYBE;\n\t    break;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask != MOD_MASK_ALT)\n\t\tgoto normalchar;\n\t    break;\n#endif\n\n#ifdef FEAT_GUI\n\tcase K_VER_SCROLLBAR:\n\t    ins_scroll();\n\t    break;\n\n\tcase K_HOR_SCROLLBAR:\n\t    ins_horscroll();\n\t    break;\n#endif\n\n\tcase K_HOME:\t// <Home>\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t    ins_home(c);\n\t    break;\n\n\tcase K_END:\t// <End>\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t    ins_end(c);\n\t    break;\n\n\tcase K_LEFT:\t// <Left>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_left();\n\t    else\n\t\tins_left();\n\t    break;\n\n\tcase K_S_LEFT:\t// <S-Left>\n\tcase K_C_LEFT:\n\t    ins_s_left();\n\t    break;\n\n\tcase K_RIGHT:\t// <Right>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_right();\n\t    else\n\t\tins_right();\n\t    break;\n\n\tcase K_S_RIGHT:\t// <S-Right>\n\tcase K_C_RIGHT:\n\t    ins_s_right();\n\t    break;\n\n\tcase K_UP:\t// <Up>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pageup();\n\t    else\n\t\tins_up(FALSE);\n\t    break;\n\n\tcase K_S_UP:\t// <S-Up>\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pageup();\n\t    break;\n\n\tcase K_DOWN:\t// <Down>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pagedown();\n\t    else\n\t\tins_down(FALSE);\n\t    break;\n\n\tcase K_S_DOWN:\t// <S-Down>\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pagedown();\n\t    break;\n\n#ifdef FEAT_DND\n\tcase K_DROP:\t// drag-n-drop event\n\t    ins_drop();\n\t    break;\n#endif\n\n\tcase K_S_TAB:\t// When not mapped, use like a normal TAB\n\t    c = TAB;\n\t    // FALLTHROUGH\n\n\tcase TAB:\t// TAB or Complete patterns along path\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_patterns())\n\t\tgoto docomplete;\n#endif\n\t    inserted_space = FALSE;\n\t    if (ins_tab())\n\t\tgoto normalchar;\t// insert TAB as a normal char\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_KENTER:\t// <Enter>\n\t    c = CAR;\n\t    // FALLTHROUGH\n\tcase CAR:\n\tcase NL:\n#if defined(FEAT_QUICKFIX)\n\t    // In a quickfix window a <CR> jumps to the error under the\n\t    // cursor.\n\t    if (bt_quickfix(curbuf) && c == CAR)\n\t    {\n\t\tif (curwin->w_llist_ref == NULL)    // quickfix window\n\t\t    do_cmdline_cmd((char_u *)\".cc\");\n\t\telse\t\t\t\t    // location list window\n\t\t    do_cmdline_cmd((char_u *)\".ll\");\n\t\tbreak;\n\t    }\n#endif\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0)\n\t    {\n\t\t// Execute the command in the cmdline window.\n\t\tcmdwin_result = CAR;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf))\n\t    {\n\t\tinvoke_prompt_callback();\n\t\tif (!bt_prompt(curbuf))\n\t\t    // buffer changed to a non-prompt buffer, get out of\n\t\t    // Insert mode\n\t\t    goto doESCkey;\n\t\tbreak;\n\t    }\n#endif\n\t    if (ins_eol(c) == FAIL && !p_im)\n\t\tgoto doESCkey;\t    // out of memory\n\t    auto_format(FALSE, FALSE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_K:\t    // digraph or keyword completion\n\t    if (ctrl_x_mode_dictionary())\n\t    {\n\t\tif (has_compl_option(TRUE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n#ifdef FEAT_DIGRAPHS\n\t    c = ins_digraph();\n\t    if (c == NUL)\n\t\tbreak;\n#endif\n\t    goto normalchar;\n\n\tcase Ctrl_X:\t// Enter CTRL-X mode\n\t    ins_ctrl_x();\n\t    break;\n\n\tcase Ctrl_RSB:\t// Tag name completion after ^X\n\t    if (!ctrl_x_mode_tags())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_F:\t// File name completion after ^X\n\t    if (!ctrl_x_mode_files())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase 's':\t// Spelling completion after ^X\n\tcase Ctrl_S:\n\t    if (!ctrl_x_mode_spell())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_L:\t// Whole line completion after ^X\n\t    if (!ctrl_x_mode_whole_line())\n\t    {\n\t\t// CTRL-L with 'insertmode' set: Leave Insert mode\n\t\tif (p_im)\n\t\t{\n\t\t    if (echeck_abbr(Ctrl_L + ABBR_OFF))\n\t\t\tbreak;\n\t\t    goto doESCkey;\n\t\t}\n\t\tgoto normalchar;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase Ctrl_P:\t// Do previous/next pattern completion\n\tcase Ctrl_N:\n\t    // if 'complete' is empty then plain ^P is no longer special,\n\t    // but it is under other ^X modes\n\t    if (*curbuf->b_p_cpt == NUL\n\t\t    && (ctrl_x_mode_normal() || ctrl_x_mode_whole_line())\n\t\t    && !compl_status_local())\n\t\tgoto normalchar;\n\ndocomplete:\n\t    compl_busy = TRUE;\n#ifdef FEAT_FOLDING\n\t    disable_fold_update++;  // don't redraw folds here\n#endif\n\t    if (ins_complete(c, TRUE) == FAIL)\n\t\tcompl_status_clear();\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    compl_busy = FALSE;\n\t    can_si = may_do_si(); // allow smartindenting\n\t    break;\n\n\tcase Ctrl_Y:\t// copy from previous line or scroll down\n\tcase Ctrl_E:\t// copy from next line\t   or scroll up\n\t    c = ins_ctrl_ey(c);\n\t    break;\n\n\t  default:\n#ifdef UNIX\n\t    if (c == intr_char)\t\t// special interrupt char\n\t\tgoto do_intr;\n#endif\n\nnormalchar:\n\t    /*\n\t     * Insert a normal character.\n\t     */\n#if defined(FEAT_EVAL)\n\t    if (!p_paste)\n\t    {\n\t\t// Trigger InsertCharPre.\n\t\tchar_u *str = do_insert_char_pre(c);\n\t\tchar_u *p;\n\n\t\tif (str != NULL)\n\t\t{\n\t\t    if (*str != NUL && stop_arrow() != FAIL)\n\t\t    {\n\t\t\t// Insert the new value of v:char literally.\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t{\n\t\t\t    c = PTR2CHAR(p);\n\t\t\t    if (c == CAR || c == K_KENTER || c == NL)\n\t\t\t\tins_eol(c);\n\t\t\t    else\n\t\t\t\tins_char(c);\n\t\t\t}\n\t\t\tAppendToRedobuffLit(str, -1);\n\t\t    }\n\t\t    vim_free(str);\n\t\t    c = NUL;\n\t\t}\n\n\t\t// If the new value is already inserted or an empty string\n\t\t// then don't insert any character.\n\t\tif (c == NUL)\n\t\t    break;\n\t    }\n#endif\n\t    // Try to perform smart-indenting.\n\t    ins_try_si(c);\n\n\t    if (c == ' ')\n\t    {\n\t\tinserted_space = TRUE;\n\t\tif (inindent(0))\n\t\t    can_cindent = FALSE;\n\t\tif (Insstart_blank_vcol == MAXCOL\n\t\t\t&& curwin->w_cursor.lnum == Insstart.lnum)\n\t\t    Insstart_blank_vcol = get_nolist_virtcol();\n\t    }\n\n\t    // Insert a normal character and check for abbreviations on a\n\t    // special character.  Let CTRL-] expand abbreviations without\n\t    // inserting it.\n\t    if (vim_iswordc(c) || (!echeck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t\t&& c != Ctrl_RSB))\n\t    {\n\t\tinsert_special(c, FALSE, FALSE);\n#ifdef FEAT_RIGHTLEFT\n\t\trevins_legal++;\n\t\trevins_chars++;\n#endif\n\t    }\n\n\t    auto_format(FALSE, TRUE);\n\n#ifdef FEAT_FOLDING\n\t    // When inserting a character the cursor line must never be in a\n\t    // closed fold.\n\t    foldOpenCursor();\n#endif\n\t    break;\n\t}   // end of switch (c)\n\n\t// If typed something may trigger CursorHoldI again.\n\tif (c != K_CURSORHOLD\n#ifdef FEAT_COMPL_FUNC\n\t\t// but not in CTRL-X mode, a script can't restore the state\n\t\t&& ctrl_x_mode_normal()\n#endif\n\t       )\n\t    did_cursorhold = FALSE;\n\n\t// If the cursor was moved we didn't just insert a space\n\tif (arrow_used)\n\t    inserted_space = FALSE;\n\n\tif (can_cindent && cindent_on() && ctrl_x_mode_normal())\n\t{\nforce_cindent:\n\t    /*\n\t     * Indent now if a key was typed that is in 'cinkeys'.\n\t     */\n\t    if (in_cinkeys(c, ' ', line_is_white))\n\t    {\n\t\tif (stop_arrow() == OK)\n\t\t    // re-indent the current line\n\t\t    do_c_expr_indent();\n\t    }\n\t}\n\n    }\t// for (;;)\n    // NOTREACHED\n}\n\n    int\nins_need_undo_get(void)\n{\n    return ins_need_undo;\n}\n\n/*\n * Redraw for Insert mode.\n * This is postponed until getting the next character to make '$' in the 'cpo'\n * option work correctly.\n * Only redraw when there are no characters available.  This speeds up\n * inserting sequences of characters (e.g., for CTRL-R).\n */\n    void\nins_redraw(int ready)\t    // not busy with something\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\tconceal_old_cursor_line = 0;\n    linenr_T\tconceal_new_cursor_line = 0;\n    int\t\tconceal_update_lines = FALSE;\n#endif\n\n    if (char_avail())\n\treturn;\n\n    // Trigger CursorMoved if the cursor moved.  Not when the popup menu is\n    // visible, the command might delete it.\n    if (ready && (has_cursormovedI()\n# ifdef FEAT_PROP_POPUP\n\t\t|| popup_visible\n# endif\n# if defined(FEAT_CONCEAL)\n\t\t|| curwin->w_p_cole > 0\n# endif\n\t\t)\n\t    && !EQUAL_POS(last_cursormoved, curwin->w_cursor)\n\t    && !pum_visible())\n    {\n# ifdef FEAT_SYN_HL\n\t// Need to update the screen first, to make sure syntax\n\t// highlighting is correct after making a change (e.g., inserting\n\t// a \"(\".  The autocommand may also require a redraw, so it's done\n\t// again below, unfortunately.\n\tif (syntax_present(curwin) && must_redraw)\n\t    update_screen(0);\n# endif\n\tif (has_cursormovedI())\n\t{\n\t    // Make sure curswant is correct, an autocommand may call\n\t    // getcurpos().\n\t    update_curswant();\n\t    ins_apply_autocmds(EVENT_CURSORMOVEDI);\n\t}\n#ifdef FEAT_PROP_POPUP\n\tif (popup_visible)\n\t    popup_check_cursor_pos();\n#endif\n# ifdef FEAT_CONCEAL\n\tif (curwin->w_p_cole > 0)\n\t{\n\t    conceal_old_cursor_line = last_cursormoved.lnum;\n\t    conceal_new_cursor_line = curwin->w_cursor.lnum;\n\t    conceal_update_lines = TRUE;\n\t}\n# endif\n\tlast_cursormoved = curwin->w_cursor;\n    }\n\n    // Trigger TextChangedI if b_changedtick_i differs.\n    if (ready && has_textchangedI()\n\t    && curbuf->b_last_changedtick_i != CHANGEDTICK(curbuf)\n\t    && !pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    // Trigger TextChangedP if b_changedtick_pum differs. When the popupmenu\n    // closes TextChangedI will need to trigger for backwards compatibility,\n    // thus use different b_last_changedtick* variables.\n    if (ready && has_textchangedP()\n\t    && curbuf->b_last_changedtick_pum != CHANGEDTICK(curbuf)\n\t    && pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDP, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    if (ready)\n\tmay_trigger_winscrolled();\n\n    // Trigger SafeState if nothing is pending.\n    may_trigger_safestate(ready\n\t    && !ins_compl_active()\n\t    && !pum_visible());\n\n#if defined(FEAT_CONCEAL)\n    if ((conceal_update_lines\n\t    && (conceal_old_cursor_line != conceal_new_cursor_line\n\t\t|| conceal_cursor_line(curwin)))\n\t    || need_cursor_line_redraw)\n    {\n\tif (conceal_old_cursor_line != conceal_new_cursor_line)\n\t    redrawWinline(curwin, conceal_old_cursor_line);\n\tredrawWinline(curwin, conceal_new_cursor_line == 0\n\t\t\t    ? curwin->w_cursor.lnum : conceal_new_cursor_line);\n\tcurwin->w_valid &= ~VALID_CROW;\n\tneed_cursor_line_redraw = FALSE;\n    }\n#endif\n    if (must_redraw)\n\tupdate_screen(0);\n    else if (clear_cmdline || redraw_cmdline)\n\tshowmode();\t\t// clear cmdline and show mode\n    showruler(FALSE);\n    setcursor();\n    emsg_on_display = FALSE;\t// may remove error message now\n}\n\n/*\n * Handle a CTRL-V or CTRL-Q typed in Insert mode.\n */\n    static void\nins_ctrl_v(void)\n{\n    int\t\tc;\n    int\t\tdid_putchar = FALSE;\n\n    // may need to redraw when no more chars available now\n    ins_redraw(FALSE);\n\n    if (redrawing() && !char_avail())\n    {\n\tedit_putchar('^', TRUE);\n\tdid_putchar = TRUE;\n    }\n    AppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\n#ifdef FEAT_CMDL_INFO\n    add_to_showcmd_c(Ctrl_V);\n#endif\n\n    // Do not change any modifyOtherKeys ESC sequence to a normal key for\n    // CTRL-SHIFT-V.\n    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n    if (did_putchar)\n\t// when the line fits in 'columns' the '^' is at the start of the next\n\t// line and will not removed by the redraw\n\tedit_unputchar();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    insert_special(c, FALSE, TRUE);\n#ifdef FEAT_RIGHTLEFT\n    revins_chars++;\n    revins_legal++;\n#endif\n}\n\n/*\n * After getting an ESC or CSI for a literal key: If the typeahead buffer\n * contains a modifyOtherKeys sequence then decode it and return the result.\n * Otherwise return \"c\".\n * Note that this doesn't wait for characters, they must be in the typeahead\n * buffer already.\n */\n    static int\ndecodeModifyOtherKeys(int c)\n{\n    char_u  *p = typebuf.tb_buf + typebuf.tb_off;\n    int\t    idx;\n    int\t    form = 0;\n    int\t    argidx = 0;\n    int\t    arg[2] = {0, 0};\n\n    // Recognize:\n    // form 0: {lead}{key};{modifier}u\n    // form 1: {lead}27;{modifier};{key}~\n    if (typebuf.tb_len >= 4 && (c == CSI || (c == ESC && *p == '[')))\n    {\n\tidx = (*p == '[');\n\tif (p[idx] == '2' && p[idx + 1] == '7' && p[idx + 2] == ';')\n\t{\n\t    form = 1;\n\t    idx += 3;\n\t}\n\twhile (idx < typebuf.tb_len && argidx < 2)\n\t{\n\t    if (p[idx] == ';')\n\t\t++argidx;\n\t    else if (VIM_ISDIGIT(p[idx]))\n\t\targ[argidx] = arg[argidx] * 10 + (p[idx] - '0');\n\t    else\n\t\tbreak;\n\t    ++idx;\n\t}\n\tif (idx < typebuf.tb_len\n\t\t&& p[idx] == (form == 1 ? '~' : 'u')\n\t\t&& argidx == 1)\n\t{\n\t    // Match, consume the code.\n\t    typebuf.tb_off += idx + 1;\n\t    typebuf.tb_len -= idx + 1;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    if (typebuf.tb_len == 0)\n\t\ttypebuf_was_filled = FALSE;\n#endif\n\n\t    mod_mask = decode_modifiers(arg[!form]);\n\t    c = merge_modifyOtherKeys(arg[form], &mod_mask);\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Put a character directly onto the screen.  It's not stored in a buffer.\n * Used while handling CTRL-K, CTRL-V, etc. in Insert mode.\n */\nstatic int  pc_status;\n#define PC_STATUS_UNSET\t0\t// pc_bytes was not set\n#define PC_STATUS_RIGHT\t1\t// right half of double-wide char\n#define PC_STATUS_LEFT\t2\t// left half of double-wide char\n#define PC_STATUS_SET\t3\t// pc_bytes was filled\nstatic char_u pc_bytes[MB_MAXBYTES + 1]; // saved bytes\nstatic int  pc_attr;\nstatic int  pc_row;\nstatic int  pc_col;\n\n    void\nedit_putchar(int c, int highlight)\n{\n    int\t    attr;\n\n    if (ScreenLines != NULL)\n    {\n\tupdate_topline();\t// just in case w_topline isn't valid\n\tvalidate_cursor();\n\tif (highlight)\n\t    attr = HL_ATTR(HLF_8);\n\telse\n\t    attr = 0;\n\tpc_row = W_WINROW(curwin) + curwin->w_wrow;\n\tpc_col = curwin->w_wincol;\n\tpc_status = PC_STATUS_UNSET;\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t{\n\t    pc_col += curwin->w_width - 1 - curwin->w_wcol;\n\t    if (has_mbyte)\n\t    {\n\t\tint fix_col = mb_fix_col(pc_col, pc_row);\n\n\t\tif (fix_col != pc_col)\n\t\t{\n\t\t    screen_putchar(' ', pc_row, fix_col, attr);\n\t\t    --curwin->w_wcol;\n\t\t    pc_status = PC_STATUS_RIGHT;\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    pc_col += curwin->w_wcol;\n\t    if (mb_lefthalve(pc_row, pc_col))\n\t\tpc_status = PC_STATUS_LEFT;\n\t}\n\n\t// save the character to be able to put it back\n\tif (pc_status == PC_STATUS_UNSET)\n\t{\n\t    screen_getbytes(pc_row, pc_col, pc_bytes, &pc_attr);\n\t    pc_status = PC_STATUS_SET;\n\t}\n\tscreen_putchar(c, pc_row, pc_col, attr);\n    }\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Set the insert start position for when using a prompt buffer.\n */\n    void\nset_insstart(linenr_T lnum, int col)\n{\n    Insstart.lnum = lnum;\n    Insstart.col = col;\n    Insstart_orig = Insstart;\n    Insstart_textlen = Insstart.col;\n    Insstart_blank_vcol = MAXCOL;\n    arrow_used = FALSE;\n}\n#endif\n\n/*\n * Undo the previous edit_putchar().\n */\n    void\nedit_unputchar(void)\n{\n    if (pc_status != PC_STATUS_UNSET && pc_row >= msg_scrolled)\n    {\n\tif (pc_status == PC_STATUS_RIGHT)\n\t    ++curwin->w_wcol;\n\tif (pc_status == PC_STATUS_RIGHT || pc_status == PC_STATUS_LEFT)\n\t    redrawWinline(curwin, curwin->w_cursor.lnum);\n\telse\n\t    screen_puts(pc_bytes, pc_row - msg_scrolled, pc_col, pc_attr);\n    }\n}\n\n/*\n * Called when p_dollar is set: display a '$' at the end of the changed text\n * Only works when cursor is in the line that changes.\n */\n    void\ndisplay_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}\n\n/*\n * Call this function before moving the cursor from the normal insert position\n * in insert mode.\n */\n    void\nundisplay_dollar(void)\n{\n    if (dollar_vcol >= 0)\n    {\n\tdollar_vcol = -1;\n\tredrawWinline(curwin, curwin->w_cursor.lnum);\n    }\n}\n\n/*\n * Truncate the space at the end of a line.  This is to be used only in an\n * insert mode.  It handles fixing the replace stack for MODE_REPLACE and\n * MODE_VREPLACE modes.\n */\n    void\ntruncate_spaces(char_u *line)\n{\n    int\t    i;\n\n    // find start of trailing white space\n    for (i = (int)STRLEN(line) - 1; i >= 0 && VIM_ISWHITE(line[i]); i--)\n    {\n\tif (State & REPLACE_FLAG)\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n    }\n    line[i + 1] = NUL;\n}\n\n/*\n * Backspace the cursor until the given column.  Handles MODE_REPLACE and\n * MODE_VREPLACE modes correctly.  May also be used when not in insert mode at\n * all.  Will attempt not to go before \"col\" even when there is a composing\n * character.\n */\n    void\nbackspace_until_column(int col)\n{\n    while ((int)curwin->w_cursor.col > col)\n    {\n\tcurwin->w_cursor.col--;\n\tif (State & REPLACE_FLAG)\n\t    replace_do_bs(col);\n\telse if (!del_char_after_col(col))\n\t    break;\n    }\n}\n\n/*\n * Like del_char(), but make sure not to go before column \"limit_col\".\n * Only matters when there are composing characters.\n * Return TRUE when something was deleted.\n */\n   static int\ndel_char_after_col(int limit_col UNUSED)\n{\n    if (enc_utf8 && limit_col >= 0)\n    {\n\tcolnr_T ecol = curwin->w_cursor.col + 1;\n\n\t// Make sure the cursor is at the start of a character, but\n\t// skip forward again when going too far back because of a\n\t// composing character.\n\tmb_adjust_cursor();\n\twhile (curwin->w_cursor.col < (colnr_T)limit_col)\n\t{\n\t    int l = utf_ptr2len(ml_get_cursor());\n\n\t    if (l == 0)  // end of line\n\t\tbreak;\n\t    curwin->w_cursor.col += l;\n\t}\n\tif (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)\n\t    return FALSE;\n\tdel_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);\n    }\n    else\n\t(void)del_char(FALSE);\n    return TRUE;\n}\n\n/*\n * Next character is interpreted literally.\n * A one, two or three digit decimal number is interpreted as its byte value.\n * If one or two digits are entered, the next character is given to vungetc().\n * For Unicode a character > 255 may be returned.\n * If \"noReduceKeys\" is TRUE do not change any modifyOtherKeys ESC sequence\n * into a normal key, return ESC.\n */\n    int\nget_literal(int noReduceKeys)\n{\n    int\t\tcc;\n    int\t\tnc;\n    int\t\ti;\n    int\t\thex = FALSE;\n    int\t\toctal = FALSE;\n    int\t\tunicode = 0;\n\n    if (got_int)\n\treturn Ctrl_C;\n\n#ifdef FEAT_GUI\n    /*\n     * In GUI there is no point inserting the internal code for a special key.\n     * It is more useful to insert the string \"<KEY>\" instead.\tThis would\n     * probably be useful in a text window too, but it would not be\n     * vi-compatible (maybe there should be an option for it?) -- webb\n     */\n    if (gui.in_use)\n    {\n\t++allow_keys;\n\tif (noReduceKeys)\n\t    ++no_reduce_keys;\n    }\n#endif\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    ++no_mapping;\t\t// don't map the next key hits\n    cc = 0;\n    i = 0;\n    for (;;)\n    {\n\tnc = plain_vgetc();\n\tif ((nc == ESC || nc == CSI) && !noReduceKeys)\n\t    nc = decodeModifyOtherKeys(nc);\n\n\tif ((mod_mask & ~MOD_MASK_SHIFT) != 0)\n\t    // A character with non-Shift modifiers should not be a valid\n\t    // character for i_CTRL-V_digit.\n\t    break;\n\n#ifdef FEAT_CMDL_INFO\n\tif ((State & MODE_CMDLINE) == 0 && MB_BYTE2LEN_CHECK(nc) == 1)\n\t    add_to_showcmd(nc);\n#endif\n\tif (nc == 'x' || nc == 'X')\n\t    hex = TRUE;\n\telse if (nc == 'o' || nc == 'O')\n\t    octal = TRUE;\n\telse if (nc == 'u' || nc == 'U')\n\t    unicode = nc;\n\telse\n\t{\n\t    if (hex || unicode != 0)\n\t    {\n\t\tif (!vim_isxdigit(nc))\n\t\t    break;\n\t\tcc = cc * 16 + hex2nr(nc);\n\t    }\n\t    else if (octal)\n\t    {\n\t\tif (nc < '0' || nc > '7')\n\t\t    break;\n\t\tcc = cc * 8 + nc - '0';\n\t    }\n\t    else\n\t    {\n\t\tif (!VIM_ISDIGIT(nc))\n\t\t    break;\n\t\tcc = cc * 10 + nc - '0';\n\t    }\n\n\t    ++i;\n\t}\n\n\tif (cc > 255 && unicode == 0)\n\t    cc = 255;\t\t// limit range to 0-255\n\tnc = 0;\n\n\tif (hex)\t\t// hex: up to two chars\n\t{\n\t    if (i >= 2)\n\t\tbreak;\n\t}\n\telse if (unicode)\t// Unicode: up to four or eight chars\n\t{\n\t    if ((unicode == 'u' && i >= 4) || (unicode == 'U' && i >= 8))\n\t\tbreak;\n\t}\n\telse if (i >= 3)\t// decimal or octal: up to three chars\n\t    break;\n    }\n    if (i == 0)\t    // no number entered\n    {\n\tif (nc == K_ZERO)   // NUL is stored as NL\n\t{\n\t    cc = '\\n';\n\t    nc = 0;\n\t}\n\telse\n\t{\n\t    cc = nc;\n\t    nc = 0;\n\t}\n    }\n\n    if (cc == 0)\t// NUL is stored as NL\n\tcc = '\\n';\n    if (enc_dbcs && (cc & 0xff) == 0)\n\tcc = '?';\t// don't accept an illegal DBCS char, the NUL in the\n\t\t\t// second byte will cause trouble!\n\n    --no_mapping;\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\t--allow_keys;\n\tif (noReduceKeys)\n\t    --no_reduce_keys;\n    }\n#endif\n    if (nc)\n    {\n\tvungetc(nc);\n\t// A character typed with i_CTRL-V_digit cannot have modifiers.\n\tmod_mask = 0;\n    }\n    got_int = FALSE;\t    // CTRL-C typed after CTRL-V is not an interrupt\n    return cc;\n}\n\n/*\n * Insert character, taking care of special keys and mod_mask\n */\n    static void\ninsert_special(\n    int\t    c,\n    int\t    allow_modmask,\n    int\t    ctrlv)\t    // c was typed after CTRL-V\n{\n    char_u  *p;\n    int\t    len;\n\n    /*\n     * Special function key, translate into \"<Key>\". Up to the last '>' is\n     * inserted with ins_str(), so as not to replace characters in replace\n     * mode.\n     * Only use mod_mask for special keys, to avoid things like <S-Space>,\n     * unless 'allow_modmask' is TRUE.\n     */\n#ifdef MACOS_X\n    // Command-key never produces a normal key\n    if (mod_mask & MOD_MASK_CMD)\n\tallow_modmask = TRUE;\n#endif\n    if (IS_SPECIAL(c) || (mod_mask && allow_modmask))\n    {\n\tp = get_special_key_name(c, mod_mask);\n\tlen = (int)STRLEN(p);\n\tc = p[len - 1];\n\tif (len > 2)\n\t{\n\t    if (stop_arrow() == FAIL)\n\t\treturn;\n\t    p[len - 1] = NUL;\n\t    ins_str(p);\n\t    AppendToRedobuffLit(p, -1);\n\t    ctrlv = FALSE;\n\t}\n    }\n    if (stop_arrow() == OK)\n\tinsertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);\n}\n\n/*\n * Special characters in this context are those that need processing other\n * than the simple insertion that can be performed here. This includes ESC\n * which terminates the insert, and CR/NL which need special processing to\n * open up a new line. This routine tries to optimize insertions performed by\n * the \"redo\", \"undo\" or \"put\" commands, so it needs to know when it should\n * stop and defer processing to the \"normal\" mechanism.\n * '0' and '^' are special, because they can be followed by CTRL-D.\n */\n#define ISSPECIAL(c)\t((c) < ' ' || (c) >= DEL || (c) == '0' || (c) == '^')\n\n/*\n * \"flags\": INSCHAR_FORMAT - force formatting\n *\t    INSCHAR_CTRLV  - char typed just after CTRL-V\n *\t    INSCHAR_NO_FEX - don't use 'formatexpr'\n *\n *   NOTE: passes the flags value straight through to internal_format() which,\n *\t   beside INSCHAR_FORMAT (above), is also looking for these:\n *\t    INSCHAR_DO_COM   - format comments\n *\t    INSCHAR_COM_LIST - format comments with num list or 2nd line indent\n */\n    void\ninsertchar(\n    int\t\tc,\t\t\t// character to insert or NUL\n    int\t\tflags,\t\t\t// INSCHAR_FORMAT, etc.\n    int\t\tsecond_indent)\t\t// indent for second line if >= 0\n{\n    int\t\ttextwidth;\n    char_u\t*p;\n    int\t\tfo_ins_blank;\n    int\t\tforce_format = flags & INSCHAR_FORMAT;\n\n    textwidth = comp_textwidth(force_format);\n    fo_ins_blank = has_format_option(FO_INS_BLANK);\n\n    /*\n     * Try to break the line in two or more pieces when:\n     * - Always do this if we have been called to do formatting only.\n     * - Always do this when 'formatoptions' has the 'a' flag and the line\n     *   ends in white space.\n     * - Otherwise:\n     *\t - Don't do this if inserting a blank\n     *\t - Don't do this if an existing character is being replaced, unless\n     *\t   we're in MODE_VREPLACE state.\n     *\t - Do this if the cursor is not on the line where insert started\n     *\t or - 'formatoptions' doesn't have 'l' or the line was not too long\n     *\t       before the insert.\n     *\t    - 'formatoptions' doesn't have 'b' or a blank was inserted at or\n     *\t      before 'textwidth'\n     */\n    if (textwidth > 0\n\t    && (force_format\n\t\t|| (!VIM_ISWHITE(c)\n\t\t    && !((State & REPLACE_FLAG)\n\t\t\t&& !(State & VREPLACE_FLAG)\n\t\t\t&& *ml_get_cursor() != NUL)\n\t\t    && (curwin->w_cursor.lnum != Insstart.lnum\n\t\t\t|| ((!has_format_option(FO_INS_LONG)\n\t\t\t\t|| Insstart_textlen <= (colnr_T)textwidth)\n\t\t\t    && (!fo_ins_blank\n\t\t\t\t|| Insstart_blank_vcol <= (colnr_T)textwidth\n\t\t\t    ))))))\n    {\n\t// Format with 'formatexpr' when it's set.  Use internal formatting\n\t// when 'formatexpr' isn't set or it returns non-zero.\n#if defined(FEAT_EVAL)\n\tint     do_internal = TRUE;\n\tcolnr_T virtcol = get_nolist_virtcol()\n\t\t\t\t  + char2cells(c != NUL ? c : gchar_cursor());\n\n\tif (*curbuf->b_p_fex != NUL && (flags & INSCHAR_NO_FEX) == 0\n\t\t&& (force_format || virtcol > (colnr_T)textwidth))\n\t{\n\t    do_internal = (fex_format(curwin->w_cursor.lnum, 1L, c) != 0);\n\t    // It may be required to save for undo again, e.g. when setline()\n\t    // was called.\n\t    ins_need_undo = TRUE;\n\t}\n\tif (do_internal)\n#endif\n\t    internal_format(textwidth, second_indent, flags, c == NUL, c);\n    }\n\n    if (c == NUL)\t    // only formatting was wanted\n\treturn;\n\n    // Check whether this character should end a comment.\n    if (did_ai && c == end_comment_pending)\n    {\n\tchar_u  *line;\n\tchar_u\tlead_end[COM_MAX_LEN];\t    // end-comment string\n\tint\tmiddle_len, end_len;\n\tint\ti;\n\n\t/*\n\t * Need to remove existing (middle) comment leader and insert end\n\t * comment leader.  First, check what comment leader we can find.\n\t */\n\ti = get_leader_len(line = ml_get_curline(), &p, FALSE, TRUE);\n\tif (i > 0 && vim_strchr(p, COM_MIDDLE) != NULL)\t// Just checking\n\t{\n\t    // Skip middle-comment string\n\t    while (*p && p[-1] != ':')\t// find end of middle flags\n\t\t++p;\n\t    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\t    // Don't count trailing white space for middle_len\n\t    while (middle_len > 0 && VIM_ISWHITE(lead_end[middle_len - 1]))\n\t\t--middle_len;\n\n\t    // Find the end-comment string\n\t    while (*p && p[-1] != ':')\t// find end of end flags\n\t\t++p;\n\t    end_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\n\t    // Skip white space before the cursor\n\t    i = curwin->w_cursor.col;\n\t    while (--i >= 0 && VIM_ISWHITE(line[i]))\n\t\t;\n\t    i++;\n\n\t    // Skip to before the middle leader\n\t    i -= middle_len;\n\n\t    // Check some expected things before we go on\n\t    if (i >= 0 && lead_end[end_len - 1] == end_comment_pending)\n\t    {\n\t\t// Backspace over all the stuff we want to replace\n\t\tbackspace_until_column(i);\n\n\t\t// Insert the end-comment string, except for the last\n\t\t// character, which will get inserted as normal later.\n\t\tins_bytes_len(lead_end, end_len - 1);\n\t    }\n\t}\n    }\n    end_comment_pending = NUL;\n\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n\n    /*\n     * If there's any pending input, grab up to INPUT_BUFLEN at once.\n     * This speeds up normal text input considerably.\n     * Don't do this when 'cindent' or 'indentexpr' is set, because we might\n     * need to re-indent at a ':', or any other character (but not what\n     * 'paste' is set)..\n     * Don't do this when there an InsertCharPre autocommand is defined,\n     * because we need to fire the event for every character.\n     * Do the check for InsertCharPre before the call to vpeekc() because the\n     * InsertCharPre autocommand could change the input buffer.\n     */\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n    if (       !ISSPECIAL(c)\n\t    && (!has_mbyte || (*mb_char2len)(c) == 1)\n\t    && !has_insertcharpre()\n\t    && vpeekc() != NUL\n\t    && !(State & REPLACE_FLAG)\n\t    && !cindent_on()\n#ifdef FEAT_RIGHTLEFT\n\t    && !p_ri\n#endif\n\t   )\n    {\n#define INPUT_BUFLEN 100\n\tchar_u\t\tbuf[INPUT_BUFLEN + 1];\n\tint\t\ti;\n\tcolnr_T\t\tvirtcol = 0;\n\n\tbuf[0] = c;\n\ti = 1;\n\tif (textwidth > 0)\n\t    virtcol = get_nolist_virtcol();\n\t/*\n\t * Stop the string when:\n\t * - no more chars available\n\t * - finding a special character (command key)\n\t * - buffer is full\n\t * - running into the 'textwidth' boundary\n\t * - need to check for abbreviation: A non-word char after a word-char\n\t */\n\twhile (\t   (c = vpeekc()) != NUL\n\t\t&& !ISSPECIAL(c)\n\t\t&& (!has_mbyte || MB_BYTE2LEN_CHECK(c) == 1)\n\t\t&& i < INPUT_BUFLEN\n\t\t&& (textwidth == 0\n\t\t    || (virtcol += byte2cells(buf[i - 1])) < (colnr_T)textwidth)\n\t\t&& !(!no_abbr && !vim_iswordc(c) && vim_iswordc(buf[i - 1])))\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    c = vgetc();\n\t    if (p_hkmap && KeyTyped)\n\t\tc = hkmap(c);\t\t    // Hebrew mode mapping\n\t    buf[i++] = c;\n#else\n\t    buf[i++] = vgetc();\n#endif\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tdo_digraph(-1);\t\t\t// clear digraphs\n\tdo_digraph(buf[i-1]);\t\t// may be the start of a digraph\n#endif\n\tbuf[i] = NUL;\n\tins_str(buf);\n\tif (flags & INSCHAR_CTRLV)\n\t{\n\t    redo_literal(*buf);\n\t    i = 1;\n\t}\n\telse\n\t    i = 0;\n\tif (buf[i] != NUL)\n\t    AppendToRedobuffLit(buf + i, -1);\n    }\n    else\n    {\n\tint\t\tcc;\n\n\tif (has_mbyte && (cc = (*mb_char2len)(c)) > 1)\n\t{\n\t    char_u\tbuf[MB_MAXBYTES + 1];\n\n\t    (*mb_char2bytes)(c, buf);\n\t    buf[cc] = NUL;\n\t    ins_char_bytes(buf, cc);\n\t    AppendCharToRedobuff(c);\n\t}\n\telse\n\t{\n\t    ins_char(c);\n\t    if (flags & INSCHAR_CTRLV)\n\t\tredo_literal(c);\n\t    else\n\t\tAppendCharToRedobuff(c);\n\t}\n    }\n}\n\n/*\n * Put a character in the redo buffer, for when just after a CTRL-V.\n */\n    static void\nredo_literal(int c)\n{\n    char_u\tbuf[10];\n\n    // Only digits need special treatment.  Translate them into a string of\n    // three digits.\n    if (VIM_ISDIGIT(c))\n    {\n\tvim_snprintf((char *)buf, sizeof(buf), \"%03d\", c);\n\tAppendToRedobuff(buf);\n    }\n    else\n\tAppendCharToRedobuff(c);\n}\n\n/*\n * start_arrow() is called when an arrow key is used in insert mode.\n * For undo/redo it resembles hitting the <ESC> key.\n */\n    void\nstart_arrow(\n    pos_T    *end_insert_pos)\t\t// can be NULL\n{\n    start_arrow_common(end_insert_pos, TRUE);\n}\n\n/*\n * Like start_arrow() but with end_change argument.\n * Will prepare for redo of CTRL-G U if \"end_change\" is FALSE.\n */\n    static void\nstart_arrow_with_change(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    start_arrow_common(end_insert_pos, end_change);\n    if (!end_change)\n    {\n\tAppendCharToRedobuff(Ctrl_G);\n\tAppendCharToRedobuff('U');\n    }\n}\n\n    static void\nstart_arrow_common(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    if (!arrow_used && end_change)\t// something has been inserted\n    {\n\tAppendToRedobuff(ESC_STR);\n\tstop_insert(end_insert_pos, FALSE, FALSE);\n\tarrow_used = TRUE;\t// this means we stopped the current insert\n    }\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n}\n\n#ifdef FEAT_SPELL\n/*\n * If we skipped highlighting word at cursor, do it now.\n * It may be skipped again, thus reset spell_redraw_lnum first.\n */\n    static void\ncheck_spell_redraw(void)\n{\n    if (spell_redraw_lnum != 0)\n    {\n\tlinenr_T\tlnum = spell_redraw_lnum;\n\n\tspell_redraw_lnum = 0;\n\tredrawWinline(curwin, lnum);\n    }\n}\n\n#endif\n\n/*\n * stop_arrow() is called before a change is made in insert mode.\n * If an arrow key has been used, start a new insertion.\n * Returns FAIL if undo is impossible, shouldn't insert then.\n */\n    int\nstop_arrow(void)\n{\n    if (arrow_used)\n    {\n\tInsstart = curwin->w_cursor;\t// new insertion starts here\n\tif (Insstart.col > Insstart_orig.col && !ins_need_undo)\n\t    // Don't update the original insert position when moved to the\n\t    // right, except when nothing was inserted yet.\n\t    update_Insstart_orig = FALSE;\n\tInsstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n\n\tif (u_save_cursor() == OK)\n\t{\n\t    arrow_used = FALSE;\n\t    ins_need_undo = FALSE;\n\t}\n\n\tai_col = 0;\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    orig_line_count = curbuf->b_ml.ml_line_count;\n\t    vr_lines_changed = 1;\n\t}\n\tResetRedobuff();\n\tAppendToRedobuff((char_u *)\"1i\");   // pretend we start an insertion\n\tnew_insert_skip = 2;\n    }\n    else if (ins_need_undo)\n    {\n\tif (u_save_cursor() == OK)\n\t    ins_need_undo = FALSE;\n    }\n\n#ifdef FEAT_FOLDING\n    // Always open fold at the cursor line when inserting something.\n    foldOpenCursor();\n#endif\n\n    return (arrow_used || ins_need_undo ? FAIL : OK);\n}\n\n/*\n * Do a few things to stop inserting.\n * \"end_insert_pos\" is where insert ended.  It is NULL when we already jumped\n * to another window/buffer.\n */\n    static void\nstop_insert(\n    pos_T\t*end_insert_pos,\n    int\t\tesc,\t\t\t// called by ins_esc()\n    int\t\tnomove)\t\t\t// <c-\\><c-o>, don't move cursor\n{\n    int\t\tcc;\n    char_u\t*ptr;\n\n    stop_redo_ins();\n    replace_flush();\t\t// abandon replace stack\n\n    /*\n     * Save the inserted text for later redo with ^@ and CTRL-A.\n     * Don't do it when \"restart_edit\" was set and nothing was inserted,\n     * otherwise CTRL-O w and then <Left> will clear \"last_insert\".\n     */\n    ptr = get_inserted();\n    if (did_restart_edit == 0 || (ptr != NULL\n\t\t\t\t       && (int)STRLEN(ptr) > new_insert_skip))\n    {\n\tvim_free(last_insert);\n\tlast_insert = ptr;\n\tlast_insert_skip = new_insert_skip;\n    }\n    else\n\tvim_free(ptr);\n\n    if (!arrow_used && end_insert_pos != NULL)\n    {\n\t// Auto-format now.  It may seem strange to do this when stopping an\n\t// insertion (or moving the cursor), but it's required when appending\n\t// a line and having it end in a space.  But only do it when something\n\t// was actually inserted, otherwise undo won't work.\n\tif (!ins_need_undo && has_format_option(FO_AUTO))\n\t{\n\t    pos_T   tpos = curwin->w_cursor;\n\n\t    // When the cursor is at the end of the line after a space the\n\t    // formatting will move it to the following word.  Avoid that by\n\t    // moving the cursor onto the space.\n\t    cc = 'x';\n\t    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL)\n\t    {\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    curwin->w_cursor = tpos;\n\t    }\n\n\t    auto_format(TRUE, FALSE);\n\n\t    if (VIM_ISWHITE(cc))\n\t    {\n\t\tif (gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t\t// If the cursor is still at the same character, also keep\n\t\t// the \"coladd\".\n\t\tif (gchar_cursor() == NUL\n\t\t\t&& curwin->w_cursor.lnum == tpos.lnum\n\t\t\t&& curwin->w_cursor.col == tpos.col)\n\t\t    curwin->w_cursor.coladd = tpos.coladd;\n\t    }\n\t}\n\n\t// If a space was inserted for auto-formatting, remove it now.\n\tcheck_auto_format(TRUE);\n\n\t// If we just did an auto-indent, remove the white space from the end\n\t// of the line, and put the cursor back.\n\t// Do this when ESC was used or moving the cursor up/down.\n\t// Check for the old position still being valid, just in case the text\n\t// got changed unexpectedly.\n\tif (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL\n\t\t\t&& curwin->w_cursor.lnum != end_insert_pos->lnum))\n\t\t&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    pos_T\ttpos = curwin->w_cursor;\n\n\t    curwin->w_cursor = *end_insert_pos;\n\t    check_cursor_col();  // make sure it is not past the line\n\t    for (;;)\n\t    {\n\t\tif (gchar_cursor() == NUL && curwin->w_cursor.col > 0)\n\t\t    --curwin->w_cursor.col;\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    break;\n\t\tif (del_char(TRUE) == FAIL)\n\t\t    break;  // should not happen\n\t    }\n\t    if (curwin->w_cursor.lnum != tpos.lnum)\n\t\tcurwin->w_cursor = tpos;\n\t    else\n\t    {\n\t\t// reset tpos, could have been invalidated in the loop above\n\t\ttpos = curwin->w_cursor;\n\t\ttpos.col++;\n\t\tif (cc != NUL && gchar_pos(&tpos) == NUL)\n\t\t    ++curwin->w_cursor.col;\t// put cursor back on the NUL\n\t    }\n\n\t    // <C-S-Right> may have started Visual mode, adjust the position for\n\t    // deleted characters.\n\t    if (VIsual_active)\n\t\tcheck_visual_pos();\n\t}\n    }\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n\n    // Set '[ and '] to the inserted text.  When end_insert_pos is NULL we are\n    // now in a different buffer.\n    if (end_insert_pos != NULL)\n    {\n\tcurbuf->b_op_start = Insstart;\n\tcurbuf->b_op_start_orig = Insstart_orig;\n\tcurbuf->b_op_end = *end_insert_pos;\n    }\n}\n\n/*\n * Set the last inserted text to a single character.\n * Used for the replace command.\n */\n    void\nset_last_insert(int c)\n{\n    char_u\t*s;\n\n    vim_free(last_insert);\n    last_insert = alloc(MB_MAXBYTES * 3 + 5);\n    if (last_insert != NULL)\n    {\n\ts = last_insert;\n\t// Use the CTRL-V only when entering a special char\n\tif (c < ' ' || c == DEL)\n\t    *s++ = Ctrl_V;\n\ts = add_char2buf(c, s);\n\t*s++ = ESC;\n\t*s++ = NUL;\n\tlast_insert_skip = 0;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_last_insert(void)\n{\n    VIM_CLEAR(last_insert);\n}\n#endif\n\n/*\n * Add character \"c\" to buffer \"s\".  Escape the special meaning of K_SPECIAL\n * and CSI.  Handle multi-byte characters.\n * Returns a pointer to after the added bytes.\n */\n    char_u *\nadd_char2buf(int c, char_u *s)\n{\n    char_u\ttemp[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tlen;\n\n    len = (*mb_char2bytes)(c, temp);\n    for (i = 0; i < len; ++i)\n    {\n\tc = temp[i];\n\t// Need to escape K_SPECIAL and CSI like in the typeahead buffer.\n\tif (c == K_SPECIAL)\n\t{\n\t    *s++ = K_SPECIAL;\n\t    *s++ = KS_SPECIAL;\n\t    *s++ = KE_FILLER;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    *s++ = CSI;\n\t    *s++ = KS_EXTRA;\n\t    *s++ = (int)KE_CSI;\n\t}\n#endif\n\telse\n\t    *s++ = c;\n    }\n    return s;\n}\n\n/*\n * move cursor to start of line\n * if flags & BL_WHITE\tmove to first non-white\n * if flags & BL_SOL\tmove to first non-white if startofline is set,\n *\t\t\t    otherwise keep \"curswant\" column\n * if flags & BL_FIX\tdon't leave the cursor on a NUL.\n */\n    void\nbeginline(int flags)\n{\n    if ((flags & BL_SOL) && !p_sol)\n\tcoladvance(curwin->w_curswant);\n    else\n    {\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n\n\tif (flags & (BL_WHITE | BL_SOL))\n\t{\n\t    char_u  *ptr;\n\n\t    for (ptr = ml_get_curline(); VIM_ISWHITE(*ptr)\n\t\t\t       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)\n\t\t++curwin->w_cursor.col;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * oneright oneleft cursor_down cursor_up\n *\n * Move one char {right,left,down,up}.\n * Doesn't move onto the NUL past the end of the line, unless it is allowed.\n * Return OK when successful, FAIL when we hit a line of file boundary.\n */\n\n    int\noneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\n\t// Adjust for multi-wide char (excluding TAB)\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\t// Return OK if the cursor moved, FAIL otherwise (at window edge).\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    // already at the very end\n\n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n\n    // move \"l\" bytes right, but don't end up on the NUL, unless 'virtualedit'\n    // contains \"onemore\".\n    if (ptr[l] == NUL && (get_ve_flags() & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}\n\n    int\noneleft(void)\n{\n    if (virtual_active())\n    {\n#ifdef FEAT_LINEBREAK\n\tint width;\n#endif\n\tint v = getviscol();\n\n\tif (v == 0)\n\t    return FAIL;\n\n#ifdef FEAT_LINEBREAK\n\t// We might get stuck on 'showbreak', skip over it.\n\twidth = 1;\n\tfor (;;)\n\t{\n\t    coladvance(v - width);\n\t    // getviscol() is slow, skip it when 'showbreak' is empty,\n\t    // 'breakindent' is not set and there are no multi-byte\n\t    // characters\n\t    if ((*get_showbreak_value(curwin) == NUL && !curwin->w_p_bri\n\t\t\t\t\t     && !has_mbyte) || getviscol() < v)\n\t\tbreak;\n\t    ++width;\n\t}\n#else\n\tcoladvance(v - 1);\n#endif\n\n\tif (curwin->w_cursor.coladd == 1)\n\t{\n\t    char_u *ptr;\n\n\t    // Adjust for multi-wide char (not a TAB)\n\t    ptr = ml_get_cursor();\n\t    if (*ptr != TAB && vim_isprintc((*mb_ptr2char)(ptr))\n\t\t\t\t\t\t\t && ptr2cells(ptr) > 1)\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\n\tcurwin->w_set_curswant = TRUE;\n\treturn OK;\n    }\n\n    if (curwin->w_cursor.col == 0)\n\treturn FAIL;\n\n    curwin->w_set_curswant = TRUE;\n    --curwin->w_cursor.col;\n\n    // if the character on the left of the current cursor is a multi-byte\n    // character, move to its first byte\n    if (has_mbyte)\n\tmb_adjust_cursor();\n    return OK;\n}\n\n    int\ncursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\t// This fails if the cursor is already in the first line or the count\n\t// is larger than the line number and '-' is in 'cpoptions'\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    /*\n\t     * Count each sequence of folded lines as one logical line.\n\t     */\n\t    // go to the start of the current fold\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\n\t    while (n--)\n\t    {\n\t\t// move up one line\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\t// If we entered a fold, move to the beginning, unless in\n\t\t// Insert mode or when 'foldopen' contains \"all\": it will open\n\t\t// in a moment.\n\t\tif (n > 0 || !((State & MODE_INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Cursor down a number of logical lines.\n */\n    int\ncursor_down(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Move to last line of fold, will fail if it's the end-of-file.\n\t(void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t// This fails if the cursor is already in the last line or would move\n\t// beyond the last line and '-' is in 'cpoptions'\n\tif (lnum >= curbuf->b_ml.ml_line_count\n\t\t|| (lnum + n > curbuf->b_ml.ml_line_count\n\t\t    && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (lnum + n >= curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count;\n\telse\n#ifdef FEAT_FOLDING\n\tif (hasAnyFolding(curwin))\n\t{\n\t    linenr_T\tlast;\n\n\t    // count each sequence of folded lines as one logical line\n\t    while (n--)\n\t    {\n\t\tif (hasFolding(lnum, NULL, &last))\n\t\t    lnum = last + 1;\n\t\telse\n\t\t    ++lnum;\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t    }\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t}\n\telse\n#endif\n\t    lnum += n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Stuff the last inserted text in the read buffer.\n * Last_insert actually is a copy of the redo buffer, so we\n * first have to remove the command.\n */\n    int\nstuff_inserted(\n    int\t    c,\t\t// Command character to be inserted\n    long    count,\t// Repeat this many times\n    int\t    no_esc)\t// Don't add an ESC at the end\n{\n    char_u\t*esc_ptr;\n    char_u\t*ptr;\n    char_u\t*last_ptr;\n    char_u\tlast = NUL;\n\n    ptr = get_last_insert();\n    if (ptr == NULL)\n    {\n\temsg(_(e_no_inserted_text_yet));\n\treturn FAIL;\n    }\n\n    // may want to stuff the command character, to start Insert mode\n    if (c != NUL)\n\tstuffcharReadbuff(c);\n    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)\n\t*esc_ptr = NUL;\t    // remove the ESC\n\n    // when the last char is either \"0\" or \"^\" it will be quoted if no ESC\n    // comes after it OR if it will inserted more than once and \"ptr\"\n    // starts with ^D.\t-- Acevedo\n    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;\n    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')\n\t    && (no_esc || (*ptr == Ctrl_D && count > 1)))\n    {\n\tlast = *last_ptr;\n\t*last_ptr = NUL;\n    }\n\n    do\n    {\n\tstuffReadbuff(ptr);\n\t// a trailing \"0\" is inserted as \"<C-V>048\", \"^\" as \"<C-V>^\"\n\tif (last)\n\t    stuffReadbuff(\n\t\t       (char_u *)(last == '0' ? \"\\026\\060\\064\\070\" : \"\\026^\"));\n    }\n    while (--count > 0);\n\n    if (last)\n\t*last_ptr = last;\n\n    if (esc_ptr != NULL)\n\t*esc_ptr = ESC;\t    // put the ESC back\n\n    // may want to stuff a trailing ESC, to get out of Insert mode\n    if (!no_esc)\n\tstuffcharReadbuff(ESC);\n\n    return OK;\n}\n\n    char_u *\nget_last_insert(void)\n{\n    if (last_insert == NULL)\n\treturn NULL;\n    return last_insert + last_insert_skip;\n}\n\n/*\n * Get last inserted string, and remove trailing <Esc>.\n * Returns pointer to allocated memory (must be freed) or NULL.\n */\n    char_u *\nget_last_insert_save(void)\n{\n    char_u\t*s;\n    int\t\tlen;\n\n    if (last_insert == NULL)\n\treturn NULL;\n    s = vim_strsave(last_insert + last_insert_skip);\n    if (s != NULL)\n    {\n\tlen = (int)STRLEN(s);\n\tif (len > 0 && s[len - 1] == ESC)\t// remove trailing ESC\n\t    s[len - 1] = NUL;\n    }\n    return s;\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text and\n * the replacement string is inserted in typebuf.tb_buf[], followed by \"c\".\n */\n    static int\necheck_abbr(int c)\n{\n    // Don't check for abbreviation in paste mode, when disabled and just\n    // after moving around with cursor keys.\n    if (p_paste || no_abbr || arrow_used)\n\treturn FALSE;\n\n    return check_abbr(c, ml_get_curline(), curwin->w_cursor.col,\n\t\tcurwin->w_cursor.lnum == Insstart.lnum ? Insstart.col : 0);\n}\n\n/*\n * replace-stack functions\n *\n * When replacing characters, the replaced characters are remembered for each\n * new character.  This is used to re-insert the old text when backspacing.\n *\n * There is a NUL headed list of characters for each character that is\n * currently in the file after the insertion point.  When BS is used, one NUL\n * headed list is put back for the deleted character.\n *\n * For a newline, there are two NUL headed lists.  One contains the characters\n * that the NL replaced.  The extra one stores the characters after the cursor\n * that were deleted (always white space).\n *\n * Replace_offset is normally 0, in which case replace_push will add a new\n * character at the end of the stack.  If replace_offset is not 0, that many\n * characters will be left on the stack above the newly inserted character.\n */\n\nstatic char_u\t*replace_stack = NULL;\nstatic long\treplace_stack_nr = 0;\t    // next entry in replace stack\nstatic long\treplace_stack_len = 0;\t    // max. number of entries\n\n    void\nreplace_push(\n    int\t    c)\t    // character that is replaced (NUL is none)\n{\n    char_u  *p;\n\n    if (replace_stack_nr < replace_offset)\t// nothing to do\n\treturn;\n    if (replace_stack_len <= replace_stack_nr)\n    {\n\treplace_stack_len += 50;\n\tp = ALLOC_MULT(char_u, replace_stack_len);\n\tif (p == NULL)\t    // out of memory\n\t{\n\t    replace_stack_len -= 50;\n\t    return;\n\t}\n\tif (replace_stack != NULL)\n\t{\n\t    mch_memmove(p, replace_stack,\n\t\t\t\t (size_t)(replace_stack_nr * sizeof(char_u)));\n\t    vim_free(replace_stack);\n\t}\n\treplace_stack = p;\n    }\n    p = replace_stack + replace_stack_nr - replace_offset;\n    if (replace_offset)\n\tmch_memmove(p + 1, p, (size_t)(replace_offset * sizeof(char_u)));\n    *p = c;\n    ++replace_stack_nr;\n}\n\n/*\n * Push a character onto the replace stack.  Handles a multi-byte character in\n * reverse byte order, so that the first byte is popped off first.\n * Return the number of bytes done (includes composing characters).\n */\n    int\nreplace_push_mb(char_u *p)\n{\n    int l = (*mb_ptr2len)(p);\n    int j;\n\n    for (j = l - 1; j >= 0; --j)\n\treplace_push(p[j]);\n    return l;\n}\n\n/*\n * Pop one item from the replace stack.\n * return -1 if stack empty\n * return replaced character or NUL otherwise\n */\n    static int\nreplace_pop(void)\n{\n    if (replace_stack_nr == 0)\n\treturn -1;\n    return (int)replace_stack[--replace_stack_nr];\n}\n\n/*\n * Join the top two items on the replace stack.  This removes to \"off\"'th NUL\n * encountered.\n */\n    void\nreplace_join(\n    int\t    off)\t// offset for which NUL to remove\n{\n    int\t    i;\n\n    for (i = replace_stack_nr; --i >= 0; )\n\tif (replace_stack[i] == NUL && off-- <= 0)\n\t{\n\t    --replace_stack_nr;\n\t    mch_memmove(replace_stack + i, replace_stack + i + 1,\n\t\t\t\t\t      (size_t)(replace_stack_nr - i));\n\t    return;\n\t}\n}\n\n/*\n * Pop bytes from the replace stack until a NUL is found, and insert them\n * before the cursor.  Can only be used in MODE_REPLACE or MODE_VREPLACE state.\n */\n    static void\nreplace_pop_ins(void)\n{\n    int\t    cc;\n    int\t    oldState = State;\n\n    State = MODE_NORMAL;\t\t\t// don't want MODE_REPLACE here\n    while ((cc = replace_pop()) > 0)\n    {\n\tmb_replace_pop_ins(cc);\n\tdec_cursor();\n    }\n    State = oldState;\n}\n\n/*\n * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it\n * indicates a multi-byte char, pop the other bytes too.\n */\n    static void\nmb_replace_pop_ins(int cc)\n{\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tc;\n\n    if (has_mbyte && (n = MB_BYTE2LEN(cc)) > 1)\n    {\n\tbuf[0] = cc;\n\tfor (i = 1; i < n; ++i)\n\t    buf[i] = replace_pop();\n\tins_bytes_len(buf, n);\n    }\n    else\n\tins_char(cc);\n\n    if (enc_utf8)\n\t// Handle composing chars.\n\tfor (;;)\n\t{\n\t    c = replace_pop();\n\t    if (c == -1)\t    // stack empty\n\t\tbreak;\n\t    if ((n = MB_BYTE2LEN(c)) == 1)\n\t    {\n\t\t// Not a multi-byte char, put it back.\n\t\treplace_push(c);\n\t\tbreak;\n\t    }\n\n\t    buf[0] = c;\n\t    for (i = 1; i < n; ++i)\n\t\tbuf[i] = replace_pop();\n\t    if (utf_iscomposing(utf_ptr2char(buf)))\n\t\tins_bytes_len(buf, n);\n\t    else\n\t    {\n\t\t// Not a composing char, put it back.\n\t\tfor (i = n - 1; i >= 0; --i)\n\t\t    replace_push(buf[i]);\n\t\tbreak;\n\t    }\n\n\t}\n}\n\n/*\n * make the replace stack empty\n * (called when exiting replace mode)\n */\n    static void\nreplace_flush(void)\n{\n    VIM_CLEAR(replace_stack);\n    replace_stack_len = 0;\n    replace_stack_nr = 0;\n}\n\n/*\n * Handle doing a BS for one character.\n * cc < 0: replace stack empty, just move cursor\n * cc == 0: character was inserted, delete it\n * cc > 0: character was replaced, put cc (first byte of original char) back\n * and check for more characters to be put back\n * When \"limit_col\" is >= 0, don't delete before this column.  Matters when\n * using composing characters, use del_char_after_col() instead of del_char().\n */\n    static void\nreplace_do_bs(int limit_col)\n{\n    int\t\tcc;\n    int\t\torig_len = 0;\n    int\t\tins_len;\n    int\t\torig_vcols = 0;\n    colnr_T\tstart_vcol;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tvcol;\n\n    cc = replace_pop();\n    if (cc > 0)\n    {\n#ifdef FEAT_PROP_POPUP\n\tsize_t\tlen_before = 0;  // init to shut up GCC\n\n\tif (curbuf->b_has_textprop)\n\t{\n\t    // Do not adjust text properties for individual delete and insert\n\t    // operations, do it afterwards on the resulting text.\n\t    len_before = STRLEN(ml_get_curline());\n\t    ++text_prop_frozen;\n\t}\n#endif\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the character we are\n\t    // going to delete.\n\t    getvcol(curwin, &curwin->w_cursor, NULL, &start_vcol, NULL);\n\t    orig_vcols = chartabsize(ml_get_cursor(), start_vcol);\n\t}\n\tif (has_mbyte)\n\t{\n\t    (void)del_char_after_col(limit_col);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor());\n\t    replace_push(cc);\n\t}\n\telse\n\t{\n\t    pchar_cursor(cc);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor()) - 1;\n\t}\n\treplace_pop_ins();\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the inserted characters\n\t    p = ml_get_cursor();\n\t    ins_len = (int)STRLEN(p) - orig_len;\n\t    vcol = start_vcol;\n\t    for (i = 0; i < ins_len; ++i)\n\t    {\n\t\tvcol += chartabsize(p + i, vcol);\n\t\ti += (*mb_ptr2len)(p) - 1;\n\t    }\n\t    vcol -= start_vcol;\n\n\t    // Delete spaces that were inserted after the cursor to keep the\n\t    // text aligned.\n\t    curwin->w_cursor.col += ins_len;\n\t    while (vcol > orig_vcols && gchar_cursor() == ' ')\n\t    {\n\t\tdel_char(FALSE);\n\t\t++orig_vcols;\n\t    }\n\t    curwin->w_cursor.col -= ins_len;\n\t}\n\n\t// mark the buffer as changed and prepare for displaying\n\tchanged_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n#ifdef FEAT_PROP_POPUP\n\tif (curbuf->b_has_textprop)\n\t{\n\t    size_t len_now = STRLEN(ml_get_curline());\n\n\t    --text_prop_frozen;\n\t    adjust_prop_columns(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t   (int)(len_now - len_before), 0);\n\t}\n#endif\n    }\n    else if (cc == 0)\n\t(void)del_char_after_col(limit_col);\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Map Hebrew keyboard when in hkmap mode.\n */\n    int\nhkmap(int c)\n{\n    if (p_hkmapp)   // phonetic mapping, by Ilya Dogolazky\n    {\n\tenum {hALEF=0, BET, GIMEL, DALET, HEI, VAV, ZAIN, HET, TET, IUD,\n\t    KAFsofit, hKAF, LAMED, MEMsofit, MEM, NUNsofit, NUN, SAMEH, AIN,\n\t    PEIsofit, PEI, ZADIsofit, ZADI, KOF, RESH, hSHIN, TAV};\n\tstatic char_u map[26] =\n\t    {(char_u)hALEF/*a*/, (char_u)BET  /*b*/, (char_u)hKAF    /*c*/,\n\t     (char_u)DALET/*d*/, (char_u)-1   /*e*/, (char_u)PEIsofit/*f*/,\n\t     (char_u)GIMEL/*g*/, (char_u)HEI  /*h*/, (char_u)IUD     /*i*/,\n\t     (char_u)HET  /*j*/, (char_u)KOF  /*k*/, (char_u)LAMED   /*l*/,\n\t     (char_u)MEM  /*m*/, (char_u)NUN  /*n*/, (char_u)SAMEH   /*o*/,\n\t     (char_u)PEI  /*p*/, (char_u)-1   /*q*/, (char_u)RESH    /*r*/,\n\t     (char_u)ZAIN /*s*/, (char_u)TAV  /*t*/, (char_u)TET     /*u*/,\n\t     (char_u)VAV  /*v*/, (char_u)hSHIN/*w*/, (char_u)-1      /*x*/,\n\t     (char_u)AIN  /*y*/, (char_u)ZADI /*z*/};\n\n\tif (c == 'N' || c == 'M' || c == 'P' || c == 'C' || c == 'Z')\n\t    return (int)(map[CharOrd(c)] - 1 + p_aleph);\n\t\t\t\t\t\t\t    // '-1'='sofit'\n\telse if (c == 'x')\n\t    return 'X';\n\telse if (c == 'q')\n\t    return '\\''; // {geresh}={'}\n\telse if (c == 246)\n\t    return ' ';  // \\\"o --> ' ' for a german keyboard\n\telse if (c == 228)\n\t    return ' ';  // \\\"a --> ' '      -- / --\n\telse if (c == 252)\n\t    return ' ';  // \\\"u --> ' '      -- / --\n\t// NOTE: islower() does not do the right thing for us on Linux so we\n\t// do this the same was as 5.7 and previous, so it works correctly on\n\t// all systems.  Specifically, the e.g. Delete and Arrow keys are\n\t// munged and won't work if e.g. searching for Hebrew text.\n\telse if (c >= 'a' && c <= 'z')\n\t    return (int)(map[CharOrdLow(c)] + p_aleph);\n\telse\n\t    return c;\n    }\n    else\n    {\n\tswitch (c)\n\t{\n\t    case '`':\treturn ';';\n\t    case '/':\treturn '.';\n\t    case '\\'':\treturn ',';\n\t    case 'q':\treturn '/';\n\t    case 'w':\treturn '\\'';\n\n\t\t\t// Hebrew letters - set offset from 'a'\n\t    case ',':\tc = '{'; break;\n\t    case '.':\tc = 'v'; break;\n\t    case ';':\tc = 't'; break;\n\t    default: {\n\t\t\t static char str[] = \"zqbcxlsjphmkwonu ydafe rig\";\n\n\t\t\t if (c < 'a' || c > 'z')\n\t\t\t     return c;\n\t\t\t c = str[CharOrdLow(c)];\n\t\t\t break;\n\t\t     }\n\t}\n\n\treturn (int)(CharOrdLow(c) + p_aleph);\n    }\n}\n#endif\n\n    static void\nins_reg(void)\n{\n    int\t\tneed_redraw = FALSE;\n    int\t\tregname;\n    int\t\tliterally = 0;\n    int\t\tvis_active = VIsual_active;\n\n    /*\n     * If we are going to wait for a character, show a '\"'.\n     */\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('\"', TRUE);\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_R);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    /*\n     * Don't map the register name. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    regname = plain_vgetc();\n    LANGMAP_ADJUST(regname, TRUE);\n    if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)\n    {\n\t// Get a third key for literal register insertion\n\tliterally = regname;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(literally);\n#endif\n\tregname = plain_vgetc();\n\tLANGMAP_ADJUST(regname, TRUE);\n    }\n    --no_mapping;\n    --allow_keys;\n\n#ifdef FEAT_EVAL\n    // Don't call u_sync() while typing the expression or giving an error\n    // message for it. Only call it explicitly.\n    ++no_u_sync;\n    if (regname == '=')\n    {\n\tpos_T\tcurpos = curwin->w_cursor;\n# ifdef HAVE_INPUT_METHOD\n\tint\tim_on = im_get_status();\n# endif\n\t// Sync undo when evaluating the expression calls setline() or\n\t// append(), so that it can be undone separately.\n\tu_sync_once = 2;\n\n\tregname = get_expr_register();\n\n\t// Cursor may be moved back a column.\n\tcurwin->w_cursor = curpos;\n\tcheck_cursor();\n# ifdef HAVE_INPUT_METHOD\n\t// Restore the Input Method.\n\tif (im_on)\n\t    im_set_active(TRUE);\n# endif\n    }\n    if (regname == NUL || !valid_yank_reg(regname, FALSE))\n    {\n\tvim_beep(BO_REG);\n\tneed_redraw = TRUE;\t// remove the '\"'\n    }\n    else\n    {\n#endif\n\tif (literally == Ctrl_O || literally == Ctrl_P)\n\t{\n\t    // Append the command to the redo buffer.\n\t    AppendCharToRedobuff(Ctrl_R);\n\t    AppendCharToRedobuff(literally);\n\t    AppendCharToRedobuff(regname);\n\n\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t (literally == Ctrl_P ? PUT_FIXINDENT : 0) | PUT_CURSEND);\n\t}\n\telse if (insert_reg(regname, literally) == FAIL)\n\t{\n\t    vim_beep(BO_REG);\n\t    need_redraw = TRUE;\t// remove the '\"'\n\t}\n\telse if (stop_insert_mode)\n\t    // When the '=' register was used and a function was invoked that\n\t    // did \":stopinsert\" then stuff_empty() returns FALSE but we won't\n\t    // insert anything, need to remove the '\"'\n\t    need_redraw = TRUE;\n\n#ifdef FEAT_EVAL\n    }\n    --no_u_sync;\n    if (u_sync_once == 1)\n\tins_need_undo = TRUE;\n    u_sync_once = 0;\n#endif\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    // If the inserted register is empty, we need to remove the '\"'\n    if (need_redraw || stuff_empty())\n\tedit_unputchar();\n\n    // Disallow starting Visual mode here, would get a weird mode.\n    if (!vis_active && VIsual_active)\n\tend_visual_mode();\n}\n\n/*\n * CTRL-G commands in Insert mode.\n */\n    static void\nins_ctrl_g(void)\n{\n    int\t\tc;\n\n    // Right after CTRL-X the cursor will be after the ruler.\n    setcursor();\n\n    /*\n     * Don't map the second key. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    switch (c)\n    {\n\t// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col\n\tcase K_UP:\n\tcase Ctrl_K:\n\tcase 'k': ins_up(TRUE);\n\t\t  break;\n\n\t// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col\n\tcase K_DOWN:\n\tcase Ctrl_J:\n\tcase 'j': ins_down(TRUE);\n\t\t  break;\n\n\t// CTRL-G u: start new undoable edit\n\tcase 'u': u_sync(TRUE);\n\t\t  ins_need_undo = TRUE;\n\n\t\t  // Need to reset Insstart, esp. because a BS that joins\n\t\t  // a line to the previous one must save for undo.\n\t\t  update_Insstart_orig = FALSE;\n\t\t  Insstart = curwin->w_cursor;\n\t\t  break;\n\n\t// CTRL-G U: do not break undo with the next char\n\tcase 'U':\n\t\t  // Allow one left/right cursor movement with the next char,\n\t\t  // without breaking undo.\n\t\t  dont_sync_undo = MAYBE;\n\t\t  break;\n\n\t// Unknown CTRL-G command, reserved for future expansion.\n\tdefault:  vim_beep(BO_CTRLG);\n    }\n}\n\n/*\n * CTRL-^ in Insert mode.\n */\n    static void\nins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, Toggle use of \":lmap\" mappings.\n\tif (State & MODE_LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~MODE_LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~MODE_LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    // may show different cursor shape or color\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle ESC in insert mode.\n * Returns TRUE when leaving insert mode, FALSE when going to repeat the\n * insert.\n */\n    static int\nins_esc(\n    long\t*count,\n    int\t\tcmdchar,\n    int\t\tnomove)\t    // don't move cursor\n{\n    int\t\ttemp;\n    static int\tdisabled_redraw = FALSE;\n#ifdef FEAT_CONCEAL\n    // Remember if the cursor line was concealed before changing State.\n    int\t\tcursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n\n    temp = curwin->w_cursor.col;\n    if (disabled_redraw)\n    {\n\t--RedrawingDisabled;\n\tdisabled_redraw = FALSE;\n    }\n    if (!arrow_used)\n    {\n\t/*\n\t * Don't append the ESC for \"r<CR>\" and \"grx\".\n\t * When 'insertmode' is set only CTRL-L stops Insert mode.  Needed for\n\t * when \"count\" is non-zero.\n\t */\n\tif (cmdchar != 'r' && cmdchar != 'v')\n\t    AppendToRedobuff(p_im ? (char_u *)\"\\014\" : ESC_STR);\n\n\t/*\n\t * Repeating insert may take a long time.  Check for\n\t * interrupt now and then.\n\t */\n\tif (*count > 0)\n\t{\n\t    line_breakcheck();\n\t    if (got_int)\n\t\t*count = 0;\n\t}\n\n\tif (--*count > 0)\t// repeat what was typed\n\t{\n\t    // Vi repeats the insert without replacing characters.\n\t    if (vim_strchr(p_cpo, CPO_REPLCNT) != NULL)\n\t\tState &= ~REPLACE_FLAG;\n\n\t    (void)start_redo_ins();\n\t    if (cmdchar == 'r' || cmdchar == 'v')\n\t\tstuffRedoReadbuff(ESC_STR);\t// no ESC in redo buffer\n\t    ++RedrawingDisabled;\n\t    disabled_redraw = TRUE;\n\t    return FALSE;\t// repeat the insert\n\t}\n\tstop_insert(&curwin->w_cursor, TRUE, nomove);\n\tundisplay_dollar();\n    }\n\n    if (cmdchar != 'r' && cmdchar != 'v')\n\tins_apply_autocmds(EVENT_INSERTLEAVEPRE);\n\n    // When an autoindent was removed, curswant stays after the\n    // indent\n    if (restart_edit == NUL && (colnr_T)temp == curwin->w_cursor.col)\n\tcurwin->w_set_curswant = TRUE;\n\n    // Remember the last Insert position in the '^ mark.\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n\tcurbuf->b_last_insert = curwin->w_cursor;\n\n    /*\n     * The cursor should end up on the last inserted character.\n     * Don't do it for CTRL-O, unless past the end of the line.\n     */\n    if (!nomove\n\t    && (curwin->w_cursor.col != 0\n\t\t|| curwin->w_cursor.coladd > 0)\n\t    && (restart_edit == NUL\n\t\t   || (gchar_cursor() == NUL && !VIsual_active))\n#ifdef FEAT_RIGHTLEFT\n\t    && !revins_on\n#endif\n\t\t\t\t      )\n    {\n\tif (curwin->w_cursor.coladd > 0 || get_ve_flags() == VE_ALL)\n\t{\n\t    oneleft();\n\t    if (restart_edit != NUL)\n\t\t++curwin->w_cursor.coladd;\n\t}\n\telse\n\t{\n\t    --curwin->w_cursor.col;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t}\n    }\n\n#ifdef HAVE_INPUT_METHOD\n    // Disable IM to allow typing English directly for Normal mode commands.\n    // When \":lmap\" is enabled don't change 'iminsert' (IM can be enabled as\n    // well).\n    if (!(State & MODE_LANGMAP))\n\tim_save_status(&curbuf->b_p_iminsert);\n    im_set_active(FALSE);\n#endif\n\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    if (!p_ek)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\n\t// Re-enable bracketed paste mode.\n\tout_str(T_BE);\n\n\t// Re-enable modifyOtherKeys.\n\tout_str(T_CTI);\n    }\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"i\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // When recording or for CTRL-O, need to display the new mode.\n    // Otherwise remove the mode message.\n    if (reg_recording != 0 || restart_edit != NUL)\n\tshowmode();\n    else if (p_smd && (got_int || !skip_showmode()))\n\tmsg(\"\");\n\n    return TRUE;\t    // exit Insert mode\n}\n\n#ifdef FEAT_RIGHTLEFT\n/*\n * Toggle language: hkmap and revins_on.\n * Move to end of reverse inserted text.\n */\n    static void\nins_ctrl_(void)\n{\n    if (revins_on && revins_chars && revins_scol >= 0)\n    {\n\twhile (gchar_cursor() != NUL && revins_chars--)\n\t    ++curwin->w_cursor.col;\n    }\n    p_ri = !p_ri;\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n    {\n\trevins_scol = curwin->w_cursor.col;\n\trevins_legal++;\n\trevins_chars = 0;\n\tundisplay_dollar();\n    }\n    else\n\trevins_scol = -1;\n    p_hkmap = curwin->w_p_rl ^ p_ri;    // be consistent!\n    showmode();\n}\n#endif\n\n/*\n * If 'keymodel' contains \"startsel\", may start selection.\n * Returns TRUE when a CTRL-O and other keys stuffed.\n */\n    static int\nins_start_select(int c)\n{\n    if (km_startsel)\n\tswitch (c)\n\t{\n\t    case K_KHOME:\n\t    case K_KEND:\n\t    case K_PAGEUP:\n\t    case K_KPAGEUP:\n\t    case K_PAGEDOWN:\n\t    case K_KPAGEDOWN:\n# ifdef MACOS_X\n\t    case K_LEFT:\n\t    case K_RIGHT:\n\t    case K_UP:\n\t    case K_DOWN:\n\t    case K_END:\n\t    case K_HOME:\n# endif\n\t\tif (!(mod_mask & MOD_MASK_SHIFT))\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case K_S_LEFT:\n\t    case K_S_RIGHT:\n\t    case K_S_UP:\n\t    case K_S_DOWN:\n\t    case K_S_END:\n\t    case K_S_HOME:\n\t\t// Start selection right away, the cursor can move with\n\t\t// CTRL-O when beyond the end of the line.\n\t\tstart_selection();\n\n\t\t// Execute the key in (insert) Select mode.\n\t\tstuffcharReadbuff(Ctrl_O);\n\t\tif (mod_mask)\n\t\t{\n\t\t    char_u\t    buf[4];\n\n\t\t    buf[0] = K_SPECIAL;\n\t\t    buf[1] = KS_MODIFIER;\n\t\t    buf[2] = mod_mask;\n\t\t    buf[3] = NUL;\n\t\t    stuffReadbuff(buf);\n\t\t}\n\t\tstuffcharReadbuff(c);\n\t\treturn TRUE;\n\t}\n    return FALSE;\n}\n\n/*\n * <Insert> key in Insert mode: toggle insert/replace mode.\n */\n    static void\nins_insert(int replaceState)\n{\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_INSERTMODE,\n\t\t   (char_u *)((State & REPLACE_FLAG) ? \"i\"\n\t\t\t    : replaceState == MODE_VREPLACE ? \"v\" : \"r\"), 1);\n#endif\n    ins_apply_autocmds(EVENT_INSERTCHANGE);\n    if (State & REPLACE_FLAG)\n\tState = MODE_INSERT | (State & MODE_LANGMAP);\n    else\n\tState = replaceState | (State & MODE_LANGMAP);\n    may_trigger_modechanged();\n    AppendCharToRedobuff(K_INS);\n    showmode();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * Pressed CTRL-O in Insert mode.\n */\n    static void\nins_ctrl_o(void)\n{\n    if (State & VREPLACE_FLAG)\n\trestart_edit = 'V';\n    else if (State & REPLACE_FLAG)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'I';\n    if (virtual_active())\n\tins_at_eol = FALSE;\t// cursor always keeps its column\n    else\n\tins_at_eol = (gchar_cursor() == NUL);\n}\n\n/*\n * If the cursor is on an indent, ^T/^D insert/delete one\n * shiftwidth.\tOtherwise ^T/^D behave like a \"<<\" or \">>\".\n * Always round the indent to 'shiftwidth', this is compatible\n * with vi.  But vi only supports ^T and ^D after an\n * autoindent, we support it everywhere.\n */\n    static void\nins_shift(int c, int lastc)\n{\n    if (stop_arrow() == FAIL)\n\treturn;\n    AppendCharToRedobuff(c);\n\n    /*\n     * 0^D and ^^D: remove all indent.\n     */\n    if (c == Ctrl_D && (lastc == '0' || lastc == '^')\n\t\t\t\t\t\t  && curwin->w_cursor.col > 0)\n    {\n\t--curwin->w_cursor.col;\n\t(void)del_char(FALSE);\t\t// delete the '^' or '0'\n\t// In Replace mode, restore the characters that '^' or '0' replaced.\n\tif (State & REPLACE_FLAG)\n\t    replace_pop_ins();\n\tif (lastc == '^')\n\t    old_indent = get_indent();\t// remember curr. indent\n\tchange_indent(INDENT_SET, 0, TRUE, 0, TRUE);\n    }\n    else\n\tchange_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);\n\n    if (did_ai && *skipwhite(ml_get_curline()) != NUL)\n\tdid_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    can_cindent = FALSE;\t// no cindenting after ^D or ^T\n}\n\n    static void\nins_del(void)\n{\n    int\t    temp;\n\n    if (stop_arrow() == FAIL)\n\treturn;\n    if (gchar_cursor() == NUL)\t\t// delete newline\n    {\n\ttemp = curwin->w_cursor.col;\n\tif (!can_bs(BS_EOL)\t\t// only if \"eol\" included\n\t\t|| do_join(2, FALSE, TRUE, FALSE, FALSE) == FAIL)\n\t    vim_beep(BO_BS);\n\telse\n\t{\n\t    curwin->w_cursor.col = temp;\n\t    // Adjust orig_line_count in case more lines have been deleted than\n\t    // have been added. That makes sure, that open_line() later\n\t    // can access all buffer lines correctly\n\t    if (State & VREPLACE_FLAG &&\n\t\t    orig_line_count > curbuf->b_ml.ml_line_count)\n\t\torig_line_count = curbuf->b_ml.ml_line_count;\n\t}\n    }\n    else if (del_char(FALSE) == FAIL)  // delete char under cursor\n\tvim_beep(BO_BS);\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    AppendCharToRedobuff(K_DEL);\n}\n\n/*\n * Delete one character for ins_bs().\n */\n    static void\nins_bs_one(colnr_T *vcolp)\n{\n    dec_cursor();\n    getvcol(curwin, &curwin->w_cursor, vcolp, NULL, NULL);\n    if (State & REPLACE_FLAG)\n    {\n\t// Don't delete characters before the insert point when in\n\t// Replace mode\n\tif (curwin->w_cursor.lnum != Insstart.lnum\n\t\t|| curwin->w_cursor.col >= Insstart.col)\n\t    replace_do_bs(-1);\n    }\n    else\n\t(void)del_char(FALSE);\n}\n\n/*\n * Handle Backspace, delete-word and delete-line in Insert mode.\n * Return TRUE when backspace was actually used.\n */\n    static int\nins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}\n\n/*\n * Handle receiving P_PS: start paste mode.  Inserts the following text up to\n * P_PE literally.\n * When \"drop\" is TRUE then consume the text and drop it.\n */\n    int\nbracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value_give_err((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value_give_err((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n    static void\nins_tabline(int c)\n{\n    // We will be leaving the current window, unless closing another tab.\n    if (c != K_TABMENU || current_tabmenu != TABLINE_MENU_CLOSE\n\t\t|| (current_tab != 0 && current_tab != tabpage_index(curtab)))\n    {\n\tundisplay_dollar();\n\tstart_arrow(&curwin->w_cursor);\n\tcan_cindent = TRUE;\n    }\n\n    if (c == K_TABLINE)\n\tgoto_tabpage(current_tab);\n    else\n    {\n\thandle_tabmenu();\n\tredraw_statuslines();\t// will redraw the tabline when needed\n    }\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    void\nins_scroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_scroll())\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n}\n\n    void\nins_horscroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_horiz_scroll(scrollbar_value, FALSE))\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n}\n#endif\n\n    static void\nins_left(void)\n{\n    pos_T\ttpos;\n    int\t\tend_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (oneleft() == OK)\n    {\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t// Only call start_arrow() when not busy with preediting, it will\n\t// break undo.  K_LEFT is inserted in im_correct_cursor().\n\tif (p_imst == IM_OVER_THE_SPOT || !im_is_preediting())\n#endif\n\t{\n\t    start_arrow_with_change(&tpos, end_change);\n\t    if (!end_change)\n\t\tAppendCharToRedobuff(K_LEFT);\n\t}\n#ifdef FEAT_RIGHTLEFT\n\t// If exit reversed string, position is fixed\n\tif (revins_scol != -1 && (int)curwin->w_cursor.col >= revins_scol)\n\t    revins_legal++;\n\trevins_chars++;\n#endif\n    }\n\n    /*\n     * if 'whichwrap' set for cursor in insert mode may go to\n     * previous line\n     */\n    else if (vim_strchr(p_ww, '[') != NULL && curwin->w_cursor.lnum > 1)\n    {\n\t// always break undo when moving upwards/downwards, else undo may break\n\tstart_arrow(&tpos);\n\t--(curwin->w_cursor.lnum);\n\tcoladvance((colnr_T)MAXCOL);\n\tcurwin->w_set_curswant = TRUE;\t// so we stay at the end\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_home(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_HOME)\n\tcurwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    start_arrow(&tpos);\n}\n\n    static void\nins_end(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_END)\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    coladvance((colnr_T)MAXCOL);\n    curwin->w_curswant = MAXCOL;\n\n    start_arrow(&tpos);\n}\n\n    static void\nins_s_left()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum > 1 || curwin->w_cursor.col > 0)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_LEFT);\n\t(void)bck_word(1L, FALSE, FALSE);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_right(void)\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (gchar_cursor() != NUL || virtual_active())\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_RIGHT);\n\tcurwin->w_set_curswant = TRUE;\n\tif (virtual_active())\n\t    oneright();\n\telse\n\t{\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t\t++curwin->w_cursor.col;\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\trevins_legal++;\n\tif (revins_chars)\n\t    revins_chars--;\n#endif\n    }\n    // if 'whichwrap' set for cursor in insert mode, may move the\n    // cursor to the next line\n    else if (vim_strchr(p_ww, ']') != NULL\n\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n    {\n\tstart_arrow(&curwin->w_cursor);\n\tcurwin->w_set_curswant = TRUE;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_s_right()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count\n\t    || gchar_cursor() != NUL)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_RIGHT);\n\t(void)fwd_word(1L, FALSE, 0);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_up(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_up(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pageup(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageUp>: tab page back\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(-1);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(BACKWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_down(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_down(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pagedown(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageDown>: tab page forward\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(0);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(FORWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n#ifdef FEAT_DND\n    static void\nins_drop(void)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Handle TAB in Insert or Replace mode.\n * Return TRUE when the TAB needs to be inserted like a normal character.\n */\n    static int\nins_tab(void)\n{\n    int\t\tind;\n    int\t\ti;\n    int\t\ttemp;\n\n    if (Insstart_blank_vcol == MAXCOL && curwin->w_cursor.lnum == Insstart.lnum)\n\tInsstart_blank_vcol = get_nolist_virtcol();\n    if (echeck_abbr(TAB + ABBR_OFF))\n\treturn FALSE;\n\n    ind = inindent(0);\n    if (ind)\n\tcan_cindent = FALSE;\n\n    /*\n     * When nothing special, insert TAB like a normal character.\n     */\n    if (!curbuf->b_p_et\n#ifdef FEAT_VARTABS\n\t    && !(p_sta && ind\n\t\t// These five lines mean 'tabstop' != 'shiftwidth'\n\t\t&& ((tabstop_count(curbuf->b_p_vts_array) > 1)\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 1\n\t\t\t&& tabstop_first(curbuf->b_p_vts_array)\n\t\t\t\t\t\t       != get_sw_value(curbuf))\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 0\n\t\t\t&& curbuf->b_p_ts != get_sw_value(curbuf))))\n\t    && tabstop_count(curbuf->b_p_vsts_array) == 0\n#else\n\t    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value(curbuf))\n#endif\n\t    && get_sts_value() == 0)\n\treturn TRUE;\n\n    if (stop_arrow() == FAIL)\n\treturn TRUE;\n\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    AppendToRedobuff((char_u *)\"\\t\");\n\n#ifdef FEAT_VARTABS\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n    {\n\ttemp = (int)get_sw_value(curbuf);\n\ttemp -= get_nolist_virtcol() % temp;\n    }\n    else if (tabstop_count(curbuf->b_p_vsts_array) > 0 || curbuf->b_p_sts != 0)\n\t\t\t\t// use 'softtabstop' when set\n\ttemp = tabstop_padding(get_nolist_virtcol(), get_sts_value(),\n\t\t\t\t\t\t     curbuf->b_p_vsts_array);\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = tabstop_padding(get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t     curbuf->b_p_vts_array);\n#else\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n\ttemp = (int)get_sw_value(curbuf);\n    else if (curbuf->b_p_sts != 0) // use 'softtabstop' when set\n\ttemp = (int)get_sts_value();\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = (int)curbuf->b_p_ts;\n    temp -= get_nolist_virtcol() % temp;\n#endif\n\n    /*\n     * Insert the first space with ins_char().\tIt will delete one char in\n     * replace mode.  Insert the rest with ins_str(); it will not delete any\n     * chars.  For MODE_VREPLACE state, we use ins_char() for all characters.\n     */\n    ins_char(' ');\n    while (--temp > 0)\n    {\n\tif (State & VREPLACE_FLAG)\n\t    ins_char(' ');\n\telse\n\t{\n\t    ins_str((char_u *)\" \");\n\t    if (State & REPLACE_FLAG)\t    // no char replaced\n\t\treplace_push(NUL);\n\t}\n    }\n\n    /*\n     * When 'expandtab' not set: Replace spaces by TABs where possible.\n     */\n#ifdef FEAT_VARTABS\n    if (!curbuf->b_p_et && (tabstop_count(curbuf->b_p_vsts_array) > 0\n\t\t\t    || get_sts_value() > 0\n\t\t\t    || (p_sta && ind)))\n#else\n    if (!curbuf->b_p_et && (get_sts_value() || (p_sta && ind)))\n#endif\n    {\n\tchar_u\t\t*ptr;\n\tchar_u\t\t*saved_line = NULL;\t// init for GCC\n\tpos_T\t\tpos;\n\tpos_T\t\tfpos;\n\tpos_T\t\t*cursor;\n\tcolnr_T\t\twant_vcol, vcol;\n\tint\t\tchange_col = -1;\n\tint\t\tsave_list = curwin->w_p_list;\n\n\t/*\n\t * Get the current line.  For MODE_VREPLACE state, don't make real\n\t * changes yet, just work on a copy of the line.\n\t */\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    pos = curwin->w_cursor;\n\t    cursor = &pos;\n\t    saved_line = vim_strsave(ml_get_curline());\n\t    if (saved_line == NULL)\n\t\treturn FALSE;\n\t    ptr = saved_line + pos.col;\n\t}\n\telse\n\t{\n\t    ptr = ml_get_cursor();\n\t    cursor = &curwin->w_cursor;\n\t}\n\n\t// When 'L' is not in 'cpoptions' a tab always takes up 'ts' spaces.\n\tif (vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\t    curwin->w_p_list = FALSE;\n\n\t// Find first white before the cursor\n\tfpos = curwin->w_cursor;\n\twhile (fpos.col > 0 && VIM_ISWHITE(ptr[-1]))\n\t{\n\t    --fpos.col;\n\t    --ptr;\n\t}\n\n\t// In Replace mode, don't change characters before the insert point.\n\tif ((State & REPLACE_FLAG)\n\t\t&& fpos.lnum == Insstart.lnum\n\t\t&& fpos.col < Insstart.col)\n\t{\n\t    ptr += Insstart.col - fpos.col;\n\t    fpos.col = Insstart.col;\n\t}\n\n\t// compute virtual column numbers of first white and cursor\n\tgetvcol(curwin, &fpos, &vcol, NULL, NULL);\n\tgetvcol(curwin, cursor, &want_vcol, NULL, NULL);\n\n\t// Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'\n\t// and 'linebreak' adding extra virtual columns.\n\twhile (VIM_ISWHITE(*ptr))\n\t{\n\t    i = lbr_chartabsize(NULL, (char_u *)\"\\t\", vcol);\n\t    if (vcol + i > want_vcol)\n\t\tbreak;\n\t    if (*ptr != TAB)\n\t    {\n\t\t*ptr = TAB;\n\t\tif (change_col < 0)\n\t\t{\n\t\t    change_col = fpos.col;  // Column of first change\n\t\t    // May have to adjust Insstart\n\t\t    if (fpos.lnum == Insstart.lnum && fpos.col < Insstart.col)\n\t\t\tInsstart.col = fpos.col;\n\t\t}\n\t    }\n\t    ++fpos.col;\n\t    ++ptr;\n\t    vcol += i;\n\t}\n\n\tif (change_col >= 0)\n\t{\n\t    int repl_off = 0;\n\t    char_u *line = ptr;\n\n\t    // Skip over the spaces we need.\n\t    while (vcol < want_vcol && *ptr == ' ')\n\t    {\n\t\tvcol += lbr_chartabsize(line, ptr, vcol);\n\t\t++ptr;\n\t\t++repl_off;\n\t    }\n\t    if (vcol > want_vcol)\n\t    {\n\t\t// Must have a char with 'showbreak' just before it.\n\t\t--ptr;\n\t\t--repl_off;\n\t    }\n\t    fpos.col += repl_off;\n\n\t    // Delete following spaces.\n\t    i = cursor->col - fpos.col;\n\t    if (i > 0)\n\t    {\n#ifdef FEAT_PROP_POPUP\n\t\tif (!(State & VREPLACE_FLAG))\n\t\t{\n\t\t    char_u  *newp;\n\t\t    int\t    col;\n\n\t\t    newp = alloc(curbuf->b_ml.ml_line_len - i);\n\t\t    if (newp == NULL)\n\t\t\treturn FALSE;\n\n\t\t    col = ptr - curbuf->b_ml.ml_line_ptr;\n\t\t    if (col > 0)\n\t\t\tmch_memmove(newp, ptr - col, col);\n\t\t    mch_memmove(newp + col, ptr + i,\n\t\t\t\t\t   curbuf->b_ml.ml_line_len - col - i);\n\n\t\t    if (curbuf->b_ml.ml_flags & ML_LINE_DIRTY)\n\t\t\tvim_free(curbuf->b_ml.ml_line_ptr);\n\t\t    curbuf->b_ml.ml_line_ptr = newp;\n\t\t    curbuf->b_ml.ml_line_len -= i;\n\t\t    curbuf->b_ml.ml_flags =\n\t\t\t   (curbuf->b_ml.ml_flags | ML_LINE_DIRTY) & ~ML_EMPTY;\n\t\t}\n\t\telse\n#endif\n\t\t    STRMOVE(ptr, ptr + i);\n\t\t// correct replace stack.\n\t\tif ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\t\t    for (temp = i; --temp >= 0; )\n\t\t\treplace_join(repl_off);\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tnetbeans_removed(curbuf, fpos.lnum, cursor->col, (long)(i + 1));\n\t\tnetbeans_inserted(curbuf, fpos.lnum, cursor->col,\n\t\t\t\t\t\t\t   (char_u *)\"\\t\", 1);\n\t    }\n#endif\n\t    cursor->col -= i;\n\n\t    /*\n\t     * In MODE_VREPLACE state, we haven't changed anything yet.  Do it\n\t     * now by backspacing over the changed spacing and then inserting\n\t     * the new spacing.\n\t     */\n\t    if (State & VREPLACE_FLAG)\n\t    {\n\t\t// Backspace from real cursor to change_col\n\t\tbackspace_until_column(change_col);\n\n\t\t// Insert each char in saved_line from changed_col to\n\t\t// ptr-cursor\n\t\tins_bytes_len(saved_line + change_col,\n\t\t\t\t\t\t    cursor->col - change_col);\n\t    }\n\t}\n\n\tif (State & VREPLACE_FLAG)\n\t    vim_free(saved_line);\n\tcurwin->w_p_list = save_list;\n    }\n\n    return FALSE;\n}\n\n/*\n * Handle CR or NL in insert mode.\n * Return FAIL when out of memory or can't undo.\n */\n    int\nins_eol(int c)\n{\n    int\t    i;\n\n    if (echeck_abbr(c + ABBR_OFF))\n\treturn OK;\n    if (stop_arrow() == FAIL)\n\treturn FAIL;\n    undisplay_dollar();\n\n    /*\n     * Strange Vi behaviour: In Replace mode, typing a NL will not delete the\n     * character under the cursor.  Only push a NUL on the replace stack,\n     * nothing to put back when the NL is deleted.\n     */\n    if ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\treplace_push(NUL);\n\n    /*\n     * In MODE_VREPLACE state, a NL replaces the rest of the line, and starts\n     * replacing the next line, so we push all of the characters left on the\n     * line onto the replace stack.  This is not done here though, it is done\n     * in open_line().\n     */\n\n    // Put cursor on NUL if on the last char and coladd is 1 (happens after\n    // CTRL-O).\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance(getviscol());\n\n#ifdef FEAT_RIGHTLEFT\n    // NL in reverse insert will always start in the end of\n    // current line.\n    if (revins_on)\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n#endif\n\n    AppendToRedobuff(NL_STR);\n    i = open_line(FORWARD,\n\t    has_format_option(FO_RET_COMS) ? OPENLINE_DO_COM : 0, old_indent,\n\t    NULL);\n    old_indent = 0;\n    can_cindent = TRUE;\n#ifdef FEAT_FOLDING\n    // When inserting a line the cursor line must never be in a closed fold.\n    foldOpenCursor();\n#endif\n\n    return i;\n}\n\n#ifdef FEAT_DIGRAPHS\n/*\n * Handle digraph in insert mode.\n * Returns character still to be inserted, or NUL when nothing remaining to be\n * done.\n */\n    static int\nins_digraph(void)\n{\n    int\t    c;\n    int\t    cc;\n    int\t    did_putchar = FALSE;\n\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('?', TRUE);\n\tdid_putchar = TRUE;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_K);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // don't map the digraph chars. This also prevents the\n    // mode message to be deleted when ESC is hit\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    if (did_putchar)\n\t// when the line fits in 'columns' the '?' is at the start of the next\n\t// line and will not be removed by the redraw\n\tedit_unputchar();\n\n    if (IS_SPECIAL(c) || mod_mask)\t    // special key\n    {\n#ifdef FEAT_CMDL_INFO\n\tclear_showcmd();\n#endif\n\tinsert_special(c, TRUE, FALSE);\n\treturn NUL;\n    }\n    if (c != ESC)\n    {\n\tdid_putchar = FALSE;\n\tif (redrawing() && !char_avail())\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\n\t    if (char2cells(c) == 1)\n\t    {\n\t\tins_redraw(FALSE);\n\t\tedit_putchar(c, TRUE);\n\t\tdid_putchar = TRUE;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    add_to_showcmd_c(c);\n#endif\n\t}\n\t++no_mapping;\n\t++allow_keys;\n\tcc = plain_vgetc();\n\t--no_mapping;\n\t--allow_keys;\n\tif (did_putchar)\n\t    // when the line fits in 'columns' the '?' is at the start of the\n\t    // next line and will not be removed by a redraw\n\t    edit_unputchar();\n\tif (cc != ESC)\n\t{\n\t    AppendToRedobuff((char_u *)CTRL_V_STR);\n\t    c = digraph_get(c, cc, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    clear_showcmd();\n#endif\n\t    return c;\n\t}\n    }\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n    return NUL;\n}\n#endif\n\n/*\n * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.\n * Returns the char to be inserted, or NUL if none found.\n */\n    int\nins_copychar(linenr_T lnum)\n{\n    int\t    c;\n    int\t    temp;\n    char_u  *ptr, *prev_ptr;\n    char_u  *line;\n\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)\n    {\n\tvim_beep(BO_COPY);\n\treturn NUL;\n    }\n\n    // try to advance to the cursor column\n    temp = 0;\n    line = ptr = ml_get(lnum);\n    prev_ptr = ptr;\n    validate_virtcol();\n    while ((colnr_T)temp < curwin->w_virtcol && *ptr != NUL)\n    {\n\tprev_ptr = ptr;\n\ttemp += lbr_chartabsize_adv(line, &ptr, (colnr_T)temp);\n    }\n    if ((colnr_T)temp > curwin->w_virtcol)\n\tptr = prev_ptr;\n\n    c = (*mb_ptr2char)(ptr);\n    if (c == NUL)\n\tvim_beep(BO_COPY);\n    return c;\n}\n\n/*\n * CTRL-Y or CTRL-E typed in Insert mode.\n */\n    static int\nins_ctrl_ey(int tc)\n{\n    int\t    c = tc;\n\n    if (ctrl_x_mode_scroll())\n    {\n\tif (c == Ctrl_Y)\n\t    scrolldown_clamp();\n\telse\n\t    scrollup_clamp();\n\tredraw_later(VALID);\n    }\n    else\n    {\n\tc = ins_copychar(curwin->w_cursor.lnum + (c == Ctrl_Y ? -1 : 1));\n\tif (c != NUL)\n\t{\n\t    long\ttw_save;\n\n\t    // The character must be taken literally, insert like it\n\t    // was typed after a CTRL-V, and pretend 'textwidth'\n\t    // wasn't set.  Digits, 'o' and 'x' are special after a\n\t    // CTRL-V, don't use it for these.\n\t    if (c < 256 && !isalnum(c))\n\t\tAppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\t    tw_save = curbuf->b_p_tw;\n\t    curbuf->b_p_tw = -1;\n\t    insert_special(c, TRUE, FALSE);\n\t    curbuf->b_p_tw = tw_save;\n#ifdef FEAT_RIGHTLEFT\n\t    revins_chars++;\n\t    revins_legal++;\n#endif\n\t    c = Ctrl_V;\t// pretend CTRL-V is last character\n\t    auto_format(FALSE, TRUE);\n\t}\n    }\n    return c;\n}\n\n/*\n * Get the value that w_virtcol would have when 'list' is off.\n * Unless 'cpo' contains the 'L' flag.\n */\n    colnr_T\nget_nolist_virtcol(void)\n{\n    // check validity of cursor in current buffer\n    if (curwin->w_buffer == NULL\n\t|| curwin->w_buffer->b_ml.ml_mfp == NULL\n\t|| curwin->w_cursor.lnum > curwin->w_buffer->b_ml.ml_line_count)\n\treturn 0;\n    if (curwin->w_p_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\treturn getvcol_nolist(&curwin->w_cursor);\n    validate_virtcol();\n    return curwin->w_virtcol;\n}\n\n#if defined(FEAT_EVAL)\n/*\n * Handle the InsertCharPre autocommand.\n * \"c\" is the character that was typed.\n * Return a pointer to allocated memory with the replacement string.\n * Return NULL to continue inserting \"c\".\n */\n    static char_u *\ndo_insert_char_pre(int c)\n{\n    char_u\t*res;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tsave_State = State;\n\n    // Return quickly when there is nothing to do.\n    if (!has_insertcharpre())\n\treturn NULL;\n\n    if (has_mbyte)\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    else\n    {\n\tbuf[0] = c;\n\tbuf[1] = NUL;\n    }\n\n    // Lock the text to avoid weird things from happening.\n    ++textlock;\n    set_vim_var_string(VV_CHAR, buf, -1);  // set v:char\n\n    res = NULL;\n    if (ins_apply_autocmds(EVENT_INSERTCHARPRE))\n    {\n\t// Get the value of v:char.  It may be empty or more than one\n\t// character.  Only use it when changed, otherwise continue with the\n\t// original character to avoid breaking autoindent.\n\tif (STRCMP(buf, get_vim_var_str(VV_CHAR)) != 0)\n\t    res = vim_strsave(get_vim_var_str(VV_CHAR));\n    }\n\n    set_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n    --textlock;\n\n    // Restore the State, it may have been changed.\n    State = save_State;\n\n    return res;\n}\n#endif\n\n    int\nget_can_cindent(void)\n{\n    return can_cindent;\n}\n\n    void\nset_can_cindent(int val)\n{\n    can_cindent = val;\n}\n\n/*\n * Trigger \"event\" and take care of fixing undo.\n */\n    int\nins_apply_autocmds(event_T event)\n{\n    varnumber_T\ttick = CHANGEDTICK(curbuf);\n    int r;\n\n    r = apply_autocmds(event, NULL, NULL, FALSE, curbuf);\n\n    // If u_savesub() was called then we are not prepared to start\n    // a new line.  Call u_save() with no contents to fix that.\n    // Except when leaving Insert mode.\n    if (event != EVENT_INSERTLEAVE && tick != CHANGEDTICK(curbuf))\n\tu_save(curwin->w_cursor.lnum, (linenr_T)(curwin->w_cursor.lnum + 1));\n\n    return r;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5161,\n/**/\n    5160,\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * edit.c: functions for Insert mode\n */\n\n#include \"vim.h\"\n\n#define BACKSPACE_CHAR\t\t    1\n#define BACKSPACE_WORD\t\t    2\n#define BACKSPACE_WORD_NOT_SPACE    3\n#define BACKSPACE_LINE\t\t    4\n\n// Set when doing something for completion that may call edit() recursively,\n// which is not allowed.\nstatic int\tcompl_busy = FALSE;\n\n\nstatic void ins_ctrl_v(void);\nstatic void insert_special(int, int, int);\nstatic void redo_literal(int c);\nstatic void start_arrow_common(pos_T *end_insert_pos, int change);\n#ifdef FEAT_SPELL\nstatic void check_spell_redraw(void);\n#endif\nstatic void stop_insert(pos_T *end_insert_pos, int esc, int nomove);\nstatic int  echeck_abbr(int);\nstatic void mb_replace_pop_ins(int cc);\nstatic void replace_flush(void);\nstatic void replace_do_bs(int limit_col);\nstatic int del_char_after_col(int limit_col);\nstatic void ins_reg(void);\nstatic void ins_ctrl_g(void);\nstatic void ins_ctrl_hat(void);\nstatic int  ins_esc(long *count, int cmdchar, int nomove);\n#ifdef FEAT_RIGHTLEFT\nstatic void ins_ctrl_(void);\n#endif\nstatic int ins_start_select(int c);\nstatic void ins_insert(int replaceState);\nstatic void ins_ctrl_o(void);\nstatic void ins_shift(int c, int lastc);\nstatic void ins_del(void);\nstatic int  ins_bs(int c, int mode, int *inserted_space_p);\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\nstatic void ins_tabline(int c);\n#endif\nstatic void ins_left(void);\nstatic void ins_home(int c);\nstatic void ins_end(int c);\nstatic void ins_s_left(void);\nstatic void ins_right(void);\nstatic void ins_s_right(void);\nstatic void ins_up(int startcol);\nstatic void ins_pageup(void);\nstatic void ins_down(int startcol);\nstatic void ins_pagedown(void);\n#ifdef FEAT_DND\nstatic void ins_drop(void);\n#endif\nstatic int  ins_tab(void);\n#ifdef FEAT_DIGRAPHS\nstatic int  ins_digraph(void);\n#endif\nstatic int  ins_ctrl_ey(int tc);\n#if defined(FEAT_EVAL)\nstatic char_u *do_insert_char_pre(int c);\n#endif\n\nstatic colnr_T\tInsstart_textlen;\t// length of line when insert started\nstatic colnr_T\tInsstart_blank_vcol;\t// vcol for first inserted blank\nstatic int\tupdate_Insstart_orig = TRUE; // set Insstart_orig to Insstart\n\nstatic char_u\t*last_insert = NULL;\t// the text of the previous insert,\n\t\t\t\t\t// K_SPECIAL and CSI are escaped\nstatic int\tlast_insert_skip; // nr of chars in front of previous insert\nstatic int\tnew_insert_skip;  // nr of chars in front of current insert\nstatic int\tdid_restart_edit;\t// \"restart_edit\" when calling edit()\n\nstatic int\tcan_cindent;\t\t// may do cindenting on this line\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\trevins_on;\t\t// reverse insert mode on\nstatic int\trevins_chars;\t\t// how much to skip after edit\nstatic int\trevins_legal;\t\t// was the last char 'legal'?\nstatic int\trevins_scol;\t\t// start column of revins session\n#endif\n\nstatic int\tins_need_undo;\t\t// call u_save() before inserting a\n\t\t\t\t\t// char.  Set when edit() is called.\n\t\t\t\t\t// after that arrow_used is used.\n\nstatic int\tdont_sync_undo = FALSE;\t// CTRL-G U prevents syncing undo for\n\t\t\t\t\t// the next left/right cursor key\n\n/*\n * edit(): Start inserting text.\n *\n * \"cmdchar\" can be:\n * 'i'\tnormal insert command\n * 'a'\tnormal append command\n * K_PS bracketed paste\n * 'R'\treplace command\n * 'r'\t\"r<CR>\" command: insert one <CR>.  Note: count can be > 1, for redo,\n *\tbut still only one <CR> is inserted.  The <Esc> is not used for redo.\n * 'g'\t\"gI\" command.\n * 'V'\t\"gR\" command for Virtual Replace mode.\n * 'v'\t\"gr\" command for single character Virtual Replace mode.\n *\n * This function is not called recursively.  For CTRL-O commands, it returns\n * and lets the caller handle the Normal-mode command.\n *\n * Return TRUE if a CTRL-O command caused the return (insert mode pending).\n */\n    int\nedit(\n    int\t\tcmdchar,\n    int\t\tstartln,\t// if set, insert at start of line\n    long\tcount)\n{\n    int\t\tc = 0;\n    char_u\t*ptr;\n    int\t\tlastc = 0;\n    int\t\tmincol;\n    static linenr_T o_lnum = 0;\n    int\t\ti;\n    int\t\tdid_backspace = TRUE;\t    // previous char was backspace\n    int\t\tline_is_white = FALSE;\t    // line is empty before insert\n    linenr_T\told_topline = 0;\t    // topline before insertion\n#ifdef FEAT_DIFF\n    int\t\told_topfill = -1;\n#endif\n    int\t\tinserted_space = FALSE;     // just inserted a space\n    int\t\treplaceState = MODE_REPLACE;\n    int\t\tnomove = FALSE;\t\t    // don't move cursor on return\n#ifdef FEAT_JOB_CHANNEL\n    int\t\tcmdchar_todo = cmdchar;\n#endif\n#ifdef FEAT_CONCEAL\n    int\t\tcursor_line_was_concealed;\n#endif\n\n    // Remember whether editing was restarted after CTRL-O.\n    did_restart_edit = restart_edit;\n\n    // sleep before redrawing, needed for \"CTRL-O :\" that results in an\n    // error message\n    check_for_delay(TRUE);\n\n    // set Insstart_orig to Insstart\n    update_Insstart_orig = TRUE;\n\n#ifdef HAVE_SANDBOX\n    // Don't allow inserting in the sandbox.\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn FALSE;\n    }\n#endif\n    // Don't allow changes in the buffer while editing the cmdline.  The\n    // caller of getcmdline() may get confused.\n    // Don't allow recursive insert mode when busy with completion.\n    if (textlock != 0 || ins_compl_active() || compl_busy || pum_visible())\n    {\n\temsg(_(e_not_allowed_to_change_text_or_change_window));\n\treturn FALSE;\n    }\n    ins_compl_clear();\t    // clear stuff for CTRL-X mode\n\n    /*\n     * Trigger InsertEnter autocommands.  Do not do this for \"r<CR>\" or \"grx\".\n     */\n    if (cmdchar != 'r' && cmdchar != 'v')\n    {\n\tpos_T   save_cursor = curwin->w_cursor;\n\n#ifdef FEAT_EVAL\n\tif (cmdchar == 'R')\n\t    ptr = (char_u *)\"r\";\n\telse if (cmdchar == 'V')\n\t    ptr = (char_u *)\"v\";\n\telse\n\t    ptr = (char_u *)\"i\";\n\tset_vim_var_string(VV_INSERTMODE, ptr, 1);\n\tset_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n#endif\n\tins_apply_autocmds(EVENT_INSERTENTER);\n\n\t// Check for changed highlighting, e.g. for ModeMsg.\n\tif (need_highlight_changed)\n\t    highlight_changed();\n\n\t// Make sure the cursor didn't move.  Do call check_cursor_col() in\n\t// case the text was modified.  Since Insert mode was not started yet\n\t// a call to check_cursor_col() may move the cursor, especially with\n\t// the \"A\" command, thus set State to avoid that. Also check that the\n\t// line number is still valid (lines may have been deleted).\n\t// Do not restore if v:char was set to a non-empty string.\n\tif (!EQUAL_POS(curwin->w_cursor, save_cursor)\n#ifdef FEAT_EVAL\n\t\t&& *get_vim_var_str(VV_CHAR) == NUL\n#endif\n\t\t&& save_cursor.lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    int save_state = State;\n\n\t    curwin->w_cursor = save_cursor;\n\t    State = MODE_INSERT;\n\t    check_cursor_col();\n\t    State = save_state;\n\t}\n    }\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line was concealed before changing State.\n    cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    /*\n     * When doing a paste with the middle mouse button, Insstart is set to\n     * where the paste started.\n     */\n    if (where_paste_started.lnum != 0)\n\tInsstart = where_paste_started;\n    else\n    {\n\tInsstart = curwin->w_cursor;\n\tif (startln)\n\t    Insstart.col = 0;\n    }\n    Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n    Insstart_blank_vcol = MAXCOL;\n    if (!did_ai)\n\tai_col = 0;\n\n    if (cmdchar != NUL && restart_edit == 0)\n    {\n\tResetRedobuff();\n\tAppendNumberToRedobuff(count);\n\tif (cmdchar == 'V' || cmdchar == 'v')\n\t{\n\t    // \"gR\" or \"gr\" command\n\t    AppendCharToRedobuff('g');\n\t    AppendCharToRedobuff((cmdchar == 'v') ? 'r' : 'R');\n\t}\n\telse\n\t{\n\t    if (cmdchar == K_PS)\n\t\tAppendCharToRedobuff('a');\n\t    else\n\t\tAppendCharToRedobuff(cmdchar);\n\t    if (cmdchar == 'g')\t\t    // \"gI\" command\n\t\tAppendCharToRedobuff('I');\n\t    else if (cmdchar == 'r')\t    // \"r<CR>\" command\n\t\tcount = 1;\t\t    // insert only one <CR>\n\t}\n    }\n\n    if (cmdchar == 'R')\n    {\n\tState = MODE_REPLACE;\n    }\n    else if (cmdchar == 'V' || cmdchar == 'v')\n    {\n\tState = MODE_VREPLACE;\n\treplaceState = MODE_VREPLACE;\n\torig_line_count = curbuf->b_ml.ml_line_count;\n\tvr_lines_changed = 1;\n    }\n    else\n\tState = MODE_INSERT;\n\n    may_trigger_modechanged();\n    stop_insert_mode = FALSE;\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"n\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    /*\n     * Enable langmap or IME, indicated by 'iminsert'.\n     * Note that IME may enabled/disabled without us noticing here, thus the\n     * 'iminsert' value may not reflect what is actually used.  It is updated\n     * when hitting <Esc>.\n     */\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n#endif\n\n    setmouse();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // there is no reverse replace mode\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n\tundisplay_dollar();\n    revins_chars = 0;\n    revins_legal = 0;\n    revins_scol = -1;\n#endif\n    if (!p_ek)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\n\t// Disable bracketed paste mode, we won't recognize the escape\n\t// sequences.\n\tout_str(T_BD);\n\n\t// Disable modifyOtherKeys, keys with modifiers would cause exiting\n\t// Insert mode.\n\tout_str(T_CTE);\n    }\n\n    /*\n     * Handle restarting Insert mode.\n     * Don't do this for \"CTRL-O .\" (repeat an insert): In that case we get\n     * here with something in the stuff buffer.\n     */\n    if (restart_edit != 0 && stuff_empty())\n    {\n\t/*\n\t * After a paste we consider text typed to be part of the insert for\n\t * the pasted text. You can backspace over the pasted text too.\n\t */\n\tif (where_paste_started.lnum)\n\t    arrow_used = FALSE;\n\telse\n\t    arrow_used = TRUE;\n\trestart_edit = 0;\n\n\t/*\n\t * If the cursor was after the end-of-line before the CTRL-O and it is\n\t * now at the end-of-line, put it after the end-of-line (this is not\n\t * correct in very rare cases).\n\t * Also do this if curswant is greater than the current virtual\n\t * column.  Eg after \"^O$\" or \"^O80|\".\n\t */\n\tvalidate_virtcol();\n\tupdate_curswant();\n\tif (((ins_at_eol && curwin->w_cursor.lnum == o_lnum)\n\t\t    || curwin->w_curswant > curwin->w_virtcol)\n\t\t&& *(ptr = ml_get_curline() + curwin->w_cursor.col) != NUL)\n\t{\n\t    if (ptr[1] == NUL)\n\t\t++curwin->w_cursor.col;\n\t    else if (has_mbyte)\n\t    {\n\t\ti = (*mb_ptr2len)(ptr);\n\t\tif (ptr[i] == NUL)\n\t\t    curwin->w_cursor.col += i;\n\t    }\n\t}\n\tins_at_eol = FALSE;\n    }\n    else\n\tarrow_used = FALSE;\n\n    // we are in insert mode now, don't need to start it anymore\n    need_start_insertmode = FALSE;\n\n    // Need to save the line for undo before inserting the first char.\n    ins_need_undo = TRUE;\n\n    where_paste_started.lnum = 0;\n    can_cindent = TRUE;\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold, unless 'insertmode' is set or\n    // restarting.\n    if (!p_im && did_restart_edit == 0)\n\tfoldOpenCursor();\n#endif\n\n    /*\n     * If 'showmode' is set, show the current (insert/replace/..) mode.\n     * A warning message for changing a readonly file is given here, before\n     * actually changing anything.  It's put after the mode, if any.\n     */\n    i = 0;\n    if (p_smd && msg_silent == 0)\n\ti = showmode();\n\n    if (!p_im && did_restart_edit == 0)\n\tchange_warning(i == 0 ? 0 : i + 1);\n\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// clear digraphs\n#endif\n\n    /*\n     * Get the current length of the redo buffer, those characters have to be\n     * skipped if we want to get to the inserted characters.\n     */\n    ptr = get_inserted();\n    if (ptr == NULL)\n\tnew_insert_skip = 0;\n    else\n    {\n\tnew_insert_skip = (int)STRLEN(ptr);\n\tvim_free(ptr);\n    }\n\n    old_indent = 0;\n\n    /*\n     * Main loop in Insert mode: repeat until Insert mode is left.\n     */\n    for (;;)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (!revins_legal)\n\t    revins_scol = -1;\t    // reset on illegal motions\n\telse\n\t    revins_legal = 0;\n#endif\n\tif (arrow_used)\t    // don't repeat insert when arrow key used\n\t    count = 0;\n\n\tif (update_Insstart_orig)\n\t    Insstart_orig = Insstart;\n\n\tif (stop_insert_mode && !ins_compl_active())\n\t{\n\t    // \":stopinsert\" used or 'insertmode' reset\n\t    count = 0;\n\t    goto doESCkey;\n\t}\n\n\t// set curwin->w_curswant for next K_DOWN or K_UP\n\tif (!arrow_used)\n\t    curwin->w_set_curswant = TRUE;\n\n\t// If there is no typeahead may check for timestamps (e.g., for when a\n\t// menu invoked a shell command).\n\tif (stuff_empty())\n\t{\n\t    did_check_timestamps = FALSE;\n\t    if (need_check_timestamps)\n\t\tcheck_timestamps(FALSE);\n\t}\n\n\t/*\n\t * When emsg() was called msg_scroll will have been set.\n\t */\n\tmsg_scroll = FALSE;\n\n#ifdef FEAT_GUI\n\t// When 'mousefocus' is set a mouse movement may have taken us to\n\t// another window.  \"need_mouse_correct\" may then be set because of an\n\t// autocommand.\n\tif (need_mouse_correct)\n\t    gui_mouse_correct();\n#endif\n\n#ifdef FEAT_FOLDING\n\t// Open fold at the cursor line, according to 'foldopen'.\n\tif (fdo_flags & FDO_INSERT)\n\t    foldOpenCursor();\n\t// Close folds where the cursor isn't, according to 'foldclose'\n\tif (!char_avail())\n\t    foldCheckClose();\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    init_prompt(cmdchar_todo);\n\t    cmdchar_todo = NUL;\n\t}\n#endif\n\n\t/*\n\t * If we inserted a character at the last position of the last line in\n\t * the window, scroll the window one line up. This avoids an extra\n\t * redraw.\n\t * This is detected when the cursor column is smaller after inserting\n\t * something.\n\t * Don't do this when the topline changed already, it has\n\t * already been adjusted (by insertchar() calling open_line())).\n\t */\n\tif (curbuf->b_mod_set\n\t\t&& curwin->w_p_wrap\n\t\t&& !did_backspace\n\t\t&& curwin->w_topline == old_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == old_topfill\n#endif\n\t\t)\n\t{\n\t    mincol = curwin->w_wcol;\n\t    validate_cursor_col();\n\n\t    if (\n#ifdef FEAT_VARTABS\n\t\tcurwin->w_wcol < mincol - tabstop_at(\n\t\t\t\t\t  get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t\t curbuf->b_p_vts_array)\n#else\n\t\t(int)curwin->w_wcol < mincol - curbuf->b_p_ts\n#endif\n\t\t    && curwin->w_wrow == W_WINROW(curwin)\n\t\t\t\t + curwin->w_height - 1 - get_scrolloff_value()\n\t\t    && (curwin->w_cursor.lnum != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill > 0\n#endif\n\t\t    ))\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    --curwin->w_topfill;\n\t\telse\n#endif\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline, NULL, &old_topline))\n\t\t    set_topline(curwin, old_topline + 1);\n\t\telse\n#endif\n\t\t    set_topline(curwin, curwin->w_topline + 1);\n\t    }\n\t}\n\n\t// May need to adjust w_topline to show the cursor.\n\tupdate_topline();\n\n\tdid_backspace = FALSE;\n\n\tvalidate_cursor();\t\t// may set must_redraw\n\n\t/*\n\t * Redraw the display when no characters are waiting.\n\t * Also shows mode, ruler and positions cursor.\n\t */\n\tins_redraw(TRUE);\n\n\tif (curwin->w_p_scb)\n\t    do_check_scrollbind(TRUE);\n\n\tif (curwin->w_p_crb)\n\t    do_check_cursorbind();\n\tupdate_curswant();\n\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n\told_topfill = curwin->w_topfill;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n\t/*\n\t * Get a character for Insert mode.  Ignore K_IGNORE and K_NOP.\n\t */\n\tif (c != K_CURSORHOLD)\n\t    lastc = c;\t\t// remember the previous char for CTRL-D\n\n\t// After using CTRL-G U the next cursor key will not break undo.\n\tif (dont_sync_undo == MAYBE)\n\t    dont_sync_undo = TRUE;\n\telse\n\t    dont_sync_undo = FALSE;\n\tif (cmdchar == K_PS)\n\t    // Got here from normal mode when bracketed paste started.\n\t    c = K_PS;\n\telse\n\t    do\n\t    {\n\t\tc = safe_vgetc();\n\n\t\tif (stop_insert_mode\n#ifdef FEAT_TERMINAL\n\t\t\t|| (c == K_IGNORE && term_use_loop())\n#endif\n\t\t   )\n\t\t{\n\t\t    // Insert mode ended, possibly from a callback, or a timer\n\t\t    // must have opened a terminal window.\n\t\t    if (c != K_IGNORE && c != K_NOP)\n\t\t\tvungetc(c);\n\t\t    count = 0;\n\t\t    nomove = TRUE;\n\t\t    ins_compl_prep(ESC);\n\t\t    goto doESCkey;\n\t\t}\n\t    } while (c == K_IGNORE || c == K_NOP);\n\n\t// Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.\n\tdid_cursorhold = TRUE;\n\n#ifdef FEAT_RIGHTLEFT\n\tif (p_hkmap && KeyTyped)\n\t    c = hkmap(c);\t\t// Hebrew mode mapping\n#endif\n\n\t// If the window was made so small that nothing shows, make it at least\n\t// one line and one column when typing.\n\tif (KeyTyped && !KeyStuffed)\n\t    win_ensure_size();\n\n\t/*\n\t * Special handling of keys while the popup menu is visible or wanted\n\t * and the cursor is still in the completed word.  Only when there is\n\t * a match, skip this when no matches were found.\n\t */\n\tif (ins_compl_active()\n\t\t&& pum_wanted()\n\t\t&& curwin->w_cursor.col >= ins_compl_col()\n\t\t&& ins_compl_has_shown_match())\n\t{\n\t    // BS: Delete one character from \"compl_leader\".\n\t    if ((c == K_BS || c == Ctrl_H)\n\t\t\t&& curwin->w_cursor.col > ins_compl_col()\n\t\t\t&& (c = ins_compl_bs()) == NUL)\n\t\tcontinue;\n\n\t    // When no match was selected or it was edited.\n\t    if (!ins_compl_used_match())\n\t    {\n\t\t// CTRL-L: Add one character from the current match to\n\t\t// \"compl_leader\".  Except when at the original match and\n\t\t// there is nothing to add, CTRL-L works like CTRL-P then.\n\t\tif (c == Ctrl_L\n\t\t\t&& (!ctrl_x_mode_line_or_eval()\n\t\t\t    || ins_compl_long_shown_match()))\n\t\t{\n\t\t    ins_compl_addfrommatch();\n\t\t    continue;\n\t\t}\n\n\t\t// A non-white character that fits in with the current\n\t\t// completion: Add to \"compl_leader\".\n\t\tif (ins_compl_accept_char(c))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    // Trigger InsertCharPre.\n\t\t    char_u *str = do_insert_char_pre(c);\n\t\t    char_u *p;\n\n\t\t    if (str != NULL)\n\t\t    {\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t    ins_compl_addleader(PTR2CHAR(p));\n\t\t\tvim_free(str);\n\t\t    }\n\t\t    else\n#endif\n\t\t\tins_compl_addleader(c);\n\t\t    continue;\n\t\t}\n\n\t\t// Pressing CTRL-Y selects the current match.  When\n\t\t// ins_compl_enter_selects() is set the Enter key does the\n\t\t// same.\n\t\tif ((c == Ctrl_Y || (ins_compl_enter_selects()\n\t\t\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t\t\t&& stop_arrow() == OK)\n\t\t{\n\t\t    ins_compl_delete();\n\t\t    ins_compl_insert(FALSE);\n\t\t}\n\t    }\n\t}\n\n\t// Prepare for or stop CTRL-X mode.  This doesn't do completion, but\n\t// it does fix up the text when finishing completion.\n\tins_compl_init_get_longest();\n\tif (ins_compl_prep(c))\n\t    continue;\n\n\t// CTRL-\\ CTRL-N goes to Normal mode,\n\t// CTRL-\\ CTRL-G goes to mode selected with 'insertmode',\n\t// CTRL-\\ CTRL-O is like CTRL-O but without moving the cursor.\n\tif (c == Ctrl_BSL)\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    c = plain_vgetc();\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (c != Ctrl_N && c != Ctrl_G && c != Ctrl_O)\n\t    {\n\t\t// it's something else\n\t\tvungetc(c);\n\t\tc = Ctrl_BSL;\n\t    }\n\t    else if (c == Ctrl_G && p_im)\n\t\tcontinue;\n\t    else\n\t    {\n\t\tif (c == Ctrl_O)\n\t\t{\n\t\t    ins_ctrl_o();\n\t\t    ins_at_eol = FALSE;\t// cursor keeps its column\n\t\t    nomove = TRUE;\n\t\t}\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tc = do_digraph(c);\n#endif\n\n\tif ((c == Ctrl_V || c == Ctrl_Q) && ctrl_x_mode_cmdline())\n\t    goto docomplete;\n\tif (c == Ctrl_V || c == Ctrl_Q)\n\t{\n\t    ins_ctrl_v();\n\t    c = Ctrl_V;\t// pretend CTRL-V is last typed character\n\t    continue;\n\t}\n\n\tif (cindent_on() && ctrl_x_mode_none())\n\t{\n\t    // A key name preceded by a bang means this key is not to be\n\t    // inserted.  Skip ahead to the re-indenting below.\n\t    // A key name preceded by a star means that indenting has to be\n\t    // done before inserting the key.\n\t    line_is_white = inindent(0);\n\t    if (in_cinkeys(c, '!', line_is_white))\n\t\tgoto force_cindent;\n\t    if (can_cindent && in_cinkeys(c, '*', line_is_white)\n\t\t\t\t\t\t\t&& stop_arrow() == OK)\n\t\tdo_c_expr_indent();\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t    switch (c)\n\t    {\n\t\tcase K_LEFT:\tc = K_RIGHT; break;\n\t\tcase K_S_LEFT:\tc = K_S_RIGHT; break;\n\t\tcase K_C_LEFT:\tc = K_C_RIGHT; break;\n\t\tcase K_RIGHT:\tc = K_LEFT; break;\n\t\tcase K_S_RIGHT: c = K_S_LEFT; break;\n\t\tcase K_C_RIGHT: c = K_C_LEFT; break;\n\t    }\n#endif\n\n\t/*\n\t * If 'keymodel' contains \"startsel\", may start selection.  If it\n\t * does, a CTRL-O and c will be stuffed, we need to get these\n\t * characters.\n\t */\n\tif (ins_start_select(c))\n\t    continue;\n\n\t/*\n\t * The big switch to handle a character in insert mode.\n\t */\n\tswitch (c)\n\t{\n\tcase ESC:\t// End input mode\n\t    if (echeck_abbr(ESC + ABBR_OFF))\n\t\tbreak;\n\t    // FALLTHROUGH\n\n\tcase Ctrl_C:\t// End input mode\n#ifdef FEAT_CMDWIN\n\t    if (c == Ctrl_C && cmdwin_type != 0)\n\t    {\n\t\t// Close the cmdline window.\n\t\tcmdwin_result = K_IGNORE;\n\t\tgot_int = FALSE; // don't stop executing autocommands et al.\n\t\tnomove = TRUE;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (c == Ctrl_C && bt_prompt(curbuf))\n\t    {\n\t\tif (invoke_prompt_interrupt())\n\t\t{\n\t\t    if (!bt_prompt(curbuf))\n\t\t\t// buffer changed to a non-prompt buffer, get out of\n\t\t\t// Insert mode\n\t\t\tgoto doESCkey;\n\t\t    break;\n\t\t}\n\t    }\n#endif\n\n#ifdef UNIX\ndo_intr:\n#endif\n\t    // when 'insertmode' set, and not halfway a mapping, don't leave\n\t    // Insert mode\n\t    if (goto_im())\n\t    {\n\t\tif (got_int)\n\t\t{\n\t\t    (void)vgetc();\t\t// flush all buffers\n\t\t    got_int = FALSE;\n\t\t}\n\t\telse\n\t\t    vim_beep(BO_IM);\n\t\tbreak;\n\t    }\ndoESCkey:\n\t    /*\n\t     * This is the ONLY return from edit()!\n\t     */\n\t    // Always update o_lnum, so that a \"CTRL-O .\" that adds a line\n\t    // still puts the cursor back after the inserted text.\n\t    if (ins_at_eol && gchar_cursor() == NUL)\n\t\to_lnum = curwin->w_cursor.lnum;\n\n\t    if (ins_esc(&count, cmdchar, nomove))\n\t    {\n\t\t// When CTRL-C was typed got_int will be set, with the result\n\t\t// that the autocommands won't be executed. When mapped got_int\n\t\t// is not set, but let's keep the behavior the same.\n\t\tif (cmdchar != 'r' && cmdchar != 'v' && c != Ctrl_C)\n\t\t    ins_apply_autocmds(EVENT_INSERTLEAVE);\n\t\tdid_cursorhold = FALSE;\n\t\treturn (c == Ctrl_O);\n\t    }\n\t    continue;\n\n\tcase Ctrl_Z:\t// suspend when 'insertmode' set\n\t    if (!p_im)\n\t\tgoto normalchar;\t// insert CTRL-Z as normal char\n\t    do_cmdline_cmd((char_u *)\"stop\");\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t\t// may need to update cursor shape\n#endif\n\t    continue;\n\n\tcase Ctrl_O:\t// execute one command\n#ifdef FEAT_COMPL_FUNC\n\t    if (ctrl_x_mode_omni())\n\t\tgoto docomplete;\n#endif\n\t    if (echeck_abbr(Ctrl_O + ABBR_OFF))\n\t\tbreak;\n\t    ins_ctrl_o();\n\n\t    // don't move the cursor left when 'virtualedit' has \"onemore\".\n\t    if (get_ve_flags() & VE_ONEMORE)\n\t    {\n\t\tins_at_eol = FALSE;\n\t\tnomove = TRUE;\n\t    }\n\t    count = 0;\n\t    goto doESCkey;\n\n\tcase K_INS:\t// toggle insert/replace mode\n\tcase K_KINS:\n\t    ins_insert(replaceState);\n\t    break;\n\n\tcase K_SELECT:\t// end of Select mode mapping - ignore\n\t    break;\n\n\tcase K_HELP:\t// Help key works like <ESC> <Help>\n\tcase K_F1:\n\tcase K_XF1:\n\t    stuffcharReadbuff(K_HELP);\n\t    if (p_im)\n\t\tneed_start_insertmode = TRUE;\n\t    goto doESCkey;\n\n#ifdef FEAT_NETBEANS_INTG\n\tcase K_F21:\t// NetBeans command\n\t    ++no_mapping;\t\t// don't map the next key hits\n\t    i = plain_vgetc();\n\t    --no_mapping;\n\t    netbeans_keycommand(i);\n\t    break;\n#endif\n\n\tcase K_ZERO:\t// Insert the previously inserted text.\n\tcase NUL:\n\tcase Ctrl_A:\n\t    // For ^@ the trailing ESC will end the insert, unless there is an\n\t    // error.\n\t    if (stuff_inserted(NUL, 1L, (c == Ctrl_A)) == FAIL\n\t\t\t\t\t\t   && c != Ctrl_A && !p_im)\n\t\tgoto doESCkey;\t\t// quit insert mode\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_R:\t// insert the contents of a register\n\t    ins_reg();\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_G:\t// commands starting with CTRL-G\n\t    ins_ctrl_g();\n\t    break;\n\n\tcase Ctrl_HAT:\t// switch input mode and/or langmap\n\t    ins_ctrl_hat();\n\t    break;\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t// switch between languages\n\t    if (!p_ari)\n\t\tgoto normalchar;\n\t    ins_ctrl_();\n\t    break;\n#endif\n\n\tcase Ctrl_D:\t// Make indent one shiftwidth smaller.\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_defines())\n\t\tgoto docomplete;\n#endif\n\t    // FALLTHROUGH\n\n\tcase Ctrl_T:\t// Make indent one shiftwidth greater.\n\t    if (c == Ctrl_T && ctrl_x_mode_thesaurus())\n\t    {\n\t\tif (has_compl_option(FALSE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n\n\t    ins_shift(c, lastc);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_DEL:\t// delete character under the cursor\n\tcase K_KDEL:\n\t    ins_del();\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_BS:\t// delete character before the cursor\n\tcase K_S_BS:\n\tcase Ctrl_H:\n\t    did_backspace = ins_bs(c, BACKSPACE_CHAR, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_W:\t// delete word before the cursor\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf) && (mod_mask & MOD_MASK_SHIFT) == 0)\n\t    {\n\t\t// In a prompt window CTRL-W is used for window commands.\n\t\t// Use Shift-CTRL-W to delete a word.\n\t\tstuffcharReadbuff(Ctrl_W);\n\t\trestart_edit = 'A';\n\t\tnomove = TRUE;\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n#endif\n\t    did_backspace = ins_bs(c, BACKSPACE_WORD, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_U:\t// delete all inserted text in current line\n# ifdef FEAT_COMPL_FUNC\n\t    // CTRL-X CTRL-U completes with 'completefunc'.\n\t    if (ctrl_x_mode_function())\n\t\tgoto docomplete;\n# endif\n\t    did_backspace = ins_bs(c, BACKSPACE_LINE, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_LEFTMOUSE:   // mouse keys\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\t    ins_mouse(c);\n\t    break;\n\n\tcase K_MOUSEDOWN: // Default action for scroll wheel up: scroll up\n\t    ins_mousescroll(MSCR_DOWN);\n\t    break;\n\n\tcase K_MOUSEUP:\t// Default action for scroll wheel down: scroll down\n\t    ins_mousescroll(MSCR_UP);\n\t    break;\n\n\tcase K_MOUSELEFT: // Scroll wheel left\n\t    ins_mousescroll(MSCR_LEFT);\n\t    break;\n\n\tcase K_MOUSERIGHT: // Scroll wheel right\n\t    ins_mousescroll(MSCR_RIGHT);\n\t    break;\n\n\tcase K_PS:\n\t    bracketed_paste(PASTE_INSERT, FALSE, NULL);\n\t    if (cmdchar == K_PS)\n\t\t// invoked from normal mode, bail out\n\t\tgoto doESCkey;\n\t    break;\n\tcase K_PE:\n\t    // Got K_PE without K_PS, ignore.\n\t    break;\n\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t    ins_tabline(c);\n\t    break;\n#endif\n\n\tcase K_IGNORE:\t// Something mapped to nothing\n\t    break;\n\n\tcase K_COMMAND:\t\t    // <Cmd>command<CR>\n\tcase K_SCRIPT_COMMAND:\t    // <ScriptCmd>command<CR>\n\t    do_cmdkey_command(c, 0);\n#ifdef FEAT_TERMINAL\n\t    if (term_use_loop())\n\t\t// Started a terminal that gets the input, exit Insert mode.\n\t\tgoto doESCkey;\n#endif\n\t    break;\n\n\tcase K_CURSORHOLD:\t// Didn't type something for a while.\n\t    ins_apply_autocmds(EVENT_CURSORHOLDI);\n\t    did_cursorhold = TRUE;\n\t    // If CTRL-G U was used apply it to the next typed key.\n\t    if (dont_sync_undo == TRUE)\n\t\tdont_sync_undo = MAYBE;\n\t    break;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask != MOD_MASK_ALT)\n\t\tgoto normalchar;\n\t    break;\n#endif\n\n#ifdef FEAT_GUI\n\tcase K_VER_SCROLLBAR:\n\t    ins_scroll();\n\t    break;\n\n\tcase K_HOR_SCROLLBAR:\n\t    ins_horscroll();\n\t    break;\n#endif\n\n\tcase K_HOME:\t// <Home>\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t    ins_home(c);\n\t    break;\n\n\tcase K_END:\t// <End>\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t    ins_end(c);\n\t    break;\n\n\tcase K_LEFT:\t// <Left>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_left();\n\t    else\n\t\tins_left();\n\t    break;\n\n\tcase K_S_LEFT:\t// <S-Left>\n\tcase K_C_LEFT:\n\t    ins_s_left();\n\t    break;\n\n\tcase K_RIGHT:\t// <Right>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_right();\n\t    else\n\t\tins_right();\n\t    break;\n\n\tcase K_S_RIGHT:\t// <S-Right>\n\tcase K_C_RIGHT:\n\t    ins_s_right();\n\t    break;\n\n\tcase K_UP:\t// <Up>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pageup();\n\t    else\n\t\tins_up(FALSE);\n\t    break;\n\n\tcase K_S_UP:\t// <S-Up>\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pageup();\n\t    break;\n\n\tcase K_DOWN:\t// <Down>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pagedown();\n\t    else\n\t\tins_down(FALSE);\n\t    break;\n\n\tcase K_S_DOWN:\t// <S-Down>\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pagedown();\n\t    break;\n\n#ifdef FEAT_DND\n\tcase K_DROP:\t// drag-n-drop event\n\t    ins_drop();\n\t    break;\n#endif\n\n\tcase K_S_TAB:\t// When not mapped, use like a normal TAB\n\t    c = TAB;\n\t    // FALLTHROUGH\n\n\tcase TAB:\t// TAB or Complete patterns along path\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_patterns())\n\t\tgoto docomplete;\n#endif\n\t    inserted_space = FALSE;\n\t    if (ins_tab())\n\t\tgoto normalchar;\t// insert TAB as a normal char\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_KENTER:\t// <Enter>\n\t    c = CAR;\n\t    // FALLTHROUGH\n\tcase CAR:\n\tcase NL:\n#if defined(FEAT_QUICKFIX)\n\t    // In a quickfix window a <CR> jumps to the error under the\n\t    // cursor.\n\t    if (bt_quickfix(curbuf) && c == CAR)\n\t    {\n\t\tif (curwin->w_llist_ref == NULL)    // quickfix window\n\t\t    do_cmdline_cmd((char_u *)\".cc\");\n\t\telse\t\t\t\t    // location list window\n\t\t    do_cmdline_cmd((char_u *)\".ll\");\n\t\tbreak;\n\t    }\n#endif\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0)\n\t    {\n\t\t// Execute the command in the cmdline window.\n\t\tcmdwin_result = CAR;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf))\n\t    {\n\t\tinvoke_prompt_callback();\n\t\tif (!bt_prompt(curbuf))\n\t\t    // buffer changed to a non-prompt buffer, get out of\n\t\t    // Insert mode\n\t\t    goto doESCkey;\n\t\tbreak;\n\t    }\n#endif\n\t    if (ins_eol(c) == FAIL && !p_im)\n\t\tgoto doESCkey;\t    // out of memory\n\t    auto_format(FALSE, FALSE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_K:\t    // digraph or keyword completion\n\t    if (ctrl_x_mode_dictionary())\n\t    {\n\t\tif (has_compl_option(TRUE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n#ifdef FEAT_DIGRAPHS\n\t    c = ins_digraph();\n\t    if (c == NUL)\n\t\tbreak;\n#endif\n\t    goto normalchar;\n\n\tcase Ctrl_X:\t// Enter CTRL-X mode\n\t    ins_ctrl_x();\n\t    break;\n\n\tcase Ctrl_RSB:\t// Tag name completion after ^X\n\t    if (!ctrl_x_mode_tags())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_F:\t// File name completion after ^X\n\t    if (!ctrl_x_mode_files())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase 's':\t// Spelling completion after ^X\n\tcase Ctrl_S:\n\t    if (!ctrl_x_mode_spell())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_L:\t// Whole line completion after ^X\n\t    if (!ctrl_x_mode_whole_line())\n\t    {\n\t\t// CTRL-L with 'insertmode' set: Leave Insert mode\n\t\tif (p_im)\n\t\t{\n\t\t    if (echeck_abbr(Ctrl_L + ABBR_OFF))\n\t\t\tbreak;\n\t\t    goto doESCkey;\n\t\t}\n\t\tgoto normalchar;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase Ctrl_P:\t// Do previous/next pattern completion\n\tcase Ctrl_N:\n\t    // if 'complete' is empty then plain ^P is no longer special,\n\t    // but it is under other ^X modes\n\t    if (*curbuf->b_p_cpt == NUL\n\t\t    && (ctrl_x_mode_normal() || ctrl_x_mode_whole_line())\n\t\t    && !compl_status_local())\n\t\tgoto normalchar;\n\ndocomplete:\n\t    compl_busy = TRUE;\n#ifdef FEAT_FOLDING\n\t    disable_fold_update++;  // don't redraw folds here\n#endif\n\t    if (ins_complete(c, TRUE) == FAIL)\n\t\tcompl_status_clear();\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    compl_busy = FALSE;\n\t    can_si = may_do_si(); // allow smartindenting\n\t    break;\n\n\tcase Ctrl_Y:\t// copy from previous line or scroll down\n\tcase Ctrl_E:\t// copy from next line\t   or scroll up\n\t    c = ins_ctrl_ey(c);\n\t    break;\n\n\t  default:\n#ifdef UNIX\n\t    if (c == intr_char)\t\t// special interrupt char\n\t\tgoto do_intr;\n#endif\n\nnormalchar:\n\t    /*\n\t     * Insert a normal character.\n\t     */\n#if defined(FEAT_EVAL)\n\t    if (!p_paste)\n\t    {\n\t\t// Trigger InsertCharPre.\n\t\tchar_u *str = do_insert_char_pre(c);\n\t\tchar_u *p;\n\n\t\tif (str != NULL)\n\t\t{\n\t\t    if (*str != NUL && stop_arrow() != FAIL)\n\t\t    {\n\t\t\t// Insert the new value of v:char literally.\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t{\n\t\t\t    c = PTR2CHAR(p);\n\t\t\t    if (c == CAR || c == K_KENTER || c == NL)\n\t\t\t\tins_eol(c);\n\t\t\t    else\n\t\t\t\tins_char(c);\n\t\t\t}\n\t\t\tAppendToRedobuffLit(str, -1);\n\t\t    }\n\t\t    vim_free(str);\n\t\t    c = NUL;\n\t\t}\n\n\t\t// If the new value is already inserted or an empty string\n\t\t// then don't insert any character.\n\t\tif (c == NUL)\n\t\t    break;\n\t    }\n#endif\n\t    // Try to perform smart-indenting.\n\t    ins_try_si(c);\n\n\t    if (c == ' ')\n\t    {\n\t\tinserted_space = TRUE;\n\t\tif (inindent(0))\n\t\t    can_cindent = FALSE;\n\t\tif (Insstart_blank_vcol == MAXCOL\n\t\t\t&& curwin->w_cursor.lnum == Insstart.lnum)\n\t\t    Insstart_blank_vcol = get_nolist_virtcol();\n\t    }\n\n\t    // Insert a normal character and check for abbreviations on a\n\t    // special character.  Let CTRL-] expand abbreviations without\n\t    // inserting it.\n\t    if (vim_iswordc(c) || (!echeck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t\t&& c != Ctrl_RSB))\n\t    {\n\t\tinsert_special(c, FALSE, FALSE);\n#ifdef FEAT_RIGHTLEFT\n\t\trevins_legal++;\n\t\trevins_chars++;\n#endif\n\t    }\n\n\t    auto_format(FALSE, TRUE);\n\n#ifdef FEAT_FOLDING\n\t    // When inserting a character the cursor line must never be in a\n\t    // closed fold.\n\t    foldOpenCursor();\n#endif\n\t    break;\n\t}   // end of switch (c)\n\n\t// If typed something may trigger CursorHoldI again.\n\tif (c != K_CURSORHOLD\n#ifdef FEAT_COMPL_FUNC\n\t\t// but not in CTRL-X mode, a script can't restore the state\n\t\t&& ctrl_x_mode_normal()\n#endif\n\t       )\n\t    did_cursorhold = FALSE;\n\n\t// If the cursor was moved we didn't just insert a space\n\tif (arrow_used)\n\t    inserted_space = FALSE;\n\n\tif (can_cindent && cindent_on() && ctrl_x_mode_normal())\n\t{\nforce_cindent:\n\t    /*\n\t     * Indent now if a key was typed that is in 'cinkeys'.\n\t     */\n\t    if (in_cinkeys(c, ' ', line_is_white))\n\t    {\n\t\tif (stop_arrow() == OK)\n\t\t    // re-indent the current line\n\t\t    do_c_expr_indent();\n\t    }\n\t}\n\n    }\t// for (;;)\n    // NOTREACHED\n}\n\n    int\nins_need_undo_get(void)\n{\n    return ins_need_undo;\n}\n\n/*\n * Redraw for Insert mode.\n * This is postponed until getting the next character to make '$' in the 'cpo'\n * option work correctly.\n * Only redraw when there are no characters available.  This speeds up\n * inserting sequences of characters (e.g., for CTRL-R).\n */\n    void\nins_redraw(int ready)\t    // not busy with something\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\tconceal_old_cursor_line = 0;\n    linenr_T\tconceal_new_cursor_line = 0;\n    int\t\tconceal_update_lines = FALSE;\n#endif\n\n    if (char_avail())\n\treturn;\n\n    // Trigger CursorMoved if the cursor moved.  Not when the popup menu is\n    // visible, the command might delete it.\n    if (ready && (has_cursormovedI()\n# ifdef FEAT_PROP_POPUP\n\t\t|| popup_visible\n# endif\n# if defined(FEAT_CONCEAL)\n\t\t|| curwin->w_p_cole > 0\n# endif\n\t\t)\n\t    && !EQUAL_POS(last_cursormoved, curwin->w_cursor)\n\t    && !pum_visible())\n    {\n# ifdef FEAT_SYN_HL\n\t// Need to update the screen first, to make sure syntax\n\t// highlighting is correct after making a change (e.g., inserting\n\t// a \"(\".  The autocommand may also require a redraw, so it's done\n\t// again below, unfortunately.\n\tif (syntax_present(curwin) && must_redraw)\n\t    update_screen(0);\n# endif\n\tif (has_cursormovedI())\n\t{\n\t    // Make sure curswant is correct, an autocommand may call\n\t    // getcurpos().\n\t    update_curswant();\n\t    ins_apply_autocmds(EVENT_CURSORMOVEDI);\n\t}\n#ifdef FEAT_PROP_POPUP\n\tif (popup_visible)\n\t    popup_check_cursor_pos();\n#endif\n# ifdef FEAT_CONCEAL\n\tif (curwin->w_p_cole > 0)\n\t{\n\t    conceal_old_cursor_line = last_cursormoved.lnum;\n\t    conceal_new_cursor_line = curwin->w_cursor.lnum;\n\t    conceal_update_lines = TRUE;\n\t}\n# endif\n\tlast_cursormoved = curwin->w_cursor;\n    }\n\n    // Trigger TextChangedI if b_changedtick_i differs.\n    if (ready && has_textchangedI()\n\t    && curbuf->b_last_changedtick_i != CHANGEDTICK(curbuf)\n\t    && !pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    // Trigger TextChangedP if b_changedtick_pum differs. When the popupmenu\n    // closes TextChangedI will need to trigger for backwards compatibility,\n    // thus use different b_last_changedtick* variables.\n    if (ready && has_textchangedP()\n\t    && curbuf->b_last_changedtick_pum != CHANGEDTICK(curbuf)\n\t    && pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDP, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    if (ready)\n\tmay_trigger_winscrolled();\n\n    // Trigger SafeState if nothing is pending.\n    may_trigger_safestate(ready\n\t    && !ins_compl_active()\n\t    && !pum_visible());\n\n#if defined(FEAT_CONCEAL)\n    if ((conceal_update_lines\n\t    && (conceal_old_cursor_line != conceal_new_cursor_line\n\t\t|| conceal_cursor_line(curwin)))\n\t    || need_cursor_line_redraw)\n    {\n\tif (conceal_old_cursor_line != conceal_new_cursor_line)\n\t    redrawWinline(curwin, conceal_old_cursor_line);\n\tredrawWinline(curwin, conceal_new_cursor_line == 0\n\t\t\t    ? curwin->w_cursor.lnum : conceal_new_cursor_line);\n\tcurwin->w_valid &= ~VALID_CROW;\n\tneed_cursor_line_redraw = FALSE;\n    }\n#endif\n    if (must_redraw)\n\tupdate_screen(0);\n    else if (clear_cmdline || redraw_cmdline)\n\tshowmode();\t\t// clear cmdline and show mode\n    showruler(FALSE);\n    setcursor();\n    emsg_on_display = FALSE;\t// may remove error message now\n}\n\n/*\n * Handle a CTRL-V or CTRL-Q typed in Insert mode.\n */\n    static void\nins_ctrl_v(void)\n{\n    int\t\tc;\n    int\t\tdid_putchar = FALSE;\n\n    // may need to redraw when no more chars available now\n    ins_redraw(FALSE);\n\n    if (redrawing() && !char_avail())\n    {\n\tedit_putchar('^', TRUE);\n\tdid_putchar = TRUE;\n    }\n    AppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\n#ifdef FEAT_CMDL_INFO\n    add_to_showcmd_c(Ctrl_V);\n#endif\n\n    // Do not change any modifyOtherKeys ESC sequence to a normal key for\n    // CTRL-SHIFT-V.\n    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n    if (did_putchar)\n\t// when the line fits in 'columns' the '^' is at the start of the next\n\t// line and will not removed by the redraw\n\tedit_unputchar();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    insert_special(c, FALSE, TRUE);\n#ifdef FEAT_RIGHTLEFT\n    revins_chars++;\n    revins_legal++;\n#endif\n}\n\n/*\n * After getting an ESC or CSI for a literal key: If the typeahead buffer\n * contains a modifyOtherKeys sequence then decode it and return the result.\n * Otherwise return \"c\".\n * Note that this doesn't wait for characters, they must be in the typeahead\n * buffer already.\n */\n    static int\ndecodeModifyOtherKeys(int c)\n{\n    char_u  *p = typebuf.tb_buf + typebuf.tb_off;\n    int\t    idx;\n    int\t    form = 0;\n    int\t    argidx = 0;\n    int\t    arg[2] = {0, 0};\n\n    // Recognize:\n    // form 0: {lead}{key};{modifier}u\n    // form 1: {lead}27;{modifier};{key}~\n    if (typebuf.tb_len >= 4 && (c == CSI || (c == ESC && *p == '[')))\n    {\n\tidx = (*p == '[');\n\tif (p[idx] == '2' && p[idx + 1] == '7' && p[idx + 2] == ';')\n\t{\n\t    form = 1;\n\t    idx += 3;\n\t}\n\twhile (idx < typebuf.tb_len && argidx < 2)\n\t{\n\t    if (p[idx] == ';')\n\t\t++argidx;\n\t    else if (VIM_ISDIGIT(p[idx]))\n\t\targ[argidx] = arg[argidx] * 10 + (p[idx] - '0');\n\t    else\n\t\tbreak;\n\t    ++idx;\n\t}\n\tif (idx < typebuf.tb_len\n\t\t&& p[idx] == (form == 1 ? '~' : 'u')\n\t\t&& argidx == 1)\n\t{\n\t    // Match, consume the code.\n\t    typebuf.tb_off += idx + 1;\n\t    typebuf.tb_len -= idx + 1;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    if (typebuf.tb_len == 0)\n\t\ttypebuf_was_filled = FALSE;\n#endif\n\n\t    mod_mask = decode_modifiers(arg[!form]);\n\t    c = merge_modifyOtherKeys(arg[form], &mod_mask);\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Put a character directly onto the screen.  It's not stored in a buffer.\n * Used while handling CTRL-K, CTRL-V, etc. in Insert mode.\n */\nstatic int  pc_status;\n#define PC_STATUS_UNSET\t0\t// pc_bytes was not set\n#define PC_STATUS_RIGHT\t1\t// right half of double-wide char\n#define PC_STATUS_LEFT\t2\t// left half of double-wide char\n#define PC_STATUS_SET\t3\t// pc_bytes was filled\nstatic char_u pc_bytes[MB_MAXBYTES + 1]; // saved bytes\nstatic int  pc_attr;\nstatic int  pc_row;\nstatic int  pc_col;\n\n    void\nedit_putchar(int c, int highlight)\n{\n    int\t    attr;\n\n    if (ScreenLines != NULL)\n    {\n\tupdate_topline();\t// just in case w_topline isn't valid\n\tvalidate_cursor();\n\tif (highlight)\n\t    attr = HL_ATTR(HLF_8);\n\telse\n\t    attr = 0;\n\tpc_row = W_WINROW(curwin) + curwin->w_wrow;\n\tpc_col = curwin->w_wincol;\n\tpc_status = PC_STATUS_UNSET;\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t{\n\t    pc_col += curwin->w_width - 1 - curwin->w_wcol;\n\t    if (has_mbyte)\n\t    {\n\t\tint fix_col = mb_fix_col(pc_col, pc_row);\n\n\t\tif (fix_col != pc_col)\n\t\t{\n\t\t    screen_putchar(' ', pc_row, fix_col, attr);\n\t\t    --curwin->w_wcol;\n\t\t    pc_status = PC_STATUS_RIGHT;\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    pc_col += curwin->w_wcol;\n\t    if (mb_lefthalve(pc_row, pc_col))\n\t\tpc_status = PC_STATUS_LEFT;\n\t}\n\n\t// save the character to be able to put it back\n\tif (pc_status == PC_STATUS_UNSET)\n\t{\n\t    screen_getbytes(pc_row, pc_col, pc_bytes, &pc_attr);\n\t    pc_status = PC_STATUS_SET;\n\t}\n\tscreen_putchar(c, pc_row, pc_col, attr);\n    }\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Set the insert start position for when using a prompt buffer.\n */\n    void\nset_insstart(linenr_T lnum, int col)\n{\n    Insstart.lnum = lnum;\n    Insstart.col = col;\n    Insstart_orig = Insstart;\n    Insstart_textlen = Insstart.col;\n    Insstart_blank_vcol = MAXCOL;\n    arrow_used = FALSE;\n}\n#endif\n\n/*\n * Undo the previous edit_putchar().\n */\n    void\nedit_unputchar(void)\n{\n    if (pc_status != PC_STATUS_UNSET && pc_row >= msg_scrolled)\n    {\n\tif (pc_status == PC_STATUS_RIGHT)\n\t    ++curwin->w_wcol;\n\tif (pc_status == PC_STATUS_RIGHT || pc_status == PC_STATUS_LEFT)\n\t    redrawWinline(curwin, curwin->w_cursor.lnum);\n\telse\n\t    screen_puts(pc_bytes, pc_row - msg_scrolled, pc_col, pc_attr);\n    }\n}\n\n/*\n * Called when p_dollar is set: display a '$' at the end of the changed text\n * Only works when cursor is in the line that changes.\n */\n    void\ndisplay_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}\n\n/*\n * Call this function before moving the cursor from the normal insert position\n * in insert mode.\n */\n    void\nundisplay_dollar(void)\n{\n    if (dollar_vcol >= 0)\n    {\n\tdollar_vcol = -1;\n\tredrawWinline(curwin, curwin->w_cursor.lnum);\n    }\n}\n\n/*\n * Truncate the space at the end of a line.  This is to be used only in an\n * insert mode.  It handles fixing the replace stack for MODE_REPLACE and\n * MODE_VREPLACE modes.\n */\n    void\ntruncate_spaces(char_u *line)\n{\n    int\t    i;\n\n    // find start of trailing white space\n    for (i = (int)STRLEN(line) - 1; i >= 0 && VIM_ISWHITE(line[i]); i--)\n    {\n\tif (State & REPLACE_FLAG)\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n    }\n    line[i + 1] = NUL;\n}\n\n/*\n * Backspace the cursor until the given column.  Handles MODE_REPLACE and\n * MODE_VREPLACE modes correctly.  May also be used when not in insert mode at\n * all.  Will attempt not to go before \"col\" even when there is a composing\n * character.\n */\n    void\nbackspace_until_column(int col)\n{\n    while ((int)curwin->w_cursor.col > col)\n    {\n\tcurwin->w_cursor.col--;\n\tif (State & REPLACE_FLAG)\n\t    replace_do_bs(col);\n\telse if (!del_char_after_col(col))\n\t    break;\n    }\n}\n\n/*\n * Like del_char(), but make sure not to go before column \"limit_col\".\n * Only matters when there are composing characters.\n * Return TRUE when something was deleted.\n */\n   static int\ndel_char_after_col(int limit_col UNUSED)\n{\n    if (enc_utf8 && limit_col >= 0)\n    {\n\tcolnr_T ecol = curwin->w_cursor.col + 1;\n\n\t// Make sure the cursor is at the start of a character, but\n\t// skip forward again when going too far back because of a\n\t// composing character.\n\tmb_adjust_cursor();\n\twhile (curwin->w_cursor.col < (colnr_T)limit_col)\n\t{\n\t    int l = utf_ptr2len(ml_get_cursor());\n\n\t    if (l == 0)  // end of line\n\t\tbreak;\n\t    curwin->w_cursor.col += l;\n\t}\n\tif (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)\n\t    return FALSE;\n\tdel_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);\n    }\n    else\n\t(void)del_char(FALSE);\n    return TRUE;\n}\n\n/*\n * Next character is interpreted literally.\n * A one, two or three digit decimal number is interpreted as its byte value.\n * If one or two digits are entered, the next character is given to vungetc().\n * For Unicode a character > 255 may be returned.\n * If \"noReduceKeys\" is TRUE do not change any modifyOtherKeys ESC sequence\n * into a normal key, return ESC.\n */\n    int\nget_literal(int noReduceKeys)\n{\n    int\t\tcc;\n    int\t\tnc;\n    int\t\ti;\n    int\t\thex = FALSE;\n    int\t\toctal = FALSE;\n    int\t\tunicode = 0;\n\n    if (got_int)\n\treturn Ctrl_C;\n\n#ifdef FEAT_GUI\n    /*\n     * In GUI there is no point inserting the internal code for a special key.\n     * It is more useful to insert the string \"<KEY>\" instead.\tThis would\n     * probably be useful in a text window too, but it would not be\n     * vi-compatible (maybe there should be an option for it?) -- webb\n     */\n    if (gui.in_use)\n    {\n\t++allow_keys;\n\tif (noReduceKeys)\n\t    ++no_reduce_keys;\n    }\n#endif\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    ++no_mapping;\t\t// don't map the next key hits\n    cc = 0;\n    i = 0;\n    for (;;)\n    {\n\tnc = plain_vgetc();\n\tif ((nc == ESC || nc == CSI) && !noReduceKeys)\n\t    nc = decodeModifyOtherKeys(nc);\n\n\tif ((mod_mask & ~MOD_MASK_SHIFT) != 0)\n\t    // A character with non-Shift modifiers should not be a valid\n\t    // character for i_CTRL-V_digit.\n\t    break;\n\n#ifdef FEAT_CMDL_INFO\n\tif ((State & MODE_CMDLINE) == 0 && MB_BYTE2LEN_CHECK(nc) == 1)\n\t    add_to_showcmd(nc);\n#endif\n\tif (nc == 'x' || nc == 'X')\n\t    hex = TRUE;\n\telse if (nc == 'o' || nc == 'O')\n\t    octal = TRUE;\n\telse if (nc == 'u' || nc == 'U')\n\t    unicode = nc;\n\telse\n\t{\n\t    if (hex || unicode != 0)\n\t    {\n\t\tif (!vim_isxdigit(nc))\n\t\t    break;\n\t\tcc = cc * 16 + hex2nr(nc);\n\t    }\n\t    else if (octal)\n\t    {\n\t\tif (nc < '0' || nc > '7')\n\t\t    break;\n\t\tcc = cc * 8 + nc - '0';\n\t    }\n\t    else\n\t    {\n\t\tif (!VIM_ISDIGIT(nc))\n\t\t    break;\n\t\tcc = cc * 10 + nc - '0';\n\t    }\n\n\t    ++i;\n\t}\n\n\tif (cc > 255 && unicode == 0)\n\t    cc = 255;\t\t// limit range to 0-255\n\tnc = 0;\n\n\tif (hex)\t\t// hex: up to two chars\n\t{\n\t    if (i >= 2)\n\t\tbreak;\n\t}\n\telse if (unicode)\t// Unicode: up to four or eight chars\n\t{\n\t    if ((unicode == 'u' && i >= 4) || (unicode == 'U' && i >= 8))\n\t\tbreak;\n\t}\n\telse if (i >= 3)\t// decimal or octal: up to three chars\n\t    break;\n    }\n    if (i == 0)\t    // no number entered\n    {\n\tif (nc == K_ZERO)   // NUL is stored as NL\n\t{\n\t    cc = '\\n';\n\t    nc = 0;\n\t}\n\telse\n\t{\n\t    cc = nc;\n\t    nc = 0;\n\t}\n    }\n\n    if (cc == 0)\t// NUL is stored as NL\n\tcc = '\\n';\n    if (enc_dbcs && (cc & 0xff) == 0)\n\tcc = '?';\t// don't accept an illegal DBCS char, the NUL in the\n\t\t\t// second byte will cause trouble!\n\n    --no_mapping;\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\t--allow_keys;\n\tif (noReduceKeys)\n\t    --no_reduce_keys;\n    }\n#endif\n    if (nc)\n    {\n\tvungetc(nc);\n\t// A character typed with i_CTRL-V_digit cannot have modifiers.\n\tmod_mask = 0;\n    }\n    got_int = FALSE;\t    // CTRL-C typed after CTRL-V is not an interrupt\n    return cc;\n}\n\n/*\n * Insert character, taking care of special keys and mod_mask\n */\n    static void\ninsert_special(\n    int\t    c,\n    int\t    allow_modmask,\n    int\t    ctrlv)\t    // c was typed after CTRL-V\n{\n    char_u  *p;\n    int\t    len;\n\n    /*\n     * Special function key, translate into \"<Key>\". Up to the last '>' is\n     * inserted with ins_str(), so as not to replace characters in replace\n     * mode.\n     * Only use mod_mask for special keys, to avoid things like <S-Space>,\n     * unless 'allow_modmask' is TRUE.\n     */\n#ifdef MACOS_X\n    // Command-key never produces a normal key\n    if (mod_mask & MOD_MASK_CMD)\n\tallow_modmask = TRUE;\n#endif\n    if (IS_SPECIAL(c) || (mod_mask && allow_modmask))\n    {\n\tp = get_special_key_name(c, mod_mask);\n\tlen = (int)STRLEN(p);\n\tc = p[len - 1];\n\tif (len > 2)\n\t{\n\t    if (stop_arrow() == FAIL)\n\t\treturn;\n\t    p[len - 1] = NUL;\n\t    ins_str(p);\n\t    AppendToRedobuffLit(p, -1);\n\t    ctrlv = FALSE;\n\t}\n    }\n    if (stop_arrow() == OK)\n\tinsertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);\n}\n\n/*\n * Special characters in this context are those that need processing other\n * than the simple insertion that can be performed here. This includes ESC\n * which terminates the insert, and CR/NL which need special processing to\n * open up a new line. This routine tries to optimize insertions performed by\n * the \"redo\", \"undo\" or \"put\" commands, so it needs to know when it should\n * stop and defer processing to the \"normal\" mechanism.\n * '0' and '^' are special, because they can be followed by CTRL-D.\n */\n#define ISSPECIAL(c)\t((c) < ' ' || (c) >= DEL || (c) == '0' || (c) == '^')\n\n/*\n * \"flags\": INSCHAR_FORMAT - force formatting\n *\t    INSCHAR_CTRLV  - char typed just after CTRL-V\n *\t    INSCHAR_NO_FEX - don't use 'formatexpr'\n *\n *   NOTE: passes the flags value straight through to internal_format() which,\n *\t   beside INSCHAR_FORMAT (above), is also looking for these:\n *\t    INSCHAR_DO_COM   - format comments\n *\t    INSCHAR_COM_LIST - format comments with num list or 2nd line indent\n */\n    void\ninsertchar(\n    int\t\tc,\t\t\t// character to insert or NUL\n    int\t\tflags,\t\t\t// INSCHAR_FORMAT, etc.\n    int\t\tsecond_indent)\t\t// indent for second line if >= 0\n{\n    int\t\ttextwidth;\n    char_u\t*p;\n    int\t\tfo_ins_blank;\n    int\t\tforce_format = flags & INSCHAR_FORMAT;\n\n    textwidth = comp_textwidth(force_format);\n    fo_ins_blank = has_format_option(FO_INS_BLANK);\n\n    /*\n     * Try to break the line in two or more pieces when:\n     * - Always do this if we have been called to do formatting only.\n     * - Always do this when 'formatoptions' has the 'a' flag and the line\n     *   ends in white space.\n     * - Otherwise:\n     *\t - Don't do this if inserting a blank\n     *\t - Don't do this if an existing character is being replaced, unless\n     *\t   we're in MODE_VREPLACE state.\n     *\t - Do this if the cursor is not on the line where insert started\n     *\t or - 'formatoptions' doesn't have 'l' or the line was not too long\n     *\t       before the insert.\n     *\t    - 'formatoptions' doesn't have 'b' or a blank was inserted at or\n     *\t      before 'textwidth'\n     */\n    if (textwidth > 0\n\t    && (force_format\n\t\t|| (!VIM_ISWHITE(c)\n\t\t    && !((State & REPLACE_FLAG)\n\t\t\t&& !(State & VREPLACE_FLAG)\n\t\t\t&& *ml_get_cursor() != NUL)\n\t\t    && (curwin->w_cursor.lnum != Insstart.lnum\n\t\t\t|| ((!has_format_option(FO_INS_LONG)\n\t\t\t\t|| Insstart_textlen <= (colnr_T)textwidth)\n\t\t\t    && (!fo_ins_blank\n\t\t\t\t|| Insstart_blank_vcol <= (colnr_T)textwidth\n\t\t\t    ))))))\n    {\n\t// Format with 'formatexpr' when it's set.  Use internal formatting\n\t// when 'formatexpr' isn't set or it returns non-zero.\n#if defined(FEAT_EVAL)\n\tint     do_internal = TRUE;\n\tcolnr_T virtcol = get_nolist_virtcol()\n\t\t\t\t  + char2cells(c != NUL ? c : gchar_cursor());\n\n\tif (*curbuf->b_p_fex != NUL && (flags & INSCHAR_NO_FEX) == 0\n\t\t&& (force_format || virtcol > (colnr_T)textwidth))\n\t{\n\t    do_internal = (fex_format(curwin->w_cursor.lnum, 1L, c) != 0);\n\t    // It may be required to save for undo again, e.g. when setline()\n\t    // was called.\n\t    ins_need_undo = TRUE;\n\t}\n\tif (do_internal)\n#endif\n\t    internal_format(textwidth, second_indent, flags, c == NUL, c);\n    }\n\n    if (c == NUL)\t    // only formatting was wanted\n\treturn;\n\n    // Check whether this character should end a comment.\n    if (did_ai && c == end_comment_pending)\n    {\n\tchar_u  *line;\n\tchar_u\tlead_end[COM_MAX_LEN];\t    // end-comment string\n\tint\tmiddle_len, end_len;\n\tint\ti;\n\n\t/*\n\t * Need to remove existing (middle) comment leader and insert end\n\t * comment leader.  First, check what comment leader we can find.\n\t */\n\ti = get_leader_len(line = ml_get_curline(), &p, FALSE, TRUE);\n\tif (i > 0 && vim_strchr(p, COM_MIDDLE) != NULL)\t// Just checking\n\t{\n\t    // Skip middle-comment string\n\t    while (*p && p[-1] != ':')\t// find end of middle flags\n\t\t++p;\n\t    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\t    // Don't count trailing white space for middle_len\n\t    while (middle_len > 0 && VIM_ISWHITE(lead_end[middle_len - 1]))\n\t\t--middle_len;\n\n\t    // Find the end-comment string\n\t    while (*p && p[-1] != ':')\t// find end of end flags\n\t\t++p;\n\t    end_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\n\t    // Skip white space before the cursor\n\t    i = curwin->w_cursor.col;\n\t    while (--i >= 0 && VIM_ISWHITE(line[i]))\n\t\t;\n\t    i++;\n\n\t    // Skip to before the middle leader\n\t    i -= middle_len;\n\n\t    // Check some expected things before we go on\n\t    if (i >= 0 && lead_end[end_len - 1] == end_comment_pending)\n\t    {\n\t\t// Backspace over all the stuff we want to replace\n\t\tbackspace_until_column(i);\n\n\t\t// Insert the end-comment string, except for the last\n\t\t// character, which will get inserted as normal later.\n\t\tins_bytes_len(lead_end, end_len - 1);\n\t    }\n\t}\n    }\n    end_comment_pending = NUL;\n\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n\n    /*\n     * If there's any pending input, grab up to INPUT_BUFLEN at once.\n     * This speeds up normal text input considerably.\n     * Don't do this when 'cindent' or 'indentexpr' is set, because we might\n     * need to re-indent at a ':', or any other character (but not what\n     * 'paste' is set)..\n     * Don't do this when there an InsertCharPre autocommand is defined,\n     * because we need to fire the event for every character.\n     * Do the check for InsertCharPre before the call to vpeekc() because the\n     * InsertCharPre autocommand could change the input buffer.\n     */\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n    if (       !ISSPECIAL(c)\n\t    && (!has_mbyte || (*mb_char2len)(c) == 1)\n\t    && !has_insertcharpre()\n\t    && vpeekc() != NUL\n\t    && !(State & REPLACE_FLAG)\n\t    && !cindent_on()\n#ifdef FEAT_RIGHTLEFT\n\t    && !p_ri\n#endif\n\t   )\n    {\n#define INPUT_BUFLEN 100\n\tchar_u\t\tbuf[INPUT_BUFLEN + 1];\n\tint\t\ti;\n\tcolnr_T\t\tvirtcol = 0;\n\n\tbuf[0] = c;\n\ti = 1;\n\tif (textwidth > 0)\n\t    virtcol = get_nolist_virtcol();\n\t/*\n\t * Stop the string when:\n\t * - no more chars available\n\t * - finding a special character (command key)\n\t * - buffer is full\n\t * - running into the 'textwidth' boundary\n\t * - need to check for abbreviation: A non-word char after a word-char\n\t */\n\twhile (\t   (c = vpeekc()) != NUL\n\t\t&& !ISSPECIAL(c)\n\t\t&& (!has_mbyte || MB_BYTE2LEN_CHECK(c) == 1)\n\t\t&& i < INPUT_BUFLEN\n\t\t&& (textwidth == 0\n\t\t    || (virtcol += byte2cells(buf[i - 1])) < (colnr_T)textwidth)\n\t\t&& !(!no_abbr && !vim_iswordc(c) && vim_iswordc(buf[i - 1])))\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    c = vgetc();\n\t    if (p_hkmap && KeyTyped)\n\t\tc = hkmap(c);\t\t    // Hebrew mode mapping\n\t    buf[i++] = c;\n#else\n\t    buf[i++] = vgetc();\n#endif\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tdo_digraph(-1);\t\t\t// clear digraphs\n\tdo_digraph(buf[i-1]);\t\t// may be the start of a digraph\n#endif\n\tbuf[i] = NUL;\n\tins_str(buf);\n\tif (flags & INSCHAR_CTRLV)\n\t{\n\t    redo_literal(*buf);\n\t    i = 1;\n\t}\n\telse\n\t    i = 0;\n\tif (buf[i] != NUL)\n\t    AppendToRedobuffLit(buf + i, -1);\n    }\n    else\n    {\n\tint\t\tcc;\n\n\tif (has_mbyte && (cc = (*mb_char2len)(c)) > 1)\n\t{\n\t    char_u\tbuf[MB_MAXBYTES + 1];\n\n\t    (*mb_char2bytes)(c, buf);\n\t    buf[cc] = NUL;\n\t    ins_char_bytes(buf, cc);\n\t    AppendCharToRedobuff(c);\n\t}\n\telse\n\t{\n\t    ins_char(c);\n\t    if (flags & INSCHAR_CTRLV)\n\t\tredo_literal(c);\n\t    else\n\t\tAppendCharToRedobuff(c);\n\t}\n    }\n}\n\n/*\n * Put a character in the redo buffer, for when just after a CTRL-V.\n */\n    static void\nredo_literal(int c)\n{\n    char_u\tbuf[10];\n\n    // Only digits need special treatment.  Translate them into a string of\n    // three digits.\n    if (VIM_ISDIGIT(c))\n    {\n\tvim_snprintf((char *)buf, sizeof(buf), \"%03d\", c);\n\tAppendToRedobuff(buf);\n    }\n    else\n\tAppendCharToRedobuff(c);\n}\n\n/*\n * start_arrow() is called when an arrow key is used in insert mode.\n * For undo/redo it resembles hitting the <ESC> key.\n */\n    void\nstart_arrow(\n    pos_T    *end_insert_pos)\t\t// can be NULL\n{\n    start_arrow_common(end_insert_pos, TRUE);\n}\n\n/*\n * Like start_arrow() but with end_change argument.\n * Will prepare for redo of CTRL-G U if \"end_change\" is FALSE.\n */\n    static void\nstart_arrow_with_change(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    start_arrow_common(end_insert_pos, end_change);\n    if (!end_change)\n    {\n\tAppendCharToRedobuff(Ctrl_G);\n\tAppendCharToRedobuff('U');\n    }\n}\n\n    static void\nstart_arrow_common(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    if (!arrow_used && end_change)\t// something has been inserted\n    {\n\tAppendToRedobuff(ESC_STR);\n\tstop_insert(end_insert_pos, FALSE, FALSE);\n\tarrow_used = TRUE;\t// this means we stopped the current insert\n    }\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n}\n\n#ifdef FEAT_SPELL\n/*\n * If we skipped highlighting word at cursor, do it now.\n * It may be skipped again, thus reset spell_redraw_lnum first.\n */\n    static void\ncheck_spell_redraw(void)\n{\n    if (spell_redraw_lnum != 0)\n    {\n\tlinenr_T\tlnum = spell_redraw_lnum;\n\n\tspell_redraw_lnum = 0;\n\tredrawWinline(curwin, lnum);\n    }\n}\n\n#endif\n\n/*\n * stop_arrow() is called before a change is made in insert mode.\n * If an arrow key has been used, start a new insertion.\n * Returns FAIL if undo is impossible, shouldn't insert then.\n */\n    int\nstop_arrow(void)\n{\n    if (arrow_used)\n    {\n\tInsstart = curwin->w_cursor;\t// new insertion starts here\n\tif (Insstart.col > Insstart_orig.col && !ins_need_undo)\n\t    // Don't update the original insert position when moved to the\n\t    // right, except when nothing was inserted yet.\n\t    update_Insstart_orig = FALSE;\n\tInsstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n\n\tif (u_save_cursor() == OK)\n\t{\n\t    arrow_used = FALSE;\n\t    ins_need_undo = FALSE;\n\t}\n\n\tai_col = 0;\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    orig_line_count = curbuf->b_ml.ml_line_count;\n\t    vr_lines_changed = 1;\n\t}\n\tResetRedobuff();\n\tAppendToRedobuff((char_u *)\"1i\");   // pretend we start an insertion\n\tnew_insert_skip = 2;\n    }\n    else if (ins_need_undo)\n    {\n\tif (u_save_cursor() == OK)\n\t    ins_need_undo = FALSE;\n    }\n\n#ifdef FEAT_FOLDING\n    // Always open fold at the cursor line when inserting something.\n    foldOpenCursor();\n#endif\n\n    return (arrow_used || ins_need_undo ? FAIL : OK);\n}\n\n/*\n * Do a few things to stop inserting.\n * \"end_insert_pos\" is where insert ended.  It is NULL when we already jumped\n * to another window/buffer.\n */\n    static void\nstop_insert(\n    pos_T\t*end_insert_pos,\n    int\t\tesc,\t\t\t// called by ins_esc()\n    int\t\tnomove)\t\t\t// <c-\\><c-o>, don't move cursor\n{\n    int\t\tcc;\n    char_u\t*ptr;\n\n    stop_redo_ins();\n    replace_flush();\t\t// abandon replace stack\n\n    /*\n     * Save the inserted text for later redo with ^@ and CTRL-A.\n     * Don't do it when \"restart_edit\" was set and nothing was inserted,\n     * otherwise CTRL-O w and then <Left> will clear \"last_insert\".\n     */\n    ptr = get_inserted();\n    if (did_restart_edit == 0 || (ptr != NULL\n\t\t\t\t       && (int)STRLEN(ptr) > new_insert_skip))\n    {\n\tvim_free(last_insert);\n\tlast_insert = ptr;\n\tlast_insert_skip = new_insert_skip;\n    }\n    else\n\tvim_free(ptr);\n\n    if (!arrow_used && end_insert_pos != NULL)\n    {\n\t// Auto-format now.  It may seem strange to do this when stopping an\n\t// insertion (or moving the cursor), but it's required when appending\n\t// a line and having it end in a space.  But only do it when something\n\t// was actually inserted, otherwise undo won't work.\n\tif (!ins_need_undo && has_format_option(FO_AUTO))\n\t{\n\t    pos_T   tpos = curwin->w_cursor;\n\n\t    // When the cursor is at the end of the line after a space the\n\t    // formatting will move it to the following word.  Avoid that by\n\t    // moving the cursor onto the space.\n\t    cc = 'x';\n\t    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL)\n\t    {\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    curwin->w_cursor = tpos;\n\t    }\n\n\t    auto_format(TRUE, FALSE);\n\n\t    if (VIM_ISWHITE(cc))\n\t    {\n\t\tif (gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t\t// If the cursor is still at the same character, also keep\n\t\t// the \"coladd\".\n\t\tif (gchar_cursor() == NUL\n\t\t\t&& curwin->w_cursor.lnum == tpos.lnum\n\t\t\t&& curwin->w_cursor.col == tpos.col)\n\t\t    curwin->w_cursor.coladd = tpos.coladd;\n\t    }\n\t}\n\n\t// If a space was inserted for auto-formatting, remove it now.\n\tcheck_auto_format(TRUE);\n\n\t// If we just did an auto-indent, remove the white space from the end\n\t// of the line, and put the cursor back.\n\t// Do this when ESC was used or moving the cursor up/down.\n\t// Check for the old position still being valid, just in case the text\n\t// got changed unexpectedly.\n\tif (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL\n\t\t\t&& curwin->w_cursor.lnum != end_insert_pos->lnum))\n\t\t&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    pos_T\ttpos = curwin->w_cursor;\n\n\t    curwin->w_cursor = *end_insert_pos;\n\t    check_cursor_col();  // make sure it is not past the line\n\t    for (;;)\n\t    {\n\t\tif (gchar_cursor() == NUL && curwin->w_cursor.col > 0)\n\t\t    --curwin->w_cursor.col;\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    break;\n\t\tif (del_char(TRUE) == FAIL)\n\t\t    break;  // should not happen\n\t    }\n\t    if (curwin->w_cursor.lnum != tpos.lnum)\n\t\tcurwin->w_cursor = tpos;\n\t    else\n\t    {\n\t\t// reset tpos, could have been invalidated in the loop above\n\t\ttpos = curwin->w_cursor;\n\t\ttpos.col++;\n\t\tif (cc != NUL && gchar_pos(&tpos) == NUL)\n\t\t    ++curwin->w_cursor.col;\t// put cursor back on the NUL\n\t    }\n\n\t    // <C-S-Right> may have started Visual mode, adjust the position for\n\t    // deleted characters.\n\t    if (VIsual_active)\n\t\tcheck_visual_pos();\n\t}\n    }\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n\n    // Set '[ and '] to the inserted text.  When end_insert_pos is NULL we are\n    // now in a different buffer.\n    if (end_insert_pos != NULL)\n    {\n\tcurbuf->b_op_start = Insstart;\n\tcurbuf->b_op_start_orig = Insstart_orig;\n\tcurbuf->b_op_end = *end_insert_pos;\n    }\n}\n\n/*\n * Set the last inserted text to a single character.\n * Used for the replace command.\n */\n    void\nset_last_insert(int c)\n{\n    char_u\t*s;\n\n    vim_free(last_insert);\n    last_insert = alloc(MB_MAXBYTES * 3 + 5);\n    if (last_insert != NULL)\n    {\n\ts = last_insert;\n\t// Use the CTRL-V only when entering a special char\n\tif (c < ' ' || c == DEL)\n\t    *s++ = Ctrl_V;\n\ts = add_char2buf(c, s);\n\t*s++ = ESC;\n\t*s++ = NUL;\n\tlast_insert_skip = 0;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_last_insert(void)\n{\n    VIM_CLEAR(last_insert);\n}\n#endif\n\n/*\n * Add character \"c\" to buffer \"s\".  Escape the special meaning of K_SPECIAL\n * and CSI.  Handle multi-byte characters.\n * Returns a pointer to after the added bytes.\n */\n    char_u *\nadd_char2buf(int c, char_u *s)\n{\n    char_u\ttemp[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tlen;\n\n    len = (*mb_char2bytes)(c, temp);\n    for (i = 0; i < len; ++i)\n    {\n\tc = temp[i];\n\t// Need to escape K_SPECIAL and CSI like in the typeahead buffer.\n\tif (c == K_SPECIAL)\n\t{\n\t    *s++ = K_SPECIAL;\n\t    *s++ = KS_SPECIAL;\n\t    *s++ = KE_FILLER;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    *s++ = CSI;\n\t    *s++ = KS_EXTRA;\n\t    *s++ = (int)KE_CSI;\n\t}\n#endif\n\telse\n\t    *s++ = c;\n    }\n    return s;\n}\n\n/*\n * move cursor to start of line\n * if flags & BL_WHITE\tmove to first non-white\n * if flags & BL_SOL\tmove to first non-white if startofline is set,\n *\t\t\t    otherwise keep \"curswant\" column\n * if flags & BL_FIX\tdon't leave the cursor on a NUL.\n */\n    void\nbeginline(int flags)\n{\n    if ((flags & BL_SOL) && !p_sol)\n\tcoladvance(curwin->w_curswant);\n    else\n    {\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n\n\tif (flags & (BL_WHITE | BL_SOL))\n\t{\n\t    char_u  *ptr;\n\n\t    for (ptr = ml_get_curline(); VIM_ISWHITE(*ptr)\n\t\t\t       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)\n\t\t++curwin->w_cursor.col;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * oneright oneleft cursor_down cursor_up\n *\n * Move one char {right,left,down,up}.\n * Doesn't move onto the NUL past the end of the line, unless it is allowed.\n * Return OK when successful, FAIL when we hit a line of file boundary.\n */\n\n    int\noneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\n\t// Adjust for multi-wide char (excluding TAB)\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\t// Return OK if the cursor moved, FAIL otherwise (at window edge).\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    // already at the very end\n\n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n\n    // move \"l\" bytes right, but don't end up on the NUL, unless 'virtualedit'\n    // contains \"onemore\".\n    if (ptr[l] == NUL && (get_ve_flags() & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}\n\n    int\noneleft(void)\n{\n    if (virtual_active())\n    {\n#ifdef FEAT_LINEBREAK\n\tint width;\n#endif\n\tint v = getviscol();\n\n\tif (v == 0)\n\t    return FAIL;\n\n#ifdef FEAT_LINEBREAK\n\t// We might get stuck on 'showbreak', skip over it.\n\twidth = 1;\n\tfor (;;)\n\t{\n\t    coladvance(v - width);\n\t    // getviscol() is slow, skip it when 'showbreak' is empty,\n\t    // 'breakindent' is not set and there are no multi-byte\n\t    // characters\n\t    if ((*get_showbreak_value(curwin) == NUL && !curwin->w_p_bri\n\t\t\t\t\t     && !has_mbyte) || getviscol() < v)\n\t\tbreak;\n\t    ++width;\n\t}\n#else\n\tcoladvance(v - 1);\n#endif\n\n\tif (curwin->w_cursor.coladd == 1)\n\t{\n\t    char_u *ptr;\n\n\t    // Adjust for multi-wide char (not a TAB)\n\t    ptr = ml_get_cursor();\n\t    if (*ptr != TAB && vim_isprintc((*mb_ptr2char)(ptr))\n\t\t\t\t\t\t\t && ptr2cells(ptr) > 1)\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\n\tcurwin->w_set_curswant = TRUE;\n\treturn OK;\n    }\n\n    if (curwin->w_cursor.col == 0)\n\treturn FAIL;\n\n    curwin->w_set_curswant = TRUE;\n    --curwin->w_cursor.col;\n\n    // if the character on the left of the current cursor is a multi-byte\n    // character, move to its first byte\n    if (has_mbyte)\n\tmb_adjust_cursor();\n    return OK;\n}\n\n    int\ncursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\t// This fails if the cursor is already in the first line or the count\n\t// is larger than the line number and '-' is in 'cpoptions'\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    /*\n\t     * Count each sequence of folded lines as one logical line.\n\t     */\n\t    // go to the start of the current fold\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\n\t    while (n--)\n\t    {\n\t\t// move up one line\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\t// If we entered a fold, move to the beginning, unless in\n\t\t// Insert mode or when 'foldopen' contains \"all\": it will open\n\t\t// in a moment.\n\t\tif (n > 0 || !((State & MODE_INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Cursor down a number of logical lines.\n */\n    int\ncursor_down(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Move to last line of fold, will fail if it's the end-of-file.\n\t(void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t// This fails if the cursor is already in the last line or would move\n\t// beyond the last line and '-' is in 'cpoptions'\n\tif (lnum >= curbuf->b_ml.ml_line_count\n\t\t|| (lnum + n > curbuf->b_ml.ml_line_count\n\t\t    && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (lnum + n >= curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count;\n\telse\n#ifdef FEAT_FOLDING\n\tif (hasAnyFolding(curwin))\n\t{\n\t    linenr_T\tlast;\n\n\t    // count each sequence of folded lines as one logical line\n\t    while (n--)\n\t    {\n\t\tif (hasFolding(lnum, NULL, &last))\n\t\t    lnum = last + 1;\n\t\telse\n\t\t    ++lnum;\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t    }\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t}\n\telse\n#endif\n\t    lnum += n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Stuff the last inserted text in the read buffer.\n * Last_insert actually is a copy of the redo buffer, so we\n * first have to remove the command.\n */\n    int\nstuff_inserted(\n    int\t    c,\t\t// Command character to be inserted\n    long    count,\t// Repeat this many times\n    int\t    no_esc)\t// Don't add an ESC at the end\n{\n    char_u\t*esc_ptr;\n    char_u\t*ptr;\n    char_u\t*last_ptr;\n    char_u\tlast = NUL;\n\n    ptr = get_last_insert();\n    if (ptr == NULL)\n    {\n\temsg(_(e_no_inserted_text_yet));\n\treturn FAIL;\n    }\n\n    // may want to stuff the command character, to start Insert mode\n    if (c != NUL)\n\tstuffcharReadbuff(c);\n    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)\n\t*esc_ptr = NUL;\t    // remove the ESC\n\n    // when the last char is either \"0\" or \"^\" it will be quoted if no ESC\n    // comes after it OR if it will inserted more than once and \"ptr\"\n    // starts with ^D.\t-- Acevedo\n    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;\n    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')\n\t    && (no_esc || (*ptr == Ctrl_D && count > 1)))\n    {\n\tlast = *last_ptr;\n\t*last_ptr = NUL;\n    }\n\n    do\n    {\n\tstuffReadbuff(ptr);\n\t// a trailing \"0\" is inserted as \"<C-V>048\", \"^\" as \"<C-V>^\"\n\tif (last)\n\t    stuffReadbuff(\n\t\t       (char_u *)(last == '0' ? \"\\026\\060\\064\\070\" : \"\\026^\"));\n    }\n    while (--count > 0);\n\n    if (last)\n\t*last_ptr = last;\n\n    if (esc_ptr != NULL)\n\t*esc_ptr = ESC;\t    // put the ESC back\n\n    // may want to stuff a trailing ESC, to get out of Insert mode\n    if (!no_esc)\n\tstuffcharReadbuff(ESC);\n\n    return OK;\n}\n\n    char_u *\nget_last_insert(void)\n{\n    if (last_insert == NULL)\n\treturn NULL;\n    return last_insert + last_insert_skip;\n}\n\n/*\n * Get last inserted string, and remove trailing <Esc>.\n * Returns pointer to allocated memory (must be freed) or NULL.\n */\n    char_u *\nget_last_insert_save(void)\n{\n    char_u\t*s;\n    int\t\tlen;\n\n    if (last_insert == NULL)\n\treturn NULL;\n    s = vim_strsave(last_insert + last_insert_skip);\n    if (s != NULL)\n    {\n\tlen = (int)STRLEN(s);\n\tif (len > 0 && s[len - 1] == ESC)\t// remove trailing ESC\n\t    s[len - 1] = NUL;\n    }\n    return s;\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text and\n * the replacement string is inserted in typebuf.tb_buf[], followed by \"c\".\n */\n    static int\necheck_abbr(int c)\n{\n    // Don't check for abbreviation in paste mode, when disabled and just\n    // after moving around with cursor keys.\n    if (p_paste || no_abbr || arrow_used)\n\treturn FALSE;\n\n    return check_abbr(c, ml_get_curline(), curwin->w_cursor.col,\n\t\tcurwin->w_cursor.lnum == Insstart.lnum ? Insstart.col : 0);\n}\n\n/*\n * replace-stack functions\n *\n * When replacing characters, the replaced characters are remembered for each\n * new character.  This is used to re-insert the old text when backspacing.\n *\n * There is a NUL headed list of characters for each character that is\n * currently in the file after the insertion point.  When BS is used, one NUL\n * headed list is put back for the deleted character.\n *\n * For a newline, there are two NUL headed lists.  One contains the characters\n * that the NL replaced.  The extra one stores the characters after the cursor\n * that were deleted (always white space).\n *\n * Replace_offset is normally 0, in which case replace_push will add a new\n * character at the end of the stack.  If replace_offset is not 0, that many\n * characters will be left on the stack above the newly inserted character.\n */\n\nstatic char_u\t*replace_stack = NULL;\nstatic long\treplace_stack_nr = 0;\t    // next entry in replace stack\nstatic long\treplace_stack_len = 0;\t    // max. number of entries\n\n    void\nreplace_push(\n    int\t    c)\t    // character that is replaced (NUL is none)\n{\n    char_u  *p;\n\n    if (replace_stack_nr < replace_offset)\t// nothing to do\n\treturn;\n    if (replace_stack_len <= replace_stack_nr)\n    {\n\treplace_stack_len += 50;\n\tp = ALLOC_MULT(char_u, replace_stack_len);\n\tif (p == NULL)\t    // out of memory\n\t{\n\t    replace_stack_len -= 50;\n\t    return;\n\t}\n\tif (replace_stack != NULL)\n\t{\n\t    mch_memmove(p, replace_stack,\n\t\t\t\t (size_t)(replace_stack_nr * sizeof(char_u)));\n\t    vim_free(replace_stack);\n\t}\n\treplace_stack = p;\n    }\n    p = replace_stack + replace_stack_nr - replace_offset;\n    if (replace_offset)\n\tmch_memmove(p + 1, p, (size_t)(replace_offset * sizeof(char_u)));\n    *p = c;\n    ++replace_stack_nr;\n}\n\n/*\n * Push a character onto the replace stack.  Handles a multi-byte character in\n * reverse byte order, so that the first byte is popped off first.\n * Return the number of bytes done (includes composing characters).\n */\n    int\nreplace_push_mb(char_u *p)\n{\n    int l = (*mb_ptr2len)(p);\n    int j;\n\n    for (j = l - 1; j >= 0; --j)\n\treplace_push(p[j]);\n    return l;\n}\n\n/*\n * Pop one item from the replace stack.\n * return -1 if stack empty\n * return replaced character or NUL otherwise\n */\n    static int\nreplace_pop(void)\n{\n    if (replace_stack_nr == 0)\n\treturn -1;\n    return (int)replace_stack[--replace_stack_nr];\n}\n\n/*\n * Join the top two items on the replace stack.  This removes to \"off\"'th NUL\n * encountered.\n */\n    void\nreplace_join(\n    int\t    off)\t// offset for which NUL to remove\n{\n    int\t    i;\n\n    for (i = replace_stack_nr; --i >= 0; )\n\tif (replace_stack[i] == NUL && off-- <= 0)\n\t{\n\t    --replace_stack_nr;\n\t    mch_memmove(replace_stack + i, replace_stack + i + 1,\n\t\t\t\t\t      (size_t)(replace_stack_nr - i));\n\t    return;\n\t}\n}\n\n/*\n * Pop bytes from the replace stack until a NUL is found, and insert them\n * before the cursor.  Can only be used in MODE_REPLACE or MODE_VREPLACE state.\n */\n    static void\nreplace_pop_ins(void)\n{\n    int\t    cc;\n    int\t    oldState = State;\n\n    State = MODE_NORMAL;\t\t\t// don't want MODE_REPLACE here\n    while ((cc = replace_pop()) > 0)\n    {\n\tmb_replace_pop_ins(cc);\n\tdec_cursor();\n    }\n    State = oldState;\n}\n\n/*\n * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it\n * indicates a multi-byte char, pop the other bytes too.\n */\n    static void\nmb_replace_pop_ins(int cc)\n{\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tc;\n\n    if (has_mbyte && (n = MB_BYTE2LEN(cc)) > 1)\n    {\n\tbuf[0] = cc;\n\tfor (i = 1; i < n; ++i)\n\t    buf[i] = replace_pop();\n\tins_bytes_len(buf, n);\n    }\n    else\n\tins_char(cc);\n\n    if (enc_utf8)\n\t// Handle composing chars.\n\tfor (;;)\n\t{\n\t    c = replace_pop();\n\t    if (c == -1)\t    // stack empty\n\t\tbreak;\n\t    if ((n = MB_BYTE2LEN(c)) == 1)\n\t    {\n\t\t// Not a multi-byte char, put it back.\n\t\treplace_push(c);\n\t\tbreak;\n\t    }\n\n\t    buf[0] = c;\n\t    for (i = 1; i < n; ++i)\n\t\tbuf[i] = replace_pop();\n\t    if (utf_iscomposing(utf_ptr2char(buf)))\n\t\tins_bytes_len(buf, n);\n\t    else\n\t    {\n\t\t// Not a composing char, put it back.\n\t\tfor (i = n - 1; i >= 0; --i)\n\t\t    replace_push(buf[i]);\n\t\tbreak;\n\t    }\n\n\t}\n}\n\n/*\n * make the replace stack empty\n * (called when exiting replace mode)\n */\n    static void\nreplace_flush(void)\n{\n    VIM_CLEAR(replace_stack);\n    replace_stack_len = 0;\n    replace_stack_nr = 0;\n}\n\n/*\n * Handle doing a BS for one character.\n * cc < 0: replace stack empty, just move cursor\n * cc == 0: character was inserted, delete it\n * cc > 0: character was replaced, put cc (first byte of original char) back\n * and check for more characters to be put back\n * When \"limit_col\" is >= 0, don't delete before this column.  Matters when\n * using composing characters, use del_char_after_col() instead of del_char().\n */\n    static void\nreplace_do_bs(int limit_col)\n{\n    int\t\tcc;\n    int\t\torig_len = 0;\n    int\t\tins_len;\n    int\t\torig_vcols = 0;\n    colnr_T\tstart_vcol;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tvcol;\n\n    cc = replace_pop();\n    if (cc > 0)\n    {\n#ifdef FEAT_PROP_POPUP\n\tsize_t\tlen_before = 0;  // init to shut up GCC\n\n\tif (curbuf->b_has_textprop)\n\t{\n\t    // Do not adjust text properties for individual delete and insert\n\t    // operations, do it afterwards on the resulting text.\n\t    len_before = STRLEN(ml_get_curline());\n\t    ++text_prop_frozen;\n\t}\n#endif\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the character we are\n\t    // going to delete.\n\t    getvcol(curwin, &curwin->w_cursor, NULL, &start_vcol, NULL);\n\t    orig_vcols = chartabsize(ml_get_cursor(), start_vcol);\n\t}\n\tif (has_mbyte)\n\t{\n\t    (void)del_char_after_col(limit_col);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor());\n\t    replace_push(cc);\n\t}\n\telse\n\t{\n\t    pchar_cursor(cc);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor()) - 1;\n\t}\n\treplace_pop_ins();\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the inserted characters\n\t    p = ml_get_cursor();\n\t    ins_len = (int)STRLEN(p) - orig_len;\n\t    vcol = start_vcol;\n\t    for (i = 0; i < ins_len; ++i)\n\t    {\n\t\tvcol += chartabsize(p + i, vcol);\n\t\ti += (*mb_ptr2len)(p) - 1;\n\t    }\n\t    vcol -= start_vcol;\n\n\t    // Delete spaces that were inserted after the cursor to keep the\n\t    // text aligned.\n\t    curwin->w_cursor.col += ins_len;\n\t    while (vcol > orig_vcols && gchar_cursor() == ' ')\n\t    {\n\t\tdel_char(FALSE);\n\t\t++orig_vcols;\n\t    }\n\t    curwin->w_cursor.col -= ins_len;\n\t}\n\n\t// mark the buffer as changed and prepare for displaying\n\tchanged_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n#ifdef FEAT_PROP_POPUP\n\tif (curbuf->b_has_textprop)\n\t{\n\t    size_t len_now = STRLEN(ml_get_curline());\n\n\t    --text_prop_frozen;\n\t    adjust_prop_columns(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t   (int)(len_now - len_before), 0);\n\t}\n#endif\n    }\n    else if (cc == 0)\n\t(void)del_char_after_col(limit_col);\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Map Hebrew keyboard when in hkmap mode.\n */\n    int\nhkmap(int c)\n{\n    if (p_hkmapp)   // phonetic mapping, by Ilya Dogolazky\n    {\n\tenum {hALEF=0, BET, GIMEL, DALET, HEI, VAV, ZAIN, HET, TET, IUD,\n\t    KAFsofit, hKAF, LAMED, MEMsofit, MEM, NUNsofit, NUN, SAMEH, AIN,\n\t    PEIsofit, PEI, ZADIsofit, ZADI, KOF, RESH, hSHIN, TAV};\n\tstatic char_u map[26] =\n\t    {(char_u)hALEF/*a*/, (char_u)BET  /*b*/, (char_u)hKAF    /*c*/,\n\t     (char_u)DALET/*d*/, (char_u)-1   /*e*/, (char_u)PEIsofit/*f*/,\n\t     (char_u)GIMEL/*g*/, (char_u)HEI  /*h*/, (char_u)IUD     /*i*/,\n\t     (char_u)HET  /*j*/, (char_u)KOF  /*k*/, (char_u)LAMED   /*l*/,\n\t     (char_u)MEM  /*m*/, (char_u)NUN  /*n*/, (char_u)SAMEH   /*o*/,\n\t     (char_u)PEI  /*p*/, (char_u)-1   /*q*/, (char_u)RESH    /*r*/,\n\t     (char_u)ZAIN /*s*/, (char_u)TAV  /*t*/, (char_u)TET     /*u*/,\n\t     (char_u)VAV  /*v*/, (char_u)hSHIN/*w*/, (char_u)-1      /*x*/,\n\t     (char_u)AIN  /*y*/, (char_u)ZADI /*z*/};\n\n\tif (c == 'N' || c == 'M' || c == 'P' || c == 'C' || c == 'Z')\n\t    return (int)(map[CharOrd(c)] - 1 + p_aleph);\n\t\t\t\t\t\t\t    // '-1'='sofit'\n\telse if (c == 'x')\n\t    return 'X';\n\telse if (c == 'q')\n\t    return '\\''; // {geresh}={'}\n\telse if (c == 246)\n\t    return ' ';  // \\\"o --> ' ' for a german keyboard\n\telse if (c == 228)\n\t    return ' ';  // \\\"a --> ' '      -- / --\n\telse if (c == 252)\n\t    return ' ';  // \\\"u --> ' '      -- / --\n\t// NOTE: islower() does not do the right thing for us on Linux so we\n\t// do this the same was as 5.7 and previous, so it works correctly on\n\t// all systems.  Specifically, the e.g. Delete and Arrow keys are\n\t// munged and won't work if e.g. searching for Hebrew text.\n\telse if (c >= 'a' && c <= 'z')\n\t    return (int)(map[CharOrdLow(c)] + p_aleph);\n\telse\n\t    return c;\n    }\n    else\n    {\n\tswitch (c)\n\t{\n\t    case '`':\treturn ';';\n\t    case '/':\treturn '.';\n\t    case '\\'':\treturn ',';\n\t    case 'q':\treturn '/';\n\t    case 'w':\treturn '\\'';\n\n\t\t\t// Hebrew letters - set offset from 'a'\n\t    case ',':\tc = '{'; break;\n\t    case '.':\tc = 'v'; break;\n\t    case ';':\tc = 't'; break;\n\t    default: {\n\t\t\t static char str[] = \"zqbcxlsjphmkwonu ydafe rig\";\n\n\t\t\t if (c < 'a' || c > 'z')\n\t\t\t     return c;\n\t\t\t c = str[CharOrdLow(c)];\n\t\t\t break;\n\t\t     }\n\t}\n\n\treturn (int)(CharOrdLow(c) + p_aleph);\n    }\n}\n#endif\n\n    static void\nins_reg(void)\n{\n    int\t\tneed_redraw = FALSE;\n    int\t\tregname;\n    int\t\tliterally = 0;\n    int\t\tvis_active = VIsual_active;\n\n    /*\n     * If we are going to wait for a character, show a '\"'.\n     */\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('\"', TRUE);\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_R);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    /*\n     * Don't map the register name. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    regname = plain_vgetc();\n    LANGMAP_ADJUST(regname, TRUE);\n    if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)\n    {\n\t// Get a third key for literal register insertion\n\tliterally = regname;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(literally);\n#endif\n\tregname = plain_vgetc();\n\tLANGMAP_ADJUST(regname, TRUE);\n    }\n    --no_mapping;\n    --allow_keys;\n\n#ifdef FEAT_EVAL\n    // Don't call u_sync() while typing the expression or giving an error\n    // message for it. Only call it explicitly.\n    ++no_u_sync;\n    if (regname == '=')\n    {\n\tpos_T\tcurpos = curwin->w_cursor;\n# ifdef HAVE_INPUT_METHOD\n\tint\tim_on = im_get_status();\n# endif\n\t// Sync undo when evaluating the expression calls setline() or\n\t// append(), so that it can be undone separately.\n\tu_sync_once = 2;\n\n\tregname = get_expr_register();\n\n\t// Cursor may be moved back a column.\n\tcurwin->w_cursor = curpos;\n\tcheck_cursor();\n# ifdef HAVE_INPUT_METHOD\n\t// Restore the Input Method.\n\tif (im_on)\n\t    im_set_active(TRUE);\n# endif\n    }\n    if (regname == NUL || !valid_yank_reg(regname, FALSE))\n    {\n\tvim_beep(BO_REG);\n\tneed_redraw = TRUE;\t// remove the '\"'\n    }\n    else\n    {\n#endif\n\tif (literally == Ctrl_O || literally == Ctrl_P)\n\t{\n\t    // Append the command to the redo buffer.\n\t    AppendCharToRedobuff(Ctrl_R);\n\t    AppendCharToRedobuff(literally);\n\t    AppendCharToRedobuff(regname);\n\n\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t (literally == Ctrl_P ? PUT_FIXINDENT : 0) | PUT_CURSEND);\n\t}\n\telse if (insert_reg(regname, literally) == FAIL)\n\t{\n\t    vim_beep(BO_REG);\n\t    need_redraw = TRUE;\t// remove the '\"'\n\t}\n\telse if (stop_insert_mode)\n\t    // When the '=' register was used and a function was invoked that\n\t    // did \":stopinsert\" then stuff_empty() returns FALSE but we won't\n\t    // insert anything, need to remove the '\"'\n\t    need_redraw = TRUE;\n\n#ifdef FEAT_EVAL\n    }\n    --no_u_sync;\n    if (u_sync_once == 1)\n\tins_need_undo = TRUE;\n    u_sync_once = 0;\n#endif\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    // If the inserted register is empty, we need to remove the '\"'\n    if (need_redraw || stuff_empty())\n\tedit_unputchar();\n\n    // Disallow starting Visual mode here, would get a weird mode.\n    if (!vis_active && VIsual_active)\n\tend_visual_mode();\n}\n\n/*\n * CTRL-G commands in Insert mode.\n */\n    static void\nins_ctrl_g(void)\n{\n    int\t\tc;\n\n    // Right after CTRL-X the cursor will be after the ruler.\n    setcursor();\n\n    /*\n     * Don't map the second key. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    switch (c)\n    {\n\t// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col\n\tcase K_UP:\n\tcase Ctrl_K:\n\tcase 'k': ins_up(TRUE);\n\t\t  break;\n\n\t// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col\n\tcase K_DOWN:\n\tcase Ctrl_J:\n\tcase 'j': ins_down(TRUE);\n\t\t  break;\n\n\t// CTRL-G u: start new undoable edit\n\tcase 'u': u_sync(TRUE);\n\t\t  ins_need_undo = TRUE;\n\n\t\t  // Need to reset Insstart, esp. because a BS that joins\n\t\t  // a line to the previous one must save for undo.\n\t\t  update_Insstart_orig = FALSE;\n\t\t  Insstart = curwin->w_cursor;\n\t\t  break;\n\n\t// CTRL-G U: do not break undo with the next char\n\tcase 'U':\n\t\t  // Allow one left/right cursor movement with the next char,\n\t\t  // without breaking undo.\n\t\t  dont_sync_undo = MAYBE;\n\t\t  break;\n\n\t// Unknown CTRL-G command, reserved for future expansion.\n\tdefault:  vim_beep(BO_CTRLG);\n    }\n}\n\n/*\n * CTRL-^ in Insert mode.\n */\n    static void\nins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, Toggle use of \":lmap\" mappings.\n\tif (State & MODE_LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~MODE_LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~MODE_LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    // may show different cursor shape or color\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle ESC in insert mode.\n * Returns TRUE when leaving insert mode, FALSE when going to repeat the\n * insert.\n */\n    static int\nins_esc(\n    long\t*count,\n    int\t\tcmdchar,\n    int\t\tnomove)\t    // don't move cursor\n{\n    int\t\ttemp;\n    static int\tdisabled_redraw = FALSE;\n#ifdef FEAT_CONCEAL\n    // Remember if the cursor line was concealed before changing State.\n    int\t\tcursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n\n    temp = curwin->w_cursor.col;\n    if (disabled_redraw)\n    {\n\t--RedrawingDisabled;\n\tdisabled_redraw = FALSE;\n    }\n    if (!arrow_used)\n    {\n\t/*\n\t * Don't append the ESC for \"r<CR>\" and \"grx\".\n\t * When 'insertmode' is set only CTRL-L stops Insert mode.  Needed for\n\t * when \"count\" is non-zero.\n\t */\n\tif (cmdchar != 'r' && cmdchar != 'v')\n\t    AppendToRedobuff(p_im ? (char_u *)\"\\014\" : ESC_STR);\n\n\t/*\n\t * Repeating insert may take a long time.  Check for\n\t * interrupt now and then.\n\t */\n\tif (*count > 0)\n\t{\n\t    line_breakcheck();\n\t    if (got_int)\n\t\t*count = 0;\n\t}\n\n\tif (--*count > 0)\t// repeat what was typed\n\t{\n\t    // Vi repeats the insert without replacing characters.\n\t    if (vim_strchr(p_cpo, CPO_REPLCNT) != NULL)\n\t\tState &= ~REPLACE_FLAG;\n\n\t    (void)start_redo_ins();\n\t    if (cmdchar == 'r' || cmdchar == 'v')\n\t\tstuffRedoReadbuff(ESC_STR);\t// no ESC in redo buffer\n\t    ++RedrawingDisabled;\n\t    disabled_redraw = TRUE;\n\t    return FALSE;\t// repeat the insert\n\t}\n\tstop_insert(&curwin->w_cursor, TRUE, nomove);\n\tundisplay_dollar();\n    }\n\n    if (cmdchar != 'r' && cmdchar != 'v')\n\tins_apply_autocmds(EVENT_INSERTLEAVEPRE);\n\n    // When an autoindent was removed, curswant stays after the\n    // indent\n    if (restart_edit == NUL && (colnr_T)temp == curwin->w_cursor.col)\n\tcurwin->w_set_curswant = TRUE;\n\n    // Remember the last Insert position in the '^ mark.\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n\tcurbuf->b_last_insert = curwin->w_cursor;\n\n    /*\n     * The cursor should end up on the last inserted character.\n     * Don't do it for CTRL-O, unless past the end of the line.\n     */\n    if (!nomove\n\t    && (curwin->w_cursor.col != 0\n\t\t|| curwin->w_cursor.coladd > 0)\n\t    && (restart_edit == NUL\n\t\t   || (gchar_cursor() == NUL && !VIsual_active))\n#ifdef FEAT_RIGHTLEFT\n\t    && !revins_on\n#endif\n\t\t\t\t      )\n    {\n\tif (curwin->w_cursor.coladd > 0 || get_ve_flags() == VE_ALL)\n\t{\n\t    oneleft();\n\t    if (restart_edit != NUL)\n\t\t++curwin->w_cursor.coladd;\n\t}\n\telse\n\t{\n\t    --curwin->w_cursor.col;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t}\n    }\n\n#ifdef HAVE_INPUT_METHOD\n    // Disable IM to allow typing English directly for Normal mode commands.\n    // When \":lmap\" is enabled don't change 'iminsert' (IM can be enabled as\n    // well).\n    if (!(State & MODE_LANGMAP))\n\tim_save_status(&curbuf->b_p_iminsert);\n    im_set_active(FALSE);\n#endif\n\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    if (!p_ek)\n    {\n\tMAY_WANT_TO_LOG_THIS;\n\n\t// Re-enable bracketed paste mode.\n\tout_str(T_BE);\n\n\t// Re-enable modifyOtherKeys.\n\tout_str(T_CTI);\n    }\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"i\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // When recording or for CTRL-O, need to display the new mode.\n    // Otherwise remove the mode message.\n    if (reg_recording != 0 || restart_edit != NUL)\n\tshowmode();\n    else if (p_smd && (got_int || !skip_showmode()))\n\tmsg(\"\");\n\n    return TRUE;\t    // exit Insert mode\n}\n\n#ifdef FEAT_RIGHTLEFT\n/*\n * Toggle language: hkmap and revins_on.\n * Move to end of reverse inserted text.\n */\n    static void\nins_ctrl_(void)\n{\n    if (revins_on && revins_chars && revins_scol >= 0)\n    {\n\twhile (gchar_cursor() != NUL && revins_chars--)\n\t    ++curwin->w_cursor.col;\n    }\n    p_ri = !p_ri;\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n    {\n\trevins_scol = curwin->w_cursor.col;\n\trevins_legal++;\n\trevins_chars = 0;\n\tundisplay_dollar();\n    }\n    else\n\trevins_scol = -1;\n    p_hkmap = curwin->w_p_rl ^ p_ri;    // be consistent!\n    showmode();\n}\n#endif\n\n/*\n * If 'keymodel' contains \"startsel\", may start selection.\n * Returns TRUE when a CTRL-O and other keys stuffed.\n */\n    static int\nins_start_select(int c)\n{\n    if (km_startsel)\n\tswitch (c)\n\t{\n\t    case K_KHOME:\n\t    case K_KEND:\n\t    case K_PAGEUP:\n\t    case K_KPAGEUP:\n\t    case K_PAGEDOWN:\n\t    case K_KPAGEDOWN:\n# ifdef MACOS_X\n\t    case K_LEFT:\n\t    case K_RIGHT:\n\t    case K_UP:\n\t    case K_DOWN:\n\t    case K_END:\n\t    case K_HOME:\n# endif\n\t\tif (!(mod_mask & MOD_MASK_SHIFT))\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case K_S_LEFT:\n\t    case K_S_RIGHT:\n\t    case K_S_UP:\n\t    case K_S_DOWN:\n\t    case K_S_END:\n\t    case K_S_HOME:\n\t\t// Start selection right away, the cursor can move with\n\t\t// CTRL-O when beyond the end of the line.\n\t\tstart_selection();\n\n\t\t// Execute the key in (insert) Select mode.\n\t\tstuffcharReadbuff(Ctrl_O);\n\t\tif (mod_mask)\n\t\t{\n\t\t    char_u\t    buf[4];\n\n\t\t    buf[0] = K_SPECIAL;\n\t\t    buf[1] = KS_MODIFIER;\n\t\t    buf[2] = mod_mask;\n\t\t    buf[3] = NUL;\n\t\t    stuffReadbuff(buf);\n\t\t}\n\t\tstuffcharReadbuff(c);\n\t\treturn TRUE;\n\t}\n    return FALSE;\n}\n\n/*\n * <Insert> key in Insert mode: toggle insert/replace mode.\n */\n    static void\nins_insert(int replaceState)\n{\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_INSERTMODE,\n\t\t   (char_u *)((State & REPLACE_FLAG) ? \"i\"\n\t\t\t    : replaceState == MODE_VREPLACE ? \"v\" : \"r\"), 1);\n#endif\n    ins_apply_autocmds(EVENT_INSERTCHANGE);\n    if (State & REPLACE_FLAG)\n\tState = MODE_INSERT | (State & MODE_LANGMAP);\n    else\n\tState = replaceState | (State & MODE_LANGMAP);\n    may_trigger_modechanged();\n    AppendCharToRedobuff(K_INS);\n    showmode();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * Pressed CTRL-O in Insert mode.\n */\n    static void\nins_ctrl_o(void)\n{\n    if (State & VREPLACE_FLAG)\n\trestart_edit = 'V';\n    else if (State & REPLACE_FLAG)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'I';\n    if (virtual_active())\n\tins_at_eol = FALSE;\t// cursor always keeps its column\n    else\n\tins_at_eol = (gchar_cursor() == NUL);\n}\n\n/*\n * If the cursor is on an indent, ^T/^D insert/delete one\n * shiftwidth.\tOtherwise ^T/^D behave like a \"<<\" or \">>\".\n * Always round the indent to 'shiftwidth', this is compatible\n * with vi.  But vi only supports ^T and ^D after an\n * autoindent, we support it everywhere.\n */\n    static void\nins_shift(int c, int lastc)\n{\n    if (stop_arrow() == FAIL)\n\treturn;\n    AppendCharToRedobuff(c);\n\n    /*\n     * 0^D and ^^D: remove all indent.\n     */\n    if (c == Ctrl_D && (lastc == '0' || lastc == '^')\n\t\t\t\t\t\t  && curwin->w_cursor.col > 0)\n    {\n\t--curwin->w_cursor.col;\n\t(void)del_char(FALSE);\t\t// delete the '^' or '0'\n\t// In Replace mode, restore the characters that '^' or '0' replaced.\n\tif (State & REPLACE_FLAG)\n\t    replace_pop_ins();\n\tif (lastc == '^')\n\t    old_indent = get_indent();\t// remember curr. indent\n\tchange_indent(INDENT_SET, 0, TRUE, 0, TRUE);\n    }\n    else\n\tchange_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);\n\n    if (did_ai && *skipwhite(ml_get_curline()) != NUL)\n\tdid_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    can_cindent = FALSE;\t// no cindenting after ^D or ^T\n}\n\n    static void\nins_del(void)\n{\n    int\t    temp;\n\n    if (stop_arrow() == FAIL)\n\treturn;\n    if (gchar_cursor() == NUL)\t\t// delete newline\n    {\n\ttemp = curwin->w_cursor.col;\n\tif (!can_bs(BS_EOL)\t\t// only if \"eol\" included\n\t\t|| do_join(2, FALSE, TRUE, FALSE, FALSE) == FAIL)\n\t    vim_beep(BO_BS);\n\telse\n\t{\n\t    curwin->w_cursor.col = temp;\n\t    // Adjust orig_line_count in case more lines have been deleted than\n\t    // have been added. That makes sure, that open_line() later\n\t    // can access all buffer lines correctly\n\t    if (State & VREPLACE_FLAG &&\n\t\t    orig_line_count > curbuf->b_ml.ml_line_count)\n\t\torig_line_count = curbuf->b_ml.ml_line_count;\n\t}\n    }\n    else if (del_char(FALSE) == FAIL)  // delete char under cursor\n\tvim_beep(BO_BS);\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    AppendCharToRedobuff(K_DEL);\n}\n\n/*\n * Delete one character for ins_bs().\n */\n    static void\nins_bs_one(colnr_T *vcolp)\n{\n    dec_cursor();\n    getvcol(curwin, &curwin->w_cursor, vcolp, NULL, NULL);\n    if (State & REPLACE_FLAG)\n    {\n\t// Don't delete characters before the insert point when in\n\t// Replace mode\n\tif (curwin->w_cursor.lnum != Insstart.lnum\n\t\t|| curwin->w_cursor.col >= Insstart.col)\n\t    replace_do_bs(-1);\n    }\n    else\n\t(void)del_char(FALSE);\n}\n\n/*\n * Handle Backspace, delete-word and delete-line in Insert mode.\n * Return TRUE when backspace was actually used.\n */\n    static int\nins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}\n\n/*\n * Handle receiving P_PS: start paste mode.  Inserts the following text up to\n * P_PE literally.\n * When \"drop\" is TRUE then consume the text and drop it.\n */\n    int\nbracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value_give_err((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value_give_err((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n    static void\nins_tabline(int c)\n{\n    // We will be leaving the current window, unless closing another tab.\n    if (c != K_TABMENU || current_tabmenu != TABLINE_MENU_CLOSE\n\t\t|| (current_tab != 0 && current_tab != tabpage_index(curtab)))\n    {\n\tundisplay_dollar();\n\tstart_arrow(&curwin->w_cursor);\n\tcan_cindent = TRUE;\n    }\n\n    if (c == K_TABLINE)\n\tgoto_tabpage(current_tab);\n    else\n    {\n\thandle_tabmenu();\n\tredraw_statuslines();\t// will redraw the tabline when needed\n    }\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    void\nins_scroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_scroll())\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n}\n\n    void\nins_horscroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_horiz_scroll(scrollbar_value, FALSE))\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n}\n#endif\n\n    static void\nins_left(void)\n{\n    pos_T\ttpos;\n    int\t\tend_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (oneleft() == OK)\n    {\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t// Only call start_arrow() when not busy with preediting, it will\n\t// break undo.  K_LEFT is inserted in im_correct_cursor().\n\tif (p_imst == IM_OVER_THE_SPOT || !im_is_preediting())\n#endif\n\t{\n\t    start_arrow_with_change(&tpos, end_change);\n\t    if (!end_change)\n\t\tAppendCharToRedobuff(K_LEFT);\n\t}\n#ifdef FEAT_RIGHTLEFT\n\t// If exit reversed string, position is fixed\n\tif (revins_scol != -1 && (int)curwin->w_cursor.col >= revins_scol)\n\t    revins_legal++;\n\trevins_chars++;\n#endif\n    }\n\n    /*\n     * if 'whichwrap' set for cursor in insert mode may go to\n     * previous line\n     */\n    else if (vim_strchr(p_ww, '[') != NULL && curwin->w_cursor.lnum > 1)\n    {\n\t// always break undo when moving upwards/downwards, else undo may break\n\tstart_arrow(&tpos);\n\t--(curwin->w_cursor.lnum);\n\tcoladvance((colnr_T)MAXCOL);\n\tcurwin->w_set_curswant = TRUE;\t// so we stay at the end\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_home(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_HOME)\n\tcurwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    start_arrow(&tpos);\n}\n\n    static void\nins_end(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_END)\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    coladvance((colnr_T)MAXCOL);\n    curwin->w_curswant = MAXCOL;\n\n    start_arrow(&tpos);\n}\n\n    static void\nins_s_left()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum > 1 || curwin->w_cursor.col > 0)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_LEFT);\n\t(void)bck_word(1L, FALSE, FALSE);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_right(void)\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (gchar_cursor() != NUL || virtual_active())\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_RIGHT);\n\tcurwin->w_set_curswant = TRUE;\n\tif (virtual_active())\n\t    oneright();\n\telse\n\t{\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t\t++curwin->w_cursor.col;\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\trevins_legal++;\n\tif (revins_chars)\n\t    revins_chars--;\n#endif\n    }\n    // if 'whichwrap' set for cursor in insert mode, may move the\n    // cursor to the next line\n    else if (vim_strchr(p_ww, ']') != NULL\n\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n    {\n\tstart_arrow(&curwin->w_cursor);\n\tcurwin->w_set_curswant = TRUE;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_s_right()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count\n\t    || gchar_cursor() != NUL)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_RIGHT);\n\t(void)fwd_word(1L, FALSE, 0);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_up(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_up(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pageup(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageUp>: tab page back\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(-1);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(BACKWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_down(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_down(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pagedown(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageDown>: tab page forward\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(0);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(FORWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n\tcan_cindent = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n#ifdef FEAT_DND\n    static void\nins_drop(void)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Handle TAB in Insert or Replace mode.\n * Return TRUE when the TAB needs to be inserted like a normal character.\n */\n    static int\nins_tab(void)\n{\n    int\t\tind;\n    int\t\ti;\n    int\t\ttemp;\n\n    if (Insstart_blank_vcol == MAXCOL && curwin->w_cursor.lnum == Insstart.lnum)\n\tInsstart_blank_vcol = get_nolist_virtcol();\n    if (echeck_abbr(TAB + ABBR_OFF))\n\treturn FALSE;\n\n    ind = inindent(0);\n    if (ind)\n\tcan_cindent = FALSE;\n\n    /*\n     * When nothing special, insert TAB like a normal character.\n     */\n    if (!curbuf->b_p_et\n#ifdef FEAT_VARTABS\n\t    && !(p_sta && ind\n\t\t// These five lines mean 'tabstop' != 'shiftwidth'\n\t\t&& ((tabstop_count(curbuf->b_p_vts_array) > 1)\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 1\n\t\t\t&& tabstop_first(curbuf->b_p_vts_array)\n\t\t\t\t\t\t       != get_sw_value(curbuf))\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 0\n\t\t\t&& curbuf->b_p_ts != get_sw_value(curbuf))))\n\t    && tabstop_count(curbuf->b_p_vsts_array) == 0\n#else\n\t    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value(curbuf))\n#endif\n\t    && get_sts_value() == 0)\n\treturn TRUE;\n\n    if (stop_arrow() == FAIL)\n\treturn TRUE;\n\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    AppendToRedobuff((char_u *)\"\\t\");\n\n#ifdef FEAT_VARTABS\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n    {\n\ttemp = (int)get_sw_value(curbuf);\n\ttemp -= get_nolist_virtcol() % temp;\n    }\n    else if (tabstop_count(curbuf->b_p_vsts_array) > 0 || curbuf->b_p_sts != 0)\n\t\t\t\t// use 'softtabstop' when set\n\ttemp = tabstop_padding(get_nolist_virtcol(), get_sts_value(),\n\t\t\t\t\t\t     curbuf->b_p_vsts_array);\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = tabstop_padding(get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t     curbuf->b_p_vts_array);\n#else\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n\ttemp = (int)get_sw_value(curbuf);\n    else if (curbuf->b_p_sts != 0) // use 'softtabstop' when set\n\ttemp = (int)get_sts_value();\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = (int)curbuf->b_p_ts;\n    temp -= get_nolist_virtcol() % temp;\n#endif\n\n    /*\n     * Insert the first space with ins_char().\tIt will delete one char in\n     * replace mode.  Insert the rest with ins_str(); it will not delete any\n     * chars.  For MODE_VREPLACE state, we use ins_char() for all characters.\n     */\n    ins_char(' ');\n    while (--temp > 0)\n    {\n\tif (State & VREPLACE_FLAG)\n\t    ins_char(' ');\n\telse\n\t{\n\t    ins_str((char_u *)\" \");\n\t    if (State & REPLACE_FLAG)\t    // no char replaced\n\t\treplace_push(NUL);\n\t}\n    }\n\n    /*\n     * When 'expandtab' not set: Replace spaces by TABs where possible.\n     */\n#ifdef FEAT_VARTABS\n    if (!curbuf->b_p_et && (tabstop_count(curbuf->b_p_vsts_array) > 0\n\t\t\t    || get_sts_value() > 0\n\t\t\t    || (p_sta && ind)))\n#else\n    if (!curbuf->b_p_et && (get_sts_value() || (p_sta && ind)))\n#endif\n    {\n\tchar_u\t\t*ptr;\n\tchar_u\t\t*saved_line = NULL;\t// init for GCC\n\tpos_T\t\tpos;\n\tpos_T\t\tfpos;\n\tpos_T\t\t*cursor;\n\tcolnr_T\t\twant_vcol, vcol;\n\tint\t\tchange_col = -1;\n\tint\t\tsave_list = curwin->w_p_list;\n\n\t/*\n\t * Get the current line.  For MODE_VREPLACE state, don't make real\n\t * changes yet, just work on a copy of the line.\n\t */\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    pos = curwin->w_cursor;\n\t    cursor = &pos;\n\t    saved_line = vim_strsave(ml_get_curline());\n\t    if (saved_line == NULL)\n\t\treturn FALSE;\n\t    ptr = saved_line + pos.col;\n\t}\n\telse\n\t{\n\t    ptr = ml_get_cursor();\n\t    cursor = &curwin->w_cursor;\n\t}\n\n\t// When 'L' is not in 'cpoptions' a tab always takes up 'ts' spaces.\n\tif (vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\t    curwin->w_p_list = FALSE;\n\n\t// Find first white before the cursor\n\tfpos = curwin->w_cursor;\n\twhile (fpos.col > 0 && VIM_ISWHITE(ptr[-1]))\n\t{\n\t    --fpos.col;\n\t    --ptr;\n\t}\n\n\t// In Replace mode, don't change characters before the insert point.\n\tif ((State & REPLACE_FLAG)\n\t\t&& fpos.lnum == Insstart.lnum\n\t\t&& fpos.col < Insstart.col)\n\t{\n\t    ptr += Insstart.col - fpos.col;\n\t    fpos.col = Insstart.col;\n\t}\n\n\t// compute virtual column numbers of first white and cursor\n\tgetvcol(curwin, &fpos, &vcol, NULL, NULL);\n\tgetvcol(curwin, cursor, &want_vcol, NULL, NULL);\n\n\t// Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'\n\t// and 'linebreak' adding extra virtual columns.\n\twhile (VIM_ISWHITE(*ptr))\n\t{\n\t    i = lbr_chartabsize(NULL, (char_u *)\"\\t\", vcol);\n\t    if (vcol + i > want_vcol)\n\t\tbreak;\n\t    if (*ptr != TAB)\n\t    {\n\t\t*ptr = TAB;\n\t\tif (change_col < 0)\n\t\t{\n\t\t    change_col = fpos.col;  // Column of first change\n\t\t    // May have to adjust Insstart\n\t\t    if (fpos.lnum == Insstart.lnum && fpos.col < Insstart.col)\n\t\t\tInsstart.col = fpos.col;\n\t\t}\n\t    }\n\t    ++fpos.col;\n\t    ++ptr;\n\t    vcol += i;\n\t}\n\n\tif (change_col >= 0)\n\t{\n\t    int repl_off = 0;\n\t    char_u *line = ptr;\n\n\t    // Skip over the spaces we need.\n\t    while (vcol < want_vcol && *ptr == ' ')\n\t    {\n\t\tvcol += lbr_chartabsize(line, ptr, vcol);\n\t\t++ptr;\n\t\t++repl_off;\n\t    }\n\t    if (vcol > want_vcol)\n\t    {\n\t\t// Must have a char with 'showbreak' just before it.\n\t\t--ptr;\n\t\t--repl_off;\n\t    }\n\t    fpos.col += repl_off;\n\n\t    // Delete following spaces.\n\t    i = cursor->col - fpos.col;\n\t    if (i > 0)\n\t    {\n#ifdef FEAT_PROP_POPUP\n\t\tif (!(State & VREPLACE_FLAG))\n\t\t{\n\t\t    char_u  *newp;\n\t\t    int\t    col;\n\n\t\t    newp = alloc(curbuf->b_ml.ml_line_len - i);\n\t\t    if (newp == NULL)\n\t\t\treturn FALSE;\n\n\t\t    col = ptr - curbuf->b_ml.ml_line_ptr;\n\t\t    if (col > 0)\n\t\t\tmch_memmove(newp, ptr - col, col);\n\t\t    mch_memmove(newp + col, ptr + i,\n\t\t\t\t\t   curbuf->b_ml.ml_line_len - col - i);\n\n\t\t    if (curbuf->b_ml.ml_flags & ML_LINE_DIRTY)\n\t\t\tvim_free(curbuf->b_ml.ml_line_ptr);\n\t\t    curbuf->b_ml.ml_line_ptr = newp;\n\t\t    curbuf->b_ml.ml_line_len -= i;\n\t\t    curbuf->b_ml.ml_flags =\n\t\t\t   (curbuf->b_ml.ml_flags | ML_LINE_DIRTY) & ~ML_EMPTY;\n\t\t}\n\t\telse\n#endif\n\t\t    STRMOVE(ptr, ptr + i);\n\t\t// correct replace stack.\n\t\tif ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\t\t    for (temp = i; --temp >= 0; )\n\t\t\treplace_join(repl_off);\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tnetbeans_removed(curbuf, fpos.lnum, cursor->col, (long)(i + 1));\n\t\tnetbeans_inserted(curbuf, fpos.lnum, cursor->col,\n\t\t\t\t\t\t\t   (char_u *)\"\\t\", 1);\n\t    }\n#endif\n\t    cursor->col -= i;\n\n\t    /*\n\t     * In MODE_VREPLACE state, we haven't changed anything yet.  Do it\n\t     * now by backspacing over the changed spacing and then inserting\n\t     * the new spacing.\n\t     */\n\t    if (State & VREPLACE_FLAG)\n\t    {\n\t\t// Backspace from real cursor to change_col\n\t\tbackspace_until_column(change_col);\n\n\t\t// Insert each char in saved_line from changed_col to\n\t\t// ptr-cursor\n\t\tins_bytes_len(saved_line + change_col,\n\t\t\t\t\t\t    cursor->col - change_col);\n\t    }\n\t}\n\n\tif (State & VREPLACE_FLAG)\n\t    vim_free(saved_line);\n\tcurwin->w_p_list = save_list;\n    }\n\n    return FALSE;\n}\n\n/*\n * Handle CR or NL in insert mode.\n * Return FAIL when out of memory or can't undo.\n */\n    int\nins_eol(int c)\n{\n    int\t    i;\n\n    if (echeck_abbr(c + ABBR_OFF))\n\treturn OK;\n    if (stop_arrow() == FAIL)\n\treturn FAIL;\n    undisplay_dollar();\n\n    /*\n     * Strange Vi behaviour: In Replace mode, typing a NL will not delete the\n     * character under the cursor.  Only push a NUL on the replace stack,\n     * nothing to put back when the NL is deleted.\n     */\n    if ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\treplace_push(NUL);\n\n    /*\n     * In MODE_VREPLACE state, a NL replaces the rest of the line, and starts\n     * replacing the next line, so we push all of the characters left on the\n     * line onto the replace stack.  This is not done here though, it is done\n     * in open_line().\n     */\n\n    // Put cursor on NUL if on the last char and coladd is 1 (happens after\n    // CTRL-O).\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance(getviscol());\n\n#ifdef FEAT_RIGHTLEFT\n    // NL in reverse insert will always start in the end of\n    // current line.\n    if (revins_on)\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n#endif\n\n    AppendToRedobuff(NL_STR);\n    i = open_line(FORWARD,\n\t    has_format_option(FO_RET_COMS) ? OPENLINE_DO_COM : 0, old_indent,\n\t    NULL);\n    old_indent = 0;\n    can_cindent = TRUE;\n#ifdef FEAT_FOLDING\n    // When inserting a line the cursor line must never be in a closed fold.\n    foldOpenCursor();\n#endif\n\n    return i;\n}\n\n#ifdef FEAT_DIGRAPHS\n/*\n * Handle digraph in insert mode.\n * Returns character still to be inserted, or NUL when nothing remaining to be\n * done.\n */\n    static int\nins_digraph(void)\n{\n    int\t    c;\n    int\t    cc;\n    int\t    did_putchar = FALSE;\n\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('?', TRUE);\n\tdid_putchar = TRUE;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_K);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // don't map the digraph chars. This also prevents the\n    // mode message to be deleted when ESC is hit\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    if (did_putchar)\n\t// when the line fits in 'columns' the '?' is at the start of the next\n\t// line and will not be removed by the redraw\n\tedit_unputchar();\n\n    if (IS_SPECIAL(c) || mod_mask)\t    // special key\n    {\n#ifdef FEAT_CMDL_INFO\n\tclear_showcmd();\n#endif\n\tinsert_special(c, TRUE, FALSE);\n\treturn NUL;\n    }\n    if (c != ESC)\n    {\n\tdid_putchar = FALSE;\n\tif (redrawing() && !char_avail())\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\n\t    if (char2cells(c) == 1)\n\t    {\n\t\tins_redraw(FALSE);\n\t\tedit_putchar(c, TRUE);\n\t\tdid_putchar = TRUE;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    add_to_showcmd_c(c);\n#endif\n\t}\n\t++no_mapping;\n\t++allow_keys;\n\tcc = plain_vgetc();\n\t--no_mapping;\n\t--allow_keys;\n\tif (did_putchar)\n\t    // when the line fits in 'columns' the '?' is at the start of the\n\t    // next line and will not be removed by a redraw\n\t    edit_unputchar();\n\tif (cc != ESC)\n\t{\n\t    AppendToRedobuff((char_u *)CTRL_V_STR);\n\t    c = digraph_get(c, cc, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    clear_showcmd();\n#endif\n\t    return c;\n\t}\n    }\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n    return NUL;\n}\n#endif\n\n/*\n * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.\n * Returns the char to be inserted, or NUL if none found.\n */\n    int\nins_copychar(linenr_T lnum)\n{\n    int\t    c;\n    int\t    temp;\n    char_u  *ptr, *prev_ptr;\n    char_u  *line;\n\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)\n    {\n\tvim_beep(BO_COPY);\n\treturn NUL;\n    }\n\n    // try to advance to the cursor column\n    temp = 0;\n    line = ptr = ml_get(lnum);\n    prev_ptr = ptr;\n    validate_virtcol();\n    while ((colnr_T)temp < curwin->w_virtcol && *ptr != NUL)\n    {\n\tprev_ptr = ptr;\n\ttemp += lbr_chartabsize_adv(line, &ptr, (colnr_T)temp);\n    }\n    if ((colnr_T)temp > curwin->w_virtcol)\n\tptr = prev_ptr;\n\n    c = (*mb_ptr2char)(ptr);\n    if (c == NUL)\n\tvim_beep(BO_COPY);\n    return c;\n}\n\n/*\n * CTRL-Y or CTRL-E typed in Insert mode.\n */\n    static int\nins_ctrl_ey(int tc)\n{\n    int\t    c = tc;\n\n    if (ctrl_x_mode_scroll())\n    {\n\tif (c == Ctrl_Y)\n\t    scrolldown_clamp();\n\telse\n\t    scrollup_clamp();\n\tredraw_later(VALID);\n    }\n    else\n    {\n\tc = ins_copychar(curwin->w_cursor.lnum + (c == Ctrl_Y ? -1 : 1));\n\tif (c != NUL)\n\t{\n\t    long\ttw_save;\n\n\t    // The character must be taken literally, insert like it\n\t    // was typed after a CTRL-V, and pretend 'textwidth'\n\t    // wasn't set.  Digits, 'o' and 'x' are special after a\n\t    // CTRL-V, don't use it for these.\n\t    if (c < 256 && !isalnum(c))\n\t\tAppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\t    tw_save = curbuf->b_p_tw;\n\t    curbuf->b_p_tw = -1;\n\t    insert_special(c, TRUE, FALSE);\n\t    curbuf->b_p_tw = tw_save;\n#ifdef FEAT_RIGHTLEFT\n\t    revins_chars++;\n\t    revins_legal++;\n#endif\n\t    c = Ctrl_V;\t// pretend CTRL-V is last character\n\t    auto_format(FALSE, TRUE);\n\t}\n    }\n    return c;\n}\n\n/*\n * Get the value that w_virtcol would have when 'list' is off.\n * Unless 'cpo' contains the 'L' flag.\n */\n    colnr_T\nget_nolist_virtcol(void)\n{\n    // check validity of cursor in current buffer\n    if (curwin->w_buffer == NULL\n\t|| curwin->w_buffer->b_ml.ml_mfp == NULL\n\t|| curwin->w_cursor.lnum > curwin->w_buffer->b_ml.ml_line_count)\n\treturn 0;\n    if (curwin->w_p_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\treturn getvcol_nolist(&curwin->w_cursor);\n    validate_virtcol();\n    return curwin->w_virtcol;\n}\n\n#if defined(FEAT_EVAL)\n/*\n * Handle the InsertCharPre autocommand.\n * \"c\" is the character that was typed.\n * Return a pointer to allocated memory with the replacement string.\n * Return NULL to continue inserting \"c\".\n */\n    static char_u *\ndo_insert_char_pre(int c)\n{\n    char_u\t*res;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tsave_State = State;\n\n    // Return quickly when there is nothing to do.\n    if (!has_insertcharpre())\n\treturn NULL;\n\n    if (has_mbyte)\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    else\n    {\n\tbuf[0] = c;\n\tbuf[1] = NUL;\n    }\n\n    // Lock the text to avoid weird things from happening.\n    ++textlock;\n    set_vim_var_string(VV_CHAR, buf, -1);  // set v:char\n\n    res = NULL;\n    if (ins_apply_autocmds(EVENT_INSERTCHARPRE))\n    {\n\t// Get the value of v:char.  It may be empty or more than one\n\t// character.  Only use it when changed, otherwise continue with the\n\t// original character to avoid breaking autoindent.\n\tif (STRCMP(buf, get_vim_var_str(VV_CHAR)) != 0)\n\t    res = vim_strsave(get_vim_var_str(VV_CHAR));\n    }\n\n    set_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n    --textlock;\n\n    // Restore the State, it may have been changed.\n    State = save_State;\n\n    return res;\n}\n#endif\n\n    int\nget_can_cindent(void)\n{\n    return can_cindent;\n}\n\n    void\nset_can_cindent(int val)\n{\n    can_cindent = val;\n}\n\n/*\n * Trigger \"event\" and take care of fixing undo.\n */\n    int\nins_apply_autocmds(event_T event)\n{\n    varnumber_T\ttick = CHANGEDTICK(curbuf);\n    int r;\n\n    r = apply_autocmds(event, NULL, NULL, FALSE, curbuf);\n\n    // If u_savesub() was called then we are not prepared to start\n    // a new line.  Call u_save() with no contents to fix that.\n    // Except when leaving Insert mode.\n    if (event != EVENT_INSERTLEAVE && tick != CHANGEDTICK(curbuf))\n\tu_save(curwin->w_cursor.lnum, (linenr_T)(curwin->w_cursor.lnum + 1));\n\n    return r;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5162,\n/**/\n    5161,\n/**/\n    5160,\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/edit.c", "src/version.c"], "buggy_code_start_loc": [4186, 737], "buggy_code_end_loc": [4187, 737], "fixing_code_start_loc": [4186, 738], "fixing_code_end_loc": [4187, 740], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-2207", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-27T12:15:07.907", "lastModified": "2023-05-03T12:15:47.777", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Un Desbordamiento de B\u00fafer en la Regi\u00f3n Heap de la Memoria en el repositorio de GitHub vim/vim versiones anteriores a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.5162", "matchCriteriaId": "A13D58DD-4029-4EED-921B-0803B548D3F7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/05bc6051-4dc3-483b-ae56-cf23346b97b9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b"}}