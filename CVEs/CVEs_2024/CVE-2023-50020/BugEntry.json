{"buggy_code": ["/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"core-config-private.h\"\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include <sys/epoll.h>\n\n#include \"ogs-core.h\"\n#include \"ogs-poll-private.h\"\n\nstatic void epoll_init(ogs_pollset_t *pollset);\nstatic void epoll_cleanup(ogs_pollset_t *pollset);\nstatic int epoll_add(ogs_poll_t *poll);\nstatic int epoll_remove(ogs_poll_t *poll);\nstatic int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout);\n\nconst ogs_pollset_actions_t ogs_epoll_actions = {\n    epoll_init,\n    epoll_cleanup,\n\n    epoll_add,\n    epoll_remove,\n    epoll_process,\n\n    ogs_notify_pollset,\n};\n\nstruct epoll_map_s {\n    ogs_poll_t *read;\n    ogs_poll_t *write;\n};\n\nstruct epoll_context_s {\n    int epfd;\n\n    ogs_hash_t *map_hash;\n    struct epoll_event *event_list;\n};\n\nstatic void epoll_init(ogs_pollset_t *pollset)\n{\n    struct epoll_context_s *context = NULL;\n    ogs_assert(pollset);\n\n    context = ogs_calloc(1, sizeof *context);\n    ogs_assert(context);\n    pollset->context = context;\n\n    context->event_list = ogs_calloc(\n            pollset->capacity, sizeof(struct epoll_event));\n    ogs_assert(context->event_list);\n\n    context->map_hash = ogs_hash_make();\n    ogs_assert(context->map_hash);\n\n    context->epfd = epoll_create(pollset->capacity);\n    ogs_assert(context->epfd >= 0);\n\n    ogs_notify_init(pollset);\n}\n\nstatic void epoll_cleanup(ogs_pollset_t *pollset)\n{\n    struct epoll_context_s *context = NULL;\n\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    ogs_notify_final(pollset);\n    close(context->epfd);\n    ogs_free(context->event_list);\n    ogs_hash_destroy(context->map_hash);\n\n    ogs_free(context);\n}\n\nstatic int epoll_add(ogs_poll_t *poll)\n{\n    int rv, op;\n    ogs_pollset_t *pollset = NULL;\n    struct epoll_context_s *context = NULL;\n    struct epoll_map_s *map = NULL;\n    struct epoll_event ee;\n\n    ogs_assert(poll);\n    pollset = poll->pollset;\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    map = ogs_hash_get(context->map_hash, &poll->fd, sizeof(poll->fd));\n    if (!map) {\n        map = ogs_calloc(1, sizeof(*map));\n        if (!map) {\n            ogs_error(\"ogs_calloc() failed\");\n            return OGS_ERROR;\n        }\n\n        op = EPOLL_CTL_ADD;\n        ogs_hash_set(context->map_hash, &poll->fd, sizeof(poll->fd), map);\n    } else {\n        op = EPOLL_CTL_MOD;\n    }\n\n    if (poll->when & OGS_POLLIN)\n        map->read = poll;\n    if (poll->when & OGS_POLLOUT)\n        map->write = poll;\n\n    memset(&ee, 0, sizeof ee);\n\n    ee.events = 0;\n    if (map->read)\n        ee.events |= (EPOLLIN|EPOLLRDHUP);\n    if (map->write)\n        ee.events |= EPOLLOUT;\n    ee.data.fd = poll->fd;\n\n    rv = epoll_ctl(context->epfd, op, poll->fd, &ee);\n    if (rv < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"epoll_ctl[%d] failed\", op);\n        return OGS_ERROR;\n    }\n\n    return OGS_OK;\n}\n\nstatic int epoll_remove(ogs_poll_t *poll)\n{\n    int rv, op;\n    ogs_pollset_t *pollset = NULL;\n    struct epoll_context_s *context = NULL;\n    struct epoll_map_s *map = NULL;\n    struct epoll_event ee;\n\n    ogs_assert(poll);\n    pollset = poll->pollset;\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    map = ogs_hash_get(context->map_hash, &poll->fd, sizeof(poll->fd));\n    ogs_assert(map);\n\n    if (poll->when & OGS_POLLIN)\n        map->read = NULL;\n    if (poll->when & OGS_POLLOUT)\n        map->write = NULL;\n\n    memset(&ee, 0, sizeof ee);\n\n    ee.events = 0;\n    if (map->read)\n        ee.events |= (EPOLLIN|EPOLLRDHUP);\n    if (map->write)\n        ee.events |= EPOLLOUT;\n\n    if (map->read || map->write) {\n        op = EPOLL_CTL_MOD;\n        ee.data.fd = poll->fd;\n    } else {\n        op = EPOLL_CTL_DEL;\n        ee.data.fd = INVALID_SOCKET;\n\n        ogs_hash_set(context->map_hash, &poll->fd, sizeof(poll->fd), NULL);\n        ogs_free(map);\n    }\n\n    rv = epoll_ctl(context->epfd, op, poll->fd, &ee);\n    if (rv < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"epoll_remove[%d] failed\", op);\n        return OGS_ERROR;\n    }\n\n    return OGS_OK;\n}\n\nstatic int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout)\n{\n    struct epoll_context_s *context = NULL;\n    int num_of_poll;\n    int i;\n\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    num_of_poll = epoll_wait(context->epfd, context->event_list,\n            pollset->capacity,\n            timeout == OGS_INFINITE_TIME ? OGS_INFINITE_TIME :\n                ogs_time_to_msec(timeout));\n    if (num_of_poll < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, \"epoll failed\");\n        return OGS_ERROR;\n    } else if (num_of_poll == 0) {\n        return OGS_TIMEUP;\n    }\n\n    for (i = 0; i < num_of_poll; i++) {\n        struct epoll_map_s *map = NULL;\n        uint32_t received;\n        short when = 0;\n        ogs_socket_t fd;\n\n        received = context->event_list[i].events;\n        if (received & EPOLLERR) {\n        /*\n         * The libevent library has OGS_POLLOUT turned on in EPOLLERR.\n         *\n         * However, SIGPIPE can occur if write() is called\n         * when the peer connection is closed.\n         *\n         * Therefore, Open5GS turns off OGS_POLLOUT\n         * so that write() cannot be called in case of EPOLLERR.\n         *\n         * See also #2411 and #2312\n         */\n#if 0\n            when = OGS_POLLIN|OGS_POLLOUT;\n#else\n            when = OGS_POLLIN;\n#endif\n        } else if ((received & EPOLLHUP) && !(received & EPOLLRDHUP)) {\n            when = OGS_POLLIN|OGS_POLLOUT;\n        } else {\n            if (received & EPOLLIN) {\n                when |= OGS_POLLIN;\n            }\n            if (received & EPOLLOUT) {\n                when |= OGS_POLLOUT;\n            }\n            if (received & EPOLLRDHUP) {\n                when |= OGS_POLLIN;\n            }\n        }\n\n        if (!when)\n            continue;\n\n        fd = context->event_list[i].data.fd;\n        ogs_assert(fd != INVALID_SOCKET);\n\n        map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n        if (!map) continue;\n\n        if (map->read && map->write && map->read == map->write) {\n            map->read->handler(when, map->read->fd, map->read->data);\n        } else {\n            if ((when & OGS_POLLIN) && map->read)\n                map->read->handler(when, map->read->fd, map->read->data);\n\n            /*\n             * map->read->handler() can call ogs_remove_epoll()\n             * So, we need to check map instance\n             */\n            map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n            if (!map) continue;\n\n            if ((when & OGS_POLLOUT) && map->write)\n                map->write->handler(when, map->write->fd, map->write->data);\n        }\n    }\n    \n    return OGS_OK;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2019 by Sukchan Lee <acetcom@gmail.com>\n *\n * This file is part of Open5GS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"core-config-private.h\"\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include <sys/epoll.h>\n\n#include \"ogs-core.h\"\n#include \"ogs-poll-private.h\"\n\nstatic void epoll_init(ogs_pollset_t *pollset);\nstatic void epoll_cleanup(ogs_pollset_t *pollset);\nstatic int epoll_add(ogs_poll_t *poll);\nstatic int epoll_remove(ogs_poll_t *poll);\nstatic int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout);\n\nconst ogs_pollset_actions_t ogs_epoll_actions = {\n    epoll_init,\n    epoll_cleanup,\n\n    epoll_add,\n    epoll_remove,\n    epoll_process,\n\n    ogs_notify_pollset,\n};\n\nstruct epoll_map_s {\n    ogs_poll_t *read;\n    ogs_poll_t *write;\n};\n\nstruct epoll_context_s {\n    int epfd;\n\n    ogs_hash_t *map_hash;\n    struct epoll_event *event_list;\n};\n\nstatic void epoll_init(ogs_pollset_t *pollset)\n{\n    struct epoll_context_s *context = NULL;\n    ogs_assert(pollset);\n\n    context = ogs_calloc(1, sizeof *context);\n    ogs_assert(context);\n    pollset->context = context;\n\n    context->event_list = ogs_calloc(\n            pollset->capacity, sizeof(struct epoll_event));\n    ogs_assert(context->event_list);\n\n    context->map_hash = ogs_hash_make();\n    ogs_assert(context->map_hash);\n\n    context->epfd = epoll_create(pollset->capacity);\n    ogs_assert(context->epfd >= 0);\n\n    ogs_notify_init(pollset);\n}\n\nstatic void epoll_cleanup(ogs_pollset_t *pollset)\n{\n    struct epoll_context_s *context = NULL;\n\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    ogs_notify_final(pollset);\n    close(context->epfd);\n    ogs_free(context->event_list);\n    ogs_hash_destroy(context->map_hash);\n\n    ogs_free(context);\n}\n\nstatic int epoll_add(ogs_poll_t *poll)\n{\n    int rv, op;\n    ogs_pollset_t *pollset = NULL;\n    struct epoll_context_s *context = NULL;\n    struct epoll_map_s *map = NULL;\n    struct epoll_event ee;\n\n    ogs_assert(poll);\n    pollset = poll->pollset;\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    map = ogs_hash_get(context->map_hash, &poll->fd, sizeof(poll->fd));\n    if (!map) {\n        map = ogs_calloc(1, sizeof(*map));\n        if (!map) {\n            ogs_error(\"ogs_calloc() failed\");\n            return OGS_ERROR;\n        }\n\n        op = EPOLL_CTL_ADD;\n        ogs_hash_set(context->map_hash, &poll->fd, sizeof(poll->fd), map);\n    } else {\n        op = EPOLL_CTL_MOD;\n    }\n\n    if (poll->when & OGS_POLLIN)\n        map->read = poll;\n    if (poll->when & OGS_POLLOUT)\n        map->write = poll;\n\n    memset(&ee, 0, sizeof ee);\n\n    ee.events = 0;\n    if (map->read)\n        ee.events |= (EPOLLIN|EPOLLRDHUP);\n    if (map->write)\n        ee.events |= EPOLLOUT;\n    ee.data.fd = poll->fd;\n\n    rv = epoll_ctl(context->epfd, op, poll->fd, &ee);\n    if (rv < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"epoll_ctl[%d] failed\", op);\n        return OGS_ERROR;\n    }\n\n    return OGS_OK;\n}\n\nstatic int epoll_remove(ogs_poll_t *poll)\n{\n    int rv, op;\n    ogs_pollset_t *pollset = NULL;\n    struct epoll_context_s *context = NULL;\n    struct epoll_map_s *map = NULL;\n    struct epoll_event ee;\n\n    ogs_assert(poll);\n    pollset = poll->pollset;\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    map = ogs_hash_get(context->map_hash, &poll->fd, sizeof(poll->fd));\n    ogs_assert(map);\n\n    if (poll->when & OGS_POLLIN)\n        map->read = NULL;\n    if (poll->when & OGS_POLLOUT)\n        map->write = NULL;\n\n    memset(&ee, 0, sizeof ee);\n\n    ee.events = 0;\n    if (map->read)\n        ee.events |= (EPOLLIN|EPOLLRDHUP);\n    if (map->write)\n        ee.events |= EPOLLOUT;\n\n    if (map->read || map->write) {\n        op = EPOLL_CTL_MOD;\n        ee.data.fd = poll->fd;\n    } else {\n        op = EPOLL_CTL_DEL;\n        ee.data.fd = INVALID_SOCKET;\n\n        ogs_hash_set(context->map_hash, &poll->fd, sizeof(poll->fd), NULL);\n        ogs_free(map);\n    }\n\n    rv = epoll_ctl(context->epfd, op, poll->fd, &ee);\n    if (rv < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"epoll_remove[%d] failed\", op);\n        return OGS_ERROR;\n    }\n\n    return OGS_OK;\n}\n\nstatic int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout)\n{\n    struct epoll_context_s *context = NULL;\n    int num_of_poll;\n    int i;\n\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    num_of_poll = epoll_wait(context->epfd, context->event_list,\n            pollset->capacity,\n            timeout == OGS_INFINITE_TIME ? OGS_INFINITE_TIME :\n                ogs_time_to_msec(timeout));\n    if (num_of_poll < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, \"epoll failed\");\n        return OGS_ERROR;\n    } else if (num_of_poll == 0) {\n        return OGS_TIMEUP;\n    }\n\n    for (i = 0; i < num_of_poll; i++) {\n        struct epoll_map_s *map = NULL;\n        uint32_t received;\n        short when = 0;\n        ogs_socket_t fd;\n\n        received = context->event_list[i].events;\n        if (received & EPOLLERR) {\n        /*\n         * The libevent library has OGS_POLLOUT turned on in EPOLLERR.\n         *\n         * However, SIGPIPE can occur if write() is called\n         * when the peer connection is closed.\n         *\n         * Therefore, Open5GS turns off OGS_POLLOUT\n         * so that write() cannot be called in case of EPOLLERR.\n         *\n         * See also #2411 and #2312\n         */\n#if 0\n            when = OGS_POLLIN|OGS_POLLOUT;\n#else\n            when = OGS_POLLIN;\n#endif\n        } else if ((received & EPOLLHUP) && !(received & EPOLLRDHUP)) {\n            when = OGS_POLLIN|OGS_POLLOUT;\n        } else {\n            if (received & EPOLLIN) {\n                when |= OGS_POLLIN;\n            }\n            if (received & EPOLLOUT) {\n                when |= OGS_POLLOUT;\n            }\n            if (received & EPOLLRDHUP) {\n                when |= OGS_POLLIN;\n                when &= ~OGS_POLLOUT;\n            }\n        }\n\n        if (!when)\n            continue;\n\n        fd = context->event_list[i].data.fd;\n        ogs_assert(fd != INVALID_SOCKET);\n\n        map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n        if (!map) continue;\n\n        if (map->read && map->write && map->read == map->write) {\n            map->read->handler(when, map->read->fd, map->read->data);\n        } else {\n            if ((when & OGS_POLLIN) && map->read)\n                map->read->handler(when, map->read->fd, map->read->data);\n\n            /*\n             * map->read->handler() can call ogs_remove_epoll()\n             * So, we need to check map instance\n             */\n            map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n            if (!map) continue;\n\n            if ((when & OGS_POLLOUT) && map->write)\n                map->write->handler(when, map->write->fd, map->write->data);\n        }\n    }\n    \n    return OGS_OK;\n}\n"], "filenames": ["lib/core/ogs-epoll.c"], "buggy_code_start_loc": [256], "buggy_code_end_loc": [256], "fixing_code_start_loc": [257], "fixing_code_end_loc": [258], "type": "CWE-400", "message": "An issue was discovered in open5gs v2.6.6. SIGPIPE can be used to crash AMF.", "other": {"cve": {"id": "CVE-2023-50020", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-02T22:15:09.190", "lastModified": "2024-01-11T17:35:56.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in open5gs v2.6.6. SIGPIPE can be used to crash AMF."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en open5gs v2.6.6. SIGPIPE se puede utilizar para bloquear AMF."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:open5gs:open5gs:2.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "27AA61AC-D4A0-40B4-8965-E578FC5F8D03"}]}]}], "references": [{"url": "https://github.com/open5gs/open5gs/commit/1aba814938e3a1b2eec7014bf6ce132d34622e08", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/open5gs/open5gs/issues/2734", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/open5gs/open5gs/commit/1aba814938e3a1b2eec7014bf6ce132d34622e08"}}