{"buggy_code": ["from __future__ import annotations\n\nimport functools\nimport logging\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Any, Callable, Iterable, List, Mapping, Optional, Tuple, Type\nfrom urllib.parse import quote as urlquote\n\nimport sentry_sdk\nfrom django.conf import settings\nfrom django.http import HttpResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom pytz import utc\nfrom rest_framework import status\nfrom rest_framework.authentication import BaseAuthentication, SessionAuthentication\nfrom rest_framework.exceptions import ParseError\nfrom rest_framework.permissions import BasePermission\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom sentry_sdk import Scope\n\nfrom sentry import analytics, options, tsdb\nfrom sentry.apidocs.hooks import HTTP_METHODS_SET\nfrom sentry.auth import access\nfrom sentry.models import Environment\nfrom sentry.ratelimits.config import DEFAULT_RATE_LIMIT_CONFIG, RateLimitConfig\nfrom sentry.silo import SiloLimit, SiloMode\nfrom sentry.types.ratelimit import RateLimit, RateLimitCategory\nfrom sentry.utils import json\nfrom sentry.utils.audit import create_audit_entry\nfrom sentry.utils.cursors import Cursor\nfrom sentry.utils.dates import to_datetime\nfrom sentry.utils.http import is_valid_origin, origin_from_request\nfrom sentry.utils.sdk import capture_exception, merge_context_into_scope\n\nfrom .authentication import ApiKeyAuthentication, OrgAuthTokenAuthentication, TokenAuthentication\nfrom .paginator import BadPaginationError, Paginator\nfrom .permissions import NoPermission\n\n__all__ = [\n    \"Endpoint\",\n    \"EnvironmentMixin\",\n    \"StatsMixin\",\n    \"control_silo_endpoint\",\n    \"region_silo_endpoint\",\n    \"pending_silo_endpoint\",\n]\n\nfrom ..services.hybrid_cloud.auth import RpcAuthentication, RpcAuthenticatorType\nfrom ..utils.pagination_factory import (\n    annotate_span_with_pagination_args,\n    clamp_pagination_per_page,\n    get_cursor,\n    get_paginator,\n)\n\nONE_MINUTE = 60\nONE_HOUR = ONE_MINUTE * 60\nONE_DAY = ONE_HOUR * 24\n\nCURSOR_LINK_HEADER = (\n    '<{uri}&cursor={cursor}>; rel=\"{name}\"; results=\"{has_results}\"; cursor=\"{cursor}\"'\n)\n\nDEFAULT_AUTHENTICATION = (\n    TokenAuthentication,\n    OrgAuthTokenAuthentication,\n    ApiKeyAuthentication,\n    SessionAuthentication,\n)\n\nlogger = logging.getLogger(__name__)\naudit_logger = logging.getLogger(\"sentry.audit.api\")\napi_access_logger = logging.getLogger(\"sentry.access.api\")\n\n\ndef allow_cors_options(func):\n    \"\"\"\n    Decorator that adds automatic handling of OPTIONS requests for CORS\n\n    If the request is OPTIONS (i.e. pre flight CORS) construct a OK (200) response\n    in which we explicitly enable the caller and add the custom headers that we support\n    For other requests just add the appropriate CORS headers\n\n    :param func: the original request handler\n    :return: a request handler that shortcuts OPTIONS requests and just returns an OK (CORS allowed)\n    \"\"\"\n\n    @functools.wraps(func)\n    def allow_cors_options_wrapper(self, request: Request, *args, **kwargs):\n        if request.method == \"OPTIONS\":\n            response = HttpResponse(status=200)\n            response[\"Access-Control-Max-Age\"] = \"3600\"  # don't ask for options again for 1 hour\n        else:\n            response = func(self, request, *args, **kwargs)\n\n        allow = \", \".join(self._allowed_methods())\n        response[\"Allow\"] = allow\n        response[\"Access-Control-Allow-Methods\"] = allow\n        response[\"Access-Control-Allow-Headers\"] = (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        response[\"Access-Control-Expose-Headers\"] = \"X-Sentry-Error, Retry-After\"\n\n        if request.META.get(\"HTTP_ORIGIN\") == \"null\":\n            origin = \"null\"  # if ORIGIN header is explicitly specified as 'null' leave it alone\n        else:\n            origin = origin_from_request(request)\n\n        if origin is None or origin == \"null\":\n            response[\"Access-Control-Allow-Origin\"] = \"*\"\n        else:\n            response[\"Access-Control-Allow-Origin\"] = origin\n\n        # If the requesting origin is a subdomain of\n        # the application's base-hostname we should allow cookies\n        # to be sent.\n        basehost = options.get(\"system.base-hostname\")\n        if basehost and origin:\n            if origin.endswith(basehost):\n                response[\"Access-Control-Allow-Credentials\"] = \"true\"\n\n        return response\n\n    return allow_cors_options_wrapper\n\n\nclass Endpoint(APIView):\n    # Note: the available renderer and parser classes can be found in conf/server.py.\n    authentication_classes: Tuple[Type[BaseAuthentication], ...] = DEFAULT_AUTHENTICATION\n    permission_classes: Tuple[Type[BasePermission], ...] = (NoPermission,)\n\n    cursor_name = \"cursor\"\n\n    public: Optional[HTTP_METHODS_SET] = None\n\n    rate_limits: RateLimitConfig | dict[\n        str, dict[RateLimitCategory, RateLimit]\n    ] = DEFAULT_RATE_LIMIT_CONFIG\n    enforce_rate_limit: bool = settings.SENTRY_RATELIMITER_ENABLED\n\n    def get_authenticators(self) -> List[BaseAuthentication]:\n        \"\"\"\n        Instantiates and returns the list of authenticators that this view can use.\n        Aggregates together authenticators that should be called cross silo, while\n        leaving methods that should be run locally.\n        \"\"\"\n\n        # TODO: Increase test coverage and get this working for monolith mode.\n        if SiloMode.get_current_mode() == SiloMode.MONOLITH:\n            return super().get_authenticators()\n\n        last_api_authenticator = RpcAuthentication([])\n        result: List[BaseAuthentication] = []\n        for authenticator_cls in self.authentication_classes:\n            auth_type = RpcAuthenticatorType.from_authenticator(authenticator_cls)\n            if auth_type is not None:\n                last_api_authenticator.types.append(auth_type)\n            else:\n                if last_api_authenticator.types:\n                    result.append(last_api_authenticator)\n                    last_api_authenticator = RpcAuthentication([])\n                result.append(authenticator_cls())\n\n        if last_api_authenticator.types:\n            result.append(last_api_authenticator)\n        return result\n\n    def build_link_header(self, request: Request, path: str, rel: str):\n        # TODO(dcramer): it would be nice to expand this to support params to consolidate `build_cursor_link`\n        uri = request.build_absolute_uri(urlquote(path))\n        return f'<{uri}>; rel=\"{rel}\">'\n\n    def build_cursor_link(self, request: Request, name: str, cursor: Cursor):\n        querystring = None\n        if request.GET.get(\"cursor\") is None:\n            querystring = request.GET.urlencode()\n        else:\n            mutable_query_dict = request.GET.copy()\n            mutable_query_dict.pop(\"cursor\")\n            querystring = mutable_query_dict.urlencode()\n\n        base_url = request.build_absolute_uri(urlquote(request.path))\n\n        if querystring is not None:\n            base_url = f\"{base_url}?{querystring}\"\n        else:\n            base_url = base_url + \"?\"\n\n        return CURSOR_LINK_HEADER.format(\n            uri=base_url,\n            cursor=str(cursor),\n            name=name,\n            has_results=\"true\" if bool(cursor) else \"false\",\n        )\n\n    def convert_args(self, request: Request, *args, **kwargs):\n        return (args, kwargs)\n\n    def handle_exception(\n        self,\n        request: Request,\n        exc: Exception,\n        handler_context: Mapping[str, Any] | None = None,\n        scope: Scope | None = None,\n    ) -> Response:\n        \"\"\"\n        Handle exceptions which arise while processing incoming API requests.\n\n        :param request:          The incoming request.\n        :param exc:              The exception raised during handling.\n        :param handler_context:  (Optional) Extra data which will be attached to the event sent to\n                                 Sentry, under the \"Request Handler Data\" heading.\n        :param scope:            (Optional) A `Scope` object containing extra data which will be\n                                 attached to the event sent to Sentry.\n\n        :returns: A 500 response including the event id of the captured Sentry event.\n        \"\"\"\n        try:\n            # Django REST Framework's built-in exception handler. If `settings.EXCEPTION_HANDLER`\n            # exists and returns a response, that's used. Otherwise, `exc` is just re-raised\n            # and caught below.\n            response = super().handle_exception(exc)\n        except Exception as err:\n            import sys\n            import traceback\n\n            sys.stderr.write(traceback.format_exc())\n\n            scope = scope or sentry_sdk.Scope()\n            if handler_context:\n                merge_context_into_scope(\"Request Handler Data\", handler_context, scope)\n            event_id = capture_exception(err, scope=scope)\n\n            response_body = {\"detail\": \"Internal Error\", \"errorId\": event_id}\n            response = Response(response_body, status=500)\n            response.exception = True\n\n        return response\n\n    def create_audit_entry(self, request: Request, transaction_id=None, **kwargs):\n        return create_audit_entry(request, transaction_id, audit_logger, **kwargs)\n\n    def load_json_body(self, request: Request):\n        \"\"\"\n        Attempts to load the request body when it's JSON.\n\n        The end result is ``request.json_body`` having a value. When it can't\n        load the body as JSON, for any reason, ``request.json_body`` is None.\n\n        The request flow is unaffected and no exceptions are ever raised.\n        \"\"\"\n\n        request.json_body = None\n\n        if not request.META.get(\"CONTENT_TYPE\", \"\").startswith(\"application/json\"):\n            return\n\n        if not len(request.body):\n            return\n\n        try:\n            request.json_body = json.loads(request.body)\n        except json.JSONDecodeError:\n            return\n\n    def initialize_request(self, request: Request, *args, **kwargs):\n        # XXX: Since DRF 3.x, when the request is passed into\n        # `initialize_request` it's set as an internal variable on the returned\n        # request. Then when we call `rv.auth` it attempts to authenticate,\n        # fails and sets `user` and `auth` to None on the internal request. We\n        # keep track of these here and reassign them as needed.\n        orig_auth = getattr(request, \"auth\", None)\n        orig_user = getattr(request, \"user\", None)\n        rv = super().initialize_request(request, *args, **kwargs)\n        # If our request is being made via our internal API client, we need to\n        # stitch back on auth and user information\n        if getattr(request, \"__from_api_client__\", False):\n            if rv.auth is None:\n                rv.auth = orig_auth\n            if rv.user is None:\n                rv.user = orig_user\n        return rv\n\n    @csrf_exempt\n    @allow_cors_options\n    def dispatch(self, request: Request, *args, **kwargs) -> Response:\n        \"\"\"\n        Identical to rest framework's dispatch except we add the ability\n        to convert arguments (for common URL params).\n        \"\"\"\n        with sentry_sdk.start_span(op=\"base.dispatch.setup\", description=type(self).__name__):\n            self.args = args\n            self.kwargs = kwargs\n            request = self.initialize_request(request, *args, **kwargs)\n            self.load_json_body(request)\n            self.request = request\n            self.headers = self.default_response_headers  # deprecate?\n\n        # Tags that will ultimately flow into the metrics backend at the end of\n        # the request (happens via middleware/stats.py).\n        request._metric_tags = {}\n\n        start_time = time.time()\n\n        origin = request.META.get(\"HTTP_ORIGIN\", \"null\")\n        # A \"null\" value should be treated as no Origin for us.\n        # See RFC6454 for more information on this behavior.\n        if origin == \"null\":\n            origin = None\n\n        try:\n            with sentry_sdk.start_span(op=\"base.dispatch.request\", description=type(self).__name__):\n                if origin:\n                    if request.auth:\n                        allowed_origins = request.auth.get_allowed_origins()\n                    else:\n                        allowed_origins = None\n                    if not is_valid_origin(origin, allowed=allowed_origins):\n                        response = Response(f\"Invalid origin: {origin}\", status=400)\n                        self.response = self.finalize_response(request, response, *args, **kwargs)\n                        return self.response\n\n                self.initial(request, *args, **kwargs)\n\n                # Get the appropriate handler method\n                method = request.method.lower()\n                if method in self.http_method_names and hasattr(self, method):\n                    handler = getattr(self, method)\n\n                    # Only convert args when using defined handlers\n                    (args, kwargs) = self.convert_args(request, *args, **kwargs)\n                    self.args = args\n                    self.kwargs = kwargs\n                else:\n                    handler = self.http_method_not_allowed\n\n                if getattr(request, \"access\", None) is None:\n                    # setup default access\n                    request.access = access.from_request(request)\n\n            with sentry_sdk.start_span(\n                op=\"base.dispatch.execute\",\n                description=f\"{type(self).__name__}.{handler.__name__}\",\n            ):\n                response = handler(request, *args, **kwargs)\n\n        except Exception as exc:\n            response = self.handle_exception(request, exc)\n\n        if origin:\n            self.add_cors_headers(request, response)\n\n        self.response = self.finalize_response(request, response, *args, **kwargs)\n\n        if settings.SENTRY_API_RESPONSE_DELAY:\n            duration = time.time() - start_time\n\n            if duration < (settings.SENTRY_API_RESPONSE_DELAY / 1000.0):\n                with sentry_sdk.start_span(\n                    op=\"base.dispatch.sleep\",\n                    description=type(self).__name__,\n                ) as span:\n                    span.set_data(\"SENTRY_API_RESPONSE_DELAY\", settings.SENTRY_API_RESPONSE_DELAY)\n                    time.sleep(settings.SENTRY_API_RESPONSE_DELAY / 1000.0 - duration)\n\n        return self.response\n\n    def add_cors_headers(self, request: Request, response):\n        response[\"Access-Control-Allow-Origin\"] = request.META[\"HTTP_ORIGIN\"]\n        response[\"Access-Control-Allow-Methods\"] = \", \".join(self.http_method_names)\n\n    def add_cursor_headers(self, request: Request, response, cursor_result):\n        if cursor_result.hits is not None:\n            response[\"X-Hits\"] = cursor_result.hits\n        if cursor_result.max_hits is not None:\n            response[\"X-Max-Hits\"] = cursor_result.max_hits\n        response[\"Link\"] = \", \".join(\n            [\n                self.build_cursor_link(request, \"previous\", cursor_result.prev),\n                self.build_cursor_link(request, \"next\", cursor_result.next),\n            ]\n        )\n\n    def respond(self, context: Mapping[str, Any] | None = None, **kwargs: Any) -> Response:\n        return Response(context, **kwargs)\n\n    def respond_with_text(self, text):\n        return self.respond({\"text\": text})\n\n    def get_per_page(self, request: Request, default_per_page=100, max_per_page=100):\n        try:\n            return clamp_pagination_per_page(\n                request.GET.get(\"per_page\", default_per_page),\n                default_per_page=default_per_page,\n                max_per_page=max_per_page,\n            )\n        except ValueError as e:\n            raise ParseError(detail=str(e))\n\n    def get_cursor_from_request(self, request: Request, cursor_cls=Cursor):\n        try:\n            return get_cursor(request.GET.get(self.cursor_name), cursor_cls)\n        except ValueError as e:\n            raise ParseError(detail=str(e))\n\n    def paginate(\n        self,\n        request,\n        on_results=None,\n        paginator=None,\n        paginator_cls=Paginator,\n        default_per_page=100,\n        max_per_page=100,\n        cursor_cls=Cursor,\n        response_cls=Response,\n        response_kwargs=None,\n        count_hits=None,\n        **paginator_kwargs,\n    ):\n        # XXX(epurkhiser): This is an experiment that overrides all paginated\n        # API requests so that we can more easily debug on the frontend the\n        # experiemce customers have when they have lots of entites.\n        override_limit = request.COOKIES.get(\"__sentry_dev_pagination_limit\", None)\n        if override_limit is not None:\n            default_per_page = int(override_limit)\n            max_per_page = int(override_limit)\n\n        try:\n            per_page = self.get_per_page(request, default_per_page, max_per_page)\n            cursor = self.get_cursor_from_request(request, cursor_cls)\n            with sentry_sdk.start_span(\n                op=\"base.paginate.get_result\",\n                description=type(self).__name__,\n            ) as span:\n                annotate_span_with_pagination_args(span, per_page)\n                paginator = get_paginator(paginator, paginator_cls, paginator_kwargs)\n                result_args = dict(count_hits=count_hits) if count_hits is not None else dict()\n                cursor_result = paginator.get_result(\n                    limit=per_page,\n                    cursor=cursor,\n                    **result_args,\n                )\n        except BadPaginationError as e:\n            raise ParseError(detail=str(e))\n\n        if response_kwargs is None:\n            response_kwargs = {}\n\n        # map results based on callback\n        if on_results:\n            with sentry_sdk.start_span(\n                op=\"base.paginate.on_results\",\n                description=type(self).__name__,\n            ):\n                results = on_results(cursor_result.results)\n        else:\n            results = cursor_result.results\n\n        response = response_cls(results, **response_kwargs)\n        self.add_cursor_headers(request, response, cursor_result)\n        return response\n\n\nclass EnvironmentMixin:\n    def _get_environment_func(self, request: Request, organization_id):\n        \"\"\"\\\n        Creates a function that when called returns the ``Environment``\n        associated with a request object, or ``None`` if no environment was\n        provided. If the environment doesn't exist, an ``Environment.DoesNotExist``\n        exception will be raised.\n\n        This returns as a callable since some objects outside of the API\n        endpoint need to handle the \"environment was provided but does not\n        exist\" state in addition to the two non-exceptional states (the\n        environment was provided and exists, or the environment was not\n        provided.)\n        \"\"\"\n        return functools.partial(self._get_environment_from_request, request, organization_id)\n\n    def _get_environment_id_from_request(self, request: Request, organization_id):\n        environment = self._get_environment_from_request(request, organization_id)\n        return environment and environment.id\n\n    def _get_environment_from_request(self, request: Request, organization_id):\n        if not hasattr(request, \"_cached_environment\"):\n            environment_param = request.GET.get(\"environment\")\n            if environment_param is None:\n                environment = None\n            else:\n                environment = Environment.get_for_organization_id(\n                    name=environment_param, organization_id=organization_id\n                )\n\n            request._cached_environment = environment\n\n        return request._cached_environment\n\n\nclass StatsMixin:\n    def _parse_args(self, request: Request, environment_id=None, restrict_rollups=True):\n        \"\"\"\n        Parse common stats parameters from the query string. This includes\n        `since`, `until`, and `resolution`.\n\n        :param boolean restrict_rollups: When False allows any rollup value to\n        be specified. Be careful using this as this allows for fine grain\n        rollups that may put strain on the system.\n        \"\"\"\n        try:\n            resolution = request.GET.get(\"resolution\")\n            if resolution:\n                resolution = self._parse_resolution(resolution)\n                if restrict_rollups and resolution not in tsdb.get_rollups():\n                    raise ValueError\n        except ValueError:\n            raise ParseError(detail=\"Invalid resolution\")\n\n        try:\n            end = request.GET.get(\"until\")\n            if end:\n                end = to_datetime(float(end))\n            else:\n                end = datetime.utcnow().replace(tzinfo=utc)\n        except ValueError:\n            raise ParseError(detail=\"until must be a numeric timestamp.\")\n\n        try:\n            start = request.GET.get(\"since\")\n            if start:\n                start = to_datetime(float(start))\n                assert start <= end\n            else:\n                start = end - timedelta(days=1, seconds=-1)\n        except ValueError:\n            raise ParseError(detail=\"since must be a numeric timestamp\")\n        except AssertionError:\n            raise ParseError(detail=\"start must be before or equal to end\")\n\n        if not resolution:\n            resolution = tsdb.get_optimal_rollup(start, end)\n\n        return {\n            \"start\": start,\n            \"end\": end,\n            \"rollup\": resolution,\n            \"environment_ids\": environment_id and [environment_id],\n        }\n\n    def _parse_resolution(self, value):\n        if value.endswith(\"h\"):\n            return int(value[:-1]) * ONE_HOUR\n        elif value.endswith(\"d\"):\n            return int(value[:-1]) * ONE_DAY\n        elif value.endswith(\"m\"):\n            return int(value[:-1]) * ONE_MINUTE\n        elif value.endswith(\"s\"):\n            return int(value[:-1])\n        else:\n            raise ValueError(value)\n\n\nclass ReleaseAnalyticsMixin:\n    def track_set_commits_local(self, request: Request, organization_id=None, project_ids=None):\n        analytics.record(\n            \"release.set_commits_local\",\n            user_id=request.user.id if request.user and request.user.id else None,\n            organization_id=organization_id,\n            project_ids=project_ids,\n            user_agent=request.META.get(\"HTTP_USER_AGENT\", \"\"),\n        )\n\n\ndef resolve_region(request: Request):\n    subdomain = getattr(request, \"subdomain\", None)\n    if subdomain is None:\n        return None\n    if subdomain in {\"us\", \"eu\"}:\n        return subdomain\n    return None\n\n\nclass EndpointSiloLimit(SiloLimit):\n    def modify_endpoint_class(self, decorated_class: Type[Endpoint]) -> type:\n        dispatch_override = self.create_override(decorated_class.dispatch)\n        new_class = type(\n            decorated_class.__name__,\n            (decorated_class,),\n            {\n                \"dispatch\": dispatch_override,\n                \"silo_limit\": self,\n            },\n        )\n        new_class.__module__ = decorated_class.__module__\n        return new_class\n\n    def create_override(\n        self,\n        original_method: Callable[..., Any],\n    ) -> Callable[..., Any]:\n        limiting_override = super().create_override(original_method)\n\n        def single_process_silo_mode_wrapper(*args: Any, **kwargs: Any) -> Any:\n            if SiloMode.single_process_silo_mode():\n                entering_mode: SiloMode = SiloMode.MONOLITH\n                for mode in self.modes:\n                    # Select a mode, if available, from the target modes.\n                    entering_mode = mode\n                with SiloMode.enter_single_process_silo_context(entering_mode):\n                    return limiting_override(*args, **kwargs)\n            else:\n                return limiting_override(*args, **kwargs)\n\n        functools.update_wrapper(single_process_silo_mode_wrapper, limiting_override)\n        return single_process_silo_mode_wrapper\n\n    def modify_endpoint_method(self, decorated_method: Callable[..., Any]) -> Callable[..., Any]:\n        return self.create_override(decorated_method)\n\n    def handle_when_unavailable(\n        self,\n        original_method: Callable[..., Any],\n        current_mode: SiloMode,\n        available_modes: Iterable[SiloMode],\n    ) -> Callable[..., Any]:\n        def handle(obj: Any, request: Request, *args: Any, **kwargs: Any) -> HttpResponse:\n            mode_str = \", \".join(str(m) for m in available_modes)\n            message = (\n                f\"Received {request.method} request at {request.path!r} to server in \"\n                f\"{current_mode} mode. This endpoint is available only in: {mode_str}\"\n            )\n            if settings.FAIL_ON_UNAVAILABLE_API_CALL:\n                raise self.AvailabilityError(message)\n            else:\n                logger.warning(message)\n                return HttpResponse(status=status.HTTP_404_NOT_FOUND)\n\n        return handle\n\n    def __call__(self, decorated_obj: Any) -> Any:\n        if isinstance(decorated_obj, type):\n            if not issubclass(decorated_obj, Endpoint):\n                raise ValueError(\"`@EndpointSiloLimit` can decorate only Endpoint subclasses\")\n            return self.modify_endpoint_class(decorated_obj)\n\n        if callable(decorated_obj):\n            return self.modify_endpoint_method(decorated_obj)\n\n        raise TypeError(\"`@EndpointSiloLimit` must decorate a class or method\")\n\n\ncontrol_silo_endpoint = EndpointSiloLimit(SiloMode.CONTROL)\nregion_silo_endpoint = EndpointSiloLimit(SiloMode.REGION)\n\n# Use this decorator to mark endpoints that still need to be marked as either\n# control_silo_endpoint or region_silo_endpoint. Marking a class with\n# pending_silo_endpoint keeps it from tripping SiloLimitCoverageTest, while ensuring\n# that the test will fail if a new endpoint is added with no decorator at all.\n# Eventually we should replace all instances of this decorator and delete it.\npending_silo_endpoint = EndpointSiloLimit()\n\n# This should be rarely used, but this should be used for any endpoints that exist in any silo mode.\nall_silo_endpoint = EndpointSiloLimit(SiloMode.CONTROL, SiloMode.REGION, SiloMode.MONOLITH)\n", "import base64\nfrom unittest import mock\nfrom unittest.mock import MagicMock\n\nfrom django.http import HttpRequest, QueryDict, StreamingHttpResponse\nfrom django.test import override_settings\nfrom pytest import raises\nfrom rest_framework.response import Response\nfrom sentry_sdk import Scope\nfrom sentry_sdk.utils import exc_info_from_error\n\nfrom sentry.api.base import Endpoint, EndpointSiloLimit, resolve_region\nfrom sentry.api.paginator import GenericOffsetPaginator\nfrom sentry.models import ApiKey\nfrom sentry.services.hybrid_cloud.util import FunctionSiloLimit\nfrom sentry.silo import SiloMode\nfrom sentry.testutils import APITestCase\nfrom sentry.testutils.helpers.options import override_options\nfrom sentry.utils.cursors import Cursor\n\n\n# Though it looks weird to have a method outside a class, this isn't a mistake but rather\n# a mock for a method in Django REST Framework's `APIView` class\ndef reraise(self, e: Exception):\n    raise e\n\n\nclass DummyEndpoint(Endpoint):\n    permission_classes = ()\n\n    def get(self, request):\n        return Response({\"ok\": True})\n\n\nclass DummyErroringEndpoint(Endpoint):\n    permission_classes = ()\n    # `as_view` requires that any init args passed to it match attributes already on the\n    # class, so even though they're really meant to be instance attributes, we have to\n    # add them here as class attributes first\n    error = None\n    handler_context_arg = None\n    scope_arg = None\n\n    def __init__(\n        self,\n        *args,\n        error: Exception,\n        handler_context_arg=None,\n        scope_arg=None,\n        **kwargs,\n    ):\n        # The error which will be thrown when a GET request is made\n        self.error = error\n        # The argumets which will be passed on to `Endpoint.handle_exception` via `super`\n        self.handler_context_arg = handler_context_arg\n        self.scope_arg = scope_arg\n\n        super().__init__(*args, **kwargs)\n\n    def get(self, request):\n        raise self.error\n\n    def handle_exception(self, request, exc, handler_context=None, scope=None):\n        return super().handle_exception(request, exc, self.handler_context_arg, self.scope_arg)\n\n\nclass DummyPaginationEndpoint(Endpoint):\n    permission_classes = ()\n\n    def get(self, request):\n        values = [x for x in range(0, 100)]\n\n        def data_fn(offset, limit):\n            page_offset = offset * limit\n            return values[page_offset : page_offset + limit]\n\n        return self.paginate(\n            request=request,\n            paginator=GenericOffsetPaginator(data_fn),\n            on_results=lambda results: results,\n        )\n\n\n_dummy_endpoint = DummyEndpoint.as_view()\n\n\nclass DummyPaginationStreamingEndpoint(Endpoint):\n    permission_classes = ()\n\n    def get(self, request):\n        values = [x for x in range(0, 100)]\n\n        def data_fn(offset, limit):\n            page_offset = offset * limit\n            return values[page_offset : page_offset + limit]\n\n        return self.paginate(\n            request=request,\n            paginator=GenericOffsetPaginator(data_fn),\n            on_results=lambda results: iter(results),\n            response_cls=StreamingHttpResponse,\n            response_kwargs={\"content_type\": \"application/json\"},\n        )\n\n\n_dummy_streaming_endpoint = DummyPaginationStreamingEndpoint.as_view()\n\n\nclass EndpointTest(APITestCase):\n    def test_basic_cors(self):\n        org = self.create_organization()\n        apikey = ApiKey.objects.create(organization_id=org.id, allowed_origins=\"*\")\n\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n        request.META[\"HTTP_AUTHORIZATION\"] = b\"Basic \" + base64.b64encode(\n            apikey.key.encode(\"utf-8\")\n        )\n\n        response = _dummy_endpoint(request)\n        response.render()\n\n        assert response.status_code == 200, response.content\n\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://example.com\"\n        assert response[\"Access-Control-Allow-Headers\"] == (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        assert response[\"Access-Control-Expose-Headers\"] == \"X-Sentry-Error, Retry-After\"\n        assert response[\"Access-Control-Allow-Methods\"] == \"GET, HEAD, OPTIONS\"\n        assert \"Access-Control-Allow-Credentials\" not in response\n\n    @override_options({\"system.base-hostname\": \"example.com\"})\n    def test_allow_credentials(self):\n        org = self.create_organization()\n        apikey = ApiKey.objects.create(organization_id=org.id, allowed_origins=\"*\")\n\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://acme.example.com\"\n        request.META[\"HTTP_AUTHORIZATION\"] = b\"Basic \" + base64.b64encode(\n            apikey.key.encode(\"utf-8\")\n        )\n\n        response = _dummy_endpoint(request)\n        response.render()\n\n        assert response.status_code == 200, response.content\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://acme.example.com\"\n        assert response[\"Access-Control-Allow-Headers\"] == (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        assert response[\"Access-Control-Expose-Headers\"] == \"X-Sentry-Error, Retry-After\"\n        assert response[\"Access-Control-Allow-Methods\"] == \"GET, HEAD, OPTIONS\"\n        assert response[\"Access-Control-Allow-Credentials\"] == \"true\"\n\n    @override_options({\"system.base-hostname\": \"acme.com\"})\n    def test_allow_credentials_incorrect(self):\n        org = self.create_organization()\n        apikey = ApiKey.objects.create(organization_id=org.id, allowed_origins=\"*\")\n\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://acme.example.com\"\n        request.META[\"HTTP_AUTHORIZATION\"] = b\"Basic \" + base64.b64encode(\n            apikey.key.encode(\"utf-8\")\n        )\n\n        response = _dummy_endpoint(request)\n        response.render()\n        assert \"Access-Control-Allow-Credentials\" not in response\n\n    def test_invalid_cors_without_auth(self):\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n\n        with self.settings(SENTRY_ALLOW_ORIGIN=\"https://sentry.io\"):\n            response = _dummy_endpoint(request)\n            response.render()\n\n        assert response.status_code == 400, response.content\n\n    def test_valid_cors_without_auth(self):\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n\n        with self.settings(SENTRY_ALLOW_ORIGIN=\"*\"):\n            response = _dummy_endpoint(request)\n            response.render()\n\n        assert response.status_code == 200, response.content\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://example.com\"\n\n    # XXX(dcramer): The default setting needs to allow requests to work or it will be a regression\n    def test_cors_not_configured_is_valid(self):\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n\n        with self.settings(SENTRY_ALLOW_ORIGIN=None):\n            response = _dummy_endpoint(request)\n            response.render()\n\n        assert response.status_code == 200, response.content\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://example.com\"\n        assert response[\"Access-Control-Allow-Headers\"] == (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        assert response[\"Access-Control-Expose-Headers\"] == \"X-Sentry-Error, Retry-After\"\n        assert response[\"Access-Control-Allow-Methods\"] == \"GET, HEAD, OPTIONS\"\n\n    @mock.patch(\"sentry.api.base.Endpoint.convert_args\")\n    def test_method_not_allowed(self, mock_convert_args):\n        request = self.make_request(method=\"POST\")\n        response = _dummy_endpoint(request)\n        response.render()\n\n        assert response.status_code == 405, response.content\n\n        # did not try to convert args\n        assert not mock_convert_args.info.called\n\n\nclass EndpointHandleExceptionTest(APITestCase):\n    @mock.patch(\"rest_framework.views.APIView.handle_exception\", return_value=Response(status=500))\n    def test_handle_exception_when_super_returns_response(\n        self, mock_super_handle_exception: MagicMock\n    ):\n        mock_endpoint = DummyErroringEndpoint.as_view(error=Exception(\"nope\"))\n        response = mock_endpoint(self.make_request(method=\"GET\"))\n\n        # The endpoint should pass along the response generated by `APIView.handle_exception`\n        assert response == mock_super_handle_exception.return_value\n\n    @mock.patch(\"rest_framework.views.APIView.handle_exception\", new=reraise)\n    @mock.patch(\"sentry.api.base.capture_exception\", return_value=\"1231201211212012\")\n    def test_handle_exception_when_super_reraises(\n        self,\n        mock_capture_exception: MagicMock,\n    ):\n        handler_context = {\"api_request_URL\": \"http://dogs.are.great/\"}\n        scope = Scope()\n        tags = {\"maisey\": \"silly\", \"charlie\": \"goofy\"}\n        for tag, value in tags.items():\n            scope.set_tag(tag, value)\n\n        cases = [\n            # The first half of each tuple is what's passed to `handle_exception`, and the second\n            # half is what we expect in the scope passed to `capture_exception`\n            (None, None, {}, {}),\n            (handler_context, None, {\"Request Handler Data\": handler_context}, {}),\n            (None, scope, {}, tags),\n            (\n                handler_context,\n                scope,\n                {\"Request Handler Data\": handler_context},\n                tags,\n            ),\n        ]\n\n        for handler_context_arg, scope_arg, expected_scope_contexts, expected_scope_tags in cases:\n            handler_error = Exception(\"nope\")\n            mock_endpoint = DummyErroringEndpoint.as_view(\n                error=handler_error,\n                handler_context_arg=handler_context_arg,\n                scope_arg=scope_arg,\n            )\n\n            with mock.patch(\"sys.exc_info\", return_value=exc_info_from_error(handler_error)):\n                with mock.patch(\"sys.stderr.write\") as mock_stderr_write:\n                    response = mock_endpoint(self.make_request(method=\"GET\"))\n\n                    assert response.status_code == 500\n                    assert response.data == {\n                        \"detail\": \"Internal Error\",\n                        \"errorId\": \"1231201211212012\",\n                    }\n                    assert response.exception is True\n\n                    mock_stderr_write.assert_called_with(\"Exception: nope\\n\")\n\n                    capture_exception_handler_context_arg = mock_capture_exception.call_args.args[0]\n                    capture_exception_scope_kwarg = mock_capture_exception.call_args.kwargs.get(\n                        \"scope\"\n                    )\n\n                    assert capture_exception_handler_context_arg == handler_error\n                    assert isinstance(capture_exception_scope_kwarg, Scope)\n                    assert capture_exception_scope_kwarg._contexts == expected_scope_contexts\n                    assert capture_exception_scope_kwarg._tags == expected_scope_tags\n\n\nclass CursorGenerationTest(APITestCase):\n    def test_serializes_params(self):\n        request = self.make_request(method=\"GET\", path=\"/api/0/organizations/\")\n        request.GET = QueryDict(\"member=1&cursor=foo\")\n        endpoint = Endpoint()\n        result = endpoint.build_cursor_link(request, \"next\", \"1492107369532:0:0\")\n\n        assert result == (\n            \"<http://testserver/api/0/organizations/?member=1&cursor=1492107369532:0:0>;\"\n            ' rel=\"next\"; results=\"true\"; cursor=\"1492107369532:0:0\"'\n        )\n\n    def test_unicode_path(self):\n        request = self.make_request(method=\"GET\", path=\"/api/0/organizations/\u00fcuuuu/\")\n        endpoint = Endpoint()\n        result = endpoint.build_cursor_link(request, \"next\", \"1492107369532:0:0\")\n\n        assert result == (\n            \"<http://testserver/api/0/organizations/%C3%BCuuuu/?&cursor=1492107369532:0:0>;\"\n            ' rel=\"next\"; results=\"true\"; cursor=\"1492107369532:0:0\"'\n        )\n\n    def test_encodes_url(self):\n        endpoint = Endpoint()\n        request = self.make_request(method=\"GET\", path=\"/foo/bar/lol:what/\")\n\n        result = endpoint.build_cursor_link(request, \"next\", cursor=Cursor(0, 0, 0))\n        assert (\n            result\n            == '<http://testserver/foo/bar/lol%3Awhat/?&cursor=0:0:0>; rel=\"next\"; results=\"false\"; cursor=\"0:0:0\"'\n        )\n\n\nclass PaginateTest(APITestCase):\n    def setUp(self):\n        super().setUp()\n        self.request = self.make_request(method=\"GET\")\n        self.view = DummyPaginationEndpoint().as_view()\n\n    def test_success(self):\n        response = self.view(self.request)\n        assert response.status_code == 200, response.content\n        assert (\n            response[\"Link\"]\n            == '<http://testserver/?&cursor=0:0:1>; rel=\"previous\"; results=\"false\"; cursor=\"0:0:1\", <http://testserver/?&cursor=0:100:0>; rel=\"next\"; results=\"false\"; cursor=\"0:100:0\"'\n        )\n\n    def test_invalid_per_page(self):\n        self.request.GET = {\"per_page\": \"nope\"}\n        response = self.view(self.request)\n        assert response.status_code == 400\n\n    def test_invalid_cursor(self):\n        self.request.GET = {\"cursor\": \"no:no:no\"}\n        response = self.view(self.request)\n        assert response.status_code == 400\n\n    def test_per_page_out_of_bounds(self):\n        self.request.GET = {\"per_page\": \"101\"}\n        response = self.view(self.request)\n        assert response.status_code == 400\n\n    def test_custom_response_type(self):\n        response = _dummy_streaming_endpoint(self.request)\n        assert response.status_code == 200\n        assert type(response) == StreamingHttpResponse\n        assert response.has_header(\"content-type\")\n\n\nclass EndpointJSONBodyTest(APITestCase):\n    def setUp(self):\n        super().setUp()\n\n        self.request = HttpRequest()\n        self.request.method = \"GET\"\n        self.request.META[\"CONTENT_TYPE\"] = \"application/json\"\n\n    def test_json(self):\n        self.request._body = '{\"foo\":\"bar\"}'\n\n        Endpoint().load_json_body(self.request)\n\n        assert self.request.json_body == {\"foo\": \"bar\"}\n\n    def test_invalid_json(self):\n        self.request._body = \"hello\"\n\n        Endpoint().load_json_body(self.request)\n\n        assert not self.request.json_body\n\n    def test_empty_request_body(self):\n        self.request._body = \"\"\n\n        Endpoint().load_json_body(self.request)\n\n        assert not self.request.json_body\n\n    def test_non_json_content_type(self):\n        self.request.META[\"CONTENT_TYPE\"] = \"text/plain\"\n\n        Endpoint().load_json_body(self.request)\n\n        assert not self.request.json_body\n\n\nclass CustomerDomainTest(APITestCase):\n    def test_resolve_region(self):\n        def request_with_subdomain(subdomain):\n            request = self.make_request(method=\"GET\")\n            request.subdomain = subdomain\n            return resolve_region(request)\n\n        assert request_with_subdomain(\"us\") == \"us\"\n        assert request_with_subdomain(\"eu\") == \"eu\"\n        assert request_with_subdomain(\"sentry\") is None\n\n\nclass EndpointSiloLimitTest(APITestCase):\n    def _test_active_on(self, endpoint_mode, active_mode, expect_to_be_active):\n        @EndpointSiloLimit(endpoint_mode)\n        class DecoratedEndpoint(DummyEndpoint):\n            pass\n\n        class EndpointWithDecoratedMethod(DummyEndpoint):\n            @EndpointSiloLimit(endpoint_mode)\n            def get(self, request):\n                return super().get(request)\n\n        with override_settings(SILO_MODE=active_mode):\n            request = self.make_request(method=\"GET\")\n\n            for endpoint_class in (DecoratedEndpoint, EndpointWithDecoratedMethod):\n                view = endpoint_class.as_view()\n                with override_settings(FAIL_ON_UNAVAILABLE_API_CALL=False):\n                    response = view(request)\n                    assert response.status_code == (200 if expect_to_be_active else 404)\n\n            if not expect_to_be_active:\n                with override_settings(FAIL_ON_UNAVAILABLE_API_CALL=True):\n                    with raises(EndpointSiloLimit.AvailabilityError):\n                        DecoratedEndpoint.as_view()(request)\n                    # TODO: Make work with EndpointWithDecoratedMethod\n\n    def test_with_active_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.REGION, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.CONTROL, True)\n\n    def test_with_inactive_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.CONTROL, False)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.REGION, False)\n\n    def test_with_monolith_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.MONOLITH, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.MONOLITH, True)\n\n\nclass FunctionSiloLimitTest(APITestCase):\n    def _test_active_on(self, endpoint_mode, active_mode, expect_to_be_active):\n        @FunctionSiloLimit(endpoint_mode)\n        def decorated_function():\n            pass\n\n        with override_settings(SILO_MODE=active_mode):\n            if expect_to_be_active:\n                decorated_function()\n            else:\n                with raises(ValueError):\n                    decorated_function()\n\n    def test_with_active_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.REGION, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.CONTROL, True)\n\n    def test_with_inactive_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.CONTROL, False)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.REGION, False)\n\n    def test_with_monolith_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.MONOLITH, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.MONOLITH, True)\n"], "fixing_code": ["from __future__ import annotations\n\nimport functools\nimport logging\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Any, Callable, Iterable, List, Mapping, Optional, Tuple, Type\nfrom urllib.parse import quote as urlquote\n\nimport sentry_sdk\nfrom django.conf import settings\nfrom django.http import HttpResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom pytz import utc\nfrom rest_framework import status\nfrom rest_framework.authentication import BaseAuthentication, SessionAuthentication\nfrom rest_framework.exceptions import ParseError\nfrom rest_framework.permissions import BasePermission\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom sentry_sdk import Scope\n\nfrom sentry import analytics, options, tsdb\nfrom sentry.apidocs.hooks import HTTP_METHODS_SET\nfrom sentry.auth import access\nfrom sentry.models import Environment\nfrom sentry.ratelimits.config import DEFAULT_RATE_LIMIT_CONFIG, RateLimitConfig\nfrom sentry.silo import SiloLimit, SiloMode\nfrom sentry.types.ratelimit import RateLimit, RateLimitCategory\nfrom sentry.utils import json\nfrom sentry.utils.audit import create_audit_entry\nfrom sentry.utils.cursors import Cursor\nfrom sentry.utils.dates import to_datetime\nfrom sentry.utils.http import is_valid_origin, origin_from_request\nfrom sentry.utils.sdk import capture_exception, merge_context_into_scope\n\nfrom .authentication import ApiKeyAuthentication, OrgAuthTokenAuthentication, TokenAuthentication\nfrom .paginator import BadPaginationError, Paginator\nfrom .permissions import NoPermission\n\n__all__ = [\n    \"Endpoint\",\n    \"EnvironmentMixin\",\n    \"StatsMixin\",\n    \"control_silo_endpoint\",\n    \"region_silo_endpoint\",\n    \"pending_silo_endpoint\",\n]\n\nfrom ..services.hybrid_cloud.auth import RpcAuthentication, RpcAuthenticatorType\nfrom ..utils.pagination_factory import (\n    annotate_span_with_pagination_args,\n    clamp_pagination_per_page,\n    get_cursor,\n    get_paginator,\n)\n\nONE_MINUTE = 60\nONE_HOUR = ONE_MINUTE * 60\nONE_DAY = ONE_HOUR * 24\n\nCURSOR_LINK_HEADER = (\n    '<{uri}&cursor={cursor}>; rel=\"{name}\"; results=\"{has_results}\"; cursor=\"{cursor}\"'\n)\n\nDEFAULT_AUTHENTICATION = (\n    TokenAuthentication,\n    OrgAuthTokenAuthentication,\n    ApiKeyAuthentication,\n    SessionAuthentication,\n)\n\nlogger = logging.getLogger(__name__)\naudit_logger = logging.getLogger(\"sentry.audit.api\")\napi_access_logger = logging.getLogger(\"sentry.access.api\")\n\n\ndef allow_cors_options(func):\n    \"\"\"\n    Decorator that adds automatic handling of OPTIONS requests for CORS\n\n    If the request is OPTIONS (i.e. pre flight CORS) construct a OK (200) response\n    in which we explicitly enable the caller and add the custom headers that we support\n    For other requests just add the appropriate CORS headers\n\n    :param func: the original request handler\n    :return: a request handler that shortcuts OPTIONS requests and just returns an OK (CORS allowed)\n    \"\"\"\n\n    @functools.wraps(func)\n    def allow_cors_options_wrapper(self, request: Request, *args, **kwargs):\n        if request.method == \"OPTIONS\":\n            response = HttpResponse(status=200)\n            response[\"Access-Control-Max-Age\"] = \"3600\"  # don't ask for options again for 1 hour\n        else:\n            response = func(self, request, *args, **kwargs)\n\n        allow = \", \".join(self._allowed_methods())\n        response[\"Allow\"] = allow\n        response[\"Access-Control-Allow-Methods\"] = allow\n        response[\"Access-Control-Allow-Headers\"] = (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        response[\"Access-Control-Expose-Headers\"] = \"X-Sentry-Error, Retry-After\"\n\n        if request.META.get(\"HTTP_ORIGIN\") == \"null\":\n            origin = \"null\"  # if ORIGIN header is explicitly specified as 'null' leave it alone\n        else:\n            origin = origin_from_request(request)\n\n        if origin is None or origin == \"null\":\n            response[\"Access-Control-Allow-Origin\"] = \"*\"\n        else:\n            response[\"Access-Control-Allow-Origin\"] = origin\n\n        # If the requesting origin is a subdomain of\n        # the application's base-hostname we should allow cookies\n        # to be sent.\n        basehost = options.get(\"system.base-hostname\")\n        if basehost and origin:\n            if origin.endswith((\"://\" + basehost, \".\" + basehost)):\n                response[\"Access-Control-Allow-Credentials\"] = \"true\"\n\n        return response\n\n    return allow_cors_options_wrapper\n\n\nclass Endpoint(APIView):\n    # Note: the available renderer and parser classes can be found in conf/server.py.\n    authentication_classes: Tuple[Type[BaseAuthentication], ...] = DEFAULT_AUTHENTICATION\n    permission_classes: Tuple[Type[BasePermission], ...] = (NoPermission,)\n\n    cursor_name = \"cursor\"\n\n    public: Optional[HTTP_METHODS_SET] = None\n\n    rate_limits: RateLimitConfig | dict[\n        str, dict[RateLimitCategory, RateLimit]\n    ] = DEFAULT_RATE_LIMIT_CONFIG\n    enforce_rate_limit: bool = settings.SENTRY_RATELIMITER_ENABLED\n\n    def get_authenticators(self) -> List[BaseAuthentication]:\n        \"\"\"\n        Instantiates and returns the list of authenticators that this view can use.\n        Aggregates together authenticators that should be called cross silo, while\n        leaving methods that should be run locally.\n        \"\"\"\n\n        # TODO: Increase test coverage and get this working for monolith mode.\n        if SiloMode.get_current_mode() == SiloMode.MONOLITH:\n            return super().get_authenticators()\n\n        last_api_authenticator = RpcAuthentication([])\n        result: List[BaseAuthentication] = []\n        for authenticator_cls in self.authentication_classes:\n            auth_type = RpcAuthenticatorType.from_authenticator(authenticator_cls)\n            if auth_type is not None:\n                last_api_authenticator.types.append(auth_type)\n            else:\n                if last_api_authenticator.types:\n                    result.append(last_api_authenticator)\n                    last_api_authenticator = RpcAuthentication([])\n                result.append(authenticator_cls())\n\n        if last_api_authenticator.types:\n            result.append(last_api_authenticator)\n        return result\n\n    def build_link_header(self, request: Request, path: str, rel: str):\n        # TODO(dcramer): it would be nice to expand this to support params to consolidate `build_cursor_link`\n        uri = request.build_absolute_uri(urlquote(path))\n        return f'<{uri}>; rel=\"{rel}\">'\n\n    def build_cursor_link(self, request: Request, name: str, cursor: Cursor):\n        querystring = None\n        if request.GET.get(\"cursor\") is None:\n            querystring = request.GET.urlencode()\n        else:\n            mutable_query_dict = request.GET.copy()\n            mutable_query_dict.pop(\"cursor\")\n            querystring = mutable_query_dict.urlencode()\n\n        base_url = request.build_absolute_uri(urlquote(request.path))\n\n        if querystring is not None:\n            base_url = f\"{base_url}?{querystring}\"\n        else:\n            base_url = base_url + \"?\"\n\n        return CURSOR_LINK_HEADER.format(\n            uri=base_url,\n            cursor=str(cursor),\n            name=name,\n            has_results=\"true\" if bool(cursor) else \"false\",\n        )\n\n    def convert_args(self, request: Request, *args, **kwargs):\n        return (args, kwargs)\n\n    def handle_exception(\n        self,\n        request: Request,\n        exc: Exception,\n        handler_context: Mapping[str, Any] | None = None,\n        scope: Scope | None = None,\n    ) -> Response:\n        \"\"\"\n        Handle exceptions which arise while processing incoming API requests.\n\n        :param request:          The incoming request.\n        :param exc:              The exception raised during handling.\n        :param handler_context:  (Optional) Extra data which will be attached to the event sent to\n                                 Sentry, under the \"Request Handler Data\" heading.\n        :param scope:            (Optional) A `Scope` object containing extra data which will be\n                                 attached to the event sent to Sentry.\n\n        :returns: A 500 response including the event id of the captured Sentry event.\n        \"\"\"\n        try:\n            # Django REST Framework's built-in exception handler. If `settings.EXCEPTION_HANDLER`\n            # exists and returns a response, that's used. Otherwise, `exc` is just re-raised\n            # and caught below.\n            response = super().handle_exception(exc)\n        except Exception as err:\n            import sys\n            import traceback\n\n            sys.stderr.write(traceback.format_exc())\n\n            scope = scope or sentry_sdk.Scope()\n            if handler_context:\n                merge_context_into_scope(\"Request Handler Data\", handler_context, scope)\n            event_id = capture_exception(err, scope=scope)\n\n            response_body = {\"detail\": \"Internal Error\", \"errorId\": event_id}\n            response = Response(response_body, status=500)\n            response.exception = True\n\n        return response\n\n    def create_audit_entry(self, request: Request, transaction_id=None, **kwargs):\n        return create_audit_entry(request, transaction_id, audit_logger, **kwargs)\n\n    def load_json_body(self, request: Request):\n        \"\"\"\n        Attempts to load the request body when it's JSON.\n\n        The end result is ``request.json_body`` having a value. When it can't\n        load the body as JSON, for any reason, ``request.json_body`` is None.\n\n        The request flow is unaffected and no exceptions are ever raised.\n        \"\"\"\n\n        request.json_body = None\n\n        if not request.META.get(\"CONTENT_TYPE\", \"\").startswith(\"application/json\"):\n            return\n\n        if not len(request.body):\n            return\n\n        try:\n            request.json_body = json.loads(request.body)\n        except json.JSONDecodeError:\n            return\n\n    def initialize_request(self, request: Request, *args, **kwargs):\n        # XXX: Since DRF 3.x, when the request is passed into\n        # `initialize_request` it's set as an internal variable on the returned\n        # request. Then when we call `rv.auth` it attempts to authenticate,\n        # fails and sets `user` and `auth` to None on the internal request. We\n        # keep track of these here and reassign them as needed.\n        orig_auth = getattr(request, \"auth\", None)\n        orig_user = getattr(request, \"user\", None)\n        rv = super().initialize_request(request, *args, **kwargs)\n        # If our request is being made via our internal API client, we need to\n        # stitch back on auth and user information\n        if getattr(request, \"__from_api_client__\", False):\n            if rv.auth is None:\n                rv.auth = orig_auth\n            if rv.user is None:\n                rv.user = orig_user\n        return rv\n\n    @csrf_exempt\n    @allow_cors_options\n    def dispatch(self, request: Request, *args, **kwargs) -> Response:\n        \"\"\"\n        Identical to rest framework's dispatch except we add the ability\n        to convert arguments (for common URL params).\n        \"\"\"\n        with sentry_sdk.start_span(op=\"base.dispatch.setup\", description=type(self).__name__):\n            self.args = args\n            self.kwargs = kwargs\n            request = self.initialize_request(request, *args, **kwargs)\n            self.load_json_body(request)\n            self.request = request\n            self.headers = self.default_response_headers  # deprecate?\n\n        # Tags that will ultimately flow into the metrics backend at the end of\n        # the request (happens via middleware/stats.py).\n        request._metric_tags = {}\n\n        start_time = time.time()\n\n        origin = request.META.get(\"HTTP_ORIGIN\", \"null\")\n        # A \"null\" value should be treated as no Origin for us.\n        # See RFC6454 for more information on this behavior.\n        if origin == \"null\":\n            origin = None\n\n        try:\n            with sentry_sdk.start_span(op=\"base.dispatch.request\", description=type(self).__name__):\n                if origin:\n                    if request.auth:\n                        allowed_origins = request.auth.get_allowed_origins()\n                    else:\n                        allowed_origins = None\n                    if not is_valid_origin(origin, allowed=allowed_origins):\n                        response = Response(f\"Invalid origin: {origin}\", status=400)\n                        self.response = self.finalize_response(request, response, *args, **kwargs)\n                        return self.response\n\n                self.initial(request, *args, **kwargs)\n\n                # Get the appropriate handler method\n                method = request.method.lower()\n                if method in self.http_method_names and hasattr(self, method):\n                    handler = getattr(self, method)\n\n                    # Only convert args when using defined handlers\n                    (args, kwargs) = self.convert_args(request, *args, **kwargs)\n                    self.args = args\n                    self.kwargs = kwargs\n                else:\n                    handler = self.http_method_not_allowed\n\n                if getattr(request, \"access\", None) is None:\n                    # setup default access\n                    request.access = access.from_request(request)\n\n            with sentry_sdk.start_span(\n                op=\"base.dispatch.execute\",\n                description=f\"{type(self).__name__}.{handler.__name__}\",\n            ):\n                response = handler(request, *args, **kwargs)\n\n        except Exception as exc:\n            response = self.handle_exception(request, exc)\n\n        if origin:\n            self.add_cors_headers(request, response)\n\n        self.response = self.finalize_response(request, response, *args, **kwargs)\n\n        if settings.SENTRY_API_RESPONSE_DELAY:\n            duration = time.time() - start_time\n\n            if duration < (settings.SENTRY_API_RESPONSE_DELAY / 1000.0):\n                with sentry_sdk.start_span(\n                    op=\"base.dispatch.sleep\",\n                    description=type(self).__name__,\n                ) as span:\n                    span.set_data(\"SENTRY_API_RESPONSE_DELAY\", settings.SENTRY_API_RESPONSE_DELAY)\n                    time.sleep(settings.SENTRY_API_RESPONSE_DELAY / 1000.0 - duration)\n\n        return self.response\n\n    def add_cors_headers(self, request: Request, response):\n        response[\"Access-Control-Allow-Origin\"] = request.META[\"HTTP_ORIGIN\"]\n        response[\"Access-Control-Allow-Methods\"] = \", \".join(self.http_method_names)\n\n    def add_cursor_headers(self, request: Request, response, cursor_result):\n        if cursor_result.hits is not None:\n            response[\"X-Hits\"] = cursor_result.hits\n        if cursor_result.max_hits is not None:\n            response[\"X-Max-Hits\"] = cursor_result.max_hits\n        response[\"Link\"] = \", \".join(\n            [\n                self.build_cursor_link(request, \"previous\", cursor_result.prev),\n                self.build_cursor_link(request, \"next\", cursor_result.next),\n            ]\n        )\n\n    def respond(self, context: Mapping[str, Any] | None = None, **kwargs: Any) -> Response:\n        return Response(context, **kwargs)\n\n    def respond_with_text(self, text):\n        return self.respond({\"text\": text})\n\n    def get_per_page(self, request: Request, default_per_page=100, max_per_page=100):\n        try:\n            return clamp_pagination_per_page(\n                request.GET.get(\"per_page\", default_per_page),\n                default_per_page=default_per_page,\n                max_per_page=max_per_page,\n            )\n        except ValueError as e:\n            raise ParseError(detail=str(e))\n\n    def get_cursor_from_request(self, request: Request, cursor_cls=Cursor):\n        try:\n            return get_cursor(request.GET.get(self.cursor_name), cursor_cls)\n        except ValueError as e:\n            raise ParseError(detail=str(e))\n\n    def paginate(\n        self,\n        request,\n        on_results=None,\n        paginator=None,\n        paginator_cls=Paginator,\n        default_per_page=100,\n        max_per_page=100,\n        cursor_cls=Cursor,\n        response_cls=Response,\n        response_kwargs=None,\n        count_hits=None,\n        **paginator_kwargs,\n    ):\n        # XXX(epurkhiser): This is an experiment that overrides all paginated\n        # API requests so that we can more easily debug on the frontend the\n        # experiemce customers have when they have lots of entites.\n        override_limit = request.COOKIES.get(\"__sentry_dev_pagination_limit\", None)\n        if override_limit is not None:\n            default_per_page = int(override_limit)\n            max_per_page = int(override_limit)\n\n        try:\n            per_page = self.get_per_page(request, default_per_page, max_per_page)\n            cursor = self.get_cursor_from_request(request, cursor_cls)\n            with sentry_sdk.start_span(\n                op=\"base.paginate.get_result\",\n                description=type(self).__name__,\n            ) as span:\n                annotate_span_with_pagination_args(span, per_page)\n                paginator = get_paginator(paginator, paginator_cls, paginator_kwargs)\n                result_args = dict(count_hits=count_hits) if count_hits is not None else dict()\n                cursor_result = paginator.get_result(\n                    limit=per_page,\n                    cursor=cursor,\n                    **result_args,\n                )\n        except BadPaginationError as e:\n            raise ParseError(detail=str(e))\n\n        if response_kwargs is None:\n            response_kwargs = {}\n\n        # map results based on callback\n        if on_results:\n            with sentry_sdk.start_span(\n                op=\"base.paginate.on_results\",\n                description=type(self).__name__,\n            ):\n                results = on_results(cursor_result.results)\n        else:\n            results = cursor_result.results\n\n        response = response_cls(results, **response_kwargs)\n        self.add_cursor_headers(request, response, cursor_result)\n        return response\n\n\nclass EnvironmentMixin:\n    def _get_environment_func(self, request: Request, organization_id):\n        \"\"\"\\\n        Creates a function that when called returns the ``Environment``\n        associated with a request object, or ``None`` if no environment was\n        provided. If the environment doesn't exist, an ``Environment.DoesNotExist``\n        exception will be raised.\n\n        This returns as a callable since some objects outside of the API\n        endpoint need to handle the \"environment was provided but does not\n        exist\" state in addition to the two non-exceptional states (the\n        environment was provided and exists, or the environment was not\n        provided.)\n        \"\"\"\n        return functools.partial(self._get_environment_from_request, request, organization_id)\n\n    def _get_environment_id_from_request(self, request: Request, organization_id):\n        environment = self._get_environment_from_request(request, organization_id)\n        return environment and environment.id\n\n    def _get_environment_from_request(self, request: Request, organization_id):\n        if not hasattr(request, \"_cached_environment\"):\n            environment_param = request.GET.get(\"environment\")\n            if environment_param is None:\n                environment = None\n            else:\n                environment = Environment.get_for_organization_id(\n                    name=environment_param, organization_id=organization_id\n                )\n\n            request._cached_environment = environment\n\n        return request._cached_environment\n\n\nclass StatsMixin:\n    def _parse_args(self, request: Request, environment_id=None, restrict_rollups=True):\n        \"\"\"\n        Parse common stats parameters from the query string. This includes\n        `since`, `until`, and `resolution`.\n\n        :param boolean restrict_rollups: When False allows any rollup value to\n        be specified. Be careful using this as this allows for fine grain\n        rollups that may put strain on the system.\n        \"\"\"\n        try:\n            resolution = request.GET.get(\"resolution\")\n            if resolution:\n                resolution = self._parse_resolution(resolution)\n                if restrict_rollups and resolution not in tsdb.get_rollups():\n                    raise ValueError\n        except ValueError:\n            raise ParseError(detail=\"Invalid resolution\")\n\n        try:\n            end = request.GET.get(\"until\")\n            if end:\n                end = to_datetime(float(end))\n            else:\n                end = datetime.utcnow().replace(tzinfo=utc)\n        except ValueError:\n            raise ParseError(detail=\"until must be a numeric timestamp.\")\n\n        try:\n            start = request.GET.get(\"since\")\n            if start:\n                start = to_datetime(float(start))\n                assert start <= end\n            else:\n                start = end - timedelta(days=1, seconds=-1)\n        except ValueError:\n            raise ParseError(detail=\"since must be a numeric timestamp\")\n        except AssertionError:\n            raise ParseError(detail=\"start must be before or equal to end\")\n\n        if not resolution:\n            resolution = tsdb.get_optimal_rollup(start, end)\n\n        return {\n            \"start\": start,\n            \"end\": end,\n            \"rollup\": resolution,\n            \"environment_ids\": environment_id and [environment_id],\n        }\n\n    def _parse_resolution(self, value):\n        if value.endswith(\"h\"):\n            return int(value[:-1]) * ONE_HOUR\n        elif value.endswith(\"d\"):\n            return int(value[:-1]) * ONE_DAY\n        elif value.endswith(\"m\"):\n            return int(value[:-1]) * ONE_MINUTE\n        elif value.endswith(\"s\"):\n            return int(value[:-1])\n        else:\n            raise ValueError(value)\n\n\nclass ReleaseAnalyticsMixin:\n    def track_set_commits_local(self, request: Request, organization_id=None, project_ids=None):\n        analytics.record(\n            \"release.set_commits_local\",\n            user_id=request.user.id if request.user and request.user.id else None,\n            organization_id=organization_id,\n            project_ids=project_ids,\n            user_agent=request.META.get(\"HTTP_USER_AGENT\", \"\"),\n        )\n\n\ndef resolve_region(request: Request):\n    subdomain = getattr(request, \"subdomain\", None)\n    if subdomain is None:\n        return None\n    if subdomain in {\"us\", \"eu\"}:\n        return subdomain\n    return None\n\n\nclass EndpointSiloLimit(SiloLimit):\n    def modify_endpoint_class(self, decorated_class: Type[Endpoint]) -> type:\n        dispatch_override = self.create_override(decorated_class.dispatch)\n        new_class = type(\n            decorated_class.__name__,\n            (decorated_class,),\n            {\n                \"dispatch\": dispatch_override,\n                \"silo_limit\": self,\n            },\n        )\n        new_class.__module__ = decorated_class.__module__\n        return new_class\n\n    def create_override(\n        self,\n        original_method: Callable[..., Any],\n    ) -> Callable[..., Any]:\n        limiting_override = super().create_override(original_method)\n\n        def single_process_silo_mode_wrapper(*args: Any, **kwargs: Any) -> Any:\n            if SiloMode.single_process_silo_mode():\n                entering_mode: SiloMode = SiloMode.MONOLITH\n                for mode in self.modes:\n                    # Select a mode, if available, from the target modes.\n                    entering_mode = mode\n                with SiloMode.enter_single_process_silo_context(entering_mode):\n                    return limiting_override(*args, **kwargs)\n            else:\n                return limiting_override(*args, **kwargs)\n\n        functools.update_wrapper(single_process_silo_mode_wrapper, limiting_override)\n        return single_process_silo_mode_wrapper\n\n    def modify_endpoint_method(self, decorated_method: Callable[..., Any]) -> Callable[..., Any]:\n        return self.create_override(decorated_method)\n\n    def handle_when_unavailable(\n        self,\n        original_method: Callable[..., Any],\n        current_mode: SiloMode,\n        available_modes: Iterable[SiloMode],\n    ) -> Callable[..., Any]:\n        def handle(obj: Any, request: Request, *args: Any, **kwargs: Any) -> HttpResponse:\n            mode_str = \", \".join(str(m) for m in available_modes)\n            message = (\n                f\"Received {request.method} request at {request.path!r} to server in \"\n                f\"{current_mode} mode. This endpoint is available only in: {mode_str}\"\n            )\n            if settings.FAIL_ON_UNAVAILABLE_API_CALL:\n                raise self.AvailabilityError(message)\n            else:\n                logger.warning(message)\n                return HttpResponse(status=status.HTTP_404_NOT_FOUND)\n\n        return handle\n\n    def __call__(self, decorated_obj: Any) -> Any:\n        if isinstance(decorated_obj, type):\n            if not issubclass(decorated_obj, Endpoint):\n                raise ValueError(\"`@EndpointSiloLimit` can decorate only Endpoint subclasses\")\n            return self.modify_endpoint_class(decorated_obj)\n\n        if callable(decorated_obj):\n            return self.modify_endpoint_method(decorated_obj)\n\n        raise TypeError(\"`@EndpointSiloLimit` must decorate a class or method\")\n\n\ncontrol_silo_endpoint = EndpointSiloLimit(SiloMode.CONTROL)\nregion_silo_endpoint = EndpointSiloLimit(SiloMode.REGION)\n\n# Use this decorator to mark endpoints that still need to be marked as either\n# control_silo_endpoint or region_silo_endpoint. Marking a class with\n# pending_silo_endpoint keeps it from tripping SiloLimitCoverageTest, while ensuring\n# that the test will fail if a new endpoint is added with no decorator at all.\n# Eventually we should replace all instances of this decorator and delete it.\npending_silo_endpoint = EndpointSiloLimit()\n\n# This should be rarely used, but this should be used for any endpoints that exist in any silo mode.\nall_silo_endpoint = EndpointSiloLimit(SiloMode.CONTROL, SiloMode.REGION, SiloMode.MONOLITH)\n", "import base64\nfrom unittest import mock\nfrom unittest.mock import MagicMock\n\nfrom django.http import HttpRequest, QueryDict, StreamingHttpResponse\nfrom django.test import override_settings\nfrom pytest import raises\nfrom rest_framework.response import Response\nfrom sentry_sdk import Scope\nfrom sentry_sdk.utils import exc_info_from_error\n\nfrom sentry.api.base import Endpoint, EndpointSiloLimit, resolve_region\nfrom sentry.api.paginator import GenericOffsetPaginator\nfrom sentry.models import ApiKey\nfrom sentry.services.hybrid_cloud.util import FunctionSiloLimit\nfrom sentry.silo import SiloMode\nfrom sentry.testutils import APITestCase\nfrom sentry.testutils.helpers.options import override_options\nfrom sentry.utils.cursors import Cursor\n\n\n# Though it looks weird to have a method outside a class, this isn't a mistake but rather\n# a mock for a method in Django REST Framework's `APIView` class\ndef reraise(self, e: Exception):\n    raise e\n\n\nclass DummyEndpoint(Endpoint):\n    permission_classes = ()\n\n    def get(self, request):\n        return Response({\"ok\": True})\n\n\nclass DummyErroringEndpoint(Endpoint):\n    permission_classes = ()\n    # `as_view` requires that any init args passed to it match attributes already on the\n    # class, so even though they're really meant to be instance attributes, we have to\n    # add them here as class attributes first\n    error = None\n    handler_context_arg = None\n    scope_arg = None\n\n    def __init__(\n        self,\n        *args,\n        error: Exception,\n        handler_context_arg=None,\n        scope_arg=None,\n        **kwargs,\n    ):\n        # The error which will be thrown when a GET request is made\n        self.error = error\n        # The argumets which will be passed on to `Endpoint.handle_exception` via `super`\n        self.handler_context_arg = handler_context_arg\n        self.scope_arg = scope_arg\n\n        super().__init__(*args, **kwargs)\n\n    def get(self, request):\n        raise self.error\n\n    def handle_exception(self, request, exc, handler_context=None, scope=None):\n        return super().handle_exception(request, exc, self.handler_context_arg, self.scope_arg)\n\n\nclass DummyPaginationEndpoint(Endpoint):\n    permission_classes = ()\n\n    def get(self, request):\n        values = [x for x in range(0, 100)]\n\n        def data_fn(offset, limit):\n            page_offset = offset * limit\n            return values[page_offset : page_offset + limit]\n\n        return self.paginate(\n            request=request,\n            paginator=GenericOffsetPaginator(data_fn),\n            on_results=lambda results: results,\n        )\n\n\n_dummy_endpoint = DummyEndpoint.as_view()\n\n\nclass DummyPaginationStreamingEndpoint(Endpoint):\n    permission_classes = ()\n\n    def get(self, request):\n        values = [x for x in range(0, 100)]\n\n        def data_fn(offset, limit):\n            page_offset = offset * limit\n            return values[page_offset : page_offset + limit]\n\n        return self.paginate(\n            request=request,\n            paginator=GenericOffsetPaginator(data_fn),\n            on_results=lambda results: iter(results),\n            response_cls=StreamingHttpResponse,\n            response_kwargs={\"content_type\": \"application/json\"},\n        )\n\n\n_dummy_streaming_endpoint = DummyPaginationStreamingEndpoint.as_view()\n\n\nclass EndpointTest(APITestCase):\n    def test_basic_cors(self):\n        org = self.create_organization()\n        apikey = ApiKey.objects.create(organization_id=org.id, allowed_origins=\"*\")\n\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n        request.META[\"HTTP_AUTHORIZATION\"] = b\"Basic \" + base64.b64encode(\n            apikey.key.encode(\"utf-8\")\n        )\n\n        response = _dummy_endpoint(request)\n        response.render()\n\n        assert response.status_code == 200, response.content\n\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://example.com\"\n        assert response[\"Access-Control-Allow-Headers\"] == (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        assert response[\"Access-Control-Expose-Headers\"] == \"X-Sentry-Error, Retry-After\"\n        assert response[\"Access-Control-Allow-Methods\"] == \"GET, HEAD, OPTIONS\"\n        assert \"Access-Control-Allow-Credentials\" not in response\n\n    @override_options({\"system.base-hostname\": \"example.com\"})\n    def test_allow_credentials(self):\n        org = self.create_organization()\n        apikey = ApiKey.objects.create(organization_id=org.id, allowed_origins=\"*\")\n\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://acme.example.com\"\n        request.META[\"HTTP_AUTHORIZATION\"] = b\"Basic \" + base64.b64encode(\n            apikey.key.encode(\"utf-8\")\n        )\n\n        response = _dummy_endpoint(request)\n        response.render()\n\n        assert response.status_code == 200, response.content\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://acme.example.com\"\n        assert response[\"Access-Control-Allow-Headers\"] == (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        assert response[\"Access-Control-Expose-Headers\"] == \"X-Sentry-Error, Retry-After\"\n        assert response[\"Access-Control-Allow-Methods\"] == \"GET, HEAD, OPTIONS\"\n        assert response[\"Access-Control-Allow-Credentials\"] == \"true\"\n\n    @override_options({\"system.base-hostname\": \"acme.com\"})\n    def test_allow_credentials_incorrect(self):\n        org = self.create_organization()\n        apikey = ApiKey.objects.create(organization_id=org.id, allowed_origins=\"*\")\n\n        for http_origin in [\"http://acme.example.com\", \"http://fakeacme.com\"]:\n            request = self.make_request(method=\"GET\")\n            request.META[\"HTTP_ORIGIN\"] = http_origin\n            request.META[\"HTTP_AUTHORIZATION\"] = b\"Basic \" + base64.b64encode(\n                apikey.key.encode(\"utf-8\")\n            )\n\n            response = _dummy_endpoint(request)\n            response.render()\n            assert \"Access-Control-Allow-Credentials\" not in response\n\n    def test_invalid_cors_without_auth(self):\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n\n        with self.settings(SENTRY_ALLOW_ORIGIN=\"https://sentry.io\"):\n            response = _dummy_endpoint(request)\n            response.render()\n\n        assert response.status_code == 400, response.content\n\n    def test_valid_cors_without_auth(self):\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n\n        with self.settings(SENTRY_ALLOW_ORIGIN=\"*\"):\n            response = _dummy_endpoint(request)\n            response.render()\n\n        assert response.status_code == 200, response.content\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://example.com\"\n\n    # XXX(dcramer): The default setting needs to allow requests to work or it will be a regression\n    def test_cors_not_configured_is_valid(self):\n        request = self.make_request(method=\"GET\")\n        request.META[\"HTTP_ORIGIN\"] = \"http://example.com\"\n\n        with self.settings(SENTRY_ALLOW_ORIGIN=None):\n            response = _dummy_endpoint(request)\n            response.render()\n\n        assert response.status_code == 200, response.content\n        assert response[\"Access-Control-Allow-Origin\"] == \"http://example.com\"\n        assert response[\"Access-Control-Allow-Headers\"] == (\n            \"X-Sentry-Auth, X-Requested-With, Origin, Accept, \"\n            \"Content-Type, Authentication, Authorization, Content-Encoding, \"\n            \"sentry-trace, baggage, X-CSRFToken\"\n        )\n        assert response[\"Access-Control-Expose-Headers\"] == \"X-Sentry-Error, Retry-After\"\n        assert response[\"Access-Control-Allow-Methods\"] == \"GET, HEAD, OPTIONS\"\n\n    @mock.patch(\"sentry.api.base.Endpoint.convert_args\")\n    def test_method_not_allowed(self, mock_convert_args):\n        request = self.make_request(method=\"POST\")\n        response = _dummy_endpoint(request)\n        response.render()\n\n        assert response.status_code == 405, response.content\n\n        # did not try to convert args\n        assert not mock_convert_args.info.called\n\n\nclass EndpointHandleExceptionTest(APITestCase):\n    @mock.patch(\"rest_framework.views.APIView.handle_exception\", return_value=Response(status=500))\n    def test_handle_exception_when_super_returns_response(\n        self, mock_super_handle_exception: MagicMock\n    ):\n        mock_endpoint = DummyErroringEndpoint.as_view(error=Exception(\"nope\"))\n        response = mock_endpoint(self.make_request(method=\"GET\"))\n\n        # The endpoint should pass along the response generated by `APIView.handle_exception`\n        assert response == mock_super_handle_exception.return_value\n\n    @mock.patch(\"rest_framework.views.APIView.handle_exception\", new=reraise)\n    @mock.patch(\"sentry.api.base.capture_exception\", return_value=\"1231201211212012\")\n    def test_handle_exception_when_super_reraises(\n        self,\n        mock_capture_exception: MagicMock,\n    ):\n        handler_context = {\"api_request_URL\": \"http://dogs.are.great/\"}\n        scope = Scope()\n        tags = {\"maisey\": \"silly\", \"charlie\": \"goofy\"}\n        for tag, value in tags.items():\n            scope.set_tag(tag, value)\n\n        cases = [\n            # The first half of each tuple is what's passed to `handle_exception`, and the second\n            # half is what we expect in the scope passed to `capture_exception`\n            (None, None, {}, {}),\n            (handler_context, None, {\"Request Handler Data\": handler_context}, {}),\n            (None, scope, {}, tags),\n            (\n                handler_context,\n                scope,\n                {\"Request Handler Data\": handler_context},\n                tags,\n            ),\n        ]\n\n        for handler_context_arg, scope_arg, expected_scope_contexts, expected_scope_tags in cases:\n            handler_error = Exception(\"nope\")\n            mock_endpoint = DummyErroringEndpoint.as_view(\n                error=handler_error,\n                handler_context_arg=handler_context_arg,\n                scope_arg=scope_arg,\n            )\n\n            with mock.patch(\"sys.exc_info\", return_value=exc_info_from_error(handler_error)):\n                with mock.patch(\"sys.stderr.write\") as mock_stderr_write:\n                    response = mock_endpoint(self.make_request(method=\"GET\"))\n\n                    assert response.status_code == 500\n                    assert response.data == {\n                        \"detail\": \"Internal Error\",\n                        \"errorId\": \"1231201211212012\",\n                    }\n                    assert response.exception is True\n\n                    mock_stderr_write.assert_called_with(\"Exception: nope\\n\")\n\n                    capture_exception_handler_context_arg = mock_capture_exception.call_args.args[0]\n                    capture_exception_scope_kwarg = mock_capture_exception.call_args.kwargs.get(\n                        \"scope\"\n                    )\n\n                    assert capture_exception_handler_context_arg == handler_error\n                    assert isinstance(capture_exception_scope_kwarg, Scope)\n                    assert capture_exception_scope_kwarg._contexts == expected_scope_contexts\n                    assert capture_exception_scope_kwarg._tags == expected_scope_tags\n\n\nclass CursorGenerationTest(APITestCase):\n    def test_serializes_params(self):\n        request = self.make_request(method=\"GET\", path=\"/api/0/organizations/\")\n        request.GET = QueryDict(\"member=1&cursor=foo\")\n        endpoint = Endpoint()\n        result = endpoint.build_cursor_link(request, \"next\", \"1492107369532:0:0\")\n\n        assert result == (\n            \"<http://testserver/api/0/organizations/?member=1&cursor=1492107369532:0:0>;\"\n            ' rel=\"next\"; results=\"true\"; cursor=\"1492107369532:0:0\"'\n        )\n\n    def test_unicode_path(self):\n        request = self.make_request(method=\"GET\", path=\"/api/0/organizations/\u00fcuuuu/\")\n        endpoint = Endpoint()\n        result = endpoint.build_cursor_link(request, \"next\", \"1492107369532:0:0\")\n\n        assert result == (\n            \"<http://testserver/api/0/organizations/%C3%BCuuuu/?&cursor=1492107369532:0:0>;\"\n            ' rel=\"next\"; results=\"true\"; cursor=\"1492107369532:0:0\"'\n        )\n\n    def test_encodes_url(self):\n        endpoint = Endpoint()\n        request = self.make_request(method=\"GET\", path=\"/foo/bar/lol:what/\")\n\n        result = endpoint.build_cursor_link(request, \"next\", cursor=Cursor(0, 0, 0))\n        assert (\n            result\n            == '<http://testserver/foo/bar/lol%3Awhat/?&cursor=0:0:0>; rel=\"next\"; results=\"false\"; cursor=\"0:0:0\"'\n        )\n\n\nclass PaginateTest(APITestCase):\n    def setUp(self):\n        super().setUp()\n        self.request = self.make_request(method=\"GET\")\n        self.view = DummyPaginationEndpoint().as_view()\n\n    def test_success(self):\n        response = self.view(self.request)\n        assert response.status_code == 200, response.content\n        assert (\n            response[\"Link\"]\n            == '<http://testserver/?&cursor=0:0:1>; rel=\"previous\"; results=\"false\"; cursor=\"0:0:1\", <http://testserver/?&cursor=0:100:0>; rel=\"next\"; results=\"false\"; cursor=\"0:100:0\"'\n        )\n\n    def test_invalid_per_page(self):\n        self.request.GET = {\"per_page\": \"nope\"}\n        response = self.view(self.request)\n        assert response.status_code == 400\n\n    def test_invalid_cursor(self):\n        self.request.GET = {\"cursor\": \"no:no:no\"}\n        response = self.view(self.request)\n        assert response.status_code == 400\n\n    def test_per_page_out_of_bounds(self):\n        self.request.GET = {\"per_page\": \"101\"}\n        response = self.view(self.request)\n        assert response.status_code == 400\n\n    def test_custom_response_type(self):\n        response = _dummy_streaming_endpoint(self.request)\n        assert response.status_code == 200\n        assert type(response) == StreamingHttpResponse\n        assert response.has_header(\"content-type\")\n\n\nclass EndpointJSONBodyTest(APITestCase):\n    def setUp(self):\n        super().setUp()\n\n        self.request = HttpRequest()\n        self.request.method = \"GET\"\n        self.request.META[\"CONTENT_TYPE\"] = \"application/json\"\n\n    def test_json(self):\n        self.request._body = '{\"foo\":\"bar\"}'\n\n        Endpoint().load_json_body(self.request)\n\n        assert self.request.json_body == {\"foo\": \"bar\"}\n\n    def test_invalid_json(self):\n        self.request._body = \"hello\"\n\n        Endpoint().load_json_body(self.request)\n\n        assert not self.request.json_body\n\n    def test_empty_request_body(self):\n        self.request._body = \"\"\n\n        Endpoint().load_json_body(self.request)\n\n        assert not self.request.json_body\n\n    def test_non_json_content_type(self):\n        self.request.META[\"CONTENT_TYPE\"] = \"text/plain\"\n\n        Endpoint().load_json_body(self.request)\n\n        assert not self.request.json_body\n\n\nclass CustomerDomainTest(APITestCase):\n    def test_resolve_region(self):\n        def request_with_subdomain(subdomain):\n            request = self.make_request(method=\"GET\")\n            request.subdomain = subdomain\n            return resolve_region(request)\n\n        assert request_with_subdomain(\"us\") == \"us\"\n        assert request_with_subdomain(\"eu\") == \"eu\"\n        assert request_with_subdomain(\"sentry\") is None\n\n\nclass EndpointSiloLimitTest(APITestCase):\n    def _test_active_on(self, endpoint_mode, active_mode, expect_to_be_active):\n        @EndpointSiloLimit(endpoint_mode)\n        class DecoratedEndpoint(DummyEndpoint):\n            pass\n\n        class EndpointWithDecoratedMethod(DummyEndpoint):\n            @EndpointSiloLimit(endpoint_mode)\n            def get(self, request):\n                return super().get(request)\n\n        with override_settings(SILO_MODE=active_mode):\n            request = self.make_request(method=\"GET\")\n\n            for endpoint_class in (DecoratedEndpoint, EndpointWithDecoratedMethod):\n                view = endpoint_class.as_view()\n                with override_settings(FAIL_ON_UNAVAILABLE_API_CALL=False):\n                    response = view(request)\n                    assert response.status_code == (200 if expect_to_be_active else 404)\n\n            if not expect_to_be_active:\n                with override_settings(FAIL_ON_UNAVAILABLE_API_CALL=True):\n                    with raises(EndpointSiloLimit.AvailabilityError):\n                        DecoratedEndpoint.as_view()(request)\n                    # TODO: Make work with EndpointWithDecoratedMethod\n\n    def test_with_active_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.REGION, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.CONTROL, True)\n\n    def test_with_inactive_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.CONTROL, False)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.REGION, False)\n\n    def test_with_monolith_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.MONOLITH, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.MONOLITH, True)\n\n\nclass FunctionSiloLimitTest(APITestCase):\n    def _test_active_on(self, endpoint_mode, active_mode, expect_to_be_active):\n        @FunctionSiloLimit(endpoint_mode)\n        def decorated_function():\n            pass\n\n        with override_settings(SILO_MODE=active_mode):\n            if expect_to_be_active:\n                decorated_function()\n            else:\n                with raises(ValueError):\n                    decorated_function()\n\n    def test_with_active_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.REGION, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.CONTROL, True)\n\n    def test_with_inactive_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.CONTROL, False)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.REGION, False)\n\n    def test_with_monolith_mode(self):\n        self._test_active_on(SiloMode.REGION, SiloMode.MONOLITH, True)\n        self._test_active_on(SiloMode.CONTROL, SiloMode.MONOLITH, True)\n"], "filenames": ["src/sentry/api/base.py", "tests/sentry/api/test_base.py"], "buggy_code_start_loc": [124, 165], "buggy_code_end_loc": [125, 174], "fixing_code_start_loc": [124, 165], "fixing_code_end_loc": [125, 175], "type": "CWE-697", "message": "Sentry is an error tracking and performance monitoring platform. Starting in version 23.6.0 and prior to version 23.6.2, the Sentry API incorrectly returns the `access-control-allow-credentials: true` HTTP header if the `Origin` request header ends with the `system.base-hostname` option of Sentry installation. This only affects installations that have `system.base-hostname` option explicitly set, as it is empty by default. Impact is limited since recent versions of major browsers have cross-site cookie blocking enabled by default. However, this flaw could allow other multi-step attacks. The patch has been released in Sentry 23.6.2.", "other": {"cve": {"id": "CVE-2023-36829", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-06T23:15:09.620", "lastModified": "2023-07-17T18:56:00.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sentry is an error tracking and performance monitoring platform. Starting in version 23.6.0 and prior to version 23.6.2, the Sentry API incorrectly returns the `access-control-allow-credentials: true` HTTP header if the `Origin` request header ends with the `system.base-hostname` option of Sentry installation. This only affects installations that have `system.base-hostname` option explicitly set, as it is empty by default. Impact is limited since recent versions of major browsers have cross-site cookie blocking enabled by default. However, this flaw could allow other multi-step attacks. The patch has been released in Sentry 23.6.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-697"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}, {"lang": "en", "value": "CWE-942"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:functional:sentry:*:*:*:*:*:*:*:*", "versionStartIncluding": "23.6.0", "versionEndExcluding": "23.6.2", "matchCriteriaId": "D219E572-0813-4204-842D-B1CD57BBB397"}]}]}], "references": [{"url": "https://github.com/getsentry/self-hosted/releases/tag/23.6.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/getsentry/sentry/commit/ee44c6be35e5e464bc40637580f39867898acd8b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/getsentry/sentry/pull/52276", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/getsentry/sentry/security/advisories/GHSA-4xqm-4p72-87h6", "source": "security-advisories@github.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/getsentry/sentry/commit/ee44c6be35e5e464bc40637580f39867898acd8b"}}