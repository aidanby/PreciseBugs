{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * linux/fs/seq_file.c\n *\n * helper functions for making synthetic files from sequences of records.\n * initial implementation -- AV, Oct 2001.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cache.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/mm.h>\n#include <linux/printk.h>\n#include <linux/string_helpers.h>\n#include <linux/uio.h>\n\n#include <linux/uaccess.h>\n#include <asm/page.h>\n\nstatic struct kmem_cache *seq_file_cache __ro_after_init;\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}\n\nstatic void *seq_buf_alloc(unsigned long size)\n{\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}\n\n/**\n *\tseq_open -\tinitialize sequential file\n *\t@file: file we initialize\n *\t@op: method table describing the sequence\n *\n *\tseq_open() sets @file, associating it with a sequence described\n *\tby @op.  @op->start() sets the iterator up and returns the first\n *\telement of sequence. @op->stop() shuts it down.  @op->next()\n *\treturns the next element of sequence.  @op->show() prints element\n *\tinto the buffer.  In case of error ->start() and ->next() return\n *\tERR_PTR(error).  In the end of sequence they return %NULL. ->show()\n *\treturns 0 in case of success and negative number in case of error.\n *\tReturning SEQ_SKIP means \"discard this element and move on\".\n *\tNote: seq_open() will allocate a struct seq_file and store its\n *\tpointer in @file->private_data. This pointer should not be modified.\n */\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p;\n\n\tWARN_ON(file->private_data);\n\n\tp = kmem_cache_zalloc(seq_file_cache, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfile->private_data = p;\n\n\tmutex_init(&p->lock);\n\tp->op = op;\n\n\t// No refcounting: the lifetime of 'p' is constrained\n\t// to the lifetime of the file.\n\tp->file = file;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}\nEXPORT_SYMBOL(seq_open);\n\nstatic int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0;\n\tint error = 0;\n\tvoid *p;\n\n\tm->index = 0;\n\tm->count = m->from = 0;\n\tif (!offset)\n\t\treturn 0;\n\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &m->index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tp = m->op->next(m, p, &m->index);\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset)\n\t\t\tbreak;\n\t}\n\tm->op->stop(m, p);\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}\n\n/**\n *\tseq_read -\t->read() method for sequential files.\n *\t@file: the file to read from\n *\t@buf: the buffer to read to\n *\t@size: the maximum number of bytes to read\n *\t@ppos: the current position in the file\n *\n *\tReady-made ->f_op->read()\n */\nssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = size};\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tiov_iter_init(&iter, READ, &iov, 1, size);\n\n\tkiocb.ki_pos = *ppos;\n\tret = seq_read_iter(&kiocb, &iter);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}\nEXPORT_SYMBOL(seq_read);\n\n/*\n * Ready-made ->f_op->read_iter()\n */\nssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct seq_file *m = iocb->ki_filp->private_data;\n\tsize_t copied = 0;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * if request is to read from zero offset, reset iterator to first\n\t * record as it might have been already advanced by previous requests\n\t */\n\tif (iocb->ki_pos == 0) {\n\t\tm->index = 0;\n\t\tm->count = 0;\n\t}\n\n\t/* Don't assume ki_pos is where we left it */\n\tif (unlikely(iocb->ki_pos != m->read_pos)) {\n\t\twhile ((err = traverse(m, iocb->ki_pos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = iocb->ki_pos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t// something left in the buffer - copy it out first\n\tif (m->count) {\n\t\tn = copy_to_iter(m->buf + m->from, m->count, iter);\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tcopied += n;\n\t\tif (m->count)\t// hadn't managed to copy everything\n\t\t\tgoto Done;\n\t}\n\t// get a non-empty record in the buffer\n\tm->from = 0;\n\tp = m->op->start(m, &m->index);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\t// EOF or an error\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\t\t// hard error\n\t\t\tbreak;\n\t\tif (unlikely(err))\t// ->show() says \"skip it\"\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) { // empty record\n\t\t\tp = m->op->next(m, p, &m->index);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!seq_has_overflowed(m)) // got it\n\t\t\tgoto Fill;\n\t\t// need a bigger buffer\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tp = m->op->start(m, &m->index);\n\t}\n\t// EOF or an error\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t// one non-empty record is in the buffer; if they want more,\n\t// try to fit more in, but in any case we need to advance\n\t// the iterator once for every record shown.\n\twhile (1) {\n\t\tsize_t offs = m->count;\n\t\tloff_t pos = m->index;\n\n\t\tp = m->op->next(m, p, &m->index);\n\t\tif (pos == m->index) {\n\t\t\tpr_info_ratelimited(\"buggy .next function %ps did not update position index\\n\",\n\t\t\t\t\t    m->op->next);\n\t\t\tm->index++;\n\t\t}\n\t\tif (!p || IS_ERR(p))\t// no next record for us\n\t\t\tbreak;\n\t\tif (m->count >= iov_iter_count(iter))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err > 0) {\t\t// ->show() says \"skip it\"\n\t\t\tm->count = offs;\n\t\t} else if (err || seq_has_overflowed(m)) {\n\t\t\tm->count = offs;\n\t\t\tbreak;\n\t\t}\n\t}\n\tm->op->stop(m, p);\n\tn = copy_to_iter(m->buf, m->count, iter);\n\tcopied += n;\n\tm->count -= n;\n\tm->from = n;\nDone:\n\tif (unlikely(!copied)) {\n\t\tcopied = m->count ? -EFAULT : err;\n\t} else {\n\t\tiocb->ki_pos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\n}\nEXPORT_SYMBOL(seq_read_iter);\n\n/**\n *\tseq_lseek -\t->llseek() method for sequential files.\n *\t@file: the file in question\n *\t@offset: new position\n *\t@whence: 0 for absolute, 1 for relative position\n *\n *\tReady-made ->f_op->llseek()\n */\nloff_t seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct seq_file *m = file->private_data;\n\tloff_t retval = -EINVAL;\n\n\tmutex_lock(&m->lock);\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t\tfallthrough;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\tbreak;\n\t\tretval = offset;\n\t\tif (offset != m->read_pos) {\n\t\t\twhile ((retval = traverse(m, offset)) == -EAGAIN)\n\t\t\t\t;\n\t\t\tif (retval) {\n\t\t\t\t/* with extreme prejudice... */\n\t\t\t\tfile->f_pos = 0;\n\t\t\t\tm->read_pos = 0;\n\t\t\t\tm->index = 0;\n\t\t\t\tm->count = 0;\n\t\t\t} else {\n\t\t\t\tm->read_pos = offset;\n\t\t\t\tretval = file->f_pos = offset;\n\t\t\t}\n\t\t} else {\n\t\t\tfile->f_pos = offset;\n\t\t}\n\t}\n\tmutex_unlock(&m->lock);\n\treturn retval;\n}\nEXPORT_SYMBOL(seq_lseek);\n\n/**\n *\tseq_release -\tfree the structures associated with sequential file.\n *\t@file: file in question\n *\t@inode: its inode\n *\n *\tFrees the structures associated with sequential file; can be used\n *\tas ->f_op->release() if you don't have private data to destroy.\n */\nint seq_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tkvfree(m->buf);\n\tkmem_cache_free(seq_file_cache, m);\n\treturn 0;\n}\nEXPORT_SYMBOL(seq_release);\n\n/**\n * seq_escape_mem - print data into buffer, escaping some characters\n * @m: target buffer\n * @src: source buffer\n * @len: size of source buffer\n * @flags: flags to pass to string_escape_mem()\n * @esc: set of characters that need escaping\n *\n * Puts data into buffer, replacing each occurrence of character from\n * given class (defined by @flags and @esc) with printable escaped sequence.\n *\n * Use seq_has_overflowed() to check for errors.\n */\nvoid seq_escape_mem(struct seq_file *m, const char *src, size_t len,\n\t\t    unsigned int flags, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint ret;\n\n\tret = string_escape_mem(src, len, buf, size, flags, esc);\n\tseq_commit(m, ret < size ? ret : -1);\n}\nEXPORT_SYMBOL(seq_escape_mem);\n\n/**\n *\tseq_escape -\tprint string into buffer, escaping some characters\n *\t@m:\ttarget buffer\n *\t@s:\tstring\n *\t@esc:\tset of characters that need escaping\n *\n *\tPuts string into buffer, replacing each occurrence of character from\n *\t@esc with usual octal escape.\n *\tUse seq_has_overflowed() to check for errors.\n */\nvoid seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tseq_escape_str(m, s, ESCAPE_OCTAL, esc);\n}\nEXPORT_SYMBOL(seq_escape);\n\nvoid seq_vprintf(struct seq_file *m, const char *f, va_list args)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_vprintf);\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL(seq_printf);\n\n#ifdef CONFIG_BINARY_PRINTF\nvoid seq_bprintf(struct seq_file *m, const char *f, const u32 *binary)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = bstr_printf(m->buf + m->count, m->size - m->count, f,\n\t\t\t\t  binary);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_bprintf);\n#endif /* CONFIG_BINARY_PRINTF */\n\n/**\n *\tmangle_path -\tmangle and copy path to buffer beginning\n *\t@s: buffer start\n *\t@p: beginning of path in above buffer\n *\t@esc: set of characters that need escaping\n *\n *      Copy the path from @p to @s, replacing each occurrence of character from\n *      @esc with usual octal escape.\n *      Returns pointer past last written character in @s, or NULL in case of\n *      failure.\n */\nchar *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(mangle_path);\n\n/**\n * seq_path - seq_file interface to print a pathname\n * @m: the seq_file handle\n * @path: the struct path to print\n * @esc: set of characters to escape in the output\n *\n * return the absolute path of 'path', as represented by the\n * dentry / mnt pair in the path parameter.\n */\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(seq_path);\n\n/**\n * seq_file_path - seq_file interface to print a pathname of a file\n * @m: the seq_file handle\n * @file: the struct file to print\n * @esc: set of characters to escape in the output\n *\n * return the absolute path to the file.\n */\nint seq_file_path(struct seq_file *m, struct file *file, const char *esc)\n{\n\treturn seq_path(m, &file->f_path, esc);\n}\nEXPORT_SYMBOL(seq_file_path);\n\n/*\n * Same as seq_path, but relative to supplied root.\n */\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}\n\n/*\n * returns the path of the 'dentry' from the root of its filesystem.\n */\nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(seq_dentry);\n\nstatic void *single_start(struct seq_file *p, loff_t *pos)\n{\n\treturn NULL + (*pos == 0);\n}\n\nstatic void *single_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn NULL;\n}\n\nstatic void single_stop(struct seq_file *p, void *v)\n{\n}\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL_ACCOUNT);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(single_open);\n\nint single_open_size(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data, size_t size)\n{\n\tchar *buf = seq_buf_alloc(size);\n\tint ret;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = single_open(file, show, data);\n\tif (ret) {\n\t\tkvfree(buf);\n\t\treturn ret;\n\t}\n\t((struct seq_file *)file->private_data)->buf = buf;\n\t((struct seq_file *)file->private_data)->size = size;\n\treturn 0;\n}\nEXPORT_SYMBOL(single_open_size);\n\nint single_release(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *op = ((struct seq_file *)file->private_data)->op;\n\tint res = seq_release(inode, file);\n\tkfree(op);\n\treturn res;\n}\nEXPORT_SYMBOL(single_release);\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}\nEXPORT_SYMBOL(seq_release_private);\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL_ACCOUNT);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}\nEXPORT_SYMBOL(__seq_open_private);\n\nint seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}\nEXPORT_SYMBOL(seq_open_private);\n\nvoid seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}\nEXPORT_SYMBOL(seq_putc);\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}\nEXPORT_SYMBOL(seq_puts);\n\n/**\n * seq_put_decimal_ull_width - A helper routine for putting decimal numbers\n * \t\t\t       without rich format of printf().\n * only 'unsigned long long' is supported.\n * @m: seq_file identifying the buffer to which data should be written\n * @delimiter: a string which is printed before the number\n * @num: the number\n * @width: a minimum field width\n *\n * This routine will put strlen(delimiter) + number into seq_filed.\n * This routine is very quick when you show lots of numbers.\n * In usual cases, it will be better to use seq_printf(). It's easier to read.\n */\nvoid seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,\n\t\t\t unsigned long long num, unsigned int width)\n{\n\tint len;\n\n\tif (m->count + 2 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\tif (!width)\n\t\twidth = 1;\n\n\tif (m->count + width >= m->size)\n\t\tgoto overflow;\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num, width);\n\tif (!len)\n\t\tgoto overflow;\n\n\tm->count += len;\n\treturn;\n\noverflow:\n\tseq_set_overflow(m);\n}\n\nvoid seq_put_decimal_ull(struct seq_file *m, const char *delimiter,\n\t\t\t unsigned long long num)\n{\n\treturn seq_put_decimal_ull_width(m, delimiter, num, 0);\n}\nEXPORT_SYMBOL(seq_put_decimal_ull);\n\n/**\n * seq_put_hex_ll - put a number in hexadecimal notation\n * @m: seq_file identifying the buffer to which data should be written\n * @delimiter: a string which is printed before the number\n * @v: the number\n * @width: a minimum field width\n *\n * seq_put_hex_ll(m, \"\", v, 8) is equal to seq_printf(m, \"%08llx\", v)\n *\n * This routine is very quick when you show lots of numbers.\n * In usual cases, it will be better to use seq_printf(). It's easier to read.\n */\nvoid seq_put_hex_ll(struct seq_file *m, const char *delimiter,\n\t\t\t\tunsigned long long v, unsigned int width)\n{\n\tunsigned int len;\n\tint i;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\t/* If x is 0, the result of __builtin_clzll is undefined */\n\tif (v == 0)\n\t\tlen = 1;\n\telse\n\t\tlen = (sizeof(v) * 8 - __builtin_clzll(v) + 3) / 4;\n\n\tif (len < width)\n\t\tlen = width;\n\n\tif (m->count + len > m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tm->buf[m->count + i] = hex_asc[0xf & v];\n\t\tv = v >> 4;\n\t}\n\tm->count += len;\n}\n\nvoid seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num)\n{\n\tint len;\n\n\tif (m->count + 3 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\tif (m->count + 2 >= m->size)\n\t\tgoto overflow;\n\n\tif (num < 0) {\n\t\tm->buf[m->count++] = '-';\n\t\tnum = -num;\n\t}\n\n\tif (num < 10) {\n\t\tm->buf[m->count++] = num + '0';\n\t\treturn;\n\t}\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num, 0);\n\tif (!len)\n\t\tgoto overflow;\n\n\tm->count += len;\n\treturn;\n\noverflow:\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_put_decimal_ll);\n\n/**\n * seq_write - write arbitrary data to buffer\n * @seq: seq_file identifying the buffer to which data should be written\n * @data: data address\n * @len: number of bytes\n *\n * Return 0 on success, non-zero otherwise.\n */\nint seq_write(struct seq_file *seq, const void *data, size_t len)\n{\n\tif (seq->count + len < seq->size) {\n\t\tmemcpy(seq->buf + seq->count, data, len);\n\t\tseq->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(seq);\n\treturn -1;\n}\nEXPORT_SYMBOL(seq_write);\n\n/**\n * seq_pad - write padding spaces to buffer\n * @m: seq_file identifying the buffer to which data should be written\n * @c: the byte to append after padding if non-zero\n */\nvoid seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0) {\n\t\tif (size + m->count > m->size) {\n\t\t\tseq_set_overflow(m);\n\t\t\treturn;\n\t\t}\n\t\tmemset(m->buf + m->count, ' ', size);\n\t\tm->count += size;\n\t}\n\tif (c)\n\t\tseq_putc(m, c);\n}\nEXPORT_SYMBOL(seq_pad);\n\n/* A complete analogue of print_hex_dump() */\nvoid seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,\n\t\t  int rowsize, int groupsize, const void *buf, size_t len,\n\t\t  bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint i, linelen, remaining = len;\n\tchar *buffer;\n\tsize_t size;\n\tint ret;\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tfor (i = 0; i < len && !seq_has_overflowed(m); i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\tswitch (prefix_type) {\n\t\tcase DUMP_PREFIX_ADDRESS:\n\t\t\tseq_printf(m, \"%s%p: \", prefix_str, ptr + i);\n\t\t\tbreak;\n\t\tcase DUMP_PREFIX_OFFSET:\n\t\t\tseq_printf(m, \"%s%.8x: \", prefix_str, i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"%s\", prefix_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tsize = seq_get_buf(m, &buffer);\n\t\tret = hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t\t buffer, size, ascii);\n\t\tseq_commit(m, ret < size ? ret : -1);\n\n\t\tseq_putc(m, '\\n');\n\t}\n}\nEXPORT_SYMBOL(seq_hex_dump);\n\nstruct list_head *seq_list_start(struct list_head *head, loff_t pos)\n{\n\tstruct list_head *lh;\n\n\tlist_for_each(lh, head)\n\t\tif (pos-- == 0)\n\t\t\treturn lh;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_list_start);\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_list_start_head);\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}\nEXPORT_SYMBOL(seq_list_next);\n\n/**\n * seq_hlist_start - start an iteration of a hlist\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start().\n */\nstruct hlist_node *seq_hlist_start(struct hlist_head *head, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\thlist_for_each(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start);\n\n/**\n * seq_hlist_start_head - start an iteration of a hlist\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start(). Call this function if you want to\n * print a header at the top of the output.\n */\nstruct hlist_node *seq_hlist_start_head(struct hlist_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_hlist_start_head);\n\n/**\n * seq_hlist_next - move to the next position of the hlist\n * @v:    the current iterator\n * @head: the head of the hlist\n * @ppos: the current position\n *\n * Called at seq_file->op->next().\n */\nstruct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn head->first;\n\telse\n\t\treturn node->next;\n}\nEXPORT_SYMBOL(seq_hlist_next);\n\n/**\n * seq_hlist_start_rcu - start an iteration of a hlist protected by RCU\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start().\n *\n * This list-traversal primitive may safely run concurrently with\n * the _rcu list-mutation primitives such as hlist_add_head_rcu()\n * as long as the traversal is guarded by rcu_read_lock().\n */\nstruct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t       loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\t__hlist_for_each_rcu(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start_rcu);\n\n/**\n * seq_hlist_start_head_rcu - start an iteration of a hlist protected by RCU\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start(). Call this function if you want to\n * print a header at the top of the output.\n *\n * This list-traversal primitive may safely run concurrently with\n * the _rcu list-mutation primitives such as hlist_add_head_rcu()\n * as long as the traversal is guarded by rcu_read_lock().\n */\nstruct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t    loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_hlist_start_head_rcu);\n\n/**\n * seq_hlist_next_rcu - move to the next position of the hlist protected by RCU\n * @v:    the current iterator\n * @head: the head of the hlist\n * @ppos: the current position\n *\n * Called at seq_file->op->next().\n *\n * This list-traversal primitive may safely run concurrently with\n * the _rcu list-mutation primitives such as hlist_add_head_rcu()\n * as long as the traversal is guarded by rcu_read_lock().\n */\nstruct hlist_node *seq_hlist_next_rcu(void *v,\n\t\t\t\t      struct hlist_head *head,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn rcu_dereference(head->first);\n\telse\n\t\treturn rcu_dereference(node->next);\n}\nEXPORT_SYMBOL(seq_hlist_next_rcu);\n\n/**\n * seq_hlist_start_percpu - start an iteration of a percpu hlist array\n * @head: pointer to percpu array of struct hlist_heads\n * @cpu:  pointer to cpu \"cursor\"\n * @pos:  start position of sequence\n *\n * Called at seq_file->op->start().\n */\nstruct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start_percpu);\n\n/**\n * seq_hlist_next_percpu - move to the next position of the percpu hlist array\n * @v:    pointer to current hlist_node\n * @head: pointer to percpu array of struct hlist_heads\n * @cpu:  pointer to cpu \"cursor\"\n * @pos:  start position of sequence\n *\n * Called at seq_file->op->next().\n */\nstruct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_next_percpu);\n\nvoid __init seq_file_init(void)\n{\n\tseq_file_cache = KMEM_CACHE(seq_file, SLAB_ACCOUNT|SLAB_PANIC);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * linux/fs/seq_file.c\n *\n * helper functions for making synthetic files from sequences of records.\n * initial implementation -- AV, Oct 2001.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cache.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/mm.h>\n#include <linux/printk.h>\n#include <linux/string_helpers.h>\n#include <linux/uio.h>\n\n#include <linux/uaccess.h>\n#include <asm/page.h>\n\nstatic struct kmem_cache *seq_file_cache __ro_after_init;\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}\n\nstatic void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}\n\n/**\n *\tseq_open -\tinitialize sequential file\n *\t@file: file we initialize\n *\t@op: method table describing the sequence\n *\n *\tseq_open() sets @file, associating it with a sequence described\n *\tby @op.  @op->start() sets the iterator up and returns the first\n *\telement of sequence. @op->stop() shuts it down.  @op->next()\n *\treturns the next element of sequence.  @op->show() prints element\n *\tinto the buffer.  In case of error ->start() and ->next() return\n *\tERR_PTR(error).  In the end of sequence they return %NULL. ->show()\n *\treturns 0 in case of success and negative number in case of error.\n *\tReturning SEQ_SKIP means \"discard this element and move on\".\n *\tNote: seq_open() will allocate a struct seq_file and store its\n *\tpointer in @file->private_data. This pointer should not be modified.\n */\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p;\n\n\tWARN_ON(file->private_data);\n\n\tp = kmem_cache_zalloc(seq_file_cache, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfile->private_data = p;\n\n\tmutex_init(&p->lock);\n\tp->op = op;\n\n\t// No refcounting: the lifetime of 'p' is constrained\n\t// to the lifetime of the file.\n\tp->file = file;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}\nEXPORT_SYMBOL(seq_open);\n\nstatic int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0;\n\tint error = 0;\n\tvoid *p;\n\n\tm->index = 0;\n\tm->count = m->from = 0;\n\tif (!offset)\n\t\treturn 0;\n\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &m->index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tp = m->op->next(m, p, &m->index);\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset)\n\t\t\tbreak;\n\t}\n\tm->op->stop(m, p);\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}\n\n/**\n *\tseq_read -\t->read() method for sequential files.\n *\t@file: the file to read from\n *\t@buf: the buffer to read to\n *\t@size: the maximum number of bytes to read\n *\t@ppos: the current position in the file\n *\n *\tReady-made ->f_op->read()\n */\nssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = size};\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tiov_iter_init(&iter, READ, &iov, 1, size);\n\n\tkiocb.ki_pos = *ppos;\n\tret = seq_read_iter(&kiocb, &iter);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}\nEXPORT_SYMBOL(seq_read);\n\n/*\n * Ready-made ->f_op->read_iter()\n */\nssize_t seq_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct seq_file *m = iocb->ki_filp->private_data;\n\tsize_t copied = 0;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * if request is to read from zero offset, reset iterator to first\n\t * record as it might have been already advanced by previous requests\n\t */\n\tif (iocb->ki_pos == 0) {\n\t\tm->index = 0;\n\t\tm->count = 0;\n\t}\n\n\t/* Don't assume ki_pos is where we left it */\n\tif (unlikely(iocb->ki_pos != m->read_pos)) {\n\t\twhile ((err = traverse(m, iocb->ki_pos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = iocb->ki_pos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t// something left in the buffer - copy it out first\n\tif (m->count) {\n\t\tn = copy_to_iter(m->buf + m->from, m->count, iter);\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tcopied += n;\n\t\tif (m->count)\t// hadn't managed to copy everything\n\t\t\tgoto Done;\n\t}\n\t// get a non-empty record in the buffer\n\tm->from = 0;\n\tp = m->op->start(m, &m->index);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\t// EOF or an error\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\t\t// hard error\n\t\t\tbreak;\n\t\tif (unlikely(err))\t// ->show() says \"skip it\"\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) { // empty record\n\t\t\tp = m->op->next(m, p, &m->index);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!seq_has_overflowed(m)) // got it\n\t\t\tgoto Fill;\n\t\t// need a bigger buffer\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tp = m->op->start(m, &m->index);\n\t}\n\t// EOF or an error\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t// one non-empty record is in the buffer; if they want more,\n\t// try to fit more in, but in any case we need to advance\n\t// the iterator once for every record shown.\n\twhile (1) {\n\t\tsize_t offs = m->count;\n\t\tloff_t pos = m->index;\n\n\t\tp = m->op->next(m, p, &m->index);\n\t\tif (pos == m->index) {\n\t\t\tpr_info_ratelimited(\"buggy .next function %ps did not update position index\\n\",\n\t\t\t\t\t    m->op->next);\n\t\t\tm->index++;\n\t\t}\n\t\tif (!p || IS_ERR(p))\t// no next record for us\n\t\t\tbreak;\n\t\tif (m->count >= iov_iter_count(iter))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err > 0) {\t\t// ->show() says \"skip it\"\n\t\t\tm->count = offs;\n\t\t} else if (err || seq_has_overflowed(m)) {\n\t\t\tm->count = offs;\n\t\t\tbreak;\n\t\t}\n\t}\n\tm->op->stop(m, p);\n\tn = copy_to_iter(m->buf, m->count, iter);\n\tcopied += n;\n\tm->count -= n;\n\tm->from = n;\nDone:\n\tif (unlikely(!copied)) {\n\t\tcopied = m->count ? -EFAULT : err;\n\t} else {\n\t\tiocb->ki_pos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\n}\nEXPORT_SYMBOL(seq_read_iter);\n\n/**\n *\tseq_lseek -\t->llseek() method for sequential files.\n *\t@file: the file in question\n *\t@offset: new position\n *\t@whence: 0 for absolute, 1 for relative position\n *\n *\tReady-made ->f_op->llseek()\n */\nloff_t seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct seq_file *m = file->private_data;\n\tloff_t retval = -EINVAL;\n\n\tmutex_lock(&m->lock);\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t\tfallthrough;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\tbreak;\n\t\tretval = offset;\n\t\tif (offset != m->read_pos) {\n\t\t\twhile ((retval = traverse(m, offset)) == -EAGAIN)\n\t\t\t\t;\n\t\t\tif (retval) {\n\t\t\t\t/* with extreme prejudice... */\n\t\t\t\tfile->f_pos = 0;\n\t\t\t\tm->read_pos = 0;\n\t\t\t\tm->index = 0;\n\t\t\t\tm->count = 0;\n\t\t\t} else {\n\t\t\t\tm->read_pos = offset;\n\t\t\t\tretval = file->f_pos = offset;\n\t\t\t}\n\t\t} else {\n\t\t\tfile->f_pos = offset;\n\t\t}\n\t}\n\tmutex_unlock(&m->lock);\n\treturn retval;\n}\nEXPORT_SYMBOL(seq_lseek);\n\n/**\n *\tseq_release -\tfree the structures associated with sequential file.\n *\t@file: file in question\n *\t@inode: its inode\n *\n *\tFrees the structures associated with sequential file; can be used\n *\tas ->f_op->release() if you don't have private data to destroy.\n */\nint seq_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tkvfree(m->buf);\n\tkmem_cache_free(seq_file_cache, m);\n\treturn 0;\n}\nEXPORT_SYMBOL(seq_release);\n\n/**\n * seq_escape_mem - print data into buffer, escaping some characters\n * @m: target buffer\n * @src: source buffer\n * @len: size of source buffer\n * @flags: flags to pass to string_escape_mem()\n * @esc: set of characters that need escaping\n *\n * Puts data into buffer, replacing each occurrence of character from\n * given class (defined by @flags and @esc) with printable escaped sequence.\n *\n * Use seq_has_overflowed() to check for errors.\n */\nvoid seq_escape_mem(struct seq_file *m, const char *src, size_t len,\n\t\t    unsigned int flags, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint ret;\n\n\tret = string_escape_mem(src, len, buf, size, flags, esc);\n\tseq_commit(m, ret < size ? ret : -1);\n}\nEXPORT_SYMBOL(seq_escape_mem);\n\n/**\n *\tseq_escape -\tprint string into buffer, escaping some characters\n *\t@m:\ttarget buffer\n *\t@s:\tstring\n *\t@esc:\tset of characters that need escaping\n *\n *\tPuts string into buffer, replacing each occurrence of character from\n *\t@esc with usual octal escape.\n *\tUse seq_has_overflowed() to check for errors.\n */\nvoid seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tseq_escape_str(m, s, ESCAPE_OCTAL, esc);\n}\nEXPORT_SYMBOL(seq_escape);\n\nvoid seq_vprintf(struct seq_file *m, const char *f, va_list args)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_vprintf);\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL(seq_printf);\n\n#ifdef CONFIG_BINARY_PRINTF\nvoid seq_bprintf(struct seq_file *m, const char *f, const u32 *binary)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = bstr_printf(m->buf + m->count, m->size - m->count, f,\n\t\t\t\t  binary);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_bprintf);\n#endif /* CONFIG_BINARY_PRINTF */\n\n/**\n *\tmangle_path -\tmangle and copy path to buffer beginning\n *\t@s: buffer start\n *\t@p: beginning of path in above buffer\n *\t@esc: set of characters that need escaping\n *\n *      Copy the path from @p to @s, replacing each occurrence of character from\n *      @esc with usual octal escape.\n *      Returns pointer past last written character in @s, or NULL in case of\n *      failure.\n */\nchar *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(mangle_path);\n\n/**\n * seq_path - seq_file interface to print a pathname\n * @m: the seq_file handle\n * @path: the struct path to print\n * @esc: set of characters to escape in the output\n *\n * return the absolute path of 'path', as represented by the\n * dentry / mnt pair in the path parameter.\n */\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(seq_path);\n\n/**\n * seq_file_path - seq_file interface to print a pathname of a file\n * @m: the seq_file handle\n * @file: the struct file to print\n * @esc: set of characters to escape in the output\n *\n * return the absolute path to the file.\n */\nint seq_file_path(struct seq_file *m, struct file *file, const char *esc)\n{\n\treturn seq_path(m, &file->f_path, esc);\n}\nEXPORT_SYMBOL(seq_file_path);\n\n/*\n * Same as seq_path, but relative to supplied root.\n */\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}\n\n/*\n * returns the path of the 'dentry' from the root of its filesystem.\n */\nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(seq_dentry);\n\nstatic void *single_start(struct seq_file *p, loff_t *pos)\n{\n\treturn NULL + (*pos == 0);\n}\n\nstatic void *single_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn NULL;\n}\n\nstatic void single_stop(struct seq_file *p, void *v)\n{\n}\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL_ACCOUNT);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(single_open);\n\nint single_open_size(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data, size_t size)\n{\n\tchar *buf = seq_buf_alloc(size);\n\tint ret;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = single_open(file, show, data);\n\tif (ret) {\n\t\tkvfree(buf);\n\t\treturn ret;\n\t}\n\t((struct seq_file *)file->private_data)->buf = buf;\n\t((struct seq_file *)file->private_data)->size = size;\n\treturn 0;\n}\nEXPORT_SYMBOL(single_open_size);\n\nint single_release(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *op = ((struct seq_file *)file->private_data)->op;\n\tint res = seq_release(inode, file);\n\tkfree(op);\n\treturn res;\n}\nEXPORT_SYMBOL(single_release);\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}\nEXPORT_SYMBOL(seq_release_private);\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL_ACCOUNT);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}\nEXPORT_SYMBOL(__seq_open_private);\n\nint seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}\nEXPORT_SYMBOL(seq_open_private);\n\nvoid seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}\nEXPORT_SYMBOL(seq_putc);\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}\nEXPORT_SYMBOL(seq_puts);\n\n/**\n * seq_put_decimal_ull_width - A helper routine for putting decimal numbers\n * \t\t\t       without rich format of printf().\n * only 'unsigned long long' is supported.\n * @m: seq_file identifying the buffer to which data should be written\n * @delimiter: a string which is printed before the number\n * @num: the number\n * @width: a minimum field width\n *\n * This routine will put strlen(delimiter) + number into seq_filed.\n * This routine is very quick when you show lots of numbers.\n * In usual cases, it will be better to use seq_printf(). It's easier to read.\n */\nvoid seq_put_decimal_ull_width(struct seq_file *m, const char *delimiter,\n\t\t\t unsigned long long num, unsigned int width)\n{\n\tint len;\n\n\tif (m->count + 2 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\tif (!width)\n\t\twidth = 1;\n\n\tif (m->count + width >= m->size)\n\t\tgoto overflow;\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num, width);\n\tif (!len)\n\t\tgoto overflow;\n\n\tm->count += len;\n\treturn;\n\noverflow:\n\tseq_set_overflow(m);\n}\n\nvoid seq_put_decimal_ull(struct seq_file *m, const char *delimiter,\n\t\t\t unsigned long long num)\n{\n\treturn seq_put_decimal_ull_width(m, delimiter, num, 0);\n}\nEXPORT_SYMBOL(seq_put_decimal_ull);\n\n/**\n * seq_put_hex_ll - put a number in hexadecimal notation\n * @m: seq_file identifying the buffer to which data should be written\n * @delimiter: a string which is printed before the number\n * @v: the number\n * @width: a minimum field width\n *\n * seq_put_hex_ll(m, \"\", v, 8) is equal to seq_printf(m, \"%08llx\", v)\n *\n * This routine is very quick when you show lots of numbers.\n * In usual cases, it will be better to use seq_printf(). It's easier to read.\n */\nvoid seq_put_hex_ll(struct seq_file *m, const char *delimiter,\n\t\t\t\tunsigned long long v, unsigned int width)\n{\n\tunsigned int len;\n\tint i;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\t/* If x is 0, the result of __builtin_clzll is undefined */\n\tif (v == 0)\n\t\tlen = 1;\n\telse\n\t\tlen = (sizeof(v) * 8 - __builtin_clzll(v) + 3) / 4;\n\n\tif (len < width)\n\t\tlen = width;\n\n\tif (m->count + len > m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tm->buf[m->count + i] = hex_asc[0xf & v];\n\t\tv = v >> 4;\n\t}\n\tm->count += len;\n}\n\nvoid seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num)\n{\n\tint len;\n\n\tif (m->count + 3 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter && delimiter[0]) {\n\t\tif (delimiter[1] == 0)\n\t\t\tseq_putc(m, delimiter[0]);\n\t\telse\n\t\t\tseq_puts(m, delimiter);\n\t}\n\n\tif (m->count + 2 >= m->size)\n\t\tgoto overflow;\n\n\tif (num < 0) {\n\t\tm->buf[m->count++] = '-';\n\t\tnum = -num;\n\t}\n\n\tif (num < 10) {\n\t\tm->buf[m->count++] = num + '0';\n\t\treturn;\n\t}\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num, 0);\n\tif (!len)\n\t\tgoto overflow;\n\n\tm->count += len;\n\treturn;\n\noverflow:\n\tseq_set_overflow(m);\n}\nEXPORT_SYMBOL(seq_put_decimal_ll);\n\n/**\n * seq_write - write arbitrary data to buffer\n * @seq: seq_file identifying the buffer to which data should be written\n * @data: data address\n * @len: number of bytes\n *\n * Return 0 on success, non-zero otherwise.\n */\nint seq_write(struct seq_file *seq, const void *data, size_t len)\n{\n\tif (seq->count + len < seq->size) {\n\t\tmemcpy(seq->buf + seq->count, data, len);\n\t\tseq->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(seq);\n\treturn -1;\n}\nEXPORT_SYMBOL(seq_write);\n\n/**\n * seq_pad - write padding spaces to buffer\n * @m: seq_file identifying the buffer to which data should be written\n * @c: the byte to append after padding if non-zero\n */\nvoid seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0) {\n\t\tif (size + m->count > m->size) {\n\t\t\tseq_set_overflow(m);\n\t\t\treturn;\n\t\t}\n\t\tmemset(m->buf + m->count, ' ', size);\n\t\tm->count += size;\n\t}\n\tif (c)\n\t\tseq_putc(m, c);\n}\nEXPORT_SYMBOL(seq_pad);\n\n/* A complete analogue of print_hex_dump() */\nvoid seq_hex_dump(struct seq_file *m, const char *prefix_str, int prefix_type,\n\t\t  int rowsize, int groupsize, const void *buf, size_t len,\n\t\t  bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint i, linelen, remaining = len;\n\tchar *buffer;\n\tsize_t size;\n\tint ret;\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tfor (i = 0; i < len && !seq_has_overflowed(m); i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\tswitch (prefix_type) {\n\t\tcase DUMP_PREFIX_ADDRESS:\n\t\t\tseq_printf(m, \"%s%p: \", prefix_str, ptr + i);\n\t\t\tbreak;\n\t\tcase DUMP_PREFIX_OFFSET:\n\t\t\tseq_printf(m, \"%s%.8x: \", prefix_str, i);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"%s\", prefix_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tsize = seq_get_buf(m, &buffer);\n\t\tret = hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t\t buffer, size, ascii);\n\t\tseq_commit(m, ret < size ? ret : -1);\n\n\t\tseq_putc(m, '\\n');\n\t}\n}\nEXPORT_SYMBOL(seq_hex_dump);\n\nstruct list_head *seq_list_start(struct list_head *head, loff_t pos)\n{\n\tstruct list_head *lh;\n\n\tlist_for_each(lh, head)\n\t\tif (pos-- == 0)\n\t\t\treturn lh;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_list_start);\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_list_start_head);\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}\nEXPORT_SYMBOL(seq_list_next);\n\n/**\n * seq_hlist_start - start an iteration of a hlist\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start().\n */\nstruct hlist_node *seq_hlist_start(struct hlist_head *head, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\thlist_for_each(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start);\n\n/**\n * seq_hlist_start_head - start an iteration of a hlist\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start(). Call this function if you want to\n * print a header at the top of the output.\n */\nstruct hlist_node *seq_hlist_start_head(struct hlist_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_hlist_start_head);\n\n/**\n * seq_hlist_next - move to the next position of the hlist\n * @v:    the current iterator\n * @head: the head of the hlist\n * @ppos: the current position\n *\n * Called at seq_file->op->next().\n */\nstruct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn head->first;\n\telse\n\t\treturn node->next;\n}\nEXPORT_SYMBOL(seq_hlist_next);\n\n/**\n * seq_hlist_start_rcu - start an iteration of a hlist protected by RCU\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start().\n *\n * This list-traversal primitive may safely run concurrently with\n * the _rcu list-mutation primitives such as hlist_add_head_rcu()\n * as long as the traversal is guarded by rcu_read_lock().\n */\nstruct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t       loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\t__hlist_for_each_rcu(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start_rcu);\n\n/**\n * seq_hlist_start_head_rcu - start an iteration of a hlist protected by RCU\n * @head: the head of the hlist\n * @pos:  the start position of the sequence\n *\n * Called at seq_file->op->start(). Call this function if you want to\n * print a header at the top of the output.\n *\n * This list-traversal primitive may safely run concurrently with\n * the _rcu list-mutation primitives such as hlist_add_head_rcu()\n * as long as the traversal is guarded by rcu_read_lock().\n */\nstruct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t    loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(head, pos - 1);\n}\nEXPORT_SYMBOL(seq_hlist_start_head_rcu);\n\n/**\n * seq_hlist_next_rcu - move to the next position of the hlist protected by RCU\n * @v:    the current iterator\n * @head: the head of the hlist\n * @ppos: the current position\n *\n * Called at seq_file->op->next().\n *\n * This list-traversal primitive may safely run concurrently with\n * the _rcu list-mutation primitives such as hlist_add_head_rcu()\n * as long as the traversal is guarded by rcu_read_lock().\n */\nstruct hlist_node *seq_hlist_next_rcu(void *v,\n\t\t\t\t      struct hlist_head *head,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn rcu_dereference(head->first);\n\telse\n\t\treturn rcu_dereference(node->next);\n}\nEXPORT_SYMBOL(seq_hlist_next_rcu);\n\n/**\n * seq_hlist_start_percpu - start an iteration of a percpu hlist array\n * @head: pointer to percpu array of struct hlist_heads\n * @cpu:  pointer to cpu \"cursor\"\n * @pos:  start position of sequence\n *\n * Called at seq_file->op->start().\n */\nstruct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_start_percpu);\n\n/**\n * seq_hlist_next_percpu - move to the next position of the percpu hlist array\n * @v:    pointer to current hlist_node\n * @head: pointer to percpu array of struct hlist_heads\n * @cpu:  pointer to cpu \"cursor\"\n * @pos:  start position of sequence\n *\n * Called at seq_file->op->next().\n */\nstruct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(seq_hlist_next_percpu);\n\nvoid __init seq_file_init(void)\n{\n\tseq_file_cache = KMEM_CACHE(seq_file, SLAB_ACCOUNT|SLAB_PANIC);\n}\n"], "filenames": ["fs/seq_file.c"], "buggy_code_start_loc": [34], "buggy_code_end_loc": [34], "fixing_code_start_loc": [35], "fixing_code_end_loc": [38], "type": "CWE-190", "message": "fs/seq_file.c in the Linux kernel 3.16 through 5.13.x before 5.13.4 does not properly restrict seq buffer allocations, leading to an integer overflow, an Out-of-bounds Write, and escalation to root by an unprivileged user, aka CID-8cae8cd89f05.", "other": {"cve": {"id": "CVE-2021-33909", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-20T19:15:09.747", "lastModified": "2023-03-01T20:14:26.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fs/seq_file.c in the Linux kernel 3.16 through 5.13.x before 5.13.4 does not properly restrict seq buffer allocations, leading to an integer overflow, an Out-of-bounds Write, and escalation to root by an unprivileged user, aka CID-8cae8cd89f05."}, {"lang": "es", "value": "Un archivo fs/seq_file.c en el kernel de Linux versiones 3.16 hasta 5.13.x anteriores a 5.13.4, no restringe apropiadamente las asignaciones de b\u00faferes seq, conllevando a un desbordamiento de enteros, una escritura fuera de l\u00edmites y una escalada a root por parte de un usuario no privilegiado, tambi\u00e9n se conoce como CID-8cae8cd89f05"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.12.43", "versionEndExcluding": "3.13", "matchCriteriaId": "39C4F3AF-A0E2-4B5A-8CEF-94A66639E158"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.16", "versionEndExcluding": "4.4.276", "matchCriteriaId": "EC5597FD-F068-49B5-99FE-8CDB79CD7682"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.276", "matchCriteriaId": "C79FFC06-9530-4CD7-B651-01D786CC925E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.240", "matchCriteriaId": "FB359B2E-773D-4D52-9915-E07A47ABE72B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.198", "matchCriteriaId": "B93AEDB9-C52B-4222-8F9A-882DAD9EF5B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.134", "matchCriteriaId": "508D9771-335F-44A6-9F2F-880DF1267A1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5", "versionEndExcluding": "5.10.52", "matchCriteriaId": "7C1E6FB6-53C8-4DC4-8AE5-93094BA39F62"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.11", "versionEndExcluding": "5.12.19", "matchCriteriaId": "34C1A2F4-DD44-4CF1-8FD4-751A0D746A9E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.13", "versionEndExcluding": "5.13.4", "matchCriteriaId": "F93FA3CC-0C79-410B-A7D7-245C2AA0723A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_session_border_controller:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "2B9F6415-2950-49FE-9CAF-8BCA4DB6DF4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_session_border_controller:8.3:*:*:*:*:*:*:*", "matchCriteriaId": "C05190B9-237F-4E2E-91EA-DB1B738864AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_session_border_controller:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "9C416FD3-2E2F-4BBC-BD5F-F896825883F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_session_border_controller:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "D886339E-EDB2-4879-BD54-1800E4CA9CAE"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:sonicwall:sma1000_firmware:*:*:*:*:*:*:*:*", "versionEndIncluding": "12.4.2-02044", "matchCriteriaId": "7F4BE1A7-14AA-4E0F-AA13-46D3B9D48F2F"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:sonicwall:sma1000:-:*:*:*:*:*:*:*", "matchCriteriaId": "DB78952C-B6BB-4A5A-A216-BA64AAC83D4D"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/163621/Sequoia-A-Deep-Root-In-Linuxs-Filesystem-Layer.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/163671/Kernel-Live-Patch-Security-Notice-LSN-0079-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/164155/Kernel-Live-Patch-Security-Notice-LSN-0081-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/165477/Kernel-Live-Patch-Security-Notice-LSN-0083-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/07/22/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/08/25/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/09/17/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/09/17/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2021/09/21/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/07/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/07/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/07/msg00016.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z4UHHIGISO3FVRF4CQNJS4IKA25ATSFU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2022-0015", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210819-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4941", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/07/20/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b"}}