{"buggy_code": ["<?php\n\n/*\n * This file is part of Flarum.\n *\n * (c) Toby Zerner <toby.zerner@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Flarum\\User\\Command;\n\nuse Flarum\\Foundation\\DispatchEventsTrait;\nuse Flarum\\User\\EmailToken;\nuse Flarum\\User\\UserRepository;\nuse Illuminate\\Contracts\\Events\\Dispatcher;\n\nclass ConfirmEmailHandler\n{\n    use DispatchEventsTrait;\n\n    /**\n     * @var \\Flarum\\User\\UserRepository\n     */\n    protected $users;\n\n    /**\n     * @param \\Flarum\\User\\UserRepository $users\n     */\n    public function __construct(Dispatcher $events, UserRepository $users)\n    {\n        $this->events = $events;\n        $this->users = $users;\n    }\n\n    /**\n     * @param ConfirmEmail $command\n     * @return \\Flarum\\User\\User\n     */\n    public function handle(ConfirmEmail $command)\n    {\n        /** @var EmailToken $token */\n        $token = EmailToken::validOrFail($command->token);\n\n        $user = $token->user;\n        $user->changeEmail($token->email);\n\n        if (! $user->is_activated) {\n            $user->activate();\n        }\n\n        $user->save();\n        $this->dispatchEventsFor($user);\n\n        $token->delete();\n\n        return $user;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * (c) Toby Zerner <toby.zerner@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Flarum\\User;\n\nuse Carbon\\Carbon;\nuse DomainException;\nuse Flarum\\Database\\AbstractModel;\nuse Flarum\\Database\\ScopeVisibilityTrait;\nuse Flarum\\Event\\ConfigureUserPreferences;\nuse Flarum\\Event\\GetDisplayName;\nuse Flarum\\Event\\PrepareUserGroups;\nuse Flarum\\Foundation\\EventGeneratorTrait;\nuse Flarum\\Group\\Group;\nuse Flarum\\Group\\Permission;\nuse Flarum\\Http\\UrlGenerator;\nuse Flarum\\Notification\\Notification;\nuse Flarum\\User\\Event\\Activated;\nuse Flarum\\User\\Event\\AvatarChanged;\nuse Flarum\\User\\Event\\CheckingPassword;\nuse Flarum\\User\\Event\\Deleted;\nuse Flarum\\User\\Event\\EmailChanged;\nuse Flarum\\User\\Event\\EmailChangeRequested;\nuse Flarum\\User\\Event\\PasswordChanged;\nuse Flarum\\User\\Event\\Registered;\nuse Flarum\\User\\Event\\Renamed;\nuse Illuminate\\Contracts\\Hashing\\Hasher;\nuse Illuminate\\Contracts\\Session\\Session;\n\n/**\n * @property int $id\n * @property string $username\n * @property string $display_name\n * @property string $email\n * @property bool $is_email_confirmed\n * @property string $password\n * @property string|null $avatar_url\n * @property array $preferences\n * @property \\Carbon\\Carbon|null $joined_at\n * @property \\Carbon\\Carbon|null $last_seen_at\n * @property \\Carbon\\Carbon|null $marked_all_as_read_at\n * @property \\Carbon\\Carbon|null $read_notifications_at\n * @property int $discussion_count\n * @property int $comment_count\n */\nclass User extends AbstractModel\n{\n    use EventGeneratorTrait;\n    use ScopeVisibilityTrait;\n\n    /**\n     * The attributes that should be mutated to dates.\n     *\n     * @var array\n     */\n    protected $dates = [\n        'joined_at',\n        'last_seen_at',\n        'marked_all_as_read_at',\n        'read_notifications_at'\n    ];\n\n    /**\n     * An array of permissions that this user has.\n     *\n     * @var string[]|null\n     */\n    protected $permissions = null;\n\n    /**\n     * @var Session\n     */\n    protected $session;\n\n    /**\n     * An array of registered user preferences. Each preference is defined with\n     * a key, and its value is an array containing the following keys:.\n     *\n     * - transformer: a callback that confines the value of the preference\n     * - default: a default value if the preference isn't set\n     *\n     * @var array\n     */\n    protected static $preferences = [];\n\n    /**\n     * The hasher with which to hash passwords.\n     *\n     * @var Hasher\n     */\n    protected static $hasher;\n\n    /**\n     * The access gate.\n     *\n     * @var Gate\n     */\n    protected static $gate;\n\n    /**\n     * Boot the model.\n     *\n     * @return void\n     */\n    public static function boot()\n    {\n        parent::boot();\n\n        // Don't allow the root admin to be deleted.\n        static::deleting(function (User $user) {\n            if ($user->id == 1) {\n                throw new DomainException('Cannot delete the root admin');\n            }\n        });\n\n        static::deleted(function (User $user) {\n            $user->raise(new Deleted($user));\n\n            Notification::whereSubject($user)->delete();\n        });\n\n        static::$dispatcher->dispatch(\n            new ConfigureUserPreferences\n        );\n    }\n\n    /**\n     * Register a new user.\n     *\n     * @param string $username\n     * @param string $email\n     * @param string $password\n     * @return static\n     */\n    public static function register($username, $email, $password)\n    {\n        $user = new static;\n\n        $user->username = $username;\n        $user->email = $email;\n        $user->password = $password;\n        $user->joined_at = Carbon::now();\n\n        $user->raise(new Registered($user));\n\n        return $user;\n    }\n\n    /**\n     * @return Gate\n     */\n    public static function getGate()\n    {\n        return static::$gate;\n    }\n\n    /**\n     * @param Gate $gate\n     */\n    public static function setGate($gate)\n    {\n        static::$gate = $gate;\n    }\n\n    /**\n     * Rename the user.\n     *\n     * @param string $username\n     * @return $this\n     */\n    public function rename($username)\n    {\n        if ($username !== $this->username) {\n            $oldUsername = $this->username;\n            $this->username = $username;\n\n            $this->raise(new Renamed($this, $oldUsername));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Change the user's email.\n     *\n     * @param string $email\n     * @return $this\n     */\n    public function changeEmail($email)\n    {\n        if ($email !== $this->email) {\n            $this->email = $email;\n\n            $this->raise(new EmailChanged($this));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Request that the user's email be changed.\n     *\n     * @param string $email\n     * @return $this\n     */\n    public function requestEmailChange($email)\n    {\n        if ($email !== $this->email) {\n            $this->raise(new EmailChangeRequested($this, $email));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Change the user's password.\n     *\n     * @param string $password\n     * @return $this\n     */\n    public function changePassword($password)\n    {\n        $this->password = $password;\n\n        $this->raise(new PasswordChanged($this));\n\n        return $this;\n    }\n\n    /**\n     * Set the password attribute, storing it as a hash.\n     *\n     * @param string $value\n     */\n    public function setPasswordAttribute($value)\n    {\n        $this->attributes['password'] = $value ? static::$hasher->make($value) : '';\n    }\n\n    /**\n     * Mark all discussions as read.\n     *\n     * @return $this\n     */\n    public function markAllAsRead()\n    {\n        $this->marked_all_as_read_at = Carbon::now();\n\n        return $this;\n    }\n\n    /**\n     * Mark all notifications as read.\n     *\n     * @return $this\n     */\n    public function markNotificationsAsRead()\n    {\n        $this->read_notifications_at = Carbon::now();\n\n        return $this;\n    }\n\n    /**\n     * Change the path of the user avatar.\n     *\n     * @param string $path\n     * @return $this\n     */\n    public function changeAvatarPath($path)\n    {\n        $this->avatar_url = $path;\n\n        $this->raise(new AvatarChanged($this));\n\n        return $this;\n    }\n\n    /**\n     * Get the URL of the user's avatar.\n     *\n     * @todo Allow different storage locations to be used\n     * @param string|null $value\n     * @return string\n     */\n    public function getAvatarUrlAttribute(string $value = null)\n    {\n        if ($value && strpos($value, '://') === false) {\n            return app(UrlGenerator::class)->to('forum')->path('assets/avatars/'.$value);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Get the user's display name.\n     *\n     * @return string\n     */\n    public function getDisplayNameAttribute()\n    {\n        return static::$dispatcher->until(new GetDisplayName($this)) ?: $this->username;\n    }\n\n    /**\n     * Check if a given password matches the user's password.\n     *\n     * @param string $password\n     * @return bool\n     */\n    public function checkPassword($password)\n    {\n        $valid = static::$dispatcher->until(new CheckingPassword($this, $password));\n\n        if ($valid !== null) {\n            return $valid;\n        }\n\n        return static::$hasher->check($password, $this->password);\n    }\n\n    /**\n     * Activate the user's account.\n     *\n     * @return $this\n     */\n    public function activate()\n    {\n        if ($this->is_email_confirmed !== true) {\n            $this->is_email_confirmed = true;\n\n            $this->raise(new Activated($this));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Check whether the user has a certain permission based on their groups.\n     *\n     * @param string $permission\n     * @return bool\n     */\n    public function hasPermission($permission)\n    {\n        if ($this->isAdmin()) {\n            return true;\n        }\n\n        if (is_null($this->permissions)) {\n            $this->permissions = $this->getPermissions();\n        }\n\n        return in_array($permission, $this->permissions);\n    }\n\n    /**\n     * Check whether the user has a permission that is like the given string,\n     * based on their groups.\n     *\n     * @param string $match\n     * @return bool\n     */\n    public function hasPermissionLike($match)\n    {\n        if ($this->isAdmin()) {\n            return true;\n        }\n\n        if (is_null($this->permissions)) {\n            $this->permissions = $this->getPermissions();\n        }\n\n        foreach ($this->permissions as $permission) {\n            if (substr($permission, -strlen($match)) === $match) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get the notification types that should be alerted to this user, according\n     * to their preferences.\n     *\n     * @return array\n     */\n    public function getAlertableNotificationTypes()\n    {\n        $types = array_keys(Notification::getSubjectModels());\n\n        return array_filter($types, [$this, 'shouldAlert']);\n    }\n\n    /**\n     * Get the number of unread notifications for the user.\n     *\n     * @return int\n     */\n    public function getUnreadNotificationCount()\n    {\n        return $this->getUnreadNotifications()->count();\n    }\n\n    /**\n     * Get all notifications that have not been read yet.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Collection\n     */\n    protected function getUnreadNotifications()\n    {\n        static $cached = null;\n\n        if (is_null($cached)) {\n            $cached = $this->notifications()\n                ->whereIn('type', $this->getAlertableNotificationTypes())\n                ->whereNull('read_at')\n                ->where('is_deleted', false)\n                ->whereSubjectVisibleTo($this)\n                ->get();\n        }\n\n        return $cached;\n    }\n\n    /**\n     * Get the number of new, unseen notifications for the user.\n     *\n     * @return int\n     */\n    public function getNewNotificationCount()\n    {\n        return $this->getUnreadNotifications()->filter(function ($notification) {\n            return $notification->created_at > $this->read_notifications_at ?: 0;\n        })->count();\n    }\n\n    /**\n     * Get the values of all registered preferences for this user, by\n     * transforming their stored preferences and merging them with the defaults.\n     *\n     * @param string $value\n     * @return array\n     */\n    public function getPreferencesAttribute($value)\n    {\n        $defaults = array_map(function ($value) {\n            return $value['default'];\n        }, static::$preferences);\n\n        $user = array_only((array) json_decode($value, true), array_keys(static::$preferences));\n\n        return array_merge($defaults, $user);\n    }\n\n    /**\n     * Encode an array of preferences for storage in the database.\n     *\n     * @param mixed $value\n     */\n    public function setPreferencesAttribute($value)\n    {\n        $this->attributes['preferences'] = json_encode($value);\n    }\n\n    /**\n     * Check whether or not the user should receive an alert for a notification\n     * type.\n     *\n     * @param string $type\n     * @return bool\n     */\n    public function shouldAlert($type)\n    {\n        return (bool) $this->getPreference(static::getNotificationPreferenceKey($type, 'alert'));\n    }\n\n    /**\n     * Check whether or not the user should receive an email for a notification\n     * type.\n     *\n     * @param string $type\n     * @return bool\n     */\n    public function shouldEmail($type)\n    {\n        return (bool) $this->getPreference(static::getNotificationPreferenceKey($type, 'email'));\n    }\n\n    /**\n     * Get the value of a preference for this user.\n     *\n     * @param string $key\n     * @param mixed $default\n     * @return mixed\n     */\n    public function getPreference($key, $default = null)\n    {\n        return array_get($this->preferences, $key, $default);\n    }\n\n    /**\n     * Set the value of a preference for this user.\n     *\n     * @param string $key\n     * @param mixed $value\n     * @return $this\n     */\n    public function setPreference($key, $value)\n    {\n        if (isset(static::$preferences[$key])) {\n            $preferences = $this->preferences;\n\n            if (! is_null($transformer = static::$preferences[$key]['transformer'])) {\n                $preferences[$key] = call_user_func($transformer, $value);\n            } else {\n                $preferences[$key] = $value;\n            }\n\n            $this->preferences = $preferences;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Set the user as being last seen just now.\n     *\n     * @return $this\n     */\n    public function updateLastSeen()\n    {\n        $this->last_seen_at = Carbon::now();\n\n        return $this;\n    }\n\n    /**\n     * Check whether or not the user is an administrator.\n     *\n     * @return bool\n     */\n    public function isAdmin()\n    {\n        return $this->groups->contains(Group::ADMINISTRATOR_ID);\n    }\n\n    /**\n     * Check whether or not the user is a guest.\n     *\n     * @return bool\n     */\n    public function isGuest()\n    {\n        return false;\n    }\n\n    /**\n     * Define the relationship with the user's posts.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function posts()\n    {\n        return $this->hasMany('Flarum\\Post\\Post');\n    }\n\n    /**\n     * Define the relationship with the user's discussions.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function discussions()\n    {\n        return $this->hasMany('Flarum\\Discussion\\Discussion');\n    }\n\n    /**\n     * Define the relationship with the user's read discussions.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\BelongsTo\n     */\n    public function read()\n    {\n        return $this->belongsToMany('Flarum\\Discussion\\Discussion');\n    }\n\n    /**\n     * Define the relationship with the user's groups.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany\n     */\n    public function groups()\n    {\n        return $this->belongsToMany('Flarum\\Group\\Group');\n    }\n\n    /**\n     * Define the relationship with the user's notifications.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function notifications()\n    {\n        return $this->hasMany('Flarum\\Notification\\Notification');\n    }\n\n    /**\n     * Define the relationship with the permissions of all of the groups that\n     * the user is in.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n     */\n    public function permissions()\n    {\n        $groupIds = [Group::GUEST_ID];\n\n        // If a user's account hasn't been activated, they are essentially no\n        // more than a guest. If they are activated, we can give them the\n        // standard 'member' group, as well as any other groups they've been\n        // assigned to.\n        if ($this->is_email_confirmed) {\n            $groupIds = array_merge($groupIds, [Group::MEMBER_ID], $this->groups->pluck('id')->all());\n        }\n\n        event(new PrepareUserGroups($this, $groupIds));\n\n        return Permission::whereIn('group_id', $groupIds);\n    }\n\n    /**\n     * Get a list of permissions that the user has.\n     *\n     * @return string[]\n     */\n    public function getPermissions()\n    {\n        return $this->permissions()->pluck('permission')->all();\n    }\n\n    /**\n     * Define the relationship with the user's access tokens.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function accessTokens()\n    {\n        return $this->hasMany('Flarum\\Http\\AccessToken');\n    }\n\n    /**\n     * Get the user's login providers.\n     */\n    public function loginProviders()\n    {\n        return $this->hasMany(LoginProvider::class);\n    }\n\n    /**\n     * @param string $ability\n     * @param array|mixed $arguments\n     * @return bool\n     */\n    public function can($ability, $arguments = [])\n    {\n        return static::$gate->forUser($this)->allows($ability, $arguments);\n    }\n\n    /**\n     * @param string $ability\n     * @param array|mixed $arguments\n     * @return bool\n     */\n    public function cannot($ability, $arguments = [])\n    {\n        return ! $this->can($ability, $arguments);\n    }\n\n    /**\n     * @return Session\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * @param Session $session\n     */\n    public function setSession(Session $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Set the hasher with which to hash passwords.\n     *\n     * @param Hasher $hasher\n     */\n    public static function setHasher(Hasher $hasher)\n    {\n        static::$hasher = $hasher;\n    }\n\n    /**\n     * Register a preference with a transformer and a default value.\n     *\n     * @param string $key\n     * @param callable $transformer\n     * @param mixed $default\n     */\n    public static function addPreference($key, callable $transformer = null, $default = null)\n    {\n        static::$preferences[$key] = compact('transformer', 'default');\n    }\n\n    /**\n     * Get the key for a preference which flags whether or not the user will\n     * receive a notification for $type via $method.\n     *\n     * @param string $type\n     * @param string $method\n     * @return string\n     */\n    public static function getNotificationPreferenceKey($type, $method)\n    {\n        return 'notify_'.$type.'_'.$method;\n    }\n\n    /**\n     * Refresh the user's comments count.\n     *\n     * @return $this\n     */\n    public function refreshCommentCount()\n    {\n        $this->comment_count = $this->posts()->count();\n\n        return $this;\n    }\n\n    /**\n     * Refresh the user's comments count.\n     *\n     * @return $this\n     */\n    public function refreshDiscussionCount()\n    {\n        $this->discussion_count = $this->discussions()->count();\n\n        return $this;\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of Flarum.\n *\n * (c) Toby Zerner <toby.zerner@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Flarum\\User\\Command;\n\nuse Flarum\\Foundation\\DispatchEventsTrait;\nuse Flarum\\User\\EmailToken;\nuse Flarum\\User\\UserRepository;\nuse Illuminate\\Contracts\\Events\\Dispatcher;\n\nclass ConfirmEmailHandler\n{\n    use DispatchEventsTrait;\n\n    /**\n     * @var \\Flarum\\User\\UserRepository\n     */\n    protected $users;\n\n    /**\n     * @param \\Flarum\\User\\UserRepository $users\n     */\n    public function __construct(Dispatcher $events, UserRepository $users)\n    {\n        $this->events = $events;\n        $this->users = $users;\n    }\n\n    /**\n     * @param ConfirmEmail $command\n     * @return \\Flarum\\User\\User\n     */\n    public function handle(ConfirmEmail $command)\n    {\n        /** @var EmailToken $token */\n        $token = EmailToken::validOrFail($command->token);\n\n        $user = $token->user;\n        $user->changeEmail($token->email);\n\n        if (! $user->is_activated) {\n            $user->activate();\n        }\n\n        $user->save();\n        $this->dispatchEventsFor($user);\n\n        // Delete *all* tokens for the user, in case other ones were sent first\n        $user->emailTokens()->delete();\n\n        return $user;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * (c) Toby Zerner <toby.zerner@gmail.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Flarum\\User;\n\nuse Carbon\\Carbon;\nuse DomainException;\nuse Flarum\\Database\\AbstractModel;\nuse Flarum\\Database\\ScopeVisibilityTrait;\nuse Flarum\\Event\\ConfigureUserPreferences;\nuse Flarum\\Event\\GetDisplayName;\nuse Flarum\\Event\\PrepareUserGroups;\nuse Flarum\\Foundation\\EventGeneratorTrait;\nuse Flarum\\Group\\Group;\nuse Flarum\\Group\\Permission;\nuse Flarum\\Http\\UrlGenerator;\nuse Flarum\\Notification\\Notification;\nuse Flarum\\User\\Event\\Activated;\nuse Flarum\\User\\Event\\AvatarChanged;\nuse Flarum\\User\\Event\\CheckingPassword;\nuse Flarum\\User\\Event\\Deleted;\nuse Flarum\\User\\Event\\EmailChanged;\nuse Flarum\\User\\Event\\EmailChangeRequested;\nuse Flarum\\User\\Event\\PasswordChanged;\nuse Flarum\\User\\Event\\Registered;\nuse Flarum\\User\\Event\\Renamed;\nuse Illuminate\\Contracts\\Hashing\\Hasher;\nuse Illuminate\\Contracts\\Session\\Session;\n\n/**\n * @property int $id\n * @property string $username\n * @property string $display_name\n * @property string $email\n * @property bool $is_email_confirmed\n * @property string $password\n * @property string|null $avatar_url\n * @property array $preferences\n * @property \\Carbon\\Carbon|null $joined_at\n * @property \\Carbon\\Carbon|null $last_seen_at\n * @property \\Carbon\\Carbon|null $marked_all_as_read_at\n * @property \\Carbon\\Carbon|null $read_notifications_at\n * @property int $discussion_count\n * @property int $comment_count\n */\nclass User extends AbstractModel\n{\n    use EventGeneratorTrait;\n    use ScopeVisibilityTrait;\n\n    /**\n     * The attributes that should be mutated to dates.\n     *\n     * @var array\n     */\n    protected $dates = [\n        'joined_at',\n        'last_seen_at',\n        'marked_all_as_read_at',\n        'read_notifications_at'\n    ];\n\n    /**\n     * An array of permissions that this user has.\n     *\n     * @var string[]|null\n     */\n    protected $permissions = null;\n\n    /**\n     * @var Session\n     */\n    protected $session;\n\n    /**\n     * An array of registered user preferences. Each preference is defined with\n     * a key, and its value is an array containing the following keys:.\n     *\n     * - transformer: a callback that confines the value of the preference\n     * - default: a default value if the preference isn't set\n     *\n     * @var array\n     */\n    protected static $preferences = [];\n\n    /**\n     * The hasher with which to hash passwords.\n     *\n     * @var Hasher\n     */\n    protected static $hasher;\n\n    /**\n     * The access gate.\n     *\n     * @var Gate\n     */\n    protected static $gate;\n\n    /**\n     * Boot the model.\n     *\n     * @return void\n     */\n    public static function boot()\n    {\n        parent::boot();\n\n        // Don't allow the root admin to be deleted.\n        static::deleting(function (User $user) {\n            if ($user->id == 1) {\n                throw new DomainException('Cannot delete the root admin');\n            }\n        });\n\n        static::deleted(function (User $user) {\n            $user->raise(new Deleted($user));\n\n            Notification::whereSubject($user)->delete();\n        });\n\n        static::$dispatcher->dispatch(\n            new ConfigureUserPreferences\n        );\n    }\n\n    /**\n     * Register a new user.\n     *\n     * @param string $username\n     * @param string $email\n     * @param string $password\n     * @return static\n     */\n    public static function register($username, $email, $password)\n    {\n        $user = new static;\n\n        $user->username = $username;\n        $user->email = $email;\n        $user->password = $password;\n        $user->joined_at = Carbon::now();\n\n        $user->raise(new Registered($user));\n\n        return $user;\n    }\n\n    /**\n     * @return Gate\n     */\n    public static function getGate()\n    {\n        return static::$gate;\n    }\n\n    /**\n     * @param Gate $gate\n     */\n    public static function setGate($gate)\n    {\n        static::$gate = $gate;\n    }\n\n    /**\n     * Rename the user.\n     *\n     * @param string $username\n     * @return $this\n     */\n    public function rename($username)\n    {\n        if ($username !== $this->username) {\n            $oldUsername = $this->username;\n            $this->username = $username;\n\n            $this->raise(new Renamed($this, $oldUsername));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Change the user's email.\n     *\n     * @param string $email\n     * @return $this\n     */\n    public function changeEmail($email)\n    {\n        if ($email !== $this->email) {\n            $this->email = $email;\n\n            $this->raise(new EmailChanged($this));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Request that the user's email be changed.\n     *\n     * @param string $email\n     * @return $this\n     */\n    public function requestEmailChange($email)\n    {\n        if ($email !== $this->email) {\n            $this->raise(new EmailChangeRequested($this, $email));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Change the user's password.\n     *\n     * @param string $password\n     * @return $this\n     */\n    public function changePassword($password)\n    {\n        $this->password = $password;\n\n        $this->raise(new PasswordChanged($this));\n\n        return $this;\n    }\n\n    /**\n     * Set the password attribute, storing it as a hash.\n     *\n     * @param string $value\n     */\n    public function setPasswordAttribute($value)\n    {\n        $this->attributes['password'] = $value ? static::$hasher->make($value) : '';\n    }\n\n    /**\n     * Mark all discussions as read.\n     *\n     * @return $this\n     */\n    public function markAllAsRead()\n    {\n        $this->marked_all_as_read_at = Carbon::now();\n\n        return $this;\n    }\n\n    /**\n     * Mark all notifications as read.\n     *\n     * @return $this\n     */\n    public function markNotificationsAsRead()\n    {\n        $this->read_notifications_at = Carbon::now();\n\n        return $this;\n    }\n\n    /**\n     * Change the path of the user avatar.\n     *\n     * @param string $path\n     * @return $this\n     */\n    public function changeAvatarPath($path)\n    {\n        $this->avatar_url = $path;\n\n        $this->raise(new AvatarChanged($this));\n\n        return $this;\n    }\n\n    /**\n     * Get the URL of the user's avatar.\n     *\n     * @todo Allow different storage locations to be used\n     * @param string|null $value\n     * @return string\n     */\n    public function getAvatarUrlAttribute(string $value = null)\n    {\n        if ($value && strpos($value, '://') === false) {\n            return app(UrlGenerator::class)->to('forum')->path('assets/avatars/'.$value);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Get the user's display name.\n     *\n     * @return string\n     */\n    public function getDisplayNameAttribute()\n    {\n        return static::$dispatcher->until(new GetDisplayName($this)) ?: $this->username;\n    }\n\n    /**\n     * Check if a given password matches the user's password.\n     *\n     * @param string $password\n     * @return bool\n     */\n    public function checkPassword($password)\n    {\n        $valid = static::$dispatcher->until(new CheckingPassword($this, $password));\n\n        if ($valid !== null) {\n            return $valid;\n        }\n\n        return static::$hasher->check($password, $this->password);\n    }\n\n    /**\n     * Activate the user's account.\n     *\n     * @return $this\n     */\n    public function activate()\n    {\n        if ($this->is_email_confirmed !== true) {\n            $this->is_email_confirmed = true;\n\n            $this->raise(new Activated($this));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Check whether the user has a certain permission based on their groups.\n     *\n     * @param string $permission\n     * @return bool\n     */\n    public function hasPermission($permission)\n    {\n        if ($this->isAdmin()) {\n            return true;\n        }\n\n        if (is_null($this->permissions)) {\n            $this->permissions = $this->getPermissions();\n        }\n\n        return in_array($permission, $this->permissions);\n    }\n\n    /**\n     * Check whether the user has a permission that is like the given string,\n     * based on their groups.\n     *\n     * @param string $match\n     * @return bool\n     */\n    public function hasPermissionLike($match)\n    {\n        if ($this->isAdmin()) {\n            return true;\n        }\n\n        if (is_null($this->permissions)) {\n            $this->permissions = $this->getPermissions();\n        }\n\n        foreach ($this->permissions as $permission) {\n            if (substr($permission, -strlen($match)) === $match) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get the notification types that should be alerted to this user, according\n     * to their preferences.\n     *\n     * @return array\n     */\n    public function getAlertableNotificationTypes()\n    {\n        $types = array_keys(Notification::getSubjectModels());\n\n        return array_filter($types, [$this, 'shouldAlert']);\n    }\n\n    /**\n     * Get the number of unread notifications for the user.\n     *\n     * @return int\n     */\n    public function getUnreadNotificationCount()\n    {\n        return $this->getUnreadNotifications()->count();\n    }\n\n    /**\n     * Get all notifications that have not been read yet.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Collection\n     */\n    protected function getUnreadNotifications()\n    {\n        static $cached = null;\n\n        if (is_null($cached)) {\n            $cached = $this->notifications()\n                ->whereIn('type', $this->getAlertableNotificationTypes())\n                ->whereNull('read_at')\n                ->where('is_deleted', false)\n                ->whereSubjectVisibleTo($this)\n                ->get();\n        }\n\n        return $cached;\n    }\n\n    /**\n     * Get the number of new, unseen notifications for the user.\n     *\n     * @return int\n     */\n    public function getNewNotificationCount()\n    {\n        return $this->getUnreadNotifications()->filter(function ($notification) {\n            return $notification->created_at > $this->read_notifications_at ?: 0;\n        })->count();\n    }\n\n    /**\n     * Get the values of all registered preferences for this user, by\n     * transforming their stored preferences and merging them with the defaults.\n     *\n     * @param string $value\n     * @return array\n     */\n    public function getPreferencesAttribute($value)\n    {\n        $defaults = array_map(function ($value) {\n            return $value['default'];\n        }, static::$preferences);\n\n        $user = array_only((array) json_decode($value, true), array_keys(static::$preferences));\n\n        return array_merge($defaults, $user);\n    }\n\n    /**\n     * Encode an array of preferences for storage in the database.\n     *\n     * @param mixed $value\n     */\n    public function setPreferencesAttribute($value)\n    {\n        $this->attributes['preferences'] = json_encode($value);\n    }\n\n    /**\n     * Check whether or not the user should receive an alert for a notification\n     * type.\n     *\n     * @param string $type\n     * @return bool\n     */\n    public function shouldAlert($type)\n    {\n        return (bool) $this->getPreference(static::getNotificationPreferenceKey($type, 'alert'));\n    }\n\n    /**\n     * Check whether or not the user should receive an email for a notification\n     * type.\n     *\n     * @param string $type\n     * @return bool\n     */\n    public function shouldEmail($type)\n    {\n        return (bool) $this->getPreference(static::getNotificationPreferenceKey($type, 'email'));\n    }\n\n    /**\n     * Get the value of a preference for this user.\n     *\n     * @param string $key\n     * @param mixed $default\n     * @return mixed\n     */\n    public function getPreference($key, $default = null)\n    {\n        return array_get($this->preferences, $key, $default);\n    }\n\n    /**\n     * Set the value of a preference for this user.\n     *\n     * @param string $key\n     * @param mixed $value\n     * @return $this\n     */\n    public function setPreference($key, $value)\n    {\n        if (isset(static::$preferences[$key])) {\n            $preferences = $this->preferences;\n\n            if (! is_null($transformer = static::$preferences[$key]['transformer'])) {\n                $preferences[$key] = call_user_func($transformer, $value);\n            } else {\n                $preferences[$key] = $value;\n            }\n\n            $this->preferences = $preferences;\n        }\n\n        return $this;\n    }\n\n    /**\n     * Set the user as being last seen just now.\n     *\n     * @return $this\n     */\n    public function updateLastSeen()\n    {\n        $this->last_seen_at = Carbon::now();\n\n        return $this;\n    }\n\n    /**\n     * Check whether or not the user is an administrator.\n     *\n     * @return bool\n     */\n    public function isAdmin()\n    {\n        return $this->groups->contains(Group::ADMINISTRATOR_ID);\n    }\n\n    /**\n     * Check whether or not the user is a guest.\n     *\n     * @return bool\n     */\n    public function isGuest()\n    {\n        return false;\n    }\n\n    /**\n     * Define the relationship with the user's posts.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function posts()\n    {\n        return $this->hasMany('Flarum\\Post\\Post');\n    }\n\n    /**\n     * Define the relationship with the user's discussions.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function discussions()\n    {\n        return $this->hasMany('Flarum\\Discussion\\Discussion');\n    }\n\n    /**\n     * Define the relationship with the user's read discussions.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\BelongsTo\n     */\n    public function read()\n    {\n        return $this->belongsToMany('Flarum\\Discussion\\Discussion');\n    }\n\n    /**\n     * Define the relationship with the user's groups.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany\n     */\n    public function groups()\n    {\n        return $this->belongsToMany('Flarum\\Group\\Group');\n    }\n\n    /**\n     * Define the relationship with the user's notifications.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function notifications()\n    {\n        return $this->hasMany('Flarum\\Notification\\Notification');\n    }\n\n    /**\n     * Define the relationship with the user's email tokens.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function emailTokens()\n    {\n        return $this->hasMany(EmailToken::class);\n    }\n\n    /**\n     * Define the relationship with the permissions of all of the groups that\n     * the user is in.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n     */\n    public function permissions()\n    {\n        $groupIds = [Group::GUEST_ID];\n\n        // If a user's account hasn't been activated, they are essentially no\n        // more than a guest. If they are activated, we can give them the\n        // standard 'member' group, as well as any other groups they've been\n        // assigned to.\n        if ($this->is_email_confirmed) {\n            $groupIds = array_merge($groupIds, [Group::MEMBER_ID], $this->groups->pluck('id')->all());\n        }\n\n        event(new PrepareUserGroups($this, $groupIds));\n\n        return Permission::whereIn('group_id', $groupIds);\n    }\n\n    /**\n     * Get a list of permissions that the user has.\n     *\n     * @return string[]\n     */\n    public function getPermissions()\n    {\n        return $this->permissions()->pluck('permission')->all();\n    }\n\n    /**\n     * Define the relationship with the user's access tokens.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function accessTokens()\n    {\n        return $this->hasMany('Flarum\\Http\\AccessToken');\n    }\n\n    /**\n     * Get the user's login providers.\n     */\n    public function loginProviders()\n    {\n        return $this->hasMany(LoginProvider::class);\n    }\n\n    /**\n     * @param string $ability\n     * @param array|mixed $arguments\n     * @return bool\n     */\n    public function can($ability, $arguments = [])\n    {\n        return static::$gate->forUser($this)->allows($ability, $arguments);\n    }\n\n    /**\n     * @param string $ability\n     * @param array|mixed $arguments\n     * @return bool\n     */\n    public function cannot($ability, $arguments = [])\n    {\n        return ! $this->can($ability, $arguments);\n    }\n\n    /**\n     * @return Session\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * @param Session $session\n     */\n    public function setSession(Session $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Set the hasher with which to hash passwords.\n     *\n     * @param Hasher $hasher\n     */\n    public static function setHasher(Hasher $hasher)\n    {\n        static::$hasher = $hasher;\n    }\n\n    /**\n     * Register a preference with a transformer and a default value.\n     *\n     * @param string $key\n     * @param callable $transformer\n     * @param mixed $default\n     */\n    public static function addPreference($key, callable $transformer = null, $default = null)\n    {\n        static::$preferences[$key] = compact('transformer', 'default');\n    }\n\n    /**\n     * Get the key for a preference which flags whether or not the user will\n     * receive a notification for $type via $method.\n     *\n     * @param string $type\n     * @param string $method\n     * @return string\n     */\n    public static function getNotificationPreferenceKey($type, $method)\n    {\n        return 'notify_'.$type.'_'.$method;\n    }\n\n    /**\n     * Refresh the user's comments count.\n     *\n     * @return $this\n     */\n    public function refreshCommentCount()\n    {\n        $this->comment_count = $this->posts()->count();\n\n        return $this;\n    }\n\n    /**\n     * Refresh the user's comments count.\n     *\n     * @return $this\n     */\n    public function refreshDiscussionCount()\n    {\n        $this->discussion_count = $this->discussions()->count();\n\n        return $this;\n    }\n}\n"], "filenames": ["src/User/Command/ConfirmEmailHandler.php", "src/User/User.php"], "buggy_code_start_loc": [56, 617], "buggy_code_end_loc": [57, 617], "fixing_code_start_loc": [56, 618], "fixing_code_end_loc": [58, 628], "type": "CWE-459", "message": "User/Command/ConfirmEmailHandler.php in Flarum before 0.1.0-beta.8 mishandles invalidation of user email tokens.", "other": {"cve": {"id": "CVE-2019-11514", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-25T03:29:00.370", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "User/Command/ConfirmEmailHandler.php in Flarum before 0.1.0-beta.8 mishandles invalidation of user email tokens."}, {"lang": "es", "value": "User/Command/ConfirmEmailHandler.php en Flarum, en versiones anteriores a 0.1.0-beta.8, manipula mal la invalidaci\u00f3n de los tokens de correo electr\u00f3nico del usuario."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-459"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:-:*:*:*:*:*:*", "matchCriteriaId": "D9EF6C49-5066-4252-8356-6109F26CD021"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta:*:*:*:*:*:*", "matchCriteriaId": "D7B3CDA0-6E1A-44EF-96E9-52197EE9BD57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "29211245-B5E7-4D83-BE77-573D8DF19079"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "5122F0A6-28F6-4DF5-89E2-850C67729C59"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "3D9BAA2E-3888-4B81-BB41-6053CBEE20DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "637415E5-2EE1-4D2C-BB25-56E59827F060"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "6CB8737B-762D-4ACA-B172-D36F8A93365A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "36954DAE-127A-4259-8BB6-99B8EF347348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta7.1:*:*:*:*:*:*", "matchCriteriaId": "5A5962B6-2742-46C8-AB55-15E5E6997045"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:0.1.0:beta7.2:*:*:*:*:*:*", "matchCriteriaId": "EE5F5C50-C597-4B0A-B048-5F294C1DFE57"}]}]}], "references": [{"url": "https://discuss.flarum.org/d/17745-flarum-0-1-0-beta-8-released", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/flarum/core/commit/66607a56749339d50620b049701ad4d6a4dafbd7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flarum/core/commit/66607a56749339d50620b049701ad4d6a4dafbd7"}}