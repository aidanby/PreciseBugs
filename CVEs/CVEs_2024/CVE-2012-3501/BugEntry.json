{"buggy_code": ["/*\n *  Copyright (C) 2005-2012 Gilles Darold\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *  Some part of the code of squidclamav are learn or simply copy/paste\n *  from the srv_clamav c-icap service written by Christos Tsantilas.\n *\n *  Copyright (C) 2004 Christos Tsantilas\n *\n * Thanks to him for his great work.\n*/\n\n#include \"c-icap.h\"\n#include \"service.h\"\n#include \"header.h\"\n#include \"body.h\"\n#include \"simple_api.h\"\n#include \"debug.h\"\n#include \"cfg_param.h\"\n#include \"squidclamav.h\"\n#include \"filetype.h\"\n#include \"ci_threads.h\"\n#include \"mem.h\"\n#include \"commands.h\"\n#include <errno.h>\n#include <signal.h>\n\n/* Structure used to store information passed throught the module methods */\ntypedef struct av_req_data{\n     ci_simple_file_t *body;\n     ci_request_t *req;\n     ci_membuf_t *error_page;\n     int blocked;\n     int no_more_scan;\n     int virus;\n     char *url;\n     char *user;\n     char *clientip;\n} av_req_data_t;\n\nstatic int SEND_PERCENT_BYTES = 0;\nstatic ci_off_t START_SEND_AFTER = 1;\n\n/*squidclamav service extra data ... */\nci_service_xdata_t *squidclamav_xdata = NULL;\n\nint AVREQDATA_POOL = -1;\n\nint squidclamav_init_service(ci_service_xdata_t * srv_xdata, struct ci_server_conf *server_conf);\nint squidclamav_post_init_service(ci_service_xdata_t * srv_xdata, struct ci_server_conf *server_conf);\nvoid squidclamav_close_service();\nint squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t *);\nint squidclamav_end_of_data_handler(ci_request_t *);\nvoid *squidclamav_init_request_data(ci_request_t * req);\nvoid squidclamav_release_request_data(void *data);\nint squidclamav_io(char *wbuf, int *wlen, char *rbuf, int *rlen, int iseof, ci_request_t * req);\n\n/* General functions */\nvoid set_istag(ci_service_xdata_t * srv_xdata);\n\n/* Declare SquidClamav C-ICAP service */ \nCI_DECLARE_MOD_DATA ci_service_module_t service = {\n     \"squidclamav\",                    /*Module name */\n     \"SquidClamav/Antivirus service\", /* Module short description */\n     ICAP_RESPMOD | ICAP_REQMOD,      /* Service type modification */\n     squidclamav_init_service,          /* init_service. */\n     squidclamav_post_init_service,     /* post_init_service. */\n     squidclamav_close_service,         /* close_service */\n     squidclamav_init_request_data,     /* init_request_data. */\n     squidclamav_release_request_data,  /* release request data */\n     squidclamav_check_preview_handler, /* Preview data */\n     squidclamav_end_of_data_handler,   /* when all data has been received */\n     squidclamav_io,\n     NULL,\n     NULL\n};\n\nint debug = 0;\nint statit = 0;\nint timeout = 1;\nchar *redirect_url = NULL;\nchar *squidguard = NULL;\nchar *clamd_local = NULL;\nchar *clamd_ip = NULL;\nchar *clamd_port = NULL;\nchar *clamd_curr_ip = NULL;\nSCPattern *patterns = NULL;\nint pattc = 0;\nint current_pattern_size = 0;\nci_off_t maxsize = 0;\nint logredir = 0;\nint dnslookup = 1;\n\n/* Used by pipe to squidGuard */\nint usepipe = 0;\npid_t pid;\nFILE *sgfpw = NULL;\nFILE *sgfpr = NULL;\n\n\n/* --------------- URL CHECK --------------------------- */\n\n#define MAX_URL_SIZE  8192\n#define MAX_METHOD_SIZE  16\n#define SMALL_BUFF 1024\n\nstruct http_info {\n    char method[MAX_METHOD_SIZE];\n    char url[MAX_URL_SIZE];\n};\n\nint extract_http_info(ci_request_t *, ci_headers_list_t *, struct http_info *);\nchar *http_content_type(ci_request_t *);\nvoid free_global ();\nvoid free_pipe ();\nvoid generate_redirect_page(char *, ci_request_t *, av_req_data_t *);\nvoid cfgreload_command(char *, int, char **);\nint create_pipe(char *command);\nint dconnect (void);\nint connectINET(char *serverHost, uint16_t serverPort);\n\n\n/* ----------------------------------------------------- */\n\n\nint squidclamav_init_service(ci_service_xdata_t * srv_xdata,\n                           struct ci_server_conf *server_conf)\n{\n    unsigned int xops;\n\n    ci_debug_printf(1, \"DEBUG squidclamav_init_service: Going to initialize squidclamav\\n\");\n\n    squidclamav_xdata = srv_xdata;\n    set_istag(squidclamav_xdata);\n    ci_service_set_preview(srv_xdata, 1024);\n    ci_service_enable_204(srv_xdata);\n    ci_service_set_transfer_preview(srv_xdata, \"*\");\n\n    xops = CI_XCLIENTIP | CI_XSERVERIP;\n    xops |= CI_XAUTHENTICATEDUSER | CI_XAUTHENTICATEDGROUPS;\n    ci_service_set_xopts(srv_xdata, xops);\n \n\n    /*Initialize object pools*/\n    AVREQDATA_POOL = ci_object_pool_register(\"av_req_data_t\", sizeof(av_req_data_t));\n\n    if(AVREQDATA_POOL < 0) {\n\t ci_debug_printf(0, \"FATAL squidclamav_init_service: error registering object_pool av_req_data_t\\n\");\n\t return 0;\n    }\n\n    /* Reload configuration command */\n    register_command(\"squidclamav:cfgreload\", MONITOR_PROC_CMD | CHILDS_PROC_CMD, cfgreload_command);\n\n     \n    /*********************\n       read config files\n     ********************/\n    clamd_curr_ip = (char *) malloc (sizeof (char) * 128);\n    memset(clamd_curr_ip, 0, sizeof(clamd_curr_ip));\n\n    if (load_patterns() == 0) {\n\treturn 0;\n    }\n\n    return 1;\n}\n\nvoid cfgreload_command(char *name, int type, char **argv)\n{\n    ci_debug_printf(1, \"DEBUG cfgreload_command: reload configuration command received\\n\");\n\n    free_global();\n    free_pipe();\n    debug = 0;\n    statit = 0;\n\n    pattc = 0;\n    current_pattern_size = 0;\n    maxsize = 0;\n    logredir = 0;\n    dnslookup = 1;\n    clamd_curr_ip = (char *) malloc (sizeof (char) * 128);\n    memset(clamd_curr_ip, 0, sizeof(clamd_curr_ip));\n    if (load_patterns() == 0)\n       ci_debug_printf(0, \"FATAL cfgreload_command: reload configuration command failed!\\n\");\n    if (squidclamav_xdata)\n       set_istag(squidclamav_xdata);\n\n    if (squidguard != NULL) {\n\tci_debug_printf(1, \"DEBUG cfgreload_command: reopening pipe to %s\\n\", squidguard);\n\tcreate_pipe(squidguard);\n    }\n\n}\n\nint squidclamav_post_init_service(ci_service_xdata_t * srv_xdata, struct ci_server_conf *server_conf)\n{\n\n    if (squidguard == NULL) return 0;\n\n    ci_debug_printf(1, \"DEBUG squidclamav_post_init_service: opening pipe to %s\\n\", squidguard);\n\n    if (create_pipe(squidguard) == 1) {\n\treturn 0;\n    }\n\n    return 1;\n}\n\nvoid squidclamav_close_service()\n{\n    ci_debug_printf(1, \"DEBUG squidclamav_close_service: clean all memory!\\n\");\n    free_global();\n    free_pipe();\n    ci_object_pool_unregister(AVREQDATA_POOL);\n}\n\nvoid *squidclamav_init_request_data(ci_request_t * req)\n{\n    int preview_size;\n    av_req_data_t *data;\n\n    preview_size = ci_req_preview_size(req);\n\n    ci_debug_printf(1, \"DEBUG squidclamav_init_request_data: initializing request data handler.\\n\");\n\n    if (!(data = ci_object_pool_alloc(AVREQDATA_POOL))) {\n\tci_debug_printf(0, \"FATAL squidclamav_init_request_data: Error allocation memory for service data!!!\");\n\treturn NULL;\n    }\n    data->body = NULL;\n    data->error_page = NULL;\n    data->req = req;\n    data->blocked = 0;\n    data->no_more_scan = 0;\n    data->virus = 0;\n\n    return data;\n}\n\n\nvoid squidclamav_release_request_data(void *data)\n{\n\n     if (data) {\n          ci_debug_printf(1, \"DEBUG squidclamav_release_request_data: Releasing request data.\\n\");\n\n        if (((av_req_data_t *) data)->body) {\n           ci_simple_file_destroy(((av_req_data_t *) data)->body);\n\t   if (((av_req_data_t *) data)->url)\n\t\tci_buffer_free(((av_req_data_t *) data)->url);\n\t   if (((av_req_data_t *) data)->user)\n\t\tci_buffer_free(((av_req_data_t *) data)->user);\n\t   if (((av_req_data_t *) data)->clientip)\n\t\tci_buffer_free(((av_req_data_t *) data)->clientip);\n\t}\n\n        if (((av_req_data_t *) data)->error_page)\n           ci_membuf_free(((av_req_data_t *) data)->error_page);\n\n        ci_object_pool_free(data);\n     }\n}\n\nint squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t * req)\n{\n     ci_headers_list_t *req_header;\n     struct http_info httpinf;\n     av_req_data_t *data = ci_service_data(req); \n     char *clientip;\n     struct hostent *clientname;\n     unsigned long ip;\n     char *username;\n     char *content_type;\n     ci_off_t content_length;\n     char *chain_ret = NULL;\n     char *ret = NULL;\n     int chkipdone = 0;\n\n     ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: processing preview header.\\n\");\n\n     if (preview_data_len)\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: preview data size is %d\\n\", preview_data_len);\n\n     /* Extract the HTTP header from the request */\n     if ((req_header = ci_http_request_headers(req)) == NULL) {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_ERROR;\n     }\n\n     /* Get the Authenticated user */\n     if ((username = ci_headers_value(req->request_header, \"X-Authenticated-User\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\n\", username);\n        /* if a TRUSTUSER match => no squidguard and no virus scan */\n        if (simple_pattern_compare(username, TRUSTUSER) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\\n\", username);\n\t   return CI_MOD_ALLOW204;\n        }\n     } else {\n\t/* set null client to - */\n\tusername = (char *)malloc(sizeof(char)*2);\n\tstrcpy(username, \"-\");\n     }\n\n     /* Check client Ip against SquidClamav trustclient */\n     if ((clientip = ci_headers_value(req->request_header, \"X-Client-IP\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\\n\", clientip);\n\tip = inet_addr(clientip);\n\tchkipdone = 0;\n\tif (dnslookup == 1) {\n\t\tif ( (clientname = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET)) != NULL) {\n\t\t\tif (clientname->h_name != NULL) {\n\t\t\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\t\t\tif (client_pattern_compare(clientip, clientname->h_name) > 0) {\n\t\t\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s(%s)\\n\", clientname->h_name, clientip);\n\t\t\t\t   return CI_MOD_ALLOW204;\n\t\t\t\t}\n\t\t\t\tchkipdone = 1;\n\t\t\t}\n\t\t  }\n\t}\n\tif (chkipdone == 0) {\n\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\tif (client_pattern_compare(clientip, NULL) > 0) {\n\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s\\n\", clientip);\n\t\t   return CI_MOD_ALLOW204;\n\t\t}\n\t}\n     } else {\n\t/* set null client to - */\n\tclientip = (char *)malloc(sizeof(char)*2);\n\tstrcpy(clientip, \"-\");\n     }\n     \n     /* Get the requested URL */\n     if (!extract_http_info(req, req_header, &httpinf)) {\n\t/* Something wrong in the header or unknow method */\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: URL requested: %s\\n\", httpinf.url);\n\n     /* Check the URL against SquidClamav Whitelist */\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",httpinf.url,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t/* Create the redirection url to squid */\n\t\tdata->blocked = 1;\n\t\tgenerate_redirect_page(strtok(chain_ret, \" \"), req, data);\n\t        xfree(chain_ret);\n\t        chain_ret = NULL;\n\t        return CI_MOD_CONTINUE;\n\t   }\n\t   xfree(chain_ret);\n\t   chain_ret = NULL;\n\t}\n     }\n\n     /* CONNECT method (https) can not be scanned so abort */\n     if (strcmp(httpinf.method, \"CONNECT\") == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: method %s can't be scanned.\\n\", httpinf.method);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Check the URL against SquidClamav abort */\n     if (simple_pattern_compare(httpinf.url, ABORT) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORT match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     /* Get the content length header */\n     content_length = ci_http_content_length(req);\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Length: %d\\n\", (int)content_length);\n\n     if ((content_length > 0) && (maxsize > 0) && (content_length >= maxsize)) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: No antivir check, content-length upper than maxsize (%d > %d)\\n\", content_length, (int)maxsize);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Get the content type header */\n     if ((content_type = http_content_type(req)) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Type: %s\\n\", content_type);\n        /* Check the Content-Type against SquidClamav abortcontent */\n        if (simple_pattern_compare(content_type, ABORTCONTENT)) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORTCONTENT match) for content-type: %s\\n\", content_type);\n\t   return CI_MOD_ALLOW204;\n        }\n     }\n\n     /* No data, so nothing to scan */\n     if (!data || !ci_req_hasbody(req)) {\n\t ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No body data, allow 204\\n\");\n          return CI_MOD_ALLOW204;\n     }\n\n     if (preview_data_len == 0) {\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: can not begin to scan url: No preview data.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n\n     data->url = ci_buffer_alloc(strlen(httpinf.url)+1);\n     strcpy(data->url, httpinf.url);\n     if (username != NULL) {\n\t     data->user = ci_buffer_alloc(strlen(username)+1);\n\t     strcpy(data->user, username);\n     } else {\n\tdata->user = NULL;\n     }\n     if (clientip != NULL) {\n\tdata->clientip = ci_buffer_alloc(strlen(clientip)+1);\n\tstrcpy(data->clientip, clientip);\n     } else {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: clientip is null, you must set 'icap_send_client_ip on' into squid.conf\\n\");\n\tdata->clientip = NULL;\n     }\n\n     data->body = ci_simple_file_new(0);\n     if ((SEND_PERCENT_BYTES >= 0) && (START_SEND_AFTER == 0)) {\n\tci_req_unlock_data(req);\n\tci_simple_file_lock_all(data->body);\n     }\n     if (!data->body)\n\treturn CI_ERROR;\n\n     if (preview_data_len) {\n\tif (ci_simple_file_write(data->body, preview_data, preview_data_len, ci_req_hasalldata(req)) == CI_ERROR)\n\t\treturn CI_ERROR;\n     }\n\n     return CI_MOD_CONTINUE;\n}\n\nint squidclamav_read_from_net(char *buf, int len, int iseof, ci_request_t * req)\n{\n     av_req_data_t *data = ci_service_data(req);\n     int allow_transfer;\n\n     if (!data)\n          return CI_ERROR;\n\n     if (!data->body)\n\treturn len;\n\n    if (data->no_more_scan == 1) {\n\treturn ci_simple_file_write(data->body, buf, len, iseof);\n    }\n\n    if ((maxsize > 0) && (data->body->bytes_in >= maxsize)) {\n\tdata->no_more_scan = 1;\n\tci_req_unlock_data(req);\n\tci_simple_file_unlock_all(data->body);\n\tci_debug_printf(1, \"DEBUG squidclamav_read_from_net: No more antivir check, downloaded stream is upper than maxsize (%d>%d)\\n\", data->body->bytes_in, (int)maxsize);\n    } else if (SEND_PERCENT_BYTES && (START_SEND_AFTER < data->body->bytes_in)) {\n\tci_req_unlock_data(req);\n\tallow_transfer = (SEND_PERCENT_BYTES * (data->body->endpos + len)) / 100;\n\tci_simple_file_unlock(data->body, allow_transfer);\n    }\n\n    return ci_simple_file_write(data->body, buf, len, iseof);\n}\n\nint squidclamav_write_to_net(char *buf, int len, ci_request_t * req)\n{\n     int bytes;\n     av_req_data_t *data = ci_service_data(req);\n\n     if (!data)\n          return CI_ERROR;\n\n     if (data->blocked == 1 && data->error_page == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_write_to_net: ending here, content was blocked\\n\");\n\treturn CI_EOF; \n     }\n     if (data->virus == 1 && data->error_page == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_write_to_net: ending here, virus was found\\n\");\n\treturn CI_EOF; \n     }\n\n     /* if a virus was found or the page has been blocked, a warning page\n\thas already been generated */\n     if (data->error_page)\n          return ci_membuf_read(data->error_page, buf, len);\n\n     if (data->body)\n\tbytes = ci_simple_file_read(data->body, buf, len);\n     else\n\t bytes =0;\n\n     return bytes;\n}\n\nint squidclamav_io(char *wbuf, int *wlen, char *rbuf, int *rlen, int iseof, ci_request_t * req)\n{\n     int ret = CI_OK;\n\n     if (rbuf && rlen) {\n           *rlen = squidclamav_read_from_net(rbuf, *rlen, iseof, req);\n\t   if (*rlen == CI_ERROR)\n\t      return CI_ERROR;\n           else if (*rlen < 0)\n\t      ret = CI_OK;\n     } else if (iseof) {\n\t   if (squidclamav_read_from_net(NULL, 0, iseof, req) == CI_ERROR)\n\t      return CI_ERROR;\n     }\n     if (wbuf && wlen) {\n          *wlen = squidclamav_write_to_net(wbuf, *wlen, req);\n     }\n     return CI_OK;\n}\n\nint squidclamav_end_of_data_handler(ci_request_t * req)\n{\n     av_req_data_t *data = ci_service_data(req);\n     ci_simple_file_t *body;\n     char cbuff[MAX_URL_SIZE];\n     char clbuf[SMALL_BUFF];\n\n     ssize_t ret;\n     int nbread = 0;\n     int loopw = 60;\n     uint16_t port;\n     struct sockaddr_in server;\n     struct sockaddr_in peer;\n     size_t peer_size;\n     char *pt = NULL;\n     int sockd;\n     int wsockd; \n     unsigned long total_read;\n\n     ci_debug_printf(2, \"DEBUG squidclamav_end_of_data_handler: ending request data handler.\\n\");\n\n     /* Nothing more to scan */\n     if (!data || !data->body)\n          return CI_MOD_DONE;\n\n     if (data->blocked == 1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: blocked content, sending redirection header + error page.\\n\");\n\treturn CI_MOD_DONE;\n     }\n\n     body = data->body;\n     if (data->no_more_scan == 1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: no more data to scan, sending content.\\n\");\n\tci_simple_file_unlock_all(body);\n\treturn CI_MOD_DONE;\n     }\n\n     /* SCAN DATA HERE */\n     if ((sockd = dconnect ()) < 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't connect to Clamd daemon.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Sending STREAM command to clamd.\\n\");\n\n     if (write(sockd, \"STREAM\", 6) <= 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't write to Clamd socket.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     while (loopw > 0) {\n\tmemset (cbuff, 0, sizeof(cbuff));\n\tret = read (sockd, cbuff, MAX_URL_SIZE);\n\tif ((ret > -1) && (pt = strstr (cbuff, \"PORT\"))) {\n\t   pt += 5;\n\t   sscanf(pt, \"%d\", (int *) &port);\n\t   break;\n\t}\n\tloopw--;\n     }\n     if (loopw == 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Clamd daemon not ready for stream scanning.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Received port %d from clamd.\\n\", port);\n\n     /* connect to clamd given port */\n     if ((wsockd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't create the Clamd socket.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     server.sin_family = AF_INET;\n     server.sin_port = htons (port);\n     peer_size = sizeof (peer);\n\n     if (getpeername(sockd, (struct sockaddr *) &peer, (socklen_t *) &peer_size) < 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't get socket peer name.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n     switch (peer.sin_family) {\n\tcase AF_UNIX:\n\tserver.sin_addr.s_addr = inet_addr (\"127.0.0.1\");\n\tbreak;\n\tcase AF_INET:\n\tserver.sin_addr.s_addr = peer.sin_addr.s_addr;\n\tbreak;\n\tdefault:\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Unexpected socket type: %d.\\n\", peer.sin_family);\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Trying to connect to clamd [port: %d].\\n\", port);\n\n     if (connect (wsockd, (struct sockaddr *) &server, sizeof (struct sockaddr_in)) < 0) {\n\tclose(wsockd);\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't connect to clamd [port: %d].\\n\", port);\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Ok connected to clamd on port: %d.\\n\", port);\n\n/*-----------------------------------------------------*/\n\n     ci_debug_printf(1, \"DEBUG: squidclamav_end_of_data_handler: Scanning data now\\n\");\n     lseek(body->fd, 0, SEEK_SET);\n     memset(cbuff, 0, sizeof(cbuff));\n     total_read = 0;\n     while (data->virus == 0 && (nbread = read(body->fd, cbuff, MAX_URL_SIZE)) > 0) {\n\t    total_read += nbread;\n\t    ret = write(wsockd, cbuff, nbread);\n\t    if ( (ret <= 0) && (total_read > 0) ) {\n\t\tci_debug_printf(3, \"ERROR squidclamav_end_of_data_handler: Can't write to clamd socket (maybe we reach clamd StreamMaxLength, total read: %ld).\\n\", total_read);\n\t\tbreak;\n\t    } else if ( ret <= 0 ) {\n\t\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't write to clamd socket.\\n\");\n\t\tbreak;\n\t    } else {\n\t\tci_debug_printf(3, \"DEBUG squidclamav_end_of_data_handler: Write %d bytes on %d to socket\\n\", (int)ret, nbread);\n\t    }\n\n\t    memset(cbuff, 0, sizeof(cbuff));\n\n     }\n\n     /* close socket to clamd */\n     if (wsockd > -1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: End Clamd connection, attempting to read result.\\n\");\n\tclose(wsockd);\n     }\n\n     memset (clbuf, 0, sizeof(clbuf));\n     while ((nbread = read(sockd, clbuf, SMALL_BUFF)) > 0) {\n\tci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: received from Clamd: %s\", clbuf);\n\tif (strstr (clbuf, \"FOUND\\n\")) {\n\t   data->virus = 1;\n\t   if (!ci_req_sent_data(req)) {\n\t\tchomp(clbuf);\n\t\tchar *urlredir = (char *) malloc( sizeof(char)*MAX_URL_SIZE );\n\t\tsnprintf(urlredir, MAX_URL_SIZE, \"%s?url=%s&source=%s&user=%s&virus=%s\", redirect_url, data->url, data->clientip, data->user, clbuf);\n\t\tif (logredir == 0)\n\t\t   ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Virus redirection: %s.\\n\", urlredir);\n\t\tif (logredir)\n\t\t    ci_debug_printf(0, \"INFO squidclamav_end_of_data_handler: Virus redirection: %s.\\n\", urlredir);\n\t\tgenerate_redirect_page(urlredir, req, data);\n\t\txfree(urlredir);\n\t   }\n\t   ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Virus found, ending download.\\n\");\n\t   break;\n\t}\n\tmemset(clbuf, 0, sizeof(clbuf));\n     }\n     /* close second socket to clamd */\n     if (sockd > -1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Closing Clamd connection.\\n\");\n\tclose(sockd);\n     }\n\n     if (data->virus) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Virus found, sending redirection header + error page.\\n\");\n          return CI_MOD_DONE;\n     }\n\n     if (!ci_req_sent_data(req)) {\n\tci_debug_printf(2, \"DEBUG squidclamav_end_of_data_handler: Responding with allow 204\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n\n     ci_debug_printf(3, \"DEBUG squidclamav_end_of_data_handler: unlocking data to be sent.\\n\");\n     ci_simple_file_unlock_all(body);\n\n     return CI_MOD_DONE;\n}\n\nvoid set_istag(ci_service_xdata_t * srv_xdata)\n{\n     char istag[SERVICE_ISTAG_SIZE + 1];\n\n\n     snprintf(istag, SERVICE_ISTAG_SIZE, \"-%d-%s-%d%d\",1, \"squidclamav\", 1, 0);\n     istag[SERVICE_ISTAG_SIZE] = '\\0';\n     ci_service_set_istag(srv_xdata, istag);\n     ci_debug_printf(2, \"DEBUG set_istag: setting istag to %s\\n\", istag);\n}\n\n/* util.c */\n\n/* NUL-terminated version of strncpy() */\nvoid\nxstrncpy (char *dest, const char *src, size_t n) {\n\tif ( (src == NULL) || (strcmp(src, \"\") == 0))\n\t\treturn;\n\tstrncpy(dest, src, n-1);\n\tdest[n-1] = 0;\n}\n\n/* Emulate the Perl chomp() method: remove \\r and \\n from end of string */\nvoid\nchomp (char *str)\n{\n\tsize_t len = 0;\n\n\tif (str == NULL) return;\n\tlen = strlen(str);\n\tif ((len > 0) && str[len - 1] == 10) {\n\t\tstr[len - 1] = 0;\n\t\tlen--;                                                       \n\t}\n\tif ((len > 0) && str[len - 1] == 13)\n\t\tstr[len - 1] = 0;\n\n\treturn;\n}\n\n/* return 0 if path exists, -1 otherwise */\nint\nisPathExists(const char *path)\n{\n    struct stat sb;\n\n    if ( (path == NULL) || (strcmp(path, \"\") == 0) ) return -1;\n\n    if (lstat(path, &sb) != 0) {\n\treturn -1;\n    }\n\n    return 0;\n}\n\n\n/* return 0 if path is secure, -1 otherwise */\nint\nisPathSecure(const char *path)\n{\n    struct stat sb;\n\n    /* no path => unreal, that's possible ! */\n    if (path == NULL) return -1;\n\n    /* file doesn't exist or access denied = secure */\n    /* fopen will fail */\n    if (lstat(path, &sb) != 0) return 0;\n\n    /* File is not a regular file => unsecure */\n    if ( S_ISLNK(sb.st_mode ) ) return -1;\n    if ( S_ISDIR(sb.st_mode ) ) return -1;\n    if ( S_ISCHR(sb.st_mode ) ) return -1;\n    if ( S_ISBLK(sb.st_mode ) ) return -1;\n    if ( S_ISFIFO(sb.st_mode ) ) return -1;\n    if ( S_ISSOCK(sb.st_mode ) ) return -1;\n\n    return 0;\n}\n\n/*\n *  xfree() - same as free(3).  Will not call free(3) if s == NULL.\n */\nvoid\nxfree(void *s)\n{\n    if (s != NULL)\n        free(s);\n    s = NULL;\n}\n\n/* Remove spaces and tabs from beginning and end of a string */\nvoid\ntrim(char *str)\n{\n\tint i = 0;\n\tint j = 0;\n\n\t/* Remove spaces and tabs from beginning */\n\twhile ( (str[i] == ' ') || (str[i] == '\\t') ) {\n\t\ti++;\n\t}\n\tif (i > 0) {\n\t\tfor (j = i; j < strlen(str); j++) {\n\t\t\tstr[j-i] = str[j];\n\t\t}\n\t\tstr[j-i] = '\\0';\n\t}\n\n\t/* Now remove spaces and tabs from end */\n\ti = strlen(str) - 1;\n\twhile ( (str[i] == ' ') || (str[i] == '\\t')) {\n\t\ti--;\n\t}\n\tif ( i < (strlen(str) - 1) ) {\n\t\tstr[i+1] = '\\0';\n\t}\n}\n\n/* Try to emulate the Perl split() method: str is splitted on the\nall occurence of delim. Take care that empty fields are not returned */\nchar**\nsplit( char* str, const char* delim)\n{\n        int size = 0;\n        char** splitted = NULL;\n        char *tmp = NULL;\n        tmp = strtok(str, delim);\n        while (tmp != NULL) {\n                splitted = (char**) realloc(splitted, sizeof(char**) * (size+1));\n                if (splitted != NULL) {\n                        splitted[size] = tmp;\n                } else {\n                        return(NULL);\n                }\n                tmp = strtok(NULL, delim);\n                size++;\n        }\n        free(tmp);\n        tmp = NULL;\n        /* add null at end of array to help ptrarray_length */\n        splitted = (char**) realloc(splitted, sizeof(char**) * (size+1));\n        if (splitted != NULL) {\n                splitted[size] = NULL;\n        } else {\n                return(NULL);\n        }\n\n        return splitted;\n}\n\n/* Return the length of a pointer array. Must be ended by NULL */\nint\nptrarray_length(char** arr)\n{\n\tint i = 0;\n\twhile(arr[i] != NULL) i++;\n\treturn i;\n}\n\nvoid *\nxmallox (size_t len)\n{\n\tvoid *memres = malloc (len);\n\tif (memres == NULL) {\n\t\tfprintf(stderr, \"Running Out of Memory!!!\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn memres;\n}\n\nsize_t\nxstrnlen(const char *s, size_t n)\n{\n\tconst char *p = (const char *)memchr(s, 0, n);\n\treturn(p ? p-s : n);\n}\n\n\n/* pattern.c */\n   \nint\nisIpAddress(char *src_addr)\n{\n  char *ptr;\n  int address;\n  int i;\n  char *s = (char *) malloc (sizeof (char) * LOW_CHAR);\n\n  xstrncpy(s, src_addr, LOW_CHAR);\n  \n  /* make sure we have numbers and dots only! */\n  if(strspn(s, \"0123456789.\") != strlen(s)) {\n    xfree(s);\n    return 1;\n  }\n\n  /* split up each number from string */\n  ptr = strtok(s, \".\");\n  if(ptr == NULL) {\n    xfree(s);\n    return 1;\n  }\n  address = atoi(ptr);\n  if(address < 0 || address > 255) {\n    xfree(s);\n    xfree(ptr);\n    return 1;\n  }\n  \n  for(i = 2; i < 4; i++) {\n    ptr = strtok(NULL, \".\");\n    if (ptr == NULL) {\n       xfree(s);\n       return 1;\n    }\n    address = atoi(ptr);\n    if (address < 0 || address > 255) {\n       xfree(ptr);\n       xfree(s);\n       return 1;\n    }\n  }\n  xfree(s);\n  \n  return 0;\n}\n\n\nint\nsimple_pattern_compare(char *str, const int type)\n{\n\tint i = 0;  \n\n\t/* pass througth all regex pattern */\n\tfor (i = 0; i < pattc; i++) {\n\t\tif ( (patterns[i].type == type) && (regexec(&patterns[i].regexv, str, 0, 0, 0) == 0) ) {\n\t\t\tswitch(type) {\n\t\t\t\t/* return 1 if string matches whitelist pattern */\n\t\t\t\tcase WHITELIST:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: whitelist (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\t/* return 1 if string matches abort pattern */\n\t\t\t\tcase ABORT:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: abort (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\t/* return 1 if string matches trustuser pattern */\n\t\t\t\tcase TRUSTUSER:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: trustuser (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\t/* return 1 if string matches abortcontent pattern */\n\t\t\t\tcase ABORTCONTENT:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: abortcontent (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:\n\t\t\t\t\tci_debug_printf(0, \"ERROR simple_pattern_compare: unknown pattern match type: %s\\n\", str);\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* return 0 otherwise */\n\treturn 0;\n}\n\nint\nclient_pattern_compare(char *ip, char *name)\n{\n\tint i = 0;  \n\n\t/* pass througth all regex pattern */\n\tfor (i = 0; i < pattc; i++) {\n\t\tif (patterns[i].type == TRUSTCLIENT) {\n\t\t\t/* Look at client ip pattern matching */\n\t\t\t/* return 1 if string matches ip TRUSTCLIENT pattern */\n\t\t\tif (regexec(&patterns[i].regexv, ip, 0, 0, 0) == 0) {\n\t\t\t\tif (debug != 0)\n\t\t\t\t\tci_debug_printf(2, \"DEBUG client_pattern_compare: trustclient (%s) matched: %s\\n\", patterns[i].pattern, ip);\n\t\t\t\treturn 1;\n\t\t\t/* Look at client name pattern matching */\n\t\t\t/* return 2 if string matches fqdn TRUSTCLIENT pattern */\n\t\t\t} else if ((name != NULL) && (regexec(&patterns[i].regexv, name, 0, 0, 0) == 0)) {\n\t\t\t\tif (debug != 0)\n\t\t\t\t\tci_debug_printf(2, \"DEBUG client_pattern_compare: trustclient (%s) matched: %s\\n\", patterns[i].pattern, name);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* return 0 otherwise */\n\treturn 0;\n}\n\n/* scconfig.c */\n\n/* load the squidclamav.conf */\nint\nload_patterns()\n{\n  char *buf = NULL;\n  FILE *fp  = NULL;\n\n  if (isPathExists(CONFIG_FILE) == 0) {\n    fp = fopen(CONFIG_FILE, \"rt\");\n    if (debug > 0)\n       ci_debug_printf(0, \"LOG load_patterns: Reading configuration from %s\\n\", CONFIG_FILE);\n  }\n  \n\n  if (fp == NULL) {\n\tci_debug_printf(0, \"FATAL load_patterns: unable to open configuration file: %s\\n\", CONFIG_FILE);\n    return 0;\n  }\n\n  buf = (char *)malloc(sizeof(char)*LOW_BUFF*2);\n  if (buf == NULL) {\n\tci_debug_printf(0, \"FATAL load_patterns: unable to allocate memory in load_patterns()\\n\");\n\tfclose(fp);\n\treturn 0;\n  }\n  while ((fgets(buf, LOW_BUFF, fp) != NULL)) {\n      /* chop newline */\n      chomp(buf);\n      /* add to regex patterns array */\n     if (add_pattern(buf) == 0) {\n\txfree(buf);\n\tfclose(fp);\n\treturn 0;\n     }\n  }\n  xfree(buf);\n  if (redirect_url == NULL) {\n    ci_debug_printf(0, \"FATAL load_patterns: No redirection URL set, going to BRIDGE mode\\n\");\n    return 0;\n  }\n   if (squidguard != NULL) {\n    ci_debug_printf(0, \"LOG load_patterns: Chaining with %s\\n\", squidguard);\n  }\n  if (fclose(fp) != 0)\n\tci_debug_printf(0, \"ERROR load_patterns: Can't close configuration file\\n\");\n\n  /* Set default values */\n  if (clamd_local == NULL) {\n\t  if (clamd_ip == NULL) {\n\t\tclamd_ip = (char *) malloc (sizeof (char) * SMALL_CHAR);\n\t\tif(clamd_ip == NULL) {\n\t\t\tci_debug_printf(0, \"FATAL load_patterns: unable to allocate memory in load_patterns()\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\txstrncpy(clamd_ip, CLAMD_SERVER, SMALL_CHAR);\n\t  }\n\n\t  if (clamd_port == NULL) {\n\t\tclamd_port = (char *) malloc (sizeof (char) * LOW_CHAR);\n\t\tif(clamd_port == NULL) {\n\t\t\tci_debug_printf(0, \"FATAL load_patterns: unable to allocate memory in load_patterns()\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\txstrncpy(clamd_port, CLAMD_PORT, LOW_CHAR);\n\t  }\n  }\n\n  return 1;\n}\n\nint\ngrowPatternArray (SCPattern item)\n{\n\tvoid *_tmp = NULL;\n        if (pattc == current_pattern_size) {\n                if (current_pattern_size == 0)\n                        current_pattern_size = PATTERN_ARR_SIZE;\n                else\n                        current_pattern_size += PATTERN_ARR_SIZE;\n\n\t\t_tmp = realloc(patterns, (current_pattern_size * sizeof(SCPattern)));\n                if (!_tmp) {\n                        return(-1);\n                }\n\n                patterns = (SCPattern*)_tmp;\n        }\n        patterns[pattc] = item;\n        pattc++;\n\n\treturn(pattc);\n}\n\n/* Add regexp expression to patterns array */\nint\nadd_pattern(char *s)\n{\n\tchar *first = NULL;\n\tchar *type  = NULL;\n\tint stored = 0;\n\tint regex_flags = REG_NOSUB;\n\tSCPattern currItem;\n\tchar *end = NULL;\n\n\t/* skip empty and commented lines */\n\tif ( (xstrnlen(s, LOW_BUFF) == 0) || (strncmp(s, \"#\", 1) == 0)) return 1;\n\n\t/* Config file directives are construct as follow: name value */  \n\ttype = (char *)malloc(sizeof(char)*LOW_CHAR);\n\tfirst = (char *)malloc(sizeof(char)*LOW_BUFF);\n\tstored = sscanf(s, \"%31s %255[^#]\", type, first);\n  \n\tif (stored < 2) {\n\t\tci_debug_printf(0, \"FATAL add_patterns: Bad configuration line for [%s]\\n\", s);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 0;\n\t}\n\t/* remove extra space or tabulation */\n\ttrim(first);\n\n\t/* URl to redirect Squid on virus found */  \n\tif(strcmp(type, \"redirect\") == 0) {\n\t\tredirect_url = (char *) malloc (sizeof (char) * LOW_BUFF);\n\t\tif(redirect_url == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(redirect_url, first, LOW_BUFF);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\t/* Path to chained other Squid redirector, mostly SquidGuard */\n\tif(strcmp(type, \"squidguard\") == 0) {\n\t\tsquidguard = (char *) malloc (sizeof (char) * LOW_BUFF);\n\t\tif(squidguard == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (isPathExists(first) == 0) {\n\t\t\t\txstrncpy(squidguard, first, LOW_BUFF);\n\t\t\t} else {\n\t\t\t\tci_debug_printf(0, \"LOG add_patterns: Wrong path to SquidGuard, disabling.\\n\");\n\t\t\t\tsquidguard = NULL;\n\t\t\t}\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n  \n\tif(strcmp(type, \"debug\") == 0) {\n\t\tif (debug == 0)\n\t\t   debug = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"logredir\") == 0) {\n\t\tif (logredir == 0)\n\t\t   logredir = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"dnslookup\") == 0) {\n\t\tif (dnslookup == 1)\n\t\t   dnslookup = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"timeout\") == 0) {\n\t\ttimeout = atoi(first);\n\t\tif (timeout > 10)\n\t\t\ttimeout = 10;\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"stat\") == 0) {\n\t\tstatit = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"clamd_ip\") == 0) {\n\t\tclamd_ip = (char *) malloc (sizeof (char) * SMALL_CHAR);\n\t\tif (clamd_ip == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(clamd_ip, first, SMALL_CHAR);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"clamd_port\") == 0) {\n\t\tclamd_port = (char *) malloc (sizeof (char) * LOW_CHAR);\n\t\tif(clamd_port == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(clamd_port, first, LOW_CHAR);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"clamd_local\") == 0) {\n\t\tclamd_local = (char *) malloc (sizeof (char) * LOW_BUFF);\n\t\tif(clamd_local == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(clamd_local, first, LOW_BUFF);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif (strcmp(type, \"maxsize\") == 0) {\n\t\tmaxsize = ci_strto_off_t(first, &end, 10);\n\t\tif ((maxsize == 0 && errno != 0) || maxsize < 0)\n\t\t\tmaxsize = 0;\n\t\tif (*end == 'k' || *end == 'K')\n\t\t\tmaxsize = maxsize * 1024;\n\t\telse if (*end == 'm' || *end == 'M')\n\t\t\tmaxsize = maxsize * 1024 * 1024;\n\t\telse if (*end == 'g' || *end == 'G')\n\t\t\tmaxsize = maxsize * 1024 * 1024 * 1024;\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\t/* force case insensitive pattern matching */\n\t/* so aborti, contenti, regexi are now obsolete */\n\tregex_flags |= REG_ICASE;\n\t/* Add extended regex search */\n\tregex_flags |= REG_EXTENDED;\n\t/* Fill the pattern type */\n\tif (strcmp(type, \"abort\") == 0) {\n\t\tcurrItem.type = ABORT;\n\t} else if (strcmp(type, \"abortcontent\") == 0) {\n\t\tcurrItem.type = ABORTCONTENT;\n\t} else if(strcmp(type, \"whitelist\") == 0) {\n\t\tcurrItem.type = WHITELIST;\n\t} else if(strcmp(type, \"trustuser\") == 0) {\n\t\tcurrItem.type = TRUSTUSER;\n\t} else if(strcmp(type, \"trustclient\") == 0) {\n\t\tcurrItem.type = TRUSTCLIENT;\n\t} else if ( (strcmp(type, \"squid_ip\") != 0) && (strcmp(type, \"squid_port\") != 0) && (strcmp(type, \"maxredir\") != 0) && (strcmp(type, \"useragent\") != 0) && (strcmp(type, \"trust_cache\") != 0) ) {\n\t\tfprintf(stderr, \"WARNING: Bad configuration keyword: %s\\n\", s);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\t/* Fill the pattern flag */\n\tcurrItem.flag = regex_flags;\n\n\t/* Fill pattern array */\n\tcurrItem.pattern = malloc(sizeof(char)*(strlen(first)+1));\n\tif (currItem.pattern == NULL) {\n\t\tfprintf(stderr, \"unable to allocate new pattern in add_to_patterns()\\n\");\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 0;\n\t}\n\tstrncpy(currItem.pattern, first, strlen(first) + 1);\n\tif ((stored = regcomp(&currItem.regexv, currItem.pattern, currItem.flag)) != 0) {\n\t\tci_debug_printf(0, \"ERROR add_pattern: Invalid regex pattern: %s\\n\", currItem.pattern);\n\t} else {\n\t\tif (growPatternArray(currItem) < 0) {\n\t\t\tfprintf(stderr, \"unable to allocate new pattern in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t}\n\t}\n\txfree(type);\n\txfree(first);\n\treturn 1;\n}\n\nint extract_http_info(ci_request_t * req, ci_headers_list_t * req_header,\n                  struct http_info *httpinf)\n{\n     char *str;\n     int i = 0;\n\n/* Format of the HTTP header we want to parse:\n\t GET http://www.squid-cache.org/Doc/config/icap_service HTTP/1.1\n*/\n     httpinf->url[0]='\\0';\n     httpinf->method[0] = '\\0';\n\n     str = req_header->headers[0];\n\n     /* if we can't find a space character, there's somethings wrong */\n     if (strchr(str, ' ') == NULL) {\n          return 0;\n     }\n\n     /* extract the HTTP method */\n     while (*str != ' ' && i < MAX_METHOD_SIZE) {\n\thttpinf->method[i] = *str;\n        str++;\n\ti++;\n     }\n     httpinf->method[i] = '\\0';\n     ci_debug_printf(3, \"DEBUG extract_http_info: method %s\\n\", httpinf->method);\n\n     /* Extract the URL part of the header */\n     while (*str == ' ') str++;\n     i = 0;\n     while (*str != ' ' && i < MAX_URL_SIZE) {\n\thttpinf->url[i] = *str;\n\ti++;\n\tstr++;\n     }\n     httpinf->url[i] = '\\0';\n     ci_debug_printf(3, \"DEBUG extract_http_info: url %s\\n\", httpinf->url);\n     if (*str != ' ') {\n          return 0;\n     }\n     /* we must find the HTTP version after all */\n     while (*str == ' ')\n          str++;\n     if (*str != 'H' || *(str + 4) != '/') {\n          return 0;\n     }\n\n     return 1;\n}\n\nchar *http_content_type(ci_request_t * req)\n{\n     ci_headers_list_t *heads;\n     char *val;\n     if (!(heads =  ci_http_response_headers(req))) {\n          /* Then maybe is a reqmod request, try to get request headers */\n          if (!(heads = ci_http_request_headers(req)))\n               return NULL;\n     }\n     if (!(val = ci_headers_value(heads, \"Content-Type\")))\n          return NULL;\n\n     return val;\n}\n\nvoid\nfree_global ()\n{\n     xfree(clamd_local);\n     xfree(clamd_ip);\n     xfree(clamd_port);\n     xfree(clamd_curr_ip);\n     xfree(redirect_url);\n     if (patterns != NULL) {\n\twhile (pattc > 0) {\n\t   pattc--;\n\t   regfree(&patterns[pattc].regexv);\n\t   xfree(patterns[pattc].pattern);\n\t}\n\tfree(patterns);\n\tpatterns = NULL;\n     }\n}\n\nvoid\nfree_pipe ()\n{\n     xfree(squidguard);\n     if (sgfpw) fclose(sgfpw);\n     if (sgfpr) fclose(sgfpr);\n}\n\nstatic const char *blocked_header_message =\n     \"<html>\\n\"\n     \"<body>\\n\"\n     \"<p>\\n\"\n     \"You will be redirected in few seconds, if not use this <a href=\\\"\";\n\nstatic const char *blocked_footer_message =\n     \"\\\">direct link</a>.\\n\"\n     \"</p>\\n\"\n     \"</body>\\n\"\n     \"</html>\\n\";\n\nvoid generate_redirect_page(char * redirect, ci_request_t * req, av_req_data_t * data)\n{\n     int new_size = 0;\n     char buf[MAX_URL_SIZE];\n     ci_membuf_t *error_page;\n\n     new_size = strlen(blocked_header_message) + strlen(redirect) + strlen(blocked_footer_message) + 10;\n\n     if ( ci_http_response_headers(req))\n          ci_http_response_reset_headers(req);\n     else\n          ci_http_response_create(req, 1, 1);\n\n     ci_debug_printf(2, \"DEBUG generate_redirect_page: creating redirection page\\n\");\n\n     snprintf(buf, MAX_URL_SIZE, \"Location: %s\", redirect);\n     /*strcat(buf, \";\");*/\n\n     ci_debug_printf(3, \"DEBUG generate_redirect_page: %s\\n\", buf);\n\n     ci_http_response_add_header(req, \"HTTP/1.0 301 Moved Permanently\");\n     ci_http_response_add_header(req, buf);\n     ci_http_response_add_header(req, \"Server: C-ICAP\");\n     ci_http_response_add_header(req, \"Connection: close\");\n     /*ci_http_response_add_header(req, \"Content-Type: text/html;\");*/\n     ci_http_response_add_header(req, \"Content-Type: text/html\");\n     ci_http_response_add_header(req, \"Content-Language: en\");\n\n     if (data->blocked == 1) {\n\terror_page = ci_membuf_new_sized(new_size);\n\t((av_req_data_t *) data)->error_page = error_page;\n\tci_membuf_write(error_page, (char *) blocked_header_message, strlen(blocked_header_message), 0);\n\tci_membuf_write(error_page, (char *) redirect, strlen(redirect), 0);\n\tci_membuf_write(error_page, (char *) blocked_footer_message, strlen(blocked_footer_message), 1);\n     }\n     ci_debug_printf(3, \"DEBUG generate_redirect_page: done\\n\");\n\n}\n\nint create_pipe(char *command)\n{\n\n    int pipe1[2];\n    int pipe2[2];\n\n    ci_debug_printf(1, \"DEBUG create_pipe: Open pipe to squidGuard %s!\\n\", command);\n\n    if (command != NULL) {\n\tif ( pipe(pipe1) < 0  ||  pipe(pipe2) < 0 ) {\n\t\tci_debug_printf(0, \"ERROR create_pipe: unable to open pipe, disabling call to %s.\\n\", command);\n\t\tperror(\"pipe\");\n\t\tusepipe = 0;\n\t} else {\n\t\tif ( (pid = fork()) == -1) {\n\t\t\tci_debug_printf(0, \"ERROR create_pipe: unable to fork, disabling call to %s.\\n\", command);\n\t\t\tusepipe = 0;\n\t\t} else {\n\t\t\tif(pid == 0) {\n\t\t\t\tclose(pipe1[1]);\n\t\t\t\tdup2(pipe1[0],0);\n\t\t\t\tclose(pipe2[0]);\n\t\t\t\tdup2(pipe2[1],1);\n\t\t\t\tsetsid();\n\t\t\t\t/* Running chained program */\n\t\t\t\texeclp(command,(char *)basename(command),(char  *)0);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tclose(pipe1[0]);\n\t\t\t\tsgfpw = fdopen(pipe1[1], \"w\");\n\t\t\t\tif (!sgfpw) {\n\t\t\t\t   ci_debug_printf(0, \"ERROR create_pipe: unable to fopen command's child stdin, disabling it.\\n\");\n\t\t\t\t\tusepipe = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* make pipe line buffered */\n\t\t\t\t\tif (setvbuf (sgfpw, (char *)NULL, _IOLBF, 0)  != 0)\n\t\t\t\t\t\tci_debug_printf(1, \"DEBUG create_pipe: unable to line buffering pipe.\\n\");\n\t\t\t\t\tsgfpr = fdopen(pipe2[0], \"r\");\n\t\t\t\t\tif(!sgfpr) {\n\t\t\t\t\t\tci_debug_printf(0, \"ERROR create_pipe: unable to fopen command's child stdout, disabling it.\\n\");\n\t\t\t\t\t\tusepipe = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tci_debug_printf(1, \"DEBUG create_pipe: bidirectional pipe to %s childs ready...\\n\", command);\n\t\t\t\t\t\tusepipe = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 1;\n}\n\nint\ndconnect ()\n{\n  struct sockaddr_un userver;\n  int asockd;\n\n\n  memset ((char *) &userver, 0, sizeof (userver));\n\n  ci_debug_printf(1, \"dconnect: entering.\\n\");\n  if (clamd_local != NULL) {\n      userver.sun_family = AF_UNIX;\n      xstrncpy (userver.sun_path, clamd_local, sizeof(userver.sun_path));\n      if ((asockd = socket (AF_UNIX, SOCK_STREAM, 0)) < 0) {\n          ci_debug_printf(0, \"ERROR dconnect: Can't bind local socket on %s.\\n\", clamd_local);\n          return -1;\n      }\n      if (connect (asockd, (struct sockaddr *) &userver, sizeof (struct sockaddr_un)) < 0) {\n          close (asockd);\n          ci_debug_printf(0, \"ERROR dconnect: Can't connect to clamd on local socket %s.\\n\", clamd_local);\n          return -1;\n      }\n      return asockd;\n\n    } else {\n        if (clamd_curr_ip[0] != 0) {\n                asockd = connectINET(clamd_curr_ip, atoi(clamd_port));\n                if ( asockd != -1 ) {\n                   ci_debug_printf(1, \"DEBUG dconnect: Connected to Clamd (%s:%s)\\n\", clamd_curr_ip,clamd_port);\n                    return asockd;\n                }\n        }\n\n        char *ptr;\n        char *s = (char *) malloc (sizeof (char) * SMALL_CHAR);\n        xstrncpy(s, clamd_ip, SMALL_CHAR);\n        ptr = strtok(s, \",\");\n        while (ptr != NULL) {\n                asockd = connectINET(ptr, atoi(clamd_port));\n                if ( asockd != -1 ) {\n                    ci_debug_printf(1, \"DEBUG dconnect: Connected to Clamd (%s:%s)\\n\", ptr,clamd_port);\n                    /* Store last working clamd */\n                    xstrncpy(clamd_curr_ip, ptr, LOW_CHAR);\n                    xfree(s);\n                    break;\n                }\n                ptr = strtok(NULL, \",\");\n        }\n        return asockd;\n        xfree(s);\n    }\n    return 0;\n}\n\nvoid connect_timeout() {\n   // doesn't actually need to do anything\n}\n\nint\nconnectINET(char *serverHost, uint16_t serverPort)\n{\n        struct sockaddr_in server;\n        struct hostent *he;\n        int asockd;\n\tstruct sigaction action;\n\taction.sa_handler = connect_timeout;\n\n        memset ((char *) &server, 0, sizeof (server));\n        server.sin_addr.s_addr = inet_addr(serverHost);\n        if ((asockd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {\n          ci_debug_printf(0, \"ERROR connectINET: Can't create a socket.\\n\");\n          return -1;\n        }\n\n        server.sin_family = AF_INET;\n        server.sin_port = htons(serverPort);\n\n        if ((he = gethostbyname(serverHost)) == 0)\n        {\n          close(asockd);\n          ci_debug_printf(0, \"ERROR connectINET: Can't lookup hostname of %s\\n\", serverHost);\n          return -1;\n        }\n        server.sin_addr = *(struct in_addr *) he->h_addr_list[0];\n\tsigaction(SIGALRM, &action, NULL);\n\talarm(timeout);\n\n        if (connect (asockd, (struct sockaddr *) &server, sizeof (struct sockaddr_in)) < 0) {\n          close (asockd);\n          ci_debug_printf(0, \"ERROR connectINET: Can't connect on %s:%d.\\n\", serverHost,serverPort);\n          return -1;\n        }\n\tint err = errno;\n\talarm(0);\n\tif (err == EINTR) {\n          close(asockd);\n\t  ci_debug_printf(0, \"ERROR connectINET: Timeout connecting to clamd on %s:%d.\\n\", serverHost,serverPort);\n\t}\n\n        return asockd;\n}\n\n"], "fixing_code": ["/*\n *  Copyright (C) 2005-2012 Gilles Darold\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *  Some part of the code of squidclamav are learn or simply copy/paste\n *  from the srv_clamav c-icap service written by Christos Tsantilas.\n *\n *  Copyright (C) 2004 Christos Tsantilas\n *\n * Thanks to him for his great work.\n*/\n\n#include \"c-icap.h\"\n#include \"service.h\"\n#include \"header.h\"\n#include \"body.h\"\n#include \"simple_api.h\"\n#include \"debug.h\"\n#include \"cfg_param.h\"\n#include \"squidclamav.h\"\n#include \"filetype.h\"\n#include \"ci_threads.h\"\n#include \"mem.h\"\n#include \"commands.h\"\n#include <errno.h>\n#include <signal.h>\n\n/* Structure used to store information passed throught the module methods */\ntypedef struct av_req_data{\n     ci_simple_file_t *body;\n     ci_request_t *req;\n     ci_membuf_t *error_page;\n     int blocked;\n     int no_more_scan;\n     int virus;\n     char *url;\n     char *user;\n     char *clientip;\n} av_req_data_t;\n\nstatic int SEND_PERCENT_BYTES = 0;\nstatic ci_off_t START_SEND_AFTER = 1;\n\n/*squidclamav service extra data ... */\nci_service_xdata_t *squidclamav_xdata = NULL;\n\nint AVREQDATA_POOL = -1;\n\nint squidclamav_init_service(ci_service_xdata_t * srv_xdata, struct ci_server_conf *server_conf);\nint squidclamav_post_init_service(ci_service_xdata_t * srv_xdata, struct ci_server_conf *server_conf);\nvoid squidclamav_close_service();\nint squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t *);\nint squidclamav_end_of_data_handler(ci_request_t *);\nvoid *squidclamav_init_request_data(ci_request_t * req);\nvoid squidclamav_release_request_data(void *data);\nint squidclamav_io(char *wbuf, int *wlen, char *rbuf, int *rlen, int iseof, ci_request_t * req);\n\n/* General functions */\nvoid set_istag(ci_service_xdata_t * srv_xdata);\n\n/* Declare SquidClamav C-ICAP service */ \nCI_DECLARE_MOD_DATA ci_service_module_t service = {\n     \"squidclamav\",                    /*Module name */\n     \"SquidClamav/Antivirus service\", /* Module short description */\n     ICAP_RESPMOD | ICAP_REQMOD,      /* Service type modification */\n     squidclamav_init_service,          /* init_service. */\n     squidclamav_post_init_service,     /* post_init_service. */\n     squidclamav_close_service,         /* close_service */\n     squidclamav_init_request_data,     /* init_request_data. */\n     squidclamav_release_request_data,  /* release request data */\n     squidclamav_check_preview_handler, /* Preview data */\n     squidclamav_end_of_data_handler,   /* when all data has been received */\n     squidclamav_io,\n     NULL,\n     NULL\n};\n\nint debug = 0;\nint statit = 0;\nint timeout = 1;\nchar *redirect_url = NULL;\nchar *squidguard = NULL;\nchar *clamd_local = NULL;\nchar *clamd_ip = NULL;\nchar *clamd_port = NULL;\nchar *clamd_curr_ip = NULL;\nSCPattern *patterns = NULL;\nint pattc = 0;\nint current_pattern_size = 0;\nci_off_t maxsize = 0;\nint logredir = 0;\nint dnslookup = 1;\n\n/* Used by pipe to squidGuard */\nint usepipe = 0;\npid_t pid;\nFILE *sgfpw = NULL;\nFILE *sgfpr = NULL;\n\n\n/* --------------- URL CHECK --------------------------- */\n\n#define MAX_URL_SIZE  8192\n#define MAX_METHOD_SIZE  16\n#define SMALL_BUFF 1024\n\nstruct http_info {\n    char method[MAX_METHOD_SIZE];\n    char url[MAX_URL_SIZE];\n};\n\nint extract_http_info(ci_request_t *, ci_headers_list_t *, struct http_info *);\nchar *http_content_type(ci_request_t *);\nvoid free_global ();\nvoid free_pipe ();\nvoid generate_redirect_page(char *, ci_request_t *, av_req_data_t *);\nvoid cfgreload_command(char *, int, char **);\nint create_pipe(char *command);\nint dconnect (void);\nint connectINET(char *serverHost, uint16_t serverPort);\nchar * replace(const char *s, const char *old, const char *new);\n\n/* ----------------------------------------------------- */\n\n\nint squidclamav_init_service(ci_service_xdata_t * srv_xdata,\n                           struct ci_server_conf *server_conf)\n{\n    unsigned int xops;\n\n    ci_debug_printf(1, \"DEBUG squidclamav_init_service: Going to initialize squidclamav\\n\");\n\n    squidclamav_xdata = srv_xdata;\n    set_istag(squidclamav_xdata);\n    ci_service_set_preview(srv_xdata, 1024);\n    ci_service_enable_204(srv_xdata);\n    ci_service_set_transfer_preview(srv_xdata, \"*\");\n\n    xops = CI_XCLIENTIP | CI_XSERVERIP;\n    xops |= CI_XAUTHENTICATEDUSER | CI_XAUTHENTICATEDGROUPS;\n    ci_service_set_xopts(srv_xdata, xops);\n \n\n    /*Initialize object pools*/\n    AVREQDATA_POOL = ci_object_pool_register(\"av_req_data_t\", sizeof(av_req_data_t));\n\n    if(AVREQDATA_POOL < 0) {\n\t ci_debug_printf(0, \"FATAL squidclamav_init_service: error registering object_pool av_req_data_t\\n\");\n\t return 0;\n    }\n\n    /* Reload configuration command */\n    register_command(\"squidclamav:cfgreload\", MONITOR_PROC_CMD | CHILDS_PROC_CMD, cfgreload_command);\n\n     \n    /*********************\n       read config files\n     ********************/\n    clamd_curr_ip = (char *) malloc (sizeof (char) * 128);\n    memset(clamd_curr_ip, 0, sizeof(clamd_curr_ip));\n\n    if (load_patterns() == 0) {\n\treturn 0;\n    }\n\n    return 1;\n}\n\nvoid cfgreload_command(char *name, int type, char **argv)\n{\n    ci_debug_printf(1, \"DEBUG cfgreload_command: reload configuration command received\\n\");\n\n    free_global();\n    free_pipe();\n    debug = 0;\n    statit = 0;\n\n    pattc = 0;\n    current_pattern_size = 0;\n    maxsize = 0;\n    logredir = 0;\n    dnslookup = 1;\n    clamd_curr_ip = (char *) malloc (sizeof (char) * 128);\n    memset(clamd_curr_ip, 0, sizeof(clamd_curr_ip));\n    if (load_patterns() == 0)\n       ci_debug_printf(0, \"FATAL cfgreload_command: reload configuration command failed!\\n\");\n    if (squidclamav_xdata)\n       set_istag(squidclamav_xdata);\n\n    if (squidguard != NULL) {\n\tci_debug_printf(1, \"DEBUG cfgreload_command: reopening pipe to %s\\n\", squidguard);\n\tcreate_pipe(squidguard);\n    }\n\n}\n\nint squidclamav_post_init_service(ci_service_xdata_t * srv_xdata, struct ci_server_conf *server_conf)\n{\n\n    if (squidguard == NULL) return 0;\n\n    ci_debug_printf(1, \"DEBUG squidclamav_post_init_service: opening pipe to %s\\n\", squidguard);\n\n    if (create_pipe(squidguard) == 1) {\n\treturn 0;\n    }\n\n    return 1;\n}\n\nvoid squidclamav_close_service()\n{\n    ci_debug_printf(1, \"DEBUG squidclamav_close_service: clean all memory!\\n\");\n    free_global();\n    free_pipe();\n    ci_object_pool_unregister(AVREQDATA_POOL);\n}\n\nvoid *squidclamav_init_request_data(ci_request_t * req)\n{\n    int preview_size;\n    av_req_data_t *data;\n\n    preview_size = ci_req_preview_size(req);\n\n    ci_debug_printf(1, \"DEBUG squidclamav_init_request_data: initializing request data handler.\\n\");\n\n    if (!(data = ci_object_pool_alloc(AVREQDATA_POOL))) {\n\tci_debug_printf(0, \"FATAL squidclamav_init_request_data: Error allocation memory for service data!!!\");\n\treturn NULL;\n    }\n    data->body = NULL;\n    data->error_page = NULL;\n    data->req = req;\n    data->blocked = 0;\n    data->no_more_scan = 0;\n    data->virus = 0;\n\n    return data;\n}\n\n\nvoid squidclamav_release_request_data(void *data)\n{\n\n     if (data) {\n          ci_debug_printf(1, \"DEBUG squidclamav_release_request_data: Releasing request data.\\n\");\n\n        if (((av_req_data_t *) data)->body) {\n           ci_simple_file_destroy(((av_req_data_t *) data)->body);\n\t   if (((av_req_data_t *) data)->url)\n\t\tci_buffer_free(((av_req_data_t *) data)->url);\n\t   if (((av_req_data_t *) data)->user)\n\t\tci_buffer_free(((av_req_data_t *) data)->user);\n\t   if (((av_req_data_t *) data)->clientip)\n\t\tci_buffer_free(((av_req_data_t *) data)->clientip);\n\t}\n\n        if (((av_req_data_t *) data)->error_page)\n           ci_membuf_free(((av_req_data_t *) data)->error_page);\n\n        ci_object_pool_free(data);\n     }\n}\n\nint squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t * req)\n{\n     ci_headers_list_t *req_header;\n     struct http_info httpinf;\n     av_req_data_t *data = ci_service_data(req); \n     char *clientip;\n     struct hostent *clientname;\n     unsigned long ip;\n     char *username;\n     char *content_type;\n     ci_off_t content_length;\n     char *chain_ret = NULL;\n     char *ret = NULL;\n     int chkipdone = 0;\n\n     ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: processing preview header.\\n\");\n\n     if (preview_data_len)\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: preview data size is %d\\n\", preview_data_len);\n\n     /* Extract the HTTP header from the request */\n     if ((req_header = ci_http_request_headers(req)) == NULL) {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_ERROR;\n     }\n\n     /* Get the Authenticated user */\n     if ((username = ci_headers_value(req->request_header, \"X-Authenticated-User\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\n\", username);\n        /* if a TRUSTUSER match => no squidguard and no virus scan */\n        if (simple_pattern_compare(username, TRUSTUSER) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\\n\", username);\n\t   return CI_MOD_ALLOW204;\n        }\n     } else {\n\t/* set null client to - */\n\tusername = (char *)malloc(sizeof(char)*2);\n\tstrcpy(username, \"-\");\n     }\n\n     /* Check client Ip against SquidClamav trustclient */\n     if ((clientip = ci_headers_value(req->request_header, \"X-Client-IP\")) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\\n\", clientip);\n\tip = inet_addr(clientip);\n\tchkipdone = 0;\n\tif (dnslookup == 1) {\n\t\tif ( (clientname = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET)) != NULL) {\n\t\t\tif (clientname->h_name != NULL) {\n\t\t\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\t\t\tif (client_pattern_compare(clientip, clientname->h_name) > 0) {\n\t\t\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s(%s)\\n\", clientname->h_name, clientip);\n\t\t\t\t   return CI_MOD_ALLOW204;\n\t\t\t\t}\n\t\t\t\tchkipdone = 1;\n\t\t\t}\n\t\t  }\n\t}\n\tif (chkipdone == 0) {\n\t\t/* if a TRUSTCLIENT match => no squidguard and no virus scan */\n\t\tif (client_pattern_compare(clientip, NULL) > 0) {\n\t\t   ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s\\n\", clientip);\n\t\t   return CI_MOD_ALLOW204;\n\t\t}\n\t}\n     } else {\n\t/* set null client to - */\n\tclientip = (char *)malloc(sizeof(char)*2);\n\tstrcpy(clientip, \"-\");\n     }\n     \n     /* Get the requested URL */\n     if (!extract_http_info(req, req_header, &httpinf)) {\n\t/* Something wrong in the header or unknow method */\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: bad http header, aborting.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: URL requested: %s\\n\", httpinf.url);\n\n     /* Check the URL against SquidClamav Whitelist */\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tchar *rbuff = NULL;\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\t/* escaping escaped character to prevent unescaping by squidguard */\n\trbuff = replace(httpinf.url, \"%\", \"%25\");\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",rbuff,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\txfree(rbuff);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t/* Create the redirection url to squid */\n\t\tdata->blocked = 1;\n\t\tgenerate_redirect_page(strtok(chain_ret, \" \"), req, data);\n\t        xfree(chain_ret);\n\t        chain_ret = NULL;\n\t        return CI_MOD_CONTINUE;\n\t   }\n\t   xfree(chain_ret);\n\t   chain_ret = NULL;\n\t}\n     }\n\n     /* CONNECT method (https) can not be scanned so abort */\n     if (strcmp(httpinf.method, \"CONNECT\") == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: method %s can't be scanned.\\n\", httpinf.method);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Check the URL against SquidClamav abort */\n     if (simple_pattern_compare(httpinf.url, ABORT) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORT match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     /* Get the content length header */\n     content_length = ci_http_content_length(req);\n     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Length: %d\\n\", (int)content_length);\n\n     if ((content_length > 0) && (maxsize > 0) && (content_length >= maxsize)) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: No antivir check, content-length upper than maxsize (%d > %d)\\n\", content_length, (int)maxsize);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     /* Get the content type header */\n     if ((content_type = http_content_type(req)) != NULL) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Content-Type: %s\\n\", content_type);\n        /* Check the Content-Type against SquidClamav abortcontent */\n        if (simple_pattern_compare(content_type, ABORTCONTENT)) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No antivir check (ABORTCONTENT match) for content-type: %s\\n\", content_type);\n\t   return CI_MOD_ALLOW204;\n        }\n     }\n\n     /* No data, so nothing to scan */\n     if (!data || !ci_req_hasbody(req)) {\n\t ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No body data, allow 204\\n\");\n          return CI_MOD_ALLOW204;\n     }\n\n     if (preview_data_len == 0) {\n\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: can not begin to scan url: No preview data.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n\n     data->url = ci_buffer_alloc(strlen(httpinf.url)+1);\n     strcpy(data->url, httpinf.url);\n     if (username != NULL) {\n\t     data->user = ci_buffer_alloc(strlen(username)+1);\n\t     strcpy(data->user, username);\n     } else {\n\tdata->user = NULL;\n     }\n     if (clientip != NULL) {\n\tdata->clientip = ci_buffer_alloc(strlen(clientip)+1);\n\tstrcpy(data->clientip, clientip);\n     } else {\n\tci_debug_printf(0, \"ERROR squidclamav_check_preview_handler: clientip is null, you must set 'icap_send_client_ip on' into squid.conf\\n\");\n\tdata->clientip = NULL;\n     }\n\n     data->body = ci_simple_file_new(0);\n     if ((SEND_PERCENT_BYTES >= 0) && (START_SEND_AFTER == 0)) {\n\tci_req_unlock_data(req);\n\tci_simple_file_lock_all(data->body);\n     }\n     if (!data->body)\n\treturn CI_ERROR;\n\n     if (preview_data_len) {\n\tif (ci_simple_file_write(data->body, preview_data, preview_data_len, ci_req_hasalldata(req)) == CI_ERROR)\n\t\treturn CI_ERROR;\n     }\n\n     return CI_MOD_CONTINUE;\n}\n\nint squidclamav_read_from_net(char *buf, int len, int iseof, ci_request_t * req)\n{\n     av_req_data_t *data = ci_service_data(req);\n     int allow_transfer;\n\n     if (!data)\n          return CI_ERROR;\n\n     if (!data->body)\n\treturn len;\n\n    if (data->no_more_scan == 1) {\n\treturn ci_simple_file_write(data->body, buf, len, iseof);\n    }\n\n    if ((maxsize > 0) && (data->body->bytes_in >= maxsize)) {\n\tdata->no_more_scan = 1;\n\tci_req_unlock_data(req);\n\tci_simple_file_unlock_all(data->body);\n\tci_debug_printf(1, \"DEBUG squidclamav_read_from_net: No more antivir check, downloaded stream is upper than maxsize (%d>%d)\\n\", data->body->bytes_in, (int)maxsize);\n    } else if (SEND_PERCENT_BYTES && (START_SEND_AFTER < data->body->bytes_in)) {\n\tci_req_unlock_data(req);\n\tallow_transfer = (SEND_PERCENT_BYTES * (data->body->endpos + len)) / 100;\n\tci_simple_file_unlock(data->body, allow_transfer);\n    }\n\n    return ci_simple_file_write(data->body, buf, len, iseof);\n}\n\nint squidclamav_write_to_net(char *buf, int len, ci_request_t * req)\n{\n     int bytes;\n     av_req_data_t *data = ci_service_data(req);\n\n     if (!data)\n          return CI_ERROR;\n\n     if (data->blocked == 1 && data->error_page == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_write_to_net: ending here, content was blocked\\n\");\n\treturn CI_EOF; \n     }\n     if (data->virus == 1 && data->error_page == 0) {\n\tci_debug_printf(2, \"DEBUG squidclamav_write_to_net: ending here, virus was found\\n\");\n\treturn CI_EOF; \n     }\n\n     /* if a virus was found or the page has been blocked, a warning page\n\thas already been generated */\n     if (data->error_page)\n          return ci_membuf_read(data->error_page, buf, len);\n\n     if (data->body)\n\tbytes = ci_simple_file_read(data->body, buf, len);\n     else\n\t bytes =0;\n\n     return bytes;\n}\n\nint squidclamav_io(char *wbuf, int *wlen, char *rbuf, int *rlen, int iseof, ci_request_t * req)\n{\n     int ret = CI_OK;\n\n     if (rbuf && rlen) {\n           *rlen = squidclamav_read_from_net(rbuf, *rlen, iseof, req);\n\t   if (*rlen == CI_ERROR)\n\t      return CI_ERROR;\n           else if (*rlen < 0)\n\t      ret = CI_OK;\n     } else if (iseof) {\n\t   if (squidclamav_read_from_net(NULL, 0, iseof, req) == CI_ERROR)\n\t      return CI_ERROR;\n     }\n     if (wbuf && wlen) {\n          *wlen = squidclamav_write_to_net(wbuf, *wlen, req);\n     }\n     return CI_OK;\n}\n\nint squidclamav_end_of_data_handler(ci_request_t * req)\n{\n     av_req_data_t *data = ci_service_data(req);\n     ci_simple_file_t *body;\n     char cbuff[MAX_URL_SIZE];\n     char clbuf[SMALL_BUFF];\n\n     ssize_t ret;\n     int nbread = 0;\n     int loopw = 60;\n     uint16_t port;\n     struct sockaddr_in server;\n     struct sockaddr_in peer;\n     size_t peer_size;\n     char *pt = NULL;\n     int sockd;\n     int wsockd; \n     unsigned long total_read;\n\n     ci_debug_printf(2, \"DEBUG squidclamav_end_of_data_handler: ending request data handler.\\n\");\n\n     /* Nothing more to scan */\n     if (!data || !data->body)\n          return CI_MOD_DONE;\n\n     if (data->blocked == 1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: blocked content, sending redirection header + error page.\\n\");\n\treturn CI_MOD_DONE;\n     }\n\n     body = data->body;\n     if (data->no_more_scan == 1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: no more data to scan, sending content.\\n\");\n\tci_simple_file_unlock_all(body);\n\treturn CI_MOD_DONE;\n     }\n\n     /* SCAN DATA HERE */\n     if ((sockd = dconnect ()) < 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't connect to Clamd daemon.\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Sending STREAM command to clamd.\\n\");\n\n     if (write(sockd, \"STREAM\", 6) <= 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't write to Clamd socket.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     while (loopw > 0) {\n\tmemset (cbuff, 0, sizeof(cbuff));\n\tret = read (sockd, cbuff, MAX_URL_SIZE);\n\tif ((ret > -1) && (pt = strstr (cbuff, \"PORT\"))) {\n\t   pt += 5;\n\t   sscanf(pt, \"%d\", (int *) &port);\n\t   break;\n\t}\n\tloopw--;\n     }\n     if (loopw == 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Clamd daemon not ready for stream scanning.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Received port %d from clamd.\\n\", port);\n\n     /* connect to clamd given port */\n     if ((wsockd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't create the Clamd socket.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     server.sin_family = AF_INET;\n     server.sin_port = htons (port);\n     peer_size = sizeof (peer);\n\n     if (getpeername(sockd, (struct sockaddr *) &peer, (socklen_t *) &peer_size) < 0) {\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't get socket peer name.\\n\");\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n     switch (peer.sin_family) {\n\tcase AF_UNIX:\n\tserver.sin_addr.s_addr = inet_addr (\"127.0.0.1\");\n\tbreak;\n\tcase AF_INET:\n\tserver.sin_addr.s_addr = peer.sin_addr.s_addr;\n\tbreak;\n\tdefault:\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Unexpected socket type: %d.\\n\", peer.sin_family);\n\tclose(sockd);\n\treturn CI_MOD_ALLOW204;\n     }\n\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Trying to connect to clamd [port: %d].\\n\", port);\n\n     if (connect (wsockd, (struct sockaddr *) &server, sizeof (struct sockaddr_in)) < 0) {\n\tclose(wsockd);\n\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't connect to clamd [port: %d].\\n\", port);\n\treturn CI_MOD_ALLOW204;\n     }\n     ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Ok connected to clamd on port: %d.\\n\", port);\n\n/*-----------------------------------------------------*/\n\n     ci_debug_printf(1, \"DEBUG: squidclamav_end_of_data_handler: Scanning data now\\n\");\n     lseek(body->fd, 0, SEEK_SET);\n     memset(cbuff, 0, sizeof(cbuff));\n     total_read = 0;\n     while (data->virus == 0 && (nbread = read(body->fd, cbuff, MAX_URL_SIZE)) > 0) {\n\t    total_read += nbread;\n\t    ret = write(wsockd, cbuff, nbread);\n\t    if ( (ret <= 0) && (total_read > 0) ) {\n\t\tci_debug_printf(3, \"ERROR squidclamav_end_of_data_handler: Can't write to clamd socket (maybe we reach clamd StreamMaxLength, total read: %ld).\\n\", total_read);\n\t\tbreak;\n\t    } else if ( ret <= 0 ) {\n\t\tci_debug_printf(0, \"ERROR squidclamav_end_of_data_handler: Can't write to clamd socket.\\n\");\n\t\tbreak;\n\t    } else {\n\t\tci_debug_printf(3, \"DEBUG squidclamav_end_of_data_handler: Write %d bytes on %d to socket\\n\", (int)ret, nbread);\n\t    }\n\n\t    memset(cbuff, 0, sizeof(cbuff));\n\n     }\n\n     /* close socket to clamd */\n     if (wsockd > -1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: End Clamd connection, attempting to read result.\\n\");\n\tclose(wsockd);\n     }\n\n     memset (clbuf, 0, sizeof(clbuf));\n     while ((nbread = read(sockd, clbuf, SMALL_BUFF)) > 0) {\n\tci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: received from Clamd: %s\", clbuf);\n\tif (strstr (clbuf, \"FOUND\\n\")) {\n\t   data->virus = 1;\n\t   if (!ci_req_sent_data(req)) {\n\t\tchomp(clbuf);\n\t\tchar *urlredir = (char *) malloc( sizeof(char)*MAX_URL_SIZE );\n\t\tsnprintf(urlredir, MAX_URL_SIZE, \"%s?url=%s&source=%s&user=%s&virus=%s\", redirect_url, data->url, data->clientip, data->user, clbuf);\n\t\tif (logredir == 0)\n\t\t   ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Virus redirection: %s.\\n\", urlredir);\n\t\tif (logredir)\n\t\t    ci_debug_printf(0, \"INFO squidclamav_end_of_data_handler: Virus redirection: %s.\\n\", urlredir);\n\t\tgenerate_redirect_page(urlredir, req, data);\n\t\txfree(urlredir);\n\t   }\n\t   ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Virus found, ending download.\\n\");\n\t   break;\n\t}\n\tmemset(clbuf, 0, sizeof(clbuf));\n     }\n     /* close second socket to clamd */\n     if (sockd > -1) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Closing Clamd connection.\\n\");\n\tclose(sockd);\n     }\n\n     if (data->virus) {\n        ci_debug_printf(1, \"DEBUG squidclamav_end_of_data_handler: Virus found, sending redirection header + error page.\\n\");\n          return CI_MOD_DONE;\n     }\n\n     if (!ci_req_sent_data(req)) {\n\tci_debug_printf(2, \"DEBUG squidclamav_end_of_data_handler: Responding with allow 204\\n\");\n\treturn CI_MOD_ALLOW204;\n     }\n\n     ci_debug_printf(3, \"DEBUG squidclamav_end_of_data_handler: unlocking data to be sent.\\n\");\n     ci_simple_file_unlock_all(body);\n\n     return CI_MOD_DONE;\n}\n\nvoid set_istag(ci_service_xdata_t * srv_xdata)\n{\n     char istag[SERVICE_ISTAG_SIZE + 1];\n\n\n     snprintf(istag, SERVICE_ISTAG_SIZE, \"-%d-%s-%d%d\",1, \"squidclamav\", 1, 0);\n     istag[SERVICE_ISTAG_SIZE] = '\\0';\n     ci_service_set_istag(srv_xdata, istag);\n     ci_debug_printf(2, \"DEBUG set_istag: setting istag to %s\\n\", istag);\n}\n\n/* util.c */\n\n/* NUL-terminated version of strncpy() */\nvoid\nxstrncpy (char *dest, const char *src, size_t n) {\n\tif ( (src == NULL) || (strcmp(src, \"\") == 0))\n\t\treturn;\n\tstrncpy(dest, src, n-1);\n\tdest[n-1] = 0;\n}\n\n/* Emulate the Perl chomp() method: remove \\r and \\n from end of string */\nvoid\nchomp (char *str)\n{\n\tsize_t len = 0;\n\n\tif (str == NULL) return;\n\tlen = strlen(str);\n\tif ((len > 0) && str[len - 1] == 10) {\n\t\tstr[len - 1] = 0;\n\t\tlen--;                                                       \n\t}\n\tif ((len > 0) && str[len - 1] == 13)\n\t\tstr[len - 1] = 0;\n\n\treturn;\n}\n\n/* return 0 if path exists, -1 otherwise */\nint\nisPathExists(const char *path)\n{\n    struct stat sb;\n\n    if ( (path == NULL) || (strcmp(path, \"\") == 0) ) return -1;\n\n    if (lstat(path, &sb) != 0) {\n\treturn -1;\n    }\n\n    return 0;\n}\n\n\n/* return 0 if path is secure, -1 otherwise */\nint\nisPathSecure(const char *path)\n{\n    struct stat sb;\n\n    /* no path => unreal, that's possible ! */\n    if (path == NULL) return -1;\n\n    /* file doesn't exist or access denied = secure */\n    /* fopen will fail */\n    if (lstat(path, &sb) != 0) return 0;\n\n    /* File is not a regular file => unsecure */\n    if ( S_ISLNK(sb.st_mode ) ) return -1;\n    if ( S_ISDIR(sb.st_mode ) ) return -1;\n    if ( S_ISCHR(sb.st_mode ) ) return -1;\n    if ( S_ISBLK(sb.st_mode ) ) return -1;\n    if ( S_ISFIFO(sb.st_mode ) ) return -1;\n    if ( S_ISSOCK(sb.st_mode ) ) return -1;\n\n    return 0;\n}\n\n/*\n *  xfree() - same as free(3).  Will not call free(3) if s == NULL.\n */\nvoid\nxfree(void *s)\n{\n    if (s != NULL)\n        free(s);\n    s = NULL;\n}\n\n/* Remove spaces and tabs from beginning and end of a string */\nvoid\ntrim(char *str)\n{\n\tint i = 0;\n\tint j = 0;\n\n\t/* Remove spaces and tabs from beginning */\n\twhile ( (str[i] == ' ') || (str[i] == '\\t') ) {\n\t\ti++;\n\t}\n\tif (i > 0) {\n\t\tfor (j = i; j < strlen(str); j++) {\n\t\t\tstr[j-i] = str[j];\n\t\t}\n\t\tstr[j-i] = '\\0';\n\t}\n\n\t/* Now remove spaces and tabs from end */\n\ti = strlen(str) - 1;\n\twhile ( (str[i] == ' ') || (str[i] == '\\t')) {\n\t\ti--;\n\t}\n\tif ( i < (strlen(str) - 1) ) {\n\t\tstr[i+1] = '\\0';\n\t}\n}\n\n/* Try to emulate the Perl split() method: str is splitted on the\nall occurence of delim. Take care that empty fields are not returned */\nchar**\nsplit( char* str, const char* delim)\n{\n        int size = 0;\n        char** splitted = NULL;\n        char *tmp = NULL;\n        tmp = strtok(str, delim);\n        while (tmp != NULL) {\n                splitted = (char**) realloc(splitted, sizeof(char**) * (size+1));\n                if (splitted != NULL) {\n                        splitted[size] = tmp;\n                } else {\n                        return(NULL);\n                }\n                tmp = strtok(NULL, delim);\n                size++;\n        }\n        free(tmp);\n        tmp = NULL;\n        /* add null at end of array to help ptrarray_length */\n        splitted = (char**) realloc(splitted, sizeof(char**) * (size+1));\n        if (splitted != NULL) {\n                splitted[size] = NULL;\n        } else {\n                return(NULL);\n        }\n\n        return splitted;\n}\n\n/* Return the length of a pointer array. Must be ended by NULL */\nint\nptrarray_length(char** arr)\n{\n\tint i = 0;\n\twhile(arr[i] != NULL) i++;\n\treturn i;\n}\n\nvoid *\nxmallox (size_t len)\n{\n\tvoid *memres = malloc (len);\n\tif (memres == NULL) {\n\t\tfprintf(stderr, \"Running Out of Memory!!!\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn memres;\n}\n\nsize_t\nxstrnlen(const char *s, size_t n)\n{\n\tconst char *p = (const char *)memchr(s, 0, n);\n\treturn(p ? p-s : n);\n}\n\n\n/* pattern.c */\n   \nint\nisIpAddress(char *src_addr)\n{\n  char *ptr;\n  int address;\n  int i;\n  char *s = (char *) malloc (sizeof (char) * LOW_CHAR);\n\n  xstrncpy(s, src_addr, LOW_CHAR);\n  \n  /* make sure we have numbers and dots only! */\n  if(strspn(s, \"0123456789.\") != strlen(s)) {\n    xfree(s);\n    return 1;\n  }\n\n  /* split up each number from string */\n  ptr = strtok(s, \".\");\n  if(ptr == NULL) {\n    xfree(s);\n    return 1;\n  }\n  address = atoi(ptr);\n  if(address < 0 || address > 255) {\n    xfree(s);\n    xfree(ptr);\n    return 1;\n  }\n  \n  for(i = 2; i < 4; i++) {\n    ptr = strtok(NULL, \".\");\n    if (ptr == NULL) {\n       xfree(s);\n       return 1;\n    }\n    address = atoi(ptr);\n    if (address < 0 || address > 255) {\n       xfree(ptr);\n       xfree(s);\n       return 1;\n    }\n  }\n  xfree(s);\n  \n  return 0;\n}\n\n\nint\nsimple_pattern_compare(char *str, const int type)\n{\n\tint i = 0;  \n\n\t/* pass througth all regex pattern */\n\tfor (i = 0; i < pattc; i++) {\n\t\tif ( (patterns[i].type == type) && (regexec(&patterns[i].regexv, str, 0, 0, 0) == 0) ) {\n\t\t\tswitch(type) {\n\t\t\t\t/* return 1 if string matches whitelist pattern */\n\t\t\t\tcase WHITELIST:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: whitelist (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\t/* return 1 if string matches abort pattern */\n\t\t\t\tcase ABORT:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: abort (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\t/* return 1 if string matches trustuser pattern */\n\t\t\t\tcase TRUSTUSER:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: trustuser (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\t/* return 1 if string matches abortcontent pattern */\n\t\t\t\tcase ABORTCONTENT:\n\t\t\t\t\tif (debug > 0)\n\t\t\t\t\t\tci_debug_printf(2, \"DEBUG simple_pattern_compare: abortcontent (%s) matched: %s\\n\", patterns[i].pattern, str);\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:\n\t\t\t\t\tci_debug_printf(0, \"ERROR simple_pattern_compare: unknown pattern match type: %s\\n\", str);\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* return 0 otherwise */\n\treturn 0;\n}\n\nint\nclient_pattern_compare(char *ip, char *name)\n{\n\tint i = 0;  \n\n\t/* pass througth all regex pattern */\n\tfor (i = 0; i < pattc; i++) {\n\t\tif (patterns[i].type == TRUSTCLIENT) {\n\t\t\t/* Look at client ip pattern matching */\n\t\t\t/* return 1 if string matches ip TRUSTCLIENT pattern */\n\t\t\tif (regexec(&patterns[i].regexv, ip, 0, 0, 0) == 0) {\n\t\t\t\tif (debug != 0)\n\t\t\t\t\tci_debug_printf(2, \"DEBUG client_pattern_compare: trustclient (%s) matched: %s\\n\", patterns[i].pattern, ip);\n\t\t\t\treturn 1;\n\t\t\t/* Look at client name pattern matching */\n\t\t\t/* return 2 if string matches fqdn TRUSTCLIENT pattern */\n\t\t\t} else if ((name != NULL) && (regexec(&patterns[i].regexv, name, 0, 0, 0) == 0)) {\n\t\t\t\tif (debug != 0)\n\t\t\t\t\tci_debug_printf(2, \"DEBUG client_pattern_compare: trustclient (%s) matched: %s\\n\", patterns[i].pattern, name);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* return 0 otherwise */\n\treturn 0;\n}\n\n/* scconfig.c */\n\n/* load the squidclamav.conf */\nint\nload_patterns()\n{\n  char *buf = NULL;\n  FILE *fp  = NULL;\n\n  if (isPathExists(CONFIG_FILE) == 0) {\n    fp = fopen(CONFIG_FILE, \"rt\");\n    if (debug > 0)\n       ci_debug_printf(0, \"LOG load_patterns: Reading configuration from %s\\n\", CONFIG_FILE);\n  }\n  \n\n  if (fp == NULL) {\n\tci_debug_printf(0, \"FATAL load_patterns: unable to open configuration file: %s\\n\", CONFIG_FILE);\n    return 0;\n  }\n\n  buf = (char *)malloc(sizeof(char)*LOW_BUFF*2);\n  if (buf == NULL) {\n\tci_debug_printf(0, \"FATAL load_patterns: unable to allocate memory in load_patterns()\\n\");\n\tfclose(fp);\n\treturn 0;\n  }\n  while ((fgets(buf, LOW_BUFF, fp) != NULL)) {\n      /* chop newline */\n      chomp(buf);\n      /* add to regex patterns array */\n     if (add_pattern(buf) == 0) {\n\txfree(buf);\n\tfclose(fp);\n\treturn 0;\n     }\n  }\n  xfree(buf);\n  if (redirect_url == NULL) {\n    ci_debug_printf(0, \"FATAL load_patterns: No redirection URL set, going to BRIDGE mode\\n\");\n    return 0;\n  }\n   if (squidguard != NULL) {\n    ci_debug_printf(0, \"LOG load_patterns: Chaining with %s\\n\", squidguard);\n  }\n  if (fclose(fp) != 0)\n\tci_debug_printf(0, \"ERROR load_patterns: Can't close configuration file\\n\");\n\n  /* Set default values */\n  if (clamd_local == NULL) {\n\t  if (clamd_ip == NULL) {\n\t\tclamd_ip = (char *) malloc (sizeof (char) * SMALL_CHAR);\n\t\tif(clamd_ip == NULL) {\n\t\t\tci_debug_printf(0, \"FATAL load_patterns: unable to allocate memory in load_patterns()\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\txstrncpy(clamd_ip, CLAMD_SERVER, SMALL_CHAR);\n\t  }\n\n\t  if (clamd_port == NULL) {\n\t\tclamd_port = (char *) malloc (sizeof (char) * LOW_CHAR);\n\t\tif(clamd_port == NULL) {\n\t\t\tci_debug_printf(0, \"FATAL load_patterns: unable to allocate memory in load_patterns()\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\txstrncpy(clamd_port, CLAMD_PORT, LOW_CHAR);\n\t  }\n  }\n\n  return 1;\n}\n\nint\ngrowPatternArray (SCPattern item)\n{\n\tvoid *_tmp = NULL;\n        if (pattc == current_pattern_size) {\n                if (current_pattern_size == 0)\n                        current_pattern_size = PATTERN_ARR_SIZE;\n                else\n                        current_pattern_size += PATTERN_ARR_SIZE;\n\n\t\t_tmp = realloc(patterns, (current_pattern_size * sizeof(SCPattern)));\n                if (!_tmp) {\n                        return(-1);\n                }\n\n                patterns = (SCPattern*)_tmp;\n        }\n        patterns[pattc] = item;\n        pattc++;\n\n\treturn(pattc);\n}\n\n/* Add regexp expression to patterns array */\nint\nadd_pattern(char *s)\n{\n\tchar *first = NULL;\n\tchar *type  = NULL;\n\tint stored = 0;\n\tint regex_flags = REG_NOSUB;\n\tSCPattern currItem;\n\tchar *end = NULL;\n\n\t/* skip empty and commented lines */\n\tif ( (xstrnlen(s, LOW_BUFF) == 0) || (strncmp(s, \"#\", 1) == 0)) return 1;\n\n\t/* Config file directives are construct as follow: name value */  \n\ttype = (char *)malloc(sizeof(char)*LOW_CHAR);\n\tfirst = (char *)malloc(sizeof(char)*LOW_BUFF);\n\tstored = sscanf(s, \"%31s %255[^#]\", type, first);\n  \n\tif (stored < 2) {\n\t\tci_debug_printf(0, \"FATAL add_patterns: Bad configuration line for [%s]\\n\", s);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 0;\n\t}\n\t/* remove extra space or tabulation */\n\ttrim(first);\n\n\t/* URl to redirect Squid on virus found */  \n\tif(strcmp(type, \"redirect\") == 0) {\n\t\tredirect_url = (char *) malloc (sizeof (char) * LOW_BUFF);\n\t\tif(redirect_url == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(redirect_url, first, LOW_BUFF);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\t/* Path to chained other Squid redirector, mostly SquidGuard */\n\tif(strcmp(type, \"squidguard\") == 0) {\n\t\tsquidguard = (char *) malloc (sizeof (char) * LOW_BUFF);\n\t\tif(squidguard == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (isPathExists(first) == 0) {\n\t\t\t\txstrncpy(squidguard, first, LOW_BUFF);\n\t\t\t} else {\n\t\t\t\tci_debug_printf(0, \"LOG add_patterns: Wrong path to SquidGuard, disabling.\\n\");\n\t\t\t\tsquidguard = NULL;\n\t\t\t}\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n  \n\tif(strcmp(type, \"debug\") == 0) {\n\t\tif (debug == 0)\n\t\t   debug = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"logredir\") == 0) {\n\t\tif (logredir == 0)\n\t\t   logredir = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"dnslookup\") == 0) {\n\t\tif (dnslookup == 1)\n\t\t   dnslookup = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"timeout\") == 0) {\n\t\ttimeout = atoi(first);\n\t\tif (timeout > 10)\n\t\t\ttimeout = 10;\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"stat\") == 0) {\n\t\tstatit = atoi(first);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"clamd_ip\") == 0) {\n\t\tclamd_ip = (char *) malloc (sizeof (char) * SMALL_CHAR);\n\t\tif (clamd_ip == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(clamd_ip, first, SMALL_CHAR);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"clamd_port\") == 0) {\n\t\tclamd_port = (char *) malloc (sizeof (char) * LOW_CHAR);\n\t\tif(clamd_port == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(clamd_port, first, LOW_CHAR);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif(strcmp(type, \"clamd_local\") == 0) {\n\t\tclamd_local = (char *) malloc (sizeof (char) * LOW_BUFF);\n\t\tif(clamd_local == NULL) {\n\t\t\tfprintf(stderr, \"unable to allocate memory in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\txstrncpy(clamd_local, first, LOW_BUFF);\n\t\t}\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\tif (strcmp(type, \"maxsize\") == 0) {\n\t\tmaxsize = ci_strto_off_t(first, &end, 10);\n\t\tif ((maxsize == 0 && errno != 0) || maxsize < 0)\n\t\t\tmaxsize = 0;\n\t\tif (*end == 'k' || *end == 'K')\n\t\t\tmaxsize = maxsize * 1024;\n\t\telse if (*end == 'm' || *end == 'M')\n\t\t\tmaxsize = maxsize * 1024 * 1024;\n\t\telse if (*end == 'g' || *end == 'G')\n\t\t\tmaxsize = maxsize * 1024 * 1024 * 1024;\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\t/* force case insensitive pattern matching */\n\t/* so aborti, contenti, regexi are now obsolete */\n\tregex_flags |= REG_ICASE;\n\t/* Add extended regex search */\n\tregex_flags |= REG_EXTENDED;\n\t/* Fill the pattern type */\n\tif (strcmp(type, \"abort\") == 0) {\n\t\tcurrItem.type = ABORT;\n\t} else if (strcmp(type, \"abortcontent\") == 0) {\n\t\tcurrItem.type = ABORTCONTENT;\n\t} else if(strcmp(type, \"whitelist\") == 0) {\n\t\tcurrItem.type = WHITELIST;\n\t} else if(strcmp(type, \"trustuser\") == 0) {\n\t\tcurrItem.type = TRUSTUSER;\n\t} else if(strcmp(type, \"trustclient\") == 0) {\n\t\tcurrItem.type = TRUSTCLIENT;\n\t} else if ( (strcmp(type, \"squid_ip\") != 0) && (strcmp(type, \"squid_port\") != 0) && (strcmp(type, \"maxredir\") != 0) && (strcmp(type, \"useragent\") != 0) && (strcmp(type, \"trust_cache\") != 0) ) {\n\t\tfprintf(stderr, \"WARNING: Bad configuration keyword: %s\\n\", s);\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 1;\n\t}\n\n\t/* Fill the pattern flag */\n\tcurrItem.flag = regex_flags;\n\n\t/* Fill pattern array */\n\tcurrItem.pattern = malloc(sizeof(char)*(strlen(first)+1));\n\tif (currItem.pattern == NULL) {\n\t\tfprintf(stderr, \"unable to allocate new pattern in add_to_patterns()\\n\");\n\t\txfree(type);\n\t\txfree(first);\n\t\treturn 0;\n\t}\n\tstrncpy(currItem.pattern, first, strlen(first) + 1);\n\tif ((stored = regcomp(&currItem.regexv, currItem.pattern, currItem.flag)) != 0) {\n\t\tci_debug_printf(0, \"ERROR add_pattern: Invalid regex pattern: %s\\n\", currItem.pattern);\n\t} else {\n\t\tif (growPatternArray(currItem) < 0) {\n\t\t\tfprintf(stderr, \"unable to allocate new pattern in add_to_patterns()\\n\");\n\t\t\txfree(type);\n\t\t\txfree(first);\n\t\t\treturn 0;\n\t\t}\n\t}\n\txfree(type);\n\txfree(first);\n\treturn 1;\n}\n\nint extract_http_info(ci_request_t * req, ci_headers_list_t * req_header,\n                  struct http_info *httpinf)\n{\n     char *str;\n     int i = 0;\n\n/* Format of the HTTP header we want to parse:\n\t GET http://www.squid-cache.org/Doc/config/icap_service HTTP/1.1\n*/\n     httpinf->url[0]='\\0';\n     httpinf->method[0] = '\\0';\n\n     str = req_header->headers[0];\n\n     /* if we can't find a space character, there's somethings wrong */\n     if (strchr(str, ' ') == NULL) {\n          return 0;\n     }\n\n     /* extract the HTTP method */\n     while (*str != ' ' && i < MAX_METHOD_SIZE) {\n\thttpinf->method[i] = *str;\n        str++;\n\ti++;\n     }\n     httpinf->method[i] = '\\0';\n     ci_debug_printf(3, \"DEBUG extract_http_info: method %s\\n\", httpinf->method);\n\n     /* Extract the URL part of the header */\n     while (*str == ' ') str++;\n     i = 0;\n     while (*str != ' ' && i < MAX_URL_SIZE) {\n\thttpinf->url[i] = *str;\n\ti++;\n\tstr++;\n     }\n     httpinf->url[i] = '\\0';\n     ci_debug_printf(3, \"DEBUG extract_http_info: url %s\\n\", httpinf->url);\n     if (*str != ' ') {\n          return 0;\n     }\n     /* we must find the HTTP version after all */\n     while (*str == ' ')\n          str++;\n     if (*str != 'H' || *(str + 4) != '/') {\n          return 0;\n     }\n\n     return 1;\n}\n\nchar *http_content_type(ci_request_t * req)\n{\n     ci_headers_list_t *heads;\n     char *val;\n     if (!(heads =  ci_http_response_headers(req))) {\n          /* Then maybe is a reqmod request, try to get request headers */\n          if (!(heads = ci_http_request_headers(req)))\n               return NULL;\n     }\n     if (!(val = ci_headers_value(heads, \"Content-Type\")))\n          return NULL;\n\n     return val;\n}\n\nvoid\nfree_global ()\n{\n     xfree(clamd_local);\n     xfree(clamd_ip);\n     xfree(clamd_port);\n     xfree(clamd_curr_ip);\n     xfree(redirect_url);\n     if (patterns != NULL) {\n\twhile (pattc > 0) {\n\t   pattc--;\n\t   regfree(&patterns[pattc].regexv);\n\t   xfree(patterns[pattc].pattern);\n\t}\n\tfree(patterns);\n\tpatterns = NULL;\n     }\n}\n\nvoid\nfree_pipe ()\n{\n     xfree(squidguard);\n     if (sgfpw) fclose(sgfpw);\n     if (sgfpr) fclose(sgfpr);\n}\n\nstatic const char *blocked_header_message =\n     \"<html>\\n\"\n     \"<body>\\n\"\n     \"<p>\\n\"\n     \"You will be redirected in few seconds, if not use this <a href=\\\"\";\n\nstatic const char *blocked_footer_message =\n     \"\\\">direct link</a>.\\n\"\n     \"</p>\\n\"\n     \"</body>\\n\"\n     \"</html>\\n\";\n\nvoid generate_redirect_page(char * redirect, ci_request_t * req, av_req_data_t * data)\n{\n     int new_size = 0;\n     char buf[MAX_URL_SIZE];\n     ci_membuf_t *error_page;\n\n     new_size = strlen(blocked_header_message) + strlen(redirect) + strlen(blocked_footer_message) + 10;\n\n     if ( ci_http_response_headers(req))\n          ci_http_response_reset_headers(req);\n     else\n          ci_http_response_create(req, 1, 1);\n\n     ci_debug_printf(2, \"DEBUG generate_redirect_page: creating redirection page\\n\");\n\n     snprintf(buf, MAX_URL_SIZE, \"Location: %s\", redirect);\n     /*strcat(buf, \";\");*/\n\n     ci_debug_printf(3, \"DEBUG generate_redirect_page: %s\\n\", buf);\n\n     ci_http_response_add_header(req, \"HTTP/1.0 301 Moved Permanently\");\n     ci_http_response_add_header(req, buf);\n     ci_http_response_add_header(req, \"Server: C-ICAP\");\n     ci_http_response_add_header(req, \"Connection: close\");\n     /*ci_http_response_add_header(req, \"Content-Type: text/html;\");*/\n     ci_http_response_add_header(req, \"Content-Type: text/html\");\n     ci_http_response_add_header(req, \"Content-Language: en\");\n\n     if (data->blocked == 1) {\n\terror_page = ci_membuf_new_sized(new_size);\n\t((av_req_data_t *) data)->error_page = error_page;\n\tci_membuf_write(error_page, (char *) blocked_header_message, strlen(blocked_header_message), 0);\n\tci_membuf_write(error_page, (char *) redirect, strlen(redirect), 0);\n\tci_membuf_write(error_page, (char *) blocked_footer_message, strlen(blocked_footer_message), 1);\n     }\n     ci_debug_printf(3, \"DEBUG generate_redirect_page: done\\n\");\n\n}\n\nint create_pipe(char *command)\n{\n\n    int pipe1[2];\n    int pipe2[2];\n\n    ci_debug_printf(1, \"DEBUG create_pipe: Open pipe to squidGuard %s!\\n\", command);\n\n    if (command != NULL) {\n\tif ( pipe(pipe1) < 0  ||  pipe(pipe2) < 0 ) {\n\t\tci_debug_printf(0, \"ERROR create_pipe: unable to open pipe, disabling call to %s.\\n\", command);\n\t\tperror(\"pipe\");\n\t\tusepipe = 0;\n\t} else {\n\t\tif ( (pid = fork()) == -1) {\n\t\t\tci_debug_printf(0, \"ERROR create_pipe: unable to fork, disabling call to %s.\\n\", command);\n\t\t\tusepipe = 0;\n\t\t} else {\n\t\t\tif(pid == 0) {\n\t\t\t\tclose(pipe1[1]);\n\t\t\t\tdup2(pipe1[0],0);\n\t\t\t\tclose(pipe2[0]);\n\t\t\t\tdup2(pipe2[1],1);\n\t\t\t\tsetsid();\n\t\t\t\t/* Running chained program */\n\t\t\t\texeclp(command,(char *)basename(command),(char  *)0);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tclose(pipe1[0]);\n\t\t\t\tsgfpw = fdopen(pipe1[1], \"w\");\n\t\t\t\tif (!sgfpw) {\n\t\t\t\t   ci_debug_printf(0, \"ERROR create_pipe: unable to fopen command's child stdin, disabling it.\\n\");\n\t\t\t\t\tusepipe = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* make pipe line buffered */\n\t\t\t\t\tif (setvbuf (sgfpw, (char *)NULL, _IOLBF, 0)  != 0)\n\t\t\t\t\t\tci_debug_printf(1, \"DEBUG create_pipe: unable to line buffering pipe.\\n\");\n\t\t\t\t\tsgfpr = fdopen(pipe2[0], \"r\");\n\t\t\t\t\tif(!sgfpr) {\n\t\t\t\t\t\tci_debug_printf(0, \"ERROR create_pipe: unable to fopen command's child stdout, disabling it.\\n\");\n\t\t\t\t\t\tusepipe = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tci_debug_printf(1, \"DEBUG create_pipe: bidirectional pipe to %s childs ready...\\n\", command);\n\t\t\t\t\t\tusepipe = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    }\n\n    return 1;\n}\n\nint\ndconnect ()\n{\n  struct sockaddr_un userver;\n  int asockd;\n\n\n  memset ((char *) &userver, 0, sizeof (userver));\n\n  ci_debug_printf(1, \"dconnect: entering.\\n\");\n  if (clamd_local != NULL) {\n      userver.sun_family = AF_UNIX;\n      xstrncpy (userver.sun_path, clamd_local, sizeof(userver.sun_path));\n      if ((asockd = socket (AF_UNIX, SOCK_STREAM, 0)) < 0) {\n          ci_debug_printf(0, \"ERROR dconnect: Can't bind local socket on %s.\\n\", clamd_local);\n          return -1;\n      }\n      if (connect (asockd, (struct sockaddr *) &userver, sizeof (struct sockaddr_un)) < 0) {\n          close (asockd);\n          ci_debug_printf(0, \"ERROR dconnect: Can't connect to clamd on local socket %s.\\n\", clamd_local);\n          return -1;\n      }\n      return asockd;\n\n    } else {\n        if (clamd_curr_ip[0] != 0) {\n                asockd = connectINET(clamd_curr_ip, atoi(clamd_port));\n                if ( asockd != -1 ) {\n                   ci_debug_printf(1, \"DEBUG dconnect: Connected to Clamd (%s:%s)\\n\", clamd_curr_ip,clamd_port);\n                    return asockd;\n                }\n        }\n\n        char *ptr;\n        char *s = (char *) malloc (sizeof (char) * SMALL_CHAR);\n        xstrncpy(s, clamd_ip, SMALL_CHAR);\n        ptr = strtok(s, \",\");\n        while (ptr != NULL) {\n                asockd = connectINET(ptr, atoi(clamd_port));\n                if ( asockd != -1 ) {\n                    ci_debug_printf(1, \"DEBUG dconnect: Connected to Clamd (%s:%s)\\n\", ptr,clamd_port);\n                    /* Store last working clamd */\n                    xstrncpy(clamd_curr_ip, ptr, LOW_CHAR);\n                    xfree(s);\n                    break;\n                }\n                ptr = strtok(NULL, \",\");\n        }\n        return asockd;\n        xfree(s);\n    }\n    return 0;\n}\n\nvoid connect_timeout() {\n   // doesn't actually need to do anything\n}\n\nint\nconnectINET(char *serverHost, uint16_t serverPort)\n{\n        struct sockaddr_in server;\n        struct hostent *he;\n        int asockd;\n\tstruct sigaction action;\n\taction.sa_handler = connect_timeout;\n\n        memset ((char *) &server, 0, sizeof (server));\n        server.sin_addr.s_addr = inet_addr(serverHost);\n        if ((asockd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {\n          ci_debug_printf(0, \"ERROR connectINET: Can't create a socket.\\n\");\n          return -1;\n        }\n\n        server.sin_family = AF_INET;\n        server.sin_port = htons(serverPort);\n\n        if ((he = gethostbyname(serverHost)) == 0)\n        {\n          close(asockd);\n          ci_debug_printf(0, \"ERROR connectINET: Can't lookup hostname of %s\\n\", serverHost);\n          return -1;\n        }\n        server.sin_addr = *(struct in_addr *) he->h_addr_list[0];\n\tsigaction(SIGALRM, &action, NULL);\n\talarm(timeout);\n\n        if (connect (asockd, (struct sockaddr *) &server, sizeof (struct sockaddr_in)) < 0) {\n          close (asockd);\n          ci_debug_printf(0, \"ERROR connectINET: Can't connect on %s:%d.\\n\", serverHost,serverPort);\n          return -1;\n        }\n\tint err = errno;\n\talarm(0);\n\tif (err == EINTR) {\n          close(asockd);\n\t  ci_debug_printf(0, \"ERROR connectINET: Timeout connecting to clamd on %s:%d.\\n\", serverHost,serverPort);\n\t}\n\n        return asockd;\n}\n\n\n/**\n * Searches all occurrences of old into s\n * and replaces with new\n */\nchar *\nreplace(const char *s, const char *old, const char *new)\n{\n\tchar *ret;\n\tint i, count = 0;\n\tsize_t newlen = strlen(new);\n\tsize_t oldlen = strlen(old);\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tif (strstr(&s[i], old) == &s[i]) {\n\t\t\tcount++;\n\t\t\ti += oldlen - 1;\n\t\t}\n\t}\n\tret = malloc(i + 1 + count * (newlen - oldlen));\n\tif (ret != NULL) {\n\t\ti = 0;\n\t\twhile (*s) {\n\t\t\tif (strstr(s, old) == s) {\n\t\t\t\tstrcpy(&ret[i], new);\n\t\t\t\ti += newlen;\n\t\t\t\ts += oldlen;\n\t\t\t} else {\n\t\t\t\tret[i++] = *s++;\n\t\t\t}\n\t\t}\n\t\tret[i] = '\\0';\n\t}\n\n\treturn ret;\n}\n\n"], "filenames": ["src/squidclamav.c"], "buggy_code_start_loc": [136], "buggy_code_end_loc": [1630], "fixing_code_start_loc": [136], "fixing_code_end_loc": [1672], "type": "CWE-119", "message": "The squidclamav_check_preview_handler function in squidclamav.c in SquidClamav 5.x before 5.8 and 6.x before 6.7 passes an unescaped URL to a system command call, which allows remote attackers to cause a denial of service (daemon crash) via a URL with certain characters, as demonstrated using %0D or %0A.", "other": {"cve": {"id": "CVE-2012-3501", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-25T10:29:52.630", "lastModified": "2012-08-27T04:00:00.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The squidclamav_check_preview_handler function in squidclamav.c in SquidClamav 5.x before 5.8 and 6.x before 6.7 passes an unescaped URL to a system command call, which allows remote attackers to cause a denial of service (daemon crash) via a URL with certain characters, as demonstrated using %0D or %0A."}, {"lang": "es", "value": "La funci\u00f3n squidclamav_check_preview_handler en squidclamav.c en SquidClamav v5.x antes de v5.8 y v6.x antes de v6.7 pasa una URL sin escapar a una llamada de comando del sistema, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda del demonio) a trav\u00e9s de una URL con ciertos caracteres, como se demuestra usando %0D o %0A."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "E7CB4208-C119-447E-A7C0-A90BFB499698"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.1:*:*:*:*:*:*:*", "matchCriteriaId": "C153D901-EE91-4F3E-A464-23DFA755A4D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.2:*:*:*:*:*:*:*", "matchCriteriaId": "3E962A89-690A-400F-9B29-8E2A6FC3D81E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B9CE52F-283E-46FC-83DF-79408B2AC0EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.4:*:*:*:*:*:*:*", "matchCriteriaId": "11E37D71-5E81-4526-9E6F-E52162EF840D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.5:*:*:*:*:*:*:*", "matchCriteriaId": "D122E4F9-D9DA-4F67-A37B-37270B279580"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.6:*:*:*:*:*:*:*", "matchCriteriaId": "AB6C2F4A-92F2-466F-AA7B-86693C484900"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:5.7:*:*:*:*:*:*:*", "matchCriteriaId": "8B575DE2-DA05-4FA5-8531-2C02F5E826F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "021CE5B8-5366-43E5-8E63-5D6278DF33DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:6.1:*:*:*:*:*:*:*", "matchCriteriaId": "87A102FB-D889-453C-99A4-AE99C09A8573"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:6.2:*:*:*:*:*:*:*", "matchCriteriaId": "702AC483-3B87-4AC7-8770-7CD3551BFDB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:6.3:*:*:*:*:*:*:*", "matchCriteriaId": "E48B46D6-1647-41FA-AB7D-2D15B391F0D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "1FCF8084-8DE0-472D-984A-BDCD696D5D8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:6.5:*:*:*:*:*:*:*", "matchCriteriaId": "9E9D61D0-38F6-4EF2-8E8D-544F485B37C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:darold:squidclamav:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "E3692992-16C8-4607-8D17-7BF2A1675081"}]}]}], "references": [{"url": "http://freecode.com/projects/squidclamav/releases/346722", "source": "secalert@redhat.com"}, {"url": "http://squidclamav.darold.net/news.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/08/16/2", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/08/16/4", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/54663", "source": "secalert@redhat.com"}, {"url": "https://bugs.gentoo.org/show_bug.cgi?id=428778", "source": "secalert@redhat.com"}, {"url": "https://github.com/darold/squidclamav/commit/80f74451f628264d1d9a1f1c0bbcebc932ba5e00", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/darold/squidclamav/commit/80f74451f628264d1d9a1f1c0bbcebc932ba5e00"}}