{"buggy_code": ["// +build linux\n\npackage chroot\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/containers/buildah/bind\"\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\t\"github.com/containers/storage/pkg/mount\"\n\t\"github.com/containers/storage/pkg/reexec\"\n\t\"github.com/containers/storage/pkg/unshare\"\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/syndtr/gocapability/capability\"\n\t\"golang.org/x/sys/unix\"\n\t\"golang.org/x/term\"\n)\n\nconst (\n\t// runUsingChrootCommand is a command we use as a key for reexec\n\trunUsingChrootCommand = \"buildah-chroot-runtime\"\n\t// runUsingChrootExec is a command we use as a key for reexec\n\trunUsingChrootExecCommand = \"buildah-chroot-exec\"\n)\n\nvar (\n\trlimitsMap = map[string]int{\n\t\t\"RLIMIT_AS\":         unix.RLIMIT_AS,\n\t\t\"RLIMIT_CORE\":       unix.RLIMIT_CORE,\n\t\t\"RLIMIT_CPU\":        unix.RLIMIT_CPU,\n\t\t\"RLIMIT_DATA\":       unix.RLIMIT_DATA,\n\t\t\"RLIMIT_FSIZE\":      unix.RLIMIT_FSIZE,\n\t\t\"RLIMIT_LOCKS\":      unix.RLIMIT_LOCKS,\n\t\t\"RLIMIT_MEMLOCK\":    unix.RLIMIT_MEMLOCK,\n\t\t\"RLIMIT_MSGQUEUE\":   unix.RLIMIT_MSGQUEUE,\n\t\t\"RLIMIT_NICE\":       unix.RLIMIT_NICE,\n\t\t\"RLIMIT_NOFILE\":     unix.RLIMIT_NOFILE,\n\t\t\"RLIMIT_NPROC\":      unix.RLIMIT_NPROC,\n\t\t\"RLIMIT_RSS\":        unix.RLIMIT_RSS,\n\t\t\"RLIMIT_RTPRIO\":     unix.RLIMIT_RTPRIO,\n\t\t\"RLIMIT_RTTIME\":     unix.RLIMIT_RTTIME,\n\t\t\"RLIMIT_SIGPENDING\": unix.RLIMIT_SIGPENDING,\n\t\t\"RLIMIT_STACK\":      unix.RLIMIT_STACK,\n\t}\n\trlimitsReverseMap = map[int]string{}\n)\n\nfunc init() {\n\treexec.Register(runUsingChrootCommand, runUsingChrootMain)\n\treexec.Register(runUsingChrootExecCommand, runUsingChrootExecMain)\n\tfor limitName, limitNumber := range rlimitsMap {\n\t\trlimitsReverseMap[limitNumber] = limitName\n\t}\n}\n\ntype runUsingChrootSubprocOptions struct {\n\tSpec        *specs.Spec\n\tBundlePath  string\n\tUIDMappings []syscall.SysProcIDMap\n\tGIDMappings []syscall.SysProcIDMap\n}\n\ntype runUsingChrootExecSubprocOptions struct {\n\tSpec       *specs.Spec\n\tBundlePath string\n}\n\n// RunUsingChroot runs a chrooted process, using some of the settings from the\n// passed-in spec, and using the specified bundlePath to hold temporary files,\n// directories, and mountpoints.\nfunc RunUsingChroot(spec *specs.Spec, bundlePath, homeDir string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\tvar confwg sync.WaitGroup\n\tvar homeFound bool\n\tfor _, env := range spec.Process.Env {\n\t\tif strings.HasPrefix(env, \"HOME=\") {\n\t\t\thomeFound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !homeFound {\n\t\tspec.Process.Env = append(spec.Process.Env, fmt.Sprintf(\"HOME=%s\", homeDir))\n\t}\n\truntime.LockOSThread()\n\tdefer runtime.UnlockOSThread()\n\n\t// Write the runtime configuration, mainly for debugging.\n\tspecbytes, err := json.Marshal(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = ioutils.AtomicWriteFile(filepath.Join(bundlePath, \"config.json\"), specbytes, 0600); err != nil {\n\t\treturn errors.Wrapf(err, \"error storing runtime configuration\")\n\t}\n\tlogrus.Debugf(\"config = %v\", string(specbytes))\n\n\t// Default to using stdin/stdout/stderr if we weren't passed objects to use.\n\tif stdin == nil {\n\t\tstdin = os.Stdin\n\t}\n\tif stdout == nil {\n\t\tstdout = os.Stdout\n\t}\n\tif stderr == nil {\n\t\tstderr = os.Stderr\n\t}\n\n\t// Create a pipe for passing configuration down to the next process.\n\tpreader, pwriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error creating configuration pipe\")\n\t}\n\tconfig, conferr := json.Marshal(runUsingChrootSubprocOptions{\n\t\tSpec:       spec,\n\t\tBundlePath: bundlePath,\n\t})\n\tif conferr != nil {\n\t\treturn errors.Wrapf(conferr, \"error encoding configuration for %q\", runUsingChrootCommand)\n\t}\n\n\t// Set our terminal's mode to raw, to pass handling of special\n\t// terminal input to the terminal in the container.\n\tif spec.Process.Terminal && term.IsTerminal(unix.Stdin) {\n\t\tstate, err := term.MakeRaw(unix.Stdin)\n\t\tif err != nil {\n\t\t\tlogrus.Warnf(\"error setting terminal state: %v\", err)\n\t\t} else {\n\t\t\tdefer func() {\n\t\t\t\tif err = term.Restore(unix.Stdin, state); err != nil {\n\t\t\t\t\tlogrus.Errorf(\"unable to restore terminal state: %v\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t}\n\n\t// Raise any resource limits that are higher than they are now, before\n\t// we drop any more privileges.\n\tif err = setRlimits(spec, false, true); err != nil {\n\t\treturn err\n\t}\n\n\t// Start the grandparent subprocess.\n\tcmd := unshare.Command(runUsingChrootCommand)\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr\n\tcmd.Dir = \"/\"\n\tcmd.Env = []string{fmt.Sprintf(\"LOGLEVEL=%d\", logrus.GetLevel())}\n\n\tlogrus.Debugf(\"Running %#v in %#v\", cmd.Cmd, cmd)\n\tconfwg.Add(1)\n\tgo func() {\n\t\t_, conferr = io.Copy(pwriter, bytes.NewReader(config))\n\t\tpwriter.Close()\n\t\tconfwg.Done()\n\t}()\n\tcmd.ExtraFiles = append([]*os.File{preader}, cmd.ExtraFiles...)\n\terr = cmd.Run()\n\tconfwg.Wait()\n\tif err == nil {\n\t\treturn conferr\n\t}\n\treturn err\n}\n\n// main() for grandparent subprocess.  Its main job is to shuttle stdio back\n// and forth, managing a pseudo-terminal if we want one, for our child, the\n// parent subprocess.\nfunc runUsingChrootMain() {\n\tvar options runUsingChrootSubprocOptions\n\n\truntime.LockOSThread()\n\n\t// Set logging.\n\tif level := os.Getenv(\"LOGLEVEL\"); level != \"\" {\n\t\tif ll, err := strconv.Atoi(level); err == nil {\n\t\t\tlogrus.SetLevel(logrus.Level(ll))\n\t\t}\n\t\tos.Unsetenv(\"LOGLEVEL\")\n\t}\n\n\t// Unpack our configuration.\n\tconfPipe := os.NewFile(3, \"confpipe\")\n\tif confPipe == nil {\n\t\tfmt.Fprintf(os.Stderr, \"error reading options pipe\\n\")\n\t\tos.Exit(1)\n\t}\n\tdefer confPipe.Close()\n\tif err := json.NewDecoder(confPipe).Decode(&options); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error decoding options: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif options.Spec == nil || options.Spec.Process == nil {\n\t\tfmt.Fprintf(os.Stderr, \"invalid options spec in runUsingChrootMain\\n\")\n\t\tos.Exit(1)\n\t}\n\n\t// Prepare to shuttle stdio back and forth.\n\trootUID32, rootGID32, err := util.GetHostRootIDs(options.Spec)\n\tif err != nil {\n\t\tlogrus.Errorf(\"error determining ownership for container stdio\")\n\t\tos.Exit(1)\n\t}\n\trootUID := int(rootUID32)\n\trootGID := int(rootGID32)\n\trelays := make(map[int]int)\n\tcloseOnceRunning := []*os.File{}\n\tvar ctty *os.File\n\tvar stdin io.Reader\n\tvar stdinCopy io.WriteCloser\n\tvar stdout io.Writer\n\tvar stderr io.Writer\n\tfdDesc := make(map[int]string)\n\tif options.Spec.Process.Terminal {\n\t\t// Create a pseudo-terminal -- open a copy of the master side.\n\t\tptyMasterFd, err := unix.Open(\"/dev/ptmx\", os.O_RDWR, 0600)\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening PTY master using /dev/ptmx: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Set the kernel's lock to \"unlocked\".\n\t\tlocked := 0\n\t\tif result, _, err := unix.Syscall(unix.SYS_IOCTL, uintptr(ptyMasterFd), unix.TIOCSPTLCK, uintptr(unsafe.Pointer(&locked))); int(result) == -1 {\n\t\t\tlogrus.Errorf(\"error unlocking PTY descriptor: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Get a handle for the other end.\n\t\tptyFd, _, err := unix.Syscall(unix.SYS_IOCTL, uintptr(ptyMasterFd), unix.TIOCGPTPEER, unix.O_RDWR|unix.O_NOCTTY)\n\t\tif int(ptyFd) == -1 {\n\t\t\tif errno, isErrno := err.(syscall.Errno); !isErrno || (errno != syscall.EINVAL && errno != syscall.ENOTTY) {\n\t\t\t\tlogrus.Errorf(\"error getting PTY descriptor: %v\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\t// EINVAL means the kernel's too old to understand TIOCGPTPEER.  Try TIOCGPTN.\n\t\t\tptyN, err := unix.IoctlGetInt(ptyMasterFd, unix.TIOCGPTN)\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Errorf(\"error getting PTY number: %v\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\tptyName := fmt.Sprintf(\"/dev/pts/%d\", ptyN)\n\t\t\tfd, err := unix.Open(ptyName, unix.O_RDWR|unix.O_NOCTTY, 0620)\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Errorf(\"error opening PTY %q: %v\", ptyName, err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\tptyFd = uintptr(fd)\n\t\t}\n\t\t// Make notes about what's going where.\n\t\trelays[ptyMasterFd] = unix.Stdout\n\t\trelays[unix.Stdin] = ptyMasterFd\n\t\tfdDesc[ptyMasterFd] = \"container terminal\"\n\t\tfdDesc[unix.Stdin] = \"stdin\"\n\t\tfdDesc[unix.Stdout] = \"stdout\"\n\t\twinsize := &unix.Winsize{}\n\t\t// Set the pseudoterminal's size to the configured size, or our own.\n\t\tif options.Spec.Process.ConsoleSize != nil {\n\t\t\t// Use configured sizes.\n\t\t\twinsize.Row = uint16(options.Spec.Process.ConsoleSize.Height)\n\t\t\twinsize.Col = uint16(options.Spec.Process.ConsoleSize.Width)\n\t\t} else {\n\t\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\t\t// Use the size of our terminal.\n\t\t\t\twinsize, err = unix.IoctlGetWinsize(unix.Stdin, unix.TIOCGWINSZ)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.Debugf(\"error reading current terminal's size\")\n\t\t\t\t\twinsize.Row = 0\n\t\t\t\t\twinsize.Col = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif winsize.Row != 0 && winsize.Col != 0 {\n\t\t\tif err = unix.IoctlSetWinsize(int(ptyFd), unix.TIOCSWINSZ, winsize); err != nil {\n\t\t\t\tlogrus.Warnf(\"error setting terminal size for pty\")\n\t\t\t}\n\t\t\t// FIXME - if we're connected to a terminal, we should\n\t\t\t// be passing the updated terminal size down when we\n\t\t\t// receive a SIGWINCH.\n\t\t}\n\t\t// Open an *os.File object that we can pass to our child.\n\t\tctty = os.NewFile(ptyFd, \"/dev/tty\")\n\t\t// Set ownership for the PTY.\n\t\tif err = ctty.Chown(rootUID, rootGID); err != nil {\n\t\t\tvar cttyInfo unix.Stat_t\n\t\t\terr2 := unix.Fstat(int(ptyFd), &cttyInfo)\n\t\t\tfrom := \"\"\n\t\t\top := \"setting\"\n\t\t\tif err2 == nil {\n\t\t\t\top = \"changing\"\n\t\t\t\tfrom = fmt.Sprintf(\"from %d/%d \", cttyInfo.Uid, cttyInfo.Gid)\n\t\t\t}\n\t\t\tlogrus.Warnf(\"error %s ownership of container PTY %sto %d/%d: %v\", op, from, rootUID, rootGID, err)\n\t\t}\n\t\t// Set permissions on the PTY.\n\t\tif err = ctty.Chmod(0620); err != nil {\n\t\t\tlogrus.Errorf(\"error setting permissions of container PTY: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Make a note that our child (the parent subprocess) should\n\t\t// have the PTY connected to its stdio, and that we should\n\t\t// close it once it's running.\n\t\tstdin = ctty\n\t\tstdout = ctty\n\t\tstderr = ctty\n\t\tcloseOnceRunning = append(closeOnceRunning, ctty)\n\t} else {\n\t\t// Create pipes for stdio.\n\t\tstdinRead, stdinWrite, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening pipe for stdin: %v\", err)\n\t\t}\n\t\tstdoutRead, stdoutWrite, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening pipe for stdout: %v\", err)\n\t\t}\n\t\tstderrRead, stderrWrite, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening pipe for stderr: %v\", err)\n\t\t}\n\t\t// Make notes about what's going where.\n\t\trelays[unix.Stdin] = int(stdinWrite.Fd())\n\t\trelays[int(stdoutRead.Fd())] = unix.Stdout\n\t\trelays[int(stderrRead.Fd())] = unix.Stderr\n\t\tfdDesc[int(stdinWrite.Fd())] = \"container stdin pipe\"\n\t\tfdDesc[int(stdoutRead.Fd())] = \"container stdout pipe\"\n\t\tfdDesc[int(stderrRead.Fd())] = \"container stderr pipe\"\n\t\tfdDesc[unix.Stdin] = \"stdin\"\n\t\tfdDesc[unix.Stdout] = \"stdout\"\n\t\tfdDesc[unix.Stderr] = \"stderr\"\n\t\t// Set ownership for the pipes.\n\t\tif err = stdinRead.Chown(rootUID, rootGID); err != nil {\n\t\t\tlogrus.Errorf(\"error setting ownership of container stdin pipe: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif err = stdoutWrite.Chown(rootUID, rootGID); err != nil {\n\t\t\tlogrus.Errorf(\"error setting ownership of container stdout pipe: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif err = stderrWrite.Chown(rootUID, rootGID); err != nil {\n\t\t\tlogrus.Errorf(\"error setting ownership of container stderr pipe: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Make a note that our child (the parent subprocess) should\n\t\t// have the pipes connected to its stdio, and that we should\n\t\t// close its ends of them once it's running.\n\t\tstdin = stdinRead\n\t\tstdout = stdoutWrite\n\t\tstderr = stderrWrite\n\t\tcloseOnceRunning = append(closeOnceRunning, stdinRead, stdoutWrite, stderrWrite)\n\t\tstdinCopy = stdinWrite\n\t\tdefer stdoutRead.Close()\n\t\tdefer stderrRead.Close()\n\t}\n\tfor readFd, writeFd := range relays {\n\t\tif err := unix.SetNonblock(readFd, true); err != nil {\n\t\t\tlogrus.Errorf(\"error setting descriptor %d (%s) non-blocking: %v\", readFd, fdDesc[readFd], err)\n\t\t\treturn\n\t\t}\n\t\tif err := unix.SetNonblock(writeFd, false); err != nil {\n\t\t\tlogrus.Errorf(\"error setting descriptor %d (%s) blocking: %v\", relays[writeFd], fdDesc[writeFd], err)\n\t\t\treturn\n\t\t}\n\t}\n\tif err := unix.SetNonblock(relays[unix.Stdin], true); err != nil {\n\t\tlogrus.Errorf(\"error setting %d to nonblocking: %v\", relays[unix.Stdin], err)\n\t}\n\tgo func() {\n\t\tbuffers := make(map[int]*bytes.Buffer)\n\t\tfor _, writeFd := range relays {\n\t\t\tbuffers[writeFd] = new(bytes.Buffer)\n\t\t}\n\t\tpollTimeout := -1\n\t\tstdinClose := false\n\t\tfor len(relays) > 0 {\n\t\t\tfds := make([]unix.PollFd, 0, len(relays))\n\t\t\tfor fd := range relays {\n\t\t\t\tfds = append(fds, unix.PollFd{Fd: int32(fd), Events: unix.POLLIN | unix.POLLHUP})\n\t\t\t}\n\t\t\t_, err := unix.Poll(fds, pollTimeout)\n\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"poll: %v\", err)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tremoveFds := make(map[int]struct{})\n\t\t\tfor _, rfd := range fds {\n\t\t\t\tif rfd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\t\tremoveFds[int(rfd.Fd)] = struct{}{}\n\t\t\t\t}\n\t\t\t\tif rfd.Revents&unix.POLLNVAL == unix.POLLNVAL {\n\t\t\t\t\tlogrus.Debugf(\"error polling descriptor %s: closed?\", fdDesc[int(rfd.Fd)])\n\t\t\t\t\tremoveFds[int(rfd.Fd)] = struct{}{}\n\t\t\t\t}\n\t\t\t\tif rfd.Revents&unix.POLLIN == 0 {\n\t\t\t\t\tif stdinClose && stdinCopy == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tb := make([]byte, 8192)\n\t\t\t\tnread, err := unix.Read(int(rfd.Fd), b)\n\t\t\t\tutil.LogIfNotRetryable(err, fmt.Sprintf(\"read %s: %v\", fdDesc[int(rfd.Fd)], err))\n\t\t\t\tif nread > 0 {\n\t\t\t\t\tif wfd, ok := relays[int(rfd.Fd)]; ok {\n\t\t\t\t\t\tnwritten, err := buffers[wfd].Write(b[:nread])\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif nwritten != nread {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", nread, nwritten)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// If this is the last of the data we'll be able to read\n\t\t\t\t\t// from this descriptor, read as much as there is to read.\n\t\t\t\t\tfor rfd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\t\t\tnr, err := unix.Read(int(rfd.Fd), b)\n\t\t\t\t\t\tutil.LogIfUnexpectedWhileDraining(err, fmt.Sprintf(\"read %s: %v\", fdDesc[int(rfd.Fd)], err))\n\t\t\t\t\t\tif nr <= 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif wfd, ok := relays[int(rfd.Fd)]; ok {\n\t\t\t\t\t\t\tnwritten, err := buffers[wfd].Write(b[:nr])\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif nwritten != nr {\n\t\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", nr, nwritten)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif nread == 0 {\n\t\t\t\t\tremoveFds[int(rfd.Fd)] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpollTimeout = -1\n\t\t\tfor wfd, buffer := range buffers {\n\t\t\t\tif buffer.Len() > 0 {\n\t\t\t\t\tnwritten, err := unix.Write(wfd, buffer.Bytes())\n\t\t\t\t\tutil.LogIfNotRetryable(err, fmt.Sprintf(\"write %s: %v\", fdDesc[wfd], err))\n\t\t\t\t\tif nwritten >= 0 {\n\t\t\t\t\t\t_ = buffer.Next(nwritten)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif buffer.Len() > 0 {\n\t\t\t\t\tpollTimeout = 100\n\t\t\t\t}\n\t\t\t\tif wfd == relays[unix.Stdin] && stdinClose && buffer.Len() == 0 {\n\t\t\t\t\tstdinCopy.Close()\n\t\t\t\t\tdelete(relays, unix.Stdin)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor rfd := range removeFds {\n\t\t\t\tif rfd == unix.Stdin {\n\t\t\t\t\tbuffer, found := buffers[relays[unix.Stdin]]\n\t\t\t\t\tif found && buffer.Len() > 0 {\n\t\t\t\t\t\tstdinClose = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !options.Spec.Process.Terminal && rfd == unix.Stdin {\n\t\t\t\t\tstdinCopy.Close()\n\t\t\t\t}\n\t\t\t\tdelete(relays, rfd)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Set up mounts and namespaces, and run the parent subprocess.\n\tstatus, err := runUsingChroot(options.Spec, options.BundlePath, ctty, stdin, stdout, stderr, closeOnceRunning)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error running subprocess: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Pass the process's exit status back to the caller by exiting with the same status.\n\tif status.Exited() {\n\t\tif status.ExitStatus() != 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited with status %d\\n\", status.ExitStatus())\n\t\t}\n\t\tos.Exit(status.ExitStatus())\n\t} else if status.Signaled() {\n\t\tfmt.Fprintf(os.Stderr, \"subprocess exited on %s\\n\", status.Signal())\n\t\tos.Exit(1)\n\t}\n}\n\n// runUsingChroot, still in the grandparent process, sets up various bind\n// mounts and then runs the parent process in its own user namespace with the\n// necessary ID mappings.\nfunc runUsingChroot(spec *specs.Spec, bundlePath string, ctty *os.File, stdin io.Reader, stdout, stderr io.Writer, closeOnceRunning []*os.File) (wstatus unix.WaitStatus, err error) {\n\tvar confwg sync.WaitGroup\n\n\t// Create a new mount namespace for ourselves and bind mount everything to a new location.\n\tundoIntermediates, err := bind.SetupIntermediateMountNamespace(spec, bundlePath)\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tdefer func() {\n\t\tif undoErr := undoIntermediates(); undoErr != nil {\n\t\t\tlogrus.Debugf(\"error cleaning up intermediate mount NS: %v\", err)\n\t\t}\n\t}()\n\n\t// Bind mount in our filesystems.\n\tundoChroots, err := setupChrootBindMounts(spec, bundlePath)\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tdefer func() {\n\t\tif undoErr := undoChroots(); undoErr != nil {\n\t\t\tlogrus.Debugf(\"error cleaning up intermediate chroot bind mounts: %v\", err)\n\t\t}\n\t}()\n\n\t// Create a pipe for passing configuration down to the next process.\n\tpreader, pwriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error creating configuration pipe\")\n\t}\n\tconfig, conferr := json.Marshal(runUsingChrootExecSubprocOptions{\n\t\tSpec:       spec,\n\t\tBundlePath: bundlePath,\n\t})\n\tif conferr != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error re-encoding configuration for %q\", runUsingChrootExecCommand)\n\t\tos.Exit(1)\n\t}\n\n\t// Apologize for the namespace configuration that we're about to ignore.\n\tlogNamespaceDiagnostics(spec)\n\n\t// If we have configured ID mappings, set them here so that they can apply to the child.\n\thostUidmap, hostGidmap, err := unshare.GetHostIDMappings(\"\")\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tuidmap, gidmap := spec.Linux.UIDMappings, spec.Linux.GIDMappings\n\tif len(uidmap) == 0 {\n\t\t// No UID mappings are configured for the container.  Borrow our parent's mappings.\n\t\tuidmap = append([]specs.LinuxIDMapping{}, hostUidmap...)\n\t\tfor i := range uidmap {\n\t\t\tuidmap[i].HostID = uidmap[i].ContainerID\n\t\t}\n\t}\n\tif len(gidmap) == 0 {\n\t\t// No GID mappings are configured for the container.  Borrow our parent's mappings.\n\t\tgidmap = append([]specs.LinuxIDMapping{}, hostGidmap...)\n\t\tfor i := range gidmap {\n\t\t\tgidmap[i].HostID = gidmap[i].ContainerID\n\t\t}\n\t}\n\n\t// Start the parent subprocess.\n\tcmd := unshare.Command(append([]string{runUsingChrootExecCommand}, spec.Process.Args...)...)\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr\n\tcmd.Dir = \"/\"\n\tcmd.Env = []string{fmt.Sprintf(\"LOGLEVEL=%d\", logrus.GetLevel())}\n\tcmd.UnshareFlags = syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS\n\trequestedUserNS := false\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tif ns.Type == specs.UserNamespace {\n\t\t\trequestedUserNS = true\n\t\t}\n\t}\n\tif len(spec.Linux.UIDMappings) > 0 || len(spec.Linux.GIDMappings) > 0 || requestedUserNS {\n\t\tcmd.UnshareFlags = cmd.UnshareFlags | syscall.CLONE_NEWUSER\n\t\tcmd.UidMappings = uidmap\n\t\tcmd.GidMappings = gidmap\n\t\tcmd.GidMappingsEnableSetgroups = true\n\t}\n\tif ctty != nil {\n\t\tcmd.Setsid = true\n\t\tcmd.Ctty = ctty\n\t}\n\tcmd.OOMScoreAdj = spec.Process.OOMScoreAdj\n\tcmd.ExtraFiles = append([]*os.File{preader}, cmd.ExtraFiles...)\n\tcmd.Hook = func(int) error {\n\t\tfor _, f := range closeOnceRunning {\n\t\t\tf.Close()\n\t\t}\n\t\treturn nil\n\t}\n\n\tlogrus.Debugf(\"Running %#v in %#v\", cmd.Cmd, cmd)\n\tconfwg.Add(1)\n\tgo func() {\n\t\t_, conferr = io.Copy(pwriter, bytes.NewReader(config))\n\t\tpwriter.Close()\n\t\tconfwg.Done()\n\t}()\n\terr = cmd.Run()\n\tconfwg.Wait()\n\tif err != nil {\n\t\tif exitError, ok := err.(*exec.ExitError); ok {\n\t\t\tif waitStatus, ok := exitError.ProcessState.Sys().(syscall.WaitStatus); ok {\n\t\t\t\tif waitStatus.Exited() {\n\t\t\t\t\tif waitStatus.ExitStatus() != 0 {\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited with status %d\\n\", waitStatus.ExitStatus())\n\t\t\t\t\t}\n\t\t\t\t\tos.Exit(waitStatus.ExitStatus())\n\t\t\t\t} else if waitStatus.Signaled() {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited on %s\\n\", waitStatus.Signal())\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintf(os.Stderr, \"process exited with error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\treturn 0, nil\n}\n\n// main() for parent subprocess.  Its main job is to try to make our\n// environment look like the one described by the runtime configuration blob,\n// and then launch the intended command as a child.\nfunc runUsingChrootExecMain() {\n\targs := os.Args[1:]\n\tvar options runUsingChrootExecSubprocOptions\n\tvar err error\n\n\truntime.LockOSThread()\n\n\t// Set logging.\n\tif level := os.Getenv(\"LOGLEVEL\"); level != \"\" {\n\t\tif ll, err := strconv.Atoi(level); err == nil {\n\t\t\tlogrus.SetLevel(logrus.Level(ll))\n\t\t}\n\t\tos.Unsetenv(\"LOGLEVEL\")\n\t}\n\n\t// Unpack our configuration.\n\tconfPipe := os.NewFile(3, \"confpipe\")\n\tif confPipe == nil {\n\t\tfmt.Fprintf(os.Stderr, \"error reading options pipe\\n\")\n\t\tos.Exit(1)\n\t}\n\tdefer confPipe.Close()\n\tif err := json.NewDecoder(confPipe).Decode(&options); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error decoding options: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Set the hostname.  We're already in a distinct UTS namespace and are admins in the user\n\t// namespace which created it, so we shouldn't get a permissions error, but seccomp policy\n\t// might deny our attempt to call sethostname() anyway, so log a debug message for that.\n\tif options.Spec == nil || options.Spec.Process == nil {\n\t\tfmt.Fprintf(os.Stderr, \"invalid options spec passed in\\n\")\n\t\tos.Exit(1)\n\t}\n\n\tif options.Spec.Hostname != \"\" {\n\t\tif err := unix.Sethostname([]byte(options.Spec.Hostname)); err != nil {\n\t\t\tlogrus.Debugf(\"failed to set hostname %q for process: %v\", options.Spec.Hostname, err)\n\t\t}\n\t}\n\n\t// Try to chroot into the root.  Do this before we potentially block the syscall via the\n\t// seccomp profile.\n\tvar oldst, newst unix.Stat_t\n\tif err := unix.Stat(options.Spec.Root.Path, &oldst); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error stat()ing intended root directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Chdir(options.Spec.Root.Path); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chdir()ing to intended root directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Chroot(options.Spec.Root.Path); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chroot()ing into directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Stat(\"/\", &newst); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error stat()ing current root directory: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tif oldst.Dev != newst.Dev || oldst.Ino != newst.Ino {\n\t\tfmt.Fprintf(os.Stderr, \"unknown error chroot()ing into directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tlogrus.Debugf(\"chrooted into %q\", options.Spec.Root.Path)\n\n\t// not doing because it's still shared: creating devices\n\t// not doing because it's not applicable: setting annotations\n\t// not doing because it's still shared: setting sysctl settings\n\t// not doing because cgroupfs is read only: configuring control groups\n\t// -> this means we can use the freezer to make sure there aren't any lingering processes\n\t// -> this means we ignore cgroups-based controls\n\t// not doing because we don't set any in the config: running hooks\n\t// not doing because we don't set it in the config: setting rootfs read-only\n\t// not doing because we don't set it in the config: setting rootfs propagation\n\tlogrus.Debugf(\"setting apparmor profile\")\n\tif err = setApparmorProfile(options.Spec); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting apparmor profile for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tif err = setSelinuxLabel(options.Spec); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting SELinux label for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlogrus.Debugf(\"setting resource limits\")\n\tif err = setRlimits(options.Spec, false, false); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting process resource limits for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Try to change to the directory.\n\tcwd := options.Spec.Process.Cwd\n\tif !filepath.IsAbs(cwd) {\n\t\tcwd = \"/\" + cwd\n\t}\n\tcwd = filepath.Clean(cwd)\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chdir()ing into new root directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Chdir(cwd); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chdir()ing into directory %q under root %q: %v\\n\", cwd, options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tlogrus.Debugf(\"changed working directory to %q\", cwd)\n\n\t// Drop privileges.\n\tuser := options.Spec.Process.User\n\tif len(user.AdditionalGids) > 0 {\n\t\tgids := make([]int, len(user.AdditionalGids))\n\t\tfor i := range user.AdditionalGids {\n\t\t\tgids[i] = int(user.AdditionalGids[i])\n\t\t}\n\t\tlogrus.Debugf(\"setting supplemental groups\")\n\t\tif err = syscall.Setgroups(gids); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"error setting supplemental groups list: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t} else {\n\t\tsetgroups, _ := ioutil.ReadFile(\"/proc/self/setgroups\")\n\t\tif strings.Trim(string(setgroups), \"\\n\") != \"deny\" {\n\t\t\tlogrus.Debugf(\"clearing supplemental groups\")\n\t\t\tif err = syscall.Setgroups([]int{}); err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"error clearing supplemental groups list: %v\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogrus.Debugf(\"setting gid\")\n\tif err = syscall.Setresgid(int(user.GID), int(user.GID), int(user.GID)); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting GID: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif err = setSeccomp(options.Spec); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting seccomp filter for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlogrus.Debugf(\"setting capabilities\")\n\tvar keepCaps []string\n\tif user.UID != 0 {\n\t\tkeepCaps = []string{\"CAP_SETUID\"}\n\t}\n\tif err := setCapabilities(options.Spec, keepCaps...); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting capabilities for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlogrus.Debugf(\"setting uid\")\n\tif err = syscall.Setresuid(int(user.UID), int(user.UID), int(user.UID)); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting UID: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Actually run the specified command.\n\tcmd := exec.Command(args[0], args[1:]...)\n\tcmd.Env = options.Spec.Process.Env\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr\n\tcmd.Dir = cwd\n\tlogrus.Debugf(\"Running %#v (PATH = %q)\", cmd, os.Getenv(\"PATH\"))\n\tif err = cmd.Run(); err != nil {\n\t\tif exitError, ok := err.(*exec.ExitError); ok {\n\t\t\tif waitStatus, ok := exitError.ProcessState.Sys().(syscall.WaitStatus); ok {\n\t\t\t\tif waitStatus.Exited() {\n\t\t\t\t\tif waitStatus.ExitStatus() != 0 {\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited with status %d\\n\", waitStatus.ExitStatus())\n\t\t\t\t\t}\n\t\t\t\t\tos.Exit(waitStatus.ExitStatus())\n\t\t\t\t} else if waitStatus.Signaled() {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited on %s\\n\", waitStatus.Signal())\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintf(os.Stderr, \"process exited with error: %v\", err)\n\t\tos.Exit(1)\n\t}\n}\n\n// logNamespaceDiagnostics knows which namespaces we want to create.\n// Output debug messages when that differs from what we're being asked to do.\nfunc logNamespaceDiagnostics(spec *specs.Spec) {\n\tsawMountNS := false\n\tsawUTSNS := false\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase specs.CgroupNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join cgroup namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create cgroup namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.IPCNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join IPC namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create IPC namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.MountNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join mount namespace %q, creating a new one\", ns.Path)\n\t\t\t}\n\t\t\tsawMountNS = true\n\t\tcase specs.NetworkNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join network namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create network namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.PIDNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join PID namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create PID namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.UserNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join user namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.UTSNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join UTS namespace %q, creating a new one\", ns.Path)\n\t\t\t}\n\t\t\tsawUTSNS = true\n\t\t}\n\t}\n\tif !sawMountNS {\n\t\tlogrus.Debugf(\"mount namespace not requested, but creating a new one anyway\")\n\t}\n\tif !sawUTSNS {\n\t\tlogrus.Debugf(\"UTS namespace not requested, but creating a new one anyway\")\n\t}\n}\n\n// setApparmorProfile sets the apparmor profile for ourselves, and hopefully any child processes that we'll start.\nfunc setApparmorProfile(spec *specs.Spec) error {\n\tif !apparmor.IsEnabled() || spec.Process.ApparmorProfile == \"\" {\n\t\treturn nil\n\t}\n\tif err := apparmor.ApplyProfile(spec.Process.ApparmorProfile); err != nil {\n\t\treturn errors.Wrapf(err, \"error setting apparmor profile to %q\", spec.Process.ApparmorProfile)\n\t}\n\treturn nil\n}\n\n// setCapabilities sets capabilities for ourselves, to be more or less inherited by any processes that we'll start.\nfunc setCapabilities(spec *specs.Spec, keepCaps ...string) error {\n\tcurrentCaps, err := capability.NewPid2(0)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error reading capabilities of current process\")\n\t}\n\tif err := currentCaps.Load(); err != nil {\n\t\treturn errors.Wrapf(err, \"error loading capabilities\")\n\t}\n\tcaps, err := capability.NewPid2(0)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error reading capabilities of current process\")\n\t}\n\tcapMap := map[capability.CapType][]string{\n\t\tcapability.BOUNDING:    spec.Process.Capabilities.Bounding,\n\t\tcapability.EFFECTIVE:   spec.Process.Capabilities.Effective,\n\t\tcapability.INHERITABLE: spec.Process.Capabilities.Inheritable,\n\t\tcapability.PERMITTED:   spec.Process.Capabilities.Permitted,\n\t\tcapability.AMBIENT:     spec.Process.Capabilities.Ambient,\n\t}\n\tknownCaps := capability.List()\n\tnoCap := capability.Cap(-1)\n\tfor capType, capList := range capMap {\n\t\tfor _, capToSet := range capList {\n\t\t\tcap := noCap\n\t\t\tfor _, c := range knownCaps {\n\t\t\t\tif strings.EqualFold(\"CAP_\"+c.String(), capToSet) {\n\t\t\t\t\tcap = c\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cap == noCap {\n\t\t\t\treturn errors.Errorf(\"error mapping capability %q to a number\", capToSet)\n\t\t\t}\n\t\t\tcaps.Set(capType, cap)\n\t\t}\n\t\tfor _, capToSet := range keepCaps {\n\t\t\tcap := noCap\n\t\t\tfor _, c := range knownCaps {\n\t\t\t\tif strings.EqualFold(\"CAP_\"+c.String(), capToSet) {\n\t\t\t\t\tcap = c\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cap == noCap {\n\t\t\t\treturn errors.Errorf(\"error mapping capability %q to a number\", capToSet)\n\t\t\t}\n\t\t\tif currentCaps.Get(capType, cap) {\n\t\t\t\tcaps.Set(capType, cap)\n\t\t\t}\n\t\t}\n\t}\n\tif err = caps.Apply(capability.CAPS | capability.BOUNDS | capability.AMBS); err != nil {\n\t\treturn errors.Wrapf(err, \"error setting capabilities\")\n\t}\n\treturn nil\n}\n\n// parses the resource limits for ourselves and any processes that\n// we'll start into a format that's more in line with the kernel APIs\nfunc parseRlimits(spec *specs.Spec) (map[int]unix.Rlimit, error) {\n\tif spec.Process == nil {\n\t\treturn nil, nil\n\t}\n\tparsed := make(map[int]unix.Rlimit)\n\tfor _, limit := range spec.Process.Rlimits {\n\t\tresource, recognized := rlimitsMap[strings.ToUpper(limit.Type)]\n\t\tif !recognized {\n\t\t\treturn nil, errors.Errorf(\"error parsing limit type %q\", limit.Type)\n\t\t}\n\t\tparsed[resource] = unix.Rlimit{Cur: limit.Soft, Max: limit.Hard}\n\t}\n\treturn parsed, nil\n}\n\n// setRlimits sets any resource limits that we want to apply to processes that\n// we'll start.\nfunc setRlimits(spec *specs.Spec, onlyLower, onlyRaise bool) error {\n\tlimits, err := parseRlimits(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor resource, desired := range limits {\n\t\tvar current unix.Rlimit\n\t\tif err := unix.Getrlimit(resource, &current); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error reading %q limit\", rlimitsReverseMap[resource])\n\t\t}\n\t\tif desired.Max > current.Max && onlyLower {\n\t\t\t// this would raise a hard limit, and we're only here to lower them\n\t\t\tcontinue\n\t\t}\n\t\tif desired.Max < current.Max && onlyRaise {\n\t\t\t// this would lower a hard limit, and we're only here to raise them\n\t\t\tcontinue\n\t\t}\n\t\tif err := unix.Setrlimit(resource, &desired); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error setting %q limit to soft=%d,hard=%d (was soft=%d,hard=%d)\", rlimitsReverseMap[resource], desired.Cur, desired.Max, current.Cur, current.Max)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc makeReadOnly(mntpoint string, flags uintptr) error {\n\tvar fs unix.Statfs_t\n\t// Make sure it's read-only.\n\tif err := unix.Statfs(mntpoint, &fs); err != nil {\n\t\treturn errors.Wrapf(err, \"error checking if directory %q was bound read-only\", mntpoint)\n\t}\n\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\tif err := unix.Mount(mntpoint, mntpoint, \"bind\", flags|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error remounting %s in mount namespace read-only\", mntpoint)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc isDevNull(dev os.FileInfo) bool {\n\tif dev.Mode()&os.ModeCharDevice != 0 {\n\t\tstat, _ := dev.Sys().(*syscall.Stat_t)\n\t\tnullStat := syscall.Stat_t{}\n\t\tif err := syscall.Stat(os.DevNull, &nullStat); err != nil {\n\t\t\tlogrus.Warnf(\"unable to stat /dev/null: %v\", err)\n\t\t\treturn false\n\t\t}\n\t\tif stat.Rdev == nullStat.Rdev {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// setupChrootBindMounts actually bind mounts things under the rootfs, and returns a\n// callback that will clean up its work.\nfunc setupChrootBindMounts(spec *specs.Spec, bundlePath string) (undoBinds func() error, err error) {\n\tvar fs unix.Statfs_t\n\tundoBinds = func() error {\n\t\tif err2 := unix.Unmount(spec.Root.Path, unix.MNT_DETACH); err2 != nil {\n\t\t\tretries := 0\n\t\t\tfor (err2 == unix.EBUSY || err2 == unix.EAGAIN) && retries < 50 {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\terr2 = unix.Unmount(spec.Root.Path, unix.MNT_DETACH)\n\t\t\t\tretries++\n\t\t\t}\n\t\t\tif err2 != nil {\n\t\t\t\tlogrus.Warnf(\"pkg/chroot: error unmounting %q (retried %d times): %v\", spec.Root.Path, retries, err2)\n\t\t\t\tif err == nil {\n\t\t\t\t\terr = err2\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\t// Now bind mount all of those things to be under the rootfs's location in this\n\t// mount namespace.\n\tcommonFlags := uintptr(unix.MS_BIND | unix.MS_REC | unix.MS_PRIVATE)\n\tbindFlags := commonFlags | unix.MS_NODEV\n\tdevFlags := commonFlags | unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_RDONLY\n\tprocFlags := devFlags | unix.MS_NODEV\n\tsysFlags := devFlags | unix.MS_NODEV\n\n\t// Bind /dev read-only.\n\tsubDev := filepath.Join(spec.Root.Path, \"/dev\")\n\tif err := unix.Mount(\"/dev\", subDev, \"bind\", devFlags, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\terr = os.Mkdir(subDev, 0755)\n\t\t\tif err == nil {\n\t\t\t\terr = unix.Mount(\"/dev\", subDev, \"bind\", devFlags, \"\")\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting /dev from host into mount namespace\")\n\t\t}\n\t}\n\t// Make sure it's read-only.\n\tif err = unix.Statfs(subDev, &fs); err != nil {\n\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was bound read-only\", subDev)\n\t}\n\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\tif err := unix.Mount(subDev, subDev, \"bind\", devFlags|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error remounting /dev in mount namespace read-only\")\n\t\t}\n\t}\n\tlogrus.Debugf(\"bind mounted %q to %q\", \"/dev\", filepath.Join(spec.Root.Path, \"/dev\"))\n\n\t// Bind /proc read-only.\n\tsubProc := filepath.Join(spec.Root.Path, \"/proc\")\n\tif err := unix.Mount(\"/proc\", subProc, \"bind\", procFlags, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\terr = os.Mkdir(subProc, 0755)\n\t\t\tif err == nil {\n\t\t\t\terr = unix.Mount(\"/proc\", subProc, \"bind\", procFlags, \"\")\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting /proc from host into mount namespace\")\n\t\t}\n\t}\n\tlogrus.Debugf(\"bind mounted %q to %q\", \"/proc\", filepath.Join(spec.Root.Path, \"/proc\"))\n\n\t// Bind /sys read-only.\n\tsubSys := filepath.Join(spec.Root.Path, \"/sys\")\n\tif err := unix.Mount(\"/sys\", subSys, \"bind\", sysFlags, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\terr = os.Mkdir(subSys, 0755)\n\t\t\tif err == nil {\n\t\t\t\terr = unix.Mount(\"/sys\", subSys, \"bind\", sysFlags, \"\")\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting /sys from host into mount namespace\")\n\t\t}\n\t}\n\tif err := makeReadOnly(subSys, sysFlags); err != nil {\n\t\treturn undoBinds, err\n\t}\n\n\tmnts, _ := mount.GetMounts()\n\tfor _, m := range mnts {\n\t\tif !strings.HasPrefix(m.Mountpoint, \"/sys/\") &&\n\t\t\tm.Mountpoint != \"/sys\" {\n\t\t\tcontinue\n\t\t}\n\t\tsubSys := filepath.Join(spec.Root.Path, m.Mountpoint)\n\t\tif err := unix.Mount(m.Mountpoint, subSys, \"bind\", sysFlags, \"\"); err != nil {\n\t\t\tmsg := fmt.Sprintf(\"could not bind mount %q, skipping: %v\", m.Mountpoint, err)\n\t\t\tif strings.HasPrefix(m.Mountpoint, \"/sys\") {\n\t\t\t\tlogrus.Infof(msg)\n\t\t\t} else {\n\t\t\t\tlogrus.Warningf(msg)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err := makeReadOnly(subSys, sysFlags); err != nil {\n\t\t\treturn undoBinds, err\n\t\t}\n\t}\n\tlogrus.Debugf(\"bind mounted %q to %q\", \"/sys\", filepath.Join(spec.Root.Path, \"/sys\"))\n\n\t// Bind mount in everything we've been asked to mount.\n\tfor _, m := range spec.Mounts {\n\t\t// Skip anything that we just mounted.\n\t\tswitch m.Destination {\n\t\tcase \"/dev\", \"/proc\", \"/sys\":\n\t\t\tlogrus.Debugf(\"already bind mounted %q on %q\", m.Destination, filepath.Join(spec.Root.Path, m.Destination))\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tif strings.HasPrefix(m.Destination, \"/dev/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.HasPrefix(m.Destination, \"/proc/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.HasPrefix(m.Destination, \"/sys/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// Skip anything that isn't a bind or tmpfs mount.\n\t\tif m.Type != \"bind\" && m.Type != \"tmpfs\" && m.Type != \"overlay\" {\n\t\t\tlogrus.Debugf(\"skipping mount of type %q on %q\", m.Type, m.Destination)\n\t\t\tcontinue\n\t\t}\n\t\t// If the target is there, we can just mount it.\n\t\tvar srcinfo os.FileInfo\n\t\tswitch m.Type {\n\t\tcase \"bind\":\n\t\t\tsrcinfo, err = os.Stat(m.Source)\n\t\t\tif err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining %q for mounting in mount namespace\", m.Source)\n\t\t\t}\n\t\tcase \"overlay\":\n\t\t\tfallthrough\n\t\tcase \"tmpfs\":\n\t\t\tsrcinfo, err = os.Stat(\"/\")\n\t\t\tif err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining / to use as a template for a %s\", m.Type)\n\t\t\t}\n\t\t}\n\t\ttarget := filepath.Join(spec.Root.Path, m.Destination)\n\t\t// Check if target is a symlink\n\t\tstat, err := os.Lstat(target)\n\t\t// If target is a symlink, follow the link and ensure the destination exists\n\t\tif err == nil && stat != nil && (stat.Mode()&os.ModeSymlink != 0) {\n\t\t\ttarget, err = copier.Eval(spec.Root.Path, m.Destination, copier.EvalOptions{})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"evaluating symlink %q\", target)\n\t\t\t}\n\t\t\t// Stat the destination of the evaluated symlink\n\t\t\t_, err = os.Stat(target)\n\t\t}\n\t\tif err != nil {\n\t\t\t// If the target can't be stat()ted, check the error.\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining %q for mounting in mount namespace\", target)\n\t\t\t}\n\t\t\t// The target isn't there yet, so create it.\n\t\t\tif srcinfo.IsDir() {\n\t\t\t\tif err = os.MkdirAll(target, 0755); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error creating mountpoint %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err = os.MkdirAll(filepath.Dir(target), 0755); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error ensuring parent of mountpoint %q (%q) is present in mount namespace\", target, filepath.Dir(target))\n\t\t\t\t}\n\t\t\t\tvar file *os.File\n\t\t\t\tif file, err = os.OpenFile(target, os.O_WRONLY|os.O_CREATE, 0755); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error creating mountpoint %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t\tfile.Close()\n\t\t\t}\n\t\t}\n\t\trequestFlags := bindFlags\n\t\texpectedFlags := uintptr(0)\n\t\tfor _, option := range m.Options {\n\t\t\tswitch option {\n\t\t\tcase \"nodev\":\n\t\t\t\trequestFlags |= unix.MS_NODEV\n\t\t\t\texpectedFlags |= unix.ST_NODEV\n\t\t\tcase \"dev\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_NODEV)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_NODEV)\n\t\t\tcase \"noexec\":\n\t\t\t\trequestFlags |= unix.MS_NOEXEC\n\t\t\t\texpectedFlags |= unix.ST_NOEXEC\n\t\t\tcase \"exec\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_NOEXEC)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_NOEXEC)\n\t\t\tcase \"nosuid\":\n\t\t\t\trequestFlags |= unix.MS_NOSUID\n\t\t\t\texpectedFlags |= unix.ST_NOSUID\n\t\t\tcase \"suid\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_NOSUID)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_NOSUID)\n\t\t\tcase \"ro\":\n\t\t\t\trequestFlags |= unix.MS_RDONLY\n\t\t\t\texpectedFlags |= unix.ST_RDONLY\n\t\t\tcase \"rw\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_RDONLY)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_RDONLY)\n\t\t\t}\n\t\t}\n\t\tswitch m.Type {\n\t\tcase \"bind\":\n\t\t\t// Do the bind mount.\n\t\t\tlogrus.Debugf(\"bind mounting %q on %q\", m.Destination, filepath.Join(spec.Root.Path, m.Destination))\n\t\t\tif err := unix.Mount(m.Source, target, \"\", requestFlags, \"\"); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting %q from host to %q in mount namespace (%q)\", m.Source, m.Destination, target)\n\t\t\t}\n\t\t\tlogrus.Debugf(\"bind mounted %q to %q\", m.Source, target)\n\t\tcase \"tmpfs\":\n\t\t\t// Mount a tmpfs.\n\t\t\tif err := mount.Mount(m.Source, target, m.Type, strings.Join(append(m.Options, \"private\"), \",\")); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error mounting tmpfs to %q in mount namespace (%q, %q)\", m.Destination, target, strings.Join(m.Options, \",\"))\n\t\t\t}\n\t\t\tlogrus.Debugf(\"mounted a tmpfs to %q\", target)\n\t\tcase \"overlay\":\n\t\t\t// Mount a overlay.\n\t\t\tif err := mount.Mount(m.Source, target, m.Type, strings.Join(append(m.Options, \"private\"), \",\")); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error mounting overlay to %q in mount namespace (%q, %q)\", m.Destination, target, strings.Join(m.Options, \",\"))\n\t\t\t}\n\t\t\tlogrus.Debugf(\"mounted a overlay to %q\", target)\n\t\t}\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was bound read-only\", target)\n\t\t}\n\t\tif uintptr(fs.Flags)&expectedFlags != expectedFlags {\n\t\t\tif err := unix.Mount(target, target, \"bind\", requestFlags|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error remounting %q in mount namespace with expected flags\", target)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set up any read-only paths that we need to.  If we're running inside\n\t// of a container, some of these locations will already be read-only.\n\tfor _, roPath := range spec.Linux.ReadonlyPaths {\n\t\tr := filepath.Join(spec.Root.Path, roPath)\n\t\ttarget, err := filepath.EvalSymlinks(r)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking %q for symlinks before marking it read-only\", r)\n\t\t}\n\t\t// Check if the location is already read-only.\n\t\tvar fs unix.Statfs_t\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q is already read-only\", target)\n\t\t}\n\t\tif fs.Flags&unix.ST_RDONLY != 0 {\n\t\t\tcontinue\n\t\t}\n\t\t// Mount the location over itself, so that we can remount it as read-only.\n\t\troFlags := uintptr(unix.MS_NODEV | unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_RDONLY)\n\t\tif err := unix.Mount(target, target, \"\", roFlags|unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting %q onto itself in preparation for making it read-only\", target)\n\t\t}\n\t\t// Remount the location read-only.\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was bound read-only\", target)\n\t\t}\n\t\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\t\tif err := unix.Mount(target, target, \"\", roFlags|unix.MS_BIND|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error remounting %q in mount namespace read-only\", target)\n\t\t\t}\n\t\t}\n\t\t// Check again.\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was remounted read-only\", target)\n\t\t}\n\t\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error verifying that %q in mount namespace was remounted read-only\", target)\n\t\t}\n\t}\n\n\t// Create an empty directory for to use for masking directories.\n\troEmptyDir := filepath.Join(bundlePath, \"empty\")\n\tif len(spec.Linux.MaskedPaths) > 0 {\n\t\tif err := os.Mkdir(roEmptyDir, 0700); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error creating empty directory %q\", roEmptyDir)\n\t\t}\n\t}\n\n\t// Set up any masked paths that we need to.  If we're running inside of\n\t// a container, some of these locations will already be read-only tmpfs\n\t// filesystems or bind mounted to os.DevNull.  If we're not running\n\t// inside of a container, and nobody else has done that, we'll do it.\n\tfor _, masked := range spec.Linux.MaskedPaths {\n\t\tt := filepath.Join(spec.Root.Path, masked)\n\t\ttarget, err := filepath.EvalSymlinks(t)\n\t\tif err != nil {\n\t\t\ttarget = t\n\t\t}\n\t\t// Get some info about the target.\n\t\ttargetinfo, err := os.Stat(target)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining %q for masking in mount namespace\", target)\n\t\t}\n\t\tif targetinfo.IsDir() {\n\t\t\t// The target's a directory.  Check if it's a read-only filesystem.\n\t\t\tvar statfs unix.Statfs_t\n\t\t\tif err = unix.Statfs(target, &statfs); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q is a mountpoint\", target)\n\t\t\t}\n\t\t\tisReadOnly := statfs.Flags&unix.MS_RDONLY != 0\n\t\t\t// Check if any of the IDs we're mapping could read it.\n\t\t\tvar stat unix.Stat_t\n\t\t\tif err = unix.Stat(target, &stat); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking permissions on directory %q\", target)\n\t\t\t}\n\t\t\tisAccessible := false\n\t\t\tif stat.Mode&unix.S_IROTH|unix.S_IXOTH != 0 {\n\t\t\t\tisAccessible = true\n\t\t\t}\n\t\t\tif !isAccessible && stat.Mode&unix.S_IROTH|unix.S_IXOTH != 0 {\n\t\t\t\tif len(spec.Linux.GIDMappings) > 0 {\n\t\t\t\t\tfor _, mapping := range spec.Linux.GIDMappings {\n\t\t\t\t\t\tif stat.Gid >= mapping.ContainerID && stat.Gid < mapping.ContainerID+mapping.Size {\n\t\t\t\t\t\t\tisAccessible = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !isAccessible && stat.Mode&unix.S_IRUSR|unix.S_IXUSR != 0 {\n\t\t\t\tif len(spec.Linux.UIDMappings) > 0 {\n\t\t\t\t\tfor _, mapping := range spec.Linux.UIDMappings {\n\t\t\t\t\t\tif stat.Uid >= mapping.ContainerID && stat.Uid < mapping.ContainerID+mapping.Size {\n\t\t\t\t\t\t\tisAccessible = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if it's empty.\n\t\t\thasContent := false\n\t\t\tdirectory, err := os.Open(target)\n\t\t\tif err != nil {\n\t\t\t\tif !os.IsPermission(err) {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error opening directory %q\", target)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames, err := directory.Readdirnames(0)\n\t\t\t\tdirectory.Close()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error reading contents of directory %q\", target)\n\t\t\t\t}\n\t\t\t\thasContent = false\n\t\t\t\tfor _, name := range names {\n\t\t\t\t\tswitch name {\n\t\t\t\t\tcase \".\", \"..\":\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tdefault:\n\t\t\t\t\t\thasContent = true\n\t\t\t\t\t}\n\t\t\t\t\tif hasContent {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The target's a directory, so read-only bind mount an empty directory on it.\n\t\t\troFlags := uintptr(syscall.MS_BIND | syscall.MS_NOSUID | syscall.MS_NODEV | syscall.MS_NOEXEC | syscall.MS_RDONLY)\n\t\t\tif !isReadOnly || (hasContent && isAccessible) {\n\t\t\t\tif err = unix.Mount(roEmptyDir, target, \"bind\", roFlags, \"\"); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error masking directory %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was mounted read-only in mount namespace\", target)\n\t\t\t\t}\n\t\t\t\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\t\t\t\tif err = unix.Mount(target, target, \"\", roFlags|syscall.MS_REMOUNT, \"\"); err != nil {\n\t\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error making sure directory %q in mount namespace is read only\", target)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If the target's is not a directory or os.DevNull, bind mount os.DevNull over it.\n\t\t\tif !isDevNull(targetinfo) {\n\t\t\t\tif err = unix.Mount(os.DevNull, target, \"\", uintptr(syscall.MS_BIND|syscall.MS_RDONLY|syscall.MS_PRIVATE), \"\"); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error masking non-directory %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn undoBinds, nil\n}\n", "//go:build linux\n// +build linux\n\npackage buildah\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/bind\"\n\t\"github.com/containers/buildah/chroot\"\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal\"\n\tinternalParse \"github.com/containers/buildah/internal/parse\"\n\tinternalUtil \"github.com/containers/buildah/internal/util\"\n\t\"github.com/containers/buildah/pkg/overlay\"\n\t\"github.com/containers/buildah/pkg/parse\"\n\t\"github.com/containers/buildah/pkg/sshagent\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/common/libnetwork/network\"\n\tnettypes \"github.com/containers/common/libnetwork/types\"\n\t\"github.com/containers/common/pkg/capabilities\"\n\t\"github.com/containers/common/pkg/cgroups\"\n\t\"github.com/containers/common/pkg/chown\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/common/pkg/subscriptions\"\n\timagetypes \"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\t\"github.com/containers/storage/pkg/reexec\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\t\"github.com/containers/storage/pkg/unshare\"\n\tstoragetypes \"github.com/containers/storage/types\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/docker/libnetwork/resolvconf\"\n\t\"github.com/docker/libnetwork/types\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\tspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\t\"golang.org/x/term\"\n)\n\n// ContainerDevices is an alias for a slice of github.com/opencontainers/runc/libcontainer/configs.Device structures.\ntype ContainerDevices define.ContainerDevices\n\nfunc setChildProcess() error {\n\tif err := unix.Prctl(unix.PR_SET_CHILD_SUBREAPER, uintptr(1), 0, 0, 0); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"prctl(PR_SET_CHILD_SUBREAPER, 1): %v\\n\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Run runs the specified command in the container's root filesystem.\nfunc (b *Builder) Run(command []string, options RunOptions) error {\n\tp, err := ioutil.TempDir(\"\", define.Package)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// On some hosts like AH, /tmp is a symlink and we need an\n\t// absolute path.\n\tpath, err := filepath.EvalSymlinks(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogrus.Debugf(\"using %q to hold bundle data\", path)\n\tdefer func() {\n\t\tif err2 := os.RemoveAll(path); err2 != nil {\n\t\t\toptions.Logger.Error(err2)\n\t\t}\n\t}()\n\n\tgp, err := generate.New(\"linux\")\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error generating new 'linux' runtime spec\")\n\t}\n\tg := &gp\n\n\tisolation := options.Isolation\n\tif isolation == define.IsolationDefault {\n\t\tisolation = b.Isolation\n\t\tif isolation == define.IsolationDefault {\n\t\t\tisolation = define.IsolationOCI\n\t\t}\n\t}\n\tif err := checkAndOverrideIsolationOptions(isolation, &options); err != nil {\n\t\treturn err\n\t}\n\n\t// hardwire the environment to match docker build to avoid subtle and hard-to-debug differences due to containers.conf\n\tb.configureEnvironment(g, options, []string{\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"})\n\n\tif b.CommonBuildOpts == nil {\n\t\treturn errors.Errorf(\"Invalid format on container you must recreate the container\")\n\t}\n\n\tif err := addCommonOptsToSpec(b.CommonBuildOpts, g); err != nil {\n\t\treturn err\n\t}\n\n\tif options.WorkingDir != \"\" {\n\t\tg.SetProcessCwd(options.WorkingDir)\n\t} else if b.WorkDir() != \"\" {\n\t\tg.SetProcessCwd(b.WorkDir())\n\t}\n\tsetupSelinux(g, b.ProcessLabel, b.MountLabel)\n\tmountPoint, err := b.Mount(b.MountLabel)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error mounting container %q\", b.ContainerID)\n\t}\n\tdefer func() {\n\t\tif err := b.Unmount(); err != nil {\n\t\t\toptions.Logger.Errorf(\"error unmounting container: %v\", err)\n\t\t}\n\t}()\n\tg.SetRootPath(mountPoint)\n\tif len(command) > 0 {\n\t\tcommand = runLookupPath(g, command)\n\t\tg.SetProcessArgs(command)\n\t} else {\n\t\tg.SetProcessArgs(nil)\n\t}\n\n\tfor _, d := range b.Devices {\n\t\tsDev := spec.LinuxDevice{\n\t\t\tType:     string(d.Type),\n\t\t\tPath:     d.Path,\n\t\t\tMajor:    d.Major,\n\t\t\tMinor:    d.Minor,\n\t\t\tFileMode: &d.FileMode,\n\t\t\tUID:      &d.Uid,\n\t\t\tGID:      &d.Gid,\n\t\t}\n\t\tg.AddDevice(sDev)\n\t\tg.AddLinuxResourcesDevice(true, string(d.Type), &d.Major, &d.Minor, string(d.Permissions))\n\t}\n\n\tsetupMaskedPaths(g)\n\tsetupReadOnlyPaths(g)\n\n\tsetupTerminal(g, options.Terminal, options.TerminalSize)\n\n\tconfigureNetwork, configureNetworks, err := b.configureNamespaces(g, &options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// rootless and networks are not supported\n\tif len(configureNetworks) > 0 && isolation == IsolationOCIRootless {\n\t\treturn errors.New(\"cannot use networks as rootless\")\n\t}\n\n\thomeDir, err := b.configureUIDGID(g, mountPoint, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tg.SetProcessApparmorProfile(b.CommonBuildOpts.ApparmorProfile)\n\n\t// Now grab the spec from the generator.  Set the generator to nil so that future contributors\n\t// will quickly be able to tell that they're supposed to be modifying the spec directly from here.\n\tspec := g.Config\n\tg = nil\n\n\t// Set the seccomp configuration using the specified profile name.  Some syscalls are\n\t// allowed if certain capabilities are to be granted (example: CAP_SYS_CHROOT and chroot),\n\t// so we sorted out the capabilities lists first.\n\tif err = setupSeccomp(spec, b.CommonBuildOpts.SeccompProfilePath); err != nil {\n\t\treturn err\n\t}\n\n\t// Figure out who owns files that will appear to be owned by UID/GID 0 in the container.\n\trootUID, rootGID, err := util.GetHostRootIDs(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\trootIDPair := &idtools.IDPair{UID: int(rootUID), GID: int(rootGID)}\n\n\tmode := os.FileMode(0755)\n\tcoptions := copier.MkdirOptions{\n\t\tChownNew: rootIDPair,\n\t\tChmodNew: &mode,\n\t}\n\tif err := copier.Mkdir(mountPoint, filepath.Join(mountPoint, spec.Process.Cwd), coptions); err != nil {\n\t\treturn err\n\t}\n\n\tbindFiles := make(map[string]string)\n\tnamespaceOptions := append(b.NamespaceOptions, options.NamespaceOptions...)\n\tvolumes := b.Volumes()\n\n\tif !contains(volumes, \"/etc/hosts\") {\n\t\thostFile, err := b.generateHosts(path, spec.Hostname, b.CommonBuildOpts.AddHost, rootIDPair)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Only bind /etc/hosts if there's a network\n\t\tif options.ConfigureNetwork != define.NetworkDisabled {\n\t\t\tbindFiles[\"/etc/hosts\"] = hostFile\n\t\t}\n\t}\n\n\tif !(contains(volumes, \"/etc/resolv.conf\") || (len(b.CommonBuildOpts.DNSServers) == 1 && strings.ToLower(b.CommonBuildOpts.DNSServers[0]) == \"none\")) {\n\t\tresolvFile, err := b.addResolvConf(path, rootIDPair, b.CommonBuildOpts.DNSServers, b.CommonBuildOpts.DNSSearch, b.CommonBuildOpts.DNSOptions, namespaceOptions)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Only bind /etc/resolv.conf if there's a network\n\t\tif options.ConfigureNetwork != define.NetworkDisabled {\n\t\t\tbindFiles[\"/etc/resolv.conf\"] = resolvFile\n\t\t}\n\t}\n\t// Empty file, so no need to recreate if it exists\n\tif _, ok := bindFiles[\"/run/.containerenv\"]; !ok {\n\t\tcontainerenvPath := filepath.Join(path, \"/run/.containerenv\")\n\t\tif err = os.MkdirAll(filepath.Dir(containerenvPath), 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trootless := 0\n\t\tif unshare.IsRootless() {\n\t\t\trootless = 1\n\t\t}\n\t\t// Populate the .containerenv with container information\n\t\tcontainerenv := fmt.Sprintf(`\\\nengine=\"buildah-%s\"\nname=%q\nid=%q\nimage=%q\nimageid=%q\nrootless=%d\n`, define.Version, b.Container, b.ContainerID, b.FromImage, b.FromImageID, rootless)\n\n\t\tif err = ioutils.AtomicWriteFile(containerenvPath, []byte(containerenv), 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := label.Relabel(containerenvPath, b.MountLabel, false); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tbindFiles[\"/run/.containerenv\"] = containerenvPath\n\t}\n\trunArtifacts, err := b.setupMounts(options.SystemContext, mountPoint, spec, path, options.Mounts, bindFiles, volumes, b.CommonBuildOpts.Volumes, b.CommonBuildOpts.ShmSize, namespaceOptions, options.Secrets, options.SSHSources, options.RunMounts, options.ContextDir, options.StageMountPoints)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error resolving mountpoints for container %q\", b.ContainerID)\n\t}\n\tif runArtifacts.SSHAuthSock != \"\" {\n\t\tsshenv := \"SSH_AUTH_SOCK=\" + runArtifacts.SSHAuthSock\n\t\tspec.Process.Env = append(spec.Process.Env, sshenv)\n\t}\n\n\t// following run was called from `buildah run`\n\t// and some images were mounted for this run\n\t// add them to cleanup artifacts\n\tif len(options.ExternalImageMounts) > 0 {\n\t\trunArtifacts.MountedImages = append(runArtifacts.MountedImages, options.ExternalImageMounts...)\n\t}\n\n\tdefer func() {\n\t\tif err := b.cleanupRunMounts(options.SystemContext, mountPoint, runArtifacts); err != nil {\n\t\t\toptions.Logger.Errorf(\"unable to cleanup run mounts %v\", err)\n\t\t}\n\t}()\n\n\tdefer b.cleanupTempVolumes()\n\n\tswitch isolation {\n\tcase define.IsolationOCI:\n\t\tvar moreCreateArgs []string\n\t\tif options.NoPivot {\n\t\t\tmoreCreateArgs = []string{\"--no-pivot\"}\n\t\t} else {\n\t\t\tmoreCreateArgs = nil\n\t\t}\n\t\terr = b.runUsingRuntimeSubproc(isolation, options, configureNetwork, configureNetworks, moreCreateArgs, spec, mountPoint, path, define.Package+\"-\"+filepath.Base(path))\n\tcase IsolationChroot:\n\t\terr = chroot.RunUsingChroot(spec, path, homeDir, options.Stdin, options.Stdout, options.Stderr)\n\tcase IsolationOCIRootless:\n\t\tmoreCreateArgs := []string{\"--no-new-keyring\"}\n\t\tif options.NoPivot {\n\t\t\tmoreCreateArgs = append(moreCreateArgs, \"--no-pivot\")\n\t\t}\n\t\tif err := setupRootlessSpecChanges(spec, path, b.CommonBuildOpts.ShmSize); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = b.runUsingRuntimeSubproc(isolation, options, configureNetwork, configureNetworks, moreCreateArgs, spec, mountPoint, path, define.Package+\"-\"+filepath.Base(path))\n\tdefault:\n\t\terr = errors.Errorf(\"don't know how to run this command\")\n\t}\n\treturn err\n}\n\nfunc addCommonOptsToSpec(commonOpts *define.CommonBuildOptions, g *generate.Generator) error {\n\t// Resources - CPU\n\tif commonOpts.CPUPeriod != 0 {\n\t\tg.SetLinuxResourcesCPUPeriod(commonOpts.CPUPeriod)\n\t}\n\tif commonOpts.CPUQuota != 0 {\n\t\tg.SetLinuxResourcesCPUQuota(commonOpts.CPUQuota)\n\t}\n\tif commonOpts.CPUShares != 0 {\n\t\tg.SetLinuxResourcesCPUShares(commonOpts.CPUShares)\n\t}\n\tif commonOpts.CPUSetCPUs != \"\" {\n\t\tg.SetLinuxResourcesCPUCpus(commonOpts.CPUSetCPUs)\n\t}\n\tif commonOpts.CPUSetMems != \"\" {\n\t\tg.SetLinuxResourcesCPUMems(commonOpts.CPUSetMems)\n\t}\n\n\t// Resources - Memory\n\tif commonOpts.Memory != 0 {\n\t\tg.SetLinuxResourcesMemoryLimit(commonOpts.Memory)\n\t}\n\tif commonOpts.MemorySwap != 0 {\n\t\tg.SetLinuxResourcesMemorySwap(commonOpts.MemorySwap)\n\t}\n\n\t// cgroup membership\n\tif commonOpts.CgroupParent != \"\" {\n\t\tg.SetLinuxCgroupsPath(commonOpts.CgroupParent)\n\t}\n\n\tdefaultContainerConfig, err := config.Default()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to get container config\")\n\t}\n\t// Other process resource limits\n\tif err := addRlimits(commonOpts.Ulimit, g, defaultContainerConfig.Containers.DefaultUlimits); err != nil {\n\t\treturn err\n\t}\n\n\tlogrus.Debugf(\"Resources: %#v\", commonOpts)\n\treturn nil\n}\n\nfunc runSetupBuiltinVolumes(mountLabel, mountPoint, containerDir string, builtinVolumes []string, rootUID, rootGID int) ([]specs.Mount, error) {\n\tvar mounts []specs.Mount\n\thostOwner := idtools.IDPair{UID: rootUID, GID: rootGID}\n\t// Add temporary copies of the contents of volume locations at the\n\t// volume locations, unless we already have something there.\n\tfor _, volume := range builtinVolumes {\n\t\tvolumePath := filepath.Join(containerDir, \"buildah-volumes\", digest.Canonical.FromString(volume).Hex())\n\t\tinitializeVolume := false\n\t\t// If we need to, create the directory that we'll use to hold\n\t\t// the volume contents.  If we do need to create it, then we'll\n\t\t// need to populate it, too, so make a note of that.\n\t\tif _, err := os.Stat(volumePath); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogrus.Debugf(\"setting up built-in volume path at %q for %q\", volumePath, volume)\n\t\t\tif err = os.MkdirAll(volumePath, 0755); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err = label.Relabel(volumePath, mountLabel, false); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tinitializeVolume = true\n\t\t}\n\t\t// Make sure the volume exists in the rootfs and read its attributes.\n\t\tcreateDirPerms := os.FileMode(0755)\n\t\terr := copier.Mkdir(mountPoint, filepath.Join(mountPoint, volume), copier.MkdirOptions{\n\t\t\tChownNew: &hostOwner,\n\t\t\tChmodNew: &createDirPerms,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"ensuring volume path %q\", filepath.Join(mountPoint, volume))\n\t\t}\n\t\tsrcPath, err := copier.Eval(mountPoint, filepath.Join(mountPoint, volume), copier.EvalOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"evaluating path %q\", srcPath)\n\t\t}\n\t\tstat, err := os.Stat(srcPath)\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\t// If we need to populate the mounted volume's contents with\n\t\t// content from the rootfs, set it up now.\n\t\tif initializeVolume {\n\t\t\tif err = os.Chmod(volumePath, stat.Mode().Perm()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err = os.Chown(volumePath, int(stat.Sys().(*syscall.Stat_t).Uid), int(stat.Sys().(*syscall.Stat_t).Gid)); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogrus.Debugf(\"populating directory %q for volume %q using contents of %q\", volumePath, volume, srcPath)\n\t\t\tif err = extractWithTar(mountPoint, srcPath, volumePath); err != nil && !os.IsNotExist(errors.Cause(err)) {\n\t\t\t\treturn nil, errors.Wrapf(err, \"error populating directory %q for volume %q using contents of %q\", volumePath, volume, srcPath)\n\t\t\t}\n\t\t}\n\t\t// Add the bind mount.\n\t\tmounts = append(mounts, specs.Mount{\n\t\t\tSource:      volumePath,\n\t\t\tDestination: volume,\n\t\t\tType:        \"bind\",\n\t\t\tOptions:     []string{\"bind\"},\n\t\t})\n\t}\n\treturn mounts, nil\n}\n\nfunc (b *Builder) setupMounts(context *imagetypes.SystemContext, mountPoint string, spec *specs.Spec, bundlePath string, optionMounts []specs.Mount, bindFiles map[string]string, builtinVolumes, volumeMounts []string, shmSize string, namespaceOptions define.NamespaceOptions, secrets map[string]define.Secret, sshSources map[string]*sshagent.Source, runFileMounts []string, contextDir string, stageMountPoints map[string]internal.StageMountDetails) (*runMountArtifacts, error) {\n\t// Start building a new list of mounts.\n\tvar mounts []specs.Mount\n\thaveMount := func(destination string) bool {\n\t\tfor _, mount := range mounts {\n\t\t\tif mount.Destination == destination {\n\t\t\t\t// Already have something to mount there.\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tipc := namespaceOptions.Find(string(specs.IPCNamespace))\n\thostIPC := ipc == nil || ipc.Host\n\tnet := namespaceOptions.Find(string(specs.NetworkNamespace))\n\thostNetwork := net == nil || net.Host\n\tuser := namespaceOptions.Find(string(specs.UserNamespace))\n\thostUser := (user == nil || user.Host) && !unshare.IsRootless()\n\n\t// Copy mounts from the generated list.\n\tmountCgroups := true\n\tspecMounts := []specs.Mount{}\n\tfor _, specMount := range spec.Mounts {\n\t\t// Override some of the mounts from the generated list if we're doing different things with namespaces.\n\t\tif specMount.Destination == \"/dev/shm\" {\n\t\t\tspecMount.Options = []string{\"nosuid\", \"noexec\", \"nodev\", \"mode=1777\"}\n\t\t\tif shmSize != \"\" {\n\t\t\t\tspecMount.Options = append(specMount.Options, \"size=\"+shmSize)\n\t\t\t}\n\t\t\tif hostIPC && !hostUser {\n\t\t\t\tif _, err := os.Stat(\"/dev/shm\"); err != nil && os.IsNotExist(err) {\n\t\t\t\t\tlogrus.Debugf(\"/dev/shm is not present, not binding into container\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tspecMount = specs.Mount{\n\t\t\t\t\tSource:      \"/dev/shm\",\n\t\t\t\t\tType:        \"bind\",\n\t\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif specMount.Destination == \"/dev/mqueue\" {\n\t\t\tif hostIPC && !hostUser {\n\t\t\t\tif _, err := os.Stat(\"/dev/mqueue\"); err != nil && os.IsNotExist(err) {\n\t\t\t\t\tlogrus.Debugf(\"/dev/mqueue is not present, not binding into container\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tspecMount = specs.Mount{\n\t\t\t\t\tSource:      \"/dev/mqueue\",\n\t\t\t\t\tType:        \"bind\",\n\t\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif specMount.Destination == \"/sys\" {\n\t\t\tif hostNetwork && !hostUser {\n\t\t\t\tmountCgroups = false\n\t\t\t\tif _, err := os.Stat(\"/sys\"); err != nil && os.IsNotExist(err) {\n\t\t\t\t\tlogrus.Debugf(\"/sys is not present, not binding into container\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tspecMount = specs.Mount{\n\t\t\t\t\tSource:      \"/sys\",\n\t\t\t\t\tType:        \"bind\",\n\t\t\t\t\tDestination: \"/sys\",\n\t\t\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspecMounts = append(specMounts, specMount)\n\t}\n\n\t// Add a mount for the cgroups filesystem, unless we're already\n\t// recursively bind mounting all of /sys, in which case we shouldn't\n\t// bother with it.\n\tsysfsMount := []specs.Mount{}\n\tif mountCgroups {\n\t\tsysfsMount = []specs.Mount{{\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tType:        \"cgroup\",\n\t\t\tSource:      \"cgroup\",\n\t\t\tOptions:     []string{bind.NoBindOption, \"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"ro\"},\n\t\t}}\n\t}\n\n\t// Get the list of files we need to bind into the container.\n\tbindFileMounts := runSetupBoundFiles(bundlePath, bindFiles)\n\n\t// After this point we need to know the per-container persistent storage directory.\n\tcdir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error determining work directory for container %q\", b.ContainerID)\n\t}\n\n\t// Figure out which UID and GID to tell the subscriptions package to use\n\t// for files that it creates.\n\trootUID, rootGID, err := util.GetHostRootIDs(spec)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get host UID and GID of the container process.\n\tprocessUID, processGID, err := util.GetHostIDs(spec.Linux.UIDMappings, spec.Linux.GIDMappings, spec.Process.User.UID, spec.Process.User.GID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the list of subscriptions mounts.\n\tsubscriptionMounts := subscriptions.MountsWithUIDGID(b.MountLabel, cdir, b.DefaultMountsFilePath, mountPoint, int(rootUID), int(rootGID), unshare.IsRootless(), false)\n\n\t// Get the list of mounts that are just for this Run() call.\n\t// TODO: acui: de-spaghettify run mounts\n\trunMounts, mountArtifacts, err := b.runSetupRunMounts(context, runFileMounts, secrets, stageMountPoints, sshSources, cdir, contextDir, spec.Linux.UIDMappings, spec.Linux.GIDMappings, int(rootUID), int(rootGID), int(processUID), int(processGID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Add temporary copies of the contents of volume locations at the\n\t// volume locations, unless we already have something there.\n\tbuiltins, err := runSetupBuiltinVolumes(b.MountLabel, mountPoint, cdir, builtinVolumes, int(rootUID), int(rootGID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the list of explicitly-specified volume mounts.\n\tvolumes, err := b.runSetupVolumeMounts(spec.Linux.MountLabel, volumeMounts, optionMounts, int(rootUID), int(rootGID), int(processUID), int(processGID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// prepare list of mount destinations which can be cleaned up safely.\n\t// we can clean bindFiles, subscriptionMounts and specMounts\n\t// everything other than these might have users content\n\tmountArtifacts.RunMountTargets = append(append(append(mountArtifacts.RunMountTargets, cleanableDestinationListFromMounts(bindFileMounts)...), cleanableDestinationListFromMounts(subscriptionMounts)...), cleanableDestinationListFromMounts(specMounts)...)\n\n\tallMounts := util.SortMounts(append(append(append(append(append(append(volumes, builtins...), runMounts...), subscriptionMounts...), bindFileMounts...), specMounts...), sysfsMount...))\n\t// Add them all, in the preferred order, except where they conflict with something that was previously added.\n\tfor _, mount := range allMounts {\n\t\tif haveMount(mount.Destination) {\n\t\t\t// Already mounting something there, no need to bother with this one.\n\t\t\tcontinue\n\t\t}\n\t\t// Add the mount.\n\t\tmounts = append(mounts, mount)\n\t}\n\n\t// Set the list in the spec.\n\tspec.Mounts = mounts\n\treturn mountArtifacts, nil\n}\n\n// Destinations which can be cleaned up after every RUN\nfunc cleanableDestinationListFromMounts(mounts []spec.Mount) []string {\n\tmountDest := []string{}\n\tfor _, mount := range mounts {\n\t\t// Add all destination to mountArtifacts so that they can be cleaned up later\n\t\tif mount.Destination != \"\" {\n\t\t\t// we dont want to remove destinations with  /etc, /dev, /sys, /proc as rootfs already contains these files\n\t\t\t// and unionfs will create a `whiteout` i.e `.wh` files on removal of overlapping files from these directories.\n\t\t\t// everything other than these will be cleanedup\n\t\t\tif !strings.HasPrefix(mount.Destination, \"/etc\") && !strings.HasPrefix(mount.Destination, \"/dev\") && !strings.HasPrefix(mount.Destination, \"/sys\") && !strings.HasPrefix(mount.Destination, \"/proc\") {\n\t\t\t\tmountDest = append(mountDest, mount.Destination)\n\t\t\t}\n\t\t}\n\t}\n\treturn mountDest\n}\n\n// addResolvConf copies files from host and sets them up to bind mount into container\nfunc (b *Builder) addResolvConf(rdir string, chownOpts *idtools.IDPair, dnsServers, dnsSearch, dnsOptions []string, namespaceOptions define.NamespaceOptions) (string, error) {\n\tresolvConf := \"/etc/resolv.conf\"\n\n\tstat, err := os.Stat(resolvConf)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tcontents, err := ioutil.ReadFile(resolvConf)\n\t// resolv.conf doesn't have to exists\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn \"\", err\n\t}\n\n\tnetns := false\n\tns := namespaceOptions.Find(string(spec.NetworkNamespace))\n\tif ns != nil && !ns.Host {\n\t\tnetns = true\n\t}\n\n\tnameservers := resolvconf.GetNameservers(contents, types.IPv4)\n\t// check if systemd-resolved is used, assume it is used when 127.0.0.53 is the only nameserver\n\tif len(nameservers) == 1 && nameservers[0] == \"127.0.0.53\" && netns {\n\t\t// read the actual resolv.conf file for systemd-resolved\n\t\tresolvedContents, err := ioutil.ReadFile(\"/run/systemd/resolve/resolv.conf\")\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn \"\", errors.Wrapf(err, \"detected that systemd-resolved is in use, but could not locate real resolv.conf\")\n\t\t\t}\n\t\t} else {\n\t\t\tcontents = resolvedContents\n\t\t}\n\t}\n\n\t// Ensure that the container's /etc/resolv.conf is compatible with its\n\t// network configuration.\n\tif netns {\n\t\t// FIXME handle IPv6\n\t\tresolve, err := resolvconf.FilterResolvDNS(contents, true)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"error parsing host resolv.conf\")\n\t\t}\n\t\tcontents = resolve.Content\n\t}\n\tsearch := resolvconf.GetSearchDomains(contents)\n\tnameservers = resolvconf.GetNameservers(contents, types.IP)\n\toptions := resolvconf.GetOptions(contents)\n\n\tdefaultContainerConfig, err := config.Default()\n\tif err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"failed to get container config\")\n\t}\n\tdnsSearch = append(defaultContainerConfig.Containers.DNSSearches, dnsSearch...)\n\tif len(dnsSearch) > 0 {\n\t\tsearch = dnsSearch\n\t}\n\n\tif b.Isolation == IsolationOCIRootless {\n\t\tif ns != nil && !ns.Host && ns.Path == \"\" {\n\t\t\t// if we are using slirp4netns, also add the built-in DNS server.\n\t\t\tlogrus.Debugf(\"adding slirp4netns 10.0.2.3 built-in DNS server\")\n\t\t\tnameservers = append([]string{\"10.0.2.3\"}, nameservers...)\n\t\t}\n\t}\n\n\tdnsServers = append(defaultContainerConfig.Containers.DNSServers, dnsServers...)\n\tif len(dnsServers) != 0 {\n\t\tdns, err := getDNSIP(dnsServers)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"error getting dns servers\")\n\t\t}\n\t\tnameservers = []string{}\n\t\tfor _, server := range dns {\n\t\t\tnameservers = append(nameservers, server.String())\n\t\t}\n\t}\n\n\tdnsOptions = append(defaultContainerConfig.Containers.DNSOptions, dnsOptions...)\n\tif len(dnsOptions) != 0 {\n\t\toptions = dnsOptions\n\t}\n\n\tcfile := filepath.Join(rdir, filepath.Base(resolvConf))\n\tif _, err = resolvconf.Build(cfile, nameservers, search, options); err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"error building resolv.conf for container %s\", b.ContainerID)\n\t}\n\n\tuid := int(stat.Sys().(*syscall.Stat_t).Uid)\n\tgid := int(stat.Sys().(*syscall.Stat_t).Gid)\n\tif chownOpts != nil {\n\t\tuid = chownOpts.UID\n\t\tgid = chownOpts.GID\n\t}\n\tif err = os.Chown(cfile, uid, gid); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif err := label.Relabel(cfile, b.MountLabel, false); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn cfile, nil\n}\n\n// generateHosts creates a containers hosts file\nfunc (b *Builder) generateHosts(rdir, hostname string, addHosts []string, chownOpts *idtools.IDPair) (string, error) {\n\thostPath := \"/etc/hosts\"\n\tstat, err := os.Stat(hostPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\thosts := bytes.NewBufferString(\"# Generated by Buildah\\n\")\n\torig, err := ioutil.ReadFile(hostPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\thosts.Write(orig)\n\tfor _, host := range addHosts {\n\t\t// verify the host format\n\t\tvalues := strings.SplitN(host, \":\", 2)\n\t\tif len(values) != 2 {\n\t\t\treturn \"\", errors.Errorf(\"unable to parse host entry %q: incorrect format\", host)\n\t\t}\n\t\tif values[0] == \"\" {\n\t\t\treturn \"\", errors.Errorf(\"hostname in host entry %q is empty\", host)\n\t\t}\n\t\tif values[1] == \"\" {\n\t\t\treturn \"\", errors.Errorf(\"IP address in host entry %q is empty\", host)\n\t\t}\n\t\thosts.Write([]byte(fmt.Sprintf(\"%s\\t%s\\n\", values[1], values[0])))\n\t}\n\thosts.Write([]byte(fmt.Sprintf(\"127.0.0.1   %s %s\\n\", b.Container, hostname)))\n\thosts.Write([]byte(fmt.Sprintf(\"::1         %s %s\\n\", b.Container, hostname)))\n\n\tif ip := util.LocalIP(); ip != \"\" {\n\t\thosts.Write([]byte(fmt.Sprintf(\"%s         %s\\n\", ip, \"host.containers.internal\")))\n\t}\n\n\tcfile := filepath.Join(rdir, filepath.Base(hostPath))\n\tif err = ioutils.AtomicWriteFile(cfile, hosts.Bytes(), stat.Mode().Perm()); err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"error writing /etc/hosts into the container\")\n\t}\n\tuid := int(stat.Sys().(*syscall.Stat_t).Uid)\n\tgid := int(stat.Sys().(*syscall.Stat_t).Gid)\n\tif chownOpts != nil {\n\t\tuid = chownOpts.UID\n\t\tgid = chownOpts.GID\n\t}\n\tif err = os.Chown(cfile, uid, gid); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := label.Relabel(cfile, b.MountLabel, false); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn cfile, nil\n}\n\nfunc setupTerminal(g *generate.Generator, terminalPolicy TerminalPolicy, terminalSize *specs.Box) {\n\tswitch terminalPolicy {\n\tcase DefaultTerminal:\n\t\tonTerminal := term.IsTerminal(unix.Stdin) && term.IsTerminal(unix.Stdout) && term.IsTerminal(unix.Stderr)\n\t\tif onTerminal {\n\t\t\tlogrus.Debugf(\"stdio is a terminal, defaulting to using a terminal\")\n\t\t} else {\n\t\t\tlogrus.Debugf(\"stdio is not a terminal, defaulting to not using a terminal\")\n\t\t}\n\t\tg.SetProcessTerminal(onTerminal)\n\tcase WithTerminal:\n\t\tg.SetProcessTerminal(true)\n\tcase WithoutTerminal:\n\t\tg.SetProcessTerminal(false)\n\t}\n\tif terminalSize != nil {\n\t\tg.SetProcessConsoleSize(terminalSize.Width, terminalSize.Height)\n\t}\n}\n\nfunc runUsingRuntime(options RunOptions, configureNetwork bool, moreCreateArgs []string, spec *specs.Spec, bundlePath, containerName string,\n\tcontainerCreateW io.WriteCloser, containerStartR io.ReadCloser) (wstatus unix.WaitStatus, err error) {\n\tif options.Logger == nil {\n\t\toptions.Logger = logrus.StandardLogger()\n\t}\n\n\t// Lock the caller to a single OS-level thread.\n\truntime.LockOSThread()\n\n\t// Set up bind mounts for things that a namespaced user might not be able to get to directly.\n\tunmountAll, err := bind.SetupIntermediateMountNamespace(spec, bundlePath)\n\tif unmountAll != nil {\n\t\tdefer func() {\n\t\t\tif err := unmountAll(); err != nil {\n\t\t\t\toptions.Logger.Error(err)\n\t\t\t}\n\t\t}()\n\t}\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\n\t// Write the runtime configuration.\n\tspecbytes, err := json.Marshal(spec)\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error encoding configuration %#v as json\", spec)\n\t}\n\tif err = ioutils.AtomicWriteFile(filepath.Join(bundlePath, \"config.json\"), specbytes, 0600); err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error storing runtime configuration\")\n\t}\n\n\tlogrus.Debugf(\"config = %v\", string(specbytes))\n\n\t// Decide which runtime to use.\n\truntime := options.Runtime\n\tif runtime == \"\" {\n\t\truntime = util.Runtime()\n\t}\n\tlocalRuntime := util.FindLocalRuntime(runtime)\n\tif localRuntime != \"\" {\n\t\truntime = localRuntime\n\t}\n\n\t// Default to just passing down our stdio.\n\tgetCreateStdio := func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\treturn os.Stdin, os.Stdout, os.Stderr\n\t}\n\n\t// Figure out how we're doing stdio handling, and create pipes and sockets.\n\tvar stdio sync.WaitGroup\n\tvar consoleListener *net.UnixListener\n\tvar errorFds, closeBeforeReadingErrorFds []int\n\tstdioPipe := make([][]int, 3)\n\tcopyConsole := false\n\tcopyPipes := false\n\tfinishCopy := make([]int, 2)\n\tif err = unix.Pipe(finishCopy); err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error creating pipe for notifying to stop stdio\")\n\t}\n\tfinishedCopy := make(chan struct{})\n\tvar pargs []string\n\tif spec.Process != nil {\n\t\tpargs = spec.Process.Args\n\t\tif spec.Process.Terminal {\n\t\t\tcopyConsole = true\n\t\t\t// Create a listening socket for accepting the container's terminal's PTY master.\n\t\t\tsocketPath := filepath.Join(bundlePath, \"console.sock\")\n\t\t\tconsoleListener, err = net.ListenUnix(\"unix\", &net.UnixAddr{Name: socketPath, Net: \"unix\"})\n\t\t\tif err != nil {\n\t\t\t\treturn 1, errors.Wrapf(err, \"error creating socket %q to receive terminal descriptor\", consoleListener.Addr())\n\t\t\t}\n\t\t\t// Add console socket arguments.\n\t\t\tmoreCreateArgs = append(moreCreateArgs, \"--console-socket\", socketPath)\n\t\t} else {\n\t\t\tcopyPipes = true\n\t\t\t// Figure out who should own the pipes.\n\t\t\tuid, gid, err := util.GetHostRootIDs(spec)\n\t\t\tif err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\t// Create stdio pipes.\n\t\t\tif stdioPipe, err = runMakeStdioPipe(int(uid), int(gid)); err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\tif err = runLabelStdioPipes(stdioPipe, spec.Process.SelinuxLabel, spec.Linux.MountLabel); err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\terrorFds = []int{stdioPipe[unix.Stdout][0], stdioPipe[unix.Stderr][0]}\n\t\t\tcloseBeforeReadingErrorFds = []int{stdioPipe[unix.Stdout][1], stdioPipe[unix.Stderr][1]}\n\t\t\t// Set stdio to our pipes.\n\t\t\tgetCreateStdio = func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\t\t\tstdin := os.NewFile(uintptr(stdioPipe[unix.Stdin][0]), \"/dev/stdin\")\n\t\t\t\tstdout := os.NewFile(uintptr(stdioPipe[unix.Stdout][1]), \"/dev/stdout\")\n\t\t\t\tstderr := os.NewFile(uintptr(stdioPipe[unix.Stderr][1]), \"/dev/stderr\")\n\t\t\t\treturn stdin, stdout, stderr\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif options.Quiet {\n\t\t\t// Discard stdout.\n\t\t\tgetCreateStdio = func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\t\t\treturn os.Stdin, nil, os.Stderr\n\t\t\t}\n\t\t}\n\t}\n\n\truntimeArgs := options.Args[:]\n\tif options.CgroupManager == config.SystemdCgroupsManager {\n\t\truntimeArgs = append(runtimeArgs, \"--systemd-cgroup\")\n\t}\n\n\t// Build the commands that we'll execute.\n\tpidFile := filepath.Join(bundlePath, \"pid\")\n\targs := append(append(append(runtimeArgs, \"create\", \"--bundle\", bundlePath, \"--pid-file\", pidFile), moreCreateArgs...), containerName)\n\tcreate := exec.Command(runtime, args...)\n\tcreate.Dir = bundlePath\n\tstdin, stdout, stderr := getCreateStdio()\n\tcreate.Stdin, create.Stdout, create.Stderr = stdin, stdout, stderr\n\tif create.SysProcAttr == nil {\n\t\tcreate.SysProcAttr = &syscall.SysProcAttr{}\n\t}\n\n\targs = append(options.Args, \"start\", containerName)\n\tstart := exec.Command(runtime, args...)\n\tstart.Dir = bundlePath\n\tstart.Stderr = os.Stderr\n\n\targs = append(options.Args, \"kill\", containerName)\n\tkill := exec.Command(runtime, args...)\n\tkill.Dir = bundlePath\n\tkill.Stderr = os.Stderr\n\n\targs = append(options.Args, \"delete\", containerName)\n\tdel := exec.Command(runtime, args...)\n\tdel.Dir = bundlePath\n\tdel.Stderr = os.Stderr\n\n\t// Actually create the container.\n\tlogrus.Debugf(\"Running %q\", create.Args)\n\terr = create.Run()\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error from %s creating container for %v: %s\", runtime, pargs, runCollectOutput(options.Logger, errorFds, closeBeforeReadingErrorFds))\n\t}\n\tdefer func() {\n\t\terr2 := del.Run()\n\t\tif err2 != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = errors.Wrapf(err2, \"error deleting container\")\n\t\t\t} else {\n\t\t\t\toptions.Logger.Infof(\"error from %s deleting container: %v\", runtime, err2)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Make sure we read the container's exit status when it exits.\n\tpidValue, err := ioutil.ReadFile(pidFile)\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tpid, err := strconv.Atoi(strings.TrimSpace(string(pidValue)))\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error parsing pid %s as a number\", string(pidValue))\n\t}\n\tvar stopped uint32\n\tvar reaping sync.WaitGroup\n\treaping.Add(1)\n\tgo func() {\n\t\tdefer reaping.Done()\n\t\tvar err error\n\t\t_, err = unix.Wait4(pid, &wstatus, 0, nil)\n\t\tif err != nil {\n\t\t\twstatus = 0\n\t\t\toptions.Logger.Errorf(\"error waiting for container child process %d: %v\\n\", pid, err)\n\t\t}\n\t\tatomic.StoreUint32(&stopped, 1)\n\t}()\n\n\tif configureNetwork {\n\t\tif _, err := containerCreateW.Write([]byte{1}); err != nil {\n\t\t\treturn 1, err\n\t\t}\n\t\tcontainerCreateW.Close()\n\t\tlogrus.Debug(\"waiting for parent start message\")\n\t\tb := make([]byte, 1)\n\t\tif _, err := containerStartR.Read(b); err != nil {\n\t\t\treturn 1, errors.Wrap(err, \"did not get container start message from parent\")\n\t\t}\n\t\tcontainerStartR.Close()\n\t}\n\n\tif copyPipes {\n\t\t// We don't need the ends of the pipes that belong to the container.\n\t\tstdin.Close()\n\t\tif stdout != nil {\n\t\t\tstdout.Close()\n\t\t}\n\t\tstderr.Close()\n\t}\n\n\t// Handle stdio for the container in the background.\n\tstdio.Add(1)\n\tgo runCopyStdio(options.Logger, &stdio, copyPipes, stdioPipe, copyConsole, consoleListener, finishCopy, finishedCopy, spec)\n\n\t// Start the container.\n\tlogrus.Debugf(\"Running %q\", start.Args)\n\terr = start.Run()\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error from %s starting container\", runtime)\n\t}\n\tdefer func() {\n\t\tif atomic.LoadUint32(&stopped) == 0 {\n\t\t\tif err2 := kill.Run(); err2 != nil {\n\t\t\t\toptions.Logger.Infof(\"error from %s stopping container: %v\", runtime, err2)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Wait for the container to exit.\n\tfor {\n\t\tnow := time.Now()\n\t\tvar state specs.State\n\t\targs = append(options.Args, \"state\", containerName)\n\t\tstat := exec.Command(runtime, args...)\n\t\tstat.Dir = bundlePath\n\t\tstat.Stderr = os.Stderr\n\t\tstateOutput, err := stat.Output()\n\t\tif err != nil {\n\t\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\t\t// container exited\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn 1, errors.Wrapf(err, \"error reading container state from %s (got output: %q)\", runtime, string(stateOutput))\n\t\t}\n\t\tif err = json.Unmarshal(stateOutput, &state); err != nil {\n\t\t\treturn 1, errors.Wrapf(err, \"error parsing container state %q from %s\", string(stateOutput), runtime)\n\t\t}\n\t\tswitch state.Status {\n\t\tcase \"running\":\n\t\tcase \"stopped\":\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\tdefault:\n\t\t\treturn 1, errors.Errorf(\"container status unexpectedly changed to %q\", state.Status)\n\t\t}\n\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\tbreak\n\t\t}\n\t\tselect {\n\t\tcase <-finishedCopy:\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\tcase <-time.After(time.Until(now.Add(100 * time.Millisecond))):\n\t\t\tcontinue\n\t\t}\n\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the writing end of the stop-handling-stdio notification pipe.\n\tunix.Close(finishCopy[1])\n\t// Wait for the stdio copy goroutine to flush.\n\tstdio.Wait()\n\t// Wait until we finish reading the exit status.\n\treaping.Wait()\n\n\treturn wstatus, nil\n}\n\nfunc runCollectOutput(logger *logrus.Logger, fds, closeBeforeReadingFds []int) string { //nolint:interfacer\n\tfor _, fd := range closeBeforeReadingFds {\n\t\tunix.Close(fd)\n\t}\n\tvar b bytes.Buffer\n\tbuf := make([]byte, 8192)\n\tfor _, fd := range fds {\n\t\tnread, err := unix.Read(fd, buf)\n\t\tif err != nil {\n\t\t\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\t\t\tswitch errno {\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.Errorf(\"error reading from pipe %d: %v\", fd, err)\n\t\t\t\tcase syscall.EINTR, syscall.EAGAIN:\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.Errorf(\"unable to wait for data from pipe %d: %v\", fd, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tfor nread > 0 {\n\t\t\tr := buf[:nread]\n\t\t\tif nwritten, err := b.Write(r); err != nil || nwritten != len(r) {\n\t\t\t\tif nwritten != len(r) {\n\t\t\t\t\tlogger.Errorf(\"error buffering data from pipe %d: %v\", fd, err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tnread, err = unix.Read(fd, buf)\n\t\t\tif err != nil {\n\t\t\t\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\t\t\t\tswitch errno {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlogger.Errorf(\"error reading from pipe %d: %v\", fd, err)\n\t\t\t\t\tcase syscall.EINTR, syscall.EAGAIN:\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.Errorf(\"unable to wait for data from pipe %d: %v\", fd, err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn b.String()\n}\n\nfunc setupRootlessNetwork(pid int) (teardown func(), err error) {\n\tslirp4netns, err := exec.LookPath(\"slirp4netns\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trootlessSlirpSyncR, rootlessSlirpSyncW, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot create slirp4netns sync pipe\")\n\t}\n\tdefer rootlessSlirpSyncR.Close()\n\n\t// Be sure there are no fds inherited to slirp4netns except the sync pipe\n\tfiles, err := ioutil.ReadDir(\"/proc/self/fd\")\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot list open fds\")\n\t}\n\tfor _, f := range files {\n\t\tfd, err := strconv.Atoi(f.Name())\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"cannot parse fd\")\n\t\t}\n\t\tif fd == int(rootlessSlirpSyncW.Fd()) {\n\t\t\tcontinue\n\t\t}\n\t\tunix.CloseOnExec(fd)\n\t}\n\n\tcmd := exec.Command(slirp4netns, \"--mtu\", \"65520\", \"-r\", \"3\", \"-c\", strconv.Itoa(pid), \"tap0\")\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = nil, nil, nil\n\tcmd.ExtraFiles = []*os.File{rootlessSlirpSyncW}\n\n\terr = cmd.Start()\n\trootlessSlirpSyncW.Close()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot start slirp4netns\")\n\t}\n\n\tb := make([]byte, 1)\n\tfor {\n\t\tif err := rootlessSlirpSyncR.SetDeadline(time.Now().Add(1 * time.Second)); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error setting slirp4netns pipe timeout\")\n\t\t}\n\t\tif _, err := rootlessSlirpSyncR.Read(b); err == nil {\n\t\t\tbreak\n\t\t} else {\n\t\t\tif os.IsTimeout(err) {\n\t\t\t\t// Check if the process is still running.\n\t\t\t\tvar status syscall.WaitStatus\n\t\t\t\t_, err := syscall.Wait4(cmd.Process.Pid, &status, syscall.WNOHANG, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, errors.Wrapf(err, \"failed to read slirp4netns process status\")\n\t\t\t\t}\n\t\t\t\tif status.Exited() || status.Signaled() {\n\t\t\t\t\treturn nil, errors.New(\"slirp4netns failed\")\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, errors.Wrapf(err, \"failed to read from slirp4netns sync pipe\")\n\t\t}\n\t}\n\n\treturn func() {\n\t\tcmd.Process.Kill() // nolint:errcheck\n\t\tcmd.Wait()         // nolint:errcheck\n\t}, nil\n}\n\nfunc (b *Builder) runConfigureNetwork(pid int, isolation define.Isolation, options RunOptions, configureNetworks []string, containerName string) (teardown func(), err error) {\n\tif isolation == IsolationOCIRootless {\n\t\tif ns := options.NamespaceOptions.Find(string(specs.NetworkNamespace)); ns != nil && !ns.Host && ns.Path == \"\" {\n\t\t\treturn setupRootlessNetwork(pid)\n\t\t}\n\t}\n\n\tif len(configureNetworks) == 0 {\n\t\tconfigureNetworks = []string{b.NetworkInterface.DefaultNetworkName()}\n\t}\n\n\t// Make sure we can access the container's network namespace,\n\t// even after it exits, to successfully tear down the\n\t// interfaces.  Ensure this by opening a handle to the network\n\t// namespace, and using our copy to both configure and\n\t// deconfigure it.\n\tnetns := fmt.Sprintf(\"/proc/%d/ns/net\", pid)\n\tnetFD, err := unix.Open(netns, unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error opening network namespace\")\n\t}\n\tmynetns := fmt.Sprintf(\"/proc/%d/fd/%d\", unix.Getpid(), netFD)\n\n\tnetworks := make(map[string]nettypes.PerNetworkOptions, len(configureNetworks))\n\tfor i, network := range configureNetworks {\n\t\tnetworks[network] = nettypes.PerNetworkOptions{\n\t\t\tInterfaceName: fmt.Sprintf(\"eth%d\", i),\n\t\t}\n\t}\n\n\topts := nettypes.NetworkOptions{\n\t\tContainerID:   containerName,\n\t\tContainerName: containerName,\n\t\tNetworks:      networks,\n\t}\n\t_, err = b.NetworkInterface.Setup(mynetns, nettypes.SetupOptions{NetworkOptions: opts})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tteardown = func() {\n\t\terr := b.NetworkInterface.Teardown(mynetns, nettypes.TeardownOptions{NetworkOptions: opts})\n\t\tif err != nil {\n\t\t\toptions.Logger.Errorf(\"failed to cleanup network: %v\", err)\n\t\t}\n\t}\n\n\treturn teardown, nil\n}\n\nfunc setNonblock(logger *logrus.Logger, fd int, description string, nonblocking bool) (bool, error) { //nolint:interfacer\n\tmask, err := unix.FcntlInt(uintptr(fd), unix.F_GETFL, 0)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tblocked := mask&unix.O_NONBLOCK == 0\n\n\tif err := unix.SetNonblock(fd, nonblocking); err != nil {\n\t\tif nonblocking {\n\t\t\tlogger.Errorf(\"error setting %s to nonblocking: %v\", description, err)\n\t\t} else {\n\t\t\tlogger.Errorf(\"error setting descriptor %s blocking: %v\", description, err)\n\t\t}\n\t}\n\treturn blocked, err\n}\n\nfunc runCopyStdio(logger *logrus.Logger, stdio *sync.WaitGroup, copyPipes bool, stdioPipe [][]int, copyConsole bool, consoleListener *net.UnixListener, finishCopy []int, finishedCopy chan struct{}, spec *specs.Spec) {\n\tdefer func() {\n\t\tunix.Close(finishCopy[0])\n\t\tif copyPipes {\n\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\tunix.Close(stdioPipe[unix.Stdout][0])\n\t\t\tunix.Close(stdioPipe[unix.Stderr][0])\n\t\t}\n\t\tstdio.Done()\n\t\tfinishedCopy <- struct{}{}\n\t}()\n\t// Map describing where data on an incoming descriptor should go.\n\trelayMap := make(map[int]int)\n\t// Map describing incoming and outgoing descriptors.\n\treadDesc := make(map[int]string)\n\twriteDesc := make(map[int]string)\n\t// Buffers.\n\trelayBuffer := make(map[int]*bytes.Buffer)\n\t// Set up the terminal descriptor or pipes for polling.\n\tif copyConsole {\n\t\t// Accept a connection over our listening socket.\n\t\tfd, err := runAcceptTerminal(logger, consoleListener, spec.Process.ConsoleSize)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"%v\", err)\n\t\t\treturn\n\t\t}\n\t\tterminalFD := fd\n\t\t// Input from our stdin, output from the terminal descriptor.\n\t\trelayMap[unix.Stdin] = terminalFD\n\t\treadDesc[unix.Stdin] = \"stdin\"\n\t\trelayBuffer[terminalFD] = new(bytes.Buffer)\n\t\twriteDesc[terminalFD] = \"container terminal input\"\n\t\trelayMap[terminalFD] = unix.Stdout\n\t\treadDesc[terminalFD] = \"container terminal output\"\n\t\trelayBuffer[unix.Stdout] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stdout] = \"output\"\n\t\t// Set our terminal's mode to raw, to pass handling of special\n\t\t// terminal input to the terminal in the container.\n\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\tif state, err := term.MakeRaw(unix.Stdin); err != nil {\n\t\t\t\tlogger.Warnf(\"error setting terminal state: %v\", err)\n\t\t\t} else {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif err = term.Restore(unix.Stdin, state); err != nil {\n\t\t\t\t\t\tlogger.Errorf(\"unable to restore terminal state: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}\n\tif copyPipes {\n\t\t// Input from our stdin, output from the stdout and stderr pipes.\n\t\trelayMap[unix.Stdin] = stdioPipe[unix.Stdin][1]\n\t\treadDesc[unix.Stdin] = \"stdin\"\n\t\trelayBuffer[stdioPipe[unix.Stdin][1]] = new(bytes.Buffer)\n\t\twriteDesc[stdioPipe[unix.Stdin][1]] = \"container stdin\"\n\t\trelayMap[stdioPipe[unix.Stdout][0]] = unix.Stdout\n\t\treadDesc[stdioPipe[unix.Stdout][0]] = \"container stdout\"\n\t\trelayBuffer[unix.Stdout] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stdout] = \"stdout\"\n\t\trelayMap[stdioPipe[unix.Stderr][0]] = unix.Stderr\n\t\treadDesc[stdioPipe[unix.Stderr][0]] = \"container stderr\"\n\t\trelayBuffer[unix.Stderr] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stderr] = \"stderr\"\n\t}\n\t// Set our reading descriptors to non-blocking.\n\tfor rfd, wfd := range relayMap {\n\t\tblocked, err := setNonblock(logger, rfd, readDesc[rfd], true)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif blocked {\n\t\t\tdefer setNonblock(logger, rfd, readDesc[rfd], false) // nolint:errcheck\n\t\t}\n\t\tsetNonblock(logger, wfd, writeDesc[wfd], false) // nolint:errcheck\n\t}\n\n\tif copyPipes {\n\t\tsetNonblock(logger, stdioPipe[unix.Stdin][1], writeDesc[stdioPipe[unix.Stdin][1]], true) // nolint:errcheck\n\t}\n\n\trunCopyStdioPassData(copyPipes, stdioPipe, finishCopy, relayMap, relayBuffer, readDesc, writeDesc)\n}\n\nfunc canRetry(err error) bool {\n\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\treturn errno == syscall.EINTR || errno == syscall.EAGAIN\n\t}\n\treturn false\n}\n\nfunc runCopyStdioPassData(copyPipes bool, stdioPipe [][]int, finishCopy []int, relayMap map[int]int, relayBuffer map[int]*bytes.Buffer, readDesc map[int]string, writeDesc map[int]string) {\n\tcloseStdin := false\n\n\t// Pass data back and forth.\n\tpollTimeout := -1\n\tfor len(relayMap) > 0 {\n\t\t// Start building the list of descriptors to poll.\n\t\tpollFds := make([]unix.PollFd, 0, len(relayMap)+1)\n\t\t// Poll for a notification that we should stop handling stdio.\n\t\tpollFds = append(pollFds, unix.PollFd{Fd: int32(finishCopy[0]), Events: unix.POLLIN | unix.POLLHUP})\n\t\t// Poll on our reading descriptors.\n\t\tfor rfd := range relayMap {\n\t\t\tpollFds = append(pollFds, unix.PollFd{Fd: int32(rfd), Events: unix.POLLIN | unix.POLLHUP})\n\t\t}\n\t\tbuf := make([]byte, 8192)\n\t\t// Wait for new data from any input descriptor, or a notification that we're done.\n\t\t_, err := unix.Poll(pollFds, pollTimeout)\n\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"error waiting for stdio/terminal data to relay: %v\", err)) {\n\t\t\treturn\n\t\t}\n\t\tremoves := make(map[int]struct{})\n\t\tfor _, pollFd := range pollFds {\n\t\t\t// If this descriptor's just been closed from the other end, mark it for\n\t\t\t// removal from the set that we're checking for.\n\t\t\tif pollFd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t}\n\t\t\t// If the descriptor was closed elsewhere, remove it from our list.\n\t\t\tif pollFd.Revents&unix.POLLNVAL != 0 {\n\t\t\t\tlogrus.Debugf(\"error polling descriptor %s: closed?\", readDesc[int(pollFd.Fd)])\n\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t}\n\t\t\t// If the POLLIN flag isn't set, then there's no data to be read from this descriptor.\n\t\t\tif pollFd.Revents&unix.POLLIN == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Read whatever there is to be read.\n\t\t\treadFD := int(pollFd.Fd)\n\t\t\twriteFD, needToRelay := relayMap[readFD]\n\t\t\tif needToRelay {\n\t\t\t\tn, err := unix.Read(readFD, buf)\n\t\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"unable to read %s data: %v\", readDesc[readFD], err)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// If it's zero-length on our stdin and we're\n\t\t\t\t// using pipes, it's an EOF, so close the stdin\n\t\t\t\t// pipe's writing end.\n\t\t\t\tif n == 0 && !canRetry(err) && int(pollFd.Fd) == unix.Stdin {\n\t\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t\t} else if n > 0 {\n\t\t\t\t\t// Buffer the data in case we get blocked on where they need to go.\n\t\t\t\t\tnwritten, err := relayBuffer[writeFD].Write(buf[:n])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif nwritten != n {\n\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", n, nwritten)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// If this is the last of the data we'll be able to read from this\n\t\t\t\t\t// descriptor, read all that there is to read.\n\t\t\t\t\tfor pollFd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\t\t\tnr, err := unix.Read(readFD, buf)\n\t\t\t\t\t\tutil.LogIfUnexpectedWhileDraining(err, fmt.Sprintf(\"read %s: %v\", readDesc[readFD], err))\n\t\t\t\t\t\tif nr <= 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnwritten, err := relayBuffer[writeFD].Write(buf[:nr])\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif nwritten != nr {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", nr, nwritten)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to drain the output buffers.  Set the default timeout\n\t\t// for the next poll() to 100ms if we still have data to write.\n\t\tpollTimeout = -1\n\t\tfor writeFD := range relayBuffer {\n\t\t\tif relayBuffer[writeFD].Len() > 0 {\n\t\t\t\tn, err := unix.Write(writeFD, relayBuffer[writeFD].Bytes())\n\t\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"unable to write %s data: %v\", writeDesc[writeFD], err)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\trelayBuffer[writeFD].Next(n)\n\t\t\t\t}\n\t\t\t\tif closeStdin && writeFD == stdioPipe[unix.Stdin][1] && stdioPipe[unix.Stdin][1] >= 0 && relayBuffer[stdioPipe[unix.Stdin][1]].Len() == 0 {\n\t\t\t\t\tlogrus.Debugf(\"closing stdin\")\n\t\t\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\t\t\tstdioPipe[unix.Stdin][1] = -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif relayBuffer[writeFD].Len() > 0 {\n\t\t\t\tpollTimeout = 100\n\t\t\t}\n\t\t}\n\t\t// Remove any descriptors which we don't need to poll any more from the poll descriptor list.\n\t\tfor remove := range removes {\n\t\t\tif copyPipes && remove == unix.Stdin {\n\t\t\t\tcloseStdin = true\n\t\t\t\tif relayBuffer[stdioPipe[unix.Stdin][1]].Len() == 0 {\n\t\t\t\t\tlogrus.Debugf(\"closing stdin\")\n\t\t\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\t\t\tstdioPipe[unix.Stdin][1] = -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete(relayMap, remove)\n\t\t}\n\t\t// If the we-can-return pipe had anything for us, we're done.\n\t\tfor _, pollFd := range pollFds {\n\t\t\tif int(pollFd.Fd) == finishCopy[0] && pollFd.Revents != 0 {\n\t\t\t\t// The pipe is closed, indicating that we can stop now.\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc runAcceptTerminal(logger *logrus.Logger, consoleListener *net.UnixListener, terminalSize *specs.Box) (int, error) {\n\tdefer consoleListener.Close()\n\tc, err := consoleListener.AcceptUnix()\n\tif err != nil {\n\t\treturn -1, errors.Wrapf(err, \"error accepting socket descriptor connection\")\n\t}\n\tdefer c.Close()\n\t// Expect a control message over our new connection.\n\tb := make([]byte, 8192)\n\toob := make([]byte, 8192)\n\tn, oobn, _, _, err := c.ReadMsgUnix(b, oob)\n\tif err != nil {\n\t\treturn -1, errors.Wrapf(err, \"error reading socket descriptor\")\n\t}\n\tif n > 0 {\n\t\tlogrus.Debugf(\"socket descriptor is for %q\", string(b[:n]))\n\t}\n\tif oobn > len(oob) {\n\t\treturn -1, errors.Errorf(\"too much out-of-bounds data (%d bytes)\", oobn)\n\t}\n\t// Parse the control message.\n\tscm, err := unix.ParseSocketControlMessage(oob[:oobn])\n\tif err != nil {\n\t\treturn -1, errors.Wrapf(err, \"error parsing out-of-bound data as a socket control message\")\n\t}\n\tlogrus.Debugf(\"control messages: %v\", scm)\n\t// Expect to get a descriptor.\n\tterminalFD := -1\n\tfor i := range scm {\n\t\tfds, err := unix.ParseUnixRights(&scm[i])\n\t\tif err != nil {\n\t\t\treturn -1, errors.Wrapf(err, \"error parsing unix rights control message: %v\", &scm[i])\n\t\t}\n\t\tlogrus.Debugf(\"fds: %v\", fds)\n\t\tif len(fds) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tterminalFD = fds[0]\n\t\tbreak\n\t}\n\tif terminalFD == -1 {\n\t\treturn -1, errors.Errorf(\"unable to read terminal descriptor\")\n\t}\n\t// Set the pseudoterminal's size to the configured size, or our own.\n\twinsize := &unix.Winsize{}\n\tif terminalSize != nil {\n\t\t// Use configured sizes.\n\t\twinsize.Row = uint16(terminalSize.Height)\n\t\twinsize.Col = uint16(terminalSize.Width)\n\t} else {\n\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\t// Use the size of our terminal.\n\t\t\tif winsize, err = unix.IoctlGetWinsize(unix.Stdin, unix.TIOCGWINSZ); err != nil {\n\t\t\t\tlogger.Warnf(\"error reading size of controlling terminal: %v\", err)\n\t\t\t\twinsize.Row = 0\n\t\t\t\twinsize.Col = 0\n\t\t\t}\n\t\t}\n\t}\n\tif winsize.Row != 0 && winsize.Col != 0 {\n\t\tif err = unix.IoctlSetWinsize(terminalFD, unix.TIOCSWINSZ, winsize); err != nil {\n\t\t\tlogger.Warnf(\"error setting size of container pseudoterminal: %v\", err)\n\t\t}\n\t\t// FIXME - if we're connected to a terminal, we should\n\t\t// be passing the updated terminal size down when we\n\t\t// receive a SIGWINCH.\n\t}\n\treturn terminalFD, nil\n}\n\n// Create pipes to use for relaying stdio.\nfunc runMakeStdioPipe(uid, gid int) ([][]int, error) {\n\tstdioPipe := make([][]int, 3)\n\tfor i := range stdioPipe {\n\t\tstdioPipe[i] = make([]int, 2)\n\t\tif err := unix.Pipe(stdioPipe[i]); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error creating pipe for container FD %d\", i)\n\t\t}\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stdin][0], uid, gid); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error setting owner of stdin pipe descriptor\")\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stdout][1], uid, gid); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error setting owner of stdout pipe descriptor\")\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stderr][1], uid, gid); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error setting owner of stderr pipe descriptor\")\n\t}\n\treturn stdioPipe, nil\n}\n\nfunc runUsingRuntimeMain() {\n\tvar options runUsingRuntimeSubprocOptions\n\t// Set logging.\n\tif level := os.Getenv(\"LOGLEVEL\"); level != \"\" {\n\t\tif ll, err := strconv.Atoi(level); err == nil {\n\t\t\tlogrus.SetLevel(logrus.Level(ll))\n\t\t}\n\t}\n\t// Unpack our configuration.\n\tconfPipe := os.NewFile(3, \"confpipe\")\n\tif confPipe == nil {\n\t\tfmt.Fprintf(os.Stderr, \"error reading options pipe\\n\")\n\t\tos.Exit(1)\n\t}\n\tdefer confPipe.Close()\n\tif err := json.NewDecoder(confPipe).Decode(&options); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error decoding options: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\t// Set ourselves up to read the container's exit status.  We're doing this in a child process\n\t// so that we won't mess with the setting in a caller of the library.\n\tif err := setChildProcess(); err != nil {\n\t\tos.Exit(1)\n\t}\n\tospec := options.Spec\n\tif ospec == nil {\n\t\tfmt.Fprintf(os.Stderr, \"options spec not specified\\n\")\n\t\tos.Exit(1)\n\t}\n\n\t// open the pipes used to communicate with the parent process\n\tvar containerCreateW *os.File\n\tvar containerStartR *os.File\n\tif options.ConfigureNetwork {\n\t\tcontainerCreateW = os.NewFile(4, \"containercreatepipe\")\n\t\tif containerCreateW == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"could not open fd 4\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcontainerStartR = os.NewFile(5, \"containerstartpipe\")\n\t\tif containerStartR == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"could not open fd 5\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\t// Run the container, start to finish.\n\tstatus, err := runUsingRuntime(options.Options, options.ConfigureNetwork, options.MoreCreateArgs, ospec, options.BundlePath, options.ContainerName, containerCreateW, containerStartR)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error running container: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\t// Pass the container's exit status back to the caller by exiting with the same status.\n\tif status.Exited() {\n\t\tos.Exit(status.ExitStatus())\n\t} else if status.Signaled() {\n\t\tfmt.Fprintf(os.Stderr, \"container exited on %s\\n\", status.Signal())\n\t\tos.Exit(1)\n\t}\n\tos.Exit(1)\n}\n\nfunc setupNamespaces(logger *logrus.Logger, g *generate.Generator, namespaceOptions define.NamespaceOptions, idmapOptions define.IDMappingOptions, policy define.NetworkConfigurationPolicy) (configureNetwork bool, configureNetworks []string, configureUTS bool, err error) {\n\t// Set namespace options in the container configuration.\n\tconfigureUserns := false\n\tspecifiedNetwork := false\n\tfor _, namespaceOption := range namespaceOptions {\n\t\tswitch namespaceOption.Name {\n\t\tcase string(specs.UserNamespace):\n\t\t\tconfigureUserns = false\n\t\t\tif !namespaceOption.Host && namespaceOption.Path == \"\" {\n\t\t\t\tconfigureUserns = true\n\t\t\t}\n\t\tcase string(specs.NetworkNamespace):\n\t\t\tspecifiedNetwork = true\n\t\t\tconfigureNetwork = false\n\t\t\tif !namespaceOption.Host && (namespaceOption.Path == \"\" || !filepath.IsAbs(namespaceOption.Path)) {\n\t\t\t\tif namespaceOption.Path != \"\" && !filepath.IsAbs(namespaceOption.Path) {\n\t\t\t\t\tconfigureNetworks = strings.Split(namespaceOption.Path, \",\")\n\t\t\t\t\tnamespaceOption.Path = \"\"\n\t\t\t\t}\n\t\t\t\tconfigureNetwork = (policy != define.NetworkDisabled)\n\t\t\t}\n\t\tcase string(specs.UTSNamespace):\n\t\t\tconfigureUTS = false\n\t\t\tif !namespaceOption.Host && namespaceOption.Path == \"\" {\n\t\t\t\tconfigureUTS = true\n\t\t\t}\n\t\t}\n\t\tif namespaceOption.Host {\n\t\t\tif err := g.RemoveLinuxNamespace(namespaceOption.Name); err != nil {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error removing %q namespace for run\", namespaceOption.Name)\n\t\t\t}\n\t\t} else if err := g.AddOrReplaceLinuxNamespace(namespaceOption.Name, namespaceOption.Path); err != nil {\n\t\t\tif namespaceOption.Path == \"\" {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding new %q namespace for run\", namespaceOption.Name)\n\t\t\t}\n\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding %q namespace %q for run\", namespaceOption.Name, namespaceOption.Path)\n\t\t}\n\t}\n\n\t// If we've got mappings, we're going to have to create a user namespace.\n\tif len(idmapOptions.UIDMap) > 0 || len(idmapOptions.GIDMap) > 0 || configureUserns {\n\t\tif err := g.AddOrReplaceLinuxNamespace(string(specs.UserNamespace), \"\"); err != nil {\n\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding new %q namespace for run\", string(specs.UserNamespace))\n\t\t}\n\t\thostUidmap, hostGidmap, err := unshare.GetHostIDMappings(\"\")\n\t\tif err != nil {\n\t\t\treturn false, nil, false, err\n\t\t}\n\t\tfor _, m := range idmapOptions.UIDMap {\n\t\t\tg.AddLinuxUIDMapping(m.HostID, m.ContainerID, m.Size)\n\t\t}\n\t\tif len(idmapOptions.UIDMap) == 0 {\n\t\t\tfor _, m := range hostUidmap {\n\t\t\t\tg.AddLinuxUIDMapping(m.ContainerID, m.ContainerID, m.Size)\n\t\t\t}\n\t\t}\n\t\tfor _, m := range idmapOptions.GIDMap {\n\t\t\tg.AddLinuxGIDMapping(m.HostID, m.ContainerID, m.Size)\n\t\t}\n\t\tif len(idmapOptions.GIDMap) == 0 {\n\t\t\tfor _, m := range hostGidmap {\n\t\t\t\tg.AddLinuxGIDMapping(m.ContainerID, m.ContainerID, m.Size)\n\t\t\t}\n\t\t}\n\t\tif !specifiedNetwork {\n\t\t\tif err := g.AddOrReplaceLinuxNamespace(string(specs.NetworkNamespace), \"\"); err != nil {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding new %q namespace for run\", string(specs.NetworkNamespace))\n\t\t\t}\n\t\t\tconfigureNetwork = (policy != define.NetworkDisabled)\n\t\t}\n\t} else {\n\t\tif err := g.RemoveLinuxNamespace(string(specs.UserNamespace)); err != nil {\n\t\t\treturn false, nil, false, errors.Wrapf(err, \"error removing %q namespace for run\", string(specs.UserNamespace))\n\t\t}\n\t\tif !specifiedNetwork {\n\t\t\tif err := g.RemoveLinuxNamespace(string(specs.NetworkNamespace)); err != nil {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error removing %q namespace for run\", string(specs.NetworkNamespace))\n\t\t\t}\n\t\t}\n\t}\n\tif configureNetwork && !unshare.IsRootless() {\n\t\tfor name, val := range define.DefaultNetworkSysctl {\n\t\t\t// Check that the sysctl we are adding is actually supported\n\t\t\t// by the kernel\n\t\t\tp := filepath.Join(\"/proc/sys\", strings.Replace(name, \".\", \"/\", -1))\n\t\t\t_, err := os.Stat(p)\n\t\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\t\treturn false, nil, false, err\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tg.AddLinuxSysctl(name, val)\n\t\t\t} else {\n\t\t\t\tlogger.Warnf(\"ignoring sysctl %s since %s doesn't exist\", name, p)\n\t\t\t}\n\t\t}\n\t}\n\treturn configureNetwork, configureNetworks, configureUTS, nil\n}\n\nfunc (b *Builder) configureNamespaces(g *generate.Generator, options *RunOptions) (bool, []string, error) {\n\tdefaultNamespaceOptions, err := DefaultNamespaceOptions()\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\n\tnamespaceOptions := defaultNamespaceOptions\n\tnamespaceOptions.AddOrReplace(b.NamespaceOptions...)\n\tnamespaceOptions.AddOrReplace(options.NamespaceOptions...)\n\n\tnetworkPolicy := options.ConfigureNetwork\n\t//Nothing was specified explicitly so network policy should be inherited from builder\n\tif networkPolicy == NetworkDefault {\n\t\tnetworkPolicy = b.ConfigureNetwork\n\n\t\t// If builder policy was NetworkDisabled and\n\t\t// we want to disable network for this run.\n\t\t// reset options.ConfigureNetwork to NetworkDisabled\n\t\t// since it will be treated as source of truth later.\n\t\tif networkPolicy == NetworkDisabled {\n\t\t\toptions.ConfigureNetwork = networkPolicy\n\t\t}\n\t}\n\n\tconfigureNetwork, configureNetworks, configureUTS, err := setupNamespaces(options.Logger, g, namespaceOptions, b.IDMappingOptions, networkPolicy)\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\n\tif configureUTS {\n\t\tif options.Hostname != \"\" {\n\t\t\tg.SetHostname(options.Hostname)\n\t\t} else if b.Hostname() != \"\" {\n\t\t\tg.SetHostname(b.Hostname())\n\t\t} else {\n\t\t\tg.SetHostname(stringid.TruncateID(b.ContainerID))\n\t\t}\n\t} else {\n\t\tg.SetHostname(\"\")\n\t}\n\n\tfound := false\n\tspec := g.Config\n\tfor i := range spec.Process.Env {\n\t\tif strings.HasPrefix(spec.Process.Env[i], \"HOSTNAME=\") {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tspec.Process.Env = append(spec.Process.Env, fmt.Sprintf(\"HOSTNAME=%s\", spec.Hostname))\n\t}\n\n\treturn configureNetwork, configureNetworks, nil\n}\n\nfunc runSetupBoundFiles(bundlePath string, bindFiles map[string]string) (mounts []specs.Mount) {\n\tfor dest, src := range bindFiles {\n\t\toptions := []string{\"rbind\"}\n\t\tif strings.HasPrefix(src, bundlePath) {\n\t\t\toptions = append(options, bind.NoBindOption)\n\t\t}\n\t\tmounts = append(mounts, specs.Mount{\n\t\t\tSource:      src,\n\t\t\tDestination: dest,\n\t\t\tType:        \"bind\",\n\t\t\tOptions:     options,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc addRlimits(ulimit []string, g *generate.Generator, defaultUlimits []string) error {\n\tvar (\n\t\tul  *units.Ulimit\n\t\terr error\n\t)\n\n\tulimit = append(defaultUlimits, ulimit...)\n\tfor _, u := range ulimit {\n\t\tif ul, err = units.ParseUlimit(u); err != nil {\n\t\t\treturn errors.Wrapf(err, \"ulimit option %q requires name=SOFT:HARD, failed to be parsed\", u)\n\t\t}\n\n\t\tg.AddProcessRlimits(\"RLIMIT_\"+strings.ToUpper(ul.Name), uint64(ul.Hard), uint64(ul.Soft))\n\t}\n\treturn nil\n}\n\nfunc (b *Builder) cleanupTempVolumes() {\n\tfor tempVolume, val := range b.TempVolumes {\n\t\tif val {\n\t\t\tif err := overlay.RemoveTemp(tempVolume); err != nil {\n\t\t\t\tb.Logger.Errorf(err.Error())\n\t\t\t}\n\t\t\tb.TempVolumes[tempVolume] = false\n\t\t}\n\t}\n}\n\nfunc (b *Builder) runSetupVolumeMounts(mountLabel string, volumeMounts []string, optionMounts []specs.Mount, rootUID, rootGID, processUID, processGID int) (mounts []specs.Mount, Err error) {\n\t// Make sure the overlay directory is clean before running\n\tcontainerDir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error looking up container directory for %s\", b.ContainerID)\n\t}\n\tif err := overlay.CleanupContent(containerDir); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error cleaning up overlay content for %s\", b.ContainerID)\n\t}\n\n\tparseMount := func(mountType, host, container string, options []string) (specs.Mount, error) {\n\t\tvar foundrw, foundro, foundz, foundZ, foundO, foundU bool\n\t\tvar rootProp, upperDir, workDir string\n\t\tfor _, opt := range options {\n\t\t\tswitch opt {\n\t\t\tcase \"rw\":\n\t\t\t\tfoundrw = true\n\t\t\tcase \"ro\":\n\t\t\t\tfoundro = true\n\t\t\tcase \"z\":\n\t\t\t\tfoundz = true\n\t\t\tcase \"Z\":\n\t\t\t\tfoundZ = true\n\t\t\tcase \"O\":\n\t\t\t\tfoundO = true\n\t\t\tcase \"U\":\n\t\t\t\tfoundU = true\n\t\t\tcase \"private\", \"rprivate\", \"slave\", \"rslave\", \"shared\", \"rshared\":\n\t\t\t\trootProp = opt\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(opt, \"upperdir\") {\n\t\t\t\tsplitOpt := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(splitOpt) > 1 {\n\t\t\t\t\tupperDir = splitOpt[1]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif strings.HasPrefix(opt, \"workdir\") {\n\t\t\t\tsplitOpt := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(splitOpt) > 1 {\n\t\t\t\t\tworkDir = splitOpt[1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !foundrw && !foundro {\n\t\t\toptions = append(options, \"rw\")\n\t\t}\n\t\tif foundz {\n\t\t\tif err := label.Relabel(host, mountLabel, true); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundZ {\n\t\t\tif err := label.Relabel(host, mountLabel, false); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundU {\n\t\t\tif err := chown.ChangeHostPathOwnership(host, true, processUID, processGID); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundO {\n\t\t\tif (upperDir != \"\" && workDir == \"\") || (workDir != \"\" && upperDir == \"\") {\n\t\t\t\treturn specs.Mount{}, errors.New(\"if specifying upperdir then workdir must be specified or vice versa\")\n\t\t\t}\n\n\t\t\tcontainerDir, err := b.store.ContainerDirectory(b.ContainerID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\n\t\t\tcontentDir, err := overlay.TempDir(containerDir, rootUID, rootGID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, errors.Wrapf(err, \"failed to create TempDir in the %s directory\", containerDir)\n\t\t\t}\n\n\t\t\toverlayOpts := overlay.Options{RootUID: rootUID,\n\t\t\t\tRootGID:                rootGID,\n\t\t\t\tUpperDirOptionFragment: upperDir,\n\t\t\t\tWorkDirOptionFragment:  workDir,\n\t\t\t\tGraphOpts:              b.store.GraphOptions(),\n\t\t\t}\n\n\t\t\toverlayMount, err := overlay.MountWithOptions(contentDir, host, container, &overlayOpts)\n\t\t\tif err == nil {\n\t\t\t\tb.TempVolumes[contentDir] = true\n\t\t\t}\n\n\t\t\t// If chown true, add correct ownership to the overlay temp directories.\n\t\t\tif foundU {\n\t\t\t\tif err := chown.ChangeHostPathOwnership(contentDir, true, processUID, processGID); err != nil {\n\t\t\t\t\treturn specs.Mount{}, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn overlayMount, err\n\t\t}\n\t\tif rootProp == \"\" {\n\t\t\toptions = append(options, \"private\")\n\t\t}\n\t\tif mountType != \"tmpfs\" {\n\t\t\tmountType = \"bind\"\n\t\t\toptions = append(options, \"rbind\")\n\t\t}\n\t\treturn specs.Mount{\n\t\t\tDestination: container,\n\t\t\tType:        mountType,\n\t\t\tSource:      host,\n\t\t\tOptions:     options,\n\t\t}, nil\n\t}\n\n\t// Bind mount volumes specified for this particular Run() invocation\n\tfor _, i := range optionMounts {\n\t\tlogrus.Debugf(\"setting up mounted volume at %q\", i.Destination)\n\t\tmount, err := parseMount(i.Type, i.Source, i.Destination, i.Options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\t// Bind mount volumes given by the user when the container was created\n\tfor _, i := range volumeMounts {\n\t\tvar options []string\n\t\tspliti := parse.SplitStringWithColonEscape(i)\n\t\tif len(spliti) > 2 {\n\t\t\toptions = strings.Split(spliti[2], \",\")\n\t\t}\n\t\toptions = append(options, \"rbind\")\n\t\tmount, err := parseMount(\"bind\", spliti[0], spliti[1], options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\treturn mounts, nil\n}\n\nfunc setupMaskedPaths(g *generate.Generator) {\n\tfor _, mp := range []string{\n\t\t\"/proc/acpi\",\n\t\t\"/proc/kcore\",\n\t\t\"/proc/keys\",\n\t\t\"/proc/latency_stats\",\n\t\t\"/proc/timer_list\",\n\t\t\"/proc/timer_stats\",\n\t\t\"/proc/sched_debug\",\n\t\t\"/proc/scsi\",\n\t\t\"/sys/firmware\",\n\t\t\"/sys/fs/selinux\",\n\t\t\"/sys/dev\",\n\t} {\n\t\tg.AddLinuxMaskedPaths(mp)\n\t}\n}\n\nfunc setupReadOnlyPaths(g *generate.Generator) {\n\tfor _, rp := range []string{\n\t\t\"/proc/asound\",\n\t\t\"/proc/bus\",\n\t\t\"/proc/fs\",\n\t\t\"/proc/irq\",\n\t\t\"/proc/sys\",\n\t\t\"/proc/sysrq-trigger\",\n\t} {\n\t\tg.AddLinuxReadonlyPaths(rp)\n\t}\n}\n\nfunc setupCapAdd(g *generate.Generator, caps ...string) error {\n\tfor _, cap := range caps {\n\t\tif err := g.AddProcessCapabilityBounding(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the bounding capability set\", cap)\n\t\t}\n\t\tif err := g.AddProcessCapabilityEffective(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the effective capability set\", cap)\n\t\t}\n\t\tif err := g.AddProcessCapabilityInheritable(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the inheritable capability set\", cap)\n\t\t}\n\t\tif err := g.AddProcessCapabilityPermitted(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the permitted capability set\", cap)\n\t\t}\n\t\tif err := g.AddProcessCapabilityAmbient(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the ambient capability set\", cap)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupCapDrop(g *generate.Generator, caps ...string) error {\n\tfor _, cap := range caps {\n\t\tif err := g.DropProcessCapabilityBounding(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the bounding capability set\", cap)\n\t\t}\n\t\tif err := g.DropProcessCapabilityEffective(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the effective capability set\", cap)\n\t\t}\n\t\tif err := g.DropProcessCapabilityInheritable(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the inheritable capability set\", cap)\n\t\t}\n\t\tif err := g.DropProcessCapabilityPermitted(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the permitted capability set\", cap)\n\t\t}\n\t\tif err := g.DropProcessCapabilityAmbient(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the ambient capability set\", cap)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupCapabilities(g *generate.Generator, defaultCapabilities, adds, drops []string) error {\n\tg.ClearProcessCapabilities()\n\tif err := setupCapAdd(g, defaultCapabilities...); err != nil {\n\t\treturn err\n\t}\n\tfor _, c := range adds {\n\t\tif strings.ToLower(c) == \"all\" {\n\t\t\tadds = capabilities.AllCapabilities()\n\t\t\tbreak\n\t\t}\n\t}\n\tfor _, c := range drops {\n\t\tif strings.ToLower(c) == \"all\" {\n\t\t\tg.ClearProcessCapabilities()\n\t\t\treturn nil\n\t\t}\n\t}\n\tif err := setupCapAdd(g, adds...); err != nil {\n\t\treturn err\n\t}\n\treturn setupCapDrop(g, drops...)\n}\n\n// Search for a command that isn't given as an absolute path using the $PATH\n// under the rootfs.  We can't resolve absolute symbolic links without\n// chroot()ing, which we may not be able to do, so just accept a link as a\n// valid resolution.\nfunc runLookupPath(g *generate.Generator, command []string) []string {\n\t// Look for the configured $PATH.\n\tspec := g.Config\n\tenvPath := \"\"\n\tfor i := range spec.Process.Env {\n\t\tif strings.HasPrefix(spec.Process.Env[i], \"PATH=\") {\n\t\t\tenvPath = spec.Process.Env[i]\n\t\t}\n\t}\n\t// If there is no configured $PATH, supply one.\n\tif envPath == \"\" {\n\t\tdefaultPath := \"/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin\"\n\t\tenvPath = \"PATH=\" + defaultPath\n\t\tg.AddProcessEnv(\"PATH\", defaultPath)\n\t}\n\t// No command, nothing to do.\n\tif len(command) == 0 {\n\t\treturn command\n\t}\n\t// Command is already an absolute path, use it as-is.\n\tif filepath.IsAbs(command[0]) {\n\t\treturn command\n\t}\n\t// For each element in the PATH,\n\tfor _, pathEntry := range filepath.SplitList(envPath[5:]) {\n\t\t// if it's the empty string, it's \".\", which is the Cwd,\n\t\tif pathEntry == \"\" {\n\t\t\tpathEntry = spec.Process.Cwd\n\t\t}\n\t\t// build the absolute path which it might be,\n\t\tcandidate := filepath.Join(pathEntry, command[0])\n\t\t// check if it's there,\n\t\tif fi, err := os.Lstat(filepath.Join(spec.Root.Path, candidate)); fi != nil && err == nil {\n\t\t\t// and if it's not a directory, and either a symlink or executable,\n\t\t\tif !fi.IsDir() && ((fi.Mode()&os.ModeSymlink != 0) || (fi.Mode()&0111 != 0)) {\n\t\t\t\t// use that.\n\t\t\t\treturn append([]string{candidate}, command[1:]...)\n\t\t\t}\n\t\t}\n\t}\n\treturn command\n}\n\nfunc getDNSIP(dnsServers []string) (dns []net.IP, err error) {\n\tfor _, i := range dnsServers {\n\t\tresult := net.ParseIP(i)\n\t\tif result == nil {\n\t\t\treturn dns, errors.Errorf(\"invalid IP address %s\", i)\n\t\t}\n\t\tdns = append(dns, result)\n\t}\n\treturn dns, nil\n}\n\nfunc (b *Builder) configureUIDGID(g *generate.Generator, mountPoint string, options RunOptions) (string, error) {\n\t// Set the user UID/GID/supplemental group list/capabilities lists.\n\tuser, homeDir, err := b.userForRun(mountPoint, options.User)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := setupCapabilities(g, b.Capabilities, options.AddCapabilities, options.DropCapabilities); err != nil {\n\t\treturn \"\", err\n\t}\n\tg.SetProcessUID(user.UID)\n\tg.SetProcessGID(user.GID)\n\tfor _, gid := range user.AdditionalGids {\n\t\tg.AddProcessAdditionalGid(gid)\n\t}\n\n\t// Remove capabilities if not running as root except Bounding set\n\tif user.UID != 0 {\n\t\tbounding := g.Config.Process.Capabilities.Bounding\n\t\tg.ClearProcessCapabilities()\n\t\tg.Config.Process.Capabilities.Bounding = bounding\n\t}\n\n\treturn homeDir, nil\n}\n\nfunc (b *Builder) configureEnvironment(g *generate.Generator, options RunOptions, defaultEnv []string) {\n\tg.ClearProcessEnv()\n\n\tif b.CommonBuildOpts.HTTPProxy {\n\t\tfor _, envSpec := range config.ProxyEnv {\n\t\t\tif envVal, ok := os.LookupEnv(envSpec); ok {\n\t\t\t\tg.AddProcessEnv(envSpec, envVal)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, envSpec := range util.MergeEnv(util.MergeEnv(defaultEnv, b.Env()), options.Env) {\n\t\tenv := strings.SplitN(envSpec, \"=\", 2)\n\t\tif len(env) > 1 {\n\t\t\tg.AddProcessEnv(env[0], env[1])\n\t\t}\n\t}\n}\n\nfunc setupRootlessSpecChanges(spec *specs.Spec, bundleDir string, shmSize string) error {\n\temptyDir := filepath.Join(bundleDir, \"empty\")\n\tif err := os.Mkdir(emptyDir, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// If the container has a network namespace, we can create a fresh /sys mount\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tif ns.Type == specs.NetworkNamespace {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Replace /sys with a read-only bind mount.\n\tmounts := []specs.Mount{\n\t\t{\n\t\t\tSource:      \"/dev\",\n\t\t\tDestination: \"/dev\",\n\t\t\tType:        \"tmpfs\",\n\t\t\tOptions:     []string{\"private\", \"strictatime\", \"noexec\", \"nosuid\", \"mode=755\", \"size=65536k\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"mqueue\",\n\t\t\tDestination: \"/dev/mqueue\",\n\t\t\tType:        \"mqueue\",\n\t\t\tOptions:     []string{\"private\", \"nodev\", \"noexec\", \"nosuid\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"pts\",\n\t\t\tDestination: \"/dev/pts\",\n\t\t\tType:        \"devpts\",\n\t\t\tOptions:     []string{\"private\", \"noexec\", \"nosuid\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"shm\",\n\t\t\tDestination: \"/dev/shm\",\n\t\t\tType:        \"tmpfs\",\n\t\t\tOptions:     []string{\"private\", \"nodev\", \"noexec\", \"nosuid\", \"mode=1777\", fmt.Sprintf(\"size=%s\", shmSize)},\n\t\t},\n\t\t{\n\t\t\tSource:      \"/proc\",\n\t\t\tDestination: \"/proc\",\n\t\t\tType:        \"proc\",\n\t\t\tOptions:     []string{\"private\", \"nodev\", \"noexec\", \"nosuid\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"/sys\",\n\t\t\tDestination: \"/sys\",\n\t\t\tType:        \"bind\",\n\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"private\", \"nodev\", \"noexec\", \"nosuid\", \"ro\"},\n\t\t},\n\t}\n\n\tcgroup2, err := cgroups.IsCgroup2UnifiedMode()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cgroup2 {\n\t\thasCgroupNs := false\n\t\tfor _, ns := range spec.Linux.Namespaces {\n\t\t\tif ns.Type == specs.CgroupNamespace {\n\t\t\t\thasCgroupNs = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif hasCgroupNs {\n\t\t\tmounts = append(mounts, specs.Mount{\n\t\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\t\tType:        \"cgroup\",\n\t\t\t\tSource:      \"cgroup\",\n\t\t\t\tOptions:     []string{\"private\", \"rw\"},\n\t\t\t})\n\t\t}\n\t} else {\n\t\tspec.Linux.Resources = nil\n\t\t// Cover up /sys/fs/cgroup, if it exist in our source for /sys.\n\t\tif _, err := os.Stat(\"/sys/fs/cgroup\"); err == nil {\n\t\t\tspec.Linux.MaskedPaths = append(spec.Linux.MaskedPaths, \"/sys/fs/cgroup\")\n\t\t}\n\t}\n\t// Keep anything that isn't under /dev, /proc, or /sys.\n\tfor i := range spec.Mounts {\n\t\tif spec.Mounts[i].Destination == \"/dev\" || strings.HasPrefix(spec.Mounts[i].Destination, \"/dev/\") ||\n\t\t\tspec.Mounts[i].Destination == \"/proc\" || strings.HasPrefix(spec.Mounts[i].Destination, \"/proc/\") ||\n\t\t\tspec.Mounts[i].Destination == \"/sys\" || strings.HasPrefix(spec.Mounts[i].Destination, \"/sys/\") {\n\t\t\tcontinue\n\t\t}\n\t\tmounts = append(mounts, spec.Mounts[i])\n\t}\n\tspec.Mounts = mounts\n\treturn nil\n}\n\nfunc (b *Builder) runUsingRuntimeSubproc(isolation define.Isolation, options RunOptions, configureNetwork bool, configureNetworks, moreCreateArgs []string, spec *specs.Spec, rootPath, bundlePath, containerName string) (err error) {\n\tvar confwg sync.WaitGroup\n\tconfig, conferr := json.Marshal(runUsingRuntimeSubprocOptions{\n\t\tOptions:          options,\n\t\tSpec:             spec,\n\t\tRootPath:         rootPath,\n\t\tBundlePath:       bundlePath,\n\t\tConfigureNetwork: configureNetwork,\n\t\tMoreCreateArgs:   moreCreateArgs,\n\t\tContainerName:    containerName,\n\t\tIsolation:        isolation,\n\t})\n\tif conferr != nil {\n\t\treturn errors.Wrapf(conferr, \"error encoding configuration for %q\", runUsingRuntimeCommand)\n\t}\n\tcmd := reexec.Command(runUsingRuntimeCommand)\n\tcmd.Dir = bundlePath\n\tcmd.Stdin = options.Stdin\n\tif cmd.Stdin == nil {\n\t\tcmd.Stdin = os.Stdin\n\t}\n\tcmd.Stdout = options.Stdout\n\tif cmd.Stdout == nil {\n\t\tcmd.Stdout = os.Stdout\n\t}\n\tcmd.Stderr = options.Stderr\n\tif cmd.Stderr == nil {\n\t\tcmd.Stderr = os.Stderr\n\t}\n\tcmd.Env = util.MergeEnv(os.Environ(), []string{fmt.Sprintf(\"LOGLEVEL=%d\", logrus.GetLevel())})\n\tpreader, pwriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error creating configuration pipe\")\n\t}\n\tconfwg.Add(1)\n\tgo func() {\n\t\t_, conferr = io.Copy(pwriter, bytes.NewReader(config))\n\t\tif conferr != nil {\n\t\t\tconferr = errors.Wrapf(conferr, \"error while copying configuration down pipe to child process\")\n\t\t}\n\t\tconfwg.Done()\n\t}()\n\n\t// create network configuration pipes\n\tvar containerCreateR, containerCreateW *os.File\n\tvar containerStartR, containerStartW *os.File\n\tif configureNetwork {\n\t\tcontainerCreateR, containerCreateW, err = os.Pipe()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error creating container create pipe\")\n\t\t}\n\t\tdefer containerCreateR.Close()\n\t\tdefer containerCreateW.Close()\n\n\t\tcontainerStartR, containerStartW, err = os.Pipe()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error creating container create pipe\")\n\t\t}\n\t\tdefer containerStartR.Close()\n\t\tdefer containerStartW.Close()\n\t\tcmd.ExtraFiles = []*os.File{containerCreateW, containerStartR}\n\t}\n\n\tcmd.ExtraFiles = append([]*os.File{preader}, cmd.ExtraFiles...)\n\tdefer preader.Close()\n\tdefer pwriter.Close()\n\tif err := cmd.Start(); err != nil {\n\t\treturn errors.Wrapf(err, \"error while starting runtime\")\n\t}\n\n\tif configureNetwork {\n\t\tif err := waitForSync(containerCreateR); err != nil {\n\t\t\t// we do not want to return here since we want to capture the exit code from the child via cmd.Wait()\n\t\t\t// close the pipes here so that the child will not hang forever\n\t\t\tcontainerCreateR.Close()\n\t\t\tcontainerStartW.Close()\n\t\t\tlogrus.Errorf(\"did not get container create message from subprocess: %v\", err)\n\t\t} else {\n\t\t\tpidFile := filepath.Join(bundlePath, \"pid\")\n\t\t\tpidValue, err := ioutil.ReadFile(pidFile)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpid, err := strconv.Atoi(strings.TrimSpace(string(pidValue)))\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error parsing pid %s as a number\", string(pidValue))\n\t\t\t}\n\n\t\t\tteardown, err := b.runConfigureNetwork(pid, isolation, options, configureNetworks, containerName)\n\t\t\tif teardown != nil {\n\t\t\t\tdefer teardown()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tlogrus.Debug(\"network namespace successfully setup, send start message to child\")\n\t\t\t_, err = containerStartW.Write([]byte{1})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif err := cmd.Wait(); err != nil {\n\t\treturn errors.Wrapf(err, \"error while running runtime\")\n\t}\n\tconfwg.Wait()\n\tif err == nil {\n\t\treturn conferr\n\t}\n\tif conferr != nil {\n\t\tlogrus.Debugf(\"%v\", conferr)\n\t}\n\treturn err\n}\n\n// waitForSync waits for a maximum of 5 seconds to read something from the file\nfunc waitForSync(pipeR *os.File) error {\n\tif err := pipeR.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\treturn err\n\t}\n\tb := make([]byte, 16)\n\t_, err := pipeR.Read(b)\n\treturn err\n}\n\nfunc checkAndOverrideIsolationOptions(isolation define.Isolation, options *RunOptions) error {\n\tswitch isolation {\n\tcase IsolationOCIRootless:\n\t\tif ns := options.NamespaceOptions.Find(string(specs.IPCNamespace)); ns == nil || ns.Host {\n\t\t\tlogrus.Debugf(\"Forcing use of an IPC namespace.\")\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.IPCNamespace)})\n\t\t_, err := exec.LookPath(\"slirp4netns\")\n\t\thostNetworking := err != nil\n\t\tnetworkNamespacePath := \"\"\n\t\tif ns := options.NamespaceOptions.Find(string(specs.NetworkNamespace)); ns != nil {\n\t\t\thostNetworking = ns.Host\n\t\t\tnetworkNamespacePath = ns.Path\n\t\t\tif hostNetworking {\n\t\t\t\tnetworkNamespacePath = \"\"\n\t\t\t}\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{\n\t\t\tName: string(specs.NetworkNamespace),\n\t\t\tHost: hostNetworking,\n\t\t\tPath: networkNamespacePath,\n\t\t})\n\t\tif ns := options.NamespaceOptions.Find(string(specs.PIDNamespace)); ns == nil || ns.Host {\n\t\t\tlogrus.Debugf(\"Forcing use of a PID namespace.\")\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.PIDNamespace), Host: false})\n\t\tif ns := options.NamespaceOptions.Find(string(specs.UserNamespace)); ns == nil || ns.Host {\n\t\t\tlogrus.Debugf(\"Forcing use of a user namespace.\")\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.UserNamespace)})\n\tcase IsolationOCI:\n\t\tpidns := options.NamespaceOptions.Find(string(specs.PIDNamespace))\n\t\tuserns := options.NamespaceOptions.Find(string(specs.UserNamespace))\n\t\tif (pidns != nil && pidns.Host) && (userns != nil && !userns.Host) {\n\t\t\treturn errors.Errorf(\"not allowed to mix host PID namespace with container user namespace\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// DefaultNamespaceOptions returns the default namespace settings from the\n// runtime-tools generator library.\nfunc DefaultNamespaceOptions() (define.NamespaceOptions, error) {\n\tcfg, err := config.Default()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to get container config\")\n\t}\n\toptions := define.NamespaceOptions{\n\t\t{Name: string(specs.CgroupNamespace), Host: cfg.CgroupNS() == \"host\"},\n\t\t{Name: string(specs.IPCNamespace), Host: cfg.IPCNS() == \"host\"},\n\t\t{Name: string(specs.MountNamespace), Host: true},\n\t\t{Name: string(specs.NetworkNamespace), Host: cfg.NetNS() == \"host\" || cfg.NetNS() == \"container\"},\n\t\t{Name: string(specs.PIDNamespace), Host: cfg.PidNS() == \"host\"},\n\t\t{Name: string(specs.UserNamespace), Host: true},\n\t\t{Name: string(specs.UTSNamespace), Host: cfg.UTSNS() == \"host\"},\n\t}\n\tg, err := generate.New(\"linux\")\n\tif err != nil {\n\t\treturn options, errors.Wrapf(err, \"error generating new 'linux' runtime spec\")\n\t}\n\tspec := g.Config\n\tif spec.Linux != nil {\n\t\tfor _, ns := range spec.Linux.Namespaces {\n\t\t\toptions.AddOrReplace(define.NamespaceOption{\n\t\t\t\tName: string(ns.Type),\n\t\t\t\tPath: ns.Path,\n\t\t\t})\n\t\t}\n\t}\n\treturn options, nil\n}\n\nfunc contains(volumes []string, v string) bool {\n\tfor _, i := range volumes {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\ntype runUsingRuntimeSubprocOptions struct {\n\tOptions          RunOptions\n\tSpec             *specs.Spec\n\tRootPath         string\n\tBundlePath       string\n\tConfigureNetwork bool\n\tMoreCreateArgs   []string\n\tContainerName    string\n\tIsolation        define.Isolation\n}\n\nfunc init() {\n\treexec.Register(runUsingRuntimeCommand, runUsingRuntimeMain)\n}\n\n// runSetupRunMounts sets up mounts that exist only in this RUN, not in subsequent runs\nfunc (b *Builder) runSetupRunMounts(context *imagetypes.SystemContext, mounts []string, secrets map[string]define.Secret, stageMountPoints map[string]internal.StageMountDetails, sshSources map[string]*sshagent.Source, containerWorkingDir string, contextDir string, uidmap []spec.LinuxIDMapping, gidmap []spec.LinuxIDMapping, rootUID int, rootGID int, processUID int, processGID int) ([]spec.Mount, *runMountArtifacts, error) {\n\tmountTargets := make([]string, 0, 10)\n\ttmpFiles := make([]string, 0, len(mounts))\n\tmountImages := make([]string, 0, 10)\n\tfinalMounts := make([]specs.Mount, 0, len(mounts))\n\tagents := make([]*sshagent.AgentServer, 0, len(mounts))\n\tsshCount := 0\n\tdefaultSSHSock := \"\"\n\ttokens := []string{}\n\tfor _, mount := range mounts {\n\t\tarr := strings.SplitN(mount, \",\", 2)\n\n\t\tkv := strings.Split(arr[0], \"=\")\n\t\tif len(kv) != 2 || kv[0] != \"type\" {\n\t\t\treturn nil, nil, errors.New(\"invalid mount type\")\n\t\t}\n\t\tif len(arr) == 2 {\n\t\t\ttokens = strings.Split(arr[1], \",\")\n\t\t}\n\t\t// For now, we only support type secret.\n\t\tswitch kv[1] {\n\t\tcase \"secret\":\n\t\t\tmount, envFile, err := getSecretMount(tokens, secrets, b.MountLabel, containerWorkingDir, uidmap, gidmap)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif mount != nil {\n\t\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\t\t\tif envFile != \"\" {\n\t\t\t\t\ttmpFiles = append(tmpFiles, envFile)\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"ssh\":\n\t\t\tmount, agent, err := b.getSSHMount(tokens, sshCount, sshSources, b.MountLabel, uidmap, gidmap, b.ProcessLabel)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif mount != nil {\n\t\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\t\t\tagents = append(agents, agent)\n\t\t\t\tif sshCount == 0 {\n\t\t\t\t\tdefaultSSHSock = mount.Destination\n\t\t\t\t}\n\t\t\t\t// Count is needed as the default destination of the ssh sock inside the container is  /run/buildkit/ssh_agent.{i}\n\t\t\t\tsshCount++\n\t\t\t}\n\t\tcase \"bind\":\n\t\t\tmount, image, err := b.getBindMount(context, tokens, contextDir, rootUID, rootGID, processUID, processGID, stageMountPoints)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\t\t// only perform cleanup if image was mounted ignore everything else\n\t\t\tif image != \"\" {\n\t\t\t\tmountImages = append(mountImages, image)\n\t\t\t}\n\t\tcase \"tmpfs\":\n\t\t\tmount, err := b.getTmpfsMount(tokens, rootUID, rootGID, processUID, processGID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\tcase \"cache\":\n\t\t\tmount, err := b.getCacheMount(tokens, rootUID, rootGID, processUID, processGID, stageMountPoints)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\tdefault:\n\t\t\treturn nil, nil, errors.Errorf(\"invalid mount type %q\", kv[1])\n\t\t}\n\t}\n\tartifacts := &runMountArtifacts{\n\t\tRunMountTargets: mountTargets,\n\t\tTmpFiles:        tmpFiles,\n\t\tAgents:          agents,\n\t\tMountedImages:   mountImages,\n\t\tSSHAuthSock:     defaultSSHSock,\n\t}\n\treturn finalMounts, artifacts, nil\n}\n\nfunc (b *Builder) getBindMount(context *imagetypes.SystemContext, tokens []string, contextDir string, rootUID, rootGID, processUID, processGID int, stageMountPoints map[string]internal.StageMountDetails) (*spec.Mount, string, error) {\n\tif contextDir == \"\" {\n\t\treturn nil, \"\", errors.New(\"Context Directory for current run invocation is not configured\")\n\t}\n\tvar optionMounts []specs.Mount\n\tmount, image, err := internalParse.GetBindMount(context, tokens, contextDir, b.store, b.MountLabel, stageMountPoints)\n\tif err != nil {\n\t\treturn nil, image, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, rootUID, rootGID, processUID, processGID)\n\tif err != nil {\n\t\treturn nil, image, err\n\t}\n\treturn &volumes[0], image, nil\n}\n\nfunc (b *Builder) getTmpfsMount(tokens []string, rootUID, rootGID, processUID, processGID int) (*spec.Mount, error) {\n\tvar optionMounts []specs.Mount\n\tmount, err := internalParse.GetTmpfsMount(tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, rootUID, rootGID, processUID, processGID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &volumes[0], nil\n}\n\nfunc (b *Builder) getCacheMount(tokens []string, rootUID, rootGID, processUID, processGID int, stageMountPoints map[string]internal.StageMountDetails) (*spec.Mount, error) {\n\tvar optionMounts []specs.Mount\n\tmount, err := internalParse.GetCacheMount(tokens, b.store, b.MountLabel, stageMountPoints)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, rootUID, rootGID, processUID, processGID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &volumes[0], nil\n}\n\nfunc getSecretMount(tokens []string, secrets map[string]define.Secret, mountlabel string, containerWorkingDir string, uidmap []spec.LinuxIDMapping, gidmap []spec.LinuxIDMapping) (*spec.Mount, string, error) {\n\terrInvalidSyntax := errors.New(\"secret should have syntax id=id[,target=path,required=bool,mode=uint,uid=uint,gid=uint\")\n\tif len(tokens) == 0 {\n\t\treturn nil, \"\", errInvalidSyntax\n\t}\n\tvar err error\n\tvar id, target string\n\tvar required bool\n\tvar uid, gid uint32\n\tvar mode uint32 = 0400\n\tfor _, val := range tokens {\n\t\tkv := strings.SplitN(val, \"=\", 2)\n\t\tswitch kv[0] {\n\t\tcase \"id\":\n\t\t\tid = kv[1]\n\t\tcase \"target\", \"dst\", \"destination\":\n\t\t\ttarget = kv[1]\n\t\tcase \"required\":\n\t\t\trequired, err = strconv.ParseBool(kv[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\tcase \"mode\":\n\t\t\tmode64, err := strconv.ParseUint(kv[1], 8, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tmode = uint32(mode64)\n\t\tcase \"uid\":\n\t\t\tuid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tuid = uint32(uid64)\n\t\tcase \"gid\":\n\t\t\tgid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tgid = uint32(gid64)\n\t\tdefault:\n\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t}\n\t}\n\n\tif id == \"\" {\n\t\treturn nil, \"\", errInvalidSyntax\n\t}\n\t// Default location for secretis is /run/secrets/id\n\tif target == \"\" {\n\t\ttarget = \"/run/secrets/\" + id\n\t}\n\n\tsecr, ok := secrets[id]\n\tif !ok {\n\t\tif required {\n\t\t\treturn nil, \"\", errors.Errorf(\"secret required but no secret with id %s found\", id)\n\t\t}\n\t\treturn nil, \"\", nil\n\t}\n\tvar data []byte\n\tvar envFile string\n\tvar ctrFileOnHost string\n\n\tswitch secr.SourceType {\n\tcase \"env\":\n\t\tdata = []byte(os.Getenv(secr.Source))\n\t\ttmpFile, err := ioutil.TempFile(\"/dev/shm\", \"buildah*\")\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tenvFile = tmpFile.Name()\n\t\tctrFileOnHost = tmpFile.Name()\n\tcase \"file\":\n\t\tdata, err = ioutil.ReadFile(secr.Source)\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tctrFileOnHost = filepath.Join(containerWorkingDir, \"secrets\", id)\n\t\t_, err = os.Stat(ctrFileOnHost)\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, \"\", err\n\t\t}\n\tdefault:\n\t\treturn nil, \"\", errors.New(\"invalid source secret type\")\n\t}\n\n\t// Copy secrets to container working dir (or tmp dir if it's an env), since we need to chmod,\n\t// chown and relabel it for the container user and we don't want to mess with the original file\n\tif err := os.MkdirAll(filepath.Dir(ctrFileOnHost), 0755); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := ioutil.WriteFile(ctrFileOnHost, data, 0644); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tif err := label.Relabel(ctrFileOnHost, mountlabel, false); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\thostUID, hostGID, err := util.GetHostIDs(uidmap, gidmap, uid, gid)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := os.Lchown(ctrFileOnHost, int(hostUID), int(hostGID)); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := os.Chmod(ctrFileOnHost, os.FileMode(mode)); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tnewMount := specs.Mount{\n\t\tDestination: target,\n\t\tType:        \"bind\",\n\t\tSource:      ctrFileOnHost,\n\t\tOptions:     []string{\"bind\", \"rprivate\", \"ro\"},\n\t}\n\treturn &newMount, envFile, nil\n}\n\n// getSSHMount parses the --mount type=ssh flag in the Containerfile, checks if there's an ssh source provided, and creates and starts an ssh-agent to be forwarded into the container\nfunc (b *Builder) getSSHMount(tokens []string, count int, sshsources map[string]*sshagent.Source, mountlabel string, uidmap []spec.LinuxIDMapping, gidmap []spec.LinuxIDMapping, processLabel string) (*spec.Mount, *sshagent.AgentServer, error) {\n\terrInvalidSyntax := errors.New(\"ssh should have syntax id=id[,target=path,required=bool,mode=uint,uid=uint,gid=uint\")\n\n\tvar err error\n\tvar id, target string\n\tvar required bool\n\tvar uid, gid uint32\n\tvar mode uint32 = 400\n\tfor _, val := range tokens {\n\t\tkv := strings.SplitN(val, \"=\", 2)\n\t\tif len(kv) < 2 {\n\t\t\treturn nil, nil, errInvalidSyntax\n\t\t}\n\t\tswitch kv[0] {\n\t\tcase \"id\":\n\t\t\tid = kv[1]\n\t\tcase \"target\", \"dst\", \"destination\":\n\t\t\ttarget = kv[1]\n\t\tcase \"required\":\n\t\t\trequired, err = strconv.ParseBool(kv[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\tcase \"mode\":\n\t\t\tmode64, err := strconv.ParseUint(kv[1], 8, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tmode = uint32(mode64)\n\t\tcase \"uid\":\n\t\t\tuid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tuid = uint32(uid64)\n\t\tcase \"gid\":\n\t\t\tgid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tgid = uint32(gid64)\n\t\tdefault:\n\t\t\treturn nil, nil, errInvalidSyntax\n\t\t}\n\t}\n\n\tif id == \"\" {\n\t\tid = \"default\"\n\t}\n\t// Default location for secretis is /run/buildkit/ssh_agent.{i}\n\tif target == \"\" {\n\t\ttarget = fmt.Sprintf(\"/run/buildkit/ssh_agent.%d\", count)\n\t}\n\n\tsshsource, ok := sshsources[id]\n\tif !ok {\n\t\tif required {\n\t\t\treturn nil, nil, errors.Errorf(\"ssh required but no ssh with id %s found\", id)\n\t\t}\n\t\treturn nil, nil, nil\n\t}\n\t// Create new agent from keys or socket\n\tfwdAgent, err := sshagent.NewAgentServer(sshsource)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\t// Start ssh server, and get the host sock we're mounting in the container\n\thostSock, err := fwdAgent.Serve(processLabel)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := label.Relabel(filepath.Dir(hostSock), mountlabel, false); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := label.Relabel(hostSock, mountlabel, false); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\n\thostUID, hostGID, err := util.GetHostIDs(uidmap, gidmap, uid, gid)\n\tif err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := os.Lchown(hostSock, int(hostUID), int(hostGID)); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := os.Chmod(hostSock, os.FileMode(mode)); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tnewMount := specs.Mount{\n\t\tDestination: target,\n\t\tType:        \"bind\",\n\t\tSource:      hostSock,\n\t\tOptions:     []string{\"bind\", \"rprivate\", \"ro\"},\n\t}\n\treturn &newMount, fwdAgent, nil\n}\n\n// cleanupRunMounts cleans up run mounts so they only appear in this run.\nfunc (b *Builder) cleanupRunMounts(context *imagetypes.SystemContext, mountpoint string, artifacts *runMountArtifacts) error {\n\tfor _, agent := range artifacts.Agents {\n\t\terr := agent.Shutdown()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t//cleanup any mounted images for this run\n\tfor _, image := range artifacts.MountedImages {\n\t\tif image != \"\" {\n\t\t\t// if flow hits here some image was mounted for this run\n\t\t\ti, err := internalUtil.LookupImage(context, b.store, image)\n\t\t\tif err == nil {\n\t\t\t\t// silently try to unmount and do nothing\n\t\t\t\t// if image is being used by something else\n\t\t\t\t_ = i.Unmount(false)\n\t\t\t}\n\t\t\tif errors.Cause(err) == storagetypes.ErrImageUnknown {\n\t\t\t\t// Ignore only if ErrImageUnknown\n\t\t\t\t// Reason: Image is already unmounted do nothing\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\topts := copier.RemoveOptions{\n\t\tAll: true,\n\t}\n\tfor _, path := range artifacts.RunMountTargets {\n\t\terr := copier.Remove(mountpoint, path, opts)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tvar prevErr error\n\tfor _, path := range artifacts.TmpFiles {\n\t\terr := os.Remove(path)\n\t\tif !os.IsNotExist(err) {\n\t\t\tif prevErr != nil {\n\t\t\t\tlogrus.Error(prevErr)\n\t\t\t}\n\t\t\tprevErr = err\n\t\t}\n\t}\n\treturn prevErr\n}\n\n// getNetworkInterface creates the network interface\nfunc getNetworkInterface(store storage.Store, cniConfDir, cniPluginPath string) (nettypes.ContainerNetwork, error) {\n\tconf, err := config.Default()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// copy the config to not modify the default by accident\n\tnewconf := *conf\n\tif len(cniConfDir) > 0 {\n\t\tnewconf.Network.NetworkConfigDir = cniConfDir\n\t}\n\tif len(cniPluginPath) > 0 {\n\t\tplugins := strings.Split(cniPluginPath, string(os.PathListSeparator))\n\t\tnewconf.Network.CNIPluginDirs = plugins\n\t}\n\n\t_, netInt, err := network.NetworkBackend(store, &newconf, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn netInt, nil\n}\n"], "fixing_code": ["// +build linux\n\npackage chroot\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/containers/buildah/bind\"\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\t\"github.com/containers/storage/pkg/mount\"\n\t\"github.com/containers/storage/pkg/reexec\"\n\t\"github.com/containers/storage/pkg/unshare\"\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/syndtr/gocapability/capability\"\n\t\"golang.org/x/sys/unix\"\n\t\"golang.org/x/term\"\n)\n\nconst (\n\t// runUsingChrootCommand is a command we use as a key for reexec\n\trunUsingChrootCommand = \"buildah-chroot-runtime\"\n\t// runUsingChrootExec is a command we use as a key for reexec\n\trunUsingChrootExecCommand = \"buildah-chroot-exec\"\n)\n\nvar (\n\trlimitsMap = map[string]int{\n\t\t\"RLIMIT_AS\":         unix.RLIMIT_AS,\n\t\t\"RLIMIT_CORE\":       unix.RLIMIT_CORE,\n\t\t\"RLIMIT_CPU\":        unix.RLIMIT_CPU,\n\t\t\"RLIMIT_DATA\":       unix.RLIMIT_DATA,\n\t\t\"RLIMIT_FSIZE\":      unix.RLIMIT_FSIZE,\n\t\t\"RLIMIT_LOCKS\":      unix.RLIMIT_LOCKS,\n\t\t\"RLIMIT_MEMLOCK\":    unix.RLIMIT_MEMLOCK,\n\t\t\"RLIMIT_MSGQUEUE\":   unix.RLIMIT_MSGQUEUE,\n\t\t\"RLIMIT_NICE\":       unix.RLIMIT_NICE,\n\t\t\"RLIMIT_NOFILE\":     unix.RLIMIT_NOFILE,\n\t\t\"RLIMIT_NPROC\":      unix.RLIMIT_NPROC,\n\t\t\"RLIMIT_RSS\":        unix.RLIMIT_RSS,\n\t\t\"RLIMIT_RTPRIO\":     unix.RLIMIT_RTPRIO,\n\t\t\"RLIMIT_RTTIME\":     unix.RLIMIT_RTTIME,\n\t\t\"RLIMIT_SIGPENDING\": unix.RLIMIT_SIGPENDING,\n\t\t\"RLIMIT_STACK\":      unix.RLIMIT_STACK,\n\t}\n\trlimitsReverseMap = map[int]string{}\n)\n\nfunc init() {\n\treexec.Register(runUsingChrootCommand, runUsingChrootMain)\n\treexec.Register(runUsingChrootExecCommand, runUsingChrootExecMain)\n\tfor limitName, limitNumber := range rlimitsMap {\n\t\trlimitsReverseMap[limitNumber] = limitName\n\t}\n}\n\ntype runUsingChrootSubprocOptions struct {\n\tSpec        *specs.Spec\n\tBundlePath  string\n\tUIDMappings []syscall.SysProcIDMap\n\tGIDMappings []syscall.SysProcIDMap\n}\n\ntype runUsingChrootExecSubprocOptions struct {\n\tSpec       *specs.Spec\n\tBundlePath string\n}\n\n// RunUsingChroot runs a chrooted process, using some of the settings from the\n// passed-in spec, and using the specified bundlePath to hold temporary files,\n// directories, and mountpoints.\nfunc RunUsingChroot(spec *specs.Spec, bundlePath, homeDir string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\tvar confwg sync.WaitGroup\n\tvar homeFound bool\n\tfor _, env := range spec.Process.Env {\n\t\tif strings.HasPrefix(env, \"HOME=\") {\n\t\t\thomeFound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !homeFound {\n\t\tspec.Process.Env = append(spec.Process.Env, fmt.Sprintf(\"HOME=%s\", homeDir))\n\t}\n\truntime.LockOSThread()\n\tdefer runtime.UnlockOSThread()\n\n\t// Write the runtime configuration, mainly for debugging.\n\tspecbytes, err := json.Marshal(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = ioutils.AtomicWriteFile(filepath.Join(bundlePath, \"config.json\"), specbytes, 0600); err != nil {\n\t\treturn errors.Wrapf(err, \"error storing runtime configuration\")\n\t}\n\tlogrus.Debugf(\"config = %v\", string(specbytes))\n\n\t// Default to using stdin/stdout/stderr if we weren't passed objects to use.\n\tif stdin == nil {\n\t\tstdin = os.Stdin\n\t}\n\tif stdout == nil {\n\t\tstdout = os.Stdout\n\t}\n\tif stderr == nil {\n\t\tstderr = os.Stderr\n\t}\n\n\t// Create a pipe for passing configuration down to the next process.\n\tpreader, pwriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error creating configuration pipe\")\n\t}\n\tconfig, conferr := json.Marshal(runUsingChrootSubprocOptions{\n\t\tSpec:       spec,\n\t\tBundlePath: bundlePath,\n\t})\n\tif conferr != nil {\n\t\treturn errors.Wrapf(conferr, \"error encoding configuration for %q\", runUsingChrootCommand)\n\t}\n\n\t// Set our terminal's mode to raw, to pass handling of special\n\t// terminal input to the terminal in the container.\n\tif spec.Process.Terminal && term.IsTerminal(unix.Stdin) {\n\t\tstate, err := term.MakeRaw(unix.Stdin)\n\t\tif err != nil {\n\t\t\tlogrus.Warnf(\"error setting terminal state: %v\", err)\n\t\t} else {\n\t\t\tdefer func() {\n\t\t\t\tif err = term.Restore(unix.Stdin, state); err != nil {\n\t\t\t\t\tlogrus.Errorf(\"unable to restore terminal state: %v\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t}\n\n\t// Raise any resource limits that are higher than they are now, before\n\t// we drop any more privileges.\n\tif err = setRlimits(spec, false, true); err != nil {\n\t\treturn err\n\t}\n\n\t// Start the grandparent subprocess.\n\tcmd := unshare.Command(runUsingChrootCommand)\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr\n\tcmd.Dir = \"/\"\n\tcmd.Env = []string{fmt.Sprintf(\"LOGLEVEL=%d\", logrus.GetLevel())}\n\n\tlogrus.Debugf(\"Running %#v in %#v\", cmd.Cmd, cmd)\n\tconfwg.Add(1)\n\tgo func() {\n\t\t_, conferr = io.Copy(pwriter, bytes.NewReader(config))\n\t\tpwriter.Close()\n\t\tconfwg.Done()\n\t}()\n\tcmd.ExtraFiles = append([]*os.File{preader}, cmd.ExtraFiles...)\n\terr = cmd.Run()\n\tconfwg.Wait()\n\tif err == nil {\n\t\treturn conferr\n\t}\n\treturn err\n}\n\n// main() for grandparent subprocess.  Its main job is to shuttle stdio back\n// and forth, managing a pseudo-terminal if we want one, for our child, the\n// parent subprocess.\nfunc runUsingChrootMain() {\n\tvar options runUsingChrootSubprocOptions\n\n\truntime.LockOSThread()\n\n\t// Set logging.\n\tif level := os.Getenv(\"LOGLEVEL\"); level != \"\" {\n\t\tif ll, err := strconv.Atoi(level); err == nil {\n\t\t\tlogrus.SetLevel(logrus.Level(ll))\n\t\t}\n\t\tos.Unsetenv(\"LOGLEVEL\")\n\t}\n\n\t// Unpack our configuration.\n\tconfPipe := os.NewFile(3, \"confpipe\")\n\tif confPipe == nil {\n\t\tfmt.Fprintf(os.Stderr, \"error reading options pipe\\n\")\n\t\tos.Exit(1)\n\t}\n\tdefer confPipe.Close()\n\tif err := json.NewDecoder(confPipe).Decode(&options); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error decoding options: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif options.Spec == nil || options.Spec.Process == nil {\n\t\tfmt.Fprintf(os.Stderr, \"invalid options spec in runUsingChrootMain\\n\")\n\t\tos.Exit(1)\n\t}\n\n\t// Prepare to shuttle stdio back and forth.\n\trootUID32, rootGID32, err := util.GetHostRootIDs(options.Spec)\n\tif err != nil {\n\t\tlogrus.Errorf(\"error determining ownership for container stdio\")\n\t\tos.Exit(1)\n\t}\n\trootUID := int(rootUID32)\n\trootGID := int(rootGID32)\n\trelays := make(map[int]int)\n\tcloseOnceRunning := []*os.File{}\n\tvar ctty *os.File\n\tvar stdin io.Reader\n\tvar stdinCopy io.WriteCloser\n\tvar stdout io.Writer\n\tvar stderr io.Writer\n\tfdDesc := make(map[int]string)\n\tif options.Spec.Process.Terminal {\n\t\t// Create a pseudo-terminal -- open a copy of the master side.\n\t\tptyMasterFd, err := unix.Open(\"/dev/ptmx\", os.O_RDWR, 0600)\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening PTY master using /dev/ptmx: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Set the kernel's lock to \"unlocked\".\n\t\tlocked := 0\n\t\tif result, _, err := unix.Syscall(unix.SYS_IOCTL, uintptr(ptyMasterFd), unix.TIOCSPTLCK, uintptr(unsafe.Pointer(&locked))); int(result) == -1 {\n\t\t\tlogrus.Errorf(\"error unlocking PTY descriptor: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Get a handle for the other end.\n\t\tptyFd, _, err := unix.Syscall(unix.SYS_IOCTL, uintptr(ptyMasterFd), unix.TIOCGPTPEER, unix.O_RDWR|unix.O_NOCTTY)\n\t\tif int(ptyFd) == -1 {\n\t\t\tif errno, isErrno := err.(syscall.Errno); !isErrno || (errno != syscall.EINVAL && errno != syscall.ENOTTY) {\n\t\t\t\tlogrus.Errorf(\"error getting PTY descriptor: %v\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\t// EINVAL means the kernel's too old to understand TIOCGPTPEER.  Try TIOCGPTN.\n\t\t\tptyN, err := unix.IoctlGetInt(ptyMasterFd, unix.TIOCGPTN)\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Errorf(\"error getting PTY number: %v\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\tptyName := fmt.Sprintf(\"/dev/pts/%d\", ptyN)\n\t\t\tfd, err := unix.Open(ptyName, unix.O_RDWR|unix.O_NOCTTY, 0620)\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Errorf(\"error opening PTY %q: %v\", ptyName, err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\tptyFd = uintptr(fd)\n\t\t}\n\t\t// Make notes about what's going where.\n\t\trelays[ptyMasterFd] = unix.Stdout\n\t\trelays[unix.Stdin] = ptyMasterFd\n\t\tfdDesc[ptyMasterFd] = \"container terminal\"\n\t\tfdDesc[unix.Stdin] = \"stdin\"\n\t\tfdDesc[unix.Stdout] = \"stdout\"\n\t\twinsize := &unix.Winsize{}\n\t\t// Set the pseudoterminal's size to the configured size, or our own.\n\t\tif options.Spec.Process.ConsoleSize != nil {\n\t\t\t// Use configured sizes.\n\t\t\twinsize.Row = uint16(options.Spec.Process.ConsoleSize.Height)\n\t\t\twinsize.Col = uint16(options.Spec.Process.ConsoleSize.Width)\n\t\t} else {\n\t\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\t\t// Use the size of our terminal.\n\t\t\t\twinsize, err = unix.IoctlGetWinsize(unix.Stdin, unix.TIOCGWINSZ)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.Debugf(\"error reading current terminal's size\")\n\t\t\t\t\twinsize.Row = 0\n\t\t\t\t\twinsize.Col = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif winsize.Row != 0 && winsize.Col != 0 {\n\t\t\tif err = unix.IoctlSetWinsize(int(ptyFd), unix.TIOCSWINSZ, winsize); err != nil {\n\t\t\t\tlogrus.Warnf(\"error setting terminal size for pty\")\n\t\t\t}\n\t\t\t// FIXME - if we're connected to a terminal, we should\n\t\t\t// be passing the updated terminal size down when we\n\t\t\t// receive a SIGWINCH.\n\t\t}\n\t\t// Open an *os.File object that we can pass to our child.\n\t\tctty = os.NewFile(ptyFd, \"/dev/tty\")\n\t\t// Set ownership for the PTY.\n\t\tif err = ctty.Chown(rootUID, rootGID); err != nil {\n\t\t\tvar cttyInfo unix.Stat_t\n\t\t\terr2 := unix.Fstat(int(ptyFd), &cttyInfo)\n\t\t\tfrom := \"\"\n\t\t\top := \"setting\"\n\t\t\tif err2 == nil {\n\t\t\t\top = \"changing\"\n\t\t\t\tfrom = fmt.Sprintf(\"from %d/%d \", cttyInfo.Uid, cttyInfo.Gid)\n\t\t\t}\n\t\t\tlogrus.Warnf(\"error %s ownership of container PTY %sto %d/%d: %v\", op, from, rootUID, rootGID, err)\n\t\t}\n\t\t// Set permissions on the PTY.\n\t\tif err = ctty.Chmod(0620); err != nil {\n\t\t\tlogrus.Errorf(\"error setting permissions of container PTY: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Make a note that our child (the parent subprocess) should\n\t\t// have the PTY connected to its stdio, and that we should\n\t\t// close it once it's running.\n\t\tstdin = ctty\n\t\tstdout = ctty\n\t\tstderr = ctty\n\t\tcloseOnceRunning = append(closeOnceRunning, ctty)\n\t} else {\n\t\t// Create pipes for stdio.\n\t\tstdinRead, stdinWrite, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening pipe for stdin: %v\", err)\n\t\t}\n\t\tstdoutRead, stdoutWrite, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening pipe for stdout: %v\", err)\n\t\t}\n\t\tstderrRead, stderrWrite, err := os.Pipe()\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"error opening pipe for stderr: %v\", err)\n\t\t}\n\t\t// Make notes about what's going where.\n\t\trelays[unix.Stdin] = int(stdinWrite.Fd())\n\t\trelays[int(stdoutRead.Fd())] = unix.Stdout\n\t\trelays[int(stderrRead.Fd())] = unix.Stderr\n\t\tfdDesc[int(stdinWrite.Fd())] = \"container stdin pipe\"\n\t\tfdDesc[int(stdoutRead.Fd())] = \"container stdout pipe\"\n\t\tfdDesc[int(stderrRead.Fd())] = \"container stderr pipe\"\n\t\tfdDesc[unix.Stdin] = \"stdin\"\n\t\tfdDesc[unix.Stdout] = \"stdout\"\n\t\tfdDesc[unix.Stderr] = \"stderr\"\n\t\t// Set ownership for the pipes.\n\t\tif err = stdinRead.Chown(rootUID, rootGID); err != nil {\n\t\t\tlogrus.Errorf(\"error setting ownership of container stdin pipe: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif err = stdoutWrite.Chown(rootUID, rootGID); err != nil {\n\t\t\tlogrus.Errorf(\"error setting ownership of container stdout pipe: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif err = stderrWrite.Chown(rootUID, rootGID); err != nil {\n\t\t\tlogrus.Errorf(\"error setting ownership of container stderr pipe: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t// Make a note that our child (the parent subprocess) should\n\t\t// have the pipes connected to its stdio, and that we should\n\t\t// close its ends of them once it's running.\n\t\tstdin = stdinRead\n\t\tstdout = stdoutWrite\n\t\tstderr = stderrWrite\n\t\tcloseOnceRunning = append(closeOnceRunning, stdinRead, stdoutWrite, stderrWrite)\n\t\tstdinCopy = stdinWrite\n\t\tdefer stdoutRead.Close()\n\t\tdefer stderrRead.Close()\n\t}\n\tfor readFd, writeFd := range relays {\n\t\tif err := unix.SetNonblock(readFd, true); err != nil {\n\t\t\tlogrus.Errorf(\"error setting descriptor %d (%s) non-blocking: %v\", readFd, fdDesc[readFd], err)\n\t\t\treturn\n\t\t}\n\t\tif err := unix.SetNonblock(writeFd, false); err != nil {\n\t\t\tlogrus.Errorf(\"error setting descriptor %d (%s) blocking: %v\", relays[writeFd], fdDesc[writeFd], err)\n\t\t\treturn\n\t\t}\n\t}\n\tif err := unix.SetNonblock(relays[unix.Stdin], true); err != nil {\n\t\tlogrus.Errorf(\"error setting %d to nonblocking: %v\", relays[unix.Stdin], err)\n\t}\n\tgo func() {\n\t\tbuffers := make(map[int]*bytes.Buffer)\n\t\tfor _, writeFd := range relays {\n\t\t\tbuffers[writeFd] = new(bytes.Buffer)\n\t\t}\n\t\tpollTimeout := -1\n\t\tstdinClose := false\n\t\tfor len(relays) > 0 {\n\t\t\tfds := make([]unix.PollFd, 0, len(relays))\n\t\t\tfor fd := range relays {\n\t\t\t\tfds = append(fds, unix.PollFd{Fd: int32(fd), Events: unix.POLLIN | unix.POLLHUP})\n\t\t\t}\n\t\t\t_, err := unix.Poll(fds, pollTimeout)\n\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"poll: %v\", err)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tremoveFds := make(map[int]struct{})\n\t\t\tfor _, rfd := range fds {\n\t\t\t\tif rfd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\t\tremoveFds[int(rfd.Fd)] = struct{}{}\n\t\t\t\t}\n\t\t\t\tif rfd.Revents&unix.POLLNVAL == unix.POLLNVAL {\n\t\t\t\t\tlogrus.Debugf(\"error polling descriptor %s: closed?\", fdDesc[int(rfd.Fd)])\n\t\t\t\t\tremoveFds[int(rfd.Fd)] = struct{}{}\n\t\t\t\t}\n\t\t\t\tif rfd.Revents&unix.POLLIN == 0 {\n\t\t\t\t\tif stdinClose && stdinCopy == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tb := make([]byte, 8192)\n\t\t\t\tnread, err := unix.Read(int(rfd.Fd), b)\n\t\t\t\tutil.LogIfNotRetryable(err, fmt.Sprintf(\"read %s: %v\", fdDesc[int(rfd.Fd)], err))\n\t\t\t\tif nread > 0 {\n\t\t\t\t\tif wfd, ok := relays[int(rfd.Fd)]; ok {\n\t\t\t\t\t\tnwritten, err := buffers[wfd].Write(b[:nread])\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif nwritten != nread {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", nread, nwritten)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// If this is the last of the data we'll be able to read\n\t\t\t\t\t// from this descriptor, read as much as there is to read.\n\t\t\t\t\tfor rfd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\t\t\tnr, err := unix.Read(int(rfd.Fd), b)\n\t\t\t\t\t\tutil.LogIfUnexpectedWhileDraining(err, fmt.Sprintf(\"read %s: %v\", fdDesc[int(rfd.Fd)], err))\n\t\t\t\t\t\tif nr <= 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif wfd, ok := relays[int(rfd.Fd)]; ok {\n\t\t\t\t\t\t\tnwritten, err := buffers[wfd].Write(b[:nr])\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif nwritten != nr {\n\t\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", nr, nwritten)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif nread == 0 {\n\t\t\t\t\tremoveFds[int(rfd.Fd)] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpollTimeout = -1\n\t\t\tfor wfd, buffer := range buffers {\n\t\t\t\tif buffer.Len() > 0 {\n\t\t\t\t\tnwritten, err := unix.Write(wfd, buffer.Bytes())\n\t\t\t\t\tutil.LogIfNotRetryable(err, fmt.Sprintf(\"write %s: %v\", fdDesc[wfd], err))\n\t\t\t\t\tif nwritten >= 0 {\n\t\t\t\t\t\t_ = buffer.Next(nwritten)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif buffer.Len() > 0 {\n\t\t\t\t\tpollTimeout = 100\n\t\t\t\t}\n\t\t\t\tif wfd == relays[unix.Stdin] && stdinClose && buffer.Len() == 0 {\n\t\t\t\t\tstdinCopy.Close()\n\t\t\t\t\tdelete(relays, unix.Stdin)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor rfd := range removeFds {\n\t\t\t\tif rfd == unix.Stdin {\n\t\t\t\t\tbuffer, found := buffers[relays[unix.Stdin]]\n\t\t\t\t\tif found && buffer.Len() > 0 {\n\t\t\t\t\t\tstdinClose = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !options.Spec.Process.Terminal && rfd == unix.Stdin {\n\t\t\t\t\tstdinCopy.Close()\n\t\t\t\t}\n\t\t\t\tdelete(relays, rfd)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Set up mounts and namespaces, and run the parent subprocess.\n\tstatus, err := runUsingChroot(options.Spec, options.BundlePath, ctty, stdin, stdout, stderr, closeOnceRunning)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error running subprocess: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Pass the process's exit status back to the caller by exiting with the same status.\n\tif status.Exited() {\n\t\tif status.ExitStatus() != 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited with status %d\\n\", status.ExitStatus())\n\t\t}\n\t\tos.Exit(status.ExitStatus())\n\t} else if status.Signaled() {\n\t\tfmt.Fprintf(os.Stderr, \"subprocess exited on %s\\n\", status.Signal())\n\t\tos.Exit(1)\n\t}\n}\n\n// runUsingChroot, still in the grandparent process, sets up various bind\n// mounts and then runs the parent process in its own user namespace with the\n// necessary ID mappings.\nfunc runUsingChroot(spec *specs.Spec, bundlePath string, ctty *os.File, stdin io.Reader, stdout, stderr io.Writer, closeOnceRunning []*os.File) (wstatus unix.WaitStatus, err error) {\n\tvar confwg sync.WaitGroup\n\n\t// Create a new mount namespace for ourselves and bind mount everything to a new location.\n\tundoIntermediates, err := bind.SetupIntermediateMountNamespace(spec, bundlePath)\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tdefer func() {\n\t\tif undoErr := undoIntermediates(); undoErr != nil {\n\t\t\tlogrus.Debugf(\"error cleaning up intermediate mount NS: %v\", err)\n\t\t}\n\t}()\n\n\t// Bind mount in our filesystems.\n\tundoChroots, err := setupChrootBindMounts(spec, bundlePath)\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tdefer func() {\n\t\tif undoErr := undoChroots(); undoErr != nil {\n\t\t\tlogrus.Debugf(\"error cleaning up intermediate chroot bind mounts: %v\", err)\n\t\t}\n\t}()\n\n\t// Create a pipe for passing configuration down to the next process.\n\tpreader, pwriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error creating configuration pipe\")\n\t}\n\tconfig, conferr := json.Marshal(runUsingChrootExecSubprocOptions{\n\t\tSpec:       spec,\n\t\tBundlePath: bundlePath,\n\t})\n\tif conferr != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error re-encoding configuration for %q\", runUsingChrootExecCommand)\n\t\tos.Exit(1)\n\t}\n\n\t// Apologize for the namespace configuration that we're about to ignore.\n\tlogNamespaceDiagnostics(spec)\n\n\t// If we have configured ID mappings, set them here so that they can apply to the child.\n\thostUidmap, hostGidmap, err := unshare.GetHostIDMappings(\"\")\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tuidmap, gidmap := spec.Linux.UIDMappings, spec.Linux.GIDMappings\n\tif len(uidmap) == 0 {\n\t\t// No UID mappings are configured for the container.  Borrow our parent's mappings.\n\t\tuidmap = append([]specs.LinuxIDMapping{}, hostUidmap...)\n\t\tfor i := range uidmap {\n\t\t\tuidmap[i].HostID = uidmap[i].ContainerID\n\t\t}\n\t}\n\tif len(gidmap) == 0 {\n\t\t// No GID mappings are configured for the container.  Borrow our parent's mappings.\n\t\tgidmap = append([]specs.LinuxIDMapping{}, hostGidmap...)\n\t\tfor i := range gidmap {\n\t\t\tgidmap[i].HostID = gidmap[i].ContainerID\n\t\t}\n\t}\n\n\t// Start the parent subprocess.\n\tcmd := unshare.Command(append([]string{runUsingChrootExecCommand}, spec.Process.Args...)...)\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr\n\tcmd.Dir = \"/\"\n\tcmd.Env = []string{fmt.Sprintf(\"LOGLEVEL=%d\", logrus.GetLevel())}\n\tcmd.UnshareFlags = syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS\n\trequestedUserNS := false\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tif ns.Type == specs.UserNamespace {\n\t\t\trequestedUserNS = true\n\t\t}\n\t}\n\tif len(spec.Linux.UIDMappings) > 0 || len(spec.Linux.GIDMappings) > 0 || requestedUserNS {\n\t\tcmd.UnshareFlags = cmd.UnshareFlags | syscall.CLONE_NEWUSER\n\t\tcmd.UidMappings = uidmap\n\t\tcmd.GidMappings = gidmap\n\t\tcmd.GidMappingsEnableSetgroups = true\n\t}\n\tif ctty != nil {\n\t\tcmd.Setsid = true\n\t\tcmd.Ctty = ctty\n\t}\n\tcmd.OOMScoreAdj = spec.Process.OOMScoreAdj\n\tcmd.ExtraFiles = append([]*os.File{preader}, cmd.ExtraFiles...)\n\tcmd.Hook = func(int) error {\n\t\tfor _, f := range closeOnceRunning {\n\t\t\tf.Close()\n\t\t}\n\t\treturn nil\n\t}\n\n\tlogrus.Debugf(\"Running %#v in %#v\", cmd.Cmd, cmd)\n\tconfwg.Add(1)\n\tgo func() {\n\t\t_, conferr = io.Copy(pwriter, bytes.NewReader(config))\n\t\tpwriter.Close()\n\t\tconfwg.Done()\n\t}()\n\terr = cmd.Run()\n\tconfwg.Wait()\n\tif err != nil {\n\t\tif exitError, ok := err.(*exec.ExitError); ok {\n\t\t\tif waitStatus, ok := exitError.ProcessState.Sys().(syscall.WaitStatus); ok {\n\t\t\t\tif waitStatus.Exited() {\n\t\t\t\t\tif waitStatus.ExitStatus() != 0 {\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited with status %d\\n\", waitStatus.ExitStatus())\n\t\t\t\t\t}\n\t\t\t\t\tos.Exit(waitStatus.ExitStatus())\n\t\t\t\t} else if waitStatus.Signaled() {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited on %s\\n\", waitStatus.Signal())\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintf(os.Stderr, \"process exited with error: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\treturn 0, nil\n}\n\n// main() for parent subprocess.  Its main job is to try to make our\n// environment look like the one described by the runtime configuration blob,\n// and then launch the intended command as a child.\nfunc runUsingChrootExecMain() {\n\targs := os.Args[1:]\n\tvar options runUsingChrootExecSubprocOptions\n\tvar err error\n\n\truntime.LockOSThread()\n\n\t// Set logging.\n\tif level := os.Getenv(\"LOGLEVEL\"); level != \"\" {\n\t\tif ll, err := strconv.Atoi(level); err == nil {\n\t\t\tlogrus.SetLevel(logrus.Level(ll))\n\t\t}\n\t\tos.Unsetenv(\"LOGLEVEL\")\n\t}\n\n\t// Unpack our configuration.\n\tconfPipe := os.NewFile(3, \"confpipe\")\n\tif confPipe == nil {\n\t\tfmt.Fprintf(os.Stderr, \"error reading options pipe\\n\")\n\t\tos.Exit(1)\n\t}\n\tdefer confPipe.Close()\n\tif err := json.NewDecoder(confPipe).Decode(&options); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error decoding options: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Set the hostname.  We're already in a distinct UTS namespace and are admins in the user\n\t// namespace which created it, so we shouldn't get a permissions error, but seccomp policy\n\t// might deny our attempt to call sethostname() anyway, so log a debug message for that.\n\tif options.Spec == nil || options.Spec.Process == nil {\n\t\tfmt.Fprintf(os.Stderr, \"invalid options spec passed in\\n\")\n\t\tos.Exit(1)\n\t}\n\n\tif options.Spec.Hostname != \"\" {\n\t\tif err := unix.Sethostname([]byte(options.Spec.Hostname)); err != nil {\n\t\t\tlogrus.Debugf(\"failed to set hostname %q for process: %v\", options.Spec.Hostname, err)\n\t\t}\n\t}\n\n\t// Try to chroot into the root.  Do this before we potentially block the syscall via the\n\t// seccomp profile.\n\tvar oldst, newst unix.Stat_t\n\tif err := unix.Stat(options.Spec.Root.Path, &oldst); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error stat()ing intended root directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Chdir(options.Spec.Root.Path); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chdir()ing to intended root directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Chroot(options.Spec.Root.Path); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chroot()ing into directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Stat(\"/\", &newst); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error stat()ing current root directory: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tif oldst.Dev != newst.Dev || oldst.Ino != newst.Ino {\n\t\tfmt.Fprintf(os.Stderr, \"unknown error chroot()ing into directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tlogrus.Debugf(\"chrooted into %q\", options.Spec.Root.Path)\n\n\t// not doing because it's still shared: creating devices\n\t// not doing because it's not applicable: setting annotations\n\t// not doing because it's still shared: setting sysctl settings\n\t// not doing because cgroupfs is read only: configuring control groups\n\t// -> this means we can use the freezer to make sure there aren't any lingering processes\n\t// -> this means we ignore cgroups-based controls\n\t// not doing because we don't set any in the config: running hooks\n\t// not doing because we don't set it in the config: setting rootfs read-only\n\t// not doing because we don't set it in the config: setting rootfs propagation\n\tlogrus.Debugf(\"setting apparmor profile\")\n\tif err = setApparmorProfile(options.Spec); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting apparmor profile for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tif err = setSelinuxLabel(options.Spec); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting SELinux label for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlogrus.Debugf(\"setting resource limits\")\n\tif err = setRlimits(options.Spec, false, false); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting process resource limits for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Try to change to the directory.\n\tcwd := options.Spec.Process.Cwd\n\tif !filepath.IsAbs(cwd) {\n\t\tcwd = \"/\" + cwd\n\t}\n\tcwd = filepath.Clean(cwd)\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chdir()ing into new root directory %q: %v\\n\", options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tif err := unix.Chdir(cwd); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error chdir()ing into directory %q under root %q: %v\\n\", cwd, options.Spec.Root.Path, err)\n\t\tos.Exit(1)\n\t}\n\tlogrus.Debugf(\"changed working directory to %q\", cwd)\n\n\t// Drop privileges.\n\tuser := options.Spec.Process.User\n\tif len(user.AdditionalGids) > 0 {\n\t\tgids := make([]int, len(user.AdditionalGids))\n\t\tfor i := range user.AdditionalGids {\n\t\t\tgids[i] = int(user.AdditionalGids[i])\n\t\t}\n\t\tlogrus.Debugf(\"setting supplemental groups\")\n\t\tif err = syscall.Setgroups(gids); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"error setting supplemental groups list: %v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t} else {\n\t\tsetgroups, _ := ioutil.ReadFile(\"/proc/self/setgroups\")\n\t\tif strings.Trim(string(setgroups), \"\\n\") != \"deny\" {\n\t\t\tlogrus.Debugf(\"clearing supplemental groups\")\n\t\t\tif err = syscall.Setgroups([]int{}); err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"error clearing supplemental groups list: %v\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t}\n\n\tlogrus.Debugf(\"setting gid\")\n\tif err = syscall.Setresgid(int(user.GID), int(user.GID), int(user.GID)); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting GID: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif err = setSeccomp(options.Spec); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting seccomp filter for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlogrus.Debugf(\"setting capabilities\")\n\tvar keepCaps []string\n\tif user.UID != 0 {\n\t\tkeepCaps = []string{\"CAP_SETUID\"}\n\t}\n\tif err := setCapabilities(options.Spec, keepCaps...); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting capabilities for process: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tlogrus.Debugf(\"setting uid\")\n\tif err = syscall.Setresuid(int(user.UID), int(user.UID), int(user.UID)); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error setting UID: %v\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Actually run the specified command.\n\tcmd := exec.Command(args[0], args[1:]...)\n\tcmd.Env = options.Spec.Process.Env\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr\n\tcmd.Dir = cwd\n\tlogrus.Debugf(\"Running %#v (PATH = %q)\", cmd, os.Getenv(\"PATH\"))\n\tif err = cmd.Run(); err != nil {\n\t\tif exitError, ok := err.(*exec.ExitError); ok {\n\t\t\tif waitStatus, ok := exitError.ProcessState.Sys().(syscall.WaitStatus); ok {\n\t\t\t\tif waitStatus.Exited() {\n\t\t\t\t\tif waitStatus.ExitStatus() != 0 {\n\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited with status %d\\n\", waitStatus.ExitStatus())\n\t\t\t\t\t}\n\t\t\t\t\tos.Exit(waitStatus.ExitStatus())\n\t\t\t\t} else if waitStatus.Signaled() {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"subprocess exited on %s\\n\", waitStatus.Signal())\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintf(os.Stderr, \"process exited with error: %v\", err)\n\t\tos.Exit(1)\n\t}\n}\n\n// logNamespaceDiagnostics knows which namespaces we want to create.\n// Output debug messages when that differs from what we're being asked to do.\nfunc logNamespaceDiagnostics(spec *specs.Spec) {\n\tsawMountNS := false\n\tsawUTSNS := false\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase specs.CgroupNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join cgroup namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create cgroup namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.IPCNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join IPC namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create IPC namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.MountNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join mount namespace %q, creating a new one\", ns.Path)\n\t\t\t}\n\t\t\tsawMountNS = true\n\t\tcase specs.NetworkNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join network namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create network namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.PIDNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join PID namespace, sorry about that\")\n\t\t\t} else {\n\t\t\t\tlogrus.Debugf(\"unable to create PID namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.UserNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join user namespace, sorry about that\")\n\t\t\t}\n\t\tcase specs.UTSNamespace:\n\t\t\tif ns.Path != \"\" {\n\t\t\t\tlogrus.Debugf(\"unable to join UTS namespace %q, creating a new one\", ns.Path)\n\t\t\t}\n\t\t\tsawUTSNS = true\n\t\t}\n\t}\n\tif !sawMountNS {\n\t\tlogrus.Debugf(\"mount namespace not requested, but creating a new one anyway\")\n\t}\n\tif !sawUTSNS {\n\t\tlogrus.Debugf(\"UTS namespace not requested, but creating a new one anyway\")\n\t}\n}\n\n// setApparmorProfile sets the apparmor profile for ourselves, and hopefully any child processes that we'll start.\nfunc setApparmorProfile(spec *specs.Spec) error {\n\tif !apparmor.IsEnabled() || spec.Process.ApparmorProfile == \"\" {\n\t\treturn nil\n\t}\n\tif err := apparmor.ApplyProfile(spec.Process.ApparmorProfile); err != nil {\n\t\treturn errors.Wrapf(err, \"error setting apparmor profile to %q\", spec.Process.ApparmorProfile)\n\t}\n\treturn nil\n}\n\n// setCapabilities sets capabilities for ourselves, to be more or less inherited by any processes that we'll start.\nfunc setCapabilities(spec *specs.Spec, keepCaps ...string) error {\n\tcurrentCaps, err := capability.NewPid2(0)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error reading capabilities of current process\")\n\t}\n\tif err := currentCaps.Load(); err != nil {\n\t\treturn errors.Wrapf(err, \"error loading capabilities\")\n\t}\n\tcaps, err := capability.NewPid2(0)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error reading capabilities of current process\")\n\t}\n\tcapMap := map[capability.CapType][]string{\n\t\tcapability.BOUNDING:    spec.Process.Capabilities.Bounding,\n\t\tcapability.EFFECTIVE:   spec.Process.Capabilities.Effective,\n\t\tcapability.INHERITABLE: []string{},\n\t\tcapability.PERMITTED:   spec.Process.Capabilities.Permitted,\n\t\tcapability.AMBIENT:     spec.Process.Capabilities.Ambient,\n\t}\n\tknownCaps := capability.List()\n\tnoCap := capability.Cap(-1)\n\tfor capType, capList := range capMap {\n\t\tfor _, capToSet := range capList {\n\t\t\tcap := noCap\n\t\t\tfor _, c := range knownCaps {\n\t\t\t\tif strings.EqualFold(\"CAP_\"+c.String(), capToSet) {\n\t\t\t\t\tcap = c\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cap == noCap {\n\t\t\t\treturn errors.Errorf(\"error mapping capability %q to a number\", capToSet)\n\t\t\t}\n\t\t\tcaps.Set(capType, cap)\n\t\t}\n\t\tfor _, capToSet := range keepCaps {\n\t\t\tcap := noCap\n\t\t\tfor _, c := range knownCaps {\n\t\t\t\tif strings.EqualFold(\"CAP_\"+c.String(), capToSet) {\n\t\t\t\t\tcap = c\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cap == noCap {\n\t\t\t\treturn errors.Errorf(\"error mapping capability %q to a number\", capToSet)\n\t\t\t}\n\t\t\tif currentCaps.Get(capType, cap) {\n\t\t\t\tcaps.Set(capType, cap)\n\t\t\t}\n\t\t}\n\t}\n\tif err = caps.Apply(capability.CAPS | capability.BOUNDS | capability.AMBS); err != nil {\n\t\treturn errors.Wrapf(err, \"error setting capabilities\")\n\t}\n\treturn nil\n}\n\n// parses the resource limits for ourselves and any processes that\n// we'll start into a format that's more in line with the kernel APIs\nfunc parseRlimits(spec *specs.Spec) (map[int]unix.Rlimit, error) {\n\tif spec.Process == nil {\n\t\treturn nil, nil\n\t}\n\tparsed := make(map[int]unix.Rlimit)\n\tfor _, limit := range spec.Process.Rlimits {\n\t\tresource, recognized := rlimitsMap[strings.ToUpper(limit.Type)]\n\t\tif !recognized {\n\t\t\treturn nil, errors.Errorf(\"error parsing limit type %q\", limit.Type)\n\t\t}\n\t\tparsed[resource] = unix.Rlimit{Cur: limit.Soft, Max: limit.Hard}\n\t}\n\treturn parsed, nil\n}\n\n// setRlimits sets any resource limits that we want to apply to processes that\n// we'll start.\nfunc setRlimits(spec *specs.Spec, onlyLower, onlyRaise bool) error {\n\tlimits, err := parseRlimits(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor resource, desired := range limits {\n\t\tvar current unix.Rlimit\n\t\tif err := unix.Getrlimit(resource, &current); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error reading %q limit\", rlimitsReverseMap[resource])\n\t\t}\n\t\tif desired.Max > current.Max && onlyLower {\n\t\t\t// this would raise a hard limit, and we're only here to lower them\n\t\t\tcontinue\n\t\t}\n\t\tif desired.Max < current.Max && onlyRaise {\n\t\t\t// this would lower a hard limit, and we're only here to raise them\n\t\t\tcontinue\n\t\t}\n\t\tif err := unix.Setrlimit(resource, &desired); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error setting %q limit to soft=%d,hard=%d (was soft=%d,hard=%d)\", rlimitsReverseMap[resource], desired.Cur, desired.Max, current.Cur, current.Max)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc makeReadOnly(mntpoint string, flags uintptr) error {\n\tvar fs unix.Statfs_t\n\t// Make sure it's read-only.\n\tif err := unix.Statfs(mntpoint, &fs); err != nil {\n\t\treturn errors.Wrapf(err, \"error checking if directory %q was bound read-only\", mntpoint)\n\t}\n\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\tif err := unix.Mount(mntpoint, mntpoint, \"bind\", flags|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error remounting %s in mount namespace read-only\", mntpoint)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc isDevNull(dev os.FileInfo) bool {\n\tif dev.Mode()&os.ModeCharDevice != 0 {\n\t\tstat, _ := dev.Sys().(*syscall.Stat_t)\n\t\tnullStat := syscall.Stat_t{}\n\t\tif err := syscall.Stat(os.DevNull, &nullStat); err != nil {\n\t\t\tlogrus.Warnf(\"unable to stat /dev/null: %v\", err)\n\t\t\treturn false\n\t\t}\n\t\tif stat.Rdev == nullStat.Rdev {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// setupChrootBindMounts actually bind mounts things under the rootfs, and returns a\n// callback that will clean up its work.\nfunc setupChrootBindMounts(spec *specs.Spec, bundlePath string) (undoBinds func() error, err error) {\n\tvar fs unix.Statfs_t\n\tundoBinds = func() error {\n\t\tif err2 := unix.Unmount(spec.Root.Path, unix.MNT_DETACH); err2 != nil {\n\t\t\tretries := 0\n\t\t\tfor (err2 == unix.EBUSY || err2 == unix.EAGAIN) && retries < 50 {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\terr2 = unix.Unmount(spec.Root.Path, unix.MNT_DETACH)\n\t\t\t\tretries++\n\t\t\t}\n\t\t\tif err2 != nil {\n\t\t\t\tlogrus.Warnf(\"pkg/chroot: error unmounting %q (retried %d times): %v\", spec.Root.Path, retries, err2)\n\t\t\t\tif err == nil {\n\t\t\t\t\terr = err2\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\t// Now bind mount all of those things to be under the rootfs's location in this\n\t// mount namespace.\n\tcommonFlags := uintptr(unix.MS_BIND | unix.MS_REC | unix.MS_PRIVATE)\n\tbindFlags := commonFlags | unix.MS_NODEV\n\tdevFlags := commonFlags | unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_RDONLY\n\tprocFlags := devFlags | unix.MS_NODEV\n\tsysFlags := devFlags | unix.MS_NODEV\n\n\t// Bind /dev read-only.\n\tsubDev := filepath.Join(spec.Root.Path, \"/dev\")\n\tif err := unix.Mount(\"/dev\", subDev, \"bind\", devFlags, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\terr = os.Mkdir(subDev, 0755)\n\t\t\tif err == nil {\n\t\t\t\terr = unix.Mount(\"/dev\", subDev, \"bind\", devFlags, \"\")\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting /dev from host into mount namespace\")\n\t\t}\n\t}\n\t// Make sure it's read-only.\n\tif err = unix.Statfs(subDev, &fs); err != nil {\n\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was bound read-only\", subDev)\n\t}\n\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\tif err := unix.Mount(subDev, subDev, \"bind\", devFlags|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error remounting /dev in mount namespace read-only\")\n\t\t}\n\t}\n\tlogrus.Debugf(\"bind mounted %q to %q\", \"/dev\", filepath.Join(spec.Root.Path, \"/dev\"))\n\n\t// Bind /proc read-only.\n\tsubProc := filepath.Join(spec.Root.Path, \"/proc\")\n\tif err := unix.Mount(\"/proc\", subProc, \"bind\", procFlags, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\terr = os.Mkdir(subProc, 0755)\n\t\t\tif err == nil {\n\t\t\t\terr = unix.Mount(\"/proc\", subProc, \"bind\", procFlags, \"\")\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting /proc from host into mount namespace\")\n\t\t}\n\t}\n\tlogrus.Debugf(\"bind mounted %q to %q\", \"/proc\", filepath.Join(spec.Root.Path, \"/proc\"))\n\n\t// Bind /sys read-only.\n\tsubSys := filepath.Join(spec.Root.Path, \"/sys\")\n\tif err := unix.Mount(\"/sys\", subSys, \"bind\", sysFlags, \"\"); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\terr = os.Mkdir(subSys, 0755)\n\t\t\tif err == nil {\n\t\t\t\terr = unix.Mount(\"/sys\", subSys, \"bind\", sysFlags, \"\")\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting /sys from host into mount namespace\")\n\t\t}\n\t}\n\tif err := makeReadOnly(subSys, sysFlags); err != nil {\n\t\treturn undoBinds, err\n\t}\n\n\tmnts, _ := mount.GetMounts()\n\tfor _, m := range mnts {\n\t\tif !strings.HasPrefix(m.Mountpoint, \"/sys/\") &&\n\t\t\tm.Mountpoint != \"/sys\" {\n\t\t\tcontinue\n\t\t}\n\t\tsubSys := filepath.Join(spec.Root.Path, m.Mountpoint)\n\t\tif err := unix.Mount(m.Mountpoint, subSys, \"bind\", sysFlags, \"\"); err != nil {\n\t\t\tmsg := fmt.Sprintf(\"could not bind mount %q, skipping: %v\", m.Mountpoint, err)\n\t\t\tif strings.HasPrefix(m.Mountpoint, \"/sys\") {\n\t\t\t\tlogrus.Infof(msg)\n\t\t\t} else {\n\t\t\t\tlogrus.Warningf(msg)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err := makeReadOnly(subSys, sysFlags); err != nil {\n\t\t\treturn undoBinds, err\n\t\t}\n\t}\n\tlogrus.Debugf(\"bind mounted %q to %q\", \"/sys\", filepath.Join(spec.Root.Path, \"/sys\"))\n\n\t// Bind mount in everything we've been asked to mount.\n\tfor _, m := range spec.Mounts {\n\t\t// Skip anything that we just mounted.\n\t\tswitch m.Destination {\n\t\tcase \"/dev\", \"/proc\", \"/sys\":\n\t\t\tlogrus.Debugf(\"already bind mounted %q on %q\", m.Destination, filepath.Join(spec.Root.Path, m.Destination))\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tif strings.HasPrefix(m.Destination, \"/dev/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.HasPrefix(m.Destination, \"/proc/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.HasPrefix(m.Destination, \"/sys/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// Skip anything that isn't a bind or tmpfs mount.\n\t\tif m.Type != \"bind\" && m.Type != \"tmpfs\" && m.Type != \"overlay\" {\n\t\t\tlogrus.Debugf(\"skipping mount of type %q on %q\", m.Type, m.Destination)\n\t\t\tcontinue\n\t\t}\n\t\t// If the target is there, we can just mount it.\n\t\tvar srcinfo os.FileInfo\n\t\tswitch m.Type {\n\t\tcase \"bind\":\n\t\t\tsrcinfo, err = os.Stat(m.Source)\n\t\t\tif err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining %q for mounting in mount namespace\", m.Source)\n\t\t\t}\n\t\tcase \"overlay\":\n\t\t\tfallthrough\n\t\tcase \"tmpfs\":\n\t\t\tsrcinfo, err = os.Stat(\"/\")\n\t\t\tif err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining / to use as a template for a %s\", m.Type)\n\t\t\t}\n\t\t}\n\t\ttarget := filepath.Join(spec.Root.Path, m.Destination)\n\t\t// Check if target is a symlink\n\t\tstat, err := os.Lstat(target)\n\t\t// If target is a symlink, follow the link and ensure the destination exists\n\t\tif err == nil && stat != nil && (stat.Mode()&os.ModeSymlink != 0) {\n\t\t\ttarget, err = copier.Eval(spec.Root.Path, m.Destination, copier.EvalOptions{})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"evaluating symlink %q\", target)\n\t\t\t}\n\t\t\t// Stat the destination of the evaluated symlink\n\t\t\t_, err = os.Stat(target)\n\t\t}\n\t\tif err != nil {\n\t\t\t// If the target can't be stat()ted, check the error.\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining %q for mounting in mount namespace\", target)\n\t\t\t}\n\t\t\t// The target isn't there yet, so create it.\n\t\t\tif srcinfo.IsDir() {\n\t\t\t\tif err = os.MkdirAll(target, 0755); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error creating mountpoint %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err = os.MkdirAll(filepath.Dir(target), 0755); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error ensuring parent of mountpoint %q (%q) is present in mount namespace\", target, filepath.Dir(target))\n\t\t\t\t}\n\t\t\t\tvar file *os.File\n\t\t\t\tif file, err = os.OpenFile(target, os.O_WRONLY|os.O_CREATE, 0755); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error creating mountpoint %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t\tfile.Close()\n\t\t\t}\n\t\t}\n\t\trequestFlags := bindFlags\n\t\texpectedFlags := uintptr(0)\n\t\tfor _, option := range m.Options {\n\t\t\tswitch option {\n\t\t\tcase \"nodev\":\n\t\t\t\trequestFlags |= unix.MS_NODEV\n\t\t\t\texpectedFlags |= unix.ST_NODEV\n\t\t\tcase \"dev\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_NODEV)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_NODEV)\n\t\t\tcase \"noexec\":\n\t\t\t\trequestFlags |= unix.MS_NOEXEC\n\t\t\t\texpectedFlags |= unix.ST_NOEXEC\n\t\t\tcase \"exec\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_NOEXEC)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_NOEXEC)\n\t\t\tcase \"nosuid\":\n\t\t\t\trequestFlags |= unix.MS_NOSUID\n\t\t\t\texpectedFlags |= unix.ST_NOSUID\n\t\t\tcase \"suid\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_NOSUID)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_NOSUID)\n\t\t\tcase \"ro\":\n\t\t\t\trequestFlags |= unix.MS_RDONLY\n\t\t\t\texpectedFlags |= unix.ST_RDONLY\n\t\t\tcase \"rw\":\n\t\t\t\trequestFlags &= ^uintptr(unix.MS_RDONLY)\n\t\t\t\texpectedFlags &= ^uintptr(unix.ST_RDONLY)\n\t\t\t}\n\t\t}\n\t\tswitch m.Type {\n\t\tcase \"bind\":\n\t\t\t// Do the bind mount.\n\t\t\tlogrus.Debugf(\"bind mounting %q on %q\", m.Destination, filepath.Join(spec.Root.Path, m.Destination))\n\t\t\tif err := unix.Mount(m.Source, target, \"\", requestFlags, \"\"); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting %q from host to %q in mount namespace (%q)\", m.Source, m.Destination, target)\n\t\t\t}\n\t\t\tlogrus.Debugf(\"bind mounted %q to %q\", m.Source, target)\n\t\tcase \"tmpfs\":\n\t\t\t// Mount a tmpfs.\n\t\t\tif err := mount.Mount(m.Source, target, m.Type, strings.Join(append(m.Options, \"private\"), \",\")); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error mounting tmpfs to %q in mount namespace (%q, %q)\", m.Destination, target, strings.Join(m.Options, \",\"))\n\t\t\t}\n\t\t\tlogrus.Debugf(\"mounted a tmpfs to %q\", target)\n\t\tcase \"overlay\":\n\t\t\t// Mount a overlay.\n\t\t\tif err := mount.Mount(m.Source, target, m.Type, strings.Join(append(m.Options, \"private\"), \",\")); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error mounting overlay to %q in mount namespace (%q, %q)\", m.Destination, target, strings.Join(m.Options, \",\"))\n\t\t\t}\n\t\t\tlogrus.Debugf(\"mounted a overlay to %q\", target)\n\t\t}\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was bound read-only\", target)\n\t\t}\n\t\tif uintptr(fs.Flags)&expectedFlags != expectedFlags {\n\t\t\tif err := unix.Mount(target, target, \"bind\", requestFlags|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error remounting %q in mount namespace with expected flags\", target)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set up any read-only paths that we need to.  If we're running inside\n\t// of a container, some of these locations will already be read-only.\n\tfor _, roPath := range spec.Linux.ReadonlyPaths {\n\t\tr := filepath.Join(spec.Root.Path, roPath)\n\t\ttarget, err := filepath.EvalSymlinks(r)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking %q for symlinks before marking it read-only\", r)\n\t\t}\n\t\t// Check if the location is already read-only.\n\t\tvar fs unix.Statfs_t\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q is already read-only\", target)\n\t\t}\n\t\tif fs.Flags&unix.ST_RDONLY != 0 {\n\t\t\tcontinue\n\t\t}\n\t\t// Mount the location over itself, so that we can remount it as read-only.\n\t\troFlags := uintptr(unix.MS_NODEV | unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_RDONLY)\n\t\tif err := unix.Mount(target, target, \"\", roFlags|unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error bind mounting %q onto itself in preparation for making it read-only\", target)\n\t\t}\n\t\t// Remount the location read-only.\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was bound read-only\", target)\n\t\t}\n\t\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\t\tif err := unix.Mount(target, target, \"\", roFlags|unix.MS_BIND|unix.MS_REMOUNT, \"\"); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error remounting %q in mount namespace read-only\", target)\n\t\t\t}\n\t\t}\n\t\t// Check again.\n\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was remounted read-only\", target)\n\t\t}\n\t\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error verifying that %q in mount namespace was remounted read-only\", target)\n\t\t}\n\t}\n\n\t// Create an empty directory for to use for masking directories.\n\troEmptyDir := filepath.Join(bundlePath, \"empty\")\n\tif len(spec.Linux.MaskedPaths) > 0 {\n\t\tif err := os.Mkdir(roEmptyDir, 0700); err != nil {\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error creating empty directory %q\", roEmptyDir)\n\t\t}\n\t}\n\n\t// Set up any masked paths that we need to.  If we're running inside of\n\t// a container, some of these locations will already be read-only tmpfs\n\t// filesystems or bind mounted to os.DevNull.  If we're not running\n\t// inside of a container, and nobody else has done that, we'll do it.\n\tfor _, masked := range spec.Linux.MaskedPaths {\n\t\tt := filepath.Join(spec.Root.Path, masked)\n\t\ttarget, err := filepath.EvalSymlinks(t)\n\t\tif err != nil {\n\t\t\ttarget = t\n\t\t}\n\t\t// Get some info about the target.\n\t\ttargetinfo, err := os.Stat(target)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\t// No target, no problem.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn undoBinds, errors.Wrapf(err, \"error examining %q for masking in mount namespace\", target)\n\t\t}\n\t\tif targetinfo.IsDir() {\n\t\t\t// The target's a directory.  Check if it's a read-only filesystem.\n\t\t\tvar statfs unix.Statfs_t\n\t\t\tif err = unix.Statfs(target, &statfs); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q is a mountpoint\", target)\n\t\t\t}\n\t\t\tisReadOnly := statfs.Flags&unix.MS_RDONLY != 0\n\t\t\t// Check if any of the IDs we're mapping could read it.\n\t\t\tvar stat unix.Stat_t\n\t\t\tif err = unix.Stat(target, &stat); err != nil {\n\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking permissions on directory %q\", target)\n\t\t\t}\n\t\t\tisAccessible := false\n\t\t\tif stat.Mode&unix.S_IROTH|unix.S_IXOTH != 0 {\n\t\t\t\tisAccessible = true\n\t\t\t}\n\t\t\tif !isAccessible && stat.Mode&unix.S_IROTH|unix.S_IXOTH != 0 {\n\t\t\t\tif len(spec.Linux.GIDMappings) > 0 {\n\t\t\t\t\tfor _, mapping := range spec.Linux.GIDMappings {\n\t\t\t\t\t\tif stat.Gid >= mapping.ContainerID && stat.Gid < mapping.ContainerID+mapping.Size {\n\t\t\t\t\t\t\tisAccessible = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !isAccessible && stat.Mode&unix.S_IRUSR|unix.S_IXUSR != 0 {\n\t\t\t\tif len(spec.Linux.UIDMappings) > 0 {\n\t\t\t\t\tfor _, mapping := range spec.Linux.UIDMappings {\n\t\t\t\t\t\tif stat.Uid >= mapping.ContainerID && stat.Uid < mapping.ContainerID+mapping.Size {\n\t\t\t\t\t\t\tisAccessible = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if it's empty.\n\t\t\thasContent := false\n\t\t\tdirectory, err := os.Open(target)\n\t\t\tif err != nil {\n\t\t\t\tif !os.IsPermission(err) {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error opening directory %q\", target)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames, err := directory.Readdirnames(0)\n\t\t\t\tdirectory.Close()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error reading contents of directory %q\", target)\n\t\t\t\t}\n\t\t\t\thasContent = false\n\t\t\t\tfor _, name := range names {\n\t\t\t\t\tswitch name {\n\t\t\t\t\tcase \".\", \"..\":\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tdefault:\n\t\t\t\t\t\thasContent = true\n\t\t\t\t\t}\n\t\t\t\t\tif hasContent {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The target's a directory, so read-only bind mount an empty directory on it.\n\t\t\troFlags := uintptr(syscall.MS_BIND | syscall.MS_NOSUID | syscall.MS_NODEV | syscall.MS_NOEXEC | syscall.MS_RDONLY)\n\t\t\tif !isReadOnly || (hasContent && isAccessible) {\n\t\t\t\tif err = unix.Mount(roEmptyDir, target, \"bind\", roFlags, \"\"); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error masking directory %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t\tif err = unix.Statfs(target, &fs); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error checking if directory %q was mounted read-only in mount namespace\", target)\n\t\t\t\t}\n\t\t\t\tif fs.Flags&unix.ST_RDONLY == 0 {\n\t\t\t\t\tif err = unix.Mount(target, target, \"\", roFlags|syscall.MS_REMOUNT, \"\"); err != nil {\n\t\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error making sure directory %q in mount namespace is read only\", target)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If the target's is not a directory or os.DevNull, bind mount os.DevNull over it.\n\t\t\tif !isDevNull(targetinfo) {\n\t\t\t\tif err = unix.Mount(os.DevNull, target, \"\", uintptr(syscall.MS_BIND|syscall.MS_RDONLY|syscall.MS_PRIVATE), \"\"); err != nil {\n\t\t\t\t\treturn undoBinds, errors.Wrapf(err, \"error masking non-directory %q in mount namespace\", target)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn undoBinds, nil\n}\n", "//go:build linux\n// +build linux\n\npackage buildah\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/bind\"\n\t\"github.com/containers/buildah/chroot\"\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal\"\n\tinternalParse \"github.com/containers/buildah/internal/parse\"\n\tinternalUtil \"github.com/containers/buildah/internal/util\"\n\t\"github.com/containers/buildah/pkg/overlay\"\n\t\"github.com/containers/buildah/pkg/parse\"\n\t\"github.com/containers/buildah/pkg/sshagent\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/common/libnetwork/network\"\n\tnettypes \"github.com/containers/common/libnetwork/types\"\n\t\"github.com/containers/common/pkg/capabilities\"\n\t\"github.com/containers/common/pkg/cgroups\"\n\t\"github.com/containers/common/pkg/chown\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/common/pkg/subscriptions\"\n\timagetypes \"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\t\"github.com/containers/storage/pkg/reexec\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\t\"github.com/containers/storage/pkg/unshare\"\n\tstoragetypes \"github.com/containers/storage/types\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/docker/libnetwork/resolvconf\"\n\t\"github.com/docker/libnetwork/types\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\tspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\t\"golang.org/x/term\"\n)\n\n// ContainerDevices is an alias for a slice of github.com/opencontainers/runc/libcontainer/configs.Device structures.\ntype ContainerDevices define.ContainerDevices\n\nfunc setChildProcess() error {\n\tif err := unix.Prctl(unix.PR_SET_CHILD_SUBREAPER, uintptr(1), 0, 0, 0); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"prctl(PR_SET_CHILD_SUBREAPER, 1): %v\\n\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Run runs the specified command in the container's root filesystem.\nfunc (b *Builder) Run(command []string, options RunOptions) error {\n\tp, err := ioutil.TempDir(\"\", define.Package)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// On some hosts like AH, /tmp is a symlink and we need an\n\t// absolute path.\n\tpath, err := filepath.EvalSymlinks(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogrus.Debugf(\"using %q to hold bundle data\", path)\n\tdefer func() {\n\t\tif err2 := os.RemoveAll(path); err2 != nil {\n\t\t\toptions.Logger.Error(err2)\n\t\t}\n\t}()\n\n\tgp, err := generate.New(\"linux\")\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error generating new 'linux' runtime spec\")\n\t}\n\tg := &gp\n\n\tisolation := options.Isolation\n\tif isolation == define.IsolationDefault {\n\t\tisolation = b.Isolation\n\t\tif isolation == define.IsolationDefault {\n\t\t\tisolation = define.IsolationOCI\n\t\t}\n\t}\n\tif err := checkAndOverrideIsolationOptions(isolation, &options); err != nil {\n\t\treturn err\n\t}\n\n\t// hardwire the environment to match docker build to avoid subtle and hard-to-debug differences due to containers.conf\n\tb.configureEnvironment(g, options, []string{\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"})\n\n\tif b.CommonBuildOpts == nil {\n\t\treturn errors.Errorf(\"Invalid format on container you must recreate the container\")\n\t}\n\n\tif err := addCommonOptsToSpec(b.CommonBuildOpts, g); err != nil {\n\t\treturn err\n\t}\n\n\tif options.WorkingDir != \"\" {\n\t\tg.SetProcessCwd(options.WorkingDir)\n\t} else if b.WorkDir() != \"\" {\n\t\tg.SetProcessCwd(b.WorkDir())\n\t}\n\tsetupSelinux(g, b.ProcessLabel, b.MountLabel)\n\tmountPoint, err := b.Mount(b.MountLabel)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error mounting container %q\", b.ContainerID)\n\t}\n\tdefer func() {\n\t\tif err := b.Unmount(); err != nil {\n\t\t\toptions.Logger.Errorf(\"error unmounting container: %v\", err)\n\t\t}\n\t}()\n\tg.SetRootPath(mountPoint)\n\tif len(command) > 0 {\n\t\tcommand = runLookupPath(g, command)\n\t\tg.SetProcessArgs(command)\n\t} else {\n\t\tg.SetProcessArgs(nil)\n\t}\n\n\tfor _, d := range b.Devices {\n\t\tsDev := spec.LinuxDevice{\n\t\t\tType:     string(d.Type),\n\t\t\tPath:     d.Path,\n\t\t\tMajor:    d.Major,\n\t\t\tMinor:    d.Minor,\n\t\t\tFileMode: &d.FileMode,\n\t\t\tUID:      &d.Uid,\n\t\t\tGID:      &d.Gid,\n\t\t}\n\t\tg.AddDevice(sDev)\n\t\tg.AddLinuxResourcesDevice(true, string(d.Type), &d.Major, &d.Minor, string(d.Permissions))\n\t}\n\n\tsetupMaskedPaths(g)\n\tsetupReadOnlyPaths(g)\n\n\tsetupTerminal(g, options.Terminal, options.TerminalSize)\n\n\tconfigureNetwork, configureNetworks, err := b.configureNamespaces(g, &options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// rootless and networks are not supported\n\tif len(configureNetworks) > 0 && isolation == IsolationOCIRootless {\n\t\treturn errors.New(\"cannot use networks as rootless\")\n\t}\n\n\thomeDir, err := b.configureUIDGID(g, mountPoint, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tg.SetProcessApparmorProfile(b.CommonBuildOpts.ApparmorProfile)\n\n\t// Now grab the spec from the generator.  Set the generator to nil so that future contributors\n\t// will quickly be able to tell that they're supposed to be modifying the spec directly from here.\n\tspec := g.Config\n\tg = nil\n\n\t// Set the seccomp configuration using the specified profile name.  Some syscalls are\n\t// allowed if certain capabilities are to be granted (example: CAP_SYS_CHROOT and chroot),\n\t// so we sorted out the capabilities lists first.\n\tif err = setupSeccomp(spec, b.CommonBuildOpts.SeccompProfilePath); err != nil {\n\t\treturn err\n\t}\n\n\t// Figure out who owns files that will appear to be owned by UID/GID 0 in the container.\n\trootUID, rootGID, err := util.GetHostRootIDs(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\trootIDPair := &idtools.IDPair{UID: int(rootUID), GID: int(rootGID)}\n\n\tmode := os.FileMode(0755)\n\tcoptions := copier.MkdirOptions{\n\t\tChownNew: rootIDPair,\n\t\tChmodNew: &mode,\n\t}\n\tif err := copier.Mkdir(mountPoint, filepath.Join(mountPoint, spec.Process.Cwd), coptions); err != nil {\n\t\treturn err\n\t}\n\n\tbindFiles := make(map[string]string)\n\tnamespaceOptions := append(b.NamespaceOptions, options.NamespaceOptions...)\n\tvolumes := b.Volumes()\n\n\tif !contains(volumes, \"/etc/hosts\") {\n\t\thostFile, err := b.generateHosts(path, spec.Hostname, b.CommonBuildOpts.AddHost, rootIDPair)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Only bind /etc/hosts if there's a network\n\t\tif options.ConfigureNetwork != define.NetworkDisabled {\n\t\t\tbindFiles[\"/etc/hosts\"] = hostFile\n\t\t}\n\t}\n\n\tif !(contains(volumes, \"/etc/resolv.conf\") || (len(b.CommonBuildOpts.DNSServers) == 1 && strings.ToLower(b.CommonBuildOpts.DNSServers[0]) == \"none\")) {\n\t\tresolvFile, err := b.addResolvConf(path, rootIDPair, b.CommonBuildOpts.DNSServers, b.CommonBuildOpts.DNSSearch, b.CommonBuildOpts.DNSOptions, namespaceOptions)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Only bind /etc/resolv.conf if there's a network\n\t\tif options.ConfigureNetwork != define.NetworkDisabled {\n\t\t\tbindFiles[\"/etc/resolv.conf\"] = resolvFile\n\t\t}\n\t}\n\t// Empty file, so no need to recreate if it exists\n\tif _, ok := bindFiles[\"/run/.containerenv\"]; !ok {\n\t\tcontainerenvPath := filepath.Join(path, \"/run/.containerenv\")\n\t\tif err = os.MkdirAll(filepath.Dir(containerenvPath), 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trootless := 0\n\t\tif unshare.IsRootless() {\n\t\t\trootless = 1\n\t\t}\n\t\t// Populate the .containerenv with container information\n\t\tcontainerenv := fmt.Sprintf(`\\\nengine=\"buildah-%s\"\nname=%q\nid=%q\nimage=%q\nimageid=%q\nrootless=%d\n`, define.Version, b.Container, b.ContainerID, b.FromImage, b.FromImageID, rootless)\n\n\t\tif err = ioutils.AtomicWriteFile(containerenvPath, []byte(containerenv), 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := label.Relabel(containerenvPath, b.MountLabel, false); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tbindFiles[\"/run/.containerenv\"] = containerenvPath\n\t}\n\trunArtifacts, err := b.setupMounts(options.SystemContext, mountPoint, spec, path, options.Mounts, bindFiles, volumes, b.CommonBuildOpts.Volumes, b.CommonBuildOpts.ShmSize, namespaceOptions, options.Secrets, options.SSHSources, options.RunMounts, options.ContextDir, options.StageMountPoints)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error resolving mountpoints for container %q\", b.ContainerID)\n\t}\n\tif runArtifacts.SSHAuthSock != \"\" {\n\t\tsshenv := \"SSH_AUTH_SOCK=\" + runArtifacts.SSHAuthSock\n\t\tspec.Process.Env = append(spec.Process.Env, sshenv)\n\t}\n\n\t// following run was called from `buildah run`\n\t// and some images were mounted for this run\n\t// add them to cleanup artifacts\n\tif len(options.ExternalImageMounts) > 0 {\n\t\trunArtifacts.MountedImages = append(runArtifacts.MountedImages, options.ExternalImageMounts...)\n\t}\n\n\tdefer func() {\n\t\tif err := b.cleanupRunMounts(options.SystemContext, mountPoint, runArtifacts); err != nil {\n\t\t\toptions.Logger.Errorf(\"unable to cleanup run mounts %v\", err)\n\t\t}\n\t}()\n\n\tdefer b.cleanupTempVolumes()\n\n\tswitch isolation {\n\tcase define.IsolationOCI:\n\t\tvar moreCreateArgs []string\n\t\tif options.NoPivot {\n\t\t\tmoreCreateArgs = []string{\"--no-pivot\"}\n\t\t} else {\n\t\t\tmoreCreateArgs = nil\n\t\t}\n\t\terr = b.runUsingRuntimeSubproc(isolation, options, configureNetwork, configureNetworks, moreCreateArgs, spec, mountPoint, path, define.Package+\"-\"+filepath.Base(path))\n\tcase IsolationChroot:\n\t\terr = chroot.RunUsingChroot(spec, path, homeDir, options.Stdin, options.Stdout, options.Stderr)\n\tcase IsolationOCIRootless:\n\t\tmoreCreateArgs := []string{\"--no-new-keyring\"}\n\t\tif options.NoPivot {\n\t\t\tmoreCreateArgs = append(moreCreateArgs, \"--no-pivot\")\n\t\t}\n\t\tif err := setupRootlessSpecChanges(spec, path, b.CommonBuildOpts.ShmSize); err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = b.runUsingRuntimeSubproc(isolation, options, configureNetwork, configureNetworks, moreCreateArgs, spec, mountPoint, path, define.Package+\"-\"+filepath.Base(path))\n\tdefault:\n\t\terr = errors.Errorf(\"don't know how to run this command\")\n\t}\n\treturn err\n}\n\nfunc addCommonOptsToSpec(commonOpts *define.CommonBuildOptions, g *generate.Generator) error {\n\t// Resources - CPU\n\tif commonOpts.CPUPeriod != 0 {\n\t\tg.SetLinuxResourcesCPUPeriod(commonOpts.CPUPeriod)\n\t}\n\tif commonOpts.CPUQuota != 0 {\n\t\tg.SetLinuxResourcesCPUQuota(commonOpts.CPUQuota)\n\t}\n\tif commonOpts.CPUShares != 0 {\n\t\tg.SetLinuxResourcesCPUShares(commonOpts.CPUShares)\n\t}\n\tif commonOpts.CPUSetCPUs != \"\" {\n\t\tg.SetLinuxResourcesCPUCpus(commonOpts.CPUSetCPUs)\n\t}\n\tif commonOpts.CPUSetMems != \"\" {\n\t\tg.SetLinuxResourcesCPUMems(commonOpts.CPUSetMems)\n\t}\n\n\t// Resources - Memory\n\tif commonOpts.Memory != 0 {\n\t\tg.SetLinuxResourcesMemoryLimit(commonOpts.Memory)\n\t}\n\tif commonOpts.MemorySwap != 0 {\n\t\tg.SetLinuxResourcesMemorySwap(commonOpts.MemorySwap)\n\t}\n\n\t// cgroup membership\n\tif commonOpts.CgroupParent != \"\" {\n\t\tg.SetLinuxCgroupsPath(commonOpts.CgroupParent)\n\t}\n\n\tdefaultContainerConfig, err := config.Default()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"failed to get container config\")\n\t}\n\t// Other process resource limits\n\tif err := addRlimits(commonOpts.Ulimit, g, defaultContainerConfig.Containers.DefaultUlimits); err != nil {\n\t\treturn err\n\t}\n\n\tlogrus.Debugf(\"Resources: %#v\", commonOpts)\n\treturn nil\n}\n\nfunc runSetupBuiltinVolumes(mountLabel, mountPoint, containerDir string, builtinVolumes []string, rootUID, rootGID int) ([]specs.Mount, error) {\n\tvar mounts []specs.Mount\n\thostOwner := idtools.IDPair{UID: rootUID, GID: rootGID}\n\t// Add temporary copies of the contents of volume locations at the\n\t// volume locations, unless we already have something there.\n\tfor _, volume := range builtinVolumes {\n\t\tvolumePath := filepath.Join(containerDir, \"buildah-volumes\", digest.Canonical.FromString(volume).Hex())\n\t\tinitializeVolume := false\n\t\t// If we need to, create the directory that we'll use to hold\n\t\t// the volume contents.  If we do need to create it, then we'll\n\t\t// need to populate it, too, so make a note of that.\n\t\tif _, err := os.Stat(volumePath); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogrus.Debugf(\"setting up built-in volume path at %q for %q\", volumePath, volume)\n\t\t\tif err = os.MkdirAll(volumePath, 0755); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err = label.Relabel(volumePath, mountLabel, false); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tinitializeVolume = true\n\t\t}\n\t\t// Make sure the volume exists in the rootfs and read its attributes.\n\t\tcreateDirPerms := os.FileMode(0755)\n\t\terr := copier.Mkdir(mountPoint, filepath.Join(mountPoint, volume), copier.MkdirOptions{\n\t\t\tChownNew: &hostOwner,\n\t\t\tChmodNew: &createDirPerms,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"ensuring volume path %q\", filepath.Join(mountPoint, volume))\n\t\t}\n\t\tsrcPath, err := copier.Eval(mountPoint, filepath.Join(mountPoint, volume), copier.EvalOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"evaluating path %q\", srcPath)\n\t\t}\n\t\tstat, err := os.Stat(srcPath)\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\t// If we need to populate the mounted volume's contents with\n\t\t// content from the rootfs, set it up now.\n\t\tif initializeVolume {\n\t\t\tif err = os.Chmod(volumePath, stat.Mode().Perm()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err = os.Chown(volumePath, int(stat.Sys().(*syscall.Stat_t).Uid), int(stat.Sys().(*syscall.Stat_t).Gid)); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogrus.Debugf(\"populating directory %q for volume %q using contents of %q\", volumePath, volume, srcPath)\n\t\t\tif err = extractWithTar(mountPoint, srcPath, volumePath); err != nil && !os.IsNotExist(errors.Cause(err)) {\n\t\t\t\treturn nil, errors.Wrapf(err, \"error populating directory %q for volume %q using contents of %q\", volumePath, volume, srcPath)\n\t\t\t}\n\t\t}\n\t\t// Add the bind mount.\n\t\tmounts = append(mounts, specs.Mount{\n\t\t\tSource:      volumePath,\n\t\t\tDestination: volume,\n\t\t\tType:        \"bind\",\n\t\t\tOptions:     []string{\"bind\"},\n\t\t})\n\t}\n\treturn mounts, nil\n}\n\nfunc (b *Builder) setupMounts(context *imagetypes.SystemContext, mountPoint string, spec *specs.Spec, bundlePath string, optionMounts []specs.Mount, bindFiles map[string]string, builtinVolumes, volumeMounts []string, shmSize string, namespaceOptions define.NamespaceOptions, secrets map[string]define.Secret, sshSources map[string]*sshagent.Source, runFileMounts []string, contextDir string, stageMountPoints map[string]internal.StageMountDetails) (*runMountArtifacts, error) {\n\t// Start building a new list of mounts.\n\tvar mounts []specs.Mount\n\thaveMount := func(destination string) bool {\n\t\tfor _, mount := range mounts {\n\t\t\tif mount.Destination == destination {\n\t\t\t\t// Already have something to mount there.\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tipc := namespaceOptions.Find(string(specs.IPCNamespace))\n\thostIPC := ipc == nil || ipc.Host\n\tnet := namespaceOptions.Find(string(specs.NetworkNamespace))\n\thostNetwork := net == nil || net.Host\n\tuser := namespaceOptions.Find(string(specs.UserNamespace))\n\thostUser := (user == nil || user.Host) && !unshare.IsRootless()\n\n\t// Copy mounts from the generated list.\n\tmountCgroups := true\n\tspecMounts := []specs.Mount{}\n\tfor _, specMount := range spec.Mounts {\n\t\t// Override some of the mounts from the generated list if we're doing different things with namespaces.\n\t\tif specMount.Destination == \"/dev/shm\" {\n\t\t\tspecMount.Options = []string{\"nosuid\", \"noexec\", \"nodev\", \"mode=1777\"}\n\t\t\tif shmSize != \"\" {\n\t\t\t\tspecMount.Options = append(specMount.Options, \"size=\"+shmSize)\n\t\t\t}\n\t\t\tif hostIPC && !hostUser {\n\t\t\t\tif _, err := os.Stat(\"/dev/shm\"); err != nil && os.IsNotExist(err) {\n\t\t\t\t\tlogrus.Debugf(\"/dev/shm is not present, not binding into container\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tspecMount = specs.Mount{\n\t\t\t\t\tSource:      \"/dev/shm\",\n\t\t\t\t\tType:        \"bind\",\n\t\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif specMount.Destination == \"/dev/mqueue\" {\n\t\t\tif hostIPC && !hostUser {\n\t\t\t\tif _, err := os.Stat(\"/dev/mqueue\"); err != nil && os.IsNotExist(err) {\n\t\t\t\t\tlogrus.Debugf(\"/dev/mqueue is not present, not binding into container\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tspecMount = specs.Mount{\n\t\t\t\t\tSource:      \"/dev/mqueue\",\n\t\t\t\t\tType:        \"bind\",\n\t\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif specMount.Destination == \"/sys\" {\n\t\t\tif hostNetwork && !hostUser {\n\t\t\t\tmountCgroups = false\n\t\t\t\tif _, err := os.Stat(\"/sys\"); err != nil && os.IsNotExist(err) {\n\t\t\t\t\tlogrus.Debugf(\"/sys is not present, not binding into container\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tspecMount = specs.Mount{\n\t\t\t\t\tSource:      \"/sys\",\n\t\t\t\t\tType:        \"bind\",\n\t\t\t\t\tDestination: \"/sys\",\n\t\t\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspecMounts = append(specMounts, specMount)\n\t}\n\n\t// Add a mount for the cgroups filesystem, unless we're already\n\t// recursively bind mounting all of /sys, in which case we shouldn't\n\t// bother with it.\n\tsysfsMount := []specs.Mount{}\n\tif mountCgroups {\n\t\tsysfsMount = []specs.Mount{{\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tType:        \"cgroup\",\n\t\t\tSource:      \"cgroup\",\n\t\t\tOptions:     []string{bind.NoBindOption, \"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"ro\"},\n\t\t}}\n\t}\n\n\t// Get the list of files we need to bind into the container.\n\tbindFileMounts := runSetupBoundFiles(bundlePath, bindFiles)\n\n\t// After this point we need to know the per-container persistent storage directory.\n\tcdir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error determining work directory for container %q\", b.ContainerID)\n\t}\n\n\t// Figure out which UID and GID to tell the subscriptions package to use\n\t// for files that it creates.\n\trootUID, rootGID, err := util.GetHostRootIDs(spec)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get host UID and GID of the container process.\n\tprocessUID, processGID, err := util.GetHostIDs(spec.Linux.UIDMappings, spec.Linux.GIDMappings, spec.Process.User.UID, spec.Process.User.GID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the list of subscriptions mounts.\n\tsubscriptionMounts := subscriptions.MountsWithUIDGID(b.MountLabel, cdir, b.DefaultMountsFilePath, mountPoint, int(rootUID), int(rootGID), unshare.IsRootless(), false)\n\n\t// Get the list of mounts that are just for this Run() call.\n\t// TODO: acui: de-spaghettify run mounts\n\trunMounts, mountArtifacts, err := b.runSetupRunMounts(context, runFileMounts, secrets, stageMountPoints, sshSources, cdir, contextDir, spec.Linux.UIDMappings, spec.Linux.GIDMappings, int(rootUID), int(rootGID), int(processUID), int(processGID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Add temporary copies of the contents of volume locations at the\n\t// volume locations, unless we already have something there.\n\tbuiltins, err := runSetupBuiltinVolumes(b.MountLabel, mountPoint, cdir, builtinVolumes, int(rootUID), int(rootGID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the list of explicitly-specified volume mounts.\n\tvolumes, err := b.runSetupVolumeMounts(spec.Linux.MountLabel, volumeMounts, optionMounts, int(rootUID), int(rootGID), int(processUID), int(processGID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// prepare list of mount destinations which can be cleaned up safely.\n\t// we can clean bindFiles, subscriptionMounts and specMounts\n\t// everything other than these might have users content\n\tmountArtifacts.RunMountTargets = append(append(append(mountArtifacts.RunMountTargets, cleanableDestinationListFromMounts(bindFileMounts)...), cleanableDestinationListFromMounts(subscriptionMounts)...), cleanableDestinationListFromMounts(specMounts)...)\n\n\tallMounts := util.SortMounts(append(append(append(append(append(append(volumes, builtins...), runMounts...), subscriptionMounts...), bindFileMounts...), specMounts...), sysfsMount...))\n\t// Add them all, in the preferred order, except where they conflict with something that was previously added.\n\tfor _, mount := range allMounts {\n\t\tif haveMount(mount.Destination) {\n\t\t\t// Already mounting something there, no need to bother with this one.\n\t\t\tcontinue\n\t\t}\n\t\t// Add the mount.\n\t\tmounts = append(mounts, mount)\n\t}\n\n\t// Set the list in the spec.\n\tspec.Mounts = mounts\n\treturn mountArtifacts, nil\n}\n\n// Destinations which can be cleaned up after every RUN\nfunc cleanableDestinationListFromMounts(mounts []spec.Mount) []string {\n\tmountDest := []string{}\n\tfor _, mount := range mounts {\n\t\t// Add all destination to mountArtifacts so that they can be cleaned up later\n\t\tif mount.Destination != \"\" {\n\t\t\t// we dont want to remove destinations with  /etc, /dev, /sys, /proc as rootfs already contains these files\n\t\t\t// and unionfs will create a `whiteout` i.e `.wh` files on removal of overlapping files from these directories.\n\t\t\t// everything other than these will be cleanedup\n\t\t\tif !strings.HasPrefix(mount.Destination, \"/etc\") && !strings.HasPrefix(mount.Destination, \"/dev\") && !strings.HasPrefix(mount.Destination, \"/sys\") && !strings.HasPrefix(mount.Destination, \"/proc\") {\n\t\t\t\tmountDest = append(mountDest, mount.Destination)\n\t\t\t}\n\t\t}\n\t}\n\treturn mountDest\n}\n\n// addResolvConf copies files from host and sets them up to bind mount into container\nfunc (b *Builder) addResolvConf(rdir string, chownOpts *idtools.IDPair, dnsServers, dnsSearch, dnsOptions []string, namespaceOptions define.NamespaceOptions) (string, error) {\n\tresolvConf := \"/etc/resolv.conf\"\n\n\tstat, err := os.Stat(resolvConf)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tcontents, err := ioutil.ReadFile(resolvConf)\n\t// resolv.conf doesn't have to exists\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn \"\", err\n\t}\n\n\tnetns := false\n\tns := namespaceOptions.Find(string(spec.NetworkNamespace))\n\tif ns != nil && !ns.Host {\n\t\tnetns = true\n\t}\n\n\tnameservers := resolvconf.GetNameservers(contents, types.IPv4)\n\t// check if systemd-resolved is used, assume it is used when 127.0.0.53 is the only nameserver\n\tif len(nameservers) == 1 && nameservers[0] == \"127.0.0.53\" && netns {\n\t\t// read the actual resolv.conf file for systemd-resolved\n\t\tresolvedContents, err := ioutil.ReadFile(\"/run/systemd/resolve/resolv.conf\")\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn \"\", errors.Wrapf(err, \"detected that systemd-resolved is in use, but could not locate real resolv.conf\")\n\t\t\t}\n\t\t} else {\n\t\t\tcontents = resolvedContents\n\t\t}\n\t}\n\n\t// Ensure that the container's /etc/resolv.conf is compatible with its\n\t// network configuration.\n\tif netns {\n\t\t// FIXME handle IPv6\n\t\tresolve, err := resolvconf.FilterResolvDNS(contents, true)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"error parsing host resolv.conf\")\n\t\t}\n\t\tcontents = resolve.Content\n\t}\n\tsearch := resolvconf.GetSearchDomains(contents)\n\tnameservers = resolvconf.GetNameservers(contents, types.IP)\n\toptions := resolvconf.GetOptions(contents)\n\n\tdefaultContainerConfig, err := config.Default()\n\tif err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"failed to get container config\")\n\t}\n\tdnsSearch = append(defaultContainerConfig.Containers.DNSSearches, dnsSearch...)\n\tif len(dnsSearch) > 0 {\n\t\tsearch = dnsSearch\n\t}\n\n\tif b.Isolation == IsolationOCIRootless {\n\t\tif ns != nil && !ns.Host && ns.Path == \"\" {\n\t\t\t// if we are using slirp4netns, also add the built-in DNS server.\n\t\t\tlogrus.Debugf(\"adding slirp4netns 10.0.2.3 built-in DNS server\")\n\t\t\tnameservers = append([]string{\"10.0.2.3\"}, nameservers...)\n\t\t}\n\t}\n\n\tdnsServers = append(defaultContainerConfig.Containers.DNSServers, dnsServers...)\n\tif len(dnsServers) != 0 {\n\t\tdns, err := getDNSIP(dnsServers)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"error getting dns servers\")\n\t\t}\n\t\tnameservers = []string{}\n\t\tfor _, server := range dns {\n\t\t\tnameservers = append(nameservers, server.String())\n\t\t}\n\t}\n\n\tdnsOptions = append(defaultContainerConfig.Containers.DNSOptions, dnsOptions...)\n\tif len(dnsOptions) != 0 {\n\t\toptions = dnsOptions\n\t}\n\n\tcfile := filepath.Join(rdir, filepath.Base(resolvConf))\n\tif _, err = resolvconf.Build(cfile, nameservers, search, options); err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"error building resolv.conf for container %s\", b.ContainerID)\n\t}\n\n\tuid := int(stat.Sys().(*syscall.Stat_t).Uid)\n\tgid := int(stat.Sys().(*syscall.Stat_t).Gid)\n\tif chownOpts != nil {\n\t\tuid = chownOpts.UID\n\t\tgid = chownOpts.GID\n\t}\n\tif err = os.Chown(cfile, uid, gid); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif err := label.Relabel(cfile, b.MountLabel, false); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn cfile, nil\n}\n\n// generateHosts creates a containers hosts file\nfunc (b *Builder) generateHosts(rdir, hostname string, addHosts []string, chownOpts *idtools.IDPair) (string, error) {\n\thostPath := \"/etc/hosts\"\n\tstat, err := os.Stat(hostPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\thosts := bytes.NewBufferString(\"# Generated by Buildah\\n\")\n\torig, err := ioutil.ReadFile(hostPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\thosts.Write(orig)\n\tfor _, host := range addHosts {\n\t\t// verify the host format\n\t\tvalues := strings.SplitN(host, \":\", 2)\n\t\tif len(values) != 2 {\n\t\t\treturn \"\", errors.Errorf(\"unable to parse host entry %q: incorrect format\", host)\n\t\t}\n\t\tif values[0] == \"\" {\n\t\t\treturn \"\", errors.Errorf(\"hostname in host entry %q is empty\", host)\n\t\t}\n\t\tif values[1] == \"\" {\n\t\t\treturn \"\", errors.Errorf(\"IP address in host entry %q is empty\", host)\n\t\t}\n\t\thosts.Write([]byte(fmt.Sprintf(\"%s\\t%s\\n\", values[1], values[0])))\n\t}\n\thosts.Write([]byte(fmt.Sprintf(\"127.0.0.1   %s %s\\n\", b.Container, hostname)))\n\thosts.Write([]byte(fmt.Sprintf(\"::1         %s %s\\n\", b.Container, hostname)))\n\n\tif ip := util.LocalIP(); ip != \"\" {\n\t\thosts.Write([]byte(fmt.Sprintf(\"%s         %s\\n\", ip, \"host.containers.internal\")))\n\t}\n\n\tcfile := filepath.Join(rdir, filepath.Base(hostPath))\n\tif err = ioutils.AtomicWriteFile(cfile, hosts.Bytes(), stat.Mode().Perm()); err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"error writing /etc/hosts into the container\")\n\t}\n\tuid := int(stat.Sys().(*syscall.Stat_t).Uid)\n\tgid := int(stat.Sys().(*syscall.Stat_t).Gid)\n\tif chownOpts != nil {\n\t\tuid = chownOpts.UID\n\t\tgid = chownOpts.GID\n\t}\n\tif err = os.Chown(cfile, uid, gid); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := label.Relabel(cfile, b.MountLabel, false); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn cfile, nil\n}\n\nfunc setupTerminal(g *generate.Generator, terminalPolicy TerminalPolicy, terminalSize *specs.Box) {\n\tswitch terminalPolicy {\n\tcase DefaultTerminal:\n\t\tonTerminal := term.IsTerminal(unix.Stdin) && term.IsTerminal(unix.Stdout) && term.IsTerminal(unix.Stderr)\n\t\tif onTerminal {\n\t\t\tlogrus.Debugf(\"stdio is a terminal, defaulting to using a terminal\")\n\t\t} else {\n\t\t\tlogrus.Debugf(\"stdio is not a terminal, defaulting to not using a terminal\")\n\t\t}\n\t\tg.SetProcessTerminal(onTerminal)\n\tcase WithTerminal:\n\t\tg.SetProcessTerminal(true)\n\tcase WithoutTerminal:\n\t\tg.SetProcessTerminal(false)\n\t}\n\tif terminalSize != nil {\n\t\tg.SetProcessConsoleSize(terminalSize.Width, terminalSize.Height)\n\t}\n}\n\nfunc runUsingRuntime(options RunOptions, configureNetwork bool, moreCreateArgs []string, spec *specs.Spec, bundlePath, containerName string,\n\tcontainerCreateW io.WriteCloser, containerStartR io.ReadCloser) (wstatus unix.WaitStatus, err error) {\n\tif options.Logger == nil {\n\t\toptions.Logger = logrus.StandardLogger()\n\t}\n\n\t// Lock the caller to a single OS-level thread.\n\truntime.LockOSThread()\n\n\t// Set up bind mounts for things that a namespaced user might not be able to get to directly.\n\tunmountAll, err := bind.SetupIntermediateMountNamespace(spec, bundlePath)\n\tif unmountAll != nil {\n\t\tdefer func() {\n\t\t\tif err := unmountAll(); err != nil {\n\t\t\t\toptions.Logger.Error(err)\n\t\t\t}\n\t\t}()\n\t}\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\n\t// Write the runtime configuration.\n\tspecbytes, err := json.Marshal(spec)\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error encoding configuration %#v as json\", spec)\n\t}\n\tif err = ioutils.AtomicWriteFile(filepath.Join(bundlePath, \"config.json\"), specbytes, 0600); err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error storing runtime configuration\")\n\t}\n\n\tlogrus.Debugf(\"config = %v\", string(specbytes))\n\n\t// Decide which runtime to use.\n\truntime := options.Runtime\n\tif runtime == \"\" {\n\t\truntime = util.Runtime()\n\t}\n\tlocalRuntime := util.FindLocalRuntime(runtime)\n\tif localRuntime != \"\" {\n\t\truntime = localRuntime\n\t}\n\n\t// Default to just passing down our stdio.\n\tgetCreateStdio := func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\treturn os.Stdin, os.Stdout, os.Stderr\n\t}\n\n\t// Figure out how we're doing stdio handling, and create pipes and sockets.\n\tvar stdio sync.WaitGroup\n\tvar consoleListener *net.UnixListener\n\tvar errorFds, closeBeforeReadingErrorFds []int\n\tstdioPipe := make([][]int, 3)\n\tcopyConsole := false\n\tcopyPipes := false\n\tfinishCopy := make([]int, 2)\n\tif err = unix.Pipe(finishCopy); err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error creating pipe for notifying to stop stdio\")\n\t}\n\tfinishedCopy := make(chan struct{})\n\tvar pargs []string\n\tif spec.Process != nil {\n\t\tpargs = spec.Process.Args\n\t\tif spec.Process.Terminal {\n\t\t\tcopyConsole = true\n\t\t\t// Create a listening socket for accepting the container's terminal's PTY master.\n\t\t\tsocketPath := filepath.Join(bundlePath, \"console.sock\")\n\t\t\tconsoleListener, err = net.ListenUnix(\"unix\", &net.UnixAddr{Name: socketPath, Net: \"unix\"})\n\t\t\tif err != nil {\n\t\t\t\treturn 1, errors.Wrapf(err, \"error creating socket %q to receive terminal descriptor\", consoleListener.Addr())\n\t\t\t}\n\t\t\t// Add console socket arguments.\n\t\t\tmoreCreateArgs = append(moreCreateArgs, \"--console-socket\", socketPath)\n\t\t} else {\n\t\t\tcopyPipes = true\n\t\t\t// Figure out who should own the pipes.\n\t\t\tuid, gid, err := util.GetHostRootIDs(spec)\n\t\t\tif err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\t// Create stdio pipes.\n\t\t\tif stdioPipe, err = runMakeStdioPipe(int(uid), int(gid)); err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\tif err = runLabelStdioPipes(stdioPipe, spec.Process.SelinuxLabel, spec.Linux.MountLabel); err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\terrorFds = []int{stdioPipe[unix.Stdout][0], stdioPipe[unix.Stderr][0]}\n\t\t\tcloseBeforeReadingErrorFds = []int{stdioPipe[unix.Stdout][1], stdioPipe[unix.Stderr][1]}\n\t\t\t// Set stdio to our pipes.\n\t\t\tgetCreateStdio = func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\t\t\tstdin := os.NewFile(uintptr(stdioPipe[unix.Stdin][0]), \"/dev/stdin\")\n\t\t\t\tstdout := os.NewFile(uintptr(stdioPipe[unix.Stdout][1]), \"/dev/stdout\")\n\t\t\t\tstderr := os.NewFile(uintptr(stdioPipe[unix.Stderr][1]), \"/dev/stderr\")\n\t\t\t\treturn stdin, stdout, stderr\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif options.Quiet {\n\t\t\t// Discard stdout.\n\t\t\tgetCreateStdio = func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\t\t\treturn os.Stdin, nil, os.Stderr\n\t\t\t}\n\t\t}\n\t}\n\n\truntimeArgs := options.Args[:]\n\tif options.CgroupManager == config.SystemdCgroupsManager {\n\t\truntimeArgs = append(runtimeArgs, \"--systemd-cgroup\")\n\t}\n\n\t// Build the commands that we'll execute.\n\tpidFile := filepath.Join(bundlePath, \"pid\")\n\targs := append(append(append(runtimeArgs, \"create\", \"--bundle\", bundlePath, \"--pid-file\", pidFile), moreCreateArgs...), containerName)\n\tcreate := exec.Command(runtime, args...)\n\tcreate.Dir = bundlePath\n\tstdin, stdout, stderr := getCreateStdio()\n\tcreate.Stdin, create.Stdout, create.Stderr = stdin, stdout, stderr\n\tif create.SysProcAttr == nil {\n\t\tcreate.SysProcAttr = &syscall.SysProcAttr{}\n\t}\n\n\targs = append(options.Args, \"start\", containerName)\n\tstart := exec.Command(runtime, args...)\n\tstart.Dir = bundlePath\n\tstart.Stderr = os.Stderr\n\n\targs = append(options.Args, \"kill\", containerName)\n\tkill := exec.Command(runtime, args...)\n\tkill.Dir = bundlePath\n\tkill.Stderr = os.Stderr\n\n\targs = append(options.Args, \"delete\", containerName)\n\tdel := exec.Command(runtime, args...)\n\tdel.Dir = bundlePath\n\tdel.Stderr = os.Stderr\n\n\t// Actually create the container.\n\tlogrus.Debugf(\"Running %q\", create.Args)\n\terr = create.Run()\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error from %s creating container for %v: %s\", runtime, pargs, runCollectOutput(options.Logger, errorFds, closeBeforeReadingErrorFds))\n\t}\n\tdefer func() {\n\t\terr2 := del.Run()\n\t\tif err2 != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = errors.Wrapf(err2, \"error deleting container\")\n\t\t\t} else {\n\t\t\t\toptions.Logger.Infof(\"error from %s deleting container: %v\", runtime, err2)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Make sure we read the container's exit status when it exits.\n\tpidValue, err := ioutil.ReadFile(pidFile)\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tpid, err := strconv.Atoi(strings.TrimSpace(string(pidValue)))\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error parsing pid %s as a number\", string(pidValue))\n\t}\n\tvar stopped uint32\n\tvar reaping sync.WaitGroup\n\treaping.Add(1)\n\tgo func() {\n\t\tdefer reaping.Done()\n\t\tvar err error\n\t\t_, err = unix.Wait4(pid, &wstatus, 0, nil)\n\t\tif err != nil {\n\t\t\twstatus = 0\n\t\t\toptions.Logger.Errorf(\"error waiting for container child process %d: %v\\n\", pid, err)\n\t\t}\n\t\tatomic.StoreUint32(&stopped, 1)\n\t}()\n\n\tif configureNetwork {\n\t\tif _, err := containerCreateW.Write([]byte{1}); err != nil {\n\t\t\treturn 1, err\n\t\t}\n\t\tcontainerCreateW.Close()\n\t\tlogrus.Debug(\"waiting for parent start message\")\n\t\tb := make([]byte, 1)\n\t\tif _, err := containerStartR.Read(b); err != nil {\n\t\t\treturn 1, errors.Wrap(err, \"did not get container start message from parent\")\n\t\t}\n\t\tcontainerStartR.Close()\n\t}\n\n\tif copyPipes {\n\t\t// We don't need the ends of the pipes that belong to the container.\n\t\tstdin.Close()\n\t\tif stdout != nil {\n\t\t\tstdout.Close()\n\t\t}\n\t\tstderr.Close()\n\t}\n\n\t// Handle stdio for the container in the background.\n\tstdio.Add(1)\n\tgo runCopyStdio(options.Logger, &stdio, copyPipes, stdioPipe, copyConsole, consoleListener, finishCopy, finishedCopy, spec)\n\n\t// Start the container.\n\tlogrus.Debugf(\"Running %q\", start.Args)\n\terr = start.Run()\n\tif err != nil {\n\t\treturn 1, errors.Wrapf(err, \"error from %s starting container\", runtime)\n\t}\n\tdefer func() {\n\t\tif atomic.LoadUint32(&stopped) == 0 {\n\t\t\tif err2 := kill.Run(); err2 != nil {\n\t\t\t\toptions.Logger.Infof(\"error from %s stopping container: %v\", runtime, err2)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Wait for the container to exit.\n\tfor {\n\t\tnow := time.Now()\n\t\tvar state specs.State\n\t\targs = append(options.Args, \"state\", containerName)\n\t\tstat := exec.Command(runtime, args...)\n\t\tstat.Dir = bundlePath\n\t\tstat.Stderr = os.Stderr\n\t\tstateOutput, err := stat.Output()\n\t\tif err != nil {\n\t\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\t\t// container exited\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn 1, errors.Wrapf(err, \"error reading container state from %s (got output: %q)\", runtime, string(stateOutput))\n\t\t}\n\t\tif err = json.Unmarshal(stateOutput, &state); err != nil {\n\t\t\treturn 1, errors.Wrapf(err, \"error parsing container state %q from %s\", string(stateOutput), runtime)\n\t\t}\n\t\tswitch state.Status {\n\t\tcase \"running\":\n\t\tcase \"stopped\":\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\tdefault:\n\t\t\treturn 1, errors.Errorf(\"container status unexpectedly changed to %q\", state.Status)\n\t\t}\n\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\tbreak\n\t\t}\n\t\tselect {\n\t\tcase <-finishedCopy:\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\tcase <-time.After(time.Until(now.Add(100 * time.Millisecond))):\n\t\t\tcontinue\n\t\t}\n\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the writing end of the stop-handling-stdio notification pipe.\n\tunix.Close(finishCopy[1])\n\t// Wait for the stdio copy goroutine to flush.\n\tstdio.Wait()\n\t// Wait until we finish reading the exit status.\n\treaping.Wait()\n\n\treturn wstatus, nil\n}\n\nfunc runCollectOutput(logger *logrus.Logger, fds, closeBeforeReadingFds []int) string { //nolint:interfacer\n\tfor _, fd := range closeBeforeReadingFds {\n\t\tunix.Close(fd)\n\t}\n\tvar b bytes.Buffer\n\tbuf := make([]byte, 8192)\n\tfor _, fd := range fds {\n\t\tnread, err := unix.Read(fd, buf)\n\t\tif err != nil {\n\t\t\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\t\t\tswitch errno {\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.Errorf(\"error reading from pipe %d: %v\", fd, err)\n\t\t\t\tcase syscall.EINTR, syscall.EAGAIN:\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.Errorf(\"unable to wait for data from pipe %d: %v\", fd, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tfor nread > 0 {\n\t\t\tr := buf[:nread]\n\t\t\tif nwritten, err := b.Write(r); err != nil || nwritten != len(r) {\n\t\t\t\tif nwritten != len(r) {\n\t\t\t\t\tlogger.Errorf(\"error buffering data from pipe %d: %v\", fd, err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tnread, err = unix.Read(fd, buf)\n\t\t\tif err != nil {\n\t\t\t\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\t\t\t\tswitch errno {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlogger.Errorf(\"error reading from pipe %d: %v\", fd, err)\n\t\t\t\t\tcase syscall.EINTR, syscall.EAGAIN:\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.Errorf(\"unable to wait for data from pipe %d: %v\", fd, err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn b.String()\n}\n\nfunc setupRootlessNetwork(pid int) (teardown func(), err error) {\n\tslirp4netns, err := exec.LookPath(\"slirp4netns\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trootlessSlirpSyncR, rootlessSlirpSyncW, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot create slirp4netns sync pipe\")\n\t}\n\tdefer rootlessSlirpSyncR.Close()\n\n\t// Be sure there are no fds inherited to slirp4netns except the sync pipe\n\tfiles, err := ioutil.ReadDir(\"/proc/self/fd\")\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot list open fds\")\n\t}\n\tfor _, f := range files {\n\t\tfd, err := strconv.Atoi(f.Name())\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"cannot parse fd\")\n\t\t}\n\t\tif fd == int(rootlessSlirpSyncW.Fd()) {\n\t\t\tcontinue\n\t\t}\n\t\tunix.CloseOnExec(fd)\n\t}\n\n\tcmd := exec.Command(slirp4netns, \"--mtu\", \"65520\", \"-r\", \"3\", \"-c\", strconv.Itoa(pid), \"tap0\")\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = nil, nil, nil\n\tcmd.ExtraFiles = []*os.File{rootlessSlirpSyncW}\n\n\terr = cmd.Start()\n\trootlessSlirpSyncW.Close()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"cannot start slirp4netns\")\n\t}\n\n\tb := make([]byte, 1)\n\tfor {\n\t\tif err := rootlessSlirpSyncR.SetDeadline(time.Now().Add(1 * time.Second)); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error setting slirp4netns pipe timeout\")\n\t\t}\n\t\tif _, err := rootlessSlirpSyncR.Read(b); err == nil {\n\t\t\tbreak\n\t\t} else {\n\t\t\tif os.IsTimeout(err) {\n\t\t\t\t// Check if the process is still running.\n\t\t\t\tvar status syscall.WaitStatus\n\t\t\t\t_, err := syscall.Wait4(cmd.Process.Pid, &status, syscall.WNOHANG, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, errors.Wrapf(err, \"failed to read slirp4netns process status\")\n\t\t\t\t}\n\t\t\t\tif status.Exited() || status.Signaled() {\n\t\t\t\t\treturn nil, errors.New(\"slirp4netns failed\")\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, errors.Wrapf(err, \"failed to read from slirp4netns sync pipe\")\n\t\t}\n\t}\n\n\treturn func() {\n\t\tcmd.Process.Kill() // nolint:errcheck\n\t\tcmd.Wait()         // nolint:errcheck\n\t}, nil\n}\n\nfunc (b *Builder) runConfigureNetwork(pid int, isolation define.Isolation, options RunOptions, configureNetworks []string, containerName string) (teardown func(), err error) {\n\tif isolation == IsolationOCIRootless {\n\t\tif ns := options.NamespaceOptions.Find(string(specs.NetworkNamespace)); ns != nil && !ns.Host && ns.Path == \"\" {\n\t\t\treturn setupRootlessNetwork(pid)\n\t\t}\n\t}\n\n\tif len(configureNetworks) == 0 {\n\t\tconfigureNetworks = []string{b.NetworkInterface.DefaultNetworkName()}\n\t}\n\n\t// Make sure we can access the container's network namespace,\n\t// even after it exits, to successfully tear down the\n\t// interfaces.  Ensure this by opening a handle to the network\n\t// namespace, and using our copy to both configure and\n\t// deconfigure it.\n\tnetns := fmt.Sprintf(\"/proc/%d/ns/net\", pid)\n\tnetFD, err := unix.Open(netns, unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error opening network namespace\")\n\t}\n\tmynetns := fmt.Sprintf(\"/proc/%d/fd/%d\", unix.Getpid(), netFD)\n\n\tnetworks := make(map[string]nettypes.PerNetworkOptions, len(configureNetworks))\n\tfor i, network := range configureNetworks {\n\t\tnetworks[network] = nettypes.PerNetworkOptions{\n\t\t\tInterfaceName: fmt.Sprintf(\"eth%d\", i),\n\t\t}\n\t}\n\n\topts := nettypes.NetworkOptions{\n\t\tContainerID:   containerName,\n\t\tContainerName: containerName,\n\t\tNetworks:      networks,\n\t}\n\t_, err = b.NetworkInterface.Setup(mynetns, nettypes.SetupOptions{NetworkOptions: opts})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tteardown = func() {\n\t\terr := b.NetworkInterface.Teardown(mynetns, nettypes.TeardownOptions{NetworkOptions: opts})\n\t\tif err != nil {\n\t\t\toptions.Logger.Errorf(\"failed to cleanup network: %v\", err)\n\t\t}\n\t}\n\n\treturn teardown, nil\n}\n\nfunc setNonblock(logger *logrus.Logger, fd int, description string, nonblocking bool) (bool, error) { //nolint:interfacer\n\tmask, err := unix.FcntlInt(uintptr(fd), unix.F_GETFL, 0)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tblocked := mask&unix.O_NONBLOCK == 0\n\n\tif err := unix.SetNonblock(fd, nonblocking); err != nil {\n\t\tif nonblocking {\n\t\t\tlogger.Errorf(\"error setting %s to nonblocking: %v\", description, err)\n\t\t} else {\n\t\t\tlogger.Errorf(\"error setting descriptor %s blocking: %v\", description, err)\n\t\t}\n\t}\n\treturn blocked, err\n}\n\nfunc runCopyStdio(logger *logrus.Logger, stdio *sync.WaitGroup, copyPipes bool, stdioPipe [][]int, copyConsole bool, consoleListener *net.UnixListener, finishCopy []int, finishedCopy chan struct{}, spec *specs.Spec) {\n\tdefer func() {\n\t\tunix.Close(finishCopy[0])\n\t\tif copyPipes {\n\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\tunix.Close(stdioPipe[unix.Stdout][0])\n\t\t\tunix.Close(stdioPipe[unix.Stderr][0])\n\t\t}\n\t\tstdio.Done()\n\t\tfinishedCopy <- struct{}{}\n\t}()\n\t// Map describing where data on an incoming descriptor should go.\n\trelayMap := make(map[int]int)\n\t// Map describing incoming and outgoing descriptors.\n\treadDesc := make(map[int]string)\n\twriteDesc := make(map[int]string)\n\t// Buffers.\n\trelayBuffer := make(map[int]*bytes.Buffer)\n\t// Set up the terminal descriptor or pipes for polling.\n\tif copyConsole {\n\t\t// Accept a connection over our listening socket.\n\t\tfd, err := runAcceptTerminal(logger, consoleListener, spec.Process.ConsoleSize)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"%v\", err)\n\t\t\treturn\n\t\t}\n\t\tterminalFD := fd\n\t\t// Input from our stdin, output from the terminal descriptor.\n\t\trelayMap[unix.Stdin] = terminalFD\n\t\treadDesc[unix.Stdin] = \"stdin\"\n\t\trelayBuffer[terminalFD] = new(bytes.Buffer)\n\t\twriteDesc[terminalFD] = \"container terminal input\"\n\t\trelayMap[terminalFD] = unix.Stdout\n\t\treadDesc[terminalFD] = \"container terminal output\"\n\t\trelayBuffer[unix.Stdout] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stdout] = \"output\"\n\t\t// Set our terminal's mode to raw, to pass handling of special\n\t\t// terminal input to the terminal in the container.\n\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\tif state, err := term.MakeRaw(unix.Stdin); err != nil {\n\t\t\t\tlogger.Warnf(\"error setting terminal state: %v\", err)\n\t\t\t} else {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif err = term.Restore(unix.Stdin, state); err != nil {\n\t\t\t\t\t\tlogger.Errorf(\"unable to restore terminal state: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}\n\tif copyPipes {\n\t\t// Input from our stdin, output from the stdout and stderr pipes.\n\t\trelayMap[unix.Stdin] = stdioPipe[unix.Stdin][1]\n\t\treadDesc[unix.Stdin] = \"stdin\"\n\t\trelayBuffer[stdioPipe[unix.Stdin][1]] = new(bytes.Buffer)\n\t\twriteDesc[stdioPipe[unix.Stdin][1]] = \"container stdin\"\n\t\trelayMap[stdioPipe[unix.Stdout][0]] = unix.Stdout\n\t\treadDesc[stdioPipe[unix.Stdout][0]] = \"container stdout\"\n\t\trelayBuffer[unix.Stdout] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stdout] = \"stdout\"\n\t\trelayMap[stdioPipe[unix.Stderr][0]] = unix.Stderr\n\t\treadDesc[stdioPipe[unix.Stderr][0]] = \"container stderr\"\n\t\trelayBuffer[unix.Stderr] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stderr] = \"stderr\"\n\t}\n\t// Set our reading descriptors to non-blocking.\n\tfor rfd, wfd := range relayMap {\n\t\tblocked, err := setNonblock(logger, rfd, readDesc[rfd], true)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif blocked {\n\t\t\tdefer setNonblock(logger, rfd, readDesc[rfd], false) // nolint:errcheck\n\t\t}\n\t\tsetNonblock(logger, wfd, writeDesc[wfd], false) // nolint:errcheck\n\t}\n\n\tif copyPipes {\n\t\tsetNonblock(logger, stdioPipe[unix.Stdin][1], writeDesc[stdioPipe[unix.Stdin][1]], true) // nolint:errcheck\n\t}\n\n\trunCopyStdioPassData(copyPipes, stdioPipe, finishCopy, relayMap, relayBuffer, readDesc, writeDesc)\n}\n\nfunc canRetry(err error) bool {\n\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\treturn errno == syscall.EINTR || errno == syscall.EAGAIN\n\t}\n\treturn false\n}\n\nfunc runCopyStdioPassData(copyPipes bool, stdioPipe [][]int, finishCopy []int, relayMap map[int]int, relayBuffer map[int]*bytes.Buffer, readDesc map[int]string, writeDesc map[int]string) {\n\tcloseStdin := false\n\n\t// Pass data back and forth.\n\tpollTimeout := -1\n\tfor len(relayMap) > 0 {\n\t\t// Start building the list of descriptors to poll.\n\t\tpollFds := make([]unix.PollFd, 0, len(relayMap)+1)\n\t\t// Poll for a notification that we should stop handling stdio.\n\t\tpollFds = append(pollFds, unix.PollFd{Fd: int32(finishCopy[0]), Events: unix.POLLIN | unix.POLLHUP})\n\t\t// Poll on our reading descriptors.\n\t\tfor rfd := range relayMap {\n\t\t\tpollFds = append(pollFds, unix.PollFd{Fd: int32(rfd), Events: unix.POLLIN | unix.POLLHUP})\n\t\t}\n\t\tbuf := make([]byte, 8192)\n\t\t// Wait for new data from any input descriptor, or a notification that we're done.\n\t\t_, err := unix.Poll(pollFds, pollTimeout)\n\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"error waiting for stdio/terminal data to relay: %v\", err)) {\n\t\t\treturn\n\t\t}\n\t\tremoves := make(map[int]struct{})\n\t\tfor _, pollFd := range pollFds {\n\t\t\t// If this descriptor's just been closed from the other end, mark it for\n\t\t\t// removal from the set that we're checking for.\n\t\t\tif pollFd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t}\n\t\t\t// If the descriptor was closed elsewhere, remove it from our list.\n\t\t\tif pollFd.Revents&unix.POLLNVAL != 0 {\n\t\t\t\tlogrus.Debugf(\"error polling descriptor %s: closed?\", readDesc[int(pollFd.Fd)])\n\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t}\n\t\t\t// If the POLLIN flag isn't set, then there's no data to be read from this descriptor.\n\t\t\tif pollFd.Revents&unix.POLLIN == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Read whatever there is to be read.\n\t\t\treadFD := int(pollFd.Fd)\n\t\t\twriteFD, needToRelay := relayMap[readFD]\n\t\t\tif needToRelay {\n\t\t\t\tn, err := unix.Read(readFD, buf)\n\t\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"unable to read %s data: %v\", readDesc[readFD], err)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// If it's zero-length on our stdin and we're\n\t\t\t\t// using pipes, it's an EOF, so close the stdin\n\t\t\t\t// pipe's writing end.\n\t\t\t\tif n == 0 && !canRetry(err) && int(pollFd.Fd) == unix.Stdin {\n\t\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t\t} else if n > 0 {\n\t\t\t\t\t// Buffer the data in case we get blocked on where they need to go.\n\t\t\t\t\tnwritten, err := relayBuffer[writeFD].Write(buf[:n])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif nwritten != n {\n\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", n, nwritten)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// If this is the last of the data we'll be able to read from this\n\t\t\t\t\t// descriptor, read all that there is to read.\n\t\t\t\t\tfor pollFd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\t\t\tnr, err := unix.Read(readFD, buf)\n\t\t\t\t\t\tutil.LogIfUnexpectedWhileDraining(err, fmt.Sprintf(\"read %s: %v\", readDesc[readFD], err))\n\t\t\t\t\t\tif nr <= 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnwritten, err := relayBuffer[writeFD].Write(buf[:nr])\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif nwritten != nr {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", nr, nwritten)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to drain the output buffers.  Set the default timeout\n\t\t// for the next poll() to 100ms if we still have data to write.\n\t\tpollTimeout = -1\n\t\tfor writeFD := range relayBuffer {\n\t\t\tif relayBuffer[writeFD].Len() > 0 {\n\t\t\t\tn, err := unix.Write(writeFD, relayBuffer[writeFD].Bytes())\n\t\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"unable to write %s data: %v\", writeDesc[writeFD], err)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\trelayBuffer[writeFD].Next(n)\n\t\t\t\t}\n\t\t\t\tif closeStdin && writeFD == stdioPipe[unix.Stdin][1] && stdioPipe[unix.Stdin][1] >= 0 && relayBuffer[stdioPipe[unix.Stdin][1]].Len() == 0 {\n\t\t\t\t\tlogrus.Debugf(\"closing stdin\")\n\t\t\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\t\t\tstdioPipe[unix.Stdin][1] = -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif relayBuffer[writeFD].Len() > 0 {\n\t\t\t\tpollTimeout = 100\n\t\t\t}\n\t\t}\n\t\t// Remove any descriptors which we don't need to poll any more from the poll descriptor list.\n\t\tfor remove := range removes {\n\t\t\tif copyPipes && remove == unix.Stdin {\n\t\t\t\tcloseStdin = true\n\t\t\t\tif relayBuffer[stdioPipe[unix.Stdin][1]].Len() == 0 {\n\t\t\t\t\tlogrus.Debugf(\"closing stdin\")\n\t\t\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\t\t\tstdioPipe[unix.Stdin][1] = -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete(relayMap, remove)\n\t\t}\n\t\t// If the we-can-return pipe had anything for us, we're done.\n\t\tfor _, pollFd := range pollFds {\n\t\t\tif int(pollFd.Fd) == finishCopy[0] && pollFd.Revents != 0 {\n\t\t\t\t// The pipe is closed, indicating that we can stop now.\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc runAcceptTerminal(logger *logrus.Logger, consoleListener *net.UnixListener, terminalSize *specs.Box) (int, error) {\n\tdefer consoleListener.Close()\n\tc, err := consoleListener.AcceptUnix()\n\tif err != nil {\n\t\treturn -1, errors.Wrapf(err, \"error accepting socket descriptor connection\")\n\t}\n\tdefer c.Close()\n\t// Expect a control message over our new connection.\n\tb := make([]byte, 8192)\n\toob := make([]byte, 8192)\n\tn, oobn, _, _, err := c.ReadMsgUnix(b, oob)\n\tif err != nil {\n\t\treturn -1, errors.Wrapf(err, \"error reading socket descriptor\")\n\t}\n\tif n > 0 {\n\t\tlogrus.Debugf(\"socket descriptor is for %q\", string(b[:n]))\n\t}\n\tif oobn > len(oob) {\n\t\treturn -1, errors.Errorf(\"too much out-of-bounds data (%d bytes)\", oobn)\n\t}\n\t// Parse the control message.\n\tscm, err := unix.ParseSocketControlMessage(oob[:oobn])\n\tif err != nil {\n\t\treturn -1, errors.Wrapf(err, \"error parsing out-of-bound data as a socket control message\")\n\t}\n\tlogrus.Debugf(\"control messages: %v\", scm)\n\t// Expect to get a descriptor.\n\tterminalFD := -1\n\tfor i := range scm {\n\t\tfds, err := unix.ParseUnixRights(&scm[i])\n\t\tif err != nil {\n\t\t\treturn -1, errors.Wrapf(err, \"error parsing unix rights control message: %v\", &scm[i])\n\t\t}\n\t\tlogrus.Debugf(\"fds: %v\", fds)\n\t\tif len(fds) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tterminalFD = fds[0]\n\t\tbreak\n\t}\n\tif terminalFD == -1 {\n\t\treturn -1, errors.Errorf(\"unable to read terminal descriptor\")\n\t}\n\t// Set the pseudoterminal's size to the configured size, or our own.\n\twinsize := &unix.Winsize{}\n\tif terminalSize != nil {\n\t\t// Use configured sizes.\n\t\twinsize.Row = uint16(terminalSize.Height)\n\t\twinsize.Col = uint16(terminalSize.Width)\n\t} else {\n\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\t// Use the size of our terminal.\n\t\t\tif winsize, err = unix.IoctlGetWinsize(unix.Stdin, unix.TIOCGWINSZ); err != nil {\n\t\t\t\tlogger.Warnf(\"error reading size of controlling terminal: %v\", err)\n\t\t\t\twinsize.Row = 0\n\t\t\t\twinsize.Col = 0\n\t\t\t}\n\t\t}\n\t}\n\tif winsize.Row != 0 && winsize.Col != 0 {\n\t\tif err = unix.IoctlSetWinsize(terminalFD, unix.TIOCSWINSZ, winsize); err != nil {\n\t\t\tlogger.Warnf(\"error setting size of container pseudoterminal: %v\", err)\n\t\t}\n\t\t// FIXME - if we're connected to a terminal, we should\n\t\t// be passing the updated terminal size down when we\n\t\t// receive a SIGWINCH.\n\t}\n\treturn terminalFD, nil\n}\n\n// Create pipes to use for relaying stdio.\nfunc runMakeStdioPipe(uid, gid int) ([][]int, error) {\n\tstdioPipe := make([][]int, 3)\n\tfor i := range stdioPipe {\n\t\tstdioPipe[i] = make([]int, 2)\n\t\tif err := unix.Pipe(stdioPipe[i]); err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error creating pipe for container FD %d\", i)\n\t\t}\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stdin][0], uid, gid); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error setting owner of stdin pipe descriptor\")\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stdout][1], uid, gid); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error setting owner of stdout pipe descriptor\")\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stderr][1], uid, gid); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error setting owner of stderr pipe descriptor\")\n\t}\n\treturn stdioPipe, nil\n}\n\nfunc runUsingRuntimeMain() {\n\tvar options runUsingRuntimeSubprocOptions\n\t// Set logging.\n\tif level := os.Getenv(\"LOGLEVEL\"); level != \"\" {\n\t\tif ll, err := strconv.Atoi(level); err == nil {\n\t\t\tlogrus.SetLevel(logrus.Level(ll))\n\t\t}\n\t}\n\t// Unpack our configuration.\n\tconfPipe := os.NewFile(3, \"confpipe\")\n\tif confPipe == nil {\n\t\tfmt.Fprintf(os.Stderr, \"error reading options pipe\\n\")\n\t\tos.Exit(1)\n\t}\n\tdefer confPipe.Close()\n\tif err := json.NewDecoder(confPipe).Decode(&options); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error decoding options: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\t// Set ourselves up to read the container's exit status.  We're doing this in a child process\n\t// so that we won't mess with the setting in a caller of the library.\n\tif err := setChildProcess(); err != nil {\n\t\tos.Exit(1)\n\t}\n\tospec := options.Spec\n\tif ospec == nil {\n\t\tfmt.Fprintf(os.Stderr, \"options spec not specified\\n\")\n\t\tos.Exit(1)\n\t}\n\n\t// open the pipes used to communicate with the parent process\n\tvar containerCreateW *os.File\n\tvar containerStartR *os.File\n\tif options.ConfigureNetwork {\n\t\tcontainerCreateW = os.NewFile(4, \"containercreatepipe\")\n\t\tif containerCreateW == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"could not open fd 4\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcontainerStartR = os.NewFile(5, \"containerstartpipe\")\n\t\tif containerStartR == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"could not open fd 5\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\t// Run the container, start to finish.\n\tstatus, err := runUsingRuntime(options.Options, options.ConfigureNetwork, options.MoreCreateArgs, ospec, options.BundlePath, options.ContainerName, containerCreateW, containerStartR)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error running container: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\t// Pass the container's exit status back to the caller by exiting with the same status.\n\tif status.Exited() {\n\t\tos.Exit(status.ExitStatus())\n\t} else if status.Signaled() {\n\t\tfmt.Fprintf(os.Stderr, \"container exited on %s\\n\", status.Signal())\n\t\tos.Exit(1)\n\t}\n\tos.Exit(1)\n}\n\nfunc setupNamespaces(logger *logrus.Logger, g *generate.Generator, namespaceOptions define.NamespaceOptions, idmapOptions define.IDMappingOptions, policy define.NetworkConfigurationPolicy) (configureNetwork bool, configureNetworks []string, configureUTS bool, err error) {\n\t// Set namespace options in the container configuration.\n\tconfigureUserns := false\n\tspecifiedNetwork := false\n\tfor _, namespaceOption := range namespaceOptions {\n\t\tswitch namespaceOption.Name {\n\t\tcase string(specs.UserNamespace):\n\t\t\tconfigureUserns = false\n\t\t\tif !namespaceOption.Host && namespaceOption.Path == \"\" {\n\t\t\t\tconfigureUserns = true\n\t\t\t}\n\t\tcase string(specs.NetworkNamespace):\n\t\t\tspecifiedNetwork = true\n\t\t\tconfigureNetwork = false\n\t\t\tif !namespaceOption.Host && (namespaceOption.Path == \"\" || !filepath.IsAbs(namespaceOption.Path)) {\n\t\t\t\tif namespaceOption.Path != \"\" && !filepath.IsAbs(namespaceOption.Path) {\n\t\t\t\t\tconfigureNetworks = strings.Split(namespaceOption.Path, \",\")\n\t\t\t\t\tnamespaceOption.Path = \"\"\n\t\t\t\t}\n\t\t\t\tconfigureNetwork = (policy != define.NetworkDisabled)\n\t\t\t}\n\t\tcase string(specs.UTSNamespace):\n\t\t\tconfigureUTS = false\n\t\t\tif !namespaceOption.Host && namespaceOption.Path == \"\" {\n\t\t\t\tconfigureUTS = true\n\t\t\t}\n\t\t}\n\t\tif namespaceOption.Host {\n\t\t\tif err := g.RemoveLinuxNamespace(namespaceOption.Name); err != nil {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error removing %q namespace for run\", namespaceOption.Name)\n\t\t\t}\n\t\t} else if err := g.AddOrReplaceLinuxNamespace(namespaceOption.Name, namespaceOption.Path); err != nil {\n\t\t\tif namespaceOption.Path == \"\" {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding new %q namespace for run\", namespaceOption.Name)\n\t\t\t}\n\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding %q namespace %q for run\", namespaceOption.Name, namespaceOption.Path)\n\t\t}\n\t}\n\n\t// If we've got mappings, we're going to have to create a user namespace.\n\tif len(idmapOptions.UIDMap) > 0 || len(idmapOptions.GIDMap) > 0 || configureUserns {\n\t\tif err := g.AddOrReplaceLinuxNamespace(string(specs.UserNamespace), \"\"); err != nil {\n\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding new %q namespace for run\", string(specs.UserNamespace))\n\t\t}\n\t\thostUidmap, hostGidmap, err := unshare.GetHostIDMappings(\"\")\n\t\tif err != nil {\n\t\t\treturn false, nil, false, err\n\t\t}\n\t\tfor _, m := range idmapOptions.UIDMap {\n\t\t\tg.AddLinuxUIDMapping(m.HostID, m.ContainerID, m.Size)\n\t\t}\n\t\tif len(idmapOptions.UIDMap) == 0 {\n\t\t\tfor _, m := range hostUidmap {\n\t\t\t\tg.AddLinuxUIDMapping(m.ContainerID, m.ContainerID, m.Size)\n\t\t\t}\n\t\t}\n\t\tfor _, m := range idmapOptions.GIDMap {\n\t\t\tg.AddLinuxGIDMapping(m.HostID, m.ContainerID, m.Size)\n\t\t}\n\t\tif len(idmapOptions.GIDMap) == 0 {\n\t\t\tfor _, m := range hostGidmap {\n\t\t\t\tg.AddLinuxGIDMapping(m.ContainerID, m.ContainerID, m.Size)\n\t\t\t}\n\t\t}\n\t\tif !specifiedNetwork {\n\t\t\tif err := g.AddOrReplaceLinuxNamespace(string(specs.NetworkNamespace), \"\"); err != nil {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error adding new %q namespace for run\", string(specs.NetworkNamespace))\n\t\t\t}\n\t\t\tconfigureNetwork = (policy != define.NetworkDisabled)\n\t\t}\n\t} else {\n\t\tif err := g.RemoveLinuxNamespace(string(specs.UserNamespace)); err != nil {\n\t\t\treturn false, nil, false, errors.Wrapf(err, \"error removing %q namespace for run\", string(specs.UserNamespace))\n\t\t}\n\t\tif !specifiedNetwork {\n\t\t\tif err := g.RemoveLinuxNamespace(string(specs.NetworkNamespace)); err != nil {\n\t\t\t\treturn false, nil, false, errors.Wrapf(err, \"error removing %q namespace for run\", string(specs.NetworkNamespace))\n\t\t\t}\n\t\t}\n\t}\n\tif configureNetwork && !unshare.IsRootless() {\n\t\tfor name, val := range define.DefaultNetworkSysctl {\n\t\t\t// Check that the sysctl we are adding is actually supported\n\t\t\t// by the kernel\n\t\t\tp := filepath.Join(\"/proc/sys\", strings.Replace(name, \".\", \"/\", -1))\n\t\t\t_, err := os.Stat(p)\n\t\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\t\treturn false, nil, false, err\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tg.AddLinuxSysctl(name, val)\n\t\t\t} else {\n\t\t\t\tlogger.Warnf(\"ignoring sysctl %s since %s doesn't exist\", name, p)\n\t\t\t}\n\t\t}\n\t}\n\treturn configureNetwork, configureNetworks, configureUTS, nil\n}\n\nfunc (b *Builder) configureNamespaces(g *generate.Generator, options *RunOptions) (bool, []string, error) {\n\tdefaultNamespaceOptions, err := DefaultNamespaceOptions()\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\n\tnamespaceOptions := defaultNamespaceOptions\n\tnamespaceOptions.AddOrReplace(b.NamespaceOptions...)\n\tnamespaceOptions.AddOrReplace(options.NamespaceOptions...)\n\n\tnetworkPolicy := options.ConfigureNetwork\n\t//Nothing was specified explicitly so network policy should be inherited from builder\n\tif networkPolicy == NetworkDefault {\n\t\tnetworkPolicy = b.ConfigureNetwork\n\n\t\t// If builder policy was NetworkDisabled and\n\t\t// we want to disable network for this run.\n\t\t// reset options.ConfigureNetwork to NetworkDisabled\n\t\t// since it will be treated as source of truth later.\n\t\tif networkPolicy == NetworkDisabled {\n\t\t\toptions.ConfigureNetwork = networkPolicy\n\t\t}\n\t}\n\n\tconfigureNetwork, configureNetworks, configureUTS, err := setupNamespaces(options.Logger, g, namespaceOptions, b.IDMappingOptions, networkPolicy)\n\tif err != nil {\n\t\treturn false, nil, err\n\t}\n\n\tif configureUTS {\n\t\tif options.Hostname != \"\" {\n\t\t\tg.SetHostname(options.Hostname)\n\t\t} else if b.Hostname() != \"\" {\n\t\t\tg.SetHostname(b.Hostname())\n\t\t} else {\n\t\t\tg.SetHostname(stringid.TruncateID(b.ContainerID))\n\t\t}\n\t} else {\n\t\tg.SetHostname(\"\")\n\t}\n\n\tfound := false\n\tspec := g.Config\n\tfor i := range spec.Process.Env {\n\t\tif strings.HasPrefix(spec.Process.Env[i], \"HOSTNAME=\") {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tspec.Process.Env = append(spec.Process.Env, fmt.Sprintf(\"HOSTNAME=%s\", spec.Hostname))\n\t}\n\n\treturn configureNetwork, configureNetworks, nil\n}\n\nfunc runSetupBoundFiles(bundlePath string, bindFiles map[string]string) (mounts []specs.Mount) {\n\tfor dest, src := range bindFiles {\n\t\toptions := []string{\"rbind\"}\n\t\tif strings.HasPrefix(src, bundlePath) {\n\t\t\toptions = append(options, bind.NoBindOption)\n\t\t}\n\t\tmounts = append(mounts, specs.Mount{\n\t\t\tSource:      src,\n\t\t\tDestination: dest,\n\t\t\tType:        \"bind\",\n\t\t\tOptions:     options,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc addRlimits(ulimit []string, g *generate.Generator, defaultUlimits []string) error {\n\tvar (\n\t\tul  *units.Ulimit\n\t\terr error\n\t)\n\n\tulimit = append(defaultUlimits, ulimit...)\n\tfor _, u := range ulimit {\n\t\tif ul, err = units.ParseUlimit(u); err != nil {\n\t\t\treturn errors.Wrapf(err, \"ulimit option %q requires name=SOFT:HARD, failed to be parsed\", u)\n\t\t}\n\n\t\tg.AddProcessRlimits(\"RLIMIT_\"+strings.ToUpper(ul.Name), uint64(ul.Hard), uint64(ul.Soft))\n\t}\n\treturn nil\n}\n\nfunc (b *Builder) cleanupTempVolumes() {\n\tfor tempVolume, val := range b.TempVolumes {\n\t\tif val {\n\t\t\tif err := overlay.RemoveTemp(tempVolume); err != nil {\n\t\t\t\tb.Logger.Errorf(err.Error())\n\t\t\t}\n\t\t\tb.TempVolumes[tempVolume] = false\n\t\t}\n\t}\n}\n\nfunc (b *Builder) runSetupVolumeMounts(mountLabel string, volumeMounts []string, optionMounts []specs.Mount, rootUID, rootGID, processUID, processGID int) (mounts []specs.Mount, Err error) {\n\t// Make sure the overlay directory is clean before running\n\tcontainerDir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error looking up container directory for %s\", b.ContainerID)\n\t}\n\tif err := overlay.CleanupContent(containerDir); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error cleaning up overlay content for %s\", b.ContainerID)\n\t}\n\n\tparseMount := func(mountType, host, container string, options []string) (specs.Mount, error) {\n\t\tvar foundrw, foundro, foundz, foundZ, foundO, foundU bool\n\t\tvar rootProp, upperDir, workDir string\n\t\tfor _, opt := range options {\n\t\t\tswitch opt {\n\t\t\tcase \"rw\":\n\t\t\t\tfoundrw = true\n\t\t\tcase \"ro\":\n\t\t\t\tfoundro = true\n\t\t\tcase \"z\":\n\t\t\t\tfoundz = true\n\t\t\tcase \"Z\":\n\t\t\t\tfoundZ = true\n\t\t\tcase \"O\":\n\t\t\t\tfoundO = true\n\t\t\tcase \"U\":\n\t\t\t\tfoundU = true\n\t\t\tcase \"private\", \"rprivate\", \"slave\", \"rslave\", \"shared\", \"rshared\":\n\t\t\t\trootProp = opt\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(opt, \"upperdir\") {\n\t\t\t\tsplitOpt := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(splitOpt) > 1 {\n\t\t\t\t\tupperDir = splitOpt[1]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif strings.HasPrefix(opt, \"workdir\") {\n\t\t\t\tsplitOpt := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(splitOpt) > 1 {\n\t\t\t\t\tworkDir = splitOpt[1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !foundrw && !foundro {\n\t\t\toptions = append(options, \"rw\")\n\t\t}\n\t\tif foundz {\n\t\t\tif err := label.Relabel(host, mountLabel, true); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundZ {\n\t\t\tif err := label.Relabel(host, mountLabel, false); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundU {\n\t\t\tif err := chown.ChangeHostPathOwnership(host, true, processUID, processGID); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundO {\n\t\t\tif (upperDir != \"\" && workDir == \"\") || (workDir != \"\" && upperDir == \"\") {\n\t\t\t\treturn specs.Mount{}, errors.New(\"if specifying upperdir then workdir must be specified or vice versa\")\n\t\t\t}\n\n\t\t\tcontainerDir, err := b.store.ContainerDirectory(b.ContainerID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\n\t\t\tcontentDir, err := overlay.TempDir(containerDir, rootUID, rootGID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, errors.Wrapf(err, \"failed to create TempDir in the %s directory\", containerDir)\n\t\t\t}\n\n\t\t\toverlayOpts := overlay.Options{RootUID: rootUID,\n\t\t\t\tRootGID:                rootGID,\n\t\t\t\tUpperDirOptionFragment: upperDir,\n\t\t\t\tWorkDirOptionFragment:  workDir,\n\t\t\t\tGraphOpts:              b.store.GraphOptions(),\n\t\t\t}\n\n\t\t\toverlayMount, err := overlay.MountWithOptions(contentDir, host, container, &overlayOpts)\n\t\t\tif err == nil {\n\t\t\t\tb.TempVolumes[contentDir] = true\n\t\t\t}\n\n\t\t\t// If chown true, add correct ownership to the overlay temp directories.\n\t\t\tif foundU {\n\t\t\t\tif err := chown.ChangeHostPathOwnership(contentDir, true, processUID, processGID); err != nil {\n\t\t\t\t\treturn specs.Mount{}, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn overlayMount, err\n\t\t}\n\t\tif rootProp == \"\" {\n\t\t\toptions = append(options, \"private\")\n\t\t}\n\t\tif mountType != \"tmpfs\" {\n\t\t\tmountType = \"bind\"\n\t\t\toptions = append(options, \"rbind\")\n\t\t}\n\t\treturn specs.Mount{\n\t\t\tDestination: container,\n\t\t\tType:        mountType,\n\t\t\tSource:      host,\n\t\t\tOptions:     options,\n\t\t}, nil\n\t}\n\n\t// Bind mount volumes specified for this particular Run() invocation\n\tfor _, i := range optionMounts {\n\t\tlogrus.Debugf(\"setting up mounted volume at %q\", i.Destination)\n\t\tmount, err := parseMount(i.Type, i.Source, i.Destination, i.Options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\t// Bind mount volumes given by the user when the container was created\n\tfor _, i := range volumeMounts {\n\t\tvar options []string\n\t\tspliti := parse.SplitStringWithColonEscape(i)\n\t\tif len(spliti) > 2 {\n\t\t\toptions = strings.Split(spliti[2], \",\")\n\t\t}\n\t\toptions = append(options, \"rbind\")\n\t\tmount, err := parseMount(\"bind\", spliti[0], spliti[1], options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\treturn mounts, nil\n}\n\nfunc setupMaskedPaths(g *generate.Generator) {\n\tfor _, mp := range []string{\n\t\t\"/proc/acpi\",\n\t\t\"/proc/kcore\",\n\t\t\"/proc/keys\",\n\t\t\"/proc/latency_stats\",\n\t\t\"/proc/timer_list\",\n\t\t\"/proc/timer_stats\",\n\t\t\"/proc/sched_debug\",\n\t\t\"/proc/scsi\",\n\t\t\"/sys/firmware\",\n\t\t\"/sys/fs/selinux\",\n\t\t\"/sys/dev\",\n\t} {\n\t\tg.AddLinuxMaskedPaths(mp)\n\t}\n}\n\nfunc setupReadOnlyPaths(g *generate.Generator) {\n\tfor _, rp := range []string{\n\t\t\"/proc/asound\",\n\t\t\"/proc/bus\",\n\t\t\"/proc/fs\",\n\t\t\"/proc/irq\",\n\t\t\"/proc/sys\",\n\t\t\"/proc/sysrq-trigger\",\n\t} {\n\t\tg.AddLinuxReadonlyPaths(rp)\n\t}\n}\n\nfunc setupCapAdd(g *generate.Generator, caps ...string) error {\n\tfor _, cap := range caps {\n\t\tif err := g.AddProcessCapabilityBounding(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the bounding capability set\", cap)\n\t\t}\n\t\tif err := g.AddProcessCapabilityEffective(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the effective capability set\", cap)\n\t\t}\n\t\tif err := g.AddProcessCapabilityPermitted(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the permitted capability set\", cap)\n\t\t}\n\t\tif err := g.AddProcessCapabilityAmbient(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error adding %q to the ambient capability set\", cap)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupCapDrop(g *generate.Generator, caps ...string) error {\n\tfor _, cap := range caps {\n\t\tif err := g.DropProcessCapabilityBounding(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the bounding capability set\", cap)\n\t\t}\n\t\tif err := g.DropProcessCapabilityEffective(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the effective capability set\", cap)\n\t\t}\n\t\tif err := g.DropProcessCapabilityPermitted(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the permitted capability set\", cap)\n\t\t}\n\t\tif err := g.DropProcessCapabilityAmbient(cap); err != nil {\n\t\t\treturn errors.Wrapf(err, \"error removing %q from the ambient capability set\", cap)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupCapabilities(g *generate.Generator, defaultCapabilities, adds, drops []string) error {\n\tg.ClearProcessCapabilities()\n\tif err := setupCapAdd(g, defaultCapabilities...); err != nil {\n\t\treturn err\n\t}\n\tfor _, c := range adds {\n\t\tif strings.ToLower(c) == \"all\" {\n\t\t\tadds = capabilities.AllCapabilities()\n\t\t\tbreak\n\t\t}\n\t}\n\tfor _, c := range drops {\n\t\tif strings.ToLower(c) == \"all\" {\n\t\t\tg.ClearProcessCapabilities()\n\t\t\treturn nil\n\t\t}\n\t}\n\tif err := setupCapAdd(g, adds...); err != nil {\n\t\treturn err\n\t}\n\treturn setupCapDrop(g, drops...)\n}\n\n// Search for a command that isn't given as an absolute path using the $PATH\n// under the rootfs.  We can't resolve absolute symbolic links without\n// chroot()ing, which we may not be able to do, so just accept a link as a\n// valid resolution.\nfunc runLookupPath(g *generate.Generator, command []string) []string {\n\t// Look for the configured $PATH.\n\tspec := g.Config\n\tenvPath := \"\"\n\tfor i := range spec.Process.Env {\n\t\tif strings.HasPrefix(spec.Process.Env[i], \"PATH=\") {\n\t\t\tenvPath = spec.Process.Env[i]\n\t\t}\n\t}\n\t// If there is no configured $PATH, supply one.\n\tif envPath == \"\" {\n\t\tdefaultPath := \"/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin\"\n\t\tenvPath = \"PATH=\" + defaultPath\n\t\tg.AddProcessEnv(\"PATH\", defaultPath)\n\t}\n\t// No command, nothing to do.\n\tif len(command) == 0 {\n\t\treturn command\n\t}\n\t// Command is already an absolute path, use it as-is.\n\tif filepath.IsAbs(command[0]) {\n\t\treturn command\n\t}\n\t// For each element in the PATH,\n\tfor _, pathEntry := range filepath.SplitList(envPath[5:]) {\n\t\t// if it's the empty string, it's \".\", which is the Cwd,\n\t\tif pathEntry == \"\" {\n\t\t\tpathEntry = spec.Process.Cwd\n\t\t}\n\t\t// build the absolute path which it might be,\n\t\tcandidate := filepath.Join(pathEntry, command[0])\n\t\t// check if it's there,\n\t\tif fi, err := os.Lstat(filepath.Join(spec.Root.Path, candidate)); fi != nil && err == nil {\n\t\t\t// and if it's not a directory, and either a symlink or executable,\n\t\t\tif !fi.IsDir() && ((fi.Mode()&os.ModeSymlink != 0) || (fi.Mode()&0111 != 0)) {\n\t\t\t\t// use that.\n\t\t\t\treturn append([]string{candidate}, command[1:]...)\n\t\t\t}\n\t\t}\n\t}\n\treturn command\n}\n\nfunc getDNSIP(dnsServers []string) (dns []net.IP, err error) {\n\tfor _, i := range dnsServers {\n\t\tresult := net.ParseIP(i)\n\t\tif result == nil {\n\t\t\treturn dns, errors.Errorf(\"invalid IP address %s\", i)\n\t\t}\n\t\tdns = append(dns, result)\n\t}\n\treturn dns, nil\n}\n\nfunc (b *Builder) configureUIDGID(g *generate.Generator, mountPoint string, options RunOptions) (string, error) {\n\t// Set the user UID/GID/supplemental group list/capabilities lists.\n\tuser, homeDir, err := b.userForRun(mountPoint, options.User)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := setupCapabilities(g, b.Capabilities, options.AddCapabilities, options.DropCapabilities); err != nil {\n\t\treturn \"\", err\n\t}\n\tg.SetProcessUID(user.UID)\n\tg.SetProcessGID(user.GID)\n\tfor _, gid := range user.AdditionalGids {\n\t\tg.AddProcessAdditionalGid(gid)\n\t}\n\n\t// Remove capabilities if not running as root except Bounding set\n\tif user.UID != 0 {\n\t\tbounding := g.Config.Process.Capabilities.Bounding\n\t\tg.ClearProcessCapabilities()\n\t\tg.Config.Process.Capabilities.Bounding = bounding\n\t}\n\n\treturn homeDir, nil\n}\n\nfunc (b *Builder) configureEnvironment(g *generate.Generator, options RunOptions, defaultEnv []string) {\n\tg.ClearProcessEnv()\n\n\tif b.CommonBuildOpts.HTTPProxy {\n\t\tfor _, envSpec := range config.ProxyEnv {\n\t\t\tif envVal, ok := os.LookupEnv(envSpec); ok {\n\t\t\t\tg.AddProcessEnv(envSpec, envVal)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, envSpec := range util.MergeEnv(util.MergeEnv(defaultEnv, b.Env()), options.Env) {\n\t\tenv := strings.SplitN(envSpec, \"=\", 2)\n\t\tif len(env) > 1 {\n\t\t\tg.AddProcessEnv(env[0], env[1])\n\t\t}\n\t}\n}\n\nfunc setupRootlessSpecChanges(spec *specs.Spec, bundleDir string, shmSize string) error {\n\temptyDir := filepath.Join(bundleDir, \"empty\")\n\tif err := os.Mkdir(emptyDir, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// If the container has a network namespace, we can create a fresh /sys mount\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tif ns.Type == specs.NetworkNamespace {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Replace /sys with a read-only bind mount.\n\tmounts := []specs.Mount{\n\t\t{\n\t\t\tSource:      \"/dev\",\n\t\t\tDestination: \"/dev\",\n\t\t\tType:        \"tmpfs\",\n\t\t\tOptions:     []string{\"private\", \"strictatime\", \"noexec\", \"nosuid\", \"mode=755\", \"size=65536k\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"mqueue\",\n\t\t\tDestination: \"/dev/mqueue\",\n\t\t\tType:        \"mqueue\",\n\t\t\tOptions:     []string{\"private\", \"nodev\", \"noexec\", \"nosuid\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"pts\",\n\t\t\tDestination: \"/dev/pts\",\n\t\t\tType:        \"devpts\",\n\t\t\tOptions:     []string{\"private\", \"noexec\", \"nosuid\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"shm\",\n\t\t\tDestination: \"/dev/shm\",\n\t\t\tType:        \"tmpfs\",\n\t\t\tOptions:     []string{\"private\", \"nodev\", \"noexec\", \"nosuid\", \"mode=1777\", fmt.Sprintf(\"size=%s\", shmSize)},\n\t\t},\n\t\t{\n\t\t\tSource:      \"/proc\",\n\t\t\tDestination: \"/proc\",\n\t\t\tType:        \"proc\",\n\t\t\tOptions:     []string{\"private\", \"nodev\", \"noexec\", \"nosuid\"},\n\t\t},\n\t\t{\n\t\t\tSource:      \"/sys\",\n\t\t\tDestination: \"/sys\",\n\t\t\tType:        \"bind\",\n\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"private\", \"nodev\", \"noexec\", \"nosuid\", \"ro\"},\n\t\t},\n\t}\n\n\tcgroup2, err := cgroups.IsCgroup2UnifiedMode()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cgroup2 {\n\t\thasCgroupNs := false\n\t\tfor _, ns := range spec.Linux.Namespaces {\n\t\t\tif ns.Type == specs.CgroupNamespace {\n\t\t\t\thasCgroupNs = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif hasCgroupNs {\n\t\t\tmounts = append(mounts, specs.Mount{\n\t\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\t\tType:        \"cgroup\",\n\t\t\t\tSource:      \"cgroup\",\n\t\t\t\tOptions:     []string{\"private\", \"rw\"},\n\t\t\t})\n\t\t}\n\t} else {\n\t\tspec.Linux.Resources = nil\n\t\t// Cover up /sys/fs/cgroup, if it exist in our source for /sys.\n\t\tif _, err := os.Stat(\"/sys/fs/cgroup\"); err == nil {\n\t\t\tspec.Linux.MaskedPaths = append(spec.Linux.MaskedPaths, \"/sys/fs/cgroup\")\n\t\t}\n\t}\n\t// Keep anything that isn't under /dev, /proc, or /sys.\n\tfor i := range spec.Mounts {\n\t\tif spec.Mounts[i].Destination == \"/dev\" || strings.HasPrefix(spec.Mounts[i].Destination, \"/dev/\") ||\n\t\t\tspec.Mounts[i].Destination == \"/proc\" || strings.HasPrefix(spec.Mounts[i].Destination, \"/proc/\") ||\n\t\t\tspec.Mounts[i].Destination == \"/sys\" || strings.HasPrefix(spec.Mounts[i].Destination, \"/sys/\") {\n\t\t\tcontinue\n\t\t}\n\t\tmounts = append(mounts, spec.Mounts[i])\n\t}\n\tspec.Mounts = mounts\n\treturn nil\n}\n\nfunc (b *Builder) runUsingRuntimeSubproc(isolation define.Isolation, options RunOptions, configureNetwork bool, configureNetworks, moreCreateArgs []string, spec *specs.Spec, rootPath, bundlePath, containerName string) (err error) {\n\tvar confwg sync.WaitGroup\n\tconfig, conferr := json.Marshal(runUsingRuntimeSubprocOptions{\n\t\tOptions:          options,\n\t\tSpec:             spec,\n\t\tRootPath:         rootPath,\n\t\tBundlePath:       bundlePath,\n\t\tConfigureNetwork: configureNetwork,\n\t\tMoreCreateArgs:   moreCreateArgs,\n\t\tContainerName:    containerName,\n\t\tIsolation:        isolation,\n\t})\n\tif conferr != nil {\n\t\treturn errors.Wrapf(conferr, \"error encoding configuration for %q\", runUsingRuntimeCommand)\n\t}\n\tcmd := reexec.Command(runUsingRuntimeCommand)\n\tcmd.Dir = bundlePath\n\tcmd.Stdin = options.Stdin\n\tif cmd.Stdin == nil {\n\t\tcmd.Stdin = os.Stdin\n\t}\n\tcmd.Stdout = options.Stdout\n\tif cmd.Stdout == nil {\n\t\tcmd.Stdout = os.Stdout\n\t}\n\tcmd.Stderr = options.Stderr\n\tif cmd.Stderr == nil {\n\t\tcmd.Stderr = os.Stderr\n\t}\n\tcmd.Env = util.MergeEnv(os.Environ(), []string{fmt.Sprintf(\"LOGLEVEL=%d\", logrus.GetLevel())})\n\tpreader, pwriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error creating configuration pipe\")\n\t}\n\tconfwg.Add(1)\n\tgo func() {\n\t\t_, conferr = io.Copy(pwriter, bytes.NewReader(config))\n\t\tif conferr != nil {\n\t\t\tconferr = errors.Wrapf(conferr, \"error while copying configuration down pipe to child process\")\n\t\t}\n\t\tconfwg.Done()\n\t}()\n\n\t// create network configuration pipes\n\tvar containerCreateR, containerCreateW *os.File\n\tvar containerStartR, containerStartW *os.File\n\tif configureNetwork {\n\t\tcontainerCreateR, containerCreateW, err = os.Pipe()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error creating container create pipe\")\n\t\t}\n\t\tdefer containerCreateR.Close()\n\t\tdefer containerCreateW.Close()\n\n\t\tcontainerStartR, containerStartW, err = os.Pipe()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error creating container create pipe\")\n\t\t}\n\t\tdefer containerStartR.Close()\n\t\tdefer containerStartW.Close()\n\t\tcmd.ExtraFiles = []*os.File{containerCreateW, containerStartR}\n\t}\n\n\tcmd.ExtraFiles = append([]*os.File{preader}, cmd.ExtraFiles...)\n\tdefer preader.Close()\n\tdefer pwriter.Close()\n\tif err := cmd.Start(); err != nil {\n\t\treturn errors.Wrapf(err, \"error while starting runtime\")\n\t}\n\n\tif configureNetwork {\n\t\tif err := waitForSync(containerCreateR); err != nil {\n\t\t\t// we do not want to return here since we want to capture the exit code from the child via cmd.Wait()\n\t\t\t// close the pipes here so that the child will not hang forever\n\t\t\tcontainerCreateR.Close()\n\t\t\tcontainerStartW.Close()\n\t\t\tlogrus.Errorf(\"did not get container create message from subprocess: %v\", err)\n\t\t} else {\n\t\t\tpidFile := filepath.Join(bundlePath, \"pid\")\n\t\t\tpidValue, err := ioutil.ReadFile(pidFile)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpid, err := strconv.Atoi(strings.TrimSpace(string(pidValue)))\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error parsing pid %s as a number\", string(pidValue))\n\t\t\t}\n\n\t\t\tteardown, err := b.runConfigureNetwork(pid, isolation, options, configureNetworks, containerName)\n\t\t\tif teardown != nil {\n\t\t\t\tdefer teardown()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tlogrus.Debug(\"network namespace successfully setup, send start message to child\")\n\t\t\t_, err = containerStartW.Write([]byte{1})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif err := cmd.Wait(); err != nil {\n\t\treturn errors.Wrapf(err, \"error while running runtime\")\n\t}\n\tconfwg.Wait()\n\tif err == nil {\n\t\treturn conferr\n\t}\n\tif conferr != nil {\n\t\tlogrus.Debugf(\"%v\", conferr)\n\t}\n\treturn err\n}\n\n// waitForSync waits for a maximum of 5 seconds to read something from the file\nfunc waitForSync(pipeR *os.File) error {\n\tif err := pipeR.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n\t\treturn err\n\t}\n\tb := make([]byte, 16)\n\t_, err := pipeR.Read(b)\n\treturn err\n}\n\nfunc checkAndOverrideIsolationOptions(isolation define.Isolation, options *RunOptions) error {\n\tswitch isolation {\n\tcase IsolationOCIRootless:\n\t\tif ns := options.NamespaceOptions.Find(string(specs.IPCNamespace)); ns == nil || ns.Host {\n\t\t\tlogrus.Debugf(\"Forcing use of an IPC namespace.\")\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.IPCNamespace)})\n\t\t_, err := exec.LookPath(\"slirp4netns\")\n\t\thostNetworking := err != nil\n\t\tnetworkNamespacePath := \"\"\n\t\tif ns := options.NamespaceOptions.Find(string(specs.NetworkNamespace)); ns != nil {\n\t\t\thostNetworking = ns.Host\n\t\t\tnetworkNamespacePath = ns.Path\n\t\t\tif hostNetworking {\n\t\t\t\tnetworkNamespacePath = \"\"\n\t\t\t}\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{\n\t\t\tName: string(specs.NetworkNamespace),\n\t\t\tHost: hostNetworking,\n\t\t\tPath: networkNamespacePath,\n\t\t})\n\t\tif ns := options.NamespaceOptions.Find(string(specs.PIDNamespace)); ns == nil || ns.Host {\n\t\t\tlogrus.Debugf(\"Forcing use of a PID namespace.\")\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.PIDNamespace), Host: false})\n\t\tif ns := options.NamespaceOptions.Find(string(specs.UserNamespace)); ns == nil || ns.Host {\n\t\t\tlogrus.Debugf(\"Forcing use of a user namespace.\")\n\t\t}\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.UserNamespace)})\n\tcase IsolationOCI:\n\t\tpidns := options.NamespaceOptions.Find(string(specs.PIDNamespace))\n\t\tuserns := options.NamespaceOptions.Find(string(specs.UserNamespace))\n\t\tif (pidns != nil && pidns.Host) && (userns != nil && !userns.Host) {\n\t\t\treturn errors.Errorf(\"not allowed to mix host PID namespace with container user namespace\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// DefaultNamespaceOptions returns the default namespace settings from the\n// runtime-tools generator library.\nfunc DefaultNamespaceOptions() (define.NamespaceOptions, error) {\n\tcfg, err := config.Default()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to get container config\")\n\t}\n\toptions := define.NamespaceOptions{\n\t\t{Name: string(specs.CgroupNamespace), Host: cfg.CgroupNS() == \"host\"},\n\t\t{Name: string(specs.IPCNamespace), Host: cfg.IPCNS() == \"host\"},\n\t\t{Name: string(specs.MountNamespace), Host: true},\n\t\t{Name: string(specs.NetworkNamespace), Host: cfg.NetNS() == \"host\" || cfg.NetNS() == \"container\"},\n\t\t{Name: string(specs.PIDNamespace), Host: cfg.PidNS() == \"host\"},\n\t\t{Name: string(specs.UserNamespace), Host: true},\n\t\t{Name: string(specs.UTSNamespace), Host: cfg.UTSNS() == \"host\"},\n\t}\n\tg, err := generate.New(\"linux\")\n\tif err != nil {\n\t\treturn options, errors.Wrapf(err, \"error generating new 'linux' runtime spec\")\n\t}\n\tspec := g.Config\n\tif spec.Linux != nil {\n\t\tfor _, ns := range spec.Linux.Namespaces {\n\t\t\toptions.AddOrReplace(define.NamespaceOption{\n\t\t\t\tName: string(ns.Type),\n\t\t\t\tPath: ns.Path,\n\t\t\t})\n\t\t}\n\t}\n\treturn options, nil\n}\n\nfunc contains(volumes []string, v string) bool {\n\tfor _, i := range volumes {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\ntype runUsingRuntimeSubprocOptions struct {\n\tOptions          RunOptions\n\tSpec             *specs.Spec\n\tRootPath         string\n\tBundlePath       string\n\tConfigureNetwork bool\n\tMoreCreateArgs   []string\n\tContainerName    string\n\tIsolation        define.Isolation\n}\n\nfunc init() {\n\treexec.Register(runUsingRuntimeCommand, runUsingRuntimeMain)\n}\n\n// runSetupRunMounts sets up mounts that exist only in this RUN, not in subsequent runs\nfunc (b *Builder) runSetupRunMounts(context *imagetypes.SystemContext, mounts []string, secrets map[string]define.Secret, stageMountPoints map[string]internal.StageMountDetails, sshSources map[string]*sshagent.Source, containerWorkingDir string, contextDir string, uidmap []spec.LinuxIDMapping, gidmap []spec.LinuxIDMapping, rootUID int, rootGID int, processUID int, processGID int) ([]spec.Mount, *runMountArtifacts, error) {\n\tmountTargets := make([]string, 0, 10)\n\ttmpFiles := make([]string, 0, len(mounts))\n\tmountImages := make([]string, 0, 10)\n\tfinalMounts := make([]specs.Mount, 0, len(mounts))\n\tagents := make([]*sshagent.AgentServer, 0, len(mounts))\n\tsshCount := 0\n\tdefaultSSHSock := \"\"\n\ttokens := []string{}\n\tfor _, mount := range mounts {\n\t\tarr := strings.SplitN(mount, \",\", 2)\n\n\t\tkv := strings.Split(arr[0], \"=\")\n\t\tif len(kv) != 2 || kv[0] != \"type\" {\n\t\t\treturn nil, nil, errors.New(\"invalid mount type\")\n\t\t}\n\t\tif len(arr) == 2 {\n\t\t\ttokens = strings.Split(arr[1], \",\")\n\t\t}\n\t\t// For now, we only support type secret.\n\t\tswitch kv[1] {\n\t\tcase \"secret\":\n\t\t\tmount, envFile, err := getSecretMount(tokens, secrets, b.MountLabel, containerWorkingDir, uidmap, gidmap)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif mount != nil {\n\t\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\t\t\tif envFile != \"\" {\n\t\t\t\t\ttmpFiles = append(tmpFiles, envFile)\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"ssh\":\n\t\t\tmount, agent, err := b.getSSHMount(tokens, sshCount, sshSources, b.MountLabel, uidmap, gidmap, b.ProcessLabel)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif mount != nil {\n\t\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\t\t\tagents = append(agents, agent)\n\t\t\t\tif sshCount == 0 {\n\t\t\t\t\tdefaultSSHSock = mount.Destination\n\t\t\t\t}\n\t\t\t\t// Count is needed as the default destination of the ssh sock inside the container is  /run/buildkit/ssh_agent.{i}\n\t\t\t\tsshCount++\n\t\t\t}\n\t\tcase \"bind\":\n\t\t\tmount, image, err := b.getBindMount(context, tokens, contextDir, rootUID, rootGID, processUID, processGID, stageMountPoints)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\t\t// only perform cleanup if image was mounted ignore everything else\n\t\t\tif image != \"\" {\n\t\t\t\tmountImages = append(mountImages, image)\n\t\t\t}\n\t\tcase \"tmpfs\":\n\t\t\tmount, err := b.getTmpfsMount(tokens, rootUID, rootGID, processUID, processGID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\tcase \"cache\":\n\t\t\tmount, err := b.getCacheMount(tokens, rootUID, rootGID, processUID, processGID, stageMountPoints)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mount)\n\t\t\tmountTargets = append(mountTargets, mount.Destination)\n\t\tdefault:\n\t\t\treturn nil, nil, errors.Errorf(\"invalid mount type %q\", kv[1])\n\t\t}\n\t}\n\tartifacts := &runMountArtifacts{\n\t\tRunMountTargets: mountTargets,\n\t\tTmpFiles:        tmpFiles,\n\t\tAgents:          agents,\n\t\tMountedImages:   mountImages,\n\t\tSSHAuthSock:     defaultSSHSock,\n\t}\n\treturn finalMounts, artifacts, nil\n}\n\nfunc (b *Builder) getBindMount(context *imagetypes.SystemContext, tokens []string, contextDir string, rootUID, rootGID, processUID, processGID int, stageMountPoints map[string]internal.StageMountDetails) (*spec.Mount, string, error) {\n\tif contextDir == \"\" {\n\t\treturn nil, \"\", errors.New(\"Context Directory for current run invocation is not configured\")\n\t}\n\tvar optionMounts []specs.Mount\n\tmount, image, err := internalParse.GetBindMount(context, tokens, contextDir, b.store, b.MountLabel, stageMountPoints)\n\tif err != nil {\n\t\treturn nil, image, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, rootUID, rootGID, processUID, processGID)\n\tif err != nil {\n\t\treturn nil, image, err\n\t}\n\treturn &volumes[0], image, nil\n}\n\nfunc (b *Builder) getTmpfsMount(tokens []string, rootUID, rootGID, processUID, processGID int) (*spec.Mount, error) {\n\tvar optionMounts []specs.Mount\n\tmount, err := internalParse.GetTmpfsMount(tokens)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, rootUID, rootGID, processUID, processGID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &volumes[0], nil\n}\n\nfunc (b *Builder) getCacheMount(tokens []string, rootUID, rootGID, processUID, processGID int, stageMountPoints map[string]internal.StageMountDetails) (*spec.Mount, error) {\n\tvar optionMounts []specs.Mount\n\tmount, err := internalParse.GetCacheMount(tokens, b.store, b.MountLabel, stageMountPoints)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, rootUID, rootGID, processUID, processGID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &volumes[0], nil\n}\n\nfunc getSecretMount(tokens []string, secrets map[string]define.Secret, mountlabel string, containerWorkingDir string, uidmap []spec.LinuxIDMapping, gidmap []spec.LinuxIDMapping) (*spec.Mount, string, error) {\n\terrInvalidSyntax := errors.New(\"secret should have syntax id=id[,target=path,required=bool,mode=uint,uid=uint,gid=uint\")\n\tif len(tokens) == 0 {\n\t\treturn nil, \"\", errInvalidSyntax\n\t}\n\tvar err error\n\tvar id, target string\n\tvar required bool\n\tvar uid, gid uint32\n\tvar mode uint32 = 0400\n\tfor _, val := range tokens {\n\t\tkv := strings.SplitN(val, \"=\", 2)\n\t\tswitch kv[0] {\n\t\tcase \"id\":\n\t\t\tid = kv[1]\n\t\tcase \"target\", \"dst\", \"destination\":\n\t\t\ttarget = kv[1]\n\t\tcase \"required\":\n\t\t\trequired, err = strconv.ParseBool(kv[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\tcase \"mode\":\n\t\t\tmode64, err := strconv.ParseUint(kv[1], 8, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tmode = uint32(mode64)\n\t\tcase \"uid\":\n\t\t\tuid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tuid = uint32(uid64)\n\t\tcase \"gid\":\n\t\t\tgid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tgid = uint32(gid64)\n\t\tdefault:\n\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t}\n\t}\n\n\tif id == \"\" {\n\t\treturn nil, \"\", errInvalidSyntax\n\t}\n\t// Default location for secretis is /run/secrets/id\n\tif target == \"\" {\n\t\ttarget = \"/run/secrets/\" + id\n\t}\n\n\tsecr, ok := secrets[id]\n\tif !ok {\n\t\tif required {\n\t\t\treturn nil, \"\", errors.Errorf(\"secret required but no secret with id %s found\", id)\n\t\t}\n\t\treturn nil, \"\", nil\n\t}\n\tvar data []byte\n\tvar envFile string\n\tvar ctrFileOnHost string\n\n\tswitch secr.SourceType {\n\tcase \"env\":\n\t\tdata = []byte(os.Getenv(secr.Source))\n\t\ttmpFile, err := ioutil.TempFile(\"/dev/shm\", \"buildah*\")\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tenvFile = tmpFile.Name()\n\t\tctrFileOnHost = tmpFile.Name()\n\tcase \"file\":\n\t\tdata, err = ioutil.ReadFile(secr.Source)\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tctrFileOnHost = filepath.Join(containerWorkingDir, \"secrets\", id)\n\t\t_, err = os.Stat(ctrFileOnHost)\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, \"\", err\n\t\t}\n\tdefault:\n\t\treturn nil, \"\", errors.New(\"invalid source secret type\")\n\t}\n\n\t// Copy secrets to container working dir (or tmp dir if it's an env), since we need to chmod,\n\t// chown and relabel it for the container user and we don't want to mess with the original file\n\tif err := os.MkdirAll(filepath.Dir(ctrFileOnHost), 0755); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := ioutil.WriteFile(ctrFileOnHost, data, 0644); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tif err := label.Relabel(ctrFileOnHost, mountlabel, false); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\thostUID, hostGID, err := util.GetHostIDs(uidmap, gidmap, uid, gid)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := os.Lchown(ctrFileOnHost, int(hostUID), int(hostGID)); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := os.Chmod(ctrFileOnHost, os.FileMode(mode)); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tnewMount := specs.Mount{\n\t\tDestination: target,\n\t\tType:        \"bind\",\n\t\tSource:      ctrFileOnHost,\n\t\tOptions:     []string{\"bind\", \"rprivate\", \"ro\"},\n\t}\n\treturn &newMount, envFile, nil\n}\n\n// getSSHMount parses the --mount type=ssh flag in the Containerfile, checks if there's an ssh source provided, and creates and starts an ssh-agent to be forwarded into the container\nfunc (b *Builder) getSSHMount(tokens []string, count int, sshsources map[string]*sshagent.Source, mountlabel string, uidmap []spec.LinuxIDMapping, gidmap []spec.LinuxIDMapping, processLabel string) (*spec.Mount, *sshagent.AgentServer, error) {\n\terrInvalidSyntax := errors.New(\"ssh should have syntax id=id[,target=path,required=bool,mode=uint,uid=uint,gid=uint\")\n\n\tvar err error\n\tvar id, target string\n\tvar required bool\n\tvar uid, gid uint32\n\tvar mode uint32 = 400\n\tfor _, val := range tokens {\n\t\tkv := strings.SplitN(val, \"=\", 2)\n\t\tif len(kv) < 2 {\n\t\t\treturn nil, nil, errInvalidSyntax\n\t\t}\n\t\tswitch kv[0] {\n\t\tcase \"id\":\n\t\t\tid = kv[1]\n\t\tcase \"target\", \"dst\", \"destination\":\n\t\t\ttarget = kv[1]\n\t\tcase \"required\":\n\t\t\trequired, err = strconv.ParseBool(kv[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\tcase \"mode\":\n\t\t\tmode64, err := strconv.ParseUint(kv[1], 8, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tmode = uint32(mode64)\n\t\tcase \"uid\":\n\t\t\tuid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tuid = uint32(uid64)\n\t\tcase \"gid\":\n\t\t\tgid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tgid = uint32(gid64)\n\t\tdefault:\n\t\t\treturn nil, nil, errInvalidSyntax\n\t\t}\n\t}\n\n\tif id == \"\" {\n\t\tid = \"default\"\n\t}\n\t// Default location for secretis is /run/buildkit/ssh_agent.{i}\n\tif target == \"\" {\n\t\ttarget = fmt.Sprintf(\"/run/buildkit/ssh_agent.%d\", count)\n\t}\n\n\tsshsource, ok := sshsources[id]\n\tif !ok {\n\t\tif required {\n\t\t\treturn nil, nil, errors.Errorf(\"ssh required but no ssh with id %s found\", id)\n\t\t}\n\t\treturn nil, nil, nil\n\t}\n\t// Create new agent from keys or socket\n\tfwdAgent, err := sshagent.NewAgentServer(sshsource)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\t// Start ssh server, and get the host sock we're mounting in the container\n\thostSock, err := fwdAgent.Serve(processLabel)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := label.Relabel(filepath.Dir(hostSock), mountlabel, false); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := label.Relabel(hostSock, mountlabel, false); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\n\thostUID, hostGID, err := util.GetHostIDs(uidmap, gidmap, uid, gid)\n\tif err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := os.Lchown(hostSock, int(hostUID), int(hostGID)); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := os.Chmod(hostSock, os.FileMode(mode)); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tnewMount := specs.Mount{\n\t\tDestination: target,\n\t\tType:        \"bind\",\n\t\tSource:      hostSock,\n\t\tOptions:     []string{\"bind\", \"rprivate\", \"ro\"},\n\t}\n\treturn &newMount, fwdAgent, nil\n}\n\n// cleanupRunMounts cleans up run mounts so they only appear in this run.\nfunc (b *Builder) cleanupRunMounts(context *imagetypes.SystemContext, mountpoint string, artifacts *runMountArtifacts) error {\n\tfor _, agent := range artifacts.Agents {\n\t\terr := agent.Shutdown()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t//cleanup any mounted images for this run\n\tfor _, image := range artifacts.MountedImages {\n\t\tif image != \"\" {\n\t\t\t// if flow hits here some image was mounted for this run\n\t\t\ti, err := internalUtil.LookupImage(context, b.store, image)\n\t\t\tif err == nil {\n\t\t\t\t// silently try to unmount and do nothing\n\t\t\t\t// if image is being used by something else\n\t\t\t\t_ = i.Unmount(false)\n\t\t\t}\n\t\t\tif errors.Cause(err) == storagetypes.ErrImageUnknown {\n\t\t\t\t// Ignore only if ErrImageUnknown\n\t\t\t\t// Reason: Image is already unmounted do nothing\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\topts := copier.RemoveOptions{\n\t\tAll: true,\n\t}\n\tfor _, path := range artifacts.RunMountTargets {\n\t\terr := copier.Remove(mountpoint, path, opts)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tvar prevErr error\n\tfor _, path := range artifacts.TmpFiles {\n\t\terr := os.Remove(path)\n\t\tif !os.IsNotExist(err) {\n\t\t\tif prevErr != nil {\n\t\t\t\tlogrus.Error(prevErr)\n\t\t\t}\n\t\t\tprevErr = err\n\t\t}\n\t}\n\treturn prevErr\n}\n\n// getNetworkInterface creates the network interface\nfunc getNetworkInterface(store storage.Store, cniConfDir, cniPluginPath string) (nettypes.ContainerNetwork, error) {\n\tconf, err := config.Default()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// copy the config to not modify the default by accident\n\tnewconf := *conf\n\tif len(cniConfDir) > 0 {\n\t\tnewconf.Network.NetworkConfigDir = cniConfDir\n\t}\n\tif len(cniPluginPath) > 0 {\n\t\tplugins := strings.Split(cniPluginPath, string(os.PathListSeparator))\n\t\tnewconf.Network.CNIPluginDirs = plugins\n\t}\n\n\t_, netInt, err := network.NetworkBackend(store, &newconf, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn netInt, nil\n}\n"], "filenames": ["chroot/run.go", "run_linux.go"], "buggy_code_start_loc": [900, 1967], "buggy_code_end_loc": [901, 1990], "fixing_code_start_loc": [900, 1966], "fixing_code_end_loc": [901, 1983], "type": "CWE-276", "message": "A flaw was found in buildah where containers were incorrectly started with non-empty default permissions. A bug was found in Moby (Docker Engine) where containers were incorrectly started with non-empty inheritable Linux process capabilities, enabling an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs. This has the potential to impact confidentiality and integrity.", "other": {"cve": {"id": "CVE-2022-27651", "sourceIdentifier": "secalert@redhat.com", "published": "2022-04-04T20:15:10.990", "lastModified": "2022-09-03T03:56:02.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in buildah where containers were incorrectly started with non-empty default permissions. A bug was found in Moby (Docker Engine) where containers were incorrectly started with non-empty inheritable Linux process capabilities, enabling an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs. This has the potential to impact confidentiality and integrity."}, {"lang": "es", "value": "Se ha encontrado un fallo en buildah por el que los contenedores eran iniciados incorrectamente con permisos por defecto no vac\u00edos. Se ha encontrado un bug en Moby (Docker Engine) donde los contenedores eran iniciados incorrectamente con capacidades de proceso Linux heredables no vac\u00edas, permitiendo a un atacante con acceso a programas con capacidades de archivo heredables elevar esas capacidades al conjunto permitido cuando execve(2) se ejecuta. Esto presenta el potencial de afectar la confidencialidad e integridad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:buildah_project:buildah:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.25.0", "matchCriteriaId": "4131BE2A-9EA3-46B8-B99B-DFE8B4221497"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2066840", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/containers/buildah/commit/e7e55c988c05dd74005184ceb64f097a0cfe645b", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/containers/buildah/security/advisories/GHSA-c3g4-w6cv-6v7h", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/25YI27MENCEPZTTGRVU6BQD5V53FNI52/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2VWH6X6HOFPO6HTESF42HIJZEPXSWVIO/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7NETC7I6RTMMBRJJQVJOJUPDK4W4PQSJ/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containers/buildah/commit/e7e55c988c05dd74005184ceb64f097a0cfe645b"}}