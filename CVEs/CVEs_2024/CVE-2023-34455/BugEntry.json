{"buggy_code": ["/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyInputStream.java\n// Since: 2011/03/31 20:14:56\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A stream filter for reading data compressed by {@link SnappyOutputStream}.\n *\n * @author leo\n */\npublic class SnappyInputStream\n        extends InputStream\n{\n    private boolean finishedReading = false;\n    protected final InputStream in;\n\n    private byte[] compressed;\n    private byte[] uncompressed;\n    private int uncompressedCursor = 0;\n    private int uncompressedLimit = 0;\n\n    private byte[] header = new byte[SnappyCodec.headerSize()];\n\n    /**\n     * Create a filter for reading compressed data as a uncompressed stream\n     *\n     * @param input\n     * @throws IOException\n     */\n    public SnappyInputStream(InputStream input)\n            throws IOException\n    {\n        this.in = input;\n        readHeader();\n    }\n\n    /**\n     * Close the stream\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#close()\n     */\n    @Override\n    public void close()\n            throws IOException\n    {\n        compressed = null;\n        uncompressed = null;\n        if (in != null) {\n            in.close();\n        }\n    }\n\n    protected void readHeader()\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < header.length) {\n            int ret = in.read(header, readBytes, header.length - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n\n        // Quick test of the header\n        if (readBytes == 0) {\n            // Snappy produces at least 1-byte result. So the empty input is not a valid input\n            throw new SnappyIOException(SnappyErrorCode.EMPTY_INPUT, \"Cannot decompress empty stream\");\n        }\n        if (readBytes < header.length || !SnappyCodec.hasMagicHeaderPrefix(header)) {\n            // do the default uncompression\n            // (probably) compressed by Snappy.compress(byte[])\n            readFully(header, readBytes);\n            return;\n        }\n    }\n\n    private static boolean isValidHeader(byte[] header)\n            throws IOException\n    {\n        SnappyCodec codec = SnappyCodec.readHeader(new ByteArrayInputStream(header));\n        if (codec.isValidMagicHeader()) {\n            // The input data is compressed by SnappyOutputStream\n            if (codec.version < SnappyCodec.MINIMUM_COMPATIBLE_VERSION) {\n                throw new SnappyIOException(SnappyErrorCode.INCOMPATIBLE_VERSION, String.format(\n                        \"Compressed with an incompatible codec version %d. At least version %d is required\",\n                        codec.version, SnappyCodec.MINIMUM_COMPATIBLE_VERSION));\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    protected void readFully(byte[] fragment, int fragmentLength)\n            throws IOException\n    {\n        if (fragmentLength == 0) {\n            finishedReading = true;\n            return;\n        }\n        // read the entire input data to the buffer\n        compressed = new byte[Math.max(8 * 1024, fragmentLength)]; // 8K\n        System.arraycopy(fragment, 0, compressed, 0, fragmentLength);\n        int cursor = fragmentLength;\n        for (int readBytes = 0; (readBytes = in.read(compressed, cursor, compressed.length - cursor)) != -1; ) {\n            cursor += readBytes;\n            if (cursor >= compressed.length) {\n                byte[] newBuf = new byte[(compressed.length * 2)];\n                System.arraycopy(compressed, 0, newBuf, 0, compressed.length);\n                compressed = newBuf;\n            }\n        }\n\n        finishedReading = true;\n\n        // Uncompress\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, cursor);\n        uncompressed = new byte[uncompressedLength];\n        Snappy.uncompress(compressed, 0, cursor, uncompressed, 0);\n        this.uncompressedCursor = 0;\n        this.uncompressedLimit = uncompressedLength;\n    }\n\n    /**\n     * Reads up to len bytes of data from the input stream into an array of\n     * bytes.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(byte[] b, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            System.arraycopy(uncompressed, uncompressedCursor, b, byteOffset + writtenBytes, bytesToWrite);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read uncompressed data into the specified array\n     *\n     * @param array\n     * @param byteOffset\n     * @param byteLength\n     * @return written bytes\n     * @throws IOException\n     */\n    public int rawRead(Object array, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            Snappy.arrayCopy(uncompressed, uncompressedCursor, bytesToWrite, array, byteOffset + writtenBytes);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of long elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of double elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of int elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of float elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of short elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 2, len * 2);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read next len bytes\n     *\n     * @param dest\n     * @param offset\n     * @param len\n     * @return read bytes\n     */\n    private int readNext(byte[] dest, int offset, int len)\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < len) {\n            int ret = in.read(dest, readBytes + offset, len - readBytes);\n            if (ret == -1) {\n                finishedReading = true;\n                return readBytes;\n            }\n            readBytes += ret;\n        }\n        return readBytes;\n    }\n\n    protected boolean hasNextChunk()\n            throws IOException\n    {\n        if (finishedReading) {\n            return false;\n        }\n\n        uncompressedCursor = 0;\n        uncompressedLimit = 0;\n\n        int readBytes = readNext(header, 0, 4);\n        if (readBytes < 4) {\n            return false;\n        }\n\n        int chunkSize = SnappyOutputStream.readInt(header, 0);\n        if (chunkSize == SnappyCodec.MAGIC_HEADER_HEAD) {\n            // Concatenated data\n            int remainingHeaderSize = SnappyCodec.headerSize() - 4;\n            readBytes = readNext(header, 4, remainingHeaderSize);\n            if(readBytes < remainingHeaderSize) {\n                throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format(\"Insufficient header size in a concatenated block\"));\n            }\n\n            if (isValidHeader(header)) {\n                return hasNextChunk();\n            }\n            else {\n                return false;\n            }\n        }\n\n        // extend the compressed data buffer size\n        if (compressed == null || chunkSize > compressed.length) {\n            compressed = new byte[chunkSize];\n        }\n        readBytes = 0;\n        while (readBytes < chunkSize) {\n            int ret = in.read(compressed, readBytes, chunkSize - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n        if (readBytes < chunkSize) {\n            throw new IOException(\"failed to read chunk\");\n        }\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, chunkSize);\n        if (uncompressed == null || uncompressedLength > uncompressed.length) {\n            uncompressed = new byte[uncompressedLength];\n        }\n        int actualUncompressedLength = Snappy.uncompress(compressed, 0, chunkSize, uncompressed, 0);\n        if (uncompressedLength != actualUncompressedLength) {\n            throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format(\"expected %,d bytes, but decompressed chunk has %,d bytes\", uncompressedLength, actualUncompressedLength));\n        }\n        uncompressedLimit = actualUncompressedLength;\n\n        return true;\n    }\n\n    /**\n     * Reads the next byte of uncompressed data from the input stream. The value\n     * byte is returned as an int in the range 0 to 255. If no byte is available\n     * because the end of the stream has been reached, the value -1 is returned.\n     * This method blocks until input data is available, the end of the stream\n     * is detected, or an exception is thrown.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read()\n     */\n    @Override\n    public int read()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressed[uncompressedCursor++] & 0xFF;\n        }\n        else {\n            if (hasNextChunk()) {\n                return read();\n            }\n            else {\n                return -1;\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.InputStream#available()\n     */\n    @Override\n    public int available()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressedLimit - uncompressedCursor;\n        }\n        else {\n            if (hasNextChunk()) {\n                return uncompressedLimit - uncompressedCursor;\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$ \n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n\n    /*\n    Tests happy cases for BitShuffle.shuffle method\n    - double: 0, 10\n    - float: 0, 10\n    - int: 0, 10\n    - long: 0, 10\n    - short: 0, 10\n     */\n    @Test\n    public void isValidArrayInputLengthForBitShuffleShuffle()\n            throws Exception\n    {\n        byte[] b = BitShuffle.shuffle(new double[0]);\n        byte[] c = BitShuffle.shuffle(new float[0]);\n        byte[] d = BitShuffle.shuffle(new int[0]);\n        byte[] e = BitShuffle.shuffle(new long[0]);\n        byte[] f = BitShuffle.shuffle(new short[0]);\n        byte[] n = BitShuffle.shuffle(new double[10]);\n        byte[] o = BitShuffle.shuffle(new float[10]);\n        byte[] p = BitShuffle.shuffle(new int[10]);\n        byte[] q = BitShuffle.shuffle(new long[10]);\n        byte[] r = BitShuffle.shuffle(new short[10]);\n    }\n\n    /*\n    Tests sad cases for BitShuffle.shuffle method\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - double: 8\n    - float: 4\n    - int: 4\n    - long: 8\n    - short: 2\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new short[Integer.MAX_VALUE / 2 + 1]);\n    }\n}\n"], "fixing_code": ["/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyInputStream.java\n// Since: 2011/03/31 20:14:56\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A stream filter for reading data compressed by {@link SnappyOutputStream}.\n *\n * @author leo\n */\npublic class SnappyInputStream\n        extends InputStream\n{\n    private boolean finishedReading = false;\n    protected final InputStream in;\n\n    private byte[] compressed;\n    private byte[] uncompressed;\n    private int uncompressedCursor = 0;\n    private int uncompressedLimit = 0;\n\n    private byte[] header = new byte[SnappyCodec.headerSize()];\n\n    /**\n     * Create a filter for reading compressed data as a uncompressed stream\n     *\n     * @param input\n     * @throws IOException\n     */\n    public SnappyInputStream(InputStream input)\n            throws IOException\n    {\n        this.in = input;\n        readHeader();\n    }\n\n    /**\n     * Close the stream\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#close()\n     */\n    @Override\n    public void close()\n            throws IOException\n    {\n        compressed = null;\n        uncompressed = null;\n        if (in != null) {\n            in.close();\n        }\n    }\n\n    protected void readHeader()\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < header.length) {\n            int ret = in.read(header, readBytes, header.length - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n\n        // Quick test of the header\n        if (readBytes == 0) {\n            // Snappy produces at least 1-byte result. So the empty input is not a valid input\n            throw new SnappyIOException(SnappyErrorCode.EMPTY_INPUT, \"Cannot decompress empty stream\");\n        }\n        if (readBytes < header.length || !SnappyCodec.hasMagicHeaderPrefix(header)) {\n            // do the default uncompression\n            // (probably) compressed by Snappy.compress(byte[])\n            readFully(header, readBytes);\n            return;\n        }\n    }\n\n    private static boolean isValidHeader(byte[] header)\n            throws IOException\n    {\n        SnappyCodec codec = SnappyCodec.readHeader(new ByteArrayInputStream(header));\n        if (codec.isValidMagicHeader()) {\n            // The input data is compressed by SnappyOutputStream\n            if (codec.version < SnappyCodec.MINIMUM_COMPATIBLE_VERSION) {\n                throw new SnappyIOException(SnappyErrorCode.INCOMPATIBLE_VERSION, String.format(\n                        \"Compressed with an incompatible codec version %d. At least version %d is required\",\n                        codec.version, SnappyCodec.MINIMUM_COMPATIBLE_VERSION));\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    protected void readFully(byte[] fragment, int fragmentLength)\n            throws IOException\n    {\n        if (fragmentLength == 0) {\n            finishedReading = true;\n            return;\n        }\n        // read the entire input data to the buffer\n        compressed = new byte[Math.max(8 * 1024, fragmentLength)]; // 8K\n        System.arraycopy(fragment, 0, compressed, 0, fragmentLength);\n        int cursor = fragmentLength;\n        for (int readBytes = 0; (readBytes = in.read(compressed, cursor, compressed.length - cursor)) != -1; ) {\n            cursor += readBytes;\n            if (cursor >= compressed.length) {\n                byte[] newBuf = new byte[(compressed.length * 2)];\n                System.arraycopy(compressed, 0, newBuf, 0, compressed.length);\n                compressed = newBuf;\n            }\n        }\n\n        finishedReading = true;\n\n        // Uncompress\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, cursor);\n        uncompressed = new byte[uncompressedLength];\n        Snappy.uncompress(compressed, 0, cursor, uncompressed, 0);\n        this.uncompressedCursor = 0;\n        this.uncompressedLimit = uncompressedLength;\n    }\n\n    /**\n     * Reads up to len bytes of data from the input stream into an array of\n     * bytes.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(byte[] b, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            System.arraycopy(uncompressed, uncompressedCursor, b, byteOffset + writtenBytes, bytesToWrite);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read uncompressed data into the specified array\n     *\n     * @param array\n     * @param byteOffset\n     * @param byteLength\n     * @return written bytes\n     * @throws IOException\n     */\n    public int rawRead(Object array, int byteOffset, int byteLength)\n            throws IOException\n    {\n        int writtenBytes = 0;\n        for (; writtenBytes < byteLength; ) {\n\n            if (uncompressedCursor >= uncompressedLimit) {\n                if (hasNextChunk()) {\n                    continue;\n                }\n                else {\n                    return writtenBytes == 0 ? -1 : writtenBytes;\n                }\n            }\n            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);\n            Snappy.arrayCopy(uncompressed, uncompressedCursor, bytesToWrite, array, byteOffset + writtenBytes);\n            writtenBytes += bytesToWrite;\n            uncompressedCursor += bytesToWrite;\n        }\n\n        return writtenBytes;\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of long elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read long array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(long[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of double elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 8, len * 8);\n    }\n\n    /**\n     * Read double array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(double[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read int array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of int elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(int[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of float elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 4, len * 4);\n    }\n\n    /**\n     * Read float array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(float[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d input\n     * @param off offset\n     * @param len the number of short elements to read\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d, int off, int len)\n            throws IOException\n    {\n        return rawRead(d, off * 2, len * 2);\n    }\n\n    /**\n     * Read short array from the stream\n     *\n     * @param d\n     * @return the total number of bytes read into the buffer, or -1 if there is\n     * no more data because the end of the stream has been reached.\n     * @throws IOException\n     */\n    public int read(short[] d)\n            throws IOException\n    {\n        return read(d, 0, d.length);\n    }\n\n    /**\n     * Read next len bytes\n     *\n     * @param dest\n     * @param offset\n     * @param len\n     * @return read bytes\n     */\n    private int readNext(byte[] dest, int offset, int len)\n            throws IOException\n    {\n        int readBytes = 0;\n        while (readBytes < len) {\n            int ret = in.read(dest, readBytes + offset, len - readBytes);\n            if (ret == -1) {\n                finishedReading = true;\n                return readBytes;\n            }\n            readBytes += ret;\n        }\n        return readBytes;\n    }\n\n    protected boolean hasNextChunk()\n            throws IOException\n    {\n        if (finishedReading) {\n            return false;\n        }\n\n        uncompressedCursor = 0;\n        uncompressedLimit = 0;\n\n        int readBytes = readNext(header, 0, 4);\n        if (readBytes < 4) {\n            return false;\n        }\n\n        int chunkSize = SnappyOutputStream.readInt(header, 0);\n        if (chunkSize == SnappyCodec.MAGIC_HEADER_HEAD) {\n            // Concatenated data\n            int remainingHeaderSize = SnappyCodec.headerSize() - 4;\n            readBytes = readNext(header, 4, remainingHeaderSize);\n            if(readBytes < remainingHeaderSize) {\n                throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format(\"Insufficient header size in a concatenated block\"));\n            }\n\n            if (isValidHeader(header)) {\n                return hasNextChunk();\n            }\n            else {\n                return false;\n            }\n        }\n\n        // chunkSize is negative\n        if (chunkSize < 0) {\n            throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, \"chunkSize is too big or negative : \" + chunkSize);\n        }\n\n        // extend the compressed data buffer size\n        if (compressed == null || chunkSize > compressed.length) {\n            // chunkSize exceeds limit\n            try {\n                compressed = new byte[chunkSize];\n            }\n            catch (java.lang.OutOfMemoryError e) {\n                throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, e.getMessage());\n            }\n        }\n        readBytes = 0;\n        while (readBytes < chunkSize) {\n            int ret = in.read(compressed, readBytes, chunkSize - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n        if (readBytes < chunkSize) {\n            throw new IOException(\"failed to read chunk\");\n        }\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, chunkSize);\n        if (uncompressed == null || uncompressedLength > uncompressed.length) {\n            uncompressed = new byte[uncompressedLength];\n        }\n        int actualUncompressedLength = Snappy.uncompress(compressed, 0, chunkSize, uncompressed, 0);\n        if (uncompressedLength != actualUncompressedLength) {\n            throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format(\"expected %,d bytes, but decompressed chunk has %,d bytes\", uncompressedLength, actualUncompressedLength));\n        }\n        uncompressedLimit = actualUncompressedLength;\n\n        return true;\n    }\n\n    /**\n     * Reads the next byte of uncompressed data from the input stream. The value\n     * byte is returned as an int in the range 0 to 255. If no byte is available\n     * because the end of the stream has been reached, the value -1 is returned.\n     * This method blocks until input data is available, the end of the stream\n     * is detected, or an exception is thrown.\n     */\n    /* (non-Javadoc)\n     * @see java.io.InputStream#read()\n     */\n    @Override\n    public int read()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressed[uncompressedCursor++] & 0xFF;\n        }\n        else {\n            if (hasNextChunk()) {\n                return read();\n            }\n            else {\n                return -1;\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see java.io.InputStream#available()\n     */\n    @Override\n    public int available()\n            throws IOException\n    {\n        if (uncompressedCursor < uncompressedLimit) {\n            return uncompressedLimit - uncompressedCursor;\n        }\n        else {\n            if (hasNextChunk()) {\n                return uncompressedLimit - uncompressedCursor;\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$ \n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n\n    /*\n\n    Tests happy cases for SnappyInputStream.read method\n    - {0}\n     */\n    @Test\n    public void isValidChunkLengthForSnappyInputStreamIn()\n            throws Exception {\n        byte[] data = {0};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.NegativeArraySizeException catched into a SnappyError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamInNegative()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        in.read(out);\n    }\n\n    /*\n    Tests sad cases for SnappyInputStream.read method\n    - Expects a java.lang.OutOfMemoryError\n    - {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0,(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff}\n     */\n    @Test(expected = SnappyError.class)\n    public void isInvalidChunkLengthForSnappyInputStreamOutOfMemory()\n            throws Exception {\n        byte[] data = {-126, 'S', 'N', 'A', 'P', 'P', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};\n        SnappyInputStream in = new SnappyInputStream(new ByteArrayInputStream(data));\n        byte[] out = new byte[50];\n        try {\n            in.read(out);\n        } catch (Exception ignored) {\n            // Exception here will be catched\n            // But OutOfMemoryError will not be caught, and will still be thrown\n        }\n    }\n\n    /*\n    Tests happy cases for BitShuffle.shuffle method\n    - double: 0, 10\n    - float: 0, 10\n    - int: 0, 10\n    - long: 0, 10\n    - short: 0, 10\n    */\n    @Test\n    public void isValidArrayInputLengthForBitShuffleShuffle()\n            throws Exception\n    {\n        byte[] b = BitShuffle.shuffle(new double[0]);\n        byte[] c = BitShuffle.shuffle(new float[0]);\n        byte[] d = BitShuffle.shuffle(new int[0]);\n        byte[] e = BitShuffle.shuffle(new long[0]);\n        byte[] f = BitShuffle.shuffle(new short[0]);\n        byte[] n = BitShuffle.shuffle(new double[10]);\n        byte[] o = BitShuffle.shuffle(new float[10]);\n        byte[] p = BitShuffle.shuffle(new int[10]);\n        byte[] q = BitShuffle.shuffle(new long[10]);\n        byte[] r = BitShuffle.shuffle(new short[10]);\n    }\n\n    /*\n    Tests sad cases for BitShuffle.shuffle method\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - double: 8\n    - float: 4\n    - int: 4\n    - long: 8\n    - short: 2\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new short[Integer.MAX_VALUE / 2 + 1]);\n\n    }\n}\n"], "filenames": ["src/main/java/org/xerial/snappy/SnappyInputStream.java", "src/test/java/org/xerial/snappy/SnappyTest.java"], "buggy_code_start_loc": [419, 28], "buggy_code_end_loc": [423, 388], "fixing_code_start_loc": [420, 29], "fixing_code_end_loc": [434, 438], "type": "CWE-770", "message": "snappy-java is a fast compressor/decompressor for Java. Due to use of an unchecked chunk length, an unrecoverable fatal error can occur in versions prior to 1.1.10.1.\n\nThe code in the function hasNextChunk in the fileSnappyInputStream.java checks if a given stream has more chunks to read. It does that by attempting to read 4 bytes. If it wasn\u2019t possible to read the 4 bytes, the function returns false. Otherwise, if 4 bytes were available, the code treats them as the length of the next chunk.\n\nIn the case that the `compressed` variable is null, a byte array is allocated with the size given by the input data. Since the code doesn\u2019t test the legality of the `chunkSize` variable, it is possible to pass a negative number (such as 0xFFFFFFFF which is -1), which will cause the code to raise a `java.lang.NegativeArraySizeException` exception. A worse case would happen when passing a huge positive value (such as 0x7FFFFFFF), which would raise the fatal `java.lang.OutOfMemoryError` error.\n\nVersion 1.1.10.1 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-34455", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-15T18:15:09.347", "lastModified": "2024-02-01T14:17:17.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snappy-java is a fast compressor/decompressor for Java. Due to use of an unchecked chunk length, an unrecoverable fatal error can occur in versions prior to 1.1.10.1.\n\nThe code in the function hasNextChunk in the fileSnappyInputStream.java checks if a given stream has more chunks to read. It does that by attempting to read 4 bytes. If it wasn\u2019t possible to read the 4 bytes, the function returns false. Otherwise, if 4 bytes were available, the code treats them as the length of the next chunk.\n\nIn the case that the `compressed` variable is null, a byte array is allocated with the size given by the input data. Since the code doesn\u2019t test the legality of the `chunkSize` variable, it is possible to pass a negative number (such as 0xFFFFFFFF which is -1), which will cause the code to raise a `java.lang.NegativeArraySizeException` exception. A worse case would happen when passing a huge positive value (such as 0x7FFFFFFF), which would raise the fatal `java.lang.OutOfMemoryError` error.\n\nVersion 1.1.10.1 contains a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xerial:snappy-java:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.10.1", "matchCriteriaId": "11C2E65C-E284-478A-8D65-351AF645472B"}]}]}], "references": [{"url": "https://github.com/xerial/snappy-java/blob/05c39b2ca9b5b7b39611529cc302d3d796329611/src/main/java/org/xerial/snappy/SnappyInputStream.java#L388", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/xerial/snappy-java/blob/master/src/main/java/org/xerial/snappy/SnappyInputStream.java", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/xerial/snappy-java/commit/3bf67857fcf70d9eea56eed4af7c925671e8eaea", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xerial/snappy-java/security/advisories/GHSA-qcwq-55hx-v3vh", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230818-0009/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xerial/snappy-java/commit/3bf67857fcf70d9eea56eed4af7c925671e8eaea"}}