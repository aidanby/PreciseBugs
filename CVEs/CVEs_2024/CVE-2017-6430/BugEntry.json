{"buggy_code": ["/*\n    etterfilter -- the actual compiler\n\n    Copyright (C) ALoR & NaGA\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n*/\n\n#include <ef.h>\n#include <ef_functions.h>\n\n/* ef_globals */\n\n/* \n * the compiler works this way:\n *\n * while bison parses the input it calls the function to\n * create temporary lists of \"blocks\". a block is a compound\n * of virtual instruction. every block element can contain a\n * single instruction or a if block.\n * the if block contains a link to the conditions list and two\n * link for the two block to be executed if the condition is \n * true or the else block (if any).\n *\n * so, after bison has finished its parsing we have a tree of \n * virtual instructions like that:\n * \n *   -----------\n *  | tree root |\n *   ----------- \n *        |\n *   -----------         -------------\n *  | block elm |  -->  | instruction |\n *   -----------         -------------\n *        |\n *   -----------         -------------\n *  | block elm |  -->  | instruction |\n *   -----------         -------------\n *        |\n *   -----------         -------------       ------------\n *  | block elm |  -->  |   if block  | --> | conditions |\n *   -----------         -------------       ------------\n *        .               /         \\\n *        .        -----------    -----------\n *        .       | block elm |  | block elm | . . .\n *                 -----------    -----------\n *                      .               .\n *                      .               .\n * \n * to create a binary filter we have to unfold the tree by converting\n * the conditions into test, eliminating the virtual if block and \n * create the right conditional jumps.\n * during the first unfolding the jumps are referencing virtual labels.\n * all the instructions are unfolded in a double-linked list.\n *\n * the last phase involves the tanslation of the labels into real offsets\n */\n\nstatic struct block *tree_root;\n\nstruct unfold_elm {\n   u_int32 label;\n   struct filter_op fop;\n   TAILQ_ENTRY (unfold_elm) next;\n};\n\nstatic TAILQ_HEAD(, unfold_elm) unfolded_tree = TAILQ_HEAD_INITIALIZER(unfolded_tree);\n\n/* label = 0 means \"no label\" */\nstatic u_int32 vlabel = 1;\n\n/* protos */\n\nstatic void unfold_blk(struct block **blk);\nstatic void unfold_ifblk(struct block **blk);\nstatic void unfold_conds(struct condition *cnd, u_int32 a, u_int32 b);\nstatic void labels_to_offsets(void);\n\n/*******************************************/\n\n/*\n * set the entry point of the filter tree\n */\nint compiler_set_root(struct block *blk)\n{\n   BUG_IF(blk == NULL);\n   tree_root = blk;\n   return E_SUCCESS;\n}\n\n/*\n * allocate an instruction container for filter_op\n */\nstruct instruction * compiler_create_instruction(struct filter_op *fop)\n{\n   struct instruction *ins;\n\n   SAFE_CALLOC(ins, 1, sizeof(struct instruction));\n   \n   /* copy the instruction */\n   memcpy(&ins->fop, fop, sizeof(struct filter_op));\n\n   return ins;\n}\n\n\n/*\n * allocate a condition container for filter_op\n */\nstruct condition * compiler_create_condition(struct filter_op *fop)\n{\n   struct condition *cnd;\n\n   SAFE_CALLOC(cnd, 1, sizeof(struct condition));\n   \n   /* copy the instruction */\n   memcpy(&cnd->fop, fop, sizeof(struct filter_op));\n\n   return cnd;\n}\n\n\n/*\n * concatenates two conditions with a logical operator \n */\nstruct condition * compiler_concat_conditions(struct condition *a, u_int16 op, struct condition *b)\n{\n   struct condition *head = a;\n   \n   /* go to the last conditions in 'a' */\n   while(a->next != NULL)\n      a = a->next;\n   \n   /* set the operation */\n   a->op = op;\n\n   /* contatenate the two block */\n   a->next = b;\n   \n   /* return the head of the conditions */\n   return head;\n}\n\n/*\n * allocate a ifblock container\n */\nstruct ifblock * compiler_create_ifblock(struct condition *conds, struct block *blk)\n{\n   struct ifblock *ifblk;\n\n   SAFE_CALLOC(ifblk, 1, sizeof(struct ifblock));\n\n   /* associate the pointers */\n   ifblk->conds = conds;\n   ifblk->blk = blk;\n\n   return ifblk;\n}\n\n\n/*\n * allocate a if_else_block container\n */\nstruct ifblock * compiler_create_ifelseblock(struct condition *conds, struct block *blk, struct block *elseblk)\n{\n   struct ifblock *ifblk;\n\n   SAFE_CALLOC(ifblk, 1, sizeof(struct ifblock));\n   \n   /* associate the pointers */\n   ifblk->conds = conds;\n   ifblk->blk = blk;\n   ifblk->elseblk = elseblk;\n\n   return ifblk;\n}\n\n\n/*\n * add an instruction to a block\n */\nstruct block * compiler_add_instr(struct instruction *ins, struct block *blk)\n{\n   struct block *bl;\n\n   SAFE_CALLOC(bl, 1, sizeof(struct block));\n\n   /* copy the current instruction in the block */\n   bl->type = BLK_INSTR;\n   bl->un.ins = ins;\n\n   /* link it to the old block chain */\n   bl->next = blk;\n\n   return bl;\n}\n\n\n/* \n * add an if block to a block\n */\nstruct block * compiler_add_ifblk(struct ifblock *ifb, struct block *blk)\n{\n   struct block *bl;\n\n   SAFE_CALLOC(bl, 1, sizeof(struct block));\n\n   /* copy the current instruction in the block */\n   bl->type = BLK_IFBLK;\n   bl->un.ifb = ifb;\n\n   /* link it to the old block chain */\n   bl->next = blk;\n\n   return bl;\n}\n\n\n/*\n * parses the tree and produce a compiled\n * array of filter_op\n */\nsize_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   BUG_IF(tree_root == NULL);\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   /* start the recursion on the tree */\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   /* substitute the virtual labels with real offsets */\n   labels_to_offsets();\n   \n   /* convert the tailq into an array */\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n\n      /* label == 0 means a real instruction */\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   \n   /* always append the exit function to a script */\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   \n   /* return the pointer to the array */\n   *fop = array;\n   \n   return (i);\n}\n\n\n/*\n * unfold a block putting it in the unfolded_tree list\n */\nstatic void unfold_blk(struct block **blk)\n{\n   struct unfold_elm *ue = NULL;\n  \n   BUG_IF(*blk == NULL);\n\n   /* the progress bar */\n   ef_debug(1, \"+\"); \n   \n   do {\n      switch((*blk)->type) {\n         case BLK_INSTR:\n            /* insert the instruction as is */\n            SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n            memcpy(&ue->fop, (*blk)->un.ins, sizeof(struct filter_op));\n            TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n            break;\n\n         case BLK_IFBLK:\n            unfold_ifblk(blk);\n            break;\n            \n         default:\n            BUG(\"undefined tree element\");\n            break;\n      } \n   } while ((*blk = (*blk)->next));\n  \n}\n\n\n/*\n * unfold an if block putting it in the unfolded_tree list\n */\nstatic void unfold_ifblk(struct block **blk)\n{\n   struct ifblock *ifblk;\n   struct unfold_elm *ue;\n   u_int32 a = vlabel++; \n   u_int32 b = vlabel++; \n   u_int32 c = vlabel++; \n\n   /*\n    * the virtual labels represent the three points of an if block:\n    *\n    *    if (conds) {\n    * a ->\n    *       ...\n    *       jmp c;\n    * b ->\n    *    } else {\n    *       ...\n    *    }\n    * c ->\n    *\n    * if the conds are true, jump to 'a'\n    * if the conds are false, jump to 'b'\n    * 'c' is used to skip the else if the conds were true\n    */\n\n   /* the progress bar */\n   ef_debug(1, \"#\"); \n   \n   /* cast the if block */\n   ifblk = (*blk)->un.ifb;\n  \n   /* compile the conditions */\n   unfold_conds(ifblk->conds, a, b);\n   \n   /* if the conditions are match, jump here */\n   SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n   ue->label = a;\n   TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n\n   /* check if the block is empty. i.e.  { } */\n   if (ifblk->blk != NULL) {\n      /* recursively compile the main block */\n      unfold_blk(&ifblk->blk);\n   }\n\n   /* \n    * if there is the else block, we have to skip it\n    * if the condition was true\n    */\n   if (ifblk->elseblk != NULL) {\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      ue->fop.opcode = FOP_JMP;\n      ue->fop.op.jmp = c;\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   }\n   \n   /* if the conditions are NOT match, jump here (after the block) */\n   SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n   ue->label = b;\n   TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   \n   /* recursively compile the else block */\n   if (ifblk->elseblk != NULL) {\n      unfold_blk(&ifblk->elseblk);\n      /* this is the label to skip the else if the condition was true */\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      ue->label = c;\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   }\n\n}\n\n\n/*\n * unfold a conditions block putting it in the unfolded_tree list\n */\nstatic void unfold_conds(struct condition *cnd, u_int32 a, u_int32 b)\n{\n   struct unfold_elm *ue = NULL;\n \n   do {\n   \n      /* the progress bar */\n      ef_debug(1, \"?\"); \n   \n      /* insert the condition as is */\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      memcpy(&ue->fop, &cnd->fop, sizeof(struct filter_op));\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n      \n      /* insert the conditional jump */\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      \n      if (cnd->op == COND_OR) {\n         ue->fop.opcode = FOP_JTRUE;\n         ue->fop.op.jmp = a;\n      } else {\n         /* AND and single instructions behave equally */\n         ue->fop.opcode = FOP_JFALSE;\n         ue->fop.op.jmp = b;\n      }\n      \n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n      \n   } while ((cnd = cnd->next));\n   \n}\n\n/*\n * converts the virtual labels to real offsets\n */\nstatic void labels_to_offsets(void)\n{\n   struct unfold_elm *ue;\n   struct unfold_elm *s;\n   u_int32 offset = 0;\n\n   fprintf(stdout, \" Converting labels to real offsets \");\n   fflush(stdout);\n   \n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      /* search only for jumps */\n      if (ue->fop.opcode == FOP_JMP || \n          ue->fop.opcode == FOP_JTRUE ||\n          ue->fop.opcode == FOP_JFALSE) {\n        \n         switch (ue->fop.opcode) {\n            case FOP_JMP:\n               ef_debug(1, \"*\"); \n               break;\n            case FOP_JTRUE:\n               ef_debug(1, \"+\");\n               break;\n            case FOP_JFALSE:\n               ef_debug(1, \"-\");\n               break;\n         }\n         \n         /* search the offset associated with the label */\n         TAILQ_FOREACH(s, &unfolded_tree, next) {\n            if (s->label == ue->fop.op.jmp) {\n               ue->fop.op.jmp = offset;\n               /* reset the offset */\n               offset = 0;\n               break;\n            }\n            /* if it is an instruction, increment the offset */\n            if (s->label == 0)\n               offset++;\n         }\n      }\n   }\n\n   fprintf(stdout, \" done.\\n\\n\");\n}\n\n/* EOF */\n\n// vim:ts=3:expandtab\n\n", "/*\n    etterfilter -- filter compiler for ettercap content filtering engine\n\n    Copyright (C) ALoR & NaGA\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n*/\n\n#include <ef.h>\n#include <ef_functions.h>\n#include <ec_libettercap.h>\n\n#include <stdarg.h>\n\nstruct ec_globals *ec_gbls;\n\n#define EF_GBL_FREE(x) do{ if (x != NULL) { free(x); x = NULL; } }while(0)\n\n/* ef_globals */\n\nextern FILE * yyin;           /* from scanner */\nextern int yyparse (void);    /* from parser */\n\n/* global options */\nstruct ef_globals *ef_gbls;\n\n/*******************************************/\n\nint main(int argc, char *argv[])\n{\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   /* etterfilter copyright */\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n \n   /* initialize the line number */\n   EF_GBL->lineno = 1;\n  \n   /* getopt related parsing...  */\n   parse_options(argc, argv);\n\n   /* set the input for source file */\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n\n   /* no buffering */\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n\n   \n   /* load the tables in etterfilter.tbl */\n   load_tables();\n   /* load the constants in etterfilter.cnt */\n   load_constants();\n\n   /* print the message */\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n\n   ef_debug(1, \"\\n\");\n\n   /* begin the parsing */\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n  \n   /* write to file */\n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n   ef_globals_free();\n   return 0;\n}\n\n\n/*\n * print debug information\n */\nvoid ef_debug(u_char level, const char *message, ...)\n{ \n   va_list ap;\n   \n   /* if not in debug don't print anything */\n   if (EF_GBL_OPTIONS->debug < level)\n      return;\n\n   /* print the message */ \n   va_start(ap, message);\n   vfprintf (stderr, message, ap);\n   fflush(stderr);\n   va_end(ap);\n   \n}\n\nvoid ef_globals_alloc(void)\n{\n\n   SAFE_CALLOC(ef_gbls, 1, sizeof(struct ef_globals));\n\n   return;\n}\n\nvoid ef_globals_free(void)\n{\n   SAFE_FREE(ef_gbls->source_file);\n   SAFE_FREE(ef_gbls->output_file);\n   SAFE_FREE(ef_gbls);\n\n   return;\n\n}\n\n/* EOF */\n\n// vim:ts=3:expandtab\n\n", "/*\n    etterfilter -- the actual compiler\n\n    Copyright (C) ALoR & NaGA\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n*/\n\n#include <ef.h>\n#include <ef_functions.h>\n#include <ec_filter.h>\n#include <ec_version.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n\n/* protos */\n\nstatic void print_progress_bar(struct filter_op *fop);\nstatic u_char * create_data_segment(struct filter_header *fh, struct filter_op *fop, size_t n);\nstatic size_t add_data_segment(u_char **data, size_t base, u_char **string, size_t slen);\n\n/*******************************************/\n\nint write_output(void)\n{\n   int fd;\n   struct filter_op *fop;\n   struct filter_header fh;\n   size_t ninst, i;\n   u_char *data;\n\n   /* conver the tree to an array of filter_op */\n   ninst = compile_tree(&fop);\n\n   if (fop == NULL)\n      return -E_NOTHANDLED;\n\n   /* create the file */\n   fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);\n   ON_ERROR(fd, -1, \"Can't create file %s\", EF_GBL_OPTIONS->output_file);\n\n   /* display the message */\n   fprintf(stdout, \" Writing output to \\'%s\\' \", EF_GBL_OPTIONS->output_file);\n   fflush(stdout);\n   \n   /* compute the header */\n   fh.magic = htons(EC_FILTER_MAGIC);\n   strncpy(fh.version, EC_VERSION, sizeof(fh.version));\n   fh.data = sizeof(fh);\n\n   data = create_data_segment(&fh, fop, ninst);\n   \n   /* write the header */\n   write(fd, &fh, sizeof(struct filter_header));\n\n   /* write the data segment */\n   write(fd, data, fh.code - fh.data);\n   \n   /* write the instructions */\n   for (i = 0; i <= ninst; i++) {\n      print_progress_bar(&fop[i]);\n      write(fd, &fop[i], sizeof(struct filter_op));\n   }\n\n   close(fd);\n   \n   fprintf(stdout, \" done.\\n\\n\");\n  \n   fprintf(stdout, \" -> Script encoded into %d instructions.\\n\\n\", (int)(i - 1));\n   \n   return E_SUCCESS;\n}\n\n/*\n * creates the data segment into an array\n * and update the file header\n */\nstatic u_char * create_data_segment(struct filter_header *fh, struct filter_op *fop, size_t n)\n{\n   size_t i, len = 0;\n   u_char *data = NULL;\n\n   for (i = 0; i < n; i++) {\n      \n      switch(fop[i].opcode) {\n         case FOP_FUNC:\n            if (fop[i].op.func.slen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.func.string, fop[i].op.func.slen);\n            }\n            if (fop[i].op.func.rlen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.func.replace, fop[i].op.func.rlen);\n            }\n            break;\n            \n         case FOP_TEST:\n            if (fop[i].op.test.slen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.test.string, fop[i].op.test.slen);\n            }\n            break;\n\n         case FOP_ASSIGN:\n            if (fop[i].op.assign.slen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.test.string, fop[i].op.test.slen);\n            }\n            break;\n      }\n\n   }\n  \n   /* where starts the code ? */\n   fh->code = fh->data + len;\n   \n   return data;\n}\n\n\n/* \n * add a string to the buffer \n */\nstatic size_t add_data_segment(u_char **data, size_t base, u_char **string, size_t slen)\n{\n   /* make room for the new string */\n   SAFE_REALLOC(*data, base + slen + 1);\n\n   /* copy the string, NULL separated */\n   memcpy(*data + base, *string, slen + 1);\n\n   /* \n    * change the pointer to the new string location \n    * it is an offset from the base of the data segment\n    */\n   *string = (u_char *)base;\n   \n   /* retur the len of the added string */\n   return slen + 1;\n}\n\n/*\n * prints a differnt sign for every different instruction\n */\nstatic void print_progress_bar(struct filter_op *fop)\n{\n   switch(fop->opcode) {\n      case FOP_EXIT:\n         ef_debug(1, \"!\");\n         break;\n      case FOP_TEST:\n         ef_debug(1, \"?\");\n         break;\n      case FOP_ASSIGN:\n         ef_debug(1, \"=\");\n         break;\n      case FOP_FUNC:\n         ef_debug(1, \".\");\n         break;\n      case FOP_JMP:\n         ef_debug(1, \":\");\n         break;\n      case FOP_JTRUE:\n      case FOP_JFALSE:\n         ef_debug(1, \";\");\n         break;\n   }\n}\n\n/* EOF */\n\n// vim:ts=3:expandtab\n\n"], "fixing_code": ["/*\n    etterfilter -- the actual compiler\n\n    Copyright (C) ALoR & NaGA\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n*/\n\n#include <ef.h>\n#include <ef_functions.h>\n\n/* ef_globals */\n\n/* \n * the compiler works this way:\n *\n * while bison parses the input it calls the function to\n * create temporary lists of \"blocks\". a block is a compound\n * of virtual instruction. every block element can contain a\n * single instruction or a if block.\n * the if block contains a link to the conditions list and two\n * link for the two block to be executed if the condition is \n * true or the else block (if any).\n *\n * so, after bison has finished its parsing we have a tree of \n * virtual instructions like that:\n * \n *   -----------\n *  | tree root |\n *   ----------- \n *        |\n *   -----------         -------------\n *  | block elm |  -->  | instruction |\n *   -----------         -------------\n *        |\n *   -----------         -------------\n *  | block elm |  -->  | instruction |\n *   -----------         -------------\n *        |\n *   -----------         -------------       ------------\n *  | block elm |  -->  |   if block  | --> | conditions |\n *   -----------         -------------       ------------\n *        .               /         \\\n *        .        -----------    -----------\n *        .       | block elm |  | block elm | . . .\n *                 -----------    -----------\n *                      .               .\n *                      .               .\n * \n * to create a binary filter we have to unfold the tree by converting\n * the conditions into test, eliminating the virtual if block and \n * create the right conditional jumps.\n * during the first unfolding the jumps are referencing virtual labels.\n * all the instructions are unfolded in a double-linked list.\n *\n * the last phase involves the tanslation of the labels into real offsets\n */\n\nstatic struct block *tree_root;\n\nstruct unfold_elm {\n   u_int32 label;\n   struct filter_op fop;\n   TAILQ_ENTRY (unfold_elm) next;\n};\n\nstatic TAILQ_HEAD(, unfold_elm) unfolded_tree = TAILQ_HEAD_INITIALIZER(unfolded_tree);\n\n/* label = 0 means \"no label\" */\nstatic u_int32 vlabel = 1;\n\n/* protos */\n\nstatic void unfold_blk(struct block **blk);\nstatic void unfold_ifblk(struct block **blk);\nstatic void unfold_conds(struct condition *cnd, u_int32 a, u_int32 b);\nstatic void labels_to_offsets(void);\n\n/*******************************************/\n\n/*\n * set the entry point of the filter tree\n */\nint compiler_set_root(struct block *blk)\n{\n   BUG_IF(blk == NULL);\n   tree_root = blk;\n   return E_SUCCESS;\n}\n\n/*\n * allocate an instruction container for filter_op\n */\nstruct instruction * compiler_create_instruction(struct filter_op *fop)\n{\n   struct instruction *ins;\n\n   SAFE_CALLOC(ins, 1, sizeof(struct instruction));\n   \n   /* copy the instruction */\n   memcpy(&ins->fop, fop, sizeof(struct filter_op));\n\n   return ins;\n}\n\n\n/*\n * allocate a condition container for filter_op\n */\nstruct condition * compiler_create_condition(struct filter_op *fop)\n{\n   struct condition *cnd;\n\n   SAFE_CALLOC(cnd, 1, sizeof(struct condition));\n   \n   /* copy the instruction */\n   memcpy(&cnd->fop, fop, sizeof(struct filter_op));\n\n   return cnd;\n}\n\n\n/*\n * concatenates two conditions with a logical operator \n */\nstruct condition * compiler_concat_conditions(struct condition *a, u_int16 op, struct condition *b)\n{\n   struct condition *head = a;\n   \n   /* go to the last conditions in 'a' */\n   while(a->next != NULL)\n      a = a->next;\n   \n   /* set the operation */\n   a->op = op;\n\n   /* contatenate the two block */\n   a->next = b;\n   \n   /* return the head of the conditions */\n   return head;\n}\n\n/*\n * allocate a ifblock container\n */\nstruct ifblock * compiler_create_ifblock(struct condition *conds, struct block *blk)\n{\n   struct ifblock *ifblk;\n\n   SAFE_CALLOC(ifblk, 1, sizeof(struct ifblock));\n\n   /* associate the pointers */\n   ifblk->conds = conds;\n   ifblk->blk = blk;\n\n   return ifblk;\n}\n\n\n/*\n * allocate a if_else_block container\n */\nstruct ifblock * compiler_create_ifelseblock(struct condition *conds, struct block *blk, struct block *elseblk)\n{\n   struct ifblock *ifblk;\n\n   SAFE_CALLOC(ifblk, 1, sizeof(struct ifblock));\n   \n   /* associate the pointers */\n   ifblk->conds = conds;\n   ifblk->blk = blk;\n   ifblk->elseblk = elseblk;\n\n   return ifblk;\n}\n\n\n/*\n * add an instruction to a block\n */\nstruct block * compiler_add_instr(struct instruction *ins, struct block *blk)\n{\n   struct block *bl;\n\n   SAFE_CALLOC(bl, 1, sizeof(struct block));\n\n   /* copy the current instruction in the block */\n   bl->type = BLK_INSTR;\n   bl->un.ins = ins;\n\n   /* link it to the old block chain */\n   bl->next = blk;\n\n   return bl;\n}\n\n\n/* \n * add an if block to a block\n */\nstruct block * compiler_add_ifblk(struct ifblock *ifb, struct block *blk)\n{\n   struct block *bl;\n\n   SAFE_CALLOC(bl, 1, sizeof(struct block));\n\n   /* copy the current instruction in the block */\n   bl->type = BLK_IFBLK;\n   bl->un.ifb = ifb;\n\n   /* link it to the old block chain */\n   bl->next = blk;\n\n   return bl;\n}\n\n\n/*\n * parses the tree and produce a compiled\n * array of filter_op\n */\nsize_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   // invalid file\n   if (tree_root == NULL)\n      return 0;\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   /* start the recursion on the tree */\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   /* substitute the virtual labels with real offsets */\n   labels_to_offsets();\n   \n   /* convert the tailq into an array */\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n\n      /* label == 0 means a real instruction */\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   \n   /* always append the exit function to a script */\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   \n   /* return the pointer to the array */\n   *fop = array;\n   \n   return (i);\n}\n\n\n/*\n * unfold a block putting it in the unfolded_tree list\n */\nstatic void unfold_blk(struct block **blk)\n{\n   struct unfold_elm *ue = NULL;\n  \n   BUG_IF(*blk == NULL);\n\n   /* the progress bar */\n   ef_debug(1, \"+\"); \n   \n   do {\n      switch((*blk)->type) {\n         case BLK_INSTR:\n            /* insert the instruction as is */\n            SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n            memcpy(&ue->fop, (*blk)->un.ins, sizeof(struct filter_op));\n            TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n            break;\n\n         case BLK_IFBLK:\n            unfold_ifblk(blk);\n            break;\n            \n         default:\n            BUG(\"undefined tree element\");\n            break;\n      } \n   } while ((*blk = (*blk)->next));\n  \n}\n\n\n/*\n * unfold an if block putting it in the unfolded_tree list\n */\nstatic void unfold_ifblk(struct block **blk)\n{\n   struct ifblock *ifblk;\n   struct unfold_elm *ue;\n   u_int32 a = vlabel++; \n   u_int32 b = vlabel++; \n   u_int32 c = vlabel++; \n\n   /*\n    * the virtual labels represent the three points of an if block:\n    *\n    *    if (conds) {\n    * a ->\n    *       ...\n    *       jmp c;\n    * b ->\n    *    } else {\n    *       ...\n    *    }\n    * c ->\n    *\n    * if the conds are true, jump to 'a'\n    * if the conds are false, jump to 'b'\n    * 'c' is used to skip the else if the conds were true\n    */\n\n   /* the progress bar */\n   ef_debug(1, \"#\"); \n   \n   /* cast the if block */\n   ifblk = (*blk)->un.ifb;\n  \n   /* compile the conditions */\n   unfold_conds(ifblk->conds, a, b);\n   \n   /* if the conditions are match, jump here */\n   SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n   ue->label = a;\n   TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n\n   /* check if the block is empty. i.e.  { } */\n   if (ifblk->blk != NULL) {\n      /* recursively compile the main block */\n      unfold_blk(&ifblk->blk);\n   }\n\n   /* \n    * if there is the else block, we have to skip it\n    * if the condition was true\n    */\n   if (ifblk->elseblk != NULL) {\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      ue->fop.opcode = FOP_JMP;\n      ue->fop.op.jmp = c;\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   }\n   \n   /* if the conditions are NOT match, jump here (after the block) */\n   SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n   ue->label = b;\n   TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   \n   /* recursively compile the else block */\n   if (ifblk->elseblk != NULL) {\n      unfold_blk(&ifblk->elseblk);\n      /* this is the label to skip the else if the condition was true */\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      ue->label = c;\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   }\n\n}\n\n\n/*\n * unfold a conditions block putting it in the unfolded_tree list\n */\nstatic void unfold_conds(struct condition *cnd, u_int32 a, u_int32 b)\n{\n   struct unfold_elm *ue = NULL;\n \n   do {\n   \n      /* the progress bar */\n      ef_debug(1, \"?\"); \n   \n      /* insert the condition as is */\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      memcpy(&ue->fop, &cnd->fop, sizeof(struct filter_op));\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n      \n      /* insert the conditional jump */\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      \n      if (cnd->op == COND_OR) {\n         ue->fop.opcode = FOP_JTRUE;\n         ue->fop.op.jmp = a;\n      } else {\n         /* AND and single instructions behave equally */\n         ue->fop.opcode = FOP_JFALSE;\n         ue->fop.op.jmp = b;\n      }\n      \n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n      \n   } while ((cnd = cnd->next));\n   \n}\n\n/*\n * converts the virtual labels to real offsets\n */\nstatic void labels_to_offsets(void)\n{\n   struct unfold_elm *ue;\n   struct unfold_elm *s;\n   u_int32 offset = 0;\n\n   fprintf(stdout, \" Converting labels to real offsets \");\n   fflush(stdout);\n   \n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      /* search only for jumps */\n      if (ue->fop.opcode == FOP_JMP || \n          ue->fop.opcode == FOP_JTRUE ||\n          ue->fop.opcode == FOP_JFALSE) {\n        \n         switch (ue->fop.opcode) {\n            case FOP_JMP:\n               ef_debug(1, \"*\"); \n               break;\n            case FOP_JTRUE:\n               ef_debug(1, \"+\");\n               break;\n            case FOP_JFALSE:\n               ef_debug(1, \"-\");\n               break;\n         }\n         \n         /* search the offset associated with the label */\n         TAILQ_FOREACH(s, &unfolded_tree, next) {\n            if (s->label == ue->fop.op.jmp) {\n               ue->fop.op.jmp = offset;\n               /* reset the offset */\n               offset = 0;\n               break;\n            }\n            /* if it is an instruction, increment the offset */\n            if (s->label == 0)\n               offset++;\n         }\n      }\n   }\n\n   fprintf(stdout, \" done.\\n\\n\");\n}\n\n/* EOF */\n\n// vim:ts=3:expandtab\n\n", "/*\n    etterfilter -- filter compiler for ettercap content filtering engine\n\n    Copyright (C) ALoR & NaGA\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n*/\n\n#include <ef.h>\n#include <ef_functions.h>\n#include <ec_libettercap.h>\n\n#include <stdarg.h>\n\nstruct ec_globals *ec_gbls;\n\n#define EF_GBL_FREE(x) do{ if (x != NULL) { free(x); x = NULL; } }while(0)\n\n/* ef_globals */\n\nextern FILE * yyin;           /* from scanner */\nextern int yyparse (void);    /* from parser */\n\n/* global options */\nstruct ef_globals *ef_gbls;\n\n/*******************************************/\n\nint main(int argc, char *argv[])\n{\n   int ret_value = 0;\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   /* etterfilter copyright */\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n \n   /* initialize the line number */\n   EF_GBL->lineno = 1;\n  \n   /* getopt related parsing...  */\n   parse_options(argc, argv);\n\n   /* set the input for source file */\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n\n   /* no buffering */\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n\n   \n   /* load the tables in etterfilter.tbl */\n   load_tables();\n   /* load the constants in etterfilter.cnt */\n   load_constants();\n\n   /* print the message */\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n\n   ef_debug(1, \"\\n\");\n\n   /* begin the parsing */\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n  \n   /* write to file */\n   ret_value = write_output();\n   if (ret_value == -E_NOTHANDLED)\n      FATAL_ERROR(\"Cannot write output file (%s): the filter is not correctly handled.\", EF_GBL_OPTIONS->output_file);\n   else if (ret_value == -E_INVALID)\n      FATAL_ERROR(\"Cannot write output file (%s): the filter format is not correct. \", EF_GBL_OPTIONS->output_file);\n\n   ef_globals_free();\n   return 0;\n}\n\n\n/*\n * print debug information\n */\nvoid ef_debug(u_char level, const char *message, ...)\n{ \n   va_list ap;\n   \n   /* if not in debug don't print anything */\n   if (EF_GBL_OPTIONS->debug < level)\n      return;\n\n   /* print the message */ \n   va_start(ap, message);\n   vfprintf (stderr, message, ap);\n   fflush(stderr);\n   va_end(ap);\n   \n}\n\nvoid ef_globals_alloc(void)\n{\n\n   SAFE_CALLOC(ef_gbls, 1, sizeof(struct ef_globals));\n\n   return;\n}\n\nvoid ef_globals_free(void)\n{\n   SAFE_FREE(ef_gbls->source_file);\n   SAFE_FREE(ef_gbls->output_file);\n   SAFE_FREE(ef_gbls);\n\n   return;\n\n}\n\n/* EOF */\n\n// vim:ts=3:expandtab\n\n", "/*\n    etterfilter -- the actual compiler\n\n    Copyright (C) ALoR & NaGA\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n*/\n\n#include <ef.h>\n#include <ef_functions.h>\n#include <ec_filter.h>\n#include <ec_version.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n\n/* protos */\n\nstatic void print_progress_bar(struct filter_op *fop);\nstatic u_char * create_data_segment(struct filter_header *fh, struct filter_op *fop, size_t n);\nstatic size_t add_data_segment(u_char **data, size_t base, u_char **string, size_t slen);\n\n/*******************************************/\n\nint write_output(void)\n{\n   int fd;\n   struct filter_op *fop;\n   struct filter_header fh;\n   size_t ninst, i;\n   u_char *data;\n\n   /* conver the tree to an array of filter_op */\n   ninst = compile_tree(&fop);\n\n   if (fop == NULL)\n      return -E_NOTHANDLED;\n\n   if (ninst == 0)\n      return -E_INVALID;\n\n   /* create the file */\n   fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);\n   ON_ERROR(fd, -1, \"Can't create file %s\", EF_GBL_OPTIONS->output_file);\n\n   /* display the message */\n   fprintf(stdout, \" Writing output to \\'%s\\' \", EF_GBL_OPTIONS->output_file);\n   fflush(stdout);\n   \n   /* compute the header */\n   fh.magic = htons(EC_FILTER_MAGIC);\n   strncpy(fh.version, EC_VERSION, sizeof(fh.version));\n   fh.data = sizeof(fh);\n\n   data = create_data_segment(&fh, fop, ninst);\n   \n   /* write the header */\n   write(fd, &fh, sizeof(struct filter_header));\n\n   /* write the data segment */\n   write(fd, data, fh.code - fh.data);\n   \n   /* write the instructions */\n   for (i = 0; i <= ninst; i++) {\n      print_progress_bar(&fop[i]);\n      write(fd, &fop[i], sizeof(struct filter_op));\n   }\n\n   close(fd);\n   \n   fprintf(stdout, \" done.\\n\\n\");\n  \n   fprintf(stdout, \" -> Script encoded into %d instructions.\\n\\n\", (int)(i - 1));\n   \n   return E_SUCCESS;\n}\n\n/*\n * creates the data segment into an array\n * and update the file header\n */\nstatic u_char * create_data_segment(struct filter_header *fh, struct filter_op *fop, size_t n)\n{\n   size_t i, len = 0;\n   u_char *data = NULL;\n\n   for (i = 0; i < n; i++) {\n      \n      switch(fop[i].opcode) {\n         case FOP_FUNC:\n            if (fop[i].op.func.slen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.func.string, fop[i].op.func.slen);\n            }\n            if (fop[i].op.func.rlen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.func.replace, fop[i].op.func.rlen);\n            }\n            break;\n            \n         case FOP_TEST:\n            if (fop[i].op.test.slen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.test.string, fop[i].op.test.slen);\n            }\n            break;\n\n         case FOP_ASSIGN:\n            if (fop[i].op.assign.slen) {\n               ef_debug(1, \"@\");\n               len += add_data_segment(&data, len, &fop[i].op.test.string, fop[i].op.test.slen);\n            }\n            break;\n      }\n\n   }\n  \n   /* where starts the code ? */\n   fh->code = fh->data + len;\n   \n   return data;\n}\n\n\n/* \n * add a string to the buffer \n */\nstatic size_t add_data_segment(u_char **data, size_t base, u_char **string, size_t slen)\n{\n   /* make room for the new string */\n   SAFE_REALLOC(*data, base + slen + 1);\n\n   /* copy the string, NULL separated */\n   memcpy(*data + base, *string, slen + 1);\n\n   /* \n    * change the pointer to the new string location \n    * it is an offset from the base of the data segment\n    */\n   *string = (u_char *)base;\n   \n   /* retur the len of the added string */\n   return slen + 1;\n}\n\n/*\n * prints a differnt sign for every different instruction\n */\nstatic void print_progress_bar(struct filter_op *fop)\n{\n   switch(fop->opcode) {\n      case FOP_EXIT:\n         ef_debug(1, \"!\");\n         break;\n      case FOP_TEST:\n         ef_debug(1, \"?\");\n         break;\n      case FOP_ASSIGN:\n         ef_debug(1, \"=\");\n         break;\n      case FOP_FUNC:\n         ef_debug(1, \".\");\n         break;\n      case FOP_JMP:\n         ef_debug(1, \":\");\n         break;\n      case FOP_JTRUE:\n      case FOP_JFALSE:\n         ef_debug(1, \";\");\n         break;\n   }\n}\n\n/* EOF */\n\n// vim:ts=3:expandtab\n\n"], "filenames": ["utils/etterfilter/ef_compiler.c", "utils/etterfilter/ef_main.c", "utils/etterfilter/ef_output.c"], "buggy_code_start_loc": [242, 43, 52], "buggy_code_end_loc": [243, 93, 52], "fixing_code_start_loc": [242, 44, 53], "fixing_code_end_loc": [245, 98, 56], "type": "CWE-125", "message": "The compile_tree function in ef_compiler.c in the Etterfilter utility in Ettercap 0.8.2 and earlier allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted filter.", "other": {"cve": {"id": "CVE-2017-6430", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T15:59:01.030", "lastModified": "2020-02-26T13:35:54.093", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The compile_tree function in ef_compiler.c in the Etterfilter utility in Ettercap 0.8.2 and earlier allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted filter."}, {"lang": "es", "value": "La funci\u00f3n compile_tree en ef_compiler.c en la utilidad Etterfilter de Ettercap 0.8.2 y versiones anteriores permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) a trav\u00e9s de un filtro manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ettercap-project:ettercap:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.8.2", "matchCriteriaId": "65344FA4-AE57-4D1A-A2EF-67FC5C09961A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3874", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/archive/1/540223/100/0/threaded", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/96582", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038057", "source": "cve@mitre.org"}, {"url": "https://github.com/Ettercap/ettercap/issues/782", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506"}}