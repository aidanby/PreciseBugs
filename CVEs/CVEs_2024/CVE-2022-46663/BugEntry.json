{"buggy_code": ["/*\n * Copyright (C) 1984-2022  Mark Nudelman\n *\n * You may distribute under the terms of either the GNU General Public\n * License or the Less License, as specified in the README file.\n *\n * For more information, see the README file.\n */\n\n/*\n * Routines to manipulate the \"line buffer\".\n * The line buffer holds a line of output as it is being built\n * in preparation for output to the screen.\n */\n\n#include \"less.h\"\n#include \"charset.h\"\n#include \"position.h\"\n\n#if MSDOS_COMPILER==WIN32C\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#endif\n\n#define MAX_PFX_WIDTH (MAX_LINENUM_WIDTH + MAX_STATUSCOL_WIDTH + 1)\nstatic struct {\n\tchar *buf;    /* Buffer which holds the current output line */\n\tint *attr;   /* Parallel to buf, to hold attributes */\n\tint print;    /* Index in buf of first printable char */\n\tint end;      /* Number of chars in buf */\n\tchar pfx[MAX_PFX_WIDTH]; /* Holds status column and line number */\n\tint pfx_attr[MAX_PFX_WIDTH];\n\tint pfx_end;  /* Number of chars in pfx */\n} linebuf;\n\n/*\n * Buffer of ansi sequences which have been shifted off the left edge \n * of the screen. \n */\nstruct xbuffer shifted_ansi;\n\n/*\n * Ring buffer of last ansi sequences sent.\n * While sending a line, these will be resent at the end\n * of any highlighted string, to restore text modes.\n * {{ Not ideal, since we don't really know how many to resend. }}\n */\n#define NUM_LAST_ANSIS 3\nstatic struct xbuffer last_ansi;\nstatic struct xbuffer last_ansis[NUM_LAST_ANSIS];\nstatic int curr_last_ansi;\n\npublic int size_linebuf = 0; /* Size of line buffer (and attr buffer) */\nstatic struct ansi_state *line_ansi = NULL;\nstatic int ansi_in_line;\nstatic int hlink_in_line;\nstatic int line_mark_attr;\nstatic int cshift;   /* Current left-shift of output line buffer */\npublic int hshift;   /* Desired left-shift of output line buffer */\npublic int tabstops[TABSTOP_MAX] = { 0 }; /* Custom tabstops */\npublic int ntabstops = 1;        /* Number of tabstops */\npublic int tabdefault = 8;       /* Default repeated tabstops */\npublic POSITION highest_hilite;  /* Pos of last hilite in file found so far */\n\nstatic int end_column;  /* Printable length, accounting for backspaces, etc. */\nstatic int right_curr;\nstatic int right_column;\nstatic int overstrike;  /* Next char should overstrike previous char */\nstatic int last_overstrike = AT_NORMAL;\nstatic int is_null_line;  /* There is no current line */\nstatic LWCHAR pendc;\nstatic POSITION pendpos;\nstatic char *end_ansi_chars;\nstatic char *mid_ansi_chars;\nstatic int in_hilite;\n\nstatic int attr_swidth LESSPARAMS ((int a));\nstatic int attr_ewidth LESSPARAMS ((int a));\nstatic int do_append LESSPARAMS ((LWCHAR ch, char *rep, POSITION pos));\n\nextern int sigs;\nextern int bs_mode;\nextern int linenums;\nextern int ctldisp;\nextern int twiddle;\nextern int binattr;\nextern int status_col;\nextern int status_col_width;\nextern int linenum_width;\nextern int auto_wrap, ignaw;\nextern int bo_s_width, bo_e_width;\nextern int ul_s_width, ul_e_width;\nextern int bl_s_width, bl_e_width;\nextern int so_s_width, so_e_width;\nextern int sc_width, sc_height;\nextern int utf_mode;\nextern POSITION start_attnpos;\nextern POSITION end_attnpos;\nextern char rscroll_char;\nextern int rscroll_attr;\nextern int use_color;\nextern int status_line;\n\nstatic char mbc_buf[MAX_UTF_CHAR_LEN];\nstatic int mbc_buf_len = 0;\nstatic int mbc_buf_index = 0;\nstatic POSITION mbc_pos;\n\n/* Configurable color map */\nstatic char color_map[AT_NUM_COLORS][12] = {\n\t\"Wm\",  /* AT_COLOR_ATTN */\n\t\"kR\",  /* AT_COLOR_BIN */\n\t\"kR\",  /* AT_COLOR_CTRL */\n\t\"kY\",  /* AT_COLOR_ERROR */\n\t\"c\",   /* AT_COLOR_LINENUM */\n\t\"Wb\",  /* AT_COLOR_MARK */\n\t\"kC\",  /* AT_COLOR_PROMPT */\n\t\"kc\",  /* AT_COLOR_RSCROLL */\n\t\"kG\",  /* AT_COLOR_SEARCH */\n\t\"\",    /* AT_COLOR_HEADER */\n\t\"\",    /* AT_UNDERLINE */\n\t\"\",    /* AT_BOLD */\n\t\"\",    /* AT_BLINK */\n\t\"\",    /* AT_STANDOUT */\n};\n\n/* State while processing an ANSI escape sequence */\nstruct ansi_state {\n\tint hindex;   /* Index into hyperlink prefix */\n\tint hlink;    /* Processing hyperlink address? */\n\tint prev_esc; /* Prev char was ESC (to detect ESC-\\ seq) */\n};\n\n/*\n * Initialize from environment variables.\n */\n\tpublic void\ninit_line(VOID_PARAM)\n{\n\tint ax;\n\n\tend_ansi_chars = lgetenv(\"LESSANSIENDCHARS\");\n\tif (isnullenv(end_ansi_chars))\n\t\tend_ansi_chars = \"m\";\n\n\tmid_ansi_chars = lgetenv(\"LESSANSIMIDCHARS\");\n\tif (isnullenv(mid_ansi_chars))\n\t\tmid_ansi_chars = \"0123456789:;[?!\\\"'#%()*+ \";\n\n\tlinebuf.buf = (char *) ecalloc(LINEBUF_SIZE, sizeof(char));\n\tlinebuf.attr = (int *) ecalloc(LINEBUF_SIZE, sizeof(int));\n\tsize_linebuf = LINEBUF_SIZE;\n\txbuf_init(&shifted_ansi);\n\txbuf_init(&last_ansi);\n\tfor (ax = 0;  ax < NUM_LAST_ANSIS;  ax++)\n\t\txbuf_init(&last_ansis[ax]);\n\tcurr_last_ansi = 0;\n}\n\n/*\n * Expand the line buffer.\n */\n\tstatic int\nexpand_linebuf(VOID_PARAM)\n{\n\t/* Double the size of the line buffer. */\n\tint new_size = size_linebuf * 2;\n\tchar *new_buf = (char *) calloc(new_size, sizeof(char));\n\tint *new_attr = (int *) calloc(new_size, sizeof(int));\n\tif (new_buf == NULL || new_attr == NULL)\n\t{\n\t\tif (new_attr != NULL)\n\t\t\tfree(new_attr);\n\t\tif (new_buf != NULL)\n\t\t\tfree(new_buf);\n\t\treturn 1;\n\t}\n\t/*\n\t * We just calloc'd the buffers; copy the old contents.\n\t */\n\tmemcpy(new_buf, linebuf.buf, size_linebuf * sizeof(char));\n\tmemcpy(new_attr, linebuf.attr, size_linebuf * sizeof(int));\n\tfree(linebuf.attr);\n\tfree(linebuf.buf);\n\tlinebuf.buf = new_buf;\n\tlinebuf.attr = new_attr;\n\tsize_linebuf = new_size;\n\treturn 0;\n}\n\n/*\n * Is a character ASCII?\n */\n\tpublic int\nis_ascii_char(ch)\n\tLWCHAR ch;\n{\n\treturn (ch <= 0x7F);\n}\n\n/*\n */\n\tstatic void\ninc_end_column(w)\n\tint w;\n{\n\tif (end_column > right_column && w > 0)\n\t{\n\t\tright_column = end_column;\n\t\tright_curr = linebuf.end;\n\t}\n\tend_column += w;\n}\n\n/*\n * Rewind the line buffer.\n */\n\tpublic void\nprewind(VOID_PARAM)\n{\n\tint ax;\n\n\tlinebuf.print = 6; /* big enough for longest UTF-8 sequence */\n\tlinebuf.pfx_end = 0;\n\tfor (linebuf.end = 0; linebuf.end < linebuf.print; linebuf.end++)\n\t{\n\t\tlinebuf.buf[linebuf.end] = '\\0';\n\t\tlinebuf.attr[linebuf.end] = 0;\n\t}\n\n\tend_column = 0;\n\tright_curr = 0;\n\tright_column = 0;\n\tcshift = 0;\n\toverstrike = 0;\n\tlast_overstrike = AT_NORMAL;\n\tmbc_buf_len = 0;\n\tis_null_line = 0;\n\tpendc = '\\0';\n\tin_hilite = 0;\n\tansi_in_line = 0;\n\thlink_in_line = 0;\n\tline_mark_attr = 0;\n\txbuf_reset(&shifted_ansi);\n\txbuf_reset(&last_ansi);\n\tfor (ax = 0;  ax < NUM_LAST_ANSIS;  ax++)\n\t\txbuf_reset(&last_ansis[ax]);\n\tcurr_last_ansi = 0;\n}\n\n/*\n * Set a character in the line buffer.\n */\n\tstatic void\nset_linebuf(n, ch, attr)\n\tint n;\n\tchar ch;\n\tint attr;\n{\n\tlinebuf.buf[n] = ch;\n\tlinebuf.attr[n] = attr;\n}\n\n/*\n * Append a character to the line buffer.\n */\n\tstatic void\nadd_linebuf(ch, attr, w)\n\tchar ch;\n\tint attr;\n\tint w;\n{\n\tset_linebuf(linebuf.end++, ch, attr);\n\tinc_end_column(w);\n}\n\n/*\n * Append a string to the line buffer.\n */\n\tstatic void\naddstr_linebuf(s, attr, cw)\n\tchar *s;\n\tint attr;\n\tint cw;\n{\n\tfor ( ;  *s != '\\0';  s++)\n\t\tadd_linebuf(*s, attr, cw);\n}\n\n/*\n * Set a character in the line prefix buffer.\n */\n\tstatic void\nset_pfx(n, ch, attr)\n\tint n;\n\tchar ch;\n\tint attr;\n{\n\tlinebuf.pfx[n] = ch;\n\tlinebuf.pfx_attr[n] = attr;\n}\n\n/*\n * Append a character to the line prefix buffer.\n */\n\tstatic void\nadd_pfx(ch, attr)\n\tchar ch;\n\tint attr;\n{\n\tset_pfx(linebuf.pfx_end++, ch, attr);\n}\n\n/*\n * Insert the status column and line number into the line buffer.\n */\n\tpublic void\nplinestart(pos)\n\tPOSITION pos;\n{\n\tLINENUM linenum = 0;\n\tint i;\n\n\tif (linenums == OPT_ONPLUS)\n\t{\n\t\t/*\n\t\t * Get the line number and put it in the current line.\n\t\t * {{ Note: since find_linenum calls forw_raw_line,\n\t\t *    it may seek in the input file, requiring the caller \n\t\t *    of plinestart to re-seek if necessary. }}\n\t\t * {{ Since forw_raw_line modifies linebuf, we must\n\t\t *    do this first, before storing anything in linebuf. }}\n\t\t */\n\t\tlinenum = find_linenum(pos);\n\t}\n\n\t/*\n\t * Display a status column if the -J option is set.\n\t */\n\tif (status_col || status_line)\n\t{\n\t\tchar c = posmark(pos);\n\t\tif (c != 0)\n\t\t\tline_mark_attr = AT_HILITE|AT_COLOR_MARK;\n\t\telse if (start_attnpos != NULL_POSITION &&\n\t\t         pos >= start_attnpos && pos <= end_attnpos)\n\t\t\tline_mark_attr = AT_HILITE|AT_COLOR_ATTN;\n\t\tif (status_col)\n\t\t{\n\t\t\tadd_pfx(c ? c : ' ', line_mark_attr); /* column 0: status */\n\t\t\twhile (linebuf.pfx_end < status_col_width)\n\t\t\t\tadd_pfx(' ', AT_NORMAL);\n\t\t}\n\t}\n\n\t/*\n\t * Display the line number at the start of each line\n\t * if the -N option is set.\n\t */\n\tif (linenums == OPT_ONPLUS)\n\t{\n\t\tchar buf[INT_STRLEN_BOUND(linenum) + 2];\n\t\tint len;\n\n\t\tlinenum = vlinenum(linenum);\n\t\tif (linenum == 0)\n\t\t\tlen = 0;\n\t\telse\n\t\t{\n\t\t\tlinenumtoa(linenum, buf);\n\t\t\tlen = (int) strlen(buf);\n\t\t}\n\t\tfor (i = 0; i < linenum_width - len; i++)\n\t\t\tadd_pfx(' ', AT_NORMAL);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tadd_pfx(buf[i], AT_BOLD|AT_COLOR_LINENUM);\n\t\tadd_pfx(' ', AT_NORMAL);\n\t}\n\tend_column = linebuf.pfx_end;\n}\n\n/*\n * Return the width of the line prefix (status column and line number).\n * {{ Actual line number can be wider than linenum_width. }}\n */\n\tpublic int\nline_pfx_width(VOID_PARAM)\n{\n\tint width = 0;\n\tif (status_col)\n\t\twidth += status_col_width;\n\tif (linenums == OPT_ONPLUS)\n\t\twidth += linenum_width + 1;\n\treturn width;\n}\n\n/*\n * Shift line left so that the last char is just to the left\n * of the first visible column.\n */\n\tpublic void\npshift_all(VOID_PARAM)\n{\n\tint i;\n\tfor (i = linebuf.print;  i < linebuf.end;  i++)\n\t\tif (linebuf.attr[i] == AT_ANSI)\n\t\t\txbuf_add_byte(&shifted_ansi, (unsigned char) linebuf.buf[i]);\n\tlinebuf.end = linebuf.print;\n\tend_column = linebuf.pfx_end;\n}\n\n/*\n * Return the printing width of the start (enter) sequence\n * for a given character attribute.\n */\n\tstatic int\nattr_swidth(a)\n\tint a;\n{\n\tint w = 0;\n\n\ta = apply_at_specials(a);\n\n\tif (a & AT_UNDERLINE)\n\t\tw += ul_s_width;\n\tif (a & AT_BOLD)\n\t\tw += bo_s_width;\n\tif (a & AT_BLINK)\n\t\tw += bl_s_width;\n\tif (a & AT_STANDOUT)\n\t\tw += so_s_width;\n\n\treturn w;\n}\n\n/*\n * Return the printing width of the end (exit) sequence\n * for a given character attribute.\n */\n\tstatic int\nattr_ewidth(a)\n\tint a;\n{\n\tint w = 0;\n\n\ta = apply_at_specials(a);\n\n\tif (a & AT_UNDERLINE)\n\t\tw += ul_e_width;\n\tif (a & AT_BOLD)\n\t\tw += bo_e_width;\n\tif (a & AT_BLINK)\n\t\tw += bl_e_width;\n\tif (a & AT_STANDOUT)\n\t\tw += so_e_width;\n\n\treturn w;\n}\n\n/*\n * Return the printing width of a given character and attribute,\n * if the character were added after prev_ch.\n * Adding a character with a given attribute may cause an enter or exit\n * attribute sequence to be inserted, so this must be taken into account.\n */\n\tpublic int\npwidth(ch, a, prev_ch, prev_a)\n\tLWCHAR ch;\n\tint a;\n\tLWCHAR prev_ch;\n\tint prev_a;\n{\n\tint w;\n\n\tif (ch == '\\b')\n\t{\n\t\t/*\n\t\t * Backspace moves backwards one or two positions.\n\t\t */\n\t\tif (prev_a & (AT_ANSI|AT_BINARY))\n\t\t\treturn strlen(prchar('\\b'));\n\t\treturn (utf_mode && is_wide_char(prev_ch)) ? -2 : -1;\n\t}\n\n\tif (!utf_mode || is_ascii_char(ch))\n\t{\n\t\tif (control_char((char)ch))\n\t\t{\n\t\t\t/*\n\t\t\t * Control characters do unpredictable things,\n\t\t\t * so we don't even try to guess; say it doesn't move.\n\t\t\t * This can only happen if the -r flag is in effect.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t{\n\t\tif (is_composing_char(ch) || is_combining_char(prev_ch, ch))\n\t\t{\n\t\t\t/*\n\t\t\t * Composing and combining chars take up no space.\n\t\t\t *\n\t\t\t * Some terminals, upon failure to compose a\n\t\t\t * composing character with the character(s) that\n\t\t\t * precede(s) it will actually take up one end_column\n\t\t\t * for the composing character; there isn't much\n\t\t\t * we could do short of testing the (complex)\n\t\t\t * composition process ourselves and printing\n\t\t\t * a binary representation when it fails.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * Other characters take one or two columns,\n\t * plus the width of any attribute enter/exit sequence.\n\t */\n\tw = 1;\n\tif (is_wide_char(ch))\n\t\tw++;\n\tif (linebuf.end > 0 && !is_at_equiv(linebuf.attr[linebuf.end-1], a))\n\t\tw += attr_ewidth(linebuf.attr[linebuf.end-1]);\n\tif (apply_at_specials(a) != AT_NORMAL &&\n\t    (linebuf.end == 0 || !is_at_equiv(linebuf.attr[linebuf.end-1], a)))\n\t\tw += attr_swidth(a);\n\treturn (w);\n}\n\n/*\n * Delete to the previous base character in the line buffer.\n */\n\tstatic int\nbackc(VOID_PARAM)\n{\n\tLWCHAR ch;\n\tchar *p;\n\n\tif (linebuf.end == 0)\n\t\treturn (0);\n\tp = &linebuf.buf[linebuf.end];\n\tch = step_char(&p, -1, linebuf.buf);\n\t/* Skip back to the next nonzero-width char. */\n\twhile (p > linebuf.buf)\n\t{\n\t\tLWCHAR prev_ch;\n\t\tint width;\n\t\tlinebuf.end = (int) (p - linebuf.buf);\n\t\tprev_ch = step_char(&p, -1, linebuf.buf);\n\t\twidth = pwidth(ch, linebuf.attr[linebuf.end], prev_ch, linebuf.attr[linebuf.end-1]);\n\t\tend_column -= width;\n\t\t/* {{ right_column? }} */\n\t\tif (width > 0)\n\t\t\tbreak;\n\t\tch = prev_ch;\n\t}\n\treturn (1);\n}\n\n/*\n * Is a character the end of an ANSI escape sequence?\n */\n\tpublic int\nis_ansi_end(ch)\n\tLWCHAR ch;\n{\n\tif (!is_ascii_char(ch))\n\t\treturn (0);\n\treturn (strchr(end_ansi_chars, (char) ch) != NULL);\n}\n\n/*\n * Can a char appear in an ANSI escape sequence, before the end char?\n */\n\tpublic int\nis_ansi_middle(ch)\n\tLWCHAR ch;\n{\n\tif (!is_ascii_char(ch))\n\t\treturn (0);\n\tif (is_ansi_end(ch))\n\t\treturn (0);\n\treturn (strchr(mid_ansi_chars, (char) ch) != NULL);\n}\n\n/*\n * Skip past an ANSI escape sequence.\n * pp is initially positioned just after the CSI_START char.\n */\n\tpublic void\nskip_ansi(pansi, pp, limit)\n\tstruct ansi_state *pansi;\n\tchar **pp;\n\tconstant char *limit;\n{\n\tLWCHAR c;\n\tdo {\n\t\tc = step_char(pp, +1, limit);\n\t} while (*pp < limit && ansi_step(pansi, c) == ANSI_MID);\n\t/* Note that we discard final char, for which is_ansi_end is true. */\n}\n\n/*\n * Determine if a character starts an ANSI escape sequence.\n * If so, return an ansi_state struct; otherwise return NULL.\n */\n\tpublic struct ansi_state *\nansi_start(ch)\n\tLWCHAR ch;\n{\n\tstruct ansi_state *pansi;\n\n\tif (!IS_CSI_START(ch))\n\t\treturn NULL;\n\tpansi = ecalloc(1, sizeof(struct ansi_state));\n\tpansi->hindex = 0;\n\tpansi->hlink = 0;\n\tpansi->prev_esc = 0;\n\treturn pansi;\n}\n\n/*\n * Determine whether the next char in an ANSI escape sequence\n * ends the sequence.\n */\n\tpublic int\nansi_step(pansi, ch)\n\tstruct ansi_state *pansi;\n\tLWCHAR ch;\n{\n\tif (pansi->hlink)\n\t{\n\t\t/* Hyperlink ends with \\7 or ESC-backslash. */\n\t\tif (ch == '\\7')\n\t\t\treturn ANSI_END;\n\t\tif (pansi->prev_esc && ch == '\\\\')\n\t\t\treturn ANSI_END;\n\t\tpansi->prev_esc = (ch == ESC);\n\t\treturn ANSI_MID;\n\t}\n\tif (pansi->hindex >= 0)\n\t{\n\t\tstatic char hlink_prefix[] = ESCS \"]8;\";\n\t\tif (ch == hlink_prefix[pansi->hindex] ||\n\t\t    (pansi->hindex == 0 && IS_CSI_START(ch)))\n\t\t{\n\t\t\tpansi->hindex++;\n\t\t\tif (hlink_prefix[pansi->hindex] == '\\0')\n\t\t\t\tpansi->hlink = 1; /* now processing hyperlink addr */\n\t\t\treturn ANSI_MID;\n\t\t}\n\t\tpansi->hindex = -1; /* not a hyperlink */\n\t}\n\t/* Check for SGR sequences */\n\tif (is_ansi_middle(ch))\n\t\treturn ANSI_MID;\n\tif (is_ansi_end(ch))\n\t\treturn ANSI_END;\n\treturn ANSI_ERR;\n}\n\n/*\n * Free an ansi_state structure.\n */\n\tpublic void\nansi_done(pansi)\n\tstruct ansi_state *pansi;\n{\n\tfree(pansi);\n}\n\n/*\n * Will w characters in attribute a fit on the screen?\n */\n\tstatic int\nfits_on_screen(w, a)\n\tint w;\n\tint a;\n{\n\tif (ctldisp == OPT_ON)\n\t\t/* We're not counting, so say that everything fits. */\n\t\treturn 1;\n\treturn (end_column - cshift + w + attr_ewidth(a) <= sc_width);\n}\n\n/*\n * Append a character and attribute to the line buffer.\n */\n#define STORE_CHAR(ch,a,rep,pos) \\\n\tdo { \\\n\t\tif (store_char((ch),(a),(rep),(pos))) return (1); \\\n\t} while (0)\n\n\tstatic int\nstore_char(ch, a, rep, pos)\n\tLWCHAR ch;\n\tint a;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tint w;\n\tint i;\n\tint replen;\n\tchar cs;\n\n\ti = (a & (AT_UNDERLINE|AT_BOLD));\n\tif (i != AT_NORMAL)\n\t\tlast_overstrike = i;\n\n#if HILITE_SEARCH\n\t{\n\t\tint matches;\n\t\tint resend_last = 0;\n\t\tint hl_attr;\n\n\t\tif (pos == NULL_POSITION)\n\t\t{\n\t\t\t/* Color the prompt unless it has ansi sequences in it. */\n\t\t\thl_attr = ansi_in_line ? 0 : AT_STANDOUT|AT_COLOR_PROMPT;\n\t\t} else\n\t\t{\n\t\t\thl_attr = is_hilited_attr(pos, pos+1, 0, &matches);\n\t\t\tif (hl_attr == 0 && status_line)\n\t\t\t\thl_attr = line_mark_attr;\n\t\t}\n\t\tif (hl_attr)\n\t\t{\n\t\t\t/*\n\t\t\t * This character should be highlighted.\n\t\t\t * Override the attribute passed in.\n\t\t\t */\n\t\t\tif (a != AT_ANSI)\n\t\t\t{\n\t\t\t\tif (highest_hilite != NULL_POSITION && pos != NULL_POSITION && pos > highest_hilite)\n\t\t\t\t\thighest_hilite = pos;\n\t\t\t\ta |= hl_attr;\n\t\t\t}\n\t\t\tin_hilite = 1;\n\t\t} else \n\t\t{\n\t\t\tif (in_hilite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This is the first non-hilited char after a hilite.\n\t\t\t\t * Resend the last ANSI seq to restore color.\n\t\t\t\t */\n\t\t\t\tresend_last = 1;\n\t\t\t}\n\t\t\tin_hilite = 0;\n\t\t}\n\t\tif (resend_last)\n\t\t{\n\t\t\tint ai;\n\t\t\tfor (ai = 0;  ai < NUM_LAST_ANSIS;  ai++)\n\t\t\t{\n\t\t\t\tint ax = (curr_last_ansi + ai) % NUM_LAST_ANSIS;\n\t\t\t\tfor (i = 0;  i < last_ansis[ax].end;  i++)\n\t\t\t\t\tSTORE_CHAR(last_ansis[ax].data[i], AT_ANSI, NULL, pos);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (a == AT_ANSI) {\n\t\tw = 0;\n\t} else {\n\t\tchar *p = &linebuf.buf[linebuf.end];\n\t\tLWCHAR prev_ch = (linebuf.end > 0) ? step_char(&p, -1, linebuf.buf) : 0;\n\t\tint prev_a = (linebuf.end > 0) ? linebuf.attr[linebuf.end-1] : 0;\n\t\tw = pwidth(ch, a, prev_ch, prev_a);\n\t}\n\n\tif (!fits_on_screen(w, a))\n\t\treturn (1);\n\n\tif (rep == NULL)\n\t{\n\t\tcs = (char) ch;\n\t\trep = &cs;\n\t\treplen = 1;\n\t} else\n\t{\n\t\treplen = utf_len(rep[0]);\n\t}\n\tif (linebuf.end + replen >= size_linebuf-6)\n\t{\n\t\t/*\n\t\t * Won't fit in line buffer.\n\t\t * Try to expand it.\n\t\t */\n\t\tif (expand_linebuf())\n\t\t\treturn (1);\n\t}\n\n\tif (cshift == hshift && shifted_ansi.end > 0)\n\t{\n\t\t/* Copy shifted ANSI sequences to beginning of line. */\n\t\tfor (i = 0;  i < shifted_ansi.end;  i++)\n\t\t\tadd_linebuf(shifted_ansi.data[i], AT_ANSI, 0);\n\t\txbuf_reset(&shifted_ansi);\n\t}\n\t/* Add the char to the buf, even if we will left-shift it next. */\n\tinc_end_column(w);\n\tfor (i = 0;  i < replen;  i++)\n\t\tadd_linebuf(*rep++, a, 0);\n\n\tif (cshift < hshift)\n\t{\n\t\t/* We haven't left-shifted enough yet. */\n\t\tif (a == AT_ANSI)\n\t\t\txbuf_add_byte(&shifted_ansi, (unsigned char) ch); /* Save ANSI attributes */\n\t\tif (linebuf.end > linebuf.print)\n\t\t{\n\t\t\t/* Shift left enough to put last byte of this char at print-1. */\n\t\t\tint i;\n\t\t\tfor (i = 0; i < linebuf.print; i++)\n\t\t\t{\n\t\t\t\tlinebuf.buf[i] = linebuf.buf[i+replen];\n\t\t\t\tlinebuf.attr[i] = linebuf.attr[i+replen];\n\t\t\t}\n\t\t\tlinebuf.end -= replen;\n\t\t\tcshift += w;\n\t\t\t/*\n\t\t\t * If the char we just left-shifted was double width,\n\t\t\t * the 2 spaces we shifted may be too much.\n\t\t\t * Represent the \"half char\" at start of line with a highlighted space.\n\t\t\t */\n\t\t\twhile (cshift > hshift)\n\t\t\t{\n\t\t\t\tadd_linebuf(' ', rscroll_attr, 0);\n\t\t\t\tcshift--;\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n\n#define STORE_STRING(s,a,pos) \\\n\tdo { if (store_string((s),(a),(pos))) return (1); } while (0)\n\n\tstatic int\nstore_string(s, a, pos)\n\tchar *s;\n\tint a;\n\tPOSITION pos;\n{\n\tif (!fits_on_screen(strlen(s), a))\n\t\treturn 1;\n\tfor ( ;  *s != 0;  s++)\n\t\tSTORE_CHAR(*s, a, NULL, pos);\n\treturn 0;\n}\n\n/*\n * Append a tab to the line buffer.\n * Store spaces to represent the tab.\n */\n#define STORE_TAB(a,pos) \\\n\tdo { if (store_tab((a),(pos))) return (1); } while (0)\n\n\tstatic int\nstore_tab(attr, pos)\n\tint attr;\n\tPOSITION pos;\n{\n\tint to_tab = end_column - linebuf.pfx_end;\n\n\tif (ntabstops < 2 || to_tab >= tabstops[ntabstops-1])\n\t\tto_tab = tabdefault -\n\t\t     ((to_tab - tabstops[ntabstops-1]) % tabdefault);\n\telse\n\t{\n\t\tint i;\n\t\tfor (i = ntabstops - 2;  i >= 0;  i--)\n\t\t\tif (to_tab >= tabstops[i])\n\t\t\t\tbreak;\n\t\tto_tab = tabstops[i+1] - to_tab;\n\t}\n\n\tdo {\n\t\tSTORE_CHAR(' ', attr, \" \", pos);\n\t} while (--to_tab > 0);\n\treturn 0;\n}\n\n#define STORE_PRCHAR(c, pos) \\\n\tdo { if (store_prchar((c), (pos))) return 1; } while (0)\n\n\tstatic int\nstore_prchar(c, pos)\n\tLWCHAR c;\n\tPOSITION pos;\n{\n\t/*\n\t * Convert to printable representation.\n\t */\n\tSTORE_STRING(prchar(c), AT_BINARY|AT_COLOR_CTRL, pos);\n\treturn 0;\n}\n\n\tstatic int\nflush_mbc_buf(pos)\n\tPOSITION pos;\n{\n\tint i;\n\n\tfor (i = 0; i < mbc_buf_index; i++)\n\t\tif (store_prchar(mbc_buf[i], pos))\n\t\t\treturn mbc_buf_index - i;\n\treturn 0;\n}\n\n/*\n * Append a character to the line buffer.\n * Expand tabs into spaces, handle underlining, boldfacing, etc.\n * Returns 0 if ok, 1 if couldn't fit in buffer.\n */\n\tpublic int\npappend(c, pos)\n\tint c;\n\tPOSITION pos;\n{\n\tint r;\n\n\tif (pendc)\n\t{\n\t\tif (c == '\\r' && pendc == '\\r')\n\t\t\treturn (0);\n\t\tif (do_append(pendc, NULL, pendpos))\n\t\t\t/*\n\t\t\t * Oops.  We've probably lost the char which\n\t\t\t * was in pendc, since caller won't back up.\n\t\t\t */\n\t\t\treturn (1);\n\t\tpendc = '\\0';\n\t}\n\n\tif (c == '\\r' && bs_mode == BS_SPECIAL)\n\t{\n\t\tif (mbc_buf_len > 0)  /* utf_mode must be on. */\n\t\t{\n\t\t\t/* Flush incomplete (truncated) sequence. */\n\t\t\tr = flush_mbc_buf(mbc_pos);\n\t\t\tmbc_buf_index = r + 1;\n\t\t\tmbc_buf_len = 0;\n\t\t\tif (r)\n\t\t\t\treturn (mbc_buf_index);\n\t\t}\n\n\t\t/*\n\t\t * Don't put the CR into the buffer until we see \n\t\t * the next char.  If the next char is a newline,\n\t\t * discard the CR.\n\t\t */\n\t\tpendc = c;\n\t\tpendpos = pos;\n\t\treturn (0);\n\t}\n\n\tif (!utf_mode)\n\t{\n\t\tr = do_append(c, NULL, pos);\n\t} else\n\t{\n\t\t/* Perform strict validation in all possible cases. */\n\t\tif (mbc_buf_len == 0)\n\t\t{\n\t\tretry:\n\t\t\tmbc_buf_index = 1;\n\t\t\t*mbc_buf = c;\n\t\t\tif (IS_ASCII_OCTET(c))\n\t\t\t\tr = do_append(c, NULL, pos);\n\t\t\telse if (IS_UTF8_LEAD(c))\n\t\t\t{\n\t\t\t\tmbc_buf_len = utf_len(c);\n\t\t\t\tmbc_pos = pos;\n\t\t\t\treturn (0);\n\t\t\t} else\n\t\t\t\t/* UTF8_INVALID or stray UTF8_TRAIL */\n\t\t\t\tr = flush_mbc_buf(pos);\n\t\t} else if (IS_UTF8_TRAIL(c))\n\t\t{\n\t\t\tmbc_buf[mbc_buf_index++] = c;\n\t\t\tif (mbc_buf_index < mbc_buf_len)\n\t\t\t\treturn (0);\n\t\t\tif (is_utf8_well_formed(mbc_buf, mbc_buf_index))\n\t\t\t\tr = do_append(get_wchar(mbc_buf), mbc_buf, mbc_pos);\n\t\t\telse\n\t\t\t\t/* Complete, but not shortest form, sequence. */\n\t\t\t\tmbc_buf_index = r = flush_mbc_buf(mbc_pos);\n\t\t\tmbc_buf_len = 0;\n\t\t} else\n\t\t{\n\t\t\t/* Flush incomplete (truncated) sequence.  */\n\t\t\tr = flush_mbc_buf(mbc_pos);\n\t\t\tmbc_buf_index = r + 1;\n\t\t\tmbc_buf_len = 0;\n\t\t\t/* Handle new char.  */\n\t\t\tif (!r)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (r)\n\t{\n\t\t/* How many chars should caller back up? */\n\t\tr = (!utf_mode) ? 1 : mbc_buf_index;\n\t}\n\treturn (r);\n}\n\n\tstatic int\nstore_control_char(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tif (ctldisp == OPT_ON)\n\t{\n\t\t/* Output the character itself. */\n\t\tSTORE_CHAR(ch, AT_NORMAL, rep, pos);\n\t} else \n\t{\n\t\t/* Output a printable representation of the character. */\n\t\tSTORE_PRCHAR((char) ch, pos);\n\t}\n\treturn (0);\n}\n\n\tstatic int\nstore_ansi(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tswitch (ansi_step(line_ansi, ch))\n\t{\n\tcase ANSI_MID:\n\t\tSTORE_CHAR(ch, AT_ANSI, rep, pos);\n\t\tif (line_ansi->hlink)\n\t\t\thlink_in_line = 1;\n\t\txbuf_add_byte(&last_ansi, (unsigned char) ch);\n\t\tbreak;\n\tcase ANSI_END:\n\t\tSTORE_CHAR(ch, AT_ANSI, rep, pos);\n\t\tansi_done(line_ansi);\n\t\tline_ansi = NULL;\n\t\txbuf_add_byte(&last_ansi, (unsigned char) ch);\n\t\txbuf_set(&last_ansis[curr_last_ansi], &last_ansi);\n\t\txbuf_reset(&last_ansi);\n\t\tcurr_last_ansi = (curr_last_ansi + 1) % NUM_LAST_ANSIS;\n\t\tbreak;\n\tcase ANSI_ERR:\n\t\t{\n\t\t\t/* Remove whole unrecognized sequence.  */\n\t\t\tchar *start = (cshift < hshift) ? xbuf_char_data(&shifted_ansi): linebuf.buf;\n\t\t\tint *end = (cshift < hshift) ? &shifted_ansi.end : &linebuf.end;\n\t\t\tchar *p = start + *end;\n\t\t\tLWCHAR bch;\n\t\t\tdo {\n\t\t\t\tbch = step_char(&p, -1, start);\n\t\t\t} while (p > start && !IS_CSI_START(bch));\n\t\t\t*end = (int) (p - start);\n\t\t}\n\t\txbuf_reset(&last_ansi);\n\t\tansi_done(line_ansi);\n\t\tline_ansi = NULL;\n\t\tbreak;\n\t}\n\treturn (0);\n} \n\n\tstatic int\nstore_bs(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tif (bs_mode == BS_CONTROL)\n\t\treturn store_control_char(ch, rep, pos);\n\tif (linebuf.end > 0 &&\n\t\t((linebuf.end <= linebuf.print && linebuf.buf[linebuf.end-1] == '\\0') ||\n\t     (linebuf.end > 0 && linebuf.attr[linebuf.end - 1] & (AT_ANSI|AT_BINARY))))\n\t\tSTORE_PRCHAR('\\b', pos);\n\telse if (bs_mode == BS_NORMAL)\n\t\tSTORE_CHAR(ch, AT_NORMAL, NULL, pos);\n\telse if (bs_mode == BS_SPECIAL)\n\t\toverstrike = backc();\n\treturn 0;\n}\n\n\tstatic int\ndo_append(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tint a = AT_NORMAL;\n\tint in_overstrike = overstrike;\n\n\tif (ctldisp == OPT_ONPLUS && line_ansi == NULL)\n\t{\n\t\tline_ansi = ansi_start(ch);\n\t\tif (line_ansi != NULL)\n\t\t\tansi_in_line = 1;\n\t}\n\n\toverstrike = 0;\n\tif (line_ansi != NULL)\n\t\treturn store_ansi(ch, rep, pos);\n\n\tif (ch == '\\b')\n\t\treturn store_bs(ch, rep, pos);\n\n\tif (in_overstrike > 0)\n\t{\n\t\t/*\n\t\t * Overstrike the character at the current position\n\t\t * in the line buffer.  This will cause either \n\t\t * underline (if a \"_\" is overstruck), \n\t\t * bold (if an identical character is overstruck),\n\t\t * or just replacing the character in the buffer.\n\t\t */\n\t\tLWCHAR prev_ch;\n\t\toverstrike = utf_mode ? -1 : 0;\n\t\tif (utf_mode)\n\t\t{\n\t\t\t/* To be correct, this must be a base character.  */\n\t\t\tprev_ch = get_wchar(&linebuf.buf[linebuf.end]);\n\t\t} else\n\t\t{\n\t\t\tprev_ch = (unsigned char) linebuf.buf[linebuf.end];\n\t\t}\n\t\ta = linebuf.attr[linebuf.end];\n\t\tif (ch == prev_ch)\n\t\t{\n\t\t\t/*\n\t\t\t * Overstriking a char with itself means make it bold.\n\t\t\t * But overstriking an underscore with itself is\n\t\t\t * ambiguous.  It could mean make it bold, or\n\t\t\t * it could mean make it underlined.\n\t\t\t * Use the previous overstrike to resolve it.\n\t\t\t */\n\t\t\tif (ch == '_')\n\t\t\t{\n\t\t\t\tif ((a & (AT_BOLD|AT_UNDERLINE)) != AT_NORMAL)\n\t\t\t\t\ta |= (AT_BOLD|AT_UNDERLINE);\n\t\t\t\telse if (last_overstrike != AT_NORMAL)\n\t\t\t\t\ta |= last_overstrike;\n\t\t\t\telse\n\t\t\t\t\ta |= AT_BOLD;\n\t\t\t} else\n\t\t\t\ta |= AT_BOLD;\n\t\t} else if (ch == '_')\n\t\t{\n\t\t\ta |= AT_UNDERLINE;\n\t\t\tch = prev_ch;\n\t\t\trep = &linebuf.buf[linebuf.end];\n\t\t} else if (prev_ch == '_')\n\t\t{\n\t\t\ta |= AT_UNDERLINE;\n\t\t}\n\t\t/* Else we replace prev_ch, but we keep its attributes.  */\n\t} else if (in_overstrike < 0)\n\t{\n\t\tif (   is_composing_char(ch)\n\t\t    || is_combining_char(get_wchar(&linebuf.buf[linebuf.end]), ch))\n\t\t\t/* Continuation of the same overstrike.  */\n\t\t\ta = last_overstrike;\n\t\telse\n\t\t\toverstrike = 0;\n\t}\n\n\tif (ch == '\\t')\n\t{\n\t\t/*\n\t\t * Expand a tab into spaces.\n\t\t */\n\t\tswitch (bs_mode)\n\t\t{\n\t\tcase BS_CONTROL:\n\t\t\treturn store_control_char(ch, rep, pos);\n\t\tcase BS_NORMAL:\n\t\tcase BS_SPECIAL:\n\t\t\tSTORE_TAB(a, pos);\n\t\t\tbreak;\n\t\t}\n\t\treturn (0);\n\t}\n\tif ((!utf_mode || is_ascii_char(ch)) && control_char((char)ch))\n\t{\n\t\treturn store_control_char(ch, rep, pos);\n\t} else if (utf_mode && ctldisp != OPT_ON && is_ubin_char(ch))\n\t{\n\t\tSTORE_STRING(prutfchar(ch), AT_BINARY, pos);\n\t} else\n\t{\n\t\tSTORE_CHAR(ch, a, rep, pos);\n\t}\n\treturn (0);\n}\n\n/*\n *\n */\n\tpublic int\npflushmbc(VOID_PARAM)\n{\n\tint r = 0;\n\n\tif (mbc_buf_len > 0)\n\t{\n\t\t/* Flush incomplete (truncated) sequence.  */\n\t\tr = flush_mbc_buf(mbc_pos);\n\t\tmbc_buf_len = 0;\n\t}\n\treturn r;\n}\n\n/*\n * Switch to normal attribute at end of line.\n */\n\tstatic void\nadd_attr_normal(VOID_PARAM)\n{\n\tif (ctldisp != OPT_ONPLUS || !is_ansi_end('m'))\n\t\treturn;\n\taddstr_linebuf(\"\\033[m\", AT_ANSI, 0);\n\tif (hlink_in_line) /* Don't send hyperlink clear if we know we don't need to. */\n\t\taddstr_linebuf(\"\\033]8;;\\033\\\\\", AT_ANSI, 0);\n}\n\n/*\n * Terminate the line in the line buffer.\n */\n\tpublic void\npdone(endline, chopped, forw)\n\tint endline;\n\tint chopped;\n\tint forw;\n{\n\t(void) pflushmbc();\n\n\tif (pendc && (pendc != '\\r' || !endline))\n\t\t/*\n\t\t * If we had a pending character, put it in the buffer.\n\t\t * But discard a pending CR if we are at end of line\n\t\t * (that is, discard the CR in a CR/LF sequence).\n\t\t */\n\t\t(void) do_append(pendc, NULL, pendpos);\n\n\tif (chopped && rscroll_char)\n\t{\n\t\t/*\n\t\t * Display the right scrolling char.\n\t\t * If we've already filled the rightmost screen char \n\t\t * (in the buffer), overwrite it.\n\t\t */\n\t\tif (end_column >= sc_width + cshift)\n\t\t{\n\t\t\t/* We've already written in the rightmost char. */\n\t\t\tend_column = right_column;\n\t\t\tlinebuf.end = right_curr;\n\t\t}\n\t\tadd_attr_normal();\n\t\twhile (end_column < sc_width-1 + cshift) \n\t\t{\n\t\t\t/*\n\t\t\t * Space to last (rightmost) char on screen.\n\t\t\t * This may be necessary if the char we overwrote\n\t\t\t * was double-width.\n\t\t\t */\n\t\t\tadd_linebuf(' ', rscroll_attr, 1);\n\t\t}\n\t\t/* Print rscroll char. It must be single-width. */\n\t\tadd_linebuf(rscroll_char, rscroll_attr, 1);\n\t} else\n\t{\n\t\tadd_attr_normal();\n\t}\n\n\t/*\n\t * If we're coloring a status line, fill out the line with spaces.\n\t */\n\tif (status_line && line_mark_attr != 0) {\n\t\twhile (end_column +1 < sc_width + cshift)\n\t\t\tadd_linebuf(' ', line_mark_attr, 1);\n\t}\n\n\t/*\n\t * Add a newline if necessary,\n\t * and append a '\\0' to the end of the line.\n\t * We output a newline if we're not at the right edge of the screen,\n\t * or if the terminal doesn't auto wrap,\n\t * or if this is really the end of the line AND the terminal ignores\n\t * a newline at the right edge.\n\t * (In the last case we don't want to output a newline if the terminal \n\t * doesn't ignore it since that would produce an extra blank line.\n\t * But we do want to output a newline if the terminal ignores it in case\n\t * the next line is blank.  In that case the single newline output for\n\t * that blank line would be ignored!)\n\t */\n\tif (end_column < sc_width + cshift || !auto_wrap || (endline && ignaw) || ctldisp == OPT_ON)\n\t{\n\t\tadd_linebuf('\\n', AT_NORMAL, 0);\n\t} \n\telse if (ignaw && end_column >= sc_width + cshift && forw)\n\t{\n\t\t/*\n\t\t * Terminals with \"ignaw\" don't wrap until they *really* need\n\t\t * to, i.e. when the character *after* the last one to fit on a\n\t\t * line is output. But they are too hard to deal with when they\n\t\t * get in the state where a full screen width of characters\n\t\t * have been output but the cursor is sitting on the right edge\n\t\t * instead of at the start of the next line.\n\t\t * So we nudge them into wrapping by outputting a space \n\t\t * character plus a backspace.  But do this only if moving \n\t\t * forward; if we're moving backward and drawing this line at\n\t\t * the top of the screen, the space would overwrite the first\n\t\t * char on the next line.  We don't need to do this \"nudge\" \n\t\t * at the top of the screen anyway.\n\t\t */\n\t\tadd_linebuf(' ', AT_NORMAL, 1);\n\t\tadd_linebuf('\\b', AT_NORMAL, -1);\n\t}\n\tset_linebuf(linebuf.end, '\\0', AT_NORMAL);\n}\n\n/*\n * Set an attribute on each char of the line in the line buffer.\n */\n\tpublic void\nset_attr_line(a)\n\tint a;\n{\n\tint i;\n\n\tfor (i = linebuf.print;  i < linebuf.end;  i++)\n\t\tlinebuf.attr[i] |= a;\n}\n\n/*\n * Set the char to be displayed in the status column.\n */\n\tpublic void\nset_status_col(c, attr)\n\tint c;\n\tint attr;\n{\n\tset_pfx(0, c, attr);\n}\n\n/*\n * Get a character from the current line.\n * Return the character as the function return value,\n * and the character attribute in *ap.\n */\n\tpublic int\ngline(i, ap)\n\tint i;\n\tint *ap;\n{\n\tif (is_null_line)\n\t{\n\t\t/*\n\t\t * If there is no current line, we pretend the line is\n\t\t * either \"~\" or \"\", depending on the \"twiddle\" flag.\n\t\t */\n\t\tif (twiddle)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\t*ap = AT_BOLD;\n\t\t\t\treturn '~';\n\t\t\t}\n\t\t\t--i;\n\t\t}\n\t\t/* Make sure we're back to AT_NORMAL before the '\\n'.  */\n\t\t*ap = AT_NORMAL;\n\t\treturn i ? '\\0' : '\\n';\n\t}\n\n\tif (i < linebuf.pfx_end)\n\t{\n\t\t*ap = linebuf.pfx_attr[i];\n\t\treturn linebuf.pfx[i];\n\t}\n\ti += linebuf.print - linebuf.pfx_end;\n\t*ap = linebuf.attr[i];\n\treturn (linebuf.buf[i] & 0xFF);\n}\n\n/*\n * Indicate that there is no current line.\n */\n\tpublic void\nnull_line(VOID_PARAM)\n{\n\tis_null_line = 1;\n\tcshift = 0;\n}\n\n/*\n * Analogous to forw_line(), but deals with \"raw lines\":\n * lines which are not split for screen width.\n * {{ This is supposed to be more efficient than forw_line(). }}\n */\n\tpublic POSITION\nforw_raw_line(curr_pos, linep, line_lenp)\n\tPOSITION curr_pos;\n\tchar **linep;\n\tint *line_lenp;\n{\n\tint n;\n\tint c;\n\tPOSITION new_pos;\n\n\tif (curr_pos == NULL_POSITION || ch_seek(curr_pos) ||\n\t\t(c = ch_forw_get()) == EOI)\n\t\treturn (NULL_POSITION);\n\n\tn = 0;\n\tfor (;;)\n\t{\n\t\tif (c == '\\n' || c == EOI || ABORT_SIGS())\n\t\t{\n\t\t\tnew_pos = ch_tell();\n\t\t\tbreak;\n\t\t}\n\t\tif (n >= size_linebuf-1)\n\t\t{\n\t\t\tif (expand_linebuf())\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Overflowed the input buffer.\n\t\t\t\t * Pretend the line ended here.\n\t\t\t\t */\n\t\t\t\tnew_pos = ch_tell() - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlinebuf.buf[n++] = c;\n\t\tc = ch_forw_get();\n\t}\n\tlinebuf.buf[n] = '\\0';\n\tif (linep != NULL)\n\t\t*linep = linebuf.buf;\n\tif (line_lenp != NULL)\n\t\t*line_lenp = n;\n\treturn (new_pos);\n}\n\n/*\n * Analogous to back_line(), but deals with \"raw lines\".\n * {{ This is supposed to be more efficient than back_line(). }}\n */\n\tpublic POSITION\nback_raw_line(curr_pos, linep, line_lenp)\n\tPOSITION curr_pos;\n\tchar **linep;\n\tint *line_lenp;\n{\n\tint n;\n\tint c;\n\tPOSITION new_pos;\n\n\tif (curr_pos == NULL_POSITION || curr_pos <= ch_zero() ||\n\t\tch_seek(curr_pos-1))\n\t\treturn (NULL_POSITION);\n\n\tn = size_linebuf;\n\tlinebuf.buf[--n] = '\\0';\n\tfor (;;)\n\t{\n\t\tc = ch_back_get();\n\t\tif (c == '\\n' || ABORT_SIGS())\n\t\t{\n\t\t\t/*\n\t\t\t * This is the newline ending the previous line.\n\t\t\t * We have hit the beginning of the line.\n\t\t\t */\n\t\t\tnew_pos = ch_tell() + 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (c == EOI)\n\t\t{\n\t\t\t/*\n\t\t\t * We have hit the beginning of the file.\n\t\t\t * This must be the first line in the file.\n\t\t\t * This must, of course, be the beginning of the line.\n\t\t\t */\n\t\t\tnew_pos = ch_zero();\n\t\t\tbreak;\n\t\t}\n\t\tif (n <= 0)\n\t\t{\n\t\t\tint old_size_linebuf = size_linebuf;\n\t\t\tchar *fm;\n\t\t\tchar *to;\n\t\t\tif (expand_linebuf())\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Overflowed the input buffer.\n\t\t\t\t * Pretend the line ended here.\n\t\t\t\t */\n\t\t\t\tnew_pos = ch_tell() + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Shift the data to the end of the new linebuf.\n\t\t\t */\n\t\t\tfor (fm = linebuf.buf + old_size_linebuf - 1,\n\t\t\t      to = linebuf.buf + size_linebuf - 1;\n\t\t\t     fm >= linebuf.buf;  fm--, to--)\n\t\t\t\t*to = *fm;\n\t\t\tn = size_linebuf - old_size_linebuf;\n\t\t}\n\t\tlinebuf.buf[--n] = c;\n\t}\n\tif (linep != NULL)\n\t\t*linep = &linebuf.buf[n];\n\tif (line_lenp != NULL)\n\t\t*line_lenp = size_linebuf - 1 - n;\n\treturn (new_pos);\n}\n\n/*\n * Append a string to the line buffer.\n */\n\tstatic int\npappstr(str)\n\tconstant char *str;\n{\n\twhile (*str != '\\0')\n\t{\n\t\tif (pappend(*str++, NULL_POSITION))\n\t\t\t/* Doesn't fit on screen. */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Load a string into the line buffer.\n * If the string is too long to fit on the screen,\n * truncate the beginning of the string to fit.\n */\n\tpublic void\nload_line(str)\n\tconstant char *str;\n{\n\tint save_hshift = hshift;\n\n\thshift = 0;\n\tfor (;;)\n\t{\n\t\tprewind();\n\t\tif (pappstr(str) == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Didn't fit on screen; increase left shift by one.\n\t\t * {{ This gets very inefficient if the string\n\t\t * is much longer than the screen width. }}\n\t\t */\n\t\thshift += 1;\n\t}\n\tset_linebuf(linebuf.end, '\\0', AT_NORMAL);\n\thshift = save_hshift;\n}\n\n/*\n * Find the shift necessary to show the end of the longest displayed line.\n */\n\tpublic int\nrrshift(VOID_PARAM)\n{\n\tPOSITION pos;\n\tint save_width;\n\tint line;\n\tint longest = 0;\n\n\tsave_width = sc_width;\n\tsc_width = INT_MAX;\n\tpos = position(TOP);\n\tfor (line = 0; line < sc_height && pos != NULL_POSITION; line++)\n\t{\n\t\tpos = forw_line(pos);\n\t\tif (end_column > longest)\n\t\t\tlongest = end_column;\n\t}\n\tsc_width = save_width;\n\tif (longest < sc_width)\n\t\treturn 0;\n\treturn longest - sc_width;\n}\n\n/*\n * Get the color_map index associated with a given attribute.\n */\n\tstatic int\ncolor_index(attr)\n\tint attr;\n{\n\tif (use_color)\n\t{\n\t\tswitch (attr & AT_COLOR)\n\t\t{\n\t\tcase AT_COLOR_ATTN:    return 0;\n\t\tcase AT_COLOR_BIN:     return 1;\n\t\tcase AT_COLOR_CTRL:    return 2;\n\t\tcase AT_COLOR_ERROR:   return 3;\n\t\tcase AT_COLOR_LINENUM: return 4;\n\t\tcase AT_COLOR_MARK:    return 5;\n\t\tcase AT_COLOR_PROMPT:  return 6;\n\t\tcase AT_COLOR_RSCROLL: return 7;\n\t\tcase AT_COLOR_SEARCH:  return 8;\n\t\tcase AT_COLOR_HEADER:  return 9;\n\t\t}\n\t}\n\tif (attr & AT_UNDERLINE)\n\t\treturn 10;\n\tif (attr & AT_BOLD)\n\t\treturn 11;\n\tif (attr & AT_BLINK)\n\t\treturn 12;\n\tif (attr & AT_STANDOUT)\n\t\treturn 13;\n\treturn -1;\n}\n\n/*\n * Set the color string to use for a given attribute.\n */\n\tpublic int\nset_color_map(attr, colorstr)\n\tint attr;\n\tchar *colorstr;\n{\n\tint cx = color_index(attr);\n\tif (cx < 0)\n\t\treturn -1;\n\tif (strlen(colorstr)+1 > sizeof(color_map[cx]))\n\t\treturn -1;\n\tif (*colorstr != '\\0' && parse_color(colorstr, NULL, NULL) == CT_NULL)\n\t\treturn -1;\n\tstrcpy(color_map[cx], colorstr);\n\treturn 0;\n}\n\n/*\n * Get the color string to use for a given attribute.\n */\n\tpublic char *\nget_color_map(attr)\n\tint attr;\n{\n\tint cx = color_index(attr);\n\tif (cx < 0)\n\t\treturn NULL;\n\treturn color_map[cx];\n}\n"], "fixing_code": ["/*\n * Copyright (C) 1984-2022  Mark Nudelman\n *\n * You may distribute under the terms of either the GNU General Public\n * License or the Less License, as specified in the README file.\n *\n * For more information, see the README file.\n */\n\n/*\n * Routines to manipulate the \"line buffer\".\n * The line buffer holds a line of output as it is being built\n * in preparation for output to the screen.\n */\n\n#include \"less.h\"\n#include \"charset.h\"\n#include \"position.h\"\n\n#if MSDOS_COMPILER==WIN32C\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#endif\n\n#define MAX_PFX_WIDTH (MAX_LINENUM_WIDTH + MAX_STATUSCOL_WIDTH + 1)\nstatic struct {\n\tchar *buf;    /* Buffer which holds the current output line */\n\tint *attr;   /* Parallel to buf, to hold attributes */\n\tint print;    /* Index in buf of first printable char */\n\tint end;      /* Number of chars in buf */\n\tchar pfx[MAX_PFX_WIDTH]; /* Holds status column and line number */\n\tint pfx_attr[MAX_PFX_WIDTH];\n\tint pfx_end;  /* Number of chars in pfx */\n} linebuf;\n\n/*\n * Buffer of ansi sequences which have been shifted off the left edge \n * of the screen. \n */\nstruct xbuffer shifted_ansi;\n\n/*\n * Ring buffer of last ansi sequences sent.\n * While sending a line, these will be resent at the end\n * of any highlighted string, to restore text modes.\n * {{ Not ideal, since we don't really know how many to resend. }}\n */\n#define NUM_LAST_ANSIS 3\nstatic struct xbuffer last_ansi;\nstatic struct xbuffer last_ansis[NUM_LAST_ANSIS];\nstatic int curr_last_ansi;\n\npublic int size_linebuf = 0; /* Size of line buffer (and attr buffer) */\nstatic struct ansi_state *line_ansi = NULL;\nstatic int ansi_in_line;\nstatic int hlink_in_line;\nstatic int line_mark_attr;\nstatic int cshift;   /* Current left-shift of output line buffer */\npublic int hshift;   /* Desired left-shift of output line buffer */\npublic int tabstops[TABSTOP_MAX] = { 0 }; /* Custom tabstops */\npublic int ntabstops = 1;        /* Number of tabstops */\npublic int tabdefault = 8;       /* Default repeated tabstops */\npublic POSITION highest_hilite;  /* Pos of last hilite in file found so far */\n\nstatic int end_column;  /* Printable length, accounting for backspaces, etc. */\nstatic int right_curr;\nstatic int right_column;\nstatic int overstrike;  /* Next char should overstrike previous char */\nstatic int last_overstrike = AT_NORMAL;\nstatic int is_null_line;  /* There is no current line */\nstatic LWCHAR pendc;\nstatic POSITION pendpos;\nstatic char *end_ansi_chars;\nstatic char *mid_ansi_chars;\nstatic int in_hilite;\n\nstatic int attr_swidth LESSPARAMS ((int a));\nstatic int attr_ewidth LESSPARAMS ((int a));\nstatic int do_append LESSPARAMS ((LWCHAR ch, char *rep, POSITION pos));\n\nextern int sigs;\nextern int bs_mode;\nextern int linenums;\nextern int ctldisp;\nextern int twiddle;\nextern int binattr;\nextern int status_col;\nextern int status_col_width;\nextern int linenum_width;\nextern int auto_wrap, ignaw;\nextern int bo_s_width, bo_e_width;\nextern int ul_s_width, ul_e_width;\nextern int bl_s_width, bl_e_width;\nextern int so_s_width, so_e_width;\nextern int sc_width, sc_height;\nextern int utf_mode;\nextern POSITION start_attnpos;\nextern POSITION end_attnpos;\nextern char rscroll_char;\nextern int rscroll_attr;\nextern int use_color;\nextern int status_line;\n\nstatic char mbc_buf[MAX_UTF_CHAR_LEN];\nstatic int mbc_buf_len = 0;\nstatic int mbc_buf_index = 0;\nstatic POSITION mbc_pos;\n\n/* Configurable color map */\nstatic char color_map[AT_NUM_COLORS][12] = {\n\t\"Wm\",  /* AT_COLOR_ATTN */\n\t\"kR\",  /* AT_COLOR_BIN */\n\t\"kR\",  /* AT_COLOR_CTRL */\n\t\"kY\",  /* AT_COLOR_ERROR */\n\t\"c\",   /* AT_COLOR_LINENUM */\n\t\"Wb\",  /* AT_COLOR_MARK */\n\t\"kC\",  /* AT_COLOR_PROMPT */\n\t\"kc\",  /* AT_COLOR_RSCROLL */\n\t\"kG\",  /* AT_COLOR_SEARCH */\n\t\"\",    /* AT_COLOR_HEADER */\n\t\"\",    /* AT_UNDERLINE */\n\t\"\",    /* AT_BOLD */\n\t\"\",    /* AT_BLINK */\n\t\"\",    /* AT_STANDOUT */\n};\n\n/* State while processing an ANSI escape sequence */\nstruct ansi_state {\n\tint hindex;   /* Index into hyperlink prefix */\n\tint hlink;    /* Processing hyperlink address? */\n\tint prev_esc; /* Prev char was ESC (to detect ESC-\\ seq) */\n};\n\n/*\n * Initialize from environment variables.\n */\n\tpublic void\ninit_line(VOID_PARAM)\n{\n\tint ax;\n\n\tend_ansi_chars = lgetenv(\"LESSANSIENDCHARS\");\n\tif (isnullenv(end_ansi_chars))\n\t\tend_ansi_chars = \"m\";\n\n\tmid_ansi_chars = lgetenv(\"LESSANSIMIDCHARS\");\n\tif (isnullenv(mid_ansi_chars))\n\t\tmid_ansi_chars = \"0123456789:;[?!\\\"'#%()*+ \";\n\n\tlinebuf.buf = (char *) ecalloc(LINEBUF_SIZE, sizeof(char));\n\tlinebuf.attr = (int *) ecalloc(LINEBUF_SIZE, sizeof(int));\n\tsize_linebuf = LINEBUF_SIZE;\n\txbuf_init(&shifted_ansi);\n\txbuf_init(&last_ansi);\n\tfor (ax = 0;  ax < NUM_LAST_ANSIS;  ax++)\n\t\txbuf_init(&last_ansis[ax]);\n\tcurr_last_ansi = 0;\n}\n\n/*\n * Expand the line buffer.\n */\n\tstatic int\nexpand_linebuf(VOID_PARAM)\n{\n\t/* Double the size of the line buffer. */\n\tint new_size = size_linebuf * 2;\n\tchar *new_buf = (char *) calloc(new_size, sizeof(char));\n\tint *new_attr = (int *) calloc(new_size, sizeof(int));\n\tif (new_buf == NULL || new_attr == NULL)\n\t{\n\t\tif (new_attr != NULL)\n\t\t\tfree(new_attr);\n\t\tif (new_buf != NULL)\n\t\t\tfree(new_buf);\n\t\treturn 1;\n\t}\n\t/*\n\t * We just calloc'd the buffers; copy the old contents.\n\t */\n\tmemcpy(new_buf, linebuf.buf, size_linebuf * sizeof(char));\n\tmemcpy(new_attr, linebuf.attr, size_linebuf * sizeof(int));\n\tfree(linebuf.attr);\n\tfree(linebuf.buf);\n\tlinebuf.buf = new_buf;\n\tlinebuf.attr = new_attr;\n\tsize_linebuf = new_size;\n\treturn 0;\n}\n\n/*\n * Is a character ASCII?\n */\n\tpublic int\nis_ascii_char(ch)\n\tLWCHAR ch;\n{\n\treturn (ch <= 0x7F);\n}\n\n/*\n */\n\tstatic void\ninc_end_column(w)\n\tint w;\n{\n\tif (end_column > right_column && w > 0)\n\t{\n\t\tright_column = end_column;\n\t\tright_curr = linebuf.end;\n\t}\n\tend_column += w;\n}\n\n/*\n * Rewind the line buffer.\n */\n\tpublic void\nprewind(VOID_PARAM)\n{\n\tint ax;\n\n\tlinebuf.print = 6; /* big enough for longest UTF-8 sequence */\n\tlinebuf.pfx_end = 0;\n\tfor (linebuf.end = 0; linebuf.end < linebuf.print; linebuf.end++)\n\t{\n\t\tlinebuf.buf[linebuf.end] = '\\0';\n\t\tlinebuf.attr[linebuf.end] = 0;\n\t}\n\n\tend_column = 0;\n\tright_curr = 0;\n\tright_column = 0;\n\tcshift = 0;\n\toverstrike = 0;\n\tlast_overstrike = AT_NORMAL;\n\tmbc_buf_len = 0;\n\tis_null_line = 0;\n\tpendc = '\\0';\n\tin_hilite = 0;\n\tansi_in_line = 0;\n\thlink_in_line = 0;\n\tline_mark_attr = 0;\n\txbuf_reset(&shifted_ansi);\n\txbuf_reset(&last_ansi);\n\tfor (ax = 0;  ax < NUM_LAST_ANSIS;  ax++)\n\t\txbuf_reset(&last_ansis[ax]);\n\tcurr_last_ansi = 0;\n}\n\n/*\n * Set a character in the line buffer.\n */\n\tstatic void\nset_linebuf(n, ch, attr)\n\tint n;\n\tchar ch;\n\tint attr;\n{\n\tlinebuf.buf[n] = ch;\n\tlinebuf.attr[n] = attr;\n}\n\n/*\n * Append a character to the line buffer.\n */\n\tstatic void\nadd_linebuf(ch, attr, w)\n\tchar ch;\n\tint attr;\n\tint w;\n{\n\tset_linebuf(linebuf.end++, ch, attr);\n\tinc_end_column(w);\n}\n\n/*\n * Append a string to the line buffer.\n */\n\tstatic void\naddstr_linebuf(s, attr, cw)\n\tchar *s;\n\tint attr;\n\tint cw;\n{\n\tfor ( ;  *s != '\\0';  s++)\n\t\tadd_linebuf(*s, attr, cw);\n}\n\n/*\n * Set a character in the line prefix buffer.\n */\n\tstatic void\nset_pfx(n, ch, attr)\n\tint n;\n\tchar ch;\n\tint attr;\n{\n\tlinebuf.pfx[n] = ch;\n\tlinebuf.pfx_attr[n] = attr;\n}\n\n/*\n * Append a character to the line prefix buffer.\n */\n\tstatic void\nadd_pfx(ch, attr)\n\tchar ch;\n\tint attr;\n{\n\tset_pfx(linebuf.pfx_end++, ch, attr);\n}\n\n/*\n * Insert the status column and line number into the line buffer.\n */\n\tpublic void\nplinestart(pos)\n\tPOSITION pos;\n{\n\tLINENUM linenum = 0;\n\tint i;\n\n\tif (linenums == OPT_ONPLUS)\n\t{\n\t\t/*\n\t\t * Get the line number and put it in the current line.\n\t\t * {{ Note: since find_linenum calls forw_raw_line,\n\t\t *    it may seek in the input file, requiring the caller \n\t\t *    of plinestart to re-seek if necessary. }}\n\t\t * {{ Since forw_raw_line modifies linebuf, we must\n\t\t *    do this first, before storing anything in linebuf. }}\n\t\t */\n\t\tlinenum = find_linenum(pos);\n\t}\n\n\t/*\n\t * Display a status column if the -J option is set.\n\t */\n\tif (status_col || status_line)\n\t{\n\t\tchar c = posmark(pos);\n\t\tif (c != 0)\n\t\t\tline_mark_attr = AT_HILITE|AT_COLOR_MARK;\n\t\telse if (start_attnpos != NULL_POSITION &&\n\t\t         pos >= start_attnpos && pos <= end_attnpos)\n\t\t\tline_mark_attr = AT_HILITE|AT_COLOR_ATTN;\n\t\tif (status_col)\n\t\t{\n\t\t\tadd_pfx(c ? c : ' ', line_mark_attr); /* column 0: status */\n\t\t\twhile (linebuf.pfx_end < status_col_width)\n\t\t\t\tadd_pfx(' ', AT_NORMAL);\n\t\t}\n\t}\n\n\t/*\n\t * Display the line number at the start of each line\n\t * if the -N option is set.\n\t */\n\tif (linenums == OPT_ONPLUS)\n\t{\n\t\tchar buf[INT_STRLEN_BOUND(linenum) + 2];\n\t\tint len;\n\n\t\tlinenum = vlinenum(linenum);\n\t\tif (linenum == 0)\n\t\t\tlen = 0;\n\t\telse\n\t\t{\n\t\t\tlinenumtoa(linenum, buf);\n\t\t\tlen = (int) strlen(buf);\n\t\t}\n\t\tfor (i = 0; i < linenum_width - len; i++)\n\t\t\tadd_pfx(' ', AT_NORMAL);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tadd_pfx(buf[i], AT_BOLD|AT_COLOR_LINENUM);\n\t\tadd_pfx(' ', AT_NORMAL);\n\t}\n\tend_column = linebuf.pfx_end;\n}\n\n/*\n * Return the width of the line prefix (status column and line number).\n * {{ Actual line number can be wider than linenum_width. }}\n */\n\tpublic int\nline_pfx_width(VOID_PARAM)\n{\n\tint width = 0;\n\tif (status_col)\n\t\twidth += status_col_width;\n\tif (linenums == OPT_ONPLUS)\n\t\twidth += linenum_width + 1;\n\treturn width;\n}\n\n/*\n * Shift line left so that the last char is just to the left\n * of the first visible column.\n */\n\tpublic void\npshift_all(VOID_PARAM)\n{\n\tint i;\n\tfor (i = linebuf.print;  i < linebuf.end;  i++)\n\t\tif (linebuf.attr[i] == AT_ANSI)\n\t\t\txbuf_add_byte(&shifted_ansi, (unsigned char) linebuf.buf[i]);\n\tlinebuf.end = linebuf.print;\n\tend_column = linebuf.pfx_end;\n}\n\n/*\n * Return the printing width of the start (enter) sequence\n * for a given character attribute.\n */\n\tstatic int\nattr_swidth(a)\n\tint a;\n{\n\tint w = 0;\n\n\ta = apply_at_specials(a);\n\n\tif (a & AT_UNDERLINE)\n\t\tw += ul_s_width;\n\tif (a & AT_BOLD)\n\t\tw += bo_s_width;\n\tif (a & AT_BLINK)\n\t\tw += bl_s_width;\n\tif (a & AT_STANDOUT)\n\t\tw += so_s_width;\n\n\treturn w;\n}\n\n/*\n * Return the printing width of the end (exit) sequence\n * for a given character attribute.\n */\n\tstatic int\nattr_ewidth(a)\n\tint a;\n{\n\tint w = 0;\n\n\ta = apply_at_specials(a);\n\n\tif (a & AT_UNDERLINE)\n\t\tw += ul_e_width;\n\tif (a & AT_BOLD)\n\t\tw += bo_e_width;\n\tif (a & AT_BLINK)\n\t\tw += bl_e_width;\n\tif (a & AT_STANDOUT)\n\t\tw += so_e_width;\n\n\treturn w;\n}\n\n/*\n * Return the printing width of a given character and attribute,\n * if the character were added after prev_ch.\n * Adding a character with a given attribute may cause an enter or exit\n * attribute sequence to be inserted, so this must be taken into account.\n */\n\tpublic int\npwidth(ch, a, prev_ch, prev_a)\n\tLWCHAR ch;\n\tint a;\n\tLWCHAR prev_ch;\n\tint prev_a;\n{\n\tint w;\n\n\tif (ch == '\\b')\n\t{\n\t\t/*\n\t\t * Backspace moves backwards one or two positions.\n\t\t */\n\t\tif (prev_a & (AT_ANSI|AT_BINARY))\n\t\t\treturn strlen(prchar('\\b'));\n\t\treturn (utf_mode && is_wide_char(prev_ch)) ? -2 : -1;\n\t}\n\n\tif (!utf_mode || is_ascii_char(ch))\n\t{\n\t\tif (control_char((char)ch))\n\t\t{\n\t\t\t/*\n\t\t\t * Control characters do unpredictable things,\n\t\t\t * so we don't even try to guess; say it doesn't move.\n\t\t\t * This can only happen if the -r flag is in effect.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t{\n\t\tif (is_composing_char(ch) || is_combining_char(prev_ch, ch))\n\t\t{\n\t\t\t/*\n\t\t\t * Composing and combining chars take up no space.\n\t\t\t *\n\t\t\t * Some terminals, upon failure to compose a\n\t\t\t * composing character with the character(s) that\n\t\t\t * precede(s) it will actually take up one end_column\n\t\t\t * for the composing character; there isn't much\n\t\t\t * we could do short of testing the (complex)\n\t\t\t * composition process ourselves and printing\n\t\t\t * a binary representation when it fails.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * Other characters take one or two columns,\n\t * plus the width of any attribute enter/exit sequence.\n\t */\n\tw = 1;\n\tif (is_wide_char(ch))\n\t\tw++;\n\tif (linebuf.end > 0 && !is_at_equiv(linebuf.attr[linebuf.end-1], a))\n\t\tw += attr_ewidth(linebuf.attr[linebuf.end-1]);\n\tif (apply_at_specials(a) != AT_NORMAL &&\n\t    (linebuf.end == 0 || !is_at_equiv(linebuf.attr[linebuf.end-1], a)))\n\t\tw += attr_swidth(a);\n\treturn (w);\n}\n\n/*\n * Delete to the previous base character in the line buffer.\n */\n\tstatic int\nbackc(VOID_PARAM)\n{\n\tLWCHAR ch;\n\tchar *p;\n\n\tif (linebuf.end == 0)\n\t\treturn (0);\n\tp = &linebuf.buf[linebuf.end];\n\tch = step_char(&p, -1, linebuf.buf);\n\t/* Skip back to the next nonzero-width char. */\n\twhile (p > linebuf.buf)\n\t{\n\t\tLWCHAR prev_ch;\n\t\tint width;\n\t\tlinebuf.end = (int) (p - linebuf.buf);\n\t\tprev_ch = step_char(&p, -1, linebuf.buf);\n\t\twidth = pwidth(ch, linebuf.attr[linebuf.end], prev_ch, linebuf.attr[linebuf.end-1]);\n\t\tend_column -= width;\n\t\t/* {{ right_column? }} */\n\t\tif (width > 0)\n\t\t\tbreak;\n\t\tch = prev_ch;\n\t}\n\treturn (1);\n}\n\n/*\n * Is a character the end of an ANSI escape sequence?\n */\n\tpublic int\nis_ansi_end(ch)\n\tLWCHAR ch;\n{\n\tif (!is_ascii_char(ch))\n\t\treturn (0);\n\treturn (strchr(end_ansi_chars, (char) ch) != NULL);\n}\n\n/*\n * Can a char appear in an ANSI escape sequence, before the end char?\n */\n\tpublic int\nis_ansi_middle(ch)\n\tLWCHAR ch;\n{\n\tif (!is_ascii_char(ch))\n\t\treturn (0);\n\tif (is_ansi_end(ch))\n\t\treturn (0);\n\treturn (strchr(mid_ansi_chars, (char) ch) != NULL);\n}\n\n/*\n * Skip past an ANSI escape sequence.\n * pp is initially positioned just after the CSI_START char.\n */\n\tpublic void\nskip_ansi(pansi, pp, limit)\n\tstruct ansi_state *pansi;\n\tchar **pp;\n\tconstant char *limit;\n{\n\tLWCHAR c;\n\tdo {\n\t\tc = step_char(pp, +1, limit);\n\t} while (*pp < limit && ansi_step(pansi, c) == ANSI_MID);\n\t/* Note that we discard final char, for which is_ansi_end is true. */\n}\n\n/*\n * Determine if a character starts an ANSI escape sequence.\n * If so, return an ansi_state struct; otherwise return NULL.\n */\n\tpublic struct ansi_state *\nansi_start(ch)\n\tLWCHAR ch;\n{\n\tstruct ansi_state *pansi;\n\n\tif (!IS_CSI_START(ch))\n\t\treturn NULL;\n\tpansi = ecalloc(1, sizeof(struct ansi_state));\n\tpansi->hindex = 0;\n\tpansi->hlink = 0;\n\tpansi->prev_esc = 0;\n\treturn pansi;\n}\n\n/*\n * Determine whether the next char in an ANSI escape sequence\n * ends the sequence.\n */\n\tpublic int\nansi_step(pansi, ch)\n\tstruct ansi_state *pansi;\n\tLWCHAR ch;\n{\n\tif (pansi->hlink)\n\t{\n\t\t/* Hyperlink ends with \\7 or ESC-backslash. */\n\t\tif (ch == '\\7')\n\t\t\treturn ANSI_END;\n\t\tif (pansi->prev_esc)\n            return (ch == '\\\\') ? ANSI_END : ANSI_ERR;\n\t\tpansi->prev_esc = (ch == ESC);\n\t\treturn ANSI_MID;\n\t}\n\tif (pansi->hindex >= 0)\n\t{\n\t\tstatic char hlink_prefix[] = ESCS \"]8;\";\n\t\tif (ch == hlink_prefix[pansi->hindex] ||\n\t\t    (pansi->hindex == 0 && IS_CSI_START(ch)))\n\t\t{\n\t\t\tpansi->hindex++;\n\t\t\tif (hlink_prefix[pansi->hindex] == '\\0')\n\t\t\t\tpansi->hlink = 1; /* now processing hyperlink addr */\n\t\t\treturn ANSI_MID;\n\t\t}\n\t\tpansi->hindex = -1; /* not a hyperlink */\n\t}\n\t/* Check for SGR sequences */\n\tif (is_ansi_middle(ch))\n\t\treturn ANSI_MID;\n\tif (is_ansi_end(ch))\n\t\treturn ANSI_END;\n\treturn ANSI_ERR;\n}\n\n/*\n * Free an ansi_state structure.\n */\n\tpublic void\nansi_done(pansi)\n\tstruct ansi_state *pansi;\n{\n\tfree(pansi);\n}\n\n/*\n * Will w characters in attribute a fit on the screen?\n */\n\tstatic int\nfits_on_screen(w, a)\n\tint w;\n\tint a;\n{\n\tif (ctldisp == OPT_ON)\n\t\t/* We're not counting, so say that everything fits. */\n\t\treturn 1;\n\treturn (end_column - cshift + w + attr_ewidth(a) <= sc_width);\n}\n\n/*\n * Append a character and attribute to the line buffer.\n */\n#define STORE_CHAR(ch,a,rep,pos) \\\n\tdo { \\\n\t\tif (store_char((ch),(a),(rep),(pos))) return (1); \\\n\t} while (0)\n\n\tstatic int\nstore_char(ch, a, rep, pos)\n\tLWCHAR ch;\n\tint a;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tint w;\n\tint i;\n\tint replen;\n\tchar cs;\n\n\ti = (a & (AT_UNDERLINE|AT_BOLD));\n\tif (i != AT_NORMAL)\n\t\tlast_overstrike = i;\n\n#if HILITE_SEARCH\n\t{\n\t\tint matches;\n\t\tint resend_last = 0;\n\t\tint hl_attr;\n\n\t\tif (pos == NULL_POSITION)\n\t\t{\n\t\t\t/* Color the prompt unless it has ansi sequences in it. */\n\t\t\thl_attr = ansi_in_line ? 0 : AT_STANDOUT|AT_COLOR_PROMPT;\n\t\t} else\n\t\t{\n\t\t\thl_attr = is_hilited_attr(pos, pos+1, 0, &matches);\n\t\t\tif (hl_attr == 0 && status_line)\n\t\t\t\thl_attr = line_mark_attr;\n\t\t}\n\t\tif (hl_attr)\n\t\t{\n\t\t\t/*\n\t\t\t * This character should be highlighted.\n\t\t\t * Override the attribute passed in.\n\t\t\t */\n\t\t\tif (a != AT_ANSI)\n\t\t\t{\n\t\t\t\tif (highest_hilite != NULL_POSITION && pos != NULL_POSITION && pos > highest_hilite)\n\t\t\t\t\thighest_hilite = pos;\n\t\t\t\ta |= hl_attr;\n\t\t\t}\n\t\t\tin_hilite = 1;\n\t\t} else \n\t\t{\n\t\t\tif (in_hilite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This is the first non-hilited char after a hilite.\n\t\t\t\t * Resend the last ANSI seq to restore color.\n\t\t\t\t */\n\t\t\t\tresend_last = 1;\n\t\t\t}\n\t\t\tin_hilite = 0;\n\t\t}\n\t\tif (resend_last)\n\t\t{\n\t\t\tint ai;\n\t\t\tfor (ai = 0;  ai < NUM_LAST_ANSIS;  ai++)\n\t\t\t{\n\t\t\t\tint ax = (curr_last_ansi + ai) % NUM_LAST_ANSIS;\n\t\t\t\tfor (i = 0;  i < last_ansis[ax].end;  i++)\n\t\t\t\t\tSTORE_CHAR(last_ansis[ax].data[i], AT_ANSI, NULL, pos);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (a == AT_ANSI) {\n\t\tw = 0;\n\t} else {\n\t\tchar *p = &linebuf.buf[linebuf.end];\n\t\tLWCHAR prev_ch = (linebuf.end > 0) ? step_char(&p, -1, linebuf.buf) : 0;\n\t\tint prev_a = (linebuf.end > 0) ? linebuf.attr[linebuf.end-1] : 0;\n\t\tw = pwidth(ch, a, prev_ch, prev_a);\n\t}\n\n\tif (!fits_on_screen(w, a))\n\t\treturn (1);\n\n\tif (rep == NULL)\n\t{\n\t\tcs = (char) ch;\n\t\trep = &cs;\n\t\treplen = 1;\n\t} else\n\t{\n\t\treplen = utf_len(rep[0]);\n\t}\n\tif (linebuf.end + replen >= size_linebuf-6)\n\t{\n\t\t/*\n\t\t * Won't fit in line buffer.\n\t\t * Try to expand it.\n\t\t */\n\t\tif (expand_linebuf())\n\t\t\treturn (1);\n\t}\n\n\tif (cshift == hshift && shifted_ansi.end > 0)\n\t{\n\t\t/* Copy shifted ANSI sequences to beginning of line. */\n\t\tfor (i = 0;  i < shifted_ansi.end;  i++)\n\t\t\tadd_linebuf(shifted_ansi.data[i], AT_ANSI, 0);\n\t\txbuf_reset(&shifted_ansi);\n\t}\n\t/* Add the char to the buf, even if we will left-shift it next. */\n\tinc_end_column(w);\n\tfor (i = 0;  i < replen;  i++)\n\t\tadd_linebuf(*rep++, a, 0);\n\n\tif (cshift < hshift)\n\t{\n\t\t/* We haven't left-shifted enough yet. */\n\t\tif (a == AT_ANSI)\n\t\t\txbuf_add_byte(&shifted_ansi, (unsigned char) ch); /* Save ANSI attributes */\n\t\tif (linebuf.end > linebuf.print)\n\t\t{\n\t\t\t/* Shift left enough to put last byte of this char at print-1. */\n\t\t\tint i;\n\t\t\tfor (i = 0; i < linebuf.print; i++)\n\t\t\t{\n\t\t\t\tlinebuf.buf[i] = linebuf.buf[i+replen];\n\t\t\t\tlinebuf.attr[i] = linebuf.attr[i+replen];\n\t\t\t}\n\t\t\tlinebuf.end -= replen;\n\t\t\tcshift += w;\n\t\t\t/*\n\t\t\t * If the char we just left-shifted was double width,\n\t\t\t * the 2 spaces we shifted may be too much.\n\t\t\t * Represent the \"half char\" at start of line with a highlighted space.\n\t\t\t */\n\t\t\twhile (cshift > hshift)\n\t\t\t{\n\t\t\t\tadd_linebuf(' ', rscroll_attr, 0);\n\t\t\t\tcshift--;\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n\n#define STORE_STRING(s,a,pos) \\\n\tdo { if (store_string((s),(a),(pos))) return (1); } while (0)\n\n\tstatic int\nstore_string(s, a, pos)\n\tchar *s;\n\tint a;\n\tPOSITION pos;\n{\n\tif (!fits_on_screen(strlen(s), a))\n\t\treturn 1;\n\tfor ( ;  *s != 0;  s++)\n\t\tSTORE_CHAR(*s, a, NULL, pos);\n\treturn 0;\n}\n\n/*\n * Append a tab to the line buffer.\n * Store spaces to represent the tab.\n */\n#define STORE_TAB(a,pos) \\\n\tdo { if (store_tab((a),(pos))) return (1); } while (0)\n\n\tstatic int\nstore_tab(attr, pos)\n\tint attr;\n\tPOSITION pos;\n{\n\tint to_tab = end_column - linebuf.pfx_end;\n\n\tif (ntabstops < 2 || to_tab >= tabstops[ntabstops-1])\n\t\tto_tab = tabdefault -\n\t\t     ((to_tab - tabstops[ntabstops-1]) % tabdefault);\n\telse\n\t{\n\t\tint i;\n\t\tfor (i = ntabstops - 2;  i >= 0;  i--)\n\t\t\tif (to_tab >= tabstops[i])\n\t\t\t\tbreak;\n\t\tto_tab = tabstops[i+1] - to_tab;\n\t}\n\n\tdo {\n\t\tSTORE_CHAR(' ', attr, \" \", pos);\n\t} while (--to_tab > 0);\n\treturn 0;\n}\n\n#define STORE_PRCHAR(c, pos) \\\n\tdo { if (store_prchar((c), (pos))) return 1; } while (0)\n\n\tstatic int\nstore_prchar(c, pos)\n\tLWCHAR c;\n\tPOSITION pos;\n{\n\t/*\n\t * Convert to printable representation.\n\t */\n\tSTORE_STRING(prchar(c), AT_BINARY|AT_COLOR_CTRL, pos);\n\treturn 0;\n}\n\n\tstatic int\nflush_mbc_buf(pos)\n\tPOSITION pos;\n{\n\tint i;\n\n\tfor (i = 0; i < mbc_buf_index; i++)\n\t\tif (store_prchar(mbc_buf[i], pos))\n\t\t\treturn mbc_buf_index - i;\n\treturn 0;\n}\n\n/*\n * Append a character to the line buffer.\n * Expand tabs into spaces, handle underlining, boldfacing, etc.\n * Returns 0 if ok, 1 if couldn't fit in buffer.\n */\n\tpublic int\npappend(c, pos)\n\tint c;\n\tPOSITION pos;\n{\n\tint r;\n\n\tif (pendc)\n\t{\n\t\tif (c == '\\r' && pendc == '\\r')\n\t\t\treturn (0);\n\t\tif (do_append(pendc, NULL, pendpos))\n\t\t\t/*\n\t\t\t * Oops.  We've probably lost the char which\n\t\t\t * was in pendc, since caller won't back up.\n\t\t\t */\n\t\t\treturn (1);\n\t\tpendc = '\\0';\n\t}\n\n\tif (c == '\\r' && bs_mode == BS_SPECIAL)\n\t{\n\t\tif (mbc_buf_len > 0)  /* utf_mode must be on. */\n\t\t{\n\t\t\t/* Flush incomplete (truncated) sequence. */\n\t\t\tr = flush_mbc_buf(mbc_pos);\n\t\t\tmbc_buf_index = r + 1;\n\t\t\tmbc_buf_len = 0;\n\t\t\tif (r)\n\t\t\t\treturn (mbc_buf_index);\n\t\t}\n\n\t\t/*\n\t\t * Don't put the CR into the buffer until we see \n\t\t * the next char.  If the next char is a newline,\n\t\t * discard the CR.\n\t\t */\n\t\tpendc = c;\n\t\tpendpos = pos;\n\t\treturn (0);\n\t}\n\n\tif (!utf_mode)\n\t{\n\t\tr = do_append(c, NULL, pos);\n\t} else\n\t{\n\t\t/* Perform strict validation in all possible cases. */\n\t\tif (mbc_buf_len == 0)\n\t\t{\n\t\tretry:\n\t\t\tmbc_buf_index = 1;\n\t\t\t*mbc_buf = c;\n\t\t\tif (IS_ASCII_OCTET(c))\n\t\t\t\tr = do_append(c, NULL, pos);\n\t\t\telse if (IS_UTF8_LEAD(c))\n\t\t\t{\n\t\t\t\tmbc_buf_len = utf_len(c);\n\t\t\t\tmbc_pos = pos;\n\t\t\t\treturn (0);\n\t\t\t} else\n\t\t\t\t/* UTF8_INVALID or stray UTF8_TRAIL */\n\t\t\t\tr = flush_mbc_buf(pos);\n\t\t} else if (IS_UTF8_TRAIL(c))\n\t\t{\n\t\t\tmbc_buf[mbc_buf_index++] = c;\n\t\t\tif (mbc_buf_index < mbc_buf_len)\n\t\t\t\treturn (0);\n\t\t\tif (is_utf8_well_formed(mbc_buf, mbc_buf_index))\n\t\t\t\tr = do_append(get_wchar(mbc_buf), mbc_buf, mbc_pos);\n\t\t\telse\n\t\t\t\t/* Complete, but not shortest form, sequence. */\n\t\t\t\tmbc_buf_index = r = flush_mbc_buf(mbc_pos);\n\t\t\tmbc_buf_len = 0;\n\t\t} else\n\t\t{\n\t\t\t/* Flush incomplete (truncated) sequence.  */\n\t\t\tr = flush_mbc_buf(mbc_pos);\n\t\t\tmbc_buf_index = r + 1;\n\t\t\tmbc_buf_len = 0;\n\t\t\t/* Handle new char.  */\n\t\t\tif (!r)\n\t\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (r)\n\t{\n\t\t/* How many chars should caller back up? */\n\t\tr = (!utf_mode) ? 1 : mbc_buf_index;\n\t}\n\treturn (r);\n}\n\n\tstatic int\nstore_control_char(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tif (ctldisp == OPT_ON)\n\t{\n\t\t/* Output the character itself. */\n\t\tSTORE_CHAR(ch, AT_NORMAL, rep, pos);\n\t} else \n\t{\n\t\t/* Output a printable representation of the character. */\n\t\tSTORE_PRCHAR((char) ch, pos);\n\t}\n\treturn (0);\n}\n\n\tstatic int\nstore_ansi(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tswitch (ansi_step(line_ansi, ch))\n\t{\n\tcase ANSI_MID:\n\t\tSTORE_CHAR(ch, AT_ANSI, rep, pos);\n\t\tif (line_ansi->hlink)\n\t\t\thlink_in_line = 1;\n\t\txbuf_add_byte(&last_ansi, (unsigned char) ch);\n\t\tbreak;\n\tcase ANSI_END:\n\t\tSTORE_CHAR(ch, AT_ANSI, rep, pos);\n\t\tansi_done(line_ansi);\n\t\tline_ansi = NULL;\n\t\txbuf_add_byte(&last_ansi, (unsigned char) ch);\n\t\txbuf_set(&last_ansis[curr_last_ansi], &last_ansi);\n\t\txbuf_reset(&last_ansi);\n\t\tcurr_last_ansi = (curr_last_ansi + 1) % NUM_LAST_ANSIS;\n\t\tbreak;\n\tcase ANSI_ERR:\n\t\t{\n\t\t\t/* Remove whole unrecognized sequence.  */\n\t\t\tchar *start = (cshift < hshift) ? xbuf_char_data(&shifted_ansi): linebuf.buf;\n\t\t\tint *end = (cshift < hshift) ? &shifted_ansi.end : &linebuf.end;\n\t\t\tchar *p = start + *end;\n\t\t\tLWCHAR bch;\n\t\t\tdo {\n\t\t\t\tbch = step_char(&p, -1, start);\n\t\t\t} while (p > start && !IS_CSI_START(bch));\n\t\t\t*end = (int) (p - start);\n\t\t}\n\t\txbuf_reset(&last_ansi);\n\t\tansi_done(line_ansi);\n\t\tline_ansi = NULL;\n\t\tbreak;\n\t}\n\treturn (0);\n} \n\n\tstatic int\nstore_bs(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tif (bs_mode == BS_CONTROL)\n\t\treturn store_control_char(ch, rep, pos);\n\tif (linebuf.end > 0 &&\n\t\t((linebuf.end <= linebuf.print && linebuf.buf[linebuf.end-1] == '\\0') ||\n\t     (linebuf.end > 0 && linebuf.attr[linebuf.end - 1] & (AT_ANSI|AT_BINARY))))\n\t\tSTORE_PRCHAR('\\b', pos);\n\telse if (bs_mode == BS_NORMAL)\n\t\tSTORE_CHAR(ch, AT_NORMAL, NULL, pos);\n\telse if (bs_mode == BS_SPECIAL)\n\t\toverstrike = backc();\n\treturn 0;\n}\n\n\tstatic int\ndo_append(ch, rep, pos)\n\tLWCHAR ch;\n\tchar *rep;\n\tPOSITION pos;\n{\n\tint a = AT_NORMAL;\n\tint in_overstrike = overstrike;\n\n\tif (ctldisp == OPT_ONPLUS && line_ansi == NULL)\n\t{\n\t\tline_ansi = ansi_start(ch);\n\t\tif (line_ansi != NULL)\n\t\t\tansi_in_line = 1;\n\t}\n\n\toverstrike = 0;\n\tif (line_ansi != NULL)\n\t\treturn store_ansi(ch, rep, pos);\n\n\tif (ch == '\\b')\n\t\treturn store_bs(ch, rep, pos);\n\n\tif (in_overstrike > 0)\n\t{\n\t\t/*\n\t\t * Overstrike the character at the current position\n\t\t * in the line buffer.  This will cause either \n\t\t * underline (if a \"_\" is overstruck), \n\t\t * bold (if an identical character is overstruck),\n\t\t * or just replacing the character in the buffer.\n\t\t */\n\t\tLWCHAR prev_ch;\n\t\toverstrike = utf_mode ? -1 : 0;\n\t\tif (utf_mode)\n\t\t{\n\t\t\t/* To be correct, this must be a base character.  */\n\t\t\tprev_ch = get_wchar(&linebuf.buf[linebuf.end]);\n\t\t} else\n\t\t{\n\t\t\tprev_ch = (unsigned char) linebuf.buf[linebuf.end];\n\t\t}\n\t\ta = linebuf.attr[linebuf.end];\n\t\tif (ch == prev_ch)\n\t\t{\n\t\t\t/*\n\t\t\t * Overstriking a char with itself means make it bold.\n\t\t\t * But overstriking an underscore with itself is\n\t\t\t * ambiguous.  It could mean make it bold, or\n\t\t\t * it could mean make it underlined.\n\t\t\t * Use the previous overstrike to resolve it.\n\t\t\t */\n\t\t\tif (ch == '_')\n\t\t\t{\n\t\t\t\tif ((a & (AT_BOLD|AT_UNDERLINE)) != AT_NORMAL)\n\t\t\t\t\ta |= (AT_BOLD|AT_UNDERLINE);\n\t\t\t\telse if (last_overstrike != AT_NORMAL)\n\t\t\t\t\ta |= last_overstrike;\n\t\t\t\telse\n\t\t\t\t\ta |= AT_BOLD;\n\t\t\t} else\n\t\t\t\ta |= AT_BOLD;\n\t\t} else if (ch == '_')\n\t\t{\n\t\t\ta |= AT_UNDERLINE;\n\t\t\tch = prev_ch;\n\t\t\trep = &linebuf.buf[linebuf.end];\n\t\t} else if (prev_ch == '_')\n\t\t{\n\t\t\ta |= AT_UNDERLINE;\n\t\t}\n\t\t/* Else we replace prev_ch, but we keep its attributes.  */\n\t} else if (in_overstrike < 0)\n\t{\n\t\tif (   is_composing_char(ch)\n\t\t    || is_combining_char(get_wchar(&linebuf.buf[linebuf.end]), ch))\n\t\t\t/* Continuation of the same overstrike.  */\n\t\t\ta = last_overstrike;\n\t\telse\n\t\t\toverstrike = 0;\n\t}\n\n\tif (ch == '\\t')\n\t{\n\t\t/*\n\t\t * Expand a tab into spaces.\n\t\t */\n\t\tswitch (bs_mode)\n\t\t{\n\t\tcase BS_CONTROL:\n\t\t\treturn store_control_char(ch, rep, pos);\n\t\tcase BS_NORMAL:\n\t\tcase BS_SPECIAL:\n\t\t\tSTORE_TAB(a, pos);\n\t\t\tbreak;\n\t\t}\n\t\treturn (0);\n\t}\n\tif ((!utf_mode || is_ascii_char(ch)) && control_char((char)ch))\n\t{\n\t\treturn store_control_char(ch, rep, pos);\n\t} else if (utf_mode && ctldisp != OPT_ON && is_ubin_char(ch))\n\t{\n\t\tSTORE_STRING(prutfchar(ch), AT_BINARY, pos);\n\t} else\n\t{\n\t\tSTORE_CHAR(ch, a, rep, pos);\n\t}\n\treturn (0);\n}\n\n/*\n *\n */\n\tpublic int\npflushmbc(VOID_PARAM)\n{\n\tint r = 0;\n\n\tif (mbc_buf_len > 0)\n\t{\n\t\t/* Flush incomplete (truncated) sequence.  */\n\t\tr = flush_mbc_buf(mbc_pos);\n\t\tmbc_buf_len = 0;\n\t}\n\treturn r;\n}\n\n/*\n * Switch to normal attribute at end of line.\n */\n\tstatic void\nadd_attr_normal(VOID_PARAM)\n{\n\tif (ctldisp != OPT_ONPLUS || !is_ansi_end('m'))\n\t\treturn;\n\taddstr_linebuf(\"\\033[m\", AT_ANSI, 0);\n\tif (hlink_in_line) /* Don't send hyperlink clear if we know we don't need to. */\n\t\taddstr_linebuf(\"\\033]8;;\\033\\\\\", AT_ANSI, 0);\n}\n\n/*\n * Terminate the line in the line buffer.\n */\n\tpublic void\npdone(endline, chopped, forw)\n\tint endline;\n\tint chopped;\n\tint forw;\n{\n\t(void) pflushmbc();\n\n\tif (pendc && (pendc != '\\r' || !endline))\n\t\t/*\n\t\t * If we had a pending character, put it in the buffer.\n\t\t * But discard a pending CR if we are at end of line\n\t\t * (that is, discard the CR in a CR/LF sequence).\n\t\t */\n\t\t(void) do_append(pendc, NULL, pendpos);\n\n\tif (chopped && rscroll_char)\n\t{\n\t\t/*\n\t\t * Display the right scrolling char.\n\t\t * If we've already filled the rightmost screen char \n\t\t * (in the buffer), overwrite it.\n\t\t */\n\t\tif (end_column >= sc_width + cshift)\n\t\t{\n\t\t\t/* We've already written in the rightmost char. */\n\t\t\tend_column = right_column;\n\t\t\tlinebuf.end = right_curr;\n\t\t}\n\t\tadd_attr_normal();\n\t\twhile (end_column < sc_width-1 + cshift) \n\t\t{\n\t\t\t/*\n\t\t\t * Space to last (rightmost) char on screen.\n\t\t\t * This may be necessary if the char we overwrote\n\t\t\t * was double-width.\n\t\t\t */\n\t\t\tadd_linebuf(' ', rscroll_attr, 1);\n\t\t}\n\t\t/* Print rscroll char. It must be single-width. */\n\t\tadd_linebuf(rscroll_char, rscroll_attr, 1);\n\t} else\n\t{\n\t\tadd_attr_normal();\n\t}\n\n\t/*\n\t * If we're coloring a status line, fill out the line with spaces.\n\t */\n\tif (status_line && line_mark_attr != 0) {\n\t\twhile (end_column +1 < sc_width + cshift)\n\t\t\tadd_linebuf(' ', line_mark_attr, 1);\n\t}\n\n\t/*\n\t * Add a newline if necessary,\n\t * and append a '\\0' to the end of the line.\n\t * We output a newline if we're not at the right edge of the screen,\n\t * or if the terminal doesn't auto wrap,\n\t * or if this is really the end of the line AND the terminal ignores\n\t * a newline at the right edge.\n\t * (In the last case we don't want to output a newline if the terminal \n\t * doesn't ignore it since that would produce an extra blank line.\n\t * But we do want to output a newline if the terminal ignores it in case\n\t * the next line is blank.  In that case the single newline output for\n\t * that blank line would be ignored!)\n\t */\n\tif (end_column < sc_width + cshift || !auto_wrap || (endline && ignaw) || ctldisp == OPT_ON)\n\t{\n\t\tadd_linebuf('\\n', AT_NORMAL, 0);\n\t} \n\telse if (ignaw && end_column >= sc_width + cshift && forw)\n\t{\n\t\t/*\n\t\t * Terminals with \"ignaw\" don't wrap until they *really* need\n\t\t * to, i.e. when the character *after* the last one to fit on a\n\t\t * line is output. But they are too hard to deal with when they\n\t\t * get in the state where a full screen width of characters\n\t\t * have been output but the cursor is sitting on the right edge\n\t\t * instead of at the start of the next line.\n\t\t * So we nudge them into wrapping by outputting a space \n\t\t * character plus a backspace.  But do this only if moving \n\t\t * forward; if we're moving backward and drawing this line at\n\t\t * the top of the screen, the space would overwrite the first\n\t\t * char on the next line.  We don't need to do this \"nudge\" \n\t\t * at the top of the screen anyway.\n\t\t */\n\t\tadd_linebuf(' ', AT_NORMAL, 1);\n\t\tadd_linebuf('\\b', AT_NORMAL, -1);\n\t}\n\tset_linebuf(linebuf.end, '\\0', AT_NORMAL);\n}\n\n/*\n * Set an attribute on each char of the line in the line buffer.\n */\n\tpublic void\nset_attr_line(a)\n\tint a;\n{\n\tint i;\n\n\tfor (i = linebuf.print;  i < linebuf.end;  i++)\n\t\tlinebuf.attr[i] |= a;\n}\n\n/*\n * Set the char to be displayed in the status column.\n */\n\tpublic void\nset_status_col(c, attr)\n\tint c;\n\tint attr;\n{\n\tset_pfx(0, c, attr);\n}\n\n/*\n * Get a character from the current line.\n * Return the character as the function return value,\n * and the character attribute in *ap.\n */\n\tpublic int\ngline(i, ap)\n\tint i;\n\tint *ap;\n{\n\tif (is_null_line)\n\t{\n\t\t/*\n\t\t * If there is no current line, we pretend the line is\n\t\t * either \"~\" or \"\", depending on the \"twiddle\" flag.\n\t\t */\n\t\tif (twiddle)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\t*ap = AT_BOLD;\n\t\t\t\treturn '~';\n\t\t\t}\n\t\t\t--i;\n\t\t}\n\t\t/* Make sure we're back to AT_NORMAL before the '\\n'.  */\n\t\t*ap = AT_NORMAL;\n\t\treturn i ? '\\0' : '\\n';\n\t}\n\n\tif (i < linebuf.pfx_end)\n\t{\n\t\t*ap = linebuf.pfx_attr[i];\n\t\treturn linebuf.pfx[i];\n\t}\n\ti += linebuf.print - linebuf.pfx_end;\n\t*ap = linebuf.attr[i];\n\treturn (linebuf.buf[i] & 0xFF);\n}\n\n/*\n * Indicate that there is no current line.\n */\n\tpublic void\nnull_line(VOID_PARAM)\n{\n\tis_null_line = 1;\n\tcshift = 0;\n}\n\n/*\n * Analogous to forw_line(), but deals with \"raw lines\":\n * lines which are not split for screen width.\n * {{ This is supposed to be more efficient than forw_line(). }}\n */\n\tpublic POSITION\nforw_raw_line(curr_pos, linep, line_lenp)\n\tPOSITION curr_pos;\n\tchar **linep;\n\tint *line_lenp;\n{\n\tint n;\n\tint c;\n\tPOSITION new_pos;\n\n\tif (curr_pos == NULL_POSITION || ch_seek(curr_pos) ||\n\t\t(c = ch_forw_get()) == EOI)\n\t\treturn (NULL_POSITION);\n\n\tn = 0;\n\tfor (;;)\n\t{\n\t\tif (c == '\\n' || c == EOI || ABORT_SIGS())\n\t\t{\n\t\t\tnew_pos = ch_tell();\n\t\t\tbreak;\n\t\t}\n\t\tif (n >= size_linebuf-1)\n\t\t{\n\t\t\tif (expand_linebuf())\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Overflowed the input buffer.\n\t\t\t\t * Pretend the line ended here.\n\t\t\t\t */\n\t\t\t\tnew_pos = ch_tell() - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlinebuf.buf[n++] = c;\n\t\tc = ch_forw_get();\n\t}\n\tlinebuf.buf[n] = '\\0';\n\tif (linep != NULL)\n\t\t*linep = linebuf.buf;\n\tif (line_lenp != NULL)\n\t\t*line_lenp = n;\n\treturn (new_pos);\n}\n\n/*\n * Analogous to back_line(), but deals with \"raw lines\".\n * {{ This is supposed to be more efficient than back_line(). }}\n */\n\tpublic POSITION\nback_raw_line(curr_pos, linep, line_lenp)\n\tPOSITION curr_pos;\n\tchar **linep;\n\tint *line_lenp;\n{\n\tint n;\n\tint c;\n\tPOSITION new_pos;\n\n\tif (curr_pos == NULL_POSITION || curr_pos <= ch_zero() ||\n\t\tch_seek(curr_pos-1))\n\t\treturn (NULL_POSITION);\n\n\tn = size_linebuf;\n\tlinebuf.buf[--n] = '\\0';\n\tfor (;;)\n\t{\n\t\tc = ch_back_get();\n\t\tif (c == '\\n' || ABORT_SIGS())\n\t\t{\n\t\t\t/*\n\t\t\t * This is the newline ending the previous line.\n\t\t\t * We have hit the beginning of the line.\n\t\t\t */\n\t\t\tnew_pos = ch_tell() + 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (c == EOI)\n\t\t{\n\t\t\t/*\n\t\t\t * We have hit the beginning of the file.\n\t\t\t * This must be the first line in the file.\n\t\t\t * This must, of course, be the beginning of the line.\n\t\t\t */\n\t\t\tnew_pos = ch_zero();\n\t\t\tbreak;\n\t\t}\n\t\tif (n <= 0)\n\t\t{\n\t\t\tint old_size_linebuf = size_linebuf;\n\t\t\tchar *fm;\n\t\t\tchar *to;\n\t\t\tif (expand_linebuf())\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Overflowed the input buffer.\n\t\t\t\t * Pretend the line ended here.\n\t\t\t\t */\n\t\t\t\tnew_pos = ch_tell() + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Shift the data to the end of the new linebuf.\n\t\t\t */\n\t\t\tfor (fm = linebuf.buf + old_size_linebuf - 1,\n\t\t\t      to = linebuf.buf + size_linebuf - 1;\n\t\t\t     fm >= linebuf.buf;  fm--, to--)\n\t\t\t\t*to = *fm;\n\t\t\tn = size_linebuf - old_size_linebuf;\n\t\t}\n\t\tlinebuf.buf[--n] = c;\n\t}\n\tif (linep != NULL)\n\t\t*linep = &linebuf.buf[n];\n\tif (line_lenp != NULL)\n\t\t*line_lenp = size_linebuf - 1 - n;\n\treturn (new_pos);\n}\n\n/*\n * Append a string to the line buffer.\n */\n\tstatic int\npappstr(str)\n\tconstant char *str;\n{\n\twhile (*str != '\\0')\n\t{\n\t\tif (pappend(*str++, NULL_POSITION))\n\t\t\t/* Doesn't fit on screen. */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Load a string into the line buffer.\n * If the string is too long to fit on the screen,\n * truncate the beginning of the string to fit.\n */\n\tpublic void\nload_line(str)\n\tconstant char *str;\n{\n\tint save_hshift = hshift;\n\n\thshift = 0;\n\tfor (;;)\n\t{\n\t\tprewind();\n\t\tif (pappstr(str) == 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * Didn't fit on screen; increase left shift by one.\n\t\t * {{ This gets very inefficient if the string\n\t\t * is much longer than the screen width. }}\n\t\t */\n\t\thshift += 1;\n\t}\n\tset_linebuf(linebuf.end, '\\0', AT_NORMAL);\n\thshift = save_hshift;\n}\n\n/*\n * Find the shift necessary to show the end of the longest displayed line.\n */\n\tpublic int\nrrshift(VOID_PARAM)\n{\n\tPOSITION pos;\n\tint save_width;\n\tint line;\n\tint longest = 0;\n\n\tsave_width = sc_width;\n\tsc_width = INT_MAX;\n\tpos = position(TOP);\n\tfor (line = 0; line < sc_height && pos != NULL_POSITION; line++)\n\t{\n\t\tpos = forw_line(pos);\n\t\tif (end_column > longest)\n\t\t\tlongest = end_column;\n\t}\n\tsc_width = save_width;\n\tif (longest < sc_width)\n\t\treturn 0;\n\treturn longest - sc_width;\n}\n\n/*\n * Get the color_map index associated with a given attribute.\n */\n\tstatic int\ncolor_index(attr)\n\tint attr;\n{\n\tif (use_color)\n\t{\n\t\tswitch (attr & AT_COLOR)\n\t\t{\n\t\tcase AT_COLOR_ATTN:    return 0;\n\t\tcase AT_COLOR_BIN:     return 1;\n\t\tcase AT_COLOR_CTRL:    return 2;\n\t\tcase AT_COLOR_ERROR:   return 3;\n\t\tcase AT_COLOR_LINENUM: return 4;\n\t\tcase AT_COLOR_MARK:    return 5;\n\t\tcase AT_COLOR_PROMPT:  return 6;\n\t\tcase AT_COLOR_RSCROLL: return 7;\n\t\tcase AT_COLOR_SEARCH:  return 8;\n\t\tcase AT_COLOR_HEADER:  return 9;\n\t\t}\n\t}\n\tif (attr & AT_UNDERLINE)\n\t\treturn 10;\n\tif (attr & AT_BOLD)\n\t\treturn 11;\n\tif (attr & AT_BLINK)\n\t\treturn 12;\n\tif (attr & AT_STANDOUT)\n\t\treturn 13;\n\treturn -1;\n}\n\n/*\n * Set the color string to use for a given attribute.\n */\n\tpublic int\nset_color_map(attr, colorstr)\n\tint attr;\n\tchar *colorstr;\n{\n\tint cx = color_index(attr);\n\tif (cx < 0)\n\t\treturn -1;\n\tif (strlen(colorstr)+1 > sizeof(color_map[cx]))\n\t\treturn -1;\n\tif (*colorstr != '\\0' && parse_color(colorstr, NULL, NULL) == CT_NULL)\n\t\treturn -1;\n\tstrcpy(color_map[cx], colorstr);\n\treturn 0;\n}\n\n/*\n * Get the color string to use for a given attribute.\n */\n\tpublic char *\nget_color_map(attr)\n\tint attr;\n{\n\tint cx = color_index(attr);\n\tif (cx < 0)\n\t\treturn NULL;\n\treturn color_map[cx];\n}\n"], "filenames": ["line.c"], "buggy_code_start_loc": [636], "buggy_code_end_loc": [638], "fixing_code_start_loc": [636], "fixing_code_end_loc": [638], "type": "NVD-CWE-Other", "message": "In GNU Less before 609, crafted data can result in \"less -R\" not filtering ANSI escape sequences sent to the terminal.", "other": {"cve": {"id": "CVE-2022-46663", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-07T21:15:09.247", "lastModified": "2023-06-10T03:15:09.107", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In GNU Less before 609, crafted data can result in \"less -R\" not filtering ANSI escape sequences sent to the terminal."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:less:*:*:*:*:*:*:*:*", "versionStartIncluding": "566", "versionEndExcluding": "609", "matchCriteriaId": "0A485C64-CC65-4504-8813-9AC601E41820"}]}]}], "references": [{"url": "http://www.greenwoodsoftware.com/less/news.609.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://www.openwall.com/lists/oss-security/2023/02/07/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/gwsw/less/commit/a78e1351113cef564d790a730d657a321624d79c", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LR7AUWB34JD4PCW3HHASBEDGGHFWPAQP/", "source": "cve@mitre.org"}, {"url": "https://www.openwall.com/lists/oss-security/2023/02/07/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gwsw/less/commit/a78e1351113cef564d790a730d657a321624d79c"}}