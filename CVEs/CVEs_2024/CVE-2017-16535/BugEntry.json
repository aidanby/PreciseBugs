{"buggy_code": ["/*\n * Released under the GPLv2 only.\n * SPDX-License-Identifier: GPL-2.0\n */\n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/quirks.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <asm/byteorder.h>\n#include \"usb.h\"\n\n\n#define USB_MAXALTSETTING\t\t128\t/* Hard limit */\n\n#define USB_MAXCONFIG\t\t\t8\t/* Arbitrary limit */\n\n\nstatic inline const char *plural(int n)\n{\n\treturn (n == 1 ? \"\" : \"s\");\n}\n\nstatic int find_next_descriptor(unsigned char *buffer, int size,\n    int dt1, int dt2, int *num_skipped)\n{\n\tstruct usb_descriptor_header *h;\n\tint n = 0;\n\tunsigned char *buffer0 = buffer;\n\n\t/* Find the next descriptor of type dt1 or dt2 */\n\twhile (size > 0) {\n\t\th = (struct usb_descriptor_header *) buffer;\n\t\tif (h->bDescriptorType == dt1 || h->bDescriptorType == dt2)\n\t\t\tbreak;\n\t\tbuffer += h->bLength;\n\t\tsize -= h->bLength;\n\t\t++n;\n\t}\n\n\t/* Store the number of descriptors skipped and return the\n\t * number of bytes skipped */\n\tif (num_skipped)\n\t\t*num_skipped = n;\n\treturn buffer - buffer0;\n}\n\nstatic void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,\n\t\tint cfgno, int inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ssp_isoc_ep_comp_descriptor *desc;\n\n\t/*\n\t * The SuperSpeedPlus Isoc endpoint companion descriptor immediately\n\t * follows the SuperSpeed Endpoint Companion descriptor\n\t */\n\tdesc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;\n\tif (desc->bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||\n\t    size < USB_DT_SSP_ISOC_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"Invalid SuperSpeedPlus isoc endpoint companion\"\n\t\t\t \"for config %d interface %d altsetting %d ep %d.\\n\",\n\t\t\t cfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\treturn;\n\t}\n\tmemcpy(&ep->ssp_isoc_ep_comp, desc, USB_DT_SSP_ISOC_EP_COMP_SIZE);\n}\n\nstatic void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,\n\t\tint inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ss_ep_comp_descriptor *desc;\n\tint max_tx;\n\n\t/* The SuperSpeed endpoint companion descriptor is supposed to\n\t * be the first thing immediately following the endpoint descriptor.\n\t */\n\tdesc = (struct usb_ss_ep_comp_descriptor *) buffer;\n\n\tif (desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||\n\t\t\tsize < USB_DT_SS_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"No SuperSpeed endpoint companion for config %d \"\n\t\t\t\t\" interface %d altsetting %d ep %d: \"\n\t\t\t\t\"using minimum values\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\n\t\t/* Fill in some default values.\n\t\t * Leave bmAttributes as zero, which will mean no streams for\n\t\t * bulk, and isoc won't support multiple bursts of packets.\n\t\t * With bursts of only one packet, and a Mult of 1, the max\n\t\t * amount of data moved per endpoint service interval is one\n\t\t * packet.\n\t\t */\n\t\tep->ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;\n\t\tep->ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;\n\t\tif (usb_endpoint_xfer_isoc(&ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(&ep->desc))\n\t\t\tep->ss_ep_comp.wBytesPerInterval =\n\t\t\t\t\tep->desc.wMaxPacketSize;\n\t\treturn;\n\t}\n\tbuffer += desc->bLength;\n\tsize -= desc->bLength;\n\tmemcpy(&ep->ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);\n\n\t/* Check the various values */\n\tif (usb_endpoint_xfer_control(&ep->desc) && desc->bMaxBurst != 0) {\n\t\tdev_warn(ddev, \"Control endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 0;\n\t} else if (desc->bMaxBurst > 15) {\n\t\tdev_warn(ddev, \"Endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 15\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 15;\n\t}\n\n\tif ((usb_endpoint_xfer_control(&ep->desc) ||\n\t\t\tusb_endpoint_xfer_int(&ep->desc)) &&\n\t\t\t\tdesc->bmAttributes != 0) {\n\t\tdev_warn(ddev, \"%s endpoint with bmAttributes = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\",\n\t\t\t\tusb_endpoint_xfer_control(&ep->desc) ? \"Control\" : \"Bulk\",\n\t\t\t\tdesc->bmAttributes,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 0;\n\t} else if (usb_endpoint_xfer_bulk(&ep->desc) &&\n\t\t\tdesc->bmAttributes > 16) {\n\t\tdev_warn(ddev, \"Bulk endpoint with more than 65536 streams in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to max\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 16;\n\t} else if (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t\t   !USB_SS_SSP_ISOC_COMP(desc->bmAttributes) &&\n\t\t   USB_SS_MULT(desc->bmAttributes) > 3) {\n\t\tdev_warn(ddev, \"Isoc endpoint has Mult of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 3\\n\",\n\t\t\t\tUSB_SS_MULT(desc->bmAttributes),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 2;\n\t}\n\n\tif (usb_endpoint_xfer_isoc(&ep->desc))\n\t\tmax_tx = (desc->bMaxBurst + 1) *\n\t\t\t(USB_SS_MULT(desc->bmAttributes)) *\n\t\t\tusb_endpoint_maxp(&ep->desc);\n\telse if (usb_endpoint_xfer_int(&ep->desc))\n\t\tmax_tx = usb_endpoint_maxp(&ep->desc) *\n\t\t\t(desc->bMaxBurst + 1);\n\telse\n\t\tmax_tx = 999999;\n\tif (le16_to_cpu(desc->wBytesPerInterval) > max_tx) {\n\t\tdev_warn(ddev, \"%s endpoint with wBytesPerInterval of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to %d\\n\",\n\t\t\t\tusb_endpoint_xfer_isoc(&ep->desc) ? \"Isoc\" : \"Int\",\n\t\t\t\tle16_to_cpu(desc->wBytesPerInterval),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress,\n\t\t\t\tmax_tx);\n\t\tep->ss_ep_comp.wBytesPerInterval = cpu_to_le16(max_tx);\n\t}\n\t/* Parse a possible SuperSpeedPlus isoc ep companion descriptor */\n\tif (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t    USB_SS_SSP_ISOC_COMP(desc->bmAttributes))\n\t\tusb_parse_ssp_isoc_endpoint_companion(ddev, cfgno, inum, asnum,\n\t\t\t\t\t\t\tep, buffer, size);\n}\n\nstatic const unsigned short low_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 8,\n\t[USB_ENDPOINT_XFER_ISOC] = 0,\n\t[USB_ENDPOINT_XFER_BULK] = 0,\n\t[USB_ENDPOINT_XFER_INT] = 8,\n};\nstatic const unsigned short full_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1023,\n\t[USB_ENDPOINT_XFER_BULK] = 64,\n\t[USB_ENDPOINT_XFER_INT] = 64,\n};\nstatic const unsigned short high_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 512,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\nstatic const unsigned short super_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 512,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 1024,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\n\nstatic int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,\n    int asnum, struct usb_host_interface *ifp, int num_ep,\n    unsigned char *buffer, int size)\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_endpoint_descriptor *d;\n\tstruct usb_host_endpoint *endpoint;\n\tint n, i, j, retval;\n\tunsigned int maxp;\n\tconst unsigned short *maxpacket_maxes;\n\n\td = (struct usb_endpoint_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\tn = USB_DT_ENDPOINT_AUDIO_SIZE;\n\telse if (d->bLength >= USB_DT_ENDPOINT_SIZE)\n\t\tn = USB_DT_ENDPOINT_SIZE;\n\telse {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint descriptor of length %d, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bLength);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\ti = d->bEndpointAddress & ~USB_ENDPOINT_DIR_MASK;\n\tif (i >= 16 || i == 0) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint with address 0x%X, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\t/* Only store as many endpoints as we have room for */\n\tif (ifp->desc.bNumEndpoints >= num_ep)\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\n\t/* Check for duplicate endpoint addresses */\n\tfor (i = 0; i < ifp->desc.bNumEndpoints; ++i) {\n\t\tif (ifp->endpoint[i].desc.bEndpointAddress ==\n\t\t    d->bEndpointAddress) {\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\\n\",\n\t\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t\t}\n\t}\n\n\tendpoint = &ifp->endpoint[ifp->desc.bNumEndpoints];\n\t++ifp->desc.bNumEndpoints;\n\n\tmemcpy(&endpoint->desc, d, n);\n\tINIT_LIST_HEAD(&endpoint->urb_list);\n\n\t/*\n\t * Fix up bInterval values outside the legal range.\n\t * Use 10 or 8 ms if no proper value can be guessed.\n\t */\n\ti = 0;\t\t/* i = min, j = max, n = default */\n\tj = 255;\n\tif (usb_endpoint_xfer_int(d)) {\n\t\ti = 1;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\t/*\n\t\t\t * Many device manufacturers are using full-speed\n\t\t\t * bInterval values in high-speed interrupt endpoint\n\t\t\t * descriptors. Try to fix those and fall back to an\n\t\t\t * 8-ms default value otherwise.\n\t\t\t */\n\t\t\tn = fls(d->bInterval*8);\n\t\t\tif (n == 0)\n\t\t\t\tn = 7;\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tj = 16;\n\n\t\t\t/*\n\t\t\t * Adjust bInterval for quirked devices.\n\t\t\t */\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in ms.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval) + 3, i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in\n\t\t\t * linear microframes.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval), i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL or _LOW */\n\t\t\t/*\n\t\t\t * For low-speed, 10 ms is the official minimum.\n\t\t\t * But some \"overclocked\" devices might want faster\n\t\t\t * polling so we'll allow it.\n\t\t\t */\n\t\t\tn = 10;\n\t\t\tbreak;\n\t\t}\n\t} else if (usb_endpoint_xfer_isoc(d)) {\n\t\ti = 1;\n\t\tj = 16;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_HIGH:\n\t\t\tn = 7;\t\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL */\n\t\t\tn = 4;\t\t/* 8 ms = 2^(4-1) frames */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (d->bInterval < i || d->bInterval > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X has an invalid bInterval %d, \"\n\t\t    \"changing to %d\\n\",\n\t\t    cfgno, inum, asnum,\n\t\t    d->bEndpointAddress, d->bInterval, n);\n\t\tendpoint->desc.bInterval = n;\n\t}\n\n\t/* Some buggy low-speed devices have Bulk endpoints, which is\n\t * explicitly forbidden by the USB spec.  In an attempt to make\n\t * them usable, we will try treating them as Interrupt endpoints.\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_LOW &&\n\t\t\tusb_endpoint_xfer_bulk(d)) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X is Bulk; changing to Interrupt\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tendpoint->desc.bmAttributes = USB_ENDPOINT_XFER_INT;\n\t\tendpoint->desc.bInterval = 1;\n\t\tif (usb_endpoint_maxp(&endpoint->desc) > 8)\n\t\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(8);\n\t}\n\n\t/* Validate the wMaxPacketSize field */\n\tmaxp = usb_endpoint_maxp(&endpoint->desc);\n\n\t/* Find the highest legal maxpacket size for this endpoint */\n\ti = 0;\t\t/* additional transactions per microframe */\n\tswitch (to_usb_device(ddev)->speed) {\n\tcase USB_SPEED_LOW:\n\t\tmaxpacket_maxes = low_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tmaxpacket_maxes = full_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\t/* Bits 12..11 are allowed only for HS periodic endpoints */\n\t\tif (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {\n\t\t\ti = maxp & (BIT(12) | BIT(11));\n\t\t\tmaxp &= ~i;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tmaxpacket_maxes = high_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tmaxpacket_maxes = super_speed_maxpacket_maxes;\n\t\tbreak;\n\t}\n\tj = maxpacket_maxes[usb_endpoint_type(&endpoint->desc)];\n\n\tif (maxp > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress, maxp, j);\n\t\tmaxp = j;\n\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(i | maxp);\n\t}\n\n\t/*\n\t * Some buggy high speed devices have bulk endpoints using\n\t * maxpacket sizes other than 512.  High speed HCDs may not\n\t * be able to handle that particular bug, so let's warn...\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_HIGH\n\t\t\t&& usb_endpoint_xfer_bulk(d)) {\n\t\tif (maxp != 512)\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t\t\t\"bulk endpoint 0x%X has invalid maxpacket %d\\n\",\n\t\t\t\tcfgno, inum, asnum, d->bEndpointAddress,\n\t\t\t\tmaxp);\n\t}\n\n\t/* Parse a possible SuperSpeed endpoint companion descriptor */\n\tif (to_usb_device(ddev)->speed >= USB_SPEED_SUPER)\n\t\tusb_parse_ss_endpoint_companion(ddev, cfgno,\n\t\t\t\tinum, asnum, endpoint, buffer, size);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the next endpoint or interface descriptor */\n\tendpoint->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t\t\tUSB_DT_INTERFACE, &n);\n\tendpoint->extralen = i;\n\tretval = buffer - buffer0 + i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"endpoint\");\n\treturn retval;\n\nskip_to_next_endpoint_or_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nvoid usb_release_interface_cache(struct kref *ref)\n{\n\tstruct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);\n\tint j;\n\n\tfor (j = 0; j < intfc->num_altsetting; j++) {\n\t\tstruct usb_host_interface *alt = &intfc->altsetting[j];\n\n\t\tkfree(alt->endpoint);\n\t\tkfree(alt->string);\n\t}\n\tkfree(intfc);\n}\n\nstatic int usb_parse_interface(struct device *ddev, int cfgno,\n    struct usb_host_config *config, unsigned char *buffer, int size,\n    u8 inums[], u8 nalts[])\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_interface_descriptor\t*d;\n\tint inum, asnum;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint i, n;\n\tint len, retval;\n\tint num_ep, num_ep_orig;\n\n\td = (struct usb_interface_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength < USB_DT_INTERFACE_SIZE)\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Which interface entry is this? */\n\tintfc = NULL;\n\tinum = d->bInterfaceNumber;\n\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\tif (inums[i] == inum) {\n\t\t\tintfc = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intfc || intfc->num_altsetting >= nalts[i])\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Check for duplicate altsetting entries */\n\tasnum = d->bAlternateSetting;\n\tfor ((i = 0, alt = &intfc->altsetting[0]);\n\t      i < intfc->num_altsetting;\n\t     (++i, ++alt)) {\n\t\tif (alt->desc.bAlternateSetting == asnum) {\n\t\t\tdev_warn(ddev, \"Duplicate descriptor for config %d \"\n\t\t\t    \"interface %d altsetting %d, skipping\\n\",\n\t\t\t    cfgno, inum, asnum);\n\t\t\tgoto skip_to_next_interface_descriptor;\n\t\t}\n\t}\n\n\t++intfc->num_altsetting;\n\tmemcpy(&alt->desc, d, USB_DT_INTERFACE_SIZE);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first endpoint or interface descriptor */\n\talt->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, &n);\n\talt->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"interface\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Allocate space for the right(?) number of endpoints */\n\tnum_ep = num_ep_orig = alt->desc.bNumEndpoints;\n\talt->desc.bNumEndpoints = 0;\t\t/* Use as a counter */\n\tif (num_ep > USB_MAXENDPOINTS) {\n\t\tdev_warn(ddev, \"too many endpoints for config %d interface %d \"\n\t\t    \"altsetting %d: %d, using maximum allowed: %d\\n\",\n\t\t    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);\n\t\tnum_ep = USB_MAXENDPOINTS;\n\t}\n\n\tif (num_ep > 0) {\n\t\t/* Can't allocate 0 bytes */\n\t\tlen = sizeof(struct usb_host_endpoint) * num_ep;\n\t\talt->endpoint = kzalloc(len, GFP_KERNEL);\n\t\tif (!alt->endpoint)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Parse all the endpoint descriptors */\n\tn = 0;\n\twhile (size > 0) {\n\t\tif (((struct usb_descriptor_header *) buffer)->bDescriptorType\n\t\t     == USB_DT_INTERFACE)\n\t\t\tbreak;\n\t\tretval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt,\n\t\t    num_ep, buffer, size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\t++n;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\tif (n != num_ep_orig)\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has %d \"\n\t\t    \"endpoint descriptor%s, different from the interface \"\n\t\t    \"descriptor's value: %d\\n\",\n\t\t    cfgno, inum, asnum, n, plural(n), num_ep_orig);\n\treturn buffer - buffer0;\n\nskip_to_next_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nstatic int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t/* Go through the descriptors, checking their length and counting the\n\t * number of altsettings for each interface */\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t/* Have we already encountered this interface?\n\t\t\t * Count its altsettings */\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tstruct usb_interface_assoc_descriptor *d;\n\n\t\t\td = (struct usb_interface_assoc_descriptor *)header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\n\t\t\t\tdev_warn(ddev,\n\t\t\t\t\t \"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\n\t\t\t\t\t cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] = d;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t/* for ((buffer2 = buffer, size2 = size); ...) */\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t/* Check for missing interface numbers */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t/* Allocate the usb_interface_caches and altsetting arrays */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t/* FIXME: parse the BOS descriptor */\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first interface descriptor */\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Parse all the interface/altsetting descriptors */\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t/* Check for missing altsettings */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* hub-only!! ... and only exported for reset/reinit path.\n * otherwise used internally on disconnect/destroy path\n */\nvoid usb_destroy_configuration(struct usb_device *dev)\n{\n\tint c, i;\n\n\tif (!dev->config)\n\t\treturn;\n\n\tif (dev->rawdescriptors) {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++)\n\t\t\tkfree(dev->rawdescriptors[i]);\n\n\t\tkfree(dev->rawdescriptors);\n\t\tdev->rawdescriptors = NULL;\n\t}\n\n\tfor (c = 0; c < dev->descriptor.bNumConfigurations; c++) {\n\t\tstruct usb_host_config *cf = &dev->config[c];\n\n\t\tkfree(cf->string);\n\t\tfor (i = 0; i < cf->desc.bNumInterfaces; i++) {\n\t\t\tif (cf->intf_cache[i])\n\t\t\t\tkref_put(&cf->intf_cache[i]->ref,\n\t\t\t\t\t  usb_release_interface_cache);\n\t\t}\n\t}\n\tkfree(dev->config);\n\tdev->config = NULL;\n}\n\n\n/*\n * Get the USB config descriptors, cache and parse'em\n *\n * hub-only!! ... and only in reset path, or usb_new_device()\n * (used by real hubs and virtual root hubs)\n */\nint usb_get_configuration(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tint ncfg = dev->descriptor.bNumConfigurations;\n\tint result = 0;\n\tunsigned int cfgno, length;\n\tunsigned char *bigbuffer;\n\tstruct usb_config_descriptor *desc;\n\n\tcfgno = 0;\n\tresult = -ENOMEM;\n\tif (ncfg > USB_MAXCONFIG) {\n\t\tdev_warn(ddev, \"too many configurations: %d, \"\n\t\t    \"using maximum allowed: %d\\n\", ncfg, USB_MAXCONFIG);\n\t\tdev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;\n\t}\n\n\tif (ncfg < 1) {\n\t\tdev_err(ddev, \"no configurations\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength = ncfg * sizeof(struct usb_host_config);\n\tdev->config = kzalloc(length, GFP_KERNEL);\n\tif (!dev->config)\n\t\tgoto err2;\n\n\tlength = ncfg * sizeof(char *);\n\tdev->rawdescriptors = kzalloc(length, GFP_KERNEL);\n\tif (!dev->rawdescriptors)\n\t\tgoto err2;\n\n\tdesc = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto err2;\n\n\tresult = 0;\n\tfor (; cfgno < ncfg; cfgno++) {\n\t\t/* We grab just the first descriptor so we know how long\n\t\t * the whole configuration is */\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    desc, USB_DT_CONFIG_SIZE);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s: %d\\n\", cfgno, \"start\", result);\n\t\t\tif (result != -EPIPE)\n\t\t\t\tgoto err;\n\t\t\tdev_err(ddev, \"chopping to %d config(s)\\n\", cfgno);\n\t\t\tdev->descriptor.bNumConfigurations = cfgno;\n\t\t\tbreak;\n\t\t} else if (result < 4) {\n\t\t\tdev_err(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno,\n\t\t\t    USB_DT_CONFIG_SIZE, result);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tlength = max((int) le16_to_cpu(desc->wTotalLength),\n\t\t    USB_DT_CONFIG_SIZE);\n\n\t\t/* Now that we know the length, get the whole thing */\n\t\tbigbuffer = kmalloc(length, GFP_KERNEL);\n\t\tif (!bigbuffer) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(200);\n\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s\\n\", cfgno, \"all\");\n\t\t\tkfree(bigbuffer);\n\t\t\tgoto err;\n\t\t}\n\t\tif (result < length) {\n\t\t\tdev_warn(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno, length, result);\n\t\t\tlength = result;\n\t\t}\n\n\t\tdev->rawdescriptors[cfgno] = bigbuffer;\n\n\t\tresult = usb_parse_configuration(dev, cfgno,\n\t\t    &dev->config[cfgno], bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\t++cfgno;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tresult = 0;\n\nerr:\n\tkfree(desc);\n\tdev->descriptor.bNumConfigurations = cfgno;\nerr2:\n\tif (result == -ENOMEM)\n\t\tdev_err(ddev, \"out of memory\\n\");\n\treturn result;\n}\n\nvoid usb_release_bos_descriptor(struct usb_device *dev)\n{\n\tif (dev->bos) {\n\t\tkfree(dev->bos->desc);\n\t\tkfree(dev->bos);\n\t\tdev->bos = NULL;\n\t}\n}\n\n/* Get BOS descriptor set */\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n"], "fixing_code": ["/*\n * Released under the GPLv2 only.\n * SPDX-License-Identifier: GPL-2.0\n */\n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/quirks.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <asm/byteorder.h>\n#include \"usb.h\"\n\n\n#define USB_MAXALTSETTING\t\t128\t/* Hard limit */\n\n#define USB_MAXCONFIG\t\t\t8\t/* Arbitrary limit */\n\n\nstatic inline const char *plural(int n)\n{\n\treturn (n == 1 ? \"\" : \"s\");\n}\n\nstatic int find_next_descriptor(unsigned char *buffer, int size,\n    int dt1, int dt2, int *num_skipped)\n{\n\tstruct usb_descriptor_header *h;\n\tint n = 0;\n\tunsigned char *buffer0 = buffer;\n\n\t/* Find the next descriptor of type dt1 or dt2 */\n\twhile (size > 0) {\n\t\th = (struct usb_descriptor_header *) buffer;\n\t\tif (h->bDescriptorType == dt1 || h->bDescriptorType == dt2)\n\t\t\tbreak;\n\t\tbuffer += h->bLength;\n\t\tsize -= h->bLength;\n\t\t++n;\n\t}\n\n\t/* Store the number of descriptors skipped and return the\n\t * number of bytes skipped */\n\tif (num_skipped)\n\t\t*num_skipped = n;\n\treturn buffer - buffer0;\n}\n\nstatic void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,\n\t\tint cfgno, int inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ssp_isoc_ep_comp_descriptor *desc;\n\n\t/*\n\t * The SuperSpeedPlus Isoc endpoint companion descriptor immediately\n\t * follows the SuperSpeed Endpoint Companion descriptor\n\t */\n\tdesc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;\n\tif (desc->bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||\n\t    size < USB_DT_SSP_ISOC_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"Invalid SuperSpeedPlus isoc endpoint companion\"\n\t\t\t \"for config %d interface %d altsetting %d ep %d.\\n\",\n\t\t\t cfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\treturn;\n\t}\n\tmemcpy(&ep->ssp_isoc_ep_comp, desc, USB_DT_SSP_ISOC_EP_COMP_SIZE);\n}\n\nstatic void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,\n\t\tint inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ss_ep_comp_descriptor *desc;\n\tint max_tx;\n\n\t/* The SuperSpeed endpoint companion descriptor is supposed to\n\t * be the first thing immediately following the endpoint descriptor.\n\t */\n\tdesc = (struct usb_ss_ep_comp_descriptor *) buffer;\n\n\tif (desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||\n\t\t\tsize < USB_DT_SS_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"No SuperSpeed endpoint companion for config %d \"\n\t\t\t\t\" interface %d altsetting %d ep %d: \"\n\t\t\t\t\"using minimum values\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\n\t\t/* Fill in some default values.\n\t\t * Leave bmAttributes as zero, which will mean no streams for\n\t\t * bulk, and isoc won't support multiple bursts of packets.\n\t\t * With bursts of only one packet, and a Mult of 1, the max\n\t\t * amount of data moved per endpoint service interval is one\n\t\t * packet.\n\t\t */\n\t\tep->ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;\n\t\tep->ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;\n\t\tif (usb_endpoint_xfer_isoc(&ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(&ep->desc))\n\t\t\tep->ss_ep_comp.wBytesPerInterval =\n\t\t\t\t\tep->desc.wMaxPacketSize;\n\t\treturn;\n\t}\n\tbuffer += desc->bLength;\n\tsize -= desc->bLength;\n\tmemcpy(&ep->ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);\n\n\t/* Check the various values */\n\tif (usb_endpoint_xfer_control(&ep->desc) && desc->bMaxBurst != 0) {\n\t\tdev_warn(ddev, \"Control endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 0;\n\t} else if (desc->bMaxBurst > 15) {\n\t\tdev_warn(ddev, \"Endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 15\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 15;\n\t}\n\n\tif ((usb_endpoint_xfer_control(&ep->desc) ||\n\t\t\tusb_endpoint_xfer_int(&ep->desc)) &&\n\t\t\t\tdesc->bmAttributes != 0) {\n\t\tdev_warn(ddev, \"%s endpoint with bmAttributes = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\",\n\t\t\t\tusb_endpoint_xfer_control(&ep->desc) ? \"Control\" : \"Bulk\",\n\t\t\t\tdesc->bmAttributes,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 0;\n\t} else if (usb_endpoint_xfer_bulk(&ep->desc) &&\n\t\t\tdesc->bmAttributes > 16) {\n\t\tdev_warn(ddev, \"Bulk endpoint with more than 65536 streams in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to max\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 16;\n\t} else if (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t\t   !USB_SS_SSP_ISOC_COMP(desc->bmAttributes) &&\n\t\t   USB_SS_MULT(desc->bmAttributes) > 3) {\n\t\tdev_warn(ddev, \"Isoc endpoint has Mult of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 3\\n\",\n\t\t\t\tUSB_SS_MULT(desc->bmAttributes),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 2;\n\t}\n\n\tif (usb_endpoint_xfer_isoc(&ep->desc))\n\t\tmax_tx = (desc->bMaxBurst + 1) *\n\t\t\t(USB_SS_MULT(desc->bmAttributes)) *\n\t\t\tusb_endpoint_maxp(&ep->desc);\n\telse if (usb_endpoint_xfer_int(&ep->desc))\n\t\tmax_tx = usb_endpoint_maxp(&ep->desc) *\n\t\t\t(desc->bMaxBurst + 1);\n\telse\n\t\tmax_tx = 999999;\n\tif (le16_to_cpu(desc->wBytesPerInterval) > max_tx) {\n\t\tdev_warn(ddev, \"%s endpoint with wBytesPerInterval of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to %d\\n\",\n\t\t\t\tusb_endpoint_xfer_isoc(&ep->desc) ? \"Isoc\" : \"Int\",\n\t\t\t\tle16_to_cpu(desc->wBytesPerInterval),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress,\n\t\t\t\tmax_tx);\n\t\tep->ss_ep_comp.wBytesPerInterval = cpu_to_le16(max_tx);\n\t}\n\t/* Parse a possible SuperSpeedPlus isoc ep companion descriptor */\n\tif (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t    USB_SS_SSP_ISOC_COMP(desc->bmAttributes))\n\t\tusb_parse_ssp_isoc_endpoint_companion(ddev, cfgno, inum, asnum,\n\t\t\t\t\t\t\tep, buffer, size);\n}\n\nstatic const unsigned short low_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 8,\n\t[USB_ENDPOINT_XFER_ISOC] = 0,\n\t[USB_ENDPOINT_XFER_BULK] = 0,\n\t[USB_ENDPOINT_XFER_INT] = 8,\n};\nstatic const unsigned short full_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1023,\n\t[USB_ENDPOINT_XFER_BULK] = 64,\n\t[USB_ENDPOINT_XFER_INT] = 64,\n};\nstatic const unsigned short high_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 512,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\nstatic const unsigned short super_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 512,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 1024,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\n\nstatic int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,\n    int asnum, struct usb_host_interface *ifp, int num_ep,\n    unsigned char *buffer, int size)\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_endpoint_descriptor *d;\n\tstruct usb_host_endpoint *endpoint;\n\tint n, i, j, retval;\n\tunsigned int maxp;\n\tconst unsigned short *maxpacket_maxes;\n\n\td = (struct usb_endpoint_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\tn = USB_DT_ENDPOINT_AUDIO_SIZE;\n\telse if (d->bLength >= USB_DT_ENDPOINT_SIZE)\n\t\tn = USB_DT_ENDPOINT_SIZE;\n\telse {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint descriptor of length %d, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bLength);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\ti = d->bEndpointAddress & ~USB_ENDPOINT_DIR_MASK;\n\tif (i >= 16 || i == 0) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint with address 0x%X, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\t/* Only store as many endpoints as we have room for */\n\tif (ifp->desc.bNumEndpoints >= num_ep)\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\n\t/* Check for duplicate endpoint addresses */\n\tfor (i = 0; i < ifp->desc.bNumEndpoints; ++i) {\n\t\tif (ifp->endpoint[i].desc.bEndpointAddress ==\n\t\t    d->bEndpointAddress) {\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\\n\",\n\t\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t\t}\n\t}\n\n\tendpoint = &ifp->endpoint[ifp->desc.bNumEndpoints];\n\t++ifp->desc.bNumEndpoints;\n\n\tmemcpy(&endpoint->desc, d, n);\n\tINIT_LIST_HEAD(&endpoint->urb_list);\n\n\t/*\n\t * Fix up bInterval values outside the legal range.\n\t * Use 10 or 8 ms if no proper value can be guessed.\n\t */\n\ti = 0;\t\t/* i = min, j = max, n = default */\n\tj = 255;\n\tif (usb_endpoint_xfer_int(d)) {\n\t\ti = 1;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\t/*\n\t\t\t * Many device manufacturers are using full-speed\n\t\t\t * bInterval values in high-speed interrupt endpoint\n\t\t\t * descriptors. Try to fix those and fall back to an\n\t\t\t * 8-ms default value otherwise.\n\t\t\t */\n\t\t\tn = fls(d->bInterval*8);\n\t\t\tif (n == 0)\n\t\t\t\tn = 7;\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tj = 16;\n\n\t\t\t/*\n\t\t\t * Adjust bInterval for quirked devices.\n\t\t\t */\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in ms.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval) + 3, i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in\n\t\t\t * linear microframes.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval), i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL or _LOW */\n\t\t\t/*\n\t\t\t * For low-speed, 10 ms is the official minimum.\n\t\t\t * But some \"overclocked\" devices might want faster\n\t\t\t * polling so we'll allow it.\n\t\t\t */\n\t\t\tn = 10;\n\t\t\tbreak;\n\t\t}\n\t} else if (usb_endpoint_xfer_isoc(d)) {\n\t\ti = 1;\n\t\tj = 16;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_HIGH:\n\t\t\tn = 7;\t\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL */\n\t\t\tn = 4;\t\t/* 8 ms = 2^(4-1) frames */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (d->bInterval < i || d->bInterval > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X has an invalid bInterval %d, \"\n\t\t    \"changing to %d\\n\",\n\t\t    cfgno, inum, asnum,\n\t\t    d->bEndpointAddress, d->bInterval, n);\n\t\tendpoint->desc.bInterval = n;\n\t}\n\n\t/* Some buggy low-speed devices have Bulk endpoints, which is\n\t * explicitly forbidden by the USB spec.  In an attempt to make\n\t * them usable, we will try treating them as Interrupt endpoints.\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_LOW &&\n\t\t\tusb_endpoint_xfer_bulk(d)) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X is Bulk; changing to Interrupt\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tendpoint->desc.bmAttributes = USB_ENDPOINT_XFER_INT;\n\t\tendpoint->desc.bInterval = 1;\n\t\tif (usb_endpoint_maxp(&endpoint->desc) > 8)\n\t\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(8);\n\t}\n\n\t/* Validate the wMaxPacketSize field */\n\tmaxp = usb_endpoint_maxp(&endpoint->desc);\n\n\t/* Find the highest legal maxpacket size for this endpoint */\n\ti = 0;\t\t/* additional transactions per microframe */\n\tswitch (to_usb_device(ddev)->speed) {\n\tcase USB_SPEED_LOW:\n\t\tmaxpacket_maxes = low_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tmaxpacket_maxes = full_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\t/* Bits 12..11 are allowed only for HS periodic endpoints */\n\t\tif (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {\n\t\t\ti = maxp & (BIT(12) | BIT(11));\n\t\t\tmaxp &= ~i;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tmaxpacket_maxes = high_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tmaxpacket_maxes = super_speed_maxpacket_maxes;\n\t\tbreak;\n\t}\n\tj = maxpacket_maxes[usb_endpoint_type(&endpoint->desc)];\n\n\tif (maxp > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress, maxp, j);\n\t\tmaxp = j;\n\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(i | maxp);\n\t}\n\n\t/*\n\t * Some buggy high speed devices have bulk endpoints using\n\t * maxpacket sizes other than 512.  High speed HCDs may not\n\t * be able to handle that particular bug, so let's warn...\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_HIGH\n\t\t\t&& usb_endpoint_xfer_bulk(d)) {\n\t\tif (maxp != 512)\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t\t\t\"bulk endpoint 0x%X has invalid maxpacket %d\\n\",\n\t\t\t\tcfgno, inum, asnum, d->bEndpointAddress,\n\t\t\t\tmaxp);\n\t}\n\n\t/* Parse a possible SuperSpeed endpoint companion descriptor */\n\tif (to_usb_device(ddev)->speed >= USB_SPEED_SUPER)\n\t\tusb_parse_ss_endpoint_companion(ddev, cfgno,\n\t\t\t\tinum, asnum, endpoint, buffer, size);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the next endpoint or interface descriptor */\n\tendpoint->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t\t\tUSB_DT_INTERFACE, &n);\n\tendpoint->extralen = i;\n\tretval = buffer - buffer0 + i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"endpoint\");\n\treturn retval;\n\nskip_to_next_endpoint_or_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nvoid usb_release_interface_cache(struct kref *ref)\n{\n\tstruct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);\n\tint j;\n\n\tfor (j = 0; j < intfc->num_altsetting; j++) {\n\t\tstruct usb_host_interface *alt = &intfc->altsetting[j];\n\n\t\tkfree(alt->endpoint);\n\t\tkfree(alt->string);\n\t}\n\tkfree(intfc);\n}\n\nstatic int usb_parse_interface(struct device *ddev, int cfgno,\n    struct usb_host_config *config, unsigned char *buffer, int size,\n    u8 inums[], u8 nalts[])\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_interface_descriptor\t*d;\n\tint inum, asnum;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint i, n;\n\tint len, retval;\n\tint num_ep, num_ep_orig;\n\n\td = (struct usb_interface_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength < USB_DT_INTERFACE_SIZE)\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Which interface entry is this? */\n\tintfc = NULL;\n\tinum = d->bInterfaceNumber;\n\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\tif (inums[i] == inum) {\n\t\t\tintfc = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intfc || intfc->num_altsetting >= nalts[i])\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Check for duplicate altsetting entries */\n\tasnum = d->bAlternateSetting;\n\tfor ((i = 0, alt = &intfc->altsetting[0]);\n\t      i < intfc->num_altsetting;\n\t     (++i, ++alt)) {\n\t\tif (alt->desc.bAlternateSetting == asnum) {\n\t\t\tdev_warn(ddev, \"Duplicate descriptor for config %d \"\n\t\t\t    \"interface %d altsetting %d, skipping\\n\",\n\t\t\t    cfgno, inum, asnum);\n\t\t\tgoto skip_to_next_interface_descriptor;\n\t\t}\n\t}\n\n\t++intfc->num_altsetting;\n\tmemcpy(&alt->desc, d, USB_DT_INTERFACE_SIZE);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first endpoint or interface descriptor */\n\talt->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, &n);\n\talt->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"interface\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Allocate space for the right(?) number of endpoints */\n\tnum_ep = num_ep_orig = alt->desc.bNumEndpoints;\n\talt->desc.bNumEndpoints = 0;\t\t/* Use as a counter */\n\tif (num_ep > USB_MAXENDPOINTS) {\n\t\tdev_warn(ddev, \"too many endpoints for config %d interface %d \"\n\t\t    \"altsetting %d: %d, using maximum allowed: %d\\n\",\n\t\t    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);\n\t\tnum_ep = USB_MAXENDPOINTS;\n\t}\n\n\tif (num_ep > 0) {\n\t\t/* Can't allocate 0 bytes */\n\t\tlen = sizeof(struct usb_host_endpoint) * num_ep;\n\t\talt->endpoint = kzalloc(len, GFP_KERNEL);\n\t\tif (!alt->endpoint)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Parse all the endpoint descriptors */\n\tn = 0;\n\twhile (size > 0) {\n\t\tif (((struct usb_descriptor_header *) buffer)->bDescriptorType\n\t\t     == USB_DT_INTERFACE)\n\t\t\tbreak;\n\t\tretval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt,\n\t\t    num_ep, buffer, size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\t++n;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\tif (n != num_ep_orig)\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has %d \"\n\t\t    \"endpoint descriptor%s, different from the interface \"\n\t\t    \"descriptor's value: %d\\n\",\n\t\t    cfgno, inum, asnum, n, plural(n), num_ep_orig);\n\treturn buffer - buffer0;\n\nskip_to_next_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nstatic int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t/* Go through the descriptors, checking their length and counting the\n\t * number of altsettings for each interface */\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t/* Have we already encountered this interface?\n\t\t\t * Count its altsettings */\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tstruct usb_interface_assoc_descriptor *d;\n\n\t\t\td = (struct usb_interface_assoc_descriptor *)header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\n\t\t\t\tdev_warn(ddev,\n\t\t\t\t\t \"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\n\t\t\t\t\t cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] = d;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t/* for ((buffer2 = buffer, size2 = size); ...) */\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t/* Check for missing interface numbers */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t/* Allocate the usb_interface_caches and altsetting arrays */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t/* FIXME: parse the BOS descriptor */\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first interface descriptor */\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Parse all the interface/altsetting descriptors */\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t/* Check for missing altsettings */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* hub-only!! ... and only exported for reset/reinit path.\n * otherwise used internally on disconnect/destroy path\n */\nvoid usb_destroy_configuration(struct usb_device *dev)\n{\n\tint c, i;\n\n\tif (!dev->config)\n\t\treturn;\n\n\tif (dev->rawdescriptors) {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++)\n\t\t\tkfree(dev->rawdescriptors[i]);\n\n\t\tkfree(dev->rawdescriptors);\n\t\tdev->rawdescriptors = NULL;\n\t}\n\n\tfor (c = 0; c < dev->descriptor.bNumConfigurations; c++) {\n\t\tstruct usb_host_config *cf = &dev->config[c];\n\n\t\tkfree(cf->string);\n\t\tfor (i = 0; i < cf->desc.bNumInterfaces; i++) {\n\t\t\tif (cf->intf_cache[i])\n\t\t\t\tkref_put(&cf->intf_cache[i]->ref,\n\t\t\t\t\t  usb_release_interface_cache);\n\t\t}\n\t}\n\tkfree(dev->config);\n\tdev->config = NULL;\n}\n\n\n/*\n * Get the USB config descriptors, cache and parse'em\n *\n * hub-only!! ... and only in reset path, or usb_new_device()\n * (used by real hubs and virtual root hubs)\n */\nint usb_get_configuration(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tint ncfg = dev->descriptor.bNumConfigurations;\n\tint result = 0;\n\tunsigned int cfgno, length;\n\tunsigned char *bigbuffer;\n\tstruct usb_config_descriptor *desc;\n\n\tcfgno = 0;\n\tresult = -ENOMEM;\n\tif (ncfg > USB_MAXCONFIG) {\n\t\tdev_warn(ddev, \"too many configurations: %d, \"\n\t\t    \"using maximum allowed: %d\\n\", ncfg, USB_MAXCONFIG);\n\t\tdev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;\n\t}\n\n\tif (ncfg < 1) {\n\t\tdev_err(ddev, \"no configurations\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength = ncfg * sizeof(struct usb_host_config);\n\tdev->config = kzalloc(length, GFP_KERNEL);\n\tif (!dev->config)\n\t\tgoto err2;\n\n\tlength = ncfg * sizeof(char *);\n\tdev->rawdescriptors = kzalloc(length, GFP_KERNEL);\n\tif (!dev->rawdescriptors)\n\t\tgoto err2;\n\n\tdesc = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto err2;\n\n\tresult = 0;\n\tfor (; cfgno < ncfg; cfgno++) {\n\t\t/* We grab just the first descriptor so we know how long\n\t\t * the whole configuration is */\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    desc, USB_DT_CONFIG_SIZE);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s: %d\\n\", cfgno, \"start\", result);\n\t\t\tif (result != -EPIPE)\n\t\t\t\tgoto err;\n\t\t\tdev_err(ddev, \"chopping to %d config(s)\\n\", cfgno);\n\t\t\tdev->descriptor.bNumConfigurations = cfgno;\n\t\t\tbreak;\n\t\t} else if (result < 4) {\n\t\t\tdev_err(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno,\n\t\t\t    USB_DT_CONFIG_SIZE, result);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tlength = max((int) le16_to_cpu(desc->wTotalLength),\n\t\t    USB_DT_CONFIG_SIZE);\n\n\t\t/* Now that we know the length, get the whole thing */\n\t\tbigbuffer = kmalloc(length, GFP_KERNEL);\n\t\tif (!bigbuffer) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(200);\n\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s\\n\", cfgno, \"all\");\n\t\t\tkfree(bigbuffer);\n\t\t\tgoto err;\n\t\t}\n\t\tif (result < length) {\n\t\t\tdev_warn(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno, length, result);\n\t\t\tlength = result;\n\t\t}\n\n\t\tdev->rawdescriptors[cfgno] = bigbuffer;\n\n\t\tresult = usb_parse_configuration(dev, cfgno,\n\t\t    &dev->config[cfgno], bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\t++cfgno;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tresult = 0;\n\nerr:\n\tkfree(desc);\n\tdev->descriptor.bNumConfigurations = cfgno;\nerr2:\n\tif (result == -ENOMEM)\n\t\tdev_err(ddev, \"out of memory\\n\");\n\treturn result;\n}\n\nvoid usb_release_bos_descriptor(struct usb_device *dev)\n{\n\tif (dev->bos) {\n\t\tkfree(dev->bos->desc);\n\t\tkfree(dev->bos);\n\t\tdev->bos = NULL;\n\t}\n}\n\n/* Get BOS descriptor set */\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\n\t\tif (total_len < sizeof(*cap) || total_len < cap->bLength) {\n\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n\t\t\tbreak;\n\t\t}\n\t\tlength = cap->bLength;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n"], "filenames": ["drivers/usb/core/config.c"], "buggy_code_start_loc": [962], "buggy_code_end_loc": [967], "fixing_code_start_loc": [963], "fixing_code_end_loc": [968], "type": "CWE-125", "message": "The usb_get_bos_descriptor function in drivers/usb/core/config.c in the Linux kernel before 4.13.10 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.", "other": {"cve": {"id": "CVE-2017-16535", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:37.147", "lastModified": "2018-08-24T10:29:01.163", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The usb_get_bos_descriptor function in drivers/usb/core/config.c in the Linux kernel before 4.13.10 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device."}, {"lang": "es", "value": "La funci\u00f3n usb_get_bos_descriptor en drivers/usb/core/config.c en el kernel de Linux, en versiones anteriores a la 4.13.10, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.9", "matchCriteriaId": "3259E528-10D8-4E5E-99CE-AE8E7A8AC898"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/102022", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/1c0edc3633b56000e18d82fc241e3995ca18a69e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/tzdz2fTB1K0/OvjIgLSTAgAJ", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1c0edc3633b56000e18d82fc241e3995ca18a69e"}}