{"buggy_code": ["AccessControl==6.0\nalembic==1.8.1\nAPScheduler==3.9.1.post1\nasyncpg==0.27.0\nboto3==1.26.1\ncelery[pytest]==5.2.7\ncolorama>=0.4.3\ncryptography==38.0.3\ndask==2022.9.2\ndeepdiff==6.3.0\nexpandvars==0.9.0\nfastapi[all]==0.89.1\nfastapi-caching[redis]==0.3.0\nfastapi-pagination[sqlalchemy]~= 0.10.0\nfideslang==1.4.2\nfideslog==1.2.10\nfirebase-admin==5.3.0\nGitPython==3.1.31\nhttpx==0.23.1\nhvac==0.11.2\nimportlib_resources==5.12.0\nJinja2==3.1.2\nloguru>=0.5,<0.6\nmultidimensional_urlencode==0.0.4\nokta==2.7.0\nopenpyxl==3.0.9\npackaging==23.0\npandas==1.4.3\nparamiko==3.1.0\npasslib[bcrypt]==1.7.4\nplotly==5.13.1\npyarrow==6.0.0\npsycopg2-binary==2.9.6\npydantic==1.10.9\npydash==6.0.2\nPyJWT==2.4.0\npymongo==3.13.0\npymssql==2.2.7\nPyMySQL==1.0.2\npython-jose[cryptography]==3.3.0\npyyaml>=5,<6\nredis==3.5.3\nRestrictedPython==6.0.0\nrich-click==1.6.1\nsendgrid==6.9.7\nslowapi==0.1.8\nsnowflake-sqlalchemy==1.4.3\nsqlalchemy[asyncio]==1.4.27\nsqlalchemy-citext==1.8.0\nsqlalchemy-bigquery==1.4.4\nsqlalchemy-redshift==0.8.11\nsqlalchemy-stubs==0.4\nSQLAlchemy-Utils==0.38.3\nsshtunnel==0.4.0\ntoml>=0.10.1\ntwilio==7.15.0\ntyping_extensions==4.5.0 # pinned to work around https://github.com/pydantic/pydantic/issues/5821\nUnidecode==1.3.4\nvalidators==0.20.0\nversioneer==0.19\n", "# pylint: disable=protected-access\nimport os\nfrom abc import ABC, abstractmethod\nfrom ast import AST, AnnAssign\nfrom operator import getitem\nfrom typing import Any, Dict, Iterable, List, Optional, Tuple, Type\nfrom zipfile import ZipFile\n\nfrom AccessControl.ZopeGuards import safe_builtins\nfrom fideslang.models import Dataset\nfrom loguru import logger\nfrom packaging.version import Version\nfrom packaging.version import parse as parse_version\nfrom RestrictedPython import compile_restricted\nfrom RestrictedPython.transformer import RestrictingNodeTransformer\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.common_exceptions import FidesopsException, ValidationError\nfrom fides.api.cryptography.cryptographic_util import str_to_b64_str\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.schemas.connection_configuration.connection_config import (\n    SaasConnectionTemplateValues,\n)\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config,\n    load_config_from_string,\n    load_dataset_from_string,\n    load_yaml_as_string,\n    replace_config_placeholders,\n    replace_dataset_placeholders,\n    replace_version,\n)\nfrom fides.api.util.unsafe_file_util import verify_zip\nfrom fides.config import CONFIG\n\n\nclass ConnectorTemplateLoader(ABC):\n    _instance: Optional[\"ConnectorTemplateLoader\"] = None\n\n    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._templates = {}  # type: ignore[attr-defined]\n            cls._instance._load_connector_templates()\n        return cls._instance\n\n    @classmethod\n    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"Returns a map of connection templates.\"\"\"\n        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]\n\n    @abstractmethod\n    def _load_connector_templates(self) -> None:\n        \"\"\"Load connector templates into the _templates dictionary\"\"\"\n\n\nclass FileConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads SaaS connector templates from the data/saas directory.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the data/saas directory\")\n        for file in os.listdir(\"data/saas/config\"):\n            if file.endswith(\".yml\"):\n                config_file = os.path.join(\"data/saas/config\", file)\n                config_dict = load_config(config_file)\n                connector_type = config_dict[\"type\"]\n                human_readable = config_dict[\"name\"]\n\n                try:\n                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")\n                except FileNotFoundError:\n                    logger.debug(\n                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"\n                    )\n                    icon = encode_file_contents(\"data/saas/icon/default.svg\")\n\n                # store connector template for retrieval\n                try:\n                    FileConnectorTemplateLoader.get_connector_templates()[\n                        connector_type\n                    ] = ConnectorTemplate(\n                        config=load_yaml_as_string(config_file),\n                        dataset=load_yaml_as_string(\n                            f\"data/saas/dataset/{connector_type}_dataset.yml\"\n                        ),\n                        icon=icon,\n                        functions=None,\n                        human_readable=human_readable,\n                    )\n                except Exception:\n                    logger.exception(\"Unable to load {} connector\", connector_type)\n\n\nclass CustomConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads custom connector templates defined in the custom_connector_template database table.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the database.\")\n        db = get_api_session()\n        for template in CustomConnectorTemplate.all(db=db):\n            if (\n                template.replaceable\n                and CustomConnectorTemplateLoader._replacement_available(template)\n            ):\n                logger.info(\n                    f\"Replacing {template.key} connector template with newer version.\"\n                )\n                template.delete(db=db)\n                continue\n            try:\n                CustomConnectorTemplateLoader._register_template(template)\n            except Exception:\n                logger.exception(\"Unable to load {} connector\", template.key)\n\n    @staticmethod\n    def _replacement_available(template: CustomConnectorTemplate) -> bool:\n        \"\"\"\n        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.\n        \"\"\"\n        replacement_connector = (\n            FileConnectorTemplateLoader.get_connector_templates().get(template.key)\n        )\n        if not replacement_connector:\n            return False\n\n        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))\n        replacement_saas_config = SaaSConfig(\n            **load_config_from_string(replacement_connector.config)\n        )\n        return parse_version(replacement_saas_config.version) > parse_version(\n            custom_saas_config.version\n        )\n\n    @classmethod\n    def _register_template(\n        cls,\n        template: CustomConnectorTemplate,\n    ) -> None:\n        \"\"\"\n        Registers a custom connector template by converting it to a ConnectorTemplate,\n        registering any custom functions, and adding it to the loader's template dictionary.\n        \"\"\"\n        connector_template = ConnectorTemplate(\n            config=template.config,\n            dataset=template.dataset,\n            icon=template.icon,\n            functions=template.functions,\n            human_readable=template.name,\n        )\n\n        # register custom functions if available\n        if template.functions:\n            register_custom_functions(template.functions)\n            logger.info(\n                f\"Loaded functions from the custom connector template '{template.key}'\"\n            )\n\n        # register the template in the loader's template dictionary\n        CustomConnectorTemplateLoader.get_connector_templates()[\n            template.key\n        ] = connector_template\n\n    # pylint: disable=too-many-branches\n    @classmethod\n    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n\n\nclass ConnectorRegistry:\n    @classmethod\n    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"\n        Returns a combined map of connector templates from all registered loaders.\n        The resulting map is an aggregation of templates from the file loader and the custom loader,\n        with custom loader templates taking precedence in case of conflicts.\n        \"\"\"\n        return {\n            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n        }\n\n    @classmethod\n    def connector_types(cls) -> List[str]:\n        \"\"\"List of registered SaaS connector types\"\"\"\n        return list(cls._get_combined_templates().keys())\n\n    @classmethod\n    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:\n        \"\"\"\n        Returns an object containing the various SaaS connector artifacts\n        \"\"\"\n        return cls._get_combined_templates().get(connector_type)\n\n\ndef create_connection_config_from_template_no_save(\n    db: Session,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n    system_id: Optional[str] = None,\n) -> ConnectionConfig:\n    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"\n    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_values.instance_key\n    )\n\n    data = {\n        \"key\": template_values.key\n        if template_values.key\n        else template_values.instance_key,\n        \"description\": template_values.description,\n        \"connection_type\": ConnectionType.saas,\n        \"access\": AccessLevel.write,\n        \"saas_config\": config_from_template,\n    }\n    if template_values.name:\n        data[\"name\"] = template_values.name\n\n    if system_id:\n        data[\"system_id\"] = system_id\n\n    # Create SaaS ConnectionConfig\n    connection_config = ConnectionConfig.create_without_saving(db, data=data)\n\n    return connection_config\n\n\ndef upsert_dataset_config_from_template(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n) -> DatasetConfig:\n    \"\"\"\n    Creates a `DatasetConfig` from a template\n    and associates it with a ConnectionConfig.\n    If the `DatasetConfig` already exists in the db,\n    then the existing record is updated.\n    \"\"\"\n    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    dataset_from_template: Dict = replace_dataset_placeholders(\n        template.dataset, \"<instance_fides_key>\", template_values.instance_key\n    )\n    data = {\n        \"connection_config_id\": connection_config.id,\n        \"fides_key\": template_values.instance_key,\n        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset\n    }\n    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)\n    return dataset_config\n\n\ndef update_saas_configs(db: Session) -> None:\n    \"\"\"\n    Updates SaaS config instances currently in the DB if to the\n    corresponding template in the registry are found.\n\n    Effectively an \"update script\" for SaaS config instances,\n    to be run on server bootstrap.\n    \"\"\"\n    for connector_type in ConnectorRegistry.connector_types():\n        logger.debug(\n            \"Determining if any updates are needed for connectors of type {} based on templates...\",\n            connector_type,\n        )\n        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore\n            connector_type\n        )\n        saas_config = SaaSConfig(**load_config_from_string(template.config))\n        template_version: Version = parse_version(saas_config.version)\n\n        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(\n            db=db,\n            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),\n        ).all()\n        for connection_config in connection_configs:\n            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)\n            if parse_version(saas_config_instance.version) < template_version:\n                logger.info(\n                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",\n                    saas_config_instance.fides_key,\n                    connector_type,\n                    saas_config_instance.version,\n                    template_version,\n                )\n                try:\n                    update_saas_instance(\n                        db,\n                        connection_config,\n                        template,\n                        saas_config_instance,\n                    )\n                except Exception:\n                    logger.exception(\n                        \"Encountered error attempting to update SaaS config instance {}\",\n                        saas_config_instance.fides_key,\n                    )\n\n\ndef update_saas_instance(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    saas_config_instance: SaaSConfig,\n) -> None:\n    \"\"\"\n    Replace in the DB the existing SaaS instance configuration data\n    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig\n    with new instance configuration data based on the given ConnectorTemplate\n    \"\"\"\n    template_vals = SaasConnectionTemplateValues(\n        name=connection_config.name,\n        key=connection_config.key,\n        description=connection_config.description,\n        secrets=connection_config.secrets,\n        instance_key=saas_config_instance.fides_key,\n    )\n\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_vals.instance_key\n    )\n\n    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))\n\n    upsert_dataset_config_from_template(db, connection_config, template, template_vals)\n\n\ndef register_custom_functions(script: str) -> None:\n    \"\"\"\n    Registers custom functions by executing the given script in a restricted environment.\n\n    The script is compiled and executed with RestrictedPython, which is designed to reduce\n    the risk of executing untrusted code. It provides a set of safe builtins to prevent\n    malicious or unintended behavior.\n\n    Args:\n        script (str): The Python script containing the custom functions to be registered.\n\n    Raises:\n        FidesopsException: If allow_custom_connector_functions is disabled.\n        SyntaxError: If the script contains a syntax error or uses restricted language features.\n        Exception: If an exception occurs during the execution of the script.\n    \"\"\"\n\n    if CONFIG.security.allow_custom_connector_functions:\n        restricted_code = compile_restricted(\n            script, \"<string>\", \"exec\", policy=CustomRestrictingNodeTransformer\n        )\n        safe_builtins[\"__import__\"] = custom_guarded_import\n        safe_builtins[\"_getitem_\"] = getitem\n        safe_builtins[\"staticmethod\"] = staticmethod\n\n        # pylint: disable=exec-used\n        exec(\n            restricted_code,\n            {\n                \"__metaclass__\": type,\n                \"__name__\": \"restricted_module\",\n                \"__builtins__\": safe_builtins,\n            },\n        )\n    else:\n        raise FidesopsException(\n            message=\"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n        )\n\n\nclass CustomRestrictingNodeTransformer(RestrictingNodeTransformer):\n    \"\"\"\n    Custom node transformer class that extends RestrictedPython's RestrictingNodeTransformer\n    to allow the use of type annotations (AnnAssign) in restricted code.\n    \"\"\"\n\n    def visit_AnnAssign(self, node: AnnAssign) -> AST:\n        return self.node_contents_visit(node)\n\n\ndef custom_guarded_import(\n    name: str,\n    _globals: Optional[dict] = None,\n    _locals: Optional[dict] = None,\n    fromlist: Optional[Tuple[str, ...]] = None,\n    level: int = 0,\n) -> Any:\n    \"\"\"\n    A custom import function that prevents the import of certain potentially unsafe modules.\n    \"\"\"\n    if name in [\n        \"os\",\n        \"sys\",\n        \"subprocess\",\n        \"shutil\",\n        \"socket\",\n        \"importlib\",\n        \"tempfile\",\n        \"glob\",\n    ]:\n        # raising SyntaxError to be consistent with exceptions thrown from other guarded functions\n        raise SyntaxError(f\"Import of '{name}' module is not allowed.\")\n    if fromlist is None:\n        fromlist = ()\n    return __import__(name, _globals, _locals, fromlist, level)\n", "from typing import Optional\nfrom zipfile import ZipFile\n\nMAX_FILE_SIZE = 16 * 1024 * 1024  # 16 MB\nCHUNK_SIZE = 1024\n\n\ndef verify_zip(zip_file: ZipFile, max_file_size: Optional[int] = None) -> None:\n    \"\"\"\n    Function to safely verify the contents of zipped files. It prevents potential\n    'zip bomb' attacks by checking the file size of the files in the zip without fully\n    extracting them. If the size of any file in the zip exceeds the specified\n    max_file_size, it raises a ValueError. If the max_file_size is not provided,\n    it uses a default value of 16 MB.\n\n    :param zip_file: A ZipFile object to be verified.\n    :param max_file_size: An optional integer specifying the maximum bytes allowed per file. If not provided, a default value is used.\n    :raises ValueError: If a file in the zip file exceeds the maximum allowed size\n    \"\"\"\n\n    if max_file_size is None:\n        max_file_size = MAX_FILE_SIZE\n\n    for file_info in zip_file.infolist():\n        file_size = 0\n\n        with zip_file.open(file_info) as file:\n            # wraps the file read in an iterator that stops once no bytes\n            # are returned or the max file size is reached\n            for chunk in iter(lambda: file.read(CHUNK_SIZE), b\"\"):\n                file_size += len(chunk)\n\n                if file_size > max_file_size:\n                    raise ValueError(\"File size exceeds maximum allowed size\")\n", "from io import BytesIO\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom fides.api.util.unsafe_file_util import verify_zip\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\nclass TestVerifyZip:\n    @pytest.fixture\n    def zip_file(self) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": \"This file isn't that big, but it will be considered suspicious if the max file size is set too low\",\n            }\n        )\n\n    def test_verify_zip(self, zip_file):\n        verify_zip(ZipFile(zip_file))\n\n    def test_verify_zip_with_small_file_size_limit(self, zip_file):\n        \"\"\"We set the max file size to 1 byte, so the zip file should be rejected.\"\"\"\n        with pytest.raises(ValueError) as exc:\n            verify_zip(ZipFile(zip_file), 1)\n        assert \"File size exceeds maximum allowed size\" in str(exc.value)\n"], "fixing_code": ["AccessControl==6.0\nalembic==1.8.1\nAPScheduler==3.9.1.post1\nasyncpg==0.27.0\nboto3==1.26.1\ncelery[pytest]==5.2.7\ncolorama>=0.4.3\ncryptography==38.0.3\ndask==2022.9.2\ndeepdiff==6.3.0\ndefusedxml==0.7.1\nexpandvars==0.9.0\nfastapi[all]==0.89.1\nfastapi-caching[redis]==0.3.0\nfastapi-pagination[sqlalchemy]~= 0.10.0\nfideslang==1.4.2\nfideslog==1.2.10\nfirebase-admin==5.3.0\nGitPython==3.1.31\nhttpx==0.23.1\nhvac==0.11.2\nimportlib_resources==5.12.0\nJinja2==3.1.2\nloguru>=0.5,<0.6\nmultidimensional_urlencode==0.0.4\nokta==2.7.0\nopenpyxl==3.0.9\npackaging==23.0\npandas==1.4.3\nparamiko==3.1.0\npasslib[bcrypt]==1.7.4\nplotly==5.13.1\npyarrow==6.0.0\npsycopg2-binary==2.9.6\npydantic==1.10.9\npydash==6.0.2\nPyJWT==2.4.0\npymongo==3.13.0\npymssql==2.2.7\nPyMySQL==1.0.2\npython-jose[cryptography]==3.3.0\npyyaml>=5,<6\nredis==3.5.3\nRestrictedPython==6.0.0\nrich-click==1.6.1\nsendgrid==6.9.7\nslowapi==0.1.8\nsnowflake-sqlalchemy==1.4.3\nsqlalchemy[asyncio]==1.4.27\nsqlalchemy-citext==1.8.0\nsqlalchemy-bigquery==1.4.4\nsqlalchemy-redshift==0.8.11\nsqlalchemy-stubs==0.4\nSQLAlchemy-Utils==0.38.3\nsshtunnel==0.4.0\ntoml>=0.10.1\ntwilio==7.15.0\ntyping_extensions==4.5.0 # pinned to work around https://github.com/pydantic/pydantic/issues/5821\nUnidecode==1.3.4\nvalidators==0.20.0\nversioneer==0.19\n", "# pylint: disable=protected-access\nimport os\nfrom abc import ABC, abstractmethod\nfrom ast import AST, AnnAssign\nfrom operator import getitem\nfrom typing import Any, Dict, Iterable, List, Optional, Tuple, Type\nfrom zipfile import ZipFile\n\nfrom AccessControl.ZopeGuards import safe_builtins\nfrom fideslang.models import Dataset\nfrom loguru import logger\nfrom packaging.version import Version\nfrom packaging.version import parse as parse_version\nfrom RestrictedPython import compile_restricted\nfrom RestrictedPython.transformer import RestrictingNodeTransformer\nfrom sqlalchemy.orm import Session\n\nfrom fides.api.api.deps import get_api_session\nfrom fides.api.common_exceptions import FidesopsException, ValidationError\nfrom fides.api.cryptography.cryptographic_util import str_to_b64_str\nfrom fides.api.models.connectionconfig import (\n    AccessLevel,\n    ConnectionConfig,\n    ConnectionType,\n)\nfrom fides.api.models.custom_connector_template import CustomConnectorTemplate\nfrom fides.api.models.datasetconfig import DatasetConfig\nfrom fides.api.schemas.connection_configuration.connection_config import (\n    SaasConnectionTemplateValues,\n)\nfrom fides.api.schemas.saas.connector_template import ConnectorTemplate\nfrom fides.api.schemas.saas.saas_config import SaaSConfig\nfrom fides.api.util.saas_util import (\n    encode_file_contents,\n    load_config,\n    load_config_from_string,\n    load_dataset_from_string,\n    load_yaml_as_string,\n    replace_config_placeholders,\n    replace_dataset_placeholders,\n    replace_version,\n)\nfrom fides.api.util.unsafe_file_util import verify_svg, verify_zip\nfrom fides.config import CONFIG\n\n\nclass ConnectorTemplateLoader(ABC):\n    _instance: Optional[\"ConnectorTemplateLoader\"] = None\n\n    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._templates = {}  # type: ignore[attr-defined]\n            cls._instance._load_connector_templates()\n        return cls._instance\n\n    @classmethod\n    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"Returns a map of connection templates.\"\"\"\n        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]\n\n    @abstractmethod\n    def _load_connector_templates(self) -> None:\n        \"\"\"Load connector templates into the _templates dictionary\"\"\"\n\n\nclass FileConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads SaaS connector templates from the data/saas directory.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the data/saas directory\")\n        for file in os.listdir(\"data/saas/config\"):\n            if file.endswith(\".yml\"):\n                config_file = os.path.join(\"data/saas/config\", file)\n                config_dict = load_config(config_file)\n                connector_type = config_dict[\"type\"]\n                human_readable = config_dict[\"name\"]\n\n                try:\n                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")\n                except FileNotFoundError:\n                    logger.debug(\n                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"\n                    )\n                    icon = encode_file_contents(\"data/saas/icon/default.svg\")\n\n                # store connector template for retrieval\n                try:\n                    FileConnectorTemplateLoader.get_connector_templates()[\n                        connector_type\n                    ] = ConnectorTemplate(\n                        config=load_yaml_as_string(config_file),\n                        dataset=load_yaml_as_string(\n                            f\"data/saas/dataset/{connector_type}_dataset.yml\"\n                        ),\n                        icon=icon,\n                        functions=None,\n                        human_readable=human_readable,\n                    )\n                except Exception:\n                    logger.exception(\"Unable to load {} connector\", connector_type)\n\n\nclass CustomConnectorTemplateLoader(ConnectorTemplateLoader):\n    \"\"\"\n    Loads custom connector templates defined in the custom_connector_template database table.\n    \"\"\"\n\n    def _load_connector_templates(self) -> None:\n        logger.info(\"Loading connectors templates from the database.\")\n        db = get_api_session()\n        for template in CustomConnectorTemplate.all(db=db):\n            if (\n                template.replaceable\n                and CustomConnectorTemplateLoader._replacement_available(template)\n            ):\n                logger.info(\n                    f\"Replacing {template.key} connector template with newer version.\"\n                )\n                template.delete(db=db)\n                continue\n            try:\n                CustomConnectorTemplateLoader._register_template(template)\n            except Exception:\n                logger.exception(\"Unable to load {} connector\", template.key)\n\n    @staticmethod\n    def _replacement_available(template: CustomConnectorTemplate) -> bool:\n        \"\"\"\n        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.\n        \"\"\"\n        replacement_connector = (\n            FileConnectorTemplateLoader.get_connector_templates().get(template.key)\n        )\n        if not replacement_connector:\n            return False\n\n        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))\n        replacement_saas_config = SaaSConfig(\n            **load_config_from_string(replacement_connector.config)\n        )\n        return parse_version(replacement_saas_config.version) > parse_version(\n            custom_saas_config.version\n        )\n\n    @classmethod\n    def _register_template(\n        cls,\n        template: CustomConnectorTemplate,\n    ) -> None:\n        \"\"\"\n        Registers a custom connector template by converting it to a ConnectorTemplate,\n        registering any custom functions, and adding it to the loader's template dictionary.\n        \"\"\"\n        connector_template = ConnectorTemplate(\n            config=template.config,\n            dataset=template.dataset,\n            icon=template.icon,\n            functions=template.functions,\n            human_readable=template.name,\n        )\n\n        # register custom functions if available\n        if template.functions:\n            register_custom_functions(template.functions)\n            logger.info(\n                f\"Loaded functions from the custom connector template '{template.key}'\"\n            )\n\n        # register the template in the loader's template dictionary\n        CustomConnectorTemplateLoader.get_connector_templates()[\n            template.key\n        ] = connector_template\n\n    # pylint: disable=too-many-branches\n    @classmethod\n    def save_template(cls, db: Session, zip_file: ZipFile) -> None:\n        \"\"\"\n        Extracts and validates the contents of a zip file containing a\n        custom connector template, registers the template, and saves it to the database.\n        \"\"\"\n\n        # verify the zip file before we use it\n        verify_zip(zip_file)\n\n        config_contents = None\n        dataset_contents = None\n        icon_contents = None\n        function_contents = None\n\n        for info in zip_file.infolist():\n            try:\n                file_contents = zip_file.read(info).decode()\n            except UnicodeDecodeError:\n                # skip any hidden metadata files that can't be decoded with UTF-8\n                logger.debug(f\"Unable to decode the file: {info.filename}\")\n                continue\n\n            if info.filename.endswith(\"config.yml\"):\n                if not config_contents:\n                    config_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with config.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\"dataset.yml\"):\n                if not dataset_contents:\n                    dataset_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple files ending with dataset.yml found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".svg\"):\n                if not icon_contents:\n                    verify_svg(file_contents)\n                    icon_contents = str_to_b64_str(file_contents)\n                else:\n                    raise ValidationError(\n                        \"Multiple svg files found, only one is allowed.\"\n                    )\n            elif info.filename.endswith(\".py\"):\n                if not function_contents:\n                    function_contents = file_contents\n                else:\n                    raise ValidationError(\n                        \"Multiple Python (.py) files found, only one is allowed.\"\n                    )\n\n        if not config_contents:\n            raise ValidationError(\"Zip file does not contain a config.yml file.\")\n\n        if not dataset_contents:\n            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")\n\n        # early validation of SaaS config and dataset\n        saas_config = SaaSConfig(**load_config_from_string(config_contents))\n        Dataset(**load_dataset_from_string(dataset_contents))\n\n        # extract connector_type, human_readable, and replaceable values from the SaaS config\n        connector_type = saas_config.type\n        human_readable = saas_config.name\n        replaceable = saas_config.replaceable\n\n        # if the incoming connector is flagged as replaceable we will update the version to match\n        # that of the existing connector template this way the custom connector template can be\n        # removed once a newer version is bundled with Fides\n        if replaceable:\n            existing_connector = (\n                FileConnectorTemplateLoader.get_connector_templates().get(\n                    connector_type\n                )\n            )\n            if existing_connector:\n                existing_config = SaaSConfig(\n                    **load_config_from_string(existing_connector.config)\n                )\n                config_contents = replace_version(\n                    config_contents, existing_config.version\n                )\n\n        template = CustomConnectorTemplate(\n            key=connector_type,\n            name=human_readable,\n            config=config_contents,\n            dataset=dataset_contents,\n            icon=icon_contents,\n            functions=function_contents,\n            replaceable=replaceable,\n        )\n\n        # attempt to register the template, raises an exception if validation fails\n        CustomConnectorTemplateLoader._register_template(template)\n\n        # save the custom connector to the database if it passed validation\n        CustomConnectorTemplate.create_or_update(\n            db=db,\n            data={\n                \"key\": connector_type,\n                \"name\": human_readable,\n                \"config\": config_contents,\n                \"dataset\": dataset_contents,\n                \"icon\": icon_contents,\n                \"functions\": function_contents,\n                \"replaceable\": replaceable,\n            },\n        )\n\n\nclass ConnectorRegistry:\n    @classmethod\n    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:\n        \"\"\"\n        Returns a combined map of connector templates from all registered loaders.\n        The resulting map is an aggregation of templates from the file loader and the custom loader,\n        with custom loader templates taking precedence in case of conflicts.\n        \"\"\"\n        return {\n            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore\n        }\n\n    @classmethod\n    def connector_types(cls) -> List[str]:\n        \"\"\"List of registered SaaS connector types\"\"\"\n        return list(cls._get_combined_templates().keys())\n\n    @classmethod\n    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:\n        \"\"\"\n        Returns an object containing the various SaaS connector artifacts\n        \"\"\"\n        return cls._get_combined_templates().get(connector_type)\n\n\ndef create_connection_config_from_template_no_save(\n    db: Session,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n    system_id: Optional[str] = None,\n) -> ConnectionConfig:\n    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"\n    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_values.instance_key\n    )\n\n    data = {\n        \"key\": template_values.key\n        if template_values.key\n        else template_values.instance_key,\n        \"description\": template_values.description,\n        \"connection_type\": ConnectionType.saas,\n        \"access\": AccessLevel.write,\n        \"saas_config\": config_from_template,\n    }\n    if template_values.name:\n        data[\"name\"] = template_values.name\n\n    if system_id:\n        data[\"system_id\"] = system_id\n\n    # Create SaaS ConnectionConfig\n    connection_config = ConnectionConfig.create_without_saving(db, data=data)\n\n    return connection_config\n\n\ndef upsert_dataset_config_from_template(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    template_values: SaasConnectionTemplateValues,\n) -> DatasetConfig:\n    \"\"\"\n    Creates a `DatasetConfig` from a template\n    and associates it with a ConnectionConfig.\n    If the `DatasetConfig` already exists in the db,\n    then the existing record is updated.\n    \"\"\"\n    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key\n    # the user has chosen\n    dataset_from_template: Dict = replace_dataset_placeholders(\n        template.dataset, \"<instance_fides_key>\", template_values.instance_key\n    )\n    data = {\n        \"connection_config_id\": connection_config.id,\n        \"fides_key\": template_values.instance_key,\n        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset\n    }\n    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)\n    return dataset_config\n\n\ndef update_saas_configs(db: Session) -> None:\n    \"\"\"\n    Updates SaaS config instances currently in the DB if to the\n    corresponding template in the registry are found.\n\n    Effectively an \"update script\" for SaaS config instances,\n    to be run on server bootstrap.\n    \"\"\"\n    for connector_type in ConnectorRegistry.connector_types():\n        logger.debug(\n            \"Determining if any updates are needed for connectors of type {} based on templates...\",\n            connector_type,\n        )\n        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore\n            connector_type\n        )\n        saas_config = SaaSConfig(**load_config_from_string(template.config))\n        template_version: Version = parse_version(saas_config.version)\n\n        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(\n            db=db,\n            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),\n        ).all()\n        for connection_config in connection_configs:\n            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)\n            if parse_version(saas_config_instance.version) < template_version:\n                logger.info(\n                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",\n                    saas_config_instance.fides_key,\n                    connector_type,\n                    saas_config_instance.version,\n                    template_version,\n                )\n                try:\n                    update_saas_instance(\n                        db,\n                        connection_config,\n                        template,\n                        saas_config_instance,\n                    )\n                except Exception:\n                    logger.exception(\n                        \"Encountered error attempting to update SaaS config instance {}\",\n                        saas_config_instance.fides_key,\n                    )\n\n\ndef update_saas_instance(\n    db: Session,\n    connection_config: ConnectionConfig,\n    template: ConnectorTemplate,\n    saas_config_instance: SaaSConfig,\n) -> None:\n    \"\"\"\n    Replace in the DB the existing SaaS instance configuration data\n    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig\n    with new instance configuration data based on the given ConnectorTemplate\n    \"\"\"\n    template_vals = SaasConnectionTemplateValues(\n        name=connection_config.name,\n        key=connection_config.key,\n        description=connection_config.description,\n        secrets=connection_config.secrets,\n        instance_key=saas_config_instance.fides_key,\n    )\n\n    config_from_template: Dict = replace_config_placeholders(\n        template.config, \"<instance_fides_key>\", template_vals.instance_key\n    )\n\n    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))\n\n    upsert_dataset_config_from_template(db, connection_config, template, template_vals)\n\n\ndef register_custom_functions(script: str) -> None:\n    \"\"\"\n    Registers custom functions by executing the given script in a restricted environment.\n\n    The script is compiled and executed with RestrictedPython, which is designed to reduce\n    the risk of executing untrusted code. It provides a set of safe builtins to prevent\n    malicious or unintended behavior.\n\n    Args:\n        script (str): The Python script containing the custom functions to be registered.\n\n    Raises:\n        FidesopsException: If allow_custom_connector_functions is disabled.\n        SyntaxError: If the script contains a syntax error or uses restricted language features.\n        Exception: If an exception occurs during the execution of the script.\n    \"\"\"\n\n    if CONFIG.security.allow_custom_connector_functions:\n        restricted_code = compile_restricted(\n            script, \"<string>\", \"exec\", policy=CustomRestrictingNodeTransformer\n        )\n        safe_builtins[\"__import__\"] = custom_guarded_import\n        safe_builtins[\"_getitem_\"] = getitem\n        safe_builtins[\"staticmethod\"] = staticmethod\n\n        # pylint: disable=exec-used\n        exec(\n            restricted_code,\n            {\n                \"__metaclass__\": type,\n                \"__name__\": \"restricted_module\",\n                \"__builtins__\": safe_builtins,\n            },\n        )\n    else:\n        raise FidesopsException(\n            message=\"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"\n        )\n\n\nclass CustomRestrictingNodeTransformer(RestrictingNodeTransformer):\n    \"\"\"\n    Custom node transformer class that extends RestrictedPython's RestrictingNodeTransformer\n    to allow the use of type annotations (AnnAssign) in restricted code.\n    \"\"\"\n\n    def visit_AnnAssign(self, node: AnnAssign) -> AST:\n        return self.node_contents_visit(node)\n\n\ndef custom_guarded_import(\n    name: str,\n    _globals: Optional[dict] = None,\n    _locals: Optional[dict] = None,\n    fromlist: Optional[Tuple[str, ...]] = None,\n    level: int = 0,\n) -> Any:\n    \"\"\"\n    A custom import function that prevents the import of certain potentially unsafe modules.\n    \"\"\"\n    if name in [\n        \"os\",\n        \"sys\",\n        \"subprocess\",\n        \"shutil\",\n        \"socket\",\n        \"importlib\",\n        \"tempfile\",\n        \"glob\",\n    ]:\n        # raising SyntaxError to be consistent with exceptions thrown from other guarded functions\n        raise SyntaxError(f\"Import of '{name}' module is not allowed.\")\n    if fromlist is None:\n        fromlist = ()\n    return __import__(name, _globals, _locals, fromlist, level)\n", "from typing import Optional\nfrom zipfile import ZipFile\n\nfrom defusedxml.ElementTree import fromstring\n\nfrom fides.api.common_exceptions import ValidationError\n\nMAX_FILE_SIZE = 16 * 1024 * 1024  # 16 MB\nCHUNK_SIZE = 1024\n\n\ndef verify_svg(contents: str) -> None:\n    \"\"\"\n    Verifies the provided SVG content.\n\n    This function checks the given SVG content string for potential issues and throws an exception if any are found.\n    It first attempts to parse the SVG content using 'defusedxml.fromstring'. If the parsing is unsuccessful, this\n    will raise an exception, indicating that the SVG content may contain unsafe XML.\n\n    :param contents: The SVG content as a string.\n    :raises ValidationError: If the SVG content contains unsafe XML or 'use xlink'\n    \"\"\"\n    try:\n        fromstring(contents)\n    except Exception:\n        raise ValidationError(\"SVG file contains unsafe XML.\")\n\n    if \"use xlink\" in contents:\n        raise ValidationError(\"SVG files with xlink references are not allowed.\")\n\n\ndef verify_zip(zip_file: ZipFile, max_file_size: Optional[int] = None) -> None:\n    \"\"\"\n    Function to safely verify the contents of zipped files. It prevents potential\n    'zip bomb' attacks by checking the file size of the files in the zip without fully\n    extracting them. If the size of any file in the zip exceeds the specified\n    max_file_size, it raises a ValueError. If the max_file_size is not provided,\n    it uses a default value of 16 MB.\n\n    :param zip_file: A ZipFile object to be verified.\n    :param max_file_size: An optional integer specifying the maximum bytes allowed per file. If not provided, a default value is used.\n    :raises ValueError: If a file in the zip file exceeds the maximum allowed size\n    \"\"\"\n\n    if max_file_size is None:\n        max_file_size = MAX_FILE_SIZE\n\n    for file_info in zip_file.infolist():\n        file_size = 0\n\n        with zip_file.open(file_info) as file:\n            # wraps the file read in an iterator that stops once no bytes\n            # are returned or the max file size is reached\n            for chunk in iter(lambda: file.read(CHUNK_SIZE), b\"\"):\n                file_size += len(chunk)\n\n                if file_size > max_file_size:\n                    raise ValueError(\"File size exceeds maximum allowed size\")\n", "from io import BytesIO\nfrom zipfile import ZipFile\n\nimport pytest\n\nfrom fides.api.common_exceptions import ValidationError\nfrom fides.api.util.unsafe_file_util import verify_svg, verify_zip\nfrom tests.ops.test_helpers.saas_test_utils import create_zip_file\n\n\nclass TestVerifySvg:\n    def test_verify_svg(self):\n        verify_svg(\n            \"\"\"<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\">\n                <circle cx=\"50\" cy=\"50\" r=\"40\"/>\n            </svg>\n            \"\"\"\n        )\n\n    def test_verify_svg_no_laughing_allowed(self):\n        \"\"\"Test \"billion laughs attack\" is prevented\"\"\"\n        with pytest.raises(ValidationError) as exc:\n            verify_svg(\n                \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n                <!DOCTYPE svg [\n                <!ENTITY lol \"lol\">\n                <!ELEMENT lolz (#PCDATA)>\n                <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n                <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\">\n                <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\">\n                <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\">\n                <!ENTITY lol5 \"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\">\n                <!ENTITY lol6 \"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\">\n                <!ENTITY lol7 \"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\">\n                <!ENTITY lol8 \"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\">\n                <!ENTITY lol9 \"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\">\n                ]>\n                <svg>\n                    <lolz>&lol9;</lolz>\n                </svg>\n                \"\"\"\n            )\n        assert \"SVG file contains unsafe XML.\" in str(exc.value)\n\n    def test_verify_svg_with_xlink(self):\n        with pytest.raises(ValidationError) as exc:\n            verify_svg(\n                \"\"\"<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 100 100\">\n                    <circle id=\"circle\" cx=\"50\" cy=\"50\" r=\"40\"/>\n                    <use xlink:href=\"#circle\"/>\n                </svg>\n                \"\"\"\n            )\n        assert \"SVG files with xlink references are not allowed.\" in str(exc.value)\n\n\nclass TestVerifyZip:\n    @pytest.fixture\n    def zip_file(self) -> BytesIO:\n        return create_zip_file(\n            {\n                \"config.yml\": \"This file isn't that big, but it will be considered suspicious if the max file size is set too low\",\n            }\n        )\n\n    def test_verify_zip(self, zip_file):\n        verify_zip(ZipFile(zip_file))\n\n    def test_verify_zip_with_small_file_size_limit(self, zip_file):\n        \"\"\"We set the max file size to 1 byte, so the zip file should be rejected.\"\"\"\n        with pytest.raises(ValueError) as exc:\n            verify_zip(ZipFile(zip_file), 1)\n        assert \"File size exceeds maximum allowed size\" in str(exc.value)\n"], "filenames": ["requirements.txt", "src/fides/api/service/connectors/saas/connector_registry_service.py", "src/fides/api/util/unsafe_file_util.py", "tests/ops/util/test_unsafe_file_util.py"], "buggy_code_start_loc": [10, 43, 3, 6], "buggy_code_end_loc": [10, 216, 5, 7], "fixing_code_start_loc": [11, 43, 4, 6], "fixing_code_end_loc": [12, 218, 30, 55], "type": "CWE-400", "message": "Fides is an open-source privacy engineering platform for managing data privacy requests and privacy regulations. The Fides webserver is vulnerable to a type of Denial of Service (DoS) attack. Attackers can exploit this vulnerability to upload zip files containing malicious SVG bombs (similar to a billion laughs attack), causing resource exhaustion in Admin UI browser tabs and creating a persistent denial of service of the 'new connector' page (`datastore-connection/new`). This vulnerability affects Fides versions `2.11.0` through `2.15.1`. Exploitation is limited to users with elevated privileges with the `CONNECTOR_TEMPLATE_REGISTER` scope, which includes root users and users with the owner role. The vulnerability has been patched in Fides version `2.16.0`. Users are advised to upgrade to this version or later to secure their systems against this threat. There is no known workaround to remediate this vulnerability without upgrading.", "other": {"cve": {"id": "CVE-2023-37481", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-18T19:15:09.927", "lastModified": "2023-07-27T19:48:07.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fides is an open-source privacy engineering platform for managing data privacy requests and privacy regulations. The Fides webserver is vulnerable to a type of Denial of Service (DoS) attack. Attackers can exploit this vulnerability to upload zip files containing malicious SVG bombs (similar to a billion laughs attack), causing resource exhaustion in Admin UI browser tabs and creating a persistent denial of service of the 'new connector' page (`datastore-connection/new`). This vulnerability affects Fides versions `2.11.0` through `2.15.1`. Exploitation is limited to users with elevated privileges with the `CONNECTOR_TEMPLATE_REGISTER` scope, which includes root users and users with the owner role. The vulnerability has been patched in Fides version `2.16.0`. Users are advised to upgrade to this version or later to secure their systems against this threat. There is no known workaround to remediate this vulnerability without upgrading."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ethyca:fides:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.11.0", "versionEndExcluding": "2.16.0", "matchCriteriaId": "784A4F45-3BA5-4372-8697-3B2BADF59AA3"}]}]}], "references": [{"url": "https://github.com/ethyca/fides/commit/8beaace082b325e693dc7682029a3cb7e6c2b69d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ethyca/fides/security/advisories/GHSA-3rw2-wfc8-wmj5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ethyca/fides/commit/8beaace082b325e693dc7682029a3cb7e6c2b69d"}}