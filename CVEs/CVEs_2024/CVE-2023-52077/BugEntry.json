{"buggy_code": ["import { performance } from 'perf_hooks';\nimport Koa from 'koa';\nimport { CacheableLocalUser, User } from '@/models/entities/user.js';\nimport { AccessToken } from '@/models/entities/access-token.js';\nimport { getIpHash } from '@/misc/get-ip-hash.js';\nimport { limiter } from './limiter.js';\nimport endpoints, { IEndpointMeta } from './endpoints.js';\nimport { ApiError } from './error.js';\nimport { apiLogger } from './logger.js';\n\nconst accessDenied = {\n\tmessage: 'Access denied.',\n\tcode: 'ACCESS_DENIED',\n\tid: '56f35758-7dd5-468b-8439-5d6fb8ec9b8e',\n};\n\nexport default async (endpoint: string, user: CacheableLocalUser | null | undefined, token: AccessToken | null | undefined, data: any, ctx?: Koa.Context) => {\n\tconst isSecure = user != null && token == null;\n\tconst isModerator = user != null && (user.isModerator || user.isAdmin);\n\n\tconst ep = endpoints.find(e => e.name === endpoint);\n\n\tif (ep == null) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'No such endpoint.',\n\t\t\tcode: 'NO_SUCH_ENDPOINT',\n\t\t\tid: 'f8080b67-5f9c-4eb7-8c18-7f1eeae8f709',\n\t\t\thttpStatusCode: 404,\n\t\t});\n\t}\n\n\tif (ep.meta.secure && !isSecure) {\n\t\tthrow new ApiError(accessDenied);\n\t}\n\n\tif (ep.meta.limit) {\n\t\t// koa will automatically load the `X-Forwarded-For` header if `proxy: true` is configured in the app.\n\t\tlet limitActor: string;\n\t\tif (user) {\n\t\t\tlimitActor = user.id;\n\t\t} else {\n\t\t\tlimitActor = getIpHash(ctx!.ip);\n\t\t}\n\n\t\tconst limit = Object.assign({}, ep.meta.limit);\n\n\t\tif (!limit.key) {\n\t\t\tlimit.key = ep.name;\n\t\t}\n\n\t\t// Rate limit\n\t\tawait limiter(limit as IEndpointMeta['limit'] & { key: NonNullable<string> }, limitActor).catch(e => {\n\t\t\tthrow new ApiError({\n\t\t\t\tmessage: 'Rate limit exceeded. Please try again later.',\n\t\t\t\tcode: 'RATE_LIMIT_EXCEEDED',\n\t\t\t\tid: 'd5826d14-3982-4d2e-8011-b9e9f02499ef',\n\t\t\t\thttpStatusCode: 429,\n\t\t\t});\n\t\t});\n\t}\n\n\tif (ep.meta.requireCredential && user == null) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'Credential required.',\n\t\t\tcode: 'CREDENTIAL_REQUIRED',\n\t\t\tid: '1384574d-a912-4b81-8601-c7b1c4085df1',\n\t\t\thttpStatusCode: 401,\n\t\t});\n\t}\n\n\tif (ep.meta.requireCredential && user!.isSuspended) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'Your account has been suspended.',\n\t\t\tcode: 'YOUR_ACCOUNT_SUSPENDED',\n\t\t\tid: 'a8c724b3-6e9c-4b46-b1a8-bc3ed6258370',\n\t\t\thttpStatusCode: 403,\n\t\t});\n\t}\n\n\tif (ep.meta.requireAdmin && !user!.isAdmin) {\n\t\tthrow new ApiError(accessDenied, { reason: 'You are not the admin.' });\n\t}\n\n\tif (ep.meta.requireModerator && !isModerator) {\n\t\tthrow new ApiError(accessDenied, { reason: 'You are not a moderator.' });\n\t}\n\n\tif (token && ep.meta.kind && !token.permission.some(p => p === ep.meta.kind)) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'Your app does not have the necessary permissions to use this endpoint.',\n\t\t\tcode: 'PERMISSION_DENIED',\n\t\t\tid: '1370e5b7-d4eb-4566-bb1d-7748ee6a1838',\n\t\t});\n\t}\n\n\t// Cast non JSON input\n\tif ((ep.meta.requireFile || ctx?.method === 'GET') && ep.params.properties) {\n\t\tfor (const k of Object.keys(ep.params.properties)) {\n\t\t\tconst param = ep.params.properties![k];\n\t\t\tif (['boolean', 'number', 'integer'].includes(param.type ?? '') && typeof data[k] === 'string') {\n\t\t\t\ttry {\n\t\t\t\t\tdata[k] = JSON.parse(data[k]);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow\tnew ApiError({\n\t\t\t\t\t\tmessage: 'Invalid param.',\n\t\t\t\t\t\tcode: 'INVALID_PARAM',\n\t\t\t\t\t\tid: '0b5f1631-7c1a-41a6-b399-cce335f34d85',\n\t\t\t\t\t}, {\n\t\t\t\t\t\tparam: k,\n\t\t\t\t\t\treason: `cannot cast to ${param.type}`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// API invoking\n\tconst before = performance.now();\n\treturn await ep.exec(data, user, token, ctx?.file, ctx?.ip, ctx?.headers).catch((e: Error) => {\n\t\tif (e instanceof ApiError) {\n\t\t\tthrow e;\n\t\t} else {\n\t\t\tapiLogger.error(`Internal error occurred in ${ep.name}: ${e.message}`, {\n\t\t\t\tep: ep.name,\n\t\t\t\tps: data,\n\t\t\t\te: {\n\t\t\t\t\tmessage: e.message,\n\t\t\t\t\tcode: e.name,\n\t\t\t\t\tstack: e.stack,\n\t\t\t\t},\n\t\t\t});\n\t\t\tthrow new ApiError(null, {\n\t\t\t\te: {\n\t\t\t\t\tmessage: e.message,\n\t\t\t\t\tcode: e.name,\n\t\t\t\t\tstack: e.stack,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}).finally(() => {\n\t\tconst after = performance.now();\n\t\tconst time = after - before;\n\t\tif (time > 1000) {\n\t\t\tapiLogger.warn(`SLOW API CALL DETECTED: ${ep.name} (${time}ms)`);\n\t\t}\n\t});\n};\n", "import define from '../../../define.js';\nimport { Users } from '@/models/index.js';\nimport { signup } from '../../../common/signup.js';\nimport { IsNull } from 'typeorm';\n\nexport const meta = {\n\ttags: ['admin'],\n\n\tres: {\n\t\ttype: 'object',\n\t\toptional: false, nullable: false,\n\t\tref: 'User',\n\t\tproperties: {\n\t\t\ttoken: {\n\t\t\t\ttype: 'string',\n\t\t\t\toptional: false, nullable: false,\n\t\t\t},\n\t\t},\n\t},\n} as const;\n\nexport const paramDef = {\n\ttype: 'object',\n\tproperties: {\n\t\tusername: Users.localUsernameSchema,\n\t\tpassword: Users.passwordSchema,\n\t},\n\trequired: ['username', 'password'],\n} as const;\n\n// eslint-disable-next-line import/no-default-export\nexport default define(meta, paramDef, async (ps, _me) => {\n\tconst me = _me ? await Users.findOneByOrFail({ id: _me.id }) : null;\n\tconst noUsers = (await Users.countBy({\n\t\thost: IsNull(),\n\t})) === 0;\n\tif (!noUsers && !me?.isAdmin) throw new Error('access denied');\n\n\tconst { account, secret } = await signup({\n\t\tusername: ps.username,\n\t\tpassword: ps.password,\n\t});\n\n\tconst res = await Users.pack(account, account, {\n\t\tdetail: true,\n\t\tincludeSecrets: true,\n\t});\n\n\t(res as any).token = secret;\n\n\treturn res;\n});\n"], "fixing_code": ["import { performance } from 'perf_hooks';\nimport Koa from 'koa';\nimport { CacheableLocalUser, User } from '@/models/entities/user.js';\nimport { AccessToken } from '@/models/entities/access-token.js';\nimport { getIpHash } from '@/misc/get-ip-hash.js';\nimport { limiter } from './limiter.js';\nimport endpoints, { IEndpointMeta } from './endpoints.js';\nimport { ApiError } from './error.js';\nimport { apiLogger } from './logger.js';\n\nconst accessDenied = {\n\tmessage: 'Access denied.',\n\tcode: 'ACCESS_DENIED',\n\tid: '56f35758-7dd5-468b-8439-5d6fb8ec9b8e',\n};\n\nexport default async (endpoint: string, user: CacheableLocalUser | null | undefined, token: AccessToken | null | undefined, data: any, ctx?: Koa.Context) => {\n\tconst isSecure = user != null && token == null;\n\tconst isModerator = user != null && (user.isModerator || user.isAdmin);\n\n\tconst ep = endpoints.find(e => e.name === endpoint);\n\n\tif (ep == null) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'No such endpoint.',\n\t\t\tcode: 'NO_SUCH_ENDPOINT',\n\t\t\tid: 'f8080b67-5f9c-4eb7-8c18-7f1eeae8f709',\n\t\t\thttpStatusCode: 404,\n\t\t});\n\t}\n\n\tif (ep.meta.secure && !isSecure) {\n\t\tthrow new ApiError(accessDenied);\n\t}\n\n\tif (ep.meta.limit) {\n\t\t// koa will automatically load the `X-Forwarded-For` header if `proxy: true` is configured in the app.\n\t\tlet limitActor: string;\n\t\tif (user) {\n\t\t\tlimitActor = user.id;\n\t\t} else {\n\t\t\tlimitActor = getIpHash(ctx!.ip);\n\t\t}\n\n\t\tconst limit = Object.assign({}, ep.meta.limit);\n\n\t\tif (!limit.key) {\n\t\t\tlimit.key = ep.name;\n\t\t}\n\n\t\t// Rate limit\n\t\tawait limiter(limit as IEndpointMeta['limit'] & { key: NonNullable<string> }, limitActor).catch(e => {\n\t\t\tthrow new ApiError({\n\t\t\t\tmessage: 'Rate limit exceeded. Please try again later.',\n\t\t\t\tcode: 'RATE_LIMIT_EXCEEDED',\n\t\t\t\tid: 'd5826d14-3982-4d2e-8011-b9e9f02499ef',\n\t\t\t\thttpStatusCode: 429,\n\t\t\t});\n\t\t});\n\t}\n\n\tif (ep.meta.requireCredential && user == null) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'Credential required.',\n\t\t\tcode: 'CREDENTIAL_REQUIRED',\n\t\t\tid: '1384574d-a912-4b81-8601-c7b1c4085df1',\n\t\t\thttpStatusCode: 401,\n\t\t});\n\t}\n\n\tif (ep.meta.requireCredential && user!.isSuspended) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'Your account has been suspended.',\n\t\t\tcode: 'YOUR_ACCOUNT_SUSPENDED',\n\t\t\tid: 'a8c724b3-6e9c-4b46-b1a8-bc3ed6258370',\n\t\t\thttpStatusCode: 403,\n\t\t});\n\t}\n\n\tif (ep.meta.requireAdmin && !user!.isAdmin) {\n\t\tthrow new ApiError(accessDenied, { reason: 'You are not the admin.' });\n\t}\n\n\tif (ep.meta.requireModerator && !isModerator) {\n\t\tthrow new ApiError(accessDenied, { reason: 'You are not a moderator.' });\n\t}\n\n\tif (token && ep.meta.kind && !token.permission.some(p => p === ep.meta.kind)) {\n\t\tthrow new ApiError({\n\t\t\tmessage: 'Your app does not have the necessary permissions to use this endpoint.',\n\t\t\tcode: 'PERMISSION_DENIED',\n\t\t\tid: '1370e5b7-d4eb-4566-bb1d-7748ee6a1838',\n\t\t});\n\t}\n\n\tif (token && ep.meta.requireAdmin) {\n\t\tthrow new ApiError(accessDenied, { reason: 'Apps cannot use admin privileges.' });\n\t}\n\n\tif (token && ep.meta.requireModerator) {\n\t\tthrow new ApiError(accessDenied, { reason: 'Apps cannot use moderator privileges.' });\n\t}\n\n\t// Cast non JSON input\n\tif ((ep.meta.requireFile || ctx?.method === 'GET') && ep.params.properties) {\n\t\tfor (const k of Object.keys(ep.params.properties)) {\n\t\t\tconst param = ep.params.properties![k];\n\t\t\tif (['boolean', 'number', 'integer'].includes(param.type ?? '') && typeof data[k] === 'string') {\n\t\t\t\ttry {\n\t\t\t\t\tdata[k] = JSON.parse(data[k]);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow\tnew ApiError({\n\t\t\t\t\t\tmessage: 'Invalid param.',\n\t\t\t\t\t\tcode: 'INVALID_PARAM',\n\t\t\t\t\t\tid: '0b5f1631-7c1a-41a6-b399-cce335f34d85',\n\t\t\t\t\t}, {\n\t\t\t\t\t\tparam: k,\n\t\t\t\t\t\treason: `cannot cast to ${param.type}`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// API invoking\n\tconst before = performance.now();\n\treturn await ep.exec(data, user, token, ctx?.file, ctx?.ip, ctx?.headers).catch((e: Error) => {\n\t\tif (e instanceof ApiError) {\n\t\t\tthrow e;\n\t\t} else {\n\t\t\tapiLogger.error(`Internal error occurred in ${ep.name}: ${e.message}`, {\n\t\t\t\tep: ep.name,\n\t\t\t\tps: data,\n\t\t\t\te: {\n\t\t\t\t\tmessage: e.message,\n\t\t\t\t\tcode: e.name,\n\t\t\t\t\tstack: e.stack,\n\t\t\t\t},\n\t\t\t});\n\t\t\tthrow new ApiError(null, {\n\t\t\t\te: {\n\t\t\t\t\tmessage: e.message,\n\t\t\t\t\tcode: e.name,\n\t\t\t\t\tstack: e.stack,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}).finally(() => {\n\t\tconst after = performance.now();\n\t\tconst time = after - before;\n\t\tif (time > 1000) {\n\t\t\tapiLogger.warn(`SLOW API CALL DETECTED: ${ep.name} (${time}ms)`);\n\t\t}\n\t});\n};\n", "import define from '../../../define.js';\nimport { Users } from '@/models/index.js';\nimport { signup } from '../../../common/signup.js';\nimport { IsNull } from 'typeorm';\n\nexport const meta = {\n\ttags: ['admin'],\n\n\tres: {\n\t\ttype: 'object',\n\t\toptional: false, nullable: false,\n\t\tref: 'User',\n\t\tproperties: {\n\t\t\ttoken: {\n\t\t\t\ttype: 'string',\n\t\t\t\toptional: false, nullable: false,\n\t\t\t},\n\t\t},\n\t},\n} as const;\n\nexport const paramDef = {\n\ttype: 'object',\n\tproperties: {\n\t\tusername: Users.localUsernameSchema,\n\t\tpassword: Users.passwordSchema,\n\t},\n\trequired: ['username', 'password'],\n} as const;\n\n// eslint-disable-next-line import/no-default-export\nexport default define(meta, paramDef, async (ps, _me, token) => {\n\tconst me = _me ? await Users.findOneByOrFail({ id: _me.id }) : null;\n\tconst noUsers = (await Users.countBy({\n\t\thost: IsNull(),\n\t})) === 0;\n\tif (!noUsers && !me?.isAdmin) throw new Error('access denied');\n\tif (token) throw new Error('access denied');\n\n\tconst { account, secret } = await signup({\n\t\tusername: ps.username,\n\t\tpassword: ps.password,\n\t});\n\n\tconst res = await Users.pack(account, account, {\n\t\tdetail: true,\n\t\tincludeSecrets: true,\n\t});\n\n\t(res as any).token = secret;\n\n\treturn res;\n});\n"], "filenames": ["packages/backend/src/server/api/call.ts", "packages/backend/src/server/api/endpoints/admin/accounts/create.ts"], "buggy_code_start_loc": [95, 32], "buggy_code_end_loc": [95, 37], "fixing_code_start_loc": [96, 32], "fixing_code_end_loc": [104, 39], "type": "CWE-863", "message": "Nexkey is a lightweight fork of Misskey v12 optimized for small to medium size servers. Prior to 12.23Q4.5, Nexkey allows external apps using tokens issued by administrators and moderators to call admin APIs.  This allows malicious third-party apps to perform operations such as updating server settings, as well as compromise object storage and email server credentials. This issue has been patched in 12.23Q4.5.", "other": {"cve": {"id": "CVE-2023-52077", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-27T19:15:07.763", "lastModified": "2024-01-04T23:11:39.740", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nexkey is a lightweight fork of Misskey v12 optimized for small to medium size servers. Prior to 12.23Q4.5, Nexkey allows external apps using tokens issued by administrators and moderators to call admin APIs.  This allows malicious third-party apps to perform operations such as updating server settings, as well as compromise object storage and email server credentials. This issue has been patched in 12.23Q4.5."}, {"lang": "es", "value": "Nexkey es una bifurcaci\u00f3n liviana de Misskey v12 optimizada para servidores de tama\u00f1o peque\u00f1o y mediano. Antes de 12.23Q4.5, Nexkey permit\u00eda que aplicaciones externas que utilizaran tokens emitidos por administradores y moderadores llamaran a las API de administraci\u00f3n. Esto permite que aplicaciones maliciosas de terceros realicen operaciones como actualizar la configuraci\u00f3n del servidor, as\u00ed como comprometer el almacenamiento de objetos y las credenciales del servidor de correo electr\u00f3nico. Este problema se solucion\u00f3 en 12.23Q4.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nexryai:nexkey:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "12.23q4.5", "matchCriteriaId": "FC7AC948-828A-4C9A-9010-FC8BBFDBCFC5"}]}]}], "references": [{"url": "https://github.com/mei23/misskey-v12/commit/78173e376f14fcc1987b02196f5538bf5b18225c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/misskey-dev/misskey/commit/5150053275594278e9eb23e72d98b16593c4c230", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nexryai/nexkey/commit/a4e4c9c47c5f84ec7ccd309bde59d4ae5d7e5a98", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nexryai/nexkey/security/advisories/GHSA-pjj7-7hcj-9cpc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mei23/misskey-v12/commit/78173e376f14fcc1987b02196f5538bf5b18225c"}}