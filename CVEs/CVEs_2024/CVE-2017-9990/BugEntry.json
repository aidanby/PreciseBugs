{"buggy_code": ["/*\n * XPM image format\n *\n * Copyright (c) 2012 Paul B Mahol\n * Copyright (c) 2017 Paras Chadha\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/avstring.h\"\n#include \"avcodec.h\"\n#include \"internal.h\"\n\ntypedef struct XPMContext {\n    uint32_t  *pixels;\n    int        pixels_size;\n} XPMDecContext;\n\ntypedef struct ColorEntry {\n    const char *name;         ///< a string representing the name of the color\n    uint32_t    rgb_color;    ///< RGB values for the color\n} ColorEntry;\n\nstatic int color_table_compare(const void *lhs, const void *rhs)\n{\n    return av_strcasecmp(lhs, ((const ColorEntry *)rhs)->name);\n}\n\nstatic const ColorEntry color_table[] = {\n    { \"AliceBlue\",            0xFFF0F8FF },\n    { \"AntiqueWhite\",         0xFFFAEBD7 },\n    { \"Aqua\",                 0xFF00FFFF },\n    { \"Aquamarine\",           0xFF7FFFD4 },\n    { \"Azure\",                0xFFF0FFFF },\n    { \"Beige\",                0xFFF5F5DC },\n    { \"Bisque\",               0xFFFFE4C4 },\n    { \"Black\",                0xFF000000 },\n    { \"BlanchedAlmond\",       0xFFFFEBCD },\n    { \"Blue\",                 0xFF0000FF },\n    { \"BlueViolet\",           0xFF8A2BE2 },\n    { \"Brown\",                0xFFA52A2A },\n    { \"BurlyWood\",            0xFFDEB887 },\n    { \"CadetBlue\",            0xFF5F9EA0 },\n    { \"Chartreuse\",           0xFF7FFF00 },\n    { \"Chocolate\",            0xFFD2691E },\n    { \"Coral\",                0xFFFF7F50 },\n    { \"CornflowerBlue\",       0xFF6495ED },\n    { \"Cornsilk\",             0xFFFFF8DC },\n    { \"Crimson\",              0xFFDC143C },\n    { \"Cyan\",                 0xFF00FFFF },\n    { \"DarkBlue\",             0xFF00008B },\n    { \"DarkCyan\",             0xFF008B8B },\n    { \"DarkGoldenRod\",        0xFFB8860B },\n    { \"DarkGray\",             0xFFA9A9A9 },\n    { \"DarkGreen\",            0xFF006400 },\n    { \"DarkKhaki\",            0xFFBDB76B },\n    { \"DarkMagenta\",          0xFF8B008B },\n    { \"DarkOliveGreen\",       0xFF556B2F },\n    { \"Darkorange\",           0xFFFF8C00 },\n    { \"DarkOrchid\",           0xFF9932CC },\n    { \"DarkRed\",              0xFF8B0000 },\n    { \"DarkSalmon\",           0xFFE9967A },\n    { \"DarkSeaGreen\",         0xFF8FBC8F },\n    { \"DarkSlateBlue\",        0xFF483D8B },\n    { \"DarkSlateGray\",        0xFF2F4F4F },\n    { \"DarkTurquoise\",        0xFF00CED1 },\n    { \"DarkViolet\",           0xFF9400D3 },\n    { \"DeepPink\",             0xFFFF1493 },\n    { \"DeepSkyBlue\",          0xFF00BFFF },\n    { \"DimGray\",              0xFF696969 },\n    { \"DodgerBlue\",           0xFF1E90FF },\n    { \"FireBrick\",            0xFFB22222 },\n    { \"FloralWhite\",          0xFFFFFAF0 },\n    { \"ForestGreen\",          0xFF228B22 },\n    { \"Fuchsia\",              0xFFFF00FF },\n    { \"Gainsboro\",            0xFFDCDCDC },\n    { \"GhostWhite\",           0xFFF8F8FF },\n    { \"Gold\",                 0xFFFFD700 },\n    { \"GoldenRod\",            0xFFDAA520 },\n    { \"Gray\",                 0xFFBEBEBE },\n    { \"Green\",                0xFF00FF00 },\n    { \"GreenYellow\",          0xFFADFF2F },\n    { \"HoneyDew\",             0xFFF0FFF0 },\n    { \"HotPink\",              0xFFFF69B4 },\n    { \"IndianRed\",            0xFFCD5C5C },\n    { \"Indigo\",               0xFF4B0082 },\n    { \"Ivory\",                0xFFFFFFF0 },\n    { \"Khaki\",                0xFFF0E68C },\n    { \"Lavender\",             0xFFE6E6FA },\n    { \"LavenderBlush\",        0xFFFFF0F5 },\n    { \"LawnGreen\",            0xFF7CFC00 },\n    { \"LemonChiffon\",         0xFFFFFACD },\n    { \"LightBlue\",            0xFFADD8E6 },\n    { \"LightCoral\",           0xFFF08080 },\n    { \"LightCyan\",            0xFFE0FFFF },\n    { \"LightGoldenRodYellow\", 0xFFFAFAD2 },\n    { \"LightGreen\",           0xFF90EE90 },\n    { \"LightGrey\",            0xFFD3D3D3 },\n    { \"LightPink\",            0xFFFFB6C1 },\n    { \"LightSalmon\",          0xFFFFA07A },\n    { \"LightSeaGreen\",        0xFF20B2AA },\n    { \"LightSkyBlue\",         0xFF87CEFA },\n    { \"LightSlateGray\",       0xFF778899 },\n    { \"LightSteelBlue\",       0xFFB0C4DE },\n    { \"LightYellow\",          0xFFFFFFE0 },\n    { \"Lime\",                 0xFF00FF00 },\n    { \"LimeGreen\",            0xFF32CD32 },\n    { \"Linen\",                0xFFFAF0E6 },\n    { \"Magenta\",              0xFFFF00FF },\n    { \"Maroon\",               0xFFB03060 },\n    { \"MediumAquaMarine\",     0xFF66CDAA },\n    { \"MediumBlue\",           0xFF0000CD },\n    { \"MediumOrchid\",         0xFFBA55D3 },\n    { \"MediumPurple\",         0xFF9370D8 },\n    { \"MediumSeaGreen\",       0xFF3CB371 },\n    { \"MediumSlateBlue\",      0xFF7B68EE },\n    { \"MediumSpringGreen\",    0xFF00FA9A },\n    { \"MediumTurquoise\",      0xFF48D1CC },\n    { \"MediumVioletRed\",      0xFFC71585 },\n    { \"MidnightBlue\",         0xFF191970 },\n    { \"MintCream\",            0xFFF5FFFA },\n    { \"MistyRose\",            0xFFFFE4E1 },\n    { \"Moccasin\",             0xFFFFE4B5 },\n    { \"NavajoWhite\",          0xFFFFDEAD },\n    { \"Navy\",                 0xFF000080 },\n    { \"None\",                 0x00000000 },\n    { \"OldLace\",              0xFFFDF5E6 },\n    { \"Olive\",                0xFF808000 },\n    { \"OliveDrab\",            0xFF6B8E23 },\n    { \"Orange\",               0xFFFFA500 },\n    { \"OrangeRed\",            0xFFFF4500 },\n    { \"Orchid\",               0xFFDA70D6 },\n    { \"PaleGoldenRod\",        0xFFEEE8AA },\n    { \"PaleGreen\",            0xFF98FB98 },\n    { \"PaleTurquoise\",        0xFFAFEEEE },\n    { \"PaleVioletRed\",        0xFFD87093 },\n    { \"PapayaWhip\",           0xFFFFEFD5 },\n    { \"PeachPuff\",            0xFFFFDAB9 },\n    { \"Peru\",                 0xFFCD853F },\n    { \"Pink\",                 0xFFFFC0CB },\n    { \"Plum\",                 0xFFDDA0DD },\n    { \"PowderBlue\",           0xFFB0E0E6 },\n    { \"Purple\",               0xFFA020F0 },\n    { \"Red\",                  0xFFFF0000 },\n    { \"RosyBrown\",            0xFFBC8F8F },\n    { \"RoyalBlue\",            0xFF4169E1 },\n    { \"SaddleBrown\",          0xFF8B4513 },\n    { \"Salmon\",               0xFFFA8072 },\n    { \"SandyBrown\",           0xFFF4A460 },\n    { \"SeaGreen\",             0xFF2E8B57 },\n    { \"SeaShell\",             0xFFFFF5EE },\n    { \"Sienna\",               0xFFA0522D },\n    { \"Silver\",               0xFFC0C0C0 },\n    { \"SkyBlue\",              0xFF87CEEB },\n    { \"SlateBlue\",            0xFF6A5ACD },\n    { \"SlateGray\",            0xFF708090 },\n    { \"Snow\",                 0xFFFFFAFA },\n    { \"SpringGreen\",          0xFF00FF7F },\n    { \"SteelBlue\",            0xFF4682B4 },\n    { \"Tan\",                  0xFFD2B48C },\n    { \"Teal\",                 0xFF008080 },\n    { \"Thistle\",              0xFFD8BFD8 },\n    { \"Tomato\",               0xFFFF6347 },\n    { \"Turquoise\",            0xFF40E0D0 },\n    { \"Violet\",               0xFFEE82EE },\n    { \"Wheat\",                0xFFF5DEB3 },\n    { \"White\",                0xFFFFFFFF },\n    { \"WhiteSmoke\",           0xFFF5F5F5 },\n    { \"Yellow\",               0xFFFFFF00 },\n    { \"YellowGreen\",          0xFF9ACD32 }\n};\n\nstatic unsigned hex_char_to_number(uint8_t x)\n{\n    if (x >= 'a' && x <= 'f')\n        x -= 'a' - 10;\n    else if (x >= 'A' && x <= 'F')\n        x -= 'A' - 10;\n    else if (x >= '0' && x <= '9')\n        x -= '0';\n    else\n        x = 0;\n    return x;\n}\n\n/*\n * Function same as strcspn but ignores characters if they are inside a C style comments\n */\nstatic size_t mod_strcspn(const char *string, const char *reject)\n{\n    int i, j;\n\n    for (i = 0; string && string[i]; i++) {\n        if (string[i] == '/' && string[i+1] == '*') {\n            i += 2;\n            while ( string && string[i] && (string[i] != '*' || string[i+1] != '/') )\n                i++;\n            i++;\n        } else if (string[i] == '/' && string[i+1] == '/') {\n            i += 2;\n            while ( string && string[i] && string[i] != '\\n' )\n                i++;\n        } else {\n            for (j = 0; reject && reject[j]; j++) {\n                if (string[i] == reject[j])\n                    break;\n            }\n            if (reject && reject[j])\n                break;\n        }\n    }\n    return i;\n}\n\nstatic uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n    const ColorEntry *entry;\n    char color_name[100];\n\n    if (*p == '#') {\n        p++;\n        len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n\n        if (!entry)\n            return ret;\n\n        ret = entry->rgb_color;\n    }\n    return ret;\n}\n\nstatic int ascii2index(const uint8_t *cpixel, int cpp)\n{\n    const uint8_t *p = cpixel;\n    int n = 0, m = 1, i;\n\n    for (i = 0; i < cpp; i++) {\n        if (*p < ' ' || *p > '~')\n            return AVERROR_INVALIDDATA;\n        n += (*p++ - ' ') * m;\n        m *= 95;\n    }\n    return n;\n}\n\nstatic int xpm_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    XPMDecContext *x = avctx->priv_data;\n    AVFrame *p=data;\n    const uint8_t *end, *ptr = avpkt->data;\n    int ncolors, cpp, ret, i, j;\n    int64_t size;\n    uint32_t *dst;\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n    end = avpkt->data + avpkt->size;\n    while (memcmp(ptr, \"/* XPM */\", 9) && ptr < end - 9)\n        ptr++;\n\n    if (ptr >= end) {\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n        return ret;\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n\n    if (cpp <= 0 || cpp >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = 1;\n    for (i = 0; i < cpp; i++)\n        size *= 94;\n\n    if (ncolors <= 0 || ncolors > size) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size *= 4;\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n    if (!x->pixels)\n        return AVERROR(ENOMEM);\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n    for (i = 0; i < ncolors; i++) {\n        const uint8_t *index;\n        int len;\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n        if (ptr + cpp > end)\n            return AVERROR_INVALIDDATA;\n        index = ptr;\n        ptr += cpp;\n\n        ptr = strstr(ptr, \"c \");\n        if (ptr) {\n            ptr += 2;\n        } else {\n            return AVERROR_INVALIDDATA;\n        }\n\n        len = strcspn(ptr, \"\\\" \");\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n            return ret;\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n        ptr += mod_strcspn(ptr, \",\") + 1;\n    }\n\n    for (i = 0; i < avctx->height; i++) {\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        for (j = 0; j < avctx->width; j++) {\n            if (ptr + cpp > end)\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n                return ret;\n\n            *dst++ = x->pixels[ret];\n            ptr += cpp;\n        }\n        ptr += mod_strcspn(ptr, \",\") + 1;\n    }\n\n    p->key_frame = 1;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n    XPMDecContext *x = avctx->priv_data;\n    av_freep(&x->pixels);\n\n    return 0;\n}\n\nAVCodec ff_xpm_decoder = {\n    .name           = \"xpm\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_XPM,\n    .priv_data_size = sizeof(XPMDecContext),\n    .close          = xpm_decode_close,\n    .decode         = xpm_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n    .long_name      = NULL_IF_CONFIG_SMALL(\"XPM (X PixMap) image\")\n};\n"], "fixing_code": ["/*\n * XPM image format\n *\n * Copyright (c) 2012 Paul B Mahol\n * Copyright (c) 2017 Paras Chadha\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/parseutils.h\"\n#include \"libavutil/avstring.h\"\n#include \"avcodec.h\"\n#include \"internal.h\"\n\ntypedef struct XPMContext {\n    uint32_t  *pixels;\n    int        pixels_size;\n    uint8_t   *buf;\n    int        buf_size;\n} XPMDecContext;\n\ntypedef struct ColorEntry {\n    const char *name;         ///< a string representing the name of the color\n    uint32_t    rgb_color;    ///< RGB values for the color\n} ColorEntry;\n\nstatic int color_table_compare(const void *lhs, const void *rhs)\n{\n    return av_strcasecmp(lhs, ((const ColorEntry *)rhs)->name);\n}\n\nstatic const ColorEntry color_table[] = {\n    { \"AliceBlue\",            0xFFF0F8FF },\n    { \"AntiqueWhite\",         0xFFFAEBD7 },\n    { \"Aqua\",                 0xFF00FFFF },\n    { \"Aquamarine\",           0xFF7FFFD4 },\n    { \"Azure\",                0xFFF0FFFF },\n    { \"Beige\",                0xFFF5F5DC },\n    { \"Bisque\",               0xFFFFE4C4 },\n    { \"Black\",                0xFF000000 },\n    { \"BlanchedAlmond\",       0xFFFFEBCD },\n    { \"Blue\",                 0xFF0000FF },\n    { \"BlueViolet\",           0xFF8A2BE2 },\n    { \"Brown\",                0xFFA52A2A },\n    { \"BurlyWood\",            0xFFDEB887 },\n    { \"CadetBlue\",            0xFF5F9EA0 },\n    { \"Chartreuse\",           0xFF7FFF00 },\n    { \"Chocolate\",            0xFFD2691E },\n    { \"Coral\",                0xFFFF7F50 },\n    { \"CornflowerBlue\",       0xFF6495ED },\n    { \"Cornsilk\",             0xFFFFF8DC },\n    { \"Crimson\",              0xFFDC143C },\n    { \"Cyan\",                 0xFF00FFFF },\n    { \"DarkBlue\",             0xFF00008B },\n    { \"DarkCyan\",             0xFF008B8B },\n    { \"DarkGoldenRod\",        0xFFB8860B },\n    { \"DarkGray\",             0xFFA9A9A9 },\n    { \"DarkGreen\",            0xFF006400 },\n    { \"DarkKhaki\",            0xFFBDB76B },\n    { \"DarkMagenta\",          0xFF8B008B },\n    { \"DarkOliveGreen\",       0xFF556B2F },\n    { \"Darkorange\",           0xFFFF8C00 },\n    { \"DarkOrchid\",           0xFF9932CC },\n    { \"DarkRed\",              0xFF8B0000 },\n    { \"DarkSalmon\",           0xFFE9967A },\n    { \"DarkSeaGreen\",         0xFF8FBC8F },\n    { \"DarkSlateBlue\",        0xFF483D8B },\n    { \"DarkSlateGray\",        0xFF2F4F4F },\n    { \"DarkTurquoise\",        0xFF00CED1 },\n    { \"DarkViolet\",           0xFF9400D3 },\n    { \"DeepPink\",             0xFFFF1493 },\n    { \"DeepSkyBlue\",          0xFF00BFFF },\n    { \"DimGray\",              0xFF696969 },\n    { \"DodgerBlue\",           0xFF1E90FF },\n    { \"FireBrick\",            0xFFB22222 },\n    { \"FloralWhite\",          0xFFFFFAF0 },\n    { \"ForestGreen\",          0xFF228B22 },\n    { \"Fuchsia\",              0xFFFF00FF },\n    { \"Gainsboro\",            0xFFDCDCDC },\n    { \"GhostWhite\",           0xFFF8F8FF },\n    { \"Gold\",                 0xFFFFD700 },\n    { \"GoldenRod\",            0xFFDAA520 },\n    { \"Gray\",                 0xFFBEBEBE },\n    { \"Green\",                0xFF00FF00 },\n    { \"GreenYellow\",          0xFFADFF2F },\n    { \"HoneyDew\",             0xFFF0FFF0 },\n    { \"HotPink\",              0xFFFF69B4 },\n    { \"IndianRed\",            0xFFCD5C5C },\n    { \"Indigo\",               0xFF4B0082 },\n    { \"Ivory\",                0xFFFFFFF0 },\n    { \"Khaki\",                0xFFF0E68C },\n    { \"Lavender\",             0xFFE6E6FA },\n    { \"LavenderBlush\",        0xFFFFF0F5 },\n    { \"LawnGreen\",            0xFF7CFC00 },\n    { \"LemonChiffon\",         0xFFFFFACD },\n    { \"LightBlue\",            0xFFADD8E6 },\n    { \"LightCoral\",           0xFFF08080 },\n    { \"LightCyan\",            0xFFE0FFFF },\n    { \"LightGoldenRodYellow\", 0xFFFAFAD2 },\n    { \"LightGreen\",           0xFF90EE90 },\n    { \"LightGrey\",            0xFFD3D3D3 },\n    { \"LightPink\",            0xFFFFB6C1 },\n    { \"LightSalmon\",          0xFFFFA07A },\n    { \"LightSeaGreen\",        0xFF20B2AA },\n    { \"LightSkyBlue\",         0xFF87CEFA },\n    { \"LightSlateGray\",       0xFF778899 },\n    { \"LightSteelBlue\",       0xFFB0C4DE },\n    { \"LightYellow\",          0xFFFFFFE0 },\n    { \"Lime\",                 0xFF00FF00 },\n    { \"LimeGreen\",            0xFF32CD32 },\n    { \"Linen\",                0xFFFAF0E6 },\n    { \"Magenta\",              0xFFFF00FF },\n    { \"Maroon\",               0xFFB03060 },\n    { \"MediumAquaMarine\",     0xFF66CDAA },\n    { \"MediumBlue\",           0xFF0000CD },\n    { \"MediumOrchid\",         0xFFBA55D3 },\n    { \"MediumPurple\",         0xFF9370D8 },\n    { \"MediumSeaGreen\",       0xFF3CB371 },\n    { \"MediumSlateBlue\",      0xFF7B68EE },\n    { \"MediumSpringGreen\",    0xFF00FA9A },\n    { \"MediumTurquoise\",      0xFF48D1CC },\n    { \"MediumVioletRed\",      0xFFC71585 },\n    { \"MidnightBlue\",         0xFF191970 },\n    { \"MintCream\",            0xFFF5FFFA },\n    { \"MistyRose\",            0xFFFFE4E1 },\n    { \"Moccasin\",             0xFFFFE4B5 },\n    { \"NavajoWhite\",          0xFFFFDEAD },\n    { \"Navy\",                 0xFF000080 },\n    { \"None\",                 0x00000000 },\n    { \"OldLace\",              0xFFFDF5E6 },\n    { \"Olive\",                0xFF808000 },\n    { \"OliveDrab\",            0xFF6B8E23 },\n    { \"Orange\",               0xFFFFA500 },\n    { \"OrangeRed\",            0xFFFF4500 },\n    { \"Orchid\",               0xFFDA70D6 },\n    { \"PaleGoldenRod\",        0xFFEEE8AA },\n    { \"PaleGreen\",            0xFF98FB98 },\n    { \"PaleTurquoise\",        0xFFAFEEEE },\n    { \"PaleVioletRed\",        0xFFD87093 },\n    { \"PapayaWhip\",           0xFFFFEFD5 },\n    { \"PeachPuff\",            0xFFFFDAB9 },\n    { \"Peru\",                 0xFFCD853F },\n    { \"Pink\",                 0xFFFFC0CB },\n    { \"Plum\",                 0xFFDDA0DD },\n    { \"PowderBlue\",           0xFFB0E0E6 },\n    { \"Purple\",               0xFFA020F0 },\n    { \"Red\",                  0xFFFF0000 },\n    { \"RosyBrown\",            0xFFBC8F8F },\n    { \"RoyalBlue\",            0xFF4169E1 },\n    { \"SaddleBrown\",          0xFF8B4513 },\n    { \"Salmon\",               0xFFFA8072 },\n    { \"SandyBrown\",           0xFFF4A460 },\n    { \"SeaGreen\",             0xFF2E8B57 },\n    { \"SeaShell\",             0xFFFFF5EE },\n    { \"Sienna\",               0xFFA0522D },\n    { \"Silver\",               0xFFC0C0C0 },\n    { \"SkyBlue\",              0xFF87CEEB },\n    { \"SlateBlue\",            0xFF6A5ACD },\n    { \"SlateGray\",            0xFF708090 },\n    { \"Snow\",                 0xFFFFFAFA },\n    { \"SpringGreen\",          0xFF00FF7F },\n    { \"SteelBlue\",            0xFF4682B4 },\n    { \"Tan\",                  0xFFD2B48C },\n    { \"Teal\",                 0xFF008080 },\n    { \"Thistle\",              0xFFD8BFD8 },\n    { \"Tomato\",               0xFFFF6347 },\n    { \"Turquoise\",            0xFF40E0D0 },\n    { \"Violet\",               0xFFEE82EE },\n    { \"Wheat\",                0xFFF5DEB3 },\n    { \"White\",                0xFFFFFFFF },\n    { \"WhiteSmoke\",           0xFFF5F5F5 },\n    { \"Yellow\",               0xFFFFFF00 },\n    { \"YellowGreen\",          0xFF9ACD32 }\n};\n\nstatic unsigned hex_char_to_number(uint8_t x)\n{\n    if (x >= 'a' && x <= 'f')\n        x -= 'a' - 10;\n    else if (x >= 'A' && x <= 'F')\n        x -= 'A' - 10;\n    else if (x >= '0' && x <= '9')\n        x -= '0';\n    else\n        x = 0;\n    return x;\n}\n\n/*\n * Function same as strcspn but ignores characters if they are inside a C style comments\n */\nstatic size_t mod_strcspn(const char *string, const char *reject)\n{\n    int i, j;\n\n    for (i = 0; string && string[i]; i++) {\n        if (string[i] == '/' && string[i+1] == '*') {\n            i += 2;\n            while ( string && string[i] && (string[i] != '*' || string[i+1] != '/') )\n                i++;\n            i++;\n        } else if (string[i] == '/' && string[i+1] == '/') {\n            i += 2;\n            while ( string && string[i] && string[i] != '\\n' )\n                i++;\n        } else {\n            for (j = 0; reject && reject[j]; j++) {\n                if (string[i] == reject[j])\n                    break;\n            }\n            if (reject && reject[j])\n                break;\n        }\n    }\n    return i;\n}\n\nstatic uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n    const ColorEntry *entry;\n    char color_name[100];\n\n    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);\n\n    if (*p == '#') {\n        p++;\n        len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n\n        if (!entry)\n            return ret;\n\n        ret = entry->rgb_color;\n    }\n    return ret;\n}\n\nstatic int ascii2index(const uint8_t *cpixel, int cpp)\n{\n    const uint8_t *p = cpixel;\n    int n = 0, m = 1, i;\n\n    for (i = 0; i < cpp; i++) {\n        if (*p < ' ' || *p > '~')\n            return AVERROR_INVALIDDATA;\n        n += (*p++ - ' ') * m;\n        m *= 95;\n    }\n    return n;\n}\n\nstatic int xpm_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    XPMDecContext *x = avctx->priv_data;\n    AVFrame *p=data;\n    const uint8_t *end, *ptr;\n    int ncolors, cpp, ret, i, j;\n    int64_t size;\n    uint32_t *dst;\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n    av_fast_padded_malloc(&x->buf, &x->buf_size, avpkt->size);\n    if (!x->buf)\n        return AVERROR(ENOMEM);\n    memcpy(x->buf, avpkt->data, avpkt->size);\n    x->buf[avpkt->size] = 0;\n\n    ptr = x->buf;\n    end = x->buf + avpkt->size;\n    while (end - ptr > 9 && memcmp(ptr, \"/* XPM */\", 9))\n        ptr++;\n\n    if (end - ptr <= 9) {\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n        return ret;\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n\n    if (cpp <= 0 || cpp >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = 1;\n    for (i = 0; i < cpp; i++)\n        size *= 95;\n\n    if (ncolors <= 0 || ncolors > size) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n        return AVERROR_INVALIDDATA;\n    }\n\n    size *= 4;\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n    if (!x->pixels)\n        return AVERROR(ENOMEM);\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n    if (end - ptr < 1)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < ncolors; i++) {\n        const uint8_t *index;\n        int len;\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n        if (end - ptr < cpp)\n            return AVERROR_INVALIDDATA;\n        index = ptr;\n        ptr += cpp;\n\n        ptr = strstr(ptr, \"c \");\n        if (ptr) {\n            ptr += 2;\n        } else {\n            return AVERROR_INVALIDDATA;\n        }\n\n        len = strcspn(ptr, \"\\\" \");\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n            return ret;\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n        ptr += mod_strcspn(ptr, \",\") + 1;\n        if (end - ptr < 1)\n            return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < avctx->height; i++) {\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n        if (end - ptr < 1)\n            return AVERROR_INVALIDDATA;\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n        if (end - ptr < 1)\n            return AVERROR_INVALIDDATA;\n\n        for (j = 0; j < avctx->width; j++) {\n            if (end - ptr < cpp)\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n                return ret;\n\n            *dst++ = x->pixels[ret];\n            ptr += cpp;\n        }\n        ptr += mod_strcspn(ptr, \",\") + 1;\n    }\n\n    p->key_frame = 1;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}\n\nstatic av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n    XPMDecContext *x = avctx->priv_data;\n    av_freep(&x->pixels);\n\n    av_freep(&x->buf);\n    x->buf_size = 0;\n\n    return 0;\n}\n\nAVCodec ff_xpm_decoder = {\n    .name           = \"xpm\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_XPM,\n    .priv_data_size = sizeof(XPMDecContext),\n    .close          = xpm_decode_close,\n    .decode         = xpm_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n    .long_name      = NULL_IF_CONFIG_SMALL(\"XPM (X PixMap) image\")\n};\n"], "filenames": ["libavcodec/xpmdec.c"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [406], "fixing_code_start_loc": [32], "fixing_code_end_loc": [430], "type": "CWE-119", "message": "Stack-based buffer overflow in the color_string_to_rgba function in libavcodec/xpmdec.c in FFmpeg 3.3 before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.", "other": {"cve": {"id": "CVE-2017-9990", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-28T06:29:00.427", "lastModified": "2017-07-05T17:30:14.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the color_string_to_rgba function in libavcodec/xpmdec.c in FFmpeg 3.3 before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file."}, {"lang": "es", "value": "Buffer overflow basado en pila -stack- en la funci\u00f3n color_string_to_rgba en el archivo libavcodec/xpmdec.c en Ffmpeg 3.3.x en sus versiones anteriores a la 3.3.1 permite a un atacante remoto causar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) u otro posible impacto no especificado mediante la manipulaci\u00f3n del archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3", "matchCriteriaId": "810187F9-9AC0-4D97-9298-DEFC64008A6F"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/99313", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1466", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/cb243972b121b1ae6b60a78ff55a0506c69f3879", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/cb243972b121b1ae6b60a78ff55a0506c69f3879"}}