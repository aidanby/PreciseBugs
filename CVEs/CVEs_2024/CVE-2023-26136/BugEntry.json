{"buggy_code": ["/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\nconst { fromCallback } = require(\"universalify\");\nconst Store = require(\"./store\").Store;\nconst permuteDomain = require(\"./permuteDomain\").permuteDomain;\nconst pathMatch = require(\"./pathMatch\").pathMatch;\nconst { getCustomInspectSymbol, getUtilInspect } = require(\"./utilHelper\");\n\nclass MemoryCookieStore extends Store {\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = {};\n    const customInspectSymbol = getCustomInspectSymbol();\n    if (customInspectSymbol) {\n      this[customInspectSymbol] = this.inspect;\n    }\n  }\n\n  inspect() {\n    const util = { inspect: getUtilInspect(inspectFallback) };\n    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;\n  }\n\n  findCookie(domain, path, key, cb) {\n    if (!this.idx[domain]) {\n      return cb(null, undefined);\n    }\n    if (!this.idx[domain][path]) {\n      return cb(null, undefined);\n    }\n    return cb(null, this.idx[domain][path][key] || null);\n  }\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    const results = [];\n    if (typeof allowSpecialUseDomain === \"function\") {\n      cb = allowSpecialUseDomain;\n      allowSpecialUseDomain = true;\n    }\n    if (!domain) {\n      return cb(null, []);\n    }\n\n    let pathMatcher;\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        Object.keys(domainIndex).forEach(cookiePath => {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        });\n      };\n    }\n\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n\n    cb(null, results);\n  }\n\n  putCookie(cookie, cb) {\n    if (!this.idx[cookie.domain]) {\n      this.idx[cookie.domain] = {};\n    }\n    if (!this.idx[cookie.domain][cookie.path]) {\n      this.idx[cookie.domain][cookie.path] = {};\n    }\n    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n    cb(null);\n  }\n  updateCookie(oldCookie, newCookie, cb) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    this.putCookie(newCookie, cb);\n  }\n  removeCookie(domain, path, key, cb) {\n    if (\n      this.idx[domain] &&\n      this.idx[domain][path] &&\n      this.idx[domain][path][key]\n    ) {\n      delete this.idx[domain][path][key];\n    }\n    cb(null);\n  }\n  removeCookies(domain, path, cb) {\n    if (this.idx[domain]) {\n      if (path) {\n        delete this.idx[domain][path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n    return cb(null);\n  }\n  removeAllCookies(cb) {\n    this.idx = {};\n    return cb(null);\n  }\n  getAllCookies(cb) {\n    const cookies = [];\n    const idx = this.idx;\n\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const paths = Object.keys(idx[domain]);\n      paths.forEach(path => {\n        const keys = Object.keys(idx[domain][path]);\n        keys.forEach(key => {\n          if (key !== null) {\n            cookies.push(idx[domain][path][key]);\n          }\n        });\n      });\n    });\n\n    // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n\n    cb(null, cookies);\n  }\n}\n\n[\n  \"findCookie\",\n  \"findCookies\",\n  \"putCookie\",\n  \"updateCookie\",\n  \"removeCookie\",\n  \"removeCookies\",\n  \"removeAllCookies\",\n  \"getAllCookies\"\n].forEach(name => {\n  MemoryCookieStore.prototype[name] = fromCallback(\n    MemoryCookieStore.prototype[name]\n  );\n});\n\nexports.MemoryCookieStore = MemoryCookieStore;\n\nfunction inspectFallback(val) {\n  const domains = Object.keys(val);\n  if (domains.length === 0) {\n    return \"{}\";\n  }\n  let result = \"{\\n\";\n  Object.keys(val).forEach((domain, i) => {\n    result += formatDomain(domain, val[domain]);\n    if (i < domains.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += \"}\";\n  return result;\n}\n\nfunction formatDomain(domainName, domainValue) {\n  const indent = \"  \";\n  let result = `${indent}'${domainName}': {\\n`;\n  Object.keys(domainValue).forEach((path, i, paths) => {\n    result += formatPath(path, domainValue[path]);\n    if (i < paths.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nfunction formatPath(pathName, pathValue) {\n  const indent = \"    \";\n  let result = `${indent}'${pathName}': {\\n`;\n  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {\n    const cookie = pathValue[cookieName];\n    result += `      ${cookieName}: ${cookie.inspect()}`;\n    if (i < cookieNames.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nexports.inspectFallback = inspectFallback;\n", "/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\nconst vows = require(\"vows\");\nconst assert = require(\"assert\");\nconst async = require(\"async\");\nconst tough = require(\"../lib/cookie\");\nconst Cookie = tough.Cookie;\nconst CookieJar = tough.CookieJar;\n\nconst atNow = Date.now();\n\nfunction at(offset) {\n  return { now: new Date(atNow + offset) };\n}\n\nvows\n  .describe(\"CookieJar\")\n  .addBatch({\n    \"Setting a basic cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a no-path cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      domain: function(c) {\n        assert.equal(c.domain, \"example.com\");\n      },\n      \"path is /\": function(c) {\n        assert.equal(c.path, \"/\");\n      },\n      \"path was derived\": function(c) {\n        assert.strictEqual(c.pathIsDefault, true);\n      }\n    },\n    \"Setting a cookie already marked as host-only\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        c.hostOnly = true;\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      domain: function(c) {\n        assert.equal(c.domain, \"example.com\");\n      },\n      \"still hostOnly\": function(c) {\n        assert.strictEqual(c.hostOnly, true);\n      }\n    },\n    \"Setting a session cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b\");\n        assert.strictEqual(c.path, null);\n        cj.setCookie(c, \"http://www.example.com/dir/index.html\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      },\n      \"gets the domain\": function(c) {\n        assert.equal(c.domain, \"www.example.com\");\n      },\n      \"gets the default path\": function(c) {\n        assert.equal(c.path, \"/dir\");\n      },\n      \"is 'hostOnly'\": function(c) {\n        assert.ok(c.hostOnly);\n      }\n    },\n    \"Setting wrong domain cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=fooxample.com; Path=/\");\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      fails: function(err, c) {\n        assert.ok(err.message.match(/domain/i));\n        assert.ok(!c);\n      }\n    },\n    \"Setting sub-domain cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=www.example.com; Path=/\");\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      fails: function(err, c) {\n        assert.ok(err.message.match(/domain/i));\n        assert.ok(!c);\n      }\n    },\n    \"Setting super-domain cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        cj.setCookie(c, \"http://www.app.example.com/index.html\", this.callback);\n      },\n      success: function(err, c) {\n        assert.ok(!err);\n        assert.equal(c.domain, \"example.com\");\n      }\n    },\n    \"Setting a sub-path cookie on a super-domain\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/subpath\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://www.example.com/index.html\", this.callback);\n      },\n      \"domain is super-domain\": function(c) {\n        assert.equal(c.domain, \"example.com\");\n      },\n      \"path is /subpath\": function(c) {\n        assert.equal(c.path, \"/subpath\");\n      },\n      \"path was NOT derived\": function(c) {\n        assert.strictEqual(c.pathIsDefault, null);\n      }\n    },\n    \"Setting HttpOnly cookie over non-HTTP API\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/; HttpOnly\");\n        cj.setCookie(\n          c,\n          \"http://example.com/index.html\",\n          { http: false },\n          this.callback\n        );\n      },\n      fails: function(err, c) {\n        assert.match(err.message, /HttpOnly/i);\n        assert.ok(!c);\n      }\n    },\n    \"Setting a basic IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[::1]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[::1]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a prefix IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[::ffff:127.0.0.1]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[::ffff:127.0.0.1]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a classic IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[2001:4860:4860::8888]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[2001:4860:4860::8888]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a short IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[2600::]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[2600::]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    }\n  })\n  .addBatch({\n    \"Store eight cookies\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const ex = \"http://example.com/index.html\";\n        const tasks = [];\n        tasks.push(next => {\n          cj.setCookie(\"a=1; Domain=example.com; Path=/\", ex, at(0), next);\n        });\n        tasks.push(next => {\n          cj.setCookie(\n            \"b=2; Domain=example.com; Path=/; HttpOnly\",\n            ex,\n            at(1000),\n            next\n          );\n        });\n        tasks.push(next => {\n          cj.setCookie(\n            \"c=3; Domain=example.com; Path=/; Secure\",\n            ex,\n            at(2000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // path\n          cj.setCookie(\n            \"d=4; Domain=example.com; Path=/foo\",\n            ex,\n            at(3000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // host only\n          cj.setCookie(\"e=5\", ex, at(4000), next);\n        });\n        tasks.push(next => {\n          // other domain\n          cj.setCookie(\n            \"f=6; Domain=nodejs.org; Path=/\",\n            \"http://nodejs.org\",\n            at(5000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // expired\n          cj.setCookie(\n            \"g=7; Domain=example.com; Path=/; Expires=Tue, 18 Oct 2011 00:00:00 GMT\",\n            ex,\n            at(6000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // expired via Max-Age\n          cj.setCookie(\"h=8; Domain=example.com; Path=/; Max-Age=1\", ex, next);\n        });\n        const cb = this.callback;\n        async.parallel(tasks, (err, results) => {\n          setTimeout(() => {\n            cb(err, cj, results);\n          }, 2000); // so that 'h=8' expires\n        });\n      },\n      \"setup ok\": function(err, cj, results) {\n        assert.ok(!err);\n        assert.ok(cj);\n        assert.ok(results);\n      },\n      \"then retrieving for http://nodejs.org\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://nodejs.org\", this.callback);\n        },\n        \"get a nodejs cookie\": function(cookies) {\n          assert.lengthOf(cookies, 1);\n          const cookie = cookies[0];\n          assert.equal(cookie.domain, \"nodejs.org\");\n        }\n      },\n      \"then retrieving for https://example.com\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"https://example.com\", { secure: true }, this.callback);\n        },\n        \"get a secure example cookie with others\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"c\", \"e\"]);\n        }\n      },\n      \"then retrieving for https://example.com (missing options)\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"https://example.com\", this.callback);\n        },\n        \"get a secure example cookie with others\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"c\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://example.com\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://EXAMPlE.com\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://EXAMPlE.com\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com, non-HTTP\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://example.com\", { http: false }, this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com/foo/bar\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://example.com/foo/bar\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"d\", \"a\", \"b\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com as a string\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookieString(\"http://example.com\", this.callback);\n        },\n        \"get a single string\": function(cookieHeader) {\n          assert.equal(cookieHeader, \"a=1; b=2; e=5\");\n        }\n      },\n      \"then retrieving for http://example.com as a set-cookie header\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getSetCookieStrings(\"http://example.com\", this.callback);\n        },\n        \"get a single string\": function(cookieHeaders) {\n          assert.lengthOf(cookieHeaders, 3);\n          assert.equal(cookieHeaders[0], \"a=1; Domain=example.com; Path=/\");\n          assert.equal(\n            cookieHeaders[1],\n            \"b=2; Domain=example.com; Path=/; HttpOnly\"\n          );\n          assert.equal(cookieHeaders[2], \"e=5; Path=/\");\n        }\n      },\n      \"then retrieving for http://www.example.com/\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://www.example.com/foo/bar\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"d\", \"a\", \"b\"]); // note lack of 'e'\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Repeated names\": {\n      topic: function() {\n        const cb = this.callback;\n        const cj = new CookieJar();\n        const ex = \"http://www.example.com/\";\n        const sc = cj.setCookie;\n        const tasks = [];\n        const now = Date.now();\n        tasks.push(sc.bind(cj, \"aaaa=xxxx\", ex, at(0)));\n        tasks.push(\n          sc.bind(cj, \"aaaa=1111; Domain=www.example.com\", ex, at(1000))\n        );\n        tasks.push(sc.bind(cj, \"aaaa=2222; Domain=example.com\", ex, at(2000)));\n        tasks.push(\n          sc.bind(\n            cj,\n            \"aaaa=3333; Domain=www.example.com; Path=/pathA\",\n            ex,\n            at(3000)\n          )\n        );\n        async.series(tasks, (err, results) => {\n          results = results.filter(e => {\n            return e !== undefined;\n          });\n          cb(err, { cj: cj, cookies: results, now: now });\n        });\n      },\n      \"all got set\": function(err, t) {\n        assert.lengthOf(t.cookies, 4);\n      },\n      \"then getting 'em back\": {\n        topic: function(t) {\n          const cj = t.cj;\n          cj.getCookies(\"http://www.example.com/pathA\", this.callback);\n        },\n        \"there's just three\": function(err, cookies) {\n          const vals = cookies.map(c => {\n            return c.value;\n          });\n          // may break with sorting; sorting should put 3333 first due to longest path:\n          assert.deepEqual(vals, [\"3333\", \"1111\", \"2222\"]);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"CookieJar setCookie errors\": {\n      \"public-suffix domain\": {\n        topic: function() {\n          const cj = new CookieJar();\n          cj.setCookie(\n            \"i=9; Domain=kyoto.jp; Path=/\",\n            \"kyoto.jp\",\n            this.callback\n          );\n        },\n        errors: function(err, cookie) {\n          assert.ok(err);\n          assert.ok(!cookie);\n          assert.match(err.message, /public suffix/i);\n        }\n      },\n      \"wrong domain\": {\n        topic: function() {\n          const cj = new CookieJar();\n          cj.setCookie(\n            \"j=10; Domain=google.com; Path=/\",\n            \"http://google.ca\",\n            this.callback\n          );\n        },\n        errors: function(err, cookie) {\n          assert.ok(err);\n          assert.ok(!cookie);\n          assert.match(err.message, /not in this host's domain/i);\n        }\n      },\n      \"old cookie is HttpOnly\": {\n        topic: function() {\n          const cb = this.callback;\n          const next = function(err, c) {\n            c = null;\n            return cb(err, cj);\n          };\n          const cj = new CookieJar();\n          cj.setCookie(\n            \"k=11; Domain=example.ca; Path=/; HttpOnly\",\n            \"http://example.ca\",\n            { http: true },\n            next\n          );\n        },\n        \"initial cookie is set\": function(err, cj) {\n          assert.ok(!err);\n          assert.ok(cj);\n        },\n        \"but when trying to overwrite\": {\n          topic: function(cj) {\n            const cb = this.callback;\n            const next = function(err, c) {\n              c = null;\n              cb(null, err);\n            };\n            cj.setCookie(\n              \"k=12; Domain=example.ca; Path=/\",\n              \"http://example.ca\",\n              { http: false },\n              next\n            );\n          },\n          \"it's an error\": function(err) {\n            assert.ok(err);\n          },\n          \"then, checking the original\": {\n            topic: function(ignored, cj) {\n              assert.ok(cj instanceof CookieJar);\n              cj.getCookies(\"http://example.ca\", { http: true }, this.callback);\n            },\n            \"cookie has original value\": function(err, cookies) {\n              assert.equal(err, null);\n              assert.lengthOf(cookies, 1);\n              assert.equal(cookies[0].value, 11);\n            }\n          }\n        }\n      },\n      \"similar to public suffix\": {\n        topic: function() {\n          const cj = new CookieJar();\n          const url = \"http://www.foonet.net\";\n          assert.isTrue(cj.rejectPublicSuffixes);\n          cj.setCookie(\"l=13; Domain=foonet.net; Path=/\", url, this.callback);\n        },\n        \"doesn't error\": function(err, cookie) {\n          assert.ok(!err);\n          assert.ok(cookie);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Loose Mode\": {\n      topic: function() {\n        const cj = new CookieJar(null, { looseMode: true });\n        cj.setCookieSync(\"FooBar\", \"http://www.foonet.net\", {});\n        return cj;\n      },\n      \"parses loose cookies\": function(cj) {\n        const cookies = cj.getCookiesSync(\"http://www.foonet.net\");\n        assert.strictEqual(cookies.length, 1);\n        assert.strictEqual(cookies[0].key, \"\");\n        assert.strictEqual(cookies[0].value, \"FooBar\");\n      }\n    },\n    \"Loose Mode Cloned\": {\n      topic: function() {\n        const cj = new CookieJar(null, { looseMode: true });\n        return CookieJar.fromJSON(cj.toJSON());\n      },\n      \"parses loose cookies from serialized cookie jar\": function(cj) {\n        cj.setCookieSync(\"FooBar\", \"http://www.foonet.net\", {});\n        const cookies = cj.getCookiesSync(\"http://www.foonet.net\");\n        assert.strictEqual(cookies.length, 1);\n        assert.strictEqual(cookies[0].key, \"\");\n        assert.strictEqual(cookies[0].value, \"FooBar\");\n      }\n    }\n  })\n  .addBatch({\n    \"Remove all cookies\": {\n      topic: function() {\n        const jar = new CookieJar();\n        const cookie1 = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        const cookie2 = Cookie.parse(\"a=b; Domain=foo.com; Path=/\");\n        const cookie3 = Cookie.parse(\"foo=bar; Domain=foo.com; Path=/\");\n        jar.setCookie(cookie1, \"http://example.com/index.html\", () => {});\n        jar.setCookie(cookie2, \"http://foo.com/index.html\", () => {});\n        jar.setCookie(cookie3, \"http://foo.com/index.html\", () => {});\n\n        const cb = this.callback;\n        jar.removeAllCookies(err => {\n          cb(err, jar);\n        });\n      },\n      \"no errors\": function(err, jar) {\n        assert(err == null);\n      },\n      \"load cookies from the jar\": {\n        topic: function(jar) {\n          jar.store.getAllCookies(this.callback);\n        },\n        \"no cookies in the jar\": function(err, cookies) {\n          assert(err == null);\n          assert(cookies != null);\n          assert(cookies.length === 0, \"cookies were not removed\");\n        }\n      }\n    },\n    \"Remove all cookies (the underlying store does not support removeAllCookies)\": {\n      topic: function() {\n        const jar = new CookieJar();\n        jar.store.removeAllCookies = undefined;\n        const cookie1 = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        const cookie2 = Cookie.parse(\"a=b; Domain=foo.com; Path=/\");\n        const cookie3 = Cookie.parse(\"foo=bar; Domain=foo.com; Path=/\");\n        jar.setCookie(cookie1, \"http://example.com/index.html\", () => {});\n        jar.setCookie(cookie2, \"http://foo.com/index.html\", () => {});\n        jar.setCookie(cookie3, \"http://foo.com/index.html\", () => {});\n\n        const cb = this.callback;\n        jar.removeAllCookies(err => {\n          cb(err, jar);\n        });\n      },\n      \"no errors\": function(err, jar) {\n        assert(err == null);\n      },\n      \"load cookies from the jar\": {\n        topic: function(jar) {\n          jar.store.getAllCookies(this.callback);\n        },\n        \"no cookies in the jar\": function(err, cookies) {\n          assert(err == null);\n          assert(cookies != null);\n          assert(cookies.length === 0, \"cookies were not removed\");\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue 132 - setCookie\": {\n      \"with foreign object\": {\n        topic: function() {\n          const jar = new CookieJar();\n          jar.setCookie(\n            { key: \"x\", value: \"y\" },\n            \"http://example.com/\",\n            this.callback\n          );\n        },\n        \"results in an error\": function(err, cookie) {\n          assert(err != null);\n          assert(!cookie);\n          assert.equal(\n            err.message,\n            \"First argument to setCookie must be a Cookie object or string\"\n          );\n        }\n      },\n      \"with String instance\": {\n        topic: function() {\n          const jar = new CookieJar();\n          jar.setCookie(\n            new String(\"x=y; Domain=example.com; Path=/\"),\n            \"http://example.com/\",\n            this.callback\n          );\n        },\n        \"is fine\": function(err, cookie) {\n          assert(!err);\n          assert(!!cookie);\n          assert.instanceOf(cookie, Cookie);\n          assert.equal(cookie.key, \"x\");\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue #144 - secure\": {\n      \"of undefined\": {\n        topic: function() {\n          const jar = new tough.CookieJar();\n          const cookieString = `AWSELB=69b2c0038b16e8e27056d1178e0d556c;\n          Path=/, jses_WS41=5f8dc2f6-ea37-49de-8dfa-b58336c2d9ce; path=/;\n          Secure; HttpOnly, AuthToken=EFKFFFCH@K@GHIHEJCJMMGJM>CDHDEK>CFGK?MHJ\n          >>JI@B??@CAEHBJH@H@A@GCFDLIMLJEEJEIFGALA?BIM?@G@DEDI@JE?I?HKJBIDDHJMEFEFM\n          >G@J?I??B@C>>LAH?GCGJ@FMEGHBGAF; expires=Sun, 31-Jan-9021 02:39:04 GMT;\n          path=/; Secure; HttpOnly, FirstReferrer=; expires=Fri, 31-Jan-9020 20:50:44\n          GMT; path=/`;\n\n          jar.setCookieSync(cookieString, \"https://google.com\");\n          jar.getCookies(\"https://google.com\", this.callback);\n        },\n        \"results in a 1-length array with a valid cookie\": function(\n          err,\n          cookies\n        ) {\n          assert(!err, err);\n          assert(cookies.length == 1);\n          assert.instanceOf(cookies[0], Cookie);\n          assert.isTrue(cookies[0].secure);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue #145 - Missing parameter validation on setCookie function causes TypeError\": {\n      \"with missing parameters\": {\n        topic: function() {\n          const jar = new tough.CookieJar();\n          jar.setCookie(\n            new String(\"x=y; Domain=example.com; Path=/\"),\n            this.callback\n          );\n        },\n        \"results in a error being returned because of missing parameters\": function(\n          err,\n          cookies\n        ) {\n          assert(err != null);\n          assert(err instanceof tough.ParameterError);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue #197 - CookieJar().setCookie crashes when empty cookie is passed\": {\n      \"with missing parameters\": {\n        topic: function() {\n          const jar = new tough.CookieJar();\n          jar.setCookie(\"\", \"https://google.com\", this.callback);\n        },\n        \"results in a error being returned because of missing parameters\": function(\n          err,\n          cookies\n        ) {\n          assert(cookies == undefined);\n        }\n      }\n    }\n  })\n  .export(module);\n"], "fixing_code": ["/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\nconst { fromCallback } = require(\"universalify\");\nconst Store = require(\"./store\").Store;\nconst permuteDomain = require(\"./permuteDomain\").permuteDomain;\nconst pathMatch = require(\"./pathMatch\").pathMatch;\nconst { getCustomInspectSymbol, getUtilInspect } = require(\"./utilHelper\");\n\nclass MemoryCookieStore extends Store {\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = Object.create(null);\n    const customInspectSymbol = getCustomInspectSymbol();\n    if (customInspectSymbol) {\n      this[customInspectSymbol] = this.inspect;\n    }\n  }\n\n  inspect() {\n    const util = { inspect: getUtilInspect(inspectFallback) };\n    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;\n  }\n\n  findCookie(domain, path, key, cb) {\n    if (!this.idx[domain]) {\n      return cb(null, undefined);\n    }\n    if (!this.idx[domain][path]) {\n      return cb(null, undefined);\n    }\n    return cb(null, this.idx[domain][path][key] || null);\n  }\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    const results = [];\n    if (typeof allowSpecialUseDomain === \"function\") {\n      cb = allowSpecialUseDomain;\n      allowSpecialUseDomain = true;\n    }\n    if (!domain) {\n      return cb(null, []);\n    }\n\n    let pathMatcher;\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        Object.keys(domainIndex).forEach(cookiePath => {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        });\n      };\n    }\n\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n\n    cb(null, results);\n  }\n\n  putCookie(cookie, cb) {\n    if (!this.idx[cookie.domain]) {\n      this.idx[cookie.domain] = Object.create(null);\n    }\n    if (!this.idx[cookie.domain][cookie.path]) {\n      this.idx[cookie.domain][cookie.path] = Object.create(null);\n    }\n    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n    cb(null);\n  }\n  updateCookie(oldCookie, newCookie, cb) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    this.putCookie(newCookie, cb);\n  }\n  removeCookie(domain, path, key, cb) {\n    if (\n      this.idx[domain] &&\n      this.idx[domain][path] &&\n      this.idx[domain][path][key]\n    ) {\n      delete this.idx[domain][path][key];\n    }\n    cb(null);\n  }\n  removeCookies(domain, path, cb) {\n    if (this.idx[domain]) {\n      if (path) {\n        delete this.idx[domain][path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n    return cb(null);\n  }\n  removeAllCookies(cb) {\n    this.idx = Object.create(null);\n    return cb(null);\n  }\n  getAllCookies(cb) {\n    const cookies = [];\n    const idx = this.idx;\n\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const paths = Object.keys(idx[domain]);\n      paths.forEach(path => {\n        const keys = Object.keys(idx[domain][path]);\n        keys.forEach(key => {\n          if (key !== null) {\n            cookies.push(idx[domain][path][key]);\n          }\n        });\n      });\n    });\n\n    // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n\n    cb(null, cookies);\n  }\n}\n\n[\n  \"findCookie\",\n  \"findCookies\",\n  \"putCookie\",\n  \"updateCookie\",\n  \"removeCookie\",\n  \"removeCookies\",\n  \"removeAllCookies\",\n  \"getAllCookies\"\n].forEach(name => {\n  MemoryCookieStore.prototype[name] = fromCallback(\n    MemoryCookieStore.prototype[name]\n  );\n});\n\nexports.MemoryCookieStore = MemoryCookieStore;\n\nfunction inspectFallback(val) {\n  const domains = Object.keys(val);\n  if (domains.length === 0) {\n    return \"[Object: null prototype] {}\";\n  }\n  let result = \"[Object: null prototype] {\\n\";\n  Object.keys(val).forEach((domain, i) => {\n    result += formatDomain(domain, val[domain]);\n    if (i < domains.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += \"}\";\n  return result;\n}\n\nfunction formatDomain(domainName, domainValue) {\n  const indent = \"  \";\n  let result = `${indent}'${domainName}': [Object: null prototype] {\\n`;\n  Object.keys(domainValue).forEach((path, i, paths) => {\n    result += formatPath(path, domainValue[path]);\n    if (i < paths.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nfunction formatPath(pathName, pathValue) {\n  const indent = \"    \";\n  let result = `${indent}'${pathName}': [Object: null prototype] {\\n`;\n  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {\n    const cookie = pathValue[cookieName];\n    result += `      ${cookieName}: ${cookie.inspect()}`;\n    if (i < cookieNames.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nexports.inspectFallback = inspectFallback;\n", "/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\nconst vows = require(\"vows\");\nconst assert = require(\"assert\");\nconst async = require(\"async\");\nconst tough = require(\"../lib/cookie\");\nconst Cookie = tough.Cookie;\nconst CookieJar = tough.CookieJar;\n\nconst atNow = Date.now();\n\nfunction at(offset) {\n  return { now: new Date(atNow + offset) };\n}\n\nvows\n  .describe(\"CookieJar\")\n  .addBatch({\n    \"Setting a basic cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a no-path cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      domain: function(c) {\n        assert.equal(c.domain, \"example.com\");\n      },\n      \"path is /\": function(c) {\n        assert.equal(c.path, \"/\");\n      },\n      \"path was derived\": function(c) {\n        assert.strictEqual(c.pathIsDefault, true);\n      }\n    },\n    \"Setting a cookie already marked as host-only\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        c.hostOnly = true;\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      domain: function(c) {\n        assert.equal(c.domain, \"example.com\");\n      },\n      \"still hostOnly\": function(c) {\n        assert.strictEqual(c.hostOnly, true);\n      }\n    },\n    \"Setting a session cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b\");\n        assert.strictEqual(c.path, null);\n        cj.setCookie(c, \"http://www.example.com/dir/index.html\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      },\n      \"gets the domain\": function(c) {\n        assert.equal(c.domain, \"www.example.com\");\n      },\n      \"gets the default path\": function(c) {\n        assert.equal(c.path, \"/dir\");\n      },\n      \"is 'hostOnly'\": function(c) {\n        assert.ok(c.hostOnly);\n      }\n    },\n    \"Setting wrong domain cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=fooxample.com; Path=/\");\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      fails: function(err, c) {\n        assert.ok(err.message.match(/domain/i));\n        assert.ok(!c);\n      }\n    },\n    \"Setting sub-domain cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=www.example.com; Path=/\");\n        cj.setCookie(c, \"http://example.com/index.html\", this.callback);\n      },\n      fails: function(err, c) {\n        assert.ok(err.message.match(/domain/i));\n        assert.ok(!c);\n      }\n    },\n    \"Setting super-domain cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        cj.setCookie(c, \"http://www.app.example.com/index.html\", this.callback);\n      },\n      success: function(err, c) {\n        assert.ok(!err);\n        assert.equal(c.domain, \"example.com\");\n      }\n    },\n    \"Setting a sub-path cookie on a super-domain\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/subpath\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://www.example.com/index.html\", this.callback);\n      },\n      \"domain is super-domain\": function(c) {\n        assert.equal(c.domain, \"example.com\");\n      },\n      \"path is /subpath\": function(c) {\n        assert.equal(c.path, \"/subpath\");\n      },\n      \"path was NOT derived\": function(c) {\n        assert.strictEqual(c.pathIsDefault, null);\n      }\n    },\n    \"Setting HttpOnly cookie over non-HTTP API\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=example.com; Path=/; HttpOnly\");\n        cj.setCookie(\n          c,\n          \"http://example.com/index.html\",\n          { http: false },\n          this.callback\n        );\n      },\n      fails: function(err, c) {\n        assert.match(err.message, /HttpOnly/i);\n        assert.ok(!c);\n      }\n    },\n    \"Setting a basic IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[::1]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[::1]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a prefix IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[::ffff:127.0.0.1]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[::ffff:127.0.0.1]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a classic IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[2001:4860:4860::8888]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[2001:4860:4860::8888]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    },\n    \"Setting a short IPv6 cookie\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const c = Cookie.parse(\"a=b; Domain=[2600::]; Path=/\");\n        assert.strictEqual(c.hostOnly, null);\n        assert.instanceOf(c.creation, Date);\n        assert.strictEqual(c.lastAccessed, null);\n        c.creation = new Date(Date.now() - 10000);\n        cj.setCookie(c, \"http://[2600::]/\", this.callback);\n      },\n      works: function(c) {\n        assert.instanceOf(c, Cookie);\n      }, // C is for Cookie, good enough for me\n      \"gets timestamped\": function(c) {\n        assert.ok(c.creation);\n        assert.ok(Date.now() - c.creation.getTime() < 5000); // recently stamped\n        assert.ok(c.lastAccessed);\n        assert.equal(c.creation, c.lastAccessed);\n        assert.equal(c.TTL(), Infinity);\n        assert.ok(!c.isPersistent());\n      }\n    }\n  })\n  .addBatch({\n    \"Store eight cookies\": {\n      topic: function() {\n        const cj = new CookieJar();\n        const ex = \"http://example.com/index.html\";\n        const tasks = [];\n        tasks.push(next => {\n          cj.setCookie(\"a=1; Domain=example.com; Path=/\", ex, at(0), next);\n        });\n        tasks.push(next => {\n          cj.setCookie(\n            \"b=2; Domain=example.com; Path=/; HttpOnly\",\n            ex,\n            at(1000),\n            next\n          );\n        });\n        tasks.push(next => {\n          cj.setCookie(\n            \"c=3; Domain=example.com; Path=/; Secure\",\n            ex,\n            at(2000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // path\n          cj.setCookie(\n            \"d=4; Domain=example.com; Path=/foo\",\n            ex,\n            at(3000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // host only\n          cj.setCookie(\"e=5\", ex, at(4000), next);\n        });\n        tasks.push(next => {\n          // other domain\n          cj.setCookie(\n            \"f=6; Domain=nodejs.org; Path=/\",\n            \"http://nodejs.org\",\n            at(5000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // expired\n          cj.setCookie(\n            \"g=7; Domain=example.com; Path=/; Expires=Tue, 18 Oct 2011 00:00:00 GMT\",\n            ex,\n            at(6000),\n            next\n          );\n        });\n        tasks.push(next => {\n          // expired via Max-Age\n          cj.setCookie(\"h=8; Domain=example.com; Path=/; Max-Age=1\", ex, next);\n        });\n        const cb = this.callback;\n        async.parallel(tasks, (err, results) => {\n          setTimeout(() => {\n            cb(err, cj, results);\n          }, 2000); // so that 'h=8' expires\n        });\n      },\n      \"setup ok\": function(err, cj, results) {\n        assert.ok(!err);\n        assert.ok(cj);\n        assert.ok(results);\n      },\n      \"then retrieving for http://nodejs.org\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://nodejs.org\", this.callback);\n        },\n        \"get a nodejs cookie\": function(cookies) {\n          assert.lengthOf(cookies, 1);\n          const cookie = cookies[0];\n          assert.equal(cookie.domain, \"nodejs.org\");\n        }\n      },\n      \"then retrieving for https://example.com\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"https://example.com\", { secure: true }, this.callback);\n        },\n        \"get a secure example cookie with others\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"c\", \"e\"]);\n        }\n      },\n      \"then retrieving for https://example.com (missing options)\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"https://example.com\", this.callback);\n        },\n        \"get a secure example cookie with others\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"c\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://example.com\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://EXAMPlE.com\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://EXAMPlE.com\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"b\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com, non-HTTP\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://example.com\", { http: false }, this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"a\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com/foo/bar\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://example.com/foo/bar\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"d\", \"a\", \"b\", \"e\"]);\n        }\n      },\n      \"then retrieving for http://example.com as a string\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookieString(\"http://example.com\", this.callback);\n        },\n        \"get a single string\": function(cookieHeader) {\n          assert.equal(cookieHeader, \"a=1; b=2; e=5\");\n        }\n      },\n      \"then retrieving for http://example.com as a set-cookie header\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getSetCookieStrings(\"http://example.com\", this.callback);\n        },\n        \"get a single string\": function(cookieHeaders) {\n          assert.lengthOf(cookieHeaders, 3);\n          assert.equal(cookieHeaders[0], \"a=1; Domain=example.com; Path=/\");\n          assert.equal(\n            cookieHeaders[1],\n            \"b=2; Domain=example.com; Path=/; HttpOnly\"\n          );\n          assert.equal(cookieHeaders[2], \"e=5; Path=/\");\n        }\n      },\n      \"then retrieving for http://www.example.com/\": {\n        topic: function(cj, oldResults) {\n          assert.ok(oldResults);\n          cj.getCookies(\"http://www.example.com/foo/bar\", this.callback);\n        },\n        \"get a bunch of cookies\": function(cookies) {\n          const names = cookies.map(c => {\n            return c.key;\n          });\n          assert.deepEqual(names, [\"d\", \"a\", \"b\"]); // note lack of 'e'\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Repeated names\": {\n      topic: function() {\n        const cb = this.callback;\n        const cj = new CookieJar();\n        const ex = \"http://www.example.com/\";\n        const sc = cj.setCookie;\n        const tasks = [];\n        const now = Date.now();\n        tasks.push(sc.bind(cj, \"aaaa=xxxx\", ex, at(0)));\n        tasks.push(\n          sc.bind(cj, \"aaaa=1111; Domain=www.example.com\", ex, at(1000))\n        );\n        tasks.push(sc.bind(cj, \"aaaa=2222; Domain=example.com\", ex, at(2000)));\n        tasks.push(\n          sc.bind(\n            cj,\n            \"aaaa=3333; Domain=www.example.com; Path=/pathA\",\n            ex,\n            at(3000)\n          )\n        );\n        async.series(tasks, (err, results) => {\n          results = results.filter(e => {\n            return e !== undefined;\n          });\n          cb(err, { cj: cj, cookies: results, now: now });\n        });\n      },\n      \"all got set\": function(err, t) {\n        assert.lengthOf(t.cookies, 4);\n      },\n      \"then getting 'em back\": {\n        topic: function(t) {\n          const cj = t.cj;\n          cj.getCookies(\"http://www.example.com/pathA\", this.callback);\n        },\n        \"there's just three\": function(err, cookies) {\n          const vals = cookies.map(c => {\n            return c.value;\n          });\n          // may break with sorting; sorting should put 3333 first due to longest path:\n          assert.deepEqual(vals, [\"3333\", \"1111\", \"2222\"]);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"CookieJar setCookie errors\": {\n      \"public-suffix domain\": {\n        topic: function() {\n          const cj = new CookieJar();\n          cj.setCookie(\n            \"i=9; Domain=kyoto.jp; Path=/\",\n            \"kyoto.jp\",\n            this.callback\n          );\n        },\n        errors: function(err, cookie) {\n          assert.ok(err);\n          assert.ok(!cookie);\n          assert.match(err.message, /public suffix/i);\n        }\n      },\n      \"wrong domain\": {\n        topic: function() {\n          const cj = new CookieJar();\n          cj.setCookie(\n            \"j=10; Domain=google.com; Path=/\",\n            \"http://google.ca\",\n            this.callback\n          );\n        },\n        errors: function(err, cookie) {\n          assert.ok(err);\n          assert.ok(!cookie);\n          assert.match(err.message, /not in this host's domain/i);\n        }\n      },\n      \"old cookie is HttpOnly\": {\n        topic: function() {\n          const cb = this.callback;\n          const next = function(err, c) {\n            c = null;\n            return cb(err, cj);\n          };\n          const cj = new CookieJar();\n          cj.setCookie(\n            \"k=11; Domain=example.ca; Path=/; HttpOnly\",\n            \"http://example.ca\",\n            { http: true },\n            next\n          );\n        },\n        \"initial cookie is set\": function(err, cj) {\n          assert.ok(!err);\n          assert.ok(cj);\n        },\n        \"but when trying to overwrite\": {\n          topic: function(cj) {\n            const cb = this.callback;\n            const next = function(err, c) {\n              c = null;\n              cb(null, err);\n            };\n            cj.setCookie(\n              \"k=12; Domain=example.ca; Path=/\",\n              \"http://example.ca\",\n              { http: false },\n              next\n            );\n          },\n          \"it's an error\": function(err) {\n            assert.ok(err);\n          },\n          \"then, checking the original\": {\n            topic: function(ignored, cj) {\n              assert.ok(cj instanceof CookieJar);\n              cj.getCookies(\"http://example.ca\", { http: true }, this.callback);\n            },\n            \"cookie has original value\": function(err, cookies) {\n              assert.equal(err, null);\n              assert.lengthOf(cookies, 1);\n              assert.equal(cookies[0].value, 11);\n            }\n          }\n        }\n      },\n      \"similar to public suffix\": {\n        topic: function() {\n          const cj = new CookieJar();\n          const url = \"http://www.foonet.net\";\n          assert.isTrue(cj.rejectPublicSuffixes);\n          cj.setCookie(\"l=13; Domain=foonet.net; Path=/\", url, this.callback);\n        },\n        \"doesn't error\": function(err, cookie) {\n          assert.ok(!err);\n          assert.ok(cookie);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Loose Mode\": {\n      topic: function() {\n        const cj = new CookieJar(null, { looseMode: true });\n        cj.setCookieSync(\"FooBar\", \"http://www.foonet.net\", {});\n        return cj;\n      },\n      \"parses loose cookies\": function(cj) {\n        const cookies = cj.getCookiesSync(\"http://www.foonet.net\");\n        assert.strictEqual(cookies.length, 1);\n        assert.strictEqual(cookies[0].key, \"\");\n        assert.strictEqual(cookies[0].value, \"FooBar\");\n      }\n    },\n    \"Loose Mode Cloned\": {\n      topic: function() {\n        const cj = new CookieJar(null, { looseMode: true });\n        return CookieJar.fromJSON(cj.toJSON());\n      },\n      \"parses loose cookies from serialized cookie jar\": function(cj) {\n        cj.setCookieSync(\"FooBar\", \"http://www.foonet.net\", {});\n        const cookies = cj.getCookiesSync(\"http://www.foonet.net\");\n        assert.strictEqual(cookies.length, 1);\n        assert.strictEqual(cookies[0].key, \"\");\n        assert.strictEqual(cookies[0].value, \"FooBar\");\n      }\n    }\n  })\n  .addBatch({\n    \"Remove all cookies\": {\n      topic: function() {\n        const jar = new CookieJar();\n        const cookie1 = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        const cookie2 = Cookie.parse(\"a=b; Domain=foo.com; Path=/\");\n        const cookie3 = Cookie.parse(\"foo=bar; Domain=foo.com; Path=/\");\n        jar.setCookie(cookie1, \"http://example.com/index.html\", () => {});\n        jar.setCookie(cookie2, \"http://foo.com/index.html\", () => {});\n        jar.setCookie(cookie3, \"http://foo.com/index.html\", () => {});\n\n        const cb = this.callback;\n        jar.removeAllCookies(err => {\n          cb(err, jar);\n        });\n      },\n      \"no errors\": function(err, jar) {\n        assert(err == null);\n      },\n      \"load cookies from the jar\": {\n        topic: function(jar) {\n          jar.store.getAllCookies(this.callback);\n        },\n        \"no cookies in the jar\": function(err, cookies) {\n          assert(err == null);\n          assert(cookies != null);\n          assert(cookies.length === 0, \"cookies were not removed\");\n        }\n      }\n    },\n    \"Remove all cookies (the underlying store does not support removeAllCookies)\": {\n      topic: function() {\n        const jar = new CookieJar();\n        jar.store.removeAllCookies = undefined;\n        const cookie1 = Cookie.parse(\"a=b; Domain=example.com; Path=/\");\n        const cookie2 = Cookie.parse(\"a=b; Domain=foo.com; Path=/\");\n        const cookie3 = Cookie.parse(\"foo=bar; Domain=foo.com; Path=/\");\n        jar.setCookie(cookie1, \"http://example.com/index.html\", () => {});\n        jar.setCookie(cookie2, \"http://foo.com/index.html\", () => {});\n        jar.setCookie(cookie3, \"http://foo.com/index.html\", () => {});\n\n        const cb = this.callback;\n        jar.removeAllCookies(err => {\n          cb(err, jar);\n        });\n      },\n      \"no errors\": function(err, jar) {\n        assert(err == null);\n      },\n      \"load cookies from the jar\": {\n        topic: function(jar) {\n          jar.store.getAllCookies(this.callback);\n        },\n        \"no cookies in the jar\": function(err, cookies) {\n          assert(err == null);\n          assert(cookies != null);\n          assert(cookies.length === 0, \"cookies were not removed\");\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue 132 - setCookie\": {\n      \"with foreign object\": {\n        topic: function() {\n          const jar = new CookieJar();\n          jar.setCookie(\n            { key: \"x\", value: \"y\" },\n            \"http://example.com/\",\n            this.callback\n          );\n        },\n        \"results in an error\": function(err, cookie) {\n          assert(err != null);\n          assert(!cookie);\n          assert.equal(\n            err.message,\n            \"First argument to setCookie must be a Cookie object or string\"\n          );\n        }\n      },\n      \"with String instance\": {\n        topic: function() {\n          const jar = new CookieJar();\n          jar.setCookie(\n            new String(\"x=y; Domain=example.com; Path=/\"),\n            \"http://example.com/\",\n            this.callback\n          );\n        },\n        \"is fine\": function(err, cookie) {\n          assert(!err);\n          assert(!!cookie);\n          assert.instanceOf(cookie, Cookie);\n          assert.equal(cookie.key, \"x\");\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue #144 - secure\": {\n      \"of undefined\": {\n        topic: function() {\n          const jar = new tough.CookieJar();\n          const cookieString = `AWSELB=69b2c0038b16e8e27056d1178e0d556c;\n          Path=/, jses_WS41=5f8dc2f6-ea37-49de-8dfa-b58336c2d9ce; path=/;\n          Secure; HttpOnly, AuthToken=EFKFFFCH@K@GHIHEJCJMMGJM>CDHDEK>CFGK?MHJ\n          >>JI@B??@CAEHBJH@H@A@GCFDLIMLJEEJEIFGALA?BIM?@G@DEDI@JE?I?HKJBIDDHJMEFEFM\n          >G@J?I??B@C>>LAH?GCGJ@FMEGHBGAF; expires=Sun, 31-Jan-9021 02:39:04 GMT;\n          path=/; Secure; HttpOnly, FirstReferrer=; expires=Fri, 31-Jan-9020 20:50:44\n          GMT; path=/`;\n\n          jar.setCookieSync(cookieString, \"https://google.com\");\n          jar.getCookies(\"https://google.com\", this.callback);\n        },\n        \"results in a 1-length array with a valid cookie\": function(\n          err,\n          cookies\n        ) {\n          assert(!err, err);\n          assert(cookies.length == 1);\n          assert.instanceOf(cookies[0], Cookie);\n          assert.isTrue(cookies[0].secure);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue #145 - Missing parameter validation on setCookie function causes TypeError\": {\n      \"with missing parameters\": {\n        topic: function() {\n          const jar = new tough.CookieJar();\n          jar.setCookie(\n            new String(\"x=y; Domain=example.com; Path=/\"),\n            this.callback\n          );\n        },\n        \"results in a error being returned because of missing parameters\": function(\n          err,\n          cookies\n        ) {\n          assert(err != null);\n          assert(err instanceof tough.ParameterError);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue #197 - CookieJar().setCookie crashes when empty cookie is passed\": {\n      \"with missing parameters\": {\n        topic: function() {\n          const jar = new tough.CookieJar();\n          jar.setCookie(\"\", \"https://google.com\", this.callback);\n        },\n        \"results in a error being returned because of missing parameters\": function(\n          err,\n          cookies\n        ) {\n          assert(cookies == undefined);\n        }\n      }\n    }\n  })\n  .addBatch({\n    \"Issue #282 - Prototype pollution\": {\n      \"when setting a cookie with the domain __proto__\": {\n        topic: function() {\n          const jar = new tough.CookieJar(undefined, {\n            rejectPublicSuffixes: false\n          });\n          // try to pollute the prototype\n          jar.setCookieSync(\n            \"Slonser=polluted; Domain=__proto__; Path=/notauth\",\n            \"https://__proto__/admin\"\n          );\n          jar.setCookieSync(\n            \"Auth=Lol; Domain=google.com; Path=/notauth\",\n            \"https://google.com/\"\n          );\n          this.callback();\n        },\n        \"results in a cookie that is not affected by the attempted prototype pollution\": function() {\n          const pollutedObject = {};\n          assert(pollutedObject[\"/notauth\"] === undefined);\n        }\n      }\n    }\n  })\n  .export(module);\n"], "filenames": ["lib/memstore.js", "test/cookie_jar_test.js"], "buggy_code_start_loc": [42, 811], "buggy_code_end_loc": [230, 811], "fixing_code_start_loc": [42, 812], "fixing_code_end_loc": [230, 837], "type": "CWE-1321", "message": "Versions of the package tough-cookie before 4.1.3 are vulnerable to Prototype Pollution due to improper handling of Cookies when using CookieJar in rejectPublicSuffixes=false mode. This issue arises from the manner in which the objects are initialized.", "other": {"cve": {"id": "CVE-2023-26136", "sourceIdentifier": "report@snyk.io", "published": "2023-07-01T05:15:16.103", "lastModified": "2024-02-28T03:15:07.087", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Versions of the package tough-cookie before 4.1.3 are vulnerable to Prototype Pollution due to improper handling of Cookies when using CookieJar in rejectPublicSuffixes=false mode. This issue arises from the manner in which the objects are initialized."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:salesforce:tough-cookie:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.1.3", "matchCriteriaId": "805B31A6-800B-42D8-80A1-91E31F7D69CA"}]}]}], "references": [{"url": "https://github.com/salesforce/tough-cookie/commit/12d474791bb856004e858fdb1c47b7608d09cf6e", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/salesforce/tough-cookie/issues/282", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/salesforce/tough-cookie/releases/tag/v4.1.3", "source": "report@snyk.io", "tags": ["Release Notes"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/07/msg00010.html", "source": "report@snyk.io"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3HUE6ZR5SL73KHL7XUPAOEL6SB7HUDT2/", "source": "report@snyk.io"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6PVVPNSAGSDS63HQ74PJ7MZ3MU5IYNVZ/", "source": "report@snyk.io"}, {"url": "https://security.snyk.io/vuln/SNYK-JS-TOUGHCOOKIE-5672873", "source": "report@snyk.io", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/salesforce/tough-cookie/commit/12d474791bb856004e858fdb1c47b7608d09cf6e"}}