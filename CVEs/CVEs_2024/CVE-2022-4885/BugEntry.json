{"buggy_code": ["#!/usr/bin/env python3\n\nimport argparse\nimport struct\nimport stat\nimport os\nimport zlib\nimport binascii\n\nimport cstruct\n\nfrom jefferson import jffs2_lzma, rtime\n\n\ndef PAD(x):\n    return ((x) + 3) & ~3\n\n\nJFFS2_OLD_MAGIC_BITMASK = 0x1984\nJFFS2_MAGIC_BITMASK = 0x1985\nJFFS2_COMPR_NONE = 0x00\nJFFS2_COMPR_ZERO = 0x01\nJFFS2_COMPR_RTIME = 0x02\nJFFS2_COMPR_RUBINMIPS = 0x03\nJFFS2_COMPR_COPY = 0x04\nJFFS2_COMPR_DYNRUBIN = 0x05\nJFFS2_COMPR_ZLIB = 0x06\nJFFS2_COMPR_LZO = 0x07\nJFFS2_COMPR_LZMA = 0x08\n\n# /* Compatibility flags. */\nJFFS2_COMPAT_MASK = 0xC000  # /* What do to if an unknown nodetype is found */\nJFFS2_NODE_ACCURATE = 0x2000\n# /* INCOMPAT: Fail to mount the filesystem */\nJFFS2_FEATURE_INCOMPAT = 0xC000\n# /* ROCOMPAT: Mount read-only */\nJFFS2_FEATURE_ROCOMPAT = 0x8000\n# /* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_COPY = 0x4000\n# /* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_DELETE = 0x0000\n\nJFFS2_NODETYPE_DIRENT = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1\nJFFS2_NODETYPE_INODE = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2\nJFFS2_NODETYPE_CLEANMARKER = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3\nJFFS2_NODETYPE_PADDING = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 4\nJFFS2_NODETYPE_SUMMARY = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 6\nJFFS2_NODETYPE_XATTR = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 8\nJFFS2_NODETYPE_XREF = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 9\n\n\ndef mtd_crc(data):\n    return (binascii.crc32(data, -1) ^ -1) & 0xFFFFFFFF\n\n\ncstruct.typedef(\"uint8\", \"uint8_t\")\ncstruct.typedef(\"uint16\", \"jint16_t\")\ncstruct.typedef(\"uint32\", \"jint32_t\")\ncstruct.typedef(\"uint32\", \"jmode_t\")\n\n\nclass Jffs2_unknown_node(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            /* All start like this */\n            jint16_t magic;\n            jint16_t nodetype;\n            jint32_t totlen; /* So we can skip over nodes we don't grok */\n            jint32_t hdr_crc;\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        comp_hrd_crc = mtd_crc(data[: self.size - 4])\n\n        if comp_hrd_crc == self.hdr_crc:\n            self.hdr_crc_match = True\n        else:\n            # print(\"hdr_crc does not match!\")\n            self.hdr_crc_match = False\n\n\nclass Jffs2_raw_xattr(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* = JFFS2_NODETYPE_XATTR */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t xid;           /* XATTR identifier number */\n            jint32_t version;\n            uint8_t xprefix;\n            uint8_t name_len;\n            jint16_t value_len;\n            jint32_t data_crc;\n            jint32_t node_crc;\n            uint8_t data[0];\n        }\n    \"\"\"\n\n\nclass Jffs2_raw_summary(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* = JFFS2_NODETYPE_SUMMARY */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t sum_num;       /* number of sum entries*/\n            jint32_t cln_mkr;       /* clean marker size, 0 = no cleanmarker */\n            jint32_t padded;        /* sum of the size of padding nodes */\n            jint32_t sum_crc;       /* summary information crc */\n            jint32_t node_crc;      /* node crc */\n            jint32_t sum[0];        /* inode summary info */\n        }\n    \"\"\"\n\n\nclass Jffs2_raw_xref(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* = JFFS2_NODETYPE_XREF */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t ino;           /* inode number */\n            jint32_t xid;           /* XATTR identifier number */\n            jint32_t xseqno;        /* xref sequencial number */\n            jint32_t node_crc;\n        }\n    \"\"\"\n\n\nclass Jffs2_raw_dirent(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* == JFFS2_NODETYPE_DIRENT */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t pino;\n            jint32_t version;\n            jint32_t ino; /* == zero for unlink */\n            jint32_t mctime;\n            uint8_t nsize;\n            uint8_t type;\n            uint8_t unused[2];\n            jint32_t node_crc;\n            jint32_t name_crc;\n        /* uint8_t data[0]; -> name */\n        }\n    \"\"\"\n\n    def unpack(self, data, node_offset):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        self.name = data[self.size : self.size + self.nsize]\n        self.node_offset = node_offset\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"node_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(self.name) == self.name_crc:\n            self.name_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.name_crc_match = False\n\n    def __str__(self):\n        result = []\n        for field in self.__fields__ + [\"name\", \"node_offset\"]:\n            result.append(field + \"=\" + str(getattr(self, field, None)))\n        return type(self).__name__ + \"(\" + \", \".join(result) + \")\"\n\n\nclass Jffs2_raw_inode(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;      /* A constant magic number.  */\n            jint16_t nodetype;   /* == JFFS2_NODETYPE_INODE */\n            jint32_t totlen;     /* Total length of this node (inc data, etc.) */\n            jint32_t hdr_crc;\n            jint32_t ino;        /* Inode number.  */\n            jint32_t version;    /* Version number.  */\n            jmode_t mode;       /* The file's type or mode.  */\n            jint16_t uid;        /* The file's owner.  */\n            jint16_t gid;        /* The file's group.  */\n            jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */\n            jint32_t atime;      /* Last access time.  */\n            jint32_t mtime;      /* Last modification time.  */\n            jint32_t ctime;      /* Change time.  */\n            jint32_t offset;     /* Where to begin to write.  */\n            jint32_t csize;      /* (Compressed) data size */\n            jint32_t dsize;      /* Size of the node's data. (after decompression) */\n            uint8_t compr;       /* Compression algorithm used */\n            uint8_t usercompr;   /* Compression algorithm requested by the user */\n            jint16_t flags;      /* See JFFS2_INO_FLAG_* */\n            jint32_t data_crc;   /* CRC for the (compressed) data.  */\n            jint32_t node_crc;   /* CRC for the raw inode (excluding data)  */\n            /* uint8_t data[0]; */\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n\n        node_data = data[self.size : self.size + self.csize]\n        if self.compr == JFFS2_COMPR_NONE:\n            self.data = node_data\n        elif self.compr == JFFS2_COMPR_ZERO:\n            self.data = b\"\\x00\" * self.dsize\n        elif self.compr == JFFS2_COMPR_ZLIB:\n            self.data = zlib.decompress(node_data)\n        elif self.compr == JFFS2_COMPR_RTIME:\n            self.data = rtime.decompress(node_data, self.dsize)\n        elif self.compr == JFFS2_COMPR_LZMA:\n            self.data = jffs2_lzma.decompress(node_data, self.dsize)\n        else:\n            print(\"compression not implemented\", self)\n            print(node_data.hex()[:20])\n            self.data = node_data\n\n        if len(self.data) != self.dsize:\n            print(\"data length mismatch!\")\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"hdr_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(node_data) == self.data_crc:\n            self.data_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.data_crc_match = False\n\n\nclass Jffs2_device_node_old(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t old_id;\n        }\n    \"\"\"\n\n\nclass Jffs2_device_node_new(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint32_t new_id;\n        }\n    \"\"\"\n\n\nNODETYPES = {\n    JFFS2_FEATURE_INCOMPAT: Jffs2_unknown_node,\n    JFFS2_NODETYPE_DIRENT: Jffs2_raw_dirent,\n    JFFS2_NODETYPE_INODE: Jffs2_raw_inode,\n    JFFS2_NODETYPE_CLEANMARKER: \"JFFS2_NODETYPE_CLEANMARKER\",\n    JFFS2_NODETYPE_SUMMARY: Jffs2_raw_summary,\n    JFFS2_NODETYPE_XATTR: Jffs2_raw_xattr,\n    JFFS2_NODETYPE_XREF: Jffs2_raw_xref,\n    JFFS2_NODETYPE_PADDING: \"JFFS2_NODETYPE_PADDING\",\n}\n\n\ndef set_endianness(endianness):\n    global Jffs2_device_node_new, Jffs2_device_node_old, Jffs2_unknown_node, Jffs2_raw_dirent, Jffs2_raw_inode, Jffs2_raw_summary, Jffs2_raw_xattr, Jffs2_raw_xref\n\n    Jffs2_device_node_new = Jffs2_device_node_new.parse(\n        Jffs2_device_node_new.__def__,\n        __name__=Jffs2_device_node_new.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_device_node_old = Jffs2_device_node_old.parse(\n        Jffs2_device_node_old.__def__,\n        __name__=Jffs2_device_node_old.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_unknown_node = Jffs2_unknown_node.parse(\n        Jffs2_unknown_node.__def__,\n        __name__=Jffs2_unknown_node.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_dirent = Jffs2_raw_dirent.parse(\n        Jffs2_raw_dirent.__def__,\n        __name__=Jffs2_raw_dirent.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_inode = Jffs2_raw_inode.parse(\n        Jffs2_raw_inode.__def__,\n        __name__=Jffs2_raw_inode.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_summary = Jffs2_raw_summary.parse(\n        Jffs2_raw_summary.__def__,\n        __name__=Jffs2_raw_summary.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_xattr = Jffs2_raw_xattr.parse(\n        Jffs2_raw_xattr.__def__,\n        __name__=Jffs2_raw_xattr.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_xref = Jffs2_raw_xref.parse(\n        Jffs2_raw_xref.__def__,\n        __name__=Jffs2_raw_xref.__name__,\n        __byte_order__=endianness,\n    )\n\n\ndef scan_fs(content, endianness, verbose=False):\n    summaries = []\n    pos = 0\n    jffs2_old_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_OLD_MAGIC_BITMASK)\n    jffs2_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_MAGIC_BITMASK)\n    fs_index = 0\n\n    fs = {}\n    fs[fs_index] = {}\n    fs[fs_index][\"endianness\"] = endianness\n    fs[fs_index][JFFS2_NODETYPE_INODE] = []\n    fs[fs_index][JFFS2_NODETYPE_DIRENT] = []\n    fs[fs_index][JFFS2_NODETYPE_XATTR] = []\n    fs[fs_index][JFFS2_NODETYPE_XREF] = []\n    fs[fs_index][JFFS2_NODETYPE_SUMMARY] = []\n\n    dirent_dict = {}\n    while True:\n        find_result = content.find(\n            jffs2_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        find_result_old = content.find(\n            jffs2_old_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        if find_result == -1 and find_result_old == -1:\n            break\n        if find_result != -1:\n            pos = find_result\n        else:\n            pos = find_result_old\n\n        unknown_node = Jffs2_unknown_node()\n        unknown_node.unpack(content[pos : pos + unknown_node.size])\n        if not unknown_node.hdr_crc_match:\n            pos += 1\n            continue\n        offset = pos\n        pos += PAD(unknown_node.totlen)\n\n        if unknown_node.magic in [\n             JFFS2_MAGIC_BITMASK,\n             JFFS2_OLD_MAGIC_BITMASK,\n        ]:\n            if unknown_node.nodetype in NODETYPES:\n                if unknown_node.nodetype == JFFS2_NODETYPE_DIRENT:\n                    dirent = Jffs2_raw_dirent()\n                    dirent.unpack(content[0 + offset :], offset)\n                    if dirent.ino in dirent_dict:\n                        print(\"duplicate inode use detected!!!\")\n                        fs_index += 1\n                        fs[fs_index] = {}\n                        fs[fs_index][\"endianness\"] = endianness\n                        fs[fs_index][JFFS2_NODETYPE_INODE] = []\n                        fs[fs_index][JFFS2_NODETYPE_DIRENT] = []\n                        fs[fs_index][JFFS2_NODETYPE_XATTR] = []\n                        fs[fs_index][JFFS2_NODETYPE_XREF] = []\n                        fs[fs_index][JFFS2_NODETYPE_SUMMARY] = []\n                        dirent_dict = {}\n\n                    dirent_dict[dirent.ino] = dirent\n\n                    fs[fs_index][JFFS2_NODETYPE_DIRENT].append(dirent)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), dirent)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_INODE:\n                    inode = Jffs2_raw_inode()\n                    inode.unpack(content[0 + offset :])\n                    fs[fs_index][JFFS2_NODETYPE_INODE].append(inode)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), inode)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XREF:\n                    xref = Jffs2_raw_xref()\n                    xref.unpack(content[offset : offset + xref.size])\n                    fs[fs_index][JFFS2_NODETYPE_XREF].append(xref)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), xref)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XATTR:\n                    xattr = Jffs2_raw_xattr()\n                    xattr.unpack(content[offset : offset + xattr.size])\n                    fs[fs_index][JFFS2_NODETYPE_XREF].append(xattr)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), xattr)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_SUMMARY:\n                    summary = Jffs2_raw_summary()\n                    summary.unpack(content[offset : offset + summary.size])\n                    summaries.append(summary)\n                    fs[fs_index][JFFS2_NODETYPE_SUMMARY].append(summary)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), summary)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_CLEANMARKER:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_PADDING:\n                    pass\n                else:\n                    print(\"Unhandled node type\", unknown_node.nodetype, unknown_node)\n    return fs.values()\n\n\ndef get_device(inode):\n    if not stat.S_ISBLK(inode.mode) and not stat.S_ISCHR(inode.mode):\n        return None\n\n    if inode.dsize == len(Jffs2_device_node_new):\n        node = Jffs2_device_node_new()\n        node.unpack(inode.data)\n        return os.makedev(\n            (node.new_id & 0xFFF00) >> 8,\n            (node.new_id & 0xFF) | ((node.new_id >> 12) & 0xFFF00),\n        )\n\n    if inode.dsize == len(Jffs2_device_node_old):\n        node = Jffs2_device_node_old()\n        node.unpack(inode.data)\n        return os.makedev((node.old_id >> 8) & 0xFF, node.old_id & 0xFF)\n    return None\n\n\ndef dump_fs(fs, target):\n    node_dict = {}\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT]:\n        dirent.inodes = []\n        for inode in fs[JFFS2_NODETYPE_INODE]:\n            if inode.ino == dirent.ino:\n                dirent.inodes.append(inode)\n        if dirent.ino in node_dict:\n            print(\"duplicate dirent.ino use detected!!!\", dirent)\n        node_dict[dirent.ino] = dirent\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT]:\n        pnode_pino = dirent.pino\n        pnodes = []\n        for _ in range(100):\n            if pnode_pino not in node_dict:\n                break\n            pnode = node_dict[pnode_pino]\n            pnode_pino = pnode.pino\n            pnodes.append(pnode)\n        pnodes.reverse()\n\n        node_names = []\n\n        for pnode in pnodes:\n            node_names.append(pnode.name.decode())\n        node_names.append(dirent.name.decode())\n        path = \"/\".join(node_names)\n\n        target_path = os.path.join(os.getcwd(), target, path)\n        for inode in dirent.inodes:\n            try:\n                if stat.S_ISDIR(inode.mode):\n                    print(\"writing S_ISDIR\", path)\n                    if not os.path.isdir(target_path):\n                        os.makedirs(target_path)\n                elif stat.S_ISLNK(inode.mode):\n                    print(\"writing S_ISLNK\", path)\n                    if not os.path.islink(target_path):\n                        if os.path.exists(target_path):\n                            print(\"file already exists as\", inode.data)\n                            continue\n                        os.symlink(inode.data, target_path)\n                elif stat.S_ISREG(inode.mode):\n                    print(\"writing S_ISREG\", path)\n                    if not os.path.isfile(target_path):\n                        if not os.path.isdir(os.path.dirname(target_path)):\n                            os.makedirs(os.path.dirname(target_path))\n                        with open(target_path, \"wb\") as fd:\n                            for inode in dirent.inodes:\n                                fd.seek(inode.offset)\n                                fd.write(inode.data)\n                    os.chmod(target_path, stat.S_IMODE(inode.mode))\n                    break\n                elif stat.S_ISCHR(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISBLK(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISFIFO(inode.mode):\n                    print(\"skipping S_ISFIFO\", path)\n                elif stat.S_ISSOCK(inode.mode):\n                    print(\"skipping S_ISSOCK\", path)\n                else:\n                    print(\"unhandled inode.mode: %o\" % inode.mode, inode, dirent)\n\n            except OSError as error:\n                print(\"OS error(%i): %s\" % (error.errno, error.strerror), inode, dirent)\n\n\ndef main():\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\"\n    )\n    parser.add_argument(\n        \"-f\", \"--force\", help=\"overwrite destination directory\", action=\"store_true\"\n    )\n    parser.add_argument(\"filesystem\", type=str, help=\"path to filesystem\")\n    parser.add_argument(\n        \"-d\",\n        \"--dest\",\n        type=str,\n        default=\"jffs2-root\",\n        help=\"destination directory (default: jffs-root)\",\n    )\n\n    args = parser.parse_args()\n    dest_path = os.path.join(os.getcwd(), args.dest)\n\n    if os.path.exists(dest_path):\n        if not args.force:\n            print(\"Destination path already exists!\")\n            return\n    else:\n        os.mkdir(dest_path)\n\n    with open(args.filesystem, \"rb\") as filesystem:\n        content = filesystem.read()\n\n    magic = struct.unpack(\"<H\", content[0:2])[0]\n    if magic in [JFFS2_OLD_MAGIC_BITMASK, JFFS2_MAGIC_BITMASK]:\n        endianness = cstruct.LITTLE_ENDIAN\n    else:\n        endianness = cstruct.BIG_ENDIAN\n\n    set_endianness(endianness)\n    fs_list = list(scan_fs(content, endianness, verbose=args.verbose))\n\n    fs_index = 1\n    for fs in fs_list:\n        if not fs[JFFS2_NODETYPE_DIRENT]:\n            continue\n\n        dest_path_fs = os.path.join(dest_path, \"fs_%i\" % fs_index)\n        print(\"dumping fs #%i to %s\" % (fs_index, dest_path_fs))\n        for key, value in fs.items():\n            if key == \"endianness\":\n                if value == cstruct.BIG_ENDIAN:\n                    print(\"Endianness: Big\")\n                elif value == cstruct.LITTLE_ENDIAN:\n                    print(\"Endianness: Little\")\n                continue\n\n            print(\"%s count: %i\" % (NODETYPES[key].__name__, len(value)))\n\n        if not os.path.exists(dest_path_fs):\n            os.mkdir(dest_path_fs)\n\n        dump_fs(fs, dest_path_fs)\n        print(\"-\" * 10)\n        fs_index += 1\n\n\nif __name__ == \"__main__\":\n    main()\n"], "fixing_code": ["#!/usr/bin/env python3\n\nimport argparse\nimport struct\nimport stat\nimport os\nimport zlib\nimport binascii\nimport cstruct\n\nfrom jefferson import jffs2_lzma, rtime\n\n\ndef PAD(x):\n    return ((x) + 3) & ~3\n\n\nJFFS2_OLD_MAGIC_BITMASK = 0x1984\nJFFS2_MAGIC_BITMASK = 0x1985\nJFFS2_COMPR_NONE = 0x00\nJFFS2_COMPR_ZERO = 0x01\nJFFS2_COMPR_RTIME = 0x02\nJFFS2_COMPR_RUBINMIPS = 0x03\nJFFS2_COMPR_COPY = 0x04\nJFFS2_COMPR_DYNRUBIN = 0x05\nJFFS2_COMPR_ZLIB = 0x06\nJFFS2_COMPR_LZO = 0x07\nJFFS2_COMPR_LZMA = 0x08\n\n# /* Compatibility flags. */\nJFFS2_COMPAT_MASK = 0xC000  # /* What do to if an unknown nodetype is found */\nJFFS2_NODE_ACCURATE = 0x2000\n# /* INCOMPAT: Fail to mount the filesystem */\nJFFS2_FEATURE_INCOMPAT = 0xC000\n# /* ROCOMPAT: Mount read-only */\nJFFS2_FEATURE_ROCOMPAT = 0x8000\n# /* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_COPY = 0x4000\n# /* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_DELETE = 0x0000\n\nJFFS2_NODETYPE_DIRENT = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1\nJFFS2_NODETYPE_INODE = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2\nJFFS2_NODETYPE_CLEANMARKER = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3\nJFFS2_NODETYPE_PADDING = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 4\nJFFS2_NODETYPE_SUMMARY = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 6\nJFFS2_NODETYPE_XATTR = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 8\nJFFS2_NODETYPE_XREF = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 9\n\n\ndef mtd_crc(data):\n    return (binascii.crc32(data, -1) ^ -1) & 0xFFFFFFFF\n\ndef is_safe_path(basedir, path, follow_symlinks=True):\n    if follow_symlinks:\n        matchpath = os.path.realpath(path)\n    else:\n        matchpath = os.path.abspath(path)\n    return basedir == os.path.commonpath((basedir, matchpath))\n\ncstruct.typedef(\"uint8\", \"uint8_t\")\ncstruct.typedef(\"uint16\", \"jint16_t\")\ncstruct.typedef(\"uint32\", \"jint32_t\")\ncstruct.typedef(\"uint32\", \"jmode_t\")\n\n\nclass Jffs2_unknown_node(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            /* All start like this */\n            jint16_t magic;\n            jint16_t nodetype;\n            jint32_t totlen; /* So we can skip over nodes we don't grok */\n            jint32_t hdr_crc;\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        comp_hrd_crc = mtd_crc(data[: self.size - 4])\n\n        if comp_hrd_crc == self.hdr_crc:\n            self.hdr_crc_match = True\n        else:\n            # print(\"hdr_crc does not match!\")\n            self.hdr_crc_match = False\n\n\nclass Jffs2_raw_xattr(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* = JFFS2_NODETYPE_XATTR */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t xid;           /* XATTR identifier number */\n            jint32_t version;\n            uint8_t xprefix;\n            uint8_t name_len;\n            jint16_t value_len;\n            jint32_t data_crc;\n            jint32_t node_crc;\n            uint8_t data[0];\n        }\n    \"\"\"\n\n\nclass Jffs2_raw_summary(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* = JFFS2_NODETYPE_SUMMARY */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t sum_num;       /* number of sum entries*/\n            jint32_t cln_mkr;       /* clean marker size, 0 = no cleanmarker */\n            jint32_t padded;        /* sum of the size of padding nodes */\n            jint32_t sum_crc;       /* summary information crc */\n            jint32_t node_crc;      /* node crc */\n            jint32_t sum[0];        /* inode summary info */\n        }\n    \"\"\"\n\n\nclass Jffs2_raw_xref(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* = JFFS2_NODETYPE_XREF */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t ino;           /* inode number */\n            jint32_t xid;           /* XATTR identifier number */\n            jint32_t xseqno;        /* xref sequencial number */\n            jint32_t node_crc;\n        }\n    \"\"\"\n\n\nclass Jffs2_raw_dirent(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* == JFFS2_NODETYPE_DIRENT */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t pino;\n            jint32_t version;\n            jint32_t ino; /* == zero for unlink */\n            jint32_t mctime;\n            uint8_t nsize;\n            uint8_t type;\n            uint8_t unused[2];\n            jint32_t node_crc;\n            jint32_t name_crc;\n        /* uint8_t data[0]; -> name */\n        }\n    \"\"\"\n\n    def unpack(self, data, node_offset):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        self.name = data[self.size : self.size + self.nsize]\n        self.node_offset = node_offset\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"node_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(self.name) == self.name_crc:\n            self.name_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.name_crc_match = False\n\n    def __str__(self):\n        result = []\n        for field in self.__fields__ + [\"name\", \"node_offset\"]:\n            result.append(field + \"=\" + str(getattr(self, field, None)))\n        return type(self).__name__ + \"(\" + \", \".join(result) + \")\"\n\n\nclass Jffs2_raw_inode(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;      /* A constant magic number.  */\n            jint16_t nodetype;   /* == JFFS2_NODETYPE_INODE */\n            jint32_t totlen;     /* Total length of this node (inc data, etc.) */\n            jint32_t hdr_crc;\n            jint32_t ino;        /* Inode number.  */\n            jint32_t version;    /* Version number.  */\n            jmode_t mode;       /* The file's type or mode.  */\n            jint16_t uid;        /* The file's owner.  */\n            jint16_t gid;        /* The file's group.  */\n            jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */\n            jint32_t atime;      /* Last access time.  */\n            jint32_t mtime;      /* Last modification time.  */\n            jint32_t ctime;      /* Change time.  */\n            jint32_t offset;     /* Where to begin to write.  */\n            jint32_t csize;      /* (Compressed) data size */\n            jint32_t dsize;      /* Size of the node's data. (after decompression) */\n            uint8_t compr;       /* Compression algorithm used */\n            uint8_t usercompr;   /* Compression algorithm requested by the user */\n            jint16_t flags;      /* See JFFS2_INO_FLAG_* */\n            jint32_t data_crc;   /* CRC for the (compressed) data.  */\n            jint32_t node_crc;   /* CRC for the raw inode (excluding data)  */\n            /* uint8_t data[0]; */\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n\n        node_data = data[self.size : self.size + self.csize]\n        if self.compr == JFFS2_COMPR_NONE:\n            self.data = node_data\n        elif self.compr == JFFS2_COMPR_ZERO:\n            self.data = b\"\\x00\" * self.dsize\n        elif self.compr == JFFS2_COMPR_ZLIB:\n            self.data = zlib.decompress(node_data)\n        elif self.compr == JFFS2_COMPR_RTIME:\n            self.data = rtime.decompress(node_data, self.dsize)\n        elif self.compr == JFFS2_COMPR_LZMA:\n            self.data = jffs2_lzma.decompress(node_data, self.dsize)\n        else:\n            print(\"compression not implemented\", self)\n            print(node_data.hex()[:20])\n            self.data = node_data\n\n        if len(self.data) != self.dsize:\n            print(\"data length mismatch!\")\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"hdr_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(node_data) == self.data_crc:\n            self.data_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.data_crc_match = False\n\n\nclass Jffs2_device_node_old(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t old_id;\n        }\n    \"\"\"\n\n\nclass Jffs2_device_node_new(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint32_t new_id;\n        }\n    \"\"\"\n\n\nNODETYPES = {\n    JFFS2_FEATURE_INCOMPAT: Jffs2_unknown_node,\n    JFFS2_NODETYPE_DIRENT: Jffs2_raw_dirent,\n    JFFS2_NODETYPE_INODE: Jffs2_raw_inode,\n    JFFS2_NODETYPE_CLEANMARKER: \"JFFS2_NODETYPE_CLEANMARKER\",\n    JFFS2_NODETYPE_SUMMARY: Jffs2_raw_summary,\n    JFFS2_NODETYPE_XATTR: Jffs2_raw_xattr,\n    JFFS2_NODETYPE_XREF: Jffs2_raw_xref,\n    JFFS2_NODETYPE_PADDING: \"JFFS2_NODETYPE_PADDING\",\n}\n\n\ndef set_endianness(endianness):\n    global Jffs2_device_node_new, Jffs2_device_node_old, Jffs2_unknown_node, Jffs2_raw_dirent, Jffs2_raw_inode, Jffs2_raw_summary, Jffs2_raw_xattr, Jffs2_raw_xref\n\n    Jffs2_device_node_new = Jffs2_device_node_new.parse(\n        Jffs2_device_node_new.__def__,\n        __name__=Jffs2_device_node_new.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_device_node_old = Jffs2_device_node_old.parse(\n        Jffs2_device_node_old.__def__,\n        __name__=Jffs2_device_node_old.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_unknown_node = Jffs2_unknown_node.parse(\n        Jffs2_unknown_node.__def__,\n        __name__=Jffs2_unknown_node.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_dirent = Jffs2_raw_dirent.parse(\n        Jffs2_raw_dirent.__def__,\n        __name__=Jffs2_raw_dirent.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_inode = Jffs2_raw_inode.parse(\n        Jffs2_raw_inode.__def__,\n        __name__=Jffs2_raw_inode.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_summary = Jffs2_raw_summary.parse(\n        Jffs2_raw_summary.__def__,\n        __name__=Jffs2_raw_summary.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_xattr = Jffs2_raw_xattr.parse(\n        Jffs2_raw_xattr.__def__,\n        __name__=Jffs2_raw_xattr.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_xref = Jffs2_raw_xref.parse(\n        Jffs2_raw_xref.__def__,\n        __name__=Jffs2_raw_xref.__name__,\n        __byte_order__=endianness,\n    )\n\n\ndef scan_fs(content, endianness, verbose=False):\n    summaries = []\n    pos = 0\n    jffs2_old_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_OLD_MAGIC_BITMASK)\n    jffs2_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_MAGIC_BITMASK)\n    fs_index = 0\n\n    fs = {}\n    fs[fs_index] = {}\n    fs[fs_index][\"endianness\"] = endianness\n    fs[fs_index][JFFS2_NODETYPE_INODE] = []\n    fs[fs_index][JFFS2_NODETYPE_DIRENT] = []\n    fs[fs_index][JFFS2_NODETYPE_XATTR] = []\n    fs[fs_index][JFFS2_NODETYPE_XREF] = []\n    fs[fs_index][JFFS2_NODETYPE_SUMMARY] = []\n\n    dirent_dict = {}\n    while True:\n        find_result = content.find(\n            jffs2_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        find_result_old = content.find(\n            jffs2_old_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        if find_result == -1 and find_result_old == -1:\n            break\n        if find_result != -1:\n            pos = find_result\n        else:\n            pos = find_result_old\n\n        unknown_node = Jffs2_unknown_node()\n        unknown_node.unpack(content[pos : pos + unknown_node.size])\n        if not unknown_node.hdr_crc_match:\n            pos += 1\n            continue\n        offset = pos\n        pos += PAD(unknown_node.totlen)\n\n        if unknown_node.magic in [\n             JFFS2_MAGIC_BITMASK,\n             JFFS2_OLD_MAGIC_BITMASK,\n        ]:\n            if unknown_node.nodetype in NODETYPES:\n                if unknown_node.nodetype == JFFS2_NODETYPE_DIRENT:\n                    dirent = Jffs2_raw_dirent()\n                    dirent.unpack(content[0 + offset :], offset)\n                    if dirent.ino in dirent_dict:\n                        print(\"duplicate inode use detected!!!\")\n                        fs_index += 1\n                        fs[fs_index] = {}\n                        fs[fs_index][\"endianness\"] = endianness\n                        fs[fs_index][JFFS2_NODETYPE_INODE] = []\n                        fs[fs_index][JFFS2_NODETYPE_DIRENT] = []\n                        fs[fs_index][JFFS2_NODETYPE_XATTR] = []\n                        fs[fs_index][JFFS2_NODETYPE_XREF] = []\n                        fs[fs_index][JFFS2_NODETYPE_SUMMARY] = []\n                        dirent_dict = {}\n\n                    dirent_dict[dirent.ino] = dirent\n\n                    fs[fs_index][JFFS2_NODETYPE_DIRENT].append(dirent)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), dirent)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_INODE:\n                    inode = Jffs2_raw_inode()\n                    inode.unpack(content[0 + offset :])\n                    fs[fs_index][JFFS2_NODETYPE_INODE].append(inode)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), inode)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XREF:\n                    xref = Jffs2_raw_xref()\n                    xref.unpack(content[offset : offset + xref.size])\n                    fs[fs_index][JFFS2_NODETYPE_XREF].append(xref)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), xref)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XATTR:\n                    xattr = Jffs2_raw_xattr()\n                    xattr.unpack(content[offset : offset + xattr.size])\n                    fs[fs_index][JFFS2_NODETYPE_XREF].append(xattr)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), xattr)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_SUMMARY:\n                    summary = Jffs2_raw_summary()\n                    summary.unpack(content[offset : offset + summary.size])\n                    summaries.append(summary)\n                    fs[fs_index][JFFS2_NODETYPE_SUMMARY].append(summary)\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), summary)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_CLEANMARKER:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_PADDING:\n                    pass\n                else:\n                    print(\"Unhandled node type\", unknown_node.nodetype, unknown_node)\n    return fs.values()\n\n\ndef get_device(inode):\n    if not stat.S_ISBLK(inode.mode) and not stat.S_ISCHR(inode.mode):\n        return None\n\n    if inode.dsize == len(Jffs2_device_node_new):\n        node = Jffs2_device_node_new()\n        node.unpack(inode.data)\n        return os.makedev(\n            (node.new_id & 0xFFF00) >> 8,\n            (node.new_id & 0xFF) | ((node.new_id >> 12) & 0xFFF00),\n        )\n\n    if inode.dsize == len(Jffs2_device_node_old):\n        node = Jffs2_device_node_old()\n        node.unpack(inode.data)\n        return os.makedev((node.old_id >> 8) & 0xFF, node.old_id & 0xFF)\n    return None\n\n\ndef dump_fs(fs, target):\n    node_dict = {}\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT]:\n        dirent.inodes = []\n        for inode in fs[JFFS2_NODETYPE_INODE]:\n            if inode.ino == dirent.ino:\n                dirent.inodes.append(inode)\n        if dirent.ino in node_dict:\n            print(\"duplicate dirent.ino use detected!!!\", dirent)\n        node_dict[dirent.ino] = dirent\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT]:\n        pnode_pino = dirent.pino\n        pnodes = []\n        for _ in range(100):\n            if pnode_pino not in node_dict:\n                break\n            pnode = node_dict[pnode_pino]\n            pnode_pino = pnode.pino\n            pnodes.append(pnode)\n        pnodes.reverse()\n\n        node_names = []\n\n        for pnode in pnodes:\n            node_names.append(pnode.name.decode())\n        node_names.append(dirent.name.decode())\n        path = \"/\".join(node_names)\n\n        target_path = os.path.realpath(os.path.join(os.getcwd(), target, path))\n\n        if not is_safe_path(target, target_path):\n            print(f\"Path traversal attempt to {target_path}, discarding.\")\n            continue\n\n        for inode in dirent.inodes:\n            try:\n                if stat.S_ISDIR(inode.mode):\n                    print(\"writing S_ISDIR\", path)\n                    if not os.path.isdir(target_path):\n                        os.makedirs(target_path)\n                elif stat.S_ISLNK(inode.mode):\n                    link_path = inode.data.decode('utf-8')\n                    if link_path:\n                        link_path = link_path[1:]\n                    link_target = os.path.realpath(os.path.join(target, link_path))\n                    if not is_safe_path(target, link_target):\n                        print(f\"Path traversal attempt through symlink to {link_target}, discarding.\")\n                        continue\n                    print(\"writing S_ISLNK\", path)\n                    if not os.path.islink(target_path):\n                        if os.path.exists(target_path):\n                            print(\"file already exists as\", inode.data)\n                            continue\n                        os.symlink(link_target, target_path)\n                elif stat.S_ISREG(inode.mode):\n                    print(\"writing S_ISREG\", path)\n                    if not os.path.isfile(target_path):\n                        if not os.path.isdir(os.path.dirname(target_path)):\n                            os.makedirs(os.path.dirname(target_path))\n                        with open(target_path, \"wb\") as fd:\n                            for inode in dirent.inodes:\n                                fd.seek(inode.offset)\n                                fd.write(inode.data)\n                    os.chmod(target_path, stat.S_IMODE(inode.mode))\n                    break\n                elif stat.S_ISCHR(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISBLK(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISFIFO(inode.mode):\n                    print(\"skipping S_ISFIFO\", path)\n                elif stat.S_ISSOCK(inode.mode):\n                    print(\"skipping S_ISSOCK\", path)\n                else:\n                    print(\"unhandled inode.mode: %o\" % inode.mode, inode, dirent)\n\n            except OSError as error:\n                print(\"OS error(%i): %s\" % (error.errno, error.strerror), inode, dirent)\n\n\ndef main():\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\"\n    )\n    parser.add_argument(\n        \"-f\", \"--force\", help=\"overwrite destination directory\", action=\"store_true\"\n    )\n    parser.add_argument(\"filesystem\", type=str, help=\"path to filesystem\")\n    parser.add_argument(\n        \"-d\",\n        \"--dest\",\n        type=str,\n        default=\"jffs2-root\",\n        help=\"destination directory (default: jffs-root)\",\n    )\n\n    args = parser.parse_args()\n    dest_path = os.path.join(os.getcwd(), args.dest)\n\n    if os.path.exists(dest_path):\n        if not args.force:\n            print(\"Destination path already exists!\")\n            return\n    else:\n        os.mkdir(dest_path)\n\n    with open(args.filesystem, \"rb\") as filesystem:\n        content = filesystem.read()\n\n    magic = struct.unpack(\"<H\", content[0:2])[0]\n    if magic in [JFFS2_OLD_MAGIC_BITMASK, JFFS2_MAGIC_BITMASK]:\n        endianness = cstruct.LITTLE_ENDIAN\n    else:\n        endianness = cstruct.BIG_ENDIAN\n\n    set_endianness(endianness)\n    fs_list = list(scan_fs(content, endianness, verbose=args.verbose))\n\n    fs_index = 1\n    for fs in fs_list:\n        if not fs[JFFS2_NODETYPE_DIRENT]:\n            continue\n\n        dest_path_fs = os.path.realpath(os.path.join(dest_path, \"fs_%i\" % fs_index))\n        print(\"dumping fs #%i to %s\" % (fs_index, dest_path_fs))\n        for key, value in fs.items():\n            if key == \"endianness\":\n                if value == cstruct.BIG_ENDIAN:\n                    print(\"Endianness: Big\")\n                elif value == cstruct.LITTLE_ENDIAN:\n                    print(\"Endianness: Little\")\n                continue\n\n            print(\"%s count: %i\" % (NODETYPES[key].__name__, len(value)))\n\n        if not os.path.exists(dest_path_fs):\n            os.mkdir(dest_path_fs)\n\n        dump_fs(fs, dest_path_fs)\n        print(\"-\" * 10)\n        fs_index += 1\n\n\nif __name__ == \"__main__\":\n    main()\n"], "filenames": ["src/scripts/jefferson"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [565], "fixing_code_start_loc": [8], "fixing_code_end_loc": [582], "type": "CWE-22", "message": "A vulnerability has been found in sviehb jefferson up to 0.3 and classified as critical. This vulnerability affects unknown code of the file src/scripts/jefferson. The manipulation leads to path traversal. The attack can be initiated remotely. Upgrading to version 0.4 is able to address this issue. The name of the patch is 53b3f2fc34af0bb32afbcee29d18213e61471d87. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218020.", "other": {"cve": {"id": "CVE-2022-4885", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-11T18:15:09.227", "lastModified": "2023-01-18T19:12:09.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in sviehb jefferson up to 0.3 and classified as critical. This vulnerability affects unknown code of the file src/scripts/jefferson. The manipulation leads to path traversal. The attack can be initiated remotely. Upgrading to version 0.4 is able to address this issue. The name of the patch is 53b3f2fc34af0bb32afbcee29d18213e61471d87. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218020."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jefferson_project:jefferson:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.3", "matchCriteriaId": "4F3A47A6-47EB-4FD4-8ED5-5677196CDAAE"}]}]}], "references": [{"url": "https://github.com/sviehb/jefferson/commit/53b3f2fc34af0bb32afbcee29d18213e61471d87", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sviehb/jefferson/pull/36", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/sviehb/jefferson/releases/tag/v0.4", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218020", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218020", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sviehb/jefferson/commit/53b3f2fc34af0bb32afbcee29d18213e61471d87"}}