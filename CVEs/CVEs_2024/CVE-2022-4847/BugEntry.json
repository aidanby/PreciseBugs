{"buggy_code": ["package server\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/labstack/echo-contrib/session\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar (\n\tuserIDContextKey = \"user-id\"\n)\n\nfunc getUserIDContextKey() string {\n\treturn userIDContextKey\n}\n\nfunc setUserSession(ctx echo.Context, user *api.User) error {\n\tsess, _ := session.Get(\"memos_session\", ctx)\n\tsess.Options = &sessions.Options{\n\t\tPath:     \"/\",\n\t\tMaxAge:   3600 * 24 * 30,\n\t\tHttpOnly: true,\n\t}\n\tsess.Values[userIDContextKey] = user.ID\n\terr := sess.Save(ctx.Request(), ctx.Response())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set session, err: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc removeUserSession(ctx echo.Context) error {\n\tsess, _ := session.Get(\"memos_session\", ctx)\n\tsess.Options = &sessions.Options{\n\t\tPath:     \"/\",\n\t\tMaxAge:   0,\n\t\tHttpOnly: true,\n\t}\n\tsess.Values[userIDContextKey] = nil\n\terr := sess.Save(ctx.Request(), ctx.Response())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set session, err: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tpath := c.Path()\n\n\t\t// Skip auth.\n\t\tif common.HasPrefixes(path, \"/api/auth\") {\n\t\t\treturn next(c)\n\t\t}\n\n\t\t{\n\t\t\t// If there is openId in query string and related user is found, then skip auth.\n\t\t\topenID := c.QueryParam(\"openId\")\n\t\t\tif openID != \"\" {\n\t\t\t\tuserFind := &api.UserFind{\n\t\t\t\t\tOpenID: &openID,\n\t\t\t\t}\n\t\t\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\t\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user by open_id\").SetInternal(err)\n\t\t\t\t}\n\t\t\t\tif user != nil {\n\t\t\t\t\t// Stores userID into context.\n\t\t\t\t\tc.Set(getUserIDContextKey(), user.ID)\n\t\t\t\t\treturn next(c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tsess, _ := session.Get(\"memos_session\", c)\n\t\t\tuserIDValue := sess.Values[userIDContextKey]\n\t\t\tif userIDValue != nil {\n\t\t\t\tuserID, _ := strconv.Atoi(fmt.Sprintf(\"%v\", userIDValue))\n\t\t\t\tuserFind := &api.UserFind{\n\t\t\t\t\tID: &userID,\n\t\t\t\t}\n\t\t\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\t\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find user by ID: %d\", userID)).SetInternal(err)\n\t\t\t\t}\n\t\t\t\tif user != nil {\n\t\t\t\t\tif user.RowStatus == api.Archived {\n\t\t\t\t\t\treturn echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(\"User has been archived with username %s\", user.Username))\n\t\t\t\t\t}\n\t\t\t\t\tc.Set(getUserIDContextKey(), userID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif common.HasPrefixes(path, \"/api/ping\", \"/api/status\", \"/api/user/:id\", \"/api/memo/all\", \"/api/memo/:memoId\", \"/api/memo/amount\") && c.Request().Method == http.MethodGet {\n\t\t\treturn next(c)\n\t\t}\n\n\t\tif common.HasPrefixes(path, \"/api/memo\", \"/api/tag\", \"/api/shortcut\") && c.Request().Method == http.MethodGet {\n\t\t\tif _, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\t\treturn next(c)\n\t\t\t}\n\t\t}\n\n\t\tuserID := c.Get(getUserIDContextKey())\n\t\tif userID == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\treturn next(c)\n\t}\n}\n", "package server\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/server/profile\"\n\t\"github.com/usememos/memos/store\"\n\n\t\"github.com/gorilla/securecookie\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/labstack/echo-contrib/session\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Server struct {\n\te *echo.Echo\n\n\tCollector *MetricCollector\n\n\tProfile *profile.Profile\n\n\tStore *store.Store\n}\n\nfunc NewServer(profile *profile.Profile) *Server {\n\te := echo.New()\n\te.Debug = true\n\te.HideBanner = true\n\te.HidePort = true\n\n\te.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `{\"time\":\"${time_rfc3339}\",` +\n\t\t\t`\"method\":\"${method}\",\"uri\":\"${uri}\",` +\n\t\t\t`\"status\":${status},\"error\":\"${error}\"}` + \"\\n\",\n\t}))\n\n\te.Use(middleware.CORS())\n\n\te.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{\n\t\tSkipper:      middleware.DefaultSkipper,\n\t\tErrorMessage: \"Request timeout\",\n\t\tTimeout:      30 * time.Second,\n\t}))\n\n\tembedFrontend(e)\n\n\t// In dev mode, set the const secret key to make signin session persistence.\n\tsecret := []byte(\"usememos\")\n\tif profile.Mode == \"prod\" {\n\t\tsecret = securecookie.GenerateRandomKey(16)\n\t}\n\te.Use(session.Middleware(sessions.NewCookieStore(secret)))\n\n\ts := &Server{\n\t\te:       e,\n\t\tProfile: profile,\n\t}\n\n\trootGroup := e.Group(\"\")\n\ts.registerRSSRoutes(rootGroup)\n\n\twebhookGroup := e.Group(\"/h\")\n\ts.registerResourcePublicRoutes(webhookGroup)\n\n\tpublicGroup := e.Group(\"/o\")\n\ts.registerResourcePublicRoutes(publicGroup)\n\ts.registerGetterPublicRoutes(publicGroup)\n\n\tapiGroup := e.Group(\"/api\")\n\tapiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn aclMiddleware(s, next)\n\t})\n\ts.registerSystemRoutes(apiGroup)\n\ts.registerAuthRoutes(apiGroup)\n\ts.registerUserRoutes(apiGroup)\n\ts.registerMemoRoutes(apiGroup)\n\ts.registerShortcutRoutes(apiGroup)\n\ts.registerResourceRoutes(apiGroup)\n\ts.registerTagRoutes(apiGroup)\n\n\treturn s\n}\n\nfunc (server *Server) Run() error {\n\treturn server.e.Start(fmt.Sprintf(\":%d\", server.Profile.Port))\n}\n"], "fixing_code": ["package server\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/usememos/memos/api\"\n\t\"github.com/usememos/memos/common\"\n\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/labstack/echo-contrib/session\"\n\t\"github.com/labstack/echo/v4\"\n)\n\nvar (\n\tuserIDContextKey = \"user-id\"\n)\n\nfunc getUserIDContextKey() string {\n\treturn userIDContextKey\n}\n\nfunc setUserSession(ctx echo.Context, user *api.User) error {\n\tsess, _ := session.Get(\"memos_session\", ctx)\n\tsess.Options = &sessions.Options{\n\t\tPath:     \"/\",\n\t\tMaxAge:   3600 * 24 * 30,\n\t\tHttpOnly: true,\n\t\tSameSite: http.SameSiteStrictMode,\n\t}\n\tsess.Values[userIDContextKey] = user.ID\n\terr := sess.Save(ctx.Request(), ctx.Response())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set session, err: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc removeUserSession(ctx echo.Context) error {\n\tsess, _ := session.Get(\"memos_session\", ctx)\n\tsess.Options = &sessions.Options{\n\t\tPath:     \"/\",\n\t\tMaxAge:   0,\n\t\tHttpOnly: true,\n\t}\n\tsess.Values[userIDContextKey] = nil\n\terr := sess.Save(ctx.Request(), ctx.Response())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set session, err: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {\n\treturn func(c echo.Context) error {\n\t\tctx := c.Request().Context()\n\t\tpath := c.Path()\n\n\t\t// Skip auth.\n\t\tif common.HasPrefixes(path, \"/api/auth\") {\n\t\t\treturn next(c)\n\t\t}\n\n\t\t{\n\t\t\t// If there is openId in query string and related user is found, then skip auth.\n\t\t\topenID := c.QueryParam(\"openId\")\n\t\t\tif openID != \"\" {\n\t\t\t\tuserFind := &api.UserFind{\n\t\t\t\t\tOpenID: &openID,\n\t\t\t\t}\n\t\t\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\t\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to find user by open_id\").SetInternal(err)\n\t\t\t\t}\n\t\t\t\tif user != nil {\n\t\t\t\t\t// Stores userID into context.\n\t\t\t\t\tc.Set(getUserIDContextKey(), user.ID)\n\t\t\t\t\treturn next(c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tsess, _ := session.Get(\"memos_session\", c)\n\t\t\tuserIDValue := sess.Values[userIDContextKey]\n\t\t\tif userIDValue != nil {\n\t\t\t\tuserID, _ := strconv.Atoi(fmt.Sprintf(\"%v\", userIDValue))\n\t\t\t\tuserFind := &api.UserFind{\n\t\t\t\t\tID: &userID,\n\t\t\t\t}\n\t\t\t\tuser, err := s.Store.FindUser(ctx, userFind)\n\t\t\t\tif err != nil && common.ErrorCode(err) != common.NotFound {\n\t\t\t\t\treturn echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(\"Failed to find user by ID: %d\", userID)).SetInternal(err)\n\t\t\t\t}\n\t\t\t\tif user != nil {\n\t\t\t\t\tif user.RowStatus == api.Archived {\n\t\t\t\t\t\treturn echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(\"User has been archived with username %s\", user.Username))\n\t\t\t\t\t}\n\t\t\t\t\tc.Set(getUserIDContextKey(), userID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif common.HasPrefixes(path, \"/api/ping\", \"/api/status\", \"/api/user/:id\", \"/api/memo/all\", \"/api/memo/:memoId\", \"/api/memo/amount\") && c.Request().Method == http.MethodGet {\n\t\t\treturn next(c)\n\t\t}\n\n\t\tif common.HasPrefixes(path, \"/api/memo\", \"/api/tag\", \"/api/shortcut\") && c.Request().Method == http.MethodGet {\n\t\t\tif _, err := strconv.Atoi(c.QueryParam(\"creatorId\")); err == nil {\n\t\t\t\treturn next(c)\n\t\t\t}\n\t\t}\n\n\t\tuserID := c.Get(getUserIDContextKey())\n\t\tif userID == nil {\n\t\t\treturn echo.NewHTTPError(http.StatusUnauthorized, \"Missing user in session\")\n\t\t}\n\n\t\treturn next(c)\n\t}\n}\n", "package server\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/usememos/memos/server/profile\"\n\t\"github.com/usememos/memos/store\"\n\n\t\"github.com/gorilla/securecookie\"\n\t\"github.com/gorilla/sessions\"\n\t\"github.com/labstack/echo-contrib/session\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\ntype Server struct {\n\te *echo.Echo\n\n\tCollector *MetricCollector\n\n\tProfile *profile.Profile\n\n\tStore *store.Store\n}\n\nfunc NewServer(profile *profile.Profile) *Server {\n\te := echo.New()\n\te.Debug = true\n\te.HideBanner = true\n\te.HidePort = true\n\n\te.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{\n\t\tFormat: `{\"time\":\"${time_rfc3339}\",` +\n\t\t\t`\"method\":\"${method}\",\"uri\":\"${uri}\",` +\n\t\t\t`\"status\":${status},\"error\":\"${error}\"}` + \"\\n\",\n\t}))\n\n\te.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{\n\t\tTokenLookup: \"cookie:_csrf\",\n\t}))\n\n\te.Use(middleware.CORS())\n\n\te.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{\n\t\tSkipper:      middleware.DefaultSkipper,\n\t\tErrorMessage: \"Request timeout\",\n\t\tTimeout:      30 * time.Second,\n\t}))\n\n\tembedFrontend(e)\n\n\t// In dev mode, set the const secret key to make signin session persistence.\n\tsecret := []byte(\"usememos\")\n\tif profile.Mode == \"prod\" {\n\t\tsecret = securecookie.GenerateRandomKey(16)\n\t}\n\te.Use(session.Middleware(sessions.NewCookieStore(secret)))\n\n\ts := &Server{\n\t\te:       e,\n\t\tProfile: profile,\n\t}\n\n\trootGroup := e.Group(\"\")\n\ts.registerRSSRoutes(rootGroup)\n\n\twebhookGroup := e.Group(\"/h\")\n\ts.registerResourcePublicRoutes(webhookGroup)\n\n\tpublicGroup := e.Group(\"/o\")\n\ts.registerResourcePublicRoutes(publicGroup)\n\ts.registerGetterPublicRoutes(publicGroup)\n\n\tapiGroup := e.Group(\"/api\")\n\tapiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn aclMiddleware(s, next)\n\t})\n\ts.registerSystemRoutes(apiGroup)\n\ts.registerAuthRoutes(apiGroup)\n\ts.registerUserRoutes(apiGroup)\n\ts.registerMemoRoutes(apiGroup)\n\ts.registerShortcutRoutes(apiGroup)\n\ts.registerResourceRoutes(apiGroup)\n\ts.registerTagRoutes(apiGroup)\n\n\treturn s\n}\n\nfunc (server *Server) Run() error {\n\treturn server.e.Start(fmt.Sprintf(\":%d\", server.Profile.Port))\n}\n"], "filenames": ["server/acl.go", "server/server.go"], "buggy_code_start_loc": [29, 36], "buggy_code_end_loc": [29, 36], "fixing_code_start_loc": [30, 37], "fixing_code_end_loc": [31, 41], "type": "CWE-941", "message": "Incorrectly Specified Destination in a Communication Channel in GitHub repository usememos/memos prior to 0.9.1.", "other": {"cve": {"id": "CVE-2022-4847", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-29T18:15:10.450", "lastModified": "2023-01-05T21:51:29.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Incorrectly Specified Destination in a Communication Channel in GitHub repository usememos/memos prior to 0.9.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-941"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usememos:memos:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.1", "matchCriteriaId": "7E75ADB4-9898-49F3-BF80-3C54F4CE0FB4"}]}]}], "references": [{"url": "https://github.com/usememos/memos/commit/c9bb2b785dc5852655405d5c9ab127a2d5aa3948", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ff6d4b5a-5e75-4a14-b5ce-f318f8613b73", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/usememos/memos/commit/c9bb2b785dc5852655405d5c9ab127a2d5aa3948"}}