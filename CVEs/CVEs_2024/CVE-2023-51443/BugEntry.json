{"buggy_code": ["/*\n * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application\n * Copyright (C) 2005-2014, Anthony Minessale II <anthm@freeswitch.org>\n *\n * Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application\n *\n * The Initial Developer of the Original Code is\n * Anthony Minessale II <anthm@freeswitch.org>\n * Portions created by the Initial Developer are Copyright (C)\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n * Anthony Minessale II <anthm@freeswitch.org>\n * Marcel Barbulescu <marcelbarbulescu@gmail.com>\n * Seven Du <dujinfang@gmail.com>\n * Noah Mehl - Open Telecom Foundation <https://opentelecom.foundation>\n *\n * switch_rtp.c -- RTP\n *\n */\n#include <switch.h>\n#ifndef _MSC_VER\n#include <switch_private.h>\n#endif\n#include <switch_stun.h>\n#include <fspr_network_io.h>\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef PACKAGE_BUGREPORT\n#undef VERSION\n#undef PACKAGE\n#undef inline\n#include <srtp.h>\n#include <srtp_priv.h>\n#include <switch_ssl.h>\n#include <switch_jitterbuffer.h>\n\n//#define DEBUG_TS_ROLLOVER\n#ifdef DEBUG_TS_ROLLOVER\n#define TS_ROLLOVER_START 4294951295\n#endif\n\n//#define DEBUG_2833\n//#define RTP_DEBUG_WRITE_DELTA\n//#define DEBUG_MISSED_SEQ\n//#define DEBUG_EXTRA\n//#define DEBUG_RTCP\n#define DEBUG_ESTIMATORS_\n\n\n#define JITTER_LEAD_FRAMES 10\n#define READ_INC(rtp_session) switch_mutex_lock(rtp_session->read_mutex); rtp_session->reading++\n#define READ_DEC(rtp_session) rtp_session->reading--; switch_mutex_unlock(rtp_session->read_mutex)\n#define WRITE_INC(rtp_session) switch_mutex_lock(rtp_session->write_mutex); rtp_session->writing++\n#define WRITE_DEC(rtp_session) rtp_session->writing--; switch_mutex_unlock(rtp_session->write_mutex)\n\n#define RTP_STUN_FREQ 1000000\n#define rtp_header_len 12\n#define RTP_START_PORT 16384\n#define RTP_END_PORT 32768\n#define MASTER_KEY_LEN   30\n#define RTP_MAGIC_NUMBER 42\n#define WARN_SRTP_ERRS 10\n#define MAX_SRTP_ERRS 100\n#define NTP_TIME_OFFSET 2208988800UL\nstatic const switch_payload_t INVALID_PT = 255;\n\n#define DTMF_SANITY (rtp_session->one_second * 30)\n\n#define rtp_session_name(_rtp_session) _rtp_session->session ? switch_core_session_get_name(_rtp_session->session) : \"-\"\n\n#define STUN_USERNAME_MAX_SIZE 513 /* From RFC5389:  \"It MUST contain a UTF-8 [RFC3629] encoded sequence of less than 513 bytes\" */\n#define SDP_UFRAG_MAX_SIZE 256 \t/* From draft-ietf-mmusic-ice-sip-sdp-24: \"the ice-ufrag attribute MUST NOT be longer than 32\n\t\t\t\t\t\t\t\t * characters when sending, but an implementation MUST accept up to 256\n\t\t\t\t\t\t\t\t * characters when receiving.\" */\n\nstatic switch_port_t START_PORT = RTP_START_PORT;\nstatic switch_port_t END_PORT = RTP_END_PORT;\nstatic switch_mutex_t *port_lock = NULL;\nstatic switch_size_t do_flush(switch_rtp_t *rtp_session, int force, switch_size_t bytes_in);\n\ntypedef srtp_hdr_t rtp_hdr_t;\n\n\n#ifdef _MSC_VER\n#pragma pack(4)\n#endif\n\n#ifdef _MSC_VER\n#pragma pack()\n#define ENABLE_SRTP\n#endif\n\nstatic switch_hash_t *alloc_hash = NULL;\n\ntypedef struct {\n\tsrtp_hdr_t header;\n\tchar body[SWITCH_RTP_MAX_BUF_LEN+4+sizeof(char *)];\n\tswitch_rtp_hdr_ext_t *ext;\n\tchar *ebody;\n} rtp_msg_t;\n\n#define RTP_BODY(_s) (char *) (_s->recv_msg.ebody ? _s->recv_msg.ebody : _s->recv_msg.body)\n\ntypedef struct {\n\tuint32_t ssrc;\n\tuint8_t seq;\n\tuint8_t r1;\n\tuint8_t r2;\n\tuint8_t r3;\n} rtcp_fir_t;\n\n#ifdef _MSC_VER\n#pragma pack(push, r1, 1)\n#endif\n\ntypedef struct switch_rtcp_sdes_unit_s {\n\tunsigned char type;\n\tunsigned char length;\n\tchar value[];\n} switch_rtcp_sdes_unit_t;\n\ntypedef struct {\n\tuint32_t ssrc;\n\tuint8_t parts[4];\n} rtcp_tmmbx_t;\n\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\ntypedef struct {\n\tunsigned version:2;\n\tunsigned p:1;\n\tunsigned fmt:5;\n\tunsigned pt:8;\n\tunsigned length:16;\n\tuint32_t send_ssrc;\n\tuint32_t recv_ssrc;\n} switch_rtcp_ext_hdr_t;\n\n#else /*  BIG_ENDIAN */\n\ntypedef struct {\n\tunsigned fmt:5;\n\tunsigned p:1;\n\tunsigned version:2;\n\tunsigned pt:8;\n\tunsigned length:16;\n\tuint32_t send_ssrc;\n\tuint32_t recv_ssrc;\n} switch_rtcp_ext_hdr_t;\n\n#endif\n\n#ifdef _MSC_VER\n#pragma pack(pop, r1)\n#endif\n\n#define KALMAN_SYSTEM_MODELS 3 /*loss, jitter, rtt*/\n#define EST_LOSS 0\n#define EST_JITTER 1\n#define EST_RTT 2\n\ntypedef struct {\n\tswitch_rtcp_ext_hdr_t header;\n\tchar body[SWITCH_RTCP_MAX_BUF_LEN];\n} rtcp_ext_msg_t;\n\ntypedef struct {\n\tswitch_rtcp_hdr_t header;\n\tchar body[SWITCH_RTCP_MAX_BUF_LEN];\n} rtcp_msg_t;\n\n\ntypedef enum {\n\tVAD_FIRE_TALK = (1 << 0),\n\tVAD_FIRE_NOT_TALK = (1 << 1)\n} vad_talk_mask_t;\n\nstruct switch_rtp_vad_data {\n\tswitch_core_session_t *session;\n\tswitch_codec_t vad_codec;\n\tswitch_codec_t *read_codec;\n\tuint32_t bg_level;\n\tuint32_t bg_count;\n\tuint32_t bg_len;\n\tuint32_t diff_level;\n\tuint8_t hangunder;\n\tuint8_t hangunder_hits;\n\tuint8_t hangover;\n\tuint8_t hangover_hits;\n\tuint8_t cng_freq;\n\tuint8_t cng_count;\n\tswitch_vad_flag_t flags;\n\tuint32_t ts;\n\tuint8_t start;\n\tuint8_t start_count;\n\tuint8_t scan_freq;\n\ttime_t next_scan;\n\tswitch_time_t start_talking;\n\tswitch_time_t stop_talking;\n\tswitch_time_t total_talk_time;\n\tint fire_events;\n};\n\nstruct switch_rtp_rfc2833_data {\n\tswitch_queue_t *dtmf_queue;\n\tchar out_digit;\n\tunsigned char out_digit_packet[4];\n\tunsigned int out_digit_sofar;\n\tunsigned int out_digit_sub_sofar;\n\tunsigned int out_digit_dur;\n\tuint16_t in_digit_seq;\n\tuint32_t in_digit_ts;\n\tuint32_t last_in_digit_ts;\n\tuint32_t in_digit_sanity;\n\tuint32_t in_interleaved;\n\tuint32_t timestamp_dtmf;\n\tuint16_t last_duration;\n\tuint32_t flip;\n\tchar first_digit;\n\tchar last_digit;\n\tswitch_queue_t *dtmf_inqueue;\n\tswitch_mutex_t *dtmf_mutex;\n\tuint8_t in_digit_queued;\n};\n\ntypedef struct {\n\tchar *ice_user;\n\tchar *user_ice;\n\tchar *luser_ice;\n\tchar *pass;\n\tchar *rpass;\n\tswitch_sockaddr_t *addr;\n\tuint32_t funny_stun;\n\tswitch_time_t next_run;\n\tswitch_core_media_ice_type_t type;\n\tice_t *ice_params;\n\tice_proto_t proto;\n\tuint8_t sending;\n\tuint8_t ready;\n\tuint8_t rready;\n\tuint8_t initializing;\n\tint missed_count;\n\tchar last_sent_id[13];\n\tswitch_time_t last_ok;\n\tuint8_t cand_responsive;\n} switch_rtp_ice_t;\n\nstruct switch_rtp;\n\nstatic void switch_rtp_dtls_init(void);\nstatic void switch_rtp_dtls_destroy(void);\n\n#define MAX_DTLS_MTU 4096\n\ntypedef struct switch_dtls_s {\n\t/* DTLS */\n\tSSL_CTX *ssl_ctx;\n\tSSL *ssl;\n\tBIO *read_bio;\n\tBIO *write_bio;\n\tBIO *filter_bio;\n\tdtls_fingerprint_t *local_fp;\n\tdtls_fingerprint_t *remote_fp;\n\tdtls_state_t state;\n\tdtls_state_t last_state;\n\tuint8_t new_state;\n\tdtls_type_t type;\n\tswitch_size_t bytes;\n\tvoid *data;\n\tswitch_socket_t *sock_output;\n\tswitch_sockaddr_t *remote_addr;\n\tchar *rsa;\n\tchar *pvt;\n\tchar *ca;\n\tchar *pem;\n\tstruct switch_rtp *rtp_session;\n\tint mtu;\n} switch_dtls_t;\n\ntypedef int (*dtls_state_handler_t)(switch_rtp_t *, switch_dtls_t *);\n\n\nstatic int dtls_state_handshake(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\nstatic int dtls_state_ready(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\nstatic int dtls_state_setup(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\nstatic int dtls_state_fail(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\n\ndtls_state_handler_t dtls_states[DS_INVALID] = {NULL, dtls_state_handshake, dtls_state_setup, dtls_state_ready, dtls_state_fail};\n\ntypedef struct ts_normalize_s {\n\tuint32_t last_ssrc;\n\tuint32_t last_frame;\n\tuint32_t ts;\n\tuint32_t delta;\n\tuint32_t delta_ttl;\n\tint last_external;\n} ts_normalize_t;\n\nstruct switch_rtp {\n\t/*\n\t * Two sockets are needed because we might be transcoding protocol families\n\t * (e.g. receive over IPv4 and send over IPv6). In case the protocol\n\t * families are equal, sock_input == sock_output and only one socket is\n\t * used.\n\t */\n\tswitch_socket_t *sock_input, *sock_output, *rtcp_sock_input, *rtcp_sock_output;\n\tswitch_pollfd_t *read_pollfd, *rtcp_read_pollfd;\n\tswitch_pollfd_t *jb_pollfd;\n\n\tswitch_sockaddr_t *local_addr, *rtcp_local_addr;\n\trtp_msg_t send_msg;\n\trtcp_msg_t rtcp_send_msg;\n\tswitch_rtcp_frame_t rtcp_frame;\n\n\tuint8_t send_rr;\n\tuint8_t fir_seq;\n\tuint16_t fir_count;\n\tuint16_t pli_count;\n\tuint32_t cur_tmmbr;\n\tuint32_t tmmbr;\n\tuint32_t tmmbn;\n\n\tts_normalize_t ts_norm;\n\tswitch_sockaddr_t *remote_addr, *rtcp_remote_addr;\n\trtp_msg_t recv_msg;\n\trtcp_msg_t rtcp_recv_msg;\n\trtcp_msg_t *rtcp_recv_msg_p;\n\n\tuint32_t autoadj_window;\n\tuint32_t autoadj_threshold;\n\tuint32_t autoadj_tally;\n\n\tuint32_t rtcp_autoadj_window;\n\tuint32_t rtcp_autoadj_threshold;\n\tuint32_t rtcp_autoadj_tally;\n\n\tsrtp_ctx_t *send_ctx[2];\n\tsrtp_ctx_t *recv_ctx[2];\n\n\tsrtp_policy_t send_policy[2];\n\tsrtp_policy_t recv_policy[2];\n\n\tuint32_t srtp_errs[2];\n\tuint32_t srctp_errs[2];\n\n\n\tint srtp_idx_rtp;\n\tint srtp_idx_rtcp;\n\n\tswitch_dtls_t *dtls;\n\tswitch_dtls_t *rtcp_dtls;\n\n\trtp_hdr_t last_rtp_hdr;\n\n\tuint16_t seq;\n\tuint32_t ssrc;\n\tuint32_t remote_ssrc;\n\tuint32_t last_jb_read_ssrc;\n\tint8_t sending_dtmf;\n\tuint8_t need_mark;\n\tswitch_payload_t payload;\n\tswitch_rtp_invalid_handler_t invalid_handler;\n\tvoid *private_data;\n\tuint32_t ts;\n\t//uint32_t last_clock_ts;\n\tuint32_t last_write_ts;\n\tuint32_t last_read_ts;\n\tuint32_t prev_read_ts;\n\tuint32_t last_cng_ts;\n\tuint32_t last_write_samplecount;\n\tuint32_t delay_samples;\n\tuint32_t next_write_samplecount;\n\tuint32_t max_next_write_samplecount;\n\tuint32_t queue_delay;\n\tswitch_time_t last_write_timestamp;\n\tuint32_t flags[SWITCH_RTP_FLAG_INVALID];\n\tswitch_memory_pool_t *pool;\n\tswitch_sockaddr_t *from_addr, *rtp_from_addr, *rtcp_from_addr, *bundle_internal_addr, *bundle_external_addr;\n\tchar *rx_host;\n\tswitch_port_t rx_port;\n\tswitch_rtp_ice_t ice;\n\tswitch_rtp_ice_t rtcp_ice;\n\tchar *timer_name;\n\tchar *local_host_str;\n\tchar *remote_host_str;\n\tchar *eff_remote_host_str;\n\tswitch_time_t first_stun;\n\tswitch_time_t last_stun;\n\tuint32_t samples_per_interval;\n\tuint32_t samples_per_second;\n\tuint32_t conf_samples_per_interval;\n\tswitch_time_t rtcp_last_sent;\n\tuint32_t rsamples_per_interval;\n\tuint32_t ms_per_packet;\n\tuint32_t one_second;\n\tuint32_t consecutive_flaws;\n\tuint32_t jitter_lead;\n\tdouble old_mean;\n\tswitch_time_t next_stat_check_time;\n\tswitch_port_t local_port;\n\tswitch_port_t remote_port;\n\tswitch_port_t eff_remote_port;\n\tswitch_port_t remote_rtcp_port;\n\n\tstruct switch_rtp_vad_data vad_data;\n\tstruct switch_rtp_rfc2833_data dtmf_data;\n\tswitch_payload_t te;\n\tswitch_payload_t recv_te;\n\tswitch_payload_t cng_pt;\n\tswitch_mutex_t *flag_mutex;\n\tswitch_mutex_t *read_mutex;\n\tswitch_mutex_t *write_mutex;\n\tswitch_mutex_t *ice_mutex;\n\tswitch_timer_t timer;\n\tswitch_timer_t write_timer;\n\tuint8_t ready;\n\tuint8_t cn;\n\tswitch_jb_t *jb;\n\tswitch_jb_t *vb;\n\tswitch_jb_t *vbw;\n\tuint32_t max_missed_packets;\n\tuint32_t missed_count;\n\tswitch_time_t last_media;\n\tuint32_t media_timeout;\n\trtp_msg_t write_msg;\n\tswitch_rtp_crypto_key_t *crypto_keys[SWITCH_RTP_CRYPTO_MAX];\n\tint reading;\n\tint writing;\n\tchar *stun_ip;\n\tswitch_port_t stun_port;\n\tint from_auto;\n\tuint32_t cng_count;\n\tswitch_rtp_bug_flag_t rtp_bugs;\n\tswitch_rtp_stats_t stats;\n\tswitch_rtcp_video_stats_t rtcp_vstats;\n\tuint32_t clean_stream;\n\tuint32_t bad_stream;\n\tuint32_t recovering_stream;\n\n\tuint32_t hot_hits;\n\tuint32_t sync_packets;\n\tint rtcp_interval;\n\tint rtcp_sent_packets;\n\tswitch_bool_t rtcp_fresh_frame;\n\n\tswitch_time_t send_time;\n\tswitch_byte_t auto_adj_used;\n\tswitch_byte_t rtcp_auto_adj_used;\n\tuint8_t pause_jb;\n\tuint16_t last_seq;\n\tuint16_t last_write_seq;\n\tuint8_t video_delta_mode;\n\tswitch_time_t last_read_time;\n\tswitch_size_t last_flush_packet_count;\n\tuint32_t interdigit_delay;\n\tswitch_core_session_t *session;\n\tpayload_map_t **pmaps;\n\tpayload_map_t *pmap_tail;\n\tkalman_estimator_t *estimators[KALMAN_SYSTEM_MODELS];\n\tcusum_kalman_detector_t *detectors[KALMAN_SYSTEM_MODELS];\n\tswitch_time_t last_adj;\n\tswitch_time_t adj_window;\n\tuint32_t elapsed_stun;\n\tuint32_t elapsed_media;\n\tuint32_t elapsed_adj;\n\tuint8_t has_rtp;\n\tuint8_t has_rtcp;\n\tuint8_t has_ice;\n\tuint8_t punts;\n\tuint8_t clean;\n\tuint32_t last_max_vb_frames;\n\tint skip_timer;\n\tuint32_t prev_nacks_inflight;\n};\n\nstruct switch_rtcp_report_block {\n\tuint32_t ssrc; /* The SSRC identifier of the source to which the information in this reception report block pertains. */\n\tunsigned int fraction :8; /* The fraction of RTP data packets from source SSRC_n lost since the previous SR or RR packet was sent */\n\tint lost :24; /* The total number of RTP data packets from source SSRC_n that have been lost since the beginning of reception */\n\tuint32_t highest_sequence_number_received;\n\tuint32_t jitter; /* An estimate of the statistical variance of the RTP data packet interarrival time, measured in timestamp units and expressed as an unsigned integer. */\n\tuint32_t lsr; /* The middle 32 bits out of 64 in the NTP timestamp */\n\tuint32_t dlsr; /* The delay, expressed in units of 1/65536 seconds, between receiving the last SR packet from source SSRC_n and sending this reception report block */\n};\n\nstruct switch_rtcp_sr_head {\n\tuint32_t ssrc;\n\tuint32_t ntp_msw;\n\tuint32_t ntp_lsw;\n\tuint32_t ts;\n\tuint32_t pc;\n\tuint32_t oc;\n};\n\nstruct switch_rtcp_sender_info {\n\tuint32_t ntp_msw;\n\tuint32_t ntp_lsw;\n\tuint32_t ts;\n\tuint32_t pc;\n\tuint32_t oc;\n};\n\nstruct switch_rtcp_sender_report {\n\tuint32_t ssrc;\n\tstruct switch_rtcp_sender_info sender_info;\n\tstruct switch_rtcp_report_block report_block;\n};\n\nstruct switch_rtcp_receiver_report {\n\tuint32_t ssrc;\n\tstruct switch_rtcp_report_block report_block;\n};\n\ntypedef enum {\n\tRESULT_CONTINUE,\n\tRESULT_GOTO_END,\n\tRESULT_GOTO_RECVFROM,\n\tRESULT_GOTO_TIMERCHECK\n} handle_rfc2833_result_t;\n\nstatic void do_2833(switch_rtp_t *rtp_session);\n\n\n#define rtp_type(rtp_session) rtp_session->flags[SWITCH_RTP_FLAG_TEXT] ?  \"text\" : (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] ? \"video\" : \"audio\")\n\n\nstatic void switch_rtp_change_ice_dest(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice, const char *host, switch_port_t port)\n{\n\tint is_rtcp = ice == &rtp_session->rtcp_ice;\n\tconst char *err = \"\";\n\tint i;\n\tuint8_t ice_cand_found_idx = 0;\n\n\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\tif (!strcmp(host, ice->ice_params->cands[i][ice->proto].con_addr) && port == ice->ice_params->cands[i][ice->proto].con_port) {\n\t\t\tice_cand_found_idx = i;\n\t\t}\n\t}\n\n\tif (!ice_cand_found_idx) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"ICE candidate [%s:%d] replaced with [%s:%d]\\n\",\n\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, host, port);\n\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr = switch_core_strdup(rtp_session->pool, host);\n\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port = port;\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"ICE chosen candidate [%s:%d] set to idx [%d]\\n\", host, port, ice_cand_found_idx);\n\t\tice->ice_params->chosen[ice->proto] = ice_cand_found_idx;\n\t}\n\n\tice->missed_count = 0;\n\n\tif (is_rtcp) {\n\t\tice->addr = rtp_session->rtcp_remote_addr;\n\t} else {\n\t\tswitch_rtp_set_remote_address(rtp_session, host, port, 0, SWITCH_FALSE, &err);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\tice->addr = rtp_session->remote_addr;\n\t\t}\n\t}\n\n}\n\n\n\nstatic handle_rfc2833_result_t handle_rfc2833(switch_rtp_t *rtp_session, switch_size_t bytes, int *do_cng)\n{\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]++;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] > DTMF_SANITY) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = 0;\n\t\t} else {\n\t\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\t\t}\n\t}\n\n\n#ifdef DEBUG_2833\n\tif (rtp_session->dtmf_data.in_digit_sanity && !(rtp_session->dtmf_data.in_digit_sanity % 100)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"sanity %d %ld\\n\", rtp_session->dtmf_data.in_digit_sanity, bytes);\n\t}\n#endif\n\n\tif (rtp_session->dtmf_data.in_digit_sanity && !--rtp_session->dtmf_data.in_digit_sanity) {\n\n\t\trtp_session->dtmf_data.last_digit = 0;\n\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Failed DTMF sanity check.\\n\");\n\t}\n\n\tif (!bytes) return RESULT_CONTINUE;\n\n\n\t/* RFC2833 ... like all RFC RE: VoIP, guaranteed to drive you to insanity!\n\t   We know the real rules here, but if we enforce them, it's an interop nightmare so,\n\t   we put up with as much as we can so we don't have to deal with being punished for\n\t   doing it right. Nice guys finish last!\n\t*/\n\n\tif (bytes > rtp_header_len && !rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] &&\n\t\trtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\tswitch_size_t len = bytes - rtp_header_len;\n\t\tunsigned char *packet = (unsigned char *) RTP_BODY(rtp_session);\n\t\tint end;\n\t\tuint16_t duration;\n\t\tchar key;\n\t\tuint16_t in_digit_seq;\n\t\tuint32_t ts;\n\n\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\n\t\tif (!(packet[0] || packet[1] || packet[2] || packet[3]) && len >= 8) {\n\t\t\tpacket += 4;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"DTMF payload offset by 4 bytes.\\n\");\n\t\t}\n\n\t\tif (!(packet[0] || packet[1] || packet[2] || packet[3]) && rtp_session->dtmf_data.in_digit_ts) {\n\t\t\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, \"Failed DTMF payload check.\\n\");\n\t\t\trtp_session->dtmf_data.last_digit = 0;\n\t\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\t\trtp_session->dtmf_data.in_digit_sanity = 0;\n\t\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\t}\n\n\t\tend = packet[1] & 0x80 ? 1 : 0;\n\t\tduration = (packet[2] << 8) + packet[3];\n\t\tkey = switch_rfc2833_to_char(packet[0]);\n\t\tin_digit_seq = ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\t\tts = htonl(rtp_session->last_rtp_hdr.ts);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_PASS_RFC2833]) {\n\n\t\t\tif (end) {\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = DTMF_SANITY - 3;\n\t\t\t} else if (!rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]) {\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = 1;\n\t\t\t}\n\n\t\t\treturn RESULT_CONTINUE;\n\t\t}\n\n\t\tif (in_digit_seq < rtp_session->dtmf_data.in_digit_seq) {\n\t\t\tif (rtp_session->dtmf_data.in_digit_seq - in_digit_seq > 100) {\n\t\t\t\trtp_session->dtmf_data.in_digit_seq = 0;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_2833\n\t\tif (!(packet[0] || packet[1] || packet[2] || packet[3]) && len >= 8) {\n\t\t\tlen -= 4;\n\t\t}\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"packet[%d]: %02x %02x %02x %02x\\n\", (int) len, (unsigned char) packet[0], (unsigned char) packet[1], (unsigned char) packet[2], (unsigned char) packet[3]);\n#endif\n\n\t\tif (in_digit_seq > rtp_session->dtmf_data.in_digit_seq) {\n\n\t\t\trtp_session->dtmf_data.in_digit_seq = in_digit_seq;\n#ifdef DEBUG_2833\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"read: %c %u %u %u %u %d %d %s\\n\",\n\t\t\t\t\t\t\t  key, in_digit_seq, rtp_session->dtmf_data.in_digit_seq,\n\t\t\t\t   ts, duration, rtp_session->last_rtp_hdr.m, end, end && !rtp_session->dtmf_data.in_digit_ts ? \"ignored\" : \"\");\n#endif\n\n\n\t\t\tif (rtp_session->dtmf_data.in_digit_ts && rtp_session->dtmf_data.in_digit_ts != ts) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, \"TS changed from last packet, resetting....\\n\");\n\t\t\t\trtp_session->dtmf_data.last_digit = 0;\n\t\t\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 0;\n\t\t\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\t\t}\n\n\n\t\t\tif (!rtp_session->dtmf_data.in_digit_queued && rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION)) {\n\t\t\t\t\tswitch_dtmf_t dtmf = { key, switch_core_min_dtmf_duration(0), 0, SWITCH_DTMF_RTP };\n#ifdef DEBUG_2833\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Early Queuing digit %c:%d\\n\", dtmf.digit, dtmf.duration / 8);\n#endif\n\t\t\t\t\tswitch_rtp_queue_rfc2833_in(rtp_session, &dtmf);\n\t\t\t\t\trtp_session->dtmf_data.in_digit_queued = 1;\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->jb && (rtp_session->rtp_bugs & RTP_BUG_FLUSH_JB_ON_DTMF)) {\n\t\t\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* only set sanity if we do NOT ignore the packet */\n\t\t\tif (rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 2000;\n\t\t\t}\n\n\t\t\tif (rtp_session->dtmf_data.last_duration > duration &&\n\t\t\t\trtp_session->dtmf_data.last_duration > 0xFC17 && ts == rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\trtp_session->dtmf_data.flip++;\n\t\t\t}\n\n\t\t\tif (end) {\n\t\t\t\tif (!rtp_session->dtmf_data.in_digit_ts && rtp_session->dtmf_data.last_in_digit_ts != ts) {\n#ifdef DEBUG_2833\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"start with end packet %d\\n\", ts);\n#endif\n\t\t\t\t\trtp_session->dtmf_data.last_in_digit_ts = ts;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_ts = ts;\n\t\t\t\t\trtp_session->dtmf_data.first_digit = key;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 2000;\n\t\t\t\t}\n\t\t\t\tif (rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\t\tswitch_dtmf_t dtmf = { key, duration, 0, SWITCH_DTMF_RTP };\n\n\t\t\t\t\tif (ts > rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\t\t\tdtmf.duration += (ts - rtp_session->dtmf_data.in_digit_ts);\n\t\t\t\t\t}\n\t\t\t\t\tif (rtp_session->dtmf_data.flip) {\n\t\t\t\t\t\tdtmf.duration += rtp_session->dtmf_data.flip * 0xFFFF;\n\t\t\t\t\t\trtp_session->dtmf_data.flip = 0;\n#ifdef DEBUG_2833\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"you're welcome!\\n\");\n#endif\n\t\t\t\t\t}\n#ifdef DEBUG_2833\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"done digit=%c ts=%u start_ts=%u dur=%u ddur=%u\\n\",\n\t\t\t\t\t\t   dtmf.digit, ts, rtp_session->dtmf_data.in_digit_ts, duration, dtmf.duration);\n#endif\n\n\t\t\t\t\tif (!(rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION) && !rtp_session->dtmf_data.in_digit_queued) {\n#ifdef DEBUG_2833\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Queuing digit %c:%d\\n\", dtmf.digit, dtmf.duration / 8);\n#endif\n\t\t\t\t\t\tswitch_rtp_queue_rfc2833_in(rtp_session, &dtmf);\n\t\t\t\t\t}\n\n\t\t\t\t\trtp_session->dtmf_data.last_digit = rtp_session->dtmf_data.first_digit;\n\n\t\t\t\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 0;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\t\t\t\t*do_cng = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\t\t\t\treturn RESULT_GOTO_END;\n\t\t\t\t\t}\n\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\treturn RESULT_GOTO_RECVFROM;\n\t\t\t\t}\n\n\t\t\t} else if (!rtp_session->dtmf_data.in_digit_ts) {\n#ifdef DEBUG_2833\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"start %d [%c]\\n\", ts, key);\n#endif\n\t\t\t\trtp_session->dtmf_data.in_digit_ts = ts;\n\t\t\t\trtp_session->dtmf_data.last_in_digit_ts = ts;\n\t\t\t\trtp_session->dtmf_data.first_digit = key;\n\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 2000;\n\t\t\t}\n\n\t\t\trtp_session->dtmf_data.last_duration = duration;\n\t\t} else {\n#ifdef DEBUG_2833\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"drop: %c %u %u %u %u %d %d\\n\",\n\t\t\t\t   key, in_digit_seq, rtp_session->dtmf_data.in_digit_seq, ts, duration, rtp_session->last_rtp_hdr.m, end);\n#endif\n\t\t\tswitch_cond_next();\n\t\t\treturn RESULT_GOTO_RECVFROM;\n\t\t}\n\t}\n\n\tif (rtp_session->dtmf_data.in_digit_ts) {\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\treturn RESULT_GOTO_END;\n\t\t}\n\n\t\tif (!rtp_session->dtmf_data.in_interleaved && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te) {\n\t\t\t/* Drat, they are sending audio still as well as DTMF ok fine..... *sigh* */\n\t\t\trtp_session->dtmf_data.in_interleaved = 1;\n\t\t}\n\n\t\tif (rtp_session->dtmf_data.in_interleaved || (rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION)) {\n\t\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\t\t\treturn RESULT_GOTO_RECVFROM;\n\t\t\t}\n\t\t} else {\n\t\t\t*do_cng = 1;\n\t\t\treturn RESULT_GOTO_TIMERCHECK;\n\t\t}\n\t}\n\n\treturn RESULT_CONTINUE;\n}\n\nstatic int rtp_write_ready(switch_rtp_t *rtp_session, uint32_t bytes, int line);\nstatic int global_init = 0;\nstatic int rtp_common_write(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\trtp_msg_t *send_msg, void *data, uint32_t datalen, switch_payload_t payload, uint32_t timestamp, switch_frame_flag_t *flags);\n\n\n#define MEDIA_TOO_LONG 2000\n#define STUN_TOO_LONG 20000\n#define ADJ_TOO_LONG 1000\n\nstatic void calc_elapsed(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice)\n{\n\tswitch_time_t ref_point;\n\tswitch_time_t now;\n\n\tnow = switch_micro_time_now();\n\n\tif (ice->last_ok && (!rtp_session->dtls || rtp_session->dtls->state == DS_READY)) {\n\t\tref_point = ice->last_ok;\n\t} else {\n\t\tref_point = rtp_session->first_stun;\n\t}\n\n\tif (!ref_point) ref_point = now;\n\n\trtp_session->elapsed_stun = (unsigned int) ((now - ref_point) / 1000);\n\n\tif (rtp_session->last_media) {\n\t\trtp_session->elapsed_media = (unsigned int) ((now - rtp_session->last_media) / 1000);\n\t} else {\n\t\trtp_session->elapsed_media = MEDIA_TOO_LONG + 1;\n\t}\n\n\tif (rtp_session->last_adj) {\n\t\trtp_session->elapsed_adj = (unsigned int) ((now - rtp_session->last_adj) / 1000);\n\t} else {\n\t\trtp_session->elapsed_adj = ADJ_TOO_LONG + 1;\n\t}\n}\n\nstatic switch_status_t ice_out(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice, switch_bool_t force)\n{\n\tuint8_t buf[256] = { 0 };\n\tswitch_stun_packet_t *packet;\n\tunsigned int elapsed;\n\tswitch_size_t bytes;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\t//switch_sockaddr_t *remote_addr = rtp_session->remote_addr;\n\tswitch_socket_t *sock_output = rtp_session->sock_output;\n\tswitch_time_t now = switch_micro_time_now();\n\n\tif (ice->type & ICE_LITE) {\n\t\t// no connectivity checks for ICE-Lite\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tif (!force && ice->next_run && ice->next_run >= now) {\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tice->next_run = now + RTP_STUN_FREQ;\n\n\tif (ice == &rtp_session->rtcp_ice && rtp_session->rtcp_sock_output) {\n\t\tsock_output = rtp_session->rtcp_sock_output;\n\t}\n\n\tif (!sock_output) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_assert(rtp_session != NULL);\n\tswitch_assert(ice->ice_user != NULL);\n\n\tREAD_INC(rtp_session);\n\n\tif (rtp_session->last_stun) {\n\t\telapsed = (unsigned int) ((switch_micro_time_now() - rtp_session->last_stun) / 1000);\n\n\t\tif (elapsed > 30000) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"No %s stun for a long time!\\n\", rtp_type(rtp_session));\n\t\t\trtp_session->last_stun = switch_micro_time_now();\n\t\t\t//status = SWITCH_STATUS_GENERR;\n\t\t\t//goto end;\n\t\t}\n\t}\n\n\tpacket = switch_stun_packet_build_header(SWITCH_STUN_BINDING_REQUEST, NULL, buf);\n\tswitch_stun_packet_attribute_add_username(packet, ice->ice_user, (uint16_t)strlen(ice->ice_user));\n\n\tmemcpy(ice->last_sent_id, packet->header.id, 12);\n\n\t//if (ice->pass && ice->type == ICE_GOOGLE_JINGLE) {\n\t//\tswitch_stun_packet_attribute_add_password(packet, ice->pass, (uint16_t)strlen(ice->pass));\n\t//}\n\n\tif ((ice->type & ICE_VANILLA)) {\n\t\tchar sw[128] = \"\";\n\n\t\tswitch_stun_packet_attribute_add_priority(packet, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].priority);\n\n\t\tswitch_snprintf(sw, sizeof(sw), \"FreeSWITCH (%s)\", switch_version_revision_human());\n\t\tswitch_stun_packet_attribute_add_software(packet, sw, (uint16_t)strlen(sw));\n\n\t\tif ((ice->type & ICE_CONTROLLED)) {\n\t\t\tswitch_stun_packet_attribute_add_controlled(packet);\n\t\t} else {\n\t\t\tswitch_stun_packet_attribute_add_controlling(packet);\n\t\t\tswitch_stun_packet_attribute_add_use_candidate(packet);\n\t\t}\n\n\t\tswitch_stun_packet_attribute_add_integrity(packet, ice->rpass);\n\t\tswitch_stun_packet_attribute_add_fingerprint(packet);\n\t}\n\n\n\tbytes = switch_stun_packet_length(packet);\n\n#ifdef DEBUG_EXTRA\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"%s send %s stun\\n\", rtp_session_name(rtp_session), rtp_type(rtp_session));\n#endif\n\tswitch_socket_sendto(sock_output, ice->addr, 0, (void *) packet, &bytes);\n\n\tice->sending = 3;\n\n\t// end:\n\tREAD_DEC(rtp_session);\n\n\treturn status;\n}\n\nint icecmp(const char *them, switch_rtp_ice_t *ice)\n{\n\tif (strchr(them, ':')) {\n\t\treturn strcmp(them, ice->user_ice);\n\t}\n\n\treturn strcmp(them, ice->luser_ice);\n}\n\nstatic void handle_ice(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice, void *data, switch_size_t len)\n{\n\tswitch_stun_packet_t *packet;\n\tswitch_stun_packet_attribute_t *attr;\n\tvoid *end_buf;\n\tchar username[STUN_USERNAME_MAX_SIZE] = { 0 };\n\tunsigned char buf[1500] = { 0 };\n\tswitch_size_t cpylen = len;\n\tint xlen = 0;\n\tint ok = 1;\n\tuint32_t *pri = NULL;\n\tint is_rtcp = ice == &rtp_session->rtcp_ice;\n\tswitch_channel_t *channel;\n\tint i;\n\tswitch_sockaddr_t *from_addr = rtp_session->from_addr;\n\tconst char *from_host = NULL;\n\tswitch_port_t from_port = 0;\n\tchar faddr_buf[80] = \"\";\n\n\tif (is_rtcp) {\n\t\tfrom_addr = rtp_session->rtcp_from_addr;\n\t}\n\n\tfrom_host = switch_get_addr(faddr_buf, sizeof(faddr_buf), from_addr);\n\tfrom_port = switch_sockaddr_get_port(from_addr);\n\n\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t//\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF OK %s CALL\\n\", rtp_type(rtp_session));\n\t//}\n\n\tif (!switch_rtp_ready(rtp_session) || zstr(ice->user_ice) || zstr(ice->ice_user)) {\n\t\treturn;\n\t}\n\n\tREAD_INC(rtp_session);\n\tWRITE_INC(rtp_session);\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\tgoto end;\n\t}\n\n\tif (cpylen > sizeof(buf)) {\n\t\tcpylen = sizeof(buf);\n\t}\n\n\tchannel = switch_core_session_get_channel(rtp_session->session);\n\n\tmemcpy(buf, data, cpylen);\n\tpacket = switch_stun_packet_parse(buf, (uint32_t)cpylen);\n\tif (!packet) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Invalid STUN/ICE packet received %ld bytes\\n\", (long)cpylen);\n\t\tgoto end;\n\n\t}\n\n\trtp_session->last_stun = switch_micro_time_now();\n\n\tif (!rtp_session->first_stun) {\n\t\trtp_session->first_stun = rtp_session->last_stun;\n\t}\n\n\tcalc_elapsed(rtp_session, ice);\n\n\tend_buf = buf + ((sizeof(buf) > packet->header.length) ? packet->header.length : sizeof(buf));\n\n\tswitch_stun_packet_first_attribute(packet, attr);\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"%s STUN PACKET TYPE: %s\\n\",\n\t\t\t\t\t  rtp_type(rtp_session), switch_stun_value_to_name(SWITCH_STUN_TYPE_PACKET_TYPE, packet->header.type));\n\tdo {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|---: %s STUN ATTR %d %x %s\\n\", rtp_type(rtp_session), attr->type, attr->type,\n\t\t\t\t\t\t  switch_stun_value_to_name(SWITCH_STUN_TYPE_ATTRIBUTE, attr->type));\n\n\t\tswitch (attr->type) {\n\t\tcase SWITCH_STUN_ATTR_USE_CAND:\n\t\t\t{\n\t\t\t\tice->rready = 1;\n\t\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host) && ice->ice_params->cands[i][ice->proto].con_port == from_port) {\n\t\t\t\t\t\tice->ice_params->cands[i][ice->proto].use_candidate = 1;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, \"Got USE-CANDIDATE on %s:%d\\n\", ice->ice_params->cands[i][ice->proto].con_addr, ice->ice_params->cands[i][ice->proto].con_port);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_ERROR_CODE:\n\t\t\t{\n\t\t\t\tswitch_stun_error_code_t *err = (switch_stun_error_code_t *) attr->value;\n\t\t\t\tuint32_t code = (err->code * 100) + err->number;\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s got %s stun binding response %u\\n\",\n\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t\t\t\t  code\n\t\t\t\t\t\t\t\t  );\n\n\t\t\t\tif ((ice->type & ICE_VANILLA) && code == 487) {\n\t\t\t\t\tif ((ice->type & ICE_CONTROLLED)) {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s STUN Changing role to CONTROLLING\\n\", rtp_type(rtp_session));\n\t\t\t\t\t\tice->type &= ~ICE_CONTROLLED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s STUN Changing role to CONTROLLED\\n\", rtp_type(rtp_session));\n\t\t\t\t\t\tice->type |= ICE_CONTROLLED;\n\t\t\t\t\t}\n\t\t\t\t\tpacket->header.type = SWITCH_STUN_BINDING_RESPONSE;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_MAPPED_ADDRESS:\n\t\t\t{\n\t\t\t\tchar ip[50];\n\t\t\t\tuint16_t port;\n\t\t\t\tswitch_stun_packet_attribute_get_mapped_address(attr, ip, sizeof(ip), &port);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %s:%d\\n\", ip, port);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_XOR_MAPPED_ADDRESS:\n\t\t\t{\n\t\t\t\tchar ip[50];\n\t\t\t\tuint16_t port;\n\t\t\t\tswitch_stun_packet_attribute_get_xor_mapped_address(attr, &packet->header, ip, sizeof(ip), &port);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %s:%d\\n\", ip, port);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_USERNAME:\n\t\t\t{\n\t\t\t\tswitch_stun_packet_attribute_get_username(attr, username, sizeof(username));\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %s\\n\", username);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SWITCH_STUN_ATTR_PRIORITY:\n\t\t\t{\n\t\t\t\tuint32_t priority = 0;\n\t\t\t\tpri = (uint32_t *) attr->value;\n\t\t\t\tpriority = ntohl(*pri);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %u\\n\", priority);\n\t\t\t\tok = priority == ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].priority;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!switch_stun_packet_next_attribute(attr, end_buf)) {\n\t\t\tbreak;\n\t\t}\n\n\t\txlen += 4 + switch_stun_attribute_padded_length(attr);\n\t} while (xlen <= packet->header.length);\n\n\tif ((ice->type & ICE_GOOGLE_JINGLE) && ok) {\n\t\tok = !strcmp(ice->user_ice, username);\n\t}\n\n\tif (packet->header.type != SWITCH_STUN_BINDING_REQUEST && packet->header.type != SWITCH_STUN_BINDING_RESPONSE) {\n\t\tgoto end;\n\t}\n\n\tif ((ice->type & ICE_VANILLA)) {\n\t\tif (!ok) ok = !memcmp(packet->header.id, ice->last_sent_id, 12);\n\n\t\tif (packet->header.type == SWITCH_STUN_BINDING_RESPONSE) {\n\t\t\tok = 1;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\trtp_session->ice.rready = 1;\n\t\t\t\trtp_session->rtcp_ice.rready = 1;\n\t\t\t} else {\n\t\t\t\tice->rready = 1;\n\t\t\t}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, \"Received STUN Binding Response from %s\\n\", from_host);\n\n\t\t\tif (ice->ice_params) {\n\t\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host) && ice->ice_params->cands[i][ice->proto].con_port == from_port) {\n\t\t\t\t\t\tice->ice_params->cands[i][ice->proto].responsive = 1;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"Marked ICE candidate %s:%d as responsive\\n\", ice->ice_params->cands[i][ice->proto].con_addr, ice->ice_params->cands[i][ice->proto].con_port);\n\t\t\t\t\t\tif (!strcmp(ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, from_host) && ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port == from_port) {\n\t\t\t\t\t\t\tice->cand_responsive = 1;\n\t\t\t\t\t\t\tice->initializing = 0;\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"Chosen ICE candidate %s:%d is responsive\\n\", ice->ice_params->cands[i][ice->proto].con_addr, ice->ice_params->cands[i][ice->proto].con_port);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\t\tswitch_core_session_video_reinit(rtp_session->session);\n\t\t\t}\n\t\t}\n\n\t\tif (!ok && ice == &rtp_session->ice && rtp_session->rtcp_ice.ice_params && pri &&\n\t\t\t*pri == rtp_session->rtcp_ice.ice_params->cands[rtp_session->rtcp_ice.ice_params->chosen[1]][1].priority) {\n\t\t\tice = &rtp_session->rtcp_ice;\n\t\t\tok = 1;\n\t\t}\n\n\t\tif (!zstr(username)) {\n\t\t\tif (!icecmp(username, ice)) {\n\t\t\t\tok = 1;\n\t\t\t} else if(!zstr(rtp_session->rtcp_ice.user_ice) && !icecmp(username, &rtp_session->rtcp_ice)) {\n\t\t\t\tice = &rtp_session->rtcp_ice;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tice->missed_count = 0;\n\t\t} else {\n\t\t\tswitch_rtp_ice_t *icep[2] = { &rtp_session->ice, &rtp_session->rtcp_ice };\n\t\t\tswitch_port_t port = 0;\n\t\t\tchar *host = NULL;\n\n\t\t\tif (rtp_session->elapsed_stun > STUN_TOO_LONG && pri) {\n\t\t\t\tint i, j;\n\t\t\t\tuint32_t old;\n\t\t\t\t//const char *tx_host;\n\t\t\t\tconst char *old_host, *err = NULL;\n\t\t\t\t//char bufa[50];\n\t\t\t\tchar bufb[50];\n\t\t\t\tchar adj_port[6];\n\t\t\t\tswitch_channel_t *channel = NULL;\n\n\n\t\t\t\tice->missed_count++;\n\t\t\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"missed %d\\n\", ice->missed_count);\n\n\n\t\t\t\tif (rtp_session->session) {\n\t\t\t\t\tchannel = switch_core_session_get_channel(rtp_session->session);\n\t\t\t\t}\n\n\t\t\t\t//ice->ice_params->cands[ice->ice_params->chosen][ice->proto].priority;\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tif (!icep[j] || !icep[j]->ice_params) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < icep[j]->ice_params->cand_idx[icep[j]->proto]; i++) {\n\t\t\t\t\t\tif (icep[j]->ice_params &&  icep[j]->ice_params->cands[i][icep[j]->proto].priority == *pri) {\n\t\t\t\t\t\t\tif (j == IPR_RTP) {\n\t\t\t\t\t\t\t\ticep[j]->ice_params->chosen[j] = i;\n\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Change candidate index to %d\\n\", i);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tice = icep[j];\n\t\t\t\t\t\t\tok = 1;\n\n\t\t\t\t\t\t\tif (j != IPR_RTP) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\told = rtp_session->remote_port;\n\n\t\t\t\t\t\t\t//tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->from_addr);\n\t\t\t\t\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\n\t\t\t\t\t\t\thost = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr;\n\t\t\t\t\t\t\tport = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port;\n\n\t\t\t\t\t\t\tif (!host || !port) {\n\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error setting remote host!\\n\");\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t\t\t  \"%s ICE Auto Changing port from %s:%u to %s:%u\\n\", rtp_type(rtp_session), old_host, old, host, port);\n\n\n\t\t\t\t\t\t\tif (channel) {\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_ip_reported\", switch_channel_get_variable(channel, \"remote_media_ip\"));\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_ip\", host);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"rtp_auto_adjust_ip\", host);\n\t\t\t\t\t\t\t\tswitch_snprintf(adj_port, sizeof(adj_port), \"%u\", port);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_port_reported\", switch_channel_get_variable(channel, \"remote_media_port\"));\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_port\", adj_port);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"rtp_auto_adjust_port\", adj_port);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"rtp_auto_candidate_adjust\", \"true\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trtp_session->auto_adj_used = 1;\n\n\n\t\t\t\t\t\t\tswitch_rtp_set_remote_address(rtp_session, host, port, 0, SWITCH_FALSE, &err);\n\t\t\t\t\t\t\tif (switch_sockaddr_info_get(&ice->addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS ||\n\t\t\t\t\t\t\t\t!ice->addr) {\n\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error setting remote host!\\n\");\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ice->missed_count > 5 && !(ice->type & ICE_GOOGLE_JINGLE)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"missed too many: %d, looking for new ICE dest.\\n\",\n\t\t\t\t\t\t  ice->missed_count);\n\t\tice->rready = 0;\n\t\tice->cand_responsive = 0;\n\t\tok = 1;\n\t}\n\n\n\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] || 1) {\n\t//\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF OK %s %d\\n\", rtp_type(rtp_session), ok);\n\t//}\n\n\tif (ok) {\n\t\tconst char *host2 = NULL;\n\t\tswitch_port_t port2 = 0;\n\t\tchar buf2[80] = \"\";\n\n\t\tif (packet->header.type == SWITCH_STUN_BINDING_REQUEST) {\n\t\t\tuint8_t stunbuf[512];\n\t\t\tswitch_stun_packet_t *rpacket;\n\t\t\tconst char *remote_ip;\n\t\t\tswitch_size_t bytes;\n\t\t\tchar ipbuf[50];\n\t\t\tswitch_socket_t *sock_output = rtp_session->sock_output;\n\t\t\tuint8_t do_adj = 0;\n\t\t\tswitch_time_t now = switch_micro_time_now();\n\t\t\tint cmp = 0;\n\t\t\tint cur_idx = -1, is_relay = 0, is_responsive = 0, use_candidate = 0;\n\n\t\t\tif (is_rtcp) {\n\t\t\t\tsock_output = rtp_session->rtcp_sock_output;\n\t\t\t}\n\n\t\t\tif (!ice->ready) {\n\t\t\t\tice->ready = 1;\n\t\t\t}\n\n\t\t\tmemset(stunbuf, 0, sizeof(stunbuf));\n\t\t\trpacket = switch_stun_packet_build_header(SWITCH_STUN_BINDING_RESPONSE, packet->header.id, stunbuf);\n\n\t\t\tif ((ice->type & ICE_GOOGLE_JINGLE)) {\n\t\t\t\tswitch_stun_packet_attribute_add_username(rpacket, username, (uint16_t)strlen(username));\n\t\t\t}\n\n\t\t\tremote_ip = switch_get_addr(ipbuf, sizeof(ipbuf), from_addr);\n\n\t\t\tswitch_stun_packet_attribute_add_xor_binded_address(rpacket, (char *) remote_ip, switch_sockaddr_get_port(from_addr), from_addr->family);\n\n\t\t\tif ((ice->type & ICE_VANILLA)) {\n\t\t\t\tswitch_stun_packet_attribute_add_integrity(rpacket, ice->pass);\n\t\t\t\tswitch_stun_packet_attribute_add_fingerprint(rpacket);\n\t\t\t}\n\n\t\t\tbytes = switch_stun_packet_length(rpacket);\n\n\t\t\thost2 = switch_get_addr(buf2, sizeof(buf2), ice->addr);\n\t\t\tport2 = switch_sockaddr_get_port(ice->addr);\n\t\t\tcmp = switch_cmp_addr(from_addr, ice->addr, SWITCH_FALSE);\n\n\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host) && ice->ice_params->cands[i][ice->proto].con_port == from_port) {\n\t\t\t\t\tif (!strcasecmp(ice->ice_params->cands[i][ice->proto].cand_type, \"relay\")) {\n\t\t\t\t\t\tis_relay = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ice->ice_params->cands[i][ice->proto].responsive) {\n\t\t\t\t\t\tis_responsive = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ice->ice_params->cands[i][ice->proto].use_candidate) {\n\t\t\t\t\t\tuse_candidate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5,\n\t\t\t\t\"%s %s STUN from %s:%d %s is_relay: %d is_responsive: %d use_candidate: %d ready: %d, rready: %d\\n\", switch_channel_get_name(channel), rtp_type(rtp_session), from_host, from_port, cmp ? \"EXPECTED\" : \"IGNORED\",\n\t\t\t\tis_relay, is_responsive, use_candidate, ice->ready, ice->rready);\n\n\t\t\tif (ice->initializing && !cmp) {\n\t\t\t\tif (!rtp_session->adj_window && (!ice->ready || !ice->rready || (!rtp_session->dtls || rtp_session->dtls->state != DS_READY))) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE set ADJUST window to 10 seconds on binding request from %s:%d (is_relay: %d, is_responsivie: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\trtp_session->adj_window = now + 10000000;\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->adj_window) {\n\t\t\t\t\tif (rtp_session->adj_window > now) {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE check: %d >= 3000 or window closed and not from relay on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", rtp_session->elapsed_stun, from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tif (!is_relay && (rtp_session->elapsed_stun >= 3000 || rtp_session->adj_window == (now + 10000000))) {\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 1 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trtp_session->adj_window = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE CHECK SAME IP DIFFT PORT %d %d on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\",ice->initializing, switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE), from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\tif (!do_adj && (switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE) || use_candidate)) {\n\t\t\t\t\tdo_adj++;\n\t\t\t\t\trtp_session->last_adj = now;\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 2 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cmp) {\n\t\t\t\tice->last_ok = now;\n\t\t\t} else if (!do_adj) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"ICE %d/%d dt:%d i:%d i2:%d cmp:%d\\n\", rtp_session->elapsed_stun, rtp_session->elapsed_media, (rtp_session->dtls && rtp_session->dtls->state != DS_READY), !ice->ready, !ice->rready, switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE));\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST ELAPSED vs 1000 %d on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\" ,rtp_session->elapsed_adj, from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\tif (rtp_session->elapsed_adj > 1000) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE IF DTLS NOT READY or %d >= 3000 or media too long %d or stun too long %d on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", rtp_session->elapsed_stun, rtp_session->elapsed_media >= MEDIA_TOO_LONG,\n\t\t\t\t\t\trtp_session->elapsed_stun >= STUN_TOO_LONG, from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\tif (!is_relay && ((rtp_session->dtls && rtp_session->dtls->state != DS_READY) ||\n\t\t\t\t\t\t((!ice->ready || !ice->rready) && (rtp_session->elapsed_stun >= 3000 || switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE))))) {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 3 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t} else if (is_relay && ice->initializing && rtp_session->elapsed_stun >= 1000) {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 4 (FLIP TO TURN) on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t} else if ((ice->initializing && rtp_session->elapsed_stun >= 3000) ||\n\t\t\t\t\t\t(rtp_session->elapsed_media >= MEDIA_TOO_LONG || rtp_session->elapsed_stun >= STUN_TOO_LONG)) {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 5 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host)) {\n\t\t\t\t\t\t\tcur_idx = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ice->type & ICE_VANILLA) && ice->ice_params && do_adj) {\n\t\t\t\tice->missed_count = 0;\n\t\t\t\tice->rready = 1;\n\n\t\t\t\tif (cur_idx > -1) {\n\t\t\t\t\tice->ice_params->chosen[ice->proto] = cur_idx;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_NOTICE,\n\t\t\t\t\t\t\t\t  \"Auto Changing %s stun/%s/dtls port from %s:%u to %s:%u idx:%d\\n\", rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\",\n\t\t\t\t\t\t\t\t  host2, port2,\n\t\t\t\t\t\t\t\t  from_host, from_port, cur_idx);\n\n\t\t\t\tswitch_rtp_change_ice_dest(rtp_session, ice, from_host, from_port);\n\n\t\t\t\tice->cand_responsive = is_responsive;\n\t\t\t\tif (ice->cand_responsive) {\n\t\t\t\t\tice->initializing = 0;\n\t\t\t\t}\n\n\t\t\t\tice->last_ok = now;\n\t\t\t}\n\t\t\t//if (cmp) {\n\t\t\tswitch_socket_sendto(sock_output, from_addr, 0, (void *) rpacket, &bytes);\n\t\t\t//}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, \"Send STUN Binding Response to %s:%u\\n\", from_host, from_port);\n\n\t\t\tif (ice->initializing && !is_responsive) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"Send STUN Binding Request on ICE candidate still unresponsive to %s:%u\\n\", from_host, from_port);\n\t\t\t\tif (ice_out(rtp_session, ice, SWITCH_TRUE) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Error sending STUN Binding Request on ICE candidate still unresponsive to %s:%u\\n\", from_host, from_port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (packet->header.type == SWITCH_STUN_BINDING_ERROR_RESPONSE) {\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_core_session_message_t msg = { 0 };\n\t\t\tmsg.from = __FILE__;\n\t\t\tmsg.numeric_arg = packet->header.type;\n\t\t\tmsg.pointer_arg = packet;\n\t\t\tmsg.message_id = SWITCH_MESSAGE_INDICATE_STUN_ERROR;\n\t\t\tswitch_core_session_receive_message(rtp_session->session, &msg);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"STUN/ICE binding error received on %s channel\\n\", rtp_type(rtp_session));\n\t\t}\n\n\t}\n\n\n\n\n end:\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\tWRITE_DEC(rtp_session);\n\tREAD_DEC(rtp_session);\n}\n\n\n#ifdef ENABLE_SRTP\nSWITCH_DECLARE(void) switch_srtp_err_to_txt(srtp_err_status_t stat, char **msg)\n{\n\tif (stat == srtp_err_status_replay_fail) *msg=\"replay check failed\";\n\telse if (stat == srtp_err_status_auth_fail) *msg=\"auth check failed\";\n\telse if (stat == srtp_err_status_fail) *msg=\"unspecified failure\";\n\telse if (stat == srtp_err_status_bad_param) *msg=\"unsupported parameter\";\n\telse if (stat == srtp_err_status_alloc_fail) *msg=\"couldn't allocate memory\";\n\telse if (stat == srtp_err_status_dealloc_fail) *msg=\"couldn't deallocate properly\";\n\telse if (stat == srtp_err_status_init_fail) *msg=\"couldn't initialize\";\n\telse if (stat == srtp_err_status_terminus) *msg=\"can't process as much data as requested\";\n\telse if (stat == srtp_err_status_cipher_fail) *msg=\"cipher failure\";\n\telse if (stat == srtp_err_status_replay_old) *msg=\"replay check failed\";\n\telse if (stat == srtp_err_status_algo_fail) *msg=\"algorithm failed test routine\";\n\telse if (stat == srtp_err_status_no_such_op) *msg=\"unsupported operation\";\n\telse if (stat == srtp_err_status_no_ctx) *msg=\"no appropriate context found\";\n\telse if (stat == srtp_err_status_cant_check) *msg=\"auth check failed\";\n\telse if (stat == srtp_err_status_key_expired) *msg=\"can't use key any more\";\n\telse if (stat == srtp_err_status_socket_err) *msg=\"error in use of socket\";\n\telse if (stat == srtp_err_status_signal_err) *msg=\"error in use POSIX signals\";\n\telse if (stat == srtp_err_status_nonce_bad) *msg=\"nonce check failed\";\n\telse if (stat == srtp_err_status_read_fail) *msg=\"couldn't read data\";\n\telse if (stat == srtp_err_status_write_fail) *msg=\"couldn't write data\";\n\telse if (stat == srtp_err_status_parse_err) *msg=\"error parsing data\";\n\telse if (stat == srtp_err_status_encode_err) *msg=\"error encoding data\";\n\telse if (stat == srtp_err_status_semaphore_err) *msg=\"error while using semaphores\";\n\telse if (stat == srtp_err_status_pfkey_err) *msg=\"error while using pfkey \";\n\telse if (stat == srtp_err_status_bad_mki) *msg=\"error MKI present in packet is invalid\";\n\telse if (stat == srtp_err_status_pkt_idx_old) *msg=\"packet index is too old to consider\";\n\telse if (stat == srtp_err_status_pkt_idx_adv) *msg=\"packet index advanced, reset needed\";\n\telse *msg=\"\";\n}\n#endif\n\nSWITCH_DECLARE(void) switch_rtp_init(switch_memory_pool_t *pool)\n{\n\tif (global_init) {\n\t\treturn;\n\t}\n\tswitch_core_hash_init(&alloc_hash);\n#ifdef ENABLE_SRTP\n\t{\n\t\tsrtp_err_status_t stat = srtp_init();\n\t\tif (stat == srtp_err_status_ok) { \n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, \"SRTP (%s) initialized.\\n\", srtp_get_version_string());\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Error initializing SRTP (%d).\\n\", stat);\n\t\t}\n\t}\n#endif\n\tswitch_mutex_init(&port_lock, SWITCH_MUTEX_NESTED, pool);\n\tswitch_rtp_dtls_init();\n\tglobal_init = 1;\n}\n\nstatic uint8_t get_next_write_ts(switch_rtp_t *rtp_session, uint32_t timestamp)\n{\n\tuint8_t m = 0, changed = 0;\n\n\tif (!(rtp_session->rtp_bugs & RTP_BUG_SEND_LINEAR_TIMESTAMPS)) {\n\t\tif (timestamp) {\n\t\t\trtp_session->ts = (uint32_t) timestamp;\n\t\t\tchanged++;\n\t\t} else if (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER)) {\n\t\t\tswitch_core_timer_next(&rtp_session->write_timer);\n\t\t\trtp_session->ts = rtp_session->write_timer.samplecount;\n\t\t\tchanged++;\n\t\t}\n\t}\n\n\tif (!changed) {\n\t\trtp_session->ts = rtp_session->last_write_ts + rtp_session->samples_per_interval;\n\t} else {\n\t\t/* Send marker bit if timestamp is lower/same as before (resetted/new timer) */\n\t\tif (abs((int32_t)(rtp_session->ts - rtp_session->last_write_ts)) > rtp_session->samples_per_interval \n\t\t\t&& !(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {\n\t\t\tm++;\n\t\t}\n\t}\n\n\treturn m;\n}\n\nstatic void do_mos(switch_rtp_t *rtp_session) {\n\tint R;\n\t\n\tif ((switch_size_t)rtp_session->stats.inbound.recved < rtp_session->stats.inbound.flaws) {\n\t\trtp_session->stats.inbound.flaws = 0;\n\t}\n\n\tif (rtp_session->stats.inbound.recved > 0 &&\n\t\trtp_session->stats.inbound.flaws && (rtp_session->stats.inbound.last_flaw != rtp_session->stats.inbound.flaws)) {\n\t\t\n\t\tif (rtp_session->consecutive_flaws++) {\n\t\t\tint penalty = rtp_session->consecutive_flaws;\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s %s %d consecutive flaws, adding %d flaw penalty\\n\",\n\t\t\t\t\t\t\t  rtp_session_name(rtp_session), rtp_type(rtp_session),\n\t\t\t\t\t\t\t  rtp_session->consecutive_flaws, penalty);\n\t\t\trtp_session->bad_stream++;\n\t\t\trtp_session->stats.inbound.flaws += penalty;\n\t\t\trtp_session->stats.inbound.last_flaw = rtp_session->stats.inbound.flaws;\n\t\t\t\n\t\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\t\trtp_session->stats.inbound.error_log->flaws += penalty;\n\t\t\t\trtp_session->stats.inbound.error_log->consecutive_flaws++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trtp_session->consecutive_flaws = 0;\n\t}\n\n\tR = (int)((double)((double)(rtp_session->stats.inbound.recved - rtp_session->stats.inbound.flaws) / (double)rtp_session->stats.inbound.recved) * 100.0);\n\n\tif (R < 0 || R > 100) R = 100;\n\n\trtp_session->stats.inbound.R = R;\n\trtp_session->stats.inbound.mos = 1 + (0.035) * R + (.000007) * R * (R-60) * (100-R);\n\t\t\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"%s %s stat %0.2f %ld/%d flaws: %ld mos: %0.2f v: %0.2f %0.2f/%0.2f\\n\",\n\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t  rtp_session->stats.inbound.R,\n\t\t\t\t\t  (long int)(rtp_session->stats.inbound.recved - rtp_session->stats.inbound.flaws), rtp_session->stats.inbound.recved,\n\t\t\t\t\t  (long int)rtp_session->stats.inbound.flaws,\n\t\t\t\t\t  rtp_session->stats.inbound.mos,\n\t\t\t\t\t  rtp_session->stats.inbound.variance,\n\t\t\t\t\t  rtp_session->stats.inbound.min_variance,\n\t\t\t\t\t  rtp_session->stats.inbound.max_variance\n\t\t\t\t\t  );\n\t\n}\n\nvoid burstr_calculate ( int loss[], int received, double *burstr, double *lossr )\n{\n\tint lost = 0;\n\tint bursts = 0;\n\tint i;\n\n\tfor ( i = 0; i < LOST_BURST_ANALYZE; i++ ) {\n\t\tlost += i * loss[i];\n\t\tbursts += loss[i];\n\t}\n\tif (received > 0 && bursts > 0) {\n\t\t*burstr = (double)((double)lost / (double)bursts) / (double)(1.0 / ( 1.0 - (double)lost / (double)received ));\n\t\tif (*burstr < 0) {\n\t\t\t*burstr = - *burstr;\n\t\t}\n\t} else {\n\t\t*burstr = 0;\n\t}\n\tif (received > 0) {\n\t\t*lossr = (double)((double)lost / (double)received);\n\t} else {\n\t\t*lossr = 0;\n\t}\n}\n\nstatic void reset_jitter_seq(switch_rtp_t *rtp_session)\n{\n\trtp_session->stats.inbound.last_proc_time = 0;\n\trtp_session->stats.inbound.last_processed_seq = 0;\n\trtp_session->jitter_lead = 0;\n\trtp_session->consecutive_flaws = 0;\n\trtp_session->stats.inbound.last_flaw = 0;\n}\n\nstatic void check_jitter(switch_rtp_t *rtp_session)\n{\n\tswitch_time_t current_time;\n\tint64_t diff_time = 0, cur_diff = 0;\n\tint seq;\n\n\tcurrent_time = switch_micro_time_now() / 1000;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_PAUSE] || rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] || rtp_session->dtmf_data.in_digit_ts) {\n\t\treset_jitter_seq(rtp_session);\n\t\treturn;\n\t}\n\n\tif (++rtp_session->jitter_lead < JITTER_LEAD_FRAMES || !rtp_session->stats.inbound.last_proc_time) {\n\t\trtp_session->stats.inbound.last_proc_time = current_time;\n\t\treturn;\n\t}\n\n\tdiff_time = (current_time - rtp_session->stats.inbound.last_proc_time);\n\tseq = (int)(uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\n\t/* Burst and Packet Loss */\n\trtp_session->stats.inbound.recved++;\n\n\tif (rtp_session->stats.inbound.last_processed_seq > 0 && seq > (int)(rtp_session->stats.inbound.last_processed_seq + 1)) {\n\t\tint lost = (seq - rtp_session->stats.inbound.last_processed_seq - 1);\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s Got: %s seq %d but expected: %d lost: %d\\n\",\n\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t\t  seq,\n\t\t\t\t\t\t  (rtp_session->stats.inbound.last_processed_seq + 1), lost);\n\t\trtp_session->stats.inbound.last_loss++;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t}\n\n\t\tif (rtp_session->stats.inbound.last_loss > 0 && rtp_session->stats.inbound.last_loss < LOST_BURST_CAPTURE) {\n\t\t\trtp_session->stats.inbound.loss[rtp_session->stats.inbound.last_loss] += lost;\n\t\t}\n\n\t\trtp_session->bad_stream++;\n\t\trtp_session->stats.inbound.flaws += lost;\n\n\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\trtp_session->stats.inbound.error_log->flaws += lost;\n\t\t}\n\n\t} else {\n\t\trtp_session->stats.inbound.last_loss = 0;\n\t}\n\n\trtp_session->stats.inbound.last_processed_seq = seq;\n\n\t/* Burst and Packet Loss */\n\n\tif (current_time > rtp_session->next_stat_check_time) {\n\t\trtp_session->next_stat_check_time = current_time + 5000;\n\t\tburstr_calculate(rtp_session->stats.inbound.loss, rtp_session->stats.inbound.recved,\n\t\t\t\t\t\t &(rtp_session->stats.inbound.burstrate), &(rtp_session->stats.inbound.lossrate));\n\t\tdo_mos(rtp_session);\n\t} else {\n\t\tdo_mos(rtp_session);\n\t}\n\n\tif (rtp_session->stats.inbound.last_loss || rtp_session->bad_stream) {\n\t\tif (rtp_session->session && (!rtp_session->stats.inbound.error_log || rtp_session->stats.inbound.error_log->stop)) {\n\t\t\tstruct error_period *error = switch_core_session_alloc(rtp_session->session, sizeof(*error));\n\t\t\terror->start = switch_micro_time_now();\n\t\t\terror->next = rtp_session->stats.inbound.error_log;\n\t\t\trtp_session->stats.inbound.error_log = error;\n\t\t}\n\n\t\tif (!rtp_session->stats.inbound.last_loss) {\n\t\t\tif (++rtp_session->recovering_stream > (rtp_session->one_second * 3)) {\n\t\t\t\tif (rtp_session->session && rtp_session->stats.inbound.error_log) {\n\t\t\t\t\trtp_session->stats.inbound.error_log->stop = switch_micro_time_now();\n\t\t\t\t}\n\n\t\t\t\trtp_session->bad_stream = 0;\n\t\t\t}\n\t\t} else {\n\t\t\trtp_session->recovering_stream = 0;\n\t\t\trtp_session->bad_stream++;\n\t\t}\n\t} else {\n\t\trtp_session->recovering_stream = 0;\n\t\trtp_session->clean_stream++;\n\t}\n\n\n\tif ( diff_time < 0 ) {\n\t\tdiff_time = -diff_time;\n\t}\n\n\trtp_session->stats.inbound.jitter_n++;\n\trtp_session->stats.inbound.jitter_add += diff_time;\n\n\tif (rtp_session->stats.inbound.mean_interval) {\n\t\tcur_diff = (int64_t)(diff_time - rtp_session->stats.inbound.mean_interval);\n\t} else {\n\t\tcur_diff = 0;\n\t}\n\n\trtp_session->stats.inbound.jitter_addsq += (cur_diff * cur_diff);\n\trtp_session->stats.inbound.last_proc_time = current_time;\n\n\tif (rtp_session->stats.inbound.jitter_n > 0) {\n\t\tdouble ipdv;\n\n\t\trtp_session->stats.inbound.mean_interval = (double)rtp_session->stats.inbound.jitter_add / (double)rtp_session->stats.inbound.jitter_n;\n\n\t\tif (!rtp_session->old_mean) {\n\t\t\trtp_session->old_mean = rtp_session->stats.inbound.mean_interval;\n\t\t}\n\n\t\trtp_session->stats.inbound.variance = (double)rtp_session->stats.inbound.jitter_addsq / (double)rtp_session->stats.inbound.jitter_n;\n\n\t\t//printf(\"CHECK %d +%ld +%ld %f %f\\n\", rtp_session->write_timer.samplecount, diff_time, (diff_time * diff_time), rtp_session->stats.inbound.mean_interval, rtp_session->stats.inbound.variance);\n\n\t\tipdv = rtp_session->old_mean - rtp_session->stats.inbound.mean_interval;\n\n\t\tif ( ipdv > IPDV_THRESHOLD ) { /* It shows Increasing Delays */\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG3, \"Calculated Instantaneous Packet Delay Variation: %s packet %lf\\n\",\n\t\t\t\t\t\t\t  rtp_type(rtp_session), ipdv);\n\t\t}\n\n\t\tif ( rtp_session->stats.inbound.variance < rtp_session->stats.inbound.min_variance || rtp_session->stats.inbound.min_variance == 0 ) {\n\t\t\trtp_session->stats.inbound.min_variance = rtp_session->stats.inbound.variance;\n\t\t}\n\n\t\tif ( rtp_session->stats.inbound.variance > rtp_session->stats.inbound.max_variance ) {\n\t\t\trtp_session->stats.inbound.max_variance = rtp_session->stats.inbound.variance;\n\t\t}\n\n\t\trtp_session->old_mean = rtp_session->stats.inbound.mean_interval;\n\t}\n}\n\nstatic void rtcp_generate_sender_info(switch_rtp_t *rtp_session, struct switch_rtcp_sender_info *sr){\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\tswitch_time_t now;\n\tuint32_t sec, ntp_sec, ntp_usec;\n\tswitch_time_exp_t now_hr;\n\tnow = switch_micro_time_now();\n\tsec = (uint32_t)(now/1000000);        /* convert to seconds     */\n\tntp_sec = sec+NTP_TIME_OFFSET;  /* convert to NTP seconds */\n\tsr->ntp_msw = htonl(ntp_sec);   /* store result in \"most significant word\" */\n\tntp_usec = (uint32_t)(now - (sec*1000000)); /* remove seconds to keep only the microseconds */\n\tsr->ntp_lsw = htonl((u_long)(ntp_usec*(double)(((uint64_t)1)<<32)*1.0e-6)); /* convert microseconds to fraction of 32bits and store result in \"least significatn word\" */\n\n\tsr->ts = htonl(rtp_session->last_write_ts);\n\tsr->pc = htonl(rtp_session->stats.outbound.packet_count);\n\tsr->oc = htonl(rtp_session->stats.outbound.raw_bytes - rtp_session->stats.outbound.packet_count * sizeof(srtp_hdr_t));\n\n\tswitch_time_exp_gmt(&now_hr,now);\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10,\"Sending an RTCP packet[%04d-%02d-%02d %02d:%02d:%02d.%d] lsr[%u] msw[%u] lsw[%u] stats_ssrc[%u] packet_count[%u] OC[%u]\\n\",\n\t\t\t1900 + now_hr.tm_year,  now_hr.tm_mday, now_hr.tm_mon, now_hr.tm_hour, now_hr.tm_min, now_hr.tm_sec, now_hr.tm_usec,\n\t\t\t(ntohl(sr->ntp_lsw)&0xffff0000)>>16 | (ntohl(sr->ntp_msw)&0x0000ffff)<<16,\n\t\t\tntohl(sr->ntp_msw),ntohl(sr->ntp_lsw), rtp_session->stats.rtcp.ssrc, ntohl(sr->pc), ntohl(sr->oc)\n\t\t\t);\n}\n\nstatic inline uint32_t calc_local_lsr_now(void)\n{\n\tswitch_time_t now;\n\tuint32_t ntp_sec, ntp_usec, lsr_now, sec;\n\tnow = switch_micro_time_now();\n\tsec = (uint32_t)(now/1000000);        /* convert to seconds     */\n\tntp_sec = sec+NTP_TIME_OFFSET;  /* convert to NTP seconds */\n\tntp_usec = (uint32_t)(now - ((switch_time_t) sec*1000000)); /* remove seconds to keep only the microseconds */\n\n\tlsr_now = (uint32_t)(ntp_usec*0.065536) | (ntp_sec&0x0000ffff)<<16; /* 0.065536 is used for convertion from useconds to fraction of 65536 (x65536/1000000) */\n\n\treturn lsr_now;\n}\n\n//#define DEBUG_RTCP\n/* extra param is for duplicates (received NACKed packets) */ \nstatic void rtcp_generate_report_block(switch_rtp_t *rtp_session, struct switch_rtcp_report_block *rtcp_report_block, \n\t\tint16_t extra_expected)\n{\n#ifdef DEBUG_RTCP\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n#endif\n\tswitch_rtcp_numbers_t * stats=&rtp_session->stats.rtcp;\n\tuint32_t expected_pkt, dlsr = 0;\n\tint32_t pkt_lost;\n\n\t/* Packet loss */\n\tif (stats->rtcp_rtp_count == 0) {\n\t\texpected_pkt = stats->high_ext_seq_recv - stats->base_seq + 1;\n\t} else {\n\t\texpected_pkt = stats->high_ext_seq_recv - stats->last_rpt_ext_seq + extra_expected;\n\t}\n\n\tpkt_lost = expected_pkt - stats->period_pkt_count;\n\tif (pkt_lost < 0) pkt_lost = 0;\n\n\tstats->cum_lost=stats->cum_lost+pkt_lost;\n\tif (expected_pkt > 0 && pkt_lost > 0) {\n\t\trtcp_report_block->fraction = (pkt_lost == expected_pkt ? 255 : (uint8_t) (pkt_lost * 256 / expected_pkt));             /* if X packets were expected and X was lost, we want 0xff to be reported, not 0 */\n\t} else {\n\t\trtcp_report_block->fraction = 0;\n\t}\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\trtcp_report_block->lost = stats->cum_lost;\n#else\n\t/* Reversing byte order for 24bits */\n\trtcp_report_block->lost = htonl(stats->cum_lost) >> 8;\n#endif\n\n#ifdef DEBUG_RTCP\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO])\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_CRIT, \"rtcp_generate_sr: stats_ssrc[%u]\\nreceived[%d]\\nexpected[%d]\\ncum[%d]\\nlost[%d|%d/256]pkt\\nlast_seq[%d]\\ncyc[%d]\\nlast_rpt_seq[%d]\\ncyc[%d]\\nssrc[%d]\\n\",\n\t\t\t\t\t\trtp_session->remote_ssrc, stats->period_pkt_count, expected_pkt,\n\t\t\t\t\t\tstats->cum_lost, pkt_lost, rtcp_report_block->fraction, stats->high_ext_seq_recv&0x0000ffff,\n\t\t\t\t\t\tstats->cycle, stats->last_rpt_ext_seq&0x0000ffff, stats->last_rpt_cycle, rtp_session->stats.rtcp.peer_ssrc\n\t\t\t\t\t\t);\n#endif\n\trtcp_report_block->highest_sequence_number_received = htonl(stats->high_ext_seq_recv);\n\n\t/* Jitter */\n\trtcp_report_block->jitter = htonl((uint32_t)stats->inter_jitter);\n\n\t/* Delay since Last Sender Report (DLSR) : 32bits, 1/65536 seconds */\n\tif (stats->last_recv_lsr_local) {\n\t\tuint32_t lsr_now = calc_local_lsr_now();\n\t\t/* check lsr_now: what we just read from clock may be in the past (race cond), don't send huge dlsr due to uint wrap around */\n\t\tif (lsr_now > stats->last_recv_lsr_local) {\n\t\t\tdlsr = lsr_now - stats->last_recv_lsr_local;\n\t\t}\n\t}\n\trtcp_report_block->lsr = stats->last_recv_lsr_peer;\n\trtcp_report_block->dlsr = htonl(dlsr);\n\tif (rtp_session->stats.rtcp.peer_ssrc) {\n\t\trtcp_report_block->ssrc = htonl(rtp_session->stats.rtcp.peer_ssrc);\n\t} else {\n\t\t/* if remote is not sending rtcp reports, take ssrc as assigned from rtp */\n\t\trtcp_report_block->ssrc = htonl(rtp_session->remote_ssrc);\n\t}\n\t\n\tstats->rtcp_rtp_count++;\n}\n\nstatic void rtcp_stats_init(switch_rtp_t *rtp_session)\n{\n\tswitch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;\n\tsrtp_hdr_t * hdr = &rtp_session->last_rtp_hdr;\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\tstats->ssrc = ntohl(hdr->ssrc);\n\tstats->last_rpt_ts = rtp_session->write_timer.samplecount;\n\tstats->init = 1;\n\tstats->last_rpt_ext_seq = 0;\n\tstats->last_rpt_cycle = 0;\n\tstats->last_pkt_tsdiff = 0;\n\tstats->inter_jitter = 0;\n\tstats->cycle = 0;\n\tstats->high_ext_seq_recv = ntohs((uint16_t)hdr->seq);\n\tstats->base_seq = ntohs((uint16_t)hdr->seq);\n\tstats->bad_seq = (1<<16) + 1; /* Make sure we wont missmatch 2 consecutive packets, so seq == bad_seq is false */\n\tstats->cum_lost = 0;\n\tstats->period_pkt_count = 0;\n\tstats->sent_pkt_count = 0;\n\tstats->pkt_count = 0;\n\tstats->rtcp_rtp_count = 0;\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats_init: %s rtcp disabled\\n\", rtp_type(rtp_session));\n\t} else if (!rtp_session->rtcp_sock_output) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_WARNING, \"rtcp_stats_init: %s no rtcp socket\\n\", rtp_type(rtp_session));\n\t} else if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU]) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats_init: %s rtcp passthru\\n\", rtp_type(rtp_session));\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats_init: %s ssrc[%u] base_seq[%u]\\n\", rtp_type(rtp_session), stats->ssrc, stats->base_seq);\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] && (switch_core_media_codec_get_cap(rtp_session->session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_MEDIA_TYPE_AUDIO, SWITCH_CODEC_FLAG_HAS_ADJ_BITRATE))) {\n\t\t\tkalman_estimator_t *estimators[KALMAN_SYSTEM_MODELS];\n\t\t\tcusum_kalman_detector_t *detectors[KALMAN_SYSTEM_MODELS];\n\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_ADJ_BITRATE_CAP] = 1;\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_ESTIMATORS] = 1;\n\n\t\t\trtp_session->estimators[EST_LOSS] = switch_core_alloc(rtp_session->pool, sizeof(*estimators[0]));\n\t\t\tswitch_kalman_init(rtp_session->estimators[EST_LOSS],0.1,0.1);\n\t\t\trtp_session->estimators[EST_RTT] = switch_core_alloc(rtp_session->pool, sizeof(*estimators[0]));\n\t\t\tswitch_kalman_init(rtp_session->estimators[EST_RTT],0.03,1);\n\t\t\trtp_session->detectors[EST_RTT] = switch_core_alloc(rtp_session->pool, sizeof(*detectors[0]));\n\t\t\tswitch_kalman_cusum_init(rtp_session->detectors[EST_RTT],0.005,0.5);\n\t\t\trtp_session->detectors[EST_LOSS] = switch_core_alloc(rtp_session->pool, sizeof(*detectors[0]));\n\t\t\tswitch_kalman_cusum_init(rtp_session->detectors[EST_LOSS], 0.5, 1);\n\t}\n}\n\nstatic int rtcp_stats(switch_rtp_t *rtp_session)\n{\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\tsrtp_hdr_t * hdr = &rtp_session->last_rtp_hdr;\n\tswitch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;\n\tuint32_t packet_spacing_diff = 0, pkt_tsdiff, pkt_extended_seq;\n\tuint16_t pkt_seq, seq_diff, max_seq;\n\tconst int MAX_DROPOUT = 3000;\n\tconst int MAX_MISORDER = 100;\n\tconst int RTP_SEQ_MOD = (1<<16);\n\n\tif(!rtp_session->rtcp_sock_output || !rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] || rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] || !rtp_session->rtcp_interval)\n\t\treturn 0; /* do not process RTCP in current state */\n\n\tpkt_seq = (uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\n\t/* Detect sequence number cycle change */\n\tmax_seq = stats->high_ext_seq_recv&0x0000ffff;\n\tseq_diff = pkt_seq - max_seq;\n\n\tif (seq_diff < MAX_DROPOUT) {  /* in order, with permissible gap */\n\t\tif (pkt_seq < max_seq) {\n\t\t\tstats->cycle++;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats:[cycle change] pkt_seq[%d] cycle[%d] max_seq[%d] stats_ssrc[%u] local_ts[%u]\\n\",\n\t\t\t\t\tpkt_seq, stats->cycle, max_seq, stats->ssrc, rtp_session->timer.samplecount);\n\t\t}\n\t\tpkt_extended_seq = stats->cycle << 16 | pkt_seq; /* getting the extended packet extended sequence ID */\n\t\tif (pkt_extended_seq > stats->high_ext_seq_recv) {\n\t\t\tstats->high_ext_seq_recv = pkt_extended_seq;\n\t\t}\n\t}\n\telse if (seq_diff <= (RTP_SEQ_MOD - MAX_MISORDER)) {   /* the sequence number made a very large jump */\n\t\tif (pkt_seq == stats->bad_seq) {\n\t\t\trtcp_stats_init(rtp_session);\n\t\t} else {\n\t\t\tstats->bad_seq = (pkt_seq + 1) & (RTP_SEQ_MOD-1);\n\t\t}\n\t\treturn 0; /* no stats, packet is out of sync and will be accounted as lost */\n\t} else {\n\t\t/* duplicate or reordered packet */\n\t}\n\n\t/* Verify that we are on the same stream source (we do not support multiple sources) */\n\tif (ntohl(hdr->ssrc) != stats->ssrc || !stats->init) {\n\t\trtcp_stats_init(rtp_session);\n\t}\n\n\tstats->period_pkt_count++;\n\tstats->pkt_count++;\n#ifdef DEBUG_RTCP\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10, \"rtcp_stats: period_pkt_count[%d]last_seq[%d]cycle[%d]stats_ssrc[%u]local_ts[%u]\\n\",\n\t\t\tstats->period_pkt_count, pkt_seq, stats->cycle, stats->ssrc, rtp_session->write_timer.samplecount);\n#endif\n\t/* Interarrival jitter calculation */\n\tpkt_tsdiff = abs((int32_t)(rtp_session->timer.samplecount - ntohl(hdr->ts)));  /* relative transit times for this packet */\n\tif (stats->pkt_count < 2) { /* Can not compute Jitter with only one packet */\n\t\tstats->last_pkt_tsdiff = pkt_tsdiff;\n\t} else {\n\t\t/* Jitter : difference of relative transit times for the two packets */\n\t\tpacket_spacing_diff = abs((int32_t)(pkt_tsdiff - stats->last_pkt_tsdiff));\n\t\tstats->last_pkt_tsdiff = pkt_tsdiff;\n\t\t/* Interarrival jitter estimation, \"J(i) = J(i-1) + ( |D(i-1,i)| - J(i-1) )/16\" */\n\t\tstats->inter_jitter = (stats->inter_jitter + (((double)packet_spacing_diff - stats->inter_jitter) /16.));\n\t}\n\n#ifdef DEBUG_RTCP\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10, \"rtcp_stats: pkt_ts[%d]local_ts[%d]diff[%d]pkt_spacing[%d]inter_jitter[%f]seq[%d]stats_ssrc[%d]\",\n\t\t\tntohl(hdr->ts), rtp_session->timer.samplecount, pkt_tsdiff, packet_spacing_diff, stats->inter_jitter, ntohs(hdr->seq), stats->ssrc);\n#endif\n\treturn 1;\n}\n\nstatic void calc_bw_exp(uint32_t bps, uint8_t bits, rtcp_tmmbx_t *tmmbx)\n{\n\tuint32_t mantissa_max, i = 0;\n\tuint8_t exp = 0;\n\tuint32_t mantissa = 0;\n\tuint16_t overhead = 60;\n\n\tswitch_assert(bits<=32);\n\n\tmantissa_max = (1 << bits) - 1;\n\n\tfor (i = 0; i < 32; ++i) {\n\t\tif (bps <= (mantissa_max << i)) {\n\t\t\texp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmantissa = (bps >> exp);\n\n\ttmmbx->parts[0] = (uint8_t) ((exp << 2) + ((mantissa >> 15) & 0x03));\n\ttmmbx->parts[1] = (uint8_t) (mantissa >> 7);\n\ttmmbx->parts[2] = (uint8_t) ((mantissa >> 1) + ((overhead >> 8) & 0x01));\n\ttmmbx->parts[3] = (uint8_t) (overhead);\n}\n\nstatic int using_ice(switch_rtp_t *rtp_session)\n{\n\tif (rtp_session->ice.ice_user || rtp_session->rtcp_ice.ice_user) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void switch_send_rtcp_event(switch_rtp_t *rtp_session ,struct switch_rtcp_sender_report *sr,struct switch_rtcp_report_block *rtcp_report_block)\n{\n\tif (sr && rtcp_report_block) {\n\t\tswitch_event_t *event;\n\n\t\tif (switch_event_create(&event, SWITCH_EVENT_SEND_RTCP_MESSAGE) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tchar value[30];\n\t\t\t\tchar header[50];\n\t\t\t\tuint32_t tmpLost;\n\t\t\t\tchar *uuid = switch_core_session_get_uuid(rtp_session->session);\n\t\t\t\tif (uuid) {\n\t\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Unique-ID\", switch_core_session_get_uuid(rtp_session->session));\n\t\t\t\t}\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%.8x\", rtp_session->stats.rtcp.ssrc);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"SSRC\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ntp_msw));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"NTP-Most-Significant-Word\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ntp_lsw));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"NTP-Least-Significant-Word\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ts));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"RTP-Timestamp\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.pc));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Sender-Packet-Count\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.oc));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Octect-Packet-Count\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ts));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Last-RTP-Timestamp\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%\" SWITCH_TIME_T_FMT, switch_time_now());\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Capture-Time\", value);\n\n\t\t\t\t/* Add sources info */\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-SSRC\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%.8x\", rtp_session->stats.rtcp.peer_ssrc);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Fraction\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", (uint8_t)rtcp_report_block->fraction);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Lost\");\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\t\t\t\ttmpLost = rtcp_report_block->lost; /* signed 24bit will extended signess to int32_t automatically */\n#else\n\t\t\t\ttmpLost = ntohl(rtcp_report_block->lost)>>8;\n\t\t\t\ttmpLost = tmpLost | ((tmpLost & 0x00800000) ? 0xff000000 : 0x00000000); /* ...and signess compensation */\n#endif\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", tmpLost);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Highest-Sequence-Number-Received\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->highest_sequence_number_received));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Jitter\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->jitter));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-LSR\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->lsr));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-DLSR\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->dlsr));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\n\t\t\t\tswitch_event_fire(&event);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"Dispatched RTCP SEND event\\n\");\n\t\t}\n\t}\n}\n\n#define MAX_NACK 10\nstatic int check_rtcp_and_ice(switch_rtp_t *rtp_session)\n{\n\tint ret = 0;\n\tint rtcp_ok = 0, rtcp_cyclic = 0, rtcp_fb = 0, force_send_rr = 0;\n\tswitch_time_t now = switch_micro_time_now();\n\tint rate = 0, nack_ttl = 0, nack_dup = 0; \n\tuint32_t cur_nack[MAX_NACK] = { 0 };\n\tuint16_t seq = 0;\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\trtp_session->flags[SWITCH_RTP_FLAG_AUTO_CNG] &&\n\t\trtp_session->send_msg.header.ts &&\n\t\trtp_session->cng_pt != INVALID_PT &&\n\t\t(rtp_session->write_timer.samplecount - rtp_session->last_write_samplecount >= rtp_session->samples_per_interval * 60)) {\n\t\tuint8_t data[10] = { 0 };\n\t\tswitch_frame_flag_t frame_flags = SFF_NONE;\n\t\tdata[0] = 65;\n\t\trtp_session->cn++;\n\n\t\tget_next_write_ts(rtp_session, 0);\n\t\trtp_session->send_msg.header.ts = htonl(rtp_session->ts);\n\n\t\tswitch_rtp_write_manual(rtp_session, (void *) data, 2, 0, rtp_session->cng_pt, ntohl(rtp_session->send_msg.header.ts), &frame_flags);\n\n\t\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER)) {\n\t\t\trtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;\n\t\t}\n\t}\n\n\trate = rtp_session->rtcp_interval;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && rtp_session->vb) {\n\t\tint n;\n\t\tfor (n = 0; n < MAX_NACK; n++) {\n\t\t\tuint32_t nack = switch_jb_pop_nack(rtp_session->vb);\n\n\t\t\tif (!nack) break;\n\n\t\t\tseq = ntohs(nack & 0xFFFF);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s Got NACK [%u][0x%x] for seq %u\\n\",\n\t\t\t\t\tswitch_core_session_get_name(rtp_session->session), nack, nack, seq);\n\n\t\t\tcur_nack[nack_ttl++] = nack;\n\t\t}\n\t\tif (nack_ttl) {\n\t\t\trtcp_ok = 1;\n\t\t\trtcp_fb = 1;\n\t\t}\n\t}\n\n\n\n\tif (rtp_session->rtcp_sent_packets < 4) {\n\t\trate = 4000;\n\t} else  {\n\t\tif (rtp_session->pli_count || rtp_session->fir_count || rtp_session->tmmbr || rtp_session->tmmbn) {\n\t\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"MARK BW/FIR ETC %d %d\\n\", rtp_session->pli_count, rtp_session->fir_count);\n\t\t\trtcp_ok = 1;\n\t\t\trtcp_fb = 1;\n\t\t}\n\t}\n\n\tif (rtp_session->send_rr) {\n\t\trtp_session->send_rr = 0;\n\t\trtcp_ok = 1;\n\t\tforce_send_rr = 1;\n\t}\n\n\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"TIME CHECK %d > %d\\n\", (int)((now - rtp_session->rtcp_last_sent) / 1000), rate);\n\n\tif (!rtcp_ok && (!rtp_session->rtcp_last_sent || (int)((now - rtp_session->rtcp_last_sent) / 1000) > rate)) {\n\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"TIME UP\\n\");\n\t\trtcp_cyclic = 1;\n\t\trtcp_ok = 1;\n\t}\n\n\tif (rtcp_ok && using_ice(rtp_session)) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\tif (!rtp_session->ice.rready) {\n\t\t\t\trtcp_ok = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!rtp_session->rtcp_ice.rready) {\n\t\t\t\trtcp_ok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"WTF %d %d %d %d\\n\", rate, rtp_session->rtcp_sent_packets, rtcp_ok, nack_ttl);\n\n\tif (rtp_session->rtcp_sock_output && rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] && !rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] && rtcp_ok) {\n\t\tswitch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;\n\t\tstruct switch_rtcp_receiver_report *rr;\n\t\tstruct switch_rtcp_sender_report *sr;\n\t\tstruct switch_rtcp_report_block *rtcp_report_block = NULL;\n\t\tswitch_size_t rtcp_bytes = sizeof(struct switch_rtcp_hdr_s)+sizeof(uint32_t); /* add size of the packet header and the ssrc */\n\t\tswitch_rtcp_hdr_t *sdes;\n\t\tuint8_t *p;\n\t\tswitch_size_t sdes_bytes = sizeof(struct switch_rtcp_hdr_s);\n\t\tuint32_t *ssrc;\n\t\tswitch_rtcp_sdes_unit_t *unit;\n\t\tswitch_bool_t is_only_receiver = FALSE;\n\n\t\tif (!rtcp_fb) {\n\t\t\trtp_session->rtcp_last_sent = now;\n\t\t\trtp_session->rtcp_sent_packets++;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && \n\t\t\t\trtp_session->vb && rtcp_cyclic) {\n\t\t\t\tnack_dup = rtp_session->prev_nacks_inflight;\n\t\t\t\trtp_session->prev_nacks_inflight = 0;\n\t\t}\n\n\t\trtp_session->rtcp_send_msg.header.version = 2;\n\t\trtp_session->rtcp_send_msg.header.p = 0;\n\n\t\tif ((switch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO) == SWITCH_MEDIA_FLOW_RECVONLY) ||\n\t\t\t\tswitch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO) == SWITCH_MEDIA_FLOW_RECVONLY) {\n\t\t\tis_only_receiver = TRUE;\n\t\t}\n\t\tif (!rtp_session->stats.rtcp.sent_pkt_count || is_only_receiver || force_send_rr) {\n\t\t\trtp_session->rtcp_send_msg.header.type = _RTCP_PT_RR; /* Receiver report */\n\t\t\trr=(struct switch_rtcp_receiver_report*) rtp_session->rtcp_send_msg.body;\n\t\t\trr->ssrc = htonl(rtp_session->ssrc);\n\t\t\trtcp_report_block = &rr->report_block;\n\t\t\trtcp_bytes += sizeof(struct switch_rtcp_report_block);\n\t\t\trtcp_generate_report_block(rtp_session, rtcp_report_block, nack_dup);\n\t\t\trtp_session->rtcp_send_msg.header.count = 1; /* reception report block count */\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Sending RTCP RR (ssrc=%u)\\n\", rtp_session->ssrc);\n\t\t} else {\n\t\t\tstruct switch_rtcp_sender_info *rtcp_sender_info;\n\t\t\trtp_session->rtcp_send_msg.header.type = _RTCP_PT_SR; /* Sender report */\n\t\t\tsr = (struct switch_rtcp_sender_report*) rtp_session->rtcp_send_msg.body;\n\t\t\tsr->ssrc = htonl(rtp_session->ssrc);\n\t\t\trtcp_sender_info = &sr->sender_info;\n\t\t\trtcp_generate_sender_info(rtp_session, rtcp_sender_info);\n\t\t\trtcp_bytes += sizeof(struct switch_rtcp_sender_info);\n\t\t\tif (!rtcp_cyclic && rtcp_fb) {\n\t\t\t\t /* rtcp-fb only, don't send receive report block */\n\t\t\t\trtp_session->rtcp_send_msg.header.count = 0;\n\t\t\t} else {\n\t\t\t\trtcp_report_block = &sr->report_block;\n\t\t\t\trtcp_bytes += sizeof(struct switch_rtcp_report_block);\n\t\t\t\trtcp_generate_report_block(rtp_session, rtcp_report_block, nack_dup);\n\t\t\t\trtp_session->rtcp_send_msg.header.count = 1; /* reception report block count */\n\t\t\t\tstats->sent_pkt_count = 0;\n\t\t\t\tif ((!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_AUDIO_FIRE_SEND_RTCP_EVENT]) ||\n\t\t\t\t\t(rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_VIDEO_FIRE_SEND_RTCP_EVENT])) {\n \t\t\t\t\tswitch_send_rtcp_event(rtp_session, sr, rtcp_report_block);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Sending RTCP SR (ssrc=%u)\\n\", rtp_session->ssrc);\n\t\t}\n\n\t\trtp_session->rtcp_send_msg.header.length = htons((uint16_t)(rtcp_bytes / 4) - 1);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tif (rtp_session->pli_count) {\n\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\n\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\text_hdr->version = 2;\n\t\t\t\text_hdr->p = 0;\n\t\t\t\text_hdr->fmt = _RTCP_PSFB_PLI;\n\t\t\t\text_hdr->pt = _RTCP_PT_PSFB;\n\n\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\text_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\trtp_session->rtcp_vstats.video_in.pli_count++;\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Sending RTCP PLI %u %u [%u]\\n\",\n\t\t\t\t\t\t\t\t  rtp_session->ssrc, rtp_session->remote_ssrc, rtp_session->rtcp_vstats.video_in.pli_count);\n\n\t\t\t\text_hdr->length = htons((uint8_t)(sizeof(switch_rtcp_ext_hdr_t) / 4) - 1);\n\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\trtp_session->pli_count = 0;\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && nack_ttl > 0) {\n\t\t\t\tint n = 0;\n\n\t\t\t\trtp_session->rtcp_vstats.video_in.nack_count++;\n\t\t\t\tfor (n = 0; n < nack_ttl; n++) {\n\t\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\t\t\t\t\tuint32_t *nack;\n\t\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\t\text_hdr->version = 2;\n\t\t\t\t\text_hdr->p = 0;\n\t\t\t\t\text_hdr->fmt = _RTCP_RTPFB_NACK;\n\t\t\t\t\text_hdr->pt = _RTCP_PT_RTPFB;\n\t\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\t\text_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\t\text_hdr->length = htons(3);\n\t\t\t\t\tp += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\t\tnack = (uint32_t *) p;\n\t\t\t\t\t*nack = cur_nack[n];\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP NACK %u [%d]\\n\",\n\t\t\t\t\t\t\t\t\t  ntohs(*nack & 0xFFFF), rtp_session->rtcp_vstats.video_in.nack_count);\n\n\t\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(cur_nack[n]);\n\t\t\t\t\tcur_nack[n] = 0;\n\t\t\t\t}\n\t\t\t\trtp_session->prev_nacks_inflight = n;\n\t\t\t}\n\n\t\t\tif (rtp_session->fir_count) {\n\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\t\t\t\trtcp_fir_t *fir;\n\n\t\t\t\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_OLD_FIR)) {\n\t\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\t\text_hdr->version = 2;\n\t\t\t\t\text_hdr->pt = _RTCP_PT_FIR;\n\t\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\t}\n\n\n\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\tp += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\tfir = (rtcp_fir_t *) p;\n\n\t\t\t\text_hdr->version = 2;\n\t\t\t\text_hdr->p = 0;\n\t\t\t\text_hdr->fmt = _RTCP_PSFB_FIR;\n\t\t\t\text_hdr->pt = _RTCP_PT_PSFB;\n\n\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\text_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);\n\n\t\t\t\tfir->ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\tfir->seq = rtp_session->fir_seq;\n\t\t\t\tfir->r1 = fir->r2 = fir->r3 = 0;\n\n\t\t\t\trtp_session->rtcp_vstats.video_in.fir_count++;\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP FIR SEQ %d [%u]\\n\", rtp_session->fir_seq, rtp_session->rtcp_vstats.video_in.fir_count);\n\n\t\t\t\trtp_session->fir_seq++;\n\n\t\t\t\text_hdr->length = htons((uint8_t)((sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_fir_t)) / 4) - 1);\n\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_fir_t);\n\t\t\t\trtp_session->fir_count = 0;\n\t\t\t}\n\n\t\t\t//if (!rtp_session->tmmbr && rtp_session->cur_tmmbr) {\n\t\t\t//\trtp_session->tmmbr = rtp_session->cur_tmmbr;\n\t\t\t//}\n\n\t\t\twhile (rtp_session->tmmbr || rtp_session->tmmbn) {\n\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\t\t\t\trtcp_tmmbx_t *tmmbx;\n\t\t\t\tuint32_t bps = 0;\n\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\tp += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\ttmmbx = (rtcp_tmmbx_t *) p;\n\n\t\t\t\text_hdr->version = 2;\n\t\t\t\text_hdr->p = 0;\n\t\t\t\text_hdr->pt = _RTCP_PT_RTPFB;\n\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\text_hdr->recv_ssrc = 0;\n\n\t\t\t\tif (rtp_session->tmmbr) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP TMMBR %u\\n\", rtp_session->tmmbr);\n\t\t\t\t\text_hdr->fmt = _RTCP_RTPFB_TMMBR;\n\t\t\t\t\tbps = rtp_session->tmmbr;\n\t\t\t\t\trtp_session->tmmbr = 0;\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP TMMBN %u\\n\", rtp_session->tmmbr);\n\t\t\t\t\text_hdr->fmt = _RTCP_RTPFB_TMMBN;\n\t\t\t\t\tbps = rtp_session->tmmbn;\n\t\t\t\t\trtp_session->tmmbn = 0;\n\t\t\t\t}\n\n\t\t\t\ttmmbx->ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\tcalc_bw_exp(bps, 17, tmmbx);\n\n\t\t\t\text_hdr->length = htons((uint8_t)((sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_tmmbx_t)) / 4) - 1);\n\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_tmmbx_t);\n\t\t\t}\n\n\t\t}\n\n\t\t//SDES + CNAME\n\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\tsdes = (switch_rtcp_hdr_t *) p;\n\t\tsdes->version = 2;\n\t\tsdes->type = _RTCP_PT_SDES;\n\t\tsdes->count = 1;\n\t\tsdes->p = 0;\n\t\tp = (uint8_t *) (sdes) + sdes_bytes;\n\t\tssrc = (uint32_t *) p;\n\t\t*ssrc = htonl(rtp_session->ssrc);\n\t\tsdes_bytes += sizeof(uint32_t);\n\n\n\t\tp = (uint8_t *) (sdes) + sdes_bytes;\n\t\tunit = (switch_rtcp_sdes_unit_t *) p;\n\t\tunit->type = _RTCP_SDES_CNAME;\n\t\tsnprintf((char *)unit->value, 80, \"%x\", rtp_session->ssrc);\n\t\tunit->length = strlen((char *)unit->value);\n\t\tsdes_bytes += sizeof(switch_rtcp_sdes_unit_t) + unit->length;\n\n\n\t\tp += sizeof(switch_rtcp_sdes_unit_t) + unit->length;\n\t\tunit = (switch_rtcp_sdes_unit_t *) p;\n\t\tunit->type = _RTCP_SDES_NOTE;\n\t\tsnprintf((char *)unit->value, 80, \"FreeSWITCH.org -- Come to ClueCon.com\");\n\t\tunit->length = strlen((char *)unit->value);\n\t\tsdes_bytes += sizeof(switch_rtcp_sdes_unit_t) + unit->length;\n\n\t\tsdes_bytes ++;//END\n\n\t\tsdes_bytes += 4 - (sdes_bytes % 4);\n\n\t\tsdes->length = htons((uint16_t)(sdes_bytes / 4) - 1);\n\t\trtcp_bytes += sdes_bytes;\n\n\t\t/* Prepare next report */\n\t\tif (rtp_session->rtcp_send_msg.header.count) {\n\t\t\tstats->last_rpt_cycle = stats->cycle;\n\t\t\tstats->last_rpt_ext_seq = stats->high_ext_seq_recv;\n\t\t\tstats->last_rpt_ts = rtp_session->write_timer.samplecount;\n\t\t\tstats->period_pkt_count = 0;\n\t\t}\n\n\n\n#ifdef ENABLE_SRTP\n\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\t\tint stat = 0;\n\t\t\tint sbytes = (int) rtcp_bytes;\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\tstat = srtp_protect_rtcp(rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_send_msg.header, &sbytes);\n\t\t\t} else {\n\t\t\t\tstat = srtp_protect_rtcp_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_send_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t}\n\n\t\t\tif (stat) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error: SRTP RTCP protection failed with code %d\\n\", stat);\n\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\tgoto end;\n\t\t\t} else {\n\t\t\t\trtcp_bytes = sbytes;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\n\t\t//#define DEBUG_EXTRA\n#ifdef DEBUG_EXTRA\n\t\t{\n\t\t\tconst char *old_host;\n\t\t\tchar bufb[50];\n\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->rtcp_remote_addr);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"%s SEND %s RTCP %s:%d %ld\\n\",\n\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t\t\t  old_host,\n\t\t\t\t\t\t\t  switch_sockaddr_get_port(rtp_session->rtcp_remote_addr),\n\t\t\t\t\t\t\t  rtcp_bytes);\n\t\t}\n#endif\n\t\tif (switch_socket_sendto(rtp_session->rtcp_sock_output, rtp_session->rtcp_remote_addr, 0, (void *)&rtp_session->rtcp_send_msg, &rtcp_bytes ) != SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\"RTCP packet not written\\n\");\n\t\t} else {\n\t\t\trtp_session->stats.inbound.period_packet_count = 0;\n\t\t}\n\t}\n\n\tif (rtp_session->ice.ice_user) {\n\t\tif (ice_out(rtp_session, &rtp_session->ice, SWITCH_FALSE) == SWITCH_STATUS_GENERR) {\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\tif (rtp_session->rtcp_ice.ice_user) {\n\t\t\tif (ice_out(rtp_session, &rtp_session->rtcp_ice, SWITCH_FALSE) == SWITCH_STATUS_GENERR) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\n end:\n\n\treturn ret;\n}\n\nSWITCH_DECLARE(void) switch_rtp_ping(switch_rtp_t *rtp_session)\n{\n\tcheck_rtcp_and_ice(rtp_session);\n}\n\nSWITCH_DECLARE(void) switch_rtp_get_random(void *buf, uint32_t len)\n{\n#ifdef HAVE_OPENSSL\n\tRAND_bytes(buf, len);\n#else\n\tswitch_stun_random_string(buf, len, NULL);\n#endif\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_shutdown(void)\n{\n\tswitch_core_port_allocator_t *alloc = NULL;\n\tswitch_hash_index_t *hi;\n\tconst void *var;\n\tvoid *val;\n\n\tif (!global_init) {\n\t\treturn;\n\t}\n\n\tswitch_mutex_lock(port_lock);\n\n\tfor (hi = switch_core_hash_first(alloc_hash); hi; hi = switch_core_hash_next(&hi)) {\n\t\tswitch_core_hash_this(hi, &var, NULL, &val);\n\t\tif ((alloc = (switch_core_port_allocator_t *) val)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, \"Destroy port allocator for %s\\n\", (char *) var);\n\t\t\tswitch_core_port_allocator_destroy(&alloc);\n\t\t}\n\t}\n\n\tswitch_core_hash_destroy(&alloc_hash);\n\tswitch_mutex_unlock(port_lock);\n\n#ifdef ENABLE_SRTP\n\tsrtp_crypto_kernel_shutdown();\n#endif\n\tswitch_rtp_dtls_destroy();\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_set_start_port(switch_port_t port)\n{\n\tif (port) {\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_lock(port_lock);\n\t\t}\n\t\tSTART_PORT = port;\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_unlock(port_lock);\n\t\t}\n\t}\n\treturn START_PORT;\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_set_end_port(switch_port_t port)\n{\n\tif (port) {\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_lock(port_lock);\n\t\t}\n\t\tEND_PORT = port;\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_unlock(port_lock);\n\t\t}\n\t}\n\treturn END_PORT;\n}\n\nSWITCH_DECLARE(void) switch_rtp_release_port(const char *ip, switch_port_t port)\n{\n\tswitch_core_port_allocator_t *alloc = NULL;\n\n\tif (!ip || !port) {\n\t\treturn;\n\t}\n\n\tswitch_mutex_lock(port_lock);\n\tif ((alloc = switch_core_hash_find(alloc_hash, ip))) {\n\t\tswitch_core_port_allocator_free_port(alloc, port);\n\t}\n\tswitch_mutex_unlock(port_lock);\n\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_request_port(const char *ip)\n{\n\tswitch_port_t port = 0;\n\tswitch_core_port_allocator_t *alloc = NULL;\n\n\tswitch_mutex_lock(port_lock);\n\talloc = switch_core_hash_find(alloc_hash, ip);\n\tif (!alloc) {\n\t\tif (switch_core_port_allocator_new(ip, START_PORT, END_PORT, SPF_EVEN, &alloc) != SWITCH_STATUS_SUCCESS) {\n\t\t\tabort();\n\t\t}\n\n\t\tswitch_core_hash_insert(alloc_hash, ip, alloc);\n\t}\n\n\tif (switch_core_port_allocator_request_port(alloc, &port) != SWITCH_STATUS_SUCCESS) {\n\t\tport = 0;\n\t}\n\n\tswitch_mutex_unlock(port_lock);\n\treturn port;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_payload_map(switch_rtp_t *rtp_session, payload_map_t **pmap)\n{\n\n\tif (rtp_session) {\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\trtp_session->pmaps = pmap;\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\treturn SWITCH_STATUS_SUCCESS;\n\t}\n\n\treturn SWITCH_STATUS_FALSE;\n}\n\nSWITCH_DECLARE(void) switch_rtp_intentional_bugs(switch_rtp_t *rtp_session, switch_rtp_bug_flag_t bugs)\n{\n\trtp_session->rtp_bugs = bugs;\n\n\tif ((rtp_session->rtp_bugs & RTP_BUG_START_SEQ_AT_ZERO)) {\n\t\trtp_session->seq = 0;\n\t}\n\n}\n\n\nstatic switch_status_t enable_remote_rtcp_socket(switch_rtp_t *rtp_session, const char **err) {\n\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_remote_addr, rtp_session->eff_remote_host_str, SWITCH_UNSPEC,\n\t\t\t\t\t\t\t\t\t rtp_session->remote_rtcp_port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !rtp_session->rtcp_remote_addr) {\n\t\t\t*err = \"RTCP Remote Address Error!\";\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t} else {\n\t\t\tconst char *host;\n\t\t\tchar bufa[50];\n\n\t\t\thost = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtcp_remote_addr);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"Setting RTCP remote addr to %s:%d %d\\n\", host, rtp_session->remote_rtcp_port, rtp_session->rtcp_remote_addr->family);\n\t\t}\n\n\t\tif (rtp_session->rtcp_sock_input && switch_sockaddr_get_family(rtp_session->rtcp_remote_addr) ==\n\t\t\tswitch_sockaddr_get_family(rtp_session->rtcp_local_addr)) {\n\t\t\trtp_session->rtcp_sock_output = rtp_session->rtcp_sock_input;\n\t\t} else {\n\n\t\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != rtp_session->rtcp_sock_input) {\n\t\t\t\tswitch_socket_close(rtp_session->rtcp_sock_output);\n\t\t\t}\n\n\t\t\tif ((status = switch_socket_create(&rtp_session->rtcp_sock_output,\n\t\t\t\t\t\t\t\t\t\t\t   switch_sockaddr_get_family(rtp_session->rtcp_remote_addr),\n\t\t\t\t\t\t\t\t\t\t\t   SOCK_DGRAM, 0, rtp_session->pool)) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t*err = \"RTCP Socket Error!\";\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t*err = \"RTCP NOT ACTIVE!\";\n\t}\n\n\treturn status;\n\n}\n\nstatic switch_status_t enable_local_rtcp_socket(switch_rtp_t *rtp_session, const char **err) {\n\n\tconst char *host = rtp_session->local_host_str;\n\tswitch_port_t port = rtp_session->local_port;\n\tswitch_socket_t *rtcp_new_sock = NULL, *rtcp_old_sock = NULL;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\tchar bufa[50];\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_local_addr, host, SWITCH_UNSPEC, port+1, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Local Address Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_socket_create(&rtcp_new_sock, switch_sockaddr_get_family(rtp_session->rtcp_local_addr), SOCK_DGRAM, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Socket Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_socket_opt_set(rtcp_new_sock, SWITCH_SO_REUSEADDR, 1) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Socket Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_socket_bind(rtcp_new_sock, rtp_session->rtcp_local_addr) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Bind Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_from_addr, switch_get_addr(bufa, sizeof(bufa), rtp_session->from_addr),\n\t\t\t\t\t\t\t\t\t\t\t SWITCH_UNSPEC, switch_sockaddr_get_port(rtp_session->from_addr) + 1, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP From Address Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\trtcp_old_sock = rtp_session->rtcp_sock_input;\n\t\trtp_session->rtcp_sock_input = rtcp_new_sock;\n\t\trtcp_new_sock = NULL;\n\n\t\tswitch_socket_create_pollset(&rtp_session->rtcp_read_pollfd, rtp_session->rtcp_sock_input, SWITCH_POLLIN | SWITCH_POLLERR, rtp_session->pool);\n\n done:\n\n\t\tif (*err) {\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error allocating rtcp [%s]\\n\", *err);\n\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\tif (rtcp_new_sock) {\n\t\t\tswitch_socket_close(rtcp_new_sock);\n\t\t}\n\n\t\tif (rtcp_old_sock) {\n\t\t\tswitch_socket_close(rtcp_old_sock);\n\t\t}\n\t} else {\n\t\tstatus = SWITCH_STATUS_FALSE;\n\t}\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_local_address(switch_rtp_t *rtp_session, const char *host, switch_port_t port, const char **err)\n{\n\tswitch_socket_t *new_sock = NULL, *old_sock = NULL;\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\tint j = 0;\n#ifndef WIN32\n\tchar o[5] = \"TEST\", i[5] = \"\";\n\tswitch_size_t len, ilen = 0;\n\tint x;\n#endif\n\n\tif (rtp_session->ready != 1) {\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\tREAD_INC(rtp_session);\n\t\tWRITE_INC(rtp_session);\n\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\n\t*err = NULL;\n\n\tif (zstr(host) || !port) {\n\t\t*err = \"Address Error\";\n\t\tgoto done;\n\t}\n\n\n\trtp_session->local_host_str = switch_core_strdup(rtp_session->pool, host);\n\trtp_session->local_port = port;\n\n\n\tif (switch_sockaddr_info_get(&rtp_session->local_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t*err = \"Local Address Error!\";\n\t\tgoto done;\n\t}\n\n\n\tif (rtp_session->sock_input) {\n\t\tswitch_rtp_kill_socket(rtp_session);\n\t}\n\n\tif (switch_socket_create(&new_sock, switch_sockaddr_get_family(rtp_session->local_addr), SOCK_DGRAM, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t*err = \"Socket Error!\";\n\t\tgoto done;\n\t}\n\n\tif (switch_socket_opt_set(new_sock, SWITCH_SO_REUSEADDR, 1) != SWITCH_STATUS_SUCCESS) {\n\t\t*err = \"Socket Error!\";\n\t\tgoto done;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_RCVBUF, 1572864);\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_SNDBUF, 1572864);\n\t} else {\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_RCVBUF, 851968);\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_SNDBUF, 851968);\n\t}\n\n\tif (switch_socket_bind(new_sock, rtp_session->local_addr) != SWITCH_STATUS_SUCCESS) {\n\t\tchar *em = switch_core_sprintf(rtp_session->pool, \"Bind Error! %s:%d\", host, port);\n\t\t*err = em;\n\t\tgoto done;\n\t}\n\n\n\tif ((j = atoi(host)) && j > 223 && j < 240) { /* mcast */\n\t\tif (switch_mcast_interface(new_sock, rtp_session->local_addr) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"Multicast Socket interface Error\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_mcast_join(new_sock, rtp_session->local_addr, NULL, NULL) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"Multicast Error\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\tconst char *var;\n\n\t\t\tif ((var = switch_channel_get_variable(channel, \"multicast_ttl\"))) {\n\t\t\t\tint ttl = atoi(var);\n\n\t\t\t\tif (ttl > 0 && ttl < 256) {\n\t\t\t\t\tif (switch_mcast_hops(new_sock, (uint8_t) ttl) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t*err = \"Mutlicast TTL set failed\";\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n#ifndef WIN32\n\tlen = sizeof(i);\n\tswitch_socket_opt_set(new_sock, SWITCH_SO_NONBLOCK, TRUE);\n\n\tswitch_socket_sendto(new_sock, rtp_session->local_addr, 0, (void *) o, &len);\n\n\tx = 0;\n\twhile (!ilen) {\n\t\tswitch_status_t status;\n\t\tilen = len;\n\t\tstatus = switch_socket_recvfrom(rtp_session->from_addr, new_sock, 0, (void *) i, &ilen);\n\n\t\tif (status != SWITCH_STATUS_SUCCESS && status != SWITCH_STATUS_BREAK) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (++x > 1000) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch_cond_next();\n\t}\n\tswitch_socket_opt_set(new_sock, SWITCH_SO_NONBLOCK, FALSE);\n\n#endif\n\n\told_sock = rtp_session->sock_input;\n\trtp_session->sock_input = new_sock;\n\tnew_sock = NULL;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] || rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] || rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t}\n\n\tswitch_socket_create_pollset(&rtp_session->read_pollfd, rtp_session->sock_input, SWITCH_POLLIN | SWITCH_POLLERR, rtp_session->pool);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tif ((status = enable_local_rtcp_socket(rtp_session, err)) == SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"Success\";\n\t\t}\n\t} else {\n\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t*err = \"Success\";\n\t}\n\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_IO);\n\n done:\n\n\tif (new_sock) {\n\t\tswitch_socket_close(new_sock);\n\t}\n\n\tif (old_sock) {\n\t\tswitch_socket_close(old_sock);\n\t}\n\n\n\tif (rtp_session->ready != 1) {\n\t\tWRITE_DEC(rtp_session);\n\t\tREAD_DEC(rtp_session);\n\t}\n\n\treturn status;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_media_timeout(switch_rtp_t *rtp_session, uint32_t ms)\n{\n\tif (!switch_rtp_ready(rtp_session) || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\treturn;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1,\n\t\t\t\t\t  \"%s MEDIA TIMEOUT %s set to %u\\n\", switch_core_session_get_name(rtp_session->session), rtp_type(rtp_session), ms);\n\trtp_session->media_timeout = ms;\n\tswitch_rtp_reset_media_timer(rtp_session);\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_max_missed_packets(switch_rtp_t *rtp_session, uint32_t max)\n{\n\tif (!switch_rtp_ready(rtp_session) || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->missed_count > max) {\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t  \"new max missed packets(%d->%d) greater than current missed packets(%d). RTP will timeout.\\n\",\n\t\t\t\t\t\t  rtp_session->max_missed_packets, max, rtp_session->missed_count);\n\t}\n\n\trtp_session->max_missed_packets = max;\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset_jb(switch_rtp_t *rtp_session)\n{\n\tif (switch_rtp_ready(rtp_session)) {\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset_vb(switch_rtp_t *rtp_session)\n{\n\n\tif (rtp_session->vb) {\n\t\tswitch_jb_reset(rtp_session->vb);\n\t}\n\n\tif (rtp_session->vbw) {\n\t\tswitch_jb_reset(rtp_session->vbw);\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset(switch_rtp_t *rtp_session)\n{\n\tif (!rtp_session) {\n\t\treturn;\n\t}\n\n\t//rtp_session->seq = (uint16_t) rand();\n\t//rtp_session->ts = 0;\n\tmemset(&rtp_session->ts_norm, 0, sizeof(rtp_session->ts_norm));\n\n\trtp_session->last_stun = rtp_session->first_stun = 0;\n\trtp_session->rtcp_sent_packets = 0;\n\trtp_session->rtcp_last_sent = 0;\n\trtp_session->last_adj = 0;\n\n\t//switch_rtp_del_dtls(rtp_session, DTLS_TYPE_RTP|DTLS_TYPE_RTCP);\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_PAUSE);\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_MUTE);\n\trtcp_stats_init(rtp_session);\n\n\tif (rtp_session->ice.ready) {\n\t\tswitch_rtp_reset_vb(rtp_session);\n\t\trtp_session->ice.ready = rtp_session->ice.rready = 0;\n\t\trtp_session->ice.cand_responsive = 0;\n\t}\n\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset_media_timer(switch_rtp_t *rtp_session)\n{\n\trtp_session->missed_count = 0;\n\trtp_session->last_media = switch_micro_time_now();\n}\n\nSWITCH_DECLARE(char *) switch_rtp_get_remote_host(switch_rtp_t *rtp_session)\n{\n\treturn zstr(rtp_session->remote_host_str) ? \"0.0.0.0\" : rtp_session->remote_host_str;\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_get_remote_port(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->remote_port;\n}\n\nstatic void ping_socket(switch_rtp_t *rtp_session)\n{\n\tuint32_t o = UINT_MAX;\n\tswitch_size_t len = sizeof(o);\n\tswitch_socket_sendto(rtp_session->sock_input, rtp_session->local_addr, 0, (void *) &o, &len);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] && rtp_session->rtcp_sock_input && rtp_session->rtcp_sock_input != rtp_session->sock_input) {\n\t\tswitch_socket_sendto(rtp_session->rtcp_sock_input, rtp_session->rtcp_local_addr, 0, (void *) &o, &len);\n\t}\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_udptl_mode(switch_rtp_t *rtp_session)\n{\n\tswitch_socket_t *sock;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_PROXY_MEDIA)) {\n\t\tping_socket(rtp_session);\n\t}\n\n\tREAD_INC(rtp_session);\n\tWRITE_INC(rtp_session);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] || rtp_session->timer.timer_interface) {\n\t\tswitch_core_timer_destroy(&rtp_session->timer);\n\t\tmemset(&rtp_session->timer, 0, sizeof(rtp_session->timer));\n\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t}\n\n\trtp_session->missed_count = 0;\n\trtp_session->max_missed_packets = 0;\n\n\trtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] = 0;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\trtp_session->rtcp_sock_input = NULL;\n\t\trtp_session->rtcp_sock_output = NULL;\n\t} else {\n\t\tif (rtp_session->rtcp_sock_input && rtp_session->rtcp_sock_input != rtp_session->sock_input) {\n\t\t\tping_socket(rtp_session);\n\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_input, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\n\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != rtp_session->rtcp_sock_input &&\n\t\t\trtp_session->rtcp_sock_output != rtp_session->sock_input) {\n\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_output, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\n\t\tif ((sock = rtp_session->rtcp_sock_input)) {\n\t\t\trtp_session->rtcp_sock_input = NULL;\n\t\t\tswitch_socket_close(sock);\n\n\t\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != sock) {\n\t\t\t\tsock = rtp_session->rtcp_sock_output;\n\t\t\t\trtp_session->rtcp_sock_output = NULL;\n\t\t\t\tswitch_socket_close(sock);\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_UDPTL);\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_PROXY_MEDIA);\n\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, FALSE);\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\n\tWRITE_DEC(rtp_session);\n\tREAD_DEC(rtp_session);\n\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_STICKY_FLUSH);\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\n\tswitch_rtp_break(rtp_session);\n\n\treturn SWITCH_STATUS_SUCCESS;\n\n}\n\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_remote_address(switch_rtp_t *rtp_session, const char *host, switch_port_t port, switch_port_t remote_rtcp_port,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  switch_bool_t change_adv_addr, const char **err)\n{\n\tswitch_sockaddr_t *remote_addr;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\t*err = \"Success\";\n\n\tif (switch_sockaddr_info_get(&remote_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !remote_addr) {\n\t\t*err = \"Remote Address Error!\";\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\n\tswitch_mutex_lock(rtp_session->write_mutex);\n\n\trtp_session->remote_addr = remote_addr;\n\n\tif (change_adv_addr) {\n\t\trtp_session->remote_host_str = switch_core_strdup(rtp_session->pool, host);\n\t\trtp_session->remote_port = port;\n\t}\n\n\trtp_session->eff_remote_host_str = switch_core_strdup(rtp_session->pool, host);\n\trtp_session->eff_remote_port = port;\n\n\tif (rtp_session->sock_input && switch_sockaddr_get_family(rtp_session->remote_addr) == switch_sockaddr_get_family(rtp_session->local_addr)) {\n\t\trtp_session->sock_output = rtp_session->sock_input;\n\t} else {\n\t\tif (rtp_session->sock_output && rtp_session->sock_output != rtp_session->sock_input) {\n\t\t\tswitch_socket_close(rtp_session->sock_output);\n\t\t}\n\t\tif ((status = switch_socket_create(&rtp_session->sock_output,\n\t\t\t\t\t\t\t\t\t\t   switch_sockaddr_get_family(rtp_session->remote_addr),\n\t\t\t\t\t\t\t\t\t\t   SOCK_DGRAM, 0, rtp_session->pool)) != SWITCH_STATUS_SUCCESS) {\n\n\t\t\t*err = \"Socket Error!\";\n\t\t}\n\t}\n\n\tif (rtp_session->dtls) {\n\t\trtp_session->dtls->sock_output = rtp_session->sock_output;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\tstatus = switch_sockaddr_info_get(&rtp_session->dtls->remote_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool);\n\t\t}\n\t}\n\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\trtp_session->rtcp_remote_addr = rtp_session->remote_addr;\n\t\t\trtp_session->rtcp_sock_output = rtp_session->sock_output;\n\t\t}/* else {\n\t\t\tif (remote_rtcp_port) {\n\t\t\t\trtp_session->remote_rtcp_port = remote_rtcp_port;\n\t\t\t} else {\n\t\t\t\trtp_session->remote_rtcp_port = rtp_session->eff_remote_port + 1;\n\t\t\t}\n\t\t\tstatus = enable_remote_rtcp_socket(rtp_session, err);\n\n\t\t\tif (rtp_session->rtcp_dtls) {\n\t\t\t\t//switch_sockaddr_info_get(&rtp_session->rtcp_dtls->remote_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool);\n\t\t\t\trtp_session->rtcp_dtls->remote_addr = rtp_session->rtcp_remote_addr;\n\t\t\t\trtp_session->rtcp_dtls->sock_output = rtp_session->rtcp_sock_output;\n\t\t\t}\n\t\t\t}*/\n\t}\n\n\tswitch_mutex_unlock(rtp_session->write_mutex);\n\n\treturn status;\n}\n\n\nstatic const char *dtls_state_names_t[] = {\"OFF\", \"HANDSHAKE\", \"SETUP\", \"READY\", \"FAIL\", \"INVALID\"};\nstatic const char *dtls_state_names(dtls_state_t s)\n{\n\tif (s > DS_INVALID) {\n\t\ts = DS_INVALID;\n\t}\n\n\treturn dtls_state_names_t[s];\n}\n\n#define dtls_set_state(_dtls, _state) switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Changing %s DTLS state from %s to %s\\n\", rtp_type(rtp_session), dtls_state_names(_dtls->state), dtls_state_names(_state)); _dtls->new_state = 1; _dtls->last_state = _dtls->state; _dtls->state = _state\n\n#define cr_keylen 16\n#define cr_saltlen 14\n#define cr_kslen 30\n\nstatic int dtls_state_setup(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tX509 *cert;\n\tswitch_secure_settings_t\tssec;\t/* Used just to wrap over params in a call to switch_rtp_add_crypto_key. */\n\tint r = 0;\n\n\tuint8_t raw_key_data[cr_kslen * 2];\n\tunsigned char local_key_buf[cr_kslen];\n\tunsigned char remote_key_buf[cr_kslen];\n\n\tmemset(&ssec, 0, sizeof(ssec));\n\tmemset(&raw_key_data, 0, cr_kslen * 2 * sizeof(uint8_t));\n\tmemset(&local_key_buf, 0, cr_kslen * sizeof(unsigned char));\n\tmemset(&remote_key_buf, 0, cr_kslen * sizeof(unsigned char));\n\n\tif ((dtls->type & DTLS_TYPE_SERVER)) {\n\t\tr = 1;\n\t} else if ((cert = SSL_get_peer_certificate(dtls->ssl))) {\n\t\tswitch_core_cert_extract_fingerprint(cert, dtls->remote_fp);\n\t\tr = switch_core_cert_verify(dtls->remote_fp);\n\t\tX509_free(cert);\n\t}\n\n\tif (!r) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s Fingerprint Verification Failed!\\n\", rtp_type(rtp_session));\n\t\tdtls_set_state(dtls, DS_FAIL);\n\t\treturn -1;\n\t} else {\n\t\tunsigned char *local_key, *remote_key, *local_salt, *remote_salt;\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"%s Fingerprint Verified.\\n\", rtp_type(rtp_session));\n\n#ifdef HAVE_OPENSSL_DTLS_SRTP\n\t\tif (!SSL_export_keying_material(dtls->ssl, raw_key_data, sizeof(raw_key_data), \"EXTRACTOR-dtls_srtp\", 19, NULL, 0, 0)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s Key material export failure\\n\", rtp_type(rtp_session));\n\t\t\tdtls_set_state(dtls, DS_FAIL);\n\t\t\treturn -1;\n\t\t}\n#else\n\t\treturn -1;\n#endif\n\n\t\tif ((dtls->type & DTLS_TYPE_CLIENT)) {\n\t\t\tlocal_key = raw_key_data;\n\t\t\tremote_key = local_key + cr_keylen;\n\t\t\tlocal_salt = remote_key + cr_keylen;\n\t\t\tremote_salt = local_salt + cr_saltlen;\n\n\t\t} else {\n\t\t\tremote_key = raw_key_data;\n\t\t\tlocal_key = remote_key + cr_keylen;\n\t\t\tremote_salt = local_key + cr_keylen;\n\t\t\tlocal_salt = remote_salt + cr_saltlen;\n\t\t}\n\n\t\tmemcpy(ssec.local_raw_key, local_key, cr_keylen);\n\t\tmemcpy(ssec.local_raw_key + cr_keylen, local_salt, cr_saltlen);\n\n\t\tmemcpy(ssec.remote_raw_key, remote_key, cr_keylen);\n\t\tmemcpy(ssec.remote_raw_key + cr_keylen, remote_salt, cr_saltlen);\n\n\t\tssec.crypto_type = AES_CM_128_HMAC_SHA1_80;\n\n\t\tif (dtls == rtp_session->rtcp_dtls && rtp_session->rtcp_dtls != rtp_session->dtls) {\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_SEND_RTCP, 0, &ssec);\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_RECV_RTCP, 0, &ssec);\n\t\t} else {\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_SEND, 0, &ssec);\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_RECV, 0, &ssec);\n\t\t}\n\t}\n\n\tdtls_set_state(dtls, DS_READY);\n\n\treturn 0;\n}\n\nstatic int dtls_state_ready(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\n\tif (dtls->new_state) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch_core_session_t *other_session;\n\n\t\t\tif (rtp_session->session && switch_core_session_get_partner(rtp_session->session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_core_session_request_video_refresh(other_session);\n\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t}\n\t\t}\n\t\tdtls->new_state = 0;\n\t}\n\treturn 0;\n}\n\nstatic int dtls_state_fail(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tif (rtp_session->session) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_DESTINATION_OUT_OF_ORDER);\n\t}\n\n\treturn -1;\n}\n\n\nstatic int dtls_state_handshake(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tint ret;\n\n\tif ((ret = SSL_do_handshake(dtls->ssl)) != 1){\n\t\tswitch((ret = SSL_get_error(dtls->ssl, ret))){\n\t\tcase SSL_ERROR_WANT_READ:\n\t\tcase SSL_ERROR_WANT_WRITE:\n\t\tcase SSL_ERROR_NONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s Handshake failure %d. This may happen when you use legacy DTLS v1.0 (legacyDTLS channel var is set) but endpoint requires DTLS v1.2.\\n\", rtp_type(rtp_session), ret);\n\t\t\tdtls_set_state(dtls, DS_FAIL);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\tdtls_set_state(dtls, DS_SETUP);\n\t}\n\n\treturn 0;\n}\n\nstatic void free_dtls(switch_dtls_t **dtlsp)\n{\n\tswitch_dtls_t *dtls;\n\n\tif (!dtlsp) {\n\t\treturn;\n\t}\n\n\tdtls = *dtlsp;\n\t*dtlsp = NULL;\n\n\tif (dtls->ssl) {\n\t\tSSL_free(dtls->ssl);\n\t}\n\n\tif (dtls->ssl_ctx) {\n\t\tSSL_CTX_free(dtls->ssl_ctx);\n\t}\n}\n\nstatic int do_dtls(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tint r = 0, ret = 0, len;\n\tswitch_size_t bytes;\n\tunsigned char buf[MAX_DTLS_MTU] = \"\";\n\tuint8_t is_ice = rtp_session->ice.ice_user ? 1 : 0;\n\tint ready = is_ice ? (rtp_session->ice.rready && rtp_session->ice.ready) : 1;\n\tint pending;\n\n\tif (!dtls->bytes && !ready) {\n\t\treturn 0;\n\t}\n\n\tif (is_ice && !rtp_session->ice.cand_responsive) {\n\t\treturn 0;\n\t}\n\n\tif (dtls->bytes > 0 && dtls->data) {\n\t\tret = BIO_write(dtls->read_bio, dtls->data, (int)dtls->bytes);\n\t\tif (ret <= 0) {\n\t\t\tret = SSL_get_error(dtls->ssl, ret);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet decode err: SSL err %d\\n\", rtp_type(rtp_session), ret);\n\t\t} else if (ret != (int)dtls->bytes) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet decode err: read %d bytes instead of %d\\n\", rtp_type(rtp_session), ret, (int)dtls->bytes);\n\t\t}\n\t}\n\n\tif (dtls_states[dtls->state]) {\n\t\tr = dtls_states[dtls->state](rtp_session, dtls);\n\t}\n\n\twhile ((pending = BIO_ctrl_pending(dtls->filter_bio)) > 0) {\n\t\tswitch_assert(pending <= sizeof(buf));\n\n\t\tlen = BIO_read(dtls->write_bio, buf, pending);\n\t\tif (len > 0) {\n\t\t\tbytes = len;\n\t\t\tret = switch_socket_sendto(dtls->sock_output, dtls->remote_addr, 0, (void *)buf, &bytes);\n\n\t\t\tif (ret != SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet not written to socket: %d\\n\", rtp_type(rtp_session), ret);\n\t\t\t} else if (bytes != len) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet write err: written %d bytes instead of %d\\n\", rtp_type(rtp_session), (int)bytes, len);\n\t\t\t}\n\t\t} else {\n\t\t\tret = SSL_get_error(dtls->ssl, len);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet encode err: SSL err %d\\n\", rtp_type(rtp_session), ret);\n\t\t}\n\t}\n\n\treturn r;\n}\n\n#if VERIFY\nstatic int cb_verify_peer(int preverify_ok, X509_STORE_CTX *ctx)\n{\n\tSSL *ssl = NULL;\n\tswitch_dtls_t *dtls;\n\tX509 *cert;\n\tint r = 0;\n\n\tssl = X509_STORE_CTX_get_app_data(ctx);\n\tdtls = (switch_dtls_t *) SSL_get_app_data(ssl);\n\n\tif (!(ssl && dtls)) {\n\t\treturn 0;\n\t}\n\n\tif ((cert = SSL_get_peer_certificate(dtls->ssl))) {\n\t\tswitch_core_cert_extract_fingerprint(cert, dtls->remote_fp);\n\n\t\tr = switch_core_cert_verify(dtls->remote_fp);\n\n\t\tX509_free(cert);\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(dtls->rtp_session->session), SWITCH_LOG_ERROR, \"%s CERT ERR!\\n\", rtp_type(dtls->rtp_session));\n\t}\n\n\treturn r;\n}\n#endif\n\n\n////////////\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\nstatic BIO_METHOD dtls_bio_filter_methods;\n#else\nstatic BIO_METHOD *dtls_bio_filter_methods;\n#endif\n\nBIO_METHOD *BIO_dtls_filter(void) {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\t\n\treturn(&dtls_bio_filter_methods);\n#else\n\treturn(dtls_bio_filter_methods);\n#endif\n}\n\ntypedef struct packet_list_s {\n\t//void *packet;\n\tint size;\n\tstruct packet_list_s *next;\n} packet_list_t;\n \n/* Helper struct to keep the filter state */\ntypedef struct dtls_bio_filter {\n\tpacket_list_t *packets;\n\tpacket_list_t *unused;\n\tpacket_list_t *tail;\n\tswitch_mutex_t *mutex;\n\tswitch_memory_pool_t *pool;\n\tlong mtu;\n} dtls_bio_filter;\n \n \nstatic int dtls_bio_filter_new(BIO *bio) {\n\t/* Create a filter state struct */\n\tdtls_bio_filter *filter;\n\tswitch_memory_pool_t *pool;\n\n\tswitch_core_new_memory_pool(&pool);\n\tfilter = switch_core_alloc(pool, sizeof(*filter));\n\tfilter->pool = pool;\n\n\tfilter->packets = NULL;\n\tswitch_mutex_init(&filter->mutex, SWITCH_MUTEX_NESTED, filter->pool);\n \n\t/* Set the BIO as initialized */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tbio->init = 1;\n\tbio->ptr = filter;\n\tbio->flags = 0;\n#else\n\tBIO_set_init(bio, 1);\n\tBIO_set_data(bio, filter);\n\tBIO_clear_flags(bio, ~0);\n#endif\n\t\n\treturn 1;\n}\n \nstatic int dtls_bio_filter_free(BIO *bio) {\n\tdtls_bio_filter *filter;\n\n\tif (bio == NULL) {\n\t\treturn 0;\n\t}\n \n\t/* Get rid of the filter state */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tfilter = (dtls_bio_filter *)bio->ptr;\n#else\n\tfilter = (dtls_bio_filter *)BIO_get_data(bio);\n#endif\n\n\tif (filter != NULL) {\n\t\tswitch_memory_pool_t *pool = filter->pool;\n\t\tswitch_core_destroy_memory_pool(&pool);\n\t\tpool = NULL;\n\t\tfilter = NULL;\n\t}\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tbio->ptr = NULL;\n\tbio->init = 0;\n\tbio->flags = 0;\n#else\n\tBIO_set_init(bio, 0);\n\tBIO_set_data(bio, NULL);\n\tBIO_clear_flags(bio, ~0);\n#endif\n\treturn 1;\n}\n \nstatic int dtls_bio_filter_write(BIO *bio, const char *in, int inl) {\n\tlong ret;\n\tdtls_bio_filter *filter;\n\t\n\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"dtls_bio_filter_write: %p, %d\\n\", (void *)in, inl);\n\t/* Forward data to the write BIO */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tret = BIO_write(bio->next_bio, in, inl);\n#else\n\tret = BIO_write(BIO_next(bio), in, inl);\n#endif\n\t\n\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"  -- %ld\\n\", ret);\n \n\t/* Keep track of the packet, as we'll advertize them one by one after a pending check */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tfilter = (dtls_bio_filter *)bio->ptr;\n#else\n\tfilter = (dtls_bio_filter *)BIO_get_data(bio);\n#endif\n\n\tif (filter != NULL) {\n\t\tpacket_list_t *node;\n\n\t\tswitch_mutex_lock(filter->mutex);\n\t\tif (filter->unused) {\n\t\t\tnode = filter->unused;\n\t\t\tnode->next = NULL;\n\t\t\tfilter->unused = filter->unused->next;\n\t\t} else {\n\t\t\tnode = switch_core_alloc(filter->pool, sizeof(*node));\n\t\t}\n\n\t\tnode->size = ret;\n\n\t\tif (filter->tail) {\n\t\t\tfilter->tail->next = node;\n\t\t} else {\n\t\t\tfilter->packets = node;\n\t\t}\n\n\t\tfilter->tail = node;\n\n\t\tswitch_mutex_unlock(filter->mutex);\n\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"New list length: %d\\n\", g_list_length(filter->packets));\n\t}\n\treturn ret;\n}\n \nstatic long dtls_bio_filter_ctrl(BIO *bio, int cmd, long num, void *ptr) {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tdtls_bio_filter *filter = (dtls_bio_filter *)bio->ptr;\n#else\n\tdtls_bio_filter *filter = (dtls_bio_filter *)BIO_get_data(bio);\n#endif\n\n\tswitch(cmd) {\n\tcase BIO_CTRL_DGRAM_GET_FALLBACK_MTU:\n\t\treturn 1200;\n\tcase BIO_CTRL_DGRAM_SET_MTU:\n\t\tfilter->mtu = num;\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"Setting MTU: %ld\\n\", filter->mtu);\n\t\treturn num;\n\tcase BIO_CTRL_FLUSH:\n\t\treturn 1;\n\tcase BIO_CTRL_DGRAM_QUERY_MTU:\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"Advertizing MTU: %ld\\n\", filter->mtu);\n\t\treturn filter->mtu;\n\tcase BIO_CTRL_WPENDING:\n\t\treturn 0L;\n\tcase BIO_CTRL_PENDING: {\n\t\tint pending = 0;\n\t\tpacket_list_t *top;\n\n\t\tif (filter == NULL) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tswitch_mutex_lock(filter->mutex);\n\t\tif ((top = filter->packets)) {\n\t\t\tfilter->packets = filter->packets->next;\n\t\t\t\n\t\t\tif (top == filter->tail || !filter->packets) {\n\t\t\t\tfilter->tail = NULL;\n\t\t\t}\n\t\t\t\n\t\t\tpending = top->size;\n\t\t\ttop->next = filter->unused;\n\t\t\tfilter->unused = top;\n\t\t}\n\t\tswitch_mutex_unlock(filter->mutex);\n\n\t\treturn pending;\n\t}\n\tdefault:\n\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"dtls_bio_filter_ctrl: %d\\n\", cmd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\nstatic BIO_METHOD dtls_bio_filter_methods = {\n\tBIO_TYPE_FILTER,\n\t\"DTLS filter\",\n\tdtls_bio_filter_write,\n\tNULL,\n\tNULL,\n\tNULL,\n\tdtls_bio_filter_ctrl,\n\tdtls_bio_filter_new,\n\tdtls_bio_filter_free,\n\tNULL\n};\n#else\nstatic BIO_METHOD *dtls_bio_filter_methods = NULL;\n#endif\n\nstatic void switch_rtp_dtls_init(void) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tdtls_bio_filter_methods = BIO_meth_new(BIO_TYPE_FILTER | BIO_get_new_index(), \"DTLS filter\");\n\tBIO_meth_set_write(dtls_bio_filter_methods, dtls_bio_filter_write);\n\tBIO_meth_set_ctrl(dtls_bio_filter_methods, dtls_bio_filter_ctrl);\n\tBIO_meth_set_create(dtls_bio_filter_methods, dtls_bio_filter_new);\n\tBIO_meth_set_destroy(dtls_bio_filter_methods, dtls_bio_filter_free);\n#endif\n}\n\nstatic void switch_rtp_dtls_destroy(void) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tif (dtls_bio_filter_methods) {\n\t\tBIO_meth_free(dtls_bio_filter_methods);\n\t\tdtls_bio_filter_methods = NULL;\n\t}\n#endif\n}\n\n///////////\n\n\n\nSWITCH_DECLARE(int) switch_rtp_has_dtls(void) {\n#ifdef HAVE_OPENSSL_DTLS_SRTP\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nSWITCH_DECLARE(dtls_state_t) switch_rtp_dtls_state(switch_rtp_t *rtp_session, dtls_type_t type)\n{\n\tdtls_state_t s = DS_OFF;\n\n\tif (!rtp_session) {\n\t\treturn s;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!rtp_session->dtls && !rtp_session->rtcp_dtls) {\n\t\ts = DS_OFF;\n\t\tgoto done;\n\t}\n\n\tif ((type == DTLS_TYPE_RTP) && rtp_session->dtls) {\n\t\ts = rtp_session->dtls->state;\n\t\tgoto done;\n\t}\n\n\tif ((type == DTLS_TYPE_RTCP) && rtp_session->rtcp_dtls) {\n\t\ts = rtp_session->rtcp_dtls->state;\n\t}\n\n done:\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn s;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_del_dtls(switch_rtp_t *rtp_session, dtls_type_t type)\n{\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\n\tif (!rtp_session) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!rtp_session->dtls && !rtp_session->rtcp_dtls) {\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif ((type & DTLS_TYPE_RTP)) {\n\t\tif (rtp_session->dtls && rtp_session->dtls == rtp_session->rtcp_dtls) {\n\t\t\trtp_session->rtcp_dtls = NULL;\n\t\t}\n\n\t\tif (rtp_session->dtls) {\n\t\t\tfree_dtls(&rtp_session->dtls);\n\t\t}\n\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\tswitch_jb_reset(rtp_session->vb);\n\t\t}\n\n\t\tif (rtp_session->vbw) {\n\t\t\tswitch_jb_reset(rtp_session->vbw);\n\t\t}\n\n\t}\n\n\tif ((type & DTLS_TYPE_RTCP) && rtp_session->rtcp_dtls) {\n\t\tfree_dtls(&rtp_session->rtcp_dtls);\n\t}\n\n\n#ifdef ENABLE_SRTP\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\tint x;\n\n\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\n\t\tfor(x = 0; x < 2; x++) {\n\t\t\tif (rtp_session->send_ctx[x]) {\n\t\t\t\tsrtp_dealloc(rtp_session->send_ctx[x]);\n\t\t\t\trtp_session->send_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {\n\t\tint x;\n\n\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\n\t\tfor (x = 0; x < 2; x++) {\n\t\t\tif (rtp_session->recv_ctx[x]) {\n\t\t\t\tsrtp_dealloc(rtp_session->recv_ctx[x]);\n\t\t\t\trtp_session->recv_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n done:\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_add_dtls(switch_rtp_t *rtp_session, dtls_fingerprint_t *local_fp, dtls_fingerprint_t *remote_fp, dtls_type_t type, uint8_t want_DTLSv1_2)\n{\n\tswitch_dtls_t *dtls;\n\tconst char *var;\n\tint ret;\n\tconst char *kind = \"\";\n\tunsigned long ssl_method_error = 0;\n\tunsigned long ssl_ctx_error = 0;\n\tconst SSL_METHOD *ssl_method;\n\tSSL_CTX *ssl_ctx;\n#if OPENSSL_VERSION_NUMBER < 0x30000000\n\tBIO *bio;\n\tDH *dh;\n#endif\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n#ifndef OPENSSL_NO_EC\n#if OPENSSL_VERSION_NUMBER < 0x10002000L\n\tEC_KEY* ecdh;\n#endif\n#endif\n\n#ifndef HAVE_OPENSSL_DTLS_SRTP\n\treturn SWITCH_STATUS_FALSE;\n#endif\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!((type & DTLS_TYPE_RTP) || (type & DTLS_TYPE_RTCP)) || !((type & DTLS_TYPE_CLIENT) || (type & DTLS_TYPE_SERVER))) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"INVALID TYPE!\\n\");\n\t}\n\n\tswitch_rtp_del_dtls(rtp_session, type);\n\n\tif ((type & DTLS_TYPE_RTP) && (type & DTLS_TYPE_RTCP)) {\n\t\tkind = \"RTP/RTCP\";\n\t} else if ((type & DTLS_TYPE_RTP)) {\n\t\tkind = \"RTP\";\n\t} else {\n\t\tkind = \"RTCP\";\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t  \"Activate %s %s DTLS %s\\n\", kind, rtp_type(rtp_session), (type & DTLS_TYPE_SERVER) ? \"server\" : \"client\");\n\n\tif (((type & DTLS_TYPE_RTP) && rtp_session->dtls) || ((type & DTLS_TYPE_RTCP) && rtp_session->rtcp_dtls)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"DTLS ALREADY INIT\\n\");\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tdtls = switch_core_alloc(rtp_session->pool, sizeof(*dtls));\n\n\tdtls->pem = switch_core_sprintf(rtp_session->pool, \"%s%s%s.pem\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);\n\n\tif (switch_file_exists(dtls->pem, rtp_session->pool) == SWITCH_STATUS_SUCCESS) {\n\t\tdtls->pvt = dtls->rsa = dtls->pem;\n\t} else {\n\t\tdtls->pvt = switch_core_sprintf(rtp_session->pool, \"%s%s%s.key\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);\n\t\tdtls->rsa = switch_core_sprintf(rtp_session->pool, \"%s%s%s.crt\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);\n\t}\n\n\tdtls->ca = switch_core_sprintf(rtp_session->pool, \"%s%sca-bundle.crt\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR);\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000\n\tssl_method = (type & DTLS_TYPE_SERVER) ? DTLS_server_method() : DTLS_client_method();\n#else\n    #ifdef HAVE_OPENSSL_DTLSv1_2_method\n\t\tssl_method = (type & DTLS_TYPE_SERVER) ? (want_DTLSv1_2 ? DTLSv1_2_server_method() : DTLSv1_server_method()) : (want_DTLSv1_2 ? DTLSv1_2_client_method() : DTLSv1_client_method());\n\t#else\n\t\tssl_method = (type & DTLS_TYPE_SERVER) ? DTLSv1_server_method() : DTLSv1_client_method();\n    #endif // HAVE_OPENSSL_DTLSv1_2_method\n#endif\n\n\tif (!ssl_method) {\n\t\tssl_method_error = ERR_peek_error();\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s ssl_method is NULL [%lu]\\n\", rtp_type(rtp_session), ssl_method_error);\n\t}\n\n\tdtls->ssl_ctx = ssl_ctx = SSL_CTX_new(ssl_method);\n\n\tif (!ssl_ctx) {\n\t\tssl_ctx_error = ERR_peek_error();\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s SSL_CTX_new failed [%lu]\\n\", rtp_type(rtp_session), ssl_ctx_error);\n\t\tswitch_channel_hangup(switch_core_session_get_channel(rtp_session->session), SWITCH_CAUSE_NORMAL_TEMPORARY_FAILURE);\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tswitch_assert(dtls->ssl_ctx);\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000\n\tbio = BIO_new_file(dtls->pem, \"r\");\n\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tBIO_free(bio);\n\tif (dh) {\n\t\tSSL_CTX_set_tmp_dh(dtls->ssl_ctx, dh);\n\t\tDH_free(dh);\n\t}\n#else\n\tif(!SSL_CTX_set_dh_auto(dtls->ssl_ctx, 1)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Failed enable auto DH!\\n\");\n\t}\n#endif\n\tSSL_CTX_set_mode(dtls->ssl_ctx, SSL_MODE_AUTO_RETRY);\n\n\t//SSL_CTX_set_verify(dtls->ssl_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);\n\tSSL_CTX_set_verify(dtls->ssl_ctx, SSL_VERIFY_NONE, NULL);\n\n\t//SSL_CTX_set_cipher_list(dtls->ssl_ctx, \"ECDH:!RC4:!SSLv3:RSA_WITH_AES_128_CBC_SHA\");\n\t//SSL_CTX_set_cipher_list(dtls->ssl_ctx, \"ECDHE-RSA-AES256-GCM-SHA384\");\n\tSSL_CTX_set_cipher_list(dtls->ssl_ctx, \"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\t//SSL_CTX_set_cipher_list(dtls->ssl_ctx, \"SUITEB128\");\n\tSSL_CTX_set_read_ahead(dtls->ssl_ctx, 1);\n#ifdef HAVE_OPENSSL_DTLS_SRTP\n\t//SSL_CTX_set_tlsext_use_srtp(dtls->ssl_ctx, \"SRTP_AES128_CM_SHA1_80:SRTP_AES128_CM_SHA1_32\");\n\tSSL_CTX_set_tlsext_use_srtp(dtls->ssl_ctx, \"SRTP_AES128_CM_SHA1_80\");\n#endif\n\n\tdtls->type = type;\n\tdtls->read_bio = BIO_new(BIO_s_mem());\n\tswitch_assert(dtls->read_bio);\n\n\tdtls->write_bio = BIO_new(BIO_s_mem());\n\tswitch_assert(dtls->write_bio);\n\n\tBIO_set_mem_eof_return(dtls->read_bio, -1);\n\tBIO_set_mem_eof_return(dtls->write_bio, -1);\n\n\tif ((ret=SSL_CTX_use_certificate_file(dtls->ssl_ctx, dtls->rsa, SSL_FILETYPE_PEM)) != 1) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS cert err [%d]\\n\", rtp_type(rtp_session), SSL_get_error(dtls->ssl, ret));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif ((ret=SSL_CTX_use_PrivateKey_file(dtls->ssl_ctx, dtls->pvt, SSL_FILETYPE_PEM)) != 1) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS key err [%d]\\n\", rtp_type(rtp_session), SSL_get_error(dtls->ssl, ret));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif (SSL_CTX_check_private_key(dtls->ssl_ctx) == 0) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS check key failed\\n\", rtp_type(rtp_session));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif (!zstr(dtls->ca) && switch_file_exists(dtls->ca, rtp_session->pool) == SWITCH_STATUS_SUCCESS\n\t\t&& (ret = SSL_CTX_load_verify_locations(dtls->ssl_ctx, dtls->ca, NULL)) != 1) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS check chain cert failed [%d]\\n\",\n\t\t\t\t\t\t  rtp_type(rtp_session) ,\n\t\t\t\t\t\t  SSL_get_error(dtls->ssl, ret));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tdtls->ssl = SSL_new(dtls->ssl_ctx);\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tdtls->filter_bio = BIO_new(BIO_dtls_filter());\n#else\n\tswitch_assert(dtls_bio_filter_methods);\n\tdtls->filter_bio = BIO_new(dtls_bio_filter_methods);\n#endif\n\n\tswitch_assert(dtls->filter_bio);\n\n\tBIO_push(dtls->filter_bio, dtls->write_bio);\n\n\tSSL_set_bio(dtls->ssl, dtls->read_bio, dtls->filter_bio);\n\n\tSSL_set_mode(dtls->ssl, SSL_MODE_AUTO_RETRY);\n\tSSL_set_read_ahead(dtls->ssl, 1);\n\n\n\t//SSL_set_verify(dtls->ssl, (SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT), cb_verify_peer);\n\n#ifndef OPENSSL_NO_EC\n#if OPENSSL_VERSION_NUMBER < 0x10002000L\n\tecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (!ecdh) {\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\tSSL_set_options(dtls->ssl, SSL_OP_SINGLE_ECDH_USE);\n\tSSL_set_tmp_ecdh(dtls->ssl, ecdh);\n\tEC_KEY_free(ecdh);\n#elif OPENSSL_VERSION_NUMBER < 0x10100000L\n\tSSL_set_ecdh_auto(dtls->ssl, 1);\n\tSSL_set_options(dtls->ssl, SSL_OP_SINGLE_ECDH_USE);\n#endif\n#endif\n\n\tSSL_set_verify(dtls->ssl, SSL_VERIFY_NONE, NULL);\n\tSSL_set_app_data(dtls->ssl, dtls);\n\n\tdtls->local_fp = local_fp;\n\tdtls->remote_fp = remote_fp;\n\tdtls->rtp_session = rtp_session;\n\tdtls->mtu = 1200;\n\n\tif (rtp_session->session) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\tif ((var = switch_channel_get_variable(channel, \"rtp_dtls_mtu\"))) {\n\t\t\tint mtu = atoi(var);\n\n\t\t\tif (mtu > 0 && mtu < MAX_DTLS_MTU) {\n\t\t\t\tdtls->mtu = mtu;\n\t\t\t}\n\n\t\t}\n\t}\n\t\n\tBIO_ctrl(dtls->filter_bio, BIO_CTRL_DGRAM_SET_MTU, dtls->mtu, NULL);\n\t\n\tswitch_core_cert_expand_fingerprint(remote_fp, remote_fp->str);\n\n\tif ((type & DTLS_TYPE_RTP)) {\n\t\trtp_session->dtls = dtls;\n\t\tdtls->sock_output = rtp_session->sock_output;\n\t\tdtls->remote_addr = rtp_session->remote_addr;\n\t}\n\n\tif ((type & DTLS_TYPE_RTCP)) {\n\t\trtp_session->rtcp_dtls = dtls;\n\t\tif (!(type & DTLS_TYPE_RTP)) {\n\t\t\tdtls->sock_output = rtp_session->rtcp_sock_output;\n\t\t\tdtls->remote_addr = rtp_session->rtcp_remote_addr;\n\t\t}\n\t}\n\n\tif ((type & DTLS_TYPE_SERVER)) {\n\t\tSSL_set_accept_state(dtls->ssl);\n\t} else {\n\t\tSSL_set_connect_state(dtls->ssl);\n\t}\n\n\tdtls_set_state(dtls, DS_HANDSHAKE);\n\n\trtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 1;\n\tswitch_rtp_break(rtp_session);\n\n done:\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn status;\n\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_add_crypto_key(switch_rtp_t *rtp_session, switch_rtp_crypto_direction_t direction, uint32_t index, switch_secure_settings_t *ssec)\n{\n#ifndef ENABLE_SRTP\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"SRTP NOT SUPPORTED IN THIS BUILD!\\n\");\n\treturn SWITCH_STATUS_FALSE;\n#else\n\n\tswitch_rtp_crypto_key_t *crypto_key;\n\tsrtp_policy_t *policy;\n\tsrtp_err_status_t stat;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\n\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\tswitch_event_t *fsevent = NULL;\n\tint idx = 0;\n\tconst char *var;\n\tunsigned char b64_key[512] = \"\";\n\t\n\tunsigned char\t*keysalt = NULL;\n\tswitch_size_t\tkeysalt_len = 0;\n\t\n\tswitch_crypto_key_material_t\t*key_material = NULL;\n\tunsigned long\t\t\t\t\t*key_material_n = NULL;\n\tsrtp_master_key_t\t\t**mkis = NULL;\n\tsrtp_master_key_t\t\t*mki = NULL;\n\tint mki_idx = 0;\n\n\tkeysalt_len = switch_core_media_crypto_keysalt_len(ssec->crypto_type);\n\n\tif (direction >= SWITCH_RTP_CRYPTO_MAX || keysalt_len > SWITCH_RTP_MAX_CRYPTO_LEN) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (direction == SWITCH_RTP_CRYPTO_RECV_RTCP) {\n\t\tdirection = SWITCH_RTP_CRYPTO_RECV;\n\t\trtp_session->srtp_idx_rtcp = idx = 1;\n\t} else if (direction == SWITCH_RTP_CRYPTO_SEND_RTCP) {\n\t\tdirection = SWITCH_RTP_CRYPTO_SEND;\n\t\trtp_session->srtp_idx_rtcp = idx = 1;\n\t}\n\n\tif (direction == SWITCH_RTP_CRYPTO_RECV) {\n\t\tpolicy = &rtp_session->recv_policy[idx];\n\t\tkeysalt = ssec->remote_raw_key;\n\t\tkey_material = ssec->remote_key_material_next;\n\t\tkey_material_n = &ssec->remote_key_material_n;\n\t} else {\n\t\tpolicy = &rtp_session->send_policy[idx];\n\t\tkeysalt = ssec->local_raw_key;\n\t\tkey_material = ssec->local_key_material_next;\n\t\tkey_material_n = &ssec->local_key_material_n;\n\t}\n\n\tswitch_b64_encode(keysalt, keysalt_len, b64_key, sizeof(b64_key));\n\n\tif (switch_true(switch_core_get_variable(\"rtp_retain_crypto_keys\"))) {\n\t\tswitch(direction) {\n\t\t\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_local_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_remote_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch(direction) {\n\t\t\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_local_video_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_remote_video_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tswitch(direction) {\n\t\t\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_local_audio_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_remote_audio_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcrypto_key = switch_core_alloc(rtp_session->pool, sizeof(*crypto_key));\n\n\tcrypto_key->type = ssec->crypto_type;\n\tcrypto_key->index = index;\n\tmemcpy(crypto_key->keysalt, keysalt, keysalt_len);\n\tcrypto_key->next = rtp_session->crypto_keys[direction];\n\trtp_session->crypto_keys[direction] = crypto_key;\n\n\tmemset(policy, 0, sizeof(*policy));\n\n\t/* many devices can't handle gaps in SRTP streams */\n\tif (!((var = switch_channel_get_variable(channel, \"srtp_allow_idle_gaps\"))\n\t\t  && switch_true(var))\n\t\t&& (!(var = switch_channel_get_variable(channel, \"send_silence_when_idle\"))\n\t\t\t|| !(atoi(var)))) {\n\t\tswitch_channel_set_variable(channel, \"send_silence_when_idle\", \"-1\");\n\t}\n\n\tswitch (crypto_key->type) {\n\tcase AES_CM_128_HMAC_SHA1_80:\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_80(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_80(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_128_HMAC_SHA1_80\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_128_HMAC_SHA1_32:\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&policy->rtcp);\n\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_128_HMAC_SHA1_32\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_256_GCM_8:\n\t\tsrtp_crypto_policy_set_aes_gcm_256_8_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_256_8_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_256_GCM_8\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_256_GCM:\n\t\tsrtp_crypto_policy_set_aes_gcm_256_16_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_256_16_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_256_GCM\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_128_GCM_8:\n\t\tsrtp_crypto_policy_set_aes_gcm_128_8_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_128_8_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_128_GCM_8\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_128_GCM:\n\t\tsrtp_crypto_policy_set_aes_gcm_128_16_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_128_16_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_128_GCM\");\n\t\t}\n\t\tbreak;\n\n\tcase AES_CM_256_HMAC_SHA1_80:\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_256_HMAC_SHA1_80\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_256_HMAC_SHA1_32:\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_256_HMAC_SHA1_32\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_192_HMAC_SHA1_80:\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_192_HMAC_SHA1_80\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_192_HMAC_SHA1_32:\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_192_HMAC_SHA1_32\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_128_NULL_AUTH:\n\t\tsrtp_crypto_policy_set_aes_cm_128_null_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_128_null_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_128_NULL_AUTH\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Missing crypto type!\\n\");\n\t\tbreak;\n\t}\n\n\t/* Setup the policy with MKI if they are used. Number of key materials must be positive to use MKI. */\n\tif (key_material && (*key_material_n > 0)) {\n\n\t\tif (direction == SWITCH_RTP_CRYPTO_RECV) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI] = 1;\t/* tell the rest of the environment MKI is used */\n\t\t} else {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI] = 1;\t/* tell the rest of the environment MKI is used */\n\t\t}\n\n\t\t/* key must be NULL for libsrtp to work correctly with MKI. */\n\t\tpolicy->key = NULL;\n\n\t\t/* Allocate array for MKIs. */\n\t\tmkis = switch_core_alloc(rtp_session->pool, *key_material_n * sizeof(srtp_master_key_t*));\n\t\tif (!mkis) {\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\t/* Build array of MKIs. */\n\t\tmki_idx = 0;\n\n\t\twhile (key_material && (mki_idx < *key_material_n)) {\n\n\t\t\tif (key_material->mki_size < 1) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"MKI bad key size at MKI %d\\n\", mki_idx);\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tmki = switch_core_alloc(rtp_session->pool, sizeof(srtp_master_key_t));\n\t\t\tif (!mki) {\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\t/* Setup MKI. */\n\t\t\tmki->mki_id = switch_core_alloc(rtp_session->pool, sizeof(key_material->mki_size));\n\t\t\tif (!mki->mki_id) {\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tmki->key = switch_core_alloc(rtp_session->pool, keysalt_len);\n\t\t\tif (!mki->key) {\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tmemcpy(mki->mki_id, &key_material->mki_id, key_material->mki_size);\n\t\t\tmki->mki_size = key_material->mki_size;\n\t\t\tmemcpy(mki->key, key_material->raw_key, keysalt_len);\n\n\t\t\tmkis[mki_idx] = mki;\n\n\t\t\tkey_material = key_material->next;\n\t\t\t++mki_idx;\n\t\t}\n\n\t\t/* And pass the array of MKIs to libsrtp. */\n\t\tpolicy->keys = mkis;\n\t\tpolicy->num_master_keys = mki_idx;\n\n\t} else {\n\t\tpolicy->key = (uint8_t *) crypto_key->keysalt;\n\t}\n\n\tpolicy->next = NULL;\n\n\tpolicy->window_size = 1024;\n\tpolicy->allow_repeat_tx = 1;\n\n\t//policy->rtp.sec_serv = sec_serv_conf_and_auth;\n\t//policy->rtcp.sec_serv = sec_serv_conf_and_auth;\n\n\tswitch (direction) {\n\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\tpolicy->ssrc.type = ssrc_any_inbound;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && idx == 0 && rtp_session->recv_ctx[idx]) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_RESET] = 1;\n\t\t} else {\n\t\t\tif ((stat = srtp_create(&rtp_session->recv_ctx[idx], policy)) || !rtp_session->recv_ctx[idx]) {\n\t\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tif (status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Activating %s Secure %s RECV%s\\n\",\n\t\t\t\t\t\t\t\t  rtp_type(rtp_session), idx ? \"RTCP\" : \"RTP\", rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI] ? \" (with MKI)\" : \"\");\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 1;\n\t\t\t} else {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error allocating srtp [%d]\\n\", stat);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\tpolicy->ssrc.type = ssrc_any_outbound;\n\t\t//policy->ssrc.type = ssrc_specific;\n\t\t//policy->ssrc.value = rtp_session->ssrc;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] && idx == 0 && rtp_session->send_ctx[idx]) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET] = 1;\n\t\t} else {\n\t\t\tif ((stat = srtp_create(&rtp_session->send_ctx[idx], policy)) || !rtp_session->send_ctx[idx]) {\n\t\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tif (status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Activating %s Secure %s SEND%s\\n\",\n\t\t\t\t\t\t\t\t  rtp_type(rtp_session), idx ? \"RTCP\" : \"RTP\", rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI] ? \" (with MKI)\" : \"\");\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 1;\n\t\t\t} else {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error allocating SRTP [%d]\\n\", stat);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (switch_event_create(&fsevent, SWITCH_EVENT_CALL_SECURE) == SWITCH_STATUS_SUCCESS) {\n\t\tif (rtp_session->dtls) {\n\t\t\tswitch_event_add_header(fsevent, SWITCH_STACK_BOTTOM, \"secure_type\", \"srtp:dtls:AES_CM_128_HMAC_SHA1_80\");\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"srtp:dtls:AES_CM_128_HMAC_SHA1_80\");\n\t\t} else {\n\t\t\tswitch_event_add_header(fsevent, SWITCH_STACK_BOTTOM, \"secure_type\", \"srtp:sdes:%s\", switch_channel_get_variable(channel, \"rtp_has_crypto\"));\n\t\t}\n\t\tswitch_event_add_header_string(fsevent, SWITCH_STACK_BOTTOM, \"caller-unique-id\", switch_channel_get_uuid(channel));\n\t\tswitch_event_fire(&fsevent);\n\t}\n\n\n\treturn SWITCH_STATUS_SUCCESS;\n#endif\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_interval(switch_rtp_t *rtp_session, uint32_t ms_per_packet, uint32_t samples_per_interval)\n{\n\trtp_session->ms_per_packet = ms_per_packet;\n\trtp_session->samples_per_interval = rtp_session->conf_samples_per_interval = samples_per_interval;\n\trtp_session->missed_count = 0;\n\trtp_session->samples_per_second =\n\t\t(uint32_t) ((double) (1000.0f / (double) (rtp_session->ms_per_packet / 1000)) * (double) rtp_session->samples_per_interval);\n\n\trtp_session->one_second = (rtp_session->samples_per_second / rtp_session->samples_per_interval);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_change_interval(switch_rtp_t *rtp_session, uint32_t ms_per_packet, uint32_t samples_per_interval)\n{\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\tint change_timer = 0;\n\n\tif (rtp_session->ms_per_packet != ms_per_packet || rtp_session->samples_per_interval != samples_per_interval) {\n\t\tchange_timer = 1;\n\t}\n\n\tswitch_rtp_set_interval(rtp_session, ms_per_packet, samples_per_interval);\n\n\tif (change_timer && rtp_session->timer_name) {\n\t\tREAD_INC(rtp_session);\n\t\tWRITE_INC(rtp_session);\n\n\t\tif (rtp_session->timer.timer_interface) {\n\t\t\tswitch_core_timer_destroy(&rtp_session->timer);\n\t\t}\n\n\t\tif (rtp_session->write_timer.timer_interface) {\n\t\t\tswitch_core_timer_destroy(&rtp_session->write_timer);\n\t\t}\n\n\t\tif ((status = switch_core_timer_init(&rtp_session->timer,\n\t\t\t\t\t\t\t\t\t\t\t rtp_session->timer_name, ms_per_packet / 1000,\n\t\t\t\t\t\t\t\t\t\t\t samples_per_interval, rtp_session->pool)) == SWITCH_STATUS_SUCCESS) {\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"RE-Starting timer [%s] %d bytes per %dms\\n\", rtp_session->timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t\tswitch_core_timer_init(&rtp_session->write_timer, rtp_session->timer_name, (ms_per_packet / 1000), samples_per_interval, rtp_session->pool);\n\t\t} else {\n\n\t\t\tmemset(&rtp_session->timer, 0, sizeof(rtp_session->timer));\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t  \"Problem RE-Starting timer [%s] %d bytes per %dms\\n\", rtp_session->timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t}\n\n\t\tWRITE_DEC(rtp_session);\n\t\tREAD_DEC(rtp_session);\n\t}\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_ssrc(switch_rtp_t *rtp_session, uint32_t ssrc)\n{\n\trtp_session->ssrc = ssrc;\n\trtp_session->send_msg.header.ssrc = htonl(rtp_session->ssrc);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_remote_ssrc(switch_rtp_t *rtp_session, uint32_t ssrc)\n{\n\trtp_session->remote_ssrc = ssrc;\n\trtp_session->flags[SWITCH_RTP_FLAG_DETECT_SSRC] = 0;\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_create(switch_rtp_t **new_rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t  switch_payload_t payload,\n\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t ms_per_packet,\n\t\t\t\t\t\t\t\t\t\t\t\t  switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID], char *timer_name, const char **err, switch_memory_pool_t *pool)\n{\n\tswitch_rtp_t *rtp_session = NULL;\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(pool, \"__session\");\n\tswitch_channel_t *channel = NULL;\n\n\tif (session) channel = switch_core_session_get_channel(session);\n\n\t*new_rtp_session = NULL;\n\n\tif (samples_per_interval > SWITCH_RTP_MAX_BUF_LEN) {\n\t\t*err = \"Packet Size Too Large!\";\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (!(rtp_session = switch_core_alloc(pool, sizeof(*rtp_session)))) {\n\t\t*err = \"Memory Error!\";\n\t\treturn SWITCH_STATUS_MEMERR;\n\t}\n\n\trtp_session->pool = pool;\n\trtp_session->te = INVALID_PT;\n\trtp_session->recv_te = INVALID_PT;\n\trtp_session->cng_pt = INVALID_PT;\n\trtp_session->session = session;\n\n\tswitch_mutex_init(&rtp_session->flag_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->read_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->write_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->ice_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->dtmf_data.dtmf_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_queue_create(&rtp_session->dtmf_data.dtmf_queue, 100, rtp_session->pool);\n\tswitch_queue_create(&rtp_session->dtmf_data.dtmf_inqueue, 100, rtp_session->pool);\n\n\tswitch_rtp_set_flags(rtp_session, flags);\n\n\t/* for from address on recvfrom calls */\n\tswitch_sockaddr_create(&rtp_session->from_addr, pool);\n\tswitch_sockaddr_create(&rtp_session->rtp_from_addr, pool);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tswitch_sockaddr_create(&rtp_session->rtcp_from_addr, pool);\n\t}\n\n\trtp_session->seq = (uint16_t) rand();\n\trtp_session->ssrc = (uint32_t) ((intptr_t) rtp_session + (switch_time_t) switch_epoch_time_now(NULL));\n#ifdef DEBUG_TS_ROLLOVER\n\trtp_session->last_write_ts = TS_ROLLOVER_START;\n#endif\n\trtp_session->stats.inbound.R = 100.0;\n\trtp_session->stats.inbound.mos = 4.5;\n\trtp_session->send_msg.header.ssrc = htonl(rtp_session->ssrc);\n\trtp_session->send_msg.header.ts = 0;\n\trtp_session->send_msg.header.m = 0;\n\trtp_session->send_msg.header.pt = (switch_payload_t) htonl(payload);\n\trtp_session->send_msg.header.version = 2;\n\trtp_session->send_msg.header.p = 0;\n\trtp_session->send_msg.header.x = 0;\n\trtp_session->send_msg.header.cc = 0;\n\n\trtp_session->recv_msg.header.ssrc = 0;\n\trtp_session->recv_msg.header.ts = 0;\n\trtp_session->recv_msg.header.seq = 0;\n\trtp_session->recv_msg.header.m = 0;\n\trtp_session->recv_msg.header.pt = (switch_payload_t) htonl(payload);\n\trtp_session->recv_msg.header.version = 2;\n\trtp_session->recv_msg.header.p = 0;\n\trtp_session->recv_msg.header.x = 0;\n\trtp_session->recv_msg.header.cc = 0;\n\n\trtp_session->payload = payload;\n\trtp_session->rtcp_last_sent = switch_micro_time_now();\n\n\tswitch_rtp_set_interval(rtp_session, ms_per_packet, samples_per_interval);\n\trtp_session->conf_samples_per_interval = samples_per_interval;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && zstr(timer_name)) {\n\t\ttimer_name = \"soft\";\n\t}\n\n\tif (!zstr(timer_name) && !strcasecmp(timer_name, \"none\")) {\n\t\ttimer_name = NULL;\n\t}\n\n\tif (!zstr(timer_name)) {\n\t\trtp_session->timer_name = switch_core_strdup(pool, timer_name);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\n\t\tif (switch_core_timer_init(&rtp_session->timer, timer_name, ms_per_packet / 1000, samples_per_interval, pool) == SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"Starting timer [%s] %d bytes per %dms\\n\", timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t\tswitch_core_timer_init(&rtp_session->write_timer, timer_name, (ms_per_packet / 1000), samples_per_interval, pool);\n#ifdef DEBUG_TS_ROLLOVER\n\t\t\trtp_session->timer.tick = TS_ROLLOVER_START / samples_per_interval;\n#endif\n\t\t} else {\n\t\t\tmemset(&rtp_session->timer, 0, sizeof(rtp_session->timer));\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t  \"Error Starting timer [%s] %d bytes per %dms, async RTP disabled\\n\", timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t\t}\n\t} else {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tif (switch_core_timer_init(&rtp_session->timer, \"soft\", 1, 90, pool) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Starting video timer.\\n\");\n\t\t\t}\n\n\t\t\t//switch_jb_create(&rtp_session->vb, 3, 10, rtp_session->pool);\n\t\t\t//switch_jb_debug_level(rtp_session->vb, 10);\n\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Not using a timer\\n\");\n\t\t}\n\n\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t}\n\n\n\tif (channel) {\n\t\tswitch_channel_set_private(channel, \"__rtcp_audio_rtp_session\", rtp_session);\n\t}\n\n\n\t/* Jitter */\n\trtp_session->stats.inbound.last_proc_time = switch_micro_time_now() / 1000;\n\trtp_session->stats.inbound.jitter_n = 0;\n\trtp_session->stats.inbound.jitter_add = 0;\n\trtp_session->stats.inbound.jitter_addsq = 0;\n\trtp_session->stats.inbound.min_variance = 0;\n\trtp_session->stats.inbound.max_variance = 0;\n\n\t/* Burst and Packet Loss */\n\trtp_session->stats.inbound.lossrate = 0;\n\trtp_session->stats.inbound.burstrate = 0;\n\tmemset(rtp_session->stats.inbound.loss, 0, sizeof(rtp_session->stats.inbound.loss));\n\trtp_session->stats.inbound.last_loss = 0;\n\trtp_session->stats.inbound.last_processed_seq = -1;\n\n\trtp_session->ready = 1;\n\t*new_rtp_session = rtp_session;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_rtp_t *) switch_rtp_new(const char *rx_host,\n\t\t\t\t\t\t\t\t\t\t\t  switch_port_t rx_port,\n\t\t\t\t\t\t\t\t\t\t\t  const char *tx_host,\n\t\t\t\t\t\t\t\t\t\t\t  switch_port_t tx_port,\n\t\t\t\t\t\t\t\t\t\t\t  switch_payload_t payload,\n\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_interval,\n\t\t\t\t\t\t\t\t\t\t\t  uint32_t ms_per_packet,\n\t\t\t\t\t\t\t\t\t\t\t  switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID], char *timer_name, const char **err, switch_memory_pool_t *pool,\n                                              switch_port_t bundle_internal_port,\n                                              switch_port_t bundle_external_port)\n{\n\tswitch_rtp_t *rtp_session = NULL;\n\n\tif (zstr(rx_host)) {\n\t\t*err = \"Missing local host\";\n\t\tgoto end;\n\t}\n\n\tif (!rx_port) {\n\t\t*err = \"Missing local port\";\n\t\tgoto end;\n\t}\n\n\tif (zstr(tx_host)) {\n\t\t*err = \"Missing remote host\";\n\t\tgoto end;\n\t}\n\n\tif (!tx_port) {\n\t\t*err = \"Missing remote port\";\n\t\tgoto end;\n\t}\n\n\tif (switch_rtp_create(&rtp_session, payload, samples_per_interval, ms_per_packet, flags, timer_name, err, pool) != SWITCH_STATUS_SUCCESS) {\n\t\tgoto end;\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\n\tif (switch_rtp_set_local_address(rtp_session, rx_host, rx_port, err) != SWITCH_STATUS_SUCCESS) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\trtp_session = NULL;\n\t\tgoto end;\n\t}\n\n\tif (switch_rtp_set_remote_address(rtp_session, tx_host, tx_port, 0, SWITCH_TRUE, err) != SWITCH_STATUS_SUCCESS) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\trtp_session = NULL;\n\t\tgoto end;\n\t}\n\n end:\n\n\tif (rtp_session) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\trtp_session->ready = 2;\n\t\trtp_session->rx_host = switch_core_strdup(rtp_session->pool, rx_host);\n\t\trtp_session->rx_port = rx_port;\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_DETECT_SSRC);\n\t} else {\n\t\tswitch_rtp_release_port(rx_host, rx_port);\n\t}\n\n\treturn rtp_session;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_telephony_event(switch_rtp_t *rtp_session, switch_payload_t te)\n{\n\tif (te > 95) {\n\t\trtp_session->te = te;\n\t}\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_set_telephony_recv_event(switch_rtp_t *rtp_session, switch_payload_t te)\n{\n\tif (te > 95) {\n\t\trtp_session->recv_te = te;\n\t}\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_set_cng_pt(switch_rtp_t *rtp_session, switch_payload_t pt)\n{\n\trtp_session->cng_pt = pt;\n\trtp_session->flags[SWITCH_RTP_FLAG_AUTO_CNG] = 1;\n}\n\nSWITCH_DECLARE(switch_timer_t *) switch_rtp_get_media_timer(switch_rtp_t *rtp_session)\n{\n\n\tif (rtp_session && rtp_session->timer.timer_interface) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t}\n\t\treturn &rtp_session->timer;\n\t}\n\n\treturn NULL;\n}\n\n\nSWITCH_DECLARE(switch_jb_t *) switch_rtp_get_jitter_buffer(switch_rtp_t *rtp_session)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn NULL;\n\t}\n\n\treturn rtp_session->jb ? rtp_session->jb : rtp_session->vb;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_pause_jitter_buffer(switch_rtp_t *rtp_session, switch_bool_t pause)\n{\n\tint new_val;\n\n\tif (rtp_session->pause_jb && !pause) {\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\tswitch_jb_reset(rtp_session->vb);\n\t\t}\n\t}\n\n\tnew_val = pause ? 1 : -1;\n\n\tif (rtp_session->pause_jb + new_val > -1) {\n\t\trtp_session->pause_jb += new_val;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1,\n\t\t\t\t\t  \"Jitterbuffer %s is %s\\n\", rtp_type(rtp_session), rtp_session->pause_jb ? \"paused\" : \"enabled\");\n\t\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_deactivate_jitter_buffer(switch_rtp_t *rtp_session)\n{\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->flags[SWITCH_RTP_FLAG_KILL_JB]++;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_get_video_buffer_size(switch_rtp_t *rtp_session, uint32_t *min_frame_len, uint32_t *max_frame_len, uint32_t *cur_frame_len, uint32_t *highest_frame_len)\n{\n\n\tif (rtp_session->vb) {\n\t\treturn switch_jb_get_frames(rtp_session->vb, min_frame_len, max_frame_len, cur_frame_len, highest_frame_len);\n\t}\n\n\treturn SWITCH_STATUS_FALSE;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_video_buffer_size(switch_rtp_t *rtp_session, uint32_t frames, uint32_t max_frames)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (!max_frames) {\n\t\tmax_frames = rtp_session->last_max_vb_frames;\n\t}\n\n\tif (!max_frames || frames >= max_frames) {\n\t\tmax_frames = frames * 10;\n\t}\n\n\trtp_session->last_max_vb_frames = max_frames;\n\n\tif (!rtp_session->vb) {\n\t\tswitch_jb_create(&rtp_session->vb, rtp_session->flags[SWITCH_RTP_FLAG_TEXT] ? SJB_TEXT : SJB_VIDEO, frames, max_frames, rtp_session->pool);\n\t\tswitch_jb_set_session(rtp_session->vb, rtp_session->session);\n\t} else {\n\t\tswitch_jb_set_frames(rtp_session->vb, frames, max_frames);\n\t}\n\n\t//switch_rtp_flush(rtp_session);\n\tswitch_core_session_request_video_refresh(rtp_session->session);\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Setting video buffer %u Frames.\\n\", frames);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_debug_jitter_buffer(switch_rtp_t *rtp_session, const char *name)\n{\n\tint x = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (name) x = atoi(name);\n\tif (x < 0) x = 0;\n\n\tif (rtp_session->jb) {\n\t\tswitch_jb_debug_level(rtp_session->jb, x);\n\t} else if (rtp_session->vb) {\n\t\tswitch_jb_debug_level(rtp_session->vb, x);\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_activate_jitter_buffer(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t queue_frames,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t max_queue_frames,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_packet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_second)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (queue_frames < 1) {\n\t\tqueue_frames = 3;\n\t}\n\n\tif (max_queue_frames < queue_frames) {\n\t\tmax_queue_frames = queue_frames * 3;\n\t}\n\n\n\n\tif (rtp_session->jb) {\n\t\tstatus = switch_jb_set_frames(rtp_session->jb, queue_frames, max_queue_frames);\n\t} else {\n\t\tREAD_INC(rtp_session);\n\t\tstatus = switch_jb_create(&rtp_session->jb, SJB_AUDIO, queue_frames, max_queue_frames, rtp_session->pool);\n\t\tswitch_jb_set_session(rtp_session->jb, rtp_session->session);\n\t\tswitch_jb_set_jitter_estimator(rtp_session->jb, &rtp_session->stats.rtcp.inter_jitter, samples_per_packet, samples_per_second);\n\t\tif (switch_true(switch_channel_get_variable_dup(switch_core_session_get_channel(rtp_session->session), \"jb_use_timestamps\", SWITCH_FALSE, -1))) {\n\t\t\tswitch_jb_ts_mode(rtp_session->jb, samples_per_packet, samples_per_second);\n\t\t}\n\t\t//switch_jb_debug_level(rtp_session->jb, 10);\n\t\tREAD_DEC(rtp_session);\n\t}\n\n\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_activate_rtcp(switch_rtp_t *rtp_session, int send_rate, switch_port_t remote_port, switch_bool_t mux)\n{\n\tconst char *err = NULL;\n\n\tif (!rtp_session->ms_per_packet) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] = 1;\n\n\tif (!(rtp_session->remote_rtcp_port = remote_port)) {\n\t\trtp_session->remote_rtcp_port = rtp_session->remote_port + 1;\n\t}\n\n\tif (mux) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]++;\n\t}\n\n\n\tif (send_rate == -1) {\n\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] = 1;\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"RTCP passthru enabled. Remote Port: %d\\n\", rtp_session->remote_rtcp_port);\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"RTCP send rate is: %d and packet rate is: %d Remote Port: %d\\n\", \t\t\t\t\t\t  send_rate, rtp_session->ms_per_packet, rtp_session->remote_rtcp_port);\n\n\t\trtp_session->rtcp_interval = send_rate;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_remote_addr, rtp_session->eff_remote_host_str, SWITCH_UNSPEC,\n\t\t\t\t\t\t\t\t\t rtp_session->remote_rtcp_port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !rtp_session->rtcp_remote_addr) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"RTCP MUX Remote Address Error!\");\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\trtp_session->rtcp_local_addr = rtp_session->local_addr;\n\t\trtp_session->rtcp_from_addr = rtp_session->from_addr;\n\t\trtp_session->rtcp_sock_input = rtp_session->sock_input;\n\t\trtp_session->rtcp_sock_output = rtp_session->sock_output;\n\n\t\trtp_session->rtcp_recv_msg_p = (rtcp_msg_t *) &rtp_session->recv_msg;\n\n\t\treturn SWITCH_STATUS_SUCCESS;\n\n\t\t//return enable_remote_rtcp_socket(rtp_session, &err);\n\t} else {\n\t\trtp_session->rtcp_recv_msg_p = (rtcp_msg_t *) &rtp_session->rtcp_recv_msg;\n\t}\n\n\treturn enable_local_rtcp_socket(rtp_session, &err) || enable_remote_rtcp_socket(rtp_session, &err);\n\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_activate_ice(switch_rtp_t *rtp_session, char *login, char *rlogin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *password, const char *rpassword, ice_proto_t proto,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch_core_media_ice_type_t type, ice_t *ice_params)\n{\n\tchar ice_user[STUN_USERNAME_MAX_SIZE];\n\tchar user_ice[STUN_USERNAME_MAX_SIZE];\n\tchar luser_ice[SDP_UFRAG_MAX_SIZE];\n\tswitch_rtp_ice_t *ice;\n\tchar *host = NULL;\n\tswitch_port_t port = 0;\n\tchar bufc[50];\n\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (proto == IPR_RTP) {\n\t\tice = &rtp_session->ice;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_PAUSE] = 0;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_MUTE] = 0;\n\t} else {\n\t\tice = &rtp_session->rtcp_ice;\n\t}\n\n\tice->proto = proto;\n\n\tif ((type & ICE_VANILLA)) {\n\t\tswitch_snprintf(ice_user, sizeof(ice_user), \"%s:%s\", login, rlogin);\n\t\tswitch_snprintf(user_ice, sizeof(user_ice), \"%s:%s\", rlogin, login);\n\t\tswitch_snprintf(luser_ice, sizeof(luser_ice), \"%s%s\", rlogin, login);\n\t\tice->ready = ice->rready = 0;\n\t\tice->cand_responsive = 0;\n\t} else {\n\t\tswitch_snprintf(ice_user, sizeof(ice_user), \"%s%s\", login, rlogin);\n\t\tswitch_snprintf(user_ice, sizeof(user_ice), \"%s%s\", rlogin, login);\n\t\tswitch_snprintf(luser_ice, sizeof(luser_ice), \"\");\n\t\tice->ready = ice->rready = 1;\n\t\tice->cand_responsive = 0;\n\t}\n\n\tice->ice_user = switch_core_strdup(rtp_session->pool, ice_user);\n\tice->user_ice = switch_core_strdup(rtp_session->pool, user_ice);\n\tice->luser_ice = switch_core_strdup(rtp_session->pool, luser_ice);\n\tice->type = type;\n\tice->ice_params = ice_params;\n\tice->pass = \"\";\n\tice->rpass = \"\";\n\tice->next_run = switch_micro_time_now();\n\tice->initializing = 1;\n\n\tif (password) {\n\t\tice->pass = switch_core_strdup(rtp_session->pool, password);\n\t}\n\n\tif (rpassword) {\n\t\tice->rpass = switch_core_strdup(rtp_session->pool, rpassword);\n\t}\n\n\tif ((ice->type & ICE_VANILLA) && ice->ice_params) {\n\t\thost = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr;\n\t\tport = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port;\n\n\t\tif (!host || !port || switch_sockaddr_info_get(&ice->addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !ice->addr) {\n\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error setting remote host!\\n\");\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t} else {\n\t\tif (proto == IPR_RTP) {\n\t\t\tice->addr = rtp_session->remote_addr;\n\t\t} else {\n\t\t\tice->addr = rtp_session->rtcp_remote_addr;\n\t\t}\n\n\t\thost = (char *)switch_get_addr(bufc, sizeof(bufc), ice->addr);\n\t\tport = switch_sockaddr_get_port(ice->addr);\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_NOTICE, \"Activating %s %s ICE: %s %s:%d\\n\",\n\t\t\t\t\t  proto == IPR_RTP ? \"RTP\" : \"RTCP\", rtp_type(rtp_session), ice_user, host, port);\n\n\n\trtp_session->rtp_bugs |= RTP_BUG_ACCEPT_ANY_PACKETS;\n\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 1;\n\t\tswitch_rtp_break(rtp_session);\n\t}\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_flush(switch_rtp_t *rtp_session)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn;\n\t}\n\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_req_bitrate(switch_rtp_t *rtp_session, uint32_t bps)\n{\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__) || rtp_session->tmmbr) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->tmmbr = bps;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_ack_bitrate(switch_rtp_t *rtp_session, uint32_t bps)\n{\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__) || rtp_session->tmmbn) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->tmmbn = bps;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(void) switch_rtp_video_refresh(switch_rtp_t *rtp_session)\n{\n\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__)) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (rtp_session->ice.ice_user || rtp_session->flags[SWITCH_RTP_FLAG_FIR] || rtp_session->flags[SWITCH_RTP_FLAG_OLD_FIR])) {\n\t\trtp_session->fir_count = 1;\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_video_loss(switch_rtp_t *rtp_session)\n{\n\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__)) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (rtp_session->ice.ice_user || rtp_session->flags[SWITCH_RTP_FLAG_PLI])) {\n\t\trtp_session->pli_count = 1;\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_break(switch_rtp_t *rtp_session)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\tint ret = 1;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK]) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 0;\n\t\t\tret = 0;\n\t\t} else if (rtp_session->session) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\tif (switch_channel_test_flag(channel, CF_VIDEO_BREAK)) {\n\t\t\t\tswitch_channel_clear_flag(channel, CF_VIDEO_BREAK);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) return;\n\n\t\tswitch_rtp_video_refresh(rtp_session);\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\trtp_session->flags[SWITCH_RTP_FLAG_BREAK] = 1;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK]) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\treturn;\n\t}\n\n\tif (rtp_session->sock_input) {\n\t\tping_socket(rtp_session);\n\t}\n\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n}\n\nSWITCH_DECLARE(void) switch_rtp_kill_socket(switch_rtp_t *rtp_session)\n{\n\tswitch_assert(rtp_session != NULL);\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_IO]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_IO] = 0;\n\t\tif (rtp_session->sock_input) {\n\t\t\tping_socket(rtp_session);\n\t\t\tswitch_socket_shutdown(rtp_session->sock_input, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\t\tif (rtp_session->sock_output && rtp_session->sock_output != rtp_session->sock_input) {\n\t\t\tswitch_socket_shutdown(rtp_session->sock_output, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\tif (rtp_session->sock_input && rtp_session->rtcp_sock_input && rtp_session->rtcp_sock_input != rtp_session->sock_input) {\n\t\t\t\tping_socket(rtp_session);\n\t\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_input, SWITCH_SHUTDOWN_READWRITE);\n\t\t\t}\n\t\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != rtp_session->sock_output && rtp_session->rtcp_sock_output != rtp_session->rtcp_sock_input) {\n\t\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_output, SWITCH_SHUTDOWN_READWRITE);\n\t\t\t}\n\t\t}\n\t}\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n}\n\nSWITCH_DECLARE(uint8_t) switch_rtp_ready(switch_rtp_t *rtp_session)\n{\n\tuint8_t ret;\n\n\tif (!rtp_session || !rtp_session->flag_mutex || rtp_session->flags[SWITCH_RTP_FLAG_SHUTDOWN]) {\n\t\treturn 0;\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\tret = (rtp_session->flags[SWITCH_RTP_FLAG_IO] && rtp_session->sock_input && rtp_session->sock_output && rtp_session->remote_addr\n\t\t   && rtp_session->ready == 2) ? 1 : 0;\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\treturn ret;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_sync_stats(switch_rtp_t *rtp_session)\n{\n\tif (!rtp_session) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->vad_data.session);\n\n\t\tswitch_channel_set_variable_printf(channel, \"vad_total_talk_time_ms\", \"%u\", (uint32_t)rtp_session->vad_data.total_talk_time / 1000);\n\t\tswitch_channel_set_variable_printf(channel, \"vad_total_talk_time_sec\", \"%u\", (uint32_t)rtp_session->vad_data.total_talk_time / 1000000);\n\t}\n\n\tdo_mos(rtp_session);\n\n\tif (rtp_session->stats.inbound.error_log && !rtp_session->stats.inbound.error_log->stop) {\n\t\trtp_session->stats.inbound.error_log->stop = switch_micro_time_now();\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_destroy(switch_rtp_t **rtp_session)\n{\n\tvoid *pop;\n\tswitch_socket_t *sock;\n#ifdef ENABLE_SRTP\n\tint x;\n#endif\n\n\tif (!rtp_session || !*rtp_session || !(*rtp_session)->ready) {\n\t\treturn;\n\t}\n\n\tif ((*rtp_session)->vb) {\n\t\t/* retrieve counter for ALL received NACKed packets */\n\t\tuint32_t nack_jb_ok = switch_jb_get_nack_success((*rtp_session)->vb);\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG((*rtp_session)->session), SWITCH_LOG_DEBUG, \n\t\t\t\t\"NACK: Added to JB: [%u]\\n\", nack_jb_ok);\n\t}\n\n\t(*rtp_session)->flags[SWITCH_RTP_FLAG_SHUTDOWN] = 1;\n\n\tREAD_INC((*rtp_session));\n\tWRITE_INC((*rtp_session));\n\n\t(*rtp_session)->ready = 0;\n\n\tWRITE_DEC((*rtp_session));\n\tREAD_DEC((*rtp_session));\n\n\tif ((*rtp_session)->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\tswitch_rtp_disable_vad(*rtp_session);\n\t}\n\n\tswitch_mutex_lock((*rtp_session)->flag_mutex);\n\n\tswitch_rtp_kill_socket(*rtp_session);\n\n\twhile (switch_queue_trypop((*rtp_session)->dtmf_data.dtmf_inqueue, &pop) == SWITCH_STATUS_SUCCESS) {\n\t\tswitch_safe_free(pop);\n\t}\n\n\twhile (switch_queue_trypop((*rtp_session)->dtmf_data.dtmf_queue, &pop) == SWITCH_STATUS_SUCCESS) {\n\t\tswitch_safe_free(pop);\n\t}\n\n\tif ((*rtp_session)->jb) {\n\t\tswitch_jb_destroy(&(*rtp_session)->jb);\n\t}\n\n\tif ((*rtp_session)->vb) {\n\t\tswitch_jb_destroy(&(*rtp_session)->vb);\n\t}\n\n\tif ((*rtp_session)->vbw) {\n\t\tswitch_jb_destroy(&(*rtp_session)->vbw);\n\t}\n\n\tif ((*rtp_session)->dtls && (*rtp_session)->dtls == (*rtp_session)->rtcp_dtls) {\n\t\t(*rtp_session)->rtcp_dtls = NULL;\n\t}\n\n\tif ((*rtp_session)->dtls) {\n\t\tfree_dtls(&(*rtp_session)->dtls);\n\t}\n\n\tif ((*rtp_session)->rtcp_dtls) {\n\t\tfree_dtls(&(*rtp_session)->rtcp_dtls);\n\t}\n\n\tif ((*rtp_session)->rtcp_sock_input == (*rtp_session)->sock_input) {\n\t\t(*rtp_session)->rtcp_sock_input = NULL;\n\t}\n\n\tif ((*rtp_session)->rtcp_sock_output == (*rtp_session)->sock_output) {\n\t\t(*rtp_session)->rtcp_sock_output = NULL;\n\t}\n\n\tsock = (*rtp_session)->sock_input;\n\t(*rtp_session)->sock_input = NULL;\n\tswitch_socket_close(sock);\n\n\tif ((*rtp_session)->sock_output != sock) {\n\t\tsock = (*rtp_session)->sock_output;\n\t\t(*rtp_session)->sock_output = NULL;\n\t\tswitch_socket_close(sock);\n\t}\n\n\tif ((sock = (*rtp_session)->rtcp_sock_input)) {\n\t\t(*rtp_session)->rtcp_sock_input = NULL;\n\t\tswitch_socket_close(sock);\n\t}\n\n\tif ((*rtp_session)->rtcp_sock_output && (*rtp_session)->rtcp_sock_output != sock) {\n\t\tsock = (*rtp_session)->rtcp_sock_output;\n\t\t(*rtp_session)->rtcp_sock_output = NULL;\n\t\tswitch_socket_close(sock);\n\t}\n\n#ifdef ENABLE_SRTP\n\tif ((*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\tfor(x = 0; x < 2; x++) {\n\t\t\tif ((*rtp_session)->send_ctx[x]) {\n\t\t\t\tsrtp_dealloc((*rtp_session)->send_ctx[x]);\n\t\t\t\t(*rtp_session)->send_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t\t(*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\t}\n\n\tif ((*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {\n\t\tfor (x = 0; x < 2; x++) {\n\t\t\tif ((*rtp_session)->recv_ctx[x]) {\n\t\t\t\tsrtp_dealloc((*rtp_session)->recv_ctx[x]);\n\t\t\t\t(*rtp_session)->recv_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t\t(*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\t}\n#endif\n\n\tif ((*rtp_session)->timer.timer_interface) {\n\t\tswitch_core_timer_destroy(&(*rtp_session)->timer);\n\t}\n\n\tif ((*rtp_session)->write_timer.timer_interface) {\n\t\tswitch_core_timer_destroy(&(*rtp_session)->write_timer);\n\t}\n\n\tswitch_rtp_release_port((*rtp_session)->rx_host, (*rtp_session)->rx_port);\n\tswitch_mutex_unlock((*rtp_session)->flag_mutex);\n\n\treturn;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_interdigit_delay(switch_rtp_t *rtp_session, uint32_t delay)\n{\n\trtp_session->interdigit_delay = delay;\n}\n\nSWITCH_DECLARE(switch_socket_t *) switch_rtp_get_rtp_socket(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->sock_input;\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_get_default_samples_per_interval(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->samples_per_interval;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_default_payload(switch_rtp_t *rtp_session, switch_payload_t payload)\n{\n\trtp_session->payload = payload;\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_get_default_payload(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->payload;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_invalid_handler(switch_rtp_t *rtp_session, switch_rtp_invalid_handler_t on_invalid)\n{\n\trtp_session->invalid_handler = on_invalid;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_flags(switch_rtp_t *rtp_session, switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID])\n{\n\tint i;\n\n\tfor(i = 0; i < SWITCH_RTP_FLAG_INVALID; i++) {\n\t\tif (flags[i]) {\n\t\t\tswitch_rtp_set_flag(rtp_session, i);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_clear_flags(switch_rtp_t *rtp_session, switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID])\n{\n\tint i;\n\n\tfor(i = 0; i < SWITCH_RTP_FLAG_INVALID; i++) {\n\t\tif (flags[i]) {\n\t\t\tswitch_rtp_clear_flag(rtp_session, i);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_flag(switch_rtp_t *rtp_session, switch_rtp_flag_t flag)\n{\n\tint old_flag = rtp_session->flags[flag];\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\trtp_session->flags[flag] = 1;\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\tif (flag == SWITCH_RTP_FLAG_PASSTHRU) {\n\t\tif (!old_flag) {\n\t\t\tswitch_rtp_pause_jitter_buffer(rtp_session, SWITCH_TRUE);\n\t\t}\n\t} else if (flag == SWITCH_RTP_FLAG_DTMF_ON) {\n\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\t} else if (flag == SWITCH_RTP_FLAG_FLUSH) {\n\t\treset_jitter_seq(rtp_session);\n\t} else if (flag == SWITCH_RTP_FLAG_AUTOADJ) {\n\t\trtp_session->autoadj_window = 20;\n\t\trtp_session->autoadj_threshold = 10;\n\t\trtp_session->autoadj_tally = 0;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RTCP_AUTOADJ] = 1;\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\t\trtp_session->rtcp_autoadj_window = 20;\n\t\trtp_session->rtcp_autoadj_threshold = 1;\n\t\trtp_session->rtcp_autoadj_tally = 0;\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\tconst char *x = switch_channel_get_variable(channel, \"rtp_auto_adjust_threshold\");\n\t\t\tif (x && *x) {\n\t\t\t\tint xn = atoi(x);\n\t\t\t\tif (xn > 0 && xn <= 65535) {\n\t\t\t\t\trtp_session->autoadj_window = xn*2;\n\t\t\t\t\trtp_session->autoadj_threshold = xn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\trtp_flush_read_buffer(rtp_session, SWITCH_RTP_FLUSH_ONCE);\n\n\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\t} else if (flag == SWITCH_RTP_FLAG_NOBLOCK && rtp_session->sock_input) {\n\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);\n\t}\n\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_test_flag(switch_rtp_t *rtp_session, switch_rtp_flag_t flags)\n{\n\treturn (uint32_t) rtp_session->flags[flags];\n}\n\nSWITCH_DECLARE(void) switch_rtp_clear_flag(switch_rtp_t *rtp_session, switch_rtp_flag_t flag)\n{\n\tint old_flag = rtp_session->flags[flag];\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\trtp_session->flags[flag] = 0;\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\tif (flag == SWITCH_RTP_FLAG_PASSTHRU) {\n\t\tif (old_flag) {\n\t\t\tswitch_rtp_pause_jitter_buffer(rtp_session, SWITCH_FALSE);\n\t\t}\n\t} else if (flag == SWITCH_RTP_FLAG_DTMF_ON) {\n\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\t} else if (flag == SWITCH_RTP_FLAG_PAUSE) {\n\t\treset_jitter_seq(rtp_session);\n\t} else if (flag == SWITCH_RTP_FLAG_NOBLOCK && rtp_session->sock_input) {\n\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, FALSE);\n\t}\n}\n\nstatic void set_dtmf_delay(switch_rtp_t *rtp_session, uint32_t ms, uint32_t max_ms)\n{\n\tint upsamp, max_upsamp;\n\n\n\tif (!max_ms) max_ms = ms;\n\n\tupsamp = ms * (rtp_session->samples_per_second / 1000);\n\tmax_upsamp = max_ms * (rtp_session->samples_per_second / 1000);\n\t\n\trtp_session->sending_dtmf = 0;\n\trtp_session->queue_delay = upsamp;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\trtp_session->max_next_write_samplecount = rtp_session->timer.samplecount + max_upsamp;\n\t\trtp_session->next_write_samplecount = rtp_session->timer.samplecount + upsamp;\n\t\trtp_session->last_write_ts += upsamp;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Queue digit delay of %dms\\n\", ms);\n}\n\nstatic void do_2833(switch_rtp_t *rtp_session)\n{\n\tswitch_frame_flag_t flags = 0;\n\tuint32_t samples = rtp_session->samples_per_interval;\n\n\tif (rtp_session->dtmf_data.out_digit_dur > 0) {\n\t\tint x, loops = 1;\n\n\t\tif (!rtp_session->last_write_ts) {\n\t\t\tif (rtp_session->timer.timer_interface) {\n\t\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\t\trtp_session->last_write_ts = rtp_session->write_timer.samplecount;\n\t\t\t} else {\n\t\t\t\trtp_session->last_write_ts = rtp_session->samples_per_interval;\n\t\t\t}\n\t\t}\n\n\t\trtp_session->dtmf_data.out_digit_sofar += samples;\n\t\trtp_session->dtmf_data.out_digit_sub_sofar += samples;\n\n\t\tif (rtp_session->dtmf_data.out_digit_sub_sofar > 0xFFFF) {\n\t\t\trtp_session->dtmf_data.out_digit_sub_sofar = samples;\n\t\t\trtp_session->dtmf_data.timestamp_dtmf += 0xFFFF;\n\t\t}\n\n\t\tif (rtp_session->dtmf_data.out_digit_sofar >= rtp_session->dtmf_data.out_digit_dur) {\n\t\t\trtp_session->dtmf_data.out_digit_packet[1] |= 0x80;\n\t\t\tloops = 3;\n\t\t}\n\n\t\trtp_session->dtmf_data.out_digit_packet[2] = (unsigned char) (rtp_session->dtmf_data.out_digit_sub_sofar >> 8);\n\t\trtp_session->dtmf_data.out_digit_packet[3] = (unsigned char) rtp_session->dtmf_data.out_digit_sub_sofar;\n\n\t\tfor (x = 0; x < loops; x++) {\n\t\t\tswitch_size_t wrote = switch_rtp_write_manual(rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_packet, 4, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  rtp_session->te, rtp_session->dtmf_data.timestamp_dtmf, &flags);\n\n\t\t\trtp_session->stats.outbound.raw_bytes += wrote;\n\t\t\trtp_session->stats.outbound.dtmf_packet_count++;\n\n\t\t\tif (loops == 1) {\n\t\t\t\trtp_session->last_write_ts += samples;\n\n\t\t\t\tif (rtp_session->rtp_bugs & RTP_BUG_SONUS_SEND_INVALID_TIMESTAMP_2833) {\n\t\t\t\t\trtp_session->dtmf_data.timestamp_dtmf = rtp_session->last_write_ts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Send %s packet for [%c] ts=%u dur=%d/%d/%d seq=%d lw=%u\\n\",\n\t\t\t\t\t\t\t  loops == 1 ? \"middle\" : \"end\", rtp_session->dtmf_data.out_digit,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.timestamp_dtmf,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sofar,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sub_sofar, rtp_session->dtmf_data.out_digit_dur, rtp_session->seq, rtp_session->last_write_ts);\n\t\t}\n\n\t\tif (loops != 1) {\n\t\t\trtp_session->sending_dtmf = 0;\n\t\t\trtp_session->need_mark = 1;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\t\trtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;\n\t\t\t}\n\n\t\t\trtp_session->dtmf_data.out_digit_dur = 0;\n\n\t\t\tif (rtp_session->interdigit_delay) {\n\t\t\t\tset_dtmf_delay(rtp_session, rtp_session->interdigit_delay, rtp_session->interdigit_delay * 10);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!rtp_session->dtmf_data.out_digit_dur && rtp_session->dtmf_data.dtmf_queue && switch_queue_size(rtp_session->dtmf_data.dtmf_queue)) {\n\t\tvoid *pop;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\tif (rtp_session->timer.samplecount < rtp_session->next_write_samplecount) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (rtp_session->timer.samplecount >= rtp_session->max_next_write_samplecount) {\n\t\t\t\trtp_session->queue_delay = 0;\n\t\t\t}\n\n\t\t} else if (rtp_session->queue_delay) {\n\t\t\tif (rtp_session->delay_samples >= rtp_session->samples_per_interval) {\n\t\t\t\trtp_session->delay_samples -= rtp_session->samples_per_interval;\n\t\t\t} else {\n\t\t\t\trtp_session->delay_samples = 0;\n\t\t\t}\n\n\t\t\tif (!rtp_session->delay_samples) {\n\t\t\t\trtp_session->queue_delay = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->queue_delay) {\n\t\t\treturn;\n\t\t}\n\n\n\t\tif (!rtp_session->sending_dtmf) {\n\t\t\trtp_session->sending_dtmf = 1;\n\t\t}\n\n\t\tif (switch_queue_trypop(rtp_session->dtmf_data.dtmf_queue, &pop) == SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_dtmf_t *rdigit = pop;\n\t\t\tswitch_size_t wrote;\n\n\t\t\tif (rdigit->digit == 'w') {\n\t\t\t\tset_dtmf_delay(rtp_session, 500, 0);\n\t\t\t\tfree(rdigit);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (rdigit->digit == 'W') {\n\t\t\t\tset_dtmf_delay(rtp_session, 1000, 0);\n\t\t\t\tfree(rdigit);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmemset(rtp_session->dtmf_data.out_digit_packet, 0, 4);\n\t\t\trtp_session->dtmf_data.out_digit_sofar = samples;\n\t\t\trtp_session->dtmf_data.out_digit_sub_sofar = samples;\n\t\t\trtp_session->dtmf_data.out_digit_dur = rdigit->duration;\n\t\t\trtp_session->dtmf_data.out_digit = rdigit->digit;\n\t\t\trtp_session->dtmf_data.out_digit_packet[0] = (unsigned char) switch_char_to_rfc2833(rdigit->digit);\n\t\t\trtp_session->dtmf_data.out_digit_packet[1] = 13;\n\t\t\trtp_session->dtmf_data.out_digit_packet[2] = (unsigned char) (rtp_session->dtmf_data.out_digit_sub_sofar >> 8);\n\t\t\trtp_session->dtmf_data.out_digit_packet[3] = (unsigned char) rtp_session->dtmf_data.out_digit_sub_sofar;\n\n\n\t\t\trtp_session->dtmf_data.timestamp_dtmf = rtp_session->last_write_ts + samples;\n\t\t\trtp_session->last_write_ts = rtp_session->dtmf_data.timestamp_dtmf;\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 0;\n\n\t\t\twrote = switch_rtp_write_manual(rtp_session,\n\t\t\t\t\t\t\t\t\t\t\trtp_session->dtmf_data.out_digit_packet,\n\t\t\t\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t\t\t\trtp_session->rtp_bugs & RTP_BUG_CISCO_SKIP_MARK_BIT_2833 ? 0 : 1,\n\t\t\t\t\t\t\t\t\t\t\trtp_session->te, rtp_session->dtmf_data.timestamp_dtmf, &flags);\n\n\n\t\t\trtp_session->stats.outbound.raw_bytes += wrote;\n\t\t\trtp_session->stats.outbound.dtmf_packet_count++;\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Send start packet for [%c] ts=%u dur=%d/%d/%d seq=%d lw=%u\\n\",\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.timestamp_dtmf,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sofar,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sub_sofar, rtp_session->dtmf_data.out_digit_dur, rtp_session->seq, rtp_session->last_write_ts);\n\n\t\t\tfree(rdigit);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) rtp_flush_read_buffer(switch_rtp_t *rtp_session, switch_rtp_flush_t flush)\n{\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] ||\n\t\trtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\treturn;\n\t}\n\n\n\tif (switch_rtp_ready(rtp_session)) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_FLUSH] = 1;\n\t\treset_jitter_seq(rtp_session);\n\n\t\tswitch (flush) {\n\t\tcase SWITCH_RTP_FLUSH_STICK:\n\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_STICKY_FLUSH);\n\t\t\tbreak;\n\t\tcase SWITCH_RTP_FLUSH_UNSTICK:\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_STICKY_FLUSH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int jb_valid(switch_rtp_t *rtp_session)\n{\n\tif (rtp_session->ice.ice_user) {\n\t\tif (!rtp_session->ice.ready && rtp_session->ice.rready) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (rtp_session->dtls && rtp_session->dtls->state != DS_READY) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic switch_size_t do_flush(switch_rtp_t *rtp_session, int force, switch_size_t bytes_in)\n{\n\tint was_blocking = 0;\n\tswitch_size_t bytes;\n\tswitch_size_t bytes_out = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn 0;\n\t}\n\n\treset_jitter_seq(rtp_session);\n\n\tif (!force) {\n\t\tif ((rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) ||\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] ||\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_UDPTL] ||\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]\n\t\t\t) {\n\t\t\treturn bytes_in;\n\t\t}\n\t}\n\n\tREAD_INC(rtp_session);\n\n\tif (switch_rtp_ready(rtp_session) ) {\n\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\t//switch_jb_reset(rtp_session->jb);\n\t\t\tbytes_out = bytes_in;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (rtp_session->vbw) {\n\t\t\tswitch_jb_reset(rtp_session->vbw);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\t//switch_jb_reset(rtp_session->vb);\n\t\t\tbytes_out = bytes_in;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),\n\t\t\t\t\t\t\t  SWITCH_LOG_CONSOLE, \"%s FLUSH\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\"\n\t\t\t\t\t\t\t  );\n\t\t}\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK]) {\n\t\t\twas_blocking = 1;\n\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);\n\t\t}\n\n\t\t// before processing/flushing packets, if current packet is rfc2833, handle it (else it would be lost)\n\t\tif (bytes_in > rtp_header_len && rtp_session->last_rtp_hdr.version == 2 && rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\t    int do_cng = 0;\n#ifdef DEBUG_2833\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"*** Handling current RTP packet before flushing. seq=%u ***\\n\", ntohs(rtp_session->last_rtp_hdr.seq));\n#endif\n\t\t    handle_rfc2833(rtp_session, bytes_in, &do_cng);\n\t\t}\n\n\t\tdo {\n\t\t\tif (switch_rtp_ready(rtp_session)) {\n\t\t\t\tbytes = sizeof(rtp_msg_t);\n\t\t\t\tswitch_socket_recvfrom(rtp_session->from_addr, rtp_session->sock_input, 0, (void *) &rtp_session->recv_msg, &bytes);\n\n\t\t\t\tif (bytes) {\n\t\t\t\t\tint do_cng = 0;\n\n\t\t\t\t\tif (rtp_session->media_timeout) {\n\t\t\t\t\t\trtp_session->last_media = switch_micro_time_now();\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Make sure to handle RFC2833 packets, even if we're flushing the packets */\n\t\t\t\t\tif (bytes > rtp_header_len && rtp_session->recv_msg.header.version == 2 && rtp_session->recv_msg.header.pt == rtp_session->recv_te) {\n\t\t\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\t\t\thandle_rfc2833(rtp_session, bytes, &do_cng);\n#ifdef DEBUG_2833\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"*** RTP packet handled in flush loop %d ***\\n\", do_cng);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\t\trtp_session->stats.inbound.raw_bytes += bytes;\n\t\t\t\t\trtp_session->stats.inbound.flush_packet_count++;\n\t\t\t\t\trtp_session->stats.inbound.packet_count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (bytes > 0);\n\n#ifdef DEBUG_2833\n        if (flushed) {\n            switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"*** do_flush: total flushed packets: %ld ***\\n\",(long)flushed);\n        }\n#endif\n\n\n\t\tif (was_blocking && switch_rtp_ready(rtp_session)) {\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, FALSE);\n\t\t}\n\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->session) {\n\t\t\t//int type = 1; // sum flags: 1 encoder; 2; decoder\n\t\t\t//switch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO, SWITCH_IO_READ, SCC_VIDEO_RESET, SCCT_INT, (void *)&type, NULL, NULL);\n\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t}\n\t}\n\n end:\n\n\tREAD_DEC(rtp_session);\n\n\treturn bytes_out;\n}\n\nstatic int check_recv_payload(switch_rtp_t *rtp_session)\n{\n\tint ok = 1;\n\n\tif (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PAYLOAD) && rtp_session->pmaps && *rtp_session->pmaps) {\n\t\tpayload_map_t *pmap;\n\t\tok = 0;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\n\t\tfor (pmap = *rtp_session->pmaps; pmap && pmap->allocated; pmap = pmap->next) {\n\t\t\tif (!pmap->negotiated) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rtp_session->last_rtp_hdr.pt == pmap->pt) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t}\n\n\treturn ok;\n}\n\nstatic int get_recv_payload(switch_rtp_t *rtp_session)\n{\n\tint r = -1;\n\n\tif (rtp_session->pmaps && *rtp_session->pmaps) {\n\t\tpayload_map_t *pmap;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\n\t\tfor (pmap = *rtp_session->pmaps; pmap && pmap->allocated; pmap = pmap->next) {\n\t\t\tif (pmap->negotiated) {\n\t\t\t\tr = pmap->pt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t}\n\n\treturn r;\n}\n\n#define return_cng_frame() do_cng = 1; goto timer_check\n\nstatic switch_status_t read_rtp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes, switch_frame_flag_t *flags,\n\t\t\t\t\t\t\t\t\t   payload_map_t **pmapP, switch_status_t poll_status, switch_bool_t return_jb_packet)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\tuint32_t ts = 0;\n\tunsigned char *b = NULL;\n\tint sync = 0;\n\tswitch_time_t now;\n\tswitch_size_t xcheck_jitter = 0;\n\tint tries = 0;\n\tint block = 0;\n\n\tswitch_assert(bytes);\n more:\n\n\ttries++;\n\n\tif (tries > 20) {\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\t\trtp_session->punts++;\n\t\trtp_session->clean = 0;\n\t\t*bytes = 0;\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tif (block) {\n\t\tint to = 20000;\n\t\tint fdr = 0;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tto = 100000;\n\t\t} else {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->timer.interval) {\n\t\t\t\tto = rtp_session->timer.interval * 1000;\n\t\t\t}\n\t\t}\n\n\t\tpoll_status = switch_poll(rtp_session->read_pollfd, 1, &fdr, to);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->timer.interval) {\n\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t}\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_ivr_parse_all_messages(rtp_session->session);\n\t\t}\n\n\t\tblock = 0;\n\t}\n\n\t*bytes = sizeof(rtp_msg_t);\n\tsync = 0;\n\n\trtp_session->has_rtp = 0;\n\trtp_session->has_ice = 0;\n\trtp_session->has_rtcp = 0;\n\tif (rtp_session->dtls) {\n\t\trtp_session->dtls->bytes = 0;\n\t\trtp_session->dtls->data = NULL;\n\t}\n\tmemset(&rtp_session->last_rtp_hdr, 0, sizeof(rtp_session->last_rtp_hdr));\n\n\tif (poll_status == SWITCH_STATUS_SUCCESS) {\n\t\tstatus = switch_socket_recvfrom(rtp_session->from_addr, rtp_session->sock_input, 0, (void *) &rtp_session->recv_msg, bytes);\n\t} else {\n\t\t*bytes = 0;\n\t}\n\n\tif (*bytes) {\n\t\tb = (unsigned char *) &rtp_session->recv_msg;\n\n\t\t/* version 2 probably rtp */\n\t\trtp_session->has_rtp = (rtp_session->recv_msg.header.version == 2);\n\n\t\tif (rtp_session->media_timeout || rtp_session->ice.ice_user) {\n\t\t\trtp_session->last_media = switch_micro_time_now();\n\t\t}\n\n\t\tif ((*b >= 20) && (*b <= 64)) {\n\t\t\tif (rtp_session->dtls) {\n\t\t\t\trtp_session->dtls->bytes = *bytes;\n\t\t\t\trtp_session->dtls->data = (void *) &rtp_session->recv_msg;\n\t\t\t}\n\t\t\trtp_session->has_ice = 0;\n\t\t\trtp_session->has_rtp = 0;\n\t\t\trtp_session->has_rtcp = 0;\n\t\t} else if (*b == 0 || *b == 1) {\n\t\t\trtp_session->has_ice = 1;\n\t\t\trtp_session->has_rtp = 0;\n\t\t\trtp_session->has_rtcp = 0;\n\t\t} else {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\tswitch(rtp_session->recv_msg.header.pt) {\n\t\t\t\tcase 64:        //  192 Full INTRA-frame request.\n\t\t\t\tcase 72:        //  200 Sender report.\n\t\t\t\tcase 73:        //  201 Receiver report.\n\t\t\t\tcase 74:        //  202 Source description.\n\t\t\t\tcase 75:        //  203 Goodbye.\n\t\t\t\tcase 76:        //  204 Application-defined.\n\t\t\t\tcase 77:        //  205 Transport layer FB message.\n\t\t\t\tcase 78:        //  206 Payload-specific FB message.\n\t\t\t\tcase 79:        //  207 Extended report.\n\t\t\t\t\trtp_session->has_rtcp = 1;\n\t\t\t\t\trtp_session->has_rtp = 0;\n\t\t\t\t\trtp_session->has_ice = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (rtp_session->rtcp_recv_msg_p->header.version == 2 &&\n\t\t\t\t\t\trtp_session->rtcp_recv_msg_p->header.type > 199 && rtp_session->rtcp_recv_msg_p->header.type < 208) {\n\t\t\t\t\t\trtp_session->has_rtcp = 1;\n\t\t\t\t\t\trtp_session->has_rtp = 0;\n\t\t\t\t\t\trtp_session->has_ice = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->has_rtp || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\t\trtp_session->missed_count = 0;\n\t\t\tswitch_cp_addr(rtp_session->rtp_from_addr, rtp_session->from_addr);\n\t\t}\n\n\t\tif (rtp_session->has_rtp) {\n\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\t\trtp_session->last_rtp_hdr.pt != 13 &&\n\t\t\t\trtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\t\t\trtp_session->last_rtp_hdr.pt != rtp_session->cng_pt) {\n\t\t\t\tint accept_packet = 1;\n\n\n\t\t\t\tif (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PAYLOAD) && \n\t\t\t\t\t!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PACKETS) && rtp_session->pmaps && *rtp_session->pmaps) {\n\t\t\t\t\tpayload_map_t *pmap;\n\t\t\t\t\taccept_packet = 0;\n\n\t\t\t\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\t\t\t\tfor (pmap = *rtp_session->pmaps; pmap && pmap->allocated; pmap = pmap->next) {\n\n\t\t\t\t\t\tif (!pmap->negotiated) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtp_session->last_rtp_hdr.pt == pmap->pt) {\n\t\t\t\t\t\t\taccept_packet = 1;\n\t\t\t\t\t\t\tif (pmapP) {\n\t\t\t\t\t\t\t\t*pmapP = pmap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\t\t\t}\n\n\t\t\t\tif (!accept_packet) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1,\n\t\t\t\t\t\t\t\t\t  \"Invalid Packet SEQ: %d TS: %d PT:%d ignored\\n\",\n\t\t\t\t\t\t\t\t\t  ntohs(rtp_session->recv_msg.header.seq), ntohl(rtp_session->last_rtp_hdr.ts), rtp_session->last_rtp_hdr.pt);\n\t\t\t\t\t*bytes = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DETECT_SSRC]) {\n\t\t\t\t//if (rtp_session->remote_ssrc != rtp_session->stats.rtcp.peer_ssrc && rtp_session->stats.rtcp.peer_ssrc) {\n\t\t\t\t//\trtp_session->remote_ssrc = rtp_session->stats.rtcp.peer_ssrc;\n\t\t\t\t//}\n\n\t\t\t\tif (rtp_session->remote_ssrc != rtp_session->last_rtp_hdr.ssrc && rtp_session->last_rtp_hdr.ssrc) {\n\t\t\t\t\trtp_session->remote_ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rtp_session->vb && (!rtp_session->jb || rtp_session->pause_jb || !jb_valid(rtp_session))) {\n\t\tif (*bytes > rtp_header_len && (rtp_session->has_rtp && check_recv_payload(rtp_session))) {\n\t\t\txcheck_jitter = *bytes;\n\t\t\tcheck_jitter(rtp_session);\n\t\t}\n\t}\n\n\tif (check_rtcp_and_ice(rtp_session) == -1) {\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF CHECK FAIL\\n\");\n\t\t//}\n\t\treturn SWITCH_STATUS_GENERR;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\tgoto udptl;\n\t}\n\n\n\tif (*bytes) {\n\t\t*flags &= ~SFF_PROXY_PACKET;\n\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t//\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF BYTES %ld b=%d\\n\", *bytes, *b);\n\t\t//}\n\n\n\t\tif (rtp_session->has_ice) {\n\t\t\tif (rtp_session->ice.ice_user) {\n\t\t\t\thandle_ice(rtp_session, &rtp_session->ice, (void *) &rtp_session->recv_msg, *bytes);\n\t\t\t}\n\t\t\t*bytes = 0;\n\t\t\tsync = 1;\n\t\t}\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (rtp_session->dtls) {\n\n\t\tif (rtp_session->rtcp_dtls && rtp_session->rtcp_dtls != rtp_session->dtls) {\n\t\t\trtp_session->rtcp_dtls->bytes = 0;\n\t\t\trtp_session->rtcp_dtls->data = NULL;\n\t\t\tdo_dtls(rtp_session, rtp_session->rtcp_dtls);\n\t\t}\n\n\t\tdo_dtls(rtp_session, rtp_session->dtls);\n\n\t\tif (rtp_session->dtls && rtp_session->dtls->bytes) {\n\t\t\t*bytes = 0;\n\t\t\tsync = 1;\n\t\t}\n\t}\n\n\n\n\tif (status == SWITCH_STATUS_SUCCESS && *bytes) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t*flags &= ~SFF_RTCP;\n\t\t\tif (rtp_session->has_rtcp) {\n\t\t\t\t*flags |= SFF_RTCP;\n\n#ifdef ENABLE_SRTP\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {\n\t\t\t\t\tint sbytes = (int) *bytes;\n\t\t\t\t\tsrtp_err_status_t stat = 0;\n\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {\n\t\t\t\t\t\tstat = srtp_unprotect_rtcp(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstat = srtp_unprotect_rtcp_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stat) {\n\t\t\t\t\t\t//++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp]++;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"RTCP UNPROTECT ERR\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t*bytes = sbytes;\n\t\t\t\t}\n#endif\n\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\treturn SWITCH_STATUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\tif ((*bytes && (!rtp_write_ready(rtp_session, *bytes, __LINE__) || !rtp_session->has_rtp || rtp_session->has_rtcp)) || sync) {\n\t\trtp_session->hot_hits = 0;\n\t\tblock = 1;\n\t\t*bytes = 0;\n\t\tgoto more;\n\t}\n\n\tif (*bytes && rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]) {\n\t\tconst char *tx_host;\n\t\tconst char *old_host;\n\t\tconst char *my_host;\n\n\t\tchar bufa[50], bufb[50], bufc[50];\n\n\n\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t  \"R %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"No-Name\",\n\t\t\t\t\t\t  (long) *bytes,\n\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),\n\t\t\t\t\t\t  rtp_session->last_rtp_hdr.pt, ntohl(rtp_session->last_rtp_hdr.ts), ntohs(rtp_session->last_rtp_hdr.seq),\n\t\t\t\t\t\t  rtp_session->last_rtp_hdr.m);\n\n\t}\n\n#ifdef RTP_READ_PLOSS\n\t{\n\t\tint r = (rand() % 10000) + 1;\n\t\tif (r <= 200) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ALERT,\n\t\t\t\t\t\t\t  \"Simulate dropped packet ......... ts: %u seq: %u\\n\", ntohl(rtp_session->last_rtp_hdr.ts), ntohs(rtp_session->last_rtp_hdr.seq));\n\t\t\t*bytes = 0;\n\t\t}\n\t}\n#endif\n\n\n\n udptl:\n\n\tts = 0;\n\trtp_session->recv_msg.ebody = NULL;\n\tnow = switch_micro_time_now();\n\n\tif (*bytes) {\n\t\tuint16_t seq = ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\t\tts = ntohl(rtp_session->last_rtp_hdr.ts);\n\n#ifdef DEBUG_MISSED_SEQ\n\t\tif (rtp_session->last_seq && rtp_session->last_seq+1 != seq) {\n\t\t\t//2012-11-28 18:33:11.799070 [ERR] switch_rtp.c:2883 Missed -65536 RTP frames from sequence [65536] to [-1] (missed). Time since last read [20021]\n\t\t\tswitch_size_t flushed_packets_diff = rtp_session->stats.inbound.flush_packet_count - rtp_session->last_flush_packet_count;\n\t\t\tswitch_size_t num_missed = (switch_size_t)seq - (rtp_session->last_seq+1);\n\n\t\t\tif (num_missed == 1) { /* We missed one packet */\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Missed one RTP frame with sequence [%d]%s. Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t  rtp_session->last_seq+1, (flushed_packets_diff == 1) ? \" (flushed by FS)\" : \" (missed)\",\n\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t} else { /* We missed multiple packets */\n\t\t\t\tif (flushed_packets_diff == 0) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (missed). Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t} else if (flushed_packets_diff == num_missed) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (flushed by FS). Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t} else if (num_missed > flushed_packets_diff) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (%ld packets flushed by FS, %ld packets missed).\"\n\t\t\t\t\t\t\t\t\t  \" Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  flushed_packets_diff, num_missed-flushed_packets_diff,\n\t\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (%ld packets flushed by FS). Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  flushed_packets_diff, rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n#endif\n\t\trtp_session->last_seq = seq;\n\n\n\t\trtp_session->last_flush_packet_count = rtp_session->stats.inbound.flush_packet_count;\n\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && now - rtp_session->last_read_time > 5000000) {\n\t\t\tswitch_rtp_video_refresh(rtp_session);\n\t\t}\n\n\t\trtp_session->last_read_time = now;\n\t}\n\n\tif (*bytes && rtp_session->has_rtp && rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]){\n\t\trtcp_stats(rtp_session);\n\t}\n\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t*bytes && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\tts && !rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session) && ts == rtp_session->last_cng_ts) {\n\t\t/* we already sent this frame..... */\n\t\t*bytes = 0;\n\t\treturn SWITCH_STATUS_SUCCESS;\n\t}\n\n\tif (*bytes) {\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\n#ifdef ENABLE_SRTP\n\t\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && rtp_session->has_rtp &&\n\t\t\t\t(check_recv_payload(rtp_session) ||\n\t\t\t\t rtp_session->last_rtp_hdr.pt == rtp_session->recv_te ||\n\t\t\t\t rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt)) {\n\t\t\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && (!rtp_session->ice.ice_user || rtp_session->has_rtp)) {\n\t\t\t\tint sbytes = (int) *bytes;\n\t\t\t\tsrtp_err_status_t stat = 0;\n\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_RESET] || !rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_RECV_RESET);\n\t\t\t\t\tsrtp_dealloc(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]);\n\t\t\t\t\trtp_session->recv_ctx[rtp_session->srtp_idx_rtp] = NULL;\n\t\t\t\t\tif ((stat = srtp_create(&rtp_session->recv_ctx[rtp_session->srtp_idx_rtp],\n\t\t\t\t\t\t\t\t\t\t\t&rtp_session->recv_policy[rtp_session->srtp_idx_rtp])) || !rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {\n\n\t\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error! RE-Activating Secure RTP RECV\\n\");\n\t\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\t\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"RE-Activating Secure RTP RECV\\n\");\n\t\t\t\t\t\trtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!(*flags & SFF_PLC) && rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {\n\t\t\t\t\t\tstat = srtp_unprotect(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp], &rtp_session->recv_msg.header, &sbytes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstat = srtp_unprotect_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp], &rtp_session->recv_msg.header, &sbytes, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && stat == srtp_err_status_replay_fail) {\n\t\t\t\t\t\t/* false alarm nack */\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"REPLAY ERR, FALSE NACK\\n\");\n\t\t\t\t\t\tsbytes = 0;\n\t\t\t\t\t\t*bytes = 0;\n\t\t\t\t\t\tif (rtp_session->stats.rtcp.pkt_count) {\n\t\t\t\t\t\t\trtp_session->stats.rtcp.period_pkt_count--;\n\t\t\t\t\t\t\trtp_session->stats.rtcp.pkt_count--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\t\tgoto more;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (stat && rtp_session->recv_msg.header.pt != rtp_session->recv_te && rtp_session->recv_msg.header.pt != rtp_session->cng_pt) {\n\t\t\t\t\tint errs = ++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp];\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SRTP_HANGUP_ON_ERROR] && stat != srtp_err_status_replay_old) {\n\t\t\t\t\t\tchar *msg;\n\t\t\t\t\t\tswitch_srtp_err_to_txt(stat, &msg);\n\t\t\t\t\t\tif (errs >= MAX_SRTP_ERRS) {\n\t\t\t\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t\t\t  \"SRTP %s unprotect failed with code %d (%s) %ld bytes %d errors\\n\",\n\t\t\t\t\t\t\t\t\t\t\t  rtp_type(rtp_session), stat, msg, (long)*bytes, errs);\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t\t\t  \"Ending call due to SRTP error\\n\");\n\t\t\t\t\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_SRTP_READ_ERROR);\n\t\t\t\t\t\t} else if (errs >= WARN_SRTP_ERRS && !(errs % WARN_SRTP_ERRS)) {\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t\t\t  \"SRTP %s unprotect failed with code %d (%s) %ld bytes %d errors\\n\",\n\t\t\t\t\t\t\t\t\t\t\t  rtp_type(rtp_session), stat, msg, (long)*bytes, errs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsbytes = 0;\n\t\t\t\t} else {\n\t\t\t\t\trtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t\t\t}\n\n\t\t\t\t*bytes = sbytes;\n\t\t\t}\n\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\t\t}\n\n\n\t\tif (rtp_session->has_rtp) {\n\t\t\tif (rtp_session->recv_msg.header.cc > 0) { /* Contributing Source Identifiers (4 bytes = sizeof CSRC header)*/\n\t\t\t\trtp_session->recv_msg.ebody = RTP_BODY(rtp_session) + (rtp_session->recv_msg.header.cc * 4);\n\t\t\t}\n\n\t\t\t/* recalculate body length in case rtp extension used */\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\t\trtp_session->recv_msg.header.x) { /* header extensions */\n\t\t\t\tuint16_t length;\n\n\t\t\t\trtp_session->recv_msg.ext = (switch_rtp_hdr_ext_t *) RTP_BODY(rtp_session);\n\t\t\t\tlength = ntohs((uint16_t)rtp_session->recv_msg.ext->length);\n\n\t\t\t\tif (length < SWITCH_RTP_MAX_BUF_LEN_WORDS) {\n\t\t\t\t\trtp_session->recv_msg.ebody = (char *)rtp_session->recv_msg.ext + (length * 4) + 4;\n\t\t\t\t\tif (*bytes > (length * 4 + 4)) {\n\t\t\t\t\t\t*bytes -= (length * 4 + 4);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*bytes = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n#ifdef DEBUG_CHROME\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->has_rtp) {\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t  \"VIDEO: seq: %d ts: %u len: %ld %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x mark: %d\\n\",\n\t\t\t\t\t\t\t\t  ntohs(rtp_session->last_rtp_hdr.seq), ntohl(rtp_session->last_rtp_hdr.ts), *bytes,\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session)), *((uint8_t *)RTP_BODY(rtp_session) + 1),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 2), *((uint8_t *)RTP_BODY(rtp_session) + 3),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 4), *((uint8_t *)RTP_BODY(rtp_session) + 5),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 6), *((uint8_t *)RTP_BODY(rtp_session) + 7),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 8), *((uint8_t *)RTP_BODY(rtp_session) + 9),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 10), rtp_session->last_rtp_hdr.m);\n\n\t\t\t}\n#endif\n\n\n\n\t\t}\n\n\n\t\trtp_session->stats.inbound.raw_bytes += *bytes;\n\n\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\t\trtp_session->stats.inbound.dtmf_packet_count++;\n\t\t} else if (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {\n\t\t\trtp_session->stats.inbound.cng_packet_count++;\n\t\t} else {\n\t\t\trtp_session->stats.inbound.media_packet_count++;\n\t\t\trtp_session->stats.inbound.media_bytes += *bytes;\n\t\t}\n\n\t\trtp_session->stats.inbound.packet_count++;\n\t}\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t((rtp_session->recv_te && rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) ||\n\t\t (*bytes < rtp_header_len && *bytes > 0 && !(rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL])))) {\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tif (ts) {\n\t\trtp_session->prev_read_ts = rtp_session->last_read_ts;\n\t\trtp_session->last_read_ts = ts;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_BYTESWAP] && check_recv_payload(rtp_session)) {\n\t\tswitch_swap_linear((int16_t *)RTP_BODY(rtp_session), (int) *bytes - rtp_header_len);\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_KILL_JB]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_KILL_JB] = 0;\n\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_destroy(&rtp_session->jb);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\tswitch_jb_destroy(&rtp_session->vb);\n\t\t}\n\n\t\tif (rtp_session->vbw) {\n\t\t\tswitch_jb_destroy(&rtp_session->vbw);\n\t\t}\n\n\t}\n\n\tif (rtp_session->has_rtp && *bytes) {\n\t\tuint32_t read_ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\t\treturn SWITCH_STATUS_SUCCESS;\n\t\t}\n\n\t\tif (rtp_session->vb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tstatus = switch_jb_put_packet(rtp_session->vb, (switch_rtp_packet_t *) &rtp_session->recv_msg, *bytes);\n\n\t\t\tif (status == SWITCH_STATUS_TOO_LATE) {\n\t\t\t\tgoto more;\n\t\t\t}\n\n\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t*bytes = 0;\n\n\t\t\tif (!return_jb_packet) {\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->jb && jb_valid(rtp_session)) {\n\t\t\tif (rtp_session->last_jb_read_ssrc && rtp_session->last_jb_read_ssrc != read_ssrc) {\n\t\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t\t}\n\n\t\t\trtp_session->last_jb_read_ssrc = read_ssrc;\n\t\t}\n\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\n\t\t\tstatus = switch_jb_put_packet(rtp_session->jb, (switch_rtp_packet_t *) &rtp_session->recv_msg, *bytes);\n\t\t\tif (status == SWITCH_STATUS_TOO_LATE) {\n\t\t\t\tgoto more;\n\t\t\t}\n\n\n\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t*bytes = 0;\n\n\t\t\tif (!return_jb_packet) {\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp_session->last_rtp_hdr.m && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && !(rtp_session->rtp_bugs & RTP_BUG_IGNORE_MARK_BIT) && \n\t\t\t\trtp_session->last_read_ts - rtp_session->prev_read_ts < rtp_session->samples_per_interval * 3) {  \n\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\t\t} else if (rtp_session->last_jb_read_ssrc && rtp_session->last_jb_read_ssrc != read_ssrc) {\n\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!*bytes || rtp_session->has_rtp) {\n\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tswitch_status_t jstatus = switch_jb_get_packet(rtp_session->jb, (switch_rtp_packet_t *) &rtp_session->recv_msg, bytes);\n\n\t\t\tstatus = jstatus;\n\n\t\t\tswitch(jstatus) {\n\t\t\tcase SWITCH_STATUS_MORE_DATA:\n\t\t\t\tif (rtp_session->punts < 4) {\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tgoto more;\n\t\t\t\t}\n\t\t\t\t*bytes = 0;\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_NOTFOUND:\n\t\t\t\t{\n\t\t\t\t\tint pt = get_recv_payload(rtp_session);\n\t\t\t\t\t(*flags) |= SFF_PLC;\n\t\t\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\t\t\t*bytes = switch_jb_get_last_read_len(rtp_session->jb);\n\t\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\t\trtp_session->last_rtp_hdr.pt = pt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_BREAK:\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_SUCCESS:\n\t\t\tcase SWITCH_STATUS_TIMEOUT:\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (status == SWITCH_STATUS_TIMEOUT) {\n\t\t\t\t\t\trtp_session->skip_timer = 1;\n\t\t\t\t\t}\n\t\t\t\t\trtp_session->stats.inbound.jb_packet_count++;\n\t\t\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\t\tif (++rtp_session->clean > 200) {\n\t\t\t\t\t\trtp_session->punts = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!xcheck_jitter) {\n\t\t\t\t\t\tcheck_jitter(rtp_session);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->vb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tswitch_status_t vstatus = switch_jb_get_packet(rtp_session->vb, (switch_rtp_packet_t *) &rtp_session->recv_msg, bytes);\n\t\t\tstatus = vstatus;\n\n\t\t\tswitch(vstatus) {\n\t\t\tcase SWITCH_STATUS_RESTART:\n\t\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\t\tstatus = SWITCH_STATUS_BREAK;\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_MORE_DATA:\n\t\t\t\tstatus = SWITCH_STATUS_BREAK;\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_BREAK:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (vstatus == SWITCH_STATUS_NOTFOUND && rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\t\t\tint pt = get_recv_payload(rtp_session);\n\t\t\t\t(*flags) |= SFF_PLC;\n\t\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\t\t*bytes = switch_jb_get_last_read_len(rtp_session->vb);\n\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\tif (pt > -1) {\n\t\t\t\t\trtp_session->last_rtp_hdr.pt = pt;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vstatus == SWITCH_STATUS_SUCCESS) {\n\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\n\t\t\t\tif (!xcheck_jitter) {\n\t\t\t\t\tcheck_jitter(rtp_session);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void handle_nack(switch_rtp_t *rtp_session, uint32_t nack)\n{\n\tswitch_size_t bytes = 0;\n\trtp_msg_t send_msg[1] = {{{0}}};\n\tuint16_t seq = (uint16_t) (nack & 0xFFFF);\n\tuint16_t blp = (uint16_t) (nack >> 16);\n\tint i;\n\tconst char *tx_host = NULL;\n\tconst char *old_host = NULL;\n\tconst char *my_host = NULL;\n\tchar bufa[50], bufb[50], bufc[50];\n\n\tif (!(rtp_session->flags[SWITCH_RTP_FLAG_NACK] && rtp_session->vbw)) {\n\t\treturn;  /* not enabled */\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtcp_from_addr);\n\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Got NACK [%u][0x%x] for seq %u\\n\", \n\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), nack, nack, ntohs(seq));\n\n\tif (switch_jb_get_packet_by_seq(rtp_session->vbw, seq, (switch_rtp_packet_t *) send_msg, &bytes) == SWITCH_STATUS_SUCCESS) {\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t  \"X %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtcp_from_addr),\n\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t}\n\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG2, \"RE----SEND %u\\n\", ntohs(send_msg->header.seq));\n\t\tswitch_rtp_write_raw(rtp_session, (void *) send_msg, &bytes, SWITCH_FALSE);\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Cannot send NACK for seq %u\\n\", ntohs(seq));\n\t}\n\n\tblp = ntohs(blp);\n\tfor (i = 0; i < 16; i++) {\n\t\tif (blp & (1 << i)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Also Got NACK for seq %u\\n\", \n\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), ntohs(seq) + i + 1);\n\t\t\t/* If they are missing more than one, may as well gen a key frame for good measure */\n\t\t\t//switch_core_media_gen_key_frame(rtp_session->session);\n\t\t\tif (switch_jb_get_packet_by_seq(rtp_session->vbw, htons(ntohs(seq) + i + 1), (switch_rtp_packet_t *) &send_msg, &bytes) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t\t\t  \"X %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtcp_from_addr),\n\t\t\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t\t\t}\n\t\t\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"RE----SEND %u\\n\", ntohs(send_msg->header.seq));\n\n\t\t\t\tswitch_rtp_write_raw(rtp_session, (void *) &send_msg, &bytes, SWITCH_FALSE);\n\t\t\t} else {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Cannot send NACK for seq %u\\n\", ntohs(seq) + i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic switch_status_t process_rtcp_report(switch_rtp_t *rtp_session, rtcp_msg_t *msg, switch_size_t bytes)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\n\t\t\t\t\t  \"RTCP packet bytes %\" SWITCH_SIZE_T_FMT \" type %d pad %d\\n\",\n\t\t\t\t\t  bytes, msg->header.type, msg->header.p);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (msg->header.type == _RTCP_PT_RTPFB || msg->header.type == _RTCP_PT_PSFB || msg->header.type < 200)) {\n\t\trtcp_ext_msg_t *extp = (rtcp_ext_msg_t *) msg;\n\n\t\tif (extp->header.fmt != 15) { // <---- REMOVE WHEN BRIA STOPS SENDING UNSOLICITED REMB\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s PICKED UP %s XRTCP type: %d fmt: %d\\n\",\n\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), rtp_type(rtp_session), msg->header.type, extp->header.fmt);\n\t\t}\n\n\t\tif (msg->header.type == _RTCP_PT_FIR ||\n\t\t\t(msg->header.type == _RTCP_PT_PSFB && (extp->header.fmt == _RTCP_PSFB_FIR || extp->header.fmt == _RTCP_PSFB_PLI))) {\n#if 0\n\t\t\tif (msg->header.type == _RTCP_PT_FIR) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Ancient FIR Received. Hello from 1996!\\n\");\n\n\t\t\t\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_OLD_FIR)) {\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_OLD_FIR);\n\t\t\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t\n\t\t\tif (switch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO) == SWITCH_MEDIA_FLOW_RECVONLY) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Ignoring FIR/PLI from a sendonly stream.\\n\", \n\t\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session));\n\t\t\t} else {\n\t\t\t\tswitch_core_media_gen_key_frame(rtp_session->session);\n\t\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Got FIR/PLI\\n\", \n\t\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session));\n\t\t\t\tswitch_channel_set_flag(switch_core_session_get_channel(rtp_session->session), CF_VIDEO_REFRESH_REQ);\n\t\t\t}\n\t\t}\n\n\t\tif (msg->header.type == _RTCP_PT_RTPFB && extp->header.fmt == _RTCP_RTPFB_NACK) {\n\t\t\tuint32_t *nack = (uint32_t *) extp->body;\n\t\t\tint i;\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Got NACK count %d\\n\", \n\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), ntohs(extp->header.length) - 2);\n\n\n\t\t\tfor (i = 0; i < ntohs(extp->header.length) - 2; i++) {\n\t\t\t\thandle_nack(rtp_session, nack[i]);\n\t\t\t}\n\n\t\t\t//switch_core_media_gen_key_frame(rtp_session->session);\n\t\t}\n\t\t\n\t} else {\n\t\tstruct switch_rtcp_report_block *report;\n\n\t\tif (msg->header.type == _RTCP_PT_SR || msg->header.type == _RTCP_PT_RR) {\n\t\t\tint i;\n#ifdef DEBUG_RTCP\n\t\t\tswitch_time_t now = switch_micro_time_now();\n#endif \n\t\t\tuint32_t lsr_now;\n\t\t\tuint32_t lsr;\n\t\t\tuint32_t packet_ssrc;\n\t\t\tdouble rtt_now = 0;\n\t\t\tuint8_t rtt_valid = 0;\n\t\t\tint rtt_increase = 0, packet_loss_increase=0;\n\n\t\t\t//if (msg->header.type == _RTCP_PT_SR && rtp_session->ice.ice_user) {\n\t\t\t//\trtp_session->send_rr = 1;\n\t\t\t//}\n\n\t\t\tlsr_now = calc_local_lsr_now();\n\n\t\t\tif (msg->header.type == _RTCP_PT_SR) { /* Sender report */\n\t\t\t\tstruct switch_rtcp_sender_report* sr = (struct switch_rtcp_sender_report*)msg->body;\n\n\t\t\t\trtp_session->stats.rtcp.packet_count = ntohl(sr->sender_info.pc);\n\t\t\t\trtp_session->stats.rtcp.octet_count = ntohl(sr->sender_info.oc);\n\t\t\t\tpacket_ssrc = sr->ssrc;\n\t\t\t\t/* Extracting LSR from NTP timestamp and save it */\n\t\t\t\tlsr = (ntohl(sr->sender_info.ntp_lsw)&0xffff0000)>>16 | (ntohl(sr->sender_info.ntp_msw)&0x0000ffff)<<16; /* The middle 32 bits out of 64 in the NTP timestamp */\n\t\t\t\trtp_session->stats.rtcp.last_recv_lsr_peer = htonl(lsr);  /* Save it include it in the next SR */\n\t\t\t\trtp_session->stats.rtcp.last_recv_lsr_local = lsr_now;    /* Save it to calculate DLSR when generating next SR */\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Received a SR with %d report blocks, \" \\\n\t\t\t\t\t\t\t\t  \"length in words = %d, \" \\\n\t\t\t\t\t\t\t\t  \"SSRC = 0x%X, \" \\\n\t\t\t\t\t\t\t\t  \"NTP MSW = %u, \" \\\n\t\t\t\t\t\t\t\t  \"NTP LSW = %u, \" \\\n\t\t\t\t\t\t\t\t  \"RTP timestamp = %u, \" \\\n\t\t\t\t\t\t\t\t  \"Sender Packet Count = %u, \" \\\n\t\t\t\t\t\t\t\t  \"Sender Octet Count = %u\\n\",\n\t\t\t\t\t\t\t\t  msg->header.count,\n\t\t\t\t\t\t\t\t  ntohs((uint16_t)msg->header.length),\n\t\t\t\t\t\t\t\t  ntohl(sr->ssrc),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.ntp_msw),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.ntp_lsw),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.ts),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.pc),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.oc));\n\n\n\t\t\t\trtp_session->rtcp_frame.ssrc = ntohl(sr->ssrc);\n\t\t\t\trtp_session->rtcp_frame.packet_type = (uint16_t)rtp_session->rtcp_recv_msg_p->header.type;\n\t\t\t\trtp_session->rtcp_frame.ntp_msw = ntohl(sr->sender_info.ntp_msw);\n\t\t\t\trtp_session->rtcp_frame.ntp_lsw = ntohl(sr->sender_info.ntp_lsw);\n\t\t\t\trtp_session->rtcp_frame.timestamp = ntohl(sr->sender_info.ts);\n\t\t\t\trtp_session->rtcp_frame.packet_count =  ntohl(sr->sender_info.pc);\n\t\t\t\trtp_session->rtcp_frame.octect_count = ntohl(sr->sender_info.oc);\n\n\t\t\t\treport = &sr->report_block;\n\t\t\t} else { /* Receiver report */\n\t\t\t\tstruct switch_rtcp_receiver_report* rr = (struct switch_rtcp_receiver_report*)msg->body;\n\t\t\t\tpacket_ssrc = rr->ssrc;\n\t\t\t\t//memset(&rtp_session->rtcp_frame, 0, sizeof(rtp_session->rtcp_frame));\n\t\t\t\treport = &rr->report_block;\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Received a RR with %d report blocks, \" \\\n\t\t\t\t\t\t\t\t  \"length in words = %d, \" \\\n\t\t\t\t\t\t\t\t  \"SSRC = 0x%X, \",\n\t\t\t\t\t\t\t\t  msg->header.count,\n\t\t\t\t\t\t\t\t  ntohs((uint16_t)msg->header.length),\n\t\t\t\t\t\t\t\t  ntohl(rr->ssrc));\n\n\t\t\t}\n\t\t\t\n\n\t\t\tfor (i = 0; i < (int)msg->header.count && i < MAX_REPORT_BLOCKS ; i++) {\n\t\t\t\tuint32_t old_avg = rtp_session->rtcp_frame.reports[i].loss_avg;\n\t\t\t\tuint8_t percent_fraction = (uint8_t)((uint16_t/* prevent overflow when '* 100' */)(uint8_t)report->fraction * 100 / 255);\n\t\t\t\tif (!rtp_session->rtcp_frame.reports[i].loss_avg) {\n\t\t\t\t\trtp_session->rtcp_frame.reports[i].loss_avg = percent_fraction;\n\t\t\t\t} else {\n\t\t\t\t\trtp_session->rtcp_frame.reports[i].loss_avg = (uint32_t)(((float)rtp_session->rtcp_frame.reports[i].loss_avg * .7) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ((float)percent_fraction * .3));\n\t\t\t\t}\n\n\t\t\t\trtp_session->rtcp_frame.reports[i].ssrc = ntohl(report->ssrc);\n\t\t\t\trtp_session->rtcp_frame.reports[i].fraction = (uint8_t)report->fraction;\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\t\t\t\trtp_session->rtcp_frame.reports[i].lost = report->lost; // signed 24bit will extended signess to int32_t automatically\n#else\n\t\t\t\trtp_session->rtcp_frame.reports[i].lost = ntohl(report->lost)>>8; // signed 24bit casted to uint32_t need >>8 after ntohl()...\n\t\t\t\trtp_session->rtcp_frame.reports[i].lost = rtp_session->rtcp_frame.reports[i].lost | ((rtp_session->rtcp_frame.reports[i].lost & 0x00800000) ? 0xff000000 : 0x00000000); // ...and signess compensation\n#endif\n\t\t\t\trtp_session->rtcp_frame.reports[i].highest_sequence_number_received = ntohl(report->highest_sequence_number_received);\n\t\t\t\trtp_session->rtcp_frame.reports[i].jitter = ntohl(report->jitter);\n\t\t\t\trtp_session->rtcp_frame.reports[i].lsr = ntohl(report->lsr);\n\t\t\t\trtp_session->rtcp_frame.reports[i].dlsr = ntohl(report->dlsr);\n\t\t\t\t\n\t\t\t\tif (rtp_session->rtcp_frame.reports[i].lsr && !rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU]) {\n\n\t\t\t\t\t/* Calculating RTT = A - DLSR - LSR */\n\t\t\t\t\trtt_now = ((double)(((int64_t)lsr_now) - rtp_session->rtcp_frame.reports[i].dlsr - rtp_session->rtcp_frame.reports[i].lsr))/65536;\n\n\t\t\t\t\t/* Only account RTT if it didn't overflow. */\n\t\t\t\t\tif (lsr_now > rtp_session->rtcp_frame.reports[i].dlsr + rtp_session->rtcp_frame.reports[i].lsr) {\n#ifdef DEBUG_RTCP\n\t\t\t\t\t\tswitch_time_exp_t now_hr;\n\t\t\t\t\t\tswitch_time_exp_gmt(&now_hr,now);\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\n\t\t\t\t\t\t\t\t\"Receiving an RTCP packet\\n[%04d-%02d-%02d %02d:%02d:%02d.%d] SSRC[0x%x]\\n\"\n\t\t\t\t\t\t\t\t\"RTT[%f] = A[%u] - DLSR[%u] - LSR[%u]\\n\",\n\t\t\t\t\t\t\t\t1900 + now_hr.tm_year, now_hr.tm_mday, now_hr.tm_mon, now_hr.tm_hour, now_hr.tm_min, now_hr.tm_sec, now_hr.tm_usec,\n\t\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].ssrc, rtt_now,\n\t\t\t\t\t\t\t\tlsr_now, rtp_session->rtcp_frame.reports[i].dlsr, rtp_session->rtcp_frame.reports[i].lsr);\n#endif \n\t\t\t\t\t\trtt_valid = 1;\n\t\t\t\t\t\tif (!rtp_session->rtcp_frame.reports[i].rtt_avg) {\n\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].rtt_avg = rtt_now;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].rtt_avg = (double)((rtp_session->rtcp_frame.reports[i].rtt_avg * .7) + (rtt_now * .3 ));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n#ifdef DEBUG_RTCP\n\t\t\t\t\t\tswitch_time_exp_t now_hr;\n\t\t\t\t\t\tswitch_time_exp_gmt(&now_hr,now);\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\"Receiving RTCP packet\\n[%04d-%02d-%02d %02d:%02d:%02d.%d] SSRC[0x%x]\\n\"\n\t\t\t\t\t\t\t\t\"Ignoring erroneous RTT[%f] = A[%u] - DLSR[%u] - LSR[%u]\\n\",\n\t\t\t\t\t\t\t\t1900 + now_hr.tm_year, now_hr.tm_mday, now_hr.tm_mon, now_hr.tm_hour, now_hr.tm_min, now_hr.tm_sec, now_hr.tm_usec,\n\t\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].ssrc, rtt_now,\n\t\t\t\t\t\t\t\tlsr_now, rtp_session->rtcp_frame.reports[i].dlsr, rtp_session->rtcp_frame.reports[i].lsr);\n#endif\n\t\t\t\t\t\trtt_valid = 0;\n\t\t\t\t\t\trtt_now = 0;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"RTT average %f\\n\",\n\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].rtt_avg);\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ADJ_BITRATE_CAP] && rtp_session->flags[SWITCH_RTP_FLAG_ESTIMATORS] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\n\t\t\t\t\t/* SWITCH_RTP_FLAG_ADJ_BITRATE_CAP : Can the codec change its bitrate on the fly per API command ? */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Current packet loss: [%d %%] Current RTT: [%f ms]\\n\", percent_fraction, rtt_now);\n#endif\n\n\t\t\t\t\tif (rtt_valid) {\n\n\t\t\t\t\t\tswitch_kalman_estimate(rtp_session->estimators[EST_RTT], rtt_now, EST_RTT);\n\n\t\t\t\t\t\tif (switch_kalman_cusum_detect_change(rtp_session->detectors[EST_RTT], rtt_now, rtp_session->estimators[EST_RTT]->val_estimate_last)) {\n\t\t\t\t\t\t\t/* sudden change in the mean value of RTT */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Sudden change in the mean value of RTT !\\n\");\n#endif\n\t\t\t\t\t\t\trtt_increase = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch_kalman_estimate(rtp_session->estimators[EST_LOSS], percent_fraction, EST_LOSS);\n\n\t\t\t\t\tif (switch_kalman_cusum_detect_change(rtp_session->detectors[EST_LOSS], percent_fraction, rtp_session->estimators[EST_LOSS]->val_estimate_last)){\n\t\t\t\t\t\t/* sudden change in the mean value of packet loss */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Sudden change in the mean value of packet loss!\\n\");\n#endif\n\t\t\t\t\t\tpacket_loss_increase = 1;\n\t\t\t\t\t}\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"ESTIMATORS: Packet loss will be: [%f] RTT will be: [%f ms]\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session->estimators[EST_LOSS]->val_estimate_last, rtp_session->estimators[EST_RTT]->val_estimate_last);\n#endif\n\n\t\t\t\t\tif (rtp_session->rtcp_frame.reports[i].loss_avg != old_avg) {\n\t\t\t\t\t\t/*getting bad*/\n\t\t\t\t\t\tif (switch_kalman_is_slow_link(rtp_session->estimators[EST_LOSS],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   rtp_session->estimators[EST_RTT])) {\n\t\t\t\t\t\t\t/* going to minimum bitrate */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Slow link conditions: Loss average: [%d %%], Previous loss: [%d %%]. \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGoing to minimum bitrate!\",rtp_session->rtcp_frame.reports[i].loss_avg, old_avg);\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE, SCCT_STRING, \"minimum\", SCCT_NONE, NULL, NULL, NULL);\n\t\t\t\t\t\t\t/* if after going to minimum bitrate we still have packet loss then we increase ptime. TODO */\n\n\t\t\t\t\t\t} else if (packet_loss_increase && (rtp_session->estimators[EST_LOSS]->val_estimate_last >= 5)) {\n\t\t\t\t\t\t\t/* sudden change in the mean value of packet loss percentage */\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_STRING, \"decrease\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Sudden change in the mean value of packet loss percentage !\\n\");\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else if (rtt_valid && !rtt_increase && rtp_session->estimators[EST_LOSS]->val_estimate_last >= rtp_session->rtcp_frame.reports[i].loss_avg ) {\n\t\t\t\t\t\t\t/* lossy because of congestion (queues full somewhere -> some packets are dropped , but RTT is good ), packet loss with many small gaps */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"packet loss, but RTT is not bad\\n\");\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else if ((rtp_session->estimators[EST_LOSS]->val_estimate_last < 1) && packet_loss_increase) {\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"small packet loss average\\n\");\n#endif\n\t\t\t\t\t\t\t/*small loss_avg*/\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_STRING, \"default\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else if ((rtp_session->estimators[EST_LOSS]->val_estimate_last < 5) &&\n\t\t\t\t\t\t\t\t   (rtp_session->rtcp_frame.reports[i].rtt_avg < rtp_session->estimators[EST_RTT]->val_estimate_last))  {\n\n\t\t\t\t\t\t\t/* estimate that packet loss will decrease, we can increase the bitrate */\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_STRING, \"increase\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* *do nothing about bitrate, just pass the packet loss to the codec */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"do nothing about bitrate, just pass the packet loss to the codec\\n\");\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->rtcp_frame.reports[i].loss_avg != old_avg) {\n\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treport++;\n\t\t\t}\n\t\t\trtp_session->rtcp_frame.report_count = (uint16_t)i;\n\t\t\t\t\n\n\n\n\n\t\t\trtp_session->rtcp_fresh_frame = 1;\n\t\t\trtp_session->stats.rtcp.peer_ssrc = ntohl(packet_ssrc);\n\t\t}\n\t}\n\n\tif (msg->header.type > 194 && msg->header.type < 255) {\n\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t}\n\n\treturn status;\n}\n\n\nstatic switch_status_t process_rtcp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes)\n{\n\tswitch_size_t len;\n\tswitch_size_t remain = *bytes;\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\trtcp_msg_t *msg = rtp_session->rtcp_recv_msg_p;\n\n\tif (remain < sizeof(switch_rtcp_ext_hdr_t) || remain > sizeof(rtcp_msg_t)) {\n\t\treturn status;\n\t}\n\tif (msg->header.version != 2) {\n\t\tif (msg->header.version == 0) {\n\t\t\tif (rtp_session->ice.ice_user) {\n\t\t\t\thandle_ice(rtp_session, &rtp_session->rtcp_ice, (void *) msg, *bytes);\n\t\t\t}\n\t\t\treturn SWITCH_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),\n\t\t\t\t\t\t\t  SWITCH_LOG_WARNING, \"Received an unsupported RTCP packet version %d\\n\", msg->header.version);\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t}\n\n\tdo {\n\t\tlen = ((switch_size_t)ntohs(msg->header.length) * 4) + 4;\n\n\t\tif (msg->header.version != 2 || !(msg->header.type > 191 && msg->header.type < 210)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t  \"INVALID RTCP PACKET TYPE %d VER %d LEN %\" SWITCH_SIZE_T_FMT \"\\n\", msg->header.type,\n\t\t\t\t\t\t\t  msg->header.version, len);\n\t\t\tstatus = SWITCH_STATUS_BREAK;\n\t\t\tbreak;\n\t\t}\n\n\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT,\n\t\t//\"WTF BYTES %ld REMAIN %ld PACKET TYPE %d LEN %ld\\n\", *bytes, remain, msg->header.type, len);\n\n\t\tif (len > remain) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t  \"RTCP INVALID LENGTH %\" SWITCH_SIZE_T_FMT \"\\n\", len);\n\t\t\tlen = remain;\n\t\t}\n\n\t\tstatus = process_rtcp_report(rtp_session, msg, len);\n\n\t\tif (remain > len) {\n\t\t\tunsigned char *p = (unsigned char *) msg;\n\t\t\tp += len;\n\t\t\tmsg = (rtcp_msg_t *) p;\n\t\t}\n\n\t\tremain -= len;\n\n\t} while (remain >= 4);\n\n\treturn status;\n}\n\nstatic switch_status_t read_rtcp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes, switch_frame_flag_t *flags)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_assert(bytes);\n\n\t*bytes = sizeof(rtcp_msg_t);\n\n\tif ((status = switch_socket_recvfrom(rtp_session->rtcp_from_addr, rtp_session->rtcp_sock_input, 0, (void *) rtp_session->rtcp_recv_msg_p, bytes))\n\t\t!= SWITCH_STATUS_SUCCESS) {\n\t\t*bytes = 0;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\tif (rtp_session->rtcp_dtls) {\n\t\tchar *b = (char *) rtp_session->rtcp_recv_msg_p;\n\n\t\tif (*b == 0 || *b == 1) {\n\t\t\tif (rtp_session->rtcp_ice.ice_user) {\n\t\t\t\thandle_ice(rtp_session, &rtp_session->rtcp_ice, (void *) rtp_session->rtcp_recv_msg_p, *bytes);\n\t\t\t}\n\t\t\t*bytes = 0;\n\t\t}\n\n\t\tif (*bytes && (*b >= 20) && (*b <= 64)) {\n\t\t\trtp_session->rtcp_dtls->bytes = *bytes;\n\t\t\trtp_session->rtcp_dtls->data = (void *) rtp_session->rtcp_recv_msg_p;\n\t\t} else {\n\t\t\trtp_session->rtcp_dtls->bytes = 0;\n\t\t\trtp_session->rtcp_dtls->data = NULL;\n\t\t}\n\n\t\tdo_dtls(rtp_session, rtp_session->rtcp_dtls);\n\n\n\t\tif (rtp_session->rtcp_dtls->bytes) {\n\t\t\t*bytes = 0;\n\t\t}\n\t}\n\n#ifdef ENABLE_SRTP\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && rtp_session->rtcp_recv_msg_p->header.version == 2) {\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && (!rtp_session->ice.ice_user || rtp_session->rtcp_recv_msg_p->header.version == 2)) {\n\t\tint sbytes = (int) *bytes;\n\t\tsrtp_err_status_t stat = 0;\n\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {\n\t\t\tstat = srtp_unprotect_rtcp(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes);\n\t\t} else {\n\t\t\tstat = srtp_unprotect_rtcp_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes, 1);\n\t\t}\n\n\t\tif (stat) {\n\t\t\t//++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp]++;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"RTCP UNPROTECT ERR\\n\");\n\t\t} else {\n\t\t\t//rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t}\n\n\t\t*bytes = sbytes;\n\n\t}\n#endif\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\n\t/* RTCP Auto ADJ */\n\tif (*bytes && rtp_session->flags[SWITCH_RTP_FLAG_RTCP_AUTOADJ] &&  switch_sockaddr_get_port(rtp_session->rtcp_from_addr)) {\n\t\tif (!switch_cmp_addr(rtp_session->rtcp_from_addr, rtp_session->rtcp_remote_addr, SWITCH_FALSE)) {\n\t\t\t\tif (++rtp_session->rtcp_autoadj_tally >= rtp_session->rtcp_autoadj_threshold) {\n\t\t\t\t\tconst char *err;\n\t\t\t\t\tuint32_t old = rtp_session->remote_rtcp_port;\n\t\t\t\t\tconst char *tx_host;\n\t\t\t\t\tconst char *old_host;\n\t\t\t\t\tchar bufa[50], bufb[50];\n\n\t\t\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtcp_from_addr);\n\t\t\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->rtcp_remote_addr);\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t  \"Auto Changing %s RTCP port from %s:%u to %s:%u\\n\", rtp_type(rtp_session), old_host, old, tx_host,\n\t\t\t\t\t\t\t\t\t  switch_sockaddr_get_port(rtp_session->rtcp_from_addr));\n\n\n\t\t\t\t\trtp_session->eff_remote_host_str = switch_core_strdup(rtp_session->pool, tx_host);\n\t\t\t\t\trtp_session->remote_rtcp_port = switch_sockaddr_get_port(rtp_session->rtcp_from_addr);\n\t\t\t\t\tstatus = enable_remote_rtcp_socket(rtp_session, &err);\n\t\t\t\t\trtp_session->rtcp_auto_adj_used = 1;\n\n\t\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),\n\t\t\t\t\t\t\t\t\t  SWITCH_LOG_DEBUG, \"Correct %s RTCP ip/port confirmed.\\n\", rtp_type(rtp_session));\n\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t}\n\t\t\t\trtp_session->rtcp_auto_adj_used = 0;\n\n\t\t\t}\n\t}\n\n\tif (*bytes) {\n\t\treturn process_rtcp_packet(rtp_session, bytes);\n\t}\n\n\treturn status;\n}\n\nstatic void check_timeout(switch_rtp_t *rtp_session)\n{\n\n\tswitch_time_t now = switch_micro_time_now();\n\tuint32_t elapsed = 0;\n\n\tif (now >= rtp_session->last_media) {\n\t\telapsed = (now - rtp_session->last_media) / 1000;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10,\n\t\t\t\t\t  \"%s MEDIA TIMEOUT %s %d/%d\\n\", switch_core_session_get_name(rtp_session->session), rtp_type(rtp_session),\n\t\t\t\t\t  elapsed, rtp_session->media_timeout);\n\n\tif (elapsed > rtp_session->media_timeout) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\n\t\t\tswitch_channel_execute_on(channel, \"execute_on_media_timeout\");\n\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_MEDIA_TIMEOUT);\n\t}\n}\n\nstatic int rtp_common_read(switch_rtp_t *rtp_session, switch_payload_t *payload_type,\n\t\t\t\t\t\t   payload_map_t **pmapP, switch_frame_flag_t *flags, switch_io_flag_t io_flags)\n{\n\n\tswitch_channel_t *channel = NULL;\n\tswitch_size_t bytes = 0;\n\tswitch_size_t rtcp_bytes = 0;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS, poll_status = SWITCH_STATUS_SUCCESS;\n\tswitch_status_t rtcp_status = SWITCH_STATUS_SUCCESS, rtcp_poll_status = SWITCH_STATUS_SUCCESS;\n\tint check = 0;\n\tint ret = -1;\n\tint sleep_mss = 1000;\n\tint poll_sec = 5;\n\tint poll_loop = 0;\n\tint fdr = 0;\n\tint rtcp_fdr = 0;\n\tint hot_socket = 0;\n\tint read_loops = 0;\n\tint slept = 0;\n\tswitch_bool_t got_jb = SWITCH_FALSE;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn -1;\n\t}\n\n\tif (rtp_session->session) {\n\t\tchannel = switch_core_session_get_channel(rtp_session->session);\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\tsleep_mss = rtp_session->timer.interval * 1000;\n\t}\n\n\tREAD_INC(rtp_session);\n\n\n\n\twhile (switch_rtp_ready(rtp_session)) {\n\t\tint do_cng = 0;\n\t\tint read_pretriggered = 0;\n\t\tint has_rtcp = 0;\n\t\tint got_rtp_poll = 0;\n\n\t\tbytes = 0;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\trtp_session->read_pollfd) {\n\n\t\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\t\twhile (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tstatus = read_rtp_packet(rtp_session, &bytes, flags, pmapP, SWITCH_STATUS_SUCCESS, SWITCH_FALSE);\n\n\t\t\t\t\tif (status == SWITCH_STATUS_GENERR) {\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((*flags & SFF_RTCP)) {\n\t\t\t\t\t\t*flags &= ~SFF_RTCP;\n\t\t\t\t\t\thas_rtcp = 1;\n\t\t\t\t\t\tread_pretriggered = 0;\n\t\t\t\t\t\tgoto rtcp;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (status == SWITCH_STATUS_BREAK) {\n\t\t\t\t\t\tread_pretriggered = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if ((rtp_session->flags[SWITCH_RTP_FLAG_AUTOFLUSH] || rtp_session->flags[SWITCH_RTP_FLAG_STICKY_FLUSH])) {\n\n\t\t\t\tif (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tstatus = read_rtp_packet(rtp_session, &bytes, flags, pmapP, SWITCH_STATUS_SUCCESS, SWITCH_FALSE);\n\t\t\t\t\tif (status == SWITCH_STATUS_GENERR) {\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif ((*flags & SFF_RTCP)) {\n\t\t\t\t\t\t*flags &= ~SFF_RTCP;\n\t\t\t\t\t\thas_rtcp = 1;\n\t\t\t\t\t\tread_pretriggered = 0;\n\t\t\t\t\t\tgoto rtcp;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Initial (%i) %d\\n\", status, bytes); */\n\t\t\t\t\tif (status != SWITCH_STATUS_FALSE) {\n\t\t\t\t\t\tread_pretriggered = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytes) {\n\t\t\t\t\t\tif (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\trtp_session->hot_hits++;//+= rtp_session->samples_per_interval;\n\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"%s Hot Hit %d\\n\",\n\t\t\t\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t\t\t\t  rtp_session->hot_hits);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trtp_session->hot_hits = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->hot_hits > 1 && !rtp_session->sync_packets) {// >= (rtp_session->samples_per_second * 30)) {\n\t\t\t\t\t\thot_socket = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trtp_session->hot_hits = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\t\t\t///NOOP\n\t\t\t} else if (hot_socket && (rtp_session->hot_hits % 10) != 0) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"%s timer while HOT\\n\", rtp_session_name(rtp_session));\n\t\t\t\tswitch_core_timer_next(&rtp_session->timer);\n\t\t\t} else if (hot_socket) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"%s skip timer once\\n\", rtp_session_name(rtp_session));\n\t\t\t\trtp_session->sync_packets++;\n\t\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t} else {\n\n\t\t\t\tif (rtp_session->sync_packets) {\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10,\n\t\t\t\t\t\t\t\t\t  \"%s Auto-Flush catching up %d packets (%d)ms.\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t\t  rtp_session->sync_packets, (rtp_session->ms_per_packet * rtp_session->sync_packets) / 1000);\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PAUSE]) {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"%s syncing %d %s packet(s)\\n\",\n\t\t\t\t\t\t\t\t\t\t rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t\t\t  rtp_session->sync_packets, rtp_type(rtp_session));\n\n\t\t\t\t\t\trtp_session->bad_stream++;\n\t\t\t\t\t\trtp_session->stats.inbound.flaws += rtp_session->sync_packets;\n\n\t\t\t\t\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\t\t\t\t\trtp_session->stats.inbound.error_log->flaws += rtp_session->sync_packets;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t\t\trtp_session->hot_hits = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (slept) {\n\t\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rtp_session->skip_timer) {\n\t\t\t\t\t\t\trtp_session->skip_timer = 0;\n\t\t\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tswitch_core_timer_next(&rtp_session->timer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tslept++;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trtp_session->sync_packets = 0;\n\t\t\t}\n\t\t}\n\n\t\trtp_session->stats.read_count++;\n\n\trecvfrom:\n\n\t\tif (!read_pretriggered) {\n\t\t\tbytes = 0;\n\t\t}\n\t\tread_loops++;\n\t\t//poll_loop = 0;\n\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->read_pollfd) {\n\t\t\tint pt = poll_sec * 1000000;\n\n\t\t\tdo_2833(rtp_session);\n\n\t\t\tif (rtp_session->dtmf_data.out_digit_dur > 0 || rtp_session->dtmf_data.in_digit_sanity || rtp_session->sending_dtmf ||\n\t\t\t\tswitch_queue_size(rtp_session->dtmf_data.dtmf_queue) || switch_queue_size(rtp_session->dtmf_data.dtmf_inqueue)) {\n\t\t\t\tpt = 20000;\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && !rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA]) {\n\t\t\t\tpt = 100000;\n\t\t\t}\n\n\t\t\tif (rtp_session->vb && !rtp_session->pause_jb) {\n\t\t\t\tif (switch_jb_poll(rtp_session->vb)) {\n\t\t\t\t\tpt = 1000;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((io_flags & SWITCH_IO_FLAG_NOBLOCK)) {\n\t\t\t\tpt = 0;\n\t\t\t}\n\n\t\t\tpoll_status = switch_poll(rtp_session->read_pollfd, 1, &fdr, pt);\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && poll_status != SWITCH_STATUS_SUCCESS && rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->dtmf_data.out_digit_dur > 0) {\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_BREAK]) {\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_BREAK);\n\t\t\t\tbytes = 0;\n\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tgot_jb = (rtp_session->vb && !rtp_session->pause_jb && switch_jb_poll(rtp_session->vb));\n\t\t} else {\n\t\t\tgot_jb = SWITCH_TRUE;\n\t\t}\n\n\t\tif (poll_status == SWITCH_STATUS_SUCCESS || got_jb) {\n\n\t\t\tgot_rtp_poll = 1;\n\n\t\t\tif (read_pretriggered) {\n\t\t\t\tread_pretriggered = 0;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tstatus = read_rtp_packet(rtp_session, &bytes, flags, pmapP, poll_status, got_jb);\n\n\t\t\t\tif (status == SWITCH_STATUS_GENERR) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->max_missed_packets && read_loops == 1 && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\t\t\t\tif (bytes && status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\trtp_session->missed_count = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (++rtp_session->missed_count >= rtp_session->max_missed_packets) {\n\t\t\t\t\t\t\t\tret = -2;\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\t\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"Read bytes (%i) %ld\\n\", status, bytes);\n\n\t\t\t\t\tif (bytes == 0) {\n\t\t\t\t\t\tif (check_rtcp_and_ice(rtp_session) == -1) {\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// This is dumb\n\t\t\t\t\t\t//switch_rtp_video_refresh(rtp_session);\n\t\t\t\t\t\tgoto  rtcp;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((*flags & SFF_PROXY_PACKET)) {\n\t\t\t\t\tret = (int) bytes;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif ((*flags & SFF_RTCP)) {\n\t\t\t\t\t*flags &= ~SFF_RTCP;\n\t\t\t\t\thas_rtcp = 1;\n\t\t\t\t\tgoto rtcp;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tpoll_loop = 0;\n\t\t} else {\n\n\t\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (!SWITCH_STATUS_IS_BREAK(poll_status) && poll_status != SWITCH_STATUS_TIMEOUT) {\n\t\t\t\tchar tmp[128] = \"\";\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Poll failed with error: %d [%s]\\n\",\n\t\t\t\t\t\t\t\t  poll_status, switch_strerror_r(poll_status, tmp, sizeof(tmp)));\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\t\trtp_session->missed_count += (poll_sec * 1000) / (rtp_session->ms_per_packet ? rtp_session->ms_per_packet / 1000 : 20);\n\t\t\t\tbytes = 0;\n\n\t\t\t\tif (rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t\t} else if (rtp_session->max_missed_packets) {\n\t\t\t\t\tif (rtp_session->missed_count >= rtp_session->max_missed_packets) {\n\t\t\t\t\t\tret = -2;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (check_rtcp_and_ice(rtp_session) == -1) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\n\t\t\tif ((!(io_flags & SWITCH_IO_FLAG_NOBLOCK)) &&\n\t\t\t\t(rtp_session->dtmf_data.out_digit_dur == 0) && !rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\trtcp:\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\trtcp_poll_status = SWITCH_STATUS_FALSE;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX] && has_rtcp) {\n\t\t\t\tif (rtp_session->rtcp_recv_msg_p->header.version == 2) { //rtcp muxed\n\t\t\t\t\trtp_session->rtcp_from_addr = rtp_session->from_addr;\n\t\t\t\t\trtcp_status = rtcp_poll_status = SWITCH_STATUS_SUCCESS;\n\t\t\t\t\trtcp_bytes = bytes;\n\t\t\t\t}\n\n\t\t\t\thas_rtcp = 0;\n\n\t\t\t} else if (rtp_session->rtcp_read_pollfd) {\n\t\t\t\trtcp_poll_status = switch_poll(rtp_session->rtcp_read_pollfd, 1, &rtcp_fdr, 0);\n\t\t\t}\n\n\t\t\tif (rtcp_poll_status == SWITCH_STATUS_SUCCESS) {\n\n\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\t\trtcp_status = read_rtcp_packet(rtp_session, &rtcp_bytes, flags);\n\t\t\t\t}\n\n\t\t\t\tif (rtcp_status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_rtp_reset_media_timer(rtp_session);\n\t\t\t\t\t\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU]) {\n\t\t\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\t\t\t\tconst char *uuid = switch_channel_get_partner_uuid(channel);\n\n\t\t\t\t\t\tif (uuid) {\n\t\t\t\t\t\t\tswitch_core_session_t *other_session;\n\t\t\t\t\t\t\tswitch_rtp_t *other_rtp_session = NULL;\n\n\t\t\t\t\t\t\tif ((other_session = switch_core_session_locate(uuid))) {\n\t\t\t\t\t\t\t\tswitch_channel_t *other_channel = switch_core_session_get_channel(other_session);\n\t\t\t\t\t\t\t\tif ((other_rtp_session = switch_channel_get_private(other_channel, \"__rtcp_audio_rtp_session\")) &&\n\t\t\t\t\t\t\t\t\tother_rtp_session->rtcp_sock_output &&\n\t\t\t\t\t\t\t\t\tswitch_rtp_test_flag(other_rtp_session, SWITCH_RTP_FLAG_ENABLE_RTCP)) {\n\t\t\t\t\t\t\t\t\tother_rtp_session->rtcp_send_msg = rtp_session->rtcp_recv_msg;\n\n#ifdef ENABLE_SRTP\n\t\t\t\t\t\t\t\t\tswitch_mutex_lock(other_rtp_session->ice_mutex);\n\t\t\t\t\t\t\t\t\tif (switch_rtp_test_flag(other_rtp_session, SWITCH_RTP_FLAG_SECURE_SEND)) {\n\t\t\t\t\t\t\t\t\t\tint stat = 0;\n\t\t\t\t\t\t\t\t\t\tint sbytes = (int) rtcp_bytes;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (!other_rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\t\t\t\t\t\t\t\tstat = srtp_protect_rtcp(other_rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &other_rtp_session->rtcp_send_msg.header, &sbytes);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tstat = srtp_protect_rtcp_mki(other_rtp_session->send_ctx[other_rtp_session->srtp_idx_rtcp], &other_rtp_session->rtcp_send_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (stat) {\n\t\t\t\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error: SRTP RTCP protection failed with code %d\\n\", stat);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\trtcp_bytes = sbytes;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tswitch_mutex_unlock(other_rtp_session->ice_mutex);\n#endif\n\n\t\t\t\t\t\t\t\t\tif (switch_socket_sendto(other_rtp_session->rtcp_sock_output, other_rtp_session->rtcp_remote_addr, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (const char*)&other_rtp_session->rtcp_send_msg, &rtcp_bytes ) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\"RTCP packet not written\\n\");\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\t\t\tprocess_rtcp_packet(rtp_session, &rtcp_bytes);\n\t\t\t\t\t\tret = 1;\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((!(io_flags & SWITCH_IO_FLAG_NOBLOCK)) &&\n\t\t\t(rtp_session->dtmf_data.out_digit_dur == 0) && !got_rtp_poll) {\n\t\t\treturn_cng_frame();\n\t\t}\n\n\t\tif (!bytes && (io_flags & SWITCH_IO_FLAG_NOBLOCK)) {\n\t\t\trtp_session->missed_count = 0;\n\t\t\tret = 0;\n\t\t\tgoto end;\n\t\t}\n\n\t\tcheck = !bytes;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_FLUSH]) {\n\t\t\tbytes = do_flush(rtp_session, SWITCH_FALSE, bytes);\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\t}\n\n\t\tif ((!bytes && rtp_session->flags[SWITCH_RTP_FLAG_BREAK]) || (bytes && bytes == 4 && *((int *) &rtp_session->recv_msg) == UINT_MAX)) {\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_BREAK);\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] || !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] ||\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] ||\n\t\t\t\t(bytes && bytes < 5) || (!bytes && poll_loop)) {\n\t\t\t\tbytes = 0;\n\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && bytes < 5) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!bytes && poll_loop) {\n\t\t\tgoto recvfrom;\n\t\t}\n\n\t\tif (bytes && rtp_session->last_rtp_hdr.m && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_TEXT] &&\n\t\t\t!(rtp_session->rtp_bugs & RTP_BUG_IGNORE_MARK_BIT)) {\n\t\t\trtp_flush_read_buffer(rtp_session, SWITCH_RTP_FLUSH_ONCE);\n\t\t}\n\n\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {\n\t\t\t*flags |= SFF_NOT_AUDIO;\n\t\t} else {\n\t\t\t*flags &= ~SFF_NOT_AUDIO; /* If this flag was already set, make sure to remove it when we get real audio */\n\t\t}\n\n\t\t/* ignore packets not meant for us unless the auto-adjust window is open (ice mode has its own alternatives to this) */\n\t\tif (!using_ice(rtp_session) && bytes) {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_AUTOADJ]) {\n\t\t\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {\n\t\t\t\t\tgoto recvfrom;\n\n\t\t\t\t}\n\t\t\t} else if (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PACKETS) && !switch_cmp_addr(rtp_session->rtp_from_addr, rtp_session->remote_addr, SWITCH_FALSE)) {\n\t\t\t\tgoto recvfrom;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && rtp_session->flags[SWITCH_RTP_FLAG_AUTOADJ] && switch_sockaddr_get_port(rtp_session->rtp_from_addr)) {\n\t\t\tif (!switch_cmp_addr(rtp_session->rtp_from_addr, rtp_session->remote_addr, SWITCH_FALSE)) {\n\t\t\t\tif (++rtp_session->autoadj_tally >= rtp_session->autoadj_threshold) {\n\t\t\t\t\tconst char *err;\n\t\t\t\t\tuint32_t old = rtp_session->remote_port;\n\t\t\t\t\tconst char *tx_host;\n\t\t\t\t\tconst char *old_host;\n\t\t\t\t\tchar bufa[50], bufb[50];\n\t\t\t\t\tchar adj_port[6];\n\n\t\t\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\t\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t  \"Auto Changing %s port from %s:%u to %s:%u\\n\", rtp_type(rtp_session), old_host, old, tx_host,\n\t\t\t\t\t\t\t\t\t  switch_sockaddr_get_port(rtp_session->rtp_from_addr));\n\n\t\t\t\t\tif (channel) {\n\t\t\t\t\t\tchar varname[80] = \"\";\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_ip_reported\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, switch_channel_get_variable(channel, \"remote_media_ip\"));\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_ip\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, tx_host);\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_port_reported\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_snprintf(adj_port, sizeof(adj_port), \"%u\", switch_sockaddr_get_port(rtp_session->rtp_from_addr));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, switch_channel_get_variable(channel, \"remote_media_port\"));\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_port\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, adj_port);\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"rtp_auto_adjust_%s\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, \"true\");\n\t\t\t\t\t}\n\t\t\t\t\trtp_session->auto_adj_used = 1;\n\t\t\t\t\tswitch_rtp_set_remote_address(rtp_session, tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr), 0, SWITCH_FALSE, &err);\n\t\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t}\n\t\t\t\t\tif (rtp_session->ice.ice_user) {\n\t\t\t\t\t\trtp_session->ice.addr = rtp_session->remote_addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Correct %s ip/port confirmed.\\n\", rtp_type(rtp_session));\n\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t}\n\t\t\t\trtp_session->auto_adj_used = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && !(rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST) && rtp_session->autoadj_window) {\n\t\t\tif (--rtp_session->autoadj_window == 0) {\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\t\tif (!bytes) {\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t\t\tswitch_core_timer_next(&rtp_session->timer);\n\t\t\t\t}\n\t\t\t\treturn_cng_frame();\n\t\t\t} else {\n\t\t\t\t*payload_type = rtp_session->last_rtp_hdr.pt;\n\t\t\t\tret = (int) bytes;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL])) {\n\t\t\t/* Fast PASS! */\n\t\t\t*flags |= SFF_PROXY_PACKET;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n#if 0\n\t\t\t\tif (rtp_session->has_rtp && check_recv_payload(rtp_session)) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t  \"Ignoring udptl packet of size of %ld bytes that looks strikingly like a RTP packet.\\n\", (long)bytes);\n\t\t\t\t\tbytes = 0;\n\t\t\t\t\tgoto do_continue;\n\t\t\t\t}\n#endif\n\t\t\t\t*flags |= SFF_UDPTL_PACKET;\n\t\t\t}\n\n\t\t\tret = (int) bytes;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (bytes) {\n\t\t\trtp_session->missed_count = 0;\n\n\t\t\tif (bytes < rtp_header_len) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Ignoring invalid RTP packet size of %ld bytes.\\n\", (long)bytes);\n\t\t\t\tbytes = 0;\n\t\t\t\tgoto do_continue;\n\t\t\t}\n\n\t\t\tif (rtp_session->last_rtp_hdr.pt && (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13)) {\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\t\tif (check || bytes) {\n\t\t\tdo_2833(rtp_session);\n\t\t}\n\n\t\tif (bytes && rtp_session->recv_msg.header.version != 2) {\n\t\t\tuint8_t *data = (uint8_t *) RTP_BODY(rtp_session);\n\n\t\t\t//if (rtp_session->recv_msg.header.version == 0) {\n\t\t\t//\tif (rtp_session->ice.ice_user) {\n\t\t\t//\t\thandle_ice(rtp_session, &rtp_session->ice, (void *) &rtp_session->recv_msg, bytes);\n\t\t\t//\t\tgoto recvfrom;\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\tif (rtp_session->invalid_handler) {\n\t\t\t\trtp_session->invalid_handler(rtp_session, rtp_session->sock_input, (void *) &rtp_session->recv_msg, bytes, rtp_session->rtp_from_addr);\n\t\t\t}\n\n\t\t\tmemset(data, 0, 2);\n\t\t\tdata[0] = 65;\n\n\t\t\trtp_session->last_rtp_hdr.pt = rtp_session->cng_pt != INVALID_PT ? rtp_session->cng_pt : SWITCH_RTP_CNG_PAYLOAD;\n\t\t\t*flags |= SFF_CNG;\n\t\t\t*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;\n\t\t\tret = 2 + rtp_header_len;\n\t\t\tgoto end;\n\t\t} else if (bytes) {\n\t\t\trtp_session->stats.inbound.period_packet_count++;\n\t\t}\n\n\n\t\t/* Handle incoming RFC2833 packets */\n\t\tswitch (handle_rfc2833(rtp_session, bytes, &do_cng)) {\n\t\tcase RESULT_GOTO_END:\n\t\t\tgoto end;\n\t\tcase RESULT_GOTO_RECVFROM:\n\t\t\tgoto recvfrom;\n\t\tcase RESULT_GOTO_TIMERCHECK:\n\t\t\tgoto timer_check;\n\t\tcase RESULT_CONTINUE:\n\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\tgoto result_continue;\n\t\t}\n\n\tresult_continue:\n\ttimer_check:\n\n\t\tif (!rtp_session->media_timeout && rtp_session->flags[SWITCH_RTP_FLAG_MUTE]) {\n\t\t\tdo_cng++;\n\t\t}\n\n\t\tif (do_cng) {\n\t\t\tuint8_t *data = (uint8_t *) RTP_BODY(rtp_session);\n\n\t\t\tdo_2833(rtp_session);\n\n\t\t\tif (rtp_session->last_cng_ts == rtp_session->last_read_ts + rtp_session->samples_per_interval) {\n\t\t\t\trtp_session->last_cng_ts = 0;\n\t\t\t} else {\n\t\t\t\trtp_session->last_cng_ts = rtp_session->last_read_ts + rtp_session->samples_per_interval;\n\t\t\t}\n\n\t\t\tmemset(data, 0, 2);\n\t\t\tdata[0] = 65;\n\t\t\trtp_session->last_rtp_hdr.pt = rtp_session->cng_pt != INVALID_PT ? rtp_session->cng_pt : SWITCH_RTP_CNG_PAYLOAD;\n\t\t\t*flags |= SFF_CNG;\n\t\t\t*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;\n\t\t\tret = 2 + rtp_header_len;\n\t\t\trtp_session->stats.inbound.skip_packet_count++;\n\t\t\tgoto end;\n\t\t}\n\n\n\t\tif (check || (bytes && !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER])) {\n\t\t\tif (!bytes && rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\t/* We're late! We're Late! */\n\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] && status == SWITCH_STATUS_BREAK) {\n\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\n\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PAUSE] && !rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] && !rtp_session->dtmf_data.in_digit_ts\n\t\t\t\t\t&& rtp_session->cng_count > (rtp_session->one_second * 2) && rtp_session->jitter_lead > JITTER_LEAD_FRAMES) {\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s %s timeout\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session), rtp_type(rtp_session));\n\n\t\t\t\t\tif (rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\t\t\t\trtp_session->stats.inbound.error_log->flaws++;\n\t\t\t\t\t}\n\t\t\t\t\trtp_session->stats.inbound.flaws++;\n\t\t\t\t\tdo_mos(rtp_session);\n\t\t\t\t}\n\n\t\t\t\trtp_session->cng_count++;\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\t\trtp_session->cng_count = 0;\n\n\t\tif (status == SWITCH_STATUS_BREAK || bytes == 0) {\n\t\t\tif (!(io_flags & SWITCH_IO_FLAG_SINGLE_READ) && rtp_session->flags[SWITCH_RTP_FLAG_DATAWAIT]) {\n\t\t\t\tgoto do_continue;\n\t\t\t}\n\t\t\treturn_cng_frame();\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_GOOGLEHACK] && rtp_session->last_rtp_hdr.pt == 102) {\n\t\t\trtp_session->last_rtp_hdr.pt = 97;\n\t\t}\n\n\t\tbreak;\n\n\tdo_continue:\n\n\t\tif (!bytes && !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\n\t\t\tif (sleep_mss) {\n\t\t\t\tswitch_yield(sleep_mss);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (switch_rtp_ready(rtp_session)) {\n\t\t*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;\n\n\t\tif (*payload_type == SWITCH_RTP_CNG_PAYLOAD) {\n\t\t\t*flags |= SFF_CNG;\n\t\t}\n\n\t\tret = (int) bytes;\n\t} else {\n\t\tret = -1;\n\t}\n\n end:\n\n\tREAD_DEC(rtp_session);\n\n\treturn ret;\n}\n\n\nSWITCH_DECLARE(switch_byte_t) switch_rtp_check_auto_adj(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->auto_adj_used;\n}\n\nSWITCH_DECLARE(switch_size_t) switch_rtp_has_dtmf(switch_rtp_t *rtp_session)\n{\n\tswitch_size_t has = 0;\n\n\tif (switch_rtp_ready(rtp_session)) {\n\t\tswitch_mutex_lock(rtp_session->dtmf_data.dtmf_mutex);\n\t\thas = switch_queue_size(rtp_session->dtmf_data.dtmf_inqueue);\n\t\tswitch_mutex_unlock(rtp_session->dtmf_data.dtmf_mutex);\n\t}\n\n\treturn has;\n}\n\nSWITCH_DECLARE(switch_size_t) switch_rtp_dequeue_dtmf(switch_rtp_t *rtp_session, switch_dtmf_t *dtmf)\n{\n\tswitch_size_t bytes = 0;\n\tswitch_dtmf_t *_dtmf = NULL;\n\tvoid *pop;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn bytes;\n\t}\n\n\tswitch_mutex_lock(rtp_session->dtmf_data.dtmf_mutex);\n\tif (switch_queue_trypop(rtp_session->dtmf_data.dtmf_inqueue, &pop) == SWITCH_STATUS_SUCCESS) {\n\n\t\t_dtmf = (switch_dtmf_t *)pop;\n\t\t*dtmf = *_dtmf;\n\t\t/* Only log DTMF buffer if sensitive_dtmf channel variable not set to true */\n\t\tif (!(switch_channel_var_true(switch_core_session_get_channel(rtp_session->session), SWITCH_SENSITIVE_DTMF_VARIABLE))) {\t\t\t\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\"RTP RECV DTMF %c:%d\\n\", dtmf->digit, dtmf->duration);\n\t\t}\n\t\tbytes++;\n\t\tfree(pop);\n\t}\n\tswitch_mutex_unlock(rtp_session->dtmf_data.dtmf_mutex);\n\n\treturn bytes;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_queue_rfc2833(switch_rtp_t *rtp_session, const switch_dtmf_t *dtmf)\n{\n\n\tswitch_dtmf_t *rdigit;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif ((rdigit = malloc(sizeof(*rdigit))) != 0) {\n\t\t*rdigit = *dtmf;\n\t\tif (rdigit->duration < switch_core_min_dtmf_duration(0)) {\n\t\t\trdigit->duration = switch_core_min_dtmf_duration(0);\n\t\t}\n\n\t\tif ((switch_queue_trypush(rtp_session->dtmf_data.dtmf_queue, rdigit)) != SWITCH_STATUS_SUCCESS) {\n\t\t\tfree(rdigit);\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t} else {\n\t\tabort();\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_queue_rfc2833_in(switch_rtp_t *rtp_session, const switch_dtmf_t *dtmf)\n{\n\tswitch_dtmf_t *rdigit;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif ((rdigit = malloc(sizeof(*rdigit))) != 0) {\n\t\t*rdigit = *dtmf;\n\t\tif (rdigit->duration < switch_core_min_dtmf_duration(0)) {\n\t\t\trdigit->duration = switch_core_min_dtmf_duration(0);\n\t\t}\n\n\t\tif ((switch_queue_trypush(rtp_session->dtmf_data.dtmf_inqueue, rdigit)) != SWITCH_STATUS_SUCCESS) {\n\t\t\tfree(rdigit);\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t} else {\n\t\tabort();\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_read(switch_rtp_t *rtp_session, void *data, uint32_t *datalen,\n\t\t\t\t\t\t\t\t\t\t\t\tswitch_payload_t *payload_type, switch_frame_flag_t *flags, switch_io_flag_t io_flags)\n{\n\tint bytes = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tbytes = rtp_common_read(rtp_session, payload_type, NULL, flags, io_flags);\n\n\tif (bytes < 0) {\n\t\t*datalen = 0;\n\t\treturn bytes == -2 ? SWITCH_STATUS_TIMEOUT : SWITCH_STATUS_GENERR;\n\t} else if (bytes == 0) {\n\t\t*datalen = 0;\n\t\treturn SWITCH_STATUS_BREAK;\n\t} else {\n\t\tif (bytes > rtp_header_len) {\n\t\t\tbytes -= rtp_header_len;\n\t\t}\n\t}\n\n\t*datalen = bytes;\n\n\tmemcpy(data, RTP_BODY(rtp_session), bytes);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtcp_zerocopy_read_frame(switch_rtp_t *rtp_session, switch_rtcp_frame_t *frame)\n{\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\t/* A fresh frame has been found! */\n\tif (rtp_session->rtcp_fresh_frame) {\n\t\t/* turn the flag off! */\n\t\trtp_session->rtcp_fresh_frame = 0;\n\n\t\t*frame = rtp_session->rtcp_frame;\n\n\t\treturn SWITCH_STATUS_SUCCESS;\n\t}\n\n\treturn SWITCH_STATUS_TIMEOUT;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_zerocopy_read_frame(switch_rtp_t *rtp_session, switch_frame_t *frame, switch_io_flag_t io_flags)\n{\n\tint bytes = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tbytes = rtp_common_read(rtp_session, &frame->payload, &frame->pmap, &frame->flags, io_flags);\n\n\tframe->data = RTP_BODY(rtp_session);\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && (bytes < rtp_header_len || switch_test_flag(frame, SFF_CNG))) {\n\t\tframe->packet = NULL;\n\t\tframe->timestamp = 0;\n\t\tframe->seq = 0;\n\t\tframe->ssrc = 0;\n\t\tframe->m = 0;\n\t} else {\n\n\t\tframe->packet = &rtp_session->recv_msg;\n\t\tframe->packetlen = bytes;\n\t\tframe->source = __FILE__;\n\n\t\tswitch_set_flag(frame, SFF_RAW_RTP);\n\t\tswitch_set_flag(frame, SFF_EXTERNAL);\n\t\tif (frame->payload == rtp_session->recv_te) {\n\t\t\tswitch_set_flag(frame, SFF_RFC2833);\n\t\t}\n\t\tframe->timestamp = ntohl(rtp_session->last_rtp_hdr.ts);\n\t\tframe->seq = (uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\t\tframe->ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);\n\t\tframe->m = rtp_session->last_rtp_hdr.m ? SWITCH_TRUE : SWITCH_FALSE;\n\t}\n\n\n\tif (bytes < 0) {\n\t\tframe->datalen = 0;\n\t\treturn bytes == -2 ? SWITCH_STATUS_TIMEOUT : SWITCH_STATUS_GENERR;\n\t} else if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\tif (bytes < rtp_header_len) {\n\t\t\tframe->datalen = 0;\n\t\t\treturn SWITCH_STATUS_BREAK;\n\t\t} else {\n\t\t\tbytes -= rtp_header_len;\n\t\t}\n\t}\n\n\tframe->datalen = bytes;\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_zerocopy_read(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t void **data, uint32_t *datalen, switch_payload_t *payload_type, switch_frame_flag_t *flags,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t switch_io_flag_t io_flags)\n{\n\tint bytes = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tbytes = rtp_common_read(rtp_session, payload_type, NULL, flags, io_flags);\n\t*data = RTP_BODY(rtp_session);\n\n\tif (bytes < 0) {\n\t\t*datalen = 0;\n\t\treturn SWITCH_STATUS_GENERR;\n\t} else {\n\t\tif (bytes > rtp_header_len) {\n\t\t\tbytes -= rtp_header_len;\n\t\t}\n\t}\n\n\t*datalen = bytes;\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nstatic int rtp_write_ready(switch_rtp_t *rtp_session, uint32_t bytes, int line)\n{\n\tif (!rtp_session) return 0;\n\n\tif (rtp_session->ice.ice_user && !(rtp_session->ice.rready || rtp_session->ice.ready)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Skip sending %s packet %ld bytes (ice not ready @ line %d!)\\n\",\n\t\t\t\t\t\t  rtp_type(rtp_session), (long)bytes, line);\n\t\treturn 0;\n\t}\n\n\tif (rtp_session->dtls && rtp_session->dtls->state != DS_READY) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Skip sending %s packet %ld bytes (dtls not ready @ line %d!)\\n\",\n\t\t\t\t\t\t  rtp_type(rtp_session), (long)bytes, line);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic int rtp_common_write(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\trtp_msg_t *send_msg, void *data, uint32_t datalen, switch_payload_t payload, uint32_t timestamp, switch_frame_flag_t *flags)\n{\n\tswitch_size_t bytes;\n\tuint8_t send = 1;\n\tuint32_t this_ts = 0;\n\tint ret;\n\tswitch_time_t now;\n\tuint8_t m = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn -1;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, datalen, __LINE__)) {\n\t\treturn 0;\n\t}\n\n\tWRITE_INC(rtp_session);\n\t\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t}\n\n\tif (send_msg) {\n\t\tbytes = datalen;\n\n\t\tm = (uint8_t) send_msg->header.m;\n\t\trtp_session->ts = ntohl(send_msg->header.ts);\n\n\t\tif (flags && *flags & SFF_RFC2833) {\n\t\t\tif (rtp_session->te == INVALID_PT) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tsend_msg->header.pt = rtp_session->te;\n\t\t}\n\t\tdata = send_msg->body;\n\t\tif (datalen > rtp_header_len) {\n\t\t\tdatalen -= rtp_header_len;\n\t\t}\n\t} else {\n\t\tif (*flags & SFF_RFC2833) {\n\t\t\tif (rtp_session->te == INVALID_PT) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tpayload = rtp_session->te;\n\t\t}\n\n\t\tsend_msg = &rtp_session->send_msg;\n\t\tsend_msg->header.pt = payload;\n\n\t\tm = get_next_write_ts(rtp_session, timestamp);\n\n\t\trtp_session->send_msg.header.ts = htonl(rtp_session->ts);\n\n\t\tmemcpy(send_msg->body, data, datalen);\n\t\tbytes = datalen + rtp_header_len;\n\t}\n\n\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\t\t\n\t\tif ((rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {\n\t\t\tm = 0;\n\t\t} else {\n\t\t\tint delta = rtp_session->ts - rtp_session->last_write_ts;\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\t\t((!rtp_session->flags[SWITCH_RTP_FLAG_RESET] && (abs(delta) > rtp_session->samples_per_interval * 10))\n\t\t\t\t|| rtp_session->ts == rtp_session->samples_per_interval)) {\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&\n\t\t\t\t(rtp_session->write_timer.samplecount - rtp_session->last_write_samplecount) > rtp_session->samples_per_interval * 10) {\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&\n\t\t\t\t((unsigned) ((switch_micro_time_now() - rtp_session->last_write_timestamp))) > (rtp_session->ms_per_packet * 10)) {\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (rtp_session->cn && payload != rtp_session->cng_pt) {\n\t\t\t\trtp_session->cn = 0;\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (rtp_session->need_mark && !rtp_session->sending_dtmf) {\n\t\t\t\tm++;\n\t\t\t\trtp_session->need_mark = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (m) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t\t\trtp_session->ts = 0;\n\t\t}\n\n\t\t/* If the marker was set, and the timestamp seems to have started over - set a new SSRC, to indicate this is a new stream */\n\t\tif (m && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND) && (rtp_session->rtp_bugs & RTP_BUG_CHANGE_SSRC_ON_MARKER) &&\n\t\t\t(rtp_session->flags[SWITCH_RTP_FLAG_RESET] || (rtp_session->ts <= rtp_session->last_write_ts && rtp_session->last_write_ts > 0))) {\n\t\t\tswitch_rtp_set_ssrc(rtp_session, (uint32_t) ((intptr_t) rtp_session + (switch_time_t) switch_epoch_time_now(NULL)));\n\t\t}\n\n\t\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO) && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_UDPTL)) {\n\t\t\tsend_msg->header.m = (m && !(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) ? 1 : 0;\n\t\t}\n\t}\n\n\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\t\tint external = (flags && *flags & SFF_EXTERNAL);\n\t\t/* Normalize the timestamps to our own base by generating a made up starting point then adding the measured deltas to that base\n\t\t   so if the timestamps and ssrc of the source change, it will not break the other end's jitter bufffer / decoder etc *cough* CHROME *cough*\n\t\t */\n\n\t\tif (!rtp_session->ts_norm.ts) {\n\t\t\trtp_session->ts_norm.ts = (uint32_t) rand() % 1000000 + 1;\n\t\t}\n\n\t\tif (!rtp_session->ts_norm.last_ssrc || send_msg->header.ssrc != rtp_session->ts_norm.last_ssrc || rtp_session->ts_norm.last_external != external) {\n\t\t\tswitch_core_session_t *other_session;\n\t\t\t\n\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\tswitch_core_media_gen_key_frame(rtp_session->session);\n\n\t\t\tif (switch_core_session_get_partner(rtp_session->session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_core_session_request_video_refresh(other_session);\n\t\t\t\tswitch_core_media_gen_key_frame(other_session);\n\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t}\n\n\t\t\tif (rtp_session->ts_norm.last_ssrc) {\n\t\t\t\trtp_session->ts_norm.delta_ttl = 0;\n\t\t\t\trtp_session->ts_norm.ts++;\n\t\t\t}\n\n\t\t\trtp_session->ts_norm.last_ssrc = send_msg->header.ssrc;\n\t\t\trtp_session->ts_norm.last_frame = ntohl(send_msg->header.ts);\n\t\t}\n\n\t\trtp_session->ts_norm.last_external = external;\n\n\t\tif (ntohl(send_msg->header.ts) != rtp_session->ts_norm.last_frame) {\n\t\t\tint32_t delta = ntohl(send_msg->header.ts) - rtp_session->ts_norm.last_frame;\n\n\t\t\tif (delta < 0 || delta > 90000) {\n\t\t\t\tswitch_core_media_gen_key_frame(rtp_session->session);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \n\t\t\t\t\t\t\t\t  \"Timestamp shift detected last: %d this: %d delta: %d stick with prev delta: %d\\n\", \n\t\t\t\t\t\t\t\t  rtp_session->ts_norm.last_frame, ntohl(send_msg->header.ts), delta, rtp_session->ts_norm.delta);\n\t\t\t} else {\n\t\t\t\trtp_session->ts_norm.delta = delta;\n\t\t\t}\n\n\t\t\trtp_session->ts_norm.ts += rtp_session->ts_norm.delta;\n\n\t\t}\n\t\t\n\t\trtp_session->ts_norm.last_frame = ntohl(send_msg->header.ts);\n\t\tsend_msg->header.ts = htonl(rtp_session->ts_norm.ts);\n\t\tthis_ts = rtp_session->ts_norm.ts;\n\t}\n\n\tsend_msg->header.ssrc = htonl(rtp_session->ssrc);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_GOOGLEHACK] && rtp_session->send_msg.header.pt == 97) {\n\t\trtp_session->last_rtp_hdr.pt = 102;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VAD] &&\n\t\trtp_session->last_rtp_hdr.pt == rtp_session->vad_data.read_codec->implementation->ianacode) {\n\n\t\tint16_t decoded[SWITCH_RECOMMENDED_BUFFER_SIZE / sizeof(int16_t)] = { 0 };\n\t\tuint32_t rate = 0;\n\t\tuint32_t codec_flags = 0;\n\t\tuint32_t len = sizeof(decoded);\n\t\ttime_t now = switch_epoch_time_now(NULL);\n\t\tsend = 0;\n\n\t\tif (rtp_session->vad_data.scan_freq && rtp_session->vad_data.next_scan <= now) {\n\t\t\trtp_session->vad_data.bg_count = rtp_session->vad_data.bg_level = 0;\n\t\t\trtp_session->vad_data.next_scan = now + rtp_session->vad_data.scan_freq;\n\t\t}\n\n\t\tif (switch_core_codec_decode(&rtp_session->vad_data.vad_codec,\n\t\t\t\t\t\t\t\t\t rtp_session->vad_data.read_codec,\n\t\t\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t\t\t datalen,\n\t\t\t\t\t\t\t\t\t rtp_session->vad_data.read_codec->implementation->actual_samples_per_second,\n\t\t\t\t\t\t\t\t\t decoded, &len, &rate, &codec_flags) == SWITCH_STATUS_SUCCESS) {\n\n\t\t\tuint32_t energy = 0;\n\t\t\tuint32_t x, y = 0, z = len / sizeof(int16_t);\n\t\t\tuint32_t score = 0;\n\t\t\tint divisor = 0;\n\t\t\tif (z) {\n\n\t\t\t\tif (!(divisor = rtp_session->vad_data.read_codec->implementation->actual_samples_per_second / 8000)) {\n\t\t\t\t\tdivisor = 1;\n\t\t\t\t}\n\n\t\t\t\tfor (x = 0; x < z; x++) {\n\t\t\t\t\tenergy += abs(decoded[y]);\n\t\t\t\t\ty += rtp_session->vad_data.read_codec->implementation->number_of_channels;\n\t\t\t\t}\n\n\t\t\t\tif (++rtp_session->vad_data.start_count < rtp_session->vad_data.start) {\n\t\t\t\t\tsend = 1;\n\t\t\t\t} else {\n\t\t\t\t\tscore = (energy / (z / divisor));\n\t\t\t\t\tif (score && (rtp_session->vad_data.bg_count < rtp_session->vad_data.bg_len)) {\n\t\t\t\t\t\trtp_session->vad_data.bg_level += score;\n\t\t\t\t\t\tif (++rtp_session->vad_data.bg_count == rtp_session->vad_data.bg_len) {\n\t\t\t\t\t\t\trtp_session->vad_data.bg_level /= rtp_session->vad_data.bg_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsend = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (score > rtp_session->vad_data.bg_level && !switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\t\t\t\t\t\tuint32_t diff = score - rtp_session->vad_data.bg_level;\n\n\t\t\t\t\t\t\tif (rtp_session->vad_data.hangover_hits) {\n\t\t\t\t\t\t\t\trtp_session->vad_data.hangover_hits--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (diff >= rtp_session->vad_data.diff_level || ++rtp_session->vad_data.hangunder_hits >= rtp_session->vad_data.hangunder) {\n\n\t\t\t\t\t\t\t\tswitch_set_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING);\n\n\t\t\t\t\t\t\t\trtp_session->vad_data.start_talking = switch_micro_time_now();\n\n\t\t\t\t\t\t\t\tif (!(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {\n\t\t\t\t\t\t\t\t\tsend_msg->header.m = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trtp_session->vad_data.hangover_hits = rtp_session->vad_data.hangunder_hits = rtp_session->vad_data.cng_count = 0;\n\t\t\t\t\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_EVENTS_TALK)) {\n\n\t\t\t\t\t\t\t\t\tif ((rtp_session->vad_data.fire_events & VAD_FIRE_TALK)) {\n\t\t\t\t\t\t\t\t\t\tswitch_event_t *event;\n\t\t\t\t\t\t\t\t\t\tif (switch_event_create(&event, SWITCH_EVENT_TALK) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\t\t\t\t\tswitch_channel_event_set_data(switch_core_session_get_channel(rtp_session->vad_data.session), event);\n\t\t\t\t\t\t\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rtp_session->vad_data.hangunder_hits) {\n\t\t\t\t\t\t\t\trtp_session->vad_data.hangunder_hits--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\t\t\t\t\t\t\tif (++rtp_session->vad_data.hangover_hits >= rtp_session->vad_data.hangover) {\n\t\t\t\t\t\t\t\t\trtp_session->vad_data.stop_talking = switch_micro_time_now();\n\t\t\t\t\t\t\t\t\trtp_session->vad_data.total_talk_time += (rtp_session->vad_data.stop_talking - rtp_session->vad_data.start_talking);\n\n\t\t\t\t\t\t\t\t\tswitch_clear_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING);\n\n\t\t\t\t\t\t\t\t\trtp_session->vad_data.hangover_hits = rtp_session->vad_data.hangunder_hits = rtp_session->vad_data.cng_count = 0;\n\t\t\t\t\t\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_EVENTS_NOTALK)) {\n\n\t\t\t\t\t\t\t\t\t\tif ((rtp_session->vad_data.fire_events & VAD_FIRE_NOT_TALK)) {\n\t\t\t\t\t\t\t\t\t\t\tswitch_event_t *event;\n\t\t\t\t\t\t\t\t\t\t\tif (switch_event_create(&event, SWITCH_EVENT_NOTALK) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch_channel_event_set_data(switch_core_session_get_channel(rtp_session->vad_data.session), event);\n\t\t\t\t\t\t\t\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\t\t\t\tsend = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\t\tuint32_t ts_delta;\n\n\t\tthis_ts = ntohl(send_msg->header.ts);\n\n\t\tts_delta = abs((int32_t)(this_ts - rtp_session->last_write_ts));\n\n\t\tif (ts_delta > rtp_session->samples_per_second * 2) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t\t}\n#ifdef DEBUG_TS_ROLLOVER\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"WRITE TS LAST:%u THIS:%u DELTA:%u\\n\", rtp_session->last_write_ts, this_ts, ts_delta);\n#endif\n\t\tif ((!(flags && *flags & SFF_RFC2833) && ts_delta == 0) || !switch_rtp_ready(rtp_session) || rtp_session->sending_dtmf) {\n\t\t\tsend = 0;\n\t\t}\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_PAUSE]) {\n\t\tsend = 0;\n\t}\n\n\tif (send) {\n\t\tint delta = 1;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (*flags & SFF_EXTERNAL) && \n\t\t\trtp_session->stats.outbound.packet_count && rtp_session->flags[SWITCH_RTP_FLAG_PASSTHRU]) {\n\t\t\tint32_t x = rtp_session->last_write_seq;\n\t\t\tint32_t y = ntohs(send_msg->header.seq);\n\n\t\t\tif (!rtp_session->video_delta_mode) {\n\t\t\t\trtp_session->video_delta_mode = 1;\n\t\t\t} else {\n\t\t\t\tif (x > UINT16_MAX / 2 && y < UINT16_MAX / 2) {\n\t\t\t\t\tx -= (int32_t)UINT16_MAX+1;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tdelta = y-x;\n\t\t\t}\n\t\t\t\n\t\t\trtp_session->last_write_seq = y;\n\t\t}\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PASSTHRU]) {\n\t\t\trtp_session->video_delta_mode = 0;\n\t\t}\n\n\t\trtp_session->seq += delta;\n\n\t\tsend_msg->header.seq = htons(rtp_session->seq);\n\t\t\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_BYTESWAP] && send_msg->header.pt == rtp_session->payload) {\n\t\t\tswitch_swap_linear((int16_t *)send_msg->body, (int) datalen);\n\t\t}\n\n#ifdef ENABLE_SRTP\n\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\t\tint sbytes = (int) bytes;\n\t\t\tsrtp_err_status_t stat;\n\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET] || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {\n\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND_RESET);\n\t\t\t\tsrtp_dealloc(rtp_session->send_ctx[rtp_session->srtp_idx_rtp]);\n\t\t\t\trtp_session->send_ctx[rtp_session->srtp_idx_rtp] = NULL;\n\t\t\t\tif (srtp_create(&rtp_session->send_ctx[rtp_session->srtp_idx_rtp],\n\t\t\t\t\t\t\t\t\t\t&rtp_session->send_policy[rtp_session->srtp_idx_rtp]) || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Error! RE-Activating %s Secure RTP SEND\\n\", rtp_type(rtp_session));\n\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\t\t\t\t\tret = -1;\n\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\tgoto end;\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t  \"RE-Activating %s Secure RTP SEND\\n\", rtp_type(rtp_session));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\tstat = srtp_protect(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &send_msg->header, &sbytes);\n\t\t\t} else {\n\t\t\t\tstat = srtp_protect_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &send_msg->header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t}\n\n\t\t\tif (stat) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t  \"Error: %s SRTP protection failed with code %d\\n\", rtp_type(rtp_session), stat);\n\t\t\t}\n\n\t\t\tbytes = sbytes;\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\n\t\tnow = switch_micro_time_now();\n#ifdef RTP_DEBUG_WRITE_DELTA\n\t\t{\n\t\t\tint delta = (int) (now - rtp_session->send_time) / 1000;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"WRITE %d delta %d\\n\", (int) bytes, delta);\n\t\t}\n#endif\n\t\trtp_session->send_time = now;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\tconst char *tx_host;\n\t\t\tconst char *old_host;\n\t\t\tconst char *my_host;\n\n\t\t\tchar bufa[50], bufb[50], bufc[50];\n\n\n\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t  \"W %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),\n\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK]) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\n\t\t\tif (!rtp_session->vbw) {\n\t\t\t\tint nack_size = 100;\n\t\t\t\tconst char *var;\n\t\t\t\t\n\t\t\t\tif ((var = switch_channel_get_variable(channel, \"rtp_nack_buffer_size\"))) {\n\t\t\t\t\tint tmp = atoi(var);\n\t\t\t\t\t\n\t\t\t\t\tif (tmp > 0 && tmp < 500) {\n\t\t\t\t\t\tnack_size = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch_jb_create(&rtp_session->vbw, SJB_VIDEO, nack_size, nack_size, rtp_session->pool);\n\n\t\t\t\tif (rtp_session->vbw) {\n\t\t\t\t\tswitch_jb_set_flag(rtp_session->vbw, SJB_QUEUE_ONLY);\n\t\t\t\t\t//switch_jb_debug_level(rtp_session->vbw, 10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch_jb_put_packet(rtp_session->vbw, (switch_rtp_packet_t *)send_msg, bytes);\n\t\t}\n\n#ifdef RTP_WRITE_PLOSS\n\t\t{\n\t\t\tint r = (rand() % 10000) + 1;\n\n\t\t\tif (r <= 200) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ALERT,\n\t\t\t\t\t\t\t\t  \"Simulate dropping packet ......... ts: %u seq: %u\\n\", ntohl(send_msg->header.ts), ntohs(send_msg->header.seq));\n\t\t\t} else {\n\t\t\t\tif (switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, (void *) send_msg, &bytes) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\trtp_session->seq--;\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t//\n\t\t//\trtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]++;\n\t\t//\n\t\t//\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, \"SEND %u\\n\", ntohs(send_msg->header.seq));\n\t\t//}\n\t\tif (switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, (void *) send_msg, &bytes) != SWITCH_STATUS_SUCCESS) {\n\t\t\trtp_session->seq -= delta;\n\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n#endif\n\t\trtp_session->last_write_ts = this_ts;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 0;\n\n\t\tif (rtp_session->queue_delay) {\n\t\t\trtp_session->delay_samples = rtp_session->queue_delay;\n\t\t\trtp_session->queue_delay = 0;\n\t\t}\n\n\t\trtp_session->stats.outbound.raw_bytes += bytes;\n\t\trtp_session->stats.outbound.packet_count++;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\trtp_session->stats.rtcp.sent_pkt_count++;\n\t\t}\n\n\t\tif (send_msg->header.pt == rtp_session->cng_pt) {\n\t\t\trtp_session->stats.outbound.cng_packet_count++;\n\t\t} else {\n\t\t\trtp_session->stats.outbound.media_packet_count++;\n\t\t\trtp_session->stats.outbound.media_bytes += bytes;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\trtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;\n\t\t}\n\n\t\trtp_session->last_write_timestamp = switch_micro_time_now();\n\t}\n\n\tret = (int) bytes;\n\n end:\n\n\tWRITE_DEC(rtp_session);\n\n\treturn ret;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_disable_vad(switch_rtp_t *rtp_session)\n{\n\n\tif (!rtp_session) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\treturn SWITCH_STATUS_GENERR;\n\t}\n\tswitch_core_codec_destroy(&rtp_session->vad_data.vad_codec);\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_VAD);\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_enable_vad(switch_rtp_t *rtp_session, switch_core_session_t *session, switch_codec_t *codec,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  switch_vad_flag_t flags)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\treturn SWITCH_STATUS_GENERR;\n\t}\n\n\tmemset(&rtp_session->vad_data, 0, sizeof(rtp_session->vad_data));\n\n\tif (switch_true(switch_channel_get_variable(switch_core_session_get_channel(rtp_session->session), \"fire_talk_events\"))) {\n\t\trtp_session->vad_data.fire_events |= VAD_FIRE_TALK;\n\t}\n\n\tif (switch_true(switch_channel_get_variable(switch_core_session_get_channel(rtp_session->session), \"fire_not_talk_events\"))) {\n\t\trtp_session->vad_data.fire_events |= VAD_FIRE_NOT_TALK;\n\t}\n\n\n\tif (switch_core_codec_init(&rtp_session->vad_data.vad_codec,\n\t\t\t\t\t\t\t   codec->implementation->iananame,\n\t\t\t\t\t\t\t   codec->implementation->modname,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   codec->implementation->samples_per_second,\n\t\t\t\t\t\t\t   codec->implementation->microseconds_per_packet / 1000,\n\t\t\t\t\t\t\t   codec->implementation->number_of_channels,\n\t\t\t\t\t\t\t   SWITCH_CODEC_FLAG_ENCODE | SWITCH_CODEC_FLAG_DECODE, NULL, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Can't load codec?\\n\");\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Activate VAD codec %s %dms\\n\", codec->implementation->iananame,\n\t\t\t\t\t  codec->implementation->microseconds_per_packet / 1000);\n\trtp_session->vad_data.diff_level = 400;\n\trtp_session->vad_data.hangunder = 15;\n\trtp_session->vad_data.hangover = 40;\n\trtp_session->vad_data.bg_len = 5;\n\trtp_session->vad_data.bg_count = 5;\n\trtp_session->vad_data.bg_level = 300;\n\trtp_session->vad_data.read_codec = codec;\n\trtp_session->vad_data.session = session;\n\trtp_session->vad_data.flags = flags;\n\trtp_session->vad_data.cng_freq = 50;\n\trtp_session->vad_data.ts = 1;\n\trtp_session->vad_data.start = 0;\n\trtp_session->vad_data.next_scan = switch_epoch_time_now(NULL);\n\trtp_session->vad_data.scan_freq = 0;\n\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\trtp_session->vad_data.start_talking = switch_micro_time_now();\n\t}\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_VAD);\n\tswitch_set_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_CNG);\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(int) switch_rtp_write_frame(switch_rtp_t *rtp_session, switch_frame_t *frame)\n{\n\tuint8_t fwd = 0;\n\tvoid *data = NULL;\n\tuint32_t len, ts = 0;\n\tswitch_payload_t payload = 0;\n\trtp_msg_t *send_msg = NULL;\n\tsrtp_hdr_t local_header;\n\tint r = 0;\n\tswitch_status_t status;\n\n\tif (!switch_rtp_ready(rtp_session) || !rtp_session->remote_addr) {\n\t\treturn -1;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, frame->datalen, __LINE__)) {\n\t\treturn 0;\n\t}\n\n\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t//\trtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]++;\n\t//\trtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]++;\n\t//}\n\n\n\tif (switch_test_flag(frame, SFF_PROXY_PACKET) || switch_test_flag(frame, SFF_UDPTL_PACKET) ||\n\t\trtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\tswitch_size_t bytes;\n\t\t//char bufa[50];\n\n\t\t/* Fast PASS! */\n\t\tif (!switch_test_flag(frame, SFF_PROXY_PACKET) && !switch_test_flag(frame, SFF_UDPTL_PACKET)) {\n\t\t\treturn 0;\n\t\t}\n\t\tbytes = frame->packetlen;\n\t\t//tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->remote_addr);\n\n\t\tsend_msg = frame->packet;\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !switch_test_flag(frame, SFF_UDPTL_PACKET)) {\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->payload > 0) {\n\t\t\t\tsend_msg->header.pt = rtp_session->payload;\n\t\t\t}\n\n\t\t\tsend_msg->header.ssrc = htonl(rtp_session->ssrc);\n\t\t\tsend_msg->header.seq = htons(++rtp_session->seq);\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\tconst char *tx_host;\n\t\t\tconst char *old_host;\n\t\t\tconst char *my_host;\n\n\t\t\tchar bufa[50], bufb[50], bufc[50];\n\n\n\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t  \"W %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),\n\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t}\n\n\t\tif ((status = switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, frame->packet, &bytes)) != SWITCH_STATUS_SUCCESS) {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_ERROR, \"bytes: %\" SWITCH_SIZE_T_FMT \", status: %d\", bytes, status);\n\t\t\t}\n\n\t\t\treturn -1 * status;\n\t\t}\n\n\n\t\trtp_session->stats.outbound.raw_bytes += bytes;\n\t\trtp_session->stats.outbound.media_bytes += bytes;\n\t\trtp_session->stats.outbound.media_packet_count++;\n\t\trtp_session->stats.outbound.packet_count++;\n\t\treturn (int) bytes;\n\t}\n\n\tfwd = (rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] &&\n\t\t   (switch_test_flag(frame, SFF_RAW_RTP) || switch_test_flag(frame, SFF_RAW_RTP_PARSE_FRAME))) ? 1 : 0;\n\n\tif (!fwd && !rtp_session->sending_dtmf && !rtp_session->queue_delay && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] && (rtp_session->rtp_bugs & RTP_BUG_GEN_ONE_GEN_ALL)) {\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Generating RTP locally but timestamp passthru is configured, disabling....\\n\");\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] = 0;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t}\n\n\tswitch_assert(frame != NULL);\n\n\tif (switch_test_flag(frame, SFF_CNG)) {\n\t\tif (rtp_session->cng_pt != INVALID_PT) {\n\t\t\tpayload = rtp_session->cng_pt;\n\t\t} else {\n\t\t\treturn (int) frame->packetlen;\n\t\t}\n\t} else {\n\t\tpayload = rtp_session->payload;\n#if 0\n\t\tif (rtp_session->pmaps && *rtp_session->pmaps) {\n\t\t\tpayload_map_t *pmap;\n\t\t\tfor (pmap = *rtp_session->pmaps; pmap; pmap = pmap->next) {\n\t\t\t\tif (pmap->current) {\n\t\t\t\t\tpayload = pmap->pt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\n\tif (switch_test_flag(frame, SFF_RTP_HEADER) || rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\tswitch_size_t wrote;\n\n\t\twrote = switch_rtp_write_manual(rtp_session, frame->data, frame->datalen,\n\t\t\t\t\t\t\t\t\t\tframe->m, frame->payload, (uint32_t) (frame->timestamp), &frame->flags);\n\n\t\trtp_session->stats.outbound.raw_bytes += wrote;\n\t\trtp_session->stats.outbound.media_bytes += wrote;\n\t\trtp_session->stats.outbound.media_packet_count++;\n\t\trtp_session->stats.outbound.packet_count++;\n\n\t\treturn wrote;\n\t}\n\n\tif (frame->pmap && rtp_session->pmaps && *rtp_session->pmaps) {\n\t\tpayload_map_t *pmap;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\tfor (pmap = *rtp_session->pmaps; pmap; pmap = pmap->next) {\n\t\t\tif (pmap->negotiated && pmap->hash == frame->pmap->hash) {\n\t\t\t\tpayload = pmap->recv_pt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t}\n\n\tif (fwd) {\n\t\tsend_msg = frame->packet;\n\t\tlocal_header = send_msg->header;\n\t\tlen = frame->packetlen;\n\t\tts = 0;\n\n\t\tsend_msg->header.pt = payload;\n\n\t\tif (switch_test_flag(frame, SFF_RAW_RTP_PARSE_FRAME)) {\n\t\t\tsend_msg->header.version = 2;\n\t\t\tsend_msg->header.m = frame->m;\n\n\t\t\tsend_msg->header.ts = htonl(frame->timestamp);\n\t\t\tif (frame->ssrc) {\n\t\t\t\tsend_msg->header.ssrc = htonl(frame->ssrc);\n\t\t\t} else {\n\t\t\t\tsend_msg->header.ssrc = htonl(rtp_session->ssrc);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tdata = frame->data;\n\t\tlen = frame->datalen;\n\t\tts = rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] ? (uint32_t) frame->timestamp : 0;\n\t}\n\n\t/*\n\t  if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t  send_msg->header.pt = rtp_session->payload;\n\t  }\n\t*/\n\n\tr = rtp_common_write(rtp_session, send_msg, data, len, payload, ts, &frame->flags);\n\n\tif (send_msg) {\n\t\tsend_msg->header = local_header;\n\t}\n\n\treturn r;\n\n}\n\nSWITCH_DECLARE(switch_rtp_stats_t *) switch_rtp_get_stats(switch_rtp_t *rtp_session, switch_memory_pool_t *pool)\n{\n\tswitch_rtp_stats_t *s;\n\n\tif (!rtp_session) {\n\t\treturn NULL;\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\tif (pool) {\n\t\ts = switch_core_alloc(pool, sizeof(*s));\n\t\t*s = rtp_session->stats;\n\t} else {\n\t\ts = &rtp_session->stats;\n\t}\n\n\tif (rtp_session->jb) {\n\t\tswitch_jb_get_frames(rtp_session->jb, NULL, NULL, NULL, (uint32_t *)&s->inbound.largest_jb_size);\n\t}\n\n\tdo_mos(rtp_session);\n\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\treturn s;\n}\n\nSWITCH_DECLARE(int) switch_rtp_write_manual(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\t\t\t\t\tvoid *data, uint32_t datalen, uint8_t m, switch_payload_t payload, uint32_t ts, switch_frame_flag_t *flags)\n{\n\tswitch_size_t bytes;\n\tint ret = -1;\n\n\tif (!switch_rtp_ready(rtp_session) || !rtp_session->remote_addr || datalen > SWITCH_RTP_MAX_BUF_LEN) {\n\t\treturn -1;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, datalen, __LINE__)) {\n\t\treturn 0;\n\t}\n\n\tif (payload == INVALID_PT) {\n\t\treturn 0;\n\t}\n\n\tWRITE_INC(rtp_session);\n\n\trtp_session->write_msg = rtp_session->send_msg;\n\trtp_session->write_msg.header.seq = htons(++rtp_session->seq);\n\trtp_session->write_msg.header.ts = htonl(ts);\n\trtp_session->write_msg.header.pt = payload;\n\trtp_session->write_msg.header.m = m;\n\tmemcpy(rtp_session->write_msg.body, data, datalen);\n\n\tbytes = rtp_header_len + datalen;\n\n\tif (switch_rtp_write_raw(rtp_session, (void *) &rtp_session->write_msg, &bytes, SWITCH_TRUE) != SWITCH_STATUS_SUCCESS) {\n\t\trtp_session->seq--;\n\t\tret = -1;\n\t\tgoto end;\n\t}\n\n\tif (((*flags) & SFF_RTP_HEADER)) {\n\t\trtp_session->last_write_ts = ts;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 0;\n\t}\n\n\tret = (int) bytes;\n\n end:\n\n\tWRITE_DEC(rtp_session);\n\n\treturn ret;\n}\n\n\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_write_raw(switch_rtp_t *rtp_session, void *data, switch_size_t *bytes, switch_bool_t process_encryption)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tswitch_assert(bytes);\n\n\tif (!switch_rtp_ready(rtp_session) || !rtp_session->remote_addr || *bytes > SWITCH_RTP_MAX_BUF_LEN) {\n\t\treturn status;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, *bytes, __LINE__)) {\n\t\treturn SWITCH_STATUS_NOT_INITALIZED;\n\t}\n\n\tWRITE_INC(rtp_session);\n\n\tif (process_encryption) {\n#ifdef ENABLE_SRTP\n\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\n\t\t\tint sbytes = (int) *bytes;\n\t\t\tsrtp_err_status_t stat;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET]) {\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND_RESET);\n\t\t\t\tsrtp_dealloc(rtp_session->send_ctx[rtp_session->srtp_idx_rtp]);\n\t\t\t\trtp_session->send_ctx[rtp_session->srtp_idx_rtp] = NULL;\n\t\t\t\tif (srtp_create(&rtp_session->send_ctx[rtp_session->srtp_idx_rtp],\n\t\t\t\t\t\t\t\t\t\t&rtp_session->send_policy[rtp_session->srtp_idx_rtp]) || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error! RE-Activating Secure RTP SEND\\n\");\n\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\t\t\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\tgoto end;\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"RE-Activating Secure RTP SEND\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\tstat = srtp_protect(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &rtp_session->write_msg.header, &sbytes);\n\t\t\t} else {\n\t\t\t\tstat = srtp_protect_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &rtp_session->write_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t}\n\n\t\t\tif (stat) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error: SRTP protection failed with code %d\\n\", stat);\n\t\t\t}\n\t\t\t*bytes = sbytes;\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\t}\n\n\tstatus = switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, data, bytes);\n#if defined(ENABLE_SRTP)\n end:\n#endif\n\n\tWRITE_DEC(rtp_session);\n\n\treturn status;\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_get_ssrc(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->ssrc;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_private(switch_rtp_t *rtp_session, void *private_data)\n{\n\trtp_session->private_data = private_data;\n}\n\nSWITCH_DECLARE(void *) switch_rtp_get_private(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->private_data;\n}\n\nSWITCH_DECLARE(switch_core_session_t*) switch_rtp_get_core_session(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->session;\n}\n\n/* For Emacs:\n * Local Variables:\n * mode:c\n * indent-tabs-mode:t\n * tab-width:4\n * c-basic-offset:4\n * End:\n * For VIM:\n * vim:set softtabstop=4 shiftwidth=4 tabstop=4 noet:\n */\n"], "fixing_code": ["/*\n * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application\n * Copyright (C) 2005-2014, Anthony Minessale II <anthm@freeswitch.org>\n *\n * Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application\n *\n * The Initial Developer of the Original Code is\n * Anthony Minessale II <anthm@freeswitch.org>\n * Portions created by the Initial Developer are Copyright (C)\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n * Anthony Minessale II <anthm@freeswitch.org>\n * Marcel Barbulescu <marcelbarbulescu@gmail.com>\n * Seven Du <dujinfang@gmail.com>\n * Noah Mehl - Open Telecom Foundation <https://opentelecom.foundation>\n *\n * switch_rtp.c -- RTP\n *\n */\n#include <switch.h>\n#ifndef _MSC_VER\n#include <switch_private.h>\n#endif\n#include <switch_stun.h>\n#include <fspr_network_io.h>\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef PACKAGE_BUGREPORT\n#undef VERSION\n#undef PACKAGE\n#undef inline\n#include <srtp.h>\n#include <srtp_priv.h>\n#include <switch_ssl.h>\n#include <switch_jitterbuffer.h>\n\n//#define DEBUG_TS_ROLLOVER\n#ifdef DEBUG_TS_ROLLOVER\n#define TS_ROLLOVER_START 4294951295\n#endif\n\n//#define DEBUG_2833\n//#define RTP_DEBUG_WRITE_DELTA\n//#define DEBUG_MISSED_SEQ\n//#define DEBUG_EXTRA\n//#define DEBUG_RTCP\n#define DEBUG_ESTIMATORS_\n\n\n#define JITTER_LEAD_FRAMES 10\n#define READ_INC(rtp_session) switch_mutex_lock(rtp_session->read_mutex); rtp_session->reading++\n#define READ_DEC(rtp_session) rtp_session->reading--; switch_mutex_unlock(rtp_session->read_mutex)\n#define WRITE_INC(rtp_session) switch_mutex_lock(rtp_session->write_mutex); rtp_session->writing++\n#define WRITE_DEC(rtp_session) rtp_session->writing--; switch_mutex_unlock(rtp_session->write_mutex)\n\n#define RTP_STUN_FREQ 1000000\n#define rtp_header_len 12\n#define RTP_START_PORT 16384\n#define RTP_END_PORT 32768\n#define MASTER_KEY_LEN   30\n#define RTP_MAGIC_NUMBER 42\n#define WARN_SRTP_ERRS 10\n#define MAX_SRTP_ERRS 100\n#define NTP_TIME_OFFSET 2208988800UL\nstatic const switch_payload_t INVALID_PT = 255;\n\n#define DTMF_SANITY (rtp_session->one_second * 30)\n\n#define rtp_session_name(_rtp_session) _rtp_session->session ? switch_core_session_get_name(_rtp_session->session) : \"-\"\n\n#define STUN_USERNAME_MAX_SIZE 513 /* From RFC5389:  \"It MUST contain a UTF-8 [RFC3629] encoded sequence of less than 513 bytes\" */\n#define SDP_UFRAG_MAX_SIZE 256 \t/* From draft-ietf-mmusic-ice-sip-sdp-24: \"the ice-ufrag attribute MUST NOT be longer than 32\n\t\t\t\t\t\t\t\t * characters when sending, but an implementation MUST accept up to 256\n\t\t\t\t\t\t\t\t * characters when receiving.\" */\n\nstatic switch_port_t START_PORT = RTP_START_PORT;\nstatic switch_port_t END_PORT = RTP_END_PORT;\nstatic switch_mutex_t *port_lock = NULL;\nstatic switch_size_t do_flush(switch_rtp_t *rtp_session, int force, switch_size_t bytes_in);\n\ntypedef srtp_hdr_t rtp_hdr_t;\n\n\n#ifdef _MSC_VER\n#pragma pack(4)\n#endif\n\n#ifdef _MSC_VER\n#pragma pack()\n#define ENABLE_SRTP\n#endif\n\nstatic switch_hash_t *alloc_hash = NULL;\n\ntypedef struct {\n\tsrtp_hdr_t header;\n\tchar body[SWITCH_RTP_MAX_BUF_LEN+4+sizeof(char *)];\n\tswitch_rtp_hdr_ext_t *ext;\n\tchar *ebody;\n} rtp_msg_t;\n\n#define RTP_BODY(_s) (char *) (_s->recv_msg.ebody ? _s->recv_msg.ebody : _s->recv_msg.body)\n\ntypedef struct {\n\tuint32_t ssrc;\n\tuint8_t seq;\n\tuint8_t r1;\n\tuint8_t r2;\n\tuint8_t r3;\n} rtcp_fir_t;\n\n#ifdef _MSC_VER\n#pragma pack(push, r1, 1)\n#endif\n\ntypedef struct switch_rtcp_sdes_unit_s {\n\tunsigned char type;\n\tunsigned char length;\n\tchar value[];\n} switch_rtcp_sdes_unit_t;\n\ntypedef struct {\n\tuint32_t ssrc;\n\tuint8_t parts[4];\n} rtcp_tmmbx_t;\n\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\ntypedef struct {\n\tunsigned version:2;\n\tunsigned p:1;\n\tunsigned fmt:5;\n\tunsigned pt:8;\n\tunsigned length:16;\n\tuint32_t send_ssrc;\n\tuint32_t recv_ssrc;\n} switch_rtcp_ext_hdr_t;\n\n#else /*  BIG_ENDIAN */\n\ntypedef struct {\n\tunsigned fmt:5;\n\tunsigned p:1;\n\tunsigned version:2;\n\tunsigned pt:8;\n\tunsigned length:16;\n\tuint32_t send_ssrc;\n\tuint32_t recv_ssrc;\n} switch_rtcp_ext_hdr_t;\n\n#endif\n\n#ifdef _MSC_VER\n#pragma pack(pop, r1)\n#endif\n\n#define KALMAN_SYSTEM_MODELS 3 /*loss, jitter, rtt*/\n#define EST_LOSS 0\n#define EST_JITTER 1\n#define EST_RTT 2\n\ntypedef struct {\n\tswitch_rtcp_ext_hdr_t header;\n\tchar body[SWITCH_RTCP_MAX_BUF_LEN];\n} rtcp_ext_msg_t;\n\ntypedef struct {\n\tswitch_rtcp_hdr_t header;\n\tchar body[SWITCH_RTCP_MAX_BUF_LEN];\n} rtcp_msg_t;\n\n\ntypedef enum {\n\tVAD_FIRE_TALK = (1 << 0),\n\tVAD_FIRE_NOT_TALK = (1 << 1)\n} vad_talk_mask_t;\n\nstruct switch_rtp_vad_data {\n\tswitch_core_session_t *session;\n\tswitch_codec_t vad_codec;\n\tswitch_codec_t *read_codec;\n\tuint32_t bg_level;\n\tuint32_t bg_count;\n\tuint32_t bg_len;\n\tuint32_t diff_level;\n\tuint8_t hangunder;\n\tuint8_t hangunder_hits;\n\tuint8_t hangover;\n\tuint8_t hangover_hits;\n\tuint8_t cng_freq;\n\tuint8_t cng_count;\n\tswitch_vad_flag_t flags;\n\tuint32_t ts;\n\tuint8_t start;\n\tuint8_t start_count;\n\tuint8_t scan_freq;\n\ttime_t next_scan;\n\tswitch_time_t start_talking;\n\tswitch_time_t stop_talking;\n\tswitch_time_t total_talk_time;\n\tint fire_events;\n};\n\nstruct switch_rtp_rfc2833_data {\n\tswitch_queue_t *dtmf_queue;\n\tchar out_digit;\n\tunsigned char out_digit_packet[4];\n\tunsigned int out_digit_sofar;\n\tunsigned int out_digit_sub_sofar;\n\tunsigned int out_digit_dur;\n\tuint16_t in_digit_seq;\n\tuint32_t in_digit_ts;\n\tuint32_t last_in_digit_ts;\n\tuint32_t in_digit_sanity;\n\tuint32_t in_interleaved;\n\tuint32_t timestamp_dtmf;\n\tuint16_t last_duration;\n\tuint32_t flip;\n\tchar first_digit;\n\tchar last_digit;\n\tswitch_queue_t *dtmf_inqueue;\n\tswitch_mutex_t *dtmf_mutex;\n\tuint8_t in_digit_queued;\n};\n\ntypedef struct {\n\tchar *ice_user;\n\tchar *user_ice;\n\tchar *luser_ice;\n\tchar *pass;\n\tchar *rpass;\n\tswitch_sockaddr_t *addr;\n\tuint32_t funny_stun;\n\tswitch_time_t next_run;\n\tswitch_core_media_ice_type_t type;\n\tice_t *ice_params;\n\tice_proto_t proto;\n\tuint8_t sending;\n\tuint8_t ready;\n\tuint8_t rready;\n\tuint8_t initializing;\n\tint missed_count;\n\tchar last_sent_id[13];\n\tswitch_time_t last_ok;\n\tuint8_t cand_responsive;\n} switch_rtp_ice_t;\n\nstruct switch_rtp;\n\nstatic void switch_rtp_dtls_init(void);\nstatic void switch_rtp_dtls_destroy(void);\n\n#define MAX_DTLS_MTU 4096\n\ntypedef struct switch_dtls_s {\n\t/* DTLS */\n\tSSL_CTX *ssl_ctx;\n\tSSL *ssl;\n\tBIO *read_bio;\n\tBIO *write_bio;\n\tBIO *filter_bio;\n\tdtls_fingerprint_t *local_fp;\n\tdtls_fingerprint_t *remote_fp;\n\tdtls_state_t state;\n\tdtls_state_t last_state;\n\tuint8_t new_state;\n\tdtls_type_t type;\n\tswitch_size_t bytes;\n\tvoid *data;\n\tswitch_socket_t *sock_output;\n\tswitch_sockaddr_t *remote_addr;\n\tchar *rsa;\n\tchar *pvt;\n\tchar *ca;\n\tchar *pem;\n\tstruct switch_rtp *rtp_session;\n\tint mtu;\n} switch_dtls_t;\n\ntypedef int (*dtls_state_handler_t)(switch_rtp_t *, switch_dtls_t *);\n\n\nstatic int dtls_state_handshake(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\nstatic int dtls_state_ready(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\nstatic int dtls_state_setup(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\nstatic int dtls_state_fail(switch_rtp_t *rtp_session, switch_dtls_t *dtls);\n\ndtls_state_handler_t dtls_states[DS_INVALID] = {NULL, dtls_state_handshake, dtls_state_setup, dtls_state_ready, dtls_state_fail};\n\ntypedef struct ts_normalize_s {\n\tuint32_t last_ssrc;\n\tuint32_t last_frame;\n\tuint32_t ts;\n\tuint32_t delta;\n\tuint32_t delta_ttl;\n\tint last_external;\n} ts_normalize_t;\n\nstruct switch_rtp {\n\t/*\n\t * Two sockets are needed because we might be transcoding protocol families\n\t * (e.g. receive over IPv4 and send over IPv6). In case the protocol\n\t * families are equal, sock_input == sock_output and only one socket is\n\t * used.\n\t */\n\tswitch_socket_t *sock_input, *sock_output, *rtcp_sock_input, *rtcp_sock_output;\n\tswitch_pollfd_t *read_pollfd, *rtcp_read_pollfd;\n\tswitch_pollfd_t *jb_pollfd;\n\n\tswitch_sockaddr_t *local_addr, *rtcp_local_addr;\n\trtp_msg_t send_msg;\n\trtcp_msg_t rtcp_send_msg;\n\tswitch_rtcp_frame_t rtcp_frame;\n\n\tuint8_t send_rr;\n\tuint8_t fir_seq;\n\tuint16_t fir_count;\n\tuint16_t pli_count;\n\tuint32_t cur_tmmbr;\n\tuint32_t tmmbr;\n\tuint32_t tmmbn;\n\n\tts_normalize_t ts_norm;\n\tswitch_sockaddr_t *remote_addr, *rtcp_remote_addr;\n\trtp_msg_t recv_msg;\n\trtcp_msg_t rtcp_recv_msg;\n\trtcp_msg_t *rtcp_recv_msg_p;\n\n\tuint32_t autoadj_window;\n\tuint32_t autoadj_threshold;\n\tuint32_t autoadj_tally;\n\n\tuint32_t rtcp_autoadj_window;\n\tuint32_t rtcp_autoadj_threshold;\n\tuint32_t rtcp_autoadj_tally;\n\n\tsrtp_ctx_t *send_ctx[2];\n\tsrtp_ctx_t *recv_ctx[2];\n\n\tsrtp_policy_t send_policy[2];\n\tsrtp_policy_t recv_policy[2];\n\n\tuint32_t srtp_errs[2];\n\tuint32_t srctp_errs[2];\n\n\n\tint srtp_idx_rtp;\n\tint srtp_idx_rtcp;\n\n\tswitch_dtls_t *dtls;\n\tswitch_dtls_t *rtcp_dtls;\n\n\trtp_hdr_t last_rtp_hdr;\n\n\tuint16_t seq;\n\tuint32_t ssrc;\n\tuint32_t remote_ssrc;\n\tuint32_t last_jb_read_ssrc;\n\tint8_t sending_dtmf;\n\tuint8_t need_mark;\n\tswitch_payload_t payload;\n\tswitch_rtp_invalid_handler_t invalid_handler;\n\tvoid *private_data;\n\tuint32_t ts;\n\t//uint32_t last_clock_ts;\n\tuint32_t last_write_ts;\n\tuint32_t last_read_ts;\n\tuint32_t prev_read_ts;\n\tuint32_t last_cng_ts;\n\tuint32_t last_write_samplecount;\n\tuint32_t delay_samples;\n\tuint32_t next_write_samplecount;\n\tuint32_t max_next_write_samplecount;\n\tuint32_t queue_delay;\n\tswitch_time_t last_write_timestamp;\n\tuint32_t flags[SWITCH_RTP_FLAG_INVALID];\n\tswitch_memory_pool_t *pool;\n\tswitch_sockaddr_t *from_addr, *rtp_from_addr, *rtcp_from_addr, *bundle_internal_addr, *bundle_external_addr;\n\tchar *rx_host;\n\tswitch_port_t rx_port;\n\tswitch_rtp_ice_t ice;\n\tswitch_rtp_ice_t rtcp_ice;\n\tchar *timer_name;\n\tchar *local_host_str;\n\tchar *remote_host_str;\n\tchar *eff_remote_host_str;\n\tswitch_time_t first_stun;\n\tswitch_time_t last_stun;\n\tuint32_t samples_per_interval;\n\tuint32_t samples_per_second;\n\tuint32_t conf_samples_per_interval;\n\tswitch_time_t rtcp_last_sent;\n\tuint32_t rsamples_per_interval;\n\tuint32_t ms_per_packet;\n\tuint32_t one_second;\n\tuint32_t consecutive_flaws;\n\tuint32_t jitter_lead;\n\tdouble old_mean;\n\tswitch_time_t next_stat_check_time;\n\tswitch_port_t local_port;\n\tswitch_port_t remote_port;\n\tswitch_port_t eff_remote_port;\n\tswitch_port_t remote_rtcp_port;\n\n\tstruct switch_rtp_vad_data vad_data;\n\tstruct switch_rtp_rfc2833_data dtmf_data;\n\tswitch_payload_t te;\n\tswitch_payload_t recv_te;\n\tswitch_payload_t cng_pt;\n\tswitch_mutex_t *flag_mutex;\n\tswitch_mutex_t *read_mutex;\n\tswitch_mutex_t *write_mutex;\n\tswitch_mutex_t *ice_mutex;\n\tswitch_timer_t timer;\n\tswitch_timer_t write_timer;\n\tuint8_t ready;\n\tuint8_t cn;\n\tswitch_jb_t *jb;\n\tswitch_jb_t *vb;\n\tswitch_jb_t *vbw;\n\tuint32_t max_missed_packets;\n\tuint32_t missed_count;\n\tswitch_time_t last_media;\n\tuint32_t media_timeout;\n\trtp_msg_t write_msg;\n\tswitch_rtp_crypto_key_t *crypto_keys[SWITCH_RTP_CRYPTO_MAX];\n\tint reading;\n\tint writing;\n\tchar *stun_ip;\n\tswitch_port_t stun_port;\n\tint from_auto;\n\tuint32_t cng_count;\n\tswitch_rtp_bug_flag_t rtp_bugs;\n\tswitch_rtp_stats_t stats;\n\tswitch_rtcp_video_stats_t rtcp_vstats;\n\tuint32_t clean_stream;\n\tuint32_t bad_stream;\n\tuint32_t recovering_stream;\n\n\tuint32_t hot_hits;\n\tuint32_t sync_packets;\n\tint rtcp_interval;\n\tint rtcp_sent_packets;\n\tswitch_bool_t rtcp_fresh_frame;\n\n\tswitch_time_t send_time;\n\tswitch_byte_t auto_adj_used;\n\tswitch_byte_t rtcp_auto_adj_used;\n\tuint8_t pause_jb;\n\tuint16_t last_seq;\n\tuint16_t last_write_seq;\n\tuint8_t video_delta_mode;\n\tswitch_time_t last_read_time;\n\tswitch_size_t last_flush_packet_count;\n\tuint32_t interdigit_delay;\n\tswitch_core_session_t *session;\n\tpayload_map_t **pmaps;\n\tpayload_map_t *pmap_tail;\n\tkalman_estimator_t *estimators[KALMAN_SYSTEM_MODELS];\n\tcusum_kalman_detector_t *detectors[KALMAN_SYSTEM_MODELS];\n\tswitch_time_t last_adj;\n\tswitch_time_t adj_window;\n\tuint32_t elapsed_stun;\n\tuint32_t elapsed_media;\n\tuint32_t elapsed_adj;\n\tuint8_t has_rtp;\n\tuint8_t has_rtcp;\n\tuint8_t has_ice;\n\tuint8_t punts;\n\tuint8_t clean;\n\tuint32_t last_max_vb_frames;\n\tint skip_timer;\n\tuint32_t prev_nacks_inflight;\n};\n\nstruct switch_rtcp_report_block {\n\tuint32_t ssrc; /* The SSRC identifier of the source to which the information in this reception report block pertains. */\n\tunsigned int fraction :8; /* The fraction of RTP data packets from source SSRC_n lost since the previous SR or RR packet was sent */\n\tint lost :24; /* The total number of RTP data packets from source SSRC_n that have been lost since the beginning of reception */\n\tuint32_t highest_sequence_number_received;\n\tuint32_t jitter; /* An estimate of the statistical variance of the RTP data packet interarrival time, measured in timestamp units and expressed as an unsigned integer. */\n\tuint32_t lsr; /* The middle 32 bits out of 64 in the NTP timestamp */\n\tuint32_t dlsr; /* The delay, expressed in units of 1/65536 seconds, between receiving the last SR packet from source SSRC_n and sending this reception report block */\n};\n\nstruct switch_rtcp_sr_head {\n\tuint32_t ssrc;\n\tuint32_t ntp_msw;\n\tuint32_t ntp_lsw;\n\tuint32_t ts;\n\tuint32_t pc;\n\tuint32_t oc;\n};\n\nstruct switch_rtcp_sender_info {\n\tuint32_t ntp_msw;\n\tuint32_t ntp_lsw;\n\tuint32_t ts;\n\tuint32_t pc;\n\tuint32_t oc;\n};\n\nstruct switch_rtcp_sender_report {\n\tuint32_t ssrc;\n\tstruct switch_rtcp_sender_info sender_info;\n\tstruct switch_rtcp_report_block report_block;\n};\n\nstruct switch_rtcp_receiver_report {\n\tuint32_t ssrc;\n\tstruct switch_rtcp_report_block report_block;\n};\n\ntypedef enum {\n\tRESULT_CONTINUE,\n\tRESULT_GOTO_END,\n\tRESULT_GOTO_RECVFROM,\n\tRESULT_GOTO_TIMERCHECK\n} handle_rfc2833_result_t;\n\nstatic void do_2833(switch_rtp_t *rtp_session);\n\n\n#define rtp_type(rtp_session) rtp_session->flags[SWITCH_RTP_FLAG_TEXT] ?  \"text\" : (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] ? \"video\" : \"audio\")\n\n\nstatic void switch_rtp_change_ice_dest(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice, const char *host, switch_port_t port)\n{\n\tint is_rtcp = ice == &rtp_session->rtcp_ice;\n\tconst char *err = \"\";\n\tint i;\n\tuint8_t ice_cand_found_idx = 0;\n\n\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\tif (!strcmp(host, ice->ice_params->cands[i][ice->proto].con_addr) && port == ice->ice_params->cands[i][ice->proto].con_port) {\n\t\t\tice_cand_found_idx = i;\n\t\t}\n\t}\n\n\tif (!ice_cand_found_idx) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"ICE candidate [%s:%d] replaced with [%s:%d]\\n\",\n\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, host, port);\n\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr = switch_core_strdup(rtp_session->pool, host);\n\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port = port;\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"ICE chosen candidate [%s:%d] set to idx [%d]\\n\", host, port, ice_cand_found_idx);\n\t\tice->ice_params->chosen[ice->proto] = ice_cand_found_idx;\n\t}\n\n\tice->missed_count = 0;\n\n\tif (is_rtcp) {\n\t\tice->addr = rtp_session->rtcp_remote_addr;\n\t} else {\n\t\tswitch_rtp_set_remote_address(rtp_session, host, port, 0, SWITCH_FALSE, &err);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\tice->addr = rtp_session->remote_addr;\n\t\t}\n\t}\n\n}\n\n\n\nstatic handle_rfc2833_result_t handle_rfc2833(switch_rtp_t *rtp_session, switch_size_t bytes, int *do_cng)\n{\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]++;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] > DTMF_SANITY) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = 0;\n\t\t} else {\n\t\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\t\t}\n\t}\n\n\n#ifdef DEBUG_2833\n\tif (rtp_session->dtmf_data.in_digit_sanity && !(rtp_session->dtmf_data.in_digit_sanity % 100)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"sanity %d %ld\\n\", rtp_session->dtmf_data.in_digit_sanity, bytes);\n\t}\n#endif\n\n\tif (rtp_session->dtmf_data.in_digit_sanity && !--rtp_session->dtmf_data.in_digit_sanity) {\n\n\t\trtp_session->dtmf_data.last_digit = 0;\n\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Failed DTMF sanity check.\\n\");\n\t}\n\n\tif (!bytes) return RESULT_CONTINUE;\n\n\n\t/* RFC2833 ... like all RFC RE: VoIP, guaranteed to drive you to insanity!\n\t   We know the real rules here, but if we enforce them, it's an interop nightmare so,\n\t   we put up with as much as we can so we don't have to deal with being punished for\n\t   doing it right. Nice guys finish last!\n\t*/\n\n\tif (bytes > rtp_header_len && !rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] &&\n\t\trtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\tswitch_size_t len = bytes - rtp_header_len;\n\t\tunsigned char *packet = (unsigned char *) RTP_BODY(rtp_session);\n\t\tint end;\n\t\tuint16_t duration;\n\t\tchar key;\n\t\tuint16_t in_digit_seq;\n\t\tuint32_t ts;\n\n\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\n\t\tif (!(packet[0] || packet[1] || packet[2] || packet[3]) && len >= 8) {\n\t\t\tpacket += 4;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"DTMF payload offset by 4 bytes.\\n\");\n\t\t}\n\n\t\tif (!(packet[0] || packet[1] || packet[2] || packet[3]) && rtp_session->dtmf_data.in_digit_ts) {\n\t\t\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, \"Failed DTMF payload check.\\n\");\n\t\t\trtp_session->dtmf_data.last_digit = 0;\n\t\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\t\trtp_session->dtmf_data.in_digit_sanity = 0;\n\t\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\t}\n\n\t\tend = packet[1] & 0x80 ? 1 : 0;\n\t\tduration = (packet[2] << 8) + packet[3];\n\t\tkey = switch_rfc2833_to_char(packet[0]);\n\t\tin_digit_seq = ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\t\tts = htonl(rtp_session->last_rtp_hdr.ts);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_PASS_RFC2833]) {\n\n\t\t\tif (end) {\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = DTMF_SANITY - 3;\n\t\t\t} else if (!rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]) {\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = 1;\n\t\t\t}\n\n\t\t\treturn RESULT_CONTINUE;\n\t\t}\n\n\t\tif (in_digit_seq < rtp_session->dtmf_data.in_digit_seq) {\n\t\t\tif (rtp_session->dtmf_data.in_digit_seq - in_digit_seq > 100) {\n\t\t\t\trtp_session->dtmf_data.in_digit_seq = 0;\n\t\t\t}\n\t\t}\n#ifdef DEBUG_2833\n\t\tif (!(packet[0] || packet[1] || packet[2] || packet[3]) && len >= 8) {\n\t\t\tlen -= 4;\n\t\t}\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"packet[%d]: %02x %02x %02x %02x\\n\", (int) len, (unsigned char) packet[0], (unsigned char) packet[1], (unsigned char) packet[2], (unsigned char) packet[3]);\n#endif\n\n\t\tif (in_digit_seq > rtp_session->dtmf_data.in_digit_seq) {\n\n\t\t\trtp_session->dtmf_data.in_digit_seq = in_digit_seq;\n#ifdef DEBUG_2833\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"read: %c %u %u %u %u %d %d %s\\n\",\n\t\t\t\t\t\t\t  key, in_digit_seq, rtp_session->dtmf_data.in_digit_seq,\n\t\t\t\t   ts, duration, rtp_session->last_rtp_hdr.m, end, end && !rtp_session->dtmf_data.in_digit_ts ? \"ignored\" : \"\");\n#endif\n\n\n\t\t\tif (rtp_session->dtmf_data.in_digit_ts && rtp_session->dtmf_data.in_digit_ts != ts) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, \"TS changed from last packet, resetting....\\n\");\n\t\t\t\trtp_session->dtmf_data.last_digit = 0;\n\t\t\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 0;\n\t\t\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\t\t}\n\n\n\t\t\tif (!rtp_session->dtmf_data.in_digit_queued && rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION)) {\n\t\t\t\t\tswitch_dtmf_t dtmf = { key, switch_core_min_dtmf_duration(0), 0, SWITCH_DTMF_RTP };\n#ifdef DEBUG_2833\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Early Queuing digit %c:%d\\n\", dtmf.digit, dtmf.duration / 8);\n#endif\n\t\t\t\t\tswitch_rtp_queue_rfc2833_in(rtp_session, &dtmf);\n\t\t\t\t\trtp_session->dtmf_data.in_digit_queued = 1;\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->jb && (rtp_session->rtp_bugs & RTP_BUG_FLUSH_JB_ON_DTMF)) {\n\t\t\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* only set sanity if we do NOT ignore the packet */\n\t\t\tif (rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 2000;\n\t\t\t}\n\n\t\t\tif (rtp_session->dtmf_data.last_duration > duration &&\n\t\t\t\trtp_session->dtmf_data.last_duration > 0xFC17 && ts == rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\trtp_session->dtmf_data.flip++;\n\t\t\t}\n\n\t\t\tif (end) {\n\t\t\t\tif (!rtp_session->dtmf_data.in_digit_ts && rtp_session->dtmf_data.last_in_digit_ts != ts) {\n#ifdef DEBUG_2833\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"start with end packet %d\\n\", ts);\n#endif\n\t\t\t\t\trtp_session->dtmf_data.last_in_digit_ts = ts;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_ts = ts;\n\t\t\t\t\trtp_session->dtmf_data.first_digit = key;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 2000;\n\t\t\t\t}\n\t\t\t\tif (rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\t\tswitch_dtmf_t dtmf = { key, duration, 0, SWITCH_DTMF_RTP };\n\n\t\t\t\t\tif (ts > rtp_session->dtmf_data.in_digit_ts) {\n\t\t\t\t\t\tdtmf.duration += (ts - rtp_session->dtmf_data.in_digit_ts);\n\t\t\t\t\t}\n\t\t\t\t\tif (rtp_session->dtmf_data.flip) {\n\t\t\t\t\t\tdtmf.duration += rtp_session->dtmf_data.flip * 0xFFFF;\n\t\t\t\t\t\trtp_session->dtmf_data.flip = 0;\n#ifdef DEBUG_2833\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"you're welcome!\\n\");\n#endif\n\t\t\t\t\t}\n#ifdef DEBUG_2833\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"done digit=%c ts=%u start_ts=%u dur=%u ddur=%u\\n\",\n\t\t\t\t\t\t   dtmf.digit, ts, rtp_session->dtmf_data.in_digit_ts, duration, dtmf.duration);\n#endif\n\n\t\t\t\t\tif (!(rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION) && !rtp_session->dtmf_data.in_digit_queued) {\n#ifdef DEBUG_2833\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Queuing digit %c:%d\\n\", dtmf.digit, dtmf.duration / 8);\n#endif\n\t\t\t\t\t\tswitch_rtp_queue_rfc2833_in(rtp_session, &dtmf);\n\t\t\t\t\t}\n\n\t\t\t\t\trtp_session->dtmf_data.last_digit = rtp_session->dtmf_data.first_digit;\n\n\t\t\t\t\trtp_session->dtmf_data.in_digit_ts = 0;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 0;\n\t\t\t\t\trtp_session->dtmf_data.in_digit_queued = 0;\n\t\t\t\t\t*do_cng = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\t\t\t\treturn RESULT_GOTO_END;\n\t\t\t\t\t}\n\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\treturn RESULT_GOTO_RECVFROM;\n\t\t\t\t}\n\n\t\t\t} else if (!rtp_session->dtmf_data.in_digit_ts) {\n#ifdef DEBUG_2833\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"start %d [%c]\\n\", ts, key);\n#endif\n\t\t\t\trtp_session->dtmf_data.in_digit_ts = ts;\n\t\t\t\trtp_session->dtmf_data.last_in_digit_ts = ts;\n\t\t\t\trtp_session->dtmf_data.first_digit = key;\n\t\t\t\trtp_session->dtmf_data.in_digit_sanity = 2000;\n\t\t\t}\n\n\t\t\trtp_session->dtmf_data.last_duration = duration;\n\t\t} else {\n#ifdef DEBUG_2833\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"drop: %c %u %u %u %u %d %d\\n\",\n\t\t\t\t   key, in_digit_seq, rtp_session->dtmf_data.in_digit_seq, ts, duration, rtp_session->last_rtp_hdr.m, end);\n#endif\n\t\t\tswitch_cond_next();\n\t\t\treturn RESULT_GOTO_RECVFROM;\n\t\t}\n\t}\n\n\tif (rtp_session->dtmf_data.in_digit_ts) {\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\treturn RESULT_GOTO_END;\n\t\t}\n\n\t\tif (!rtp_session->dtmf_data.in_interleaved && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te) {\n\t\t\t/* Drat, they are sending audio still as well as DTMF ok fine..... *sigh* */\n\t\t\trtp_session->dtmf_data.in_interleaved = 1;\n\t\t}\n\n\t\tif (rtp_session->dtmf_data.in_interleaved || (rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION)) {\n\t\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\t\t\treturn RESULT_GOTO_RECVFROM;\n\t\t\t}\n\t\t} else {\n\t\t\t*do_cng = 1;\n\t\t\treturn RESULT_GOTO_TIMERCHECK;\n\t\t}\n\t}\n\n\treturn RESULT_CONTINUE;\n}\n\nstatic int rtp_write_ready(switch_rtp_t *rtp_session, uint32_t bytes, int line);\nstatic int global_init = 0;\nstatic int rtp_common_write(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\trtp_msg_t *send_msg, void *data, uint32_t datalen, switch_payload_t payload, uint32_t timestamp, switch_frame_flag_t *flags);\n\n\n#define MEDIA_TOO_LONG 2000\n#define STUN_TOO_LONG 20000\n#define ADJ_TOO_LONG 1000\n\nstatic void calc_elapsed(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice)\n{\n\tswitch_time_t ref_point;\n\tswitch_time_t now;\n\n\tnow = switch_micro_time_now();\n\n\tif (ice->last_ok && (!rtp_session->dtls || rtp_session->dtls->state == DS_READY)) {\n\t\tref_point = ice->last_ok;\n\t} else {\n\t\tref_point = rtp_session->first_stun;\n\t}\n\n\tif (!ref_point) ref_point = now;\n\n\trtp_session->elapsed_stun = (unsigned int) ((now - ref_point) / 1000);\n\n\tif (rtp_session->last_media) {\n\t\trtp_session->elapsed_media = (unsigned int) ((now - rtp_session->last_media) / 1000);\n\t} else {\n\t\trtp_session->elapsed_media = MEDIA_TOO_LONG + 1;\n\t}\n\n\tif (rtp_session->last_adj) {\n\t\trtp_session->elapsed_adj = (unsigned int) ((now - rtp_session->last_adj) / 1000);\n\t} else {\n\t\trtp_session->elapsed_adj = ADJ_TOO_LONG + 1;\n\t}\n}\n\nstatic switch_status_t ice_out(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice, switch_bool_t force)\n{\n\tuint8_t buf[256] = { 0 };\n\tswitch_stun_packet_t *packet;\n\tunsigned int elapsed;\n\tswitch_size_t bytes;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\t//switch_sockaddr_t *remote_addr = rtp_session->remote_addr;\n\tswitch_socket_t *sock_output = rtp_session->sock_output;\n\tswitch_time_t now = switch_micro_time_now();\n\n\tif (ice->type & ICE_LITE) {\n\t\t// no connectivity checks for ICE-Lite\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tif (!force && ice->next_run && ice->next_run >= now) {\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tice->next_run = now + RTP_STUN_FREQ;\n\n\tif (ice == &rtp_session->rtcp_ice && rtp_session->rtcp_sock_output) {\n\t\tsock_output = rtp_session->rtcp_sock_output;\n\t}\n\n\tif (!sock_output) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_assert(rtp_session != NULL);\n\tswitch_assert(ice->ice_user != NULL);\n\n\tREAD_INC(rtp_session);\n\n\tif (rtp_session->last_stun) {\n\t\telapsed = (unsigned int) ((switch_micro_time_now() - rtp_session->last_stun) / 1000);\n\n\t\tif (elapsed > 30000) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"No %s stun for a long time!\\n\", rtp_type(rtp_session));\n\t\t\trtp_session->last_stun = switch_micro_time_now();\n\t\t\t//status = SWITCH_STATUS_GENERR;\n\t\t\t//goto end;\n\t\t}\n\t}\n\n\tpacket = switch_stun_packet_build_header(SWITCH_STUN_BINDING_REQUEST, NULL, buf);\n\tswitch_stun_packet_attribute_add_username(packet, ice->ice_user, (uint16_t)strlen(ice->ice_user));\n\n\tmemcpy(ice->last_sent_id, packet->header.id, 12);\n\n\t//if (ice->pass && ice->type == ICE_GOOGLE_JINGLE) {\n\t//\tswitch_stun_packet_attribute_add_password(packet, ice->pass, (uint16_t)strlen(ice->pass));\n\t//}\n\n\tif ((ice->type & ICE_VANILLA)) {\n\t\tchar sw[128] = \"\";\n\n\t\tswitch_stun_packet_attribute_add_priority(packet, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].priority);\n\n\t\tswitch_snprintf(sw, sizeof(sw), \"FreeSWITCH (%s)\", switch_version_revision_human());\n\t\tswitch_stun_packet_attribute_add_software(packet, sw, (uint16_t)strlen(sw));\n\n\t\tif ((ice->type & ICE_CONTROLLED)) {\n\t\t\tswitch_stun_packet_attribute_add_controlled(packet);\n\t\t} else {\n\t\t\tswitch_stun_packet_attribute_add_controlling(packet);\n\t\t\tswitch_stun_packet_attribute_add_use_candidate(packet);\n\t\t}\n\n\t\tswitch_stun_packet_attribute_add_integrity(packet, ice->rpass);\n\t\tswitch_stun_packet_attribute_add_fingerprint(packet);\n\t}\n\n\n\tbytes = switch_stun_packet_length(packet);\n\n#ifdef DEBUG_EXTRA\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"%s send %s stun\\n\", rtp_session_name(rtp_session), rtp_type(rtp_session));\n#endif\n\tswitch_socket_sendto(sock_output, ice->addr, 0, (void *) packet, &bytes);\n\n\tice->sending = 3;\n\n\t// end:\n\tREAD_DEC(rtp_session);\n\n\treturn status;\n}\n\nint icecmp(const char *them, switch_rtp_ice_t *ice)\n{\n\tif (strchr(them, ':')) {\n\t\treturn strcmp(them, ice->user_ice);\n\t}\n\n\treturn strcmp(them, ice->luser_ice);\n}\n\nstatic void handle_ice(switch_rtp_t *rtp_session, switch_rtp_ice_t *ice, void *data, switch_size_t len)\n{\n\tswitch_stun_packet_t *packet;\n\tswitch_stun_packet_attribute_t *attr;\n\tvoid *end_buf;\n\tchar username[STUN_USERNAME_MAX_SIZE] = { 0 };\n\tunsigned char buf[1500] = { 0 };\n\tswitch_size_t cpylen = len;\n\tint xlen = 0;\n\tint ok = 1;\n\tuint32_t *pri = NULL;\n\tint is_rtcp = ice == &rtp_session->rtcp_ice;\n\tswitch_channel_t *channel;\n\tint i;\n\tswitch_sockaddr_t *from_addr = rtp_session->from_addr;\n\tconst char *from_host = NULL;\n\tswitch_port_t from_port = 0;\n\tchar faddr_buf[80] = \"\";\n\n\tif (is_rtcp) {\n\t\tfrom_addr = rtp_session->rtcp_from_addr;\n\t}\n\n\tfrom_host = switch_get_addr(faddr_buf, sizeof(faddr_buf), from_addr);\n\tfrom_port = switch_sockaddr_get_port(from_addr);\n\n\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t//\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF OK %s CALL\\n\", rtp_type(rtp_session));\n\t//}\n\n\tif (!switch_rtp_ready(rtp_session) || zstr(ice->user_ice) || zstr(ice->ice_user)) {\n\t\treturn;\n\t}\n\n\tREAD_INC(rtp_session);\n\tWRITE_INC(rtp_session);\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\tgoto end;\n\t}\n\n\tif (cpylen > sizeof(buf)) {\n\t\tcpylen = sizeof(buf);\n\t}\n\n\tchannel = switch_core_session_get_channel(rtp_session->session);\n\n\tmemcpy(buf, data, cpylen);\n\tpacket = switch_stun_packet_parse(buf, (uint32_t)cpylen);\n\tif (!packet) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Invalid STUN/ICE packet received %ld bytes\\n\", (long)cpylen);\n\t\tgoto end;\n\n\t}\n\n\trtp_session->last_stun = switch_micro_time_now();\n\n\tif (!rtp_session->first_stun) {\n\t\trtp_session->first_stun = rtp_session->last_stun;\n\t}\n\n\tcalc_elapsed(rtp_session, ice);\n\n\tend_buf = buf + ((sizeof(buf) > packet->header.length) ? packet->header.length : sizeof(buf));\n\n\tswitch_stun_packet_first_attribute(packet, attr);\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"%s STUN PACKET TYPE: %s\\n\",\n\t\t\t\t\t  rtp_type(rtp_session), switch_stun_value_to_name(SWITCH_STUN_TYPE_PACKET_TYPE, packet->header.type));\n\tdo {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|---: %s STUN ATTR %d %x %s\\n\", rtp_type(rtp_session), attr->type, attr->type,\n\t\t\t\t\t\t  switch_stun_value_to_name(SWITCH_STUN_TYPE_ATTRIBUTE, attr->type));\n\n\t\tswitch (attr->type) {\n\t\tcase SWITCH_STUN_ATTR_USE_CAND:\n\t\t\t{\n\t\t\t\tice->rready = 1;\n\t\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host) && ice->ice_params->cands[i][ice->proto].con_port == from_port) {\n\t\t\t\t\t\tice->ice_params->cands[i][ice->proto].use_candidate = 1;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, \"Got USE-CANDIDATE on %s:%d\\n\", ice->ice_params->cands[i][ice->proto].con_addr, ice->ice_params->cands[i][ice->proto].con_port);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_ERROR_CODE:\n\t\t\t{\n\t\t\t\tswitch_stun_error_code_t *err = (switch_stun_error_code_t *) attr->value;\n\t\t\t\tuint32_t code = (err->code * 100) + err->number;\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s got %s stun binding response %u\\n\",\n\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t\t\t\t  code\n\t\t\t\t\t\t\t\t  );\n\n\t\t\t\tif ((ice->type & ICE_VANILLA) && code == 487) {\n\t\t\t\t\tif ((ice->type & ICE_CONTROLLED)) {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s STUN Changing role to CONTROLLING\\n\", rtp_type(rtp_session));\n\t\t\t\t\t\tice->type &= ~ICE_CONTROLLED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s STUN Changing role to CONTROLLED\\n\", rtp_type(rtp_session));\n\t\t\t\t\t\tice->type |= ICE_CONTROLLED;\n\t\t\t\t\t}\n\t\t\t\t\tpacket->header.type = SWITCH_STUN_BINDING_RESPONSE;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_MAPPED_ADDRESS:\n\t\t\t{\n\t\t\t\tchar ip[50];\n\t\t\t\tuint16_t port;\n\t\t\t\tswitch_stun_packet_attribute_get_mapped_address(attr, ip, sizeof(ip), &port);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %s:%d\\n\", ip, port);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_XOR_MAPPED_ADDRESS:\n\t\t\t{\n\t\t\t\tchar ip[50];\n\t\t\t\tuint16_t port;\n\t\t\t\tswitch_stun_packet_attribute_get_xor_mapped_address(attr, &packet->header, ip, sizeof(ip), &port);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %s:%d\\n\", ip, port);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SWITCH_STUN_ATTR_USERNAME:\n\t\t\t{\n\t\t\t\tswitch_stun_packet_attribute_get_username(attr, username, sizeof(username));\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %s\\n\", username);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SWITCH_STUN_ATTR_PRIORITY:\n\t\t\t{\n\t\t\t\tuint32_t priority = 0;\n\t\t\t\tpri = (uint32_t *) attr->value;\n\t\t\t\tpriority = ntohl(*pri);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG8, \"|------: %u\\n\", priority);\n\t\t\t\tok = priority == ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].priority;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!switch_stun_packet_next_attribute(attr, end_buf)) {\n\t\t\tbreak;\n\t\t}\n\n\t\txlen += 4 + switch_stun_attribute_padded_length(attr);\n\t} while (xlen <= packet->header.length);\n\n\tif ((ice->type & ICE_GOOGLE_JINGLE) && ok) {\n\t\tok = !strcmp(ice->user_ice, username);\n\t}\n\n\tif (packet->header.type != SWITCH_STUN_BINDING_REQUEST && packet->header.type != SWITCH_STUN_BINDING_RESPONSE) {\n\t\tgoto end;\n\t}\n\n\tif ((ice->type & ICE_VANILLA)) {\n\t\tif (!ok) ok = !memcmp(packet->header.id, ice->last_sent_id, 12);\n\n\t\tif (packet->header.type == SWITCH_STUN_BINDING_RESPONSE) {\n\t\t\tok = 1;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\trtp_session->ice.rready = 1;\n\t\t\t\trtp_session->rtcp_ice.rready = 1;\n\t\t\t} else {\n\t\t\t\tice->rready = 1;\n\t\t\t}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, \"Received STUN Binding Response from %s\\n\", from_host);\n\n\t\t\tif (ice->ice_params) {\n\t\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host) && ice->ice_params->cands[i][ice->proto].con_port == from_port) {\n\t\t\t\t\t\tice->ice_params->cands[i][ice->proto].responsive = 1;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"Marked ICE candidate %s:%d as responsive\\n\", ice->ice_params->cands[i][ice->proto].con_addr, ice->ice_params->cands[i][ice->proto].con_port);\n\t\t\t\t\t\tif (!strcmp(ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, from_host) && ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port == from_port) {\n\t\t\t\t\t\t\tice->cand_responsive = 1;\n\t\t\t\t\t\t\tice->initializing = 0;\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"Chosen ICE candidate %s:%d is responsive\\n\", ice->ice_params->cands[i][ice->proto].con_addr, ice->ice_params->cands[i][ice->proto].con_port);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\t\tswitch_core_session_video_reinit(rtp_session->session);\n\t\t\t}\n\t\t}\n\n\t\tif (!ok && ice == &rtp_session->ice && rtp_session->rtcp_ice.ice_params && pri &&\n\t\t\t*pri == rtp_session->rtcp_ice.ice_params->cands[rtp_session->rtcp_ice.ice_params->chosen[1]][1].priority) {\n\t\t\tice = &rtp_session->rtcp_ice;\n\t\t\tok = 1;\n\t\t}\n\n\t\tif (!zstr(username)) {\n\t\t\tif (!icecmp(username, ice)) {\n\t\t\t\tok = 1;\n\t\t\t} else if(!zstr(rtp_session->rtcp_ice.user_ice) && !icecmp(username, &rtp_session->rtcp_ice)) {\n\t\t\t\tice = &rtp_session->rtcp_ice;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tice->missed_count = 0;\n\t\t} else {\n\t\t\tswitch_rtp_ice_t *icep[2] = { &rtp_session->ice, &rtp_session->rtcp_ice };\n\t\t\tswitch_port_t port = 0;\n\t\t\tchar *host = NULL;\n\n\t\t\tif (rtp_session->elapsed_stun > STUN_TOO_LONG && pri) {\n\t\t\t\tint i, j;\n\t\t\t\tuint32_t old;\n\t\t\t\t//const char *tx_host;\n\t\t\t\tconst char *old_host, *err = NULL;\n\t\t\t\t//char bufa[50];\n\t\t\t\tchar bufb[50];\n\t\t\t\tchar adj_port[6];\n\t\t\t\tswitch_channel_t *channel = NULL;\n\n\n\t\t\t\tice->missed_count++;\n\t\t\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"missed %d\\n\", ice->missed_count);\n\n\n\t\t\t\tif (rtp_session->session) {\n\t\t\t\t\tchannel = switch_core_session_get_channel(rtp_session->session);\n\t\t\t\t}\n\n\t\t\t\t//ice->ice_params->cands[ice->ice_params->chosen][ice->proto].priority;\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\tif (!icep[j] || !icep[j]->ice_params) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < icep[j]->ice_params->cand_idx[icep[j]->proto]; i++) {\n\t\t\t\t\t\tif (icep[j]->ice_params &&  icep[j]->ice_params->cands[i][icep[j]->proto].priority == *pri) {\n\t\t\t\t\t\t\tif (j == IPR_RTP) {\n\t\t\t\t\t\t\t\ticep[j]->ice_params->chosen[j] = i;\n\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Change candidate index to %d\\n\", i);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tice = icep[j];\n\t\t\t\t\t\t\tok = 1;\n\n\t\t\t\t\t\t\tif (j != IPR_RTP) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\told = rtp_session->remote_port;\n\n\t\t\t\t\t\t\t//tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->from_addr);\n\t\t\t\t\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\n\t\t\t\t\t\t\thost = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr;\n\t\t\t\t\t\t\tport = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port;\n\n\t\t\t\t\t\t\tif (!host || !port) {\n\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error setting remote host!\\n\");\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t\t\t  \"%s ICE Auto Changing port from %s:%u to %s:%u\\n\", rtp_type(rtp_session), old_host, old, host, port);\n\n\n\t\t\t\t\t\t\tif (channel) {\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_ip_reported\", switch_channel_get_variable(channel, \"remote_media_ip\"));\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_ip\", host);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"rtp_auto_adjust_ip\", host);\n\t\t\t\t\t\t\t\tswitch_snprintf(adj_port, sizeof(adj_port), \"%u\", port);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_port_reported\", switch_channel_get_variable(channel, \"remote_media_port\"));\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"remote_media_port\", adj_port);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"rtp_auto_adjust_port\", adj_port);\n\t\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"rtp_auto_candidate_adjust\", \"true\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trtp_session->auto_adj_used = 1;\n\n\n\t\t\t\t\t\t\tswitch_rtp_set_remote_address(rtp_session, host, port, 0, SWITCH_FALSE, &err);\n\t\t\t\t\t\t\tif (switch_sockaddr_info_get(&ice->addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS ||\n\t\t\t\t\t\t\t\t!ice->addr) {\n\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error setting remote host!\\n\");\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ice->missed_count > 5 && !(ice->type & ICE_GOOGLE_JINGLE)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"missed too many: %d, looking for new ICE dest.\\n\",\n\t\t\t\t\t\t  ice->missed_count);\n\t\tice->rready = 0;\n\t\tice->cand_responsive = 0;\n\t\tok = 1;\n\t}\n\n\n\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] || 1) {\n\t//\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF OK %s %d\\n\", rtp_type(rtp_session), ok);\n\t//}\n\n\tif (ok) {\n\t\tconst char *host2 = NULL;\n\t\tswitch_port_t port2 = 0;\n\t\tchar buf2[80] = \"\";\n\n\t\tif (packet->header.type == SWITCH_STUN_BINDING_REQUEST) {\n\t\t\tuint8_t stunbuf[512];\n\t\t\tswitch_stun_packet_t *rpacket;\n\t\t\tconst char *remote_ip;\n\t\t\tswitch_size_t bytes;\n\t\t\tchar ipbuf[50];\n\t\t\tswitch_socket_t *sock_output = rtp_session->sock_output;\n\t\t\tuint8_t do_adj = 0;\n\t\t\tswitch_time_t now = switch_micro_time_now();\n\t\t\tint cmp = 0;\n\t\t\tint cur_idx = -1, is_relay = 0, is_responsive = 0, use_candidate = 0;\n\n\t\t\tif (is_rtcp) {\n\t\t\t\tsock_output = rtp_session->rtcp_sock_output;\n\t\t\t}\n\n\t\t\tif (!ice->ready) {\n\t\t\t\tice->ready = 1;\n\t\t\t}\n\n\t\t\tmemset(stunbuf, 0, sizeof(stunbuf));\n\t\t\trpacket = switch_stun_packet_build_header(SWITCH_STUN_BINDING_RESPONSE, packet->header.id, stunbuf);\n\n\t\t\tif ((ice->type & ICE_GOOGLE_JINGLE)) {\n\t\t\t\tswitch_stun_packet_attribute_add_username(rpacket, username, (uint16_t)strlen(username));\n\t\t\t}\n\n\t\t\tremote_ip = switch_get_addr(ipbuf, sizeof(ipbuf), from_addr);\n\n\t\t\tswitch_stun_packet_attribute_add_xor_binded_address(rpacket, (char *) remote_ip, switch_sockaddr_get_port(from_addr), from_addr->family);\n\n\t\t\tif ((ice->type & ICE_VANILLA)) {\n\t\t\t\tswitch_stun_packet_attribute_add_integrity(rpacket, ice->pass);\n\t\t\t\tswitch_stun_packet_attribute_add_fingerprint(rpacket);\n\t\t\t}\n\n\t\t\tbytes = switch_stun_packet_length(rpacket);\n\n\t\t\thost2 = switch_get_addr(buf2, sizeof(buf2), ice->addr);\n\t\t\tport2 = switch_sockaddr_get_port(ice->addr);\n\t\t\tcmp = switch_cmp_addr(from_addr, ice->addr, SWITCH_FALSE);\n\n\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host) && ice->ice_params->cands[i][ice->proto].con_port == from_port) {\n\t\t\t\t\tif (!strcasecmp(ice->ice_params->cands[i][ice->proto].cand_type, \"relay\")) {\n\t\t\t\t\t\tis_relay = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ice->ice_params->cands[i][ice->proto].responsive) {\n\t\t\t\t\t\tis_responsive = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ice->ice_params->cands[i][ice->proto].use_candidate) {\n\t\t\t\t\t\tuse_candidate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5,\n\t\t\t\t\"%s %s STUN from %s:%d %s is_relay: %d is_responsive: %d use_candidate: %d ready: %d, rready: %d\\n\", switch_channel_get_name(channel), rtp_type(rtp_session), from_host, from_port, cmp ? \"EXPECTED\" : \"IGNORED\",\n\t\t\t\tis_relay, is_responsive, use_candidate, ice->ready, ice->rready);\n\n\t\t\tif (ice->initializing && !cmp) {\n\t\t\t\tif (!rtp_session->adj_window && (!ice->ready || !ice->rready || (!rtp_session->dtls || rtp_session->dtls->state != DS_READY))) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE set ADJUST window to 10 seconds on binding request from %s:%d (is_relay: %d, is_responsivie: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\trtp_session->adj_window = now + 10000000;\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->adj_window) {\n\t\t\t\t\tif (rtp_session->adj_window > now) {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE check: %d >= 3000 or window closed and not from relay on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", rtp_session->elapsed_stun, from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tif (!is_relay && (rtp_session->elapsed_stun >= 3000 || rtp_session->adj_window == (now + 10000000))) {\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 1 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trtp_session->adj_window = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE CHECK SAME IP DIFFT PORT %d %d on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\",ice->initializing, switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE), from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\tif (!do_adj && (switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE) || use_candidate)) {\n\t\t\t\t\tdo_adj++;\n\t\t\t\t\trtp_session->last_adj = now;\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 2 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cmp) {\n\t\t\t\tice->last_ok = now;\n\t\t\t} else if (!do_adj) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"ICE %d/%d dt:%d i:%d i2:%d cmp:%d\\n\", rtp_session->elapsed_stun, rtp_session->elapsed_media, (rtp_session->dtls && rtp_session->dtls->state != DS_READY), !ice->ready, !ice->rready, switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE));\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST ELAPSED vs 1000 %d on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\" ,rtp_session->elapsed_adj, from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\tif (rtp_session->elapsed_adj > 1000) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE IF DTLS NOT READY or %d >= 3000 or media too long %d or stun too long %d on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", rtp_session->elapsed_stun, rtp_session->elapsed_media >= MEDIA_TOO_LONG,\n\t\t\t\t\t\trtp_session->elapsed_stun >= STUN_TOO_LONG, from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\tif (!is_relay && ((rtp_session->dtls && rtp_session->dtls->state != DS_READY) ||\n\t\t\t\t\t\t((!ice->ready || !ice->rready) && (rtp_session->elapsed_stun >= 3000 || switch_cmp_addr(from_addr, ice->addr, SWITCH_TRUE))))) {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 3 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t} else if (is_relay && ice->initializing && rtp_session->elapsed_stun >= 1000) {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 4 (FLIP TO TURN) on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t} else if ((ice->initializing && rtp_session->elapsed_stun >= 3000) ||\n\t\t\t\t\t\t(rtp_session->elapsed_media >= MEDIA_TOO_LONG || rtp_session->elapsed_stun >= STUN_TOO_LONG)) {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"%s %s %s ICE ADJUST HIT 5 on binding request from %s:%d (is_relay: %d, is_responsive: %d, use_candidate: %d) Current cand: %s:%d typ: %s\\n\",\n\t\t\t\t\t\t\tswitch_channel_get_name(channel), rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\", from_host, from_port, is_relay, is_responsive, use_candidate,\n\t\t\t\t\t\t\tice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port, ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].cand_type);\n\n\t\t\t\t\t\tdo_adj++;\n\t\t\t\t\t\trtp_session->last_adj = now;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < ice->ice_params->cand_idx[ice->proto]; i++) {\n\t\t\t\t\t\tif (!strcmp(ice->ice_params->cands[i][ice->proto].con_addr, from_host)) {\n\t\t\t\t\t\t\tcur_idx = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ice->type & ICE_VANILLA) && ice->ice_params && do_adj) {\n\t\t\t\tice->missed_count = 0;\n\t\t\t\tice->rready = 1;\n\n\t\t\t\tif (cur_idx > -1) {\n\t\t\t\t\tice->ice_params->chosen[ice->proto] = cur_idx;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_NOTICE,\n\t\t\t\t\t\t\t\t  \"Auto Changing %s stun/%s/dtls port from %s:%u to %s:%u idx:%d\\n\", rtp_type(rtp_session), is_rtcp ? \"rtcp\" : \"rtp\",\n\t\t\t\t\t\t\t\t  host2, port2,\n\t\t\t\t\t\t\t\t  from_host, from_port, cur_idx);\n\n\t\t\t\tswitch_rtp_change_ice_dest(rtp_session, ice, from_host, from_port);\n\n\t\t\t\tice->cand_responsive = is_responsive;\n\t\t\t\tif (ice->cand_responsive) {\n\t\t\t\t\tice->initializing = 0;\n\t\t\t\t}\n\n\t\t\t\tice->last_ok = now;\n\t\t\t}\n\t\t\t//if (cmp) {\n\t\t\tswitch_socket_sendto(sock_output, from_addr, 0, (void *) rpacket, &bytes);\n\t\t\t//}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, \"Send STUN Binding Response to %s:%u\\n\", from_host, from_port);\n\n\t\t\tif (ice->initializing && !is_responsive) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"Send STUN Binding Request on ICE candidate still unresponsive to %s:%u\\n\", from_host, from_port);\n\t\t\t\tif (ice_out(rtp_session, ice, SWITCH_TRUE) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Error sending STUN Binding Request on ICE candidate still unresponsive to %s:%u\\n\", from_host, from_port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (packet->header.type == SWITCH_STUN_BINDING_ERROR_RESPONSE) {\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_core_session_message_t msg = { 0 };\n\t\t\tmsg.from = __FILE__;\n\t\t\tmsg.numeric_arg = packet->header.type;\n\t\t\tmsg.pointer_arg = packet;\n\t\t\tmsg.message_id = SWITCH_MESSAGE_INDICATE_STUN_ERROR;\n\t\t\tswitch_core_session_receive_message(rtp_session->session, &msg);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"STUN/ICE binding error received on %s channel\\n\", rtp_type(rtp_session));\n\t\t}\n\n\t}\n\n\n\n\n end:\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\tWRITE_DEC(rtp_session);\n\tREAD_DEC(rtp_session);\n}\n\n\n#ifdef ENABLE_SRTP\nSWITCH_DECLARE(void) switch_srtp_err_to_txt(srtp_err_status_t stat, char **msg)\n{\n\tif (stat == srtp_err_status_replay_fail) *msg=\"replay check failed\";\n\telse if (stat == srtp_err_status_auth_fail) *msg=\"auth check failed\";\n\telse if (stat == srtp_err_status_fail) *msg=\"unspecified failure\";\n\telse if (stat == srtp_err_status_bad_param) *msg=\"unsupported parameter\";\n\telse if (stat == srtp_err_status_alloc_fail) *msg=\"couldn't allocate memory\";\n\telse if (stat == srtp_err_status_dealloc_fail) *msg=\"couldn't deallocate properly\";\n\telse if (stat == srtp_err_status_init_fail) *msg=\"couldn't initialize\";\n\telse if (stat == srtp_err_status_terminus) *msg=\"can't process as much data as requested\";\n\telse if (stat == srtp_err_status_cipher_fail) *msg=\"cipher failure\";\n\telse if (stat == srtp_err_status_replay_old) *msg=\"replay check failed\";\n\telse if (stat == srtp_err_status_algo_fail) *msg=\"algorithm failed test routine\";\n\telse if (stat == srtp_err_status_no_such_op) *msg=\"unsupported operation\";\n\telse if (stat == srtp_err_status_no_ctx) *msg=\"no appropriate context found\";\n\telse if (stat == srtp_err_status_cant_check) *msg=\"auth check failed\";\n\telse if (stat == srtp_err_status_key_expired) *msg=\"can't use key any more\";\n\telse if (stat == srtp_err_status_socket_err) *msg=\"error in use of socket\";\n\telse if (stat == srtp_err_status_signal_err) *msg=\"error in use POSIX signals\";\n\telse if (stat == srtp_err_status_nonce_bad) *msg=\"nonce check failed\";\n\telse if (stat == srtp_err_status_read_fail) *msg=\"couldn't read data\";\n\telse if (stat == srtp_err_status_write_fail) *msg=\"couldn't write data\";\n\telse if (stat == srtp_err_status_parse_err) *msg=\"error parsing data\";\n\telse if (stat == srtp_err_status_encode_err) *msg=\"error encoding data\";\n\telse if (stat == srtp_err_status_semaphore_err) *msg=\"error while using semaphores\";\n\telse if (stat == srtp_err_status_pfkey_err) *msg=\"error while using pfkey \";\n\telse if (stat == srtp_err_status_bad_mki) *msg=\"error MKI present in packet is invalid\";\n\telse if (stat == srtp_err_status_pkt_idx_old) *msg=\"packet index is too old to consider\";\n\telse if (stat == srtp_err_status_pkt_idx_adv) *msg=\"packet index advanced, reset needed\";\n\telse *msg=\"\";\n}\n#endif\n\nSWITCH_DECLARE(void) switch_rtp_init(switch_memory_pool_t *pool)\n{\n\tif (global_init) {\n\t\treturn;\n\t}\n\tswitch_core_hash_init(&alloc_hash);\n#ifdef ENABLE_SRTP\n\t{\n\t\tsrtp_err_status_t stat = srtp_init();\n\t\tif (stat == srtp_err_status_ok) { \n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, \"SRTP (%s) initialized.\\n\", srtp_get_version_string());\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Error initializing SRTP (%d).\\n\", stat);\n\t\t}\n\t}\n#endif\n\tswitch_mutex_init(&port_lock, SWITCH_MUTEX_NESTED, pool);\n\tswitch_rtp_dtls_init();\n\tglobal_init = 1;\n}\n\nstatic uint8_t get_next_write_ts(switch_rtp_t *rtp_session, uint32_t timestamp)\n{\n\tuint8_t m = 0, changed = 0;\n\n\tif (!(rtp_session->rtp_bugs & RTP_BUG_SEND_LINEAR_TIMESTAMPS)) {\n\t\tif (timestamp) {\n\t\t\trtp_session->ts = (uint32_t) timestamp;\n\t\t\tchanged++;\n\t\t} else if (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER)) {\n\t\t\tswitch_core_timer_next(&rtp_session->write_timer);\n\t\t\trtp_session->ts = rtp_session->write_timer.samplecount;\n\t\t\tchanged++;\n\t\t}\n\t}\n\n\tif (!changed) {\n\t\trtp_session->ts = rtp_session->last_write_ts + rtp_session->samples_per_interval;\n\t} else {\n\t\t/* Send marker bit if timestamp is lower/same as before (resetted/new timer) */\n\t\tif (abs((int32_t)(rtp_session->ts - rtp_session->last_write_ts)) > rtp_session->samples_per_interval \n\t\t\t&& !(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {\n\t\t\tm++;\n\t\t}\n\t}\n\n\treturn m;\n}\n\nstatic void do_mos(switch_rtp_t *rtp_session) {\n\tint R;\n\t\n\tif ((switch_size_t)rtp_session->stats.inbound.recved < rtp_session->stats.inbound.flaws) {\n\t\trtp_session->stats.inbound.flaws = 0;\n\t}\n\n\tif (rtp_session->stats.inbound.recved > 0 &&\n\t\trtp_session->stats.inbound.flaws && (rtp_session->stats.inbound.last_flaw != rtp_session->stats.inbound.flaws)) {\n\t\t\n\t\tif (rtp_session->consecutive_flaws++) {\n\t\t\tint penalty = rtp_session->consecutive_flaws;\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s %s %d consecutive flaws, adding %d flaw penalty\\n\",\n\t\t\t\t\t\t\t  rtp_session_name(rtp_session), rtp_type(rtp_session),\n\t\t\t\t\t\t\t  rtp_session->consecutive_flaws, penalty);\n\t\t\trtp_session->bad_stream++;\n\t\t\trtp_session->stats.inbound.flaws += penalty;\n\t\t\trtp_session->stats.inbound.last_flaw = rtp_session->stats.inbound.flaws;\n\t\t\t\n\t\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\t\trtp_session->stats.inbound.error_log->flaws += penalty;\n\t\t\t\trtp_session->stats.inbound.error_log->consecutive_flaws++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trtp_session->consecutive_flaws = 0;\n\t}\n\n\tR = (int)((double)((double)(rtp_session->stats.inbound.recved - rtp_session->stats.inbound.flaws) / (double)rtp_session->stats.inbound.recved) * 100.0);\n\n\tif (R < 0 || R > 100) R = 100;\n\n\trtp_session->stats.inbound.R = R;\n\trtp_session->stats.inbound.mos = 1 + (0.035) * R + (.000007) * R * (R-60) * (100-R);\n\t\t\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"%s %s stat %0.2f %ld/%d flaws: %ld mos: %0.2f v: %0.2f %0.2f/%0.2f\\n\",\n\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t  rtp_session->stats.inbound.R,\n\t\t\t\t\t  (long int)(rtp_session->stats.inbound.recved - rtp_session->stats.inbound.flaws), rtp_session->stats.inbound.recved,\n\t\t\t\t\t  (long int)rtp_session->stats.inbound.flaws,\n\t\t\t\t\t  rtp_session->stats.inbound.mos,\n\t\t\t\t\t  rtp_session->stats.inbound.variance,\n\t\t\t\t\t  rtp_session->stats.inbound.min_variance,\n\t\t\t\t\t  rtp_session->stats.inbound.max_variance\n\t\t\t\t\t  );\n\t\n}\n\nvoid burstr_calculate ( int loss[], int received, double *burstr, double *lossr )\n{\n\tint lost = 0;\n\tint bursts = 0;\n\tint i;\n\n\tfor ( i = 0; i < LOST_BURST_ANALYZE; i++ ) {\n\t\tlost += i * loss[i];\n\t\tbursts += loss[i];\n\t}\n\tif (received > 0 && bursts > 0) {\n\t\t*burstr = (double)((double)lost / (double)bursts) / (double)(1.0 / ( 1.0 - (double)lost / (double)received ));\n\t\tif (*burstr < 0) {\n\t\t\t*burstr = - *burstr;\n\t\t}\n\t} else {\n\t\t*burstr = 0;\n\t}\n\tif (received > 0) {\n\t\t*lossr = (double)((double)lost / (double)received);\n\t} else {\n\t\t*lossr = 0;\n\t}\n}\n\nstatic void reset_jitter_seq(switch_rtp_t *rtp_session)\n{\n\trtp_session->stats.inbound.last_proc_time = 0;\n\trtp_session->stats.inbound.last_processed_seq = 0;\n\trtp_session->jitter_lead = 0;\n\trtp_session->consecutive_flaws = 0;\n\trtp_session->stats.inbound.last_flaw = 0;\n}\n\nstatic void check_jitter(switch_rtp_t *rtp_session)\n{\n\tswitch_time_t current_time;\n\tint64_t diff_time = 0, cur_diff = 0;\n\tint seq;\n\n\tcurrent_time = switch_micro_time_now() / 1000;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_PAUSE] || rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] || rtp_session->dtmf_data.in_digit_ts) {\n\t\treset_jitter_seq(rtp_session);\n\t\treturn;\n\t}\n\n\tif (++rtp_session->jitter_lead < JITTER_LEAD_FRAMES || !rtp_session->stats.inbound.last_proc_time) {\n\t\trtp_session->stats.inbound.last_proc_time = current_time;\n\t\treturn;\n\t}\n\n\tdiff_time = (current_time - rtp_session->stats.inbound.last_proc_time);\n\tseq = (int)(uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\n\t/* Burst and Packet Loss */\n\trtp_session->stats.inbound.recved++;\n\n\tif (rtp_session->stats.inbound.last_processed_seq > 0 && seq > (int)(rtp_session->stats.inbound.last_processed_seq + 1)) {\n\t\tint lost = (seq - rtp_session->stats.inbound.last_processed_seq - 1);\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s Got: %s seq %d but expected: %d lost: %d\\n\",\n\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t\t  seq,\n\t\t\t\t\t\t  (rtp_session->stats.inbound.last_processed_seq + 1), lost);\n\t\trtp_session->stats.inbound.last_loss++;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t}\n\n\t\tif (rtp_session->stats.inbound.last_loss > 0 && rtp_session->stats.inbound.last_loss < LOST_BURST_CAPTURE) {\n\t\t\trtp_session->stats.inbound.loss[rtp_session->stats.inbound.last_loss] += lost;\n\t\t}\n\n\t\trtp_session->bad_stream++;\n\t\trtp_session->stats.inbound.flaws += lost;\n\n\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\trtp_session->stats.inbound.error_log->flaws += lost;\n\t\t}\n\n\t} else {\n\t\trtp_session->stats.inbound.last_loss = 0;\n\t}\n\n\trtp_session->stats.inbound.last_processed_seq = seq;\n\n\t/* Burst and Packet Loss */\n\n\tif (current_time > rtp_session->next_stat_check_time) {\n\t\trtp_session->next_stat_check_time = current_time + 5000;\n\t\tburstr_calculate(rtp_session->stats.inbound.loss, rtp_session->stats.inbound.recved,\n\t\t\t\t\t\t &(rtp_session->stats.inbound.burstrate), &(rtp_session->stats.inbound.lossrate));\n\t\tdo_mos(rtp_session);\n\t} else {\n\t\tdo_mos(rtp_session);\n\t}\n\n\tif (rtp_session->stats.inbound.last_loss || rtp_session->bad_stream) {\n\t\tif (rtp_session->session && (!rtp_session->stats.inbound.error_log || rtp_session->stats.inbound.error_log->stop)) {\n\t\t\tstruct error_period *error = switch_core_session_alloc(rtp_session->session, sizeof(*error));\n\t\t\terror->start = switch_micro_time_now();\n\t\t\terror->next = rtp_session->stats.inbound.error_log;\n\t\t\trtp_session->stats.inbound.error_log = error;\n\t\t}\n\n\t\tif (!rtp_session->stats.inbound.last_loss) {\n\t\t\tif (++rtp_session->recovering_stream > (rtp_session->one_second * 3)) {\n\t\t\t\tif (rtp_session->session && rtp_session->stats.inbound.error_log) {\n\t\t\t\t\trtp_session->stats.inbound.error_log->stop = switch_micro_time_now();\n\t\t\t\t}\n\n\t\t\t\trtp_session->bad_stream = 0;\n\t\t\t}\n\t\t} else {\n\t\t\trtp_session->recovering_stream = 0;\n\t\t\trtp_session->bad_stream++;\n\t\t}\n\t} else {\n\t\trtp_session->recovering_stream = 0;\n\t\trtp_session->clean_stream++;\n\t}\n\n\n\tif ( diff_time < 0 ) {\n\t\tdiff_time = -diff_time;\n\t}\n\n\trtp_session->stats.inbound.jitter_n++;\n\trtp_session->stats.inbound.jitter_add += diff_time;\n\n\tif (rtp_session->stats.inbound.mean_interval) {\n\t\tcur_diff = (int64_t)(diff_time - rtp_session->stats.inbound.mean_interval);\n\t} else {\n\t\tcur_diff = 0;\n\t}\n\n\trtp_session->stats.inbound.jitter_addsq += (cur_diff * cur_diff);\n\trtp_session->stats.inbound.last_proc_time = current_time;\n\n\tif (rtp_session->stats.inbound.jitter_n > 0) {\n\t\tdouble ipdv;\n\n\t\trtp_session->stats.inbound.mean_interval = (double)rtp_session->stats.inbound.jitter_add / (double)rtp_session->stats.inbound.jitter_n;\n\n\t\tif (!rtp_session->old_mean) {\n\t\t\trtp_session->old_mean = rtp_session->stats.inbound.mean_interval;\n\t\t}\n\n\t\trtp_session->stats.inbound.variance = (double)rtp_session->stats.inbound.jitter_addsq / (double)rtp_session->stats.inbound.jitter_n;\n\n\t\t//printf(\"CHECK %d +%ld +%ld %f %f\\n\", rtp_session->write_timer.samplecount, diff_time, (diff_time * diff_time), rtp_session->stats.inbound.mean_interval, rtp_session->stats.inbound.variance);\n\n\t\tipdv = rtp_session->old_mean - rtp_session->stats.inbound.mean_interval;\n\n\t\tif ( ipdv > IPDV_THRESHOLD ) { /* It shows Increasing Delays */\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG3, \"Calculated Instantaneous Packet Delay Variation: %s packet %lf\\n\",\n\t\t\t\t\t\t\t  rtp_type(rtp_session), ipdv);\n\t\t}\n\n\t\tif ( rtp_session->stats.inbound.variance < rtp_session->stats.inbound.min_variance || rtp_session->stats.inbound.min_variance == 0 ) {\n\t\t\trtp_session->stats.inbound.min_variance = rtp_session->stats.inbound.variance;\n\t\t}\n\n\t\tif ( rtp_session->stats.inbound.variance > rtp_session->stats.inbound.max_variance ) {\n\t\t\trtp_session->stats.inbound.max_variance = rtp_session->stats.inbound.variance;\n\t\t}\n\n\t\trtp_session->old_mean = rtp_session->stats.inbound.mean_interval;\n\t}\n}\n\nstatic void rtcp_generate_sender_info(switch_rtp_t *rtp_session, struct switch_rtcp_sender_info *sr){\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\tswitch_time_t now;\n\tuint32_t sec, ntp_sec, ntp_usec;\n\tswitch_time_exp_t now_hr;\n\tnow = switch_micro_time_now();\n\tsec = (uint32_t)(now/1000000);        /* convert to seconds     */\n\tntp_sec = sec+NTP_TIME_OFFSET;  /* convert to NTP seconds */\n\tsr->ntp_msw = htonl(ntp_sec);   /* store result in \"most significant word\" */\n\tntp_usec = (uint32_t)(now - (sec*1000000)); /* remove seconds to keep only the microseconds */\n\tsr->ntp_lsw = htonl((u_long)(ntp_usec*(double)(((uint64_t)1)<<32)*1.0e-6)); /* convert microseconds to fraction of 32bits and store result in \"least significatn word\" */\n\n\tsr->ts = htonl(rtp_session->last_write_ts);\n\tsr->pc = htonl(rtp_session->stats.outbound.packet_count);\n\tsr->oc = htonl(rtp_session->stats.outbound.raw_bytes - rtp_session->stats.outbound.packet_count * sizeof(srtp_hdr_t));\n\n\tswitch_time_exp_gmt(&now_hr,now);\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10,\"Sending an RTCP packet[%04d-%02d-%02d %02d:%02d:%02d.%d] lsr[%u] msw[%u] lsw[%u] stats_ssrc[%u] packet_count[%u] OC[%u]\\n\",\n\t\t\t1900 + now_hr.tm_year,  now_hr.tm_mday, now_hr.tm_mon, now_hr.tm_hour, now_hr.tm_min, now_hr.tm_sec, now_hr.tm_usec,\n\t\t\t(ntohl(sr->ntp_lsw)&0xffff0000)>>16 | (ntohl(sr->ntp_msw)&0x0000ffff)<<16,\n\t\t\tntohl(sr->ntp_msw),ntohl(sr->ntp_lsw), rtp_session->stats.rtcp.ssrc, ntohl(sr->pc), ntohl(sr->oc)\n\t\t\t);\n}\n\nstatic inline uint32_t calc_local_lsr_now(void)\n{\n\tswitch_time_t now;\n\tuint32_t ntp_sec, ntp_usec, lsr_now, sec;\n\tnow = switch_micro_time_now();\n\tsec = (uint32_t)(now/1000000);        /* convert to seconds     */\n\tntp_sec = sec+NTP_TIME_OFFSET;  /* convert to NTP seconds */\n\tntp_usec = (uint32_t)(now - ((switch_time_t) sec*1000000)); /* remove seconds to keep only the microseconds */\n\n\tlsr_now = (uint32_t)(ntp_usec*0.065536) | (ntp_sec&0x0000ffff)<<16; /* 0.065536 is used for convertion from useconds to fraction of 65536 (x65536/1000000) */\n\n\treturn lsr_now;\n}\n\n//#define DEBUG_RTCP\n/* extra param is for duplicates (received NACKed packets) */ \nstatic void rtcp_generate_report_block(switch_rtp_t *rtp_session, struct switch_rtcp_report_block *rtcp_report_block, \n\t\tint16_t extra_expected)\n{\n#ifdef DEBUG_RTCP\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n#endif\n\tswitch_rtcp_numbers_t * stats=&rtp_session->stats.rtcp;\n\tuint32_t expected_pkt, dlsr = 0;\n\tint32_t pkt_lost;\n\n\t/* Packet loss */\n\tif (stats->rtcp_rtp_count == 0) {\n\t\texpected_pkt = stats->high_ext_seq_recv - stats->base_seq + 1;\n\t} else {\n\t\texpected_pkt = stats->high_ext_seq_recv - stats->last_rpt_ext_seq + extra_expected;\n\t}\n\n\tpkt_lost = expected_pkt - stats->period_pkt_count;\n\tif (pkt_lost < 0) pkt_lost = 0;\n\n\tstats->cum_lost=stats->cum_lost+pkt_lost;\n\tif (expected_pkt > 0 && pkt_lost > 0) {\n\t\trtcp_report_block->fraction = (pkt_lost == expected_pkt ? 255 : (uint8_t) (pkt_lost * 256 / expected_pkt));             /* if X packets were expected and X was lost, we want 0xff to be reported, not 0 */\n\t} else {\n\t\trtcp_report_block->fraction = 0;\n\t}\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\trtcp_report_block->lost = stats->cum_lost;\n#else\n\t/* Reversing byte order for 24bits */\n\trtcp_report_block->lost = htonl(stats->cum_lost) >> 8;\n#endif\n\n#ifdef DEBUG_RTCP\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO])\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_CRIT, \"rtcp_generate_sr: stats_ssrc[%u]\\nreceived[%d]\\nexpected[%d]\\ncum[%d]\\nlost[%d|%d/256]pkt\\nlast_seq[%d]\\ncyc[%d]\\nlast_rpt_seq[%d]\\ncyc[%d]\\nssrc[%d]\\n\",\n\t\t\t\t\t\trtp_session->remote_ssrc, stats->period_pkt_count, expected_pkt,\n\t\t\t\t\t\tstats->cum_lost, pkt_lost, rtcp_report_block->fraction, stats->high_ext_seq_recv&0x0000ffff,\n\t\t\t\t\t\tstats->cycle, stats->last_rpt_ext_seq&0x0000ffff, stats->last_rpt_cycle, rtp_session->stats.rtcp.peer_ssrc\n\t\t\t\t\t\t);\n#endif\n\trtcp_report_block->highest_sequence_number_received = htonl(stats->high_ext_seq_recv);\n\n\t/* Jitter */\n\trtcp_report_block->jitter = htonl((uint32_t)stats->inter_jitter);\n\n\t/* Delay since Last Sender Report (DLSR) : 32bits, 1/65536 seconds */\n\tif (stats->last_recv_lsr_local) {\n\t\tuint32_t lsr_now = calc_local_lsr_now();\n\t\t/* check lsr_now: what we just read from clock may be in the past (race cond), don't send huge dlsr due to uint wrap around */\n\t\tif (lsr_now > stats->last_recv_lsr_local) {\n\t\t\tdlsr = lsr_now - stats->last_recv_lsr_local;\n\t\t}\n\t}\n\trtcp_report_block->lsr = stats->last_recv_lsr_peer;\n\trtcp_report_block->dlsr = htonl(dlsr);\n\tif (rtp_session->stats.rtcp.peer_ssrc) {\n\t\trtcp_report_block->ssrc = htonl(rtp_session->stats.rtcp.peer_ssrc);\n\t} else {\n\t\t/* if remote is not sending rtcp reports, take ssrc as assigned from rtp */\n\t\trtcp_report_block->ssrc = htonl(rtp_session->remote_ssrc);\n\t}\n\t\n\tstats->rtcp_rtp_count++;\n}\n\nstatic void rtcp_stats_init(switch_rtp_t *rtp_session)\n{\n\tswitch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;\n\tsrtp_hdr_t * hdr = &rtp_session->last_rtp_hdr;\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\tstats->ssrc = ntohl(hdr->ssrc);\n\tstats->last_rpt_ts = rtp_session->write_timer.samplecount;\n\tstats->init = 1;\n\tstats->last_rpt_ext_seq = 0;\n\tstats->last_rpt_cycle = 0;\n\tstats->last_pkt_tsdiff = 0;\n\tstats->inter_jitter = 0;\n\tstats->cycle = 0;\n\tstats->high_ext_seq_recv = ntohs((uint16_t)hdr->seq);\n\tstats->base_seq = ntohs((uint16_t)hdr->seq);\n\tstats->bad_seq = (1<<16) + 1; /* Make sure we wont missmatch 2 consecutive packets, so seq == bad_seq is false */\n\tstats->cum_lost = 0;\n\tstats->period_pkt_count = 0;\n\tstats->sent_pkt_count = 0;\n\tstats->pkt_count = 0;\n\tstats->rtcp_rtp_count = 0;\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats_init: %s rtcp disabled\\n\", rtp_type(rtp_session));\n\t} else if (!rtp_session->rtcp_sock_output) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_WARNING, \"rtcp_stats_init: %s no rtcp socket\\n\", rtp_type(rtp_session));\n\t} else if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU]) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats_init: %s rtcp passthru\\n\", rtp_type(rtp_session));\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats_init: %s ssrc[%u] base_seq[%u]\\n\", rtp_type(rtp_session), stats->ssrc, stats->base_seq);\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] && (switch_core_media_codec_get_cap(rtp_session->session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_MEDIA_TYPE_AUDIO, SWITCH_CODEC_FLAG_HAS_ADJ_BITRATE))) {\n\t\t\tkalman_estimator_t *estimators[KALMAN_SYSTEM_MODELS];\n\t\t\tcusum_kalman_detector_t *detectors[KALMAN_SYSTEM_MODELS];\n\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_ADJ_BITRATE_CAP] = 1;\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_ESTIMATORS] = 1;\n\n\t\t\trtp_session->estimators[EST_LOSS] = switch_core_alloc(rtp_session->pool, sizeof(*estimators[0]));\n\t\t\tswitch_kalman_init(rtp_session->estimators[EST_LOSS],0.1,0.1);\n\t\t\trtp_session->estimators[EST_RTT] = switch_core_alloc(rtp_session->pool, sizeof(*estimators[0]));\n\t\t\tswitch_kalman_init(rtp_session->estimators[EST_RTT],0.03,1);\n\t\t\trtp_session->detectors[EST_RTT] = switch_core_alloc(rtp_session->pool, sizeof(*detectors[0]));\n\t\t\tswitch_kalman_cusum_init(rtp_session->detectors[EST_RTT],0.005,0.5);\n\t\t\trtp_session->detectors[EST_LOSS] = switch_core_alloc(rtp_session->pool, sizeof(*detectors[0]));\n\t\t\tswitch_kalman_cusum_init(rtp_session->detectors[EST_LOSS], 0.5, 1);\n\t}\n}\n\nstatic int rtcp_stats(switch_rtp_t *rtp_session)\n{\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, \"__session\");\n\tsrtp_hdr_t * hdr = &rtp_session->last_rtp_hdr;\n\tswitch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;\n\tuint32_t packet_spacing_diff = 0, pkt_tsdiff, pkt_extended_seq;\n\tuint16_t pkt_seq, seq_diff, max_seq;\n\tconst int MAX_DROPOUT = 3000;\n\tconst int MAX_MISORDER = 100;\n\tconst int RTP_SEQ_MOD = (1<<16);\n\n\tif(!rtp_session->rtcp_sock_output || !rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] || rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] || !rtp_session->rtcp_interval)\n\t\treturn 0; /* do not process RTCP in current state */\n\n\tpkt_seq = (uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\n\t/* Detect sequence number cycle change */\n\tmax_seq = stats->high_ext_seq_recv&0x0000ffff;\n\tseq_diff = pkt_seq - max_seq;\n\n\tif (seq_diff < MAX_DROPOUT) {  /* in order, with permissible gap */\n\t\tif (pkt_seq < max_seq) {\n\t\t\tstats->cycle++;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"rtcp_stats:[cycle change] pkt_seq[%d] cycle[%d] max_seq[%d] stats_ssrc[%u] local_ts[%u]\\n\",\n\t\t\t\t\tpkt_seq, stats->cycle, max_seq, stats->ssrc, rtp_session->timer.samplecount);\n\t\t}\n\t\tpkt_extended_seq = stats->cycle << 16 | pkt_seq; /* getting the extended packet extended sequence ID */\n\t\tif (pkt_extended_seq > stats->high_ext_seq_recv) {\n\t\t\tstats->high_ext_seq_recv = pkt_extended_seq;\n\t\t}\n\t}\n\telse if (seq_diff <= (RTP_SEQ_MOD - MAX_MISORDER)) {   /* the sequence number made a very large jump */\n\t\tif (pkt_seq == stats->bad_seq) {\n\t\t\trtcp_stats_init(rtp_session);\n\t\t} else {\n\t\t\tstats->bad_seq = (pkt_seq + 1) & (RTP_SEQ_MOD-1);\n\t\t}\n\t\treturn 0; /* no stats, packet is out of sync and will be accounted as lost */\n\t} else {\n\t\t/* duplicate or reordered packet */\n\t}\n\n\t/* Verify that we are on the same stream source (we do not support multiple sources) */\n\tif (ntohl(hdr->ssrc) != stats->ssrc || !stats->init) {\n\t\trtcp_stats_init(rtp_session);\n\t}\n\n\tstats->period_pkt_count++;\n\tstats->pkt_count++;\n#ifdef DEBUG_RTCP\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10, \"rtcp_stats: period_pkt_count[%d]last_seq[%d]cycle[%d]stats_ssrc[%u]local_ts[%u]\\n\",\n\t\t\tstats->period_pkt_count, pkt_seq, stats->cycle, stats->ssrc, rtp_session->write_timer.samplecount);\n#endif\n\t/* Interarrival jitter calculation */\n\tpkt_tsdiff = abs((int32_t)(rtp_session->timer.samplecount - ntohl(hdr->ts)));  /* relative transit times for this packet */\n\tif (stats->pkt_count < 2) { /* Can not compute Jitter with only one packet */\n\t\tstats->last_pkt_tsdiff = pkt_tsdiff;\n\t} else {\n\t\t/* Jitter : difference of relative transit times for the two packets */\n\t\tpacket_spacing_diff = abs((int32_t)(pkt_tsdiff - stats->last_pkt_tsdiff));\n\t\tstats->last_pkt_tsdiff = pkt_tsdiff;\n\t\t/* Interarrival jitter estimation, \"J(i) = J(i-1) + ( |D(i-1,i)| - J(i-1) )/16\" */\n\t\tstats->inter_jitter = (stats->inter_jitter + (((double)packet_spacing_diff - stats->inter_jitter) /16.));\n\t}\n\n#ifdef DEBUG_RTCP\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10, \"rtcp_stats: pkt_ts[%d]local_ts[%d]diff[%d]pkt_spacing[%d]inter_jitter[%f]seq[%d]stats_ssrc[%d]\",\n\t\t\tntohl(hdr->ts), rtp_session->timer.samplecount, pkt_tsdiff, packet_spacing_diff, stats->inter_jitter, ntohs(hdr->seq), stats->ssrc);\n#endif\n\treturn 1;\n}\n\nstatic void calc_bw_exp(uint32_t bps, uint8_t bits, rtcp_tmmbx_t *tmmbx)\n{\n\tuint32_t mantissa_max, i = 0;\n\tuint8_t exp = 0;\n\tuint32_t mantissa = 0;\n\tuint16_t overhead = 60;\n\n\tswitch_assert(bits<=32);\n\n\tmantissa_max = (1 << bits) - 1;\n\n\tfor (i = 0; i < 32; ++i) {\n\t\tif (bps <= (mantissa_max << i)) {\n\t\t\texp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmantissa = (bps >> exp);\n\n\ttmmbx->parts[0] = (uint8_t) ((exp << 2) + ((mantissa >> 15) & 0x03));\n\ttmmbx->parts[1] = (uint8_t) (mantissa >> 7);\n\ttmmbx->parts[2] = (uint8_t) ((mantissa >> 1) + ((overhead >> 8) & 0x01));\n\ttmmbx->parts[3] = (uint8_t) (overhead);\n}\n\nstatic int using_ice(switch_rtp_t *rtp_session)\n{\n\tif (rtp_session->ice.ice_user || rtp_session->rtcp_ice.ice_user) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void switch_send_rtcp_event(switch_rtp_t *rtp_session ,struct switch_rtcp_sender_report *sr,struct switch_rtcp_report_block *rtcp_report_block)\n{\n\tif (sr && rtcp_report_block) {\n\t\tswitch_event_t *event;\n\n\t\tif (switch_event_create(&event, SWITCH_EVENT_SEND_RTCP_MESSAGE) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tchar value[30];\n\t\t\t\tchar header[50];\n\t\t\t\tuint32_t tmpLost;\n\t\t\t\tchar *uuid = switch_core_session_get_uuid(rtp_session->session);\n\t\t\t\tif (uuid) {\n\t\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Unique-ID\", switch_core_session_get_uuid(rtp_session->session));\n\t\t\t\t}\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%.8x\", rtp_session->stats.rtcp.ssrc);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"SSRC\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ntp_msw));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"NTP-Most-Significant-Word\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ntp_lsw));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"NTP-Least-Significant-Word\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ts));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"RTP-Timestamp\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.pc));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Sender-Packet-Count\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.oc));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Octect-Packet-Count\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(sr->sender_info.ts));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Last-RTP-Timestamp\", value);\n\n\t\t\t\tsnprintf(value, sizeof(value), \"%\" SWITCH_TIME_T_FMT, switch_time_now());\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Capture-Time\", value);\n\n\t\t\t\t/* Add sources info */\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-SSRC\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%.8x\", rtp_session->stats.rtcp.peer_ssrc);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Fraction\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", (uint8_t)rtcp_report_block->fraction);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Lost\");\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\t\t\t\ttmpLost = rtcp_report_block->lost; /* signed 24bit will extended signess to int32_t automatically */\n#else\n\t\t\t\ttmpLost = ntohl(rtcp_report_block->lost)>>8;\n\t\t\t\ttmpLost = tmpLost | ((tmpLost & 0x00800000) ? 0xff000000 : 0x00000000); /* ...and signess compensation */\n#endif\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", tmpLost);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Highest-Sequence-Number-Received\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->highest_sequence_number_received));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-Jitter\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->jitter));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-LSR\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->lsr));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\t\t\t\tsnprintf(header, sizeof(header), \"Source-DLSR\");\n\t\t\t\tsnprintf(value, sizeof(value), \"%u\", ntohl(rtcp_report_block->dlsr));\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, header, value);\n\n\t\t\t\tswitch_event_fire(&event);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"Dispatched RTCP SEND event\\n\");\n\t\t}\n\t}\n}\n\n#define MAX_NACK 10\nstatic int check_rtcp_and_ice(switch_rtp_t *rtp_session)\n{\n\tint ret = 0;\n\tint rtcp_ok = 0, rtcp_cyclic = 0, rtcp_fb = 0, force_send_rr = 0;\n\tswitch_time_t now = switch_micro_time_now();\n\tint rate = 0, nack_ttl = 0, nack_dup = 0; \n\tuint32_t cur_nack[MAX_NACK] = { 0 };\n\tuint16_t seq = 0;\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\trtp_session->flags[SWITCH_RTP_FLAG_AUTO_CNG] &&\n\t\trtp_session->send_msg.header.ts &&\n\t\trtp_session->cng_pt != INVALID_PT &&\n\t\t(rtp_session->write_timer.samplecount - rtp_session->last_write_samplecount >= rtp_session->samples_per_interval * 60)) {\n\t\tuint8_t data[10] = { 0 };\n\t\tswitch_frame_flag_t frame_flags = SFF_NONE;\n\t\tdata[0] = 65;\n\t\trtp_session->cn++;\n\n\t\tget_next_write_ts(rtp_session, 0);\n\t\trtp_session->send_msg.header.ts = htonl(rtp_session->ts);\n\n\t\tswitch_rtp_write_manual(rtp_session, (void *) data, 2, 0, rtp_session->cng_pt, ntohl(rtp_session->send_msg.header.ts), &frame_flags);\n\n\t\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER)) {\n\t\t\trtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;\n\t\t}\n\t}\n\n\trate = rtp_session->rtcp_interval;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && rtp_session->vb) {\n\t\tint n;\n\t\tfor (n = 0; n < MAX_NACK; n++) {\n\t\t\tuint32_t nack = switch_jb_pop_nack(rtp_session->vb);\n\n\t\t\tif (!nack) break;\n\n\t\t\tseq = ntohs(nack & 0xFFFF);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s Got NACK [%u][0x%x] for seq %u\\n\",\n\t\t\t\t\tswitch_core_session_get_name(rtp_session->session), nack, nack, seq);\n\n\t\t\tcur_nack[nack_ttl++] = nack;\n\t\t}\n\t\tif (nack_ttl) {\n\t\t\trtcp_ok = 1;\n\t\t\trtcp_fb = 1;\n\t\t}\n\t}\n\n\n\n\tif (rtp_session->rtcp_sent_packets < 4) {\n\t\trate = 4000;\n\t} else  {\n\t\tif (rtp_session->pli_count || rtp_session->fir_count || rtp_session->tmmbr || rtp_session->tmmbn) {\n\t\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"MARK BW/FIR ETC %d %d\\n\", rtp_session->pli_count, rtp_session->fir_count);\n\t\t\trtcp_ok = 1;\n\t\t\trtcp_fb = 1;\n\t\t}\n\t}\n\n\tif (rtp_session->send_rr) {\n\t\trtp_session->send_rr = 0;\n\t\trtcp_ok = 1;\n\t\tforce_send_rr = 1;\n\t}\n\n\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"TIME CHECK %d > %d\\n\", (int)((now - rtp_session->rtcp_last_sent) / 1000), rate);\n\n\tif (!rtcp_ok && (!rtp_session->rtcp_last_sent || (int)((now - rtp_session->rtcp_last_sent) / 1000) > rate)) {\n\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"TIME UP\\n\");\n\t\trtcp_cyclic = 1;\n\t\trtcp_ok = 1;\n\t}\n\n\tif (rtcp_ok && using_ice(rtp_session)) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\tif (!rtp_session->ice.rready) {\n\t\t\t\trtcp_ok = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!rtp_session->rtcp_ice.rready) {\n\t\t\t\trtcp_ok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"WTF %d %d %d %d\\n\", rate, rtp_session->rtcp_sent_packets, rtcp_ok, nack_ttl);\n\n\tif (rtp_session->rtcp_sock_output && rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] && !rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] && rtcp_ok) {\n\t\tswitch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;\n\t\tstruct switch_rtcp_receiver_report *rr;\n\t\tstruct switch_rtcp_sender_report *sr;\n\t\tstruct switch_rtcp_report_block *rtcp_report_block = NULL;\n\t\tswitch_size_t rtcp_bytes = sizeof(struct switch_rtcp_hdr_s)+sizeof(uint32_t); /* add size of the packet header and the ssrc */\n\t\tswitch_rtcp_hdr_t *sdes;\n\t\tuint8_t *p;\n\t\tswitch_size_t sdes_bytes = sizeof(struct switch_rtcp_hdr_s);\n\t\tuint32_t *ssrc;\n\t\tswitch_rtcp_sdes_unit_t *unit;\n\t\tswitch_bool_t is_only_receiver = FALSE;\n\n\t\tif (!rtcp_fb) {\n\t\t\trtp_session->rtcp_last_sent = now;\n\t\t\trtp_session->rtcp_sent_packets++;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && \n\t\t\t\trtp_session->vb && rtcp_cyclic) {\n\t\t\t\tnack_dup = rtp_session->prev_nacks_inflight;\n\t\t\t\trtp_session->prev_nacks_inflight = 0;\n\t\t}\n\n\t\trtp_session->rtcp_send_msg.header.version = 2;\n\t\trtp_session->rtcp_send_msg.header.p = 0;\n\n\t\tif ((switch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO) == SWITCH_MEDIA_FLOW_RECVONLY) ||\n\t\t\t\tswitch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO) == SWITCH_MEDIA_FLOW_RECVONLY) {\n\t\t\tis_only_receiver = TRUE;\n\t\t}\n\t\tif (!rtp_session->stats.rtcp.sent_pkt_count || is_only_receiver || force_send_rr) {\n\t\t\trtp_session->rtcp_send_msg.header.type = _RTCP_PT_RR; /* Receiver report */\n\t\t\trr=(struct switch_rtcp_receiver_report*) rtp_session->rtcp_send_msg.body;\n\t\t\trr->ssrc = htonl(rtp_session->ssrc);\n\t\t\trtcp_report_block = &rr->report_block;\n\t\t\trtcp_bytes += sizeof(struct switch_rtcp_report_block);\n\t\t\trtcp_generate_report_block(rtp_session, rtcp_report_block, nack_dup);\n\t\t\trtp_session->rtcp_send_msg.header.count = 1; /* reception report block count */\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Sending RTCP RR (ssrc=%u)\\n\", rtp_session->ssrc);\n\t\t} else {\n\t\t\tstruct switch_rtcp_sender_info *rtcp_sender_info;\n\t\t\trtp_session->rtcp_send_msg.header.type = _RTCP_PT_SR; /* Sender report */\n\t\t\tsr = (struct switch_rtcp_sender_report*) rtp_session->rtcp_send_msg.body;\n\t\t\tsr->ssrc = htonl(rtp_session->ssrc);\n\t\t\trtcp_sender_info = &sr->sender_info;\n\t\t\trtcp_generate_sender_info(rtp_session, rtcp_sender_info);\n\t\t\trtcp_bytes += sizeof(struct switch_rtcp_sender_info);\n\t\t\tif (!rtcp_cyclic && rtcp_fb) {\n\t\t\t\t /* rtcp-fb only, don't send receive report block */\n\t\t\t\trtp_session->rtcp_send_msg.header.count = 0;\n\t\t\t} else {\n\t\t\t\trtcp_report_block = &sr->report_block;\n\t\t\t\trtcp_bytes += sizeof(struct switch_rtcp_report_block);\n\t\t\t\trtcp_generate_report_block(rtp_session, rtcp_report_block, nack_dup);\n\t\t\t\trtp_session->rtcp_send_msg.header.count = 1; /* reception report block count */\n\t\t\t\tstats->sent_pkt_count = 0;\n\t\t\t\tif ((!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_AUDIO_FIRE_SEND_RTCP_EVENT]) ||\n\t\t\t\t\t(rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_VIDEO_FIRE_SEND_RTCP_EVENT])) {\n \t\t\t\t\tswitch_send_rtcp_event(rtp_session, sr, rtcp_report_block);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Sending RTCP SR (ssrc=%u)\\n\", rtp_session->ssrc);\n\t\t}\n\n\t\trtp_session->rtcp_send_msg.header.length = htons((uint16_t)(rtcp_bytes / 4) - 1);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tif (rtp_session->pli_count) {\n\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\n\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\text_hdr->version = 2;\n\t\t\t\text_hdr->p = 0;\n\t\t\t\text_hdr->fmt = _RTCP_PSFB_PLI;\n\t\t\t\text_hdr->pt = _RTCP_PT_PSFB;\n\n\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\text_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\trtp_session->rtcp_vstats.video_in.pli_count++;\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Sending RTCP PLI %u %u [%u]\\n\",\n\t\t\t\t\t\t\t\t  rtp_session->ssrc, rtp_session->remote_ssrc, rtp_session->rtcp_vstats.video_in.pli_count);\n\n\t\t\t\text_hdr->length = htons((uint8_t)(sizeof(switch_rtcp_ext_hdr_t) / 4) - 1);\n\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\trtp_session->pli_count = 0;\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && nack_ttl > 0) {\n\t\t\t\tint n = 0;\n\n\t\t\t\trtp_session->rtcp_vstats.video_in.nack_count++;\n\t\t\t\tfor (n = 0; n < nack_ttl; n++) {\n\t\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\t\t\t\t\tuint32_t *nack;\n\t\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\t\text_hdr->version = 2;\n\t\t\t\t\text_hdr->p = 0;\n\t\t\t\t\text_hdr->fmt = _RTCP_RTPFB_NACK;\n\t\t\t\t\text_hdr->pt = _RTCP_PT_RTPFB;\n\t\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\t\text_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\t\text_hdr->length = htons(3);\n\t\t\t\t\tp += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\t\tnack = (uint32_t *) p;\n\t\t\t\t\t*nack = cur_nack[n];\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP NACK %u [%d]\\n\",\n\t\t\t\t\t\t\t\t\t  ntohs(*nack & 0xFFFF), rtp_session->rtcp_vstats.video_in.nack_count);\n\n\t\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(cur_nack[n]);\n\t\t\t\t\tcur_nack[n] = 0;\n\t\t\t\t}\n\t\t\t\trtp_session->prev_nacks_inflight = n;\n\t\t\t}\n\n\t\t\tif (rtp_session->fir_count) {\n\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\t\t\t\trtcp_fir_t *fir;\n\n\t\t\t\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_OLD_FIR)) {\n\t\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\t\text_hdr->version = 2;\n\t\t\t\t\text_hdr->pt = _RTCP_PT_FIR;\n\t\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\t}\n\n\n\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\tp += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\tfir = (rtcp_fir_t *) p;\n\n\t\t\t\text_hdr->version = 2;\n\t\t\t\text_hdr->p = 0;\n\t\t\t\text_hdr->fmt = _RTCP_PSFB_FIR;\n\t\t\t\text_hdr->pt = _RTCP_PT_PSFB;\n\n\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\text_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);\n\n\t\t\t\tfir->ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\tfir->seq = rtp_session->fir_seq;\n\t\t\t\tfir->r1 = fir->r2 = fir->r3 = 0;\n\n\t\t\t\trtp_session->rtcp_vstats.video_in.fir_count++;\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP FIR SEQ %d [%u]\\n\", rtp_session->fir_seq, rtp_session->rtcp_vstats.video_in.fir_count);\n\n\t\t\t\trtp_session->fir_seq++;\n\n\t\t\t\text_hdr->length = htons((uint8_t)((sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_fir_t)) / 4) - 1);\n\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_fir_t);\n\t\t\t\trtp_session->fir_count = 0;\n\t\t\t}\n\n\t\t\t//if (!rtp_session->tmmbr && rtp_session->cur_tmmbr) {\n\t\t\t//\trtp_session->tmmbr = rtp_session->cur_tmmbr;\n\t\t\t//}\n\n\t\t\twhile (rtp_session->tmmbr || rtp_session->tmmbn) {\n\t\t\t\tswitch_rtcp_ext_hdr_t *ext_hdr;\n\t\t\t\trtcp_tmmbx_t *tmmbx;\n\t\t\t\tuint32_t bps = 0;\n\t\t\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\t\t\text_hdr = (switch_rtcp_ext_hdr_t *) p;\n\n\t\t\t\tp += sizeof(switch_rtcp_ext_hdr_t);\n\t\t\t\ttmmbx = (rtcp_tmmbx_t *) p;\n\n\t\t\t\text_hdr->version = 2;\n\t\t\t\text_hdr->p = 0;\n\t\t\t\text_hdr->pt = _RTCP_PT_RTPFB;\n\t\t\t\text_hdr->send_ssrc = htonl(rtp_session->ssrc);\n\t\t\t\text_hdr->recv_ssrc = 0;\n\n\t\t\t\tif (rtp_session->tmmbr) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP TMMBR %u\\n\", rtp_session->tmmbr);\n\t\t\t\t\text_hdr->fmt = _RTCP_RTPFB_TMMBR;\n\t\t\t\t\tbps = rtp_session->tmmbr;\n\t\t\t\t\trtp_session->tmmbr = 0;\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Sending RTCP TMMBN %u\\n\", rtp_session->tmmbr);\n\t\t\t\t\text_hdr->fmt = _RTCP_RTPFB_TMMBN;\n\t\t\t\t\tbps = rtp_session->tmmbn;\n\t\t\t\t\trtp_session->tmmbn = 0;\n\t\t\t\t}\n\n\t\t\t\ttmmbx->ssrc = htonl(rtp_session->remote_ssrc);\n\t\t\t\tcalc_bw_exp(bps, 17, tmmbx);\n\n\t\t\t\text_hdr->length = htons((uint8_t)((sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_tmmbx_t)) / 4) - 1);\n\t\t\t\trtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_tmmbx_t);\n\t\t\t}\n\n\t\t}\n\n\t\t//SDES + CNAME\n\t\tp = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;\n\t\tsdes = (switch_rtcp_hdr_t *) p;\n\t\tsdes->version = 2;\n\t\tsdes->type = _RTCP_PT_SDES;\n\t\tsdes->count = 1;\n\t\tsdes->p = 0;\n\t\tp = (uint8_t *) (sdes) + sdes_bytes;\n\t\tssrc = (uint32_t *) p;\n\t\t*ssrc = htonl(rtp_session->ssrc);\n\t\tsdes_bytes += sizeof(uint32_t);\n\n\n\t\tp = (uint8_t *) (sdes) + sdes_bytes;\n\t\tunit = (switch_rtcp_sdes_unit_t *) p;\n\t\tunit->type = _RTCP_SDES_CNAME;\n\t\tsnprintf((char *)unit->value, 80, \"%x\", rtp_session->ssrc);\n\t\tunit->length = strlen((char *)unit->value);\n\t\tsdes_bytes += sizeof(switch_rtcp_sdes_unit_t) + unit->length;\n\n\n\t\tp += sizeof(switch_rtcp_sdes_unit_t) + unit->length;\n\t\tunit = (switch_rtcp_sdes_unit_t *) p;\n\t\tunit->type = _RTCP_SDES_NOTE;\n\t\tsnprintf((char *)unit->value, 80, \"FreeSWITCH.org -- Come to ClueCon.com\");\n\t\tunit->length = strlen((char *)unit->value);\n\t\tsdes_bytes += sizeof(switch_rtcp_sdes_unit_t) + unit->length;\n\n\t\tsdes_bytes ++;//END\n\n\t\tsdes_bytes += 4 - (sdes_bytes % 4);\n\n\t\tsdes->length = htons((uint16_t)(sdes_bytes / 4) - 1);\n\t\trtcp_bytes += sdes_bytes;\n\n\t\t/* Prepare next report */\n\t\tif (rtp_session->rtcp_send_msg.header.count) {\n\t\t\tstats->last_rpt_cycle = stats->cycle;\n\t\t\tstats->last_rpt_ext_seq = stats->high_ext_seq_recv;\n\t\t\tstats->last_rpt_ts = rtp_session->write_timer.samplecount;\n\t\t\tstats->period_pkt_count = 0;\n\t\t}\n\n\n\n#ifdef ENABLE_SRTP\n\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\t\tint stat = 0;\n\t\t\tint sbytes = (int) rtcp_bytes;\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\tstat = srtp_protect_rtcp(rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_send_msg.header, &sbytes);\n\t\t\t} else {\n\t\t\t\tstat = srtp_protect_rtcp_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_send_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t}\n\n\t\t\tif (stat) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error: SRTP RTCP protection failed with code %d\\n\", stat);\n\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\tgoto end;\n\t\t\t} else {\n\t\t\t\trtcp_bytes = sbytes;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\n\t\t//#define DEBUG_EXTRA\n#ifdef DEBUG_EXTRA\n\t\t{\n\t\t\tconst char *old_host;\n\t\t\tchar bufb[50];\n\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->rtcp_remote_addr);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"%s SEND %s RTCP %s:%d %ld\\n\",\n\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t  rtp_type(rtp_session),\n\t\t\t\t\t\t\t  old_host,\n\t\t\t\t\t\t\t  switch_sockaddr_get_port(rtp_session->rtcp_remote_addr),\n\t\t\t\t\t\t\t  rtcp_bytes);\n\t\t}\n#endif\n\t\tif (switch_socket_sendto(rtp_session->rtcp_sock_output, rtp_session->rtcp_remote_addr, 0, (void *)&rtp_session->rtcp_send_msg, &rtcp_bytes ) != SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\"RTCP packet not written\\n\");\n\t\t} else {\n\t\t\trtp_session->stats.inbound.period_packet_count = 0;\n\t\t}\n\t}\n\n\tif (rtp_session->ice.ice_user) {\n\t\tif (ice_out(rtp_session, &rtp_session->ice, SWITCH_FALSE) == SWITCH_STATUS_GENERR) {\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\tif (rtp_session->rtcp_ice.ice_user) {\n\t\t\tif (ice_out(rtp_session, &rtp_session->rtcp_ice, SWITCH_FALSE) == SWITCH_STATUS_GENERR) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\n end:\n\n\treturn ret;\n}\n\nSWITCH_DECLARE(void) switch_rtp_ping(switch_rtp_t *rtp_session)\n{\n\tcheck_rtcp_and_ice(rtp_session);\n}\n\nSWITCH_DECLARE(void) switch_rtp_get_random(void *buf, uint32_t len)\n{\n#ifdef HAVE_OPENSSL\n\tRAND_bytes(buf, len);\n#else\n\tswitch_stun_random_string(buf, len, NULL);\n#endif\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_shutdown(void)\n{\n\tswitch_core_port_allocator_t *alloc = NULL;\n\tswitch_hash_index_t *hi;\n\tconst void *var;\n\tvoid *val;\n\n\tif (!global_init) {\n\t\treturn;\n\t}\n\n\tswitch_mutex_lock(port_lock);\n\n\tfor (hi = switch_core_hash_first(alloc_hash); hi; hi = switch_core_hash_next(&hi)) {\n\t\tswitch_core_hash_this(hi, &var, NULL, &val);\n\t\tif ((alloc = (switch_core_port_allocator_t *) val)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, \"Destroy port allocator for %s\\n\", (char *) var);\n\t\t\tswitch_core_port_allocator_destroy(&alloc);\n\t\t}\n\t}\n\n\tswitch_core_hash_destroy(&alloc_hash);\n\tswitch_mutex_unlock(port_lock);\n\n#ifdef ENABLE_SRTP\n\tsrtp_crypto_kernel_shutdown();\n#endif\n\tswitch_rtp_dtls_destroy();\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_set_start_port(switch_port_t port)\n{\n\tif (port) {\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_lock(port_lock);\n\t\t}\n\t\tSTART_PORT = port;\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_unlock(port_lock);\n\t\t}\n\t}\n\treturn START_PORT;\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_set_end_port(switch_port_t port)\n{\n\tif (port) {\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_lock(port_lock);\n\t\t}\n\t\tEND_PORT = port;\n\t\tif (port_lock) {\n\t\t\tswitch_mutex_unlock(port_lock);\n\t\t}\n\t}\n\treturn END_PORT;\n}\n\nSWITCH_DECLARE(void) switch_rtp_release_port(const char *ip, switch_port_t port)\n{\n\tswitch_core_port_allocator_t *alloc = NULL;\n\n\tif (!ip || !port) {\n\t\treturn;\n\t}\n\n\tswitch_mutex_lock(port_lock);\n\tif ((alloc = switch_core_hash_find(alloc_hash, ip))) {\n\t\tswitch_core_port_allocator_free_port(alloc, port);\n\t}\n\tswitch_mutex_unlock(port_lock);\n\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_request_port(const char *ip)\n{\n\tswitch_port_t port = 0;\n\tswitch_core_port_allocator_t *alloc = NULL;\n\n\tswitch_mutex_lock(port_lock);\n\talloc = switch_core_hash_find(alloc_hash, ip);\n\tif (!alloc) {\n\t\tif (switch_core_port_allocator_new(ip, START_PORT, END_PORT, SPF_EVEN, &alloc) != SWITCH_STATUS_SUCCESS) {\n\t\t\tabort();\n\t\t}\n\n\t\tswitch_core_hash_insert(alloc_hash, ip, alloc);\n\t}\n\n\tif (switch_core_port_allocator_request_port(alloc, &port) != SWITCH_STATUS_SUCCESS) {\n\t\tport = 0;\n\t}\n\n\tswitch_mutex_unlock(port_lock);\n\treturn port;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_payload_map(switch_rtp_t *rtp_session, payload_map_t **pmap)\n{\n\n\tif (rtp_session) {\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\trtp_session->pmaps = pmap;\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\treturn SWITCH_STATUS_SUCCESS;\n\t}\n\n\treturn SWITCH_STATUS_FALSE;\n}\n\nSWITCH_DECLARE(void) switch_rtp_intentional_bugs(switch_rtp_t *rtp_session, switch_rtp_bug_flag_t bugs)\n{\n\trtp_session->rtp_bugs = bugs;\n\n\tif ((rtp_session->rtp_bugs & RTP_BUG_START_SEQ_AT_ZERO)) {\n\t\trtp_session->seq = 0;\n\t}\n\n}\n\n\nstatic switch_status_t enable_remote_rtcp_socket(switch_rtp_t *rtp_session, const char **err) {\n\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_remote_addr, rtp_session->eff_remote_host_str, SWITCH_UNSPEC,\n\t\t\t\t\t\t\t\t\t rtp_session->remote_rtcp_port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !rtp_session->rtcp_remote_addr) {\n\t\t\t*err = \"RTCP Remote Address Error!\";\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t} else {\n\t\t\tconst char *host;\n\t\t\tchar bufa[50];\n\n\t\t\thost = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtcp_remote_addr);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"Setting RTCP remote addr to %s:%d %d\\n\", host, rtp_session->remote_rtcp_port, rtp_session->rtcp_remote_addr->family);\n\t\t}\n\n\t\tif (rtp_session->rtcp_sock_input && switch_sockaddr_get_family(rtp_session->rtcp_remote_addr) ==\n\t\t\tswitch_sockaddr_get_family(rtp_session->rtcp_local_addr)) {\n\t\t\trtp_session->rtcp_sock_output = rtp_session->rtcp_sock_input;\n\t\t} else {\n\n\t\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != rtp_session->rtcp_sock_input) {\n\t\t\t\tswitch_socket_close(rtp_session->rtcp_sock_output);\n\t\t\t}\n\n\t\t\tif ((status = switch_socket_create(&rtp_session->rtcp_sock_output,\n\t\t\t\t\t\t\t\t\t\t\t   switch_sockaddr_get_family(rtp_session->rtcp_remote_addr),\n\t\t\t\t\t\t\t\t\t\t\t   SOCK_DGRAM, 0, rtp_session->pool)) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t*err = \"RTCP Socket Error!\";\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t*err = \"RTCP NOT ACTIVE!\";\n\t}\n\n\treturn status;\n\n}\n\nstatic switch_status_t enable_local_rtcp_socket(switch_rtp_t *rtp_session, const char **err) {\n\n\tconst char *host = rtp_session->local_host_str;\n\tswitch_port_t port = rtp_session->local_port;\n\tswitch_socket_t *rtcp_new_sock = NULL, *rtcp_old_sock = NULL;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\tchar bufa[50];\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_local_addr, host, SWITCH_UNSPEC, port+1, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Local Address Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_socket_create(&rtcp_new_sock, switch_sockaddr_get_family(rtp_session->rtcp_local_addr), SOCK_DGRAM, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Socket Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_socket_opt_set(rtcp_new_sock, SWITCH_SO_REUSEADDR, 1) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Socket Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_socket_bind(rtcp_new_sock, rtp_session->rtcp_local_addr) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP Bind Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_from_addr, switch_get_addr(bufa, sizeof(bufa), rtp_session->from_addr),\n\t\t\t\t\t\t\t\t\t\t\t SWITCH_UNSPEC, switch_sockaddr_get_port(rtp_session->from_addr) + 1, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"RTCP From Address Error!\";\n\t\t\tgoto done;\n\t\t}\n\n\t\trtcp_old_sock = rtp_session->rtcp_sock_input;\n\t\trtp_session->rtcp_sock_input = rtcp_new_sock;\n\t\trtcp_new_sock = NULL;\n\n\t\tswitch_socket_create_pollset(&rtp_session->rtcp_read_pollfd, rtp_session->rtcp_sock_input, SWITCH_POLLIN | SWITCH_POLLERR, rtp_session->pool);\n\n done:\n\n\t\tif (*err) {\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error allocating rtcp [%s]\\n\", *err);\n\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\tif (rtcp_new_sock) {\n\t\t\tswitch_socket_close(rtcp_new_sock);\n\t\t}\n\n\t\tif (rtcp_old_sock) {\n\t\t\tswitch_socket_close(rtcp_old_sock);\n\t\t}\n\t} else {\n\t\tstatus = SWITCH_STATUS_FALSE;\n\t}\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_local_address(switch_rtp_t *rtp_session, const char *host, switch_port_t port, const char **err)\n{\n\tswitch_socket_t *new_sock = NULL, *old_sock = NULL;\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\tint j = 0;\n#ifndef WIN32\n\tchar o[5] = \"TEST\", i[5] = \"\";\n\tswitch_size_t len, ilen = 0;\n\tint x;\n#endif\n\n\tif (rtp_session->ready != 1) {\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\tREAD_INC(rtp_session);\n\t\tWRITE_INC(rtp_session);\n\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\n\t*err = NULL;\n\n\tif (zstr(host) || !port) {\n\t\t*err = \"Address Error\";\n\t\tgoto done;\n\t}\n\n\n\trtp_session->local_host_str = switch_core_strdup(rtp_session->pool, host);\n\trtp_session->local_port = port;\n\n\n\tif (switch_sockaddr_info_get(&rtp_session->local_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t*err = \"Local Address Error!\";\n\t\tgoto done;\n\t}\n\n\n\tif (rtp_session->sock_input) {\n\t\tswitch_rtp_kill_socket(rtp_session);\n\t}\n\n\tif (switch_socket_create(&new_sock, switch_sockaddr_get_family(rtp_session->local_addr), SOCK_DGRAM, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\t*err = \"Socket Error!\";\n\t\tgoto done;\n\t}\n\n\tif (switch_socket_opt_set(new_sock, SWITCH_SO_REUSEADDR, 1) != SWITCH_STATUS_SUCCESS) {\n\t\t*err = \"Socket Error!\";\n\t\tgoto done;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_RCVBUF, 1572864);\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_SNDBUF, 1572864);\n\t} else {\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_RCVBUF, 851968);\n\t\tswitch_socket_opt_set(new_sock, SWITCH_SO_SNDBUF, 851968);\n\t}\n\n\tif (switch_socket_bind(new_sock, rtp_session->local_addr) != SWITCH_STATUS_SUCCESS) {\n\t\tchar *em = switch_core_sprintf(rtp_session->pool, \"Bind Error! %s:%d\", host, port);\n\t\t*err = em;\n\t\tgoto done;\n\t}\n\n\n\tif ((j = atoi(host)) && j > 223 && j < 240) { /* mcast */\n\t\tif (switch_mcast_interface(new_sock, rtp_session->local_addr) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"Multicast Socket interface Error\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (switch_mcast_join(new_sock, rtp_session->local_addr, NULL, NULL) != SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"Multicast Error\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\tconst char *var;\n\n\t\t\tif ((var = switch_channel_get_variable(channel, \"multicast_ttl\"))) {\n\t\t\t\tint ttl = atoi(var);\n\n\t\t\t\tif (ttl > 0 && ttl < 256) {\n\t\t\t\t\tif (switch_mcast_hops(new_sock, (uint8_t) ttl) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t*err = \"Mutlicast TTL set failed\";\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n#ifndef WIN32\n\tlen = sizeof(i);\n\tswitch_socket_opt_set(new_sock, SWITCH_SO_NONBLOCK, TRUE);\n\n\tswitch_socket_sendto(new_sock, rtp_session->local_addr, 0, (void *) o, &len);\n\n\tx = 0;\n\twhile (!ilen) {\n\t\tswitch_status_t status;\n\t\tilen = len;\n\t\tstatus = switch_socket_recvfrom(rtp_session->from_addr, new_sock, 0, (void *) i, &ilen);\n\n\t\tif (status != SWITCH_STATUS_SUCCESS && status != SWITCH_STATUS_BREAK) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (++x > 1000) {\n\t\t\tbreak;\n\t\t}\n\t\tswitch_cond_next();\n\t}\n\tswitch_socket_opt_set(new_sock, SWITCH_SO_NONBLOCK, FALSE);\n\n#endif\n\n\told_sock = rtp_session->sock_input;\n\trtp_session->sock_input = new_sock;\n\tnew_sock = NULL;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] || rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] || rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t}\n\n\tswitch_socket_create_pollset(&rtp_session->read_pollfd, rtp_session->sock_input, SWITCH_POLLIN | SWITCH_POLLERR, rtp_session->pool);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tif ((status = enable_local_rtcp_socket(rtp_session, err)) == SWITCH_STATUS_SUCCESS) {\n\t\t\t*err = \"Success\";\n\t\t}\n\t} else {\n\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t*err = \"Success\";\n\t}\n\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_IO);\n\n done:\n\n\tif (new_sock) {\n\t\tswitch_socket_close(new_sock);\n\t}\n\n\tif (old_sock) {\n\t\tswitch_socket_close(old_sock);\n\t}\n\n\n\tif (rtp_session->ready != 1) {\n\t\tWRITE_DEC(rtp_session);\n\t\tREAD_DEC(rtp_session);\n\t}\n\n\treturn status;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_media_timeout(switch_rtp_t *rtp_session, uint32_t ms)\n{\n\tif (!switch_rtp_ready(rtp_session) || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\treturn;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1,\n\t\t\t\t\t  \"%s MEDIA TIMEOUT %s set to %u\\n\", switch_core_session_get_name(rtp_session->session), rtp_type(rtp_session), ms);\n\trtp_session->media_timeout = ms;\n\tswitch_rtp_reset_media_timer(rtp_session);\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_max_missed_packets(switch_rtp_t *rtp_session, uint32_t max)\n{\n\tif (!switch_rtp_ready(rtp_session) || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->missed_count > max) {\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t  \"new max missed packets(%d->%d) greater than current missed packets(%d). RTP will timeout.\\n\",\n\t\t\t\t\t\t  rtp_session->max_missed_packets, max, rtp_session->missed_count);\n\t}\n\n\trtp_session->max_missed_packets = max;\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset_jb(switch_rtp_t *rtp_session)\n{\n\tif (switch_rtp_ready(rtp_session)) {\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset_vb(switch_rtp_t *rtp_session)\n{\n\n\tif (rtp_session->vb) {\n\t\tswitch_jb_reset(rtp_session->vb);\n\t}\n\n\tif (rtp_session->vbw) {\n\t\tswitch_jb_reset(rtp_session->vbw);\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset(switch_rtp_t *rtp_session)\n{\n\tif (!rtp_session) {\n\t\treturn;\n\t}\n\n\t//rtp_session->seq = (uint16_t) rand();\n\t//rtp_session->ts = 0;\n\tmemset(&rtp_session->ts_norm, 0, sizeof(rtp_session->ts_norm));\n\n\trtp_session->last_stun = rtp_session->first_stun = 0;\n\trtp_session->rtcp_sent_packets = 0;\n\trtp_session->rtcp_last_sent = 0;\n\trtp_session->last_adj = 0;\n\n\t//switch_rtp_del_dtls(rtp_session, DTLS_TYPE_RTP|DTLS_TYPE_RTCP);\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_PAUSE);\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_MUTE);\n\trtcp_stats_init(rtp_session);\n\n\tif (rtp_session->ice.ready) {\n\t\tswitch_rtp_reset_vb(rtp_session);\n\t\trtp_session->ice.ready = rtp_session->ice.rready = 0;\n\t\trtp_session->ice.cand_responsive = 0;\n\t}\n\n}\n\nSWITCH_DECLARE(void) switch_rtp_reset_media_timer(switch_rtp_t *rtp_session)\n{\n\trtp_session->missed_count = 0;\n\trtp_session->last_media = switch_micro_time_now();\n}\n\nSWITCH_DECLARE(char *) switch_rtp_get_remote_host(switch_rtp_t *rtp_session)\n{\n\treturn zstr(rtp_session->remote_host_str) ? \"0.0.0.0\" : rtp_session->remote_host_str;\n}\n\nSWITCH_DECLARE(switch_port_t) switch_rtp_get_remote_port(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->remote_port;\n}\n\nstatic void ping_socket(switch_rtp_t *rtp_session)\n{\n\tuint32_t o = UINT_MAX;\n\tswitch_size_t len = sizeof(o);\n\tswitch_socket_sendto(rtp_session->sock_input, rtp_session->local_addr, 0, (void *) &o, &len);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] && rtp_session->rtcp_sock_input && rtp_session->rtcp_sock_input != rtp_session->sock_input) {\n\t\tswitch_socket_sendto(rtp_session->rtcp_sock_input, rtp_session->rtcp_local_addr, 0, (void *) &o, &len);\n\t}\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_udptl_mode(switch_rtp_t *rtp_session)\n{\n\tswitch_socket_t *sock;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_PROXY_MEDIA)) {\n\t\tping_socket(rtp_session);\n\t}\n\n\tREAD_INC(rtp_session);\n\tWRITE_INC(rtp_session);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] || rtp_session->timer.timer_interface) {\n\t\tswitch_core_timer_destroy(&rtp_session->timer);\n\t\tmemset(&rtp_session->timer, 0, sizeof(rtp_session->timer));\n\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t}\n\n\trtp_session->missed_count = 0;\n\trtp_session->max_missed_packets = 0;\n\n\trtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] = 0;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\trtp_session->rtcp_sock_input = NULL;\n\t\trtp_session->rtcp_sock_output = NULL;\n\t} else {\n\t\tif (rtp_session->rtcp_sock_input && rtp_session->rtcp_sock_input != rtp_session->sock_input) {\n\t\t\tping_socket(rtp_session);\n\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_input, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\n\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != rtp_session->rtcp_sock_input &&\n\t\t\trtp_session->rtcp_sock_output != rtp_session->sock_input) {\n\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_output, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\n\t\tif ((sock = rtp_session->rtcp_sock_input)) {\n\t\t\trtp_session->rtcp_sock_input = NULL;\n\t\t\tswitch_socket_close(sock);\n\n\t\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != sock) {\n\t\t\t\tsock = rtp_session->rtcp_sock_output;\n\t\t\t\trtp_session->rtcp_sock_output = NULL;\n\t\t\t\tswitch_socket_close(sock);\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_UDPTL);\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_PROXY_MEDIA);\n\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, FALSE);\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\n\tWRITE_DEC(rtp_session);\n\tREAD_DEC(rtp_session);\n\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_STICKY_FLUSH);\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\n\tswitch_rtp_break(rtp_session);\n\n\treturn SWITCH_STATUS_SUCCESS;\n\n}\n\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_remote_address(switch_rtp_t *rtp_session, const char *host, switch_port_t port, switch_port_t remote_rtcp_port,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  switch_bool_t change_adv_addr, const char **err)\n{\n\tswitch_sockaddr_t *remote_addr;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\t*err = \"Success\";\n\n\tif (switch_sockaddr_info_get(&remote_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !remote_addr) {\n\t\t*err = \"Remote Address Error!\";\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\n\tswitch_mutex_lock(rtp_session->write_mutex);\n\n\trtp_session->remote_addr = remote_addr;\n\n\tif (change_adv_addr) {\n\t\trtp_session->remote_host_str = switch_core_strdup(rtp_session->pool, host);\n\t\trtp_session->remote_port = port;\n\t}\n\n\trtp_session->eff_remote_host_str = switch_core_strdup(rtp_session->pool, host);\n\trtp_session->eff_remote_port = port;\n\n\tif (rtp_session->sock_input && switch_sockaddr_get_family(rtp_session->remote_addr) == switch_sockaddr_get_family(rtp_session->local_addr)) {\n\t\trtp_session->sock_output = rtp_session->sock_input;\n\t} else {\n\t\tif (rtp_session->sock_output && rtp_session->sock_output != rtp_session->sock_input) {\n\t\t\tswitch_socket_close(rtp_session->sock_output);\n\t\t}\n\t\tif ((status = switch_socket_create(&rtp_session->sock_output,\n\t\t\t\t\t\t\t\t\t\t   switch_sockaddr_get_family(rtp_session->remote_addr),\n\t\t\t\t\t\t\t\t\t\t   SOCK_DGRAM, 0, rtp_session->pool)) != SWITCH_STATUS_SUCCESS) {\n\n\t\t\t*err = \"Socket Error!\";\n\t\t}\n\t}\n\n\tif (rtp_session->dtls) {\n\t\trtp_session->dtls->sock_output = rtp_session->sock_output;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\tstatus = switch_sockaddr_info_get(&rtp_session->dtls->remote_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool);\n\t\t}\n\t}\n\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\trtp_session->rtcp_remote_addr = rtp_session->remote_addr;\n\t\t\trtp_session->rtcp_sock_output = rtp_session->sock_output;\n\t\t}/* else {\n\t\t\tif (remote_rtcp_port) {\n\t\t\t\trtp_session->remote_rtcp_port = remote_rtcp_port;\n\t\t\t} else {\n\t\t\t\trtp_session->remote_rtcp_port = rtp_session->eff_remote_port + 1;\n\t\t\t}\n\t\t\tstatus = enable_remote_rtcp_socket(rtp_session, err);\n\n\t\t\tif (rtp_session->rtcp_dtls) {\n\t\t\t\t//switch_sockaddr_info_get(&rtp_session->rtcp_dtls->remote_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool);\n\t\t\t\trtp_session->rtcp_dtls->remote_addr = rtp_session->rtcp_remote_addr;\n\t\t\t\trtp_session->rtcp_dtls->sock_output = rtp_session->rtcp_sock_output;\n\t\t\t}\n\t\t\t}*/\n\t}\n\n\tswitch_mutex_unlock(rtp_session->write_mutex);\n\n\treturn status;\n}\n\n\nstatic const char *dtls_state_names_t[] = {\"OFF\", \"HANDSHAKE\", \"SETUP\", \"READY\", \"FAIL\", \"INVALID\"};\nstatic const char *dtls_state_names(dtls_state_t s)\n{\n\tif (s > DS_INVALID) {\n\t\ts = DS_INVALID;\n\t}\n\n\treturn dtls_state_names_t[s];\n}\n\n#define dtls_set_state(_dtls, _state) switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Changing %s DTLS state from %s to %s\\n\", rtp_type(rtp_session), dtls_state_names(_dtls->state), dtls_state_names(_state)); _dtls->new_state = 1; _dtls->last_state = _dtls->state; _dtls->state = _state\n\n#define cr_keylen 16\n#define cr_saltlen 14\n#define cr_kslen 30\n\nstatic int dtls_state_setup(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tX509 *cert;\n\tswitch_secure_settings_t\tssec;\t/* Used just to wrap over params in a call to switch_rtp_add_crypto_key. */\n\tint r = 0;\n\n\tuint8_t raw_key_data[cr_kslen * 2];\n\tunsigned char local_key_buf[cr_kslen];\n\tunsigned char remote_key_buf[cr_kslen];\n\n\tmemset(&ssec, 0, sizeof(ssec));\n\tmemset(&raw_key_data, 0, cr_kslen * 2 * sizeof(uint8_t));\n\tmemset(&local_key_buf, 0, cr_kslen * sizeof(unsigned char));\n\tmemset(&remote_key_buf, 0, cr_kslen * sizeof(unsigned char));\n\n\tif ((dtls->type & DTLS_TYPE_SERVER)) {\n\t\tr = 1;\n\t} else if ((cert = SSL_get_peer_certificate(dtls->ssl))) {\n\t\tswitch_core_cert_extract_fingerprint(cert, dtls->remote_fp);\n\t\tr = switch_core_cert_verify(dtls->remote_fp);\n\t\tX509_free(cert);\n\t}\n\n\tif (!r) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s Fingerprint Verification Failed!\\n\", rtp_type(rtp_session));\n\t\tdtls_set_state(dtls, DS_FAIL);\n\t\treturn -1;\n\t} else {\n\t\tunsigned char *local_key, *remote_key, *local_salt, *remote_salt;\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"%s Fingerprint Verified.\\n\", rtp_type(rtp_session));\n\n#ifdef HAVE_OPENSSL_DTLS_SRTP\n\t\tif (!SSL_export_keying_material(dtls->ssl, raw_key_data, sizeof(raw_key_data), \"EXTRACTOR-dtls_srtp\", 19, NULL, 0, 0)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s Key material export failure\\n\", rtp_type(rtp_session));\n\t\t\tdtls_set_state(dtls, DS_FAIL);\n\t\t\treturn -1;\n\t\t}\n#else\n\t\treturn -1;\n#endif\n\n\t\tif ((dtls->type & DTLS_TYPE_CLIENT)) {\n\t\t\tlocal_key = raw_key_data;\n\t\t\tremote_key = local_key + cr_keylen;\n\t\t\tlocal_salt = remote_key + cr_keylen;\n\t\t\tremote_salt = local_salt + cr_saltlen;\n\n\t\t} else {\n\t\t\tremote_key = raw_key_data;\n\t\t\tlocal_key = remote_key + cr_keylen;\n\t\t\tremote_salt = local_key + cr_keylen;\n\t\t\tlocal_salt = remote_salt + cr_saltlen;\n\t\t}\n\n\t\tmemcpy(ssec.local_raw_key, local_key, cr_keylen);\n\t\tmemcpy(ssec.local_raw_key + cr_keylen, local_salt, cr_saltlen);\n\n\t\tmemcpy(ssec.remote_raw_key, remote_key, cr_keylen);\n\t\tmemcpy(ssec.remote_raw_key + cr_keylen, remote_salt, cr_saltlen);\n\n\t\tssec.crypto_type = AES_CM_128_HMAC_SHA1_80;\n\n\t\tif (dtls == rtp_session->rtcp_dtls && rtp_session->rtcp_dtls != rtp_session->dtls) {\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_SEND_RTCP, 0, &ssec);\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_RECV_RTCP, 0, &ssec);\n\t\t} else {\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_SEND, 0, &ssec);\n\t\t\tswitch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_RECV, 0, &ssec);\n\t\t}\n\t}\n\n\tdtls_set_state(dtls, DS_READY);\n\n\treturn 0;\n}\n\nstatic int dtls_state_ready(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\n\tif (dtls->new_state) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch_core_session_t *other_session;\n\n\t\t\tif (rtp_session->session && switch_core_session_get_partner(rtp_session->session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_core_session_request_video_refresh(other_session);\n\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t}\n\t\t}\n\t\tdtls->new_state = 0;\n\t}\n\treturn 0;\n}\n\nstatic int dtls_state_fail(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tif (rtp_session->session) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_DESTINATION_OUT_OF_ORDER);\n\t}\n\n\treturn -1;\n}\n\n\nstatic int dtls_state_handshake(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tint ret;\n\n\tif ((ret = SSL_do_handshake(dtls->ssl)) != 1){\n\t\tswitch((ret = SSL_get_error(dtls->ssl, ret))){\n\t\tcase SSL_ERROR_WANT_READ:\n\t\tcase SSL_ERROR_WANT_WRITE:\n\t\tcase SSL_ERROR_NONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"%s Handshake failure %d. This may happen when you use legacy DTLS v1.0 (legacyDTLS channel var is set) but endpoint requires DTLS v1.2.\\n\", rtp_type(rtp_session), ret);\n\t\t\tdtls_set_state(dtls, DS_FAIL);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\tdtls_set_state(dtls, DS_SETUP);\n\t}\n\n\treturn 0;\n}\n\nstatic void free_dtls(switch_dtls_t **dtlsp)\n{\n\tswitch_dtls_t *dtls;\n\n\tif (!dtlsp) {\n\t\treturn;\n\t}\n\n\tdtls = *dtlsp;\n\t*dtlsp = NULL;\n\n\tif (dtls->ssl) {\n\t\tSSL_free(dtls->ssl);\n\t}\n\n\tif (dtls->ssl_ctx) {\n\t\tSSL_CTX_free(dtls->ssl_ctx);\n\t}\n}\n\nstatic int do_dtls(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n{\n\tint r = 0, ret = 0, len;\n\tswitch_size_t bytes;\n\tunsigned char buf[MAX_DTLS_MTU] = \"\";\n\tuint8_t is_ice = rtp_session->ice.ice_user ? 1 : 0;\n\tint ready = is_ice ? (rtp_session->ice.rready && rtp_session->ice.ready) : 1;\n\tint pending;\n\n\tif (!dtls->bytes && !ready) {\n\t\treturn 0;\n\t}\n\n\tif (is_ice && !(rtp_session->ice.type & ICE_LITE) && !rtp_session->ice.cand_responsive) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, \"Got DTLS packet but candidate is not responsive\\n\");\n\n\t\treturn 0;\n\t}\n\n\tif (is_ice && !switch_cmp_addr(rtp_session->from_addr, rtp_session->ice.addr, SWITCH_TRUE)) {\n\t\tchar tmp_buf1[80] = \"\";\n\t\tchar tmp_buf2[80] = \"\";\n\t\tconst char *host_from = switch_get_addr(tmp_buf1, sizeof(tmp_buf1), rtp_session->from_addr);\n\t\tconst char *host_ice_cur_addr = switch_get_addr(tmp_buf2, sizeof(tmp_buf2), rtp_session->ice.addr);\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, \"Got DTLS packet from [%s] whilst current ICE negotiated address is [%s]. Ignored.\\n\", host_from, host_ice_cur_addr);\n\n\t\treturn 0;\n\t}\n\n\tif (dtls->bytes > 0 && dtls->data) {\n\t\tret = BIO_write(dtls->read_bio, dtls->data, (int)dtls->bytes);\n\t\tif (ret <= 0) {\n\t\t\tret = SSL_get_error(dtls->ssl, ret);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet decode err: SSL err %d\\n\", rtp_type(rtp_session), ret);\n\t\t} else if (ret != (int)dtls->bytes) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet decode err: read %d bytes instead of %d\\n\", rtp_type(rtp_session), ret, (int)dtls->bytes);\n\t\t}\n\t}\n\n\tif (dtls_states[dtls->state]) {\n\t\tr = dtls_states[dtls->state](rtp_session, dtls);\n\t}\n\n\twhile ((pending = BIO_ctrl_pending(dtls->filter_bio)) > 0) {\n\t\tswitch_assert(pending <= sizeof(buf));\n\n\t\tlen = BIO_read(dtls->write_bio, buf, pending);\n\t\tif (len > 0) {\n\t\t\tbytes = len;\n\t\t\tret = switch_socket_sendto(dtls->sock_output, dtls->remote_addr, 0, (void *)buf, &bytes);\n\n\t\t\tif (ret != SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet not written to socket: %d\\n\", rtp_type(rtp_session), ret);\n\t\t\t} else if (bytes != len) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet write err: written %d bytes instead of %d\\n\", rtp_type(rtp_session), (int)bytes, len);\n\t\t\t}\n\t\t} else {\n\t\t\tret = SSL_get_error(dtls->ssl, len);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS packet encode err: SSL err %d\\n\", rtp_type(rtp_session), ret);\n\t\t}\n\t}\n\n\treturn r;\n}\n\n#if VERIFY\nstatic int cb_verify_peer(int preverify_ok, X509_STORE_CTX *ctx)\n{\n\tSSL *ssl = NULL;\n\tswitch_dtls_t *dtls;\n\tX509 *cert;\n\tint r = 0;\n\n\tssl = X509_STORE_CTX_get_app_data(ctx);\n\tdtls = (switch_dtls_t *) SSL_get_app_data(ssl);\n\n\tif (!(ssl && dtls)) {\n\t\treturn 0;\n\t}\n\n\tif ((cert = SSL_get_peer_certificate(dtls->ssl))) {\n\t\tswitch_core_cert_extract_fingerprint(cert, dtls->remote_fp);\n\n\t\tr = switch_core_cert_verify(dtls->remote_fp);\n\n\t\tX509_free(cert);\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(dtls->rtp_session->session), SWITCH_LOG_ERROR, \"%s CERT ERR!\\n\", rtp_type(dtls->rtp_session));\n\t}\n\n\treturn r;\n}\n#endif\n\n\n////////////\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\nstatic BIO_METHOD dtls_bio_filter_methods;\n#else\nstatic BIO_METHOD *dtls_bio_filter_methods;\n#endif\n\nBIO_METHOD *BIO_dtls_filter(void) {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\t\n\treturn(&dtls_bio_filter_methods);\n#else\n\treturn(dtls_bio_filter_methods);\n#endif\n}\n\ntypedef struct packet_list_s {\n\t//void *packet;\n\tint size;\n\tstruct packet_list_s *next;\n} packet_list_t;\n \n/* Helper struct to keep the filter state */\ntypedef struct dtls_bio_filter {\n\tpacket_list_t *packets;\n\tpacket_list_t *unused;\n\tpacket_list_t *tail;\n\tswitch_mutex_t *mutex;\n\tswitch_memory_pool_t *pool;\n\tlong mtu;\n} dtls_bio_filter;\n \n \nstatic int dtls_bio_filter_new(BIO *bio) {\n\t/* Create a filter state struct */\n\tdtls_bio_filter *filter;\n\tswitch_memory_pool_t *pool;\n\n\tswitch_core_new_memory_pool(&pool);\n\tfilter = switch_core_alloc(pool, sizeof(*filter));\n\tfilter->pool = pool;\n\n\tfilter->packets = NULL;\n\tswitch_mutex_init(&filter->mutex, SWITCH_MUTEX_NESTED, filter->pool);\n \n\t/* Set the BIO as initialized */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tbio->init = 1;\n\tbio->ptr = filter;\n\tbio->flags = 0;\n#else\n\tBIO_set_init(bio, 1);\n\tBIO_set_data(bio, filter);\n\tBIO_clear_flags(bio, ~0);\n#endif\n\t\n\treturn 1;\n}\n \nstatic int dtls_bio_filter_free(BIO *bio) {\n\tdtls_bio_filter *filter;\n\n\tif (bio == NULL) {\n\t\treturn 0;\n\t}\n \n\t/* Get rid of the filter state */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tfilter = (dtls_bio_filter *)bio->ptr;\n#else\n\tfilter = (dtls_bio_filter *)BIO_get_data(bio);\n#endif\n\n\tif (filter != NULL) {\n\t\tswitch_memory_pool_t *pool = filter->pool;\n\t\tswitch_core_destroy_memory_pool(&pool);\n\t\tpool = NULL;\n\t\tfilter = NULL;\n\t}\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tbio->ptr = NULL;\n\tbio->init = 0;\n\tbio->flags = 0;\n#else\n\tBIO_set_init(bio, 0);\n\tBIO_set_data(bio, NULL);\n\tBIO_clear_flags(bio, ~0);\n#endif\n\treturn 1;\n}\n \nstatic int dtls_bio_filter_write(BIO *bio, const char *in, int inl) {\n\tlong ret;\n\tdtls_bio_filter *filter;\n\t\n\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"dtls_bio_filter_write: %p, %d\\n\", (void *)in, inl);\n\t/* Forward data to the write BIO */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tret = BIO_write(bio->next_bio, in, inl);\n#else\n\tret = BIO_write(BIO_next(bio), in, inl);\n#endif\n\t\n\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"  -- %ld\\n\", ret);\n \n\t/* Keep track of the packet, as we'll advertize them one by one after a pending check */\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tfilter = (dtls_bio_filter *)bio->ptr;\n#else\n\tfilter = (dtls_bio_filter *)BIO_get_data(bio);\n#endif\n\n\tif (filter != NULL) {\n\t\tpacket_list_t *node;\n\n\t\tswitch_mutex_lock(filter->mutex);\n\t\tif (filter->unused) {\n\t\t\tnode = filter->unused;\n\t\t\tnode->next = NULL;\n\t\t\tfilter->unused = filter->unused->next;\n\t\t} else {\n\t\t\tnode = switch_core_alloc(filter->pool, sizeof(*node));\n\t\t}\n\n\t\tnode->size = ret;\n\n\t\tif (filter->tail) {\n\t\t\tfilter->tail->next = node;\n\t\t} else {\n\t\t\tfilter->packets = node;\n\t\t}\n\n\t\tfilter->tail = node;\n\n\t\tswitch_mutex_unlock(filter->mutex);\n\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"New list length: %d\\n\", g_list_length(filter->packets));\n\t}\n\treturn ret;\n}\n \nstatic long dtls_bio_filter_ctrl(BIO *bio, int cmd, long num, void *ptr) {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tdtls_bio_filter *filter = (dtls_bio_filter *)bio->ptr;\n#else\n\tdtls_bio_filter *filter = (dtls_bio_filter *)BIO_get_data(bio);\n#endif\n\n\tswitch(cmd) {\n\tcase BIO_CTRL_DGRAM_GET_FALLBACK_MTU:\n\t\treturn 1200;\n\tcase BIO_CTRL_DGRAM_SET_MTU:\n\t\tfilter->mtu = num;\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"Setting MTU: %ld\\n\", filter->mtu);\n\t\treturn num;\n\tcase BIO_CTRL_FLUSH:\n\t\treturn 1;\n\tcase BIO_CTRL_DGRAM_QUERY_MTU:\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"Advertizing MTU: %ld\\n\", filter->mtu);\n\t\treturn filter->mtu;\n\tcase BIO_CTRL_WPENDING:\n\t\treturn 0L;\n\tcase BIO_CTRL_PENDING: {\n\t\tint pending = 0;\n\t\tpacket_list_t *top;\n\n\t\tif (filter == NULL) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tswitch_mutex_lock(filter->mutex);\n\t\tif ((top = filter->packets)) {\n\t\t\tfilter->packets = filter->packets->next;\n\t\t\t\n\t\t\tif (top == filter->tail || !filter->packets) {\n\t\t\t\tfilter->tail = NULL;\n\t\t\t}\n\t\t\t\n\t\t\tpending = top->size;\n\t\t\ttop->next = filter->unused;\n\t\t\tfilter->unused = top;\n\t\t}\n\t\tswitch_mutex_unlock(filter->mutex);\n\n\t\treturn pending;\n\t}\n\tdefault:\n\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"dtls_bio_filter_ctrl: %d\\n\", cmd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\nstatic BIO_METHOD dtls_bio_filter_methods = {\n\tBIO_TYPE_FILTER,\n\t\"DTLS filter\",\n\tdtls_bio_filter_write,\n\tNULL,\n\tNULL,\n\tNULL,\n\tdtls_bio_filter_ctrl,\n\tdtls_bio_filter_new,\n\tdtls_bio_filter_free,\n\tNULL\n};\n#else\nstatic BIO_METHOD *dtls_bio_filter_methods = NULL;\n#endif\n\nstatic void switch_rtp_dtls_init(void) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tdtls_bio_filter_methods = BIO_meth_new(BIO_TYPE_FILTER | BIO_get_new_index(), \"DTLS filter\");\n\tBIO_meth_set_write(dtls_bio_filter_methods, dtls_bio_filter_write);\n\tBIO_meth_set_ctrl(dtls_bio_filter_methods, dtls_bio_filter_ctrl);\n\tBIO_meth_set_create(dtls_bio_filter_methods, dtls_bio_filter_new);\n\tBIO_meth_set_destroy(dtls_bio_filter_methods, dtls_bio_filter_free);\n#endif\n}\n\nstatic void switch_rtp_dtls_destroy(void) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tif (dtls_bio_filter_methods) {\n\t\tBIO_meth_free(dtls_bio_filter_methods);\n\t\tdtls_bio_filter_methods = NULL;\n\t}\n#endif\n}\n\n///////////\n\n\n\nSWITCH_DECLARE(int) switch_rtp_has_dtls(void) {\n#ifdef HAVE_OPENSSL_DTLS_SRTP\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nSWITCH_DECLARE(dtls_state_t) switch_rtp_dtls_state(switch_rtp_t *rtp_session, dtls_type_t type)\n{\n\tdtls_state_t s = DS_OFF;\n\n\tif (!rtp_session) {\n\t\treturn s;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!rtp_session->dtls && !rtp_session->rtcp_dtls) {\n\t\ts = DS_OFF;\n\t\tgoto done;\n\t}\n\n\tif ((type == DTLS_TYPE_RTP) && rtp_session->dtls) {\n\t\ts = rtp_session->dtls->state;\n\t\tgoto done;\n\t}\n\n\tif ((type == DTLS_TYPE_RTCP) && rtp_session->rtcp_dtls) {\n\t\ts = rtp_session->rtcp_dtls->state;\n\t}\n\n done:\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn s;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_del_dtls(switch_rtp_t *rtp_session, dtls_type_t type)\n{\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\n\tif (!rtp_session) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!rtp_session->dtls && !rtp_session->rtcp_dtls) {\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif ((type & DTLS_TYPE_RTP)) {\n\t\tif (rtp_session->dtls && rtp_session->dtls == rtp_session->rtcp_dtls) {\n\t\t\trtp_session->rtcp_dtls = NULL;\n\t\t}\n\n\t\tif (rtp_session->dtls) {\n\t\t\tfree_dtls(&rtp_session->dtls);\n\t\t}\n\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\tswitch_jb_reset(rtp_session->vb);\n\t\t}\n\n\t\tif (rtp_session->vbw) {\n\t\t\tswitch_jb_reset(rtp_session->vbw);\n\t\t}\n\n\t}\n\n\tif ((type & DTLS_TYPE_RTCP) && rtp_session->rtcp_dtls) {\n\t\tfree_dtls(&rtp_session->rtcp_dtls);\n\t}\n\n\n#ifdef ENABLE_SRTP\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\tint x;\n\n\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\n\t\tfor(x = 0; x < 2; x++) {\n\t\t\tif (rtp_session->send_ctx[x]) {\n\t\t\t\tsrtp_dealloc(rtp_session->send_ctx[x]);\n\t\t\t\trtp_session->send_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {\n\t\tint x;\n\n\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\n\t\tfor (x = 0; x < 2; x++) {\n\t\t\tif (rtp_session->recv_ctx[x]) {\n\t\t\t\tsrtp_dealloc(rtp_session->recv_ctx[x]);\n\t\t\t\trtp_session->recv_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n done:\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_add_dtls(switch_rtp_t *rtp_session, dtls_fingerprint_t *local_fp, dtls_fingerprint_t *remote_fp, dtls_type_t type, uint8_t want_DTLSv1_2)\n{\n\tswitch_dtls_t *dtls;\n\tconst char *var;\n\tint ret;\n\tconst char *kind = \"\";\n\tunsigned long ssl_method_error = 0;\n\tunsigned long ssl_ctx_error = 0;\n\tconst SSL_METHOD *ssl_method;\n\tSSL_CTX *ssl_ctx;\n#if OPENSSL_VERSION_NUMBER < 0x30000000\n\tBIO *bio;\n\tDH *dh;\n#endif\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n#ifndef OPENSSL_NO_EC\n#if OPENSSL_VERSION_NUMBER < 0x10002000L\n\tEC_KEY* ecdh;\n#endif\n#endif\n\n#ifndef HAVE_OPENSSL_DTLS_SRTP\n\treturn SWITCH_STATUS_FALSE;\n#endif\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (!((type & DTLS_TYPE_RTP) || (type & DTLS_TYPE_RTCP)) || !((type & DTLS_TYPE_CLIENT) || (type & DTLS_TYPE_SERVER))) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"INVALID TYPE!\\n\");\n\t}\n\n\tswitch_rtp_del_dtls(rtp_session, type);\n\n\tif ((type & DTLS_TYPE_RTP) && (type & DTLS_TYPE_RTCP)) {\n\t\tkind = \"RTP/RTCP\";\n\t} else if ((type & DTLS_TYPE_RTP)) {\n\t\tkind = \"RTP\";\n\t} else {\n\t\tkind = \"RTCP\";\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t  \"Activate %s %s DTLS %s\\n\", kind, rtp_type(rtp_session), (type & DTLS_TYPE_SERVER) ? \"server\" : \"client\");\n\n\tif (((type & DTLS_TYPE_RTP) && rtp_session->dtls) || ((type & DTLS_TYPE_RTCP) && rtp_session->rtcp_dtls)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"DTLS ALREADY INIT\\n\");\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tdtls = switch_core_alloc(rtp_session->pool, sizeof(*dtls));\n\n\tdtls->pem = switch_core_sprintf(rtp_session->pool, \"%s%s%s.pem\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);\n\n\tif (switch_file_exists(dtls->pem, rtp_session->pool) == SWITCH_STATUS_SUCCESS) {\n\t\tdtls->pvt = dtls->rsa = dtls->pem;\n\t} else {\n\t\tdtls->pvt = switch_core_sprintf(rtp_session->pool, \"%s%s%s.key\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);\n\t\tdtls->rsa = switch_core_sprintf(rtp_session->pool, \"%s%s%s.crt\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);\n\t}\n\n\tdtls->ca = switch_core_sprintf(rtp_session->pool, \"%s%sca-bundle.crt\", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR);\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000\n\tssl_method = (type & DTLS_TYPE_SERVER) ? DTLS_server_method() : DTLS_client_method();\n#else\n    #ifdef HAVE_OPENSSL_DTLSv1_2_method\n\t\tssl_method = (type & DTLS_TYPE_SERVER) ? (want_DTLSv1_2 ? DTLSv1_2_server_method() : DTLSv1_server_method()) : (want_DTLSv1_2 ? DTLSv1_2_client_method() : DTLSv1_client_method());\n\t#else\n\t\tssl_method = (type & DTLS_TYPE_SERVER) ? DTLSv1_server_method() : DTLSv1_client_method();\n    #endif // HAVE_OPENSSL_DTLSv1_2_method\n#endif\n\n\tif (!ssl_method) {\n\t\tssl_method_error = ERR_peek_error();\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s ssl_method is NULL [%lu]\\n\", rtp_type(rtp_session), ssl_method_error);\n\t}\n\n\tdtls->ssl_ctx = ssl_ctx = SSL_CTX_new(ssl_method);\n\n\tif (!ssl_ctx) {\n\t\tssl_ctx_error = ERR_peek_error();\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s SSL_CTX_new failed [%lu]\\n\", rtp_type(rtp_session), ssl_ctx_error);\n\t\tswitch_channel_hangup(switch_core_session_get_channel(rtp_session->session), SWITCH_CAUSE_NORMAL_TEMPORARY_FAILURE);\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tswitch_assert(dtls->ssl_ctx);\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000\n\tbio = BIO_new_file(dtls->pem, \"r\");\n\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tBIO_free(bio);\n\tif (dh) {\n\t\tSSL_CTX_set_tmp_dh(dtls->ssl_ctx, dh);\n\t\tDH_free(dh);\n\t}\n#else\n\tif(!SSL_CTX_set_dh_auto(dtls->ssl_ctx, 1)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Failed enable auto DH!\\n\");\n\t}\n#endif\n\tSSL_CTX_set_mode(dtls->ssl_ctx, SSL_MODE_AUTO_RETRY);\n\n\t//SSL_CTX_set_verify(dtls->ssl_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);\n\tSSL_CTX_set_verify(dtls->ssl_ctx, SSL_VERIFY_NONE, NULL);\n\n\t//SSL_CTX_set_cipher_list(dtls->ssl_ctx, \"ECDH:!RC4:!SSLv3:RSA_WITH_AES_128_CBC_SHA\");\n\t//SSL_CTX_set_cipher_list(dtls->ssl_ctx, \"ECDHE-RSA-AES256-GCM-SHA384\");\n\tSSL_CTX_set_cipher_list(dtls->ssl_ctx, \"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\t//SSL_CTX_set_cipher_list(dtls->ssl_ctx, \"SUITEB128\");\n\tSSL_CTX_set_read_ahead(dtls->ssl_ctx, 1);\n#ifdef HAVE_OPENSSL_DTLS_SRTP\n\t//SSL_CTX_set_tlsext_use_srtp(dtls->ssl_ctx, \"SRTP_AES128_CM_SHA1_80:SRTP_AES128_CM_SHA1_32\");\n\tSSL_CTX_set_tlsext_use_srtp(dtls->ssl_ctx, \"SRTP_AES128_CM_SHA1_80\");\n#endif\n\n\tdtls->type = type;\n\tdtls->read_bio = BIO_new(BIO_s_mem());\n\tswitch_assert(dtls->read_bio);\n\n\tdtls->write_bio = BIO_new(BIO_s_mem());\n\tswitch_assert(dtls->write_bio);\n\n\tBIO_set_mem_eof_return(dtls->read_bio, -1);\n\tBIO_set_mem_eof_return(dtls->write_bio, -1);\n\n\tif ((ret=SSL_CTX_use_certificate_file(dtls->ssl_ctx, dtls->rsa, SSL_FILETYPE_PEM)) != 1) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS cert err [%d]\\n\", rtp_type(rtp_session), SSL_get_error(dtls->ssl, ret));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif ((ret=SSL_CTX_use_PrivateKey_file(dtls->ssl_ctx, dtls->pvt, SSL_FILETYPE_PEM)) != 1) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS key err [%d]\\n\", rtp_type(rtp_session), SSL_get_error(dtls->ssl, ret));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif (SSL_CTX_check_private_key(dtls->ssl_ctx) == 0) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS check key failed\\n\", rtp_type(rtp_session));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tif (!zstr(dtls->ca) && switch_file_exists(dtls->ca, rtp_session->pool) == SWITCH_STATUS_SUCCESS\n\t\t&& (ret = SSL_CTX_load_verify_locations(dtls->ssl_ctx, dtls->ca, NULL)) != 1) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"%s DTLS check chain cert failed [%d]\\n\",\n\t\t\t\t\t\t  rtp_type(rtp_session) ,\n\t\t\t\t\t\t  SSL_get_error(dtls->ssl, ret));\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\n\tdtls->ssl = SSL_new(dtls->ssl_ctx);\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tdtls->filter_bio = BIO_new(BIO_dtls_filter());\n#else\n\tswitch_assert(dtls_bio_filter_methods);\n\tdtls->filter_bio = BIO_new(dtls_bio_filter_methods);\n#endif\n\n\tswitch_assert(dtls->filter_bio);\n\n\tBIO_push(dtls->filter_bio, dtls->write_bio);\n\n\tSSL_set_bio(dtls->ssl, dtls->read_bio, dtls->filter_bio);\n\n\tSSL_set_mode(dtls->ssl, SSL_MODE_AUTO_RETRY);\n\tSSL_set_read_ahead(dtls->ssl, 1);\n\n\n\t//SSL_set_verify(dtls->ssl, (SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT), cb_verify_peer);\n\n#ifndef OPENSSL_NO_EC\n#if OPENSSL_VERSION_NUMBER < 0x10002000L\n\tecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (!ecdh) {\n\t\tswitch_goto_status(SWITCH_STATUS_FALSE, done);\n\t}\n\tSSL_set_options(dtls->ssl, SSL_OP_SINGLE_ECDH_USE);\n\tSSL_set_tmp_ecdh(dtls->ssl, ecdh);\n\tEC_KEY_free(ecdh);\n#elif OPENSSL_VERSION_NUMBER < 0x10100000L\n\tSSL_set_ecdh_auto(dtls->ssl, 1);\n\tSSL_set_options(dtls->ssl, SSL_OP_SINGLE_ECDH_USE);\n#endif\n#endif\n\n\tSSL_set_verify(dtls->ssl, SSL_VERIFY_NONE, NULL);\n\tSSL_set_app_data(dtls->ssl, dtls);\n\n\tdtls->local_fp = local_fp;\n\tdtls->remote_fp = remote_fp;\n\tdtls->rtp_session = rtp_session;\n\tdtls->mtu = 1200;\n\n\tif (rtp_session->session) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\tif ((var = switch_channel_get_variable(channel, \"rtp_dtls_mtu\"))) {\n\t\t\tint mtu = atoi(var);\n\n\t\t\tif (mtu > 0 && mtu < MAX_DTLS_MTU) {\n\t\t\t\tdtls->mtu = mtu;\n\t\t\t}\n\n\t\t}\n\t}\n\t\n\tBIO_ctrl(dtls->filter_bio, BIO_CTRL_DGRAM_SET_MTU, dtls->mtu, NULL);\n\t\n\tswitch_core_cert_expand_fingerprint(remote_fp, remote_fp->str);\n\n\tif ((type & DTLS_TYPE_RTP)) {\n\t\trtp_session->dtls = dtls;\n\t\tdtls->sock_output = rtp_session->sock_output;\n\t\tdtls->remote_addr = rtp_session->remote_addr;\n\t}\n\n\tif ((type & DTLS_TYPE_RTCP)) {\n\t\trtp_session->rtcp_dtls = dtls;\n\t\tif (!(type & DTLS_TYPE_RTP)) {\n\t\t\tdtls->sock_output = rtp_session->rtcp_sock_output;\n\t\t\tdtls->remote_addr = rtp_session->rtcp_remote_addr;\n\t\t}\n\t}\n\n\tif ((type & DTLS_TYPE_SERVER)) {\n\t\tSSL_set_accept_state(dtls->ssl);\n\t} else {\n\t\tSSL_set_connect_state(dtls->ssl);\n\t}\n\n\tdtls_set_state(dtls, DS_HANDSHAKE);\n\n\trtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 1;\n\tswitch_rtp_break(rtp_session);\n\n done:\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn status;\n\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_add_crypto_key(switch_rtp_t *rtp_session, switch_rtp_crypto_direction_t direction, uint32_t index, switch_secure_settings_t *ssec)\n{\n#ifndef ENABLE_SRTP\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"SRTP NOT SUPPORTED IN THIS BUILD!\\n\");\n\treturn SWITCH_STATUS_FALSE;\n#else\n\n\tswitch_rtp_crypto_key_t *crypto_key;\n\tsrtp_policy_t *policy;\n\tsrtp_err_status_t stat;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\n\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\tswitch_event_t *fsevent = NULL;\n\tint idx = 0;\n\tconst char *var;\n\tunsigned char b64_key[512] = \"\";\n\t\n\tunsigned char\t*keysalt = NULL;\n\tswitch_size_t\tkeysalt_len = 0;\n\t\n\tswitch_crypto_key_material_t\t*key_material = NULL;\n\tunsigned long\t\t\t\t\t*key_material_n = NULL;\n\tsrtp_master_key_t\t\t**mkis = NULL;\n\tsrtp_master_key_t\t\t*mki = NULL;\n\tint mki_idx = 0;\n\n\tkeysalt_len = switch_core_media_crypto_keysalt_len(ssec->crypto_type);\n\n\tif (direction >= SWITCH_RTP_CRYPTO_MAX || keysalt_len > SWITCH_RTP_MAX_CRYPTO_LEN) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (direction == SWITCH_RTP_CRYPTO_RECV_RTCP) {\n\t\tdirection = SWITCH_RTP_CRYPTO_RECV;\n\t\trtp_session->srtp_idx_rtcp = idx = 1;\n\t} else if (direction == SWITCH_RTP_CRYPTO_SEND_RTCP) {\n\t\tdirection = SWITCH_RTP_CRYPTO_SEND;\n\t\trtp_session->srtp_idx_rtcp = idx = 1;\n\t}\n\n\tif (direction == SWITCH_RTP_CRYPTO_RECV) {\n\t\tpolicy = &rtp_session->recv_policy[idx];\n\t\tkeysalt = ssec->remote_raw_key;\n\t\tkey_material = ssec->remote_key_material_next;\n\t\tkey_material_n = &ssec->remote_key_material_n;\n\t} else {\n\t\tpolicy = &rtp_session->send_policy[idx];\n\t\tkeysalt = ssec->local_raw_key;\n\t\tkey_material = ssec->local_key_material_next;\n\t\tkey_material_n = &ssec->local_key_material_n;\n\t}\n\n\tswitch_b64_encode(keysalt, keysalt_len, b64_key, sizeof(b64_key));\n\n\tif (switch_true(switch_core_get_variable(\"rtp_retain_crypto_keys\"))) {\n\t\tswitch(direction) {\n\t\t\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_local_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_remote_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch(direction) {\n\t\t\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_local_video_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_remote_video_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tswitch(direction) {\n\t\t\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_local_audio_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\t\t\tswitch_channel_set_variable(channel, \"srtp_remote_audio_crypto_key\", (const char *)b64_key);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcrypto_key = switch_core_alloc(rtp_session->pool, sizeof(*crypto_key));\n\n\tcrypto_key->type = ssec->crypto_type;\n\tcrypto_key->index = index;\n\tmemcpy(crypto_key->keysalt, keysalt, keysalt_len);\n\tcrypto_key->next = rtp_session->crypto_keys[direction];\n\trtp_session->crypto_keys[direction] = crypto_key;\n\n\tmemset(policy, 0, sizeof(*policy));\n\n\t/* many devices can't handle gaps in SRTP streams */\n\tif (!((var = switch_channel_get_variable(channel, \"srtp_allow_idle_gaps\"))\n\t\t  && switch_true(var))\n\t\t&& (!(var = switch_channel_get_variable(channel, \"send_silence_when_idle\"))\n\t\t\t|| !(atoi(var)))) {\n\t\tswitch_channel_set_variable(channel, \"send_silence_when_idle\", \"-1\");\n\t}\n\n\tswitch (crypto_key->type) {\n\tcase AES_CM_128_HMAC_SHA1_80:\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_80(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_80(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_128_HMAC_SHA1_80\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_128_HMAC_SHA1_32:\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&policy->rtcp);\n\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_128_HMAC_SHA1_32\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_256_GCM_8:\n\t\tsrtp_crypto_policy_set_aes_gcm_256_8_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_256_8_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_256_GCM_8\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_256_GCM:\n\t\tsrtp_crypto_policy_set_aes_gcm_256_16_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_256_16_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_256_GCM\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_128_GCM_8:\n\t\tsrtp_crypto_policy_set_aes_gcm_128_8_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_128_8_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_128_GCM_8\");\n\t\t}\n\t\tbreak;\n\n\tcase AEAD_AES_128_GCM:\n\t\tsrtp_crypto_policy_set_aes_gcm_128_16_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_gcm_128_16_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AEAD_AES_128_GCM\");\n\t\t}\n\t\tbreak;\n\n\tcase AES_CM_256_HMAC_SHA1_80:\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_256_HMAC_SHA1_80\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_256_HMAC_SHA1_32:\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_256_HMAC_SHA1_32\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_192_HMAC_SHA1_80:\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_192_HMAC_SHA1_80\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_192_HMAC_SHA1_32:\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(&policy->rtcp);\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_192_HMAC_SHA1_32\");\n\t\t}\n\t\tbreak;\n\tcase AES_CM_128_NULL_AUTH:\n\t\tsrtp_crypto_policy_set_aes_cm_128_null_auth(&policy->rtp);\n\t\tsrtp_crypto_policy_set_aes_cm_128_null_auth(&policy->rtcp);\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"AES_CM_128_NULL_AUTH\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Missing crypto type!\\n\");\n\t\tbreak;\n\t}\n\n\t/* Setup the policy with MKI if they are used. Number of key materials must be positive to use MKI. */\n\tif (key_material && (*key_material_n > 0)) {\n\n\t\tif (direction == SWITCH_RTP_CRYPTO_RECV) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI] = 1;\t/* tell the rest of the environment MKI is used */\n\t\t} else {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI] = 1;\t/* tell the rest of the environment MKI is used */\n\t\t}\n\n\t\t/* key must be NULL for libsrtp to work correctly with MKI. */\n\t\tpolicy->key = NULL;\n\n\t\t/* Allocate array for MKIs. */\n\t\tmkis = switch_core_alloc(rtp_session->pool, *key_material_n * sizeof(srtp_master_key_t*));\n\t\tif (!mkis) {\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\t/* Build array of MKIs. */\n\t\tmki_idx = 0;\n\n\t\twhile (key_material && (mki_idx < *key_material_n)) {\n\n\t\t\tif (key_material->mki_size < 1) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"MKI bad key size at MKI %d\\n\", mki_idx);\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tmki = switch_core_alloc(rtp_session->pool, sizeof(srtp_master_key_t));\n\t\t\tif (!mki) {\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\t/* Setup MKI. */\n\t\t\tmki->mki_id = switch_core_alloc(rtp_session->pool, sizeof(key_material->mki_size));\n\t\t\tif (!mki->mki_id) {\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tmki->key = switch_core_alloc(rtp_session->pool, keysalt_len);\n\t\t\tif (!mki->key) {\n\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tmemcpy(mki->mki_id, &key_material->mki_id, key_material->mki_size);\n\t\t\tmki->mki_size = key_material->mki_size;\n\t\t\tmemcpy(mki->key, key_material->raw_key, keysalt_len);\n\n\t\t\tmkis[mki_idx] = mki;\n\n\t\t\tkey_material = key_material->next;\n\t\t\t++mki_idx;\n\t\t}\n\n\t\t/* And pass the array of MKIs to libsrtp. */\n\t\tpolicy->keys = mkis;\n\t\tpolicy->num_master_keys = mki_idx;\n\n\t} else {\n\t\tpolicy->key = (uint8_t *) crypto_key->keysalt;\n\t}\n\n\tpolicy->next = NULL;\n\n\tpolicy->window_size = 1024;\n\tpolicy->allow_repeat_tx = 1;\n\n\t//policy->rtp.sec_serv = sec_serv_conf_and_auth;\n\t//policy->rtcp.sec_serv = sec_serv_conf_and_auth;\n\n\tswitch (direction) {\n\tcase SWITCH_RTP_CRYPTO_RECV:\n\t\tpolicy->ssrc.type = ssrc_any_inbound;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && idx == 0 && rtp_session->recv_ctx[idx]) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_RESET] = 1;\n\t\t} else {\n\t\t\tif ((stat = srtp_create(&rtp_session->recv_ctx[idx], policy)) || !rtp_session->recv_ctx[idx]) {\n\t\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tif (status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Activating %s Secure %s RECV%s\\n\",\n\t\t\t\t\t\t\t\t  rtp_type(rtp_session), idx ? \"RTCP\" : \"RTP\", rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI] ? \" (with MKI)\" : \"\");\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 1;\n\t\t\t} else {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error allocating srtp [%d]\\n\", stat);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SWITCH_RTP_CRYPTO_SEND:\n\t\tpolicy->ssrc.type = ssrc_any_outbound;\n\t\t//policy->ssrc.type = ssrc_specific;\n\t\t//policy->ssrc.value = rtp_session->ssrc;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] && idx == 0 && rtp_session->send_ctx[idx]) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET] = 1;\n\t\t} else {\n\t\t\tif ((stat = srtp_create(&rtp_session->send_ctx[idx], policy)) || !rtp_session->send_ctx[idx]) {\n\t\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t}\n\n\t\t\tif (status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"Activating %s Secure %s SEND%s\\n\",\n\t\t\t\t\t\t\t\t  rtp_type(rtp_session), idx ? \"RTCP\" : \"RTP\", rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI] ? \" (with MKI)\" : \"\");\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 1;\n\t\t\t} else {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error allocating SRTP [%d]\\n\", stat);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (switch_event_create(&fsevent, SWITCH_EVENT_CALL_SECURE) == SWITCH_STATUS_SUCCESS) {\n\t\tif (rtp_session->dtls) {\n\t\t\tswitch_event_add_header(fsevent, SWITCH_STACK_BOTTOM, \"secure_type\", \"srtp:dtls:AES_CM_128_HMAC_SHA1_80\");\n\t\t\tswitch_channel_set_variable(channel, \"rtp_has_crypto\", \"srtp:dtls:AES_CM_128_HMAC_SHA1_80\");\n\t\t} else {\n\t\t\tswitch_event_add_header(fsevent, SWITCH_STACK_BOTTOM, \"secure_type\", \"srtp:sdes:%s\", switch_channel_get_variable(channel, \"rtp_has_crypto\"));\n\t\t}\n\t\tswitch_event_add_header_string(fsevent, SWITCH_STACK_BOTTOM, \"caller-unique-id\", switch_channel_get_uuid(channel));\n\t\tswitch_event_fire(&fsevent);\n\t}\n\n\n\treturn SWITCH_STATUS_SUCCESS;\n#endif\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_interval(switch_rtp_t *rtp_session, uint32_t ms_per_packet, uint32_t samples_per_interval)\n{\n\trtp_session->ms_per_packet = ms_per_packet;\n\trtp_session->samples_per_interval = rtp_session->conf_samples_per_interval = samples_per_interval;\n\trtp_session->missed_count = 0;\n\trtp_session->samples_per_second =\n\t\t(uint32_t) ((double) (1000.0f / (double) (rtp_session->ms_per_packet / 1000)) * (double) rtp_session->samples_per_interval);\n\n\trtp_session->one_second = (rtp_session->samples_per_second / rtp_session->samples_per_interval);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_change_interval(switch_rtp_t *rtp_session, uint32_t ms_per_packet, uint32_t samples_per_interval)\n{\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS;\n\tint change_timer = 0;\n\n\tif (rtp_session->ms_per_packet != ms_per_packet || rtp_session->samples_per_interval != samples_per_interval) {\n\t\tchange_timer = 1;\n\t}\n\n\tswitch_rtp_set_interval(rtp_session, ms_per_packet, samples_per_interval);\n\n\tif (change_timer && rtp_session->timer_name) {\n\t\tREAD_INC(rtp_session);\n\t\tWRITE_INC(rtp_session);\n\n\t\tif (rtp_session->timer.timer_interface) {\n\t\t\tswitch_core_timer_destroy(&rtp_session->timer);\n\t\t}\n\n\t\tif (rtp_session->write_timer.timer_interface) {\n\t\t\tswitch_core_timer_destroy(&rtp_session->write_timer);\n\t\t}\n\n\t\tif ((status = switch_core_timer_init(&rtp_session->timer,\n\t\t\t\t\t\t\t\t\t\t\t rtp_session->timer_name, ms_per_packet / 1000,\n\t\t\t\t\t\t\t\t\t\t\t samples_per_interval, rtp_session->pool)) == SWITCH_STATUS_SUCCESS) {\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"RE-Starting timer [%s] %d bytes per %dms\\n\", rtp_session->timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t\tswitch_core_timer_init(&rtp_session->write_timer, rtp_session->timer_name, (ms_per_packet / 1000), samples_per_interval, rtp_session->pool);\n\t\t} else {\n\n\t\t\tmemset(&rtp_session->timer, 0, sizeof(rtp_session->timer));\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t  \"Problem RE-Starting timer [%s] %d bytes per %dms\\n\", rtp_session->timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t}\n\n\t\tWRITE_DEC(rtp_session);\n\t\tREAD_DEC(rtp_session);\n\t}\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_ssrc(switch_rtp_t *rtp_session, uint32_t ssrc)\n{\n\trtp_session->ssrc = ssrc;\n\trtp_session->send_msg.header.ssrc = htonl(rtp_session->ssrc);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_remote_ssrc(switch_rtp_t *rtp_session, uint32_t ssrc)\n{\n\trtp_session->remote_ssrc = ssrc;\n\trtp_session->flags[SWITCH_RTP_FLAG_DETECT_SSRC] = 0;\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_create(switch_rtp_t **new_rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t  switch_payload_t payload,\n\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_interval,\n\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t ms_per_packet,\n\t\t\t\t\t\t\t\t\t\t\t\t  switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID], char *timer_name, const char **err, switch_memory_pool_t *pool)\n{\n\tswitch_rtp_t *rtp_session = NULL;\n\tswitch_core_session_t *session = switch_core_memory_pool_get_data(pool, \"__session\");\n\tswitch_channel_t *channel = NULL;\n\n\tif (session) channel = switch_core_session_get_channel(session);\n\n\t*new_rtp_session = NULL;\n\n\tif (samples_per_interval > SWITCH_RTP_MAX_BUF_LEN) {\n\t\t*err = \"Packet Size Too Large!\";\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (!(rtp_session = switch_core_alloc(pool, sizeof(*rtp_session)))) {\n\t\t*err = \"Memory Error!\";\n\t\treturn SWITCH_STATUS_MEMERR;\n\t}\n\n\trtp_session->pool = pool;\n\trtp_session->te = INVALID_PT;\n\trtp_session->recv_te = INVALID_PT;\n\trtp_session->cng_pt = INVALID_PT;\n\trtp_session->session = session;\n\n\tswitch_mutex_init(&rtp_session->flag_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->read_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->write_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->ice_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_mutex_init(&rtp_session->dtmf_data.dtmf_mutex, SWITCH_MUTEX_NESTED, pool);\n\tswitch_queue_create(&rtp_session->dtmf_data.dtmf_queue, 100, rtp_session->pool);\n\tswitch_queue_create(&rtp_session->dtmf_data.dtmf_inqueue, 100, rtp_session->pool);\n\n\tswitch_rtp_set_flags(rtp_session, flags);\n\n\t/* for from address on recvfrom calls */\n\tswitch_sockaddr_create(&rtp_session->from_addr, pool);\n\tswitch_sockaddr_create(&rtp_session->rtp_from_addr, pool);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\tswitch_sockaddr_create(&rtp_session->rtcp_from_addr, pool);\n\t}\n\n\trtp_session->seq = (uint16_t) rand();\n\trtp_session->ssrc = (uint32_t) ((intptr_t) rtp_session + (switch_time_t) switch_epoch_time_now(NULL));\n#ifdef DEBUG_TS_ROLLOVER\n\trtp_session->last_write_ts = TS_ROLLOVER_START;\n#endif\n\trtp_session->stats.inbound.R = 100.0;\n\trtp_session->stats.inbound.mos = 4.5;\n\trtp_session->send_msg.header.ssrc = htonl(rtp_session->ssrc);\n\trtp_session->send_msg.header.ts = 0;\n\trtp_session->send_msg.header.m = 0;\n\trtp_session->send_msg.header.pt = (switch_payload_t) htonl(payload);\n\trtp_session->send_msg.header.version = 2;\n\trtp_session->send_msg.header.p = 0;\n\trtp_session->send_msg.header.x = 0;\n\trtp_session->send_msg.header.cc = 0;\n\n\trtp_session->recv_msg.header.ssrc = 0;\n\trtp_session->recv_msg.header.ts = 0;\n\trtp_session->recv_msg.header.seq = 0;\n\trtp_session->recv_msg.header.m = 0;\n\trtp_session->recv_msg.header.pt = (switch_payload_t) htonl(payload);\n\trtp_session->recv_msg.header.version = 2;\n\trtp_session->recv_msg.header.p = 0;\n\trtp_session->recv_msg.header.x = 0;\n\trtp_session->recv_msg.header.cc = 0;\n\n\trtp_session->payload = payload;\n\trtp_session->rtcp_last_sent = switch_micro_time_now();\n\n\tswitch_rtp_set_interval(rtp_session, ms_per_packet, samples_per_interval);\n\trtp_session->conf_samples_per_interval = samples_per_interval;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && zstr(timer_name)) {\n\t\ttimer_name = \"soft\";\n\t}\n\n\tif (!zstr(timer_name) && !strcasecmp(timer_name, \"none\")) {\n\t\ttimer_name = NULL;\n\t}\n\n\tif (!zstr(timer_name)) {\n\t\trtp_session->timer_name = switch_core_strdup(pool, timer_name);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\n\t\tif (switch_core_timer_init(&rtp_session->timer, timer_name, ms_per_packet / 1000, samples_per_interval, pool) == SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t  \"Starting timer [%s] %d bytes per %dms\\n\", timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t\tswitch_core_timer_init(&rtp_session->write_timer, timer_name, (ms_per_packet / 1000), samples_per_interval, pool);\n#ifdef DEBUG_TS_ROLLOVER\n\t\t\trtp_session->timer.tick = TS_ROLLOVER_START / samples_per_interval;\n#endif\n\t\t} else {\n\t\t\tmemset(&rtp_session->timer, 0, sizeof(rtp_session->timer));\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t  \"Error Starting timer [%s] %d bytes per %dms, async RTP disabled\\n\", timer_name, samples_per_interval, ms_per_packet / 1000);\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t\t}\n\t} else {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tif (switch_core_timer_init(&rtp_session->timer, \"soft\", 1, 90, pool) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Starting video timer.\\n\");\n\t\t\t}\n\n\t\t\t//switch_jb_create(&rtp_session->vb, 3, 10, rtp_session->pool);\n\t\t\t//switch_jb_debug_level(rtp_session->vb, 10);\n\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Not using a timer\\n\");\n\t\t}\n\n\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);\n\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t}\n\n\n\tif (channel) {\n\t\tswitch_channel_set_private(channel, \"__rtcp_audio_rtp_session\", rtp_session);\n\t}\n\n\n\t/* Jitter */\n\trtp_session->stats.inbound.last_proc_time = switch_micro_time_now() / 1000;\n\trtp_session->stats.inbound.jitter_n = 0;\n\trtp_session->stats.inbound.jitter_add = 0;\n\trtp_session->stats.inbound.jitter_addsq = 0;\n\trtp_session->stats.inbound.min_variance = 0;\n\trtp_session->stats.inbound.max_variance = 0;\n\n\t/* Burst and Packet Loss */\n\trtp_session->stats.inbound.lossrate = 0;\n\trtp_session->stats.inbound.burstrate = 0;\n\tmemset(rtp_session->stats.inbound.loss, 0, sizeof(rtp_session->stats.inbound.loss));\n\trtp_session->stats.inbound.last_loss = 0;\n\trtp_session->stats.inbound.last_processed_seq = -1;\n\n\trtp_session->ready = 1;\n\t*new_rtp_session = rtp_session;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_rtp_t *) switch_rtp_new(const char *rx_host,\n\t\t\t\t\t\t\t\t\t\t\t  switch_port_t rx_port,\n\t\t\t\t\t\t\t\t\t\t\t  const char *tx_host,\n\t\t\t\t\t\t\t\t\t\t\t  switch_port_t tx_port,\n\t\t\t\t\t\t\t\t\t\t\t  switch_payload_t payload,\n\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_interval,\n\t\t\t\t\t\t\t\t\t\t\t  uint32_t ms_per_packet,\n\t\t\t\t\t\t\t\t\t\t\t  switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID], char *timer_name, const char **err, switch_memory_pool_t *pool,\n                                              switch_port_t bundle_internal_port,\n                                              switch_port_t bundle_external_port)\n{\n\tswitch_rtp_t *rtp_session = NULL;\n\n\tif (zstr(rx_host)) {\n\t\t*err = \"Missing local host\";\n\t\tgoto end;\n\t}\n\n\tif (!rx_port) {\n\t\t*err = \"Missing local port\";\n\t\tgoto end;\n\t}\n\n\tif (zstr(tx_host)) {\n\t\t*err = \"Missing remote host\";\n\t\tgoto end;\n\t}\n\n\tif (!tx_port) {\n\t\t*err = \"Missing remote port\";\n\t\tgoto end;\n\t}\n\n\tif (switch_rtp_create(&rtp_session, payload, samples_per_interval, ms_per_packet, flags, timer_name, err, pool) != SWITCH_STATUS_SUCCESS) {\n\t\tgoto end;\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\n\tif (switch_rtp_set_local_address(rtp_session, rx_host, rx_port, err) != SWITCH_STATUS_SUCCESS) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\trtp_session = NULL;\n\t\tgoto end;\n\t}\n\n\tif (switch_rtp_set_remote_address(rtp_session, tx_host, tx_port, 0, SWITCH_TRUE, err) != SWITCH_STATUS_SUCCESS) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\trtp_session = NULL;\n\t\tgoto end;\n\t}\n\n end:\n\n\tif (rtp_session) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\trtp_session->ready = 2;\n\t\trtp_session->rx_host = switch_core_strdup(rtp_session->pool, rx_host);\n\t\trtp_session->rx_port = rx_port;\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_DETECT_SSRC);\n\t} else {\n\t\tswitch_rtp_release_port(rx_host, rx_port);\n\t}\n\n\treturn rtp_session;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_telephony_event(switch_rtp_t *rtp_session, switch_payload_t te)\n{\n\tif (te > 95) {\n\t\trtp_session->te = te;\n\t}\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_set_telephony_recv_event(switch_rtp_t *rtp_session, switch_payload_t te)\n{\n\tif (te > 95) {\n\t\trtp_session->recv_te = te;\n\t}\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_set_cng_pt(switch_rtp_t *rtp_session, switch_payload_t pt)\n{\n\trtp_session->cng_pt = pt;\n\trtp_session->flags[SWITCH_RTP_FLAG_AUTO_CNG] = 1;\n}\n\nSWITCH_DECLARE(switch_timer_t *) switch_rtp_get_media_timer(switch_rtp_t *rtp_session)\n{\n\n\tif (rtp_session && rtp_session->timer.timer_interface) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t}\n\t\treturn &rtp_session->timer;\n\t}\n\n\treturn NULL;\n}\n\n\nSWITCH_DECLARE(switch_jb_t *) switch_rtp_get_jitter_buffer(switch_rtp_t *rtp_session)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn NULL;\n\t}\n\n\treturn rtp_session->jb ? rtp_session->jb : rtp_session->vb;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_pause_jitter_buffer(switch_rtp_t *rtp_session, switch_bool_t pause)\n{\n\tint new_val;\n\n\tif (rtp_session->pause_jb && !pause) {\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\tswitch_jb_reset(rtp_session->vb);\n\t\t}\n\t}\n\n\tnew_val = pause ? 1 : -1;\n\n\tif (rtp_session->pause_jb + new_val > -1) {\n\t\trtp_session->pause_jb += new_val;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1,\n\t\t\t\t\t  \"Jitterbuffer %s is %s\\n\", rtp_type(rtp_session), rtp_session->pause_jb ? \"paused\" : \"enabled\");\n\t\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_deactivate_jitter_buffer(switch_rtp_t *rtp_session)\n{\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->flags[SWITCH_RTP_FLAG_KILL_JB]++;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_get_video_buffer_size(switch_rtp_t *rtp_session, uint32_t *min_frame_len, uint32_t *max_frame_len, uint32_t *cur_frame_len, uint32_t *highest_frame_len)\n{\n\n\tif (rtp_session->vb) {\n\t\treturn switch_jb_get_frames(rtp_session->vb, min_frame_len, max_frame_len, cur_frame_len, highest_frame_len);\n\t}\n\n\treturn SWITCH_STATUS_FALSE;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_set_video_buffer_size(switch_rtp_t *rtp_session, uint32_t frames, uint32_t max_frames)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (!max_frames) {\n\t\tmax_frames = rtp_session->last_max_vb_frames;\n\t}\n\n\tif (!max_frames || frames >= max_frames) {\n\t\tmax_frames = frames * 10;\n\t}\n\n\trtp_session->last_max_vb_frames = max_frames;\n\n\tif (!rtp_session->vb) {\n\t\tswitch_jb_create(&rtp_session->vb, rtp_session->flags[SWITCH_RTP_FLAG_TEXT] ? SJB_TEXT : SJB_VIDEO, frames, max_frames, rtp_session->pool);\n\t\tswitch_jb_set_session(rtp_session->vb, rtp_session->session);\n\t} else {\n\t\tswitch_jb_set_frames(rtp_session->vb, frames, max_frames);\n\t}\n\n\t//switch_rtp_flush(rtp_session);\n\tswitch_core_session_request_video_refresh(rtp_session->session);\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"Setting video buffer %u Frames.\\n\", frames);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_debug_jitter_buffer(switch_rtp_t *rtp_session, const char *name)\n{\n\tint x = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (name) x = atoi(name);\n\tif (x < 0) x = 0;\n\n\tif (rtp_session->jb) {\n\t\tswitch_jb_debug_level(rtp_session->jb, x);\n\t} else if (rtp_session->vb) {\n\t\tswitch_jb_debug_level(rtp_session->vb, x);\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_activate_jitter_buffer(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t queue_frames,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t max_queue_frames,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_packet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  uint32_t samples_per_second)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (queue_frames < 1) {\n\t\tqueue_frames = 3;\n\t}\n\n\tif (max_queue_frames < queue_frames) {\n\t\tmax_queue_frames = queue_frames * 3;\n\t}\n\n\n\n\tif (rtp_session->jb) {\n\t\tstatus = switch_jb_set_frames(rtp_session->jb, queue_frames, max_queue_frames);\n\t} else {\n\t\tREAD_INC(rtp_session);\n\t\tstatus = switch_jb_create(&rtp_session->jb, SJB_AUDIO, queue_frames, max_queue_frames, rtp_session->pool);\n\t\tswitch_jb_set_session(rtp_session->jb, rtp_session->session);\n\t\tswitch_jb_set_jitter_estimator(rtp_session->jb, &rtp_session->stats.rtcp.inter_jitter, samples_per_packet, samples_per_second);\n\t\tif (switch_true(switch_channel_get_variable_dup(switch_core_session_get_channel(rtp_session->session), \"jb_use_timestamps\", SWITCH_FALSE, -1))) {\n\t\t\tswitch_jb_ts_mode(rtp_session->jb, samples_per_packet, samples_per_second);\n\t\t}\n\t\t//switch_jb_debug_level(rtp_session->jb, 10);\n\t\tREAD_DEC(rtp_session);\n\t}\n\n\n\n\treturn status;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_activate_rtcp(switch_rtp_t *rtp_session, int send_rate, switch_port_t remote_port, switch_bool_t mux)\n{\n\tconst char *err = NULL;\n\n\tif (!rtp_session->ms_per_packet) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] = 1;\n\n\tif (!(rtp_session->remote_rtcp_port = remote_port)) {\n\t\trtp_session->remote_rtcp_port = rtp_session->remote_port + 1;\n\t}\n\n\tif (mux) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]++;\n\t}\n\n\n\tif (send_rate == -1) {\n\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] = 1;\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"RTCP passthru enabled. Remote Port: %d\\n\", rtp_session->remote_rtcp_port);\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"RTCP send rate is: %d and packet rate is: %d Remote Port: %d\\n\", \t\t\t\t\t\t  send_rate, rtp_session->ms_per_packet, rtp_session->remote_rtcp_port);\n\n\t\trtp_session->rtcp_interval = send_rate;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\n\t\tif (switch_sockaddr_info_get(&rtp_session->rtcp_remote_addr, rtp_session->eff_remote_host_str, SWITCH_UNSPEC,\n\t\t\t\t\t\t\t\t\t rtp_session->remote_rtcp_port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !rtp_session->rtcp_remote_addr) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"RTCP MUX Remote Address Error!\");\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\n\t\trtp_session->rtcp_local_addr = rtp_session->local_addr;\n\t\trtp_session->rtcp_from_addr = rtp_session->from_addr;\n\t\trtp_session->rtcp_sock_input = rtp_session->sock_input;\n\t\trtp_session->rtcp_sock_output = rtp_session->sock_output;\n\n\t\trtp_session->rtcp_recv_msg_p = (rtcp_msg_t *) &rtp_session->recv_msg;\n\n\t\treturn SWITCH_STATUS_SUCCESS;\n\n\t\t//return enable_remote_rtcp_socket(rtp_session, &err);\n\t} else {\n\t\trtp_session->rtcp_recv_msg_p = (rtcp_msg_t *) &rtp_session->rtcp_recv_msg;\n\t}\n\n\treturn enable_local_rtcp_socket(rtp_session, &err) || enable_remote_rtcp_socket(rtp_session, &err);\n\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_activate_ice(switch_rtp_t *rtp_session, char *login, char *rlogin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst char *password, const char *rpassword, ice_proto_t proto,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch_core_media_ice_type_t type, ice_t *ice_params)\n{\n\tchar ice_user[STUN_USERNAME_MAX_SIZE];\n\tchar user_ice[STUN_USERNAME_MAX_SIZE];\n\tchar luser_ice[SDP_UFRAG_MAX_SIZE];\n\tswitch_rtp_ice_t *ice;\n\tchar *host = NULL;\n\tswitch_port_t port = 0;\n\tchar bufc[50];\n\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (proto == IPR_RTP) {\n\t\tice = &rtp_session->ice;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_PAUSE] = 0;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_MUTE] = 0;\n\t} else {\n\t\tice = &rtp_session->rtcp_ice;\n\t}\n\n\tice->proto = proto;\n\n\tif ((type & ICE_VANILLA)) {\n\t\tswitch_snprintf(ice_user, sizeof(ice_user), \"%s:%s\", login, rlogin);\n\t\tswitch_snprintf(user_ice, sizeof(user_ice), \"%s:%s\", rlogin, login);\n\t\tswitch_snprintf(luser_ice, sizeof(luser_ice), \"%s%s\", rlogin, login);\n\t\tice->ready = ice->rready = 0;\n\t\tice->cand_responsive = 0;\n\t} else {\n\t\tswitch_snprintf(ice_user, sizeof(ice_user), \"%s%s\", login, rlogin);\n\t\tswitch_snprintf(user_ice, sizeof(user_ice), \"%s%s\", rlogin, login);\n\t\tswitch_snprintf(luser_ice, sizeof(luser_ice), \"\");\n\t\tice->ready = ice->rready = 1;\n\t\tice->cand_responsive = 0;\n\t}\n\n\tice->ice_user = switch_core_strdup(rtp_session->pool, ice_user);\n\tice->user_ice = switch_core_strdup(rtp_session->pool, user_ice);\n\tice->luser_ice = switch_core_strdup(rtp_session->pool, luser_ice);\n\tice->type = type;\n\tice->ice_params = ice_params;\n\tice->pass = \"\";\n\tice->rpass = \"\";\n\tice->next_run = switch_micro_time_now();\n\tice->initializing = 1;\n\n\tif (password) {\n\t\tice->pass = switch_core_strdup(rtp_session->pool, password);\n\t}\n\n\tif (rpassword) {\n\t\tice->rpass = switch_core_strdup(rtp_session->pool, rpassword);\n\t}\n\n\tif ((ice->type & ICE_VANILLA) && ice->ice_params) {\n\t\thost = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr;\n\t\tport = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port;\n\n\t\tif (!host || !port || switch_sockaddr_info_get(&ice->addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !ice->addr) {\n\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error setting remote host!\\n\");\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t} else {\n\t\tif (proto == IPR_RTP) {\n\t\t\tice->addr = rtp_session->remote_addr;\n\t\t} else {\n\t\t\tice->addr = rtp_session->rtcp_remote_addr;\n\t\t}\n\n\t\thost = (char *)switch_get_addr(bufc, sizeof(bufc), ice->addr);\n\t\tport = switch_sockaddr_get_port(ice->addr);\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_NOTICE, \"Activating %s %s ICE: %s %s:%d\\n\",\n\t\t\t\t\t  proto == IPR_RTP ? \"RTP\" : \"RTCP\", rtp_type(rtp_session), ice_user, host, port);\n\n\n\trtp_session->rtp_bugs |= RTP_BUG_ACCEPT_ANY_PACKETS;\n\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 1;\n\t\tswitch_rtp_break(rtp_session);\n\t}\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_flush(switch_rtp_t *rtp_session)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn;\n\t}\n\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_req_bitrate(switch_rtp_t *rtp_session, uint32_t bps)\n{\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__) || rtp_session->tmmbr) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->tmmbr = bps;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_ack_bitrate(switch_rtp_t *rtp_session, uint32_t bps)\n{\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__) || rtp_session->tmmbn) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\trtp_session->tmmbn = bps;\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(void) switch_rtp_video_refresh(switch_rtp_t *rtp_session)\n{\n\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__)) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (rtp_session->ice.ice_user || rtp_session->flags[SWITCH_RTP_FLAG_FIR] || rtp_session->flags[SWITCH_RTP_FLAG_OLD_FIR])) {\n\t\trtp_session->fir_count = 1;\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_video_loss(switch_rtp_t *rtp_session)\n{\n\n\tif (!rtp_write_ready(rtp_session, 0, __LINE__)) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (rtp_session->ice.ice_user || rtp_session->flags[SWITCH_RTP_FLAG_PLI])) {\n\t\trtp_session->pli_count = 1;\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_break(switch_rtp_t *rtp_session)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\tint ret = 1;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK]) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 0;\n\t\t\tret = 0;\n\t\t} else if (rtp_session->session) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\tif (switch_channel_test_flag(channel, CF_VIDEO_BREAK)) {\n\t\t\t\tswitch_channel_clear_flag(channel, CF_VIDEO_BREAK);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) return;\n\n\t\tswitch_rtp_video_refresh(rtp_session);\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\trtp_session->flags[SWITCH_RTP_FLAG_BREAK] = 1;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK]) {\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\treturn;\n\t}\n\n\tif (rtp_session->sock_input) {\n\t\tping_socket(rtp_session);\n\t}\n\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n}\n\nSWITCH_DECLARE(void) switch_rtp_kill_socket(switch_rtp_t *rtp_session)\n{\n\tswitch_assert(rtp_session != NULL);\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_IO]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_IO] = 0;\n\t\tif (rtp_session->sock_input) {\n\t\t\tping_socket(rtp_session);\n\t\t\tswitch_socket_shutdown(rtp_session->sock_input, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\t\tif (rtp_session->sock_output && rtp_session->sock_output != rtp_session->sock_input) {\n\t\t\tswitch_socket_shutdown(rtp_session->sock_output, SWITCH_SHUTDOWN_READWRITE);\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\tif (rtp_session->sock_input && rtp_session->rtcp_sock_input && rtp_session->rtcp_sock_input != rtp_session->sock_input) {\n\t\t\t\tping_socket(rtp_session);\n\t\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_input, SWITCH_SHUTDOWN_READWRITE);\n\t\t\t}\n\t\t\tif (rtp_session->rtcp_sock_output && rtp_session->rtcp_sock_output != rtp_session->sock_output && rtp_session->rtcp_sock_output != rtp_session->rtcp_sock_input) {\n\t\t\t\tswitch_socket_shutdown(rtp_session->rtcp_sock_output, SWITCH_SHUTDOWN_READWRITE);\n\t\t\t}\n\t\t}\n\t}\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n}\n\nSWITCH_DECLARE(uint8_t) switch_rtp_ready(switch_rtp_t *rtp_session)\n{\n\tuint8_t ret;\n\n\tif (!rtp_session || !rtp_session->flag_mutex || rtp_session->flags[SWITCH_RTP_FLAG_SHUTDOWN]) {\n\t\treturn 0;\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\tret = (rtp_session->flags[SWITCH_RTP_FLAG_IO] && rtp_session->sock_input && rtp_session->sock_output && rtp_session->remote_addr\n\t\t   && rtp_session->ready == 2) ? 1 : 0;\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\treturn ret;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_sync_stats(switch_rtp_t *rtp_session)\n{\n\tif (!rtp_session) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->vad_data.session);\n\n\t\tswitch_channel_set_variable_printf(channel, \"vad_total_talk_time_ms\", \"%u\", (uint32_t)rtp_session->vad_data.total_talk_time / 1000);\n\t\tswitch_channel_set_variable_printf(channel, \"vad_total_talk_time_sec\", \"%u\", (uint32_t)rtp_session->vad_data.total_talk_time / 1000000);\n\t}\n\n\tdo_mos(rtp_session);\n\n\tif (rtp_session->stats.inbound.error_log && !rtp_session->stats.inbound.error_log->stop) {\n\t\trtp_session->stats.inbound.error_log->stop = switch_micro_time_now();\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\n\nSWITCH_DECLARE(void) switch_rtp_destroy(switch_rtp_t **rtp_session)\n{\n\tvoid *pop;\n\tswitch_socket_t *sock;\n#ifdef ENABLE_SRTP\n\tint x;\n#endif\n\n\tif (!rtp_session || !*rtp_session || !(*rtp_session)->ready) {\n\t\treturn;\n\t}\n\n\tif ((*rtp_session)->vb) {\n\t\t/* retrieve counter for ALL received NACKed packets */\n\t\tuint32_t nack_jb_ok = switch_jb_get_nack_success((*rtp_session)->vb);\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG((*rtp_session)->session), SWITCH_LOG_DEBUG, \n\t\t\t\t\"NACK: Added to JB: [%u]\\n\", nack_jb_ok);\n\t}\n\n\t(*rtp_session)->flags[SWITCH_RTP_FLAG_SHUTDOWN] = 1;\n\n\tREAD_INC((*rtp_session));\n\tWRITE_INC((*rtp_session));\n\n\t(*rtp_session)->ready = 0;\n\n\tWRITE_DEC((*rtp_session));\n\tREAD_DEC((*rtp_session));\n\n\tif ((*rtp_session)->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\tswitch_rtp_disable_vad(*rtp_session);\n\t}\n\n\tswitch_mutex_lock((*rtp_session)->flag_mutex);\n\n\tswitch_rtp_kill_socket(*rtp_session);\n\n\twhile (switch_queue_trypop((*rtp_session)->dtmf_data.dtmf_inqueue, &pop) == SWITCH_STATUS_SUCCESS) {\n\t\tswitch_safe_free(pop);\n\t}\n\n\twhile (switch_queue_trypop((*rtp_session)->dtmf_data.dtmf_queue, &pop) == SWITCH_STATUS_SUCCESS) {\n\t\tswitch_safe_free(pop);\n\t}\n\n\tif ((*rtp_session)->jb) {\n\t\tswitch_jb_destroy(&(*rtp_session)->jb);\n\t}\n\n\tif ((*rtp_session)->vb) {\n\t\tswitch_jb_destroy(&(*rtp_session)->vb);\n\t}\n\n\tif ((*rtp_session)->vbw) {\n\t\tswitch_jb_destroy(&(*rtp_session)->vbw);\n\t}\n\n\tif ((*rtp_session)->dtls && (*rtp_session)->dtls == (*rtp_session)->rtcp_dtls) {\n\t\t(*rtp_session)->rtcp_dtls = NULL;\n\t}\n\n\tif ((*rtp_session)->dtls) {\n\t\tfree_dtls(&(*rtp_session)->dtls);\n\t}\n\n\tif ((*rtp_session)->rtcp_dtls) {\n\t\tfree_dtls(&(*rtp_session)->rtcp_dtls);\n\t}\n\n\tif ((*rtp_session)->rtcp_sock_input == (*rtp_session)->sock_input) {\n\t\t(*rtp_session)->rtcp_sock_input = NULL;\n\t}\n\n\tif ((*rtp_session)->rtcp_sock_output == (*rtp_session)->sock_output) {\n\t\t(*rtp_session)->rtcp_sock_output = NULL;\n\t}\n\n\tsock = (*rtp_session)->sock_input;\n\t(*rtp_session)->sock_input = NULL;\n\tswitch_socket_close(sock);\n\n\tif ((*rtp_session)->sock_output != sock) {\n\t\tsock = (*rtp_session)->sock_output;\n\t\t(*rtp_session)->sock_output = NULL;\n\t\tswitch_socket_close(sock);\n\t}\n\n\tif ((sock = (*rtp_session)->rtcp_sock_input)) {\n\t\t(*rtp_session)->rtcp_sock_input = NULL;\n\t\tswitch_socket_close(sock);\n\t}\n\n\tif ((*rtp_session)->rtcp_sock_output && (*rtp_session)->rtcp_sock_output != sock) {\n\t\tsock = (*rtp_session)->rtcp_sock_output;\n\t\t(*rtp_session)->rtcp_sock_output = NULL;\n\t\tswitch_socket_close(sock);\n\t}\n\n#ifdef ENABLE_SRTP\n\tif ((*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\tfor(x = 0; x < 2; x++) {\n\t\t\tif ((*rtp_session)->send_ctx[x]) {\n\t\t\t\tsrtp_dealloc((*rtp_session)->send_ctx[x]);\n\t\t\t\t(*rtp_session)->send_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t\t(*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\t}\n\n\tif ((*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {\n\t\tfor (x = 0; x < 2; x++) {\n\t\t\tif ((*rtp_session)->recv_ctx[x]) {\n\t\t\t\tsrtp_dealloc((*rtp_session)->recv_ctx[x]);\n\t\t\t\t(*rtp_session)->recv_ctx[x] = NULL;\n\t\t\t}\n\t\t}\n\t\t(*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\t}\n#endif\n\n\tif ((*rtp_session)->timer.timer_interface) {\n\t\tswitch_core_timer_destroy(&(*rtp_session)->timer);\n\t}\n\n\tif ((*rtp_session)->write_timer.timer_interface) {\n\t\tswitch_core_timer_destroy(&(*rtp_session)->write_timer);\n\t}\n\n\tswitch_rtp_release_port((*rtp_session)->rx_host, (*rtp_session)->rx_port);\n\tswitch_mutex_unlock((*rtp_session)->flag_mutex);\n\n\treturn;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_interdigit_delay(switch_rtp_t *rtp_session, uint32_t delay)\n{\n\trtp_session->interdigit_delay = delay;\n}\n\nSWITCH_DECLARE(switch_socket_t *) switch_rtp_get_rtp_socket(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->sock_input;\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_get_default_samples_per_interval(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->samples_per_interval;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_default_payload(switch_rtp_t *rtp_session, switch_payload_t payload)\n{\n\trtp_session->payload = payload;\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_get_default_payload(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->payload;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_invalid_handler(switch_rtp_t *rtp_session, switch_rtp_invalid_handler_t on_invalid)\n{\n\trtp_session->invalid_handler = on_invalid;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_flags(switch_rtp_t *rtp_session, switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID])\n{\n\tint i;\n\n\tfor(i = 0; i < SWITCH_RTP_FLAG_INVALID; i++) {\n\t\tif (flags[i]) {\n\t\t\tswitch_rtp_set_flag(rtp_session, i);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_clear_flags(switch_rtp_t *rtp_session, switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID])\n{\n\tint i;\n\n\tfor(i = 0; i < SWITCH_RTP_FLAG_INVALID; i++) {\n\t\tif (flags[i]) {\n\t\t\tswitch_rtp_clear_flag(rtp_session, i);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_flag(switch_rtp_t *rtp_session, switch_rtp_flag_t flag)\n{\n\tint old_flag = rtp_session->flags[flag];\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\trtp_session->flags[flag] = 1;\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\tif (flag == SWITCH_RTP_FLAG_PASSTHRU) {\n\t\tif (!old_flag) {\n\t\t\tswitch_rtp_pause_jitter_buffer(rtp_session, SWITCH_TRUE);\n\t\t}\n\t} else if (flag == SWITCH_RTP_FLAG_DTMF_ON) {\n\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\t} else if (flag == SWITCH_RTP_FLAG_FLUSH) {\n\t\treset_jitter_seq(rtp_session);\n\t} else if (flag == SWITCH_RTP_FLAG_AUTOADJ) {\n\t\trtp_session->autoadj_window = 20;\n\t\trtp_session->autoadj_threshold = 10;\n\t\trtp_session->autoadj_tally = 0;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RTCP_AUTOADJ] = 1;\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\t\trtp_session->rtcp_autoadj_window = 20;\n\t\trtp_session->rtcp_autoadj_threshold = 1;\n\t\trtp_session->rtcp_autoadj_tally = 0;\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\tconst char *x = switch_channel_get_variable(channel, \"rtp_auto_adjust_threshold\");\n\t\t\tif (x && *x) {\n\t\t\t\tint xn = atoi(x);\n\t\t\t\tif (xn > 0 && xn <= 65535) {\n\t\t\t\t\trtp_session->autoadj_window = xn*2;\n\t\t\t\t\trtp_session->autoadj_threshold = xn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\trtp_flush_read_buffer(rtp_session, SWITCH_RTP_FLUSH_ONCE);\n\n\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\t} else if (flag == SWITCH_RTP_FLAG_NOBLOCK && rtp_session->sock_input) {\n\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);\n\t}\n\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_test_flag(switch_rtp_t *rtp_session, switch_rtp_flag_t flags)\n{\n\treturn (uint32_t) rtp_session->flags[flags];\n}\n\nSWITCH_DECLARE(void) switch_rtp_clear_flag(switch_rtp_t *rtp_session, switch_rtp_flag_t flag)\n{\n\tint old_flag = rtp_session->flags[flag];\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\trtp_session->flags[flag] = 0;\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\tif (flag == SWITCH_RTP_FLAG_PASSTHRU) {\n\t\tif (old_flag) {\n\t\t\tswitch_rtp_pause_jitter_buffer(rtp_session, SWITCH_FALSE);\n\t\t}\n\t} else if (flag == SWITCH_RTP_FLAG_DTMF_ON) {\n\t\trtp_session->stats.inbound.last_processed_seq = 0;\n\t} else if (flag == SWITCH_RTP_FLAG_PAUSE) {\n\t\treset_jitter_seq(rtp_session);\n\t} else if (flag == SWITCH_RTP_FLAG_NOBLOCK && rtp_session->sock_input) {\n\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, FALSE);\n\t}\n}\n\nstatic void set_dtmf_delay(switch_rtp_t *rtp_session, uint32_t ms, uint32_t max_ms)\n{\n\tint upsamp, max_upsamp;\n\n\n\tif (!max_ms) max_ms = ms;\n\n\tupsamp = ms * (rtp_session->samples_per_second / 1000);\n\tmax_upsamp = max_ms * (rtp_session->samples_per_second / 1000);\n\t\n\trtp_session->sending_dtmf = 0;\n\trtp_session->queue_delay = upsamp;\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\trtp_session->max_next_write_samplecount = rtp_session->timer.samplecount + max_upsamp;\n\t\trtp_session->next_write_samplecount = rtp_session->timer.samplecount + upsamp;\n\t\trtp_session->last_write_ts += upsamp;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Queue digit delay of %dms\\n\", ms);\n}\n\nstatic void do_2833(switch_rtp_t *rtp_session)\n{\n\tswitch_frame_flag_t flags = 0;\n\tuint32_t samples = rtp_session->samples_per_interval;\n\n\tif (rtp_session->dtmf_data.out_digit_dur > 0) {\n\t\tint x, loops = 1;\n\n\t\tif (!rtp_session->last_write_ts) {\n\t\t\tif (rtp_session->timer.timer_interface) {\n\t\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\t\trtp_session->last_write_ts = rtp_session->write_timer.samplecount;\n\t\t\t} else {\n\t\t\t\trtp_session->last_write_ts = rtp_session->samples_per_interval;\n\t\t\t}\n\t\t}\n\n\t\trtp_session->dtmf_data.out_digit_sofar += samples;\n\t\trtp_session->dtmf_data.out_digit_sub_sofar += samples;\n\n\t\tif (rtp_session->dtmf_data.out_digit_sub_sofar > 0xFFFF) {\n\t\t\trtp_session->dtmf_data.out_digit_sub_sofar = samples;\n\t\t\trtp_session->dtmf_data.timestamp_dtmf += 0xFFFF;\n\t\t}\n\n\t\tif (rtp_session->dtmf_data.out_digit_sofar >= rtp_session->dtmf_data.out_digit_dur) {\n\t\t\trtp_session->dtmf_data.out_digit_packet[1] |= 0x80;\n\t\t\tloops = 3;\n\t\t}\n\n\t\trtp_session->dtmf_data.out_digit_packet[2] = (unsigned char) (rtp_session->dtmf_data.out_digit_sub_sofar >> 8);\n\t\trtp_session->dtmf_data.out_digit_packet[3] = (unsigned char) rtp_session->dtmf_data.out_digit_sub_sofar;\n\n\t\tfor (x = 0; x < loops; x++) {\n\t\t\tswitch_size_t wrote = switch_rtp_write_manual(rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_packet, 4, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  rtp_session->te, rtp_session->dtmf_data.timestamp_dtmf, &flags);\n\n\t\t\trtp_session->stats.outbound.raw_bytes += wrote;\n\t\t\trtp_session->stats.outbound.dtmf_packet_count++;\n\n\t\t\tif (loops == 1) {\n\t\t\t\trtp_session->last_write_ts += samples;\n\n\t\t\t\tif (rtp_session->rtp_bugs & RTP_BUG_SONUS_SEND_INVALID_TIMESTAMP_2833) {\n\t\t\t\t\trtp_session->dtmf_data.timestamp_dtmf = rtp_session->last_write_ts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Send %s packet for [%c] ts=%u dur=%d/%d/%d seq=%d lw=%u\\n\",\n\t\t\t\t\t\t\t  loops == 1 ? \"middle\" : \"end\", rtp_session->dtmf_data.out_digit,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.timestamp_dtmf,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sofar,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sub_sofar, rtp_session->dtmf_data.out_digit_dur, rtp_session->seq, rtp_session->last_write_ts);\n\t\t}\n\n\t\tif (loops != 1) {\n\t\t\trtp_session->sending_dtmf = 0;\n\t\t\trtp_session->need_mark = 1;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\t\trtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;\n\t\t\t}\n\n\t\t\trtp_session->dtmf_data.out_digit_dur = 0;\n\n\t\t\tif (rtp_session->interdigit_delay) {\n\t\t\t\tset_dtmf_delay(rtp_session, rtp_session->interdigit_delay, rtp_session->interdigit_delay * 10);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!rtp_session->dtmf_data.out_digit_dur && rtp_session->dtmf_data.dtmf_queue && switch_queue_size(rtp_session->dtmf_data.dtmf_queue)) {\n\t\tvoid *pop;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\tif (rtp_session->timer.samplecount < rtp_session->next_write_samplecount) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (rtp_session->timer.samplecount >= rtp_session->max_next_write_samplecount) {\n\t\t\t\trtp_session->queue_delay = 0;\n\t\t\t}\n\n\t\t} else if (rtp_session->queue_delay) {\n\t\t\tif (rtp_session->delay_samples >= rtp_session->samples_per_interval) {\n\t\t\t\trtp_session->delay_samples -= rtp_session->samples_per_interval;\n\t\t\t} else {\n\t\t\t\trtp_session->delay_samples = 0;\n\t\t\t}\n\n\t\t\tif (!rtp_session->delay_samples) {\n\t\t\t\trtp_session->queue_delay = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->queue_delay) {\n\t\t\treturn;\n\t\t}\n\n\n\t\tif (!rtp_session->sending_dtmf) {\n\t\t\trtp_session->sending_dtmf = 1;\n\t\t}\n\n\t\tif (switch_queue_trypop(rtp_session->dtmf_data.dtmf_queue, &pop) == SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_dtmf_t *rdigit = pop;\n\t\t\tswitch_size_t wrote;\n\n\t\t\tif (rdigit->digit == 'w') {\n\t\t\t\tset_dtmf_delay(rtp_session, 500, 0);\n\t\t\t\tfree(rdigit);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (rdigit->digit == 'W') {\n\t\t\t\tset_dtmf_delay(rtp_session, 1000, 0);\n\t\t\t\tfree(rdigit);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmemset(rtp_session->dtmf_data.out_digit_packet, 0, 4);\n\t\t\trtp_session->dtmf_data.out_digit_sofar = samples;\n\t\t\trtp_session->dtmf_data.out_digit_sub_sofar = samples;\n\t\t\trtp_session->dtmf_data.out_digit_dur = rdigit->duration;\n\t\t\trtp_session->dtmf_data.out_digit = rdigit->digit;\n\t\t\trtp_session->dtmf_data.out_digit_packet[0] = (unsigned char) switch_char_to_rfc2833(rdigit->digit);\n\t\t\trtp_session->dtmf_data.out_digit_packet[1] = 13;\n\t\t\trtp_session->dtmf_data.out_digit_packet[2] = (unsigned char) (rtp_session->dtmf_data.out_digit_sub_sofar >> 8);\n\t\t\trtp_session->dtmf_data.out_digit_packet[3] = (unsigned char) rtp_session->dtmf_data.out_digit_sub_sofar;\n\n\n\t\t\trtp_session->dtmf_data.timestamp_dtmf = rtp_session->last_write_ts + samples;\n\t\t\trtp_session->last_write_ts = rtp_session->dtmf_data.timestamp_dtmf;\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 0;\n\n\t\t\twrote = switch_rtp_write_manual(rtp_session,\n\t\t\t\t\t\t\t\t\t\t\trtp_session->dtmf_data.out_digit_packet,\n\t\t\t\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t\t\t\trtp_session->rtp_bugs & RTP_BUG_CISCO_SKIP_MARK_BIT_2833 ? 0 : 1,\n\t\t\t\t\t\t\t\t\t\t\trtp_session->te, rtp_session->dtmf_data.timestamp_dtmf, &flags);\n\n\n\t\t\trtp_session->stats.outbound.raw_bytes += wrote;\n\t\t\trtp_session->stats.outbound.dtmf_packet_count++;\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Send start packet for [%c] ts=%u dur=%d/%d/%d seq=%d lw=%u\\n\",\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.timestamp_dtmf,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sofar,\n\t\t\t\t\t\t\t  rtp_session->dtmf_data.out_digit_sub_sofar, rtp_session->dtmf_data.out_digit_dur, rtp_session->seq, rtp_session->last_write_ts);\n\n\t\t\tfree(rdigit);\n\t\t}\n\t}\n}\n\nSWITCH_DECLARE(void) rtp_flush_read_buffer(switch_rtp_t *rtp_session, switch_rtp_flush_t flush)\n{\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] ||\n\t\trtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\treturn;\n\t}\n\n\n\tif (switch_rtp_ready(rtp_session)) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_FLUSH] = 1;\n\t\treset_jitter_seq(rtp_session);\n\n\t\tswitch (flush) {\n\t\tcase SWITCH_RTP_FLUSH_STICK:\n\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_STICKY_FLUSH);\n\t\t\tbreak;\n\t\tcase SWITCH_RTP_FLUSH_UNSTICK:\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_STICKY_FLUSH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int jb_valid(switch_rtp_t *rtp_session)\n{\n\tif (rtp_session->ice.ice_user) {\n\t\tif (!rtp_session->ice.ready && rtp_session->ice.rready) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (rtp_session->dtls && rtp_session->dtls->state != DS_READY) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic switch_size_t do_flush(switch_rtp_t *rtp_session, int force, switch_size_t bytes_in)\n{\n\tint was_blocking = 0;\n\tswitch_size_t bytes;\n\tswitch_size_t bytes_out = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn 0;\n\t}\n\n\treset_jitter_seq(rtp_session);\n\n\tif (!force) {\n\t\tif ((rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) ||\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] ||\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_UDPTL] ||\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]\n\t\t\t) {\n\t\t\treturn bytes_in;\n\t\t}\n\t}\n\n\tREAD_INC(rtp_session);\n\n\tif (switch_rtp_ready(rtp_session) ) {\n\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\t//switch_jb_reset(rtp_session->jb);\n\t\t\tbytes_out = bytes_in;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (rtp_session->vbw) {\n\t\t\tswitch_jb_reset(rtp_session->vbw);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\t//switch_jb_reset(rtp_session->vb);\n\t\t\tbytes_out = bytes_in;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),\n\t\t\t\t\t\t\t  SWITCH_LOG_CONSOLE, \"%s FLUSH\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\"\n\t\t\t\t\t\t\t  );\n\t\t}\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK]) {\n\t\t\twas_blocking = 1;\n\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);\n\t\t}\n\n\t\t// before processing/flushing packets, if current packet is rfc2833, handle it (else it would be lost)\n\t\tif (bytes_in > rtp_header_len && rtp_session->last_rtp_hdr.version == 2 && rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\t    int do_cng = 0;\n#ifdef DEBUG_2833\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"*** Handling current RTP packet before flushing. seq=%u ***\\n\", ntohs(rtp_session->last_rtp_hdr.seq));\n#endif\n\t\t    handle_rfc2833(rtp_session, bytes_in, &do_cng);\n\t\t}\n\n\t\tdo {\n\t\t\tif (switch_rtp_ready(rtp_session)) {\n\t\t\t\tbytes = sizeof(rtp_msg_t);\n\t\t\t\tswitch_socket_recvfrom(rtp_session->from_addr, rtp_session->sock_input, 0, (void *) &rtp_session->recv_msg, &bytes);\n\n\t\t\t\tif (bytes) {\n\t\t\t\t\tint do_cng = 0;\n\n\t\t\t\t\tif (rtp_session->media_timeout) {\n\t\t\t\t\t\trtp_session->last_media = switch_micro_time_now();\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Make sure to handle RFC2833 packets, even if we're flushing the packets */\n\t\t\t\t\tif (bytes > rtp_header_len && rtp_session->recv_msg.header.version == 2 && rtp_session->recv_msg.header.pt == rtp_session->recv_te) {\n\t\t\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\t\t\thandle_rfc2833(rtp_session, bytes, &do_cng);\n#ifdef DEBUG_2833\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"*** RTP packet handled in flush loop %d ***\\n\", do_cng);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\t\trtp_session->stats.inbound.raw_bytes += bytes;\n\t\t\t\t\trtp_session->stats.inbound.flush_packet_count++;\n\t\t\t\t\trtp_session->stats.inbound.packet_count++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (bytes > 0);\n\n#ifdef DEBUG_2833\n        if (flushed) {\n            switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"*** do_flush: total flushed packets: %ld ***\\n\",(long)flushed);\n        }\n#endif\n\n\n\t\tif (was_blocking && switch_rtp_ready(rtp_session)) {\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);\n\t\t\tswitch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, FALSE);\n\t\t}\n\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->session) {\n\t\t\t//int type = 1; // sum flags: 1 encoder; 2; decoder\n\t\t\t//switch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO, SWITCH_IO_READ, SCC_VIDEO_RESET, SCCT_INT, (void *)&type, NULL, NULL);\n\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t}\n\t}\n\n end:\n\n\tREAD_DEC(rtp_session);\n\n\treturn bytes_out;\n}\n\nstatic int check_recv_payload(switch_rtp_t *rtp_session)\n{\n\tint ok = 1;\n\n\tif (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PAYLOAD) && rtp_session->pmaps && *rtp_session->pmaps) {\n\t\tpayload_map_t *pmap;\n\t\tok = 0;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\n\t\tfor (pmap = *rtp_session->pmaps; pmap && pmap->allocated; pmap = pmap->next) {\n\t\t\tif (!pmap->negotiated) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rtp_session->last_rtp_hdr.pt == pmap->pt) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t}\n\n\treturn ok;\n}\n\nstatic int get_recv_payload(switch_rtp_t *rtp_session)\n{\n\tint r = -1;\n\n\tif (rtp_session->pmaps && *rtp_session->pmaps) {\n\t\tpayload_map_t *pmap;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\n\t\tfor (pmap = *rtp_session->pmaps; pmap && pmap->allocated; pmap = pmap->next) {\n\t\t\tif (pmap->negotiated) {\n\t\t\t\tr = pmap->pt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t}\n\n\treturn r;\n}\n\n#define return_cng_frame() do_cng = 1; goto timer_check\n\nstatic switch_status_t read_rtp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes, switch_frame_flag_t *flags,\n\t\t\t\t\t\t\t\t\t   payload_map_t **pmapP, switch_status_t poll_status, switch_bool_t return_jb_packet)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\tuint32_t ts = 0;\n\tunsigned char *b = NULL;\n\tint sync = 0;\n\tswitch_time_t now;\n\tswitch_size_t xcheck_jitter = 0;\n\tint tries = 0;\n\tint block = 0;\n\n\tswitch_assert(bytes);\n more:\n\n\ttries++;\n\n\tif (tries > 20) {\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t}\n\t\trtp_session->punts++;\n\t\trtp_session->clean = 0;\n\t\t*bytes = 0;\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tif (block) {\n\t\tint to = 20000;\n\t\tint fdr = 0;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tto = 100000;\n\t\t} else {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->timer.interval) {\n\t\t\t\tto = rtp_session->timer.interval * 1000;\n\t\t\t}\n\t\t}\n\n\t\tpoll_status = switch_poll(rtp_session->read_pollfd, 1, &fdr, to);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->timer.interval) {\n\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t}\n\n\t\tif (rtp_session->session) {\n\t\t\tswitch_ivr_parse_all_messages(rtp_session->session);\n\t\t}\n\n\t\tblock = 0;\n\t}\n\n\t*bytes = sizeof(rtp_msg_t);\n\tsync = 0;\n\n\trtp_session->has_rtp = 0;\n\trtp_session->has_ice = 0;\n\trtp_session->has_rtcp = 0;\n\tif (rtp_session->dtls) {\n\t\trtp_session->dtls->bytes = 0;\n\t\trtp_session->dtls->data = NULL;\n\t}\n\tmemset(&rtp_session->last_rtp_hdr, 0, sizeof(rtp_session->last_rtp_hdr));\n\n\tif (poll_status == SWITCH_STATUS_SUCCESS) {\n\t\tstatus = switch_socket_recvfrom(rtp_session->from_addr, rtp_session->sock_input, 0, (void *) &rtp_session->recv_msg, bytes);\n\t} else {\n\t\t*bytes = 0;\n\t}\n\n\tif (*bytes) {\n\t\tb = (unsigned char *) &rtp_session->recv_msg;\n\n\t\t/* version 2 probably rtp */\n\t\trtp_session->has_rtp = (rtp_session->recv_msg.header.version == 2);\n\n\t\tif (rtp_session->media_timeout || rtp_session->ice.ice_user) {\n\t\t\trtp_session->last_media = switch_micro_time_now();\n\t\t}\n\n\t\tif ((*b >= 20) && (*b <= 64)) {\n\t\t\tif (rtp_session->dtls) {\n\t\t\t\trtp_session->dtls->bytes = *bytes;\n\t\t\t\trtp_session->dtls->data = (void *) &rtp_session->recv_msg;\n\t\t\t}\n\t\t\trtp_session->has_ice = 0;\n\t\t\trtp_session->has_rtp = 0;\n\t\t\trtp_session->has_rtcp = 0;\n\t\t} else if (*b == 0 || *b == 1) {\n\t\t\trtp_session->has_ice = 1;\n\t\t\trtp_session->has_rtp = 0;\n\t\t\trtp_session->has_rtcp = 0;\n\t\t} else {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\tswitch(rtp_session->recv_msg.header.pt) {\n\t\t\t\tcase 64:        //  192 Full INTRA-frame request.\n\t\t\t\tcase 72:        //  200 Sender report.\n\t\t\t\tcase 73:        //  201 Receiver report.\n\t\t\t\tcase 74:        //  202 Source description.\n\t\t\t\tcase 75:        //  203 Goodbye.\n\t\t\t\tcase 76:        //  204 Application-defined.\n\t\t\t\tcase 77:        //  205 Transport layer FB message.\n\t\t\t\tcase 78:        //  206 Payload-specific FB message.\n\t\t\t\tcase 79:        //  207 Extended report.\n\t\t\t\t\trtp_session->has_rtcp = 1;\n\t\t\t\t\trtp_session->has_rtp = 0;\n\t\t\t\t\trtp_session->has_ice = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (rtp_session->rtcp_recv_msg_p->header.version == 2 &&\n\t\t\t\t\t\trtp_session->rtcp_recv_msg_p->header.type > 199 && rtp_session->rtcp_recv_msg_p->header.type < 208) {\n\t\t\t\t\t\trtp_session->has_rtcp = 1;\n\t\t\t\t\t\trtp_session->has_rtp = 0;\n\t\t\t\t\t\trtp_session->has_ice = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->has_rtp || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\t\trtp_session->missed_count = 0;\n\t\t\tswitch_cp_addr(rtp_session->rtp_from_addr, rtp_session->from_addr);\n\t\t}\n\n\t\tif (rtp_session->has_rtp) {\n\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\t\trtp_session->last_rtp_hdr.pt != 13 &&\n\t\t\t\trtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\t\t\trtp_session->last_rtp_hdr.pt != rtp_session->cng_pt) {\n\t\t\t\tint accept_packet = 1;\n\n\n\t\t\t\tif (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PAYLOAD) && \n\t\t\t\t\t!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PACKETS) && rtp_session->pmaps && *rtp_session->pmaps) {\n\t\t\t\t\tpayload_map_t *pmap;\n\t\t\t\t\taccept_packet = 0;\n\n\t\t\t\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\t\t\t\tfor (pmap = *rtp_session->pmaps; pmap && pmap->allocated; pmap = pmap->next) {\n\n\t\t\t\t\t\tif (!pmap->negotiated) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rtp_session->last_rtp_hdr.pt == pmap->pt) {\n\t\t\t\t\t\t\taccept_packet = 1;\n\t\t\t\t\t\t\tif (pmapP) {\n\t\t\t\t\t\t\t\t*pmapP = pmap;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t\t\t\t}\n\n\t\t\t\tif (!accept_packet) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1,\n\t\t\t\t\t\t\t\t\t  \"Invalid Packet SEQ: %d TS: %d PT:%d ignored\\n\",\n\t\t\t\t\t\t\t\t\t  ntohs(rtp_session->recv_msg.header.seq), ntohl(rtp_session->last_rtp_hdr.ts), rtp_session->last_rtp_hdr.pt);\n\t\t\t\t\t*bytes = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DETECT_SSRC]) {\n\t\t\t\t//if (rtp_session->remote_ssrc != rtp_session->stats.rtcp.peer_ssrc && rtp_session->stats.rtcp.peer_ssrc) {\n\t\t\t\t//\trtp_session->remote_ssrc = rtp_session->stats.rtcp.peer_ssrc;\n\t\t\t\t//}\n\n\t\t\t\tif (rtp_session->remote_ssrc != rtp_session->last_rtp_hdr.ssrc && rtp_session->last_rtp_hdr.ssrc) {\n\t\t\t\t\trtp_session->remote_ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rtp_session->vb && (!rtp_session->jb || rtp_session->pause_jb || !jb_valid(rtp_session))) {\n\t\tif (*bytes > rtp_header_len && (rtp_session->has_rtp && check_recv_payload(rtp_session))) {\n\t\t\txcheck_jitter = *bytes;\n\t\t\tcheck_jitter(rtp_session);\n\t\t}\n\t}\n\n\tif (check_rtcp_and_ice(rtp_session) == -1) {\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF CHECK FAIL\\n\");\n\t\t//}\n\t\treturn SWITCH_STATUS_GENERR;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\tgoto udptl;\n\t}\n\n\n\tif (*bytes) {\n\t\t*flags &= ~SFF_PROXY_PACKET;\n\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t//\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"WTF BYTES %ld b=%d\\n\", *bytes, *b);\n\t\t//}\n\n\n\t\tif (rtp_session->has_ice) {\n\t\t\tif (rtp_session->ice.ice_user) {\n\t\t\t\thandle_ice(rtp_session, &rtp_session->ice, (void *) &rtp_session->recv_msg, *bytes);\n\t\t\t}\n\t\t\t*bytes = 0;\n\t\t\tsync = 1;\n\t\t}\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\n\tif (rtp_session->dtls) {\n\n\t\tif (rtp_session->rtcp_dtls && rtp_session->rtcp_dtls != rtp_session->dtls) {\n\t\t\trtp_session->rtcp_dtls->bytes = 0;\n\t\t\trtp_session->rtcp_dtls->data = NULL;\n\t\t\tdo_dtls(rtp_session, rtp_session->rtcp_dtls);\n\t\t}\n\n\t\tdo_dtls(rtp_session, rtp_session->dtls);\n\n\t\tif (rtp_session->dtls && rtp_session->dtls->bytes) {\n\t\t\t*bytes = 0;\n\t\t\tsync = 1;\n\t\t}\n\t}\n\n\n\n\tif (status == SWITCH_STATUS_SUCCESS && *bytes) {\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t*flags &= ~SFF_RTCP;\n\t\t\tif (rtp_session->has_rtcp) {\n\t\t\t\t*flags |= SFF_RTCP;\n\n#ifdef ENABLE_SRTP\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {\n\t\t\t\t\tint sbytes = (int) *bytes;\n\t\t\t\t\tsrtp_err_status_t stat = 0;\n\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {\n\t\t\t\t\t\tstat = srtp_unprotect_rtcp(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstat = srtp_unprotect_rtcp_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stat) {\n\t\t\t\t\t\t//++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp]++;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"RTCP UNPROTECT ERR\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t*bytes = sbytes;\n\t\t\t\t}\n#endif\n\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\treturn SWITCH_STATUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\tif ((*bytes && (!rtp_write_ready(rtp_session, *bytes, __LINE__) || !rtp_session->has_rtp || rtp_session->has_rtcp)) || sync) {\n\t\trtp_session->hot_hits = 0;\n\t\tblock = 1;\n\t\t*bytes = 0;\n\t\tgoto more;\n\t}\n\n\tif (*bytes && rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]) {\n\t\tconst char *tx_host;\n\t\tconst char *old_host;\n\t\tconst char *my_host;\n\n\t\tchar bufa[50], bufb[50], bufc[50];\n\n\n\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t  \"R %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"No-Name\",\n\t\t\t\t\t\t  (long) *bytes,\n\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),\n\t\t\t\t\t\t  rtp_session->last_rtp_hdr.pt, ntohl(rtp_session->last_rtp_hdr.ts), ntohs(rtp_session->last_rtp_hdr.seq),\n\t\t\t\t\t\t  rtp_session->last_rtp_hdr.m);\n\n\t}\n\n#ifdef RTP_READ_PLOSS\n\t{\n\t\tint r = (rand() % 10000) + 1;\n\t\tif (r <= 200) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ALERT,\n\t\t\t\t\t\t\t  \"Simulate dropped packet ......... ts: %u seq: %u\\n\", ntohl(rtp_session->last_rtp_hdr.ts), ntohs(rtp_session->last_rtp_hdr.seq));\n\t\t\t*bytes = 0;\n\t\t}\n\t}\n#endif\n\n\n\n udptl:\n\n\tts = 0;\n\trtp_session->recv_msg.ebody = NULL;\n\tnow = switch_micro_time_now();\n\n\tif (*bytes) {\n\t\tuint16_t seq = ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\t\tts = ntohl(rtp_session->last_rtp_hdr.ts);\n\n#ifdef DEBUG_MISSED_SEQ\n\t\tif (rtp_session->last_seq && rtp_session->last_seq+1 != seq) {\n\t\t\t//2012-11-28 18:33:11.799070 [ERR] switch_rtp.c:2883 Missed -65536 RTP frames from sequence [65536] to [-1] (missed). Time since last read [20021]\n\t\t\tswitch_size_t flushed_packets_diff = rtp_session->stats.inbound.flush_packet_count - rtp_session->last_flush_packet_count;\n\t\t\tswitch_size_t num_missed = (switch_size_t)seq - (rtp_session->last_seq+1);\n\n\t\t\tif (num_missed == 1) { /* We missed one packet */\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Missed one RTP frame with sequence [%d]%s. Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t  rtp_session->last_seq+1, (flushed_packets_diff == 1) ? \" (flushed by FS)\" : \" (missed)\",\n\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t} else { /* We missed multiple packets */\n\t\t\t\tif (flushed_packets_diff == 0) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (missed). Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t} else if (flushed_packets_diff == num_missed) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (flushed by FS). Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t} else if (num_missed > flushed_packets_diff) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (%ld packets flushed by FS, %ld packets missed).\"\n\t\t\t\t\t\t\t\t\t  \" Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  flushed_packets_diff, num_missed-flushed_packets_diff,\n\t\t\t\t\t\t\t\t\t  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Missed %ld RTP frames from sequence [%d] to [%d] (%ld packets flushed by FS). Time since last read [%ld]\\n\",\n\t\t\t\t\t\t\t\t\t  num_missed, rtp_session->last_seq+1, seq-1,\n\t\t\t\t\t\t\t\t\t  flushed_packets_diff, rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n#endif\n\t\trtp_session->last_seq = seq;\n\n\n\t\trtp_session->last_flush_packet_count = rtp_session->stats.inbound.flush_packet_count;\n\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && now - rtp_session->last_read_time > 5000000) {\n\t\t\tswitch_rtp_video_refresh(rtp_session);\n\t\t}\n\n\t\trtp_session->last_read_time = now;\n\t}\n\n\tif (*bytes && rtp_session->has_rtp && rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]){\n\t\trtcp_stats(rtp_session);\n\t}\n\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t*bytes && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\tts && !rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session) && ts == rtp_session->last_cng_ts) {\n\t\t/* we already sent this frame..... */\n\t\t*bytes = 0;\n\t\treturn SWITCH_STATUS_SUCCESS;\n\t}\n\n\tif (*bytes) {\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\n#ifdef ENABLE_SRTP\n\t\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && rtp_session->has_rtp &&\n\t\t\t\t(check_recv_payload(rtp_session) ||\n\t\t\t\t rtp_session->last_rtp_hdr.pt == rtp_session->recv_te ||\n\t\t\t\t rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt)) {\n\t\t\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && (!rtp_session->ice.ice_user || rtp_session->has_rtp)) {\n\t\t\t\tint sbytes = (int) *bytes;\n\t\t\t\tsrtp_err_status_t stat = 0;\n\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_RESET] || !rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_RECV_RESET);\n\t\t\t\t\tsrtp_dealloc(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]);\n\t\t\t\t\trtp_session->recv_ctx[rtp_session->srtp_idx_rtp] = NULL;\n\t\t\t\t\tif ((stat = srtp_create(&rtp_session->recv_ctx[rtp_session->srtp_idx_rtp],\n\t\t\t\t\t\t\t\t\t\t\t&rtp_session->recv_policy[rtp_session->srtp_idx_rtp])) || !rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {\n\n\t\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error! RE-Activating Secure RTP RECV\\n\");\n\t\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;\n\t\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"RE-Activating Secure RTP RECV\\n\");\n\t\t\t\t\t\trtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!(*flags & SFF_PLC) && rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {\n\t\t\t\t\t\tstat = srtp_unprotect(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp], &rtp_session->recv_msg.header, &sbytes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstat = srtp_unprotect_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp], &rtp_session->recv_msg.header, &sbytes, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && stat == srtp_err_status_replay_fail) {\n\t\t\t\t\t\t/* false alarm nack */\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"REPLAY ERR, FALSE NACK\\n\");\n\t\t\t\t\t\tsbytes = 0;\n\t\t\t\t\t\t*bytes = 0;\n\t\t\t\t\t\tif (rtp_session->stats.rtcp.pkt_count) {\n\t\t\t\t\t\t\trtp_session->stats.rtcp.period_pkt_count--;\n\t\t\t\t\t\t\trtp_session->stats.rtcp.pkt_count--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\t\tgoto more;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (stat && rtp_session->recv_msg.header.pt != rtp_session->recv_te && rtp_session->recv_msg.header.pt != rtp_session->cng_pt) {\n\t\t\t\t\tint errs = ++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp];\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SRTP_HANGUP_ON_ERROR] && stat != srtp_err_status_replay_old) {\n\t\t\t\t\t\tchar *msg;\n\t\t\t\t\t\tswitch_srtp_err_to_txt(stat, &msg);\n\t\t\t\t\t\tif (errs >= MAX_SRTP_ERRS) {\n\t\t\t\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t\t\t  \"SRTP %s unprotect failed with code %d (%s) %ld bytes %d errors\\n\",\n\t\t\t\t\t\t\t\t\t\t\t  rtp_type(rtp_session), stat, msg, (long)*bytes, errs);\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t\t\t  \"Ending call due to SRTP error\\n\");\n\t\t\t\t\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_SRTP_READ_ERROR);\n\t\t\t\t\t\t} else if (errs >= WARN_SRTP_ERRS && !(errs % WARN_SRTP_ERRS)) {\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t\t\t  \"SRTP %s unprotect failed with code %d (%s) %ld bytes %d errors\\n\",\n\t\t\t\t\t\t\t\t\t\t\t  rtp_type(rtp_session), stat, msg, (long)*bytes, errs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsbytes = 0;\n\t\t\t\t} else {\n\t\t\t\t\trtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t\t\t}\n\n\t\t\t\t*bytes = sbytes;\n\t\t\t}\n\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\t\t}\n\n\n\t\tif (rtp_session->has_rtp) {\n\t\t\tif (rtp_session->recv_msg.header.cc > 0) { /* Contributing Source Identifiers (4 bytes = sizeof CSRC header)*/\n\t\t\t\trtp_session->recv_msg.ebody = RTP_BODY(rtp_session) + (rtp_session->recv_msg.header.cc * 4);\n\t\t\t}\n\n\t\t\t/* recalculate body length in case rtp extension used */\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\t\trtp_session->recv_msg.header.x) { /* header extensions */\n\t\t\t\tuint16_t length;\n\n\t\t\t\trtp_session->recv_msg.ext = (switch_rtp_hdr_ext_t *) RTP_BODY(rtp_session);\n\t\t\t\tlength = ntohs((uint16_t)rtp_session->recv_msg.ext->length);\n\n\t\t\t\tif (length < SWITCH_RTP_MAX_BUF_LEN_WORDS) {\n\t\t\t\t\trtp_session->recv_msg.ebody = (char *)rtp_session->recv_msg.ext + (length * 4) + 4;\n\t\t\t\t\tif (*bytes > (length * 4 + 4)) {\n\t\t\t\t\t\t*bytes -= (length * 4 + 4);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*bytes = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n#ifdef DEBUG_CHROME\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->has_rtp) {\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t  \"VIDEO: seq: %d ts: %u len: %ld %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x mark: %d\\n\",\n\t\t\t\t\t\t\t\t  ntohs(rtp_session->last_rtp_hdr.seq), ntohl(rtp_session->last_rtp_hdr.ts), *bytes,\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session)), *((uint8_t *)RTP_BODY(rtp_session) + 1),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 2), *((uint8_t *)RTP_BODY(rtp_session) + 3),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 4), *((uint8_t *)RTP_BODY(rtp_session) + 5),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 6), *((uint8_t *)RTP_BODY(rtp_session) + 7),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 8), *((uint8_t *)RTP_BODY(rtp_session) + 9),\n\t\t\t\t\t\t\t\t  *((uint8_t *)RTP_BODY(rtp_session) + 10), rtp_session->last_rtp_hdr.m);\n\n\t\t\t}\n#endif\n\n\n\n\t\t}\n\n\n\t\trtp_session->stats.inbound.raw_bytes += *bytes;\n\n\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {\n\t\t\trtp_session->stats.inbound.dtmf_packet_count++;\n\t\t} else if (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {\n\t\t\trtp_session->stats.inbound.cng_packet_count++;\n\t\t} else {\n\t\t\trtp_session->stats.inbound.media_packet_count++;\n\t\t\trtp_session->stats.inbound.media_bytes += *bytes;\n\t\t}\n\n\t\trtp_session->stats.inbound.packet_count++;\n\t}\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t((rtp_session->recv_te && rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) ||\n\t\t (*bytes < rtp_header_len && *bytes > 0 && !(rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL])))) {\n\t\treturn SWITCH_STATUS_BREAK;\n\t}\n\n\tif (ts) {\n\t\trtp_session->prev_read_ts = rtp_session->last_read_ts;\n\t\trtp_session->last_read_ts = ts;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_BYTESWAP] && check_recv_payload(rtp_session)) {\n\t\tswitch_swap_linear((int16_t *)RTP_BODY(rtp_session), (int) *bytes - rtp_header_len);\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_KILL_JB]) {\n\t\trtp_session->flags[SWITCH_RTP_FLAG_KILL_JB] = 0;\n\n\t\tif (rtp_session->jb) {\n\t\t\tswitch_jb_destroy(&rtp_session->jb);\n\t\t}\n\n\t\tif (rtp_session->vb) {\n\t\t\tswitch_jb_destroy(&rtp_session->vb);\n\t\t}\n\n\t\tif (rtp_session->vbw) {\n\t\t\tswitch_jb_destroy(&rtp_session->vbw);\n\t\t}\n\n\t}\n\n\tif (rtp_session->has_rtp && *bytes) {\n\t\tuint32_t read_ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\t\treturn SWITCH_STATUS_SUCCESS;\n\t\t}\n\n\t\tif (rtp_session->vb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tstatus = switch_jb_put_packet(rtp_session->vb, (switch_rtp_packet_t *) &rtp_session->recv_msg, *bytes);\n\n\t\t\tif (status == SWITCH_STATUS_TOO_LATE) {\n\t\t\t\tgoto more;\n\t\t\t}\n\n\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t*bytes = 0;\n\n\t\t\tif (!return_jb_packet) {\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->jb && jb_valid(rtp_session)) {\n\t\t\tif (rtp_session->last_jb_read_ssrc && rtp_session->last_jb_read_ssrc != read_ssrc) {\n\t\t\t\tswitch_jb_reset(rtp_session->jb);\n\t\t\t}\n\n\t\t\trtp_session->last_jb_read_ssrc = read_ssrc;\n\t\t}\n\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\n\t\t\tstatus = switch_jb_put_packet(rtp_session->jb, (switch_rtp_packet_t *) &rtp_session->recv_msg, *bytes);\n\t\t\tif (status == SWITCH_STATUS_TOO_LATE) {\n\t\t\t\tgoto more;\n\t\t\t}\n\n\n\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t*bytes = 0;\n\n\t\t\tif (!return_jb_packet) {\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtp_session->last_rtp_hdr.m && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && !(rtp_session->rtp_bugs & RTP_BUG_IGNORE_MARK_BIT) && \n\t\t\t\trtp_session->last_read_ts - rtp_session->prev_read_ts < rtp_session->samples_per_interval * 3) {  \n\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\t\t} else if (rtp_session->last_jb_read_ssrc && rtp_session->last_jb_read_ssrc != read_ssrc) {\n\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!*bytes || rtp_session->has_rtp) {\n\n\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tswitch_status_t jstatus = switch_jb_get_packet(rtp_session->jb, (switch_rtp_packet_t *) &rtp_session->recv_msg, bytes);\n\n\t\t\tstatus = jstatus;\n\n\t\t\tswitch(jstatus) {\n\t\t\tcase SWITCH_STATUS_MORE_DATA:\n\t\t\t\tif (rtp_session->punts < 4) {\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tgoto more;\n\t\t\t\t}\n\t\t\t\t*bytes = 0;\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_NOTFOUND:\n\t\t\t\t{\n\t\t\t\t\tint pt = get_recv_payload(rtp_session);\n\t\t\t\t\t(*flags) |= SFF_PLC;\n\t\t\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\t\t\t*bytes = switch_jb_get_last_read_len(rtp_session->jb);\n\t\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\t\trtp_session->last_rtp_hdr.pt = pt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_BREAK:\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_SUCCESS:\n\t\t\tcase SWITCH_STATUS_TIMEOUT:\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (status == SWITCH_STATUS_TIMEOUT) {\n\t\t\t\t\t\trtp_session->skip_timer = 1;\n\t\t\t\t\t}\n\t\t\t\t\trtp_session->stats.inbound.jb_packet_count++;\n\t\t\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\t\tif (++rtp_session->clean > 200) {\n\t\t\t\t\t\trtp_session->punts = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!xcheck_jitter) {\n\t\t\t\t\t\tcheck_jitter(rtp_session);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->vb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\tswitch_status_t vstatus = switch_jb_get_packet(rtp_session->vb, (switch_rtp_packet_t *) &rtp_session->recv_msg, bytes);\n\t\t\tstatus = vstatus;\n\n\t\t\tswitch(vstatus) {\n\t\t\tcase SWITCH_STATUS_RESTART:\n\t\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\t\tstatus = SWITCH_STATUS_BREAK;\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_MORE_DATA:\n\t\t\t\tstatus = SWITCH_STATUS_BREAK;\n\t\t\t\tbreak;\n\t\t\tcase SWITCH_STATUS_BREAK:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (vstatus == SWITCH_STATUS_NOTFOUND && rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\t\t\tint pt = get_recv_payload(rtp_session);\n\t\t\t\t(*flags) |= SFF_PLC;\n\t\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\t\t*bytes = switch_jb_get_last_read_len(rtp_session->vb);\n\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\t\t\t\tif (pt > -1) {\n\t\t\t\t\trtp_session->last_rtp_hdr.pt = pt;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vstatus == SWITCH_STATUS_SUCCESS) {\n\t\t\t\trtp_session->last_rtp_hdr = rtp_session->recv_msg.header;\n\n\t\t\t\tif (!xcheck_jitter) {\n\t\t\t\t\tcheck_jitter(rtp_session);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void handle_nack(switch_rtp_t *rtp_session, uint32_t nack)\n{\n\tswitch_size_t bytes = 0;\n\trtp_msg_t send_msg[1] = {{{0}}};\n\tuint16_t seq = (uint16_t) (nack & 0xFFFF);\n\tuint16_t blp = (uint16_t) (nack >> 16);\n\tint i;\n\tconst char *tx_host = NULL;\n\tconst char *old_host = NULL;\n\tconst char *my_host = NULL;\n\tchar bufa[50], bufb[50], bufc[50];\n\n\tif (!(rtp_session->flags[SWITCH_RTP_FLAG_NACK] && rtp_session->vbw)) {\n\t\treturn;  /* not enabled */\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtcp_from_addr);\n\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Got NACK [%u][0x%x] for seq %u\\n\", \n\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), nack, nack, ntohs(seq));\n\n\tif (switch_jb_get_packet_by_seq(rtp_session->vbw, seq, (switch_rtp_packet_t *) send_msg, &bytes) == SWITCH_STATUS_SUCCESS) {\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t  \"X %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtcp_from_addr),\n\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t}\n\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG2, \"RE----SEND %u\\n\", ntohs(send_msg->header.seq));\n\t\tswitch_rtp_write_raw(rtp_session, (void *) send_msg, &bytes, SWITCH_FALSE);\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Cannot send NACK for seq %u\\n\", ntohs(seq));\n\t}\n\n\tblp = ntohs(blp);\n\tfor (i = 0; i < 16; i++) {\n\t\tif (blp & (1 << i)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Also Got NACK for seq %u\\n\", \n\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), ntohs(seq) + i + 1);\n\t\t\t/* If they are missing more than one, may as well gen a key frame for good measure */\n\t\t\t//switch_core_media_gen_key_frame(rtp_session->session);\n\t\t\tif (switch_jb_get_packet_by_seq(rtp_session->vbw, htons(ntohs(seq) + i + 1), (switch_rtp_packet_t *) &send_msg, &bytes) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t\t\t  \"X %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtcp_from_addr),\n\t\t\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t\t\t}\n\t\t\t\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"RE----SEND %u\\n\", ntohs(send_msg->header.seq));\n\n\t\t\t\tswitch_rtp_write_raw(rtp_session, (void *) &send_msg, &bytes, SWITCH_FALSE);\n\t\t\t} else {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"Cannot send NACK for seq %u\\n\", ntohs(seq) + i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic switch_status_t process_rtcp_report(switch_rtp_t *rtp_session, rtcp_msg_t *msg, switch_size_t bytes)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\n\t\t\t\t\t  \"RTCP packet bytes %\" SWITCH_SIZE_T_FMT \" type %d pad %d\\n\",\n\t\t\t\t\t  bytes, msg->header.type, msg->header.p);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (msg->header.type == _RTCP_PT_RTPFB || msg->header.type == _RTCP_PT_PSFB || msg->header.type < 200)) {\n\t\trtcp_ext_msg_t *extp = (rtcp_ext_msg_t *) msg;\n\n\t\tif (extp->header.fmt != 15) { // <---- REMOVE WHEN BRIA STOPS SENDING UNSOLICITED REMB\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s PICKED UP %s XRTCP type: %d fmt: %d\\n\",\n\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), rtp_type(rtp_session), msg->header.type, extp->header.fmt);\n\t\t}\n\n\t\tif (msg->header.type == _RTCP_PT_FIR ||\n\t\t\t(msg->header.type == _RTCP_PT_PSFB && (extp->header.fmt == _RTCP_PSFB_FIR || extp->header.fmt == _RTCP_PSFB_PLI))) {\n#if 0\n\t\t\tif (msg->header.type == _RTCP_PT_FIR) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Ancient FIR Received. Hello from 1996!\\n\");\n\n\t\t\t\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_OLD_FIR)) {\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_OLD_FIR);\n\t\t\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\t\n\t\t\tif (switch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO) == SWITCH_MEDIA_FLOW_RECVONLY) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Ignoring FIR/PLI from a sendonly stream.\\n\", \n\t\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session));\n\t\t\t} else {\n\t\t\t\tswitch_core_media_gen_key_frame(rtp_session->session);\n\t\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Got FIR/PLI\\n\", \n\t\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session));\n\t\t\t\tswitch_channel_set_flag(switch_core_session_get_channel(rtp_session->session), CF_VIDEO_REFRESH_REQ);\n\t\t\t}\n\t\t}\n\n\t\tif (msg->header.type == _RTCP_PT_RTPFB && extp->header.fmt == _RTCP_RTPFB_NACK) {\n\t\t\tuint32_t *nack = (uint32_t *) extp->body;\n\t\t\tint i;\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, \"%s Got NACK count %d\\n\", \n\t\t\t\t\t\t\t  switch_core_session_get_name(rtp_session->session), ntohs(extp->header.length) - 2);\n\n\n\t\t\tfor (i = 0; i < ntohs(extp->header.length) - 2; i++) {\n\t\t\t\thandle_nack(rtp_session, nack[i]);\n\t\t\t}\n\n\t\t\t//switch_core_media_gen_key_frame(rtp_session->session);\n\t\t}\n\t\t\n\t} else {\n\t\tstruct switch_rtcp_report_block *report;\n\n\t\tif (msg->header.type == _RTCP_PT_SR || msg->header.type == _RTCP_PT_RR) {\n\t\t\tint i;\n#ifdef DEBUG_RTCP\n\t\t\tswitch_time_t now = switch_micro_time_now();\n#endif \n\t\t\tuint32_t lsr_now;\n\t\t\tuint32_t lsr;\n\t\t\tuint32_t packet_ssrc;\n\t\t\tdouble rtt_now = 0;\n\t\t\tuint8_t rtt_valid = 0;\n\t\t\tint rtt_increase = 0, packet_loss_increase=0;\n\n\t\t\t//if (msg->header.type == _RTCP_PT_SR && rtp_session->ice.ice_user) {\n\t\t\t//\trtp_session->send_rr = 1;\n\t\t\t//}\n\n\t\t\tlsr_now = calc_local_lsr_now();\n\n\t\t\tif (msg->header.type == _RTCP_PT_SR) { /* Sender report */\n\t\t\t\tstruct switch_rtcp_sender_report* sr = (struct switch_rtcp_sender_report*)msg->body;\n\n\t\t\t\trtp_session->stats.rtcp.packet_count = ntohl(sr->sender_info.pc);\n\t\t\t\trtp_session->stats.rtcp.octet_count = ntohl(sr->sender_info.oc);\n\t\t\t\tpacket_ssrc = sr->ssrc;\n\t\t\t\t/* Extracting LSR from NTP timestamp and save it */\n\t\t\t\tlsr = (ntohl(sr->sender_info.ntp_lsw)&0xffff0000)>>16 | (ntohl(sr->sender_info.ntp_msw)&0x0000ffff)<<16; /* The middle 32 bits out of 64 in the NTP timestamp */\n\t\t\t\trtp_session->stats.rtcp.last_recv_lsr_peer = htonl(lsr);  /* Save it include it in the next SR */\n\t\t\t\trtp_session->stats.rtcp.last_recv_lsr_local = lsr_now;    /* Save it to calculate DLSR when generating next SR */\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Received a SR with %d report blocks, \" \\\n\t\t\t\t\t\t\t\t  \"length in words = %d, \" \\\n\t\t\t\t\t\t\t\t  \"SSRC = 0x%X, \" \\\n\t\t\t\t\t\t\t\t  \"NTP MSW = %u, \" \\\n\t\t\t\t\t\t\t\t  \"NTP LSW = %u, \" \\\n\t\t\t\t\t\t\t\t  \"RTP timestamp = %u, \" \\\n\t\t\t\t\t\t\t\t  \"Sender Packet Count = %u, \" \\\n\t\t\t\t\t\t\t\t  \"Sender Octet Count = %u\\n\",\n\t\t\t\t\t\t\t\t  msg->header.count,\n\t\t\t\t\t\t\t\t  ntohs((uint16_t)msg->header.length),\n\t\t\t\t\t\t\t\t  ntohl(sr->ssrc),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.ntp_msw),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.ntp_lsw),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.ts),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.pc),\n\t\t\t\t\t\t\t\t  ntohl(sr->sender_info.oc));\n\n\n\t\t\t\trtp_session->rtcp_frame.ssrc = ntohl(sr->ssrc);\n\t\t\t\trtp_session->rtcp_frame.packet_type = (uint16_t)rtp_session->rtcp_recv_msg_p->header.type;\n\t\t\t\trtp_session->rtcp_frame.ntp_msw = ntohl(sr->sender_info.ntp_msw);\n\t\t\t\trtp_session->rtcp_frame.ntp_lsw = ntohl(sr->sender_info.ntp_lsw);\n\t\t\t\trtp_session->rtcp_frame.timestamp = ntohl(sr->sender_info.ts);\n\t\t\t\trtp_session->rtcp_frame.packet_count =  ntohl(sr->sender_info.pc);\n\t\t\t\trtp_session->rtcp_frame.octect_count = ntohl(sr->sender_info.oc);\n\n\t\t\t\treport = &sr->report_block;\n\t\t\t} else { /* Receiver report */\n\t\t\t\tstruct switch_rtcp_receiver_report* rr = (struct switch_rtcp_receiver_report*)msg->body;\n\t\t\t\tpacket_ssrc = rr->ssrc;\n\t\t\t\t//memset(&rtp_session->rtcp_frame, 0, sizeof(rtp_session->rtcp_frame));\n\t\t\t\treport = &rr->report_block;\n\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Received a RR with %d report blocks, \" \\\n\t\t\t\t\t\t\t\t  \"length in words = %d, \" \\\n\t\t\t\t\t\t\t\t  \"SSRC = 0x%X, \",\n\t\t\t\t\t\t\t\t  msg->header.count,\n\t\t\t\t\t\t\t\t  ntohs((uint16_t)msg->header.length),\n\t\t\t\t\t\t\t\t  ntohl(rr->ssrc));\n\n\t\t\t}\n\t\t\t\n\n\t\t\tfor (i = 0; i < (int)msg->header.count && i < MAX_REPORT_BLOCKS ; i++) {\n\t\t\t\tuint32_t old_avg = rtp_session->rtcp_frame.reports[i].loss_avg;\n\t\t\t\tuint8_t percent_fraction = (uint8_t)((uint16_t/* prevent overflow when '* 100' */)(uint8_t)report->fraction * 100 / 255);\n\t\t\t\tif (!rtp_session->rtcp_frame.reports[i].loss_avg) {\n\t\t\t\t\trtp_session->rtcp_frame.reports[i].loss_avg = percent_fraction;\n\t\t\t\t} else {\n\t\t\t\t\trtp_session->rtcp_frame.reports[i].loss_avg = (uint32_t)(((float)rtp_session->rtcp_frame.reports[i].loss_avg * .7) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ((float)percent_fraction * .3));\n\t\t\t\t}\n\n\t\t\t\trtp_session->rtcp_frame.reports[i].ssrc = ntohl(report->ssrc);\n\t\t\t\trtp_session->rtcp_frame.reports[i].fraction = (uint8_t)report->fraction;\n#if SWITCH_BYTE_ORDER == __BIG_ENDIAN\n\t\t\t\trtp_session->rtcp_frame.reports[i].lost = report->lost; // signed 24bit will extended signess to int32_t automatically\n#else\n\t\t\t\trtp_session->rtcp_frame.reports[i].lost = ntohl(report->lost)>>8; // signed 24bit casted to uint32_t need >>8 after ntohl()...\n\t\t\t\trtp_session->rtcp_frame.reports[i].lost = rtp_session->rtcp_frame.reports[i].lost | ((rtp_session->rtcp_frame.reports[i].lost & 0x00800000) ? 0xff000000 : 0x00000000); // ...and signess compensation\n#endif\n\t\t\t\trtp_session->rtcp_frame.reports[i].highest_sequence_number_received = ntohl(report->highest_sequence_number_received);\n\t\t\t\trtp_session->rtcp_frame.reports[i].jitter = ntohl(report->jitter);\n\t\t\t\trtp_session->rtcp_frame.reports[i].lsr = ntohl(report->lsr);\n\t\t\t\trtp_session->rtcp_frame.reports[i].dlsr = ntohl(report->dlsr);\n\t\t\t\t\n\t\t\t\tif (rtp_session->rtcp_frame.reports[i].lsr && !rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU]) {\n\n\t\t\t\t\t/* Calculating RTT = A - DLSR - LSR */\n\t\t\t\t\trtt_now = ((double)(((int64_t)lsr_now) - rtp_session->rtcp_frame.reports[i].dlsr - rtp_session->rtcp_frame.reports[i].lsr))/65536;\n\n\t\t\t\t\t/* Only account RTT if it didn't overflow. */\n\t\t\t\t\tif (lsr_now > rtp_session->rtcp_frame.reports[i].dlsr + rtp_session->rtcp_frame.reports[i].lsr) {\n#ifdef DEBUG_RTCP\n\t\t\t\t\t\tswitch_time_exp_t now_hr;\n\t\t\t\t\t\tswitch_time_exp_gmt(&now_hr,now);\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\n\t\t\t\t\t\t\t\t\"Receiving an RTCP packet\\n[%04d-%02d-%02d %02d:%02d:%02d.%d] SSRC[0x%x]\\n\"\n\t\t\t\t\t\t\t\t\"RTT[%f] = A[%u] - DLSR[%u] - LSR[%u]\\n\",\n\t\t\t\t\t\t\t\t1900 + now_hr.tm_year, now_hr.tm_mday, now_hr.tm_mon, now_hr.tm_hour, now_hr.tm_min, now_hr.tm_sec, now_hr.tm_usec,\n\t\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].ssrc, rtt_now,\n\t\t\t\t\t\t\t\tlsr_now, rtp_session->rtcp_frame.reports[i].dlsr, rtp_session->rtcp_frame.reports[i].lsr);\n#endif \n\t\t\t\t\t\trtt_valid = 1;\n\t\t\t\t\t\tif (!rtp_session->rtcp_frame.reports[i].rtt_avg) {\n\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].rtt_avg = rtt_now;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].rtt_avg = (double)((rtp_session->rtcp_frame.reports[i].rtt_avg * .7) + (rtt_now * .3 ));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n#ifdef DEBUG_RTCP\n\t\t\t\t\t\tswitch_time_exp_t now_hr;\n\t\t\t\t\t\tswitch_time_exp_gmt(&now_hr,now);\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\"Receiving RTCP packet\\n[%04d-%02d-%02d %02d:%02d:%02d.%d] SSRC[0x%x]\\n\"\n\t\t\t\t\t\t\t\t\"Ignoring erroneous RTT[%f] = A[%u] - DLSR[%u] - LSR[%u]\\n\",\n\t\t\t\t\t\t\t\t1900 + now_hr.tm_year, now_hr.tm_mday, now_hr.tm_mon, now_hr.tm_hour, now_hr.tm_min, now_hr.tm_sec, now_hr.tm_usec,\n\t\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].ssrc, rtt_now,\n\t\t\t\t\t\t\t\tlsr_now, rtp_session->rtcp_frame.reports[i].dlsr, rtp_session->rtcp_frame.reports[i].lsr);\n#endif\n\t\t\t\t\t\trtt_valid = 0;\n\t\t\t\t\t\trtt_now = 0;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"RTT average %f\\n\",\n\t\t\t\t\t\t\trtp_session->rtcp_frame.reports[i].rtt_avg);\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ADJ_BITRATE_CAP] && rtp_session->flags[SWITCH_RTP_FLAG_ESTIMATORS] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\n\t\t\t\t\t/* SWITCH_RTP_FLAG_ADJ_BITRATE_CAP : Can the codec change its bitrate on the fly per API command ? */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Current packet loss: [%d %%] Current RTT: [%f ms]\\n\", percent_fraction, rtt_now);\n#endif\n\n\t\t\t\t\tif (rtt_valid) {\n\n\t\t\t\t\t\tswitch_kalman_estimate(rtp_session->estimators[EST_RTT], rtt_now, EST_RTT);\n\n\t\t\t\t\t\tif (switch_kalman_cusum_detect_change(rtp_session->detectors[EST_RTT], rtt_now, rtp_session->estimators[EST_RTT]->val_estimate_last)) {\n\t\t\t\t\t\t\t/* sudden change in the mean value of RTT */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Sudden change in the mean value of RTT !\\n\");\n#endif\n\t\t\t\t\t\t\trtt_increase = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch_kalman_estimate(rtp_session->estimators[EST_LOSS], percent_fraction, EST_LOSS);\n\n\t\t\t\t\tif (switch_kalman_cusum_detect_change(rtp_session->detectors[EST_LOSS], percent_fraction, rtp_session->estimators[EST_LOSS]->val_estimate_last)){\n\t\t\t\t\t\t/* sudden change in the mean value of packet loss */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Sudden change in the mean value of packet loss!\\n\");\n#endif\n\t\t\t\t\t\tpacket_loss_increase = 1;\n\t\t\t\t\t}\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"ESTIMATORS: Packet loss will be: [%f] RTT will be: [%f ms]\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session->estimators[EST_LOSS]->val_estimate_last, rtp_session->estimators[EST_RTT]->val_estimate_last);\n#endif\n\n\t\t\t\t\tif (rtp_session->rtcp_frame.reports[i].loss_avg != old_avg) {\n\t\t\t\t\t\t/*getting bad*/\n\t\t\t\t\t\tif (switch_kalman_is_slow_link(rtp_session->estimators[EST_LOSS],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   rtp_session->estimators[EST_RTT])) {\n\t\t\t\t\t\t\t/* going to minimum bitrate */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Slow link conditions: Loss average: [%d %%], Previous loss: [%d %%]. \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tGoing to minimum bitrate!\",rtp_session->rtcp_frame.reports[i].loss_avg, old_avg);\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE, SCCT_STRING, \"minimum\", SCCT_NONE, NULL, NULL, NULL);\n\t\t\t\t\t\t\t/* if after going to minimum bitrate we still have packet loss then we increase ptime. TODO */\n\n\t\t\t\t\t\t} else if (packet_loss_increase && (rtp_session->estimators[EST_LOSS]->val_estimate_last >= 5)) {\n\t\t\t\t\t\t\t/* sudden change in the mean value of packet loss percentage */\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_STRING, \"decrease\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"Sudden change in the mean value of packet loss percentage !\\n\");\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else if (rtt_valid && !rtt_increase && rtp_session->estimators[EST_LOSS]->val_estimate_last >= rtp_session->rtcp_frame.reports[i].loss_avg ) {\n\t\t\t\t\t\t\t/* lossy because of congestion (queues full somewhere -> some packets are dropped , but RTT is good ), packet loss with many small gaps */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"packet loss, but RTT is not bad\\n\");\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else if ((rtp_session->estimators[EST_LOSS]->val_estimate_last < 1) && packet_loss_increase) {\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"small packet loss average\\n\");\n#endif\n\t\t\t\t\t\t\t/*small loss_avg*/\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_STRING, \"default\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else if ((rtp_session->estimators[EST_LOSS]->val_estimate_last < 5) &&\n\t\t\t\t\t\t\t\t   (rtp_session->rtcp_frame.reports[i].rtt_avg < rtp_session->estimators[EST_RTT]->val_estimate_last))  {\n\n\t\t\t\t\t\t\t/* estimate that packet loss will decrease, we can increase the bitrate */\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_ADJUST_BITRATE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_STRING, \"increase\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* *do nothing about bitrate, just pass the packet loss to the codec */\n#ifdef DEBUG_ESTIMATORS_\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3,\"do nothing about bitrate, just pass the packet loss to the codec\\n\");\n#endif\n\t\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->rtcp_frame.reports[i].loss_avg != old_avg) {\n\t\t\t\t\t\tswitch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSWITCH_IO_WRITE, SCC_AUDIO_PACKET_LOSS, SCCT_INT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(void *)&rtp_session->rtcp_frame.reports[i].loss_avg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSCCT_NONE, NULL, NULL, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treport++;\n\t\t\t}\n\t\t\trtp_session->rtcp_frame.report_count = (uint16_t)i;\n\t\t\t\t\n\n\n\n\n\t\t\trtp_session->rtcp_fresh_frame = 1;\n\t\t\trtp_session->stats.rtcp.peer_ssrc = ntohl(packet_ssrc);\n\t\t}\n\t}\n\n\tif (msg->header.type > 194 && msg->header.type < 255) {\n\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t}\n\n\treturn status;\n}\n\n\nstatic switch_status_t process_rtcp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes)\n{\n\tswitch_size_t len;\n\tswitch_size_t remain = *bytes;\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\trtcp_msg_t *msg = rtp_session->rtcp_recv_msg_p;\n\n\tif (remain < sizeof(switch_rtcp_ext_hdr_t) || remain > sizeof(rtcp_msg_t)) {\n\t\treturn status;\n\t}\n\tif (msg->header.version != 2) {\n\t\tif (msg->header.version == 0) {\n\t\t\tif (rtp_session->ice.ice_user) {\n\t\t\t\thandle_ice(rtp_session, &rtp_session->rtcp_ice, (void *) msg, *bytes);\n\t\t\t}\n\t\t\treturn SWITCH_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),\n\t\t\t\t\t\t\t  SWITCH_LOG_WARNING, \"Received an unsupported RTCP packet version %d\\n\", msg->header.version);\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t}\n\n\tdo {\n\t\tlen = ((switch_size_t)ntohs(msg->header.length) * 4) + 4;\n\n\t\tif (msg->header.version != 2 || !(msg->header.type > 191 && msg->header.type < 210)) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t  \"INVALID RTCP PACKET TYPE %d VER %d LEN %\" SWITCH_SIZE_T_FMT \"\\n\", msg->header.type,\n\t\t\t\t\t\t\t  msg->header.version, len);\n\t\t\tstatus = SWITCH_STATUS_BREAK;\n\t\t\tbreak;\n\t\t}\n\n\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT,\n\t\t//\"WTF BYTES %ld REMAIN %ld PACKET TYPE %d LEN %ld\\n\", *bytes, remain, msg->header.type, len);\n\n\t\tif (len > remain) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t  \"RTCP INVALID LENGTH %\" SWITCH_SIZE_T_FMT \"\\n\", len);\n\t\t\tlen = remain;\n\t\t}\n\n\t\tstatus = process_rtcp_report(rtp_session, msg, len);\n\n\t\tif (remain > len) {\n\t\t\tunsigned char *p = (unsigned char *) msg;\n\t\t\tp += len;\n\t\t\tmsg = (rtcp_msg_t *) p;\n\t\t}\n\n\t\tremain -= len;\n\n\t} while (remain >= 4);\n\n\treturn status;\n}\n\nstatic switch_status_t read_rtcp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes, switch_frame_flag_t *flags)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tswitch_assert(bytes);\n\n\t*bytes = sizeof(rtcp_msg_t);\n\n\tif ((status = switch_socket_recvfrom(rtp_session->rtcp_from_addr, rtp_session->rtcp_sock_input, 0, (void *) rtp_session->rtcp_recv_msg_p, bytes))\n\t\t!= SWITCH_STATUS_SUCCESS) {\n\t\t*bytes = 0;\n\t}\n\n\tswitch_mutex_lock(rtp_session->ice_mutex);\n\tif (rtp_session->rtcp_dtls) {\n\t\tchar *b = (char *) rtp_session->rtcp_recv_msg_p;\n\n\t\tif (*b == 0 || *b == 1) {\n\t\t\tif (rtp_session->rtcp_ice.ice_user) {\n\t\t\t\thandle_ice(rtp_session, &rtp_session->rtcp_ice, (void *) rtp_session->rtcp_recv_msg_p, *bytes);\n\t\t\t}\n\t\t\t*bytes = 0;\n\t\t}\n\n\t\tif (*bytes && (*b >= 20) && (*b <= 64)) {\n\t\t\trtp_session->rtcp_dtls->bytes = *bytes;\n\t\t\trtp_session->rtcp_dtls->data = (void *) rtp_session->rtcp_recv_msg_p;\n\t\t} else {\n\t\t\trtp_session->rtcp_dtls->bytes = 0;\n\t\t\trtp_session->rtcp_dtls->data = NULL;\n\t\t}\n\n\t\tdo_dtls(rtp_session, rtp_session->rtcp_dtls);\n\n\n\t\tif (rtp_session->rtcp_dtls->bytes) {\n\t\t\t*bytes = 0;\n\t\t}\n\t}\n\n#ifdef ENABLE_SRTP\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && rtp_session->rtcp_recv_msg_p->header.version == 2) {\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && (!rtp_session->ice.ice_user || rtp_session->rtcp_recv_msg_p->header.version == 2)) {\n\t\tint sbytes = (int) *bytes;\n\t\tsrtp_err_status_t stat = 0;\n\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {\n\t\t\tstat = srtp_unprotect_rtcp(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes);\n\t\t} else {\n\t\t\tstat = srtp_unprotect_rtcp_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes, 1);\n\t\t}\n\n\t\tif (stat) {\n\t\t\t//++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp]++;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"RTCP UNPROTECT ERR\\n\");\n\t\t} else {\n\t\t\t//rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;\n\t\t}\n\n\t\t*bytes = sbytes;\n\n\t}\n#endif\n\n\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\n\n\t/* RTCP Auto ADJ */\n\tif (*bytes && rtp_session->flags[SWITCH_RTP_FLAG_RTCP_AUTOADJ] &&  switch_sockaddr_get_port(rtp_session->rtcp_from_addr)) {\n\t\tif (!switch_cmp_addr(rtp_session->rtcp_from_addr, rtp_session->rtcp_remote_addr, SWITCH_FALSE)) {\n\t\t\t\tif (++rtp_session->rtcp_autoadj_tally >= rtp_session->rtcp_autoadj_threshold) {\n\t\t\t\t\tconst char *err;\n\t\t\t\t\tuint32_t old = rtp_session->remote_rtcp_port;\n\t\t\t\t\tconst char *tx_host;\n\t\t\t\t\tconst char *old_host;\n\t\t\t\t\tchar bufa[50], bufb[50];\n\n\t\t\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtcp_from_addr);\n\t\t\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->rtcp_remote_addr);\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t  \"Auto Changing %s RTCP port from %s:%u to %s:%u\\n\", rtp_type(rtp_session), old_host, old, tx_host,\n\t\t\t\t\t\t\t\t\t  switch_sockaddr_get_port(rtp_session->rtcp_from_addr));\n\n\n\t\t\t\t\trtp_session->eff_remote_host_str = switch_core_strdup(rtp_session->pool, tx_host);\n\t\t\t\t\trtp_session->remote_rtcp_port = switch_sockaddr_get_port(rtp_session->rtcp_from_addr);\n\t\t\t\t\tstatus = enable_remote_rtcp_socket(rtp_session, &err);\n\t\t\t\t\trtp_session->rtcp_auto_adj_used = 1;\n\n\t\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),\n\t\t\t\t\t\t\t\t\t  SWITCH_LOG_DEBUG, \"Correct %s RTCP ip/port confirmed.\\n\", rtp_type(rtp_session));\n\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t}\n\t\t\t\trtp_session->rtcp_auto_adj_used = 0;\n\n\t\t\t}\n\t}\n\n\tif (*bytes) {\n\t\treturn process_rtcp_packet(rtp_session, bytes);\n\t}\n\n\treturn status;\n}\n\nstatic void check_timeout(switch_rtp_t *rtp_session)\n{\n\n\tswitch_time_t now = switch_micro_time_now();\n\tuint32_t elapsed = 0;\n\n\tif (now >= rtp_session->last_media) {\n\t\telapsed = (now - rtp_session->last_media) / 1000;\n\t}\n\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10,\n\t\t\t\t\t  \"%s MEDIA TIMEOUT %s %d/%d\\n\", switch_core_session_get_name(rtp_session->session), rtp_type(rtp_session),\n\t\t\t\t\t  elapsed, rtp_session->media_timeout);\n\n\tif (elapsed > rtp_session->media_timeout) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\n\t\t\tswitch_channel_execute_on(channel, \"execute_on_media_timeout\");\n\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_MEDIA_TIMEOUT);\n\t}\n}\n\nstatic int rtp_common_read(switch_rtp_t *rtp_session, switch_payload_t *payload_type,\n\t\t\t\t\t\t   payload_map_t **pmapP, switch_frame_flag_t *flags, switch_io_flag_t io_flags)\n{\n\n\tswitch_channel_t *channel = NULL;\n\tswitch_size_t bytes = 0;\n\tswitch_size_t rtcp_bytes = 0;\n\tswitch_status_t status = SWITCH_STATUS_SUCCESS, poll_status = SWITCH_STATUS_SUCCESS;\n\tswitch_status_t rtcp_status = SWITCH_STATUS_SUCCESS, rtcp_poll_status = SWITCH_STATUS_SUCCESS;\n\tint check = 0;\n\tint ret = -1;\n\tint sleep_mss = 1000;\n\tint poll_sec = 5;\n\tint poll_loop = 0;\n\tint fdr = 0;\n\tint rtcp_fdr = 0;\n\tint hot_socket = 0;\n\tint read_loops = 0;\n\tint slept = 0;\n\tswitch_bool_t got_jb = SWITCH_FALSE;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn -1;\n\t}\n\n\tif (rtp_session->session) {\n\t\tchannel = switch_core_session_get_channel(rtp_session->session);\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\tsleep_mss = rtp_session->timer.interval * 1000;\n\t}\n\n\tREAD_INC(rtp_session);\n\n\n\n\twhile (switch_rtp_ready(rtp_session)) {\n\t\tint do_cng = 0;\n\t\tint read_pretriggered = 0;\n\t\tint has_rtcp = 0;\n\t\tint got_rtp_poll = 0;\n\n\t\tbytes = 0;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\trtp_session->read_pollfd) {\n\n\t\t\tif (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {\n\t\t\t\twhile (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tstatus = read_rtp_packet(rtp_session, &bytes, flags, pmapP, SWITCH_STATUS_SUCCESS, SWITCH_FALSE);\n\n\t\t\t\t\tif (status == SWITCH_STATUS_GENERR) {\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((*flags & SFF_RTCP)) {\n\t\t\t\t\t\t*flags &= ~SFF_RTCP;\n\t\t\t\t\t\thas_rtcp = 1;\n\t\t\t\t\t\tread_pretriggered = 0;\n\t\t\t\t\t\tgoto rtcp;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (status == SWITCH_STATUS_BREAK) {\n\t\t\t\t\t\tread_pretriggered = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if ((rtp_session->flags[SWITCH_RTP_FLAG_AUTOFLUSH] || rtp_session->flags[SWITCH_RTP_FLAG_STICKY_FLUSH])) {\n\n\t\t\t\tif (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tstatus = read_rtp_packet(rtp_session, &bytes, flags, pmapP, SWITCH_STATUS_SUCCESS, SWITCH_FALSE);\n\t\t\t\t\tif (status == SWITCH_STATUS_GENERR) {\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif ((*flags & SFF_RTCP)) {\n\t\t\t\t\t\t*flags &= ~SFF_RTCP;\n\t\t\t\t\t\thas_rtcp = 1;\n\t\t\t\t\t\tread_pretriggered = 0;\n\t\t\t\t\t\tgoto rtcp;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Initial (%i) %d\\n\", status, bytes); */\n\t\t\t\t\tif (status != SWITCH_STATUS_FALSE) {\n\t\t\t\t\t\tread_pretriggered = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytes) {\n\t\t\t\t\t\tif (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\trtp_session->hot_hits++;//+= rtp_session->samples_per_interval;\n\n\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"%s Hot Hit %d\\n\",\n\t\t\t\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t\t\t\t  rtp_session->hot_hits);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trtp_session->hot_hits = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->hot_hits > 1 && !rtp_session->sync_packets) {// >= (rtp_session->samples_per_second * 30)) {\n\t\t\t\t\t\thot_socket = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trtp_session->hot_hits = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\t\t\t///NOOP\n\t\t\t} else if (hot_socket && (rtp_session->hot_hits % 10) != 0) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"%s timer while HOT\\n\", rtp_session_name(rtp_session));\n\t\t\t\tswitch_core_timer_next(&rtp_session->timer);\n\t\t\t} else if (hot_socket) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, \"%s skip timer once\\n\", rtp_session_name(rtp_session));\n\t\t\t\trtp_session->sync_packets++;\n\t\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t} else {\n\n\t\t\t\tif (rtp_session->sync_packets) {\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10,\n\t\t\t\t\t\t\t\t\t  \"%s Auto-Flush catching up %d packets (%d)ms.\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t\t  rtp_session->sync_packets, (rtp_session->ms_per_packet * rtp_session->sync_packets) / 1000);\n\t\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PAUSE]) {\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"%s syncing %d %s packet(s)\\n\",\n\t\t\t\t\t\t\t\t\t\t rtp_session_name(rtp_session),\n\t\t\t\t\t\t\t\t\t\t  rtp_session->sync_packets, rtp_type(rtp_session));\n\n\t\t\t\t\t\trtp_session->bad_stream++;\n\t\t\t\t\t\trtp_session->stats.inbound.flaws += rtp_session->sync_packets;\n\n\t\t\t\t\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\t\t\t\t\trtp_session->stats.inbound.error_log->flaws += rtp_session->sync_packets;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch_core_timer_sync(&rtp_session->timer);\n\t\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t\t\trtp_session->hot_hits = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (slept) {\n\t\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rtp_session->skip_timer) {\n\t\t\t\t\t\t\trtp_session->skip_timer = 0;\n\t\t\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tswitch_core_timer_next(&rtp_session->timer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tslept++;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trtp_session->sync_packets = 0;\n\t\t\t}\n\t\t}\n\n\t\trtp_session->stats.read_count++;\n\n\trecvfrom:\n\n\t\tif (!read_pretriggered) {\n\t\t\tbytes = 0;\n\t\t}\n\t\tread_loops++;\n\t\t//poll_loop = 0;\n\n\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->read_pollfd) {\n\t\t\tint pt = poll_sec * 1000000;\n\n\t\t\tdo_2833(rtp_session);\n\n\t\t\tif (rtp_session->dtmf_data.out_digit_dur > 0 || rtp_session->dtmf_data.in_digit_sanity || rtp_session->sending_dtmf ||\n\t\t\t\tswitch_queue_size(rtp_session->dtmf_data.dtmf_queue) || switch_queue_size(rtp_session->dtmf_data.dtmf_inqueue)) {\n\t\t\t\tpt = 20000;\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && !rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA]) {\n\t\t\t\tpt = 100000;\n\t\t\t}\n\n\t\t\tif (rtp_session->vb && !rtp_session->pause_jb) {\n\t\t\t\tif (switch_jb_poll(rtp_session->vb)) {\n\t\t\t\t\tpt = 1000;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((io_flags & SWITCH_IO_FLAG_NOBLOCK)) {\n\t\t\t\tpt = 0;\n\t\t\t}\n\n\t\t\tpoll_status = switch_poll(rtp_session->read_pollfd, 1, &fdr, pt);\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && poll_status != SWITCH_STATUS_SUCCESS && rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->dtmf_data.out_digit_dur > 0) {\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_BREAK]) {\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_BREAK);\n\t\t\t\tbytes = 0;\n\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\tgot_jb = (rtp_session->vb && !rtp_session->pause_jb && switch_jb_poll(rtp_session->vb));\n\t\t} else {\n\t\t\tgot_jb = SWITCH_TRUE;\n\t\t}\n\n\t\tif (poll_status == SWITCH_STATUS_SUCCESS || got_jb) {\n\n\t\t\tgot_rtp_poll = 1;\n\n\t\t\tif (read_pretriggered) {\n\t\t\t\tread_pretriggered = 0;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tstatus = read_rtp_packet(rtp_session, &bytes, flags, pmapP, poll_status, got_jb);\n\n\t\t\t\tif (status == SWITCH_STATUS_GENERR) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->max_missed_packets && read_loops == 1 && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\t\t\t\tif (bytes && status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\trtp_session->missed_count = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (++rtp_session->missed_count >= rtp_session->max_missed_packets) {\n\t\t\t\t\t\t\t\tret = -2;\n\t\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\t\t\t//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, \"Read bytes (%i) %ld\\n\", status, bytes);\n\n\t\t\t\t\tif (bytes == 0) {\n\t\t\t\t\t\tif (check_rtcp_and_ice(rtp_session) == -1) {\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// This is dumb\n\t\t\t\t\t\t//switch_rtp_video_refresh(rtp_session);\n\t\t\t\t\t\tgoto  rtcp;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((*flags & SFF_PROXY_PACKET)) {\n\t\t\t\t\tret = (int) bytes;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif ((*flags & SFF_RTCP)) {\n\t\t\t\t\t*flags &= ~SFF_RTCP;\n\t\t\t\t\thas_rtcp = 1;\n\t\t\t\t\tgoto rtcp;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tpoll_loop = 0;\n\t\t} else {\n\n\t\t\tif (!switch_rtp_ready(rtp_session)) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (!SWITCH_STATUS_IS_BREAK(poll_status) && poll_status != SWITCH_STATUS_TIMEOUT) {\n\t\t\t\tchar tmp[128] = \"\";\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Poll failed with error: %d [%s]\\n\",\n\t\t\t\t\t\t\t\t  poll_status, switch_strerror_r(poll_status, tmp, sizeof(tmp)));\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t\t\trtp_session->missed_count += (poll_sec * 1000) / (rtp_session->ms_per_packet ? rtp_session->ms_per_packet / 1000 : 20);\n\t\t\t\tbytes = 0;\n\n\t\t\t\tif (rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t\t} else if (rtp_session->max_missed_packets) {\n\t\t\t\t\tif (rtp_session->missed_count >= rtp_session->max_missed_packets) {\n\t\t\t\t\t\tret = -2;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (check_rtcp_and_ice(rtp_session) == -1) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\n\t\t\tif ((!(io_flags & SWITCH_IO_FLAG_NOBLOCK)) &&\n\t\t\t\t(rtp_session->dtmf_data.out_digit_dur == 0) && !rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\trtcp:\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\trtcp_poll_status = SWITCH_STATUS_FALSE;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX] && has_rtcp) {\n\t\t\t\tif (rtp_session->rtcp_recv_msg_p->header.version == 2) { //rtcp muxed\n\t\t\t\t\trtp_session->rtcp_from_addr = rtp_session->from_addr;\n\t\t\t\t\trtcp_status = rtcp_poll_status = SWITCH_STATUS_SUCCESS;\n\t\t\t\t\trtcp_bytes = bytes;\n\t\t\t\t}\n\n\t\t\t\thas_rtcp = 0;\n\n\t\t\t} else if (rtp_session->rtcp_read_pollfd) {\n\t\t\t\trtcp_poll_status = switch_poll(rtp_session->rtcp_read_pollfd, 1, &rtcp_fdr, 0);\n\t\t\t}\n\n\t\t\tif (rtcp_poll_status == SWITCH_STATUS_SUCCESS) {\n\n\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\t\trtcp_status = read_rtcp_packet(rtp_session, &rtcp_bytes, flags);\n\t\t\t\t}\n\n\t\t\t\tif (rtcp_status == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_rtp_reset_media_timer(rtp_session);\n\t\t\t\t\t\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU]) {\n\t\t\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\t\t\t\t\t\tconst char *uuid = switch_channel_get_partner_uuid(channel);\n\n\t\t\t\t\t\tif (uuid) {\n\t\t\t\t\t\t\tswitch_core_session_t *other_session;\n\t\t\t\t\t\t\tswitch_rtp_t *other_rtp_session = NULL;\n\n\t\t\t\t\t\t\tif ((other_session = switch_core_session_locate(uuid))) {\n\t\t\t\t\t\t\t\tswitch_channel_t *other_channel = switch_core_session_get_channel(other_session);\n\t\t\t\t\t\t\t\tif ((other_rtp_session = switch_channel_get_private(other_channel, \"__rtcp_audio_rtp_session\")) &&\n\t\t\t\t\t\t\t\t\tother_rtp_session->rtcp_sock_output &&\n\t\t\t\t\t\t\t\t\tswitch_rtp_test_flag(other_rtp_session, SWITCH_RTP_FLAG_ENABLE_RTCP)) {\n\t\t\t\t\t\t\t\t\tother_rtp_session->rtcp_send_msg = rtp_session->rtcp_recv_msg;\n\n#ifdef ENABLE_SRTP\n\t\t\t\t\t\t\t\t\tswitch_mutex_lock(other_rtp_session->ice_mutex);\n\t\t\t\t\t\t\t\t\tif (switch_rtp_test_flag(other_rtp_session, SWITCH_RTP_FLAG_SECURE_SEND)) {\n\t\t\t\t\t\t\t\t\t\tint stat = 0;\n\t\t\t\t\t\t\t\t\t\tint sbytes = (int) rtcp_bytes;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (!other_rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\t\t\t\t\t\t\t\tstat = srtp_protect_rtcp(other_rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &other_rtp_session->rtcp_send_msg.header, &sbytes);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tstat = srtp_protect_rtcp_mki(other_rtp_session->send_ctx[other_rtp_session->srtp_idx_rtcp], &other_rtp_session->rtcp_send_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (stat) {\n\t\t\t\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error: SRTP RTCP protection failed with code %d\\n\", stat);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\trtcp_bytes = sbytes;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tswitch_mutex_unlock(other_rtp_session->ice_mutex);\n#endif\n\n\t\t\t\t\t\t\t\t\tif (switch_socket_sendto(other_rtp_session->rtcp_sock_output, other_rtp_session->rtcp_remote_addr, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (const char*)&other_rtp_session->rtcp_send_msg, &rtcp_bytes ) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\"RTCP packet not written\\n\");\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {\n\t\t\t\t\t\tprocess_rtcp_packet(rtp_session, &rtcp_bytes);\n\t\t\t\t\t\tret = 1;\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((!(io_flags & SWITCH_IO_FLAG_NOBLOCK)) &&\n\t\t\t(rtp_session->dtmf_data.out_digit_dur == 0) && !got_rtp_poll) {\n\t\t\treturn_cng_frame();\n\t\t}\n\n\t\tif (!bytes && (io_flags & SWITCH_IO_FLAG_NOBLOCK)) {\n\t\t\trtp_session->missed_count = 0;\n\t\t\tret = 0;\n\t\t\tgoto end;\n\t\t}\n\n\t\tcheck = !bytes;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_FLUSH]) {\n\t\t\tbytes = do_flush(rtp_session, SWITCH_FALSE, bytes);\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);\n\t\t}\n\n\t\tif ((!bytes && rtp_session->flags[SWITCH_RTP_FLAG_BREAK]) || (bytes && bytes == 4 && *((int *) &rtp_session->recv_msg) == UINT_MAX)) {\n\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_BREAK);\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] || !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] ||\n\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] ||\n\t\t\t\t(bytes && bytes < 5) || (!bytes && poll_loop)) {\n\t\t\t\tbytes = 0;\n\t\t\t\treset_jitter_seq(rtp_session);\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && bytes < 5) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!bytes && poll_loop) {\n\t\t\tgoto recvfrom;\n\t\t}\n\n\t\tif (bytes && rtp_session->last_rtp_hdr.m && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\t\t!rtp_session->flags[SWITCH_RTP_FLAG_TEXT] &&\n\t\t\t!(rtp_session->rtp_bugs & RTP_BUG_IGNORE_MARK_BIT)) {\n\t\t\trtp_flush_read_buffer(rtp_session, SWITCH_RTP_FLUSH_ONCE);\n\t\t}\n\n\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {\n\t\t\t*flags |= SFF_NOT_AUDIO;\n\t\t} else {\n\t\t\t*flags &= ~SFF_NOT_AUDIO; /* If this flag was already set, make sure to remove it when we get real audio */\n\t\t}\n\n\t\t/* ignore packets not meant for us unless the auto-adjust window is open (ice mode has its own alternatives to this) */\n\t\tif (!using_ice(rtp_session) && bytes) {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_AUTOADJ]) {\n\t\t\t\tif (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {\n\t\t\t\t\tgoto recvfrom;\n\n\t\t\t\t}\n\t\t\t} else if (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PACKETS) && !switch_cmp_addr(rtp_session->rtp_from_addr, rtp_session->remote_addr, SWITCH_FALSE)) {\n\t\t\t\tgoto recvfrom;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && rtp_session->flags[SWITCH_RTP_FLAG_AUTOADJ] && switch_sockaddr_get_port(rtp_session->rtp_from_addr)) {\n\t\t\tif (!switch_cmp_addr(rtp_session->rtp_from_addr, rtp_session->remote_addr, SWITCH_FALSE)) {\n\t\t\t\tif (++rtp_session->autoadj_tally >= rtp_session->autoadj_threshold) {\n\t\t\t\t\tconst char *err;\n\t\t\t\t\tuint32_t old = rtp_session->remote_port;\n\t\t\t\t\tconst char *tx_host;\n\t\t\t\t\tconst char *old_host;\n\t\t\t\t\tchar bufa[50], bufb[50];\n\t\t\t\t\tchar adj_port[6];\n\n\t\t\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\t\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t  \"Auto Changing %s port from %s:%u to %s:%u\\n\", rtp_type(rtp_session), old_host, old, tx_host,\n\t\t\t\t\t\t\t\t\t  switch_sockaddr_get_port(rtp_session->rtp_from_addr));\n\n\t\t\t\t\tif (channel) {\n\t\t\t\t\t\tchar varname[80] = \"\";\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_ip_reported\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, switch_channel_get_variable(channel, \"remote_media_ip\"));\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_ip\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, tx_host);\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_port_reported\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_snprintf(adj_port, sizeof(adj_port), \"%u\", switch_sockaddr_get_port(rtp_session->rtp_from_addr));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, switch_channel_get_variable(channel, \"remote_media_port\"));\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"remote_%s_port\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, adj_port);\n\n\t\t\t\t\t\tswitch_snprintf(varname, sizeof(varname), \"rtp_auto_adjust_%s\", rtp_type(rtp_session));\n\t\t\t\t\t\tswitch_channel_set_variable(channel, varname, \"true\");\n\t\t\t\t\t}\n\t\t\t\t\trtp_session->auto_adj_used = 1;\n\t\t\t\t\tswitch_rtp_set_remote_address(rtp_session, tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr), 0, SWITCH_FALSE, &err);\n\t\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\t}\n\t\t\t\t\tif (rtp_session->ice.ice_user) {\n\t\t\t\t\t\trtp_session->ice.addr = rtp_session->remote_addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Correct %s ip/port confirmed.\\n\", rtp_type(rtp_session));\n\t\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t\t}\n\t\t\t\trtp_session->auto_adj_used = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && !(rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST) && rtp_session->autoadj_window) {\n\t\t\tif (--rtp_session->autoadj_window == 0) {\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);\n\t\t\t}\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\t\tif (!bytes) {\n\t\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t\t\tswitch_core_timer_next(&rtp_session->timer);\n\t\t\t\t}\n\t\t\t\treturn_cng_frame();\n\t\t\t} else {\n\t\t\t\t*payload_type = rtp_session->last_rtp_hdr.pt;\n\t\t\t\tret = (int) bytes;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes && (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL])) {\n\t\t\t/* Fast PASS! */\n\t\t\t*flags |= SFF_PROXY_PACKET;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n#if 0\n\t\t\t\tif (rtp_session->has_rtp && check_recv_payload(rtp_session)) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t\t\t\t  \"Ignoring udptl packet of size of %ld bytes that looks strikingly like a RTP packet.\\n\", (long)bytes);\n\t\t\t\t\tbytes = 0;\n\t\t\t\t\tgoto do_continue;\n\t\t\t\t}\n#endif\n\t\t\t\t*flags |= SFF_UDPTL_PACKET;\n\t\t\t}\n\n\t\t\tret = (int) bytes;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (bytes) {\n\t\t\trtp_session->missed_count = 0;\n\n\t\t\tif (bytes < rtp_header_len) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Ignoring invalid RTP packet size of %ld bytes.\\n\", (long)bytes);\n\t\t\t\tbytes = 0;\n\t\t\t\tgoto do_continue;\n\t\t\t}\n\n\t\t\tif (rtp_session->last_rtp_hdr.pt && (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13)) {\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\t\tif (check || bytes) {\n\t\t\tdo_2833(rtp_session);\n\t\t}\n\n\t\tif (bytes && rtp_session->recv_msg.header.version != 2) {\n\t\t\tuint8_t *data = (uint8_t *) RTP_BODY(rtp_session);\n\n\t\t\t//if (rtp_session->recv_msg.header.version == 0) {\n\t\t\t//\tif (rtp_session->ice.ice_user) {\n\t\t\t//\t\thandle_ice(rtp_session, &rtp_session->ice, (void *) &rtp_session->recv_msg, bytes);\n\t\t\t//\t\tgoto recvfrom;\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\tif (rtp_session->invalid_handler) {\n\t\t\t\trtp_session->invalid_handler(rtp_session, rtp_session->sock_input, (void *) &rtp_session->recv_msg, bytes, rtp_session->rtp_from_addr);\n\t\t\t}\n\n\t\t\tmemset(data, 0, 2);\n\t\t\tdata[0] = 65;\n\n\t\t\trtp_session->last_rtp_hdr.pt = rtp_session->cng_pt != INVALID_PT ? rtp_session->cng_pt : SWITCH_RTP_CNG_PAYLOAD;\n\t\t\t*flags |= SFF_CNG;\n\t\t\t*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;\n\t\t\tret = 2 + rtp_header_len;\n\t\t\tgoto end;\n\t\t} else if (bytes) {\n\t\t\trtp_session->stats.inbound.period_packet_count++;\n\t\t}\n\n\n\t\t/* Handle incoming RFC2833 packets */\n\t\tswitch (handle_rfc2833(rtp_session, bytes, &do_cng)) {\n\t\tcase RESULT_GOTO_END:\n\t\t\tgoto end;\n\t\tcase RESULT_GOTO_RECVFROM:\n\t\t\tgoto recvfrom;\n\t\tcase RESULT_GOTO_TIMERCHECK:\n\t\t\tgoto timer_check;\n\t\tcase RESULT_CONTINUE:\n\t\t\tstatus = SWITCH_STATUS_SUCCESS;\n\t\t\tgoto result_continue;\n\t\t}\n\n\tresult_continue:\n\ttimer_check:\n\n\t\tif (!rtp_session->media_timeout && rtp_session->flags[SWITCH_RTP_FLAG_MUTE]) {\n\t\t\tdo_cng++;\n\t\t}\n\n\t\tif (do_cng) {\n\t\t\tuint8_t *data = (uint8_t *) RTP_BODY(rtp_session);\n\n\t\t\tdo_2833(rtp_session);\n\n\t\t\tif (rtp_session->last_cng_ts == rtp_session->last_read_ts + rtp_session->samples_per_interval) {\n\t\t\t\trtp_session->last_cng_ts = 0;\n\t\t\t} else {\n\t\t\t\trtp_session->last_cng_ts = rtp_session->last_read_ts + rtp_session->samples_per_interval;\n\t\t\t}\n\n\t\t\tmemset(data, 0, 2);\n\t\t\tdata[0] = 65;\n\t\t\trtp_session->last_rtp_hdr.pt = rtp_session->cng_pt != INVALID_PT ? rtp_session->cng_pt : SWITCH_RTP_CNG_PAYLOAD;\n\t\t\t*flags |= SFF_CNG;\n\t\t\t*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;\n\t\t\tret = 2 + rtp_header_len;\n\t\t\trtp_session->stats.inbound.skip_packet_count++;\n\t\t\tgoto end;\n\t\t}\n\n\n\t\tif (check || (bytes && !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER])) {\n\t\t\tif (!bytes && rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\t/* We're late! We're Late! */\n\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] && status == SWITCH_STATUS_BREAK) {\n\t\t\t\t\tswitch_cond_next();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\n\t\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PAUSE] && !rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] && !rtp_session->dtmf_data.in_digit_ts\n\t\t\t\t\t&& rtp_session->cng_count > (rtp_session->one_second * 2) && rtp_session->jitter_lead > JITTER_LEAD_FRAMES) {\n\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \"%s %s timeout\\n\",\n\t\t\t\t\t\t\t\t\t  rtp_session_name(rtp_session), rtp_type(rtp_session));\n\n\t\t\t\t\tif (rtp_session->media_timeout && rtp_session->last_media) {\n\t\t\t\t\t\tcheck_timeout(rtp_session);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rtp_session->stats.inbound.error_log) {\n\t\t\t\t\t\trtp_session->stats.inbound.error_log->flaws++;\n\t\t\t\t\t}\n\t\t\t\t\trtp_session->stats.inbound.flaws++;\n\t\t\t\t\tdo_mos(rtp_session);\n\t\t\t\t}\n\n\t\t\t\trtp_session->cng_count++;\n\t\t\t\treturn_cng_frame();\n\t\t\t}\n\t\t}\n\n\t\trtp_session->cng_count = 0;\n\n\t\tif (status == SWITCH_STATUS_BREAK || bytes == 0) {\n\t\t\tif (!(io_flags & SWITCH_IO_FLAG_SINGLE_READ) && rtp_session->flags[SWITCH_RTP_FLAG_DATAWAIT]) {\n\t\t\t\tgoto do_continue;\n\t\t\t}\n\t\t\treturn_cng_frame();\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_GOOGLEHACK] && rtp_session->last_rtp_hdr.pt == 102) {\n\t\t\trtp_session->last_rtp_hdr.pt = 97;\n\t\t}\n\n\t\tbreak;\n\n\tdo_continue:\n\n\t\tif (!bytes && !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\n\t\t\tif (sleep_mss) {\n\t\t\t\tswitch_yield(sleep_mss);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (switch_rtp_ready(rtp_session)) {\n\t\t*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;\n\n\t\tif (*payload_type == SWITCH_RTP_CNG_PAYLOAD) {\n\t\t\t*flags |= SFF_CNG;\n\t\t}\n\n\t\tret = (int) bytes;\n\t} else {\n\t\tret = -1;\n\t}\n\n end:\n\n\tREAD_DEC(rtp_session);\n\n\treturn ret;\n}\n\n\nSWITCH_DECLARE(switch_byte_t) switch_rtp_check_auto_adj(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->auto_adj_used;\n}\n\nSWITCH_DECLARE(switch_size_t) switch_rtp_has_dtmf(switch_rtp_t *rtp_session)\n{\n\tswitch_size_t has = 0;\n\n\tif (switch_rtp_ready(rtp_session)) {\n\t\tswitch_mutex_lock(rtp_session->dtmf_data.dtmf_mutex);\n\t\thas = switch_queue_size(rtp_session->dtmf_data.dtmf_inqueue);\n\t\tswitch_mutex_unlock(rtp_session->dtmf_data.dtmf_mutex);\n\t}\n\n\treturn has;\n}\n\nSWITCH_DECLARE(switch_size_t) switch_rtp_dequeue_dtmf(switch_rtp_t *rtp_session, switch_dtmf_t *dtmf)\n{\n\tswitch_size_t bytes = 0;\n\tswitch_dtmf_t *_dtmf = NULL;\n\tvoid *pop;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn bytes;\n\t}\n\n\tswitch_mutex_lock(rtp_session->dtmf_data.dtmf_mutex);\n\tif (switch_queue_trypop(rtp_session->dtmf_data.dtmf_inqueue, &pop) == SWITCH_STATUS_SUCCESS) {\n\n\t\t_dtmf = (switch_dtmf_t *)pop;\n\t\t*dtmf = *_dtmf;\n\t\t/* Only log DTMF buffer if sensitive_dtmf channel variable not set to true */\n\t\tif (!(switch_channel_var_true(switch_core_session_get_channel(rtp_session->session), SWITCH_SENSITIVE_DTMF_VARIABLE))) {\t\t\t\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,\"RTP RECV DTMF %c:%d\\n\", dtmf->digit, dtmf->duration);\n\t\t}\n\t\tbytes++;\n\t\tfree(pop);\n\t}\n\tswitch_mutex_unlock(rtp_session->dtmf_data.dtmf_mutex);\n\n\treturn bytes;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_queue_rfc2833(switch_rtp_t *rtp_session, const switch_dtmf_t *dtmf)\n{\n\n\tswitch_dtmf_t *rdigit;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif ((rdigit = malloc(sizeof(*rdigit))) != 0) {\n\t\t*rdigit = *dtmf;\n\t\tif (rdigit->duration < switch_core_min_dtmf_duration(0)) {\n\t\t\trdigit->duration = switch_core_min_dtmf_duration(0);\n\t\t}\n\n\t\tif ((switch_queue_trypush(rtp_session->dtmf_data.dtmf_queue, rdigit)) != SWITCH_STATUS_SUCCESS) {\n\t\t\tfree(rdigit);\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t} else {\n\t\tabort();\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_queue_rfc2833_in(switch_rtp_t *rtp_session, const switch_dtmf_t *dtmf)\n{\n\tswitch_dtmf_t *rdigit;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif ((rdigit = malloc(sizeof(*rdigit))) != 0) {\n\t\t*rdigit = *dtmf;\n\t\tif (rdigit->duration < switch_core_min_dtmf_duration(0)) {\n\t\t\trdigit->duration = switch_core_min_dtmf_duration(0);\n\t\t}\n\n\t\tif ((switch_queue_trypush(rtp_session->dtmf_data.dtmf_inqueue, rdigit)) != SWITCH_STATUS_SUCCESS) {\n\t\t\tfree(rdigit);\n\t\t\treturn SWITCH_STATUS_FALSE;\n\t\t}\n\t} else {\n\t\tabort();\n\t}\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_read(switch_rtp_t *rtp_session, void *data, uint32_t *datalen,\n\t\t\t\t\t\t\t\t\t\t\t\tswitch_payload_t *payload_type, switch_frame_flag_t *flags, switch_io_flag_t io_flags)\n{\n\tint bytes = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tbytes = rtp_common_read(rtp_session, payload_type, NULL, flags, io_flags);\n\n\tif (bytes < 0) {\n\t\t*datalen = 0;\n\t\treturn bytes == -2 ? SWITCH_STATUS_TIMEOUT : SWITCH_STATUS_GENERR;\n\t} else if (bytes == 0) {\n\t\t*datalen = 0;\n\t\treturn SWITCH_STATUS_BREAK;\n\t} else {\n\t\tif (bytes > rtp_header_len) {\n\t\t\tbytes -= rtp_header_len;\n\t\t}\n\t}\n\n\t*datalen = bytes;\n\n\tmemcpy(data, RTP_BODY(rtp_session), bytes);\n\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtcp_zerocopy_read_frame(switch_rtp_t *rtp_session, switch_rtcp_frame_t *frame)\n{\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\t/* A fresh frame has been found! */\n\tif (rtp_session->rtcp_fresh_frame) {\n\t\t/* turn the flag off! */\n\t\trtp_session->rtcp_fresh_frame = 0;\n\n\t\t*frame = rtp_session->rtcp_frame;\n\n\t\treturn SWITCH_STATUS_SUCCESS;\n\t}\n\n\treturn SWITCH_STATUS_TIMEOUT;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_zerocopy_read_frame(switch_rtp_t *rtp_session, switch_frame_t *frame, switch_io_flag_t io_flags)\n{\n\tint bytes = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tbytes = rtp_common_read(rtp_session, &frame->payload, &frame->pmap, &frame->flags, io_flags);\n\n\tframe->data = RTP_BODY(rtp_session);\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && (bytes < rtp_header_len || switch_test_flag(frame, SFF_CNG))) {\n\t\tframe->packet = NULL;\n\t\tframe->timestamp = 0;\n\t\tframe->seq = 0;\n\t\tframe->ssrc = 0;\n\t\tframe->m = 0;\n\t} else {\n\n\t\tframe->packet = &rtp_session->recv_msg;\n\t\tframe->packetlen = bytes;\n\t\tframe->source = __FILE__;\n\n\t\tswitch_set_flag(frame, SFF_RAW_RTP);\n\t\tswitch_set_flag(frame, SFF_EXTERNAL);\n\t\tif (frame->payload == rtp_session->recv_te) {\n\t\t\tswitch_set_flag(frame, SFF_RFC2833);\n\t\t}\n\t\tframe->timestamp = ntohl(rtp_session->last_rtp_hdr.ts);\n\t\tframe->seq = (uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);\n\t\tframe->ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);\n\t\tframe->m = rtp_session->last_rtp_hdr.m ? SWITCH_TRUE : SWITCH_FALSE;\n\t}\n\n\n\tif (bytes < 0) {\n\t\tframe->datalen = 0;\n\t\treturn bytes == -2 ? SWITCH_STATUS_TIMEOUT : SWITCH_STATUS_GENERR;\n\t} else if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\tif (bytes < rtp_header_len) {\n\t\t\tframe->datalen = 0;\n\t\t\treturn SWITCH_STATUS_BREAK;\n\t\t} else {\n\t\t\tbytes -= rtp_header_len;\n\t\t}\n\t}\n\n\tframe->datalen = bytes;\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_zerocopy_read(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t void **data, uint32_t *datalen, switch_payload_t *payload_type, switch_frame_flag_t *flags,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t switch_io_flag_t io_flags)\n{\n\tint bytes = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tbytes = rtp_common_read(rtp_session, payload_type, NULL, flags, io_flags);\n\t*data = RTP_BODY(rtp_session);\n\n\tif (bytes < 0) {\n\t\t*datalen = 0;\n\t\treturn SWITCH_STATUS_GENERR;\n\t} else {\n\t\tif (bytes > rtp_header_len) {\n\t\t\tbytes -= rtp_header_len;\n\t\t}\n\t}\n\n\t*datalen = bytes;\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nstatic int rtp_write_ready(switch_rtp_t *rtp_session, uint32_t bytes, int line)\n{\n\tif (!rtp_session) return 0;\n\n\tif (rtp_session->ice.ice_user && !(rtp_session->ice.rready || rtp_session->ice.ready)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Skip sending %s packet %ld bytes (ice not ready @ line %d!)\\n\",\n\t\t\t\t\t\t  rtp_type(rtp_session), (long)bytes, line);\n\t\treturn 0;\n\t}\n\n\tif (rtp_session->dtls && rtp_session->dtls->state != DS_READY) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, \"Skip sending %s packet %ld bytes (dtls not ready @ line %d!)\\n\",\n\t\t\t\t\t\t  rtp_type(rtp_session), (long)bytes, line);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic int rtp_common_write(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\trtp_msg_t *send_msg, void *data, uint32_t datalen, switch_payload_t payload, uint32_t timestamp, switch_frame_flag_t *flags)\n{\n\tswitch_size_t bytes;\n\tuint8_t send = 1;\n\tuint32_t this_ts = 0;\n\tint ret;\n\tswitch_time_t now;\n\tuint8_t m = 0;\n\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn -1;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, datalen, __LINE__)) {\n\t\treturn 0;\n\t}\n\n\tWRITE_INC(rtp_session);\n\t\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t}\n\n\tif (send_msg) {\n\t\tbytes = datalen;\n\n\t\tm = (uint8_t) send_msg->header.m;\n\t\trtp_session->ts = ntohl(send_msg->header.ts);\n\n\t\tif (flags && *flags & SFF_RFC2833) {\n\t\t\tif (rtp_session->te == INVALID_PT) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tsend_msg->header.pt = rtp_session->te;\n\t\t}\n\t\tdata = send_msg->body;\n\t\tif (datalen > rtp_header_len) {\n\t\t\tdatalen -= rtp_header_len;\n\t\t}\n\t} else {\n\t\tif (*flags & SFF_RFC2833) {\n\t\t\tif (rtp_session->te == INVALID_PT) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tpayload = rtp_session->te;\n\t\t}\n\n\t\tsend_msg = &rtp_session->send_msg;\n\t\tsend_msg->header.pt = payload;\n\n\t\tm = get_next_write_ts(rtp_session, timestamp);\n\n\t\trtp_session->send_msg.header.ts = htonl(rtp_session->ts);\n\n\t\tmemcpy(send_msg->body, data, datalen);\n\t\tbytes = datalen + rtp_header_len;\n\t}\n\n\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\t\t\n\t\tif ((rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {\n\t\t\tm = 0;\n\t\t} else {\n\t\t\tint delta = rtp_session->ts - rtp_session->last_write_ts;\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&\n\t\t\t\t((!rtp_session->flags[SWITCH_RTP_FLAG_RESET] && (abs(delta) > rtp_session->samples_per_interval * 10))\n\t\t\t\t|| rtp_session->ts == rtp_session->samples_per_interval)) {\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\t}\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&\n\t\t\t\t(rtp_session->write_timer.samplecount - rtp_session->last_write_samplecount) > rtp_session->samples_per_interval * 10) {\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&\n\t\t\t\t((unsigned) ((switch_micro_time_now() - rtp_session->last_write_timestamp))) > (rtp_session->ms_per_packet * 10)) {\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (rtp_session->cn && payload != rtp_session->cng_pt) {\n\t\t\t\trtp_session->cn = 0;\n\t\t\t\tm++;\n\t\t\t}\n\n\t\t\tif (rtp_session->need_mark && !rtp_session->sending_dtmf) {\n\t\t\t\tm++;\n\t\t\t\trtp_session->need_mark = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (m) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t\t\trtp_session->ts = 0;\n\t\t}\n\n\t\t/* If the marker was set, and the timestamp seems to have started over - set a new SSRC, to indicate this is a new stream */\n\t\tif (m && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND) && (rtp_session->rtp_bugs & RTP_BUG_CHANGE_SSRC_ON_MARKER) &&\n\t\t\t(rtp_session->flags[SWITCH_RTP_FLAG_RESET] || (rtp_session->ts <= rtp_session->last_write_ts && rtp_session->last_write_ts > 0))) {\n\t\t\tswitch_rtp_set_ssrc(rtp_session, (uint32_t) ((intptr_t) rtp_session + (switch_time_t) switch_epoch_time_now(NULL)));\n\t\t}\n\n\t\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO) && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_UDPTL)) {\n\t\t\tsend_msg->header.m = (m && !(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) ? 1 : 0;\n\t\t}\n\t}\n\n\tif (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\t\tint external = (flags && *flags & SFF_EXTERNAL);\n\t\t/* Normalize the timestamps to our own base by generating a made up starting point then adding the measured deltas to that base\n\t\t   so if the timestamps and ssrc of the source change, it will not break the other end's jitter bufffer / decoder etc *cough* CHROME *cough*\n\t\t */\n\n\t\tif (!rtp_session->ts_norm.ts) {\n\t\t\trtp_session->ts_norm.ts = (uint32_t) rand() % 1000000 + 1;\n\t\t}\n\n\t\tif (!rtp_session->ts_norm.last_ssrc || send_msg->header.ssrc != rtp_session->ts_norm.last_ssrc || rtp_session->ts_norm.last_external != external) {\n\t\t\tswitch_core_session_t *other_session;\n\t\t\t\n\t\t\tswitch_core_session_request_video_refresh(rtp_session->session);\n\t\t\tswitch_core_media_gen_key_frame(rtp_session->session);\n\n\t\t\tif (switch_core_session_get_partner(rtp_session->session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_core_session_request_video_refresh(other_session);\n\t\t\t\tswitch_core_media_gen_key_frame(other_session);\n\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t}\n\n\t\t\tif (rtp_session->ts_norm.last_ssrc) {\n\t\t\t\trtp_session->ts_norm.delta_ttl = 0;\n\t\t\t\trtp_session->ts_norm.ts++;\n\t\t\t}\n\n\t\t\trtp_session->ts_norm.last_ssrc = send_msg->header.ssrc;\n\t\t\trtp_session->ts_norm.last_frame = ntohl(send_msg->header.ts);\n\t\t}\n\n\t\trtp_session->ts_norm.last_external = external;\n\n\t\tif (ntohl(send_msg->header.ts) != rtp_session->ts_norm.last_frame) {\n\t\t\tint32_t delta = ntohl(send_msg->header.ts) - rtp_session->ts_norm.last_frame;\n\n\t\t\tif (delta < 0 || delta > 90000) {\n\t\t\t\tswitch_core_media_gen_key_frame(rtp_session->session);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, \n\t\t\t\t\t\t\t\t  \"Timestamp shift detected last: %d this: %d delta: %d stick with prev delta: %d\\n\", \n\t\t\t\t\t\t\t\t  rtp_session->ts_norm.last_frame, ntohl(send_msg->header.ts), delta, rtp_session->ts_norm.delta);\n\t\t\t} else {\n\t\t\t\trtp_session->ts_norm.delta = delta;\n\t\t\t}\n\n\t\t\trtp_session->ts_norm.ts += rtp_session->ts_norm.delta;\n\n\t\t}\n\t\t\n\t\trtp_session->ts_norm.last_frame = ntohl(send_msg->header.ts);\n\t\tsend_msg->header.ts = htonl(rtp_session->ts_norm.ts);\n\t\tthis_ts = rtp_session->ts_norm.ts;\n\t}\n\n\tsend_msg->header.ssrc = htonl(rtp_session->ssrc);\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_GOOGLEHACK] && rtp_session->send_msg.header.pt == 97) {\n\t\trtp_session->last_rtp_hdr.pt = 102;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VAD] &&\n\t\trtp_session->last_rtp_hdr.pt == rtp_session->vad_data.read_codec->implementation->ianacode) {\n\n\t\tint16_t decoded[SWITCH_RECOMMENDED_BUFFER_SIZE / sizeof(int16_t)] = { 0 };\n\t\tuint32_t rate = 0;\n\t\tuint32_t codec_flags = 0;\n\t\tuint32_t len = sizeof(decoded);\n\t\ttime_t now = switch_epoch_time_now(NULL);\n\t\tsend = 0;\n\n\t\tif (rtp_session->vad_data.scan_freq && rtp_session->vad_data.next_scan <= now) {\n\t\t\trtp_session->vad_data.bg_count = rtp_session->vad_data.bg_level = 0;\n\t\t\trtp_session->vad_data.next_scan = now + rtp_session->vad_data.scan_freq;\n\t\t}\n\n\t\tif (switch_core_codec_decode(&rtp_session->vad_data.vad_codec,\n\t\t\t\t\t\t\t\t\t rtp_session->vad_data.read_codec,\n\t\t\t\t\t\t\t\t\t data,\n\t\t\t\t\t\t\t\t\t datalen,\n\t\t\t\t\t\t\t\t\t rtp_session->vad_data.read_codec->implementation->actual_samples_per_second,\n\t\t\t\t\t\t\t\t\t decoded, &len, &rate, &codec_flags) == SWITCH_STATUS_SUCCESS) {\n\n\t\t\tuint32_t energy = 0;\n\t\t\tuint32_t x, y = 0, z = len / sizeof(int16_t);\n\t\t\tuint32_t score = 0;\n\t\t\tint divisor = 0;\n\t\t\tif (z) {\n\n\t\t\t\tif (!(divisor = rtp_session->vad_data.read_codec->implementation->actual_samples_per_second / 8000)) {\n\t\t\t\t\tdivisor = 1;\n\t\t\t\t}\n\n\t\t\t\tfor (x = 0; x < z; x++) {\n\t\t\t\t\tenergy += abs(decoded[y]);\n\t\t\t\t\ty += rtp_session->vad_data.read_codec->implementation->number_of_channels;\n\t\t\t\t}\n\n\t\t\t\tif (++rtp_session->vad_data.start_count < rtp_session->vad_data.start) {\n\t\t\t\t\tsend = 1;\n\t\t\t\t} else {\n\t\t\t\t\tscore = (energy / (z / divisor));\n\t\t\t\t\tif (score && (rtp_session->vad_data.bg_count < rtp_session->vad_data.bg_len)) {\n\t\t\t\t\t\trtp_session->vad_data.bg_level += score;\n\t\t\t\t\t\tif (++rtp_session->vad_data.bg_count == rtp_session->vad_data.bg_len) {\n\t\t\t\t\t\t\trtp_session->vad_data.bg_level /= rtp_session->vad_data.bg_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsend = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (score > rtp_session->vad_data.bg_level && !switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\t\t\t\t\t\tuint32_t diff = score - rtp_session->vad_data.bg_level;\n\n\t\t\t\t\t\t\tif (rtp_session->vad_data.hangover_hits) {\n\t\t\t\t\t\t\t\trtp_session->vad_data.hangover_hits--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (diff >= rtp_session->vad_data.diff_level || ++rtp_session->vad_data.hangunder_hits >= rtp_session->vad_data.hangunder) {\n\n\t\t\t\t\t\t\t\tswitch_set_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING);\n\n\t\t\t\t\t\t\t\trtp_session->vad_data.start_talking = switch_micro_time_now();\n\n\t\t\t\t\t\t\t\tif (!(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {\n\t\t\t\t\t\t\t\t\tsend_msg->header.m = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trtp_session->vad_data.hangover_hits = rtp_session->vad_data.hangunder_hits = rtp_session->vad_data.cng_count = 0;\n\t\t\t\t\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_EVENTS_TALK)) {\n\n\t\t\t\t\t\t\t\t\tif ((rtp_session->vad_data.fire_events & VAD_FIRE_TALK)) {\n\t\t\t\t\t\t\t\t\t\tswitch_event_t *event;\n\t\t\t\t\t\t\t\t\t\tif (switch_event_create(&event, SWITCH_EVENT_TALK) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\t\t\t\t\tswitch_channel_event_set_data(switch_core_session_get_channel(rtp_session->vad_data.session), event);\n\t\t\t\t\t\t\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rtp_session->vad_data.hangunder_hits) {\n\t\t\t\t\t\t\t\trtp_session->vad_data.hangunder_hits--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\t\t\t\t\t\t\tif (++rtp_session->vad_data.hangover_hits >= rtp_session->vad_data.hangover) {\n\t\t\t\t\t\t\t\t\trtp_session->vad_data.stop_talking = switch_micro_time_now();\n\t\t\t\t\t\t\t\t\trtp_session->vad_data.total_talk_time += (rtp_session->vad_data.stop_talking - rtp_session->vad_data.start_talking);\n\n\t\t\t\t\t\t\t\t\tswitch_clear_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING);\n\n\t\t\t\t\t\t\t\t\trtp_session->vad_data.hangover_hits = rtp_session->vad_data.hangunder_hits = rtp_session->vad_data.cng_count = 0;\n\t\t\t\t\t\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_EVENTS_NOTALK)) {\n\n\t\t\t\t\t\t\t\t\t\tif ((rtp_session->vad_data.fire_events & VAD_FIRE_NOT_TALK)) {\n\t\t\t\t\t\t\t\t\t\t\tswitch_event_t *event;\n\t\t\t\t\t\t\t\t\t\t\tif (switch_event_create(&event, SWITCH_EVENT_NOTALK) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch_channel_event_set_data(switch_core_session_get_channel(rtp_session->vad_data.session), event);\n\t\t\t\t\t\t\t\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\t\t\t\tsend = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {\n\t\tuint32_t ts_delta;\n\n\t\tthis_ts = ntohl(send_msg->header.ts);\n\n\t\tts_delta = abs((int32_t)(this_ts - rtp_session->last_write_ts));\n\n\t\tif (ts_delta > rtp_session->samples_per_second * 2) {\n\t\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t\t}\n#ifdef DEBUG_TS_ROLLOVER\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"WRITE TS LAST:%u THIS:%u DELTA:%u\\n\", rtp_session->last_write_ts, this_ts, ts_delta);\n#endif\n\t\tif ((!(flags && *flags & SFF_RFC2833) && ts_delta == 0) || !switch_rtp_ready(rtp_session) || rtp_session->sending_dtmf) {\n\t\t\tsend = 0;\n\t\t}\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_PAUSE]) {\n\t\tsend = 0;\n\t}\n\n\tif (send) {\n\t\tint delta = 1;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (*flags & SFF_EXTERNAL) && \n\t\t\trtp_session->stats.outbound.packet_count && rtp_session->flags[SWITCH_RTP_FLAG_PASSTHRU]) {\n\t\t\tint32_t x = rtp_session->last_write_seq;\n\t\t\tint32_t y = ntohs(send_msg->header.seq);\n\n\t\t\tif (!rtp_session->video_delta_mode) {\n\t\t\t\trtp_session->video_delta_mode = 1;\n\t\t\t} else {\n\t\t\t\tif (x > UINT16_MAX / 2 && y < UINT16_MAX / 2) {\n\t\t\t\t\tx -= (int32_t)UINT16_MAX+1;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tdelta = y-x;\n\t\t\t}\n\t\t\t\n\t\t\trtp_session->last_write_seq = y;\n\t\t}\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_PASSTHRU]) {\n\t\t\trtp_session->video_delta_mode = 0;\n\t\t}\n\n\t\trtp_session->seq += delta;\n\n\t\tsend_msg->header.seq = htons(rtp_session->seq);\n\t\t\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_BYTESWAP] && send_msg->header.pt == rtp_session->payload) {\n\t\t\tswitch_swap_linear((int16_t *)send_msg->body, (int) datalen);\n\t\t}\n\n#ifdef ENABLE_SRTP\n\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\t\t\tint sbytes = (int) bytes;\n\t\t\tsrtp_err_status_t stat;\n\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET] || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {\n\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND_RESET);\n\t\t\t\tsrtp_dealloc(rtp_session->send_ctx[rtp_session->srtp_idx_rtp]);\n\t\t\t\trtp_session->send_ctx[rtp_session->srtp_idx_rtp] = NULL;\n\t\t\t\tif (srtp_create(&rtp_session->send_ctx[rtp_session->srtp_idx_rtp],\n\t\t\t\t\t\t\t\t\t\t&rtp_session->send_policy[rtp_session->srtp_idx_rtp]) || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t  \"Error! RE-Activating %s Secure RTP SEND\\n\", rtp_type(rtp_session));\n\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\t\t\t\t\tret = -1;\n\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\tgoto end;\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,\n\t\t\t\t\t\t\t\t\t  \"RE-Activating %s Secure RTP SEND\\n\", rtp_type(rtp_session));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\tstat = srtp_protect(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &send_msg->header, &sbytes);\n\t\t\t} else {\n\t\t\t\tstat = srtp_protect_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &send_msg->header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t}\n\n\t\t\tif (stat) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,\n\t\t\t\t\t\t\t\t  \"Error: %s SRTP protection failed with code %d\\n\", rtp_type(rtp_session), stat);\n\t\t\t}\n\n\t\t\tbytes = sbytes;\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\n\t\tnow = switch_micro_time_now();\n#ifdef RTP_DEBUG_WRITE_DELTA\n\t\t{\n\t\t\tint delta = (int) (now - rtp_session->send_time) / 1000;\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"WRITE %d delta %d\\n\", (int) bytes, delta);\n\t\t}\n#endif\n\t\trtp_session->send_time = now;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\tconst char *tx_host;\n\t\t\tconst char *old_host;\n\t\t\tconst char *my_host;\n\n\t\t\tchar bufa[50], bufb[50], bufc[50];\n\n\n\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t  \"W %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),\n\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_NACK]) {\n\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);\n\n\t\t\tif (!rtp_session->vbw) {\n\t\t\t\tint nack_size = 100;\n\t\t\t\tconst char *var;\n\t\t\t\t\n\t\t\t\tif ((var = switch_channel_get_variable(channel, \"rtp_nack_buffer_size\"))) {\n\t\t\t\t\tint tmp = atoi(var);\n\t\t\t\t\t\n\t\t\t\t\tif (tmp > 0 && tmp < 500) {\n\t\t\t\t\t\tnack_size = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch_jb_create(&rtp_session->vbw, SJB_VIDEO, nack_size, nack_size, rtp_session->pool);\n\n\t\t\t\tif (rtp_session->vbw) {\n\t\t\t\t\tswitch_jb_set_flag(rtp_session->vbw, SJB_QUEUE_ONLY);\n\t\t\t\t\t//switch_jb_debug_level(rtp_session->vbw, 10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch_jb_put_packet(rtp_session->vbw, (switch_rtp_packet_t *)send_msg, bytes);\n\t\t}\n\n#ifdef RTP_WRITE_PLOSS\n\t\t{\n\t\t\tint r = (rand() % 10000) + 1;\n\n\t\t\tif (r <= 200) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ALERT,\n\t\t\t\t\t\t\t\t  \"Simulate dropping packet ......... ts: %u seq: %u\\n\", ntohl(send_msg->header.ts), ntohs(send_msg->header.seq));\n\t\t\t} else {\n\t\t\t\tif (switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, (void *) send_msg, &bytes) != SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\trtp_session->seq--;\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t\t//\n\t\t//\trtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]++;\n\t\t//\n\t\t//\t//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, \"SEND %u\\n\", ntohs(send_msg->header.seq));\n\t\t//}\n\t\tif (switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, (void *) send_msg, &bytes) != SWITCH_STATUS_SUCCESS) {\n\t\t\trtp_session->seq -= delta;\n\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n#endif\n\t\trtp_session->last_write_ts = this_ts;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 0;\n\n\t\tif (rtp_session->queue_delay) {\n\t\t\trtp_session->delay_samples = rtp_session->queue_delay;\n\t\t\trtp_session->queue_delay = 0;\n\t\t}\n\n\t\trtp_session->stats.outbound.raw_bytes += bytes;\n\t\trtp_session->stats.outbound.packet_count++;\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {\n\t\t\trtp_session->stats.rtcp.sent_pkt_count++;\n\t\t}\n\n\t\tif (send_msg->header.pt == rtp_session->cng_pt) {\n\t\t\trtp_session->stats.outbound.cng_packet_count++;\n\t\t} else {\n\t\t\trtp_session->stats.outbound.media_packet_count++;\n\t\t\trtp_session->stats.outbound.media_bytes += bytes;\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {\n\t\t\t//switch_core_timer_sync(&rtp_session->write_timer);\n\t\t\trtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;\n\t\t}\n\n\t\trtp_session->last_write_timestamp = switch_micro_time_now();\n\t}\n\n\tret = (int) bytes;\n\n end:\n\n\tWRITE_DEC(rtp_session);\n\n\treturn ret;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_disable_vad(switch_rtp_t *rtp_session)\n{\n\n\tif (!rtp_session) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (!rtp_session->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\treturn SWITCH_STATUS_GENERR;\n\t}\n\tswitch_core_codec_destroy(&rtp_session->vad_data.vad_codec);\n\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_VAD);\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_enable_vad(switch_rtp_t *rtp_session, switch_core_session_t *session, switch_codec_t *codec,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  switch_vad_flag_t flags)\n{\n\tif (!switch_rtp_ready(rtp_session)) {\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\n\tif (rtp_session->flags[SWITCH_RTP_FLAG_VAD]) {\n\t\treturn SWITCH_STATUS_GENERR;\n\t}\n\n\tmemset(&rtp_session->vad_data, 0, sizeof(rtp_session->vad_data));\n\n\tif (switch_true(switch_channel_get_variable(switch_core_session_get_channel(rtp_session->session), \"fire_talk_events\"))) {\n\t\trtp_session->vad_data.fire_events |= VAD_FIRE_TALK;\n\t}\n\n\tif (switch_true(switch_channel_get_variable(switch_core_session_get_channel(rtp_session->session), \"fire_not_talk_events\"))) {\n\t\trtp_session->vad_data.fire_events |= VAD_FIRE_NOT_TALK;\n\t}\n\n\n\tif (switch_core_codec_init(&rtp_session->vad_data.vad_codec,\n\t\t\t\t\t\t\t   codec->implementation->iananame,\n\t\t\t\t\t\t\t   codec->implementation->modname,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   codec->implementation->samples_per_second,\n\t\t\t\t\t\t\t   codec->implementation->microseconds_per_packet / 1000,\n\t\t\t\t\t\t\t   codec->implementation->number_of_channels,\n\t\t\t\t\t\t\t   SWITCH_CODEC_FLAG_ENCODE | SWITCH_CODEC_FLAG_DECODE, NULL, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Can't load codec?\\n\");\n\t\treturn SWITCH_STATUS_FALSE;\n\t}\n\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, \"Activate VAD codec %s %dms\\n\", codec->implementation->iananame,\n\t\t\t\t\t  codec->implementation->microseconds_per_packet / 1000);\n\trtp_session->vad_data.diff_level = 400;\n\trtp_session->vad_data.hangunder = 15;\n\trtp_session->vad_data.hangover = 40;\n\trtp_session->vad_data.bg_len = 5;\n\trtp_session->vad_data.bg_count = 5;\n\trtp_session->vad_data.bg_level = 300;\n\trtp_session->vad_data.read_codec = codec;\n\trtp_session->vad_data.session = session;\n\trtp_session->vad_data.flags = flags;\n\trtp_session->vad_data.cng_freq = 50;\n\trtp_session->vad_data.ts = 1;\n\trtp_session->vad_data.start = 0;\n\trtp_session->vad_data.next_scan = switch_epoch_time_now(NULL);\n\trtp_session->vad_data.scan_freq = 0;\n\tif (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {\n\t\trtp_session->vad_data.start_talking = switch_micro_time_now();\n\t}\n\tswitch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_VAD);\n\tswitch_set_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_CNG);\n\treturn SWITCH_STATUS_SUCCESS;\n}\n\nSWITCH_DECLARE(int) switch_rtp_write_frame(switch_rtp_t *rtp_session, switch_frame_t *frame)\n{\n\tuint8_t fwd = 0;\n\tvoid *data = NULL;\n\tuint32_t len, ts = 0;\n\tswitch_payload_t payload = 0;\n\trtp_msg_t *send_msg = NULL;\n\tsrtp_hdr_t local_header;\n\tint r = 0;\n\tswitch_status_t status;\n\n\tif (!switch_rtp_ready(rtp_session) || !rtp_session->remote_addr) {\n\t\treturn -1;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, frame->datalen, __LINE__)) {\n\t\treturn 0;\n\t}\n\n\t//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t//\trtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]++;\n\t//\trtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]++;\n\t//}\n\n\n\tif (switch_test_flag(frame, SFF_PROXY_PACKET) || switch_test_flag(frame, SFF_UDPTL_PACKET) ||\n\t\trtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\n\t\t//if (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {\n\t\tswitch_size_t bytes;\n\t\t//char bufa[50];\n\n\t\t/* Fast PASS! */\n\t\tif (!switch_test_flag(frame, SFF_PROXY_PACKET) && !switch_test_flag(frame, SFF_UDPTL_PACKET)) {\n\t\t\treturn 0;\n\t\t}\n\t\tbytes = frame->packetlen;\n\t\t//tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->remote_addr);\n\n\t\tsend_msg = frame->packet;\n\n\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !switch_test_flag(frame, SFF_UDPTL_PACKET)) {\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->payload > 0) {\n\t\t\t\tsend_msg->header.pt = rtp_session->payload;\n\t\t\t}\n\n\t\t\tsend_msg->header.ssrc = htonl(rtp_session->ssrc);\n\t\t\tsend_msg->header.seq = htons(++rtp_session->seq);\n\t\t}\n\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\tconst char *tx_host;\n\t\t\tconst char *old_host;\n\t\t\tconst char *my_host;\n\n\t\t\tchar bufa[50], bufb[50], bufc[50];\n\n\n\t\t\ttx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);\n\t\t\told_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);\n\t\t\tmy_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);\n\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,\n\t\t\t\t\t\t\t  \"W %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\\n\",\n\t\t\t\t\t\t\t  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : \"NoName\",\n\t\t\t\t\t\t\t  (long) bytes,\n\t\t\t\t\t\t\t  my_host, switch_sockaddr_get_port(rtp_session->local_addr),\n\t\t\t\t\t\t\t  old_host, rtp_session->remote_port,\n\t\t\t\t\t\t\t  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),\n\t\t\t\t\t\t\t  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);\n\n\t\t}\n\n\t\tif ((status = switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, frame->packet, &bytes)) != SWITCH_STATUS_SUCCESS) {\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_ERROR, \"bytes: %\" SWITCH_SIZE_T_FMT \", status: %d\", bytes, status);\n\t\t\t}\n\n\t\t\treturn -1 * status;\n\t\t}\n\n\n\t\trtp_session->stats.outbound.raw_bytes += bytes;\n\t\trtp_session->stats.outbound.media_bytes += bytes;\n\t\trtp_session->stats.outbound.media_packet_count++;\n\t\trtp_session->stats.outbound.packet_count++;\n\t\treturn (int) bytes;\n\t}\n\n\tfwd = (rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] &&\n\t\t   (switch_test_flag(frame, SFF_RAW_RTP) || switch_test_flag(frame, SFF_RAW_RTP_PARSE_FRAME))) ? 1 : 0;\n\n\tif (!fwd && !rtp_session->sending_dtmf && !rtp_session->queue_delay && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] && (rtp_session->rtp_bugs & RTP_BUG_GEN_ONE_GEN_ALL)) {\n\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, \"Generating RTP locally but timestamp passthru is configured, disabling....\\n\");\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] = 0;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;\n\t}\n\n\tswitch_assert(frame != NULL);\n\n\tif (switch_test_flag(frame, SFF_CNG)) {\n\t\tif (rtp_session->cng_pt != INVALID_PT) {\n\t\t\tpayload = rtp_session->cng_pt;\n\t\t} else {\n\t\t\treturn (int) frame->packetlen;\n\t\t}\n\t} else {\n\t\tpayload = rtp_session->payload;\n#if 0\n\t\tif (rtp_session->pmaps && *rtp_session->pmaps) {\n\t\t\tpayload_map_t *pmap;\n\t\t\tfor (pmap = *rtp_session->pmaps; pmap; pmap = pmap->next) {\n\t\t\t\tif (pmap->current) {\n\t\t\t\t\tpayload = pmap->pt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\n\tif (switch_test_flag(frame, SFF_RTP_HEADER) || rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {\n\t\tswitch_size_t wrote;\n\n\t\twrote = switch_rtp_write_manual(rtp_session, frame->data, frame->datalen,\n\t\t\t\t\t\t\t\t\t\tframe->m, frame->payload, (uint32_t) (frame->timestamp), &frame->flags);\n\n\t\trtp_session->stats.outbound.raw_bytes += wrote;\n\t\trtp_session->stats.outbound.media_bytes += wrote;\n\t\trtp_session->stats.outbound.media_packet_count++;\n\t\trtp_session->stats.outbound.packet_count++;\n\n\t\treturn wrote;\n\t}\n\n\tif (frame->pmap && rtp_session->pmaps && *rtp_session->pmaps) {\n\t\tpayload_map_t *pmap;\n\n\t\tswitch_mutex_lock(rtp_session->flag_mutex);\n\t\tfor (pmap = *rtp_session->pmaps; pmap; pmap = pmap->next) {\n\t\t\tif (pmap->negotiated && pmap->hash == frame->pmap->hash) {\n\t\t\t\tpayload = pmap->recv_pt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\t}\n\n\tif (fwd) {\n\t\tsend_msg = frame->packet;\n\t\tlocal_header = send_msg->header;\n\t\tlen = frame->packetlen;\n\t\tts = 0;\n\n\t\tsend_msg->header.pt = payload;\n\n\t\tif (switch_test_flag(frame, SFF_RAW_RTP_PARSE_FRAME)) {\n\t\t\tsend_msg->header.version = 2;\n\t\t\tsend_msg->header.m = frame->m;\n\n\t\t\tsend_msg->header.ts = htonl(frame->timestamp);\n\t\t\tif (frame->ssrc) {\n\t\t\t\tsend_msg->header.ssrc = htonl(frame->ssrc);\n\t\t\t} else {\n\t\t\t\tsend_msg->header.ssrc = htonl(rtp_session->ssrc);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tdata = frame->data;\n\t\tlen = frame->datalen;\n\t\tts = rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] ? (uint32_t) frame->timestamp : 0;\n\t}\n\n\t/*\n\t  if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {\n\t  send_msg->header.pt = rtp_session->payload;\n\t  }\n\t*/\n\n\tr = rtp_common_write(rtp_session, send_msg, data, len, payload, ts, &frame->flags);\n\n\tif (send_msg) {\n\t\tsend_msg->header = local_header;\n\t}\n\n\treturn r;\n\n}\n\nSWITCH_DECLARE(switch_rtp_stats_t *) switch_rtp_get_stats(switch_rtp_t *rtp_session, switch_memory_pool_t *pool)\n{\n\tswitch_rtp_stats_t *s;\n\n\tif (!rtp_session) {\n\t\treturn NULL;\n\t}\n\n\tswitch_mutex_lock(rtp_session->flag_mutex);\n\tif (pool) {\n\t\ts = switch_core_alloc(pool, sizeof(*s));\n\t\t*s = rtp_session->stats;\n\t} else {\n\t\ts = &rtp_session->stats;\n\t}\n\n\tif (rtp_session->jb) {\n\t\tswitch_jb_get_frames(rtp_session->jb, NULL, NULL, NULL, (uint32_t *)&s->inbound.largest_jb_size);\n\t}\n\n\tdo_mos(rtp_session);\n\n\tswitch_mutex_unlock(rtp_session->flag_mutex);\n\n\treturn s;\n}\n\nSWITCH_DECLARE(int) switch_rtp_write_manual(switch_rtp_t *rtp_session,\n\t\t\t\t\t\t\t\t\t\t\tvoid *data, uint32_t datalen, uint8_t m, switch_payload_t payload, uint32_t ts, switch_frame_flag_t *flags)\n{\n\tswitch_size_t bytes;\n\tint ret = -1;\n\n\tif (!switch_rtp_ready(rtp_session) || !rtp_session->remote_addr || datalen > SWITCH_RTP_MAX_BUF_LEN) {\n\t\treturn -1;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, datalen, __LINE__)) {\n\t\treturn 0;\n\t}\n\n\tif (payload == INVALID_PT) {\n\t\treturn 0;\n\t}\n\n\tWRITE_INC(rtp_session);\n\n\trtp_session->write_msg = rtp_session->send_msg;\n\trtp_session->write_msg.header.seq = htons(++rtp_session->seq);\n\trtp_session->write_msg.header.ts = htonl(ts);\n\trtp_session->write_msg.header.pt = payload;\n\trtp_session->write_msg.header.m = m;\n\tmemcpy(rtp_session->write_msg.body, data, datalen);\n\n\tbytes = rtp_header_len + datalen;\n\n\tif (switch_rtp_write_raw(rtp_session, (void *) &rtp_session->write_msg, &bytes, SWITCH_TRUE) != SWITCH_STATUS_SUCCESS) {\n\t\trtp_session->seq--;\n\t\tret = -1;\n\t\tgoto end;\n\t}\n\n\tif (((*flags) & SFF_RTP_HEADER)) {\n\t\trtp_session->last_write_ts = ts;\n\t\trtp_session->flags[SWITCH_RTP_FLAG_RESET] = 0;\n\t}\n\n\tret = (int) bytes;\n\n end:\n\n\tWRITE_DEC(rtp_session);\n\n\treturn ret;\n}\n\n\n\nSWITCH_DECLARE(switch_status_t) switch_rtp_write_raw(switch_rtp_t *rtp_session, void *data, switch_size_t *bytes, switch_bool_t process_encryption)\n{\n\tswitch_status_t status = SWITCH_STATUS_FALSE;\n\n\tswitch_assert(bytes);\n\n\tif (!switch_rtp_ready(rtp_session) || !rtp_session->remote_addr || *bytes > SWITCH_RTP_MAX_BUF_LEN) {\n\t\treturn status;\n\t}\n\n\tif (!rtp_write_ready(rtp_session, *bytes, __LINE__)) {\n\t\treturn SWITCH_STATUS_NOT_INITALIZED;\n\t}\n\n\tWRITE_INC(rtp_session);\n\n\tif (process_encryption) {\n#ifdef ENABLE_SRTP\n\t\tswitch_mutex_lock(rtp_session->ice_mutex);\n\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {\n\n\t\t\tint sbytes = (int) *bytes;\n\t\t\tsrtp_err_status_t stat;\n\n\t\t\tif (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET]) {\n\t\t\t\tswitch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND_RESET);\n\t\t\t\tsrtp_dealloc(rtp_session->send_ctx[rtp_session->srtp_idx_rtp]);\n\t\t\t\trtp_session->send_ctx[rtp_session->srtp_idx_rtp] = NULL;\n\t\t\t\tif (srtp_create(&rtp_session->send_ctx[rtp_session->srtp_idx_rtp],\n\t\t\t\t\t\t\t\t\t\t&rtp_session->send_policy[rtp_session->srtp_idx_rtp]) || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error! RE-Activating Secure RTP SEND\\n\");\n\t\t\t\t\trtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;\n\t\t\t\t\tstatus = SWITCH_STATUS_FALSE;\n\t\t\t\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n\t\t\t\t\tgoto end;\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, \"RE-Activating Secure RTP SEND\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {\n\t\t\t\tstat = srtp_protect(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &rtp_session->write_msg.header, &sbytes);\n\t\t\t} else {\n\t\t\t\tstat = srtp_protect_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &rtp_session->write_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);\n\t\t\t}\n\n\t\t\tif (stat) {\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, \"Error: SRTP protection failed with code %d\\n\", stat);\n\t\t\t}\n\t\t\t*bytes = sbytes;\n\t\t}\n\t\tswitch_mutex_unlock(rtp_session->ice_mutex);\n#endif\n\t}\n\n\tstatus = switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, data, bytes);\n#if defined(ENABLE_SRTP)\n end:\n#endif\n\n\tWRITE_DEC(rtp_session);\n\n\treturn status;\n}\n\nSWITCH_DECLARE(uint32_t) switch_rtp_get_ssrc(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->ssrc;\n}\n\nSWITCH_DECLARE(void) switch_rtp_set_private(switch_rtp_t *rtp_session, void *private_data)\n{\n\trtp_session->private_data = private_data;\n}\n\nSWITCH_DECLARE(void *) switch_rtp_get_private(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->private_data;\n}\n\nSWITCH_DECLARE(switch_core_session_t*) switch_rtp_get_core_session(switch_rtp_t *rtp_session)\n{\n\treturn rtp_session->session;\n}\n\n/* For Emacs:\n * Local Variables:\n * mode:c\n * indent-tabs-mode:t\n * tab-width:4\n * c-basic-offset:4\n * End:\n * For VIM:\n * vim:set softtabstop=4 shiftwidth=4 tabstop=4 noet:\n */\n"], "filenames": ["src/switch_rtp.c"], "buggy_code_start_loc": [3377], "buggy_code_end_loc": [3378], "fixing_code_start_loc": [3377], "fixing_code_end_loc": [3391], "type": "CWE-703", "message": "FreeSWITCH is a Software Defined Telecom Stack enabling the digital transformation from proprietary telecom switches to a software implementation that runs on any commodity hardware. Prior to version 1.10.11, when handling DTLS-SRTP for media setup, FreeSWITCH is susceptible to Denial of Service due to a race condition in the hello handshake phase of the DTLS protocol. This attack can be done continuously, thus denying new DTLS-SRTP encrypted calls during the attack. If an attacker manages to send a ClientHello DTLS message with an invalid CipherSuite (such as `TLS_NULL_WITH_NULL_NULL`) to the port on the FreeSWITCH server that is expecting packets from the caller, a DTLS error is generated. This results in the media session being torn down, which is followed by teardown at signaling (SIP) level too. Abuse of this vulnerability may lead to a massive Denial of Service on vulnerable FreeSWITCH servers for calls that rely on DTLS-SRTP. To address this vulnerability, upgrade FreeSWITCH to 1.10.11 which includes the security fix. The solution implemented is to drop all packets from addresses that have not been validated by an ICE check.", "other": {"cve": {"id": "CVE-2023-51443", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-27T17:15:08.093", "lastModified": "2024-02-02T02:23:51.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeSWITCH is a Software Defined Telecom Stack enabling the digital transformation from proprietary telecom switches to a software implementation that runs on any commodity hardware. Prior to version 1.10.11, when handling DTLS-SRTP for media setup, FreeSWITCH is susceptible to Denial of Service due to a race condition in the hello handshake phase of the DTLS protocol. This attack can be done continuously, thus denying new DTLS-SRTP encrypted calls during the attack. If an attacker manages to send a ClientHello DTLS message with an invalid CipherSuite (such as `TLS_NULL_WITH_NULL_NULL`) to the port on the FreeSWITCH server that is expecting packets from the caller, a DTLS error is generated. This results in the media session being torn down, which is followed by teardown at signaling (SIP) level too. Abuse of this vulnerability may lead to a massive Denial of Service on vulnerable FreeSWITCH servers for calls that rely on DTLS-SRTP. To address this vulnerability, upgrade FreeSWITCH to 1.10.11 which includes the security fix. The solution implemented is to drop all packets from addresses that have not been validated by an ICE check."}, {"lang": "es", "value": "FreeSWITCH es un Software Defined Telecom Stack que permite la transformaci\u00f3n digital de conmutadores de telecomunicaciones propietarios a una implementaci\u00f3n de software que se ejecuta en cualquier hardware b\u00e1sico. Antes de la versi\u00f3n 1.10.11, cuando se maneja DTLS-SRTP para la configuraci\u00f3n de medios, FreeSWITCH es susceptible a una denegaci\u00f3n de servicio debido a una condici\u00f3n de ejecuci\u00f3n en la fase de handshake del protocolo DTLS. Este ataque se puede realizar de forma continua, negando as\u00ed nuevas llamadas cifradas DTLS-SRTP durante el ataque. Si un atacante logra enviar un mensaje DTLS ClientHello con un CipherSuite no v\u00e1lido (como `TLS_NULL_WITH_NULL_NULL`) al puerto en el servidor FreeSWITCH que espera paquetes de la persona que llama, se genera un error DTLS. Esto da como resultado la cancelaci\u00f3n de la sesi\u00f3n de medios, a la que sigue tambi\u00e9n la cancelaci\u00f3n a nivel de se\u00f1alizaci\u00f3n (SIP). El abuso de esta vulnerabilidad puede provocar una denegaci\u00f3n de servicio masiva en servidores FreeSWITCH vulnerables para llamadas que dependen de DTLS-SRTP. Para abordar esta vulnerabilidad, actualice FreeSWITCH a 1.10.11, que incluye la soluci\u00f3n de seguridad. La soluci\u00f3n implementada es descartar todos los paquetes de direcciones que no hayan sido validadas por una verificaci\u00f3n ICE."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-703"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeswitch:freeswitch:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.11", "matchCriteriaId": "D602178F-BD2F-4B3D-97D9-7555182A7015"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/176393/FreeSWITCH-Denial-Of-Service.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/signalwire/freeswitch/commit/86cbda90b84ba186e508fbc7bfae469270a97d11", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/signalwire/freeswitch/security/advisories/GHSA-39gv-hq72-j6m6", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/signalwire/freeswitch/commit/86cbda90b84ba186e508fbc7bfae469270a97d11"}}