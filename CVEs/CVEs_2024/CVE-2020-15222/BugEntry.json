{"buggy_code": ["/*\n * Copyright \u00a9 2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @Copyright \t2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"context\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/pkg/errors\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n)\n\nconst clientAssertionJWTBearerType = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n\nfunc (f *Fosite) findClientPublicJWK(oidcClient OpenIDConnectClient, t *jwt.Token) (interface{}, error) {\n\tif set := oidcClient.GetJSONWebKeys(); set != nil {\n\t\treturn findPublicKey(t, set)\n\t}\n\n\tif location := oidcClient.GetJSONWebKeysURI(); len(location) > 0 {\n\t\tkeys, err := f.JWKSFetcherStrategy.Resolve(location, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif key, err := findPublicKey(t, keys); err == nil {\n\t\t\treturn key, nil\n\t\t}\n\n\t\tkeys, err = f.JWKSFetcherStrategy.Resolve(location, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn findPublicKey(t, keys)\n\t}\n\n\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"The OAuth 2.0 Client has no JSON Web Keys set registered, but they are needed to complete the request.\"))\n}\n\nfunc (f *Fosite) AuthenticateClient(ctx context.Context, r *http.Request, form url.Values) (Client, error) {\n\tif assertionType := form.Get(\"client_assertion_type\"); assertionType == clientAssertionJWTBearerType {\n\t\tassertion := form.Get(\"client_assertion\")\n\t\tif len(assertion) == 0 {\n\t\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"The client_assertion request parameter must be set when using client_assertion_type of \\\"%s\\\".\", clientAssertionJWTBearerType))\n\t\t}\n\n\t\tvar clientID string\n\t\tvar client Client\n\n\t\ttoken, err := jwt.ParseWithClaims(assertion, new(jwt.MapClaims), func(t *jwt.Token) (interface{}, error) {\n\t\t\tvar err error\n\t\t\tclientID, _, err = clientCredentialsFromRequestBody(form, false)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif clientID == \"\" {\n\t\t\t\tif claims, ok := t.Claims.(*jwt.MapClaims); !ok {\n\t\t\t\t\treturn nil, errors.WithStack(ErrRequestUnauthorized.WithHint(\"Unable to type assert claims from client_assertion.\").WithDebugf(`Expected claims to be of type \"*jwt.MapClaims\" but got \"%T\".`, t.Claims))\n\t\t\t\t} else if sub, ok := (*claims)[\"sub\"].(string); !ok {\n\t\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(`The claim \"sub\" from the client_assertion JSON Web Token is undefined.`))\n\t\t\t\t} else {\n\t\t\t\t\tclientID = sub\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient, err = f.Store.GetClient(ctx, clientID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithDebug(err.Error()))\n\t\t\t}\n\n\t\t\toidcClient, ok := client.(OpenIDConnectClient)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHint(\"The server configuration does not support OpenID Connect specific authentication methods.\"))\n\t\t\t}\n\n\t\t\tswitch oidcClient.GetTokenEndpointAuthMethod() {\n\t\t\tcase \"client_secret_post\":\n\t\t\t\tfallthrough\n\t\t\tcase \"client_secret_basic\":\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Request uses the \\\"client_secret_jwt\\\" authentication method, but the OAuth 2.0 Client only supports the \\\"%s\\\" client authentication method. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"client_secret_jwt\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t\t\tcase \"client_secret_jwt\":\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"This requested OAuth 2.0 client only supports client authentication method \\\"client_secret_jwt\\\", however that method is not supported by this server.\"))\n\t\t\tcase \"private_key_jwt\":\n\t\t\t}\n\n\t\t\tif oidcClient.GetTokenEndpointAuthSigningAlgorithm() != fmt.Sprintf(\"%s\", t.Header[\"alg\"]) {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(`The \"client_assertion\"\" uses signing algorithm \"%s\", but the requested OAuth 2.0 Client enforces signing algorithm \"%s\".`, t.Header[\"alg\"], oidcClient.GetTokenEndpointAuthSigningAlgorithm()))\n\t\t\t}\n\n\t\t\tif _, ok := t.Method.(*jwt.SigningMethodRSA); ok {\n\t\t\t\treturn f.findClientPublicJWK(oidcClient, t)\n\t\t\t} else if _, ok := t.Method.(*jwt.SigningMethodECDSA); ok {\n\t\t\t\treturn f.findClientPublicJWK(oidcClient, t)\n\t\t\t} else if _, ok := t.Method.(*jwt.SigningMethodRSAPSS); ok {\n\t\t\t\treturn f.findClientPublicJWK(oidcClient, t)\n\t\t\t} else if _, ok := t.Method.(*jwt.SigningMethodHMAC); ok {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"This authorization server does not support client authentication method \\\"client_secret_jwt\\\".\"))\n\t\t\t}\n\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The client_assertion request parameter uses unsupported signing algorithm \\\"%s\\\".\", t.Header[\"alg\"]))\n\t\t})\n\t\tif err != nil {\n\t\t\t// Do not re-process already enhanced errors\n\t\t\tif e, ok := errors.Cause(err).(*jwt.ValidationError); ok {\n\t\t\t\tif e.Inner != nil {\n\t\t\t\t\treturn nil, e.Inner\n\t\t\t\t}\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Unable to verify the integrity of the \\\"client_assertion\\\" value.\").WithDebug(err.Error()))\n\t\t\t}\n\t\t\treturn nil, err\n\t\t} else if err := token.Claims.Valid(); err != nil {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Unable to verify the request object because its claims could not be validated, check if the expiry time is set correctly.\").WithDebug(err.Error()))\n\t\t}\n\n\t\tclaims, ok := token.Claims.(*jwt.MapClaims)\n\t\tif !ok {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Unable to type assert claims from request parameter \\\"client_assertion\\\".\").WithDebugf(`Got claims of type %T but expected type \"*jwt.MapClaims\".`, token.Claims))\n\t\t}\n\n\t\tif !claims.VerifyIssuer(clientID, true) {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Claim \\\"iss\\\" from \\\"client_assertion\\\" must match the \\\"client_id\\\" of the OAuth 2.0 Client.\"))\n\t\t} else if f.TokenURL == \"\" {\n\t\t\treturn nil, errors.WithStack(ErrMisconfiguration.WithHint(\"The authorization server's token endpoint URL has not been set.\"))\n\t\t} else if sub, ok := (*claims)[\"sub\"].(string); !ok || sub != clientID {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Claim \\\"sub\\\" from \\\"client_assertion\\\" must match the \\\"client_id\\\" of the OAuth 2.0 Client.\"))\n\t\t} else if jti, ok := (*claims)[\"jti\"].(string); !ok || len(jti) == 0 {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Claim \\\"jti\\\" from \\\"client_assertion\\\" must be set but is not.\"))\n\t\t}\n\n\t\tif auds, ok := (*claims)[\"aud\"].([]interface{}); !ok {\n\t\t\tif !claims.VerifyAudience(f.TokenURL, true) {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"Claim \\\"audience\\\" from \\\"client_assertion\\\" must match the authorization server's token endpoint \\\"%s\\\".\", f.TokenURL))\n\t\t\t}\n\t\t} else {\n\t\t\tvar found bool\n\t\t\tfor _, aud := range auds {\n\t\t\t\tif a, ok := aud.(string); ok && a == f.TokenURL {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !found {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"Claim \\\"audience\\\" from \\\"client_assertion\\\" must match the authorization server's token endpoint \\\"%s\\\".\", f.TokenURL))\n\t\t\t}\n\t\t}\n\n\t\treturn client, nil\n\t} else if len(assertionType) > 0 {\n\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"Unknown client_assertion_type \\\"%s\\\".\", assertionType))\n\t}\n\n\tclientID, clientSecret, err := clientCredentialsFromRequest(r, form)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient, err := f.Store.GetClient(ctx, clientID)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithDebug(err.Error()))\n\t}\n\n\tif oidcClient, ok := client.(OpenIDConnectClient); !ok {\n\t\t// If this isn't an OpenID Connect client then we actually don't care about any of this, just continue!\n\t} else if ok && form.Get(\"client_id\") != \"\" && form.Get(\"client_secret\") != \"\" && oidcClient.GetTokenEndpointAuthMethod() != \"client_secret_post\" {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Client supports client authentication method \\\"%s\\\", but method \\\"client_secret_post\\\" was requested. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"client_secret_post\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t} else if _, _, basicOk := r.BasicAuth(); basicOk && ok && oidcClient.GetTokenEndpointAuthMethod() != \"client_secret_basic\" {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Client supports client authentication method \\\"%s\\\", but method \\\"client_secret_basic\\\" was requested. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"client_secret_basic\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t} else if ok && oidcClient.GetTokenEndpointAuthMethod() != \"none\" && client.IsPublic() {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Client supports client authentication method \\\"%s\\\", but method \\\"none\\\" was requested. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"none\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t}\n\n\tif client.IsPublic() {\n\t\treturn client, nil\n\t}\n\n\t// Enforce client authentication\n\tif err := f.Hasher.Compare(ctx, client.GetHashedSecret(), []byte(clientSecret)); err != nil {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithDebug(err.Error()))\n\t}\n\n\treturn client, nil\n}\n\nfunc findPublicKey(t *jwt.Token, set *jose.JSONWebKeySet) (*rsa.PublicKey, error) {\n\tkid, ok := t.Header[\"kid\"].(string)\n\tif !ok {\n\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHint(\"The JSON Web Token must contain a kid header value but did not.\"))\n\t}\n\n\tkeys := set.Key(kid)\n\tif len(keys) == 0 {\n\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"The JSON Web Token uses signing key with kid \\\"%s\\\", which could not be found.\", kid))\n\t}\n\n\tfor _, key := range keys {\n\t\tif key.Use != \"sig\" {\n\t\t\tcontinue\n\t\t}\n\t\tif k, ok := key.Key.(*rsa.PublicKey); ok {\n\t\t\treturn k, nil\n\t\t}\n\t}\n\n\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"Unable to find RSA public key with use=\\\"sig\\\" for kid \\\"%s\\\" in JSON Web Key Set.\", kid))\n}\n\nfunc clientCredentialsFromRequest(r *http.Request, form url.Values) (clientID, clientSecret string, err error) {\n\tif id, secret, ok := r.BasicAuth(); !ok {\n\t\treturn clientCredentialsFromRequestBody(form, true)\n\t} else if clientID, err = url.QueryUnescape(id); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client id in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t} else if clientSecret, err = url.QueryUnescape(secret); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client secret in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t}\n\n\treturn clientID, clientSecret, nil\n}\n\nfunc clientCredentialsFromRequestBody(form url.Values, forceID bool) (clientID, clientSecret string, err error) {\n\tclientID = form.Get(\"client_id\")\n\tclientSecret = form.Get(\"client_secret\")\n\n\tif clientID == \"\" && forceID {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(\"Client credentials missing or malformed in both HTTP Authorization header and HTTP POST body.\"))\n\t}\n\n\tif clientID, err = url.QueryUnescape(clientID); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client id in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t} else if clientSecret, err = url.QueryUnescape(clientSecret); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client secret in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t}\n\n\treturn clientID, clientSecret, nil\n}\n", "/*\n * Copyright \u00a9 2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @Copyright \t2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite_test\n\nimport (\n\t\"context\"\n\t\"crypto/rsa\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t. \"github.com/ory/fosite\"\n\t\"github.com/ory/fosite/internal\"\n\t\"github.com/ory/fosite/storage\"\n)\n\nfunc mustGenerateAssertion(t *testing.T, claims jwt.MapClaims, key *rsa.PrivateKey, kid string) string {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)\n\ttoken.Header[\"kid\"] = kid\n\ttokenString, err := token.SignedString(key)\n\trequire.NoError(t, err)\n\treturn tokenString\n}\n\nfunc mustGenerateHSAssertion(t *testing.T, claims jwt.MapClaims, key *rsa.PrivateKey, kid string) string {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString([]byte(\"aaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccddddddddddddddddddddddd\"))\n\trequire.NoError(t, err)\n\treturn tokenString\n}\n\nfunc mustGenerateNoneAssertion(t *testing.T, claims jwt.MapClaims, key *rsa.PrivateKey, kid string) string {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodNone, claims)\n\ttokenString, err := token.SignedString(jwt.UnsafeAllowNoneSignatureType)\n\trequire.NoError(t, err)\n\treturn tokenString\n}\n\nfunc TestAuthenticateClient(t *testing.T) {\n\tconst at = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n\n\thasher := &BCrypt{WorkFactor: 6}\n\tf := &Fosite{\n\t\tJWKSFetcherStrategy: NewDefaultJWKSFetcherStrategy(),\n\t\tStore:               storage.NewMemoryStore(),\n\t\tHasher:              hasher,\n\t\tTokenURL:            \"token-url\",\n\t}\n\n\tbarSecret, err := hasher.Hash(context.TODO(), []byte(\"bar\"))\n\trequire.NoError(t, err)\n\n\tkey := internal.MustRSAKey()\n\tjwks := &jose.JSONWebKeySet{\n\t\tKeys: []jose.JSONWebKey{\n\t\t\t{\n\t\t\t\tKeyID: \"kid-foo\",\n\t\t\t\tUse:   \"sig\",\n\t\t\t\tKey:   &key.PublicKey,\n\t\t\t},\n\t\t},\n\t}\n\n\tvar h http.HandlerFunc\n\th = func(w http.ResponseWriter, r *http.Request) {\n\t\trequire.NoError(t, json.NewEncoder(w).Encode(jwks))\n\t}\n\tts := httptest.NewServer(h)\n\tdefer ts.Close()\n\n\tfor k, tc := range []struct {\n\t\td             string\n\t\tclient        *DefaultOpenIDConnectClient\n\t\tassertionType string\n\t\tassertion     string\n\t\tr             *http.Request\n\t\tform          url.Values\n\t\texpectErr     error\n\t}{\n\t\t{\n\t\t\td:         \"should fail because authentication can not be determined\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\"}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client does not exist\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Public: true}, TokenEndpointAuthMethod: \"none\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"bar\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass because client is public and authentication requirements are met\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Public: true}, TokenEndpointAuthMethod: \"none\"},\n\t\t\tform:   url.Values{\"client_id\": []string{\"foo\"}},\n\t\t\tr:      new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because auth method is not none\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Public: true}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass because client is confidential and id and secret match in post body\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:   url.Values{\"client_id\": []string{\"foo\"}, \"client_secret\": []string{\"bar\"}},\n\t\t\tr:      new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and secret does not match in post body\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_secret\": []string{\"baz\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and id does not exist in post body\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_secret\": []string{\"bar\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass because client is confidential and id and secret match in header\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:   url.Values{},\n\t\t\tr:      &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:bar\"))}}},\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because auth method is not client_secret_basic\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:bar\"))}}},\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and secret does not match in header\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:baz\"))}}},\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client id is not encoded using application/x-www-form-urlencoded\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"%%%%%%:foo\"))}}},\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client secret is not encoded using application/x-www-form-urlencoded\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:%%%%%%%\"))}}},\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and id does not exist in header\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:bar\"))}}},\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client_assertion but client_assertion is missing\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client_assertion_type is unknown\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_assertion_type\": []string{\"foobar\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs are set within the client and client_id is not set in the request\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because token auth method is not private_key_jwt\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"client_secret_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs are set within the client and client_id is not set in the request (aud is array)\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": []string{\"token-url-2\", \"token-url\"},\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because audience (array) does not match token url\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": []string{\"token-url-1\", \"token-url-2\"},\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs are set within the client\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because JWT algorithm is HS256\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateHSAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because JWT algorithm is none\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateNoneAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs URI is set\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeysURI: ts.URL, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion sub does not match client\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"not-bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion iss does not match client\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"not-bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion jti is not set\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion aud is not set\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"not-token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"case=%d/description=%s\", k, tc.d), func(t *testing.T) {\n\t\t\tstore := storage.NewMemoryStore()\n\t\t\tstore.Clients[tc.client.ID] = tc.client\n\t\t\tf.Store = store\n\n\t\t\tc, err := f.AuthenticateClient(nil, tc.r, tc.form)\n\t\t\tif tc.expectErr != nil {\n\t\t\t\trequire.EqualError(t, err, tc.expectErr.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tswitch e := errors.Cause(err).(type) {\n\t\t\t\tcase *jwt.ValidationError:\n\t\t\t\t\tt.Logf(\"Error is: %s\", e.Inner)\n\t\t\t\tcase *RFC6749Error:\n\t\t\t\t\tt.Logf(\"Debug is: %s\", e.Debug)\n\t\t\t\t}\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.EqualValues(t, tc.client, c)\n\t\t})\n\t}\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport \"context\"\n\n// ClientManager defines the (persistent) manager interface for clients.\ntype ClientManager interface {\n\t// GetClient loads the client by its ID or returns an error\n\t// if the client does not exist or another error occurred.\n\tGetClient(ctx context.Context, id string) (Client, error)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\nvar (\n\t// ErrInvalidatedAuthorizeCode is an error indicating that an authorization code has been\n\t// used previously.\n\tErrInvalidatedAuthorizeCode = errors.New(\"Authorization code has ben invalidated\")\n\t// ErrSerializationFailure is an error indicating that the transactional capable storage could not guarantee\n\t// consistency of Update & Delete operations on the same rows between multiple sessions.\n\tErrSerializationFailure = errors.New(\"The request could not be completed due to concurrent access\")\n\tErrUnknownRequest       = &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The handler is not responsible for this request\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestForbidden = &RFC6749Error{\n\t\tName:        errRequestForbidden,\n\t\tDescription: \"The request is not allowed\",\n\t\tHint:        \"You are not allowed to perform this action.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrInvalidRequest = &RFC6749Error{\n\t\tName:        errInvalidRequestName,\n\t\tDescription: \"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed\",\n\t\tHint:        \"Make sure that the various parameters are correct, be aware of case sensitivity and trim your parameters. Make sure that the client you are using has exactly whitelisted the redirect_uri you specified.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrUnauthorizedClient = &RFC6749Error{\n\t\tName:        errUnauthorizedClientName,\n\t\tDescription: \"The client is not authorized to request a token using this method\",\n\t\tHint:        \"Make sure that client id and secret are correctly specified and that the client exists.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrAccessDenied = &RFC6749Error{\n\t\tName:        errAccessDeniedName,\n\t\tDescription: \"The resource owner or authorization server denied the request\",\n\t\tHint:        \"Make sure that the request you are making is valid. Maybe the credential or request parameters you are using are limited in scope or otherwise restricted.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrUnsupportedResponseType = &RFC6749Error{\n\t\tName:        errUnsupportedResponseTypeName,\n\t\tDescription: \"The authorization server does not support obtaining a token using this method\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidScope = &RFC6749Error{\n\t\tName:        errInvalidScopeName,\n\t\tDescription: \"The requested scope is invalid, unknown, or malformed\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrServerError = &RFC6749Error{\n\t\tName:        errServerErrorName,\n\t\tDescription: \"The authorization server encountered an unexpected condition that prevented it from fulfilling the request\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrTemporarilyUnavailable = &RFC6749Error{\n\t\tName:        errTemporarilyUnavailableName,\n\t\tDescription: \"The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server\",\n\t\tCode:        http.StatusServiceUnavailable,\n\t}\n\tErrUnsupportedGrantType = &RFC6749Error{\n\t\tName:        errUnsupportedGrantTypeName,\n\t\tDescription: \"The authorization grant type is not supported by the authorization server\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidGrant = &RFC6749Error{\n\t\tName:        errInvalidGrantName,\n\t\tDescription: \"The provided authorization grant (e.g., authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidClient = &RFC6749Error{\n\t\tName:        errInvalidClientName,\n\t\tDescription: \"Client authentication failed (e.g., unknown client, no client authentication included, or unsupported authentication method)\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInvalidState = &RFC6749Error{\n\t\tName:        errInvalidStateName,\n\t\tDescription: fmt.Sprintf(\"The state is missing or has less than %d characters and is therefore considered too weak\", MinParameterEntropy),\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrMisconfiguration = &RFC6749Error{\n\t\tName:        errMisconfigurationName,\n\t\tDescription: \"The request failed because of an internal error that is probably caused by misconfiguration\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrInsufficientEntropy = &RFC6749Error{\n\t\tName:        errInsufficientEntropyName,\n\t\tDescription: fmt.Sprintf(\"The request used a security parameter (e.g., anti-replay, anti-csrf) with insufficient entropy (minimum of %d characters)\", MinParameterEntropy),\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrNotFound = &RFC6749Error{\n\t\tName:        errNotFoundName,\n\t\tDescription: \"Could not find the requested resource(s)\",\n\t\tCode:        http.StatusNotFound,\n\t}\n\tErrRequestUnauthorized = &RFC6749Error{\n\t\tName:        errRequestUnauthorizedName,\n\t\tDescription: \"The request could not be authorized\",\n\t\tHint:        \"Check that you provided valid credentials in the right format.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrTokenSignatureMismatch = &RFC6749Error{\n\t\tName:        errTokenSignatureMismatchName,\n\t\tDescription: \"Token signature mismatch\",\n\t\tHint:        \"Check that you provided  a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidTokenFormat = &RFC6749Error{\n\t\tName:        errInvalidTokenFormatName,\n\t\tDescription: \"Invalid token format\",\n\t\tHint:        \"Check that you provided a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrTokenExpired = &RFC6749Error{\n\t\tName:        errTokenExpiredName,\n\t\tDescription: \"Token expired\",\n\t\tHint:        \"The token expired.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrScopeNotGranted = &RFC6749Error{\n\t\tName:        errScopeNotGrantedName,\n\t\tDescription: \"The token was not granted the requested scope\",\n\t\tHint:        \"The resource owner did not grant the requested scope.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrTokenClaim = &RFC6749Error{\n\t\tName:        errTokenClaimName,\n\t\tDescription: \"The token failed validation due to a claim mismatch\",\n\t\tHint:        \"One or more token claims failed validation.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInactiveToken = &RFC6749Error{\n\t\tName:        errTokenInactiveName,\n\t\tDescription: \"Token is inactive because it is malformed, expired or otherwise invalid\",\n\t\tHint:        \"Token validation failed.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrRevokationClientMismatch = &RFC6749Error{\n\t\tName:        errRevokationClientMismatchName,\n\t\tDescription: \"Token was not issued to the client making the revokation request\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrLoginRequired = &RFC6749Error{\n\t\tName:        errLoginRequired,\n\t\tDescription: \"The Authorization Server requires End-User authentication\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInteractionRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User interaction of some form to proceed\",\n\t\tName:        errInteractionRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrConsentRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User consent\",\n\t\tName:        errConsentRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request parameter\",\n\t\tName:        errRequestNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestURINotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request_uri parameter\",\n\t\tName:        errRequestURINotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRegistrationNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the registration parameter\",\n\t\tName:        errRegistrationNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestURI = &RFC6749Error{\n\t\tDescription: \"The request_uri in the Authorization Request returns an error or contains invalid data. \",\n\t\tName:        errInvalidRequestURI,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestObject = &RFC6749Error{\n\t\tDescription: \"The request parameter contains an invalid Request Object. \",\n\t\tName:        errInvalidRequestObject,\n\t\tCode:        http.StatusBadRequest,\n\t}\n)\n\nconst (\n\terrInvalidRequestURI            = \"invalid_request_uri\"\n\terrInvalidRequestObject         = \"invalid_request_object\"\n\terrConsentRequired              = \"consent_required\"\n\terrInteractionRequired          = \"interaction_required\"\n\terrLoginRequired                = \"login_required\"\n\terrRequestUnauthorizedName      = \"request_unauthorized\"\n\terrRequestForbidden             = \"request_forbidden\"\n\terrInvalidRequestName           = \"invalid_request\"\n\terrUnauthorizedClientName       = \"unauthorized_client\"\n\terrAccessDeniedName             = \"access_denied\"\n\terrUnsupportedResponseTypeName  = \"unsupported_response_type\"\n\terrInvalidScopeName             = \"invalid_scope\"\n\terrServerErrorName              = \"server_error\"\n\terrTemporarilyUnavailableName   = \"temporarily_unavailable\"\n\terrUnsupportedGrantTypeName     = \"unsupported_grant_type\"\n\terrInvalidGrantName             = \"invalid_grant\"\n\terrInvalidClientName            = \"invalid_client\"\n\terrNotFoundName                 = \"not_found\"\n\terrInvalidStateName             = \"invalid_state\"\n\terrMisconfigurationName         = \"misconfiguration\"\n\terrInsufficientEntropyName      = \"insufficient_entropy\"\n\terrInvalidTokenFormatName       = \"invalid_token\"\n\terrTokenSignatureMismatchName   = \"token_signature_mismatch\"\n\terrTokenExpiredName             = \"token_expired\"\n\terrScopeNotGrantedName          = \"scope_not_granted\"\n\terrTokenClaimName               = \"token_claim\"\n\terrTokenInactiveName            = \"token_inactive\"\n\terrAuthorizaionCodeInactiveName = \"authorization_code_inactive\"\n\terrUnknownErrorName             = \"error\"\n\terrRevokationClientMismatchName = \"revokation_client_mismatch\"\n\terrRequestNotSupportedName      = \"request_not_supported\"\n\terrRequestURINotSupportedName   = \"request_uri_not_supported\"\n\terrRegistrationNotSupportedName = \"registration_not_supported\"\n)\n\nfunc ErrorToRFC6749Error(err error) *RFC6749Error {\n\tif e, ok := err.(*RFC6749Error); ok {\n\t\treturn e\n\t} else if e, ok := errors.Cause(err).(*RFC6749Error); ok {\n\t\treturn e\n\t}\n\treturn &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The error is unrecognizable.\",\n\t\tDebug:       err.Error(),\n\t\tCode:        http.StatusInternalServerError,\n\t}\n}\n\ntype RFC6749Error struct {\n\tName        string `json:\"error\"`\n\tDescription string `json:\"error_description\"`\n\tHint        string `json:\"error_hint,omitempty\"`\n\tCode        int    `json:\"status_code,omitempty\"`\n\tDebug       string `json:\"error_debug,omitempty\"`\n}\n\nfunc (e *RFC6749Error) Status() string {\n\treturn http.StatusText(e.Code)\n}\n\nfunc (e *RFC6749Error) Error() string {\n\treturn e.Name\n}\n\nfunc (e *RFC6749Error) RequestID() string {\n\treturn \"\"\n}\n\nfunc (e *RFC6749Error) Reason() string {\n\treturn e.Hint\n}\n\nfunc (e *RFC6749Error) StatusCode() int {\n\treturn e.Code\n}\n\nfunc (e *RFC6749Error) WithHintf(hint string, args ...interface{}) *RFC6749Error {\n\treturn e.WithHint(fmt.Sprintf(hint, args...))\n}\n\nfunc (e *RFC6749Error) WithHint(hint string) *RFC6749Error {\n\terr := *e\n\terr.Hint = hint\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebug(debug string) *RFC6749Error {\n\terr := *e\n\terr.Debug = debug\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebugf(debug string, args ...interface{}) *RFC6749Error {\n\treturn e.WithDebug(fmt.Sprintf(debug, args...))\n}\n\nfunc (e *RFC6749Error) WithDescription(description string) *RFC6749Error {\n\terr := *e\n\terr.Description = description\n\treturn &err\n}\n", "module github.com/ory/fosite\n\nrequire (\n\tgithub.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dgrijalva/jwt-go v3.2.0+incompatible\n\tgithub.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 // indirect\n\tgithub.com/golang/mock v1.1.1\n\tgithub.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f // indirect\n\tgithub.com/gorilla/context v1.1.1 // indirect\n\tgithub.com/gorilla/mux v1.6.2\n\tgithub.com/jtolds/gls v4.2.1+incompatible // indirect\n\tgithub.com/magiconair/properties v1.8.0\n\tgithub.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826\n\tgithub.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b // indirect\n\tgithub.com/oleiade/reflections v1.0.0\n\tgithub.com/ory/go-convenience v0.1.0\n\tgithub.com/parnurzeal/gorequest v0.2.15\n\tgithub.com/pborman/uuid v1.2.0\n\tgithub.com/pkg/errors v0.8.0\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d // indirect\n\tgithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a // indirect\n\tgithub.com/stretchr/testify v1.2.2\n\tgolang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4\n\tgolang.org/x/net v0.0.0-20181005035420-146acd28ed58 // indirect\n\tgolang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced\n\tgolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f // indirect\n\tgoogle.golang.org/appengine v1.2.0 // indirect\n\tgopkg.in/square/go-jose.v2 v2.1.9\n)\n\ngo 1.13\n", "github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf h1:eg0MeVzsP1G42dRafH3vf+al2vQIJU0YHX+1Tw87oco=\ngithub.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 h1:LCoguo7Zd0MByKMbQbTvcZw7HiBcbvew+MOcwsJVwrY=\ngithub.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5/go.mod h1:/Zj4wYkgs4iZTTu3o/KG3Itv/qCCa8VVMlb3i9OVuzc=\ngithub.com/golang/mock v1.1.1 h1:G5FRp8JnTd7RQH5kemVNlMeyXQAztQ3mOWV95KxsXH8=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0 h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/google/uuid v1.0.0 h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=\ngithub.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f h1:JJ2EP5vV3LAD2U1CxQtD7PTOO15Y96kXmKDz7TjxGHs=\ngithub.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/mux v1.6.2 h1:Pgr17XVTNXAk3q/r4CpKzC5xBM/qW1uVLV+IhRZpIIk=\ngithub.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/jtolds/gls v4.2.1+incompatible h1:fSuqC+Gmlu6l/ZYAoZzx2pyucC8Xza35fpRVWLVmUEE=\ngithub.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/magiconair/properties v1.8.0 h1:LLgXmsheXeRoUOBOjtwPQCWIYqM/LU1ayDtDePerRcY=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826 h1:RWengNIwukTxcDr9M+97sNutRR1RKhG96O6jWumTTnw=\ngithub.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826/go.mod h1:TaXosZuwdSHYgviHp1DAtfrULt5eUgsSMsZf+YrPgl8=\ngithub.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b h1:Pip12xNtMvEFUBF4f8/b5yRXj94LLrNdLWELfOr2KcY=\ngithub.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=\ngithub.com/oleiade/reflections v1.0.0 h1:0ir4pc6v8/PJ0yw5AEtMddfXpWBXg9cnG7SgSoJuCgY=\ngithub.com/oleiade/reflections v1.0.0/go.mod h1:RbATFBbKYkVdqmSFtx13Bb/tVhR0lgOBXunWTZKeL4w=\ngithub.com/ory/go-convenience v0.1.0 h1:zouLKfF2GoSGnJwGq+PE/nJAE6dj2Zj5QlTgmMTsTS8=\ngithub.com/ory/go-convenience v0.1.0/go.mod h1:uEY/a60PL5c12nYz4V5cHY03IBmwIAEm8TWB0yn9KNs=\ngithub.com/parnurzeal/gorequest v0.2.15 h1:oPjDCsF5IkD4gUk6vIgsxYNaSgvAnIh1EJeROn3HdJU=\ngithub.com/parnurzeal/gorequest v0.2.15/go.mod h1:3Kh2QUMJoqw3icWAecsyzkpY7UzRfDhbRdTjtNwNiUE=\ngithub.com/pborman/uuid v1.2.0 h1:J7Q5mO4ysT1dv8hyrUGHb9+ooztCXu1D8MY8DZYsu3g=\ngithub.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=\ngithub.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a h1:JSvGDIbmil4Ui/dDdFBExb7/cmkNjyX5F97oglmvCDo=\ngithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngolang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4 h1:Vk3wNqEZwyGyei9yq5ekj7frek2u7HUfffJ1/opblzc=\ngolang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181005035420-146acd28ed58 h1:otZG8yDCO4LVps5+9bxOeNiCvgmOyt96J3roHTYs7oE=\ngolang.org/x/net v0.0.0-20181005035420-146acd28ed58/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced h1:4oqSq7eft7MdPKBGQK11X9WYUxmj6ZLgGTqYIbY1kyw=\ngolang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f h1:wMNYb4v58l5UBM7MYRLPG6ZhfOqbKu7X5eyFl8ZhKvA=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngoogle.golang.org/appengine v1.2.0 h1:S0iUepdCWODXRvtE+gcRDd15L+k+k1AiHlMiMjefH24=\ngoogle.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngopkg.in/square/go-jose.v2 v2.1.9 h1:YCFbL5T2gbmC2sMG12s1x2PAlTK5TZNte3hjZEIcCAg=\ngopkg.in/square/go-jose.v2 v2.1.9/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage oauth2\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/ory/fosite\"\n\t\"github.com/ory/fosite/storage\"\n\t\"github.com/pkg/errors\"\n)\n\ntype RefreshTokenGrantHandler struct {\n\tAccessTokenStrategy    AccessTokenStrategy\n\tRefreshTokenStrategy   RefreshTokenStrategy\n\tTokenRevocationStorage TokenRevocationStorage\n\n\t// AccessTokenLifespan defines the lifetime of an access token.\n\tAccessTokenLifespan time.Duration\n\n\t// RefreshTokenLifespan defines the lifetime of a refresh token.\n\tRefreshTokenLifespan time.Duration\n\n\tScopeStrategy            fosite.ScopeStrategy\n\tAudienceMatchingStrategy fosite.AudienceMatchingStrategy\n\tRefreshTokenScopes       []string\n}\n\n// HandleTokenEndpointRequest implements https://tools.ietf.org/html/rfc6749#section-6\nfunc (c *RefreshTokenGrantHandler) HandleTokenEndpointRequest(ctx context.Context, request fosite.AccessRequester) error {\n\t// grant_type REQUIRED.\n\t// Value MUST be set to \"refresh_token\".\n\tif !request.GetGrantTypes().ExactOne(\"refresh_token\") {\n\t\treturn errors.WithStack(fosite.ErrUnknownRequest)\n\t}\n\n\tif !request.GetClient().GetGrantTypes().Has(\"refresh_token\") {\n\t\treturn errors.WithStack(fosite.ErrInvalidGrant.WithHint(\"The OAuth 2.0 Client is not allowed to use authorization grant \\\"refresh_token\\\".\"))\n\t}\n\n\trefresh := request.GetRequestForm().Get(\"refresh_token\")\n\tsignature := c.RefreshTokenStrategy.RefreshTokenSignature(refresh)\n\toriginalRequest, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, request.GetSession())\n\tif errors.Cause(err) == fosite.ErrNotFound {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))\n\t} else if err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t} else if err := c.RefreshTokenStrategy.ValidateRefreshToken(ctx, originalRequest, refresh); err != nil {\n\t\t// The authorization server MUST ... validate the refresh token.\n\t\t// This needs to happen after store retrieval for the session to be hydrated properly\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))\n\t}\n\n\tif !(len(c.RefreshTokenScopes) == 0 || originalRequest.GetGrantedScopes().HasOneOf(c.RefreshTokenScopes...)) {\n\t\tscopeNames := strings.Join(c.RefreshTokenScopes, \" or \")\n\t\thint := fmt.Sprintf(\"The OAuth 2.0 Client was not granted scope %s and may thus not perform the \\\"refresh_token\\\" authorization grant.\", scopeNames)\n\t\treturn errors.WithStack(fosite.ErrScopeNotGranted.WithHint(hint))\n\n\t}\n\n\t// The authorization server MUST ... and ensure that the refresh token was issued to the authenticated client\n\tif originalRequest.GetClient().GetID() != request.GetClient().GetID() {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.WithHint(\"The OAuth 2.0 Client ID from this request does not match the ID during the initial token issuance.\"))\n\t}\n\n\trequest.SetSession(originalRequest.GetSession().Clone())\n\trequest.SetRequestedScopes(originalRequest.GetRequestedScopes())\n\trequest.SetRequestedAudience(originalRequest.GetRequestedAudience())\n\n\tfor _, scope := range originalRequest.GetGrantedScopes() {\n\t\tif !c.ScopeStrategy(request.GetClient().GetScopes(), scope) {\n\t\t\treturn errors.WithStack(fosite.ErrInvalidScope.WithHintf(\"The OAuth 2.0 Client is not allowed to request scope \\\"%s\\\".\", scope))\n\t\t}\n\t\trequest.GrantScope(scope)\n\t}\n\n\tif err := c.AudienceMatchingStrategy(request.GetClient().GetAudience(), originalRequest.GetGrantedAudience()); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, audience := range originalRequest.GetGrantedAudience() {\n\t\trequest.GrantAudience(audience)\n\t}\n\n\trequest.GetSession().SetExpiresAt(fosite.AccessToken, time.Now().UTC().Add(c.AccessTokenLifespan).Round(time.Second))\n\tif c.RefreshTokenLifespan > -1 {\n\t\trequest.GetSession().SetExpiresAt(fosite.RefreshToken, time.Now().UTC().Add(c.RefreshTokenLifespan).Round(time.Second))\n\t}\n\n\treturn nil\n}\n\n// PopulateTokenEndpointResponse implements https://tools.ietf.org/html/rfc6749#section-6\nfunc (c *RefreshTokenGrantHandler) PopulateTokenEndpointResponse(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) error {\n\tif !requester.GetGrantTypes().ExactOne(\"refresh_token\") {\n\t\treturn errors.WithStack(fosite.ErrUnknownRequest)\n\t}\n\n\taccessToken, accessSignature, err := c.AccessTokenStrategy.GenerateAccessToken(ctx, requester)\n\tif err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t}\n\n\trefreshToken, refreshSignature, err := c.RefreshTokenStrategy.GenerateRefreshToken(ctx, requester)\n\tif err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t}\n\n\tsignature := c.RefreshTokenStrategy.RefreshTokenSignature(requester.GetRequestForm().Get(\"refresh_token\"))\n\n\tctx, err = storage.MaybeBeginTx(ctx, c.TokenRevocationStorage)\n\tif err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t}\n\n\tts, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)\n\tif err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t} else if err := c.TokenRevocationStorage.RevokeAccessToken(ctx, ts.GetID()); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t} else if err := c.TokenRevocationStorage.RevokeRefreshToken(ctx, ts.GetID()); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t}\n\n\tstoreReq := requester.Sanitize([]string{})\n\tstoreReq.SetID(ts.GetID())\n\n\tif err := c.TokenRevocationStorage.CreateAccessTokenSession(ctx, accessSignature, storeReq); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t}\n\n\tif err := c.TokenRevocationStorage.CreateRefreshTokenSession(ctx, refreshSignature, storeReq); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t}\n\n\tresponder.SetAccessToken(accessToken)\n\tresponder.SetTokenType(\"bearer\")\n\tresponder.SetExpiresIn(getExpiresIn(requester, fosite.AccessToken, c.AccessTokenLifespan, time.Now().UTC()))\n\tresponder.SetScopes(requester.GetGrantedScopes())\n\tresponder.SetExtra(\"refresh_token\", refreshToken)\n\n\tif err := storage.MaybeCommitTx(ctx, c.TokenRevocationStorage); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, false, c.TokenRevocationStorage, err)\n\t}\n\n\treturn nil\n}\n\nfunc handleRefreshTokenEndpointResponseStorageError(ctx context.Context, rollback bool, store TokenRevocationStorage, storageErr error) (err error) {\n\tdefer func() {\n\t\tif rollback {\n\t\t\tif rbErr := storage.MaybeRollbackTx(ctx, store); rbErr != nil {\n\t\t\t\terr = errors.WithStack(fosite.ErrServerError.WithDebug(rbErr.Error()))\n\t\t\t}\n\t\t}\n\t}()\n\n\tif errors.Cause(storageErr) == fosite.ErrSerializationFailure {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.\n\t\t\tWithDebugf(storageErr.Error()).\n\t\t\tWithHint(\"Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.\"))\n\t}\n\n\tif errors.Cause(storageErr) == fosite.ErrNotFound {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.\n\t\t\tWithDebugf(storageErr.Error()).\n\t\t\tWithHint(\"Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.\"))\n\t}\n\n\treturn errors.WithStack(fosite.ErrServerError.WithDebug(storageErr.Error()))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AccessRequester)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\turl \"net/url\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessRequester is a mock of AccessRequester interface\ntype MockAccessRequester struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessRequesterMockRecorder\n}\n\n// MockAccessRequesterMockRecorder is the mock recorder for MockAccessRequester\ntype MockAccessRequesterMockRecorder struct {\n\tmock *MockAccessRequester\n}\n\n// NewMockAccessRequester creates a new mock instance\nfunc NewMockAccessRequester(ctrl *gomock.Controller) *MockAccessRequester {\n\tmock := &MockAccessRequester{ctrl: ctrl}\n\tmock.recorder = &MockAccessRequesterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessRequester) EXPECT() *MockAccessRequesterMockRecorder {\n\treturn m.recorder\n}\n\n// AppendRequestedScope mocks base method\nfunc (m *MockAccessRequester) AppendRequestedScope(arg0 string) {\n\tm.ctrl.Call(m, \"AppendRequestedScope\", arg0)\n}\n\n// AppendRequestedScope indicates an expected call of AppendRequestedScope\nfunc (mr *MockAccessRequesterMockRecorder) AppendRequestedScope(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AppendRequestedScope\", reflect.TypeOf((*MockAccessRequester)(nil).AppendRequestedScope), arg0)\n}\n\n// GetClient mocks base method\nfunc (m *MockAccessRequester) GetClient() fosite.Client {\n\tret := m.ctrl.Call(m, \"GetClient\")\n\tret0, _ := ret[0].(fosite.Client)\n\treturn ret0\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockAccessRequesterMockRecorder) GetClient() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockAccessRequester)(nil).GetClient))\n}\n\n// GetGrantTypes mocks base method\nfunc (m *MockAccessRequester) GetGrantTypes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantTypes indicates an expected call of GetGrantTypes\nfunc (mr *MockAccessRequesterMockRecorder) GetGrantTypes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantTypes\", reflect.TypeOf((*MockAccessRequester)(nil).GetGrantTypes))\n}\n\n// GetGrantedAudience mocks base method\nfunc (m *MockAccessRequester) GetGrantedAudience() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedAudience indicates an expected call of GetGrantedAudience\nfunc (mr *MockAccessRequesterMockRecorder) GetGrantedAudience() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedAudience\", reflect.TypeOf((*MockAccessRequester)(nil).GetGrantedAudience))\n}\n\n// GetGrantedScopes mocks base method\nfunc (m *MockAccessRequester) GetGrantedScopes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedScopes indicates an expected call of GetGrantedScopes\nfunc (mr *MockAccessRequesterMockRecorder) GetGrantedScopes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedScopes\", reflect.TypeOf((*MockAccessRequester)(nil).GetGrantedScopes))\n}\n\n// GetID mocks base method\nfunc (m *MockAccessRequester) GetID() string {\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockAccessRequesterMockRecorder) GetID() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockAccessRequester)(nil).GetID))\n}\n\n// GetRequestForm mocks base method\nfunc (m *MockAccessRequester) GetRequestForm() url.Values {\n\tret := m.ctrl.Call(m, \"GetRequestForm\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetRequestForm indicates an expected call of GetRequestForm\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestForm() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestForm\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestForm))\n}\n\n// GetRequestedAt mocks base method\nfunc (m *MockAccessRequester) GetRequestedAt() time.Time {\n\tret := m.ctrl.Call(m, \"GetRequestedAt\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetRequestedAt indicates an expected call of GetRequestedAt\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestedAt() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAt\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestedAt))\n}\n\n// GetRequestedAudience mocks base method\nfunc (m *MockAccessRequester) GetRequestedAudience() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetRequestedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedAudience indicates an expected call of GetRequestedAudience\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestedAudience() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAudience\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestedAudience))\n}\n\n// GetRequestedScopes mocks base method\nfunc (m *MockAccessRequester) GetRequestedScopes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetRequestedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedScopes indicates an expected call of GetRequestedScopes\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestedScopes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedScopes\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestedScopes))\n}\n\n// GetSession mocks base method\nfunc (m *MockAccessRequester) GetSession() fosite.Session {\n\tret := m.ctrl.Call(m, \"GetSession\")\n\tret0, _ := ret[0].(fosite.Session)\n\treturn ret0\n}\n\n// GetSession indicates an expected call of GetSession\nfunc (mr *MockAccessRequesterMockRecorder) GetSession() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetSession\", reflect.TypeOf((*MockAccessRequester)(nil).GetSession))\n}\n\n// GrantAudience mocks base method\nfunc (m *MockAccessRequester) GrantAudience(arg0 string) {\n\tm.ctrl.Call(m, \"GrantAudience\", arg0)\n}\n\n// GrantAudience indicates an expected call of GrantAudience\nfunc (mr *MockAccessRequesterMockRecorder) GrantAudience(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantAudience\", reflect.TypeOf((*MockAccessRequester)(nil).GrantAudience), arg0)\n}\n\n// GrantScope mocks base method\nfunc (m *MockAccessRequester) GrantScope(arg0 string) {\n\tm.ctrl.Call(m, \"GrantScope\", arg0)\n}\n\n// GrantScope indicates an expected call of GrantScope\nfunc (mr *MockAccessRequesterMockRecorder) GrantScope(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantScope\", reflect.TypeOf((*MockAccessRequester)(nil).GrantScope), arg0)\n}\n\n// Merge mocks base method\nfunc (m *MockAccessRequester) Merge(arg0 fosite.Requester) {\n\tm.ctrl.Call(m, \"Merge\", arg0)\n}\n\n// Merge indicates an expected call of Merge\nfunc (mr *MockAccessRequesterMockRecorder) Merge(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Merge\", reflect.TypeOf((*MockAccessRequester)(nil).Merge), arg0)\n}\n\n// Sanitize mocks base method\nfunc (m *MockAccessRequester) Sanitize(arg0 []string) fosite.Requester {\n\tret := m.ctrl.Call(m, \"Sanitize\", arg0)\n\tret0, _ := ret[0].(fosite.Requester)\n\treturn ret0\n}\n\n// Sanitize indicates an expected call of Sanitize\nfunc (mr *MockAccessRequesterMockRecorder) Sanitize(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sanitize\", reflect.TypeOf((*MockAccessRequester)(nil).Sanitize), arg0)\n}\n\n// SetID mocks base method\nfunc (m *MockAccessRequester) SetID(arg0 string) {\n\tm.ctrl.Call(m, \"SetID\", arg0)\n}\n\n// SetID indicates an expected call of SetID\nfunc (mr *MockAccessRequesterMockRecorder) SetID(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetID\", reflect.TypeOf((*MockAccessRequester)(nil).SetID), arg0)\n}\n\n// SetRequestedAudience mocks base method\nfunc (m *MockAccessRequester) SetRequestedAudience(arg0 fosite.Arguments) {\n\tm.ctrl.Call(m, \"SetRequestedAudience\", arg0)\n}\n\n// SetRequestedAudience indicates an expected call of SetRequestedAudience\nfunc (mr *MockAccessRequesterMockRecorder) SetRequestedAudience(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedAudience\", reflect.TypeOf((*MockAccessRequester)(nil).SetRequestedAudience), arg0)\n}\n\n// SetRequestedScopes mocks base method\nfunc (m *MockAccessRequester) SetRequestedScopes(arg0 fosite.Arguments) {\n\tm.ctrl.Call(m, \"SetRequestedScopes\", arg0)\n}\n\n// SetRequestedScopes indicates an expected call of SetRequestedScopes\nfunc (mr *MockAccessRequesterMockRecorder) SetRequestedScopes(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedScopes\", reflect.TypeOf((*MockAccessRequester)(nil).SetRequestedScopes), arg0)\n}\n\n// SetSession mocks base method\nfunc (m *MockAccessRequester) SetSession(arg0 fosite.Session) {\n\tm.ctrl.Call(m, \"SetSession\", arg0)\n}\n\n// SetSession indicates an expected call of SetSession\nfunc (mr *MockAccessRequesterMockRecorder) SetSession(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetSession\", reflect.TypeOf((*MockAccessRequester)(nil).SetSession), arg0)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AccessResponder)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessResponder is a mock of AccessResponder interface\ntype MockAccessResponder struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessResponderMockRecorder\n}\n\n// MockAccessResponderMockRecorder is the mock recorder for MockAccessResponder\ntype MockAccessResponderMockRecorder struct {\n\tmock *MockAccessResponder\n}\n\n// NewMockAccessResponder creates a new mock instance\nfunc NewMockAccessResponder(ctrl *gomock.Controller) *MockAccessResponder {\n\tmock := &MockAccessResponder{ctrl: ctrl}\n\tmock.recorder = &MockAccessResponderMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessResponder) EXPECT() *MockAccessResponderMockRecorder {\n\treturn m.recorder\n}\n\n// GetAccessToken mocks base method\nfunc (m *MockAccessResponder) GetAccessToken() string {\n\tret := m.ctrl.Call(m, \"GetAccessToken\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetAccessToken indicates an expected call of GetAccessToken\nfunc (mr *MockAccessResponderMockRecorder) GetAccessToken() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessToken\", reflect.TypeOf((*MockAccessResponder)(nil).GetAccessToken))\n}\n\n// GetExtra mocks base method\nfunc (m *MockAccessResponder) GetExtra(arg0 string) interface{} {\n\tret := m.ctrl.Call(m, \"GetExtra\", arg0)\n\tret0, _ := ret[0].(interface{})\n\treturn ret0\n}\n\n// GetExtra indicates an expected call of GetExtra\nfunc (mr *MockAccessResponderMockRecorder) GetExtra(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetExtra\", reflect.TypeOf((*MockAccessResponder)(nil).GetExtra), arg0)\n}\n\n// GetTokenType mocks base method\nfunc (m *MockAccessResponder) GetTokenType() string {\n\tret := m.ctrl.Call(m, \"GetTokenType\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetTokenType indicates an expected call of GetTokenType\nfunc (mr *MockAccessResponderMockRecorder) GetTokenType() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetTokenType\", reflect.TypeOf((*MockAccessResponder)(nil).GetTokenType))\n}\n\n// SetAccessToken mocks base method\nfunc (m *MockAccessResponder) SetAccessToken(arg0 string) {\n\tm.ctrl.Call(m, \"SetAccessToken\", arg0)\n}\n\n// SetAccessToken indicates an expected call of SetAccessToken\nfunc (mr *MockAccessResponderMockRecorder) SetAccessToken(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetAccessToken\", reflect.TypeOf((*MockAccessResponder)(nil).SetAccessToken), arg0)\n}\n\n// SetExpiresIn mocks base method\nfunc (m *MockAccessResponder) SetExpiresIn(arg0 time.Duration) {\n\tm.ctrl.Call(m, \"SetExpiresIn\", arg0)\n}\n\n// SetExpiresIn indicates an expected call of SetExpiresIn\nfunc (mr *MockAccessResponderMockRecorder) SetExpiresIn(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetExpiresIn\", reflect.TypeOf((*MockAccessResponder)(nil).SetExpiresIn), arg0)\n}\n\n// SetExtra mocks base method\nfunc (m *MockAccessResponder) SetExtra(arg0 string, arg1 interface{}) {\n\tm.ctrl.Call(m, \"SetExtra\", arg0, arg1)\n}\n\n// SetExtra indicates an expected call of SetExtra\nfunc (mr *MockAccessResponderMockRecorder) SetExtra(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetExtra\", reflect.TypeOf((*MockAccessResponder)(nil).SetExtra), arg0, arg1)\n}\n\n// SetScopes mocks base method\nfunc (m *MockAccessResponder) SetScopes(arg0 fosite.Arguments) {\n\tm.ctrl.Call(m, \"SetScopes\", arg0)\n}\n\n// SetScopes indicates an expected call of SetScopes\nfunc (mr *MockAccessResponderMockRecorder) SetScopes(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetScopes\", reflect.TypeOf((*MockAccessResponder)(nil).SetScopes), arg0)\n}\n\n// SetTokenType mocks base method\nfunc (m *MockAccessResponder) SetTokenType(arg0 string) {\n\tm.ctrl.Call(m, \"SetTokenType\", arg0)\n}\n\n// SetTokenType indicates an expected call of SetTokenType\nfunc (mr *MockAccessResponderMockRecorder) SetTokenType(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetTokenType\", reflect.TypeOf((*MockAccessResponder)(nil).SetTokenType), arg0)\n}\n\n// ToMap mocks base method\nfunc (m *MockAccessResponder) ToMap() map[string]interface{} {\n\tret := m.ctrl.Call(m, \"ToMap\")\n\tret0, _ := ret[0].(map[string]interface{})\n\treturn ret0\n}\n\n// ToMap indicates an expected call of ToMap\nfunc (mr *MockAccessResponderMockRecorder) ToMap() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ToMap\", reflect.TypeOf((*MockAccessResponder)(nil).ToMap))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessTokenStorage is a mock of AccessTokenStorage interface\ntype MockAccessTokenStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessTokenStorageMockRecorder\n}\n\n// MockAccessTokenStorageMockRecorder is the mock recorder for MockAccessTokenStorage\ntype MockAccessTokenStorageMockRecorder struct {\n\tmock *MockAccessTokenStorage\n}\n\n// NewMockAccessTokenStorage creates a new mock instance\nfunc NewMockAccessTokenStorage(ctrl *gomock.Controller) *MockAccessTokenStorage {\n\tmock := &MockAccessTokenStorage{ctrl: ctrl}\n\tmock.recorder = &MockAccessTokenStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessTokenStorage) EXPECT() *MockAccessTokenStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockAccessTokenStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockAccessTokenStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockAccessTokenStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockAccessTokenStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockAccessTokenStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockAccessTokenStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockAccessTokenStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockAccessTokenStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockAccessTokenStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessTokenStrategy is a mock of AccessTokenStrategy interface\ntype MockAccessTokenStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessTokenStrategyMockRecorder\n}\n\n// MockAccessTokenStrategyMockRecorder is the mock recorder for MockAccessTokenStrategy\ntype MockAccessTokenStrategyMockRecorder struct {\n\tmock *MockAccessTokenStrategy\n}\n\n// NewMockAccessTokenStrategy creates a new mock instance\nfunc NewMockAccessTokenStrategy(ctrl *gomock.Controller) *MockAccessTokenStrategy {\n\tmock := &MockAccessTokenStrategy{ctrl: ctrl}\n\tmock.recorder = &MockAccessTokenStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessTokenStrategy) EXPECT() *MockAccessTokenStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// AccessTokenSignature mocks base method\nfunc (m *MockAccessTokenStrategy) AccessTokenSignature(arg0 string) string {\n\tret := m.ctrl.Call(m, \"AccessTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AccessTokenSignature indicates an expected call of AccessTokenSignature\nfunc (mr *MockAccessTokenStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AccessTokenSignature\", reflect.TypeOf((*MockAccessTokenStrategy)(nil).AccessTokenSignature), arg0)\n}\n\n// GenerateAccessToken mocks base method\nfunc (m *MockAccessTokenStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tret := m.ctrl.Call(m, \"GenerateAccessToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAccessToken indicates an expected call of GenerateAccessToken\nfunc (mr *MockAccessTokenStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAccessToken\", reflect.TypeOf((*MockAccessTokenStrategy)(nil).GenerateAccessToken), arg0, arg1)\n}\n\n// ValidateAccessToken mocks base method\nfunc (m *MockAccessTokenStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tret := m.ctrl.Call(m, \"ValidateAccessToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAccessToken indicates an expected call of ValidateAccessToken\nfunc (mr *MockAccessTokenStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAccessToken\", reflect.TypeOf((*MockAccessTokenStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeCodeStorage is a mock of AuthorizeCodeStorage interface\ntype MockAuthorizeCodeStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeCodeStorageMockRecorder\n}\n\n// MockAuthorizeCodeStorageMockRecorder is the mock recorder for MockAuthorizeCodeStorage\ntype MockAuthorizeCodeStorageMockRecorder struct {\n\tmock *MockAuthorizeCodeStorage\n}\n\n// NewMockAuthorizeCodeStorage creates a new mock instance\nfunc NewMockAuthorizeCodeStorage(ctrl *gomock.Controller) *MockAuthorizeCodeStorage {\n\tmock := &MockAuthorizeCodeStorage{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeCodeStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeCodeStorage) EXPECT() *MockAuthorizeCodeStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAuthorizeCodeSession mocks base method\nfunc (m *MockAuthorizeCodeStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession\nfunc (mr *MockAuthorizeCodeStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAuthorizeCodeSession\", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// GetAuthorizeCodeSession mocks base method\nfunc (m *MockAuthorizeCodeStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession\nfunc (mr *MockAuthorizeCodeStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAuthorizeCodeSession\", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// InvalidateAuthorizeCodeSession mocks base method\nfunc (m *MockAuthorizeCodeStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"InvalidateAuthorizeCodeSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession\nfunc (mr *MockAuthorizeCodeStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InvalidateAuthorizeCodeSession\", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeCodeStrategy is a mock of AuthorizeCodeStrategy interface\ntype MockAuthorizeCodeStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeCodeStrategyMockRecorder\n}\n\n// MockAuthorizeCodeStrategyMockRecorder is the mock recorder for MockAuthorizeCodeStrategy\ntype MockAuthorizeCodeStrategyMockRecorder struct {\n\tmock *MockAuthorizeCodeStrategy\n}\n\n// NewMockAuthorizeCodeStrategy creates a new mock instance\nfunc NewMockAuthorizeCodeStrategy(ctrl *gomock.Controller) *MockAuthorizeCodeStrategy {\n\tmock := &MockAuthorizeCodeStrategy{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeCodeStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeCodeStrategy) EXPECT() *MockAuthorizeCodeStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// AuthorizeCodeSignature mocks base method\nfunc (m *MockAuthorizeCodeStrategy) AuthorizeCodeSignature(arg0 string) string {\n\tret := m.ctrl.Call(m, \"AuthorizeCodeSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature\nfunc (mr *MockAuthorizeCodeStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AuthorizeCodeSignature\", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).AuthorizeCodeSignature), arg0)\n}\n\n// GenerateAuthorizeCode mocks base method\nfunc (m *MockAuthorizeCodeStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tret := m.ctrl.Call(m, \"GenerateAuthorizeCode\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode\nfunc (mr *MockAuthorizeCodeStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAuthorizeCode\", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)\n}\n\n// ValidateAuthorizeCode mocks base method\nfunc (m *MockAuthorizeCodeStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tret := m.ctrl.Call(m, \"ValidateAuthorizeCode\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode\nfunc (mr *MockAuthorizeCodeStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAuthorizeCode\", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AuthorizeEndpointHandler)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeEndpointHandler is a mock of AuthorizeEndpointHandler interface\ntype MockAuthorizeEndpointHandler struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeEndpointHandlerMockRecorder\n}\n\n// MockAuthorizeEndpointHandlerMockRecorder is the mock recorder for MockAuthorizeEndpointHandler\ntype MockAuthorizeEndpointHandlerMockRecorder struct {\n\tmock *MockAuthorizeEndpointHandler\n}\n\n// NewMockAuthorizeEndpointHandler creates a new mock instance\nfunc NewMockAuthorizeEndpointHandler(ctrl *gomock.Controller) *MockAuthorizeEndpointHandler {\n\tmock := &MockAuthorizeEndpointHandler{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeEndpointHandlerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeEndpointHandler) EXPECT() *MockAuthorizeEndpointHandlerMockRecorder {\n\treturn m.recorder\n}\n\n// HandleAuthorizeEndpointRequest mocks base method\nfunc (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 context.Context, arg1 fosite.AuthorizeRequester, arg2 fosite.AuthorizeResponder) error {\n\tret := m.ctrl.Call(m, \"HandleAuthorizeEndpointRequest\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// HandleAuthorizeEndpointRequest indicates an expected call of HandleAuthorizeEndpointRequest\nfunc (mr *MockAuthorizeEndpointHandlerMockRecorder) HandleAuthorizeEndpointRequest(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"HandleAuthorizeEndpointRequest\", reflect.TypeOf((*MockAuthorizeEndpointHandler)(nil).HandleAuthorizeEndpointRequest), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AuthorizeRequester)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\turl \"net/url\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeRequester is a mock of AuthorizeRequester interface\ntype MockAuthorizeRequester struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeRequesterMockRecorder\n}\n\n// MockAuthorizeRequesterMockRecorder is the mock recorder for MockAuthorizeRequester\ntype MockAuthorizeRequesterMockRecorder struct {\n\tmock *MockAuthorizeRequester\n}\n\n// NewMockAuthorizeRequester creates a new mock instance\nfunc NewMockAuthorizeRequester(ctrl *gomock.Controller) *MockAuthorizeRequester {\n\tmock := &MockAuthorizeRequester{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeRequesterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeRequester) EXPECT() *MockAuthorizeRequesterMockRecorder {\n\treturn m.recorder\n}\n\n// AppendRequestedScope mocks base method\nfunc (m *MockAuthorizeRequester) AppendRequestedScope(arg0 string) {\n\tm.ctrl.Call(m, \"AppendRequestedScope\", arg0)\n}\n\n// AppendRequestedScope indicates an expected call of AppendRequestedScope\nfunc (mr *MockAuthorizeRequesterMockRecorder) AppendRequestedScope(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AppendRequestedScope\", reflect.TypeOf((*MockAuthorizeRequester)(nil).AppendRequestedScope), arg0)\n}\n\n// DidHandleAllResponseTypes mocks base method\nfunc (m *MockAuthorizeRequester) DidHandleAllResponseTypes() bool {\n\tret := m.ctrl.Call(m, \"DidHandleAllResponseTypes\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// DidHandleAllResponseTypes indicates an expected call of DidHandleAllResponseTypes\nfunc (mr *MockAuthorizeRequesterMockRecorder) DidHandleAllResponseTypes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DidHandleAllResponseTypes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).DidHandleAllResponseTypes))\n}\n\n// GetClient mocks base method\nfunc (m *MockAuthorizeRequester) GetClient() fosite.Client {\n\tret := m.ctrl.Call(m, \"GetClient\")\n\tret0, _ := ret[0].(fosite.Client)\n\treturn ret0\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetClient() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetClient))\n}\n\n// GetGrantedAudience mocks base method\nfunc (m *MockAuthorizeRequester) GetGrantedAudience() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedAudience indicates an expected call of GetGrantedAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetGrantedAudience() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetGrantedAudience))\n}\n\n// GetGrantedScopes mocks base method\nfunc (m *MockAuthorizeRequester) GetGrantedScopes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedScopes indicates an expected call of GetGrantedScopes\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetGrantedScopes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedScopes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetGrantedScopes))\n}\n\n// GetID mocks base method\nfunc (m *MockAuthorizeRequester) GetID() string {\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetID() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetID))\n}\n\n// GetRedirectURI mocks base method\nfunc (m *MockAuthorizeRequester) GetRedirectURI() *url.URL {\n\tret := m.ctrl.Call(m, \"GetRedirectURI\")\n\tret0, _ := ret[0].(*url.URL)\n\treturn ret0\n}\n\n// GetRedirectURI indicates an expected call of GetRedirectURI\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRedirectURI() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRedirectURI\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRedirectURI))\n}\n\n// GetRequestForm mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestForm() url.Values {\n\tret := m.ctrl.Call(m, \"GetRequestForm\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetRequestForm indicates an expected call of GetRequestForm\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestForm() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestForm\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestForm))\n}\n\n// GetRequestedAt mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestedAt() time.Time {\n\tret := m.ctrl.Call(m, \"GetRequestedAt\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetRequestedAt indicates an expected call of GetRequestedAt\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestedAt() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAt\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestedAt))\n}\n\n// GetRequestedAudience mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestedAudience() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetRequestedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedAudience indicates an expected call of GetRequestedAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestedAudience() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestedAudience))\n}\n\n// GetRequestedScopes mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestedScopes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetRequestedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedScopes indicates an expected call of GetRequestedScopes\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestedScopes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedScopes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestedScopes))\n}\n\n// GetResponseTypes mocks base method\nfunc (m *MockAuthorizeRequester) GetResponseTypes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetResponseTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetResponseTypes indicates an expected call of GetResponseTypes\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetResponseTypes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetResponseTypes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetResponseTypes))\n}\n\n// GetSession mocks base method\nfunc (m *MockAuthorizeRequester) GetSession() fosite.Session {\n\tret := m.ctrl.Call(m, \"GetSession\")\n\tret0, _ := ret[0].(fosite.Session)\n\treturn ret0\n}\n\n// GetSession indicates an expected call of GetSession\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetSession() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetSession\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetSession))\n}\n\n// GetState mocks base method\nfunc (m *MockAuthorizeRequester) GetState() string {\n\tret := m.ctrl.Call(m, \"GetState\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetState indicates an expected call of GetState\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetState() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetState\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetState))\n}\n\n// GrantAudience mocks base method\nfunc (m *MockAuthorizeRequester) GrantAudience(arg0 string) {\n\tm.ctrl.Call(m, \"GrantAudience\", arg0)\n}\n\n// GrantAudience indicates an expected call of GrantAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) GrantAudience(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GrantAudience), arg0)\n}\n\n// GrantScope mocks base method\nfunc (m *MockAuthorizeRequester) GrantScope(arg0 string) {\n\tm.ctrl.Call(m, \"GrantScope\", arg0)\n}\n\n// GrantScope indicates an expected call of GrantScope\nfunc (mr *MockAuthorizeRequesterMockRecorder) GrantScope(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantScope\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GrantScope), arg0)\n}\n\n// IsRedirectURIValid mocks base method\nfunc (m *MockAuthorizeRequester) IsRedirectURIValid() bool {\n\tret := m.ctrl.Call(m, \"IsRedirectURIValid\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// IsRedirectURIValid indicates an expected call of IsRedirectURIValid\nfunc (mr *MockAuthorizeRequesterMockRecorder) IsRedirectURIValid() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsRedirectURIValid\", reflect.TypeOf((*MockAuthorizeRequester)(nil).IsRedirectURIValid))\n}\n\n// Merge mocks base method\nfunc (m *MockAuthorizeRequester) Merge(arg0 fosite.Requester) {\n\tm.ctrl.Call(m, \"Merge\", arg0)\n}\n\n// Merge indicates an expected call of Merge\nfunc (mr *MockAuthorizeRequesterMockRecorder) Merge(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Merge\", reflect.TypeOf((*MockAuthorizeRequester)(nil).Merge), arg0)\n}\n\n// Sanitize mocks base method\nfunc (m *MockAuthorizeRequester) Sanitize(arg0 []string) fosite.Requester {\n\tret := m.ctrl.Call(m, \"Sanitize\", arg0)\n\tret0, _ := ret[0].(fosite.Requester)\n\treturn ret0\n}\n\n// Sanitize indicates an expected call of Sanitize\nfunc (mr *MockAuthorizeRequesterMockRecorder) Sanitize(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sanitize\", reflect.TypeOf((*MockAuthorizeRequester)(nil).Sanitize), arg0)\n}\n\n// SetID mocks base method\nfunc (m *MockAuthorizeRequester) SetID(arg0 string) {\n\tm.ctrl.Call(m, \"SetID\", arg0)\n}\n\n// SetID indicates an expected call of SetID\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetID(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetID\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetID), arg0)\n}\n\n// SetRequestedAudience mocks base method\nfunc (m *MockAuthorizeRequester) SetRequestedAudience(arg0 fosite.Arguments) {\n\tm.ctrl.Call(m, \"SetRequestedAudience\", arg0)\n}\n\n// SetRequestedAudience indicates an expected call of SetRequestedAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetRequestedAudience(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetRequestedAudience), arg0)\n}\n\n// SetRequestedScopes mocks base method\nfunc (m *MockAuthorizeRequester) SetRequestedScopes(arg0 fosite.Arguments) {\n\tm.ctrl.Call(m, \"SetRequestedScopes\", arg0)\n}\n\n// SetRequestedScopes indicates an expected call of SetRequestedScopes\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetRequestedScopes(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedScopes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetRequestedScopes), arg0)\n}\n\n// SetResponseTypeHandled mocks base method\nfunc (m *MockAuthorizeRequester) SetResponseTypeHandled(arg0 string) {\n\tm.ctrl.Call(m, \"SetResponseTypeHandled\", arg0)\n}\n\n// SetResponseTypeHandled indicates an expected call of SetResponseTypeHandled\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetResponseTypeHandled(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetResponseTypeHandled\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetResponseTypeHandled), arg0)\n}\n\n// SetSession mocks base method\nfunc (m *MockAuthorizeRequester) SetSession(arg0 fosite.Session) {\n\tm.ctrl.Call(m, \"SetSession\", arg0)\n}\n\n// SetSession indicates an expected call of SetSession\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetSession(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetSession\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetSession), arg0)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AuthorizeResponder)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\thttp \"net/http\"\n\turl \"net/url\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockAuthorizeResponder is a mock of AuthorizeResponder interface\ntype MockAuthorizeResponder struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeResponderMockRecorder\n}\n\n// MockAuthorizeResponderMockRecorder is the mock recorder for MockAuthorizeResponder\ntype MockAuthorizeResponderMockRecorder struct {\n\tmock *MockAuthorizeResponder\n}\n\n// NewMockAuthorizeResponder creates a new mock instance\nfunc NewMockAuthorizeResponder(ctrl *gomock.Controller) *MockAuthorizeResponder {\n\tmock := &MockAuthorizeResponder{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeResponderMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeResponder) EXPECT() *MockAuthorizeResponderMockRecorder {\n\treturn m.recorder\n}\n\n// AddFragment mocks base method\nfunc (m *MockAuthorizeResponder) AddFragment(arg0, arg1 string) {\n\tm.ctrl.Call(m, \"AddFragment\", arg0, arg1)\n}\n\n// AddFragment indicates an expected call of AddFragment\nfunc (mr *MockAuthorizeResponderMockRecorder) AddFragment(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddFragment\", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddFragment), arg0, arg1)\n}\n\n// AddHeader mocks base method\nfunc (m *MockAuthorizeResponder) AddHeader(arg0, arg1 string) {\n\tm.ctrl.Call(m, \"AddHeader\", arg0, arg1)\n}\n\n// AddHeader indicates an expected call of AddHeader\nfunc (mr *MockAuthorizeResponderMockRecorder) AddHeader(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddHeader\", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddHeader), arg0, arg1)\n}\n\n// AddQuery mocks base method\nfunc (m *MockAuthorizeResponder) AddQuery(arg0, arg1 string) {\n\tm.ctrl.Call(m, \"AddQuery\", arg0, arg1)\n}\n\n// AddQuery indicates an expected call of AddQuery\nfunc (mr *MockAuthorizeResponderMockRecorder) AddQuery(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddQuery\", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddQuery), arg0, arg1)\n}\n\n// GetCode mocks base method\nfunc (m *MockAuthorizeResponder) GetCode() string {\n\tret := m.ctrl.Call(m, \"GetCode\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetCode indicates an expected call of GetCode\nfunc (mr *MockAuthorizeResponderMockRecorder) GetCode() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetCode\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetCode))\n}\n\n// GetFragment mocks base method\nfunc (m *MockAuthorizeResponder) GetFragment() url.Values {\n\tret := m.ctrl.Call(m, \"GetFragment\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetFragment indicates an expected call of GetFragment\nfunc (mr *MockAuthorizeResponderMockRecorder) GetFragment() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetFragment\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetFragment))\n}\n\n// GetHeader mocks base method\nfunc (m *MockAuthorizeResponder) GetHeader() http.Header {\n\tret := m.ctrl.Call(m, \"GetHeader\")\n\tret0, _ := ret[0].(http.Header)\n\treturn ret0\n}\n\n// GetHeader indicates an expected call of GetHeader\nfunc (mr *MockAuthorizeResponderMockRecorder) GetHeader() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetHeader\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetHeader))\n}\n\n// GetQuery mocks base method\nfunc (m *MockAuthorizeResponder) GetQuery() url.Values {\n\tret := m.ctrl.Call(m, \"GetQuery\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetQuery indicates an expected call of GetQuery\nfunc (mr *MockAuthorizeResponderMockRecorder) GetQuery() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetQuery\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetQuery))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Client)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockClient is a mock of Client interface\ntype MockClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockClientMockRecorder\n}\n\n// MockClientMockRecorder is the mock recorder for MockClient\ntype MockClientMockRecorder struct {\n\tmock *MockClient\n}\n\n// NewMockClient creates a new mock instance\nfunc NewMockClient(ctrl *gomock.Controller) *MockClient {\n\tmock := &MockClient{ctrl: ctrl}\n\tmock.recorder = &MockClientMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockClient) EXPECT() *MockClientMockRecorder {\n\treturn m.recorder\n}\n\n// GetAudience mocks base method\nfunc (m *MockClient) GetAudience() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetAudience indicates an expected call of GetAudience\nfunc (mr *MockClientMockRecorder) GetAudience() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAudience\", reflect.TypeOf((*MockClient)(nil).GetAudience))\n}\n\n// GetGrantTypes mocks base method\nfunc (m *MockClient) GetGrantTypes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantTypes indicates an expected call of GetGrantTypes\nfunc (mr *MockClientMockRecorder) GetGrantTypes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantTypes\", reflect.TypeOf((*MockClient)(nil).GetGrantTypes))\n}\n\n// GetHashedSecret mocks base method\nfunc (m *MockClient) GetHashedSecret() []byte {\n\tret := m.ctrl.Call(m, \"GetHashedSecret\")\n\tret0, _ := ret[0].([]byte)\n\treturn ret0\n}\n\n// GetHashedSecret indicates an expected call of GetHashedSecret\nfunc (mr *MockClientMockRecorder) GetHashedSecret() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetHashedSecret\", reflect.TypeOf((*MockClient)(nil).GetHashedSecret))\n}\n\n// GetID mocks base method\nfunc (m *MockClient) GetID() string {\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockClientMockRecorder) GetID() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockClient)(nil).GetID))\n}\n\n// GetRedirectURIs mocks base method\nfunc (m *MockClient) GetRedirectURIs() []string {\n\tret := m.ctrl.Call(m, \"GetRedirectURIs\")\n\tret0, _ := ret[0].([]string)\n\treturn ret0\n}\n\n// GetRedirectURIs indicates an expected call of GetRedirectURIs\nfunc (mr *MockClientMockRecorder) GetRedirectURIs() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRedirectURIs\", reflect.TypeOf((*MockClient)(nil).GetRedirectURIs))\n}\n\n// GetResponseTypes mocks base method\nfunc (m *MockClient) GetResponseTypes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetResponseTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetResponseTypes indicates an expected call of GetResponseTypes\nfunc (mr *MockClientMockRecorder) GetResponseTypes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetResponseTypes\", reflect.TypeOf((*MockClient)(nil).GetResponseTypes))\n}\n\n// GetScopes mocks base method\nfunc (m *MockClient) GetScopes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetScopes indicates an expected call of GetScopes\nfunc (mr *MockClientMockRecorder) GetScopes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetScopes\", reflect.TypeOf((*MockClient)(nil).GetScopes))\n}\n\n// IsPublic mocks base method\nfunc (m *MockClient) IsPublic() bool {\n\tret := m.ctrl.Call(m, \"IsPublic\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// IsPublic indicates an expected call of IsPublic\nfunc (mr *MockClientMockRecorder) IsPublic() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsPublic\", reflect.TypeOf((*MockClient)(nil).IsPublic))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Hasher)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockHasher is a mock of Hasher interface\ntype MockHasher struct {\n\tctrl     *gomock.Controller\n\trecorder *MockHasherMockRecorder\n}\n\n// MockHasherMockRecorder is the mock recorder for MockHasher\ntype MockHasherMockRecorder struct {\n\tmock *MockHasher\n}\n\n// NewMockHasher creates a new mock instance\nfunc NewMockHasher(ctrl *gomock.Controller) *MockHasher {\n\tmock := &MockHasher{ctrl: ctrl}\n\tmock.recorder = &MockHasherMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockHasher) EXPECT() *MockHasherMockRecorder {\n\treturn m.recorder\n}\n\n// Compare mocks base method\nfunc (m *MockHasher) Compare(arg0 context.Context, arg1, arg2 []byte) error {\n\tret := m.ctrl.Call(m, \"Compare\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Compare indicates an expected call of Compare\nfunc (mr *MockHasherMockRecorder) Compare(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Compare\", reflect.TypeOf((*MockHasher)(nil).Compare), arg0, arg1, arg2)\n}\n\n// Hash mocks base method\nfunc (m *MockHasher) Hash(arg0 context.Context, arg1 []byte) ([]byte, error) {\n\tret := m.ctrl.Call(m, \"Hash\", arg0, arg1)\n\tret0, _ := ret[0].([]byte)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Hash indicates an expected call of Hash\nfunc (mr *MockHasherMockRecorder) Hash(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Hash\", reflect.TypeOf((*MockHasher)(nil).Hash), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectTokenStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockOpenIDConnectTokenStrategy is a mock of OpenIDConnectTokenStrategy interface\ntype MockOpenIDConnectTokenStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockOpenIDConnectTokenStrategyMockRecorder\n}\n\n// MockOpenIDConnectTokenStrategyMockRecorder is the mock recorder for MockOpenIDConnectTokenStrategy\ntype MockOpenIDConnectTokenStrategyMockRecorder struct {\n\tmock *MockOpenIDConnectTokenStrategy\n}\n\n// NewMockOpenIDConnectTokenStrategy creates a new mock instance\nfunc NewMockOpenIDConnectTokenStrategy(ctrl *gomock.Controller) *MockOpenIDConnectTokenStrategy {\n\tmock := &MockOpenIDConnectTokenStrategy{ctrl: ctrl}\n\tmock.recorder = &MockOpenIDConnectTokenStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockOpenIDConnectTokenStrategy) EXPECT() *MockOpenIDConnectTokenStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// GenerateIDToken mocks base method\nfunc (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, arg1 fosite.Requester) (string, error) {\n\tret := m.ctrl.Call(m, \"GenerateIDToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GenerateIDToken indicates an expected call of GenerateIDToken\nfunc (mr *MockOpenIDConnectTokenStrategyMockRecorder) GenerateIDToken(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateIDToken\", reflect.TypeOf((*MockOpenIDConnectTokenStrategy)(nil).GenerateIDToken), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: TokenIntrospector)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockTokenIntrospector is a mock of TokenIntrospector interface\ntype MockTokenIntrospector struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTokenIntrospectorMockRecorder\n}\n\n// MockTokenIntrospectorMockRecorder is the mock recorder for MockTokenIntrospector\ntype MockTokenIntrospectorMockRecorder struct {\n\tmock *MockTokenIntrospector\n}\n\n// NewMockTokenIntrospector creates a new mock instance\nfunc NewMockTokenIntrospector(ctrl *gomock.Controller) *MockTokenIntrospector {\n\tmock := &MockTokenIntrospector{ctrl: ctrl}\n\tmock.recorder = &MockTokenIntrospectorMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTokenIntrospector) EXPECT() *MockTokenIntrospectorMockRecorder {\n\treturn m.recorder\n}\n\n// IntrospectToken mocks base method\nfunc (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.AccessRequester, arg4 []string) (fosite.TokenType, error) {\n\tret := m.ctrl.Call(m, \"IntrospectToken\", arg0, arg1, arg2, arg3, arg4)\n\tret0, _ := ret[0].(fosite.TokenType)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// IntrospectToken indicates an expected call of IntrospectToken\nfunc (mr *MockTokenIntrospectorMockRecorder) IntrospectToken(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IntrospectToken\", reflect.TypeOf((*MockTokenIntrospector)(nil).IntrospectToken), arg0, arg1, arg2, arg3, arg4)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ClientCredentialsGrantStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockClientCredentialsGrantStorage is a mock of ClientCredentialsGrantStorage interface\ntype MockClientCredentialsGrantStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockClientCredentialsGrantStorageMockRecorder\n}\n\n// MockClientCredentialsGrantStorageMockRecorder is the mock recorder for MockClientCredentialsGrantStorage\ntype MockClientCredentialsGrantStorageMockRecorder struct {\n\tmock *MockClientCredentialsGrantStorage\n}\n\n// NewMockClientCredentialsGrantStorage creates a new mock instance\nfunc NewMockClientCredentialsGrantStorage(ctrl *gomock.Controller) *MockClientCredentialsGrantStorage {\n\tmock := &MockClientCredentialsGrantStorage{ctrl: ctrl}\n\tmock.recorder = &MockClientCredentialsGrantStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockClientCredentialsGrantStorage) EXPECT() *MockClientCredentialsGrantStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockClientCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockClientCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockClientCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockClientCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockClientCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockClientCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ResourceOwnerPasswordCredentialsGrantStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockResourceOwnerPasswordCredentialsGrantStorage is a mock of ResourceOwnerPasswordCredentialsGrantStorage interface\ntype MockResourceOwnerPasswordCredentialsGrantStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder\n}\n\n// MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder is the mock recorder for MockResourceOwnerPasswordCredentialsGrantStorage\ntype MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder struct {\n\tmock *MockResourceOwnerPasswordCredentialsGrantStorage\n}\n\n// NewMockResourceOwnerPasswordCredentialsGrantStorage creates a new mock instance\nfunc NewMockResourceOwnerPasswordCredentialsGrantStorage(ctrl *gomock.Controller) *MockResourceOwnerPasswordCredentialsGrantStorage {\n\tmock := &MockResourceOwnerPasswordCredentialsGrantStorage{ctrl: ctrl}\n\tmock.recorder = &MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) EXPECT() *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder {\n\treturn m.recorder\n}\n\n// Authenticate mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) Authenticate(arg0 context.Context, arg1, arg2 string) error {\n\tret := m.ctrl.Call(m, \"Authenticate\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Authenticate indicates an expected call of Authenticate\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) Authenticate(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Authenticate\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).Authenticate), arg0, arg1, arg2)\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// CreateRefreshTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRefreshTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// DeleteRefreshTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteRefreshTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRefreshTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n\n// GetRefreshTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRefreshTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: TokenRevocationStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockTokenRevocationStorage is a mock of TokenRevocationStorage interface\ntype MockTokenRevocationStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTokenRevocationStorageMockRecorder\n}\n\n// MockTokenRevocationStorageMockRecorder is the mock recorder for MockTokenRevocationStorage\ntype MockTokenRevocationStorageMockRecorder struct {\n\tmock *MockTokenRevocationStorage\n}\n\n// NewMockTokenRevocationStorage creates a new mock instance\nfunc NewMockTokenRevocationStorage(ctrl *gomock.Controller) *MockTokenRevocationStorage {\n\tmock := &MockTokenRevocationStorage{ctrl: ctrl}\n\tmock.recorder = &MockTokenRevocationStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTokenRevocationStorage) EXPECT() *MockTokenRevocationStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// CreateRefreshTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRefreshTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// DeleteRefreshTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteRefreshTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRefreshTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n\n// GetRefreshTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRefreshTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// RevokeAccessToken mocks base method\nfunc (m *MockTokenRevocationStorage) RevokeAccessToken(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"RevokeAccessToken\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RevokeAccessToken indicates an expected call of RevokeAccessToken\nfunc (mr *MockTokenRevocationStorageMockRecorder) RevokeAccessToken(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeAccessToken\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeAccessToken), arg0, arg1)\n}\n\n// RevokeRefreshToken mocks base method\nfunc (m *MockTokenRevocationStorage) RevokeRefreshToken(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"RevokeRefreshToken\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RevokeRefreshToken indicates an expected call of RevokeRefreshToken\nfunc (mr *MockTokenRevocationStorageMockRecorder) RevokeRefreshToken(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeRefreshToken\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeRefreshToken), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockCoreStorage is a mock of CoreStorage interface\ntype MockCoreStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockCoreStorageMockRecorder\n}\n\n// MockCoreStorageMockRecorder is the mock recorder for MockCoreStorage\ntype MockCoreStorageMockRecorder struct {\n\tmock *MockCoreStorage\n}\n\n// NewMockCoreStorage creates a new mock instance\nfunc NewMockCoreStorage(ctrl *gomock.Controller) *MockCoreStorage {\n\tmock := &MockCoreStorage{ctrl: ctrl}\n\tmock.recorder = &MockCoreStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockCoreStorage) EXPECT() *MockCoreStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockCoreStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockCoreStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// CreateAuthorizeCodeSession mocks base method\nfunc (m *MockCoreStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession\nfunc (mr *MockCoreStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAuthorizeCodeSession\", reflect.TypeOf((*MockCoreStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// CreateRefreshTokenSession mocks base method\nfunc (m *MockCoreStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession\nfunc (mr *MockCoreStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRefreshTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockCoreStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockCoreStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// DeleteRefreshTokenSession mocks base method\nfunc (m *MockCoreStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteRefreshTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession\nfunc (mr *MockCoreStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRefreshTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockCoreStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockCoreStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n\n// GetAuthorizeCodeSession mocks base method\nfunc (m *MockCoreStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession\nfunc (mr *MockCoreStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAuthorizeCodeSession\", reflect.TypeOf((*MockCoreStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// GetRefreshTokenSession mocks base method\nfunc (m *MockCoreStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession\nfunc (mr *MockCoreStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRefreshTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// InvalidateAuthorizeCodeSession mocks base method\nfunc (m *MockCoreStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"InvalidateAuthorizeCodeSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession\nfunc (mr *MockCoreStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InvalidateAuthorizeCodeSession\", reflect.TypeOf((*MockCoreStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockCoreStrategy is a mock of CoreStrategy interface\ntype MockCoreStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockCoreStrategyMockRecorder\n}\n\n// MockCoreStrategyMockRecorder is the mock recorder for MockCoreStrategy\ntype MockCoreStrategyMockRecorder struct {\n\tmock *MockCoreStrategy\n}\n\n// NewMockCoreStrategy creates a new mock instance\nfunc NewMockCoreStrategy(ctrl *gomock.Controller) *MockCoreStrategy {\n\tmock := &MockCoreStrategy{ctrl: ctrl}\n\tmock.recorder = &MockCoreStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockCoreStrategy) EXPECT() *MockCoreStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// AccessTokenSignature mocks base method\nfunc (m *MockCoreStrategy) AccessTokenSignature(arg0 string) string {\n\tret := m.ctrl.Call(m, \"AccessTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AccessTokenSignature indicates an expected call of AccessTokenSignature\nfunc (mr *MockCoreStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AccessTokenSignature\", reflect.TypeOf((*MockCoreStrategy)(nil).AccessTokenSignature), arg0)\n}\n\n// AuthorizeCodeSignature mocks base method\nfunc (m *MockCoreStrategy) AuthorizeCodeSignature(arg0 string) string {\n\tret := m.ctrl.Call(m, \"AuthorizeCodeSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature\nfunc (mr *MockCoreStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AuthorizeCodeSignature\", reflect.TypeOf((*MockCoreStrategy)(nil).AuthorizeCodeSignature), arg0)\n}\n\n// GenerateAccessToken mocks base method\nfunc (m *MockCoreStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tret := m.ctrl.Call(m, \"GenerateAccessToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAccessToken indicates an expected call of GenerateAccessToken\nfunc (mr *MockCoreStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAccessToken\", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAccessToken), arg0, arg1)\n}\n\n// GenerateAuthorizeCode mocks base method\nfunc (m *MockCoreStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tret := m.ctrl.Call(m, \"GenerateAuthorizeCode\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode\nfunc (mr *MockCoreStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAuthorizeCode\", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)\n}\n\n// GenerateRefreshToken mocks base method\nfunc (m *MockCoreStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tret := m.ctrl.Call(m, \"GenerateRefreshToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateRefreshToken indicates an expected call of GenerateRefreshToken\nfunc (mr *MockCoreStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateRefreshToken\", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateRefreshToken), arg0, arg1)\n}\n\n// RefreshTokenSignature mocks base method\nfunc (m *MockCoreStrategy) RefreshTokenSignature(arg0 string) string {\n\tret := m.ctrl.Call(m, \"RefreshTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// RefreshTokenSignature indicates an expected call of RefreshTokenSignature\nfunc (mr *MockCoreStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RefreshTokenSignature\", reflect.TypeOf((*MockCoreStrategy)(nil).RefreshTokenSignature), arg0)\n}\n\n// ValidateAccessToken mocks base method\nfunc (m *MockCoreStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tret := m.ctrl.Call(m, \"ValidateAccessToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAccessToken indicates an expected call of ValidateAccessToken\nfunc (mr *MockCoreStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAccessToken\", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)\n}\n\n// ValidateAuthorizeCode mocks base method\nfunc (m *MockCoreStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tret := m.ctrl.Call(m, \"ValidateAuthorizeCode\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode\nfunc (mr *MockCoreStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAuthorizeCode\", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)\n}\n\n// ValidateRefreshToken mocks base method\nfunc (m *MockCoreStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tret := m.ctrl.Call(m, \"ValidateRefreshToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateRefreshToken indicates an expected call of ValidateRefreshToken\nfunc (mr *MockCoreStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateRefreshToken\", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectRequestStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockOpenIDConnectRequestStorage is a mock of OpenIDConnectRequestStorage interface\ntype MockOpenIDConnectRequestStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockOpenIDConnectRequestStorageMockRecorder\n}\n\n// MockOpenIDConnectRequestStorageMockRecorder is the mock recorder for MockOpenIDConnectRequestStorage\ntype MockOpenIDConnectRequestStorageMockRecorder struct {\n\tmock *MockOpenIDConnectRequestStorage\n}\n\n// NewMockOpenIDConnectRequestStorage creates a new mock instance\nfunc NewMockOpenIDConnectRequestStorage(ctrl *gomock.Controller) *MockOpenIDConnectRequestStorage {\n\tmock := &MockOpenIDConnectRequestStorage{ctrl: ctrl}\n\tmock.recorder = &MockOpenIDConnectRequestStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockOpenIDConnectRequestStorage) EXPECT() *MockOpenIDConnectRequestStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateOpenIDConnectSession mocks base method\nfunc (m *MockOpenIDConnectRequestStorage) CreateOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreateOpenIDConnectSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateOpenIDConnectSession indicates an expected call of CreateOpenIDConnectSession\nfunc (mr *MockOpenIDConnectRequestStorageMockRecorder) CreateOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateOpenIDConnectSession\", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).CreateOpenIDConnectSession), arg0, arg1, arg2)\n}\n\n// DeleteOpenIDConnectSession mocks base method\nfunc (m *MockOpenIDConnectRequestStorage) DeleteOpenIDConnectSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeleteOpenIDConnectSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteOpenIDConnectSession indicates an expected call of DeleteOpenIDConnectSession\nfunc (mr *MockOpenIDConnectRequestStorageMockRecorder) DeleteOpenIDConnectSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteOpenIDConnectSession\", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).DeleteOpenIDConnectSession), arg0, arg1)\n}\n\n// GetOpenIDConnectSession mocks base method\nfunc (m *MockOpenIDConnectRequestStorage) GetOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetOpenIDConnectSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetOpenIDConnectSession indicates an expected call of GetOpenIDConnectSession\nfunc (mr *MockOpenIDConnectRequestStorageMockRecorder) GetOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetOpenIDConnectSession\", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).GetOpenIDConnectSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/pkce (interfaces: PKCERequestStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockPKCERequestStorage is a mock of PKCERequestStorage interface\ntype MockPKCERequestStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockPKCERequestStorageMockRecorder\n}\n\n// MockPKCERequestStorageMockRecorder is the mock recorder for MockPKCERequestStorage\ntype MockPKCERequestStorageMockRecorder struct {\n\tmock *MockPKCERequestStorage\n}\n\n// NewMockPKCERequestStorage creates a new mock instance\nfunc NewMockPKCERequestStorage(ctrl *gomock.Controller) *MockPKCERequestStorage {\n\tmock := &MockPKCERequestStorage{ctrl: ctrl}\n\tmock.recorder = &MockPKCERequestStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockPKCERequestStorage) EXPECT() *MockPKCERequestStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreatePKCERequestSession mocks base method\nfunc (m *MockPKCERequestStorage) CreatePKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tret := m.ctrl.Call(m, \"CreatePKCERequestSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreatePKCERequestSession indicates an expected call of CreatePKCERequestSession\nfunc (mr *MockPKCERequestStorageMockRecorder) CreatePKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePKCERequestSession\", reflect.TypeOf((*MockPKCERequestStorage)(nil).CreatePKCERequestSession), arg0, arg1, arg2)\n}\n\n// DeletePKCERequestSession mocks base method\nfunc (m *MockPKCERequestStorage) DeletePKCERequestSession(arg0 context.Context, arg1 string) error {\n\tret := m.ctrl.Call(m, \"DeletePKCERequestSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeletePKCERequestSession indicates an expected call of DeletePKCERequestSession\nfunc (mr *MockPKCERequestStorageMockRecorder) DeletePKCERequestSession(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePKCERequestSession\", reflect.TypeOf((*MockPKCERequestStorage)(nil).DeletePKCERequestSession), arg0, arg1)\n}\n\n// GetPKCERequestSession mocks base method\nfunc (m *MockPKCERequestStorage) GetPKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tret := m.ctrl.Call(m, \"GetPKCERequestSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetPKCERequestSession indicates an expected call of GetPKCERequestSession\nfunc (mr *MockPKCERequestStorageMockRecorder) GetPKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetPKCERequestSession\", reflect.TypeOf((*MockPKCERequestStorage)(nil).GetPKCERequestSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: RefreshTokenStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockRefreshTokenStrategy is a mock of RefreshTokenStrategy interface\ntype MockRefreshTokenStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRefreshTokenStrategyMockRecorder\n}\n\n// MockRefreshTokenStrategyMockRecorder is the mock recorder for MockRefreshTokenStrategy\ntype MockRefreshTokenStrategyMockRecorder struct {\n\tmock *MockRefreshTokenStrategy\n}\n\n// NewMockRefreshTokenStrategy creates a new mock instance\nfunc NewMockRefreshTokenStrategy(ctrl *gomock.Controller) *MockRefreshTokenStrategy {\n\tmock := &MockRefreshTokenStrategy{ctrl: ctrl}\n\tmock.recorder = &MockRefreshTokenStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockRefreshTokenStrategy) EXPECT() *MockRefreshTokenStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// GenerateRefreshToken mocks base method\nfunc (m *MockRefreshTokenStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tret := m.ctrl.Call(m, \"GenerateRefreshToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateRefreshToken indicates an expected call of GenerateRefreshToken\nfunc (mr *MockRefreshTokenStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateRefreshToken\", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).GenerateRefreshToken), arg0, arg1)\n}\n\n// RefreshTokenSignature mocks base method\nfunc (m *MockRefreshTokenStrategy) RefreshTokenSignature(arg0 string) string {\n\tret := m.ctrl.Call(m, \"RefreshTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// RefreshTokenSignature indicates an expected call of RefreshTokenSignature\nfunc (mr *MockRefreshTokenStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RefreshTokenSignature\", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).RefreshTokenSignature), arg0)\n}\n\n// ValidateRefreshToken mocks base method\nfunc (m *MockRefreshTokenStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tret := m.ctrl.Call(m, \"ValidateRefreshToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateRefreshToken indicates an expected call of ValidateRefreshToken\nfunc (mr *MockRefreshTokenStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateRefreshToken\", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Requester)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\turl \"net/url\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockRequester is a mock of Requester interface\ntype MockRequester struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRequesterMockRecorder\n}\n\n// MockRequesterMockRecorder is the mock recorder for MockRequester\ntype MockRequesterMockRecorder struct {\n\tmock *MockRequester\n}\n\n// NewMockRequester creates a new mock instance\nfunc NewMockRequester(ctrl *gomock.Controller) *MockRequester {\n\tmock := &MockRequester{ctrl: ctrl}\n\tmock.recorder = &MockRequesterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockRequester) EXPECT() *MockRequesterMockRecorder {\n\treturn m.recorder\n}\n\n// AppendRequestedScope mocks base method\nfunc (m *MockRequester) AppendRequestedScope(arg0 string) {\n\tm.ctrl.Call(m, \"AppendRequestedScope\", arg0)\n}\n\n// AppendRequestedScope indicates an expected call of AppendRequestedScope\nfunc (mr *MockRequesterMockRecorder) AppendRequestedScope(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AppendRequestedScope\", reflect.TypeOf((*MockRequester)(nil).AppendRequestedScope), arg0)\n}\n\n// GetClient mocks base method\nfunc (m *MockRequester) GetClient() fosite.Client {\n\tret := m.ctrl.Call(m, \"GetClient\")\n\tret0, _ := ret[0].(fosite.Client)\n\treturn ret0\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockRequesterMockRecorder) GetClient() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockRequester)(nil).GetClient))\n}\n\n// GetGrantedAudience mocks base method\nfunc (m *MockRequester) GetGrantedAudience() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedAudience indicates an expected call of GetGrantedAudience\nfunc (mr *MockRequesterMockRecorder) GetGrantedAudience() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedAudience\", reflect.TypeOf((*MockRequester)(nil).GetGrantedAudience))\n}\n\n// GetGrantedScopes mocks base method\nfunc (m *MockRequester) GetGrantedScopes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetGrantedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedScopes indicates an expected call of GetGrantedScopes\nfunc (mr *MockRequesterMockRecorder) GetGrantedScopes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedScopes\", reflect.TypeOf((*MockRequester)(nil).GetGrantedScopes))\n}\n\n// GetID mocks base method\nfunc (m *MockRequester) GetID() string {\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockRequesterMockRecorder) GetID() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockRequester)(nil).GetID))\n}\n\n// GetRequestForm mocks base method\nfunc (m *MockRequester) GetRequestForm() url.Values {\n\tret := m.ctrl.Call(m, \"GetRequestForm\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetRequestForm indicates an expected call of GetRequestForm\nfunc (mr *MockRequesterMockRecorder) GetRequestForm() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestForm\", reflect.TypeOf((*MockRequester)(nil).GetRequestForm))\n}\n\n// GetRequestedAt mocks base method\nfunc (m *MockRequester) GetRequestedAt() time.Time {\n\tret := m.ctrl.Call(m, \"GetRequestedAt\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetRequestedAt indicates an expected call of GetRequestedAt\nfunc (mr *MockRequesterMockRecorder) GetRequestedAt() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAt\", reflect.TypeOf((*MockRequester)(nil).GetRequestedAt))\n}\n\n// GetRequestedAudience mocks base method\nfunc (m *MockRequester) GetRequestedAudience() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetRequestedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedAudience indicates an expected call of GetRequestedAudience\nfunc (mr *MockRequesterMockRecorder) GetRequestedAudience() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAudience\", reflect.TypeOf((*MockRequester)(nil).GetRequestedAudience))\n}\n\n// GetRequestedScopes mocks base method\nfunc (m *MockRequester) GetRequestedScopes() fosite.Arguments {\n\tret := m.ctrl.Call(m, \"GetRequestedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedScopes indicates an expected call of GetRequestedScopes\nfunc (mr *MockRequesterMockRecorder) GetRequestedScopes() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedScopes\", reflect.TypeOf((*MockRequester)(nil).GetRequestedScopes))\n}\n\n// GetSession mocks base method\nfunc (m *MockRequester) GetSession() fosite.Session {\n\tret := m.ctrl.Call(m, \"GetSession\")\n\tret0, _ := ret[0].(fosite.Session)\n\treturn ret0\n}\n\n// GetSession indicates an expected call of GetSession\nfunc (mr *MockRequesterMockRecorder) GetSession() *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetSession\", reflect.TypeOf((*MockRequester)(nil).GetSession))\n}\n\n// GrantAudience mocks base method\nfunc (m *MockRequester) GrantAudience(arg0 string) {\n\tm.ctrl.Call(m, \"GrantAudience\", arg0)\n}\n\n// GrantAudience indicates an expected call of GrantAudience\nfunc (mr *MockRequesterMockRecorder) GrantAudience(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantAudience\", reflect.TypeOf((*MockRequester)(nil).GrantAudience), arg0)\n}\n\n// GrantScope mocks base method\nfunc (m *MockRequester) GrantScope(arg0 string) {\n\tm.ctrl.Call(m, \"GrantScope\", arg0)\n}\n\n// GrantScope indicates an expected call of GrantScope\nfunc (mr *MockRequesterMockRecorder) GrantScope(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantScope\", reflect.TypeOf((*MockRequester)(nil).GrantScope), arg0)\n}\n\n// Merge mocks base method\nfunc (m *MockRequester) Merge(arg0 fosite.Requester) {\n\tm.ctrl.Call(m, \"Merge\", arg0)\n}\n\n// Merge indicates an expected call of Merge\nfunc (mr *MockRequesterMockRecorder) Merge(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Merge\", reflect.TypeOf((*MockRequester)(nil).Merge), arg0)\n}\n\n// Sanitize mocks base method\nfunc (m *MockRequester) Sanitize(arg0 []string) fosite.Requester {\n\tret := m.ctrl.Call(m, \"Sanitize\", arg0)\n\tret0, _ := ret[0].(fosite.Requester)\n\treturn ret0\n}\n\n// Sanitize indicates an expected call of Sanitize\nfunc (mr *MockRequesterMockRecorder) Sanitize(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sanitize\", reflect.TypeOf((*MockRequester)(nil).Sanitize), arg0)\n}\n\n// SetID mocks base method\nfunc (m *MockRequester) SetID(arg0 string) {\n\tm.ctrl.Call(m, \"SetID\", arg0)\n}\n\n// SetID indicates an expected call of SetID\nfunc (mr *MockRequesterMockRecorder) SetID(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetID\", reflect.TypeOf((*MockRequester)(nil).SetID), arg0)\n}\n\n// SetRequestedAudience mocks base method\nfunc (m *MockRequester) SetRequestedAudience(arg0 fosite.Arguments) {\n\tm.ctrl.Call(m, \"SetRequestedAudience\", arg0)\n}\n\n// SetRequestedAudience indicates an expected call of SetRequestedAudience\nfunc (mr *MockRequesterMockRecorder) SetRequestedAudience(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedAudience\", reflect.TypeOf((*MockRequester)(nil).SetRequestedAudience), arg0)\n}\n\n// SetRequestedScopes mocks base method\nfunc (m *MockRequester) SetRequestedScopes(arg0 fosite.Arguments) {\n\tm.ctrl.Call(m, \"SetRequestedScopes\", arg0)\n}\n\n// SetRequestedScopes indicates an expected call of SetRequestedScopes\nfunc (mr *MockRequesterMockRecorder) SetRequestedScopes(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedScopes\", reflect.TypeOf((*MockRequester)(nil).SetRequestedScopes), arg0)\n}\n\n// SetSession mocks base method\nfunc (m *MockRequester) SetSession(arg0 fosite.Session) {\n\tm.ctrl.Call(m, \"SetSession\", arg0)\n}\n\n// SetSession indicates an expected call of SetSession\nfunc (mr *MockRequesterMockRecorder) SetSession(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetSession\", reflect.TypeOf((*MockRequester)(nil).SetSession), arg0)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: RevocationHandler)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockRevocationHandler is a mock of RevocationHandler interface\ntype MockRevocationHandler struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRevocationHandlerMockRecorder\n}\n\n// MockRevocationHandlerMockRecorder is the mock recorder for MockRevocationHandler\ntype MockRevocationHandlerMockRecorder struct {\n\tmock *MockRevocationHandler\n}\n\n// NewMockRevocationHandler creates a new mock instance\nfunc NewMockRevocationHandler(ctrl *gomock.Controller) *MockRevocationHandler {\n\tmock := &MockRevocationHandler{ctrl: ctrl}\n\tmock.recorder = &MockRevocationHandlerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockRevocationHandler) EXPECT() *MockRevocationHandlerMockRecorder {\n\treturn m.recorder\n}\n\n// RevokeToken mocks base method\nfunc (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.Client) error {\n\tret := m.ctrl.Call(m, \"RevokeToken\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RevokeToken indicates an expected call of RevokeToken\nfunc (mr *MockRevocationHandlerMockRecorder) RevokeToken(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeToken\", reflect.TypeOf((*MockRevocationHandler)(nil).RevokeToken), arg0, arg1, arg2, arg3)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Storage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockStorage is a mock of Storage interface\ntype MockStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockStorageMockRecorder\n}\n\n// MockStorageMockRecorder is the mock recorder for MockStorage\ntype MockStorageMockRecorder struct {\n\tmock *MockStorage\n}\n\n// NewMockStorage creates a new mock instance\nfunc NewMockStorage(ctrl *gomock.Controller) *MockStorage {\n\tmock := &MockStorage{ctrl: ctrl}\n\tmock.recorder = &MockStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockStorage) EXPECT() *MockStorageMockRecorder {\n\treturn m.recorder\n}\n\n// GetClient mocks base method\nfunc (m *MockStorage) GetClient(arg0 context.Context, arg1 string) (fosite.Client, error) {\n\tret := m.ctrl.Call(m, \"GetClient\", arg0, arg1)\n\tret0, _ := ret[0].(fosite.Client)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockStorageMockRecorder) GetClient(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockStorage)(nil).GetClient), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: TokenEndpointHandler)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockTokenEndpointHandler is a mock of TokenEndpointHandler interface\ntype MockTokenEndpointHandler struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTokenEndpointHandlerMockRecorder\n}\n\n// MockTokenEndpointHandlerMockRecorder is the mock recorder for MockTokenEndpointHandler\ntype MockTokenEndpointHandlerMockRecorder struct {\n\tmock *MockTokenEndpointHandler\n}\n\n// NewMockTokenEndpointHandler creates a new mock instance\nfunc NewMockTokenEndpointHandler(ctrl *gomock.Controller) *MockTokenEndpointHandler {\n\tmock := &MockTokenEndpointHandler{ctrl: ctrl}\n\tmock.recorder = &MockTokenEndpointHandlerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTokenEndpointHandler) EXPECT() *MockTokenEndpointHandlerMockRecorder {\n\treturn m.recorder\n}\n\n// HandleTokenEndpointRequest mocks base method\nfunc (m *MockTokenEndpointHandler) HandleTokenEndpointRequest(arg0 context.Context, arg1 fosite.AccessRequester) error {\n\tret := m.ctrl.Call(m, \"HandleTokenEndpointRequest\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// HandleTokenEndpointRequest indicates an expected call of HandleTokenEndpointRequest\nfunc (mr *MockTokenEndpointHandlerMockRecorder) HandleTokenEndpointRequest(arg0, arg1 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"HandleTokenEndpointRequest\", reflect.TypeOf((*MockTokenEndpointHandler)(nil).HandleTokenEndpointRequest), arg0, arg1)\n}\n\n// PopulateTokenEndpointResponse mocks base method\nfunc (m *MockTokenEndpointHandler) PopulateTokenEndpointResponse(arg0 context.Context, arg1 fosite.AccessRequester, arg2 fosite.AccessResponder) error {\n\tret := m.ctrl.Call(m, \"PopulateTokenEndpointResponse\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// PopulateTokenEndpointResponse indicates an expected call of PopulateTokenEndpointResponse\nfunc (mr *MockTokenEndpointHandlerMockRecorder) PopulateTokenEndpointResponse(arg0, arg1, arg2 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PopulateTokenEndpointResponse\", reflect.TypeOf((*MockTokenEndpointHandler)(nil).PopulateTokenEndpointResponse), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/storage (interfaces: Transactional)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockTransactional is a mock of Transactional interface\ntype MockTransactional struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTransactionalMockRecorder\n}\n\n// MockTransactionalMockRecorder is the mock recorder for MockTransactional\ntype MockTransactionalMockRecorder struct {\n\tmock *MockTransactional\n}\n\n// NewMockTransactional creates a new mock instance\nfunc NewMockTransactional(ctrl *gomock.Controller) *MockTransactional {\n\tmock := &MockTransactional{ctrl: ctrl}\n\tmock.recorder = &MockTransactionalMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTransactional) EXPECT() *MockTransactionalMockRecorder {\n\treturn m.recorder\n}\n\n// BeginTX mocks base method\nfunc (m *MockTransactional) BeginTX(arg0 context.Context) (context.Context, error) {\n\tret := m.ctrl.Call(m, \"BeginTX\", arg0)\n\tret0, _ := ret[0].(context.Context)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// BeginTX indicates an expected call of BeginTX\nfunc (mr *MockTransactionalMockRecorder) BeginTX(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BeginTX\", reflect.TypeOf((*MockTransactional)(nil).BeginTX), arg0)\n}\n\n// Commit mocks base method\nfunc (m *MockTransactional) Commit(arg0 context.Context) error {\n\tret := m.ctrl.Call(m, \"Commit\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Commit indicates an expected call of Commit\nfunc (mr *MockTransactionalMockRecorder) Commit(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Commit\", reflect.TypeOf((*MockTransactional)(nil).Commit), arg0)\n}\n\n// Rollback mocks base method\nfunc (m *MockTransactional) Rollback(arg0 context.Context) error {\n\tret := m.ctrl.Call(m, \"Rollback\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Rollback indicates an expected call of Rollback\nfunc (mr *MockTransactionalMockRecorder) Rollback(arg0 interface{}) *gomock.Call {\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Rollback\", reflect.TypeOf((*MockTransactional)(nil).Rollback), arg0)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage storage\n\nimport (\n\t\"context\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/fosite\"\n)\n\ntype MemoryUserRelation struct {\n\tUsername string\n\tPassword string\n}\n\ntype MemoryStore struct {\n\tClients        map[string]fosite.Client\n\tAuthorizeCodes map[string]StoreAuthorizeCode\n\tIDSessions     map[string]fosite.Requester\n\tAccessTokens   map[string]fosite.Requester\n\tImplicit       map[string]fosite.Requester\n\tRefreshTokens  map[string]fosite.Requester\n\tPKCES          map[string]fosite.Requester\n\tUsers          map[string]MemoryUserRelation\n\t// In-memory request ID to token signatures\n\tAccessTokenRequestIDs  map[string]string\n\tRefreshTokenRequestIDs map[string]string\n}\n\nfunc NewMemoryStore() *MemoryStore {\n\treturn &MemoryStore{\n\t\tClients:                make(map[string]fosite.Client),\n\t\tAuthorizeCodes:         make(map[string]StoreAuthorizeCode),\n\t\tIDSessions:             make(map[string]fosite.Requester),\n\t\tAccessTokens:           make(map[string]fosite.Requester),\n\t\tImplicit:               make(map[string]fosite.Requester),\n\t\tRefreshTokens:          make(map[string]fosite.Requester),\n\t\tPKCES:                  make(map[string]fosite.Requester),\n\t\tUsers:                  make(map[string]MemoryUserRelation),\n\t\tAccessTokenRequestIDs:  make(map[string]string),\n\t\tRefreshTokenRequestIDs: make(map[string]string),\n\t}\n}\n\ntype StoreAuthorizeCode struct {\n\tactive bool\n\tfosite.Requester\n}\n\nfunc NewExampleStore() *MemoryStore {\n\treturn &MemoryStore{\n\t\tIDSessions: make(map[string]fosite.Requester),\n\t\tClients: map[string]fosite.Client{\n\t\t\t\"my-client\": &fosite.DefaultClient{\n\t\t\t\tID:            \"my-client\",\n\t\t\t\tSecret:        []byte(`$2a$10$IxMdI6d.LIRZPpSfEwNoeu4rY3FhDREsxFJXikcgdRRAStxUlsuEO`), // = \"foobar\"\n\t\t\t\tRedirectURIs:  []string{\"http://localhost:3846/callback\"},\n\t\t\t\tResponseTypes: []string{\"id_token\", \"code\", \"token\"},\n\t\t\t\tGrantTypes:    []string{\"implicit\", \"refresh_token\", \"authorization_code\", \"password\", \"client_credentials\"},\n\t\t\t\tScopes:        []string{\"fosite\", \"openid\", \"photos\", \"offline\"},\n\t\t\t},\n\t\t\t\"encoded:client\": &fosite.DefaultClient{\n\t\t\t\tID:            \"encoded:client\",\n\t\t\t\tSecret:        []byte(`$2a$10$A7M8b65dSSKGHF0H2sNkn.9Z0hT8U1Nv6OWPV3teUUaczXkVkxuDS`), // = \"encoded&password\"\n\t\t\t\tRedirectURIs:  []string{\"http://localhost:3846/callback\"},\n\t\t\t\tResponseTypes: []string{\"id_token\", \"code\", \"token\"},\n\t\t\t\tGrantTypes:    []string{\"implicit\", \"refresh_token\", \"authorization_code\", \"password\", \"client_credentials\"},\n\t\t\t\tScopes:        []string{\"fosite\", \"openid\", \"photos\", \"offline\"},\n\t\t\t},\n\t\t},\n\t\tUsers: map[string]MemoryUserRelation{\n\t\t\t\"peter\": {\n\t\t\t\t// This store simply checks for equality, a real storage implementation would obviously use\n\t\t\t\t// a hashing algorithm for encrypting the user password.\n\t\t\t\tUsername: \"peter\",\n\t\t\t\tPassword: \"secret\",\n\t\t\t},\n\t\t},\n\t\tAuthorizeCodes:         map[string]StoreAuthorizeCode{},\n\t\tImplicit:               map[string]fosite.Requester{},\n\t\tAccessTokens:           map[string]fosite.Requester{},\n\t\tRefreshTokens:          map[string]fosite.Requester{},\n\t\tPKCES:                  map[string]fosite.Requester{},\n\t\tAccessTokenRequestIDs:  map[string]string{},\n\t\tRefreshTokenRequestIDs: map[string]string{},\n\t}\n}\n\nfunc (s *MemoryStore) CreateOpenIDConnectSession(_ context.Context, authorizeCode string, requester fosite.Requester) error {\n\ts.IDSessions[authorizeCode] = requester\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetOpenIDConnectSession(_ context.Context, authorizeCode string, requester fosite.Requester) (fosite.Requester, error) {\n\tcl, ok := s.IDSessions[authorizeCode]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn cl, nil\n}\n\nfunc (s *MemoryStore) DeleteOpenIDConnectSession(_ context.Context, authorizeCode string) error {\n\tdelete(s.IDSessions, authorizeCode)\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetClient(_ context.Context, id string) (fosite.Client, error) {\n\tcl, ok := s.Clients[id]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn cl, nil\n}\n\nfunc (s *MemoryStore) CreateAuthorizeCodeSession(_ context.Context, code string, req fosite.Requester) error {\n\ts.AuthorizeCodes[code] = StoreAuthorizeCode{active: true, Requester: req}\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetAuthorizeCodeSession(_ context.Context, code string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.AuthorizeCodes[code]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\tif !rel.active {\n\t\treturn rel, fosite.ErrInvalidatedAuthorizeCode\n\t}\n\n\treturn rel.Requester, nil\n}\n\nfunc (s *MemoryStore) InvalidateAuthorizeCodeSession(ctx context.Context, code string) error {\n\trel, ok := s.AuthorizeCodes[code]\n\tif !ok {\n\t\treturn fosite.ErrNotFound\n\t}\n\trel.active = false\n\ts.AuthorizeCodes[code] = rel\n\treturn nil\n}\n\nfunc (s *MemoryStore) DeleteAuthorizeCodeSession(_ context.Context, code string) error {\n\tdelete(s.AuthorizeCodes, code)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreatePKCERequestSession(_ context.Context, code string, req fosite.Requester) error {\n\ts.PKCES[code] = req\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetPKCERequestSession(_ context.Context, code string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.PKCES[code]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn rel, nil\n}\n\nfunc (s *MemoryStore) DeletePKCERequestSession(_ context.Context, code string) error {\n\tdelete(s.PKCES, code)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreateAccessTokenSession(_ context.Context, signature string, req fosite.Requester) error {\n\ts.AccessTokens[signature] = req\n\ts.AccessTokenRequestIDs[req.GetID()] = signature\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetAccessTokenSession(_ context.Context, signature string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.AccessTokens[signature]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn rel, nil\n}\n\nfunc (s *MemoryStore) DeleteAccessTokenSession(_ context.Context, signature string) error {\n\tdelete(s.AccessTokens, signature)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreateRefreshTokenSession(_ context.Context, signature string, req fosite.Requester) error {\n\ts.RefreshTokens[signature] = req\n\ts.RefreshTokenRequestIDs[req.GetID()] = signature\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetRefreshTokenSession(_ context.Context, signature string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.RefreshTokens[signature]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn rel, nil\n}\n\nfunc (s *MemoryStore) DeleteRefreshTokenSession(_ context.Context, signature string) error {\n\tdelete(s.RefreshTokens, signature)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreateImplicitAccessTokenSession(_ context.Context, code string, req fosite.Requester) error {\n\ts.Implicit[code] = req\n\treturn nil\n}\n\nfunc (s *MemoryStore) Authenticate(_ context.Context, name string, secret string) error {\n\trel, ok := s.Users[name]\n\tif !ok {\n\t\treturn fosite.ErrNotFound\n\t}\n\tif rel.Password != secret {\n\t\treturn errors.New(\"Invalid credentials\")\n\t}\n\treturn nil\n}\n\nfunc (s *MemoryStore) RevokeRefreshToken(ctx context.Context, requestID string) error {\n\tif signature, exists := s.RefreshTokenRequestIDs[requestID]; exists {\n\t\ts.DeleteRefreshTokenSession(ctx, signature)\n\t\ts.DeleteAccessTokenSession(ctx, signature)\n\t}\n\treturn nil\n}\n\nfunc (s *MemoryStore) RevokeAccessToken(ctx context.Context, requestID string) error {\n\tif signature, exists := s.AccessTokenRequestIDs[requestID]; exists {\n\t\ts.DeleteAccessTokenSession(ctx, signature)\n\t}\n\treturn nil\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @Copyright \t2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"context\"\n\t\"crypto/rsa\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/pkg/errors\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n)\n\nconst clientAssertionJWTBearerType = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n\nfunc (f *Fosite) findClientPublicJWK(oidcClient OpenIDConnectClient, t *jwt.Token) (interface{}, error) {\n\tif set := oidcClient.GetJSONWebKeys(); set != nil {\n\t\treturn findPublicKey(t, set)\n\t}\n\n\tif location := oidcClient.GetJSONWebKeysURI(); len(location) > 0 {\n\t\tkeys, err := f.JWKSFetcherStrategy.Resolve(location, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif key, err := findPublicKey(t, keys); err == nil {\n\t\t\treturn key, nil\n\t\t}\n\n\t\tkeys, err = f.JWKSFetcherStrategy.Resolve(location, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn findPublicKey(t, keys)\n\t}\n\n\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"The OAuth 2.0 Client has no JSON Web Keys set registered, but they are needed to complete the request.\"))\n}\n\nfunc (f *Fosite) AuthenticateClient(ctx context.Context, r *http.Request, form url.Values) (Client, error) {\n\tif assertionType := form.Get(\"client_assertion_type\"); assertionType == clientAssertionJWTBearerType {\n\t\tassertion := form.Get(\"client_assertion\")\n\t\tif len(assertion) == 0 {\n\t\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"The client_assertion request parameter must be set when using client_assertion_type of \\\"%s\\\".\", clientAssertionJWTBearerType))\n\t\t}\n\n\t\tvar clientID string\n\t\tvar client Client\n\n\t\ttoken, err := jwt.ParseWithClaims(assertion, new(jwt.MapClaims), func(t *jwt.Token) (interface{}, error) {\n\t\t\tvar err error\n\t\t\tclientID, _, err = clientCredentialsFromRequestBody(form, false)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif clientID == \"\" {\n\t\t\t\tif claims, ok := t.Claims.(*jwt.MapClaims); !ok {\n\t\t\t\t\treturn nil, errors.WithStack(ErrRequestUnauthorized.WithHint(\"Unable to type assert claims from client_assertion.\").WithDebugf(`Expected claims to be of type \"*jwt.MapClaims\" but got \"%T\".`, t.Claims))\n\t\t\t\t} else if sub, ok := (*claims)[\"sub\"].(string); !ok {\n\t\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(`The claim \"sub\" from the client_assertion JSON Web Token is undefined.`))\n\t\t\t\t} else {\n\t\t\t\t\tclientID = sub\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient, err = f.Store.GetClient(ctx, clientID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithDebug(err.Error()))\n\t\t\t}\n\n\t\t\toidcClient, ok := client.(OpenIDConnectClient)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHint(\"The server configuration does not support OpenID Connect specific authentication methods.\"))\n\t\t\t}\n\n\t\t\tswitch oidcClient.GetTokenEndpointAuthMethod() {\n\t\t\tcase \"client_secret_post\":\n\t\t\t\tfallthrough\n\t\t\tcase \"client_secret_basic\":\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Request uses the \\\"client_secret_jwt\\\" authentication method, but the OAuth 2.0 Client only supports the \\\"%s\\\" client authentication method. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"client_secret_jwt\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t\t\tcase \"client_secret_jwt\":\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"This requested OAuth 2.0 client only supports client authentication method \\\"client_secret_jwt\\\", however that method is not supported by this server.\"))\n\t\t\tcase \"private_key_jwt\":\n\t\t\t}\n\n\t\t\tif oidcClient.GetTokenEndpointAuthSigningAlgorithm() != fmt.Sprintf(\"%s\", t.Header[\"alg\"]) {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(`The \"client_assertion\"\" uses signing algorithm \"%s\", but the requested OAuth 2.0 Client enforces signing algorithm \"%s\".`, t.Header[\"alg\"], oidcClient.GetTokenEndpointAuthSigningAlgorithm()))\n\t\t\t}\n\n\t\t\tif _, ok := t.Method.(*jwt.SigningMethodRSA); ok {\n\t\t\t\treturn f.findClientPublicJWK(oidcClient, t)\n\t\t\t} else if _, ok := t.Method.(*jwt.SigningMethodECDSA); ok {\n\t\t\t\treturn f.findClientPublicJWK(oidcClient, t)\n\t\t\t} else if _, ok := t.Method.(*jwt.SigningMethodRSAPSS); ok {\n\t\t\t\treturn f.findClientPublicJWK(oidcClient, t)\n\t\t\t} else if _, ok := t.Method.(*jwt.SigningMethodHMAC); ok {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"This authorization server does not support client authentication method \\\"client_secret_jwt\\\".\"))\n\t\t\t}\n\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The client_assertion request parameter uses unsupported signing algorithm \\\"%s\\\".\", t.Header[\"alg\"]))\n\t\t})\n\t\tif err != nil {\n\t\t\t// Do not re-process already enhanced errors\n\t\t\tif e, ok := errors.Cause(err).(*jwt.ValidationError); ok {\n\t\t\t\tif e.Inner != nil {\n\t\t\t\t\treturn nil, e.Inner\n\t\t\t\t}\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Unable to verify the integrity of the \\\"client_assertion\\\" value.\").WithDebug(err.Error()))\n\t\t\t}\n\t\t\treturn nil, err\n\t\t} else if err := token.Claims.Valid(); err != nil {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Unable to verify the request object because its claims could not be validated, check if the expiry time is set correctly.\").WithDebug(err.Error()))\n\t\t}\n\n\t\tclaims, ok := token.Claims.(*jwt.MapClaims)\n\t\tif !ok {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Unable to type assert claims from request parameter \\\"client_assertion\\\".\").WithDebugf(`Got claims of type %T but expected type \"*jwt.MapClaims\".`, token.Claims))\n\t\t}\n\n\t\tvar jti string\n\t\tif !claims.VerifyIssuer(clientID, true) {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Claim \\\"iss\\\" from \\\"client_assertion\\\" must match the \\\"client_id\\\" of the OAuth 2.0 Client.\"))\n\t\t} else if f.TokenURL == \"\" {\n\t\t\treturn nil, errors.WithStack(ErrMisconfiguration.WithHint(\"The authorization server's token endpoint URL has not been set.\"))\n\t\t} else if sub, ok := (*claims)[\"sub\"].(string); !ok || sub != clientID {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Claim \\\"sub\\\" from \\\"client_assertion\\\" must match the \\\"client_id\\\" of the OAuth 2.0 Client.\"))\n\t\t} else if jti, ok = (*claims)[\"jti\"].(string); !ok || len(jti) == 0 {\n\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHint(\"Claim \\\"jti\\\" from \\\"client_assertion\\\" must be set but is not.\"))\n\t\t} else if f.Store.ClientAssertionJWTValid(context.Background(), jti) != nil {\n\t\t\treturn nil, errors.WithStack(ErrJTIKnown.WithHint(\"Claim \\\"jti\\\" from \\\"client_assertion\\\" MUST only be used once.\"))\n\t\t}\n\n\t\t// type conversion according to jwt.MapClaims.VerifyExpiresAt\n\t\tvar expiry int64\n\t\terr = nil\n\t\tswitch exp := (*claims)[\"exp\"].(type) {\n\t\tcase float64:\n\t\t\texpiry = int64(exp)\n\t\tcase json.Number:\n\t\t\texpiry, err = exp.Int64()\n\t\tdefault:\n\t\t\terr = ErrInvalidClient.WithHint(\"Unable to type assert the expiry time from claims. This should not happen as we validate the expiry time already earlier with token.Claims.Valid()\")\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, errors.WithStack(err)\n\t\t}\n\t\tif err := f.Store.SetClientAssertionJWT(context.Background(), jti, time.Unix(expiry, 0)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif auds, ok := (*claims)[\"aud\"].([]interface{}); !ok {\n\t\t\tif !claims.VerifyAudience(f.TokenURL, true) {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"Claim \\\"audience\\\" from \\\"client_assertion\\\" must match the authorization server's token endpoint \\\"%s\\\".\", f.TokenURL))\n\t\t\t}\n\t\t} else {\n\t\t\tvar found bool\n\t\t\tfor _, aud := range auds {\n\t\t\t\tif a, ok := aud.(string); ok && a == f.TokenURL {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !found {\n\t\t\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"Claim \\\"audience\\\" from \\\"client_assertion\\\" must match the authorization server's token endpoint \\\"%s\\\".\", f.TokenURL))\n\t\t\t}\n\t\t}\n\n\t\treturn client, nil\n\t} else if len(assertionType) > 0 {\n\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"Unknown client_assertion_type \\\"%s\\\".\", assertionType))\n\t}\n\n\tclientID, clientSecret, err := clientCredentialsFromRequest(r, form)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient, err := f.Store.GetClient(ctx, clientID)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithDebug(err.Error()))\n\t}\n\n\tif oidcClient, ok := client.(OpenIDConnectClient); !ok {\n\t\t// If this isn't an OpenID Connect client then we actually don't care about any of this, just continue!\n\t} else if ok && form.Get(\"client_id\") != \"\" && form.Get(\"client_secret\") != \"\" && oidcClient.GetTokenEndpointAuthMethod() != \"client_secret_post\" {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Client supports client authentication method \\\"%s\\\", but method \\\"client_secret_post\\\" was requested. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"client_secret_post\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t} else if _, _, basicOk := r.BasicAuth(); basicOk && ok && oidcClient.GetTokenEndpointAuthMethod() != \"client_secret_basic\" {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Client supports client authentication method \\\"%s\\\", but method \\\"client_secret_basic\\\" was requested. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"client_secret_basic\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t} else if ok && oidcClient.GetTokenEndpointAuthMethod() != \"none\" && client.IsPublic() {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithHintf(\"The OAuth 2.0 Client supports client authentication method \\\"%s\\\", but method \\\"none\\\" was requested. You must configure the OAuth 2.0 client's \\\"token_endpoint_auth_method\\\" value to accept \\\"none\\\".\", oidcClient.GetTokenEndpointAuthMethod()))\n\t}\n\n\tif client.IsPublic() {\n\t\treturn client, nil\n\t}\n\n\t// Enforce client authentication\n\tif err := f.Hasher.Compare(ctx, client.GetHashedSecret(), []byte(clientSecret)); err != nil {\n\t\treturn nil, errors.WithStack(ErrInvalidClient.WithDebug(err.Error()))\n\t}\n\n\treturn client, nil\n}\n\nfunc findPublicKey(t *jwt.Token, set *jose.JSONWebKeySet) (*rsa.PublicKey, error) {\n\tkid, ok := t.Header[\"kid\"].(string)\n\tif !ok {\n\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHint(\"The JSON Web Token must contain a kid header value but did not.\"))\n\t}\n\n\tkeys := set.Key(kid)\n\tif len(keys) == 0 {\n\t\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"The JSON Web Token uses signing key with kid \\\"%s\\\", which could not be found.\", kid))\n\t}\n\n\tfor _, key := range keys {\n\t\tif key.Use != \"sig\" {\n\t\t\tcontinue\n\t\t}\n\t\tif k, ok := key.Key.(*rsa.PublicKey); ok {\n\t\t\treturn k, nil\n\t\t}\n\t}\n\n\treturn nil, errors.WithStack(ErrInvalidRequest.WithHintf(\"Unable to find RSA public key with use=\\\"sig\\\" for kid \\\"%s\\\" in JSON Web Key Set.\", kid))\n}\n\nfunc clientCredentialsFromRequest(r *http.Request, form url.Values) (clientID, clientSecret string, err error) {\n\tif id, secret, ok := r.BasicAuth(); !ok {\n\t\treturn clientCredentialsFromRequestBody(form, true)\n\t} else if clientID, err = url.QueryUnescape(id); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client id in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t} else if clientSecret, err = url.QueryUnescape(secret); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client secret in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t}\n\n\treturn clientID, clientSecret, nil\n}\n\nfunc clientCredentialsFromRequestBody(form url.Values, forceID bool) (clientID, clientSecret string, err error) {\n\tclientID = form.Get(\"client_id\")\n\tclientSecret = form.Get(\"client_secret\")\n\n\tif clientID == \"\" && forceID {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(\"Client credentials missing or malformed in both HTTP Authorization header and HTTP POST body.\"))\n\t}\n\n\tif clientID, err = url.QueryUnescape(clientID); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client id in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t} else if clientSecret, err = url.QueryUnescape(clientSecret); err != nil {\n\t\treturn \"\", \"\", errors.WithStack(ErrInvalidRequest.WithHint(`The client secret in the HTTP authorization header could not be decoded from \"application/x-www-form-urlencoded\".`).WithDebug(err.Error()))\n\t}\n\n\treturn clientID, clientSecret, nil\n}\n", "/*\n * Copyright \u00a9 2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @Copyright \t2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite_test\n\nimport (\n\t\"context\"\n\t\"crypto/rsa\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tjose \"gopkg.in/square/go-jose.v2\"\n\n\t. \"github.com/ory/fosite\"\n\t\"github.com/ory/fosite/internal\"\n\t\"github.com/ory/fosite/storage\"\n)\n\nfunc mustGenerateAssertion(t *testing.T, claims jwt.MapClaims, key *rsa.PrivateKey, kid string) string {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)\n\ttoken.Header[\"kid\"] = kid\n\ttokenString, err := token.SignedString(key)\n\trequire.NoError(t, err)\n\treturn tokenString\n}\n\nfunc mustGenerateHSAssertion(t *testing.T, claims jwt.MapClaims, key *rsa.PrivateKey, kid string) string {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString([]byte(\"aaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccddddddddddddddddddddddd\"))\n\trequire.NoError(t, err)\n\treturn tokenString\n}\n\nfunc mustGenerateNoneAssertion(t *testing.T, claims jwt.MapClaims, key *rsa.PrivateKey, kid string) string {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodNone, claims)\n\ttokenString, err := token.SignedString(jwt.UnsafeAllowNoneSignatureType)\n\trequire.NoError(t, err)\n\treturn tokenString\n}\n\nfunc TestAuthenticateClient(t *testing.T) {\n\tconst at = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n\n\thasher := &BCrypt{WorkFactor: 6}\n\tf := &Fosite{\n\t\tJWKSFetcherStrategy: NewDefaultJWKSFetcherStrategy(),\n\t\tStore:               storage.NewMemoryStore(),\n\t\tHasher:              hasher,\n\t\tTokenURL:            \"token-url\",\n\t}\n\n\tbarSecret, err := hasher.Hash(context.TODO(), []byte(\"bar\"))\n\trequire.NoError(t, err)\n\n\tkey := internal.MustRSAKey()\n\tjwks := &jose.JSONWebKeySet{\n\t\tKeys: []jose.JSONWebKey{\n\t\t\t{\n\t\t\t\tKeyID: \"kid-foo\",\n\t\t\t\tUse:   \"sig\",\n\t\t\t\tKey:   &key.PublicKey,\n\t\t\t},\n\t\t},\n\t}\n\n\tvar h http.HandlerFunc\n\th = func(w http.ResponseWriter, r *http.Request) {\n\t\trequire.NoError(t, json.NewEncoder(w).Encode(jwks))\n\t}\n\tts := httptest.NewServer(h)\n\tdefer ts.Close()\n\n\tfor k, tc := range []struct {\n\t\td             string\n\t\tclient        *DefaultOpenIDConnectClient\n\t\tassertionType string\n\t\tassertion     string\n\t\tr             *http.Request\n\t\tform          url.Values\n\t\texpectErr     error\n\t}{\n\t\t{\n\t\t\td:         \"should fail because authentication can not be determined\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\"}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client does not exist\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Public: true}, TokenEndpointAuthMethod: \"none\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"bar\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass because client is public and authentication requirements are met\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Public: true}, TokenEndpointAuthMethod: \"none\"},\n\t\t\tform:   url.Values{\"client_id\": []string{\"foo\"}},\n\t\t\tr:      new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because auth method is not none\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Public: true}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass because client is confidential and id and secret match in post body\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:   url.Values{\"client_id\": []string{\"foo\"}, \"client_secret\": []string{\"bar\"}},\n\t\t\tr:      new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and secret does not match in post body\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_secret\": []string{\"baz\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and id does not exist in post body\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_secret\": []string{\"bar\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass because client is confidential and id and secret match in header\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:   url.Values{},\n\t\t\tr:      &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:bar\"))}}},\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because auth method is not client_secret_basic\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_post\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:bar\"))}}},\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and secret does not match in header\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:baz\"))}}},\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client id is not encoded using application/x-www-form-urlencoded\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"%%%%%%:foo\"))}}},\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client secret is not encoded using application/x-www-form-urlencoded\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:%%%%%%%\"))}}},\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client is confidential and id does not exist in header\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, TokenEndpointAuthMethod: \"client_secret_basic\"},\n\t\t\tform:      url.Values{},\n\t\t\tr:         &http.Request{Header: http.Header{\"Authorization\": {\"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"foo:bar\"))}}},\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client_assertion but client_assertion is missing\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:         \"should fail because client_assertion_type is unknown\",\n\t\t\tclient:    &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"foo\", Secret: barSecret}, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform:      url.Values{\"client_id\": []string{\"foo\"}, \"client_assertion_type\": []string{\"foobar\"}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidRequest,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs are set within the client and client_id is not set in the request\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because token auth method is not private_key_jwt\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"client_secret_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs are set within the client and client_id is not set in the request (aud is array)\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": []string{\"token-url-2\", \"token-url\"},\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because audience (array) does not match token url\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": []string{\"token-url-1\", \"token-url-2\"},\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs are set within the client\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because JWT algorithm is HS256\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateHSAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because JWT algorithm is none\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateNoneAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should pass with proper assertion when JWKs URI is set\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeysURI: ts.URL, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr: new(http.Request),\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion sub does not match client\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"not-bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion iss does not match client\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"not-bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion jti is not set\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"aud\": \"token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t\t{\n\t\t\td:      \"should fail because client_assertion aud is not set\",\n\t\t\tclient: &DefaultOpenIDConnectClient{DefaultClient: &DefaultClient{ID: \"bar\", Secret: barSecret}, JSONWebKeys: jwks, TokenEndpointAuthMethod: \"private_key_jwt\"},\n\t\t\tform: url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\t\t\"sub\": \"bar\",\n\t\t\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\t\t\"iss\": \"bar\",\n\t\t\t\t\"jti\": \"12345\",\n\t\t\t\t\"aud\": \"not-token-url\",\n\t\t\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}},\n\t\t\tr:         new(http.Request),\n\t\t\texpectErr: ErrInvalidClient,\n\t\t},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"case=%d/description=%s\", k, tc.d), func(t *testing.T) {\n\t\t\tstore := storage.NewMemoryStore()\n\t\t\tstore.Clients[tc.client.ID] = tc.client\n\t\t\tf.Store = store\n\n\t\t\tc, err := f.AuthenticateClient(nil, tc.r, tc.form)\n\t\t\tif tc.expectErr != nil {\n\t\t\t\trequire.EqualError(t, err, tc.expectErr.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tswitch e := errors.Cause(err).(type) {\n\t\t\t\tcase *jwt.ValidationError:\n\t\t\t\t\tt.Logf(\"Error is: %s\", e.Inner)\n\t\t\t\tcase *RFC6749Error:\n\t\t\t\t\tt.Logf(\"Debug is: %s\", e.Debug)\n\t\t\t\t}\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.EqualValues(t, tc.client, c)\n\t\t})\n\t}\n}\n\nfunc TestAuthenticateClientTwice(t *testing.T) {\n\tconst at = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n\n\tkey := internal.MustRSAKey()\n\tclient := &DefaultOpenIDConnectClient{\n\t\tDefaultClient: &DefaultClient{\n\t\t\tID:     \"bar\",\n\t\t\tSecret: []byte(\"secret\"),\n\t\t},\n\t\tJSONWebKeys: &jose.JSONWebKeySet{\n\t\t\tKeys: []jose.JSONWebKey{\n\t\t\t\t{\n\t\t\t\t\tKeyID: \"kid-foo\",\n\t\t\t\t\tUse:   \"sig\",\n\t\t\t\t\tKey:   &key.PublicKey,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tTokenEndpointAuthMethod: \"private_key_jwt\",\n\t}\n\tstore := storage.NewMemoryStore()\n\tstore.Clients[client.ID] = client\n\n\thasher := &BCrypt{WorkFactor: 6}\n\tf := &Fosite{\n\t\tJWKSFetcherStrategy: NewDefaultJWKSFetcherStrategy(),\n\t\tStore:               store,\n\t\tHasher:              hasher,\n\t\tTokenURL:            \"token-url\",\n\t}\n\n\tformValues := url.Values{\"client_id\": []string{\"bar\"}, \"client_assertion\": {mustGenerateAssertion(t, jwt.MapClaims{\n\t\t\"sub\": \"bar\",\n\t\t\"exp\": time.Now().Add(time.Hour).Unix(),\n\t\t\"iss\": \"bar\",\n\t\t\"jti\": \"12345\",\n\t\t\"aud\": \"token-url\",\n\t}, key, \"kid-foo\")}, \"client_assertion_type\": []string{at}}\n\n\tc, err := f.AuthenticateClient(nil, new(http.Request), formValues)\n\trequire.NoError(t, err, \"%#v\", err)\n\tassert.Equal(t, client, c)\n\n\t// replay the request and expect it to fail\n\tc, err = f.AuthenticateClient(nil, new(http.Request), formValues)\n\trequire.Error(t, err)\n\tassert.EqualError(t, err, ErrJTIKnown.Error())\n\tassert.Nil(t, c)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n// ClientManager defines the (persistent) manager interface for clients.\ntype ClientManager interface {\n\t// GetClient loads the client by its ID or returns an error\n\t// if the client does not exist or another error occurred.\n\tGetClient(ctx context.Context, id string) (Client, error)\n\t// ClientAssertionJWTValid returns an error if the JTI is\n\t// known or the DB check failed and nil if the JTI is not known.\n\tClientAssertionJWTValid(ctx context.Context, jti string) error\n\t// SetClientAssertionJWT marks a JTI as known for the given\n\t// expiry time. Before inserting the new JTI, it will clean\n\t// up any existing JTIs that have expired as those tokens can\n\t// not be replayed due to the expiry.\n\tSetClientAssertionJWT(ctx context.Context, jti string, exp time.Time) error\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage fosite\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\nvar (\n\t// ErrInvalidatedAuthorizeCode is an error indicating that an authorization code has been\n\t// used previously.\n\tErrInvalidatedAuthorizeCode = errors.New(\"Authorization code has ben invalidated\")\n\t// ErrSerializationFailure is an error indicating that the transactional capable storage could not guarantee\n\t// consistency of Update & Delete operations on the same rows between multiple sessions.\n\tErrSerializationFailure = errors.New(\"The request could not be completed due to concurrent access\")\n\tErrUnknownRequest       = &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The handler is not responsible for this request\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestForbidden = &RFC6749Error{\n\t\tName:        errRequestForbidden,\n\t\tDescription: \"The request is not allowed\",\n\t\tHint:        \"You are not allowed to perform this action.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrInvalidRequest = &RFC6749Error{\n\t\tName:        errInvalidRequestName,\n\t\tDescription: \"The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed\",\n\t\tHint:        \"Make sure that the various parameters are correct, be aware of case sensitivity and trim your parameters. Make sure that the client you are using has exactly whitelisted the redirect_uri you specified.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrUnauthorizedClient = &RFC6749Error{\n\t\tName:        errUnauthorizedClientName,\n\t\tDescription: \"The client is not authorized to request a token using this method\",\n\t\tHint:        \"Make sure that client id and secret are correctly specified and that the client exists.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrAccessDenied = &RFC6749Error{\n\t\tName:        errAccessDeniedName,\n\t\tDescription: \"The resource owner or authorization server denied the request\",\n\t\tHint:        \"Make sure that the request you are making is valid. Maybe the credential or request parameters you are using are limited in scope or otherwise restricted.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrUnsupportedResponseType = &RFC6749Error{\n\t\tName:        errUnsupportedResponseTypeName,\n\t\tDescription: \"The authorization server does not support obtaining a token using this method\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidScope = &RFC6749Error{\n\t\tName:        errInvalidScopeName,\n\t\tDescription: \"The requested scope is invalid, unknown, or malformed\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrServerError = &RFC6749Error{\n\t\tName:        errServerErrorName,\n\t\tDescription: \"The authorization server encountered an unexpected condition that prevented it from fulfilling the request\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrTemporarilyUnavailable = &RFC6749Error{\n\t\tName:        errTemporarilyUnavailableName,\n\t\tDescription: \"The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server\",\n\t\tCode:        http.StatusServiceUnavailable,\n\t}\n\tErrUnsupportedGrantType = &RFC6749Error{\n\t\tName:        errUnsupportedGrantTypeName,\n\t\tDescription: \"The authorization grant type is not supported by the authorization server\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidGrant = &RFC6749Error{\n\t\tName:        errInvalidGrantName,\n\t\tDescription: \"The provided authorization grant (e.g., authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidClient = &RFC6749Error{\n\t\tName:        errInvalidClientName,\n\t\tDescription: \"Client authentication failed (e.g., unknown client, no client authentication included, or unsupported authentication method)\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInvalidState = &RFC6749Error{\n\t\tName:        errInvalidStateName,\n\t\tDescription: fmt.Sprintf(\"The state is missing or has less than %d characters and is therefore considered too weak\", MinParameterEntropy),\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrMisconfiguration = &RFC6749Error{\n\t\tName:        errMisconfigurationName,\n\t\tDescription: \"The request failed because of an internal error that is probably caused by misconfiguration\",\n\t\tCode:        http.StatusInternalServerError,\n\t}\n\tErrInsufficientEntropy = &RFC6749Error{\n\t\tName:        errInsufficientEntropyName,\n\t\tDescription: fmt.Sprintf(\"The request used a security parameter (e.g., anti-replay, anti-csrf) with insufficient entropy (minimum of %d characters)\", MinParameterEntropy),\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrNotFound = &RFC6749Error{\n\t\tName:        errNotFoundName,\n\t\tDescription: \"Could not find the requested resource(s)\",\n\t\tCode:        http.StatusNotFound,\n\t}\n\tErrRequestUnauthorized = &RFC6749Error{\n\t\tName:        errRequestUnauthorizedName,\n\t\tDescription: \"The request could not be authorized\",\n\t\tHint:        \"Check that you provided valid credentials in the right format.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrTokenSignatureMismatch = &RFC6749Error{\n\t\tName:        errTokenSignatureMismatchName,\n\t\tDescription: \"Token signature mismatch\",\n\t\tHint:        \"Check that you provided  a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidTokenFormat = &RFC6749Error{\n\t\tName:        errInvalidTokenFormatName,\n\t\tDescription: \"Invalid token format\",\n\t\tHint:        \"Check that you provided a valid token in the right format.\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrTokenExpired = &RFC6749Error{\n\t\tName:        errTokenExpiredName,\n\t\tDescription: \"Token expired\",\n\t\tHint:        \"The token expired.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrScopeNotGranted = &RFC6749Error{\n\t\tName:        errScopeNotGrantedName,\n\t\tDescription: \"The token was not granted the requested scope\",\n\t\tHint:        \"The resource owner did not grant the requested scope.\",\n\t\tCode:        http.StatusForbidden,\n\t}\n\tErrTokenClaim = &RFC6749Error{\n\t\tName:        errTokenClaimName,\n\t\tDescription: \"The token failed validation due to a claim mismatch\",\n\t\tHint:        \"One or more token claims failed validation.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrInactiveToken = &RFC6749Error{\n\t\tName:        errTokenInactiveName,\n\t\tDescription: \"Token is inactive because it is malformed, expired or otherwise invalid\",\n\t\tHint:        \"Token validation failed.\",\n\t\tCode:        http.StatusUnauthorized,\n\t}\n\tErrRevokationClientMismatch = &RFC6749Error{\n\t\tName:        errRevokationClientMismatchName,\n\t\tDescription: \"Token was not issued to the client making the revokation request\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrLoginRequired = &RFC6749Error{\n\t\tName:        errLoginRequired,\n\t\tDescription: \"The Authorization Server requires End-User authentication\",\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInteractionRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User interaction of some form to proceed\",\n\t\tName:        errInteractionRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrConsentRequired = &RFC6749Error{\n\t\tDescription: \"The Authorization Server requires End-User consent\",\n\t\tName:        errConsentRequired,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request parameter\",\n\t\tName:        errRequestNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRequestURINotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the request_uri parameter\",\n\t\tName:        errRequestURINotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrRegistrationNotSupported = &RFC6749Error{\n\t\tDescription: \"The OP does not support use of the registration parameter\",\n\t\tName:        errRegistrationNotSupportedName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestURI = &RFC6749Error{\n\t\tDescription: \"The request_uri in the Authorization Request returns an error or contains invalid data. \",\n\t\tName:        errInvalidRequestURI,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrInvalidRequestObject = &RFC6749Error{\n\t\tDescription: \"The request parameter contains an invalid Request Object. \",\n\t\tName:        errInvalidRequestObject,\n\t\tCode:        http.StatusBadRequest,\n\t}\n\tErrJTIKnown = &RFC6749Error{\n\t\tDescription: \"The jti was already used.\",\n\t\tName:        errJTIKnownName,\n\t\tCode:        http.StatusBadRequest,\n\t}\n)\n\nconst (\n\terrInvalidRequestURI            = \"invalid_request_uri\"\n\terrInvalidRequestObject         = \"invalid_request_object\"\n\terrConsentRequired              = \"consent_required\"\n\terrInteractionRequired          = \"interaction_required\"\n\terrLoginRequired                = \"login_required\"\n\terrRequestUnauthorizedName      = \"request_unauthorized\"\n\terrRequestForbidden             = \"request_forbidden\"\n\terrInvalidRequestName           = \"invalid_request\"\n\terrUnauthorizedClientName       = \"unauthorized_client\"\n\terrAccessDeniedName             = \"access_denied\"\n\terrUnsupportedResponseTypeName  = \"unsupported_response_type\"\n\terrInvalidScopeName             = \"invalid_scope\"\n\terrServerErrorName              = \"server_error\"\n\terrTemporarilyUnavailableName   = \"temporarily_unavailable\"\n\terrUnsupportedGrantTypeName     = \"unsupported_grant_type\"\n\terrInvalidGrantName             = \"invalid_grant\"\n\terrInvalidClientName            = \"invalid_client\"\n\terrNotFoundName                 = \"not_found\"\n\terrInvalidStateName             = \"invalid_state\"\n\terrMisconfigurationName         = \"misconfiguration\"\n\terrInsufficientEntropyName      = \"insufficient_entropy\"\n\terrInvalidTokenFormatName       = \"invalid_token\"\n\terrTokenSignatureMismatchName   = \"token_signature_mismatch\"\n\terrTokenExpiredName             = \"token_expired\"\n\terrScopeNotGrantedName          = \"scope_not_granted\"\n\terrTokenClaimName               = \"token_claim\"\n\terrTokenInactiveName            = \"token_inactive\"\n\terrAuthorizaionCodeInactiveName = \"authorization_code_inactive\"\n\terrUnknownErrorName             = \"error\"\n\terrRevokationClientMismatchName = \"revokation_client_mismatch\"\n\terrRequestNotSupportedName      = \"request_not_supported\"\n\terrRequestURINotSupportedName   = \"request_uri_not_supported\"\n\terrRegistrationNotSupportedName = \"registration_not_supported\"\n\terrJTIKnownName                 = \"jti_known\"\n)\n\nfunc ErrorToRFC6749Error(err error) *RFC6749Error {\n\tif e, ok := err.(*RFC6749Error); ok {\n\t\treturn e\n\t} else if e, ok := errors.Cause(err).(*RFC6749Error); ok {\n\t\treturn e\n\t}\n\treturn &RFC6749Error{\n\t\tName:        errUnknownErrorName,\n\t\tDescription: \"The error is unrecognizable.\",\n\t\tDebug:       err.Error(),\n\t\tCode:        http.StatusInternalServerError,\n\t}\n}\n\ntype RFC6749Error struct {\n\tName        string `json:\"error\"`\n\tDescription string `json:\"error_description\"`\n\tHint        string `json:\"error_hint,omitempty\"`\n\tCode        int    `json:\"status_code,omitempty\"`\n\tDebug       string `json:\"error_debug,omitempty\"`\n}\n\nfunc (e *RFC6749Error) Status() string {\n\treturn http.StatusText(e.Code)\n}\n\nfunc (e *RFC6749Error) Error() string {\n\treturn e.Name\n}\n\nfunc (e *RFC6749Error) RequestID() string {\n\treturn \"\"\n}\n\nfunc (e *RFC6749Error) Reason() string {\n\treturn e.Hint\n}\n\nfunc (e *RFC6749Error) StatusCode() int {\n\treturn e.Code\n}\n\nfunc (e *RFC6749Error) WithHintf(hint string, args ...interface{}) *RFC6749Error {\n\treturn e.WithHint(fmt.Sprintf(hint, args...))\n}\n\nfunc (e *RFC6749Error) WithHint(hint string) *RFC6749Error {\n\terr := *e\n\terr.Hint = hint\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebug(debug string) *RFC6749Error {\n\terr := *e\n\terr.Debug = debug\n\treturn &err\n}\n\nfunc (e *RFC6749Error) WithDebugf(debug string, args ...interface{}) *RFC6749Error {\n\treturn e.WithDebug(fmt.Sprintf(debug, args...))\n}\n\nfunc (e *RFC6749Error) WithDescription(description string) *RFC6749Error {\n\terr := *e\n\terr.Description = description\n\treturn &err\n}\n", "module github.com/ory/fosite\n\nrequire (\n\tgithub.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dgrijalva/jwt-go v3.2.0+incompatible\n\tgithub.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 // indirect\n\tgithub.com/golang/mock v1.4.3\n\tgithub.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f // indirect\n\tgithub.com/gorilla/context v1.1.1 // indirect\n\tgithub.com/gorilla/mux v1.6.2\n\tgithub.com/jtolds/gls v4.2.1+incompatible // indirect\n\tgithub.com/magiconair/properties v1.8.0\n\tgithub.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826\n\tgithub.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b // indirect\n\tgithub.com/oleiade/reflections v1.0.0\n\tgithub.com/ory/go-convenience v0.1.0\n\tgithub.com/parnurzeal/gorequest v0.2.15\n\tgithub.com/pborman/uuid v1.2.0\n\tgithub.com/pkg/errors v0.8.0\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d // indirect\n\tgithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a // indirect\n\tgithub.com/stretchr/testify v1.2.2\n\tgolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2\n\tgolang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced\n\tgoogle.golang.org/appengine v1.2.0 // indirect\n\tgopkg.in/square/go-jose.v2 v2.1.9\n)\n\ngo 1.13\n", "github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf h1:eg0MeVzsP1G42dRafH3vf+al2vQIJU0YHX+1Tw87oco=\ngithub.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 h1:LCoguo7Zd0MByKMbQbTvcZw7HiBcbvew+MOcwsJVwrY=\ngithub.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5/go.mod h1:/Zj4wYkgs4iZTTu3o/KG3Itv/qCCa8VVMlb3i9OVuzc=\ngithub.com/golang/mock v1.1.1 h1:G5FRp8JnTd7RQH5kemVNlMeyXQAztQ3mOWV95KxsXH8=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.4.3 h1:GV+pQPG/EUUbkh47niozDcADz6go/dUwhVzdUQHIVRw=\ngithub.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/protobuf v1.2.0 h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/google/uuid v1.0.0 h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=\ngithub.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f h1:JJ2EP5vV3LAD2U1CxQtD7PTOO15Y96kXmKDz7TjxGHs=\ngithub.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/mux v1.6.2 h1:Pgr17XVTNXAk3q/r4CpKzC5xBM/qW1uVLV+IhRZpIIk=\ngithub.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/jtolds/gls v4.2.1+incompatible h1:fSuqC+Gmlu6l/ZYAoZzx2pyucC8Xza35fpRVWLVmUEE=\ngithub.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/magiconair/properties v1.8.0 h1:LLgXmsheXeRoUOBOjtwPQCWIYqM/LU1ayDtDePerRcY=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826 h1:RWengNIwukTxcDr9M+97sNutRR1RKhG96O6jWumTTnw=\ngithub.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826/go.mod h1:TaXosZuwdSHYgviHp1DAtfrULt5eUgsSMsZf+YrPgl8=\ngithub.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b h1:Pip12xNtMvEFUBF4f8/b5yRXj94LLrNdLWELfOr2KcY=\ngithub.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=\ngithub.com/oleiade/reflections v1.0.0 h1:0ir4pc6v8/PJ0yw5AEtMddfXpWBXg9cnG7SgSoJuCgY=\ngithub.com/oleiade/reflections v1.0.0/go.mod h1:RbATFBbKYkVdqmSFtx13Bb/tVhR0lgOBXunWTZKeL4w=\ngithub.com/ory/go-convenience v0.1.0 h1:zouLKfF2GoSGnJwGq+PE/nJAE6dj2Zj5QlTgmMTsTS8=\ngithub.com/ory/go-convenience v0.1.0/go.mod h1:uEY/a60PL5c12nYz4V5cHY03IBmwIAEm8TWB0yn9KNs=\ngithub.com/parnurzeal/gorequest v0.2.15 h1:oPjDCsF5IkD4gUk6vIgsxYNaSgvAnIh1EJeROn3HdJU=\ngithub.com/parnurzeal/gorequest v0.2.15/go.mod h1:3Kh2QUMJoqw3icWAecsyzkpY7UzRfDhbRdTjtNwNiUE=\ngithub.com/pborman/uuid v1.2.0 h1:J7Q5mO4ysT1dv8hyrUGHb9+ooztCXu1D8MY8DZYsu3g=\ngithub.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=\ngithub.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a h1:JSvGDIbmil4Ui/dDdFBExb7/cmkNjyX5F97oglmvCDo=\ngithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngolang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4 h1:Vk3wNqEZwyGyei9yq5ekj7frek2u7HUfffJ1/opblzc=\ngolang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2 h1:VklqNMn3ovrHsnt90PveolxSbWFaJdECFbxSq0Mqo2M=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181005035420-146acd28ed58 h1:otZG8yDCO4LVps5+9bxOeNiCvgmOyt96J3roHTYs7oE=\ngolang.org/x/net v0.0.0-20181005035420-146acd28ed58/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a h1:oWX7TPOiFAMXLq8o0ikBYfCJVlRHBcsciT5bXOrH628=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced h1:4oqSq7eft7MdPKBGQK11X9WYUxmj6ZLgGTqYIbY1kyw=\ngolang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f h1:wMNYb4v58l5UBM7MYRLPG6ZhfOqbKu7X5eyFl8ZhKvA=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262 h1:qsl9y/CJx34tuA7QCPNp86JNJe4spst6Ff8MjvPUdPg=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngoogle.golang.org/appengine v1.2.0 h1:S0iUepdCWODXRvtE+gcRDd15L+k+k1AiHlMiMjefH24=\ngoogle.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngopkg.in/square/go-jose.v2 v2.1.9 h1:YCFbL5T2gbmC2sMG12s1x2PAlTK5TZNte3hjZEIcCAg=\ngopkg.in/square/go-jose.v2 v2.1.9/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage oauth2\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/fosite\"\n\t\"github.com/ory/fosite/storage\"\n)\n\ntype RefreshTokenGrantHandler struct {\n\tAccessTokenStrategy    AccessTokenStrategy\n\tRefreshTokenStrategy   RefreshTokenStrategy\n\tTokenRevocationStorage TokenRevocationStorage\n\n\t// AccessTokenLifespan defines the lifetime of an access token.\n\tAccessTokenLifespan time.Duration\n\n\t// RefreshTokenLifespan defines the lifetime of a refresh token.\n\tRefreshTokenLifespan time.Duration\n\n\tScopeStrategy            fosite.ScopeStrategy\n\tAudienceMatchingStrategy fosite.AudienceMatchingStrategy\n\tRefreshTokenScopes       []string\n}\n\n// HandleTokenEndpointRequest implements https://tools.ietf.org/html/rfc6749#section-6\nfunc (c *RefreshTokenGrantHandler) HandleTokenEndpointRequest(ctx context.Context, request fosite.AccessRequester) error {\n\t// grant_type REQUIRED.\n\t// Value MUST be set to \"refresh_token\".\n\tif !request.GetGrantTypes().ExactOne(\"refresh_token\") {\n\t\treturn errors.WithStack(fosite.ErrUnknownRequest)\n\t}\n\n\tif !request.GetClient().GetGrantTypes().Has(\"refresh_token\") {\n\t\treturn errors.WithStack(fosite.ErrInvalidGrant.WithHint(\"The OAuth 2.0 Client is not allowed to use authorization grant \\\"refresh_token\\\".\"))\n\t}\n\n\trefresh := request.GetRequestForm().Get(\"refresh_token\")\n\tsignature := c.RefreshTokenStrategy.RefreshTokenSignature(refresh)\n\toriginalRequest, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, request.GetSession())\n\tif errors.Cause(err) == fosite.ErrNotFound {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))\n\t} else if err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t} else if err := c.RefreshTokenStrategy.ValidateRefreshToken(ctx, originalRequest, refresh); err != nil {\n\t\t// The authorization server MUST ... validate the refresh token.\n\t\t// This needs to happen after store retrieval for the session to be hydrated properly\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))\n\t}\n\n\tif !(len(c.RefreshTokenScopes) == 0 || originalRequest.GetGrantedScopes().HasOneOf(c.RefreshTokenScopes...)) {\n\t\tscopeNames := strings.Join(c.RefreshTokenScopes, \" or \")\n\t\thint := fmt.Sprintf(\"The OAuth 2.0 Client was not granted scope %s and may thus not perform the \\\"refresh_token\\\" authorization grant.\", scopeNames)\n\t\treturn errors.WithStack(fosite.ErrScopeNotGranted.WithHint(hint))\n\n\t}\n\n\t// The authorization server MUST ... and ensure that the refresh token was issued to the authenticated client\n\tif originalRequest.GetClient().GetID() != request.GetClient().GetID() {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.WithHint(\"The OAuth 2.0 Client ID from this request does not match the ID during the initial token issuance.\"))\n\t}\n\n\trequest.SetSession(originalRequest.GetSession().Clone())\n\trequest.SetRequestedScopes(originalRequest.GetRequestedScopes())\n\trequest.SetRequestedAudience(originalRequest.GetRequestedAudience())\n\n\tfor _, scope := range originalRequest.GetGrantedScopes() {\n\t\tif !c.ScopeStrategy(request.GetClient().GetScopes(), scope) {\n\t\t\treturn errors.WithStack(fosite.ErrInvalidScope.WithHintf(\"The OAuth 2.0 Client is not allowed to request scope \\\"%s\\\".\", scope))\n\t\t}\n\t\trequest.GrantScope(scope)\n\t}\n\n\tif err := c.AudienceMatchingStrategy(request.GetClient().GetAudience(), originalRequest.GetGrantedAudience()); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, audience := range originalRequest.GetGrantedAudience() {\n\t\trequest.GrantAudience(audience)\n\t}\n\n\trequest.GetSession().SetExpiresAt(fosite.AccessToken, time.Now().UTC().Add(c.AccessTokenLifespan).Round(time.Second))\n\tif c.RefreshTokenLifespan > -1 {\n\t\trequest.GetSession().SetExpiresAt(fosite.RefreshToken, time.Now().UTC().Add(c.RefreshTokenLifespan).Round(time.Second))\n\t}\n\n\treturn nil\n}\n\n// PopulateTokenEndpointResponse implements https://tools.ietf.org/html/rfc6749#section-6\nfunc (c *RefreshTokenGrantHandler) PopulateTokenEndpointResponse(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) error {\n\tif !requester.GetGrantTypes().ExactOne(\"refresh_token\") {\n\t\treturn errors.WithStack(fosite.ErrUnknownRequest)\n\t}\n\n\taccessToken, accessSignature, err := c.AccessTokenStrategy.GenerateAccessToken(ctx, requester)\n\tif err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t}\n\n\trefreshToken, refreshSignature, err := c.RefreshTokenStrategy.GenerateRefreshToken(ctx, requester)\n\tif err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t}\n\n\tsignature := c.RefreshTokenStrategy.RefreshTokenSignature(requester.GetRequestForm().Get(\"refresh_token\"))\n\n\tctx, err = storage.MaybeBeginTx(ctx, c.TokenRevocationStorage)\n\tif err != nil {\n\t\treturn errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))\n\t}\n\n\tts, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)\n\tif err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t} else if err := c.TokenRevocationStorage.RevokeAccessToken(ctx, ts.GetID()); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t} else if err := c.TokenRevocationStorage.RevokeRefreshToken(ctx, ts.GetID()); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t}\n\n\tstoreReq := requester.Sanitize([]string{})\n\tstoreReq.SetID(ts.GetID())\n\n\tif err := c.TokenRevocationStorage.CreateAccessTokenSession(ctx, accessSignature, storeReq); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t}\n\n\tif err := c.TokenRevocationStorage.CreateRefreshTokenSession(ctx, refreshSignature, storeReq); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)\n\t}\n\n\tresponder.SetAccessToken(accessToken)\n\tresponder.SetTokenType(\"bearer\")\n\tresponder.SetExpiresIn(getExpiresIn(requester, fosite.AccessToken, c.AccessTokenLifespan, time.Now().UTC()))\n\tresponder.SetScopes(requester.GetGrantedScopes())\n\tresponder.SetExtra(\"refresh_token\", refreshToken)\n\n\tif err := storage.MaybeCommitTx(ctx, c.TokenRevocationStorage); err != nil {\n\t\treturn handleRefreshTokenEndpointResponseStorageError(ctx, false, c.TokenRevocationStorage, err)\n\t}\n\n\treturn nil\n}\n\nfunc handleRefreshTokenEndpointResponseStorageError(ctx context.Context, rollback bool, store TokenRevocationStorage, storageErr error) (err error) {\n\tdefer func() {\n\t\tif rollback {\n\t\t\tif rbErr := storage.MaybeRollbackTx(ctx, store); rbErr != nil {\n\t\t\t\terr = errors.WithStack(fosite.ErrServerError.WithDebug(rbErr.Error()))\n\t\t\t}\n\t\t}\n\t}()\n\n\tif errors.Cause(storageErr) == fosite.ErrSerializationFailure {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.\n\t\t\tWithDebugf(storageErr.Error()).\n\t\t\tWithHint(\"Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.\"))\n\t}\n\n\tif errors.Cause(storageErr) == fosite.ErrNotFound {\n\t\treturn errors.WithStack(fosite.ErrInvalidRequest.\n\t\t\tWithDebugf(storageErr.Error()).\n\t\t\tWithHint(\"Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.\"))\n\t}\n\n\treturn errors.WithStack(fosite.ErrServerError.WithDebug(storageErr.Error()))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AccessRequester)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\turl \"net/url\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessRequester is a mock of AccessRequester interface\ntype MockAccessRequester struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessRequesterMockRecorder\n}\n\n// MockAccessRequesterMockRecorder is the mock recorder for MockAccessRequester\ntype MockAccessRequesterMockRecorder struct {\n\tmock *MockAccessRequester\n}\n\n// NewMockAccessRequester creates a new mock instance\nfunc NewMockAccessRequester(ctrl *gomock.Controller) *MockAccessRequester {\n\tmock := &MockAccessRequester{ctrl: ctrl}\n\tmock.recorder = &MockAccessRequesterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessRequester) EXPECT() *MockAccessRequesterMockRecorder {\n\treturn m.recorder\n}\n\n// AppendRequestedScope mocks base method\nfunc (m *MockAccessRequester) AppendRequestedScope(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AppendRequestedScope\", arg0)\n}\n\n// AppendRequestedScope indicates an expected call of AppendRequestedScope\nfunc (mr *MockAccessRequesterMockRecorder) AppendRequestedScope(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AppendRequestedScope\", reflect.TypeOf((*MockAccessRequester)(nil).AppendRequestedScope), arg0)\n}\n\n// GetClient mocks base method\nfunc (m *MockAccessRequester) GetClient() fosite.Client {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetClient\")\n\tret0, _ := ret[0].(fosite.Client)\n\treturn ret0\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockAccessRequesterMockRecorder) GetClient() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockAccessRequester)(nil).GetClient))\n}\n\n// GetGrantTypes mocks base method\nfunc (m *MockAccessRequester) GetGrantTypes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantTypes indicates an expected call of GetGrantTypes\nfunc (mr *MockAccessRequesterMockRecorder) GetGrantTypes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantTypes\", reflect.TypeOf((*MockAccessRequester)(nil).GetGrantTypes))\n}\n\n// GetGrantedAudience mocks base method\nfunc (m *MockAccessRequester) GetGrantedAudience() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedAudience indicates an expected call of GetGrantedAudience\nfunc (mr *MockAccessRequesterMockRecorder) GetGrantedAudience() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedAudience\", reflect.TypeOf((*MockAccessRequester)(nil).GetGrantedAudience))\n}\n\n// GetGrantedScopes mocks base method\nfunc (m *MockAccessRequester) GetGrantedScopes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedScopes indicates an expected call of GetGrantedScopes\nfunc (mr *MockAccessRequesterMockRecorder) GetGrantedScopes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedScopes\", reflect.TypeOf((*MockAccessRequester)(nil).GetGrantedScopes))\n}\n\n// GetID mocks base method\nfunc (m *MockAccessRequester) GetID() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockAccessRequesterMockRecorder) GetID() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockAccessRequester)(nil).GetID))\n}\n\n// GetRequestForm mocks base method\nfunc (m *MockAccessRequester) GetRequestForm() url.Values {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestForm\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetRequestForm indicates an expected call of GetRequestForm\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestForm() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestForm\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestForm))\n}\n\n// GetRequestedAt mocks base method\nfunc (m *MockAccessRequester) GetRequestedAt() time.Time {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedAt\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetRequestedAt indicates an expected call of GetRequestedAt\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestedAt() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAt\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestedAt))\n}\n\n// GetRequestedAudience mocks base method\nfunc (m *MockAccessRequester) GetRequestedAudience() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedAudience indicates an expected call of GetRequestedAudience\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestedAudience() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAudience\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestedAudience))\n}\n\n// GetRequestedScopes mocks base method\nfunc (m *MockAccessRequester) GetRequestedScopes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedScopes indicates an expected call of GetRequestedScopes\nfunc (mr *MockAccessRequesterMockRecorder) GetRequestedScopes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedScopes\", reflect.TypeOf((*MockAccessRequester)(nil).GetRequestedScopes))\n}\n\n// GetSession mocks base method\nfunc (m *MockAccessRequester) GetSession() fosite.Session {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetSession\")\n\tret0, _ := ret[0].(fosite.Session)\n\treturn ret0\n}\n\n// GetSession indicates an expected call of GetSession\nfunc (mr *MockAccessRequesterMockRecorder) GetSession() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetSession\", reflect.TypeOf((*MockAccessRequester)(nil).GetSession))\n}\n\n// GrantAudience mocks base method\nfunc (m *MockAccessRequester) GrantAudience(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"GrantAudience\", arg0)\n}\n\n// GrantAudience indicates an expected call of GrantAudience\nfunc (mr *MockAccessRequesterMockRecorder) GrantAudience(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantAudience\", reflect.TypeOf((*MockAccessRequester)(nil).GrantAudience), arg0)\n}\n\n// GrantScope mocks base method\nfunc (m *MockAccessRequester) GrantScope(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"GrantScope\", arg0)\n}\n\n// GrantScope indicates an expected call of GrantScope\nfunc (mr *MockAccessRequesterMockRecorder) GrantScope(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantScope\", reflect.TypeOf((*MockAccessRequester)(nil).GrantScope), arg0)\n}\n\n// Merge mocks base method\nfunc (m *MockAccessRequester) Merge(arg0 fosite.Requester) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Merge\", arg0)\n}\n\n// Merge indicates an expected call of Merge\nfunc (mr *MockAccessRequesterMockRecorder) Merge(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Merge\", reflect.TypeOf((*MockAccessRequester)(nil).Merge), arg0)\n}\n\n// Sanitize mocks base method\nfunc (m *MockAccessRequester) Sanitize(arg0 []string) fosite.Requester {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Sanitize\", arg0)\n\tret0, _ := ret[0].(fosite.Requester)\n\treturn ret0\n}\n\n// Sanitize indicates an expected call of Sanitize\nfunc (mr *MockAccessRequesterMockRecorder) Sanitize(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sanitize\", reflect.TypeOf((*MockAccessRequester)(nil).Sanitize), arg0)\n}\n\n// SetID mocks base method\nfunc (m *MockAccessRequester) SetID(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetID\", arg0)\n}\n\n// SetID indicates an expected call of SetID\nfunc (mr *MockAccessRequesterMockRecorder) SetID(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetID\", reflect.TypeOf((*MockAccessRequester)(nil).SetID), arg0)\n}\n\n// SetRequestedAudience mocks base method\nfunc (m *MockAccessRequester) SetRequestedAudience(arg0 fosite.Arguments) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetRequestedAudience\", arg0)\n}\n\n// SetRequestedAudience indicates an expected call of SetRequestedAudience\nfunc (mr *MockAccessRequesterMockRecorder) SetRequestedAudience(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedAudience\", reflect.TypeOf((*MockAccessRequester)(nil).SetRequestedAudience), arg0)\n}\n\n// SetRequestedScopes mocks base method\nfunc (m *MockAccessRequester) SetRequestedScopes(arg0 fosite.Arguments) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetRequestedScopes\", arg0)\n}\n\n// SetRequestedScopes indicates an expected call of SetRequestedScopes\nfunc (mr *MockAccessRequesterMockRecorder) SetRequestedScopes(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedScopes\", reflect.TypeOf((*MockAccessRequester)(nil).SetRequestedScopes), arg0)\n}\n\n// SetSession mocks base method\nfunc (m *MockAccessRequester) SetSession(arg0 fosite.Session) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetSession\", arg0)\n}\n\n// SetSession indicates an expected call of SetSession\nfunc (mr *MockAccessRequesterMockRecorder) SetSession(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetSession\", reflect.TypeOf((*MockAccessRequester)(nil).SetSession), arg0)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AccessResponder)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessResponder is a mock of AccessResponder interface\ntype MockAccessResponder struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessResponderMockRecorder\n}\n\n// MockAccessResponderMockRecorder is the mock recorder for MockAccessResponder\ntype MockAccessResponderMockRecorder struct {\n\tmock *MockAccessResponder\n}\n\n// NewMockAccessResponder creates a new mock instance\nfunc NewMockAccessResponder(ctrl *gomock.Controller) *MockAccessResponder {\n\tmock := &MockAccessResponder{ctrl: ctrl}\n\tmock.recorder = &MockAccessResponderMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessResponder) EXPECT() *MockAccessResponderMockRecorder {\n\treturn m.recorder\n}\n\n// GetAccessToken mocks base method\nfunc (m *MockAccessResponder) GetAccessToken() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAccessToken\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetAccessToken indicates an expected call of GetAccessToken\nfunc (mr *MockAccessResponderMockRecorder) GetAccessToken() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessToken\", reflect.TypeOf((*MockAccessResponder)(nil).GetAccessToken))\n}\n\n// GetExtra mocks base method\nfunc (m *MockAccessResponder) GetExtra(arg0 string) interface{} {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetExtra\", arg0)\n\tret0, _ := ret[0].(interface{})\n\treturn ret0\n}\n\n// GetExtra indicates an expected call of GetExtra\nfunc (mr *MockAccessResponderMockRecorder) GetExtra(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetExtra\", reflect.TypeOf((*MockAccessResponder)(nil).GetExtra), arg0)\n}\n\n// GetTokenType mocks base method\nfunc (m *MockAccessResponder) GetTokenType() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetTokenType\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetTokenType indicates an expected call of GetTokenType\nfunc (mr *MockAccessResponderMockRecorder) GetTokenType() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetTokenType\", reflect.TypeOf((*MockAccessResponder)(nil).GetTokenType))\n}\n\n// SetAccessToken mocks base method\nfunc (m *MockAccessResponder) SetAccessToken(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetAccessToken\", arg0)\n}\n\n// SetAccessToken indicates an expected call of SetAccessToken\nfunc (mr *MockAccessResponderMockRecorder) SetAccessToken(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetAccessToken\", reflect.TypeOf((*MockAccessResponder)(nil).SetAccessToken), arg0)\n}\n\n// SetExpiresIn mocks base method\nfunc (m *MockAccessResponder) SetExpiresIn(arg0 time.Duration) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetExpiresIn\", arg0)\n}\n\n// SetExpiresIn indicates an expected call of SetExpiresIn\nfunc (mr *MockAccessResponderMockRecorder) SetExpiresIn(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetExpiresIn\", reflect.TypeOf((*MockAccessResponder)(nil).SetExpiresIn), arg0)\n}\n\n// SetExtra mocks base method\nfunc (m *MockAccessResponder) SetExtra(arg0 string, arg1 interface{}) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetExtra\", arg0, arg1)\n}\n\n// SetExtra indicates an expected call of SetExtra\nfunc (mr *MockAccessResponderMockRecorder) SetExtra(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetExtra\", reflect.TypeOf((*MockAccessResponder)(nil).SetExtra), arg0, arg1)\n}\n\n// SetScopes mocks base method\nfunc (m *MockAccessResponder) SetScopes(arg0 fosite.Arguments) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetScopes\", arg0)\n}\n\n// SetScopes indicates an expected call of SetScopes\nfunc (mr *MockAccessResponderMockRecorder) SetScopes(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetScopes\", reflect.TypeOf((*MockAccessResponder)(nil).SetScopes), arg0)\n}\n\n// SetTokenType mocks base method\nfunc (m *MockAccessResponder) SetTokenType(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetTokenType\", arg0)\n}\n\n// SetTokenType indicates an expected call of SetTokenType\nfunc (mr *MockAccessResponderMockRecorder) SetTokenType(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetTokenType\", reflect.TypeOf((*MockAccessResponder)(nil).SetTokenType), arg0)\n}\n\n// ToMap mocks base method\nfunc (m *MockAccessResponder) ToMap() map[string]interface{} {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ToMap\")\n\tret0, _ := ret[0].(map[string]interface{})\n\treturn ret0\n}\n\n// ToMap indicates an expected call of ToMap\nfunc (mr *MockAccessResponderMockRecorder) ToMap() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ToMap\", reflect.TypeOf((*MockAccessResponder)(nil).ToMap))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessTokenStorage is a mock of AccessTokenStorage interface\ntype MockAccessTokenStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessTokenStorageMockRecorder\n}\n\n// MockAccessTokenStorageMockRecorder is the mock recorder for MockAccessTokenStorage\ntype MockAccessTokenStorageMockRecorder struct {\n\tmock *MockAccessTokenStorage\n}\n\n// NewMockAccessTokenStorage creates a new mock instance\nfunc NewMockAccessTokenStorage(ctrl *gomock.Controller) *MockAccessTokenStorage {\n\tmock := &MockAccessTokenStorage{ctrl: ctrl}\n\tmock.recorder = &MockAccessTokenStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessTokenStorage) EXPECT() *MockAccessTokenStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockAccessTokenStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockAccessTokenStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockAccessTokenStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockAccessTokenStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockAccessTokenStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockAccessTokenStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockAccessTokenStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockAccessTokenStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockAccessTokenStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAccessTokenStrategy is a mock of AccessTokenStrategy interface\ntype MockAccessTokenStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAccessTokenStrategyMockRecorder\n}\n\n// MockAccessTokenStrategyMockRecorder is the mock recorder for MockAccessTokenStrategy\ntype MockAccessTokenStrategyMockRecorder struct {\n\tmock *MockAccessTokenStrategy\n}\n\n// NewMockAccessTokenStrategy creates a new mock instance\nfunc NewMockAccessTokenStrategy(ctrl *gomock.Controller) *MockAccessTokenStrategy {\n\tmock := &MockAccessTokenStrategy{ctrl: ctrl}\n\tmock.recorder = &MockAccessTokenStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAccessTokenStrategy) EXPECT() *MockAccessTokenStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// AccessTokenSignature mocks base method\nfunc (m *MockAccessTokenStrategy) AccessTokenSignature(arg0 string) string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AccessTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AccessTokenSignature indicates an expected call of AccessTokenSignature\nfunc (mr *MockAccessTokenStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AccessTokenSignature\", reflect.TypeOf((*MockAccessTokenStrategy)(nil).AccessTokenSignature), arg0)\n}\n\n// GenerateAccessToken mocks base method\nfunc (m *MockAccessTokenStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GenerateAccessToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAccessToken indicates an expected call of GenerateAccessToken\nfunc (mr *MockAccessTokenStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAccessToken\", reflect.TypeOf((*MockAccessTokenStrategy)(nil).GenerateAccessToken), arg0, arg1)\n}\n\n// ValidateAccessToken mocks base method\nfunc (m *MockAccessTokenStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ValidateAccessToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAccessToken indicates an expected call of ValidateAccessToken\nfunc (mr *MockAccessTokenStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAccessToken\", reflect.TypeOf((*MockAccessTokenStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeCodeStorage is a mock of AuthorizeCodeStorage interface\ntype MockAuthorizeCodeStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeCodeStorageMockRecorder\n}\n\n// MockAuthorizeCodeStorageMockRecorder is the mock recorder for MockAuthorizeCodeStorage\ntype MockAuthorizeCodeStorageMockRecorder struct {\n\tmock *MockAuthorizeCodeStorage\n}\n\n// NewMockAuthorizeCodeStorage creates a new mock instance\nfunc NewMockAuthorizeCodeStorage(ctrl *gomock.Controller) *MockAuthorizeCodeStorage {\n\tmock := &MockAuthorizeCodeStorage{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeCodeStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeCodeStorage) EXPECT() *MockAuthorizeCodeStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAuthorizeCodeSession mocks base method\nfunc (m *MockAuthorizeCodeStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession\nfunc (mr *MockAuthorizeCodeStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAuthorizeCodeSession\", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// GetAuthorizeCodeSession mocks base method\nfunc (m *MockAuthorizeCodeStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession\nfunc (mr *MockAuthorizeCodeStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAuthorizeCodeSession\", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// InvalidateAuthorizeCodeSession mocks base method\nfunc (m *MockAuthorizeCodeStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"InvalidateAuthorizeCodeSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession\nfunc (mr *MockAuthorizeCodeStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InvalidateAuthorizeCodeSession\", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeCodeStrategy is a mock of AuthorizeCodeStrategy interface\ntype MockAuthorizeCodeStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeCodeStrategyMockRecorder\n}\n\n// MockAuthorizeCodeStrategyMockRecorder is the mock recorder for MockAuthorizeCodeStrategy\ntype MockAuthorizeCodeStrategyMockRecorder struct {\n\tmock *MockAuthorizeCodeStrategy\n}\n\n// NewMockAuthorizeCodeStrategy creates a new mock instance\nfunc NewMockAuthorizeCodeStrategy(ctrl *gomock.Controller) *MockAuthorizeCodeStrategy {\n\tmock := &MockAuthorizeCodeStrategy{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeCodeStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeCodeStrategy) EXPECT() *MockAuthorizeCodeStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// AuthorizeCodeSignature mocks base method\nfunc (m *MockAuthorizeCodeStrategy) AuthorizeCodeSignature(arg0 string) string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AuthorizeCodeSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature\nfunc (mr *MockAuthorizeCodeStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AuthorizeCodeSignature\", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).AuthorizeCodeSignature), arg0)\n}\n\n// GenerateAuthorizeCode mocks base method\nfunc (m *MockAuthorizeCodeStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GenerateAuthorizeCode\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode\nfunc (mr *MockAuthorizeCodeStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAuthorizeCode\", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)\n}\n\n// ValidateAuthorizeCode mocks base method\nfunc (m *MockAuthorizeCodeStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ValidateAuthorizeCode\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode\nfunc (mr *MockAuthorizeCodeStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAuthorizeCode\", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AuthorizeEndpointHandler)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeEndpointHandler is a mock of AuthorizeEndpointHandler interface\ntype MockAuthorizeEndpointHandler struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeEndpointHandlerMockRecorder\n}\n\n// MockAuthorizeEndpointHandlerMockRecorder is the mock recorder for MockAuthorizeEndpointHandler\ntype MockAuthorizeEndpointHandlerMockRecorder struct {\n\tmock *MockAuthorizeEndpointHandler\n}\n\n// NewMockAuthorizeEndpointHandler creates a new mock instance\nfunc NewMockAuthorizeEndpointHandler(ctrl *gomock.Controller) *MockAuthorizeEndpointHandler {\n\tmock := &MockAuthorizeEndpointHandler{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeEndpointHandlerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeEndpointHandler) EXPECT() *MockAuthorizeEndpointHandlerMockRecorder {\n\treturn m.recorder\n}\n\n// HandleAuthorizeEndpointRequest mocks base method\nfunc (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 context.Context, arg1 fosite.AuthorizeRequester, arg2 fosite.AuthorizeResponder) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"HandleAuthorizeEndpointRequest\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// HandleAuthorizeEndpointRequest indicates an expected call of HandleAuthorizeEndpointRequest\nfunc (mr *MockAuthorizeEndpointHandlerMockRecorder) HandleAuthorizeEndpointRequest(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"HandleAuthorizeEndpointRequest\", reflect.TypeOf((*MockAuthorizeEndpointHandler)(nil).HandleAuthorizeEndpointRequest), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AuthorizeRequester)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\turl \"net/url\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockAuthorizeRequester is a mock of AuthorizeRequester interface\ntype MockAuthorizeRequester struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeRequesterMockRecorder\n}\n\n// MockAuthorizeRequesterMockRecorder is the mock recorder for MockAuthorizeRequester\ntype MockAuthorizeRequesterMockRecorder struct {\n\tmock *MockAuthorizeRequester\n}\n\n// NewMockAuthorizeRequester creates a new mock instance\nfunc NewMockAuthorizeRequester(ctrl *gomock.Controller) *MockAuthorizeRequester {\n\tmock := &MockAuthorizeRequester{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeRequesterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeRequester) EXPECT() *MockAuthorizeRequesterMockRecorder {\n\treturn m.recorder\n}\n\n// AppendRequestedScope mocks base method\nfunc (m *MockAuthorizeRequester) AppendRequestedScope(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AppendRequestedScope\", arg0)\n}\n\n// AppendRequestedScope indicates an expected call of AppendRequestedScope\nfunc (mr *MockAuthorizeRequesterMockRecorder) AppendRequestedScope(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AppendRequestedScope\", reflect.TypeOf((*MockAuthorizeRequester)(nil).AppendRequestedScope), arg0)\n}\n\n// DidHandleAllResponseTypes mocks base method\nfunc (m *MockAuthorizeRequester) DidHandleAllResponseTypes() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DidHandleAllResponseTypes\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// DidHandleAllResponseTypes indicates an expected call of DidHandleAllResponseTypes\nfunc (mr *MockAuthorizeRequesterMockRecorder) DidHandleAllResponseTypes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DidHandleAllResponseTypes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).DidHandleAllResponseTypes))\n}\n\n// GetClient mocks base method\nfunc (m *MockAuthorizeRequester) GetClient() fosite.Client {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetClient\")\n\tret0, _ := ret[0].(fosite.Client)\n\treturn ret0\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetClient() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetClient))\n}\n\n// GetGrantedAudience mocks base method\nfunc (m *MockAuthorizeRequester) GetGrantedAudience() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedAudience indicates an expected call of GetGrantedAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetGrantedAudience() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetGrantedAudience))\n}\n\n// GetGrantedScopes mocks base method\nfunc (m *MockAuthorizeRequester) GetGrantedScopes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedScopes indicates an expected call of GetGrantedScopes\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetGrantedScopes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedScopes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetGrantedScopes))\n}\n\n// GetID mocks base method\nfunc (m *MockAuthorizeRequester) GetID() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetID() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetID))\n}\n\n// GetRedirectURI mocks base method\nfunc (m *MockAuthorizeRequester) GetRedirectURI() *url.URL {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRedirectURI\")\n\tret0, _ := ret[0].(*url.URL)\n\treturn ret0\n}\n\n// GetRedirectURI indicates an expected call of GetRedirectURI\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRedirectURI() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRedirectURI\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRedirectURI))\n}\n\n// GetRequestForm mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestForm() url.Values {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestForm\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetRequestForm indicates an expected call of GetRequestForm\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestForm() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestForm\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestForm))\n}\n\n// GetRequestedAt mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestedAt() time.Time {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedAt\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetRequestedAt indicates an expected call of GetRequestedAt\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestedAt() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAt\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestedAt))\n}\n\n// GetRequestedAudience mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestedAudience() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedAudience indicates an expected call of GetRequestedAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestedAudience() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestedAudience))\n}\n\n// GetRequestedScopes mocks base method\nfunc (m *MockAuthorizeRequester) GetRequestedScopes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedScopes indicates an expected call of GetRequestedScopes\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetRequestedScopes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedScopes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetRequestedScopes))\n}\n\n// GetResponseTypes mocks base method\nfunc (m *MockAuthorizeRequester) GetResponseTypes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetResponseTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetResponseTypes indicates an expected call of GetResponseTypes\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetResponseTypes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetResponseTypes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetResponseTypes))\n}\n\n// GetSession mocks base method\nfunc (m *MockAuthorizeRequester) GetSession() fosite.Session {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetSession\")\n\tret0, _ := ret[0].(fosite.Session)\n\treturn ret0\n}\n\n// GetSession indicates an expected call of GetSession\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetSession() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetSession\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetSession))\n}\n\n// GetState mocks base method\nfunc (m *MockAuthorizeRequester) GetState() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetState\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetState indicates an expected call of GetState\nfunc (mr *MockAuthorizeRequesterMockRecorder) GetState() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetState\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GetState))\n}\n\n// GrantAudience mocks base method\nfunc (m *MockAuthorizeRequester) GrantAudience(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"GrantAudience\", arg0)\n}\n\n// GrantAudience indicates an expected call of GrantAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) GrantAudience(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GrantAudience), arg0)\n}\n\n// GrantScope mocks base method\nfunc (m *MockAuthorizeRequester) GrantScope(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"GrantScope\", arg0)\n}\n\n// GrantScope indicates an expected call of GrantScope\nfunc (mr *MockAuthorizeRequesterMockRecorder) GrantScope(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantScope\", reflect.TypeOf((*MockAuthorizeRequester)(nil).GrantScope), arg0)\n}\n\n// IsRedirectURIValid mocks base method\nfunc (m *MockAuthorizeRequester) IsRedirectURIValid() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"IsRedirectURIValid\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// IsRedirectURIValid indicates an expected call of IsRedirectURIValid\nfunc (mr *MockAuthorizeRequesterMockRecorder) IsRedirectURIValid() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsRedirectURIValid\", reflect.TypeOf((*MockAuthorizeRequester)(nil).IsRedirectURIValid))\n}\n\n// Merge mocks base method\nfunc (m *MockAuthorizeRequester) Merge(arg0 fosite.Requester) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Merge\", arg0)\n}\n\n// Merge indicates an expected call of Merge\nfunc (mr *MockAuthorizeRequesterMockRecorder) Merge(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Merge\", reflect.TypeOf((*MockAuthorizeRequester)(nil).Merge), arg0)\n}\n\n// Sanitize mocks base method\nfunc (m *MockAuthorizeRequester) Sanitize(arg0 []string) fosite.Requester {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Sanitize\", arg0)\n\tret0, _ := ret[0].(fosite.Requester)\n\treturn ret0\n}\n\n// Sanitize indicates an expected call of Sanitize\nfunc (mr *MockAuthorizeRequesterMockRecorder) Sanitize(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sanitize\", reflect.TypeOf((*MockAuthorizeRequester)(nil).Sanitize), arg0)\n}\n\n// SetID mocks base method\nfunc (m *MockAuthorizeRequester) SetID(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetID\", arg0)\n}\n\n// SetID indicates an expected call of SetID\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetID(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetID\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetID), arg0)\n}\n\n// SetRequestedAudience mocks base method\nfunc (m *MockAuthorizeRequester) SetRequestedAudience(arg0 fosite.Arguments) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetRequestedAudience\", arg0)\n}\n\n// SetRequestedAudience indicates an expected call of SetRequestedAudience\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetRequestedAudience(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedAudience\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetRequestedAudience), arg0)\n}\n\n// SetRequestedScopes mocks base method\nfunc (m *MockAuthorizeRequester) SetRequestedScopes(arg0 fosite.Arguments) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetRequestedScopes\", arg0)\n}\n\n// SetRequestedScopes indicates an expected call of SetRequestedScopes\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetRequestedScopes(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedScopes\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetRequestedScopes), arg0)\n}\n\n// SetResponseTypeHandled mocks base method\nfunc (m *MockAuthorizeRequester) SetResponseTypeHandled(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetResponseTypeHandled\", arg0)\n}\n\n// SetResponseTypeHandled indicates an expected call of SetResponseTypeHandled\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetResponseTypeHandled(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetResponseTypeHandled\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetResponseTypeHandled), arg0)\n}\n\n// SetSession mocks base method\nfunc (m *MockAuthorizeRequester) SetSession(arg0 fosite.Session) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetSession\", arg0)\n}\n\n// SetSession indicates an expected call of SetSession\nfunc (mr *MockAuthorizeRequesterMockRecorder) SetSession(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetSession\", reflect.TypeOf((*MockAuthorizeRequester)(nil).SetSession), arg0)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: AuthorizeResponder)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\thttp \"net/http\"\n\turl \"net/url\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockAuthorizeResponder is a mock of AuthorizeResponder interface\ntype MockAuthorizeResponder struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAuthorizeResponderMockRecorder\n}\n\n// MockAuthorizeResponderMockRecorder is the mock recorder for MockAuthorizeResponder\ntype MockAuthorizeResponderMockRecorder struct {\n\tmock *MockAuthorizeResponder\n}\n\n// NewMockAuthorizeResponder creates a new mock instance\nfunc NewMockAuthorizeResponder(ctrl *gomock.Controller) *MockAuthorizeResponder {\n\tmock := &MockAuthorizeResponder{ctrl: ctrl}\n\tmock.recorder = &MockAuthorizeResponderMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockAuthorizeResponder) EXPECT() *MockAuthorizeResponderMockRecorder {\n\treturn m.recorder\n}\n\n// AddFragment mocks base method\nfunc (m *MockAuthorizeResponder) AddFragment(arg0, arg1 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AddFragment\", arg0, arg1)\n}\n\n// AddFragment indicates an expected call of AddFragment\nfunc (mr *MockAuthorizeResponderMockRecorder) AddFragment(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddFragment\", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddFragment), arg0, arg1)\n}\n\n// AddHeader mocks base method\nfunc (m *MockAuthorizeResponder) AddHeader(arg0, arg1 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AddHeader\", arg0, arg1)\n}\n\n// AddHeader indicates an expected call of AddHeader\nfunc (mr *MockAuthorizeResponderMockRecorder) AddHeader(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddHeader\", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddHeader), arg0, arg1)\n}\n\n// AddQuery mocks base method\nfunc (m *MockAuthorizeResponder) AddQuery(arg0, arg1 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AddQuery\", arg0, arg1)\n}\n\n// AddQuery indicates an expected call of AddQuery\nfunc (mr *MockAuthorizeResponderMockRecorder) AddQuery(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddQuery\", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddQuery), arg0, arg1)\n}\n\n// GetCode mocks base method\nfunc (m *MockAuthorizeResponder) GetCode() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetCode\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetCode indicates an expected call of GetCode\nfunc (mr *MockAuthorizeResponderMockRecorder) GetCode() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetCode\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetCode))\n}\n\n// GetFragment mocks base method\nfunc (m *MockAuthorizeResponder) GetFragment() url.Values {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetFragment\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetFragment indicates an expected call of GetFragment\nfunc (mr *MockAuthorizeResponderMockRecorder) GetFragment() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetFragment\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetFragment))\n}\n\n// GetHeader mocks base method\nfunc (m *MockAuthorizeResponder) GetHeader() http.Header {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetHeader\")\n\tret0, _ := ret[0].(http.Header)\n\treturn ret0\n}\n\n// GetHeader indicates an expected call of GetHeader\nfunc (mr *MockAuthorizeResponderMockRecorder) GetHeader() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetHeader\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetHeader))\n}\n\n// GetQuery mocks base method\nfunc (m *MockAuthorizeResponder) GetQuery() url.Values {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetQuery\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetQuery indicates an expected call of GetQuery\nfunc (mr *MockAuthorizeResponderMockRecorder) GetQuery() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetQuery\", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetQuery))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Client)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockClient is a mock of Client interface\ntype MockClient struct {\n\tctrl     *gomock.Controller\n\trecorder *MockClientMockRecorder\n}\n\n// MockClientMockRecorder is the mock recorder for MockClient\ntype MockClientMockRecorder struct {\n\tmock *MockClient\n}\n\n// NewMockClient creates a new mock instance\nfunc NewMockClient(ctrl *gomock.Controller) *MockClient {\n\tmock := &MockClient{ctrl: ctrl}\n\tmock.recorder = &MockClientMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockClient) EXPECT() *MockClientMockRecorder {\n\treturn m.recorder\n}\n\n// GetAudience mocks base method\nfunc (m *MockClient) GetAudience() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetAudience indicates an expected call of GetAudience\nfunc (mr *MockClientMockRecorder) GetAudience() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAudience\", reflect.TypeOf((*MockClient)(nil).GetAudience))\n}\n\n// GetGrantTypes mocks base method\nfunc (m *MockClient) GetGrantTypes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantTypes indicates an expected call of GetGrantTypes\nfunc (mr *MockClientMockRecorder) GetGrantTypes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantTypes\", reflect.TypeOf((*MockClient)(nil).GetGrantTypes))\n}\n\n// GetHashedSecret mocks base method\nfunc (m *MockClient) GetHashedSecret() []byte {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetHashedSecret\")\n\tret0, _ := ret[0].([]byte)\n\treturn ret0\n}\n\n// GetHashedSecret indicates an expected call of GetHashedSecret\nfunc (mr *MockClientMockRecorder) GetHashedSecret() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetHashedSecret\", reflect.TypeOf((*MockClient)(nil).GetHashedSecret))\n}\n\n// GetID mocks base method\nfunc (m *MockClient) GetID() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockClientMockRecorder) GetID() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockClient)(nil).GetID))\n}\n\n// GetRedirectURIs mocks base method\nfunc (m *MockClient) GetRedirectURIs() []string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRedirectURIs\")\n\tret0, _ := ret[0].([]string)\n\treturn ret0\n}\n\n// GetRedirectURIs indicates an expected call of GetRedirectURIs\nfunc (mr *MockClientMockRecorder) GetRedirectURIs() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRedirectURIs\", reflect.TypeOf((*MockClient)(nil).GetRedirectURIs))\n}\n\n// GetResponseTypes mocks base method\nfunc (m *MockClient) GetResponseTypes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetResponseTypes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetResponseTypes indicates an expected call of GetResponseTypes\nfunc (mr *MockClientMockRecorder) GetResponseTypes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetResponseTypes\", reflect.TypeOf((*MockClient)(nil).GetResponseTypes))\n}\n\n// GetScopes mocks base method\nfunc (m *MockClient) GetScopes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetScopes indicates an expected call of GetScopes\nfunc (mr *MockClientMockRecorder) GetScopes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetScopes\", reflect.TypeOf((*MockClient)(nil).GetScopes))\n}\n\n// IsPublic mocks base method\nfunc (m *MockClient) IsPublic() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"IsPublic\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// IsPublic indicates an expected call of IsPublic\nfunc (mr *MockClientMockRecorder) IsPublic() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IsPublic\", reflect.TypeOf((*MockClient)(nil).IsPublic))\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Hasher)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockHasher is a mock of Hasher interface\ntype MockHasher struct {\n\tctrl     *gomock.Controller\n\trecorder *MockHasherMockRecorder\n}\n\n// MockHasherMockRecorder is the mock recorder for MockHasher\ntype MockHasherMockRecorder struct {\n\tmock *MockHasher\n}\n\n// NewMockHasher creates a new mock instance\nfunc NewMockHasher(ctrl *gomock.Controller) *MockHasher {\n\tmock := &MockHasher{ctrl: ctrl}\n\tmock.recorder = &MockHasherMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockHasher) EXPECT() *MockHasherMockRecorder {\n\treturn m.recorder\n}\n\n// Compare mocks base method\nfunc (m *MockHasher) Compare(arg0 context.Context, arg1, arg2 []byte) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Compare\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Compare indicates an expected call of Compare\nfunc (mr *MockHasherMockRecorder) Compare(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Compare\", reflect.TypeOf((*MockHasher)(nil).Compare), arg0, arg1, arg2)\n}\n\n// Hash mocks base method\nfunc (m *MockHasher) Hash(arg0 context.Context, arg1 []byte) ([]byte, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Hash\", arg0, arg1)\n\tret0, _ := ret[0].([]byte)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Hash indicates an expected call of Hash\nfunc (mr *MockHasherMockRecorder) Hash(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Hash\", reflect.TypeOf((*MockHasher)(nil).Hash), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectTokenStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockOpenIDConnectTokenStrategy is a mock of OpenIDConnectTokenStrategy interface\ntype MockOpenIDConnectTokenStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockOpenIDConnectTokenStrategyMockRecorder\n}\n\n// MockOpenIDConnectTokenStrategyMockRecorder is the mock recorder for MockOpenIDConnectTokenStrategy\ntype MockOpenIDConnectTokenStrategyMockRecorder struct {\n\tmock *MockOpenIDConnectTokenStrategy\n}\n\n// NewMockOpenIDConnectTokenStrategy creates a new mock instance\nfunc NewMockOpenIDConnectTokenStrategy(ctrl *gomock.Controller) *MockOpenIDConnectTokenStrategy {\n\tmock := &MockOpenIDConnectTokenStrategy{ctrl: ctrl}\n\tmock.recorder = &MockOpenIDConnectTokenStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockOpenIDConnectTokenStrategy) EXPECT() *MockOpenIDConnectTokenStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// GenerateIDToken mocks base method\nfunc (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, arg1 fosite.Requester) (string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GenerateIDToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GenerateIDToken indicates an expected call of GenerateIDToken\nfunc (mr *MockOpenIDConnectTokenStrategyMockRecorder) GenerateIDToken(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateIDToken\", reflect.TypeOf((*MockOpenIDConnectTokenStrategy)(nil).GenerateIDToken), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: TokenIntrospector)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockTokenIntrospector is a mock of TokenIntrospector interface\ntype MockTokenIntrospector struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTokenIntrospectorMockRecorder\n}\n\n// MockTokenIntrospectorMockRecorder is the mock recorder for MockTokenIntrospector\ntype MockTokenIntrospectorMockRecorder struct {\n\tmock *MockTokenIntrospector\n}\n\n// NewMockTokenIntrospector creates a new mock instance\nfunc NewMockTokenIntrospector(ctrl *gomock.Controller) *MockTokenIntrospector {\n\tmock := &MockTokenIntrospector{ctrl: ctrl}\n\tmock.recorder = &MockTokenIntrospectorMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTokenIntrospector) EXPECT() *MockTokenIntrospectorMockRecorder {\n\treturn m.recorder\n}\n\n// IntrospectToken mocks base method\nfunc (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.AccessRequester, arg4 []string) (fosite.TokenType, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"IntrospectToken\", arg0, arg1, arg2, arg3, arg4)\n\tret0, _ := ret[0].(fosite.TokenType)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// IntrospectToken indicates an expected call of IntrospectToken\nfunc (mr *MockTokenIntrospectorMockRecorder) IntrospectToken(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"IntrospectToken\", reflect.TypeOf((*MockTokenIntrospector)(nil).IntrospectToken), arg0, arg1, arg2, arg3, arg4)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ClientCredentialsGrantStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockClientCredentialsGrantStorage is a mock of ClientCredentialsGrantStorage interface\ntype MockClientCredentialsGrantStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockClientCredentialsGrantStorageMockRecorder\n}\n\n// MockClientCredentialsGrantStorageMockRecorder is the mock recorder for MockClientCredentialsGrantStorage\ntype MockClientCredentialsGrantStorageMockRecorder struct {\n\tmock *MockClientCredentialsGrantStorage\n}\n\n// NewMockClientCredentialsGrantStorage creates a new mock instance\nfunc NewMockClientCredentialsGrantStorage(ctrl *gomock.Controller) *MockClientCredentialsGrantStorage {\n\tmock := &MockClientCredentialsGrantStorage{ctrl: ctrl}\n\tmock.recorder = &MockClientCredentialsGrantStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockClientCredentialsGrantStorage) EXPECT() *MockClientCredentialsGrantStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockClientCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockClientCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockClientCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockClientCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockClientCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockClientCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ResourceOwnerPasswordCredentialsGrantStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockResourceOwnerPasswordCredentialsGrantStorage is a mock of ResourceOwnerPasswordCredentialsGrantStorage interface\ntype MockResourceOwnerPasswordCredentialsGrantStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder\n}\n\n// MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder is the mock recorder for MockResourceOwnerPasswordCredentialsGrantStorage\ntype MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder struct {\n\tmock *MockResourceOwnerPasswordCredentialsGrantStorage\n}\n\n// NewMockResourceOwnerPasswordCredentialsGrantStorage creates a new mock instance\nfunc NewMockResourceOwnerPasswordCredentialsGrantStorage(ctrl *gomock.Controller) *MockResourceOwnerPasswordCredentialsGrantStorage {\n\tmock := &MockResourceOwnerPasswordCredentialsGrantStorage{ctrl: ctrl}\n\tmock.recorder = &MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) EXPECT() *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder {\n\treturn m.recorder\n}\n\n// Authenticate mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) Authenticate(arg0 context.Context, arg1, arg2 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Authenticate\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Authenticate indicates an expected call of Authenticate\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) Authenticate(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Authenticate\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).Authenticate), arg0, arg1, arg2)\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// CreateRefreshTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRefreshTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// DeleteRefreshTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRefreshTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRefreshTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n\n// GetRefreshTokenSession mocks base method\nfunc (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession\nfunc (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRefreshTokenSession\", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: TokenRevocationStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockTokenRevocationStorage is a mock of TokenRevocationStorage interface\ntype MockTokenRevocationStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTokenRevocationStorageMockRecorder\n}\n\n// MockTokenRevocationStorageMockRecorder is the mock recorder for MockTokenRevocationStorage\ntype MockTokenRevocationStorageMockRecorder struct {\n\tmock *MockTokenRevocationStorage\n}\n\n// NewMockTokenRevocationStorage creates a new mock instance\nfunc NewMockTokenRevocationStorage(ctrl *gomock.Controller) *MockTokenRevocationStorage {\n\tmock := &MockTokenRevocationStorage{ctrl: ctrl}\n\tmock.recorder = &MockTokenRevocationStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTokenRevocationStorage) EXPECT() *MockTokenRevocationStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// CreateRefreshTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRefreshTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// DeleteRefreshTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRefreshTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRefreshTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n\n// GetRefreshTokenSession mocks base method\nfunc (m *MockTokenRevocationStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession\nfunc (mr *MockTokenRevocationStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRefreshTokenSession\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// RevokeAccessToken mocks base method\nfunc (m *MockTokenRevocationStorage) RevokeAccessToken(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RevokeAccessToken\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RevokeAccessToken indicates an expected call of RevokeAccessToken\nfunc (mr *MockTokenRevocationStorageMockRecorder) RevokeAccessToken(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeAccessToken\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeAccessToken), arg0, arg1)\n}\n\n// RevokeRefreshToken mocks base method\nfunc (m *MockTokenRevocationStorage) RevokeRefreshToken(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RevokeRefreshToken\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RevokeRefreshToken indicates an expected call of RevokeRefreshToken\nfunc (mr *MockTokenRevocationStorageMockRecorder) RevokeRefreshToken(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeRefreshToken\", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeRefreshToken), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockCoreStorage is a mock of CoreStorage interface\ntype MockCoreStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockCoreStorageMockRecorder\n}\n\n// MockCoreStorageMockRecorder is the mock recorder for MockCoreStorage\ntype MockCoreStorageMockRecorder struct {\n\tmock *MockCoreStorage\n}\n\n// NewMockCoreStorage creates a new mock instance\nfunc NewMockCoreStorage(ctrl *gomock.Controller) *MockCoreStorage {\n\tmock := &MockCoreStorage{ctrl: ctrl}\n\tmock.recorder = &MockCoreStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockCoreStorage) EXPECT() *MockCoreStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateAccessTokenSession mocks base method\nfunc (m *MockCoreStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession\nfunc (mr *MockCoreStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAccessTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)\n}\n\n// CreateAuthorizeCodeSession mocks base method\nfunc (m *MockCoreStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession\nfunc (mr *MockCoreStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateAuthorizeCodeSession\", reflect.TypeOf((*MockCoreStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// CreateRefreshTokenSession mocks base method\nfunc (m *MockCoreStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession\nfunc (mr *MockCoreStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateRefreshTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// DeleteAccessTokenSession mocks base method\nfunc (m *MockCoreStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteAccessTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession\nfunc (mr *MockCoreStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteAccessTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).DeleteAccessTokenSession), arg0, arg1)\n}\n\n// DeleteRefreshTokenSession mocks base method\nfunc (m *MockCoreStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteRefreshTokenSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession\nfunc (mr *MockCoreStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteRefreshTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)\n}\n\n// GetAccessTokenSession mocks base method\nfunc (m *MockCoreStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAccessTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAccessTokenSession indicates an expected call of GetAccessTokenSession\nfunc (mr *MockCoreStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAccessTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)\n}\n\n// GetAuthorizeCodeSession mocks base method\nfunc (m *MockCoreStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAuthorizeCodeSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession\nfunc (mr *MockCoreStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAuthorizeCodeSession\", reflect.TypeOf((*MockCoreStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)\n}\n\n// GetRefreshTokenSession mocks base method\nfunc (m *MockCoreStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRefreshTokenSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession\nfunc (mr *MockCoreStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRefreshTokenSession\", reflect.TypeOf((*MockCoreStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)\n}\n\n// InvalidateAuthorizeCodeSession mocks base method\nfunc (m *MockCoreStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"InvalidateAuthorizeCodeSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession\nfunc (mr *MockCoreStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InvalidateAuthorizeCodeSession\", reflect.TypeOf((*MockCoreStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockCoreStrategy is a mock of CoreStrategy interface\ntype MockCoreStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockCoreStrategyMockRecorder\n}\n\n// MockCoreStrategyMockRecorder is the mock recorder for MockCoreStrategy\ntype MockCoreStrategyMockRecorder struct {\n\tmock *MockCoreStrategy\n}\n\n// NewMockCoreStrategy creates a new mock instance\nfunc NewMockCoreStrategy(ctrl *gomock.Controller) *MockCoreStrategy {\n\tmock := &MockCoreStrategy{ctrl: ctrl}\n\tmock.recorder = &MockCoreStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockCoreStrategy) EXPECT() *MockCoreStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// AccessTokenSignature mocks base method\nfunc (m *MockCoreStrategy) AccessTokenSignature(arg0 string) string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AccessTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AccessTokenSignature indicates an expected call of AccessTokenSignature\nfunc (mr *MockCoreStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AccessTokenSignature\", reflect.TypeOf((*MockCoreStrategy)(nil).AccessTokenSignature), arg0)\n}\n\n// AuthorizeCodeSignature mocks base method\nfunc (m *MockCoreStrategy) AuthorizeCodeSignature(arg0 string) string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AuthorizeCodeSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature\nfunc (mr *MockCoreStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AuthorizeCodeSignature\", reflect.TypeOf((*MockCoreStrategy)(nil).AuthorizeCodeSignature), arg0)\n}\n\n// GenerateAccessToken mocks base method\nfunc (m *MockCoreStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GenerateAccessToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAccessToken indicates an expected call of GenerateAccessToken\nfunc (mr *MockCoreStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAccessToken\", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAccessToken), arg0, arg1)\n}\n\n// GenerateAuthorizeCode mocks base method\nfunc (m *MockCoreStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GenerateAuthorizeCode\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode\nfunc (mr *MockCoreStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateAuthorizeCode\", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)\n}\n\n// GenerateRefreshToken mocks base method\nfunc (m *MockCoreStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GenerateRefreshToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateRefreshToken indicates an expected call of GenerateRefreshToken\nfunc (mr *MockCoreStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateRefreshToken\", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateRefreshToken), arg0, arg1)\n}\n\n// RefreshTokenSignature mocks base method\nfunc (m *MockCoreStrategy) RefreshTokenSignature(arg0 string) string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RefreshTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// RefreshTokenSignature indicates an expected call of RefreshTokenSignature\nfunc (mr *MockCoreStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RefreshTokenSignature\", reflect.TypeOf((*MockCoreStrategy)(nil).RefreshTokenSignature), arg0)\n}\n\n// ValidateAccessToken mocks base method\nfunc (m *MockCoreStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ValidateAccessToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAccessToken indicates an expected call of ValidateAccessToken\nfunc (mr *MockCoreStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAccessToken\", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)\n}\n\n// ValidateAuthorizeCode mocks base method\nfunc (m *MockCoreStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ValidateAuthorizeCode\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode\nfunc (mr *MockCoreStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateAuthorizeCode\", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)\n}\n\n// ValidateRefreshToken mocks base method\nfunc (m *MockCoreStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ValidateRefreshToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateRefreshToken indicates an expected call of ValidateRefreshToken\nfunc (mr *MockCoreStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateRefreshToken\", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectRequestStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockOpenIDConnectRequestStorage is a mock of OpenIDConnectRequestStorage interface\ntype MockOpenIDConnectRequestStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockOpenIDConnectRequestStorageMockRecorder\n}\n\n// MockOpenIDConnectRequestStorageMockRecorder is the mock recorder for MockOpenIDConnectRequestStorage\ntype MockOpenIDConnectRequestStorageMockRecorder struct {\n\tmock *MockOpenIDConnectRequestStorage\n}\n\n// NewMockOpenIDConnectRequestStorage creates a new mock instance\nfunc NewMockOpenIDConnectRequestStorage(ctrl *gomock.Controller) *MockOpenIDConnectRequestStorage {\n\tmock := &MockOpenIDConnectRequestStorage{ctrl: ctrl}\n\tmock.recorder = &MockOpenIDConnectRequestStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockOpenIDConnectRequestStorage) EXPECT() *MockOpenIDConnectRequestStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreateOpenIDConnectSession mocks base method\nfunc (m *MockOpenIDConnectRequestStorage) CreateOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreateOpenIDConnectSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreateOpenIDConnectSession indicates an expected call of CreateOpenIDConnectSession\nfunc (mr *MockOpenIDConnectRequestStorageMockRecorder) CreateOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreateOpenIDConnectSession\", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).CreateOpenIDConnectSession), arg0, arg1, arg2)\n}\n\n// DeleteOpenIDConnectSession mocks base method\nfunc (m *MockOpenIDConnectRequestStorage) DeleteOpenIDConnectSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteOpenIDConnectSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteOpenIDConnectSession indicates an expected call of DeleteOpenIDConnectSession\nfunc (mr *MockOpenIDConnectRequestStorageMockRecorder) DeleteOpenIDConnectSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteOpenIDConnectSession\", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).DeleteOpenIDConnectSession), arg0, arg1)\n}\n\n// GetOpenIDConnectSession mocks base method\nfunc (m *MockOpenIDConnectRequestStorage) GetOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetOpenIDConnectSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetOpenIDConnectSession indicates an expected call of GetOpenIDConnectSession\nfunc (mr *MockOpenIDConnectRequestStorageMockRecorder) GetOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetOpenIDConnectSession\", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).GetOpenIDConnectSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/pkce (interfaces: PKCERequestStorage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockPKCERequestStorage is a mock of PKCERequestStorage interface\ntype MockPKCERequestStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockPKCERequestStorageMockRecorder\n}\n\n// MockPKCERequestStorageMockRecorder is the mock recorder for MockPKCERequestStorage\ntype MockPKCERequestStorageMockRecorder struct {\n\tmock *MockPKCERequestStorage\n}\n\n// NewMockPKCERequestStorage creates a new mock instance\nfunc NewMockPKCERequestStorage(ctrl *gomock.Controller) *MockPKCERequestStorage {\n\tmock := &MockPKCERequestStorage{ctrl: ctrl}\n\tmock.recorder = &MockPKCERequestStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockPKCERequestStorage) EXPECT() *MockPKCERequestStorageMockRecorder {\n\treturn m.recorder\n}\n\n// CreatePKCERequestSession mocks base method\nfunc (m *MockPKCERequestStorage) CreatePKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CreatePKCERequestSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CreatePKCERequestSession indicates an expected call of CreatePKCERequestSession\nfunc (mr *MockPKCERequestStorageMockRecorder) CreatePKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CreatePKCERequestSession\", reflect.TypeOf((*MockPKCERequestStorage)(nil).CreatePKCERequestSession), arg0, arg1, arg2)\n}\n\n// DeletePKCERequestSession mocks base method\nfunc (m *MockPKCERequestStorage) DeletePKCERequestSession(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeletePKCERequestSession\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeletePKCERequestSession indicates an expected call of DeletePKCERequestSession\nfunc (mr *MockPKCERequestStorageMockRecorder) DeletePKCERequestSession(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeletePKCERequestSession\", reflect.TypeOf((*MockPKCERequestStorage)(nil).DeletePKCERequestSession), arg0, arg1)\n}\n\n// GetPKCERequestSession mocks base method\nfunc (m *MockPKCERequestStorage) GetPKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetPKCERequestSession\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(fosite.Requester)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetPKCERequestSession indicates an expected call of GetPKCERequestSession\nfunc (mr *MockPKCERequestStorageMockRecorder) GetPKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetPKCERequestSession\", reflect.TypeOf((*MockPKCERequestStorage)(nil).GetPKCERequestSession), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/handler/oauth2 (interfaces: RefreshTokenStrategy)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockRefreshTokenStrategy is a mock of RefreshTokenStrategy interface\ntype MockRefreshTokenStrategy struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRefreshTokenStrategyMockRecorder\n}\n\n// MockRefreshTokenStrategyMockRecorder is the mock recorder for MockRefreshTokenStrategy\ntype MockRefreshTokenStrategyMockRecorder struct {\n\tmock *MockRefreshTokenStrategy\n}\n\n// NewMockRefreshTokenStrategy creates a new mock instance\nfunc NewMockRefreshTokenStrategy(ctrl *gomock.Controller) *MockRefreshTokenStrategy {\n\tmock := &MockRefreshTokenStrategy{ctrl: ctrl}\n\tmock.recorder = &MockRefreshTokenStrategyMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockRefreshTokenStrategy) EXPECT() *MockRefreshTokenStrategyMockRecorder {\n\treturn m.recorder\n}\n\n// GenerateRefreshToken mocks base method\nfunc (m *MockRefreshTokenStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GenerateRefreshToken\", arg0, arg1)\n\tret0, _ := ret[0].(string)\n\tret1, _ := ret[1].(string)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// GenerateRefreshToken indicates an expected call of GenerateRefreshToken\nfunc (mr *MockRefreshTokenStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GenerateRefreshToken\", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).GenerateRefreshToken), arg0, arg1)\n}\n\n// RefreshTokenSignature mocks base method\nfunc (m *MockRefreshTokenStrategy) RefreshTokenSignature(arg0 string) string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RefreshTokenSignature\", arg0)\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// RefreshTokenSignature indicates an expected call of RefreshTokenSignature\nfunc (mr *MockRefreshTokenStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RefreshTokenSignature\", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).RefreshTokenSignature), arg0)\n}\n\n// ValidateRefreshToken mocks base method\nfunc (m *MockRefreshTokenStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ValidateRefreshToken\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ValidateRefreshToken indicates an expected call of ValidateRefreshToken\nfunc (mr *MockRefreshTokenStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ValidateRefreshToken\", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Requester)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\turl \"net/url\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockRequester is a mock of Requester interface\ntype MockRequester struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRequesterMockRecorder\n}\n\n// MockRequesterMockRecorder is the mock recorder for MockRequester\ntype MockRequesterMockRecorder struct {\n\tmock *MockRequester\n}\n\n// NewMockRequester creates a new mock instance\nfunc NewMockRequester(ctrl *gomock.Controller) *MockRequester {\n\tmock := &MockRequester{ctrl: ctrl}\n\tmock.recorder = &MockRequesterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockRequester) EXPECT() *MockRequesterMockRecorder {\n\treturn m.recorder\n}\n\n// AppendRequestedScope mocks base method\nfunc (m *MockRequester) AppendRequestedScope(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AppendRequestedScope\", arg0)\n}\n\n// AppendRequestedScope indicates an expected call of AppendRequestedScope\nfunc (mr *MockRequesterMockRecorder) AppendRequestedScope(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AppendRequestedScope\", reflect.TypeOf((*MockRequester)(nil).AppendRequestedScope), arg0)\n}\n\n// GetClient mocks base method\nfunc (m *MockRequester) GetClient() fosite.Client {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetClient\")\n\tret0, _ := ret[0].(fosite.Client)\n\treturn ret0\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockRequesterMockRecorder) GetClient() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockRequester)(nil).GetClient))\n}\n\n// GetGrantedAudience mocks base method\nfunc (m *MockRequester) GetGrantedAudience() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedAudience indicates an expected call of GetGrantedAudience\nfunc (mr *MockRequesterMockRecorder) GetGrantedAudience() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedAudience\", reflect.TypeOf((*MockRequester)(nil).GetGrantedAudience))\n}\n\n// GetGrantedScopes mocks base method\nfunc (m *MockRequester) GetGrantedScopes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetGrantedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetGrantedScopes indicates an expected call of GetGrantedScopes\nfunc (mr *MockRequesterMockRecorder) GetGrantedScopes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetGrantedScopes\", reflect.TypeOf((*MockRequester)(nil).GetGrantedScopes))\n}\n\n// GetID mocks base method\nfunc (m *MockRequester) GetID() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetID\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n// GetID indicates an expected call of GetID\nfunc (mr *MockRequesterMockRecorder) GetID() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetID\", reflect.TypeOf((*MockRequester)(nil).GetID))\n}\n\n// GetRequestForm mocks base method\nfunc (m *MockRequester) GetRequestForm() url.Values {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestForm\")\n\tret0, _ := ret[0].(url.Values)\n\treturn ret0\n}\n\n// GetRequestForm indicates an expected call of GetRequestForm\nfunc (mr *MockRequesterMockRecorder) GetRequestForm() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestForm\", reflect.TypeOf((*MockRequester)(nil).GetRequestForm))\n}\n\n// GetRequestedAt mocks base method\nfunc (m *MockRequester) GetRequestedAt() time.Time {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedAt\")\n\tret0, _ := ret[0].(time.Time)\n\treturn ret0\n}\n\n// GetRequestedAt indicates an expected call of GetRequestedAt\nfunc (mr *MockRequesterMockRecorder) GetRequestedAt() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAt\", reflect.TypeOf((*MockRequester)(nil).GetRequestedAt))\n}\n\n// GetRequestedAudience mocks base method\nfunc (m *MockRequester) GetRequestedAudience() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedAudience\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedAudience indicates an expected call of GetRequestedAudience\nfunc (mr *MockRequesterMockRecorder) GetRequestedAudience() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedAudience\", reflect.TypeOf((*MockRequester)(nil).GetRequestedAudience))\n}\n\n// GetRequestedScopes mocks base method\nfunc (m *MockRequester) GetRequestedScopes() fosite.Arguments {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetRequestedScopes\")\n\tret0, _ := ret[0].(fosite.Arguments)\n\treturn ret0\n}\n\n// GetRequestedScopes indicates an expected call of GetRequestedScopes\nfunc (mr *MockRequesterMockRecorder) GetRequestedScopes() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetRequestedScopes\", reflect.TypeOf((*MockRequester)(nil).GetRequestedScopes))\n}\n\n// GetSession mocks base method\nfunc (m *MockRequester) GetSession() fosite.Session {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetSession\")\n\tret0, _ := ret[0].(fosite.Session)\n\treturn ret0\n}\n\n// GetSession indicates an expected call of GetSession\nfunc (mr *MockRequesterMockRecorder) GetSession() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetSession\", reflect.TypeOf((*MockRequester)(nil).GetSession))\n}\n\n// GrantAudience mocks base method\nfunc (m *MockRequester) GrantAudience(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"GrantAudience\", arg0)\n}\n\n// GrantAudience indicates an expected call of GrantAudience\nfunc (mr *MockRequesterMockRecorder) GrantAudience(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantAudience\", reflect.TypeOf((*MockRequester)(nil).GrantAudience), arg0)\n}\n\n// GrantScope mocks base method\nfunc (m *MockRequester) GrantScope(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"GrantScope\", arg0)\n}\n\n// GrantScope indicates an expected call of GrantScope\nfunc (mr *MockRequesterMockRecorder) GrantScope(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GrantScope\", reflect.TypeOf((*MockRequester)(nil).GrantScope), arg0)\n}\n\n// Merge mocks base method\nfunc (m *MockRequester) Merge(arg0 fosite.Requester) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Merge\", arg0)\n}\n\n// Merge indicates an expected call of Merge\nfunc (mr *MockRequesterMockRecorder) Merge(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Merge\", reflect.TypeOf((*MockRequester)(nil).Merge), arg0)\n}\n\n// Sanitize mocks base method\nfunc (m *MockRequester) Sanitize(arg0 []string) fosite.Requester {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Sanitize\", arg0)\n\tret0, _ := ret[0].(fosite.Requester)\n\treturn ret0\n}\n\n// Sanitize indicates an expected call of Sanitize\nfunc (mr *MockRequesterMockRecorder) Sanitize(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sanitize\", reflect.TypeOf((*MockRequester)(nil).Sanitize), arg0)\n}\n\n// SetID mocks base method\nfunc (m *MockRequester) SetID(arg0 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetID\", arg0)\n}\n\n// SetID indicates an expected call of SetID\nfunc (mr *MockRequesterMockRecorder) SetID(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetID\", reflect.TypeOf((*MockRequester)(nil).SetID), arg0)\n}\n\n// SetRequestedAudience mocks base method\nfunc (m *MockRequester) SetRequestedAudience(arg0 fosite.Arguments) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetRequestedAudience\", arg0)\n}\n\n// SetRequestedAudience indicates an expected call of SetRequestedAudience\nfunc (mr *MockRequesterMockRecorder) SetRequestedAudience(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedAudience\", reflect.TypeOf((*MockRequester)(nil).SetRequestedAudience), arg0)\n}\n\n// SetRequestedScopes mocks base method\nfunc (m *MockRequester) SetRequestedScopes(arg0 fosite.Arguments) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetRequestedScopes\", arg0)\n}\n\n// SetRequestedScopes indicates an expected call of SetRequestedScopes\nfunc (mr *MockRequesterMockRecorder) SetRequestedScopes(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetRequestedScopes\", reflect.TypeOf((*MockRequester)(nil).SetRequestedScopes), arg0)\n}\n\n// SetSession mocks base method\nfunc (m *MockRequester) SetSession(arg0 fosite.Session) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetSession\", arg0)\n}\n\n// SetSession indicates an expected call of SetSession\nfunc (mr *MockRequesterMockRecorder) SetSession(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetSession\", reflect.TypeOf((*MockRequester)(nil).SetSession), arg0)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: RevocationHandler)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockRevocationHandler is a mock of RevocationHandler interface\ntype MockRevocationHandler struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRevocationHandlerMockRecorder\n}\n\n// MockRevocationHandlerMockRecorder is the mock recorder for MockRevocationHandler\ntype MockRevocationHandlerMockRecorder struct {\n\tmock *MockRevocationHandler\n}\n\n// NewMockRevocationHandler creates a new mock instance\nfunc NewMockRevocationHandler(ctrl *gomock.Controller) *MockRevocationHandler {\n\tmock := &MockRevocationHandler{ctrl: ctrl}\n\tmock.recorder = &MockRevocationHandlerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockRevocationHandler) EXPECT() *MockRevocationHandlerMockRecorder {\n\treturn m.recorder\n}\n\n// RevokeToken mocks base method\nfunc (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.Client) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RevokeToken\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// RevokeToken indicates an expected call of RevokeToken\nfunc (mr *MockRevocationHandlerMockRecorder) RevokeToken(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RevokeToken\", reflect.TypeOf((*MockRevocationHandler)(nil).RevokeToken), arg0, arg1, arg2, arg3)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: Storage)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockStorage is a mock of Storage interface\ntype MockStorage struct {\n\tctrl     *gomock.Controller\n\trecorder *MockStorageMockRecorder\n}\n\n// MockStorageMockRecorder is the mock recorder for MockStorage\ntype MockStorageMockRecorder struct {\n\tmock *MockStorage\n}\n\n// NewMockStorage creates a new mock instance\nfunc NewMockStorage(ctrl *gomock.Controller) *MockStorage {\n\tmock := &MockStorage{ctrl: ctrl}\n\tmock.recorder = &MockStorageMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockStorage) EXPECT() *MockStorageMockRecorder {\n\treturn m.recorder\n}\n\n// ClientAssertionJWTValid mocks base method\nfunc (m *MockStorage) ClientAssertionJWTValid(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ClientAssertionJWTValid\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// ClientAssertionJWTValid indicates an expected call of ClientAssertionJWTValid\nfunc (mr *MockStorageMockRecorder) ClientAssertionJWTValid(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ClientAssertionJWTValid\", reflect.TypeOf((*MockStorage)(nil).ClientAssertionJWTValid), arg0, arg1)\n}\n\n// GetClient mocks base method\nfunc (m *MockStorage) GetClient(arg0 context.Context, arg1 string) (fosite.Client, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetClient\", arg0, arg1)\n\tret0, _ := ret[0].(fosite.Client)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetClient indicates an expected call of GetClient\nfunc (mr *MockStorageMockRecorder) GetClient(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetClient\", reflect.TypeOf((*MockStorage)(nil).GetClient), arg0, arg1)\n}\n\n// SetClientAssertionJWT mocks base method\nfunc (m *MockStorage) SetClientAssertionJWT(arg0 context.Context, arg1 string, arg2 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetClientAssertionJWT\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetClientAssertionJWT indicates an expected call of SetClientAssertionJWT\nfunc (mr *MockStorageMockRecorder) SetClientAssertionJWT(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetClientAssertionJWT\", reflect.TypeOf((*MockStorage)(nil).SetClientAssertionJWT), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite (interfaces: TokenEndpointHandler)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\tfosite \"github.com/ory/fosite\"\n)\n\n// MockTokenEndpointHandler is a mock of TokenEndpointHandler interface\ntype MockTokenEndpointHandler struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTokenEndpointHandlerMockRecorder\n}\n\n// MockTokenEndpointHandlerMockRecorder is the mock recorder for MockTokenEndpointHandler\ntype MockTokenEndpointHandlerMockRecorder struct {\n\tmock *MockTokenEndpointHandler\n}\n\n// NewMockTokenEndpointHandler creates a new mock instance\nfunc NewMockTokenEndpointHandler(ctrl *gomock.Controller) *MockTokenEndpointHandler {\n\tmock := &MockTokenEndpointHandler{ctrl: ctrl}\n\tmock.recorder = &MockTokenEndpointHandlerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTokenEndpointHandler) EXPECT() *MockTokenEndpointHandlerMockRecorder {\n\treturn m.recorder\n}\n\n// HandleTokenEndpointRequest mocks base method\nfunc (m *MockTokenEndpointHandler) HandleTokenEndpointRequest(arg0 context.Context, arg1 fosite.AccessRequester) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"HandleTokenEndpointRequest\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// HandleTokenEndpointRequest indicates an expected call of HandleTokenEndpointRequest\nfunc (mr *MockTokenEndpointHandlerMockRecorder) HandleTokenEndpointRequest(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"HandleTokenEndpointRequest\", reflect.TypeOf((*MockTokenEndpointHandler)(nil).HandleTokenEndpointRequest), arg0, arg1)\n}\n\n// PopulateTokenEndpointResponse mocks base method\nfunc (m *MockTokenEndpointHandler) PopulateTokenEndpointResponse(arg0 context.Context, arg1 fosite.AccessRequester, arg2 fosite.AccessResponder) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PopulateTokenEndpointResponse\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// PopulateTokenEndpointResponse indicates an expected call of PopulateTokenEndpointResponse\nfunc (mr *MockTokenEndpointHandlerMockRecorder) PopulateTokenEndpointResponse(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PopulateTokenEndpointResponse\", reflect.TypeOf((*MockTokenEndpointHandler)(nil).PopulateTokenEndpointResponse), arg0, arg1, arg2)\n}\n", "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/fosite/storage (interfaces: Transactional)\n\n// Package internal is a generated GoMock package.\npackage internal\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockTransactional is a mock of Transactional interface\ntype MockTransactional struct {\n\tctrl     *gomock.Controller\n\trecorder *MockTransactionalMockRecorder\n}\n\n// MockTransactionalMockRecorder is the mock recorder for MockTransactional\ntype MockTransactionalMockRecorder struct {\n\tmock *MockTransactional\n}\n\n// NewMockTransactional creates a new mock instance\nfunc NewMockTransactional(ctrl *gomock.Controller) *MockTransactional {\n\tmock := &MockTransactional{ctrl: ctrl}\n\tmock.recorder = &MockTransactionalMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use\nfunc (m *MockTransactional) EXPECT() *MockTransactionalMockRecorder {\n\treturn m.recorder\n}\n\n// BeginTX mocks base method\nfunc (m *MockTransactional) BeginTX(arg0 context.Context) (context.Context, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"BeginTX\", arg0)\n\tret0, _ := ret[0].(context.Context)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// BeginTX indicates an expected call of BeginTX\nfunc (mr *MockTransactionalMockRecorder) BeginTX(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"BeginTX\", reflect.TypeOf((*MockTransactional)(nil).BeginTX), arg0)\n}\n\n// Commit mocks base method\nfunc (m *MockTransactional) Commit(arg0 context.Context) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Commit\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Commit indicates an expected call of Commit\nfunc (mr *MockTransactionalMockRecorder) Commit(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Commit\", reflect.TypeOf((*MockTransactional)(nil).Commit), arg0)\n}\n\n// Rollback mocks base method\nfunc (m *MockTransactional) Rollback(arg0 context.Context) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Rollback\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Rollback indicates an expected call of Rollback\nfunc (mr *MockTransactionalMockRecorder) Rollback(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Rollback\", reflect.TypeOf((*MockTransactional)(nil).Rollback), arg0)\n}\n", "/*\n * Copyright \u00a9 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n *\n */\n\npackage storage\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/fosite\"\n)\n\ntype MemoryUserRelation struct {\n\tUsername string\n\tPassword string\n}\n\ntype MemoryStore struct {\n\tClients         map[string]fosite.Client\n\tAuthorizeCodes  map[string]StoreAuthorizeCode\n\tIDSessions      map[string]fosite.Requester\n\tAccessTokens    map[string]fosite.Requester\n\tImplicit        map[string]fosite.Requester\n\tRefreshTokens   map[string]fosite.Requester\n\tPKCES           map[string]fosite.Requester\n\tUsers           map[string]MemoryUserRelation\n\tBlacklistedJTIs map[string]time.Time\n\t// In-memory request ID to token signatures\n\tAccessTokenRequestIDs  map[string]string\n\tRefreshTokenRequestIDs map[string]string\n}\n\nfunc NewMemoryStore() *MemoryStore {\n\treturn &MemoryStore{\n\t\tClients:                make(map[string]fosite.Client),\n\t\tAuthorizeCodes:         make(map[string]StoreAuthorizeCode),\n\t\tIDSessions:             make(map[string]fosite.Requester),\n\t\tAccessTokens:           make(map[string]fosite.Requester),\n\t\tImplicit:               make(map[string]fosite.Requester),\n\t\tRefreshTokens:          make(map[string]fosite.Requester),\n\t\tPKCES:                  make(map[string]fosite.Requester),\n\t\tUsers:                  make(map[string]MemoryUserRelation),\n\t\tAccessTokenRequestIDs:  make(map[string]string),\n\t\tRefreshTokenRequestIDs: make(map[string]string),\n\t\tBlacklistedJTIs:        make(map[string]time.Time),\n\t}\n}\n\ntype StoreAuthorizeCode struct {\n\tactive bool\n\tfosite.Requester\n}\n\nfunc NewExampleStore() *MemoryStore {\n\treturn &MemoryStore{\n\t\tIDSessions: make(map[string]fosite.Requester),\n\t\tClients: map[string]fosite.Client{\n\t\t\t\"my-client\": &fosite.DefaultClient{\n\t\t\t\tID:            \"my-client\",\n\t\t\t\tSecret:        []byte(`$2a$10$IxMdI6d.LIRZPpSfEwNoeu4rY3FhDREsxFJXikcgdRRAStxUlsuEO`), // = \"foobar\"\n\t\t\t\tRedirectURIs:  []string{\"http://localhost:3846/callback\"},\n\t\t\t\tResponseTypes: []string{\"id_token\", \"code\", \"token\"},\n\t\t\t\tGrantTypes:    []string{\"implicit\", \"refresh_token\", \"authorization_code\", \"password\", \"client_credentials\"},\n\t\t\t\tScopes:        []string{\"fosite\", \"openid\", \"photos\", \"offline\"},\n\t\t\t},\n\t\t\t\"encoded:client\": &fosite.DefaultClient{\n\t\t\t\tID:            \"encoded:client\",\n\t\t\t\tSecret:        []byte(`$2a$10$A7M8b65dSSKGHF0H2sNkn.9Z0hT8U1Nv6OWPV3teUUaczXkVkxuDS`), // = \"encoded&password\"\n\t\t\t\tRedirectURIs:  []string{\"http://localhost:3846/callback\"},\n\t\t\t\tResponseTypes: []string{\"id_token\", \"code\", \"token\"},\n\t\t\t\tGrantTypes:    []string{\"implicit\", \"refresh_token\", \"authorization_code\", \"password\", \"client_credentials\"},\n\t\t\t\tScopes:        []string{\"fosite\", \"openid\", \"photos\", \"offline\"},\n\t\t\t},\n\t\t},\n\t\tUsers: map[string]MemoryUserRelation{\n\t\t\t\"peter\": {\n\t\t\t\t// This store simply checks for equality, a real storage implementation would obviously use\n\t\t\t\t// a hashing algorithm for encrypting the user password.\n\t\t\t\tUsername: \"peter\",\n\t\t\t\tPassword: \"secret\",\n\t\t\t},\n\t\t},\n\t\tAuthorizeCodes:         map[string]StoreAuthorizeCode{},\n\t\tImplicit:               map[string]fosite.Requester{},\n\t\tAccessTokens:           map[string]fosite.Requester{},\n\t\tRefreshTokens:          map[string]fosite.Requester{},\n\t\tPKCES:                  map[string]fosite.Requester{},\n\t\tAccessTokenRequestIDs:  map[string]string{},\n\t\tRefreshTokenRequestIDs: map[string]string{},\n\t}\n}\n\nfunc (s *MemoryStore) CreateOpenIDConnectSession(_ context.Context, authorizeCode string, requester fosite.Requester) error {\n\ts.IDSessions[authorizeCode] = requester\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetOpenIDConnectSession(_ context.Context, authorizeCode string, requester fosite.Requester) (fosite.Requester, error) {\n\tcl, ok := s.IDSessions[authorizeCode]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn cl, nil\n}\n\nfunc (s *MemoryStore) DeleteOpenIDConnectSession(_ context.Context, authorizeCode string) error {\n\tdelete(s.IDSessions, authorizeCode)\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetClient(_ context.Context, id string) (fosite.Client, error) {\n\tcl, ok := s.Clients[id]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn cl, nil\n}\n\nfunc (s *MemoryStore) ClientAssertionJWTValid(_ context.Context, jti string) error {\n\tif exp, exists := s.BlacklistedJTIs[jti]; exists && exp.After(time.Now()) {\n\t\treturn fosite.ErrJTIKnown\n\t}\n\n\treturn nil\n}\n\nfunc (s *MemoryStore) SetClientAssertionJWT(_ context.Context, jti string, exp time.Time) error {\n\t// delete expired jtis\n\tfor j, e := range s.BlacklistedJTIs {\n\t\tif e.Before(time.Now()) {\n\t\t\tdelete(s.BlacklistedJTIs, j)\n\t\t}\n\t}\n\n\tif _, exists := s.BlacklistedJTIs[jti]; exists {\n\t\treturn fosite.ErrJTIKnown\n\t}\n\n\ts.BlacklistedJTIs[jti] = exp\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreateAuthorizeCodeSession(_ context.Context, code string, req fosite.Requester) error {\n\ts.AuthorizeCodes[code] = StoreAuthorizeCode{active: true, Requester: req}\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetAuthorizeCodeSession(_ context.Context, code string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.AuthorizeCodes[code]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\tif !rel.active {\n\t\treturn rel, fosite.ErrInvalidatedAuthorizeCode\n\t}\n\n\treturn rel.Requester, nil\n}\n\nfunc (s *MemoryStore) InvalidateAuthorizeCodeSession(ctx context.Context, code string) error {\n\trel, ok := s.AuthorizeCodes[code]\n\tif !ok {\n\t\treturn fosite.ErrNotFound\n\t}\n\trel.active = false\n\ts.AuthorizeCodes[code] = rel\n\treturn nil\n}\n\nfunc (s *MemoryStore) DeleteAuthorizeCodeSession(_ context.Context, code string) error {\n\tdelete(s.AuthorizeCodes, code)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreatePKCERequestSession(_ context.Context, code string, req fosite.Requester) error {\n\ts.PKCES[code] = req\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetPKCERequestSession(_ context.Context, code string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.PKCES[code]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn rel, nil\n}\n\nfunc (s *MemoryStore) DeletePKCERequestSession(_ context.Context, code string) error {\n\tdelete(s.PKCES, code)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreateAccessTokenSession(_ context.Context, signature string, req fosite.Requester) error {\n\ts.AccessTokens[signature] = req\n\ts.AccessTokenRequestIDs[req.GetID()] = signature\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetAccessTokenSession(_ context.Context, signature string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.AccessTokens[signature]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn rel, nil\n}\n\nfunc (s *MemoryStore) DeleteAccessTokenSession(_ context.Context, signature string) error {\n\tdelete(s.AccessTokens, signature)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreateRefreshTokenSession(_ context.Context, signature string, req fosite.Requester) error {\n\ts.RefreshTokens[signature] = req\n\ts.RefreshTokenRequestIDs[req.GetID()] = signature\n\treturn nil\n}\n\nfunc (s *MemoryStore) GetRefreshTokenSession(_ context.Context, signature string, _ fosite.Session) (fosite.Requester, error) {\n\trel, ok := s.RefreshTokens[signature]\n\tif !ok {\n\t\treturn nil, fosite.ErrNotFound\n\t}\n\treturn rel, nil\n}\n\nfunc (s *MemoryStore) DeleteRefreshTokenSession(_ context.Context, signature string) error {\n\tdelete(s.RefreshTokens, signature)\n\treturn nil\n}\n\nfunc (s *MemoryStore) CreateImplicitAccessTokenSession(_ context.Context, code string, req fosite.Requester) error {\n\ts.Implicit[code] = req\n\treturn nil\n}\n\nfunc (s *MemoryStore) Authenticate(_ context.Context, name string, secret string) error {\n\trel, ok := s.Users[name]\n\tif !ok {\n\t\treturn fosite.ErrNotFound\n\t}\n\tif rel.Password != secret {\n\t\treturn errors.New(\"Invalid credentials\")\n\t}\n\treturn nil\n}\n\nfunc (s *MemoryStore) RevokeRefreshToken(ctx context.Context, requestID string) error {\n\tif signature, exists := s.RefreshTokenRequestIDs[requestID]; exists {\n\t\ts.DeleteRefreshTokenSession(ctx, signature)\n\t\ts.DeleteAccessTokenSession(ctx, signature)\n\t}\n\treturn nil\n}\n\nfunc (s *MemoryStore) RevokeAccessToken(ctx context.Context, requestID string) error {\n\tif signature, exists := s.AccessTokenRequestIDs[requestID]; exists {\n\t\ts.DeleteAccessTokenSession(ctx, signature)\n\t}\n\treturn nil\n}\n"], "filenames": ["client_authentication.go", "client_authentication_test.go", "client_manager.go", "errors.go", "go.mod", "go.sum", "handler/oauth2/flow_refresh.go", "internal/access_request.go", "internal/access_response.go", "internal/access_token_storage.go", "internal/access_token_strategy.go", "internal/authorize_code_storage.go", "internal/authorize_code_strategy.go", "internal/authorize_handler.go", "internal/authorize_request.go", "internal/authorize_response.go", "internal/client.go", "internal/hash.go", "internal/id_token_strategy.go", "internal/introspector.go", "internal/oauth2_client_storage.go", "internal/oauth2_owner_storage.go", "internal/oauth2_revoke_storage.go", "internal/oauth2_storage.go", "internal/oauth2_strategy.go", "internal/openid_id_token_storage.go", "internal/pkce_storage_strategy.go", "internal/refresh_token_strategy.go", "internal/request.go", "internal/revoke_handler.go", "internal/storage.go", "internal/token_handler.go", "internal/transactional.go", "storage/memory.go"], "buggy_code_start_loc": [26, 217, 24, 206, 8, 10, 29, 41, 40, 40, 40, 40, 40, 40, 41, 39, 39, 38, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 40, 9, 40, 38, 25], "buggy_code_end_loc": [152, 387, 30, 244, 29, 60, 33, 248, 133, 72, 73, 72, 73, 47, 306, 112, 130, 58, 48, 48, 72, 121, 133, 146, 149, 72, 72, 73, 236, 47, 50, 59, 70, 135], "fixing_code_start_loc": [27, 217, 24, 207, 8, 11, 30, 42, 41, 41, 41, 41, 41, 41, 42, 40, 40, 39, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 41, 10, 41, 39, 26], "fixing_code_end_loc": [177, 438, 42, 251, 26, 74, 33, 287, 152, 79, 80, 79, 80, 50, 355, 127, 147, 63, 51, 51, 79, 136, 150, 165, 168, 79, 79, 80, 273, 50, 82, 64, 77, 163], "type": "CWE-345", "message": "In ORY Fosite (the security first OAuth2 & OpenID Connect framework for Go) before version 0.31.0, when using \"private_key_jwt\" authentication the uniqueness of the `jti` value is not checked. When using client authentication method \"private_key_jwt\", OpenId specification says the following about assertion `jti`: \"A unique identifier for the token, which can be used to prevent reuse of the token. These tokens MUST only be used once, unless conditions for reuse were negotiated between the parties\". Hydra does not seem to check the uniqueness of this `jti` value. This problem is fixed in version 0.31.0.", "other": {"cve": {"id": "CVE-2020-15222", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-24T17:15:13.117", "lastModified": "2021-11-18T17:51:51.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ORY Fosite (the security first OAuth2 & OpenID Connect framework for Go) before version 0.31.0, when using \"private_key_jwt\" authentication the uniqueness of the `jti` value is not checked. When using client authentication method \"private_key_jwt\", OpenId specification says the following about assertion `jti`: \"A unique identifier for the token, which can be used to prevent reuse of the token. These tokens MUST only be used once, unless conditions for reuse were negotiated between the parties\". Hydra does not seem to check the uniqueness of this `jti` value. This problem is fixed in version 0.31.0."}, {"lang": "es", "value": "En ORY Fosite (el primer framework de seguridad OAuth2 &amp; OpenID Connect para Go) anterior a la versi\u00f3n 0.31.0, cuando se usa la autenticaci\u00f3n \"private_key_jwt\", no se verifica la unicidad del valor \"jti\".&#xa0;Cuando se usa el m\u00e9todo de autenticaci\u00f3n de cliente \"private_key_jwt\", la especificaci\u00f3n de OpenId dice lo siguiente sobre la aserci\u00f3n de \"jti\": \"Un identificador \u00fanico para el token, que se puede usar para impedir la reutilizaci\u00f3n del token. Estos tokens DEBEN ser\u00e1n usados una sola vez, a menos que existan condiciones para la reutilizaci\u00f3n se negociaba entre las partes\".&#xa0;Hydra no parece comprobar la unicidad de este valor \"jti\".&#xa0;Este problema se corrigi\u00f3 en la versi\u00f3n 0.31.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ory:fosite:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.31.0", "matchCriteriaId": "542BA3D2-FDFC-43AA-B209-BC9780EDAB7D"}]}]}], "references": [{"url": "https://github.com/ory/fosite/commit/0c9e0f6d654913ad57c507dd9a36631e1858a3e9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ory/fosite/security/advisories/GHSA-v3q9-2p3m-7g43", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ory/fosite/commit/0c9e0f6d654913ad57c507dd9a36631e1858a3e9"}}