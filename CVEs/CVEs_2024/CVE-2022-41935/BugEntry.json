{"buggy_code": ["<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.4\" reference=\"XWiki.LiveTableResultsMacros\" locale=\"\">\n  <web>XWiki</web>\n  <name>LiveTableResultsMacros</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>XWiki.WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title>$services.localization.render('platform.livetable.resultsMacros')</title>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.0</syntaxId>\n  <hidden>true</hidden>\n  <content>{{velocity output=\"false\"}}\n#template('hierarchy_macros.vm')\n\n#**\n * Macro to get the results of a livetable data call.\n * This page is called from live grids via Ajax with the argument xpage=plain. It returns a\n * set of results serialized in JSON.\n *#\n#macro(gridresult $className $collist)\n  #gridresultwithfilter($className $collist '' '' {})\n#end\n\n\n#**\n * Computes the query used to retrieve the results of a live table data call.\n * NOTE: This macro is not fully encapsulated because it defines a few Velocity variables that are used in subsequent macros.\n *#\n#macro(gridresultwithfilter_buildQuery $className $collist $filterfrom $filterwhere $filterParams)\n  ## Additional columns; should *not* contain raw parameters, all added column names must be filtered\n  #set($fromSql = '')\n  ## Parametrized filter part of the query\n  #set($whereSql = '')\n  ## List of values to use with $whereSql\n  #if (!$filterParams)\n    #set($filterParams = {})\n  #end\n  #if ($filterParams.entrySet())\n    #set($whereParams = {})\n  #else\n    #set($whereParams = [])\n  #end\n  #set($class = $xwiki.getDocument($className).getxWikiClass())\n  ##\n  ## Add the columns needed for the actual data\n  ##\n  #set($tablelist = [])\n  #foreach($colname in $collist)\n    #livetable_addColumnToQuery($colname)\n  #end\n  ##\n  ## Tag filtering\n  ##\n  #if($request.tag)\n    #set($fromSql = \"${fromSql} , BaseObject as tobject, DBStringListProperty as tagprop\")\n    #set($whereSql = \"${whereSql} and tobject.className='XWiki.TagClass' and tobject.name=doc.fullName and tobject.id=tagprop.id.id and tagprop.id.name='tags' and (\")\n    #foreach($tag in $request.getParameterValues('tag'))\n      #if($foreach.count &gt; 1) #set($whereSql = \"${whereSql} and \") #end\n      ## Tags are case insensitive but they are stored unchanged which means we have to normalize them when performing\n      ## a query. Unfortunately there's no simple way to match multiple tags (AND operator). If we join the list of\n      ## tags in the FROM clause then we match at least one of the tags (OR operator). The only remaining option is to\n      ## check that the list of tags contains each of the desired tags. HQL doesn't help us to lower-case the entire\n      ## list of tags so we use an inner select for this.\n      #if ($whereParams.entrySet())\n        #set($whereSql = \"${whereSql} lower(:wikitag${foreach.count}) in (select lower(tag) from tagprop.list tag)\")\n        #set($discard = $whereParams.put(\"wikitag$foreach.count\", \"${tag}\"))\n      #else\n        #set($whereSql = \"${whereSql} lower(?) in (select lower(tag) from tagprop.list tag)\")\n        #set($discard = $whereParams.add(\"${tag}\"))\n      #end\n    #end\n    #set($whereSql = \"${whereSql})\")\n  #end\n  ##\n  ##\n  ## Order\n  ##\n  ## if the object for the classname of the order column is not already in the from sql, put it\n  #macro(addObjectClause $objectAlias)\n    #if($fromSql.indexOf($objectAlias) &lt; 0)\n      #set($fromSql = \"${fromSql}, BaseObject $objectAlias\")\n      #if ($whereParams.entrySet())\n        #set($whereSql = \"${whereSql} and ${objectAlias}.name = doc.fullName and ${objectAlias}.className = :${objectAlias}_className\")\n        #set($discard = $whereParams.put(\"${objectAlias}_className\", $propClassName))\n      #else\n        #set($whereSql = \"${whereSql} and ${objectAlias}.name = doc.fullName and ${objectAlias}.className = ?\")\n        #set($discard = $whereParams.add($propClassName))\n      #end\n    #end\n  #end\n  ## Set the order clause for a field. We first ignore the case using the lower function (so that e.g. 'aaa' equals 'AAA')\n  ## but then consider it only for equal values (so that e.g. 'AAA' comes before 'aaa').\n  #macro(setOrderClause $fieldName $direction $useRawValue)\n    #if ($useRawValue)\n      #set($orderSql = \" order by ${fieldName} ${direction}\")\n    #else\n      #set($orderSql = \" order by lower(${fieldName}) ${direction}, ${fieldName} ${direction}\")\n    #end\n  #end\n  #set($order = \"$!request.sort\")\n  #if ($order == 'doc.location')\n    #set ($order = 'doc.fullName')\n  #end\n  #set ($orderSql = '')\n  #if($order != '')\n    #set($orderDirection = \"$!{request.get('dir').toLowerCase()}\")\n    #if(\"$!orderDirection\" != '' &amp;&amp; \"$!orderDirection\" != 'asc')\n      #set($orderDirection = 'desc')\n    #end\n    #livetable_getTableAlias($order)\n    #if($order.startsWith('doc.'))\n      ## The column is a document field.\n      ##\n      ## These document fields need to be ordered as raw values and not as strings.\n      #set($rawDocumentFields = ['translation', 'date', 'contentUpdateDate', 'creationDate', 'elements', 'minorEdit1', 'hidden'])\n      #set($documentField = $stringtool.removeStart($order, 'doc.'))\n      #setOrderClause(${safe_tableAlias.replace('_','.')}, ${orderDirection},  $rawDocumentFields.contains($documentField))\n    #else\n      ## The column is an object property.\n      ##\n      ## Resolve the property.\n      #livetable_getPropertyClassAndType($order)\n      #set ($multiselect = \"$!{propClass.get($order).getProperty('multiSelect').getValue()}\")\n      ## We can only handle single values, not multiselect ones.\n      #if ($multiselect != '1')\n        ## Some property types do not need lowercasing since they have unique values by design, so we use the raw values to order.\n        #set($rawPropertyTypes = ['NumberClass', 'BooleanClass', 'DateClass', 'LevelsClass'])\n        ## If the order column is also a filer column, this means that it was already added to the query and all we need to do is to add it to the order clause.\n        #if(!$tablelist.contains($order))\n          ## The order column is not also a filter column, so not yet defined in the query.\n          ## We need to first define it (to the from and where clauses) before we can add it to the order clause.\n          ##\n          ## Resolve the table name of the property to be used in the from clause below.\n          #livetable_getTableName($order)\n          ## If the sort column has a _class specified, join that object in\n          #set($orderObjectAlias = 'obj')\n          #if($propClassName != '' &amp;&amp; \"$!propClass\" != '')\n            ## prepare the alias of the BaseObject table that corresponds to the class of this column\n            #set($orderObjectAlias = \"$!{propClassName.replaceAll('[^a-zA-Z0-9_]', '')}_obj\")\n            #addObjectClause($orderObjectAlias)\n          #end\n          #set($fromSql = \"${fromSql}, ${tableName} ${safe_tableAlias}\")\n          ## FIXME: Check if this is indeed a property of the class. Hint: $propType can be used.\n          ## Conditions are put on the object coresponding to the column of the order ($orderObjectAlias), which depends on which is the class of the $order\n          #if ($whereParams.entrySet())\n            #set($whereSql = \"${whereSql} and ${orderObjectAlias}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.name = :${safe_tableAlias}_name\")\n            #set($discard = $whereParams.put(\"${safe_tableAlias}_name\", \"${order}\"))\n          #else\n            #set($whereSql = \"${whereSql} and ${orderObjectAlias}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.name = ?\")\n            #set($discard = $whereParams.add(\"${order}\"))\n          #end\n        #end\n        ## Add the column to the order clause.\n        #setOrderClause(\"${safe_tableAlias}.value\", ${orderDirection}, $rawPropertyTypes.contains($propType))\n      #end\n    #end\n  #end\n  ##\n  ##\n  ## Compute the final queries\n  ##\n  #if ($filterParams.entrySet())\n    #set($sqlParams = {})\n    #set($tagsMatchingParams = {})\n    #set($allMatchingParams = {})\n  #else\n    #set($sqlParams = [])\n    #set($tagsMatchingParams = [])\n    #set($allMatchingParams = [])\n  #end\n  #if(\"$!className\" != '')\n    ## Class query\n    #if ($sqlParams.entrySet())\n      #set($sql = \", BaseObject as obj $!fromSql $!filterfrom where obj.name=doc.fullName and obj.className = :className and doc.fullName not in (:classTemplate1, :classTemplate2) $!whereSql $!filterwhere\")\n      #set($discard = $sqlParams.put('className', \"${className}\"))\n      #set($discard = $sqlParams.put('classTemplate1', \"${className}Template\"))\n      #set($discard = $sqlParams.put('classTemplate2', ${className.replaceAll('Class$', 'Template')}))\n      #set($discard = $sqlParams.putAll($whereParams))\n    #else\n      #set($sql = \", BaseObject as obj $!fromSql $!filterfrom where obj.name=doc.fullName and obj.className = ? and doc.fullName not in (?, ?) $!whereSql $!filterwhere\")\n      #set($discard = $sqlParams.addAll([\"${className}\", \"${className}Template\", ${className.replaceAll('Class$', 'Template')}]))\n      #set($discard = $sqlParams.addAll($whereParams))\n    #end\n    ##\n    #set($tagsMatchingFiltersFrom = \", BaseObject as obj $!fromSql $!filterfrom\")\n    #if ($tagsMatchingParams.entrySet())\n      #set($tagsMatchingFiltersWhere = \"obj.name=doc.fullName and obj.className = :className and doc.fullName not in (:classTemplate1, :classTemplate2) $!whereSql $!filterwhere\")\n      #set($discard = $tagsMatchingParams.put('className', \"${className}\"))\n      #set($discard = $tagsMatchingParams.put('classTemplate1', \"${className}Template\"))\n      #set($discard = $tagsMatchingParams.put('classTemplate2', ${className.replaceAll('Class$', 'Template')}))\n      #set($discard = $tagsMatchingParams.putAll($whereParams))\n    #else\n      #set($tagsMatchingFiltersWhere = \"obj.name=doc.fullName and obj.className = ? and doc.fullName not in (?, ?) $!whereSql $!filterwhere\")\n      #set($discard = $tagsMatchingParams.addAll([\"${className}\", \"${className}Template\", ${className.replaceAll('Class$', 'Template')}]))\n      #set($discard = $tagsMatchingParams.addAll($whereParams))\n    #end\n    ##\n    #set($allMatchingTagsFrom = \", BaseObject as obj $!filterfrom\")\n    #if ($allMatchingParams.entrySet())\n      #set($allMatchingTagsWhere = \"obj.name=doc.fullName and obj.className = :className and doc.fullName not in (:classTemplate1, :classTemplate2) $!filterwhere\")\n      #set($discard = $allMatchingParams.put('className', \"${className}\"))\n      #set($discard = $allMatchingParams.put('classTemplate1', \"${className}Template\"))\n      #set($discard = $allMatchingParams.put('classTemplate2', ${className.replaceAll('Class$', 'Template')}))\n    #else\n      #set($allMatchingTagsWhere = \"obj.name=doc.fullName and obj.className = ? and doc.fullName not in (?, ?) $!filterwhere\")\n      #set($discard = $allMatchingParams.addAll([\"${className}\", \"${className}Template\", ${className.replaceAll('Class$', 'Template')}]))\n    #end\n    ##\n    #if($filterParams)\n      #if ($filterParams.entrySet())\n        #set($discard = $sqlParams.putAll($filterParams))\n        #set($discard = $tagsMatchingParams.putAll($filterParams))\n        #set($discard = $allMatchingParams.putAll($filterParams))\n      #else\n        #set($discard = $sqlParams.addAll($filterParams))\n        #set($discard = $tagsMatchingParams.addAll($filterParams))\n        #set($discard = $allMatchingParams.addAll($filterParams))\n      #end\n    #end\n  #else\n    ## Document query\n    #set($sql = \"$!fromSql $!filterfrom where 1=1 $!whereSql $!filterwhere\")\n    #if ($whereParams.entrySet())\n      #set($discard = $sqlParams.putAll($whereParams))\n    #else\n      #set($discard = $sqlParams.addAll($whereParams))\n    #end\n    ##\n    #set($tagsMatchingFiltersFrom = \"$!fromSql $!filterfrom\")\n    #set($tagsMatchingFiltersWhere = \"1=1 $!whereSql $!filterwhere\")\n    #if ($whereParams.entrySet())\n      #set($discard = $tagsMatchingParams.putAll($whereParams))\n    #else\n      #set($discard = $tagsMatchingParams.addAll($whereParams))\n    #end\n    ##\n    #set($allMatchingTagsFrom = \"$!filterfrom\")\n    #set($allMatchingTagsWhere = \"1=1 $!filterwhere\")\n    ##\n    #if($filterParams)\n      #if ($filterParams.entrySet())\n        #set($discard = $sqlParams.putAll($filterParams))\n        #set($discard = $tagsMatchingParams.putAll($filterParams))\n        #set($discard = $allMatchingParams.putAll($filterParams))\n      #else\n        #set($discard = $sqlParams.addAll($filterParams))\n        #set($discard = $tagsMatchingParams.addAll($filterParams))\n        #set($discard = $allMatchingParams.addAll($filterParams))\n      #end\n    #end\n  #end\n  #if($orderSql != '')\n    #set($sql = \"$sql $!{orderSql}\")\n  #end\n#end\n#**\n * Adds TagCloud information to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables defined by gridresultwithfilter_buildQuery.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildTagCloudJSON $map)\n  ##\n  ## TagCloud matching the current filters\n  ##\n  #set($tagsMatchingFilters = $xwiki.tag.getTagCountForQuery($tagsMatchingFiltersFrom, $tagsMatchingFiltersWhere, $tagsMatchingParams))\n  ## FIXME: We use a map just because the client expects an object, but all we really need is a list..\n  #set($matchingTags = {})\n  #foreach($tag in $tagsMatchingFilters.keySet())\n    ## NOTE: The value doesn't have a special meaning. I've used 1 just because it takes less space when serialized.\n    #set($discard = $matchingTags.put($tag, 1))\n  #end\n  #set($discard = $map.put('matchingtags', $matchingTags))\n  ##\n  ## TagCloud matching all the documents used by the live table\n  ##\n  #set($allMatchingTags = $xwiki.tag.getTagCountForQuery($allMatchingTagsFrom, $allMatchingTagsWhere, $allMatchingParams))\n  ## FIXME: We use a list of maps just because the client expects an array, but we should simply return $allMatchingTags..\n  #set($tags = [])\n  #foreach($tag in $allMatchingTags.keySet())\n    #set($discard = $tags.add({'tag': $tag, 'count': $allMatchingTags.get($tag)}))\n  #end\n  #set($discard = $map.put('tags', $tags))\n#end\n\n\n#**\n * Adds information about each live table row to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables defined by gridresultwithfilter_buildQuery.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildRowsJSON $map)\n  #set($offset = $numbertool.toNumber($request.get('offset')).intValue())\n  ## Offset starts from 0 in velocity and 1 in javascript\n  #set($offset = $offset - 1)\n  #if(!$offset || $offset &lt; 0)\n    #set($offset = 0)\n  #end\n  #set($limit = $numbertool.toNumber($request.get('limit')).intValue())\n  #if(!$limit)\n    #set ($limit = 15)\n  #end\n  #set($query = $services.query.hql($sql))\n  ## Apply query filters if defined. Otherwise use default.\n  #foreach ($queryFilter in $stringtool.split($!request.queryFilters, ', '))\n    #set ($query = $query.addFilter($queryFilter))\n  #end\n  #set ($query = $query.setLimit($limit).setOffset($offset).bindValues($sqlParams))\n  #set($items = $query.execute())\n  #set($discard = $map.put('totalrows', $query.count()))\n  #set($discard = $map.put('returnedrows', $mathtool.min($items.size(), $limit)))\n  #set($discard = $map.put('offset', $mathtool.add($offset, 1)))\n  #set($rows = [])\n  #foreach($item in $items)\n    #gridresult_buildRowJSON($item $rows)\n  #end\n  #set ($discard = $map.put('rows', $rows))\n  #livetable_filterObfuscated($map)\n#end\n\n\n#**\n * Adds information about the specified live table row to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables available in gridresult_buildRowsJSON.\n *\n * @param $item the name of the document that feeds this live table row\n * @param $rows stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildRowJSON $item $rows)\n  ## Handle both the case where the \"language\" filter is used and thus languages are returned too and the case where\n  ## only the document name is returned. When more than the document name is returned the $item variable is a list.\n  #if($item.size())\n    ## Extract doc name and doc language from $item\n    #set($docName = $item[0])\n    #set($docLanguage = $item[1])\n  #else\n    #set($docName = $item)\n    #set($docLanguage = '')\n  #end\n  #set ($docReference = $services.model.resolveDocument($docName))\n  #set ($isViewable = $services.security.authorization.hasAccess('view', $docReference))\n  #if ($isViewable)\n    #set ($row = {\n      'doc_viewable': $isViewable,\n      'doc_fullName': $services.model.serialize($docReference, 'local'),\n      'doc_space': $services.model.serialize($docReference.parent, 'local'),\n      'doc_location': \"#hierarchy($docReference, {'limit': 5, 'plain': false, 'local': true, 'displayTitle': false})\",\n      'doc_url': $xwiki.getURL($docReference),\n      'doc_space_url': $xwiki.getURL($docReference.parent),\n      'doc_wiki': $docReference.wikiReference.name,\n      'doc_wiki_url': $xwiki.getURL($docReference.wikiReference),\n      'doc_hasadmin': $xwiki.hasAdminRights(),\n      'doc_hasedit': $services.security.authorization.hasAccess('edit', $docReference),\n      'doc_hasdelete': $services.security.authorization.hasAccess('delete', $docReference),\n      'doc_edit_url': $xwiki.getURL($docReference, 'edit'),\n      'doc_copy_url': $xwiki.getURL($docReference, 'view', 'xpage=copy'),\n      'doc_delete_url': $xwiki.getURL($docReference, 'delete'),\n      'doc_rename_url': $xwiki.getURL($docReference, 'view', 'xpage=rename&amp;step=1')\n    })\n    #set ($isTranslation = \"$!docLanguage\" != '' &amp;&amp; $xwiki.getLanguagePreference() != $docLanguage)\n    ## Display the language after the document name so that not all translated documents have the same name displayed.\n    #set ($row.doc_name = \"$docReference.name#if ($isTranslation) ($docLanguage)#end\")\n    #set ($row.doc_hascopy = $row.doc_viewable)\n    #set ($row.doc_hasrename = $row.doc_hasdelete)\n    #set ($row.doc_hasrights = $row.doc_hasedit &amp;&amp; $isAdvancedUser)\n    #if ($docReference.name == 'WebHome')\n    \n      ## For nested pages, use the page administration.\n      #set ($webPreferencesReference = $services.model.createDocumentReference(\n        'WebPreferences', $docReference.lastSpaceReference))\n      #set ($row.doc_rights_url = $xwiki.getURL($webPreferencesReference, 'admin',\n        'editor=spaceadmin&amp;section=PageRights'))\n    #else\n      ## For terminal pages, use the old rights editor.\n      ## TODO: We should create a page administration for terminal pages too.\n      #set ($row.doc_rights_url = $xwiki.getURL($docReference, 'edit', 'editor=rights'))\n    #end\n    #if ($row.doc_viewable)\n      #set ($itemDoc = $xwiki.getDocument($docReference))\n      ## Handle translations. We need to make sure we display the data associated to the correct document if the returned\n      ## result is a translation.\n      #if ($isTranslation)\n        #set ($translatedDoc = $itemDoc.getTranslatedDocument($docLanguage))\n      #else\n        #set ($translatedDoc = $itemDoc.translatedDocument)\n      #end\n      #set($discard = $itemDoc.use($className))\n      #set($discard = $row.put('doc_objectCount', $itemDoc.getObjectNumbers($className)))\n      #set($discard = $row.put('doc_edit_url', $itemDoc.getURL($itemDoc.defaultEditMode)))\n      #set($discard = $row.put('doc_author_url', $xwiki.getURL($translatedDoc.author)))\n      #set($discard = $row.put('doc_date', $xwiki.formatDate($translatedDoc.date)))\n      #set($discard = $row.put('doc_title', $translatedDoc.plainTitle))\n      #set($rawTitle = $translatedDoc.title)\n      #if($rawTitle != $row['doc_title'])\n        #set($discard = $row.put('doc_title_raw', $rawTitle))\n      #end\n      #set($discard = $row.put('doc_author', $xwiki.getPlainUserName($translatedDoc.authorReference)))\n      #set($discard = $row.put('doc_creationDate', $xwiki.formatDate($translatedDoc.creationDate)))\n      #set($discard = $row.put('doc_creator', $xwiki.getPlainUserName($translatedDoc.creatorReference)))\n      #set($discard = $row.put('doc_hidden', $translatedDoc.isHidden()))\n      #foreach($colname in $collist)\n        #gridresult_buildColumnJSON($colname $row)\n      #end\n    #end\n  #else\n    #set ($row = {\n      'doc_viewable': $isViewable,\n      'doc_fullName': 'obfuscated'\n    })\n  #end\n  #set($discard = $rows.add($row))\n#end\n\n\n#**\n * Adds information about the given column to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables available in gridresult_buildRowJSON.\n *\n * @param $colname the name of the live table column for which to retrieve information\n * @param $row stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildColumnJSON $colname $row)\n  #if($colname.startsWith('doc.'))\n  #elseif($colname == '_action')\n    #set($discard = $row.put($colname, $services.localization.render(\"${request.transprefix}actiontext\")))\n  #elseif($colname == '_attachments')\n    #livetable_getAttachmentsList($translatedDoc)\n    #set($discard = $row.put($colname, $attachlist))\n  #elseif($colname == '_avatar')\n    #livetable_getAvatar($itemDoc)\n    #set($discard = $row.put($colname, $avatar))\n  #elseif($colname == '_images')\n    #livetable_getImagesList($itemDoc)\n    #set($discard = $row.put($colname, $imagesList))\n  ## Output likes if they are available.\n  #elseif($colname == '_likes' &amp;&amp; \"$!services.like\" != \"\")\n    #set($likes = $services.like.getLikes($docReference))\n    #if ($likes.isPresent())\n      #set($discard = $row.put('_likes', $likes.get()))\n    #end\n  #else\n    #livetable_getPropertyClassAndType($colname)\n    #if(!$propClass.equals($class))\n      #set($discard = $itemDoc.use($propClassName))\n    #end\n    #set($fieldObject = $itemDoc.getFirstObject($colname))\n    #set($fieldProperty = $fieldObject.getProperty($colname))\n    #if ($fieldProperty.getPropertyClass().classType == 'Password')\n      #set($fieldValue = '********')\n    #else\n      #set($fieldValue = \"$!fieldProperty.getValue()\")\n    #end\n    #set($fieldDisplayValue = \"$!itemDoc.display($colname, 'view')\")\n    #if($fieldDisplayValue == '')\n      #set($fieldDisplayValue = $services.localization.render(\"${request.transprefix}emptyvalue\"))\n    #end\n    #set($fieldUrl = '')\n    ## Only retrieve an URL for a DBListClass item\n    #if(($propType == 'DBListClass' || $propType == 'PageClass') &amp;&amp; $propClass.get($colname).getProperty('multiSelect').value != 1)\n      #set($fieldUrl = $xwiki.getURL($fieldValue))\n      #if($fieldUrl == $xwiki.getURL($services.model.resolveDocument('', 'default', $doc.documentReference.extractReference('WIKI'))))\n        #set($fieldUrl = '')\n      #end\n    #end\n    #set($discard = $row.put($colname, $fieldDisplayValue.replaceFirst($regextool.quote('{{html clean=\"false\" wiki=\"false\"}}'), '').replaceAll(\"$regextool.quote('{{/html}}')$\", '')))\n    #set($discard = $row.put(\"${colname}_value\", $fieldValue))\n    #set($discard = $row.put(\"${colname}_url\", $fieldUrl))\n    ## Reset to the default class\n    #set($discard = $itemDoc.use($className))\n  #end\n#end\n\n\n#**\n * Builds the JSON response to a live table data call.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresultwithfilter_buildJSON $className $collist $filterfrom $filterwhere $filterParams $map)\n  #gridresultwithfilter_buildQuery($className $collist $filterfrom $filterwhere $filterParams)\n  #if(\"$!request.sql\" == '1')\n    #set($discard = $map.put('sql', $sql))\n    #set($discard = $map.put('params', $sqlParams))\n  #end\n  #set($discard = $map.put('reqNo', $numbertool.toNumber($request.reqNo).intValue()))\n  #gridresult_buildTagCloudJSON($map)\n  #gridresult_buildRowsJSON($map)\n#end\n\n\n#**\n * Builds the JSON response to a live table data call.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildJSON $className $collist $map)\n  #gridresultwithfilter_buildJSON($className $collist '' '' {} $map)\n#end\n\n\n#**\n * Macro to get the results of a livetable data call.\n * This page is called from live grids via Ajax with the argument xpage=plain. It returns a\n * set of results serialized in JSON.\n *#\n#macro(gridresultwithfilter $className $collist $filterfrom $filterwhere $filterParams)\n  #if($xcontext.action == 'get' &amp;&amp; \"$!{request.outputSyntax}\" == 'plain')\n    ## Build the JSON in memory (using basic Java data types) so that it can be adjusted before serialization.\n    #set($map = {})\n    #gridresultwithfilter_buildJSON($className $collist $filterfrom $filterwhere $filterParams $map)\n    #jsonResponse($map)\n  #end\n#end\n\n\n#**\n * Get the name of the Property that should be used for a given livetable column.\n * NOTE the resulting $tableName is safe to use inside SQL queries\n *#\n#macro(livetable_getTableName $colname)\n  #livetable_getPropertyClassAndType($colname)\n  #if($propType == 'NumberClass')\n    #set($numberType = $propClass.get($colname).getProperty('numberType').getValue())\n    #if($numberType == 'integer')\n      #set($tableName = 'IntegerProperty')\n    #elseif($numberType == 'float')\n      #set($tableName = 'FloatProperty')\n    #elseif($numberType == 'double')\n      #set($tableName = 'DoubleProperty')\n    #else\n      #set($tableName = 'LongProperty')\n    #end\n  #elseif($propType == 'BooleanClass')\n    #set($tableName = 'IntegerProperty')\n  #elseif($propType == 'DateClass')\n    #set($tableName = 'DateProperty')\n  #elseif($propType == 'TextAreaClass' || $propType == 'UsersClass' || $propType == 'GroupsClass')\n    #set($tableName = 'LargeStringProperty')\n  #elseif($propType == 'StaticListClass' || $propType == 'DBListClass' || $propType == 'DBTreeListClass' || $propType == 'PageClass')\n    #set($multiSelect = $propClass.get($colname).getProperty('multiSelect').getValue())\n    #set($relationalStorage = $propClass.get($colname).getProperty('relationalStorage').getValue())\n    #if($multiSelect == 1)\n      #if($relationalStorage == 1)\n        #set($tableName = 'DBStringListProperty')\n      #else\n        #set($tableName = 'StringListProperty')\n      #end\n    #else\n      #set($tableName = 'StringProperty')\n    #end\n  #else\n    #set($tableName = 'StringProperty')\n  #end\n#end\n\n#**\n * Get the property class and type for a given livetable column.\n *#\n#macro(livetable_getPropertyClassAndType $colname)\n  #set($propClassName = \"$!request.get(${colname.concat('_class')})\")\n  #if($propClassName != '')\n    #set($propClass = $xwiki.getDocument($propClassName).getxWikiClass())\n  #else\n    #set($propClass = $class)\n  #end\n  #set($propType = '')\n  #if($propClass.getPropertyNames().contains($colname))\n    #set($propType = \"$!{propClass.get($colname).type}\")\n  #end\n#end\n\n#**\n * Old alias of the #livetable_getTableName macro.\n * @deprecated since 2.2.3, use {@link #livetable_getTableName}\n *#\n#macro(grid_gettablename $colname)\n  #livetable_getTableName($colname)\n#end\n\n\n\n#**\n * List attachments for a document, putting the result as HTML markup in the $attachlist variable.\n *#\n#macro(livetable_getAttachmentsList $itemDoc)\n  #set($attachlist = '')\n  #foreach($attachment in $itemDoc.attachmentList)\n    #set($attachmentUrl = $itemDoc.getAttachmentURL($attachment.filename))\n    #set($attachlist = \"${attachlist}&lt;a href='${attachmentUrl}'&gt;$attachment.filename&lt;/a&gt;&lt;br/&gt;\")\n  #end\n#end\n\n#**\n * Old alias of the #livetable_getAttachmentsList macro.\n * @deprecated since 2.2.3, use {@link #livetable_getAttachmentsList}\n *#\n#macro(grid_attachlist $itemDoc)\n  #livetable_getAttachmentsList($itemDoc)\n#end\n\n\n\n#**\n * List image attachments for a document, putting the result as HTML markup in the $imagesList variable.\n *#\n#macro(livetable_getImagesList $itemDoc)\n  #set($imagesList = '')\n  #foreach ($attachment in $itemDoc.attachmentList)\n    #if($attachment.isImage())\n      ## Create a thumbnail by resizing the image on the server side, if needed, to fit inside a 50x50 pixel square.\n      #set($thumbnailURL = $itemDoc.getAttachmentURL($attachment.filename, 'download', \"width=50&amp;height=50&amp;keepAspectRatio=true\"))\n      #set($imageURL = $itemDoc.getAttachmentURL($attachment.filename))\n      #set($imagesList = \"${imagesList}&lt;a href=\"\"$imageURL\"\"&gt;&lt;img src=\"\"$thumbnailURL\"\" alt=\"\"$attachment.filename\"\" title=\"\"$attachment.filename\"\" /&gt;&lt;/a&gt;\")\n    #end\n  #end\n#end\n\n#**\n * Old alias of the #livetable_getImagesList macro.\n * @deprecated since 2.2.3, use {@link #livetable_getImagesList}\n *#\n#macro(grid_photolist $itemDoc)\n  #livetable_getImagesList($itemDoc)\n#end\n\n\n#**\n * Generate the HTML code for a user avatar.\n *#\n#macro(livetable_getAvatar $itemDoc)\n  #set ($avatar = \"#mediumUserAvatar($itemDoc.fullName)\")\n  #set ($avatar = $avatar.trim())\n#end\n\n#**\n * Old alias of the #livetable_getAvatar macro.\n * @deprecated since 2.2.3, use {@link #livetable_getAvatar}\n *#\n#macro(grid_avatar $itemDoc)\n  #livetable_getAvatar($itemDoc)\n#end\n\n\n\n#**\n * Macro to extend the query to select the properties for the livetable columns.\n * NOTE $colName is filtered (all characters but [a-zA-Z0-9_.] are removed) before use\n *#\n#macro (livetable_addColumnToQuery $colName)\n  ## Safe because / is not allowed in property names\n  ## The $joinModeMarker is used in #livetable_filterDBStringListProperty.\n  #set ($joinModeMarker = \"/join_mode\")\n  #if (!$colName.endsWith($joinModeMarker))\n    #set ($filterValue = \"$!request.getParameter($colName)\")\n    #if (\"$!filterValue\" != '')\n      #set ($discard = $tablelist.add($colName))\n      ## Some columns may support filtering with multiple constraints (multiple filter values).\n      #set ($filterValues = $request.getParameterValues($colName))\n      #if ($colName.startsWith('doc.'))\n        #if ($colName == 'doc.location')\n          #set ($safeColName = 'doc.fullName')\n          ## Use filterLocation since addLivetableLocationFilter is buggy when called several times (it'll add the\n          ## same HQL binding name every time it's called! See https://jira.xwiki.org/browse/XWIKI-17463).\n          ## Also note that we don't call addLocationFilter since we use a Map for $params.\n          #filterLocation($whereSql, $whereParams, $filterValue, 'locationFilterValue2', true)\n        #elseif ($colName == 'doc.date' || $colName == 'doc.creationDate' || $colName == 'doc.contentUpdateDate')\n          #livetable_getTableAlias($colName)\n          #livetable_filterDateProperty()\n        #else\n          #set ($safeColName = $colName.replaceAll('[^a-zA-Z0-9_.]', '').replace('_', '.'))\n          #if ($whereParams.entrySet())\n            #set ($whereSql = \"${whereSql} and upper(str($safeColName)) like upper(:${safeColName.replace('.', '_')}_filter)\")\n            #set ($discard = $whereParams.put(\"${safeColName.replace('.', '_')}_filter\", \"%$filterValue%\"))\n          #else\n            #set ($whereSql = \"${whereSql} and upper(str($safeColName)) like upper(?)\")\n            #set ($discard = $whereParams.add(\"%$filterValue%\"))\n          #end\n        #end\n      #else\n        #livetable_filterProperty($colName)\n      #end\n    #end\n  #end\n#end\n\n\n#**\n * Determine how the filter values should be matched against the stored values. This macro sets two variables:\n * &lt;ul&gt;\n *   &lt;li&gt;$matchType: use this when the specified column supports only a single filter value&lt;/li&gt;\n *   &lt;li&gt;$matchTypes: use this when the specified column supports multiple filter values.&lt;/li&gt;\n * &lt;/ul&gt;\n *\n * @param column the column name; each column can have a different match type\n * @param filterValueCount the number of filter values for which to determine the match type; each filter value can have\n *          a different match type\n * @param defaultMatchType the default match type to use for the given column when the request doesn't specify one\n *#\n#macro (livetable_getMatchTypes $column $filterValueCount $defaultMatchType)\n  #set ($macro.matchTypes = $request.getParameterValues(\"${column}_match\"))\n  #if (!$macro.matchTypes || $macro.matchTypes.isEmpty())\n    ## No match type specified for this column.\n    #set ($matchType = $defaultMatchType)\n    #set ($matchTypes = $stringtool.repeat($matchType, ',', $filterValueCount).split(','))\n  #else\n    ## At least one match type specified for this column.\n    #set ($matchType = $macro.matchTypes.get(0))\n    #set ($matchTypes = [])\n    #set ($discard = $matchTypes.addAll($macro.matchTypes.subList(0, $mathtool.min($macro.matchTypes.size(),\n      $filterValueCount))))\n    #if ($matchTypes.size() &lt; $filterValueCount)\n      ## Add missing match types.\n      #set ($discard = $matchTypes.addAll($stringtool.repeat($matchType, ',', $mathtool.sub($filterValueCount,\n        $matchTypes.size())).split(',')))\n    #end\n  #end\n#end\n\n\n#macro (livetable_filterProperty $colname)\n  #livetable_getTableAlias($colname)\n  #livetable_getTableName($colname)\n  #set ($fromSql = \"$fromSql, $tableName as $safe_tableAlias\")\n  ##\n  ## If the column is not from $class, we need to make sure we join with the proper table.\n  #set ($filterObjectAlias = 'obj')\n  #set ($propClass = $class)\n  #set ($propClassName = $request.getParameter(\"${colname}_class\"))\n  #if (\"$!propClassName\" != '')\n    #set ($propClass = $xwiki.getDocument($propClassName).getxWikiClass())\n    #if (\"$!propClass\" != '')\n      ## Prepare the alias of the BaseObject table that corresponds to the class of this column\n      ## Property table is to be joined with its object, determined depending on $propClassName.\n      #set ($filterObjectAlias = \"$!{propClassName.replaceAll('[^a-zA-Z0-9_]', '')}_obj\")\n      #addObjectClause($filterObjectAlias)\n    #end\n  #end\n  #if ($whereParams.entrySet())\n    #set ($joinObjectTable = \"${filterObjectAlias}.id = ${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = :${safe_tableAlias}_id_name\")\n    #set ($discard = $whereParams.put(\"${safe_tableAlias}_id_name\", $colname))\n  #else\n    #set ($joinObjectTable = \"${filterObjectAlias}.id = ${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ?\")\n    #set ($discard = $whereParams.add($colname))\n  #end\n  #set ($whereSql = \"$whereSql and $joinObjectTable\")\n  ##\n  ## We determine the default match type (when not specified) based on the property meta class (e.g. DateClass).\n  #set ($propMetaClass = $NULL)\n  #if ($propClass &amp;&amp; $propClass.getPropertyNames().contains($colname))\n    #set ($propMetaClass = $propClass.get($colname).type)\n  #end\n  ##\n  #set ($numberProperties = ['IntegerProperty', 'LongProperty', 'FloatProperty', 'DoubleProperty'])\n  #if ($numberProperties.contains($tableName))\n    #livetable_filterNumberProperty()\n  #elseif ($tableName == 'DateProperty')\n    #livetable_filterDateProperty()\n  #elseif ($tableName == 'DBStringListProperty')\n    #livetable_filterDBStringListProperty()\n  #elseif ($tableName == 'StringListProperty')\n    #livetable_filterStringListProperty()\n  #else\n    ## StringProperty or LargeStringProperty\n    #livetable_filterStringProperty()\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterNumberProperty)\n  #set($numberValue = $numbertool.toNumber($filterValue))\n  #if($tableName == 'IntegerProperty' || $tableName == 'LongProperty')\n    #if($tableName == 'LongProperty')\n      #set($numberValue = $numberValue.longValue())\n    #else\n      ## IntegerProperty\n      #set($numberValue = $numberValue.intValue())\n    #end\n    #if ($whereParams.entrySet())\n      #set($whereSql = \"${whereSql} and ${safe_tableAlias}.value = :${safe_tableAlias}_value\")\n      #set($discard = $whereParams.put(\"${safe_tableAlias}_value\", $numberValue))\n    #else\n      #set($whereSql = \"${whereSql} and ${safe_tableAlias}.value = ?\")\n      #set($discard = $whereParams.add($numberValue))\n    #end\n  #else\n    #if($tableName == 'FloatProperty')\n      #set($numberValue = $numberValue.floatValue())\n    #else\n      ## DoubleProperty\n      #set($numberValue = $numberValue.doubleValue())\n    #end\n    #set($precision = 0.000001)\n    #if ($whereParams.entrySet())\n      #set($whereSql = \"${whereSql} and abs(:${safe_tableAlias}_value - ${safe_tableAlias}.value) &lt;= ${precision}\")\n      #set($discard = $whereParams.put(\"${safe_tableAlias}_value\", $numberValue))\n    #else\n      #set($whereSql = \"${whereSql} and abs(? - ${safe_tableAlias}.value) &lt;= ${precision}\")\n      #set($discard = $whereParams.add($numberValue))\n    #end\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterDateProperty)\n  #if ($safe_tableAlias.startsWith('doc.'))\n    #set ($dateProperty = $safe_tableAlias)\n  #else\n    #set ($dateProperty = \"${safe_tableAlias}.value\")\n  #end\n  #set ($safeDateProperty = $dateProperty.replace('.', '_'))\n  #set ($dateRange = {})\n  ## Perform partial string matching by default if no match type is specified.\n  ## Note that for the moment we support only one filter value (e.g. one date range) and thus only the first match type\n  ## is taken into account.\n  #livetable_getMatchTypes($colname $filterValues.size() 'partial')\n  #parseDateRange($matchType $filterValue $dateRange)\n  #if ($dateRange.start || $dateRange.end)\n    ## Date range.\n    #if ($dateRange.start)\n      #if ($whereParams.entrySet())\n        #set ($whereSql = \"${whereSql} and $dateProperty &gt;= :${safeDateProperty}1\")\n        #set ($discard = $whereParams.put(\"${safeDateProperty}1\", $dateRange.start))\n      #else\n        #set ($whereSql = \"${whereSql} and $dateProperty &gt;= ?\")\n        #set ($discard = $whereParams.add($dateRange.start))\n      #end\n    #end\n    #if ($dateRange.end)\n      #if ($whereParams.entrySet())\n        #set ($whereSql = \"${whereSql} and $dateProperty &lt;= :${safeDateProperty}2\")\n        #set ($discard = $whereParams.put(\"${safeDateProperty}2\", $dateRange.end))\n      #else\n        #set ($whereSql = \"${whereSql} and $dateProperty &lt;= ?\")\n        #set ($discard = $whereParams.add($dateRange.end))\n      #end\n    #end\n  #else\n    ## String matching (contains).\n    #if ($whereParams.entrySet())\n      #set ($whereSql = \"${whereSql} and upper(str($dateProperty)) like upper(:$safeDateProperty)\")\n      #set ($discard = $whereParams.put($safeDateProperty, \"%$filterValue%\"))\n    #else\n      #set ($whereSql = \"${whereSql} and upper(str($dateProperty)) like upper(?)\")\n      #set ($discard = $whereParams.add(\"%$filterValue%\"))\n    #end\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterDBStringListProperty)\n  ## Perform exact matching by default if no match type is specified.\n  ## Note that for DBStringList properties we take into account only the first match type, even if multiple filter\n  ## values are specified. Basically the first match type is used for all filter values.\n  #livetable_getMatchTypes($colname $filterValues.size() 'exact')\n  #if ($matchType == 'partial' || $matchType == 'prefix')\n    ## We need to join with the list of values in order to be able to use the LIKE operator.\n    #set ($matchTarget = \"${safe_tableAlias}_item\")\n    #if ($whereParams.entrySet())\n      #set ($paramPrefix = \"${safe_tableAlias}_item_\")\n    #else\n      #set ($paramPrefix = $NULL)\n    #end\n    #set ($joinPos = $mathtool.add($fromSql.lastIndexOf(\" $safe_tableAlias\"), $mathtool.add($safe_tableAlias.length(), 1)))\n    #set ($fromSql = \"$fromSql.substring(0, $joinPos) join ${safe_tableAlias}.list as $matchTarget $fromSql.substring($joinPos)\")\n  #else\n    ## Fall-back on exact matching even if the match type is specified, when its value is not supported.\n    #set ($matchType = 'exact')\n    #set ($matchTarget = \"${safe_tableAlias}.list\")\n    #if ($whereParams.entrySet())\n      #set ($paramPrefix = \"${safe_tableAlias}_list_\")\n    #else\n      #set ($paramPrefix = $NULL)\n    #end\n  #end\n  #set ($filterQuery = \"#livetable_getFilterQuery($matchTarget $matchType true $filterValues.size() $paramPrefix $NULL)\")\n  #set ($whereSql = \"$whereSql and ($filterQuery.trim())\")\n  #foreach ($filterValue in $filterValues)\n    #livetable_addFilterParam($filterValue $matchType $whereParams \"${paramPrefix}${foreach.count}\")\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterStringListProperty)\n  ## From the user point of view we support only exact matching for StringList properties, due to the way the values of\n  ## these properties are stored (concatenated). But when building the actual query, the match type is in fact partial\n  ## because we have to use the like operator in order to match the concatenated list of values.\n  #livetable_getMatchTypes($colname $filterValues.size() 'exact')\n  #set ($matchTarget = \"concat('|', concat(${safe_tableAlias}.textValue, '|'))\")\n  #if ($whereParams.entrySet())\n    #set ($paramPrefix = \"${safe_tableAlias}_textValue_\")\n  #else\n    #set ($paramPrefix = $NULL)\n  #end\n  ## As noted above, we have to use the like operator because the list of values is saved concatenated, so from the\n  ## point of view of the query the match type is always partial.\n  #set ($filterQuery = \"#livetable_getFilterQuery($matchTarget 'partial' false $filterValues.size() $paramPrefix $NULL)\")\n  #set ($whereSql = \"${whereSql} and ($filterQuery.trim())\")\n  #foreach ($filterValue in $filterValues)\n    #if ($matchTypes.get($foreach.index) == 'empty')\n      ## The client side cannot pass an empty filter value so it specifies that the value is empty using the match type.\n      #set ($filterValue = '')\n    #end\n    ## As noted above, we can only perform exact matching due to the way the values are stored (concatenated).\n    #livetable_addFilterParam(\"%|$filterValue|%\" 'exact' $whereParams \"${paramPrefix}${foreach.count}\")\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterStringProperty)\n  #if ($propMetaClass.endsWith('ListClass'))\n    ## Perform exact matching by default for StaticListClass, DBListClass and DBTreeListClass\n    ## when they are stored as StringProperty (i.e. single value and no relational storage).\n    #set ($defaultStringMatchType = 'exact')\n  #else\n    ## Perform partial matching by default otherwise.\n    #set ($defaultStringMatchType = 'partial')\n  #end\n  #livetable_getMatchTypes($colname $filterValues.size() $defaultStringMatchType)\n  ## Group the filter values by match type so that we cann optimize the query.\n  #livetable_groupFilterValuesByMatchType($matchTypes $filterValues)\n  #if ($whereParams.entrySet())\n    #set ($paramPrefix = \"${safe_tableAlias}_value_\")\n  #else\n    #set ($paramPrefix = $NULL)\n  #end\n  ## Note that unlike other property types, the String property supports different match types for different filter\n  ## values. This means we have to call livetable_getFilterQuery for each filter value and then join the constraints\n  ## ourselves.\n  #set ($constraints = [])\n  #set ($paramOffset = 1)\n  #foreach ($entry in $filterValuesByMatchType.entrySet())\n    #set ($matchType = $entry.key)\n    #set ($filterValues = $entry.value)\n    #set ($constraint = \"#livetable_getFilterQuery(\"\"${safe_tableAlias}.value\"\" $matchType false $filterValues.size() $paramPrefix $paramOffset)\")\n    #set ($discard = $constraints.add($constraint.trim()))\n    #foreach ($filterValue in $filterValues)\n      #livetable_addFilterParam($filterValue $matchType $whereParams\n        \"${paramPrefix}${mathtool.add($paramOffset, $foreach.index)}\")\n    #end\n    #set ($paramOffset = $paramOffset + $filterValues.size())\n  #end\n  #set ($whereSql = \"${whereSql} and ($stringtool.join($constraints, \"\" $joinOperator \"\"))\")\n#end\n\n#macro (livetable_groupFilterValuesByMatchType $matchTypes $filterValues)\n  #set ($filterValuesByMatchType = {})\n  #foreach ($matchType in $matchTypes)\n    #set ($discard = $filterValuesByMatchType.putIfAbsent($matchType, []))\n    #set ($discard = $filterValuesByMatchType.get($matchType).add($filterValues.get($foreach.index)))\n  #end\n#end\n\n#macro (livetable_getJoinOperator $colName)\n  #set ($joinOperator = \"$!{request.get(\"\"${colName}${joinModeMarker}\"\").toUpperCase()}\")\n  #if ($joinOperator != 'AND' &amp;&amp; $joinOperator != 'OR')\n    #set ($joinOperator = 'AND')\n  #end\n#end\n\n#macro (livetable_getFilterQuery $column $matchType $isList $valueCount $paramPrefix $paramOffset)\n  #livetable_getJoinOperator($colname)\n  #if (!$paramOffset)\n    #set ($paramOffset = 1)\n  #end\n  #if ($matchType == 'partial' || $matchType == 'prefix')\n    #livetable_repeatParams(\"upper($column) like upper(?)\", \" $joinOperator \", $valueCount, $paramPrefix, $paramOffset)\n  #elseif($matchType == 'empty')\n    ## Check if the value of the column is like the empty parameter (which is often the empty string), or if the value \n    ## of the column is null (to be compliant with Oracle which stores the empty string as a NULL value).\n    #livetable_repeatParams(\"($column like ? or $column is null)\", \" $joinOperator \", $valueCount, $paramPrefix, \n    $paramOffset)\n  #elseif ($isList)\n    #livetable_repeatParams(\"? in elements($column)\", \" $joinOperator \", $valueCount, $paramPrefix, $paramOffset)\n  #elseif ($valueCount &gt; 1 &amp;&amp; $joinOperator == 'OR')\n    $column in (#livetable_repeatParams('?', ', ', $valueCount, $paramPrefix, $paramOffset))\n  #else\n    #livetable_repeatParams(\"$column = ?\", ' AND ', $valueCount, $paramPrefix, $paramOffset)\n  #end\n#end\n\n#macro (livetable_repeatParams $str $separator $valueCount $paramPrefix $paramOffset)\n  #if ($valueCount &gt; 0)\n    #foreach ($count in [1..$valueCount])\n      #if ($count &gt; 1)\n        $separator##\n      #end\n      #if ($paramPrefix)\n        $str.replace('?', \":${paramPrefix}${mathtool.add($paramOffset, $foreach.index)}\")##\n      #else\n        $str##\n      #end\n    #end\n  #end\n#end\n\n#macro (livetable_addFilterParam $filterValue $matchType $params $paramName)\n  #if ($matchType == 'partial')\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, \"%$!filterValue%\"))\n    #else\n      #set ($discard = $params.add(\"%$!filterValue%\"))\n    #end\n  #elseif ($matchType == 'prefix')\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, \"$!filterValue%\"))\n    #else\n      #set ($discard = $params.add(\"$!filterValue%\"))\n    #end\n  #elseif ($matchType == 'empty')\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, ''))\n    #else\n      #set ($discard = $params.add(''))\n    #end\n  #else\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, $filterValue))\n    #else\n      #set ($discard = $params.add($filterValue))\n    #end\n  #end\n#end\n\n\n#**\n * Old alias of the #livetable_addColumnToQuery macro.\n * @deprecated since 2.2.3, use {@link #livetable_addColumnToQuery}\n *#\n#macro(grid_addcolumn $colname)\n  #livetable_addColumnToQuery($colname)\n#end\n\n#**\n * Generates a valid SQL table alias for the specified live table column.\n *#\n#macro (livetable_getTableAlias $columnName)\n  #set ($prefix = 'doc.')\n  #if ($columnName.startsWith($prefix))\n    #set ($suffix = $stringtool.removeStart($columnName, $prefix))\n  #else\n    ## Force a prefix to avoid the cases when the column name is a reserved SQL keyword.\n    #set ($prefix = 'prop_')\n    #set ($suffix = $columnName)\n  #end\n  ## Remove non-word characters.\n  #set ($safe_tableAlias = \"$prefix$suffix.replaceAll('\\W', '')\")\n#end\n{{/velocity}}</content>\n</xwikidoc>\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.livetable;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.script.ModelScriptService;\nimport org.xwiki.query.internal.ScriptQuery;\nimport org.xwiki.query.script.QueryManagerScriptService;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.script.SecurityScriptServiceComponentList;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.page.PageTest;\nimport org.xwiki.test.page.XWikiSyntax20ComponentList;\nimport org.xwiki.velocity.tools.JSONTool;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.classes.StaticListClass;\nimport com.xpn.xwiki.plugin.tag.TagPluginApi;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyMap;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for the {@code LiveTableResults} page.\n * \n * @version $Id$\n */\n@XWikiSyntax20ComponentList\n@SecurityScriptServiceComponentList\n@ComponentList({\n    ModelScriptService.class\n})\nclass LiveTableResultsTest extends PageTest\n{\n    private QueryManagerScriptService queryService;\n\n    private Map<String, Object> results;\n\n    @Mock\n    private ScriptQuery query;\n\n    @BeforeEach\n    @SuppressWarnings(\"deprecation\")\n    public void setUp() throws Exception\n    {\n        // The LiveTableResultsMacros page expects that the HTTP query is done with the \"get\" action and asking for\n        // plain output.\n        setOutputSyntax(Syntax.PLAIN_1_0);\n        this.request.put(\"outputSyntax\", \"plain\");\n        this.request.put(\"xpage\", \"plain\");\n        this.oldcore.getXWikiContext().setAction(\"get\");\n\n        // Prepare mock Query Service so that tests can control what the DB returns.\n        this.queryService = mock(QueryManagerScriptService.class);\n        this.oldcore.getMocker().registerComponent(ScriptService.class, \"query\", this.queryService);\n\n        // The LiveTableResultsMacros page uses the tag plugin for the LT tag cloud feature\n        TagPluginApi tagPluginApi = mock(TagPluginApi.class);\n        doReturn(tagPluginApi).when(this.oldcore.getSpyXWiki()).getPluginApi(eq(\"tag\"), any(XWikiContext.class));\n\n        loadPage(new DocumentReference(\"xwiki\", \"XWiki\", \"LiveTableResultsMacros\"));\n    }\n\n    @Test\n    void plainPageResults() throws Exception\n    {\n        setColumns(\"doc.name\", \"doc.date\");\n        setSort(\"doc.date\", false);\n        setQueryFilters(\"currentlanguage\", \"hidden\");\n        // Offset starting from 1.\n        setOffset(13);\n        setLimit(7);\n\n        when(this.queryService.hql(\"  where 1=1    order by doc.date desc\")).thenReturn(this.query);\n        when(this.query.addFilter(\"currentlanguage\")).thenReturn(this.query);\n        when(this.query.addFilter(\"hidden\")).thenReturn(this.query);\n        when(this.query.setLimit(7)).thenReturn(this.query);\n        // Offset starting from 0.\n        when(this.query.setOffset(12)).thenReturn(this.query);\n        when(this.query.bindValues(anyMap())).thenReturn(this.query);\n\n        when(this.query.count()).thenReturn(17L);\n        when(this.query.execute()).thenReturn(Arrays.asList(\"A.B\", \"X.Y\"));\n\n        renderPage();\n\n        assertEquals(17L, getTotalRowCount());\n        assertEquals(2, getRowCount());\n        assertEquals(13, getOffset());\n\n        List<Map<String, Object>> rows = getRows();\n        assertEquals(2, rows.size());\n\n        Map<String, Object> ab = rows.get(0);\n        assertEquals(\"A\", ab.get(\"doc_space\"));\n        assertEquals(\"B\", ab.get(\"doc_name\"));\n\n        Map<String, Object> xy = rows.get(1);\n        assertEquals(\"X\", xy.get(\"doc_space\"));\n        assertEquals(\"Y\", xy.get(\"doc_name\"));\n    }\n\n    /**\n     * @see \"XWIKI-12803: Class attribute not escaped in Live Tables\"\n     */\n    @Test\n    void sqlReservedKeywordAsPropertyName() throws Exception\n    {\n        setColumns(\"where\");\n        setSort(\"where\", true);\n        setClassName(\"My.Class\");\n\n        when(this.queryService.hql(any())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService).hql(\n            \", BaseObject as obj , StringProperty prop_where  \"\n                + \"where obj.name=doc.fullName and obj.className = :className and \"\n                + \"doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id=prop_where.id.id and prop_where.name = :prop_where_name   \"\n                + \"order by lower(prop_where.value) asc, prop_where.value asc\");\n    }\n\n    /**\n     * @see \"XWIKI-12855: Unable to sort the Location column in Page Index\"\n     */\n    @Test\n    void orderByLocation() throws Exception\n    {\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        setSort(\"doc.location\", false);\n\n        renderPage();\n\n        verify(this.queryService).hql(\"  where 1=1    order by lower(doc.fullName) desc, doc.fullName desc\");\n    }\n\n    /**\n     * Verify we can restrict pages by using a location filter and that we can also filter by doc.location\n     * at the same time. See <a href=\"https://jira.xwiki.org/browse/XWIKI-17463\">XWIKI-17463</a>.\n     */\n    @Test\n    void restrictLocationAndFilterByDocLocation() throws Exception\n    {\n        // Simulate the following type of URL:\n        // http://localhost:8080/xwiki/bin/get/XWiki/LiveTableResults?outputSyntax=plain&collist=doc.location\n        //   &location=Hello&offset=1&limit=15&reqNo=2&doc.location=t&sort=doc.location&dir=asc\n        setColumns(\"doc.location\");\n        setLocation(\"Hello\");\n        setFilter(\"doc.location\", \"test\");\n\n        when(this.queryService.hql(any(String.class))).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(anyMap())).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService).hql(\"  where 1=1  AND ((doc.name = 'WebHome' AND LOWER(doc.space) LIKE \"\n            + \"LOWER(:locationFilterValue2) ESCAPE '!') OR (doc.name <> 'WebHome' AND LOWER(doc.fullName) LIKE \"\n            + \"LOWER(:locationFilterValue2) ESCAPE '!'))  AND LOWER(doc.fullName) LIKE \"\n            + \"LOWER(:locationFilterValue1) ESCAPE '!'\");\n        ArgumentCaptor<Map<String, ?>> argument = ArgumentCaptor.forClass(Map.class);\n        verify(query).bindValues(argument.capture());\n        assertEquals(2, argument.getValue().size());\n        assertEquals(\"%Hello%\", argument.getValue().get(\"locationFilterValue1\"));\n        assertEquals(\"%test%\", argument.getValue().get(\"locationFilterValue2\"));\n    }\n\n    /**\n     * Verify the query and its bound values when an empty matcher is used on one of the values. In this test, the\n     * filter is applied on a static string list with MultiSelect = false, which can be assimilated to a field of type \n     * String when filtering.\n     */\n    @Test\n    void filterStringEmptyMatcher() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Panels\", \"PanelClass\"));\n        StaticListClass category = document.getXClass().addStaticListField(\"category\");\n        category.setValues(\"Information|Tools\");\n        this.xwiki.saveDocument(document, \"creates PanelClass\", true, this.context);\n        \n        setColumns(\"name,description,category\");\n        setSort(\"name\", true);\n        setClassName(\"Panels.PanelClass\");\n        setFilter(\"category_match\", \"empty\");\n        setFilter(\"category\", \"-\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"Information\");\n        this.request.put(\"category/join_mode\", \"OR\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService)\n            .hql(\", BaseObject as obj , StringProperty as prop_category, StringProperty prop_name  \"\n                + \"where obj.name=doc.fullName and obj.className = :className \"\n                + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id = prop_category.id.id and prop_category.id.name = :prop_category_id_name \"\n                + \"and ((prop_category.value like :prop_category_value_1 or prop_category.value is null) \"\n                + \"OR prop_category.value = :prop_category_value_2) \"\n                + \"and obj.id=prop_name.id.id and prop_name.name = :prop_name_name   \"\n                + \"order by lower(prop_name.value) asc, prop_name.value asc\");\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Panels.PanelClass\");\n        values.put(\"classTemplate1\", \"Panels.PanelClassTemplate\");\n        values.put(\"classTemplate2\", \"Panels.PanelTemplate\");\n        values.put(\"prop_category_id_name\", \"category\");\n        values.put(\"prop_category_value_1\", \"\");\n        values.put(\"prop_category_value_2\", \"Information\");\n        values.put(\"prop_name_name\", \"name\");\n        verify(this.query).bindValues(values);\n    }\n\n    /**\n     * Verify the query and its bound values when an empty matcher is used on one of the values. In this test, the\n     * filter is applied on a static string list with MultiSelect = true.\n     */\n    @Test\n    void filterStringListEmptyMatcher() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Panels\", \"PanelClass\"));\n        StaticListClass category = document.getXClass().addStaticListField(\"category\");\n        category.setValues(\"Information|Tools\");\n        category.setMultiSelect(true);\n        this.xwiki.saveDocument(document, \"creates PanelClass\", true, this.context);\n\n        setColumns(\"name,description,category\");\n        setSort(\"name\", true);\n        setClassName(\"Panels.PanelClass\");\n        setFilter(\"category_match\", \"empty\");\n        setFilter(\"category\", \"-\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"Information\");\n        setJoinMode(\"category\", \"OR\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService)\n            .hql(\", BaseObject as obj , StringListProperty as prop_category, StringProperty prop_name  \"\n                + \"where obj.name=doc.fullName \"\n                + \"and obj.className = :className \"\n                + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id = prop_category.id.id \"\n                + \"and prop_category.id.name = :prop_category_id_name \"\n                + \"and (\"\n                + \"upper(concat('|', concat(prop_category.textValue, '|'))) like upper(:prop_category_textValue_1) \"\n                + \"OR upper(concat('|', concat(prop_category.textValue, '|'))) like upper(:prop_category_textValue_2)\"\n                + \") \"\n                + \"and obj.id=prop_name.id.id and prop_name.name = :prop_name_name   \"\n                + \"order by lower(prop_name.value) asc, prop_name.value asc\");\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Panels.PanelClass\");\n        values.put(\"classTemplate1\", \"Panels.PanelClassTemplate\");\n        values.put(\"classTemplate2\", \"Panels.PanelTemplate\");\n        values.put(\"prop_category_id_name\", \"category\");\n        values.put(\"prop_category_textValue_1\", \"%||%\");\n        values.put(\"prop_category_textValue_2\", \"%|Information|%\");\n        values.put(\"prop_name_name\", \"name\");\n        verify(this.query).bindValues(values);\n    }\n\n    /**\n     * Verify that we can filter String properties by multiple values and that the filter values are grouped by match\n     * type (in order to optimize the query).\n     */\n    @Test\n    void filterStringMultipleValues() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Panels\", \"PanelClass\"));\n        document.getXClass().addStaticListField(\"category\");\n        this.xwiki.saveDocument(document, \"creates PanelClass\", true, this.context);\n\n        setColumns(\"name,description,category\");\n        setSort(\"name\", true);\n        setClassName(\"Panels.PanelClass\");\n        setFilter(\"category_match\", \"partial\");\n        setFilter(\"category\", \"a\");\n        setFilter(\"category_match\", \"prefix\");\n        setFilter(\"category\", \"b\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"c\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"d\");\n        this.request.put(\"category/join_mode\", \"OR\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService)\n            .hql(\", BaseObject as obj , StringProperty as prop_category, StringProperty prop_name  \"\n                + \"where obj.name=doc.fullName and obj.className = :className \"\n                + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id = prop_category.id.id and prop_category.id.name = :prop_category_id_name \"\n                + \"and (upper(prop_category.value) like upper(:prop_category_value_1) OR\"\n                + \" upper(prop_category.value) like upper(:prop_category_value_2) OR\"\n                + \" prop_category.value in (:prop_category_value_3, :prop_category_value_4)) \"\n                + \"and obj.id=prop_name.id.id and prop_name.name = :prop_name_name   \"\n                + \"order by lower(prop_name.value) asc, prop_name.value asc\");\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Panels.PanelClass\");\n        values.put(\"classTemplate1\", \"Panels.PanelClassTemplate\");\n        values.put(\"classTemplate2\", \"Panels.PanelTemplate\");\n        values.put(\"prop_category_id_name\", \"category\");\n        values.put(\"prop_category_value_1\", \"%a%\");\n        values.put(\"prop_category_value_2\", \"b%\");\n        values.put(\"prop_category_value_3\", \"c\");\n        values.put(\"prop_category_value_4\", \"d\");\n        values.put(\"prop_name_name\", \"name\");\n        verify(this.query).bindValues(values);\n    }\n\n    /**\n     * When no match type is explicitly defined for a matcher on a short text, the matcher must be partial (i.e., the\n     * filtering must match on substrings).\n     */\n    @Test\n    void filterStringNoMatcherSpecified() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Test\", \"MyPage\"));\n        document.getXClass().addTextField(\"shortText\", \"Short Text\", 10);\n        this.xwiki.saveDocument(document, \"creates my page\", true, this.context);\n        setColumns(\"shortText\");\n        setClassName(\"Test.MyPage\");\n        setFilter(\"shortText\", \"X\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService).hql(\", BaseObject as obj , StringProperty as prop_shortText  \"\n            + \"where obj.name=doc.fullName \"\n            + \"and obj.className = :className \"\n            + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n            + \"and obj.id = prop_shortText.id.id \"\n            + \"and prop_shortText.id.name = :prop_shortText_id_name \"\n            + \"and (upper(prop_shortText.value) like upper(:prop_shortText_value_1)) \");\n\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Test.MyPage\");\n        values.put(\"classTemplate1\", \"Test.MyPageTemplate\");\n        values.put(\"classTemplate2\", \"Test.MyPage\");\n        values.put(\"prop_shortText_id_name\", \"shortText\");\n        values.put(\"prop_shortText_value_1\", \"%X%\");\n        verify(this.query).bindValues(values);\n    }\n\n    @Test\n    void nonViewableResultsAreObfuscated() throws Exception\n    {\n        this.request.put(\"limit\", \"2\");\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(3L);\n        when(this.query.execute()).thenReturn(Arrays.asList(\"XWiki.NotViewable\", \"XWiki.Viewable\"));\n\n        when(this.oldcore.getMockContextualAuthorizationManager()\n            .hasAccess(same(Right.VIEW), eq(new DocumentReference(\"xwiki\", \"XWiki\", \"NotViewable\")))).thenReturn(false);\n\n        renderPage();\n\n        List<Map<String, Object>> rows = getRows();\n        assertEquals(2, rows.size());\n        assertEquals(2, getRowCount());\n        Map<String, Object> obfuscated = rows.get(0);\n        assertFalse((boolean) obfuscated.get(\"doc_viewable\"));\n        assertEquals(\"obfuscated\", obfuscated.get(\"doc_fullName\"));\n\n        Map<String, Object> viewable = rows.get(1);\n        assertTrue((boolean) viewable.get(\"doc_viewable\"));\n        assertEquals(\"XWiki.Viewable\", viewable.get(\"doc_fullName\"));\n    }\n\n    @Test\n    void removeObfuscatedResultsWhenTotalrowsLowerThanLimit() throws Exception\n    {\n        this.request.put(\"limit\", \"2\");\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(2L);\n        when(this.query.execute()).thenReturn(Arrays.asList(\"XWiki.NotViewable\", \"XWiki.Viewable\"));\n\n        when(this.oldcore.getMockContextualAuthorizationManager()\n            .hasAccess(same(Right.VIEW), eq(new DocumentReference(\"xwiki\", \"XWiki\", \"NotViewable\")))).thenReturn(false);\n\n        renderPage();\n\n        List<Map<String, Object>> rows = getRows();\n        assertEquals(1, rows.size());\n        assertEquals(1, getRowCount());\n\n        Map<String, Object> viewable = rows.get(0);\n        assertTrue((boolean) viewable.get(\"doc_viewable\"));\n        assertEquals(\"XWiki.Viewable\", viewable.get(\"doc_fullName\"));\n    }\n\n    //\n    // Helper methods\n    //\n\n    @SuppressWarnings(\"unchecked\")\n    private String renderPage() throws Exception\n    {\n        JSONTool jsonTool = mock(JSONTool.class);\n        registerVelocityTool(\"jsontool\", jsonTool);\n\n        String output = renderPage(new DocumentReference(\"xwiki\", \"XWiki\", \"LiveTableResults\"));\n\n        ArgumentCaptor<Object> argument = ArgumentCaptor.forClass(Object.class);\n        verify(jsonTool).serialize(argument.capture());\n\n        this.results = (Map<String, Object>) argument.getValue();\n\n        return output;\n    }\n\n    private void setClassName(String className)\n    {\n        this.request.put(\"classname\", className);\n    }\n\n    private void setColumns(String... columns)\n    {\n        this.request.put(\"collist\", StringUtils.join(columns, ','));\n    }\n\n    private void setLocation(String location)\n    {\n        this.request.put(\"location\", location);\n    }\n\n    private void setOffset(int offset)\n    {\n        this.request.put(\"offset\", String.valueOf(offset));\n    }\n\n    private void setLimit(int limit)\n    {\n        this.request.put(\"limit\", String.valueOf(limit));\n    }\n\n    private void setSort(String column, Boolean ascending)\n    {\n        this.request.put(\"sort\", column);\n        if (ascending != null) {\n            this.request.put(\"dir\", ascending ? \"asc\" : \"desc\");\n        }\n    }\n\n    private void setFilter(String column, String value)\n    {\n        this.request.put(column, value);\n    }\n\n    private void setJoinMode(String column, String joinMode)\n    {\n        this.request.put(column + \"/join_mode\", joinMode);\n    }\n\n    private void setQueryFilters(String... filters)\n    {\n        this.request.put(\"queryFilters\", StringUtils.join(filters, ','));\n    }\n\n    private Object getTotalRowCount()\n    {\n        return this.results.get(\"totalrows\");\n    }\n\n    private Object getRowCount()\n    {\n        return this.results.get(\"returnedrows\");\n    }\n\n    private Object getOffset()\n    {\n        return this.results.get(\"offset\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List<Map<String, Object>> getRows()\n    {\n        return (List<Map<String, Object>>) this.results.get(\"rows\");\n    }\n}\n"], "fixing_code": ["<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n\n<!--\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n-->\n\n<xwikidoc version=\"1.4\" reference=\"XWiki.LiveTableResultsMacros\" locale=\"\">\n  <web>XWiki</web>\n  <name>LiveTableResultsMacros</name>\n  <language/>\n  <defaultLanguage/>\n  <translation>0</translation>\n  <creator>xwiki:XWiki.Admin</creator>\n  <parent>XWiki.WebHome</parent>\n  <author>xwiki:XWiki.Admin</author>\n  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>\n  <version>1.1</version>\n  <title>$services.localization.render('platform.livetable.resultsMacros')</title>\n  <comment/>\n  <minorEdit>false</minorEdit>\n  <syntaxId>xwiki/2.0</syntaxId>\n  <hidden>true</hidden>\n  <content>{{velocity output=\"false\"}}\n#template('hierarchy_macros.vm')\n\n#**\n * Macro to get the results of a livetable data call.\n * This page is called from live grids via Ajax with the argument xpage=plain. It returns a\n * set of results serialized in JSON.\n *#\n#macro(gridresult $className $collist)\n  #gridresultwithfilter($className $collist '' '' {})\n#end\n\n\n#**\n * Computes the query used to retrieve the results of a live table data call.\n * NOTE: This macro is not fully encapsulated because it defines a few Velocity variables that are used in subsequent macros.\n *#\n#macro(gridresultwithfilter_buildQuery $className $collist $filterfrom $filterwhere $filterParams)\n  ## Additional columns; should *not* contain raw parameters, all added column names must be filtered\n  #set($fromSql = '')\n  ## Parametrized filter part of the query\n  #set($whereSql = '')\n  ## List of values to use with $whereSql\n  #if (!$filterParams)\n    #set($filterParams = {})\n  #end\n  #if ($filterParams.entrySet())\n    #set($whereParams = {})\n  #else\n    #set($whereParams = [])\n  #end\n  #set($class = $xwiki.getDocument($className).getxWikiClass())\n  ##\n  ## Add the columns needed for the actual data\n  ##\n  #set($tablelist = [])\n  #foreach($colname in $collist)\n    #livetable_addColumnToQuery($colname)\n  #end\n  ##\n  ## Tag filtering\n  ##\n  #if($request.tag)\n    #set($fromSql = \"${fromSql} , BaseObject as tobject, DBStringListProperty as tagprop\")\n    #set($whereSql = \"${whereSql} and tobject.className='XWiki.TagClass' and tobject.name=doc.fullName and tobject.id=tagprop.id.id and tagprop.id.name='tags' and (\")\n    #foreach($tag in $request.getParameterValues('tag'))\n      #if($foreach.count &gt; 1) #set($whereSql = \"${whereSql} and \") #end\n      ## Tags are case insensitive but they are stored unchanged which means we have to normalize them when performing\n      ## a query. Unfortunately there's no simple way to match multiple tags (AND operator). If we join the list of\n      ## tags in the FROM clause then we match at least one of the tags (OR operator). The only remaining option is to\n      ## check that the list of tags contains each of the desired tags. HQL doesn't help us to lower-case the entire\n      ## list of tags so we use an inner select for this.\n      #if ($whereParams.entrySet())\n        #set($whereSql = \"${whereSql} lower(:wikitag${foreach.count}) in (select lower(tag) from tagprop.list tag)\")\n        #set($discard = $whereParams.put(\"wikitag$foreach.count\", \"${tag}\"))\n      #else\n        #set($whereSql = \"${whereSql} lower(?) in (select lower(tag) from tagprop.list tag)\")\n        #set($discard = $whereParams.add(\"${tag}\"))\n      #end\n    #end\n    #set($whereSql = \"${whereSql})\")\n  #end\n  ##\n  ##\n  ## Order\n  ##\n  ## if the object for the classname of the order column is not already in the from sql, put it\n  #macro(addObjectClause $objectAlias)\n    #if($fromSql.indexOf($objectAlias) &lt; 0)\n      #set($fromSql = \"${fromSql}, BaseObject $objectAlias\")\n      #if ($whereParams.entrySet())\n        #set($whereSql = \"${whereSql} and ${objectAlias}.name = doc.fullName and ${objectAlias}.className = :${objectAlias}_className\")\n        #set($discard = $whereParams.put(\"${objectAlias}_className\", $propClassName))\n      #else\n        #set($whereSql = \"${whereSql} and ${objectAlias}.name = doc.fullName and ${objectAlias}.className = ?\")\n        #set($discard = $whereParams.add($propClassName))\n      #end\n    #end\n  #end\n  ## Set the order clause for a field. We first ignore the case using the lower function (so that e.g. 'aaa' equals 'AAA')\n  ## but then consider it only for equal values (so that e.g. 'AAA' comes before 'aaa').\n  #macro(setOrderClause $fieldName $direction $useRawValue)\n    #if ($useRawValue)\n      #set($orderSql = \" order by ${fieldName} ${direction}\")\n    #else\n      #set($orderSql = \" order by lower(${fieldName}) ${direction}, ${fieldName} ${direction}\")\n    #end\n  #end\n  #set($order = \"$!request.sort\")\n  #if ($order == 'doc.location')\n    #set ($order = 'doc.fullName')\n  #end\n  #set ($orderSql = '')\n  #if($order != '')\n    #set($orderDirection = \"$!{request.get('dir').toLowerCase()}\")\n    #if(\"$!orderDirection\" != '' &amp;&amp; \"$!orderDirection\" != 'asc')\n      #set($orderDirection = 'desc')\n    #end\n    #livetable_getTableAlias($order)\n    #if($order.startsWith('doc.'))\n      ## The column is a document field.\n      ##\n      ## These document fields need to be ordered as raw values and not as strings.\n      #set($rawDocumentFields = ['translation', 'date', 'contentUpdateDate', 'creationDate', 'elements', 'minorEdit1', 'hidden'])\n      #set($documentField = $stringtool.removeStart($order, 'doc.'))\n      #setOrderClause(${safe_tableAlias.replace('_','.')}, ${orderDirection},  $rawDocumentFields.contains($documentField))\n    #else\n      ## The column is an object property.\n      ##\n      ## Resolve the property.\n      #livetable_getPropertyClassAndType($order)\n      #set ($multiselect = \"$!{propClass.get($order).getProperty('multiSelect').getValue()}\")\n      ## We can only handle single values, not multiselect ones.\n      #if ($multiselect != '1')\n        ## Some property types do not need lowercasing since they have unique values by design, so we use the raw values to order.\n        #set($rawPropertyTypes = ['NumberClass', 'BooleanClass', 'DateClass', 'LevelsClass'])\n        ## If the order column is also a filer column, this means that it was already added to the query and all we need to do is to add it to the order clause.\n        #if(!$tablelist.contains($order))\n          ## The order column is not also a filter column, so not yet defined in the query.\n          ## We need to first define it (to the from and where clauses) before we can add it to the order clause.\n          ##\n          ## Resolve the table name of the property to be used in the from clause below.\n          #livetable_getTableName($order)\n          ## If the sort column has a _class specified, join that object in\n          #set($orderObjectAlias = 'obj')\n          #if($propClassName != '' &amp;&amp; \"$!propClass\" != '')\n            ## prepare the alias of the BaseObject table that corresponds to the class of this column\n            #set($orderObjectAlias = \"$!{propClassName.replaceAll('[^a-zA-Z0-9_]', '')}_obj\")\n            #addObjectClause($orderObjectAlias)\n          #end\n          #set($fromSql = \"${fromSql}, ${tableName} ${safe_tableAlias}\")\n          ## FIXME: Check if this is indeed a property of the class. Hint: $propType can be used.\n          ## Conditions are put on the object coresponding to the column of the order ($orderObjectAlias), which depends on which is the class of the $order\n          #if ($whereParams.entrySet())\n            #set($whereSql = \"${whereSql} and ${orderObjectAlias}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.name = :${safe_tableAlias}_name\")\n            #set($discard = $whereParams.put(\"${safe_tableAlias}_name\", \"${order}\"))\n          #else\n            #set($whereSql = \"${whereSql} and ${orderObjectAlias}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.name = ?\")\n            #set($discard = $whereParams.add(\"${order}\"))\n          #end\n        #end\n        ## Add the column to the order clause.\n        #setOrderClause(\"${safe_tableAlias}.value\", ${orderDirection}, $rawPropertyTypes.contains($propType))\n      #end\n    #end\n  #end\n  ##\n  ##\n  ## Compute the final queries\n  ##\n  #if ($filterParams.entrySet())\n    #set($sqlParams = {})\n    #set($tagsMatchingParams = {})\n    #set($allMatchingParams = {})\n  #else\n    #set($sqlParams = [])\n    #set($tagsMatchingParams = [])\n    #set($allMatchingParams = [])\n  #end\n  #if(\"$!className\" != '')\n    ## Class query\n    #if ($sqlParams.entrySet())\n      #set($sql = \", BaseObject as obj $!fromSql $!filterfrom where obj.name=doc.fullName and obj.className = :className and doc.fullName not in (:classTemplate1, :classTemplate2) $!whereSql $!filterwhere\")\n      #set($discard = $sqlParams.put('className', \"${className}\"))\n      #set($discard = $sqlParams.put('classTemplate1', \"${className}Template\"))\n      #set($discard = $sqlParams.put('classTemplate2', ${className.replaceAll('Class$', 'Template')}))\n      #set($discard = $sqlParams.putAll($whereParams))\n    #else\n      #set($sql = \", BaseObject as obj $!fromSql $!filterfrom where obj.name=doc.fullName and obj.className = ? and doc.fullName not in (?, ?) $!whereSql $!filterwhere\")\n      #set($discard = $sqlParams.addAll([\"${className}\", \"${className}Template\", ${className.replaceAll('Class$', 'Template')}]))\n      #set($discard = $sqlParams.addAll($whereParams))\n    #end\n    ##\n    #set($tagsMatchingFiltersFrom = \", BaseObject as obj $!fromSql $!filterfrom\")\n    #if ($tagsMatchingParams.entrySet())\n      #set($tagsMatchingFiltersWhere = \"obj.name=doc.fullName and obj.className = :className and doc.fullName not in (:classTemplate1, :classTemplate2) $!whereSql $!filterwhere\")\n      #set($discard = $tagsMatchingParams.put('className', \"${className}\"))\n      #set($discard = $tagsMatchingParams.put('classTemplate1', \"${className}Template\"))\n      #set($discard = $tagsMatchingParams.put('classTemplate2', ${className.replaceAll('Class$', 'Template')}))\n      #set($discard = $tagsMatchingParams.putAll($whereParams))\n    #else\n      #set($tagsMatchingFiltersWhere = \"obj.name=doc.fullName and obj.className = ? and doc.fullName not in (?, ?) $!whereSql $!filterwhere\")\n      #set($discard = $tagsMatchingParams.addAll([\"${className}\", \"${className}Template\", ${className.replaceAll('Class$', 'Template')}]))\n      #set($discard = $tagsMatchingParams.addAll($whereParams))\n    #end\n    ##\n    #set($allMatchingTagsFrom = \", BaseObject as obj $!filterfrom\")\n    #if ($allMatchingParams.entrySet())\n      #set($allMatchingTagsWhere = \"obj.name=doc.fullName and obj.className = :className and doc.fullName not in (:classTemplate1, :classTemplate2) $!filterwhere\")\n      #set($discard = $allMatchingParams.put('className', \"${className}\"))\n      #set($discard = $allMatchingParams.put('classTemplate1', \"${className}Template\"))\n      #set($discard = $allMatchingParams.put('classTemplate2', ${className.replaceAll('Class$', 'Template')}))\n    #else\n      #set($allMatchingTagsWhere = \"obj.name=doc.fullName and obj.className = ? and doc.fullName not in (?, ?) $!filterwhere\")\n      #set($discard = $allMatchingParams.addAll([\"${className}\", \"${className}Template\", ${className.replaceAll('Class$', 'Template')}]))\n    #end\n    ##\n    #if($filterParams)\n      #if ($filterParams.entrySet())\n        #set($discard = $sqlParams.putAll($filterParams))\n        #set($discard = $tagsMatchingParams.putAll($filterParams))\n        #set($discard = $allMatchingParams.putAll($filterParams))\n      #else\n        #set($discard = $sqlParams.addAll($filterParams))\n        #set($discard = $tagsMatchingParams.addAll($filterParams))\n        #set($discard = $allMatchingParams.addAll($filterParams))\n      #end\n    #end\n  #else\n    ## Document query\n    #set($sql = \"$!fromSql $!filterfrom where 1=1 $!whereSql $!filterwhere\")\n    #if ($whereParams.entrySet())\n      #set($discard = $sqlParams.putAll($whereParams))\n    #else\n      #set($discard = $sqlParams.addAll($whereParams))\n    #end\n    ##\n    #set($tagsMatchingFiltersFrom = \"$!fromSql $!filterfrom\")\n    #set($tagsMatchingFiltersWhere = \"1=1 $!whereSql $!filterwhere\")\n    #if ($whereParams.entrySet())\n      #set($discard = $tagsMatchingParams.putAll($whereParams))\n    #else\n      #set($discard = $tagsMatchingParams.addAll($whereParams))\n    #end\n    ##\n    #set($allMatchingTagsFrom = \"$!filterfrom\")\n    #set($allMatchingTagsWhere = \"1=1 $!filterwhere\")\n    ##\n    #if($filterParams)\n      #if ($filterParams.entrySet())\n        #set($discard = $sqlParams.putAll($filterParams))\n        #set($discard = $tagsMatchingParams.putAll($filterParams))\n        #set($discard = $allMatchingParams.putAll($filterParams))\n      #else\n        #set($discard = $sqlParams.addAll($filterParams))\n        #set($discard = $tagsMatchingParams.addAll($filterParams))\n        #set($discard = $allMatchingParams.addAll($filterParams))\n      #end\n    #end\n  #end\n  #if($orderSql != '')\n    #set($sql = \"$sql $!{orderSql}\")\n  #end\n#end\n#**\n * Adds TagCloud information to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables defined by gridresultwithfilter_buildQuery.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildTagCloudJSON $map)\n  ##\n  ## TagCloud matching the current filters\n  ##\n  #set($tagsMatchingFilters = $xwiki.tag.getTagCountForQuery($tagsMatchingFiltersFrom, $tagsMatchingFiltersWhere, $tagsMatchingParams))\n  ## FIXME: We use a map just because the client expects an object, but all we really need is a list..\n  #set($matchingTags = {})\n  #foreach($tag in $tagsMatchingFilters.keySet())\n    ## NOTE: The value doesn't have a special meaning. I've used 1 just because it takes less space when serialized.\n    #set($discard = $matchingTags.put($tag, 1))\n  #end\n  #set($discard = $map.put('matchingtags', $matchingTags))\n  ##\n  ## TagCloud matching all the documents used by the live table\n  ##\n  #set($allMatchingTags = $xwiki.tag.getTagCountForQuery($allMatchingTagsFrom, $allMatchingTagsWhere, $allMatchingParams))\n  ## FIXME: We use a list of maps just because the client expects an array, but we should simply return $allMatchingTags..\n  #set($tags = [])\n  #foreach($tag in $allMatchingTags.keySet())\n    #set($discard = $tags.add({'tag': $tag, 'count': $allMatchingTags.get($tag)}))\n  #end\n  #set($discard = $map.put('tags', $tags))\n#end\n\n\n#**\n * Adds information about each live table row to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables defined by gridresultwithfilter_buildQuery.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildRowsJSON $map)\n  #set($offset = $numbertool.toNumber($request.get('offset')).intValue())\n  ## Offset starts from 0 in velocity and 1 in javascript\n  #set($offset = $offset - 1)\n  #if(!$offset || $offset &lt; 0)\n    #set($offset = 0)\n  #end\n  #set($limit = $numbertool.toNumber($request.get('limit')).intValue())\n  #if(!$limit)\n    #set ($limit = 15)\n  #end\n  #set($query = $services.query.hql($sql))\n  ## Apply query filters if defined. Otherwise use default.\n  #foreach ($queryFilter in $stringtool.split($!request.queryFilters, ', '))\n    #set ($query = $query.addFilter($queryFilter))\n  #end\n  #set ($query = $query.setLimit($limit).setOffset($offset).bindValues($sqlParams))\n  #set($items = $query.execute())\n  #set($discard = $map.put('totalrows', $query.count()))\n  #if ($limit > 0)\n    #set($discard = $map.put('returnedrows', $mathtool.min($items.size(), $limit)))\n  #else\n    ## When the limit is 0, it's equivalent to no limit at all and the actual number of returned results can be used.\n    #set($discard = $map.put('returnedrows', $items.size()))\n  #end\n  #set($discard = $map.put('offset', $mathtool.add($offset, 1)))\n  #set($rows = [])\n  #foreach($item in $items)\n    #gridresult_buildRowJSON($item $rows)\n  #end\n  #set ($discard = $map.put('rows', $rows))\n  #livetable_filterObfuscated($map)\n#end\n\n\n#**\n * Adds information about the specified live table row to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables available in gridresult_buildRowsJSON.\n *\n * @param $item the name of the document that feeds this live table row\n * @param $rows stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildRowJSON $item $rows)\n  ## Handle both the case where the \"language\" filter is used and thus languages are returned too and the case where\n  ## only the document name is returned. When more than the document name is returned the $item variable is a list.\n  #if($item.size())\n    ## Extract doc name and doc language from $item\n    #set($docName = $item[0])\n    #set($docLanguage = $item[1])\n  #else\n    #set($docName = $item)\n    #set($docLanguage = '')\n  #end\n  #set ($docReference = $services.model.resolveDocument($docName))\n  #set ($isViewable = $services.security.authorization.hasAccess('view', $docReference))\n  #if ($isViewable)\n    #set ($row = {\n      'doc_viewable': $isViewable,\n      'doc_fullName': $services.model.serialize($docReference, 'local'),\n      'doc_space': $services.model.serialize($docReference.parent, 'local'),\n      'doc_location': \"#hierarchy($docReference, {'limit': 5, 'plain': false, 'local': true, 'displayTitle': false})\",\n      'doc_url': $xwiki.getURL($docReference),\n      'doc_space_url': $xwiki.getURL($docReference.parent),\n      'doc_wiki': $docReference.wikiReference.name,\n      'doc_wiki_url': $xwiki.getURL($docReference.wikiReference),\n      'doc_hasadmin': $xwiki.hasAdminRights(),\n      'doc_hasedit': $services.security.authorization.hasAccess('edit', $docReference),\n      'doc_hasdelete': $services.security.authorization.hasAccess('delete', $docReference),\n      'doc_edit_url': $xwiki.getURL($docReference, 'edit'),\n      'doc_copy_url': $xwiki.getURL($docReference, 'view', 'xpage=copy'),\n      'doc_delete_url': $xwiki.getURL($docReference, 'delete'),\n      'doc_rename_url': $xwiki.getURL($docReference, 'view', 'xpage=rename&amp;step=1')\n    })\n    #set ($isTranslation = \"$!docLanguage\" != '' &amp;&amp; $xwiki.getLanguagePreference() != $docLanguage)\n    ## Display the language after the document name so that not all translated documents have the same name displayed.\n    #set ($row.doc_name = \"$docReference.name#if ($isTranslation) ($docLanguage)#end\")\n    #set ($row.doc_hascopy = $row.doc_viewable)\n    #set ($row.doc_hasrename = $row.doc_hasdelete)\n    #set ($row.doc_hasrights = $row.doc_hasedit &amp;&amp; $isAdvancedUser)\n    #if ($docReference.name == 'WebHome')\n    \n      ## For nested pages, use the page administration.\n      #set ($webPreferencesReference = $services.model.createDocumentReference(\n        'WebPreferences', $docReference.lastSpaceReference))\n      #set ($row.doc_rights_url = $xwiki.getURL($webPreferencesReference, 'admin',\n        'editor=spaceadmin&amp;section=PageRights'))\n    #else\n      ## For terminal pages, use the old rights editor.\n      ## TODO: We should create a page administration for terminal pages too.\n      #set ($row.doc_rights_url = $xwiki.getURL($docReference, 'edit', 'editor=rights'))\n    #end\n    #if ($row.doc_viewable)\n      #set ($itemDoc = $xwiki.getDocument($docReference))\n      ## Handle translations. We need to make sure we display the data associated to the correct document if the returned\n      ## result is a translation.\n      #if ($isTranslation)\n        #set ($translatedDoc = $itemDoc.getTranslatedDocument($docLanguage))\n      #else\n        #set ($translatedDoc = $itemDoc.translatedDocument)\n      #end\n      #set($discard = $itemDoc.use($className))\n      #set($discard = $row.put('doc_objectCount', $itemDoc.getObjectNumbers($className)))\n      #set($discard = $row.put('doc_edit_url', $itemDoc.getURL($itemDoc.defaultEditMode)))\n      #set($discard = $row.put('doc_author_url', $xwiki.getURL($translatedDoc.author)))\n      #set($discard = $row.put('doc_date', $xwiki.formatDate($translatedDoc.date)))\n      #set($discard = $row.put('doc_title', $translatedDoc.plainTitle))\n      #set($rawTitle = $translatedDoc.title)\n      #if($rawTitle != $row['doc_title'])\n        #set($discard = $row.put('doc_title_raw', $rawTitle))\n      #end\n      #set($discard = $row.put('doc_author', $xwiki.getPlainUserName($translatedDoc.authorReference)))\n      #set($discard = $row.put('doc_creationDate', $xwiki.formatDate($translatedDoc.creationDate)))\n      #set($discard = $row.put('doc_creator', $xwiki.getPlainUserName($translatedDoc.creatorReference)))\n      #set($discard = $row.put('doc_hidden', $translatedDoc.isHidden()))\n      #foreach($colname in $collist)\n        #gridresult_buildColumnJSON($colname $row)\n      #end\n    #end\n  #else\n    #set ($row = {\n      'doc_viewable': $isViewable,\n      'doc_fullName': 'obfuscated'\n    })\n  #end\n  #set($discard = $rows.add($row))\n#end\n\n\n#**\n * Adds information about the given column to the JSON returned by a live table data call.\n * NOTE: This macro uses Velocity variables available in gridresult_buildRowJSON.\n *\n * @param $colname the name of the live table column for which to retrieve information\n * @param $row stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildColumnJSON $colname $row)\n  #if($colname.startsWith('doc.'))\n  #elseif($colname == '_action')\n    #set($discard = $row.put($colname, $services.localization.render(\"${request.transprefix}actiontext\")))\n  #elseif($colname == '_attachments')\n    #livetable_getAttachmentsList($translatedDoc)\n    #set($discard = $row.put($colname, $attachlist))\n  #elseif($colname == '_avatar')\n    #livetable_getAvatar($itemDoc)\n    #set($discard = $row.put($colname, $avatar))\n  #elseif($colname == '_images')\n    #livetable_getImagesList($itemDoc)\n    #set($discard = $row.put($colname, $imagesList))\n  ## Output likes if they are available.\n  #elseif($colname == '_likes' &amp;&amp; \"$!services.like\" != \"\")\n    #set($likes = $services.like.getLikes($docReference))\n    #if ($likes.isPresent())\n      #set($discard = $row.put('_likes', $likes.get()))\n    #end\n  #else\n    #livetable_getPropertyClassAndType($colname)\n    #if(!$propClass.equals($class))\n      #set($discard = $itemDoc.use($propClassName))\n    #end\n    #set($fieldObject = $itemDoc.getFirstObject($colname))\n    #set($fieldProperty = $fieldObject.getProperty($colname))\n    #if ($fieldProperty.getPropertyClass().classType == 'Password')\n      #set($fieldValue = '********')\n    #else\n      #set($fieldValue = \"$!fieldProperty.getValue()\")\n    #end\n    #set($fieldDisplayValue = \"$!itemDoc.display($colname, 'view')\")\n    #if($fieldDisplayValue == '')\n      #set($fieldDisplayValue = $services.localization.render(\"${request.transprefix}emptyvalue\"))\n    #end\n    #set($fieldUrl = '')\n    ## Only retrieve an URL for a DBListClass item\n    #if(($propType == 'DBListClass' || $propType == 'PageClass') &amp;&amp; $propClass.get($colname).getProperty('multiSelect').value != 1)\n      #set($fieldUrl = $xwiki.getURL($fieldValue))\n      #if($fieldUrl == $xwiki.getURL($services.model.resolveDocument('', 'default', $doc.documentReference.extractReference('WIKI'))))\n        #set($fieldUrl = '')\n      #end\n    #end\n    #set($discard = $row.put($colname, $fieldDisplayValue.replaceFirst($regextool.quote('{{html clean=\"false\" wiki=\"false\"}}'), '').replaceAll(\"$regextool.quote('{{/html}}')$\", '')))\n    #set($discard = $row.put(\"${colname}_value\", $fieldValue))\n    #set($discard = $row.put(\"${colname}_url\", $fieldUrl))\n    ## Reset to the default class\n    #set($discard = $itemDoc.use($className))\n  #end\n#end\n\n\n#**\n * Builds the JSON response to a live table data call.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresultwithfilter_buildJSON $className $collist $filterfrom $filterwhere $filterParams $map)\n  #gridresultwithfilter_buildQuery($className $collist $filterfrom $filterwhere $filterParams)\n  #if(\"$!request.sql\" == '1')\n    #set($discard = $map.put('sql', $sql))\n    #set($discard = $map.put('params', $sqlParams))\n  #end\n  #set($discard = $map.put('reqNo', $numbertool.toNumber($request.reqNo).intValue()))\n  #gridresult_buildTagCloudJSON($map)\n  #gridresult_buildRowsJSON($map)\n#end\n\n\n#**\n * Builds the JSON response to a live table data call.\n *\n * @param $map stores the JSON in memory so that it can be adjusted before serialization\n *#\n#macro(gridresult_buildJSON $className $collist $map)\n  #gridresultwithfilter_buildJSON($className $collist '' '' {} $map)\n#end\n\n\n#**\n * Macro to get the results of a livetable data call.\n * This page is called from live grids via Ajax with the argument xpage=plain. It returns a\n * set of results serialized in JSON.\n *#\n#macro(gridresultwithfilter $className $collist $filterfrom $filterwhere $filterParams)\n  #if($xcontext.action == 'get' &amp;&amp; \"$!{request.outputSyntax}\" == 'plain')\n    ## Build the JSON in memory (using basic Java data types) so that it can be adjusted before serialization.\n    #set($map = {})\n    #gridresultwithfilter_buildJSON($className $collist $filterfrom $filterwhere $filterParams $map)\n    #jsonResponse($map)\n  #end\n#end\n\n\n#**\n * Get the name of the Property that should be used for a given livetable column.\n * NOTE the resulting $tableName is safe to use inside SQL queries\n *#\n#macro(livetable_getTableName $colname)\n  #livetable_getPropertyClassAndType($colname)\n  #if($propType == 'NumberClass')\n    #set($numberType = $propClass.get($colname).getProperty('numberType').getValue())\n    #if($numberType == 'integer')\n      #set($tableName = 'IntegerProperty')\n    #elseif($numberType == 'float')\n      #set($tableName = 'FloatProperty')\n    #elseif($numberType == 'double')\n      #set($tableName = 'DoubleProperty')\n    #else\n      #set($tableName = 'LongProperty')\n    #end\n  #elseif($propType == 'BooleanClass')\n    #set($tableName = 'IntegerProperty')\n  #elseif($propType == 'DateClass')\n    #set($tableName = 'DateProperty')\n  #elseif($propType == 'TextAreaClass' || $propType == 'UsersClass' || $propType == 'GroupsClass')\n    #set($tableName = 'LargeStringProperty')\n  #elseif($propType == 'StaticListClass' || $propType == 'DBListClass' || $propType == 'DBTreeListClass' || $propType == 'PageClass')\n    #set($multiSelect = $propClass.get($colname).getProperty('multiSelect').getValue())\n    #set($relationalStorage = $propClass.get($colname).getProperty('relationalStorage').getValue())\n    #if($multiSelect == 1)\n      #if($relationalStorage == 1)\n        #set($tableName = 'DBStringListProperty')\n      #else\n        #set($tableName = 'StringListProperty')\n      #end\n    #else\n      #set($tableName = 'StringProperty')\n    #end\n  #else\n    #set($tableName = 'StringProperty')\n  #end\n#end\n\n#**\n * Get the property class and type for a given livetable column.\n *#\n#macro(livetable_getPropertyClassAndType $colname)\n  #set($propClassName = \"$!request.get(${colname.concat('_class')})\")\n  #if($propClassName != '')\n    #set($propClass = $xwiki.getDocument($propClassName).getxWikiClass())\n  #else\n    #set($propClass = $class)\n  #end\n  #set($propType = '')\n  #if($propClass.getPropertyNames().contains($colname))\n    #set($propType = \"$!{propClass.get($colname).type}\")\n  #end\n#end\n\n#**\n * Old alias of the #livetable_getTableName macro.\n * @deprecated since 2.2.3, use {@link #livetable_getTableName}\n *#\n#macro(grid_gettablename $colname)\n  #livetable_getTableName($colname)\n#end\n\n\n\n#**\n * List attachments for a document, putting the result as HTML markup in the $attachlist variable.\n *#\n#macro(livetable_getAttachmentsList $itemDoc)\n  #set($attachlist = '')\n  #foreach($attachment in $itemDoc.attachmentList)\n    #set($attachmentUrl = $itemDoc.getAttachmentURL($attachment.filename))\n    #set($attachlist = \"${attachlist}&lt;a href='${attachmentUrl}'&gt;$attachment.filename&lt;/a&gt;&lt;br/&gt;\")\n  #end\n#end\n\n#**\n * Old alias of the #livetable_getAttachmentsList macro.\n * @deprecated since 2.2.3, use {@link #livetable_getAttachmentsList}\n *#\n#macro(grid_attachlist $itemDoc)\n  #livetable_getAttachmentsList($itemDoc)\n#end\n\n\n\n#**\n * List image attachments for a document, putting the result as HTML markup in the $imagesList variable.\n *#\n#macro(livetable_getImagesList $itemDoc)\n  #set($imagesList = '')\n  #foreach ($attachment in $itemDoc.attachmentList)\n    #if($attachment.isImage())\n      ## Create a thumbnail by resizing the image on the server side, if needed, to fit inside a 50x50 pixel square.\n      #set($thumbnailURL = $itemDoc.getAttachmentURL($attachment.filename, 'download', \"width=50&amp;height=50&amp;keepAspectRatio=true\"))\n      #set($imageURL = $itemDoc.getAttachmentURL($attachment.filename))\n      #set($imagesList = \"${imagesList}&lt;a href=\"\"$imageURL\"\"&gt;&lt;img src=\"\"$thumbnailURL\"\" alt=\"\"$attachment.filename\"\" title=\"\"$attachment.filename\"\" /&gt;&lt;/a&gt;\")\n    #end\n  #end\n#end\n\n#**\n * Old alias of the #livetable_getImagesList macro.\n * @deprecated since 2.2.3, use {@link #livetable_getImagesList}\n *#\n#macro(grid_photolist $itemDoc)\n  #livetable_getImagesList($itemDoc)\n#end\n\n\n#**\n * Generate the HTML code for a user avatar.\n *#\n#macro(livetable_getAvatar $itemDoc)\n  #set ($avatar = \"#mediumUserAvatar($itemDoc.fullName)\")\n  #set ($avatar = $avatar.trim())\n#end\n\n#**\n * Old alias of the #livetable_getAvatar macro.\n * @deprecated since 2.2.3, use {@link #livetable_getAvatar}\n *#\n#macro(grid_avatar $itemDoc)\n  #livetable_getAvatar($itemDoc)\n#end\n\n\n\n#**\n * Macro to extend the query to select the properties for the livetable columns.\n * NOTE $colName is filtered (all characters but [a-zA-Z0-9_.] are removed) before use\n *#\n#macro (livetable_addColumnToQuery $colName)\n  ## Safe because / is not allowed in property names\n  ## The $joinModeMarker is used in #livetable_filterDBStringListProperty.\n  #set ($joinModeMarker = \"/join_mode\")\n  #if (!$colName.endsWith($joinModeMarker))\n    #set ($filterValue = \"$!request.getParameter($colName)\")\n    #if (\"$!filterValue\" != '')\n      #set ($discard = $tablelist.add($colName))\n      ## Some columns may support filtering with multiple constraints (multiple filter values).\n      #set ($filterValues = $request.getParameterValues($colName))\n      #if ($colName.startsWith('doc.'))\n        #if ($colName == 'doc.location')\n          #set ($safeColName = 'doc.fullName')\n          ## Use filterLocation since addLivetableLocationFilter is buggy when called several times (it'll add the\n          ## same HQL binding name every time it's called! See https://jira.xwiki.org/browse/XWIKI-17463).\n          ## Also note that we don't call addLocationFilter since we use a Map for $params.\n          #filterLocation($whereSql, $whereParams, $filterValue, 'locationFilterValue2', true)\n        #elseif ($colName == 'doc.date' || $colName == 'doc.creationDate' || $colName == 'doc.contentUpdateDate')\n          #livetable_getTableAlias($colName)\n          #livetable_filterDateProperty()\n        #else\n          #set ($safeColName = $colName.replaceAll('[^a-zA-Z0-9_.]', '').replace('_', '.'))\n          #if ($whereParams.entrySet())\n            #set ($whereSql = \"${whereSql} and upper(str($safeColName)) like upper(:${safeColName.replace('.', '_')}_filter)\")\n            #set ($discard = $whereParams.put(\"${safeColName.replace('.', '_')}_filter\", \"%$filterValue%\"))\n          #else\n            #set ($whereSql = \"${whereSql} and upper(str($safeColName)) like upper(?)\")\n            #set ($discard = $whereParams.add(\"%$filterValue%\"))\n          #end\n        #end\n      #else\n        #livetable_filterProperty($colName)\n      #end\n    #end\n  #end\n#end\n\n\n#**\n * Determine how the filter values should be matched against the stored values. This macro sets two variables:\n * &lt;ul&gt;\n *   &lt;li&gt;$matchType: use this when the specified column supports only a single filter value&lt;/li&gt;\n *   &lt;li&gt;$matchTypes: use this when the specified column supports multiple filter values.&lt;/li&gt;\n * &lt;/ul&gt;\n *\n * @param column the column name; each column can have a different match type\n * @param filterValueCount the number of filter values for which to determine the match type; each filter value can have\n *          a different match type\n * @param defaultMatchType the default match type to use for the given column when the request doesn't specify one\n *#\n#macro (livetable_getMatchTypes $column $filterValueCount $defaultMatchType)\n  #set ($macro.matchTypes = $request.getParameterValues(\"${column}_match\"))\n  #if (!$macro.matchTypes || $macro.matchTypes.isEmpty())\n    ## No match type specified for this column.\n    #set ($matchType = $defaultMatchType)\n    #set ($matchTypes = $stringtool.repeat($matchType, ',', $filterValueCount).split(','))\n  #else\n    ## At least one match type specified for this column.\n    #set ($matchType = $macro.matchTypes.get(0))\n    #set ($matchTypes = [])\n    #set ($discard = $matchTypes.addAll($macro.matchTypes.subList(0, $mathtool.min($macro.matchTypes.size(),\n      $filterValueCount))))\n    #if ($matchTypes.size() &lt; $filterValueCount)\n      ## Add missing match types.\n      #set ($discard = $matchTypes.addAll($stringtool.repeat($matchType, ',', $mathtool.sub($filterValueCount,\n        $matchTypes.size())).split(',')))\n    #end\n  #end\n#end\n\n\n#macro (livetable_filterProperty $colname)\n  #livetable_getTableAlias($colname)\n  #livetable_getTableName($colname)\n  #set ($fromSql = \"$fromSql, $tableName as $safe_tableAlias\")\n  ##\n  ## If the column is not from $class, we need to make sure we join with the proper table.\n  #set ($filterObjectAlias = 'obj')\n  #set ($propClass = $class)\n  #set ($propClassName = $request.getParameter(\"${colname}_class\"))\n  #if (\"$!propClassName\" != '')\n    #set ($propClass = $xwiki.getDocument($propClassName).getxWikiClass())\n    #if (\"$!propClass\" != '')\n      ## Prepare the alias of the BaseObject table that corresponds to the class of this column\n      ## Property table is to be joined with its object, determined depending on $propClassName.\n      #set ($filterObjectAlias = \"$!{propClassName.replaceAll('[^a-zA-Z0-9_]', '')}_obj\")\n      #addObjectClause($filterObjectAlias)\n    #end\n  #end\n  #if ($whereParams.entrySet())\n    #set ($joinObjectTable = \"${filterObjectAlias}.id = ${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = :${safe_tableAlias}_id_name\")\n    #set ($discard = $whereParams.put(\"${safe_tableAlias}_id_name\", $colname))\n  #else\n    #set ($joinObjectTable = \"${filterObjectAlias}.id = ${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ?\")\n    #set ($discard = $whereParams.add($colname))\n  #end\n  #set ($whereSql = \"$whereSql and $joinObjectTable\")\n  ##\n  ## We determine the default match type (when not specified) based on the property meta class (e.g. DateClass).\n  #set ($propMetaClass = $NULL)\n  #if ($propClass &amp;&amp; $propClass.getPropertyNames().contains($colname))\n    #set ($propMetaClass = $propClass.get($colname).type)\n  #end\n  ##\n  #set ($numberProperties = ['IntegerProperty', 'LongProperty', 'FloatProperty', 'DoubleProperty'])\n  #if ($numberProperties.contains($tableName))\n    #livetable_filterNumberProperty()\n  #elseif ($tableName == 'DateProperty')\n    #livetable_filterDateProperty()\n  #elseif ($tableName == 'DBStringListProperty')\n    #livetable_filterDBStringListProperty()\n  #elseif ($tableName == 'StringListProperty')\n    #livetable_filterStringListProperty()\n  #else\n    ## StringProperty or LargeStringProperty\n    #livetable_filterStringProperty()\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterNumberProperty)\n  #set($numberValue = $numbertool.toNumber($filterValue))\n  #if($tableName == 'IntegerProperty' || $tableName == 'LongProperty')\n    #if($tableName == 'LongProperty')\n      #set($numberValue = $numberValue.longValue())\n    #else\n      ## IntegerProperty\n      #set($numberValue = $numberValue.intValue())\n    #end\n    #if ($whereParams.entrySet())\n      #set($whereSql = \"${whereSql} and ${safe_tableAlias}.value = :${safe_tableAlias}_value\")\n      #set($discard = $whereParams.put(\"${safe_tableAlias}_value\", $numberValue))\n    #else\n      #set($whereSql = \"${whereSql} and ${safe_tableAlias}.value = ?\")\n      #set($discard = $whereParams.add($numberValue))\n    #end\n  #else\n    #if($tableName == 'FloatProperty')\n      #set($numberValue = $numberValue.floatValue())\n    #else\n      ## DoubleProperty\n      #set($numberValue = $numberValue.doubleValue())\n    #end\n    #set($precision = 0.000001)\n    #if ($whereParams.entrySet())\n      #set($whereSql = \"${whereSql} and abs(:${safe_tableAlias}_value - ${safe_tableAlias}.value) &lt;= ${precision}\")\n      #set($discard = $whereParams.put(\"${safe_tableAlias}_value\", $numberValue))\n    #else\n      #set($whereSql = \"${whereSql} and abs(? - ${safe_tableAlias}.value) &lt;= ${precision}\")\n      #set($discard = $whereParams.add($numberValue))\n    #end\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterDateProperty)\n  #if ($safe_tableAlias.startsWith('doc.'))\n    #set ($dateProperty = $safe_tableAlias)\n  #else\n    #set ($dateProperty = \"${safe_tableAlias}.value\")\n  #end\n  #set ($safeDateProperty = $dateProperty.replace('.', '_'))\n  #set ($dateRange = {})\n  ## Perform partial string matching by default if no match type is specified.\n  ## Note that for the moment we support only one filter value (e.g. one date range) and thus only the first match type\n  ## is taken into account.\n  #livetable_getMatchTypes($colname $filterValues.size() 'partial')\n  #parseDateRange($matchType $filterValue $dateRange)\n  #if ($dateRange.start || $dateRange.end)\n    ## Date range.\n    #if ($dateRange.start)\n      #if ($whereParams.entrySet())\n        #set ($whereSql = \"${whereSql} and $dateProperty &gt;= :${safeDateProperty}1\")\n        #set ($discard = $whereParams.put(\"${safeDateProperty}1\", $dateRange.start))\n      #else\n        #set ($whereSql = \"${whereSql} and $dateProperty &gt;= ?\")\n        #set ($discard = $whereParams.add($dateRange.start))\n      #end\n    #end\n    #if ($dateRange.end)\n      #if ($whereParams.entrySet())\n        #set ($whereSql = \"${whereSql} and $dateProperty &lt;= :${safeDateProperty}2\")\n        #set ($discard = $whereParams.put(\"${safeDateProperty}2\", $dateRange.end))\n      #else\n        #set ($whereSql = \"${whereSql} and $dateProperty &lt;= ?\")\n        #set ($discard = $whereParams.add($dateRange.end))\n      #end\n    #end\n  #else\n    ## String matching (contains).\n    #if ($whereParams.entrySet())\n      #set ($whereSql = \"${whereSql} and upper(str($dateProperty)) like upper(:$safeDateProperty)\")\n      #set ($discard = $whereParams.put($safeDateProperty, \"%$filterValue%\"))\n    #else\n      #set ($whereSql = \"${whereSql} and upper(str($dateProperty)) like upper(?)\")\n      #set ($discard = $whereParams.add(\"%$filterValue%\"))\n    #end\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterDBStringListProperty)\n  ## Perform exact matching by default if no match type is specified.\n  ## Note that for DBStringList properties we take into account only the first match type, even if multiple filter\n  ## values are specified. Basically the first match type is used for all filter values.\n  #livetable_getMatchTypes($colname $filterValues.size() 'exact')\n  #if ($matchType == 'partial' || $matchType == 'prefix')\n    ## We need to join with the list of values in order to be able to use the LIKE operator.\n    #set ($matchTarget = \"${safe_tableAlias}_item\")\n    #if ($whereParams.entrySet())\n      #set ($paramPrefix = \"${safe_tableAlias}_item_\")\n    #else\n      #set ($paramPrefix = $NULL)\n    #end\n    #set ($joinPos = $mathtool.add($fromSql.lastIndexOf(\" $safe_tableAlias\"), $mathtool.add($safe_tableAlias.length(), 1)))\n    #set ($fromSql = \"$fromSql.substring(0, $joinPos) join ${safe_tableAlias}.list as $matchTarget $fromSql.substring($joinPos)\")\n  #else\n    ## Fall-back on exact matching even if the match type is specified, when its value is not supported.\n    #set ($matchType = 'exact')\n    #set ($matchTarget = \"${safe_tableAlias}.list\")\n    #if ($whereParams.entrySet())\n      #set ($paramPrefix = \"${safe_tableAlias}_list_\")\n    #else\n      #set ($paramPrefix = $NULL)\n    #end\n  #end\n  #set ($filterQuery = \"#livetable_getFilterQuery($matchTarget $matchType true $filterValues.size() $paramPrefix $NULL)\")\n  #set ($whereSql = \"$whereSql and ($filterQuery.trim())\")\n  #foreach ($filterValue in $filterValues)\n    #livetable_addFilterParam($filterValue $matchType $whereParams \"${paramPrefix}${foreach.count}\")\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterStringListProperty)\n  ## From the user point of view we support only exact matching for StringList properties, due to the way the values of\n  ## these properties are stored (concatenated). But when building the actual query, the match type is in fact partial\n  ## because we have to use the like operator in order to match the concatenated list of values.\n  #livetable_getMatchTypes($colname $filterValues.size() 'exact')\n  #set ($matchTarget = \"concat('|', concat(${safe_tableAlias}.textValue, '|'))\")\n  #if ($whereParams.entrySet())\n    #set ($paramPrefix = \"${safe_tableAlias}_textValue_\")\n  #else\n    #set ($paramPrefix = $NULL)\n  #end\n  ## As noted above, we have to use the like operator because the list of values is saved concatenated, so from the\n  ## point of view of the query the match type is always partial.\n  #set ($filterQuery = \"#livetable_getFilterQuery($matchTarget 'partial' false $filterValues.size() $paramPrefix $NULL)\")\n  #set ($whereSql = \"${whereSql} and ($filterQuery.trim())\")\n  #foreach ($filterValue in $filterValues)\n    #if ($matchTypes.get($foreach.index) == 'empty')\n      ## The client side cannot pass an empty filter value so it specifies that the value is empty using the match type.\n      #set ($filterValue = '')\n    #end\n    ## As noted above, we can only perform exact matching due to the way the values are stored (concatenated).\n    #livetable_addFilterParam(\"%|$filterValue|%\" 'exact' $whereParams \"${paramPrefix}${foreach.count}\")\n  #end\n#end\n\n\n#**\n * NOTE: This macro uses variables defined in livetable_filterProperty . It was not meant to be used alone.\n *#\n#macro (livetable_filterStringProperty)\n  #if ($propMetaClass.endsWith('ListClass'))\n    ## Perform exact matching by default for StaticListClass, DBListClass and DBTreeListClass\n    ## when they are stored as StringProperty (i.e. single value and no relational storage).\n    #set ($defaultStringMatchType = 'exact')\n  #else\n    ## Perform partial matching by default otherwise.\n    #set ($defaultStringMatchType = 'partial')\n  #end\n  #livetable_getMatchTypes($colname $filterValues.size() $defaultStringMatchType)\n  ## Group the filter values by match type so that we cann optimize the query.\n  #livetable_groupFilterValuesByMatchType($matchTypes $filterValues)\n  #if ($whereParams.entrySet())\n    #set ($paramPrefix = \"${safe_tableAlias}_value_\")\n  #else\n    #set ($paramPrefix = $NULL)\n  #end\n  ## Note that unlike other property types, the String property supports different match types for different filter\n  ## values. This means we have to call livetable_getFilterQuery for each filter value and then join the constraints\n  ## ourselves.\n  #set ($constraints = [])\n  #set ($paramOffset = 1)\n  #foreach ($entry in $filterValuesByMatchType.entrySet())\n    #set ($matchType = $entry.key)\n    #set ($filterValues = $entry.value)\n    #set ($constraint = \"#livetable_getFilterQuery(\"\"${safe_tableAlias}.value\"\" $matchType false $filterValues.size() $paramPrefix $paramOffset)\")\n    #set ($discard = $constraints.add($constraint.trim()))\n    #foreach ($filterValue in $filterValues)\n      #livetable_addFilterParam($filterValue $matchType $whereParams\n        \"${paramPrefix}${mathtool.add($paramOffset, $foreach.index)}\")\n    #end\n    #set ($paramOffset = $paramOffset + $filterValues.size())\n  #end\n  #set ($whereSql = \"${whereSql} and ($stringtool.join($constraints, \"\" $joinOperator \"\"))\")\n#end\n\n#macro (livetable_groupFilterValuesByMatchType $matchTypes $filterValues)\n  #set ($filterValuesByMatchType = {})\n  #foreach ($matchType in $matchTypes)\n    #set ($discard = $filterValuesByMatchType.putIfAbsent($matchType, []))\n    #set ($discard = $filterValuesByMatchType.get($matchType).add($filterValues.get($foreach.index)))\n  #end\n#end\n\n#macro (livetable_getJoinOperator $colName)\n  #set ($joinOperator = \"$!{request.get(\"\"${colName}${joinModeMarker}\"\").toUpperCase()}\")\n  #if ($joinOperator != 'AND' &amp;&amp; $joinOperator != 'OR')\n    #set ($joinOperator = 'AND')\n  #end\n#end\n\n#macro (livetable_getFilterQuery $column $matchType $isList $valueCount $paramPrefix $paramOffset)\n  #livetable_getJoinOperator($colname)\n  #if (!$paramOffset)\n    #set ($paramOffset = 1)\n  #end\n  #if ($matchType == 'partial' || $matchType == 'prefix')\n    #livetable_repeatParams(\"upper($column) like upper(?)\", \" $joinOperator \", $valueCount, $paramPrefix, $paramOffset)\n  #elseif($matchType == 'empty')\n    ## Check if the value of the column is like the empty parameter (which is often the empty string), or if the value \n    ## of the column is null (to be compliant with Oracle which stores the empty string as a NULL value).\n    #livetable_repeatParams(\"($column like ? or $column is null)\", \" $joinOperator \", $valueCount, $paramPrefix, \n    $paramOffset)\n  #elseif ($isList)\n    #livetable_repeatParams(\"? in elements($column)\", \" $joinOperator \", $valueCount, $paramPrefix, $paramOffset)\n  #elseif ($valueCount &gt; 1 &amp;&amp; $joinOperator == 'OR')\n    $column in (#livetable_repeatParams('?', ', ', $valueCount, $paramPrefix, $paramOffset))\n  #else\n    #livetable_repeatParams(\"$column = ?\", ' AND ', $valueCount, $paramPrefix, $paramOffset)\n  #end\n#end\n\n#macro (livetable_repeatParams $str $separator $valueCount $paramPrefix $paramOffset)\n  #if ($valueCount &gt; 0)\n    #foreach ($count in [1..$valueCount])\n      #if ($count &gt; 1)\n        $separator##\n      #end\n      #if ($paramPrefix)\n        $str.replace('?', \":${paramPrefix}${mathtool.add($paramOffset, $foreach.index)}\")##\n      #else\n        $str##\n      #end\n    #end\n  #end\n#end\n\n#macro (livetable_addFilterParam $filterValue $matchType $params $paramName)\n  #if ($matchType == 'partial')\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, \"%$!filterValue%\"))\n    #else\n      #set ($discard = $params.add(\"%$!filterValue%\"))\n    #end\n  #elseif ($matchType == 'prefix')\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, \"$!filterValue%\"))\n    #else\n      #set ($discard = $params.add(\"$!filterValue%\"))\n    #end\n  #elseif ($matchType == 'empty')\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, ''))\n    #else\n      #set ($discard = $params.add(''))\n    #end\n  #else\n    #if ($params.entrySet())\n      #set ($discard = $params.put($paramName, $filterValue))\n    #else\n      #set ($discard = $params.add($filterValue))\n    #end\n  #end\n#end\n\n\n#**\n * Old alias of the #livetable_addColumnToQuery macro.\n * @deprecated since 2.2.3, use {@link #livetable_addColumnToQuery}\n *#\n#macro(grid_addcolumn $colname)\n  #livetable_addColumnToQuery($colname)\n#end\n\n#**\n * Generates a valid SQL table alias for the specified live table column.\n *#\n#macro (livetable_getTableAlias $columnName)\n  #set ($prefix = 'doc.')\n  #if ($columnName.startsWith($prefix))\n    #set ($suffix = $stringtool.removeStart($columnName, $prefix))\n  #else\n    ## Force a prefix to avoid the cases when the column name is a reserved SQL keyword.\n    #set ($prefix = 'prop_')\n    #set ($suffix = $columnName)\n  #end\n  ## Remove non-word characters.\n  #set ($safe_tableAlias = \"$prefix$suffix.replaceAll('\\W', '')\")\n#end\n{{/velocity}}</content>\n</xwikidoc>\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.livetable;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.script.ModelScriptService;\nimport org.xwiki.query.internal.ScriptQuery;\nimport org.xwiki.query.script.QueryManagerScriptService;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.script.SecurityScriptServiceComponentList;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.page.PageTest;\nimport org.xwiki.test.page.XWikiSyntax20ComponentList;\nimport org.xwiki.velocity.tools.JSONTool;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.classes.StaticListClass;\nimport com.xpn.xwiki.plugin.tag.TagPluginApi;\n\nimport static java.util.Collections.emptyList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyMap;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.same;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for the {@code LiveTableResults} page.\n * \n * @version $Id$\n */\n@XWikiSyntax20ComponentList\n@SecurityScriptServiceComponentList\n@ComponentList({\n    ModelScriptService.class\n})\nclass LiveTableResultsTest extends PageTest\n{\n    private QueryManagerScriptService queryService;\n\n    private Map<String, Object> results;\n\n    @Mock\n    private ScriptQuery query;\n\n    @BeforeEach\n    @SuppressWarnings(\"deprecation\")\n    public void setUp() throws Exception\n    {\n        // The LiveTableResultsMacros page expects that the HTTP query is done with the \"get\" action and asking for\n        // plain output.\n        setOutputSyntax(Syntax.PLAIN_1_0);\n        this.request.put(\"outputSyntax\", \"plain\");\n        this.request.put(\"xpage\", \"plain\");\n        this.oldcore.getXWikiContext().setAction(\"get\");\n\n        // Prepare mock Query Service so that tests can control what the DB returns.\n        this.queryService = mock(QueryManagerScriptService.class);\n        this.oldcore.getMocker().registerComponent(ScriptService.class, \"query\", this.queryService);\n\n        // The LiveTableResultsMacros page uses the tag plugin for the LT tag cloud feature\n        TagPluginApi tagPluginApi = mock(TagPluginApi.class);\n        doReturn(tagPluginApi).when(this.oldcore.getSpyXWiki()).getPluginApi(eq(\"tag\"), any(XWikiContext.class));\n\n        loadPage(new DocumentReference(\"xwiki\", \"XWiki\", \"LiveTableResultsMacros\"));\n    }\n\n    @Test\n    void plainPageResults() throws Exception\n    {\n        setColumns(\"doc.name\", \"doc.date\");\n        setSort(\"doc.date\", false);\n        setQueryFilters(\"currentlanguage\", \"hidden\");\n        // Offset starting from 1.\n        setOffset(13);\n        setLimit(7);\n\n        when(this.queryService.hql(\"  where 1=1    order by doc.date desc\")).thenReturn(this.query);\n        when(this.query.addFilter(\"currentlanguage\")).thenReturn(this.query);\n        when(this.query.addFilter(\"hidden\")).thenReturn(this.query);\n        when(this.query.setLimit(7)).thenReturn(this.query);\n        // Offset starting from 0.\n        when(this.query.setOffset(12)).thenReturn(this.query);\n        when(this.query.bindValues(anyMap())).thenReturn(this.query);\n\n        when(this.query.count()).thenReturn(17L);\n        when(this.query.execute()).thenReturn(Arrays.asList(\"A.B\", \"X.Y\"));\n\n        renderPage();\n\n        assertEquals(17L, getTotalRowCount());\n        assertEquals(2, getRowCount());\n        assertEquals(13, getOffset());\n\n        List<Map<String, Object>> rows = getRows();\n        assertEquals(2, rows.size());\n\n        Map<String, Object> ab = rows.get(0);\n        assertEquals(\"A\", ab.get(\"doc_space\"));\n        assertEquals(\"B\", ab.get(\"doc_name\"));\n\n        Map<String, Object> xy = rows.get(1);\n        assertEquals(\"X\", xy.get(\"doc_space\"));\n        assertEquals(\"Y\", xy.get(\"doc_name\"));\n    }\n\n    /**\n     * @see \"XWIKI-12803: Class attribute not escaped in Live Tables\"\n     */\n    @Test\n    void sqlReservedKeywordAsPropertyName() throws Exception\n    {\n        setColumns(\"where\");\n        setSort(\"where\", true);\n        setClassName(\"My.Class\");\n\n        when(this.queryService.hql(any())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService).hql(\n            \", BaseObject as obj , StringProperty prop_where  \"\n                + \"where obj.name=doc.fullName and obj.className = :className and \"\n                + \"doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id=prop_where.id.id and prop_where.name = :prop_where_name   \"\n                + \"order by lower(prop_where.value) asc, prop_where.value asc\");\n    }\n\n    /**\n     * @see \"XWIKI-12855: Unable to sort the Location column in Page Index\"\n     */\n    @Test\n    void orderByLocation() throws Exception\n    {\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        setSort(\"doc.location\", false);\n\n        renderPage();\n\n        verify(this.queryService).hql(\"  where 1=1    order by lower(doc.fullName) desc, doc.fullName desc\");\n    }\n\n    /**\n     * Verify we can restrict pages by using a location filter and that we can also filter by doc.location\n     * at the same time. See <a href=\"https://jira.xwiki.org/browse/XWIKI-17463\">XWIKI-17463</a>.\n     */\n    @Test\n    void restrictLocationAndFilterByDocLocation() throws Exception\n    {\n        // Simulate the following type of URL:\n        // http://localhost:8080/xwiki/bin/get/XWiki/LiveTableResults?outputSyntax=plain&collist=doc.location\n        //   &location=Hello&offset=1&limit=15&reqNo=2&doc.location=t&sort=doc.location&dir=asc\n        setColumns(\"doc.location\");\n        setLocation(\"Hello\");\n        setFilter(\"doc.location\", \"test\");\n\n        when(this.queryService.hql(any(String.class))).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(anyMap())).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService).hql(\"  where 1=1  AND ((doc.name = 'WebHome' AND LOWER(doc.space) LIKE \"\n            + \"LOWER(:locationFilterValue2) ESCAPE '!') OR (doc.name <> 'WebHome' AND LOWER(doc.fullName) LIKE \"\n            + \"LOWER(:locationFilterValue2) ESCAPE '!'))  AND LOWER(doc.fullName) LIKE \"\n            + \"LOWER(:locationFilterValue1) ESCAPE '!'\");\n        ArgumentCaptor<Map<String, ?>> argument = ArgumentCaptor.forClass(Map.class);\n        verify(query).bindValues(argument.capture());\n        assertEquals(2, argument.getValue().size());\n        assertEquals(\"%Hello%\", argument.getValue().get(\"locationFilterValue1\"));\n        assertEquals(\"%test%\", argument.getValue().get(\"locationFilterValue2\"));\n    }\n\n    /**\n     * Verify the query and its bound values when an empty matcher is used on one of the values. In this test, the\n     * filter is applied on a static string list with MultiSelect = false, which can be assimilated to a field of type \n     * String when filtering.\n     */\n    @Test\n    void filterStringEmptyMatcher() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Panels\", \"PanelClass\"));\n        StaticListClass category = document.getXClass().addStaticListField(\"category\");\n        category.setValues(\"Information|Tools\");\n        this.xwiki.saveDocument(document, \"creates PanelClass\", true, this.context);\n        \n        setColumns(\"name,description,category\");\n        setSort(\"name\", true);\n        setClassName(\"Panels.PanelClass\");\n        setFilter(\"category_match\", \"empty\");\n        setFilter(\"category\", \"-\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"Information\");\n        this.request.put(\"category/join_mode\", \"OR\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService)\n            .hql(\", BaseObject as obj , StringProperty as prop_category, StringProperty prop_name  \"\n                + \"where obj.name=doc.fullName and obj.className = :className \"\n                + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id = prop_category.id.id and prop_category.id.name = :prop_category_id_name \"\n                + \"and ((prop_category.value like :prop_category_value_1 or prop_category.value is null) \"\n                + \"OR prop_category.value = :prop_category_value_2) \"\n                + \"and obj.id=prop_name.id.id and prop_name.name = :prop_name_name   \"\n                + \"order by lower(prop_name.value) asc, prop_name.value asc\");\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Panels.PanelClass\");\n        values.put(\"classTemplate1\", \"Panels.PanelClassTemplate\");\n        values.put(\"classTemplate2\", \"Panels.PanelTemplate\");\n        values.put(\"prop_category_id_name\", \"category\");\n        values.put(\"prop_category_value_1\", \"\");\n        values.put(\"prop_category_value_2\", \"Information\");\n        values.put(\"prop_name_name\", \"name\");\n        verify(this.query).bindValues(values);\n    }\n\n    /**\n     * Verify the query and its bound values when an empty matcher is used on one of the values. In this test, the\n     * filter is applied on a static string list with MultiSelect = true.\n     */\n    @Test\n    void filterStringListEmptyMatcher() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Panels\", \"PanelClass\"));\n        StaticListClass category = document.getXClass().addStaticListField(\"category\");\n        category.setValues(\"Information|Tools\");\n        category.setMultiSelect(true);\n        this.xwiki.saveDocument(document, \"creates PanelClass\", true, this.context);\n\n        setColumns(\"name,description,category\");\n        setSort(\"name\", true);\n        setClassName(\"Panels.PanelClass\");\n        setFilter(\"category_match\", \"empty\");\n        setFilter(\"category\", \"-\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"Information\");\n        setJoinMode(\"category\", \"OR\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService)\n            .hql(\", BaseObject as obj , StringListProperty as prop_category, StringProperty prop_name  \"\n                + \"where obj.name=doc.fullName \"\n                + \"and obj.className = :className \"\n                + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id = prop_category.id.id \"\n                + \"and prop_category.id.name = :prop_category_id_name \"\n                + \"and (\"\n                + \"upper(concat('|', concat(prop_category.textValue, '|'))) like upper(:prop_category_textValue_1) \"\n                + \"OR upper(concat('|', concat(prop_category.textValue, '|'))) like upper(:prop_category_textValue_2)\"\n                + \") \"\n                + \"and obj.id=prop_name.id.id and prop_name.name = :prop_name_name   \"\n                + \"order by lower(prop_name.value) asc, prop_name.value asc\");\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Panels.PanelClass\");\n        values.put(\"classTemplate1\", \"Panels.PanelClassTemplate\");\n        values.put(\"classTemplate2\", \"Panels.PanelTemplate\");\n        values.put(\"prop_category_id_name\", \"category\");\n        values.put(\"prop_category_textValue_1\", \"%||%\");\n        values.put(\"prop_category_textValue_2\", \"%|Information|%\");\n        values.put(\"prop_name_name\", \"name\");\n        verify(this.query).bindValues(values);\n    }\n\n    /**\n     * Verify that we can filter String properties by multiple values and that the filter values are grouped by match\n     * type (in order to optimize the query).\n     */\n    @Test\n    void filterStringMultipleValues() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Panels\", \"PanelClass\"));\n        document.getXClass().addStaticListField(\"category\");\n        this.xwiki.saveDocument(document, \"creates PanelClass\", true, this.context);\n\n        setColumns(\"name,description,category\");\n        setSort(\"name\", true);\n        setClassName(\"Panels.PanelClass\");\n        setFilter(\"category_match\", \"partial\");\n        setFilter(\"category\", \"a\");\n        setFilter(\"category_match\", \"prefix\");\n        setFilter(\"category\", \"b\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"c\");\n        setFilter(\"category_match\", \"exact\");\n        setFilter(\"category\", \"d\");\n        this.request.put(\"category/join_mode\", \"OR\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService)\n            .hql(\", BaseObject as obj , StringProperty as prop_category, StringProperty prop_name  \"\n                + \"where obj.name=doc.fullName and obj.className = :className \"\n                + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n                + \"and obj.id = prop_category.id.id and prop_category.id.name = :prop_category_id_name \"\n                + \"and (upper(prop_category.value) like upper(:prop_category_value_1) OR\"\n                + \" upper(prop_category.value) like upper(:prop_category_value_2) OR\"\n                + \" prop_category.value in (:prop_category_value_3, :prop_category_value_4)) \"\n                + \"and obj.id=prop_name.id.id and prop_name.name = :prop_name_name   \"\n                + \"order by lower(prop_name.value) asc, prop_name.value asc\");\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Panels.PanelClass\");\n        values.put(\"classTemplate1\", \"Panels.PanelClassTemplate\");\n        values.put(\"classTemplate2\", \"Panels.PanelTemplate\");\n        values.put(\"prop_category_id_name\", \"category\");\n        values.put(\"prop_category_value_1\", \"%a%\");\n        values.put(\"prop_category_value_2\", \"b%\");\n        values.put(\"prop_category_value_3\", \"c\");\n        values.put(\"prop_category_value_4\", \"d\");\n        values.put(\"prop_name_name\", \"name\");\n        verify(this.query).bindValues(values);\n    }\n\n    /**\n     * When no match type is explicitly defined for a matcher on a short text, the matcher must be partial (i.e., the\n     * filtering must match on substrings).\n     */\n    @Test\n    void filterStringNoMatcherSpecified() throws Exception\n    {\n        XWikiDocument document = new XWikiDocument(new DocumentReference(\"xwiki\", \"Test\", \"MyPage\"));\n        document.getXClass().addTextField(\"shortText\", \"Short Text\", 10);\n        this.xwiki.saveDocument(document, \"creates my page\", true, this.context);\n        setColumns(\"shortText\");\n        setClassName(\"Test.MyPage\");\n        setFilter(\"shortText\", \"X\");\n\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n\n        renderPage();\n\n        verify(this.queryService).hql(\", BaseObject as obj , StringProperty as prop_shortText  \"\n            + \"where obj.name=doc.fullName \"\n            + \"and obj.className = :className \"\n            + \"and doc.fullName not in (:classTemplate1, :classTemplate2)  \"\n            + \"and obj.id = prop_shortText.id.id \"\n            + \"and prop_shortText.id.name = :prop_shortText_id_name \"\n            + \"and (upper(prop_shortText.value) like upper(:prop_shortText_value_1)) \");\n\n        Map<String, Object> values = new HashMap<>();\n        values.put(\"className\", \"Test.MyPage\");\n        values.put(\"classTemplate1\", \"Test.MyPageTemplate\");\n        values.put(\"classTemplate2\", \"Test.MyPage\");\n        values.put(\"prop_shortText_id_name\", \"shortText\");\n        values.put(\"prop_shortText_value_1\", \"%X%\");\n        verify(this.query).bindValues(values);\n    }\n\n    @Test\n    void nonViewableResultsAreObfuscated() throws Exception\n    {\n        this.request.put(\"limit\", \"2\");\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(3L);\n        when(this.query.execute()).thenReturn(Arrays.asList(\"XWiki.NotViewable\", \"XWiki.Viewable\"));\n\n        when(this.oldcore.getMockContextualAuthorizationManager()\n            .hasAccess(same(Right.VIEW), eq(new DocumentReference(\"xwiki\", \"XWiki\", \"NotViewable\")))).thenReturn(false);\n\n        renderPage();\n\n        List<Map<String, Object>> rows = getRows();\n        assertEquals(2, rows.size());\n        assertEquals(2, getRowCount());\n        Map<String, Object> obfuscated = rows.get(0);\n        assertFalse((boolean) obfuscated.get(\"doc_viewable\"));\n        assertEquals(\"obfuscated\", obfuscated.get(\"doc_fullName\"));\n\n        Map<String, Object> viewable = rows.get(1);\n        assertTrue((boolean) viewable.get(\"doc_viewable\"));\n        assertEquals(\"XWiki.Viewable\", viewable.get(\"doc_fullName\"));\n    }\n\n    @Test\n    void removeObfuscatedResultsWhenTotalrowsLowerThanLimit() throws Exception\n    {\n        this.request.put(\"limit\", \"2\");\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(2L);\n        when(this.query.execute()).thenReturn(Arrays.asList(\"XWiki.NotViewable\", \"XWiki.Viewable\"));\n\n        when(this.oldcore.getMockContextualAuthorizationManager()\n            .hasAccess(same(Right.VIEW), eq(new DocumentReference(\"xwiki\", \"XWiki\", \"NotViewable\")))).thenReturn(false);\n\n        renderPage();\n\n        List<Map<String, Object>> rows = getRows();\n        assertEquals(1, rows.size());\n        assertEquals(1, getRowCount());\n\n        Map<String, Object> viewable = rows.get(0);\n        assertTrue((boolean) viewable.get(\"doc_viewable\"));\n        assertEquals(\"XWiki.Viewable\", viewable.get(\"doc_fullName\"));\n    }\n\n    @Test\n    void removeObfuscatedResultsWhenLimitIs0() throws Exception\n    {\n        when(this.queryService.hql(anyString())).thenReturn(this.query);\n        when(this.query.setLimit(anyInt())).thenReturn(this.query);\n        when(this.query.setOffset(anyInt())).thenReturn(this.query);\n        when(this.query.bindValues(any(Map.class))).thenReturn(this.query);\n        when(this.query.count()).thenReturn(1L);\n        when(this.query.execute()).thenReturn(Arrays.asList(\"XWiki.NotViewable\"));\n\n        when(this.oldcore.getMockContextualAuthorizationManager()\n            .hasAccess(same(Right.VIEW), eq(new DocumentReference(\"xwiki\", \"XWiki\", \"NotViewable\")))).thenReturn(false);\n\n        this.request.put(\"limit\", \"0\");\n        this.request.put(\"classname\", \"\");\n        this.request.put(\"collist\", \"doc.title,doc.location,doc.content\");\n        this.request.put(\"doc.title\", \"Sandbo\");\n        this.request.put(\"doc.location\", \"Sandbox.TestPage3\");\n        this.request.put(\"doc.content\", \"dummy\");\n        this.request.put(\"limit\", \"0\");\n\n        renderPage();\n\n        assertEquals(0, getTotalRowCount());\n        assertEquals(0, getRowCount());\n        assertEquals(1, getOffset());\n        assertEquals(emptyList(), getRows());\n    }\n\n    //\n    // Helper methods\n    //\n\n    @SuppressWarnings(\"unchecked\")\n    private String renderPage() throws Exception\n    {\n        JSONTool jsonTool = mock(JSONTool.class);\n        registerVelocityTool(\"jsontool\", jsonTool);\n\n        String output = renderPage(new DocumentReference(\"xwiki\", \"XWiki\", \"LiveTableResults\"));\n\n        ArgumentCaptor<Object> argument = ArgumentCaptor.forClass(Object.class);\n        verify(jsonTool).serialize(argument.capture());\n\n        this.results = (Map<String, Object>) argument.getValue();\n\n        return output;\n    }\n\n    private void setClassName(String className)\n    {\n        this.request.put(\"classname\", className);\n    }\n\n    private void setColumns(String... columns)\n    {\n        this.request.put(\"collist\", StringUtils.join(columns, ','));\n    }\n\n    private void setLocation(String location)\n    {\n        this.request.put(\"location\", location);\n    }\n\n    private void setOffset(int offset)\n    {\n        this.request.put(\"offset\", String.valueOf(offset));\n    }\n\n    private void setLimit(int limit)\n    {\n        this.request.put(\"limit\", String.valueOf(limit));\n    }\n\n    private void setSort(String column, Boolean ascending)\n    {\n        this.request.put(\"sort\", column);\n        if (ascending != null) {\n            this.request.put(\"dir\", ascending ? \"asc\" : \"desc\");\n        }\n    }\n\n    private void setFilter(String column, String value)\n    {\n        this.request.put(column, value);\n    }\n\n    private void setJoinMode(String column, String joinMode)\n    {\n        this.request.put(column + \"/join_mode\", joinMode);\n    }\n\n    private void setQueryFilters(String... filters)\n    {\n        this.request.put(\"queryFilters\", StringUtils.join(filters, ','));\n    }\n\n    private Object getTotalRowCount()\n    {\n        return this.results.get(\"totalrows\");\n    }\n\n    private Object getRowCount()\n    {\n        return this.results.get(\"returnedrows\");\n    }\n\n    private Object getOffset()\n    {\n        return this.results.get(\"offset\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List<Map<String, Object>> getRows()\n    {\n        return (List<Map<String, Object>>) this.results.get(\"rows\");\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-livetable/xwiki-platform-livetable-ui/src/main/resources/XWiki/LiveTableResultsMacros.xml", "xwiki-platform-core/xwiki-platform-livetable/xwiki-platform-livetable-ui/src/test/java/org/xwiki/livetable/LiveTableResultsTest.java"], "buggy_code_start_loc": [339, 49], "buggy_code_end_loc": [340, 472], "fixing_code_start_loc": [339, 50], "fixing_code_end_loc": [345, 503], "type": "CWE-200", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Users without the right to view documents can deduce their existence by repeated Livetable queries. The issue has been patched in XWiki 14.6RC1, 13.10.8, and 14.4.3, the response is not properly cleaned up of obfuscated entries. As a workaround, The patch for the document `XWiki.LiveTableResultsMacros` can be manually applied or a XAR archive of a patched version can be imported, on versions 12.10.11, 13.9-rc-1, and 13.4.4. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-41935", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-23T20:15:10.177", "lastModified": "2022-11-30T17:34:20.943", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Users without the right to view documents can deduce their existence by repeated Livetable queries. The issue has been patched in XWiki 14.6RC1, 13.10.8, and 14.4.3, the response is not properly cleaned up of obfuscated entries. As a workaround, The patch for the document `XWiki.LiveTableResultsMacros` can be manually applied or a XAR archive of a patched version can be imported, on versions 12.10.11, 13.9-rc-1, and 13.4.4. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.10.11", "versionEndExcluding": "13.10.8", "matchCriteriaId": "D85CE504-50CC-40BE-A8B0-2B6BD9186841"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.4.3", "matchCriteriaId": "CF0D4D4B-363F-4D5D-B780-1CBCC1C202B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:14.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "CDAB9E27-2E41-44EA-BBCB-8015B22272B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:14.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "79B3E9A4-CAC3-4E8D-9C76-F7AE5C3385C1"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/1450b6e3c69ac7df25e5a2571186d1f43402facd#diff-5a739e5865b1f1ad9d79b724791be51b0095a0170cc078911c940478b13b949a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-p2x4-6ghr-6vmq", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-19999", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/1450b6e3c69ac7df25e5a2571186d1f43402facd#diff-5a739e5865b1f1ad9d79b724791be51b0095a0170cc078911c940478b13b949a"}}