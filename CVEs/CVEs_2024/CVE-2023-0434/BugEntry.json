{"buggy_code": ["# -*- coding: utf-8 -*-\n\nimport os\nimport re\nimport shutil\nimport time\n\nfrom pyload import PKGDIR\n\nfrom ... import exc_logger\n\n# CONFIG_VERSION\n__version__ = 2\n\n\nclass ConfigParser:\n    \"\"\"\n    holds and manage the configuration.\n\n    current dict layout:\n\n    {\n\n     section : {\n      option : {\n            value:\n            type:\n            desc:\n      }\n      desc:\n\n    }\n    \"\"\"\n\n    _CONFLINE = re.compile(\n        r'\\s*(?P<T>.+?)\\s+(?P<N>[^ ]+?)\\s*:\\s*\"(?P<D>.+?)\"\\s*=\\s?(?P<V>.*)'\n    )\n    _SECTLINE = re.compile(r'(.+?)\\s+-\\s+\"(.+?)\":')\n    _VERSION = re.compile(r\"\\s*version\\s*:\\s*(\\d+)\")\n\n    def __init__(self, userdir):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.config = {}  #: the config values\n        self.plugin = {}  #: the config for plugins\n\n        # TODO: Recheck\n        configdir = os.path.join(userdir, \"settings\")\n        os.makedirs(configdir, exist_ok=True)\n\n        self.configpath = os.path.join(configdir, \"pyload.cfg\")\n        self.pluginpath = os.path.join(configdir, \"plugins.cfg\")\n\n        self.plugin_cb = None  #: callback when plugin config value is changed\n\n        self.check_version()\n\n        self.read_default_config()\n\n    def check_version(self, n=0):\n        \"\"\"\n        determines if config need to be copied.\n        \"\"\"\n        try:\n            if not os.path.exists(self.configpath):\n                os.makedirs(os.path.dirname(self.configpath), exist_ok=True)\n                shutil.copy(\n                    os.path.join(PKGDIR, \"core\", \"config\", \"default.cfg\"),\n                    self.configpath,\n                )\n                os.chmod(self.configpath, 0o600)\n\n            if not os.path.exists(self.pluginpath):\n                os.makedirs(os.path.dirname(self.pluginpath), exist_ok=True)\n                with open(self.pluginpath, mode=\"w\") as fp:\n                    fp.write(f\"version: {__version__}\")\n                os.chmod(self.pluginpath, 0o600)\n\n            with open(self.configpath) as fp:\n                content = fp.read()\n\n            m_ver = self._VERSION.search(content)\n            if m_ver is None or int(m_ver.group(1)) < __version__:\n                shutil.copy(\n                    os.path.join(PKGDIR, \"core\", \"config\", \"default.cfg\"),\n                    self.configpath,\n                )\n                print(\"Old version of config was replaced\")\n\n            with open(self.pluginpath) as fp:\n                content = fp.read()\n\n            m_ver = self._VERSION.search(content)\n            if m_ver is None or int(m_ver.group(1)) < __version__:\n                with open(self.pluginpath, mode=\"w\") as fp:\n                    fp.write(f\"version: {__version__}\")\n\n                print(\"Old version of plugin-config replaced\")\n\n        except Exception:\n            if n < 3:\n                time.sleep(1)\n                self.check_version(n + 1)\n            else:\n                raise\n\n    def read_default_config(self):\n        \"\"\"\n        reads the config file.\n        \"\"\"\n        self.config = self.parse_config(\n            os.path.join(PKGDIR, \"core\", \"config\", \"default.cfg\")\n        )\n        self.plugin = self.parse_config(self.pluginpath)\n\n        try:\n            homeconf = self.parse_config(self.configpath)\n            self.update_values(homeconf, self.config)\n\n        except Exception as exc:\n            exc_logger.exception(exc)\n\n    def parse_config(self, config_file):\n        \"\"\"\n        parses a given configfile.\n        \"\"\"\n        with open(config_file) as fp:\n\n            config = fp.read()\n\n            config = config.splitlines()[1:]\n\n            conf = {}\n\n            section, option, value, typ, desc = \"\", \"\", \"\", \"\", \"\"\n\n            listmode = False\n\n            for line in config:\n                comment = line.rfind(\"#\")\n                if (\n                    line.find(\":\", comment) < 0 > line.find(\"=\", comment)\n                    and comment > 0\n                    and line[comment - 1].isspace()\n                ):\n                    line = line.rpartition(\"#\")  #: removes comments\n                    if line[1]:\n                        line = line[0]\n                    else:\n                        line = line[2]\n\n                line = line.strip()\n\n                try:\n                    if line == \"\":\n                        continue\n                    m = self._SECTLINE.match(line)\n                    if m is not None:\n                        section, desc = m.groups()\n                        conf[section] = {\"desc\": desc}\n                    else:\n                        if listmode:\n                            if line.endswith(\"]\"):\n                                listmode = False\n                                line = line.replace(\"]\", \"\")\n\n                            value += [\n                                self.cast(typ, x.strip()) for x in line.split(\",\") if x\n                            ]\n\n                            if not listmode:\n                                conf[section][option] = {\n                                    \"desc\": desc,\n                                    \"type\": typ,\n                                    \"value\": value,\n                                }\n\n                        else:\n                            m = self._CONFLINE.search(line)\n\n                            typ = m.group(\"T\")\n                            option = m.group(\"N\")\n                            desc = m.group(\"D\").strip()\n                            value = m.group(\"V\").strip()\n\n                            if value.startswith(\"[\"):\n                                if value.endswith(\"]\"):\n                                    listmode = False\n                                    value = value[:-1]\n                                else:\n                                    listmode = True\n\n                                value = [\n                                    self.cast(typ, x.strip())\n                                    for x in value[1:].split(\",\")\n                                    if x\n                                ]\n                            else:\n                                value = self.cast(typ, value)\n\n                            if not listmode:\n                                conf[section][option] = {\n                                    \"desc\": desc,\n                                    \"type\": typ,\n                                    \"value\": value,\n                                }\n\n                except Exception as exc:\n                    exc_logger.exception(exc)\n\n        return conf\n\n    def update_values(self, config, dest):\n        \"\"\"\n        sets the config values from a parsed config file to values in destination.\n        \"\"\"\n        for section in config.keys():\n            if section in dest:\n                for option in config[section].keys():\n                    if option in (\"desc\", \"outline\"):\n                        continue\n\n                    if option in dest[section]:\n                        dest[section][option][\"value\"] = config[section][option][\n                            \"value\"\n                        ]\n\n                        # else:\n                        #    dest[section][option] = config[section][option]\n\n                        # else:\n                        #    dest[section] = config[section]\n\n    def save_config(self, config, filename):\n        \"\"\"\n        saves config to filename.\n        \"\"\"\n        with open(filename, mode=\"w\") as fp:\n            os.chmod(filename, 0o600)\n            fp.write(f\"version: {__version__} \\n\")\n            for section in sorted(config.keys()):\n                fp.write(f'\\n{section} - \"{config[section][\"desc\"]}\":\\n')\n\n                for option, data in sorted(\n                    config[section].items(), key=lambda _x: _x[0]\n                ):\n                    if option in (\"desc\", \"outline\"):\n                        continue\n\n                    if isinstance(data[\"value\"], list):\n                        value = \"[ \\n\"\n                        for x in data[\"value\"]:\n                            value += f\"\\t\\t{x},\\n\"\n                        value += \"\\t\\t]\\n\"\n                    else:\n                        value = str(data[\"value\"]) + \"\\n\"\n\n                    fp.write(f'\\t{data[\"type\"]} {option} : \"{data[\"desc\"]}\" = {value}')\n\n    def cast(self, typ, value):\n        \"\"\"\n        cast value to given format.\n        \"\"\"\n        if typ == \"int\":\n            return int(value)\n\n        elif typ == \"float\":\n            return float(value)\n\n        elif typ == \"str\":\n            return \"\" if value is None else str(value)\n\n        elif typ == \"bytes\":\n            return b\"\" if value is None else bytes(value)\n\n        elif typ == \"bool\":\n            value = \"\" if value is None else str(value)\n            return value.lower() in (\"1\", \"true\", \"on\", \"yes\", \"y\")\n\n        elif typ == \"time\":\n            value = \"\" if value is None else str(value)\n            if not value:\n                value = \"0:00\"\n            if \":\" not in value:\n                value += \":00\"\n            return value\n\n        elif typ in (\"file\", \"folder\"):\n            return \"\" if value in (None, \"\") else os.path.realpath(os.path.expanduser(os.fsdecode(value)))\n\n        else:\n            return value\n\n    def save(self):\n        \"\"\"\n        saves the configs to disk.\n        \"\"\"\n        self.save_config(self.config, self.configpath)\n        self.save_config(self.plugin, self.pluginpath)\n\n    def __getitem__(self, section):\n        \"\"\"\n        provides dictonary like access: c['section']['option']\n        \"\"\"\n        return Section(self, section)\n\n    def get(self, section, option):\n        \"\"\"\n        get value.\n        \"\"\"\n        return self.config[section][option][\"value\"]\n\n    def set(self, section, option, value):\n        \"\"\"\n        set value.\n        \"\"\"\n        value = self.cast(self.config[section][option][\"type\"], value)\n\n        self.config[section][option][\"value\"] = value\n        self.save()\n\n    def toggle(self, section, option):\n        self.set(section, option, self.get(section, option) ^ True)\n\n    def get_plugin(self, plugin, option):\n        \"\"\"\n        gets a value for a plugin.\n        \"\"\"\n        return self.plugin[plugin][option][\"value\"]\n\n    def set_plugin(self, plugin, option, value):\n        \"\"\"\n        sets a value for a plugin.\n        \"\"\"\n        value = self.cast(self.plugin[plugin][option][\"type\"], value)\n\n        # TODO: check if callable\n        if self.plugin_cb:\n            self.plugin_cb(plugin, option, value)\n\n        self.plugin[plugin][option][\"value\"] = value\n        self.save()\n\n    def get_meta_data(self, section, option):\n        \"\"\"\n        get all config data for an option.\n        \"\"\"\n        return self.config[section][option]\n\n    def add_plugin_config(self, name, config, outline=\"\"):\n        \"\"\"\n        adds config options with tuples (name, type, desc, default)\n        \"\"\"\n        conf = self.plugin.get(name, {\"desc\": name})\n        conf[\"outline\"] = outline\n\n        for item in config:\n            if item[0] in conf and item[1] == conf[item[0]][\"type\"]:\n                conf[item[0]][\"desc\"] = item[2]\n            else:\n                conf[item[0]] = {\n                    \"desc\": item[2],\n                    \"type\": item[1],\n                    \"value\": self.cast(item[1], item[3]),\n                }\n\n        values = [x[0] for x in config] + [\"desc\", \"outline\"]\n        # delete old values\n        self.plugin[name] = {k: v for k, v in conf.items() if k in values}\n\n    def delete_config(self, name):\n        \"\"\"\n        Removes a plugin config.\n        \"\"\"\n        if name in self.plugin:\n            del self.plugin[name]\n\n\nclass Section:\n    \"\"\"\n    provides dictionary like access for configparser.\n    \"\"\"\n\n    def __init__(self, parser, section):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.parser = parser\n        self.section = section\n\n    def __getitem__(self, item):\n        \"\"\"\n        getitem.\n        \"\"\"\n        return self.parser.get(self.section, item)\n\n    def __setitem__(self, item, value):\n        \"\"\"\n        setitem.\n        \"\"\"\n        self.parser.set(self.section, item, value)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\nimport os\nimport re\nimport shutil\nimport time\n\nfrom pyload import PKGDIR\n\nfrom ... import exc_logger\n\n# CONFIG_VERSION\n__version__ = 2\n\n\nclass ConfigParser:\n    \"\"\"\n    holds and manage the configuration.\n\n    current dict layout:\n\n    {\n\n     section : {\n      option : {\n            value:\n            type:\n            desc:\n      }\n      desc:\n\n    }\n    \"\"\"\n\n    _CONFLINE = re.compile(\n        r'\\s*(?P<T>.+?)\\s+(?P<N>[^ ]+?)\\s*:\\s*\"(?P<D>.+?)\"\\s*=\\s?(?P<V>.*)'\n    )\n    _SECTLINE = re.compile(r'(.+?)\\s+-\\s+\"(.+?)\":')\n    _VERSION = re.compile(r\"\\s*version\\s*:\\s*(\\d+)\")\n\n    def __init__(self, userdir):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.config = {}  #: the config values\n        self.plugin = {}  #: the config for plugins\n\n        # TODO: Recheck\n        configdir = os.path.join(userdir, \"settings\")\n        os.makedirs(configdir, exist_ok=True)\n\n        self.configpath = os.path.join(configdir, \"pyload.cfg\")\n        self.pluginpath = os.path.join(configdir, \"plugins.cfg\")\n\n        self.plugin_cb = None  #: callback when plugin config value is changed\n\n        self.check_version()\n\n        self.read_default_config()\n\n    def check_version(self, n=0):\n        \"\"\"\n        determines if config need to be copied.\n        \"\"\"\n        try:\n            if not os.path.exists(self.configpath):\n                os.makedirs(os.path.dirname(self.configpath), exist_ok=True)\n                shutil.copy(\n                    os.path.join(PKGDIR, \"core\", \"config\", \"default.cfg\"),\n                    self.configpath,\n                )\n                os.chmod(self.configpath, 0o600)\n\n            if not os.path.exists(self.pluginpath):\n                os.makedirs(os.path.dirname(self.pluginpath), exist_ok=True)\n                with open(self.pluginpath, mode=\"w\") as fp:\n                    fp.write(f\"version: {__version__}\")\n                os.chmod(self.pluginpath, 0o600)\n\n            with open(self.configpath) as fp:\n                content = fp.read()\n\n            m_ver = self._VERSION.search(content)\n            if m_ver is None or int(m_ver.group(1)) < __version__:\n                shutil.copy(\n                    os.path.join(PKGDIR, \"core\", \"config\", \"default.cfg\"),\n                    self.configpath,\n                )\n                print(\"Old version of config was replaced\")\n\n            with open(self.pluginpath) as fp:\n                content = fp.read()\n\n            m_ver = self._VERSION.search(content)\n            if m_ver is None or int(m_ver.group(1)) < __version__:\n                with open(self.pluginpath, mode=\"w\") as fp:\n                    fp.write(f\"version: {__version__}\")\n\n                print(\"Old version of plugin-config replaced\")\n\n        except Exception:\n            if n < 3:\n                time.sleep(1)\n                self.check_version(n + 1)\n            else:\n                raise\n\n    def read_default_config(self):\n        \"\"\"\n        reads the config file.\n        \"\"\"\n        self.config = self.parse_config(\n            os.path.join(PKGDIR, \"core\", \"config\", \"default.cfg\")\n        )\n        self.plugin = self.parse_config(self.pluginpath)\n\n        try:\n            homeconf = self.parse_config(self.configpath)\n            self.update_values(homeconf, self.config)\n\n        except Exception as exc:\n            exc_logger.exception(exc)\n\n    def parse_config(self, config_file):\n        \"\"\"\n        parses a given configfile.\n        \"\"\"\n        with open(config_file) as fp:\n\n            config = fp.read()\n\n            config = config.splitlines()[1:]\n\n            conf = {}\n\n            section, option, value, typ, desc = \"\", \"\", \"\", \"\", \"\"\n\n            listmode = False\n\n            for line in config:\n                comment = line.rfind(\"#\")\n                if (\n                    line.find(\":\", comment) < 0 > line.find(\"=\", comment)\n                    and comment > 0\n                    and line[comment - 1].isspace()\n                ):\n                    line = line.rpartition(\"#\")  #: removes comments\n                    if line[1]:\n                        line = line[0]\n                    else:\n                        line = line[2]\n\n                line = line.strip()\n\n                try:\n                    if line == \"\":\n                        continue\n                    m = self._SECTLINE.match(line)\n                    if m is not None:\n                        section, desc = m.groups()\n                        conf[section] = {\"desc\": desc}\n                    else:\n                        if listmode:\n                            if line.endswith(\"]\"):\n                                listmode = False\n                                line = line.replace(\"]\", \"\")\n\n                            value += [\n                                self.cast(typ, x.strip()) for x in line.split(\",\") if x\n                            ]\n\n                            if not listmode:\n                                conf[section][option] = {\n                                    \"desc\": desc,\n                                    \"type\": typ,\n                                    \"value\": value,\n                                }\n\n                        else:\n                            m = self._CONFLINE.search(line)\n\n                            typ = m.group(\"T\")\n                            option = m.group(\"N\")\n                            desc = m.group(\"D\").strip()\n                            value = m.group(\"V\").strip()\n\n                            if value.startswith(\"[\"):\n                                if value.endswith(\"]\"):\n                                    listmode = False\n                                    value = value[:-1]\n                                else:\n                                    listmode = True\n\n                                value = [\n                                    self.cast(typ, x.strip())\n                                    for x in value[1:].split(\",\")\n                                    if x\n                                ]\n                            else:\n                                value = self.cast(typ, value)\n\n                            if not listmode:\n                                conf[section][option] = {\n                                    \"desc\": desc,\n                                    \"type\": typ,\n                                    \"value\": value,\n                                }\n\n                except Exception as exc:\n                    exc_logger.exception(exc)\n\n        return conf\n\n    def update_values(self, config, dest):\n        \"\"\"\n        sets the config values from a parsed config file to values in destination.\n        \"\"\"\n        for section in config.keys():\n            if section in dest:\n                for option in config[section].keys():\n                    if option in (\"desc\", \"outline\"):\n                        continue\n\n                    if option in dest[section]:\n                        dest[section][option][\"value\"] = config[section][option][\n                            \"value\"\n                        ]\n\n                        # else:\n                        #    dest[section][option] = config[section][option]\n\n                        # else:\n                        #    dest[section] = config[section]\n\n    def save_config(self, config, filename):\n        \"\"\"\n        saves config to filename.\n        \"\"\"\n        with open(filename, mode=\"w\") as fp:\n            os.chmod(filename, 0o600)\n            fp.write(f\"version: {__version__} \\n\")\n            for section in sorted(config.keys()):\n                fp.write(f'\\n{section} - \"{config[section][\"desc\"]}\":\\n')\n\n                for option, data in sorted(\n                    config[section].items(), key=lambda _x: _x[0]\n                ):\n                    if option in (\"desc\", \"outline\"):\n                        continue\n\n                    if isinstance(data[\"value\"], list):\n                        value = \"[ \\n\"\n                        for x in data[\"value\"]:\n                            value += f\"\\t\\t{x},\\n\"\n                        value += \"\\t\\t]\\n\"\n                    else:\n                        value = str(data[\"value\"]) + \"\\n\"\n\n                    fp.write(f'\\t{data[\"type\"]} {option} : \"{data[\"desc\"]}\" = {value}')\n\n    def cast(self, typ, value):\n        \"\"\"\n        cast value to given format.\n        \"\"\"\n        if typ == \"int\":\n            return int(value)\n\n        elif typ == \"float\":\n            return float(value)\n\n        elif typ == \"str\":\n            return \"\" if value is None else str(value)\n\n        elif typ == \"bytes\":\n            return b\"\" if value is None else bytes(value)\n\n        elif typ == \"bool\":\n            value = \"\" if value is None else str(value)\n            return value.lower() in (\"1\", \"true\", \"on\", \"yes\", \"y\")\n\n        elif typ == \"time\":\n            default_value = \"0:00\"\n            value = \"\" if value is None else str(value)\n            if not value:\n                value = default_value\n            elif \":\" not in value:\n                value += \":00\"\n\n            hours, seconds = value.split(\":\", 1)\n            if (\n                hours.isnumeric()\n                and seconds.isnumeric()\n                and 0 <= int(hours) <= 23\n                and 0 <= int(seconds) <= 59\n            ):\n                pass\n            else:\n                value = default_value\n\n            return value\n\n        elif typ in (\"file\", \"folder\"):\n            return (\n                \"\"\n                if value in (None, \"\")\n                else os.path.realpath(os.path.expanduser(os.fsdecode(value)))\n            )\n\n        else:\n            return value\n\n    def save(self):\n        \"\"\"\n        saves the configs to disk.\n        \"\"\"\n        self.save_config(self.config, self.configpath)\n        self.save_config(self.plugin, self.pluginpath)\n\n    def __getitem__(self, section):\n        \"\"\"\n        provides dictonary like access: c['section']['option']\n        \"\"\"\n        return Section(self, section)\n\n    def get(self, section, option):\n        \"\"\"\n        get value.\n        \"\"\"\n        return self.config[section][option][\"value\"]\n\n    def set(self, section, option, value):\n        \"\"\"\n        set value.\n        \"\"\"\n        value = self.cast(self.config[section][option][\"type\"], value)\n\n        self.config[section][option][\"value\"] = value\n        self.save()\n\n    def toggle(self, section, option):\n        self.set(section, option, self.get(section, option) ^ True)\n\n    def get_plugin(self, plugin, option):\n        \"\"\"\n        gets a value for a plugin.\n        \"\"\"\n        return self.plugin[plugin][option][\"value\"]\n\n    def set_plugin(self, plugin, option, value):\n        \"\"\"\n        sets a value for a plugin.\n        \"\"\"\n        value = self.cast(self.plugin[plugin][option][\"type\"], value)\n\n        # TODO: check if callable\n        if self.plugin_cb:\n            self.plugin_cb(plugin, option, value)\n\n        self.plugin[plugin][option][\"value\"] = value\n        self.save()\n\n    def get_meta_data(self, section, option):\n        \"\"\"\n        get all config data for an option.\n        \"\"\"\n        return self.config[section][option]\n\n    def add_plugin_config(self, name, config, outline=\"\"):\n        \"\"\"\n        adds config options with tuples (name, type, desc, default)\n        \"\"\"\n        conf = self.plugin.get(name, {\"desc\": name})\n        conf[\"outline\"] = outline\n\n        for item in config:\n            if item[0] in conf and item[1] == conf[item[0]][\"type\"]:\n                conf[item[0]][\"desc\"] = item[2]\n            else:\n                conf[item[0]] = {\n                    \"desc\": item[2],\n                    \"type\": item[1],\n                    \"value\": self.cast(item[1], item[3]),\n                }\n\n        values = [x[0] for x in config] + [\"desc\", \"outline\"]\n        # delete old values\n        self.plugin[name] = {k: v for k, v in conf.items() if k in values}\n\n    def delete_config(self, name):\n        \"\"\"\n        Removes a plugin config.\n        \"\"\"\n        if name in self.plugin:\n            del self.plugin[name]\n\n\nclass Section:\n    \"\"\"\n    provides dictionary like access for configparser.\n    \"\"\"\n\n    def __init__(self, parser, section):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.parser = parser\n        self.section = section\n\n    def __getitem__(self, item):\n        \"\"\"\n        getitem.\n        \"\"\"\n        return self.parser.get(self.section, item)\n\n    def __setitem__(self, item, value):\n        \"\"\"\n        setitem.\n        \"\"\"\n        self.parser.set(self.section, item, value)\n"], "filenames": ["src/pyload/core/config/parser.py"], "buggy_code_start_loc": [281], "buggy_code_end_loc": [291], "fixing_code_start_loc": [282], "fixing_code_end_loc": [308], "type": "CWE-20", "message": "Improper Input Validation in GitHub repository pyload/pyload prior to 0.5.0b3.dev40.", "other": {"cve": {"id": "CVE-2023-0434", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-22T01:15:10.183", "lastModified": "2023-01-30T17:35:02.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Input Validation in GitHub repository pyload/pyload prior to 0.5.0b3.dev40."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:H/UI:R/S:U/C:N/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.2, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.9", "matchCriteriaId": "71C7D7BA-743B-4C43-B77C-E6C1A6ACFE7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:0.5.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "3040B5C9-171B-40D9-83CB-CD529DC046ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:0.5.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "78FA70FC-0CFE-4E89-9274-1670E1204B61"}]}]}], "references": [{"url": "https://github.com/pyload/pyload/commit/a2b1eb1028f45ac58dea5f58593c1d3db2b4a104", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7d9332d8-6997-483b-9fb9-bcf2ae01dad4", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pyload/pyload/commit/a2b1eb1028f45ac58dea5f58593c1d3db2b4a104"}}