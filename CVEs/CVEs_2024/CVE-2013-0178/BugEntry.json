{"buggy_code": ["/* diskstore.c implements a very simple disk backed key-value store used\n * by Redis for the \"disk\" backend. This implementation uses the filesystem\n * to store key/value pairs. Every file represents a given key.\n *\n * The key path is calculated using the SHA1 of the key name. For instance\n * the key \"foo\" is stored as a file name called:\n *\n *  /0b/ee/0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\n *\n * The couples of characters from the hex output of SHA1 are also used\n * to locate two two levels of directories to store the file (as most\n * filesystems are not able to handle too many files in a single dir).\n *\n * In the end there are 65536 final directories (256 directories inside\n * every 256 top level directories), so that with 1 billion of files every\n * directory will contain in the average 15258 entires, that is ok with\n * most filesystems implementation.\n *\n * The actaul implementation of this disk store is highly related to the\n * filesystem implementation. This implementation may be replaced by\n * a B+TREE implementation in future implementations.\n *\n * Data ok every key is serialized using the same format used for .rdb\n * serialization. Everything is serialized on every entry: key name,\n * ttl information in case of keys with an associated expire time, and the\n * serialized value itself.\n *\n * Because the format is the same of the .rdb files it is trivial to create\n * an .rdb file starting from this format just by mean of scanning the\n * directories and concatenating entries, with the sole addition of an\n * .rdb header at the start and the end-of-db opcode at the end.\n *\n * -------------------------------------------------------------------------\n *\n * Copyright (c) 2010-2011, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"redis.h\"\n\n#include <fcntl.h>\n#include <sys/stat.h>\n\nint dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.diskstore_path;\n\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n\n    /* Directory already in place. Assume everything is ok. */\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n\n    /* File exists but it's not a directory */\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n\n    /* New disk store, create the directory structure now, as creating\n     * them in a lazy way is not a good idea, after very few insertions\n     * we'll need most of the 65536 directories anyway. */\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}\n\nint dsClose(void) {\n    return REDIS_OK;\n}\n\nint dsSet(redisDb *db, robj *key, robj *val) {\n}\n\nrobj *dsGet(redisDb *db, robj *key) {\n}\n\nint dsExists(redisDb *db, robj *key) {\n}\n", "#include \"redis.h\"\n#include <sys/uio.h>\n\nvoid *dupClientReplyValue(void *o) {\n    incrRefCount((robj*)o);\n    return o;\n}\n\nint listMatchObjects(void *a, void *b) {\n    return equalStringObjects(a,b);\n}\n\nredisClient *createClient(int fd) {\n    redisClient *c = zmalloc(sizeof(redisClient));\n    c->bufpos = 0;\n\n    anetNonBlock(NULL,fd);\n    anetTcpNoDelay(NULL,fd);\n    if (!c) return NULL;\n    if (aeCreateFileEvent(server.el,fd,AE_READABLE,\n        readQueryFromClient, c) == AE_ERR)\n    {\n        close(fd);\n        zfree(c);\n        return NULL;\n    }\n\n    selectDb(c,0);\n    c->fd = fd;\n    c->querybuf = sdsempty();\n    c->reqtype = 0;\n    c->argc = 0;\n    c->argv = NULL;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n    c->sentlen = 0;\n    c->flags = 0;\n    c->lastinteraction = time(NULL);\n    c->authenticated = 0;\n    c->replstate = REDIS_REPL_NONE;\n    c->reply = listCreate();\n    listSetFreeMethod(c->reply,decrRefCount);\n    listSetDupMethod(c->reply,dupClientReplyValue);\n    c->bpop.keys = NULL;\n    c->bpop.count = 0;\n    c->bpop.timeout = 0;\n    c->bpop.target = NULL;\n    c->io_keys = listCreate();\n    c->watched_keys = listCreate();\n    listSetFreeMethod(c->io_keys,decrRefCount);\n    c->pubsub_channels = dictCreate(&setDictType,NULL);\n    c->pubsub_patterns = listCreate();\n    listSetFreeMethod(c->pubsub_patterns,decrRefCount);\n    listSetMatchMethod(c->pubsub_patterns,listMatchObjects);\n    listAddNodeTail(server.clients,c);\n    initClientMultiState(c);\n    return c;\n}\n\n/* Set the event loop to listen for write events on the client's socket.\n * Typically gets called every time a reply is built. */\nint _installWriteEvent(redisClient *c) {\n    /* When CLOSE_AFTER_REPLY is set, no more replies may be added! */\n    redisAssert(!(c->flags & REDIS_CLOSE_AFTER_REPLY));\n\n    if (c->fd <= 0) return REDIS_ERR;\n    if (c->bufpos == 0 && listLength(c->reply) == 0 &&\n        (c->replstate == REDIS_REPL_NONE ||\n         c->replstate == REDIS_REPL_ONLINE) &&\n        aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,\n        sendReplyToClient, c) == AE_ERR) return REDIS_ERR;\n    return REDIS_OK;\n}\n\n/* Create a duplicate of the last object in the reply list when\n * it is not exclusively owned by the reply list. */\nrobj *dupLastObjectIfNeeded(list *reply) {\n    robj *new, *cur;\n    listNode *ln;\n    redisAssert(listLength(reply) > 0);\n    ln = listLast(reply);\n    cur = listNodeValue(ln);\n    if (cur->refcount > 1) {\n        new = dupStringObject(cur);\n        decrRefCount(cur);\n        listNodeValue(ln) = new;\n    }\n    return listNodeValue(ln);\n}\n\nint _addReplyToBuffer(redisClient *c, char *s, size_t len) {\n    size_t available = sizeof(c->buf)-c->bufpos;\n\n    /* If there already are entries in the reply list, we cannot\n     * add anything more to the static buffer. */\n    if (listLength(c->reply) > 0) return REDIS_ERR;\n\n    /* Check that the buffer has enough space available for this string. */\n    if (len > available) return REDIS_ERR;\n\n    memcpy(c->buf+c->bufpos,s,len);\n    c->bufpos+=len;\n    return REDIS_OK;\n}\n\nvoid _addReplyObjectToList(redisClient *c, robj *o) {\n    robj *tail;\n    if (listLength(c->reply) == 0) {\n        incrRefCount(o);\n        listAddNodeTail(c->reply,o);\n    } else {\n        tail = listNodeValue(listLast(c->reply));\n\n        /* Append to this object when possible. */\n        if (tail->ptr != NULL &&\n            sdslen(tail->ptr)+sdslen(o->ptr) <= REDIS_REPLY_CHUNK_BYTES)\n        {\n            tail = dupLastObjectIfNeeded(c->reply);\n            tail->ptr = sdscatlen(tail->ptr,o->ptr,sdslen(o->ptr));\n        } else {\n            incrRefCount(o);\n            listAddNodeTail(c->reply,o);\n        }\n    }\n}\n\n/* This method takes responsibility over the sds. When it is no longer\n * needed it will be free'd, otherwise it ends up in a robj. */\nvoid _addReplySdsToList(redisClient *c, sds s) {\n    robj *tail;\n    if (listLength(c->reply) == 0) {\n        listAddNodeTail(c->reply,createObject(REDIS_STRING,s));\n    } else {\n        tail = listNodeValue(listLast(c->reply));\n\n        /* Append to this object when possible. */\n        if (tail->ptr != NULL &&\n            sdslen(tail->ptr)+sdslen(s) <= REDIS_REPLY_CHUNK_BYTES)\n        {\n            tail = dupLastObjectIfNeeded(c->reply);\n            tail->ptr = sdscatlen(tail->ptr,s,sdslen(s));\n            sdsfree(s);\n        } else {\n            listAddNodeTail(c->reply,createObject(REDIS_STRING,s));\n        }\n    }\n}\n\nvoid _addReplyStringToList(redisClient *c, char *s, size_t len) {\n    robj *tail;\n    if (listLength(c->reply) == 0) {\n        listAddNodeTail(c->reply,createStringObject(s,len));\n    } else {\n        tail = listNodeValue(listLast(c->reply));\n\n        /* Append to this object when possible. */\n        if (tail->ptr != NULL &&\n            sdslen(tail->ptr)+len <= REDIS_REPLY_CHUNK_BYTES)\n        {\n            tail = dupLastObjectIfNeeded(c->reply);\n            tail->ptr = sdscatlen(tail->ptr,s,len);\n        } else {\n            listAddNodeTail(c->reply,createStringObject(s,len));\n        }\n    }\n}\n\nvoid addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);\n\n    /* This is an important place where we can avoid copy-on-write\n     * when there is a saving child running, avoiding touching the\n     * refcount field of the object if it's not needed.\n     *\n     * If the encoding is RAW and there is room in the static buffer\n     * we'll be able to send the object to the client without\n     * messing with its page. */\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        /* FIXME: convert the long into string and use _addReplyToBuffer()\n         * instead of calling getDecodedObject. As this place in the\n         * code is too performance critical. */\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}\n\nvoid addReplySds(redisClient *c, sds s) {\n    if (_installWriteEvent(c) != REDIS_OK) {\n        /* The caller expects the sds to be free'd. */\n        sdsfree(s);\n        return;\n    }\n    if (_addReplyToBuffer(c,s,sdslen(s)) == REDIS_OK) {\n        sdsfree(s);\n    } else {\n        /* This method free's the sds when it is no longer needed. */\n        _addReplySdsToList(c,s);\n    }\n}\n\nvoid addReplyString(redisClient *c, char *s, size_t len) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    if (_addReplyToBuffer(c,s,len) != REDIS_OK)\n        _addReplyStringToList(c,s,len);\n}\n\nvoid _addReplyError(redisClient *c, char *s, size_t len) {\n    addReplyString(c,\"-ERR \",5);\n    addReplyString(c,s,len);\n    addReplyString(c,\"\\r\\n\",2);\n}\n\nvoid addReplyError(redisClient *c, char *err) {\n    _addReplyError(c,err,strlen(err));\n}\n\nvoid addReplyErrorFormat(redisClient *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    _addReplyError(c,s,sdslen(s));\n    sdsfree(s);\n}\n\nvoid _addReplyStatus(redisClient *c, char *s, size_t len) {\n    addReplyString(c,\"+\",1);\n    addReplyString(c,s,len);\n    addReplyString(c,\"\\r\\n\",2);\n}\n\nvoid addReplyStatus(redisClient *c, char *status) {\n    _addReplyStatus(c,status,strlen(status));\n}\n\nvoid addReplyStatusFormat(redisClient *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    _addReplyStatus(c,s,sdslen(s));\n    sdsfree(s);\n}\n\n/* Adds an empty object to the reply list that will contain the multi bulk\n * length, which is not known when this function is called. */\nvoid *addDeferredMultiBulkLength(redisClient *c) {\n    /* Note that we install the write event here even if the object is not\n     * ready to be sent, since we are sure that before returning to the\n     * event loop setDeferredMultiBulkLength() will be called. */\n    if (_installWriteEvent(c) != REDIS_OK) return NULL;\n    listAddNodeTail(c->reply,createObject(REDIS_STRING,NULL));\n    return listLast(c->reply);\n}\n\n/* Populate the length object and try glueing it to the next chunk. */\nvoid setDeferredMultiBulkLength(redisClient *c, void *node, long length) {\n    listNode *ln = (listNode*)node;\n    robj *len, *next;\n\n    /* Abort when *node is NULL (see addDeferredMultiBulkLength). */\n    if (node == NULL) return;\n\n    len = listNodeValue(ln);\n    len->ptr = sdscatprintf(sdsempty(),\"*%ld\\r\\n\",length);\n    if (ln->next != NULL) {\n        next = listNodeValue(ln->next);\n\n        /* Only glue when the next node is non-NULL (an sds in this case) */\n        if (next->ptr != NULL) {\n            len->ptr = sdscatlen(len->ptr,next->ptr,sdslen(next->ptr));\n            listDelNode(c->reply,ln->next);\n        }\n    }\n}\n\n/* Add a duble as a bulk reply */\nvoid addReplyDouble(redisClient *c, double d) {\n    char dbuf[128], sbuf[128];\n    int dlen, slen;\n    dlen = snprintf(dbuf,sizeof(dbuf),\"%.17g\",d);\n    slen = snprintf(sbuf,sizeof(sbuf),\"$%d\\r\\n%s\\r\\n\",dlen,dbuf);\n    addReplyString(c,sbuf,slen);\n}\n\n/* Add a long long as integer reply or bulk len / multi bulk count.\n * Basically this is used to output <prefix><long long><crlf>. */\nvoid _addReplyLongLong(redisClient *c, long long ll, char prefix) {\n    char buf[128];\n    int len;\n    buf[0] = prefix;\n    len = ll2string(buf+1,sizeof(buf)-1,ll);\n    buf[len+1] = '\\r';\n    buf[len+2] = '\\n';\n    addReplyString(c,buf,len+3);\n}\n\nvoid addReplyLongLong(redisClient *c, long long ll) {\n    _addReplyLongLong(c,ll,':');\n}\n\nvoid addReplyMultiBulkLen(redisClient *c, long length) {\n    _addReplyLongLong(c,length,'*');\n}\n\n/* Create the length prefix of a bulk reply, example: $2234 */\nvoid addReplyBulkLen(redisClient *c, robj *obj) {\n    size_t len;\n\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        len = sdslen(obj->ptr);\n    } else {\n        long n = (long)obj->ptr;\n\n        /* Compute how many bytes will take this integer as a radix 10 string */\n        len = 1;\n        if (n < 0) {\n            len++;\n            n = -n;\n        }\n        while((n = n/10) != 0) {\n            len++;\n        }\n    }\n    _addReplyLongLong(c,len,'$');\n}\n\n/* Add a Redis Object as a bulk reply */\nvoid addReplyBulk(redisClient *c, robj *obj) {\n    addReplyBulkLen(c,obj);\n    addReply(c,obj);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C buffer as bulk reply */\nvoid addReplyBulkCBuffer(redisClient *c, void *p, size_t len) {\n    _addReplyLongLong(c,len,'$');\n    addReplyString(c,p,len);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C nul term string as bulk reply */\nvoid addReplyBulkCString(redisClient *c, char *s) {\n    if (s == NULL) {\n        addReply(c,shared.nullbulk);\n    } else {\n        addReplyBulkCBuffer(c,s,strlen(s));\n    }\n}\n\n/* Add a long long as a bulk reply */\nvoid addReplyBulkLongLong(redisClient *c, long long ll) {\n    char buf[64];\n    int len;\n\n    len = ll2string(buf,64,ll);\n    addReplyBulkCBuffer(c,buf,len);\n}\n\nstatic void acceptCommonHandler(int fd) {\n    redisClient *c;\n    if ((c = createClient(fd)) == NULL) {\n        redisLog(REDIS_WARNING,\"Error allocating resoures for the client\");\n        close(fd); /* May be already closed, just ingore errors */\n        return;\n    }\n    /* If maxclient directive is set and this is one client more... close the\n     * connection. Note that we create the client instead to check before\n     * for this condition, since now the socket is already set in nonblocking\n     * mode and we can send an error for free using the Kernel I/O */\n    if (server.maxclients && listLength(server.clients) > server.maxclients) {\n        char *err = \"-ERR max number of clients reached\\r\\n\";\n\n        /* That's a best effort error message, don't check write errors */\n        if (write(c->fd,err,strlen(err)) == -1) {\n            /* Nothing to do, Just to avoid the warning... */\n        }\n        freeClient(c);\n        return;\n    }\n    server.stat_numconnections++;\n}\n\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cport, cfd;\n    char cip[128];\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n    REDIS_NOTUSED(privdata);\n\n    cfd = anetTcpAccept(server.neterr, fd, cip, &cport);\n    if (cfd == AE_ERR) {\n        redisLog(REDIS_VERBOSE,\"Accepting client connection: %s\", server.neterr);\n        return;\n    }\n    redisLog(REDIS_VERBOSE,\"Accepted %s:%d\", cip, cport);\n    acceptCommonHandler(cfd);\n}\n\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cfd;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n    REDIS_NOTUSED(privdata);\n\n    cfd = anetUnixAccept(server.neterr, fd);\n    if (cfd == AE_ERR) {\n        redisLog(REDIS_VERBOSE,\"Accepting client connection: %s\", server.neterr);\n        return;\n    }\n    redisLog(REDIS_VERBOSE,\"Accepted connection to %s\", server.unixsocket);\n    acceptCommonHandler(cfd);\n}\n\n\nstatic void freeClientArgv(redisClient *c) {\n    int j;\n    for (j = 0; j < c->argc; j++)\n        decrRefCount(c->argv[j]);\n    c->argc = 0;\n}\n\nvoid freeClient(redisClient *c) {\n    listNode *ln;\n\n    /* Note that if the client we are freeing is blocked into a blocking\n     * call, we have to set querybuf to NULL *before* to call\n     * unblockClientWaitingData() to avoid processInputBuffer() will get\n     * called. Also it is important to remove the file events after\n     * this, because this call adds the READABLE event. */\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n\n    /* UNWATCH all the keys */\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    /* Unsubscribe from all the pubsub channels */\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    /* Obvious cleanup */\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    /* Remove from the list of clients */\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    /* Remove from the list of clients waiting for swapped keys, or ready\n     * to be restarted, but not yet woken up again. */\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.vm_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n\n            /* When this client is waiting to be woken up (REDIS_IO_WAIT),\n             * it should be present in the list io_ready_clients */\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.vm_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    /* Master/slave cleanup.\n     * Case 1: we lost the connection with a slave. */\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n\n    /* Case 2: we lost the connection with the master. */\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        /* FIXME */\n        server.replstate = REDIS_REPL_CONNECT;\n        /* Since we lost the connection with the master, we should also\n         * close the connection with all our slaves if we have any, so\n         * when we'll resync with the master the other slaves will sync again\n         * with us as well. Note that also when the slave is not connected\n         * to the master it will keep refusing connections by other slaves. */\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    /* Release memory */\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}\n\nvoid sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {\n    redisClient *c = privdata;\n    int nwritten = 0, totwritten = 0, objlen;\n    robj *o;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n\n    /* Use writev() if we have enough buffers to send */\n    if (!server.glueoutputbuf &&\n        listLength(c->reply) > REDIS_WRITEV_THRESHOLD &&\n        !(c->flags & REDIS_MASTER))\n    {\n        sendReplyToClientWritev(el, fd, privdata, mask);\n        return;\n    }\n\n    while(c->bufpos > 0 || listLength(c->reply)) {\n        if (c->bufpos > 0) {\n            if (c->flags & REDIS_MASTER) {\n                /* Don't reply to a master */\n                nwritten = c->bufpos - c->sentlen;\n            } else {\n                nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);\n                if (nwritten <= 0) break;\n            }\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If the buffer was sent, set bufpos to zero to continue with\n             * the remainder of the reply. */\n            if (c->sentlen == c->bufpos) {\n                c->bufpos = 0;\n                c->sentlen = 0;\n            }\n        } else {\n            o = listNodeValue(listFirst(c->reply));\n            objlen = sdslen(o->ptr);\n\n            if (objlen == 0) {\n                listDelNode(c->reply,listFirst(c->reply));\n                continue;\n            }\n\n            if (c->flags & REDIS_MASTER) {\n                /* Don't reply to a master */\n                nwritten = objlen - c->sentlen;\n            } else {\n                nwritten = write(fd, ((char*)o->ptr)+c->sentlen,objlen-c->sentlen);\n                if (nwritten <= 0) break;\n            }\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If we fully sent the object on head go to the next one */\n            if (c->sentlen == objlen) {\n                listDelNode(c->reply,listFirst(c->reply));\n                c->sentlen = 0;\n            }\n        }\n        /* Note that we avoid to send more thank REDIS_MAX_WRITE_PER_EVENT\n         * bytes, in a single threaded server it's a good idea to serve\n         * other clients as well, even if a very large request comes from\n         * super fast link that is always able to accept data (in real world\n         * scenario think about 'KEYS *' against the loopback interfae) */\n        if (totwritten > REDIS_MAX_WRITE_PER_EVENT) break;\n    }\n    if (nwritten == -1) {\n        if (errno == EAGAIN) {\n            nwritten = 0;\n        } else {\n            redisLog(REDIS_VERBOSE,\n                \"Error writing to client: %s\", strerror(errno));\n            freeClient(c);\n            return;\n        }\n    }\n    if (totwritten > 0) c->lastinteraction = time(NULL);\n    if (listLength(c->reply) == 0) {\n        c->sentlen = 0;\n        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n\n        /* Close connection after entire reply has been sent. */\n        if (c->flags & REDIS_CLOSE_AFTER_REPLY) freeClient(c);\n    }\n}\n\nvoid sendReplyToClientWritev(aeEventLoop *el, int fd, void *privdata, int mask)\n{\n    redisClient *c = privdata;\n    int nwritten = 0, totwritten = 0, objlen, willwrite;\n    robj *o;\n    struct iovec iov[REDIS_WRITEV_IOVEC_COUNT];\n    int offset, ion = 0;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n\n    listNode *node;\n    while (listLength(c->reply)) {\n        offset = c->sentlen;\n        ion = 0;\n        willwrite = 0;\n\n        /* fill-in the iov[] array */\n        for(node = listFirst(c->reply); node; node = listNextNode(node)) {\n            o = listNodeValue(node);\n            objlen = sdslen(o->ptr);\n\n            if (totwritten + objlen - offset > REDIS_MAX_WRITE_PER_EVENT)\n                break;\n\n            if(ion == REDIS_WRITEV_IOVEC_COUNT)\n                break; /* no more iovecs */\n\n            iov[ion].iov_base = ((char*)o->ptr) + offset;\n            iov[ion].iov_len = objlen - offset;\n            willwrite += objlen - offset;\n            offset = 0; /* just for the first item */\n            ion++;\n        }\n\n        if(willwrite == 0)\n            break;\n\n        /* write all collected blocks at once */\n        if((nwritten = writev(fd, iov, ion)) < 0) {\n            if (errno != EAGAIN) {\n                redisLog(REDIS_VERBOSE,\n                         \"Error writing to client: %s\", strerror(errno));\n                freeClient(c);\n                return;\n            }\n            break;\n        }\n\n        totwritten += nwritten;\n        offset = c->sentlen;\n\n        /* remove written robjs from c->reply */\n        while (nwritten && listLength(c->reply)) {\n            o = listNodeValue(listFirst(c->reply));\n            objlen = sdslen(o->ptr);\n\n            if(nwritten >= objlen - offset) {\n                listDelNode(c->reply, listFirst(c->reply));\n                nwritten -= objlen - offset;\n                c->sentlen = 0;\n            } else {\n                /* partial write */\n                c->sentlen += nwritten;\n                break;\n            }\n            offset = 0;\n        }\n    }\n\n    if (totwritten > 0)\n        c->lastinteraction = time(NULL);\n\n    if (listLength(c->reply) == 0) {\n        c->sentlen = 0;\n        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    }\n}\n\n/* resetClient prepare the client to process the next command */\nvoid resetClient(redisClient *c) {\n    freeClientArgv(c);\n    c->reqtype = 0;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n}\n\nvoid closeTimedoutClients(void) {\n    redisClient *c;\n    listNode *ln;\n    time_t now = time(NULL);\n    listIter li;\n\n    listRewind(server.clients,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        c = listNodeValue(ln);\n        if (server.maxidletime &&\n            !(c->flags & REDIS_SLAVE) &&    /* no timeout for slaves */\n            !(c->flags & REDIS_MASTER) &&   /* no timeout for masters */\n            !(c->flags & REDIS_BLOCKED) &&  /* no timeout for BLPOP */\n            dictSize(c->pubsub_channels) == 0 && /* no timeout for pubsub */\n            listLength(c->pubsub_patterns) == 0 &&\n            (now - c->lastinteraction > server.maxidletime))\n        {\n            redisLog(REDIS_VERBOSE,\"Closing idle client\");\n            freeClient(c);\n        } else if (c->flags & REDIS_BLOCKED) {\n            if (c->bpop.timeout != 0 && c->bpop.timeout < now) {\n                addReply(c,shared.nullmultibulk);\n                unblockClientWaitingData(c);\n            }\n        }\n    }\n}\n\nint processInlineBuffer(redisClient *c) {\n    char *newline = strstr(c->querybuf,\"\\r\\n\");\n    int argc, j;\n    sds *argv;\n    size_t querylen;\n\n    /* Nothing to do without a \\r\\n */\n    if (newline == NULL)\n        return REDIS_ERR;\n\n    /* Split the input buffer up to the \\r\\n */\n    querylen = newline-(c->querybuf);\n    argv = sdssplitlen(c->querybuf,querylen,\" \",1,&argc);\n\n    /* Leave data after the first line of the query in the buffer */\n    c->querybuf = sdsrange(c->querybuf,querylen+2,-1);\n\n    /* Setup argv array on client structure */\n    if (c->argv) zfree(c->argv);\n    c->argv = zmalloc(sizeof(robj*)*argc);\n\n    /* Create redis objects for all arguments. */\n    for (c->argc = 0, j = 0; j < argc; j++) {\n        if (sdslen(argv[j])) {\n            c->argv[c->argc] = createObject(REDIS_STRING,argv[j]);\n            c->argc++;\n        } else {\n            sdsfree(argv[j]);\n        }\n    }\n    zfree(argv);\n    return REDIS_OK;\n}\n\n/* Helper function. Trims query buffer to make the function that processes\n * multi bulk requests idempotent. */\nstatic void setProtocolError(redisClient *c, int pos) {\n    c->flags |= REDIS_CLOSE_AFTER_REPLY;\n    c->querybuf = sdsrange(c->querybuf,pos,-1);\n}\n\nint processMultibulkBuffer(redisClient *c) {\n    char *newline = NULL;\n    char *eptr;\n    int pos = 0, tolerr;\n    long bulklen;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        redisAssert(c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strstr(c->querybuf,\"\\r\\n\");\n        if (newline == NULL)\n            return REDIS_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        redisAssert(c->querybuf[0] == '*');\n        c->multibulklen = strtol(c->querybuf+1,&eptr,10);\n        pos = (newline-c->querybuf)+2;\n        if (c->multibulklen <= 0) {\n            c->querybuf = sdsrange(c->querybuf,pos,-1);\n            return REDIS_OK;\n        } else if (c->multibulklen > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(c,pos);\n            return REDIS_ERR;\n        }\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n\n        /* Search new newline */\n        newline = strstr(c->querybuf+pos,\"\\r\\n\");\n    }\n\n    redisAssert(c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strstr(c->querybuf+pos,\"\\r\\n\");\n            if (newline != NULL) {\n                if (c->querybuf[pos] != '$') {\n                    addReplyErrorFormat(c,\n                        \"Protocol error: expected '$', got '%c'\",\n                        c->querybuf[pos]);\n                    setProtocolError(c,pos);\n                    return REDIS_ERR;\n                }\n\n                bulklen = strtol(c->querybuf+pos+1,&eptr,10);\n                tolerr = (eptr[0] != '\\r');\n                if (tolerr || bulklen == LONG_MIN || bulklen == LONG_MAX ||\n                    bulklen < 0 || bulklen > 512*1024*1024)\n                {\n                    addReplyError(c,\"Protocol error: invalid bulk length\");\n                    setProtocolError(c,pos);\n                    return REDIS_ERR;\n                }\n                pos += eptr-(c->querybuf+pos)+2;\n                c->bulklen = bulklen;\n            } else {\n                /* No newline in current buffer, so wait for more data */\n                break;\n            }\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-pos < (unsigned)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            c->argv[c->argc++] = createStringObject(c->querybuf+pos,c->bulklen);\n            pos += c->bulklen+2;\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* Trim to pos */\n    c->querybuf = sdsrange(c->querybuf,pos,-1);\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) {\n        return REDIS_OK;\n    }\n    return REDIS_ERR;\n}\n\nvoid processInputBuffer(redisClient *c) {\n    /* Keep processing while there is something in the input buffer */\n    while(sdslen(c->querybuf)) {\n        /* Immediately abort if the client is in the middle of something. */\n        if (c->flags & REDIS_BLOCKED || c->flags & REDIS_IO_WAIT) return;\n\n        /* REDIS_CLOSE_AFTER_REPLY closes the connection once the reply is\n         * written to the client. Make sure to not let the reply grow after\n         * this flag has been set (i.e. don't process more commands). */\n        if (c->flags & REDIS_CLOSE_AFTER_REPLY) return;\n\n        /* Determine request type when unknown. */\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = REDIS_REQ_MULTIBULK;\n            } else {\n                c->reqtype = REDIS_REQ_INLINE;\n            }\n        }\n\n        if (c->reqtype == REDIS_REQ_INLINE) {\n            if (processInlineBuffer(c) != REDIS_OK) break;\n        } else if (c->reqtype == REDIS_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != REDIS_OK) break;\n        } else {\n            redisPanic(\"Unknown request type\");\n        }\n\n        /* Multibulk processing could see a <= 0 length. */\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            /* Only reset the client when the command was executed. */\n            if (processCommand(c) == REDIS_OK)\n                resetClient(c);\n        }\n    }\n}\n\nvoid readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {\n    redisClient *c = (redisClient*) privdata;\n    char buf[REDIS_IOBUF_LEN];\n    int nread;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n\n    nread = read(fd, buf, REDIS_IOBUF_LEN);\n    if (nread == -1) {\n        if (errno == EAGAIN) {\n            nread = 0;\n        } else {\n            redisLog(REDIS_VERBOSE, \"Reading from client: %s\",strerror(errno));\n            freeClient(c);\n            return;\n        }\n    } else if (nread == 0) {\n        redisLog(REDIS_VERBOSE, \"Client closed connection\");\n        freeClient(c);\n        return;\n    }\n    if (nread) {\n        c->querybuf = sdscatlen(c->querybuf,buf,nread);\n        c->lastinteraction = time(NULL);\n    } else {\n        return;\n    }\n    processInputBuffer(c);\n}\n", "/*\n * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"redis.h\"\n\n#ifdef HAVE_BACKTRACE\n#include <execinfo.h>\n#include <ucontext.h>\n#endif /* HAVE_BACKTRACE */\n\n#include <time.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <pthread.h>\n#include <sys/resource.h>\n\n/* Our shared \"common\" objects */\n\nstruct sharedObjectsStruct shared;\n\n/* Global vars that are actally used as constants. The following double\n * values are used for double on-disk serialization, and are initialized\n * at runtime to avoid strange compiler optimizations. */\n\ndouble R_Zero, R_PosInf, R_NegInf, R_Nan;\n\n/*================================= Globals ================================= */\n\n/* Global vars */\nstruct redisServer server; /* server global state */\nstruct redisCommand *commandTable;\nstruct redisCommand readonlyCommandTable[] = {\n    {\"get\",getCommand,2,0,NULL,1,1,1},\n    {\"set\",setCommand,3,REDIS_CMD_DENYOOM,NULL,0,0,0},\n    {\"setnx\",setnxCommand,3,REDIS_CMD_DENYOOM,NULL,0,0,0},\n    {\"setex\",setexCommand,4,REDIS_CMD_DENYOOM,NULL,0,0,0},\n    {\"append\",appendCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"strlen\",strlenCommand,2,0,NULL,1,1,1},\n    {\"del\",delCommand,-2,0,NULL,0,0,0},\n    {\"exists\",existsCommand,2,0,NULL,1,1,1},\n    {\"setbit\",setbitCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"getbit\",getbitCommand,3,0,NULL,1,1,1},\n    {\"setrange\",setrangeCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"getrange\",getrangeCommand,4,0,NULL,1,1,1},\n    {\"substr\",getrangeCommand,4,0,NULL,1,1,1},\n    {\"incr\",incrCommand,2,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"decr\",decrCommand,2,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"mget\",mgetCommand,-2,0,NULL,1,-1,1},\n    {\"rpush\",rpushCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"lpush\",lpushCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"rpushx\",rpushxCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"lpushx\",lpushxCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"linsert\",linsertCommand,5,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"rpop\",rpopCommand,2,0,NULL,1,1,1},\n    {\"lpop\",lpopCommand,2,0,NULL,1,1,1},\n    {\"brpop\",brpopCommand,-3,0,NULL,1,1,1},\n    {\"brpoplpush\",brpoplpushCommand,4,REDIS_CMD_DENYOOM,NULL,1,2,1},\n    {\"blpop\",blpopCommand,-3,0,NULL,1,1,1},\n    {\"llen\",llenCommand,2,0,NULL,1,1,1},\n    {\"lindex\",lindexCommand,3,0,NULL,1,1,1},\n    {\"lset\",lsetCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"lrange\",lrangeCommand,4,0,NULL,1,1,1},\n    {\"ltrim\",ltrimCommand,4,0,NULL,1,1,1},\n    {\"lrem\",lremCommand,4,0,NULL,1,1,1},\n    {\"rpoplpush\",rpoplpushCommand,3,REDIS_CMD_DENYOOM,NULL,1,2,1},\n    {\"sadd\",saddCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"srem\",sremCommand,3,0,NULL,1,1,1},\n    {\"smove\",smoveCommand,4,0,NULL,1,2,1},\n    {\"sismember\",sismemberCommand,3,0,NULL,1,1,1},\n    {\"scard\",scardCommand,2,0,NULL,1,1,1},\n    {\"spop\",spopCommand,2,0,NULL,1,1,1},\n    {\"srandmember\",srandmemberCommand,2,0,NULL,1,1,1},\n    {\"sinter\",sinterCommand,-2,REDIS_CMD_DENYOOM,NULL,1,-1,1},\n    {\"sinterstore\",sinterstoreCommand,-3,REDIS_CMD_DENYOOM,NULL,2,-1,1},\n    {\"sunion\",sunionCommand,-2,REDIS_CMD_DENYOOM,NULL,1,-1,1},\n    {\"sunionstore\",sunionstoreCommand,-3,REDIS_CMD_DENYOOM,NULL,2,-1,1},\n    {\"sdiff\",sdiffCommand,-2,REDIS_CMD_DENYOOM,NULL,1,-1,1},\n    {\"sdiffstore\",sdiffstoreCommand,-3,REDIS_CMD_DENYOOM,NULL,2,-1,1},\n    {\"smembers\",sinterCommand,2,0,NULL,1,1,1},\n    {\"zadd\",zaddCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"zincrby\",zincrbyCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"zrem\",zremCommand,3,0,NULL,1,1,1},\n    {\"zremrangebyscore\",zremrangebyscoreCommand,4,0,NULL,1,1,1},\n    {\"zremrangebyrank\",zremrangebyrankCommand,4,0,NULL,1,1,1},\n    {\"zunionstore\",zunionstoreCommand,-4,REDIS_CMD_DENYOOM,zunionInterBlockClientOnSwappedKeys,0,0,0},\n    {\"zinterstore\",zinterstoreCommand,-4,REDIS_CMD_DENYOOM,zunionInterBlockClientOnSwappedKeys,0,0,0},\n    {\"zrange\",zrangeCommand,-4,0,NULL,1,1,1},\n    {\"zrangebyscore\",zrangebyscoreCommand,-4,0,NULL,1,1,1},\n    {\"zrevrangebyscore\",zrevrangebyscoreCommand,-4,0,NULL,1,1,1},\n    {\"zcount\",zcountCommand,4,0,NULL,1,1,1},\n    {\"zrevrange\",zrevrangeCommand,-4,0,NULL,1,1,1},\n    {\"zcard\",zcardCommand,2,0,NULL,1,1,1},\n    {\"zscore\",zscoreCommand,3,0,NULL,1,1,1},\n    {\"zrank\",zrankCommand,3,0,NULL,1,1,1},\n    {\"zrevrank\",zrevrankCommand,3,0,NULL,1,1,1},\n    {\"hset\",hsetCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hsetnx\",hsetnxCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hget\",hgetCommand,3,0,NULL,1,1,1},\n    {\"hmset\",hmsetCommand,-4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hmget\",hmgetCommand,-3,0,NULL,1,1,1},\n    {\"hincrby\",hincrbyCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hdel\",hdelCommand,3,0,NULL,1,1,1},\n    {\"hlen\",hlenCommand,2,0,NULL,1,1,1},\n    {\"hkeys\",hkeysCommand,2,0,NULL,1,1,1},\n    {\"hvals\",hvalsCommand,2,0,NULL,1,1,1},\n    {\"hgetall\",hgetallCommand,2,0,NULL,1,1,1},\n    {\"hexists\",hexistsCommand,3,0,NULL,1,1,1},\n    {\"incrby\",incrbyCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"decrby\",decrbyCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"getset\",getsetCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"mset\",msetCommand,-3,REDIS_CMD_DENYOOM,NULL,1,-1,2},\n    {\"msetnx\",msetnxCommand,-3,REDIS_CMD_DENYOOM,NULL,1,-1,2},\n    {\"randomkey\",randomkeyCommand,1,0,NULL,0,0,0},\n    {\"select\",selectCommand,2,0,NULL,0,0,0},\n    {\"move\",moveCommand,3,0,NULL,1,1,1},\n    {\"rename\",renameCommand,3,0,NULL,1,1,1},\n    {\"renamenx\",renamenxCommand,3,0,NULL,1,1,1},\n    {\"expire\",expireCommand,3,0,NULL,0,0,0},\n    {\"expireat\",expireatCommand,3,0,NULL,0,0,0},\n    {\"keys\",keysCommand,2,0,NULL,0,0,0},\n    {\"dbsize\",dbsizeCommand,1,0,NULL,0,0,0},\n    {\"auth\",authCommand,2,0,NULL,0,0,0},\n    {\"ping\",pingCommand,1,0,NULL,0,0,0},\n    {\"echo\",echoCommand,2,0,NULL,0,0,0},\n    {\"save\",saveCommand,1,0,NULL,0,0,0},\n    {\"bgsave\",bgsaveCommand,1,0,NULL,0,0,0},\n    {\"bgrewriteaof\",bgrewriteaofCommand,1,0,NULL,0,0,0},\n    {\"shutdown\",shutdownCommand,1,0,NULL,0,0,0},\n    {\"lastsave\",lastsaveCommand,1,0,NULL,0,0,0},\n    {\"type\",typeCommand,2,0,NULL,1,1,1},\n    {\"multi\",multiCommand,1,0,NULL,0,0,0},\n    {\"exec\",execCommand,1,REDIS_CMD_DENYOOM,execBlockClientOnSwappedKeys,0,0,0},\n    {\"discard\",discardCommand,1,0,NULL,0,0,0},\n    {\"sync\",syncCommand,1,0,NULL,0,0,0},\n    {\"flushdb\",flushdbCommand,1,0,NULL,0,0,0},\n    {\"flushall\",flushallCommand,1,0,NULL,0,0,0},\n    {\"sort\",sortCommand,-2,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"info\",infoCommand,1,0,NULL,0,0,0},\n    {\"monitor\",monitorCommand,1,0,NULL,0,0,0},\n    {\"ttl\",ttlCommand,2,0,NULL,1,1,1},\n    {\"persist\",persistCommand,2,0,NULL,1,1,1},\n    {\"slaveof\",slaveofCommand,3,0,NULL,0,0,0},\n    {\"debug\",debugCommand,-2,0,NULL,0,0,0},\n    {\"config\",configCommand,-2,0,NULL,0,0,0},\n    {\"subscribe\",subscribeCommand,-2,0,NULL,0,0,0},\n    {\"unsubscribe\",unsubscribeCommand,-1,0,NULL,0,0,0},\n    {\"psubscribe\",psubscribeCommand,-2,0,NULL,0,0,0},\n    {\"punsubscribe\",punsubscribeCommand,-1,0,NULL,0,0,0},\n    {\"publish\",publishCommand,3,REDIS_CMD_FORCE_REPLICATION,NULL,0,0,0},\n    {\"watch\",watchCommand,-2,0,NULL,0,0,0},\n    {\"unwatch\",unwatchCommand,1,0,NULL,0,0,0}\n};\n\n/*============================ Utility functions ============================ */\n\nvoid redisLog(int level, const char *fmt, ...) {\n    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };\n    const char *c = \".-*#\";\n    time_t now = time(NULL);\n    va_list ap;\n    FILE *fp;\n    char buf[64];\n    char msg[REDIS_MAX_LOGMSG_LEN];\n\n    if (level < server.verbosity) return;\n\n    fp = (server.logfile == NULL) ? stdout : fopen(server.logfile,\"a\");\n    if (!fp) return;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    strftime(buf,sizeof(buf),\"%d %b %H:%M:%S\",localtime(&now));\n    fprintf(fp,\"[%d] %s %c %s\\n\",(int)getpid(),buf,c[level],msg);\n    fflush(fp);\n\n    if (server.logfile) fclose(fp);\n\n    if (server.syslog_enabled) syslog(syslogLevelMap[level], \"%s\", msg);\n}\n\n/* Redis generally does not try to recover from out of memory conditions\n * when allocating objects or strings, it is not clear if it will be possible\n * to report this condition to the client since the networking layer itself\n * is based on heap allocation for send buffers, so we simply abort.\n * At least the code will be simpler to read... */\nvoid oom(const char *msg) {\n    redisLog(REDIS_WARNING, \"%s: Out of memory\\n\",msg);\n    sleep(1);\n    abort();\n}\n\n/*====================== Hash table type implementation  ==================== */\n\n/* This is an hash table type that uses the SDS dynamic strings libary as\n * keys and radis objects as values (objects can hold SDS strings,\n * lists, sets). */\n\nvoid dictVanillaFree(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    zfree(val);\n}\n\nvoid dictListDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    listRelease((list*)val);\n}\n\nint dictSdsKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    int l1,l2;\n    DICT_NOTUSED(privdata);\n\n    l1 = sdslen((sds)key1);\n    l2 = sdslen((sds)key2);\n    if (l1 != l2) return 0;\n    return memcmp(key1, key2, l1) == 0;\n}\n\n/* A case insensitive version used for the command lookup table. */\nint dictSdsKeyCaseCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    DICT_NOTUSED(privdata);\n\n    return strcasecmp(key1, key2) == 0;\n}\n\nvoid dictRedisObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Values of swapped out keys as set to NULL */\n    decrRefCount(val);\n}\n\nvoid dictSdsDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    sdsfree(val);\n}\n\nint dictObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    const robj *o1 = key1, *o2 = key2;\n    return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n}\n\nunsigned int dictObjHash(const void *key) {\n    const robj *o = key;\n    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n}\n\nunsigned int dictSdsHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nunsigned int dictSdsCaseHash(const void *key) {\n    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nint dictEncObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    robj *o1 = (robj*) key1, *o2 = (robj*) key2;\n    int cmp;\n\n    if (o1->encoding == REDIS_ENCODING_INT &&\n        o2->encoding == REDIS_ENCODING_INT)\n            return o1->ptr == o2->ptr;\n\n    o1 = getDecodedObject(o1);\n    o2 = getDecodedObject(o2);\n    cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n    decrRefCount(o1);\n    decrRefCount(o2);\n    return cmp;\n}\n\nunsigned int dictEncObjHash(const void *key) {\n    robj *o = (robj*) key;\n\n    if (o->encoding == REDIS_ENCODING_RAW) {\n        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n    } else {\n        if (o->encoding == REDIS_ENCODING_INT) {\n            char buf[32];\n            int len;\n\n            len = ll2string(buf,32,(long)o->ptr);\n            return dictGenHashFunction((unsigned char*)buf, len);\n        } else {\n            unsigned int hash;\n\n            o = getDecodedObject(o);\n            hash = dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n            decrRefCount(o);\n            return hash;\n        }\n    }\n}\n\n/* Sets type */\ndictType setDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictRedisObjectDestructor, /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */\ndictType zsetDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictRedisObjectDestructor, /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Db->dict, keys are sds strings, vals are Redis objects. */\ndictType dbDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictRedisObjectDestructor   /* val destructor */\n};\n\n/* Db->expires */\ndictType keyptrDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Command table. sds string -> command struct pointer. */\ndictType commandTableDictType = {\n    dictSdsCaseHash,           /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCaseCompare,     /* key compare */\n    dictSdsDestructor,         /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Hash type hash table (note that small hashes are represented with zimpaps) */\ndictType hashDictType = {\n    dictEncObjHash,             /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictEncObjKeyCompare,       /* key compare */\n    dictRedisObjectDestructor,  /* key destructor */\n    dictRedisObjectDestructor   /* val destructor */\n};\n\n/* Keylist hash table type has unencoded redis objects as keys and\n * lists as values. It's used for blocking operations (BLPOP) and to\n * map swapped keys to a list of clients waiting for this keys to be loaded. */\ndictType keylistDictType = {\n    dictObjHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictObjKeyCompare,          /* key compare */\n    dictRedisObjectDestructor,  /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\nint htNeedsResize(dict *dict) {\n    long long size, used;\n\n    size = dictSlots(dict);\n    used = dictSize(dict);\n    return (size && used && size > DICT_HT_INITIAL_SIZE &&\n            (used*100/size < REDIS_HT_MINFILL));\n}\n\n/* If the percentage of used slots in the HT reaches REDIS_HT_MINFILL\n * we resize the hash table to save memory */\nvoid tryResizeHashTables(void) {\n    int j;\n\n    for (j = 0; j < server.dbnum; j++) {\n        if (htNeedsResize(server.db[j].dict))\n            dictResize(server.db[j].dict);\n        if (htNeedsResize(server.db[j].expires))\n            dictResize(server.db[j].expires);\n    }\n}\n\n/* Our hash table implementation performs rehashing incrementally while\n * we write/read from the hash table. Still if the server is idle, the hash\n * table will use two tables for a long time. So we try to use 1 millisecond\n * of CPU time at every serverCron() loop in order to rehash some key. */\nvoid incrementallyRehash(void) {\n    int j;\n\n    for (j = 0; j < server.dbnum; j++) {\n        if (dictIsRehashing(server.db[j].dict)) {\n            dictRehashMilliseconds(server.db[j].dict,1);\n            break; /* already used our millisecond for this loop... */\n        }\n    }\n}\n\n/* This function is called once a background process of some kind terminates,\n * as we want to avoid resizing the hash tables when there is a child in order\n * to play well with copy-on-write (otherwise when a resize happens lots of\n * memory pages are copied). The goal of this function is to update the ability\n * for dict.c to resize the hash tables accordingly to the fact we have o not\n * running childs. */\nvoid updateDictResizePolicy(void) {\n    if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1)\n        dictEnableResize();\n    else\n        dictDisableResize();\n}\n\n/* ======================= Cron: called every 100 ms ======================== */\n\n/* Try to expire a few timed out keys. The algorithm used is adaptive and\n * will use few CPU cycles if there are few expiring keys, otherwise\n * it will get more aggressive to avoid that too much memory is used by\n * keys that can be removed from the keyspace. */\nvoid activeExpireCycle(void) {\n    int j;\n\n    for (j = 0; j < server.dbnum; j++) {\n        int expired;\n        redisDb *db = server.db+j;\n\n        /* Continue to expire if at the end of the cycle more than 25%\n         * of the keys were expired. */\n        do {\n            long num = dictSize(db->expires);\n            time_t now = time(NULL);\n\n            expired = 0;\n            if (num > REDIS_EXPIRELOOKUPS_PER_CRON)\n                num = REDIS_EXPIRELOOKUPS_PER_CRON;\n            while (num--) {\n                dictEntry *de;\n                time_t t;\n\n                if ((de = dictGetRandomKey(db->expires)) == NULL) break;\n                t = (time_t) dictGetEntryVal(de);\n                if (now > t) {\n                    sds key = dictGetEntryKey(de);\n                    robj *keyobj = createStringObject(key,sdslen(key));\n\n                    propagateExpire(db,keyobj);\n                    dbDelete(db,keyobj);\n                    decrRefCount(keyobj);\n                    expired++;\n                    server.stat_expiredkeys++;\n                }\n            }\n        } while (expired > REDIS_EXPIRELOOKUPS_PER_CRON/4);\n    }\n}\n\nvoid updateLRUClock(void) {\n    server.lruclock = (time(NULL)/REDIS_LRU_CLOCK_RESOLUTION) &\n                                                REDIS_LRU_CLOCK_MAX;\n}\n\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    int j, loops = server.cronloops++;\n    REDIS_NOTUSED(eventLoop);\n    REDIS_NOTUSED(id);\n    REDIS_NOTUSED(clientData);\n\n    /* We take a cached value of the unix time in the global state because\n     * with virtual memory and aging there is to store the current time\n     * in objects at every object access, and accuracy is not needed.\n     * To access a global var is faster than calling time(NULL) */\n    server.unixtime = time(NULL);\n    /* We have just 22 bits per object for LRU information.\n     * So we use an (eventually wrapping) LRU clock with 10 seconds resolution.\n     * 2^22 bits with 10 seconds resoluton is more or less 1.5 years.\n     *\n     * Note that even if this will wrap after 1.5 years it's not a problem,\n     * everything will still work but just some object will appear younger\n     * to Redis. But for this to happen a given object should never be touched\n     * for 1.5 years.\n     *\n     * Note that you can change the resolution altering the\n     * REDIS_LRU_CLOCK_RESOLUTION define.\n     */\n    updateLRUClock();\n\n    /* We received a SIGTERM, shutting down here in a safe way, as it is\n     * not ok doing so inside the signal handler. */\n    if (server.shutdown_asap) {\n        if (prepareForShutdown() == REDIS_OK) exit(0);\n        redisLog(REDIS_WARNING,\"SIGTERM received but errors trying to shut down the server, check the logs for more information\");\n    }\n\n    /* Show some info about non-empty databases */\n    for (j = 0; j < server.dbnum; j++) {\n        long long size, used, vkeys;\n\n        size = dictSlots(server.db[j].dict);\n        used = dictSize(server.db[j].dict);\n        vkeys = dictSize(server.db[j].expires);\n        if (!(loops % 50) && (used || vkeys)) {\n            redisLog(REDIS_VERBOSE,\"DB %d: %lld keys (%lld volatile) in %lld slots HT.\",j,used,vkeys,size);\n            /* dictPrintStats(server.dict); */\n        }\n    }\n\n    /* We don't want to resize the hash tables while a bacground saving\n     * is in progress: the saving child is created using fork() that is\n     * implemented with a copy-on-write semantic in most modern systems, so\n     * if we resize the HT while there is the saving child at work actually\n     * a lot of memory movements in the parent will cause a lot of pages\n     * copied. */\n    if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1) {\n        if (!(loops % 10)) tryResizeHashTables();\n        if (server.activerehashing) incrementallyRehash();\n    }\n\n    /* Show information about connected clients */\n    if (!(loops % 50)) {\n        redisLog(REDIS_VERBOSE,\"%d clients connected (%d slaves), %zu bytes in use\",\n            listLength(server.clients)-listLength(server.slaves),\n            listLength(server.slaves),\n            zmalloc_used_memory());\n    }\n\n    /* Close connections of timedout clients */\n    if ((server.maxidletime && !(loops % 100)) || server.bpop_blocked_clients)\n        closeTimedoutClients();\n\n    /* Check if a background saving or AOF rewrite in progress terminated */\n    if (server.bgsavechildpid != -1 || server.bgrewritechildpid != -1) {\n        int statloc;\n        pid_t pid;\n\n        if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {\n            if (pid == server.bgsavechildpid) {\n                backgroundSaveDoneHandler(statloc);\n            } else {\n                backgroundRewriteDoneHandler(statloc);\n            }\n            updateDictResizePolicy();\n        }\n    } else {\n        /* If there is not a background saving in progress check if\n         * we have to save now */\n         time_t now = time(NULL);\n         for (j = 0; j < server.saveparamslen; j++) {\n            struct saveparam *sp = server.saveparams+j;\n\n            if (server.dirty >= sp->changes &&\n                now-server.lastsave > sp->seconds) {\n                redisLog(REDIS_NOTICE,\"%d changes in %d seconds. Saving...\",\n                    sp->changes, sp->seconds);\n                rdbSaveBackground(server.dbfilename);\n                break;\n            }\n         }\n    }\n\n    /* Expire a few keys per cycle, only if this is a master.\n     * On slaves we wait for DEL operations synthesized by the master\n     * in order to guarantee a strict consistency. */\n    if (server.masterhost == NULL) activeExpireCycle();\n\n    /* Swap a few keys on disk if we are over the memory limit and VM\n     * is enbled. Try to free objects from the free list first. */\n    if (vmCanSwapOut()) {\n        while (server.vm_enabled && zmalloc_used_memory() >\n                server.vm_max_memory)\n        {\n            int retval = (server.vm_max_threads == 0) ?\n                        vmSwapOneObjectBlocking() :\n                        vmSwapOneObjectThreaded();\n            if (retval == REDIS_ERR && !(loops % 300) &&\n                zmalloc_used_memory() >\n                (server.vm_max_memory+server.vm_max_memory/10))\n            {\n                redisLog(REDIS_WARNING,\"WARNING: vm-max-memory limit exceeded by more than 10%% but unable to swap more objects out!\");\n            }\n            /* Note that when using threade I/O we free just one object,\n             * because anyway when the I/O thread in charge to swap this\n             * object out will finish, the handler of completed jobs\n             * will try to swap more objects if we are still out of memory. */\n            if (retval == REDIS_ERR || server.vm_max_threads > 0) break;\n        }\n    }\n\n    /* Replication cron function -- used to reconnect to master and\n     * to detect transfer failures. */\n    if (!(loops % 10)) replicationCron();\n\n    return 100;\n}\n\n/* This function gets called every time Redis is entering the\n * main loop of the event driven library, that is, before to sleep\n * for ready file descriptors. */\nvoid beforeSleep(struct aeEventLoop *eventLoop) {\n    REDIS_NOTUSED(eventLoop);\n    listNode *ln;\n    redisClient *c;\n\n    /* Awake clients that got all the swapped keys they requested */\n    if (server.vm_enabled && listLength(server.io_ready_clients)) {\n        listIter li;\n\n        listRewind(server.io_ready_clients,&li);\n        while((ln = listNext(&li))) {\n            c = ln->value;\n            struct redisCommand *cmd;\n\n            /* Resume the client. */\n            listDelNode(server.io_ready_clients,ln);\n            c->flags &= (~REDIS_IO_WAIT);\n            server.vm_blocked_clients--;\n            aeCreateFileEvent(server.el, c->fd, AE_READABLE,\n                readQueryFromClient, c);\n            cmd = lookupCommand(c->argv[0]->ptr);\n            redisAssert(cmd != NULL);\n            call(c,cmd);\n            resetClient(c);\n            /* There may be more data to process in the input buffer. */\n            if (c->querybuf && sdslen(c->querybuf) > 0)\n                processInputBuffer(c);\n        }\n    }\n\n    /* Try to process pending commands for clients that were just unblocked. */\n    while (listLength(server.unblocked_clients)) {\n        ln = listFirst(server.unblocked_clients);\n        redisAssert(ln != NULL);\n        c = ln->value;\n        listDelNode(server.unblocked_clients,ln);\n\n        /* Process remaining data in the input buffer. */\n        if (c->querybuf && sdslen(c->querybuf) > 0)\n            processInputBuffer(c);\n    }\n\n    /* Write the AOF buffer on disk */\n    flushAppendOnlyFile();\n}\n\n/* =========================== Server initialization ======================== */\n\nvoid createSharedObjects(void) {\n    int j;\n\n    shared.crlf = createObject(REDIS_STRING,sdsnew(\"\\r\\n\"));\n    shared.ok = createObject(REDIS_STRING,sdsnew(\"+OK\\r\\n\"));\n    shared.err = createObject(REDIS_STRING,sdsnew(\"-ERR\\r\\n\"));\n    shared.emptybulk = createObject(REDIS_STRING,sdsnew(\"$0\\r\\n\\r\\n\"));\n    shared.czero = createObject(REDIS_STRING,sdsnew(\":0\\r\\n\"));\n    shared.cone = createObject(REDIS_STRING,sdsnew(\":1\\r\\n\"));\n    shared.cnegone = createObject(REDIS_STRING,sdsnew(\":-1\\r\\n\"));\n    shared.nullbulk = createObject(REDIS_STRING,sdsnew(\"$-1\\r\\n\"));\n    shared.nullmultibulk = createObject(REDIS_STRING,sdsnew(\"*-1\\r\\n\"));\n    shared.emptymultibulk = createObject(REDIS_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.pong = createObject(REDIS_STRING,sdsnew(\"+PONG\\r\\n\"));\n    shared.queued = createObject(REDIS_STRING,sdsnew(\"+QUEUED\\r\\n\"));\n    shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR Operation against a key holding the wrong kind of value\\r\\n\"));\n    shared.nokeyerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR no such key\\r\\n\"));\n    shared.syntaxerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR syntax error\\r\\n\"));\n    shared.sameobjecterr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR source and destination objects are the same\\r\\n\"));\n    shared.outofrangeerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR index out of range\\r\\n\"));\n    shared.loadingerr = createObject(REDIS_STRING,sdsnew(\n        \"-LOADING Redis is loading the dataset in memory\\r\\n\"));\n    shared.space = createObject(REDIS_STRING,sdsnew(\" \"));\n    shared.colon = createObject(REDIS_STRING,sdsnew(\":\"));\n    shared.plus = createObject(REDIS_STRING,sdsnew(\"+\"));\n    shared.select0 = createStringObject(\"select 0\\r\\n\",10);\n    shared.select1 = createStringObject(\"select 1\\r\\n\",10);\n    shared.select2 = createStringObject(\"select 2\\r\\n\",10);\n    shared.select3 = createStringObject(\"select 3\\r\\n\",10);\n    shared.select4 = createStringObject(\"select 4\\r\\n\",10);\n    shared.select5 = createStringObject(\"select 5\\r\\n\",10);\n    shared.select6 = createStringObject(\"select 6\\r\\n\",10);\n    shared.select7 = createStringObject(\"select 7\\r\\n\",10);\n    shared.select8 = createStringObject(\"select 8\\r\\n\",10);\n    shared.select9 = createStringObject(\"select 9\\r\\n\",10);\n    shared.messagebulk = createStringObject(\"$7\\r\\nmessage\\r\\n\",13);\n    shared.pmessagebulk = createStringObject(\"$8\\r\\npmessage\\r\\n\",14);\n    shared.subscribebulk = createStringObject(\"$9\\r\\nsubscribe\\r\\n\",15);\n    shared.unsubscribebulk = createStringObject(\"$11\\r\\nunsubscribe\\r\\n\",18);\n    shared.psubscribebulk = createStringObject(\"$10\\r\\npsubscribe\\r\\n\",17);\n    shared.punsubscribebulk = createStringObject(\"$12\\r\\npunsubscribe\\r\\n\",19);\n    shared.mbulk3 = createStringObject(\"*3\\r\\n\",4);\n    shared.mbulk4 = createStringObject(\"*4\\r\\n\",4);\n    for (j = 0; j < REDIS_SHARED_INTEGERS; j++) {\n        shared.integers[j] = createObject(REDIS_STRING,(void*)(long)j);\n        shared.integers[j]->encoding = REDIS_ENCODING_INT;\n    }\n}\n\nvoid initServerConfig() {\n    server.port = REDIS_SERVERPORT;\n    server.bindaddr = NULL;\n    server.unixsocket = NULL;\n    server.ipfd = -1;\n    server.sofd = -1;\n    server.dbnum = REDIS_DEFAULT_DBNUM;\n    server.verbosity = REDIS_VERBOSE;\n    server.maxidletime = REDIS_MAXIDLETIME;\n    server.saveparams = NULL;\n    server.loading = 0;\n    server.logfile = NULL; /* NULL = log on standard output */\n    server.syslog_enabled = 0;\n    server.syslog_ident = zstrdup(\"redis\");\n    server.syslog_facility = LOG_LOCAL0;\n    server.glueoutputbuf = 1;\n    server.daemonize = 0;\n    server.appendonly = 0;\n    server.appendfsync = APPENDFSYNC_EVERYSEC;\n    server.no_appendfsync_on_rewrite = 0;\n    server.lastfsync = time(NULL);\n    server.appendfd = -1;\n    server.appendseldb = -1; /* Make sure the first time will not match */\n    server.pidfile = zstrdup(\"/var/run/redis.pid\");\n    server.dbfilename = zstrdup(\"dump.rdb\");\n    server.appendfilename = zstrdup(\"appendonly.aof\");\n    server.requirepass = NULL;\n    server.rdbcompression = 1;\n    server.activerehashing = 1;\n    server.maxclients = 0;\n    server.bpop_blocked_clients = 0;\n    server.maxmemory = 0;\n    server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;\n    server.maxmemory_samples = 3;\n    server.vm_enabled = 0;\n    server.vm_swap_file = zstrdup(\"/tmp/redis-%p.vm\");\n    server.vm_page_size = 256;          /* 256 bytes per page */\n    server.vm_pages = 1024*1024*100;    /* 104 millions of pages */\n    server.vm_max_memory = 1024LL*1024*1024*1; /* 1 GB of RAM */\n    server.vm_max_threads = 4;\n    server.vm_blocked_clients = 0;\n    server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES;\n    server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE;\n    server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;\n    server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;\n    server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;\n    server.shutdown_asap = 0;\n\n    updateLRUClock();\n    resetServerSaveParams();\n\n    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */\n    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */\n    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */\n    /* Replication related */\n    server.isslave = 0;\n    server.masterauth = NULL;\n    server.masterhost = NULL;\n    server.masterport = 6379;\n    server.master = NULL;\n    server.replstate = REDIS_REPL_NONE;\n    server.repl_serve_stale_data = 1;\n\n    /* Double constants initialization */\n    R_Zero = 0.0;\n    R_PosInf = 1.0/R_Zero;\n    R_NegInf = -1.0/R_Zero;\n    R_Nan = R_Zero/R_Zero;\n\n    /* Command table -- we intiialize it here as it is part of the\n     * initial configuration, since command names may be changed via\n     * redis.conf using the rename-command directive. */\n    server.commands = dictCreate(&commandTableDictType,NULL);\n    populateCommandTable();\n    server.delCommand = lookupCommandByCString(\"del\");\n    server.multiCommand = lookupCommandByCString(\"multi\");\n}\n\nvoid initServer() {\n    int j;\n\n    signal(SIGHUP, SIG_IGN);\n    signal(SIGPIPE, SIG_IGN);\n    setupSigSegvAction();\n\n    if (server.syslog_enabled) {\n        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,\n            server.syslog_facility);\n    }\n\n    server.mainthread = pthread_self();\n    server.clients = listCreate();\n    server.slaves = listCreate();\n    server.monitors = listCreate();\n    server.unblocked_clients = listCreate();\n    createSharedObjects();\n    server.el = aeCreateEventLoop();\n    server.db = zmalloc(sizeof(redisDb)*server.dbnum);\n    server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);\n    if (server.ipfd == ANET_ERR) {\n        redisLog(REDIS_WARNING, \"Opening port: %s\", server.neterr);\n        exit(1);\n    }\n    if (server.unixsocket != NULL) {\n        unlink(server.unixsocket); /* don't care if this fails */\n        server.sofd = anetUnixServer(server.neterr,server.unixsocket);\n        if (server.sofd == ANET_ERR) {\n            redisLog(REDIS_WARNING, \"Opening socket: %s\", server.neterr);\n            exit(1);\n        }\n    }\n    if (server.ipfd < 0 && server.sofd < 0) {\n        redisLog(REDIS_WARNING, \"Configured to not listen anywhere, exiting.\");\n        exit(1);\n    }\n    for (j = 0; j < server.dbnum; j++) {\n        server.db[j].dict = dictCreate(&dbDictType,NULL);\n        server.db[j].expires = dictCreate(&keyptrDictType,NULL);\n        server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);\n        if (server.vm_enabled)\n            server.db[j].io_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].id = j;\n    }\n    server.pubsub_channels = dictCreate(&keylistDictType,NULL);\n    server.pubsub_patterns = listCreate();\n    listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);\n    listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);\n    server.cronloops = 0;\n    server.bgsavechildpid = -1;\n    server.bgrewritechildpid = -1;\n    server.bgrewritebuf = sdsempty();\n    server.aofbuf = sdsempty();\n    server.lastsave = time(NULL);\n    server.dirty = 0;\n    server.stat_numcommands = 0;\n    server.stat_numconnections = 0;\n    server.stat_expiredkeys = 0;\n    server.stat_evictedkeys = 0;\n    server.stat_starttime = time(NULL);\n    server.stat_keyspace_misses = 0;\n    server.stat_keyspace_hits = 0;\n    server.unixtime = time(NULL);\n    aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);\n    if (server.ipfd > 0 && aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,\n        acceptTcpHandler,NULL) == AE_ERR) oom(\"creating file event\");\n    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,\n        acceptUnixHandler,NULL) == AE_ERR) oom(\"creating file event\");\n\n    if (server.appendonly) {\n        server.appendfd = open(server.appendfilename,O_WRONLY|O_APPEND|O_CREAT,0644);\n        if (server.appendfd == -1) {\n            redisLog(REDIS_WARNING, \"Can't open the append-only file: %s\",\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    if (server.vm_enabled) vmInit();\n}\n\n/* Populates the Redis Command Table starting from the hard coded list\n * we have on top of redis.c file. */\nvoid populateCommandTable(void) {\n    int j;\n    int numcommands = sizeof(readonlyCommandTable)/sizeof(struct redisCommand);\n\n    for (j = 0; j < numcommands; j++) {\n        struct redisCommand *c = readonlyCommandTable+j;\n        int retval;\n\n        retval = dictAdd(server.commands, sdsnew(c->name), c);\n        assert(retval == DICT_OK);\n    }\n}\n\n/* ====================== Commands lookup and execution ===================== */\n\nstruct redisCommand *lookupCommand(sds name) {\n    return dictFetchValue(server.commands, name);\n}\n\nstruct redisCommand *lookupCommandByCString(char *s) {\n    struct redisCommand *cmd;\n    sds name = sdsnew(s);\n\n    cmd = dictFetchValue(server.commands, name);\n    sdsfree(name);\n    return cmd;\n}\n\n/* Call() is the core of Redis execution of a command */\nvoid call(redisClient *c, struct redisCommand *cmd) {\n    long long dirty;\n\n    dirty = server.dirty;\n    cmd->proc(c);\n    dirty = server.dirty-dirty;\n\n    if (server.appendonly && dirty)\n        feedAppendOnlyFile(cmd,c->db->id,c->argv,c->argc);\n    if ((dirty || cmd->flags & REDIS_CMD_FORCE_REPLICATION) &&\n        listLength(server.slaves))\n        replicationFeedSlaves(server.slaves,c->db->id,c->argv,c->argc);\n    if (listLength(server.monitors))\n        replicationFeedMonitors(server.monitors,c->db->id,c->argv,c->argc);\n    server.stat_numcommands++;\n}\n\n/* If this function gets called we already read a whole\n * command, argments are in the client argv/argc fields.\n * processCommand() execute the command or prepare the\n * server for a bulk read from the client.\n *\n * If 1 is returned the client is still alive and valid and\n * and other operations can be performed by the caller. Otherwise\n * if 0 is returned the client was destroied (i.e. after QUIT). */\nint processCommand(redisClient *c) {\n    struct redisCommand *cmd;\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= REDIS_CLOSE_AFTER_REPLY;\n        return REDIS_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such wrong arity, bad command name and so forth. */\n    cmd = lookupCommand(c->argv[0]->ptr);\n    if (!cmd) {\n        addReplyErrorFormat(c,\"unknown command '%s'\",\n            (char*)c->argv[0]->ptr);\n        return REDIS_OK;\n    } else if ((cmd->arity > 0 && cmd->arity != c->argc) ||\n               (c->argc < -cmd->arity)) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            cmd->name);\n        return REDIS_OK;\n    }\n\n    /* Check if the user is authenticated */\n    if (server.requirepass && !c->authenticated && cmd->proc != authCommand) {\n        addReplyError(c,\"operation not permitted\");\n        return REDIS_OK;\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * First we try to free some memory if possible (if there are volatile\n     * keys in the dataset). If there are not the only thing we can do\n     * is returning an error. */\n    if (server.maxmemory) freeMemoryIfNeeded();\n    if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) &&\n        zmalloc_used_memory() > server.maxmemory)\n    {\n        addReplyError(c,\"command not allowed when used memory > 'maxmemory'\");\n        return REDIS_OK;\n    }\n\n    /* Only allow SUBSCRIBE and UNSUBSCRIBE in the context of Pub/Sub */\n    if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0)\n        &&\n        cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand &&\n        cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) {\n        addReplyError(c,\"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context\");\n        return REDIS_OK;\n    }\n\n    /* Only allow INFO and SLAVEOF when slave-serve-stale-data is no and\n     * we are a slave with a broken link with master. */\n    if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        cmd->proc != infoCommand && cmd->proc != slaveofCommand)\n    {\n        addReplyError(c,\n            \"link with MASTER is down and slave-serve-stale-data is set to no\");\n        return REDIS_OK;\n    }\n\n    /* Loading DB? Return an error if the command is not INFO */\n    if (server.loading && cmd->proc != infoCommand) {\n        addReply(c, shared.loadingerr);\n        return REDIS_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & REDIS_MULTI &&\n        cmd->proc != execCommand && cmd->proc != discardCommand &&\n        cmd->proc != multiCommand && cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c,cmd);\n        addReply(c,shared.queued);\n    } else {\n        if (server.vm_enabled && server.vm_max_threads > 0 &&\n            blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR;\n        call(c,cmd);\n    }\n    return REDIS_OK;\n}\n\n/*================================== Shutdown =============================== */\n\nint prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    /* Kill the saving child if there is a background saving in progress.\n       We want to avoid race conditions, for instance our saving child may\n       overwrite the synchronous saving did by SHUTDOWN. */\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        /* Append only file: fsync() the AOF and exit */\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        /* Snapshotting. Perform a SYNC SAVE and exit */\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            /* Ooops.. error saving! The best we can do is to continue\n             * operating. Note that if there was a background saving process,\n             * in the next cron() Redis will be notified that the background\n             * saving aborted, handling special stuff like slaves pending for\n             * synchronization... */\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}\n\n/*================================== Commands =============================== */\n\nvoid authCommand(redisClient *c) {\n    if (!server.requirepass || !strcmp(c->argv[1]->ptr, server.requirepass)) {\n      c->authenticated = 1;\n      addReply(c,shared.ok);\n    } else {\n      c->authenticated = 0;\n      addReplyError(c,\"invalid password\");\n    }\n}\n\nvoid pingCommand(redisClient *c) {\n    addReply(c,shared.pong);\n}\n\nvoid echoCommand(redisClient *c) {\n    addReplyBulk(c,c->argv[1]);\n}\n\n/* Convert an amount of bytes into a human readable string in the form\n * of 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, unsigned long long n) {\n    double d;\n\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lluB\",n);\n        return;\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    }\n}\n\n/* Create the string returned by the INFO command. This is decoupled\n * by the INFO command itself as we need to report the same information\n * on memory corruption problems. */\nsds genRedisInfoString(void) {\n    sds info;\n    time_t uptime = time(NULL)-server.stat_starttime;\n    int j;\n    char hmem[64];\n    struct rusage self_ru, c_ru;\n\n    getrusage(RUSAGE_SELF, &self_ru);\n    getrusage(RUSAGE_CHILDREN, &c_ru);\n\n    bytesToHuman(hmem,zmalloc_used_memory());\n    info = sdscatprintf(sdsempty(),\n        \"redis_version:%s\\r\\n\"\n        \"redis_git_sha1:%s\\r\\n\"\n        \"redis_git_dirty:%d\\r\\n\"\n        \"arch_bits:%s\\r\\n\"\n        \"multiplexing_api:%s\\r\\n\"\n        \"process_id:%ld\\r\\n\"\n        \"uptime_in_seconds:%ld\\r\\n\"\n        \"uptime_in_days:%ld\\r\\n\"\n        \"lru_clock:%ld\\r\\n\"\n        \"used_cpu_sys:%.2f\\r\\n\"\n        \"used_cpu_user:%.2f\\r\\n\"\n        \"used_cpu_sys_childrens:%.2f\\r\\n\"\n        \"used_cpu_user_childrens:%.2f\\r\\n\"\n        \"connected_clients:%d\\r\\n\"\n        \"connected_slaves:%d\\r\\n\"\n        \"blocked_clients:%d\\r\\n\"\n        \"used_memory:%zu\\r\\n\"\n        \"used_memory_human:%s\\r\\n\"\n        \"used_memory_rss:%zu\\r\\n\"\n        \"mem_fragmentation_ratio:%.2f\\r\\n\"\n        \"use_tcmalloc:%d\\r\\n\"\n        \"loading:%d\\r\\n\"\n        \"aof_enabled:%d\\r\\n\"\n        \"changes_since_last_save:%lld\\r\\n\"\n        \"bgsave_in_progress:%d\\r\\n\"\n        \"last_save_time:%ld\\r\\n\"\n        \"bgrewriteaof_in_progress:%d\\r\\n\"\n        \"total_connections_received:%lld\\r\\n\"\n        \"total_commands_processed:%lld\\r\\n\"\n        \"expired_keys:%lld\\r\\n\"\n        \"evicted_keys:%lld\\r\\n\"\n        \"keyspace_hits:%lld\\r\\n\"\n        \"keyspace_misses:%lld\\r\\n\"\n        \"hash_max_zipmap_entries:%zu\\r\\n\"\n        \"hash_max_zipmap_value:%zu\\r\\n\"\n        \"pubsub_channels:%ld\\r\\n\"\n        \"pubsub_patterns:%u\\r\\n\"\n        \"vm_enabled:%d\\r\\n\"\n        \"role:%s\\r\\n\"\n        ,REDIS_VERSION,\n        redisGitSHA1(),\n        strtol(redisGitDirty(),NULL,10) > 0,\n        (sizeof(long) == 8) ? \"64\" : \"32\",\n        aeGetApiName(),\n        (long) getpid(),\n        uptime,\n        uptime/(3600*24),\n        (unsigned long) server.lruclock,\n        (float)self_ru.ru_utime.tv_sec+(float)self_ru.ru_utime.tv_usec/1000000,\n        (float)self_ru.ru_stime.tv_sec+(float)self_ru.ru_stime.tv_usec/1000000,\n        (float)c_ru.ru_utime.tv_sec+(float)c_ru.ru_utime.tv_usec/1000000,\n        (float)c_ru.ru_stime.tv_sec+(float)c_ru.ru_stime.tv_usec/1000000,\n        listLength(server.clients)-listLength(server.slaves),\n        listLength(server.slaves),\n        server.bpop_blocked_clients,\n        zmalloc_used_memory(),\n        hmem,\n        zmalloc_get_rss(),\n        zmalloc_get_fragmentation_ratio(),\n#ifdef USE_TCMALLOC\n        1,\n#else\n        0,\n#endif\n        server.loading,\n        server.appendonly,\n        server.dirty,\n        server.bgsavechildpid != -1,\n        server.lastsave,\n        server.bgrewritechildpid != -1,\n        server.stat_numconnections,\n        server.stat_numcommands,\n        server.stat_expiredkeys,\n        server.stat_evictedkeys,\n        server.stat_keyspace_hits,\n        server.stat_keyspace_misses,\n        server.hash_max_zipmap_entries,\n        server.hash_max_zipmap_value,\n        dictSize(server.pubsub_channels),\n        listLength(server.pubsub_patterns),\n        server.vm_enabled != 0,\n        server.masterhost == NULL ? \"master\" : \"slave\"\n    );\n    if (server.masterhost) {\n        info = sdscatprintf(info,\n            \"master_host:%s\\r\\n\"\n            \"master_port:%d\\r\\n\"\n            \"master_link_status:%s\\r\\n\"\n            \"master_last_io_seconds_ago:%d\\r\\n\"\n            \"master_sync_in_progress:%d\\r\\n\"\n            ,server.masterhost,\n            server.masterport,\n            (server.replstate == REDIS_REPL_CONNECTED) ?\n                \"up\" : \"down\",\n            server.master ? ((int)(time(NULL)-server.master->lastinteraction)) : -1,\n            server.replstate == REDIS_REPL_TRANSFER\n        );\n\n        if (server.replstate == REDIS_REPL_TRANSFER) {\n            info = sdscatprintf(info,\n                \"master_sync_left_bytes:%ld\\r\\n\"\n                \"master_sync_last_io_seconds_ago:%d\\r\\n\"\n                ,(long)server.repl_transfer_left,\n                (int)(time(NULL)-server.repl_transfer_lastio)\n            );\n        }\n    }\n    if (server.vm_enabled) {\n        lockThreadedIO();\n        info = sdscatprintf(info,\n            \"vm_conf_max_memory:%llu\\r\\n\"\n            \"vm_conf_page_size:%llu\\r\\n\"\n            \"vm_conf_pages:%llu\\r\\n\"\n            \"vm_stats_used_pages:%llu\\r\\n\"\n            \"vm_stats_swapped_objects:%llu\\r\\n\"\n            \"vm_stats_swappin_count:%llu\\r\\n\"\n            \"vm_stats_swappout_count:%llu\\r\\n\"\n            \"vm_stats_io_newjobs_len:%lu\\r\\n\"\n            \"vm_stats_io_processing_len:%lu\\r\\n\"\n            \"vm_stats_io_processed_len:%lu\\r\\n\"\n            \"vm_stats_io_active_threads:%lu\\r\\n\"\n            \"vm_stats_blocked_clients:%lu\\r\\n\"\n            ,(unsigned long long) server.vm_max_memory,\n            (unsigned long long) server.vm_page_size,\n            (unsigned long long) server.vm_pages,\n            (unsigned long long) server.vm_stats_used_pages,\n            (unsigned long long) server.vm_stats_swapped_objects,\n            (unsigned long long) server.vm_stats_swapins,\n            (unsigned long long) server.vm_stats_swapouts,\n            (unsigned long) listLength(server.io_newjobs),\n            (unsigned long) listLength(server.io_processing),\n            (unsigned long) listLength(server.io_processed),\n            (unsigned long) server.io_active_threads,\n            (unsigned long) server.vm_blocked_clients\n        );\n        unlockThreadedIO();\n    }\n    if (server.loading) {\n        double perc;\n        time_t eta, elapsed;\n        off_t remaining_bytes = server.loading_total_bytes-\n                                server.loading_loaded_bytes;\n\n        perc = ((double)server.loading_loaded_bytes /\n               server.loading_total_bytes) * 100;\n\n        elapsed = time(NULL)-server.loading_start_time;\n        if (elapsed == 0) {\n            eta = 1; /* A fake 1 second figure if we don't have enough info */\n        } else {\n            eta = (elapsed*remaining_bytes)/server.loading_loaded_bytes;\n        }\n\n        info = sdscatprintf(info,\n            \"loading_start_time:%ld\\r\\n\"\n            \"loading_total_bytes:%llu\\r\\n\"\n            \"loading_loaded_bytes:%llu\\r\\n\"\n            \"loading_loaded_perc:%.2f\\r\\n\"\n            \"loading_eta_seconds:%ld\\r\\n\"\n            ,(unsigned long) server.loading_start_time,\n            (unsigned long long) server.loading_total_bytes,\n            (unsigned long long) server.loading_loaded_bytes,\n            perc,\n            eta\n        );\n    }\n    for (j = 0; j < server.dbnum; j++) {\n        long long keys, vkeys;\n\n        keys = dictSize(server.db[j].dict);\n        vkeys = dictSize(server.db[j].expires);\n        if (keys || vkeys) {\n            info = sdscatprintf(info, \"db%d:keys=%lld,expires=%lld\\r\\n\",\n                j, keys, vkeys);\n        }\n    }\n    return info;\n}\n\nvoid infoCommand(redisClient *c) {\n    sds info = genRedisInfoString();\n    addReplySds(c,sdscatprintf(sdsempty(),\"$%lu\\r\\n\",\n        (unsigned long)sdslen(info)));\n    addReplySds(c,info);\n    addReply(c,shared.crlf);\n}\n\nvoid monitorCommand(redisClient *c) {\n    /* ignore MONITOR if aleady slave or in monitor mode */\n    if (c->flags & REDIS_SLAVE) return;\n\n    c->flags |= (REDIS_SLAVE|REDIS_MONITOR);\n    c->slaveseldb = 0;\n    listAddNodeTail(server.monitors,c);\n    addReply(c,shared.ok);\n}\n\n/* ============================ Maxmemory directive  ======================== */\n\n/* This function gets called when 'maxmemory' is set on the config file to limit\n * the max memory used by the server, and we are out of memory.\n * This function will try to, in order:\n *\n * - Free objects from the free list\n * - Try to remove keys with an EXPIRE set\n *\n * It is not possible to free enough memory to reach used-memory < maxmemory\n * the server will start refusing commands that will enlarge even more the\n * memory usage.\n */\nvoid freeMemoryIfNeeded(void) {\n    /* Remove keys accordingly to the active policy as long as we are\n     * over the memory limit. */\n    if (server.maxmemory_policy == REDIS_MAXMEMORY_NO_EVICTION) return;\n\n    while (server.maxmemory && zmalloc_used_memory() > server.maxmemory) {\n        int j, k, freed = 0;\n\n        for (j = 0; j < server.dbnum; j++) {\n            long bestval = 0; /* just to prevent warning */\n            sds bestkey = NULL;\n            struct dictEntry *de;\n            redisDb *db = server.db+j;\n            dict *dict;\n\n            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||\n                server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM)\n            {\n                dict = server.db[j].dict;\n            } else {\n                dict = server.db[j].expires;\n            }\n            if (dictSize(dict) == 0) continue;\n\n            /* volatile-random and allkeys-random policy */\n            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM ||\n                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_RANDOM)\n            {\n                de = dictGetRandomKey(dict);\n                bestkey = dictGetEntryKey(de);\n            }\n\n            /* volatile-lru and allkeys-lru policy */\n            else if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||\n                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)\n            {\n                for (k = 0; k < server.maxmemory_samples; k++) {\n                    sds thiskey;\n                    long thisval;\n                    robj *o;\n\n                    de = dictGetRandomKey(dict);\n                    thiskey = dictGetEntryKey(de);\n                    /* When policy is volatile-lru we need an additonal lookup\n                     * to locate the real key, as dict is set to db->expires. */\n                    if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)\n                        de = dictFind(db->dict, thiskey);\n                    o = dictGetEntryVal(de);\n                    thisval = estimateObjectIdleTime(o);\n\n                    /* Higher idle time is better candidate for deletion */\n                    if (bestkey == NULL || thisval > bestval) {\n                        bestkey = thiskey;\n                        bestval = thisval;\n                    }\n                }\n            }\n\n            /* volatile-ttl */\n            else if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_TTL) {\n                for (k = 0; k < server.maxmemory_samples; k++) {\n                    sds thiskey;\n                    long thisval;\n\n                    de = dictGetRandomKey(dict);\n                    thiskey = dictGetEntryKey(de);\n                    thisval = (long) dictGetEntryVal(de);\n\n                    /* Expire sooner (minor expire unix timestamp) is better\n                     * candidate for deletion */\n                    if (bestkey == NULL || thisval < bestval) {\n                        bestkey = thiskey;\n                        bestval = thisval;\n                    }\n                }\n            }\n\n            /* Finally remove the selected key. */\n            if (bestkey) {\n                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));\n                dbDelete(db,keyobj);\n                server.stat_evictedkeys++;\n                decrRefCount(keyobj);\n                freed++;\n            }\n        }\n        if (!freed) return; /* nothing to free... */\n    }\n}\n\n/* =================================== Main! ================================ */\n\n#ifdef __linux__\nint linuxOvercommitMemoryValue(void) {\n    FILE *fp = fopen(\"/proc/sys/vm/overcommit_memory\",\"r\");\n    char buf[64];\n\n    if (!fp) return -1;\n    if (fgets(buf,64,fp) == NULL) {\n        fclose(fp);\n        return -1;\n    }\n    fclose(fp);\n\n    return atoi(buf);\n}\n\nvoid linuxOvercommitMemoryWarning(void) {\n    if (linuxOvercommitMemoryValue() == 0) {\n        redisLog(REDIS_WARNING,\"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\");\n    }\n}\n#endif /* __linux__ */\n\nvoid createPidFile(void) {\n    /* Try to write the pid file in a best-effort way. */\n    FILE *fp = fopen(server.pidfile,\"w\");\n    if (fp) {\n        fprintf(fp,\"%d\\n\",getpid());\n        fclose(fp);\n    }\n}\n\nvoid daemonize(void) {\n    int fd;\n\n    if (fork() != 0) exit(0); /* parent exits */\n    setsid(); /* create a new session */\n\n    /* Every output goes to /dev/null. If Redis is daemonized but\n     * the 'logfile' is set to 'stdout' in the configuration file\n     * it will not log at all. */\n    if ((fd = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n        dup2(fd, STDIN_FILENO);\n        dup2(fd, STDOUT_FILENO);\n        dup2(fd, STDERR_FILENO);\n        if (fd > STDERR_FILENO) close(fd);\n    }\n}\n\nvoid version() {\n    printf(\"Redis server version %s (%s:%d)\\n\", REDIS_VERSION,\n        redisGitSHA1(), atoi(redisGitDirty()) > 0);\n    exit(0);\n}\n\nvoid usage() {\n    fprintf(stderr,\"Usage: ./redis-server [/path/to/redis.conf]\\n\");\n    fprintf(stderr,\"       ./redis-server - (read config from stdin)\\n\");\n    exit(1);\n}\n\nint main(int argc, char **argv) {\n    time_t start;\n\n    initServerConfig();\n    if (argc == 2) {\n        if (strcmp(argv[1], \"-v\") == 0 ||\n            strcmp(argv[1], \"--version\") == 0) version();\n        if (strcmp(argv[1], \"--help\") == 0) usage();\n        resetServerSaveParams();\n        loadServerConfig(argv[1]);\n    } else if ((argc > 2)) {\n        usage();\n    } else {\n        redisLog(REDIS_WARNING,\"Warning: no config file specified, using the default config. In order to specify a config file use 'redis-server /path/to/redis.conf'\");\n    }\n    if (server.daemonize) daemonize();\n    initServer();\n    if (server.daemonize) createPidFile();\n    redisLog(REDIS_NOTICE,\"Server started, Redis version \" REDIS_VERSION);\n#ifdef __linux__\n    linuxOvercommitMemoryWarning();\n#endif\n    start = time(NULL);\n    if (server.appendonly) {\n        if (loadAppendOnlyFile(server.appendfilename) == REDIS_OK)\n            redisLog(REDIS_NOTICE,\"DB loaded from append only file: %ld seconds\",time(NULL)-start);\n    } else {\n        if (rdbLoad(server.dbfilename) == REDIS_OK)\n            redisLog(REDIS_NOTICE,\"DB loaded from disk: %ld seconds\",time(NULL)-start);\n    }\n    if (server.ipfd > 0)\n        redisLog(REDIS_NOTICE,\"The server is now ready to accept connections on port %d\", server.port);\n    if (server.sofd > 0)\n        redisLog(REDIS_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket);\n    aeSetBeforeSleepProc(server.el,beforeSleep);\n    aeMain(server.el);\n    aeDeleteEventLoop(server.el);\n    return 0;\n}\n\n/* ============================= Backtrace support ========================= */\n\n#ifdef HAVE_BACKTRACE\nvoid *getMcontextEip(ucontext_t *uc) {\n#if defined(__FreeBSD__)\n    return (void*) uc->uc_mcontext.mc_eip;\n#elif defined(__dietlibc__)\n    return (void*) uc->uc_mcontext.eip;\n#elif defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)\n  #if __x86_64__\n    return (void*) uc->uc_mcontext->__ss.__rip;\n  #else\n    return (void*) uc->uc_mcontext->__ss.__eip;\n  #endif\n#elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)\n  #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)\n    return (void*) uc->uc_mcontext->__ss.__rip;\n  #else\n    return (void*) uc->uc_mcontext->__ss.__eip;\n  #endif\n#elif defined(__i386__)\n    return (void*) uc->uc_mcontext.gregs[14]; /* Linux 32 */\n#elif defined(__X86_64__) || defined(__x86_64__)\n    return (void*) uc->uc_mcontext.gregs[16]; /* Linux 64 */\n#elif defined(__ia64__) /* Linux IA64 */\n    return (void*) uc->uc_mcontext.sc_ip;\n#else\n    return NULL;\n#endif\n}\n\nvoid segvHandler(int sig, siginfo_t *info, void *secret) {\n    void *trace[100];\n    char **messages = NULL;\n    int i, trace_size = 0;\n    ucontext_t *uc = (ucontext_t*) secret;\n    sds infostring;\n    struct sigaction act;\n    REDIS_NOTUSED(info);\n\n    redisLog(REDIS_WARNING,\n        \"======= Ooops! Redis %s got signal: -%d- =======\", REDIS_VERSION, sig);\n    infostring = genRedisInfoString();\n    redisLog(REDIS_WARNING, \"%s\",infostring);\n    /* It's not safe to sdsfree() the returned string under memory\n     * corruption conditions. Let it leak as we are going to abort */\n\n    trace_size = backtrace(trace, 100);\n    /* overwrite sigaction with caller's address */\n    if (getMcontextEip(uc) != NULL) {\n        trace[1] = getMcontextEip(uc);\n    }\n    messages = backtrace_symbols(trace, trace_size);\n\n    for (i=1; i<trace_size; ++i)\n        redisLog(REDIS_WARNING,\"%s\", messages[i]);\n\n    /* free(messages); Don't call free() with possibly corrupted memory. */\n    if (server.daemonize) unlink(server.pidfile);\n\n    /* Make sure we exit with the right signal at the end. So for instance\n     * the core will be dumped if enabled. */\n    sigemptyset (&act.sa_mask);\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction\n     * is used. Otherwise, sa_handler is used */\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = SIG_DFL;\n    sigaction (sig, &act, NULL);\n    kill(getpid(),sig);\n}\n\nvoid sigtermHandler(int sig) {\n    REDIS_NOTUSED(sig);\n\n    redisLog(REDIS_WARNING,\"SIGTERM received, scheduling shutting down...\");\n    server.shutdown_asap = 1;\n}\n\nvoid setupSigSegvAction(void) {\n    struct sigaction act;\n\n    sigemptyset (&act.sa_mask);\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction\n     * is used. Otherwise, sa_handler is used */\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = segvHandler;\n    sigaction (SIGSEGV, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n    sigaction (SIGFPE, &act, NULL);\n    sigaction (SIGILL, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = sigtermHandler;\n    sigaction (SIGTERM, &act, NULL);\n    return;\n}\n\n#else /* HAVE_BACKTRACE */\nvoid setupSigSegvAction(void) {\n}\n#endif /* HAVE_BACKTRACE */\n\n/* The End */\n", "#ifndef __REDIS_H\n#define __REDIS_H\n\n#include \"fmacros.h\"\n#include \"config.h\"\n\n#if defined(__sun)\n#include \"solarisfixes.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n#include <unistd.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <pthread.h>\n#include <syslog.h>\n\n#include \"ae.h\"     /* Event driven programming library */\n#include \"sds.h\"    /* Dynamic safe strings */\n#include \"dict.h\"   /* Hash tables */\n#include \"adlist.h\" /* Linked lists */\n#include \"zmalloc.h\" /* total memory usage aware version of malloc/free */\n#include \"anet.h\"   /* Networking the easy way */\n#include \"zipmap.h\" /* Compact string -> string data structure */\n#include \"ziplist.h\" /* Compact list data structure */\n#include \"intset.h\" /* Compact integer set structure */\n#include \"version.h\"\n\n/* Error codes */\n#define REDIS_OK                0\n#define REDIS_ERR               -1\n\n/* Static server configuration */\n#define REDIS_SERVERPORT        6379    /* TCP port */\n#define REDIS_MAXIDLETIME       (60*5)  /* default client timeout */\n#define REDIS_IOBUF_LEN         1024\n#define REDIS_LOADBUF_LEN       1024\n#define REDIS_STATIC_ARGS       8\n#define REDIS_DEFAULT_DBNUM     16\n#define REDIS_CONFIGLINE_MAX    1024\n#define REDIS_MAX_SYNC_TIME     60      /* Slave can't take more to sync */\n#define REDIS_EXPIRELOOKUPS_PER_CRON    10 /* lookup 10 expires per loop */\n#define REDIS_MAX_WRITE_PER_EVENT (1024*64)\n#define REDIS_REQUEST_MAX_SIZE (1024*1024*256) /* max bytes in inline command */\n#define REDIS_SHARED_INTEGERS 10000\n#define REDIS_REPLY_CHUNK_BYTES (5*1500) /* 5 TCP packets with default MTU */\n#define REDIS_MAX_LOGMSG_LEN    1024 /* Default maximum length of syslog messages */\n\n/* If more then REDIS_WRITEV_THRESHOLD write packets are pending use writev */\n#define REDIS_WRITEV_THRESHOLD      3\n/* Max number of iovecs used for each writev call */\n#define REDIS_WRITEV_IOVEC_COUNT    256\n\n/* Hash table parameters */\n#define REDIS_HT_MINFILL        10      /* Minimal hash table fill 10% */\n\n/* Command flags:\n *   REDIS_CMD_DENYOOM:\n *     Commands marked with this flag will return an error when 'maxmemory' is\n *     set and the server is using more than 'maxmemory' bytes of memory.\n *     In short: commands with this flag are denied on low memory conditions.\n *   REDIS_CMD_FORCE_REPLICATION:\n *     Force replication even if dirty is 0. */\n#define REDIS_CMD_DENYOOM 4\n#define REDIS_CMD_FORCE_REPLICATION 8\n\n/* Object types */\n#define REDIS_STRING 0\n#define REDIS_LIST 1\n#define REDIS_SET 2\n#define REDIS_ZSET 3\n#define REDIS_HASH 4\n#define REDIS_VMPOINTER 8\n\n/* Objects encoding. Some kind of objects like Strings and Hashes can be\n * internally represented in multiple ways. The 'encoding' field of the object\n * is set to one of this fields for this object. */\n#define REDIS_ENCODING_RAW 0     /* Raw representation */\n#define REDIS_ENCODING_INT 1     /* Encoded as integer */\n#define REDIS_ENCODING_HT 2      /* Encoded as hash table */\n#define REDIS_ENCODING_ZIPMAP 3  /* Encoded as zipmap */\n#define REDIS_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */\n#define REDIS_ENCODING_ZIPLIST 5 /* Encoded as ziplist */\n#define REDIS_ENCODING_INTSET 6  /* Encoded as intset */\n\n/* Object types only used for dumping to disk */\n#define REDIS_EXPIRETIME 253\n#define REDIS_SELECTDB 254\n#define REDIS_EOF 255\n\n/* Defines related to the dump file format. To store 32 bits lengths for short\n * keys requires a lot of space, so we check the most significant 2 bits of\n * the first byte to interpreter the length:\n *\n * 00|000000 => if the two MSB are 00 the len is the 6 bits of this byte\n * 01|000000 00000000 =>  01, the len is 14 byes, 6 bits + 8 bits of next byte\n * 10|000000 [32 bit integer] => if it's 01, a full 32 bit len will follow\n * 11|000000 this means: specially encoded object will follow. The six bits\n *           number specify the kind of object that follows.\n *           See the REDIS_RDB_ENC_* defines.\n *\n * Lenghts up to 63 are stored using a single byte, most DB keys, and may\n * values, will fit inside. */\n#define REDIS_RDB_6BITLEN 0\n#define REDIS_RDB_14BITLEN 1\n#define REDIS_RDB_32BITLEN 2\n#define REDIS_RDB_ENCVAL 3\n#define REDIS_RDB_LENERR UINT_MAX\n\n/* When a length of a string object stored on disk has the first two bits\n * set, the remaining two bits specify a special encoding for the object\n * accordingly to the following defines: */\n#define REDIS_RDB_ENC_INT8 0        /* 8 bit signed integer */\n#define REDIS_RDB_ENC_INT16 1       /* 16 bit signed integer */\n#define REDIS_RDB_ENC_INT32 2       /* 32 bit signed integer */\n#define REDIS_RDB_ENC_LZF 3         /* string compressed with FASTLZ */\n\n/* Virtual memory object->where field. */\n#define REDIS_VM_MEMORY 0       /* The object is on memory */\n#define REDIS_VM_SWAPPED 1      /* The object is on disk */\n#define REDIS_VM_SWAPPING 2     /* Redis is swapping this object on disk */\n#define REDIS_VM_LOADING 3      /* Redis is loading this object from disk */\n\n/* Virtual memory static configuration stuff.\n * Check vmFindContiguousPages() to know more about this magic numbers. */\n#define REDIS_VM_MAX_NEAR_PAGES 65536\n#define REDIS_VM_MAX_RANDOM_JUMP 4096\n#define REDIS_VM_MAX_THREADS 32\n#define REDIS_THREAD_STACK_SIZE (1024*1024*4)\n/* The following is the *percentage* of completed I/O jobs to process when the\n * handelr is called. While Virtual Memory I/O operations are performed by\n * threads, this operations must be processed by the main thread when completed\n * in order to take effect. */\n#define REDIS_MAX_COMPLETED_JOBS_PROCESSED 1\n\n/* Client flags */\n#define REDIS_SLAVE 1       /* This client is a slave server */\n#define REDIS_MASTER 2      /* This client is a master server */\n#define REDIS_MONITOR 4     /* This client is a slave monitor, see MONITOR */\n#define REDIS_MULTI 8       /* This client is in a MULTI context */\n#define REDIS_BLOCKED 16    /* The client is waiting in a blocking operation */\n#define REDIS_IO_WAIT 32    /* The client is waiting for Virtual Memory I/O */\n#define REDIS_DIRTY_CAS 64  /* Watched keys modified. EXEC will fail. */\n#define REDIS_CLOSE_AFTER_REPLY 128 /* Close after writing entire reply. */\n\n/* Client request types */\n#define REDIS_REQ_INLINE 1\n#define REDIS_REQ_MULTIBULK 2\n\n/* Slave replication state - slave side */\n#define REDIS_REPL_NONE 0   /* No active replication */\n#define REDIS_REPL_CONNECT 1    /* Must connect to master */\n#define REDIS_REPL_TRANSFER 2    /* Receiving .rdb from master */\n#define REDIS_REPL_CONNECTED 3  /* Connected to master */\n\n/* Slave replication state - from the point of view of master\n * Note that in SEND_BULK and ONLINE state the slave receives new updates\n * in its output queue. In the WAIT_BGSAVE state instead the server is waiting\n * to start the next background saving in order to send updates to it. */\n#define REDIS_REPL_WAIT_BGSAVE_START 3 /* master waits bgsave to start feeding it */\n#define REDIS_REPL_WAIT_BGSAVE_END 4 /* master waits bgsave to start bulk DB transmission */\n#define REDIS_REPL_SEND_BULK 5 /* master is sending the bulk DB */\n#define REDIS_REPL_ONLINE 6 /* bulk DB already transmitted, receive updates */\n\n/* List related stuff */\n#define REDIS_HEAD 0\n#define REDIS_TAIL 1\n\n/* Sort operations */\n#define REDIS_SORT_GET 0\n#define REDIS_SORT_ASC 1\n#define REDIS_SORT_DESC 2\n#define REDIS_SORTKEY_MAX 1024\n\n/* Log levels */\n#define REDIS_DEBUG 0\n#define REDIS_VERBOSE 1\n#define REDIS_NOTICE 2\n#define REDIS_WARNING 3\n\n/* Anti-warning macro... */\n#define REDIS_NOTUSED(V) ((void) V)\n\n#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */\n#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */\n\n/* Append only defines */\n#define APPENDFSYNC_NO 0\n#define APPENDFSYNC_ALWAYS 1\n#define APPENDFSYNC_EVERYSEC 2\n\n/* Zip structure related defaults */\n#define REDIS_HASH_MAX_ZIPMAP_ENTRIES 64\n#define REDIS_HASH_MAX_ZIPMAP_VALUE 512\n#define REDIS_LIST_MAX_ZIPLIST_ENTRIES 512\n#define REDIS_LIST_MAX_ZIPLIST_VALUE 64\n#define REDIS_SET_MAX_INTSET_ENTRIES 512\n\n/* Sets operations codes */\n#define REDIS_OP_UNION 0\n#define REDIS_OP_DIFF 1\n#define REDIS_OP_INTER 2\n\n/* Redis maxmemory strategies */\n#define REDIS_MAXMEMORY_VOLATILE_LRU 0\n#define REDIS_MAXMEMORY_VOLATILE_TTL 1\n#define REDIS_MAXMEMORY_VOLATILE_RANDOM 2\n#define REDIS_MAXMEMORY_ALLKEYS_LRU 3\n#define REDIS_MAXMEMORY_ALLKEYS_RANDOM 4\n#define REDIS_MAXMEMORY_NO_EVICTION 5\n\n/* We can print the stacktrace, so our assert is defined this way: */\n#define redisAssert(_e) ((_e)?(void)0 : (_redisAssert(#_e,__FILE__,__LINE__),_exit(1)))\n#define redisPanic(_e) _redisPanic(#_e,__FILE__,__LINE__),_exit(1)\nvoid _redisAssert(char *estr, char *file, int line);\nvoid _redisPanic(char *msg, char *file, int line);\n\n/*-----------------------------------------------------------------------------\n * Data types\n *----------------------------------------------------------------------------*/\n\n/* A redis object, that is a type able to hold a string / list / set */\n\n/* The actual Redis Object */\n#define REDIS_LRU_CLOCK_MAX ((1<<21)-1) /* Max value of obj->lru */\n#define REDIS_LRU_CLOCK_RESOLUTION 10 /* LRU clock resolution in seconds */\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned storage:2;     /* REDIS_VM_MEMORY or REDIS_VM_SWAPPING */\n    unsigned encoding:4;\n    unsigned lru:22;        /* lru time (relative to server.lruclock) */\n    int refcount;\n    void *ptr;\n    /* VM fields are only allocated if VM is active, otherwise the\n     * object allocation function will just allocate\n     * sizeof(redisObjct) minus sizeof(redisObjectVM), so using\n     * Redis without VM active will not have any overhead. */\n} robj;\n\n/* The VM pointer structure - identifies an object in the swap file.\n *\n * This object is stored in place of the value\n * object in the main key->value hash table representing a database.\n * Note that the first fields (type, storage) are the same as the redisObject\n * structure so that vmPointer strucuters can be accessed even when casted\n * as redisObject structures.\n *\n * This is useful as we don't know if a value object is or not on disk, but we\n * are always able to read obj->storage to check this. For vmPointer\n * structures \"type\" is set to REDIS_VMPOINTER (even if without this field\n * is still possible to check the kind of object from the value of 'storage').*/\ntypedef struct vmPointer {\n    unsigned type:4;\n    unsigned storage:2; /* REDIS_VM_SWAPPED or REDIS_VM_LOADING */\n    unsigned notused:26;\n    unsigned int vtype; /* type of the object stored in the swap file */\n    off_t page;         /* the page at witch the object is stored on disk */\n    off_t usedpages;    /* number of pages used on disk */\n} vmpointer;\n\n/* Macro used to initalize a Redis object allocated on the stack.\n * Note that this macro is taken near the structure definition to make sure\n * we'll update it when the structure is changed, to avoid bugs like\n * bug #85 introduced exactly in this way. */\n#define initStaticStringObject(_var,_ptr) do { \\\n    _var.refcount = 1; \\\n    _var.type = REDIS_STRING; \\\n    _var.encoding = REDIS_ENCODING_RAW; \\\n    _var.ptr = _ptr; \\\n    _var.storage = REDIS_VM_MEMORY; \\\n} while(0);\n\ntypedef struct redisDb {\n    dict *dict;                 /* The keyspace for this DB */\n    dict *expires;              /* Timeout of keys with a timeout set */\n    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */\n    dict *io_keys;              /* Keys with clients waiting for VM I/O */\n    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */\n    int id;\n} redisDb;\n\n/* Client MULTI/EXEC state */\ntypedef struct multiCmd {\n    robj **argv;\n    int argc;\n    struct redisCommand *cmd;\n} multiCmd;\n\ntypedef struct multiState {\n    multiCmd *commands;     /* Array of MULTI commands */\n    int count;              /* Total number of MULTI commands */\n} multiState;\n\ntypedef struct blockingState {\n    robj **keys;            /* The key we are waiting to terminate a blocking\n                             * operation such as BLPOP. Otherwise NULL. */\n    int count;              /* Number of blocking keys */\n    time_t timeout;         /* Blocking operation timeout. If UNIX current time\n                             * is >= timeout then the operation timed out. */\n    robj *target;           /* The key that should receive the element,\n                             * for BRPOPLPUSH. */\n} blockingState;\n\n/* With multiplexing we need to take per-clinet state.\n * Clients are taken in a liked list. */\ntypedef struct redisClient {\n    int fd;\n    redisDb *db;\n    int dictid;\n    sds querybuf;\n    int argc;\n    robj **argv;\n    int reqtype;\n    int multibulklen;       /* number of multi bulk arguments left to read */\n    long bulklen;           /* length of bulk argument in multi bulk request */\n    list *reply;\n    int sentlen;\n    time_t lastinteraction; /* time of the last interaction, used for timeout */\n    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */\n    int slaveseldb;         /* slave selected db, if this client is a slave */\n    int authenticated;      /* when requirepass is non-NULL */\n    int replstate;          /* replication state if this is a slave */\n    int repldbfd;           /* replication DB file descriptor */\n    long repldboff;         /* replication DB file offset */\n    off_t repldbsize;       /* replication DB file size */\n    multiState mstate;      /* MULTI/EXEC state */\n    blockingState bpop;   /* blocking state */\n    list *io_keys;          /* Keys this client is waiting to be loaded from the\n                             * swap file in order to continue. */\n    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */\n    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */\n    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */\n\n    /* Response buffer */\n    int bufpos;\n    char buf[REDIS_REPLY_CHUNK_BYTES];\n} redisClient;\n\nstruct saveparam {\n    time_t seconds;\n    int changes;\n};\n\nstruct sharedObjectsStruct {\n    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,\n    *colon, *nullbulk, *nullmultibulk, *queued,\n    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,\n    *outofrangeerr, *loadingerr, *plus,\n    *select0, *select1, *select2, *select3, *select4,\n    *select5, *select6, *select7, *select8, *select9,\n    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,\n    *mbulk4, *psubscribebulk, *punsubscribebulk,\n    *integers[REDIS_SHARED_INTEGERS];\n};\n\n/* Global server state structure */\nstruct redisServer {\n    pthread_t mainthread;\n    int port;\n    char *bindaddr;\n    char *unixsocket;\n    int ipfd;\n    int sofd;\n    redisDb *db;\n    long long dirty;            /* changes to DB from the last save */\n    long long dirty_before_bgsave; /* used to restore dirty on failed BGSAVE */\n    list *clients;\n    dict *commands;             /* Command table hahs table */\n    /* RDB / AOF loading information */\n    int loading;\n    off_t loading_total_bytes;\n    off_t loading_loaded_bytes;\n    time_t loading_start_time;\n    /* Fast pointers to often looked up command */\n    struct redisCommand *delCommand, *multiCommand;\n    list *slaves, *monitors;\n    char neterr[ANET_ERR_LEN];\n    aeEventLoop *el;\n    int cronloops;              /* number of times the cron function run */\n    time_t lastsave;                /* Unix time of last save succeeede */\n    /* Fields used only for stats */\n    time_t stat_starttime;          /* server start time */\n    long long stat_numcommands;     /* number of processed commands */\n    long long stat_numconnections;  /* number of connections received */\n    long long stat_expiredkeys;     /* number of expired keys */\n    long long stat_evictedkeys;     /* number of evicted keys (maxmemory) */\n    long long stat_keyspace_hits;   /* number of successful lookups of keys */\n    long long stat_keyspace_misses; /* number of failed lookups of keys */\n    /* Configuration */\n    int verbosity;\n    int glueoutputbuf;\n    int maxidletime;\n    int dbnum;\n    int daemonize;\n    int appendonly;\n    int appendfsync;\n    int no_appendfsync_on_rewrite;\n    int shutdown_asap;\n    time_t lastfsync;\n    int appendfd;\n    int appendseldb;\n    char *pidfile;\n    pid_t bgsavechildpid;\n    pid_t bgrewritechildpid;\n    sds bgrewritebuf; /* buffer taken by parent during oppend only rewrite */\n    sds aofbuf;       /* AOF buffer, written before entering the event loop */\n    struct saveparam *saveparams;\n    int saveparamslen;\n    char *logfile;\n    int syslog_enabled;\n    char *syslog_ident;\n    int syslog_facility;\n    char *dbfilename;\n    char *appendfilename;\n    char *requirepass;\n    int rdbcompression;\n    int activerehashing;\n    /* Replication related */\n    int isslave;\n    /* Slave specific fields */\n    char *masterauth;\n    char *masterhost;\n    int masterport;\n    redisClient *master;    /* client that is master for this slave */\n    int replstate;          /* replication status if the instance is a slave */\n    off_t repl_transfer_left;  /* bytes left reading .rdb  */\n    int repl_transfer_s;    /* slave -> master SYNC socket */\n    int repl_transfer_fd;   /* slave -> master SYNC temp file descriptor */\n    char *repl_transfer_tmpfile; /* slave-> master SYNC temp file name */\n    time_t repl_transfer_lastio; /* unix time of the latest read, for timeout */\n    int repl_serve_stale_data; /* Serve stale data when link is down? */\n    /* Limits */\n    unsigned int maxclients;\n    unsigned long long maxmemory;\n    int maxmemory_policy;\n    int maxmemory_samples;\n    /* Blocked clients */\n    unsigned int bpop_blocked_clients;\n    unsigned int vm_blocked_clients;\n    list *unblocked_clients;\n    /* Sort parameters - qsort_r() is only available under BSD so we\n     * have to take this state global, in order to pass it to sortCompare() */\n    int sort_desc;\n    int sort_alpha;\n    int sort_bypattern;\n    /* Virtual memory configuration */\n    int vm_enabled;\n    char *vm_swap_file;\n    off_t vm_page_size;\n    off_t vm_pages;\n    unsigned long long vm_max_memory;\n    /* Zip structure config */\n    size_t hash_max_zipmap_entries;\n    size_t hash_max_zipmap_value;\n    size_t list_max_ziplist_entries;\n    size_t list_max_ziplist_value;\n    size_t set_max_intset_entries;\n    /* Virtual memory state */\n    FILE *vm_fp;\n    int vm_fd;\n    off_t vm_next_page; /* Next probably empty page */\n    off_t vm_near_pages; /* Number of pages allocated sequentially */\n    unsigned char *vm_bitmap; /* Bitmap of free/used pages */\n    time_t unixtime;    /* Unix time sampled every second. */\n    /* Virtual memory I/O threads stuff */\n    /* An I/O thread process an element taken from the io_jobs queue and\n     * put the result of the operation in the io_done list. While the\n     * job is being processed, it's put on io_processing queue. */\n    list *io_newjobs; /* List of VM I/O jobs yet to be processed */\n    list *io_processing; /* List of VM I/O jobs being processed */\n    list *io_processed; /* List of VM I/O jobs already processed */\n    list *io_ready_clients; /* Clients ready to be unblocked. All keys loaded */\n    pthread_mutex_t io_mutex; /* lock to access io_jobs/io_done/io_thread_job */\n    pthread_mutex_t io_swapfile_mutex; /* So we can lseek + write */\n    pthread_attr_t io_threads_attr; /* attributes for threads creation */\n    int io_active_threads; /* Number of running I/O threads */\n    int vm_max_threads; /* Max number of I/O threads running at the same time */\n    /* Our main thread is blocked on the event loop, locking for sockets ready\n     * to be read or written, so when a threaded I/O operation is ready to be\n     * processed by the main thread, the I/O thread will use a unix pipe to\n     * awake the main thread. The followings are the two pipe FDs. */\n    int io_ready_pipe_read;\n    int io_ready_pipe_write;\n    /* Virtual memory stats */\n    unsigned long long vm_stats_used_pages;\n    unsigned long long vm_stats_swapped_objects;\n    unsigned long long vm_stats_swapouts;\n    unsigned long long vm_stats_swapins;\n    /* Pubsub */\n    dict *pubsub_channels; /* Map channels to list of subscribed clients */\n    list *pubsub_patterns; /* A list of pubsub_patterns */\n    /* Misc */\n    unsigned lruclock:22;        /* clock incrementing every minute, for LRU */\n    unsigned lruclock_padding:10;\n};\n\ntypedef struct pubsubPattern {\n    redisClient *client;\n    robj *pattern;\n} pubsubPattern;\n\ntypedef void redisCommandProc(redisClient *c);\ntypedef void redisVmPreloadProc(redisClient *c, struct redisCommand *cmd, int argc, robj **argv);\nstruct redisCommand {\n    char *name;\n    redisCommandProc *proc;\n    int arity;\n    int flags;\n    /* Use a function to determine which keys need to be loaded\n     * in the background prior to executing this command. Takes precedence\n     * over vm_firstkey and others, ignored when NULL */\n    redisVmPreloadProc *vm_preload_proc;\n    /* What keys should be loaded in background when calling this command? */\n    int vm_firstkey; /* The first argument that's a key (0 = no keys) */\n    int vm_lastkey;  /* THe last argument that's a key */\n    int vm_keystep;  /* The step between first and last key */\n};\n\nstruct redisFunctionSym {\n    char *name;\n    unsigned long pointer;\n};\n\ntypedef struct _redisSortObject {\n    robj *obj;\n    union {\n        double score;\n        robj *cmpobj;\n    } u;\n} redisSortObject;\n\ntypedef struct _redisSortOperation {\n    int type;\n    robj *pattern;\n} redisSortOperation;\n\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    robj *obj;\n    double score;\n    struct zskiplistNode *backward;\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\n    unsigned long length;\n    int level;\n} zskiplist;\n\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n\n/* VM threaded I/O request message */\n#define REDIS_IOJOB_LOAD 0          /* Load from disk to memory */\n#define REDIS_IOJOB_PREPARE_SWAP 1  /* Compute needed pages */\n#define REDIS_IOJOB_DO_SWAP 2       /* Swap from memory to disk */\ntypedef struct iojob {\n    int type;   /* Request type, REDIS_IOJOB_* */\n    redisDb *db;/* Redis database */\n    robj *key;  /* This I/O request is about swapping this key */\n    robj *id;   /* Unique identifier of this job:\n                   this is the object to swap for REDIS_IOREQ_*_SWAP, or the\n                   vmpointer objct for REDIS_IOREQ_LOAD. */\n    robj *val;  /* the value to swap for REDIS_IOREQ_*_SWAP, otherwise this\n                 * field is populated by the I/O thread for REDIS_IOREQ_LOAD. */\n    off_t page; /* Swap page where to read/write the object */\n    off_t pages; /* Swap pages needed to save object. PREPARE_SWAP return val */\n    int canceled; /* True if this command was canceled by blocking side of VM */\n    pthread_t thread; /* ID of the thread processing this entry */\n} iojob;\n\n/* Structure to hold list iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    unsigned char encoding;\n    unsigned char direction; /* Iteration direction */\n    unsigned char *zi;\n    listNode *ln;\n} listTypeIterator;\n\n/* Structure for an entry while iterating over a list. */\ntypedef struct {\n    listTypeIterator *li;\n    unsigned char *zi;  /* Entry in ziplist */\n    listNode *ln;       /* Entry in linked list */\n} listTypeEntry;\n\n/* Structure to hold set iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    int encoding;\n    int ii; /* intset iterator */\n    dictIterator *di;\n} setTypeIterator;\n\n/* Structure to hold hash iteration abstration. Note that iteration over\n * hashes involves both fields and values. Because it is possible that\n * not both are required, store pointers in the iterator to avoid\n * unnecessary memory allocation for fields/values. */\ntypedef struct {\n    int encoding;\n    unsigned char *zi;\n    unsigned char *zk, *zv;\n    unsigned int zklen, zvlen;\n\n    dictIterator *di;\n    dictEntry *de;\n} hashTypeIterator;\n\n#define REDIS_HASH_KEY 1\n#define REDIS_HASH_VALUE 2\n\n/*-----------------------------------------------------------------------------\n * Extern declarations\n *----------------------------------------------------------------------------*/\n\nextern struct redisServer server;\nextern struct sharedObjectsStruct shared;\nextern dictType setDictType;\nextern dictType zsetDictType;\nextern double R_Zero, R_PosInf, R_NegInf, R_Nan;\ndictType hashDictType;\n\n/*-----------------------------------------------------------------------------\n * Functions prototypes\n *----------------------------------------------------------------------------*/\n\n/* networking.c -- Networking and Client related operations */\nredisClient *createClient(int fd);\nvoid closeTimedoutClients(void);\nvoid freeClient(redisClient *c);\nvoid resetClient(redisClient *c);\nvoid sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid sendReplyToClientWritev(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid addReply(redisClient *c, robj *obj);\nvoid *addDeferredMultiBulkLength(redisClient *c);\nvoid setDeferredMultiBulkLength(redisClient *c, void *node, long length);\nvoid addReplySds(redisClient *c, sds s);\nvoid processInputBuffer(redisClient *c);\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid addReplyBulk(redisClient *c, robj *obj);\nvoid addReplyBulkCString(redisClient *c, char *s);\nvoid addReplyBulkCBuffer(redisClient *c, void *p, size_t len);\nvoid addReplyBulkLongLong(redisClient *c, long long ll);\nvoid acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid addReply(redisClient *c, robj *obj);\nvoid addReplySds(redisClient *c, sds s);\nvoid addReplyError(redisClient *c, char *err);\nvoid addReplyStatus(redisClient *c, char *status);\nvoid addReplyDouble(redisClient *c, double d);\nvoid addReplyLongLong(redisClient *c, long long ll);\nvoid addReplyMultiBulkLen(redisClient *c, long length);\nvoid *dupClientReplyValue(void *o);\n\n#ifdef __GNUC__\nvoid addReplyErrorFormat(redisClient *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\nvoid addReplyStatusFormat(redisClient *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nvoid addReplyErrorFormat(redisClient *c, const char *fmt, ...);\nvoid addReplyStatusFormat(redisClient *c, const char *fmt, ...);\n#endif\n\n/* List data type */\nvoid listTypeTryConversion(robj *subject, robj *value);\nvoid listTypePush(robj *subject, robj *value, int where);\nrobj *listTypePop(robj *subject, int where);\nunsigned long listTypeLength(robj *subject);\nlistTypeIterator *listTypeInitIterator(robj *subject, int index, unsigned char direction);\nvoid listTypeReleaseIterator(listTypeIterator *li);\nint listTypeNext(listTypeIterator *li, listTypeEntry *entry);\nrobj *listTypeGet(listTypeEntry *entry);\nvoid listTypeInsert(listTypeEntry *entry, robj *value, int where);\nint listTypeEqual(listTypeEntry *entry, robj *o);\nvoid listTypeDelete(listTypeEntry *entry);\nvoid listTypeConvert(robj *subject, int enc);\nvoid unblockClientWaitingData(redisClient *c);\nint handleClientsWaitingListPush(redisClient *c, robj *key, robj *ele);\nvoid popGenericCommand(redisClient *c, int where);\n\n/* MULTI/EXEC/WATCH... */\nvoid unwatchAllKeys(redisClient *c);\nvoid initClientMultiState(redisClient *c);\nvoid freeClientMultiState(redisClient *c);\nvoid queueMultiCommand(redisClient *c, struct redisCommand *cmd);\nvoid touchWatchedKey(redisDb *db, robj *key);\nvoid touchWatchedKeysOnFlush(int dbid);\n\n/* Redis object implementation */\nvoid decrRefCount(void *o);\nvoid incrRefCount(robj *o);\nvoid freeStringObject(robj *o);\nvoid freeListObject(robj *o);\nvoid freeSetObject(robj *o);\nvoid freeZsetObject(robj *o);\nvoid freeHashObject(robj *o);\nrobj *createObject(int type, void *ptr);\nrobj *createStringObject(char *ptr, size_t len);\nrobj *dupStringObject(robj *o);\nrobj *tryObjectEncoding(robj *o);\nrobj *getDecodedObject(robj *o);\nsize_t stringObjectLen(robj *o);\nrobj *createStringObjectFromLongLong(long long value);\nrobj *createListObject(void);\nrobj *createZiplistObject(void);\nrobj *createSetObject(void);\nrobj *createIntsetObject(void);\nrobj *createHashObject(void);\nrobj *createZsetObject(void);\nint getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg);\nint checkType(redisClient *c, robj *o, int type);\nint getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg);\nint getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg);\nint getLongLongFromObject(robj *o, long long *target);\nchar *strEncoding(int encoding);\nint compareStringObjects(robj *a, robj *b);\nint equalStringObjects(robj *a, robj *b);\nunsigned long estimateObjectIdleTime(robj *o);\n\n/* Synchronous I/O with timeout */\nint syncWrite(int fd, char *ptr, ssize_t size, int timeout);\nint syncRead(int fd, char *ptr, ssize_t size, int timeout);\nint syncReadLine(int fd, char *ptr, ssize_t size, int timeout);\nint fwriteBulkString(FILE *fp, char *s, unsigned long len);\nint fwriteBulkDouble(FILE *fp, double d);\nint fwriteBulkLongLong(FILE *fp, long long l);\nint fwriteBulkObject(FILE *fp, robj *obj);\n\n/* Replication */\nvoid replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);\nvoid replicationFeedMonitors(list *monitors, int dictid, robj **argv, int argc);\nint syncWithMaster(void);\nvoid updateSlavesWaitingBgsave(int bgsaveerr);\nvoid replicationCron(void);\n\n/* Generic persistence functions */\nvoid startLoading(FILE *fp);\nvoid loadingProgress(off_t pos);\nvoid stopLoading(void);\n\n/* RDB persistence */\nint rdbLoad(char *filename);\nint rdbSaveBackground(char *filename);\nvoid rdbRemoveTempFile(pid_t childpid);\nint rdbSave(char *filename);\nint rdbSaveObject(FILE *fp, robj *o);\noff_t rdbSavedObjectLen(robj *o);\noff_t rdbSavedObjectPages(robj *o);\nrobj *rdbLoadObject(int type, FILE *fp);\nvoid backgroundSaveDoneHandler(int statloc);\n\n/* AOF persistence */\nvoid flushAppendOnlyFile(void);\nvoid feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);\nvoid aofRemoveTempFile(pid_t childpid);\nint rewriteAppendOnlyFileBackground(void);\nint loadAppendOnlyFile(char *filename);\nvoid stopAppendOnly(void);\nint startAppendOnly(void);\nvoid backgroundRewriteDoneHandler(int statloc);\n\n/* Sorted sets data type */\nzskiplist *zslCreate(void);\nvoid zslFree(zskiplist *zsl);\nzskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);\n\n/* Core functions */\nvoid freeMemoryIfNeeded(void);\nint processCommand(redisClient *c);\nvoid setupSigSegvAction(void);\nstruct redisCommand *lookupCommand(sds name);\nstruct redisCommand *lookupCommandByCString(char *s);\nvoid call(redisClient *c, struct redisCommand *cmd);\nint prepareForShutdown();\nvoid redisLog(int level, const char *fmt, ...);\nvoid usage();\nvoid updateDictResizePolicy(void);\nint htNeedsResize(dict *dict);\nvoid oom(const char *msg);\nvoid populateCommandTable(void);\n\n/* Disk store */\nint dsOpen(void);\nint dsClose(void);\nint dsSet(redisDb *db, robj *key, robj *val);\nrobj *dsGet(redisDb *db, robj *key);\nint dsExists(redisDb *db, robj *key);\n\n/* Disk Store Cache */\nvoid vmInit(void);\nvoid vmMarkPagesFree(off_t page, off_t count);\nrobj *vmLoadObject(robj *o);\nrobj *vmPreviewObject(robj *o);\nint vmSwapOneObjectBlocking(void);\nint vmSwapOneObjectThreaded(void);\nint vmCanSwapOut(void);\nvoid vmThreadedIOCompletedJob(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid vmCancelThreadedIOJob(robj *o);\nvoid lockThreadedIO(void);\nvoid unlockThreadedIO(void);\nint vmSwapObjectThreaded(robj *key, robj *val, redisDb *db);\nvoid freeIOJob(iojob *j);\nvoid queueIOJob(iojob *j);\nint vmWriteObjectOnSwap(robj *o, off_t page);\nrobj *vmReadObjectFromSwap(off_t page, int type);\nvoid waitEmptyIOJobsQueue(void);\nvoid vmReopenSwapFile(void);\nint vmFreePage(off_t page);\nvoid zunionInterBlockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd, int argc, robj **argv);\nvoid execBlockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd, int argc, robj **argv);\nint blockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd);\nint dontWaitForSwappedKey(redisClient *c, robj *key);\nvoid handleClientsBlockedOnSwappedKey(redisDb *db, robj *key);\nvmpointer *vmSwapObjectBlocking(robj *val);\n\n/* Set data type */\nrobj *setTypeCreate(robj *value);\nint setTypeAdd(robj *subject, robj *value);\nint setTypeRemove(robj *subject, robj *value);\nint setTypeIsMember(robj *subject, robj *value);\nsetTypeIterator *setTypeInitIterator(robj *subject);\nvoid setTypeReleaseIterator(setTypeIterator *si);\nint setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele);\nrobj *setTypeNextObject(setTypeIterator *si);\nint setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele);\nunsigned long setTypeSize(robj *subject);\nvoid setTypeConvert(robj *subject, int enc);\n\n/* Hash data type */\nvoid convertToRealHash(robj *o);\nvoid hashTypeTryConversion(robj *subject, robj **argv, int start, int end);\nvoid hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);\nint hashTypeGet(robj *o, robj *key, robj **objval, unsigned char **v, unsigned int *vlen);\nrobj *hashTypeGetObject(robj *o, robj *key);\nint hashTypeExists(robj *o, robj *key);\nint hashTypeSet(robj *o, robj *key, robj *value);\nint hashTypeDelete(robj *o, robj *key);\nunsigned long hashTypeLength(robj *o);\nhashTypeIterator *hashTypeInitIterator(robj *subject);\nvoid hashTypeReleaseIterator(hashTypeIterator *hi);\nint hashTypeNext(hashTypeIterator *hi);\nint hashTypeCurrent(hashTypeIterator *hi, int what, robj **objval, unsigned char **v, unsigned int *vlen);\nrobj *hashTypeCurrentObject(hashTypeIterator *hi, int what);\nrobj *hashTypeLookupWriteOrCreate(redisClient *c, robj *key);\n\n/* Pub / Sub */\nint pubsubUnsubscribeAllChannels(redisClient *c, int notify);\nint pubsubUnsubscribeAllPatterns(redisClient *c, int notify);\nvoid freePubsubPattern(void *p);\nint listMatchPubsubPattern(void *a, void *b);\n\n/* Utility functions */\nint stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase);\nint stringmatch(const char *pattern, const char *string, int nocase);\nlong long memtoll(const char *p, int *err);\nint ll2string(char *s, size_t len, long long value);\nint isStringRepresentableAsLong(sds s, long *longval);\nint isStringRepresentableAsLongLong(sds s, long long *longval);\nint isObjectRepresentableAsLongLong(robj *o, long long *llongval);\n\n/* Configuration */\nvoid loadServerConfig(char *filename);\nvoid appendServerSaveParams(time_t seconds, int changes);\nvoid resetServerSaveParams();\n\n/* db.c -- Keyspace access API */\nint removeExpire(redisDb *db, robj *key);\nvoid propagateExpire(redisDb *db, robj *key);\nint expireIfNeeded(redisDb *db, robj *key);\ntime_t getExpire(redisDb *db, robj *key);\nvoid setExpire(redisDb *db, robj *key, time_t when);\nrobj *lookupKey(redisDb *db, robj *key);\nrobj *lookupKeyRead(redisDb *db, robj *key);\nrobj *lookupKeyWrite(redisDb *db, robj *key);\nrobj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply);\nrobj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply);\nint dbAdd(redisDb *db, robj *key, robj *val);\nint dbReplace(redisDb *db, robj *key, robj *val);\nint dbExists(redisDb *db, robj *key);\nrobj *dbRandomKey(redisDb *db);\nint dbDelete(redisDb *db, robj *key);\nlong long emptyDb();\nint selectDb(redisClient *c, int id);\n\n/* Git SHA1 */\nchar *redisGitSHA1(void);\nchar *redisGitDirty(void);\n\n/* Commands prototypes */\nvoid authCommand(redisClient *c);\nvoid pingCommand(redisClient *c);\nvoid echoCommand(redisClient *c);\nvoid setCommand(redisClient *c);\nvoid setnxCommand(redisClient *c);\nvoid setexCommand(redisClient *c);\nvoid getCommand(redisClient *c);\nvoid delCommand(redisClient *c);\nvoid existsCommand(redisClient *c);\nvoid setbitCommand(redisClient *c);\nvoid getbitCommand(redisClient *c);\nvoid setrangeCommand(redisClient *c);\nvoid getrangeCommand(redisClient *c);\nvoid incrCommand(redisClient *c);\nvoid decrCommand(redisClient *c);\nvoid incrbyCommand(redisClient *c);\nvoid decrbyCommand(redisClient *c);\nvoid selectCommand(redisClient *c);\nvoid randomkeyCommand(redisClient *c);\nvoid keysCommand(redisClient *c);\nvoid dbsizeCommand(redisClient *c);\nvoid lastsaveCommand(redisClient *c);\nvoid saveCommand(redisClient *c);\nvoid bgsaveCommand(redisClient *c);\nvoid bgrewriteaofCommand(redisClient *c);\nvoid shutdownCommand(redisClient *c);\nvoid moveCommand(redisClient *c);\nvoid renameCommand(redisClient *c);\nvoid renamenxCommand(redisClient *c);\nvoid lpushCommand(redisClient *c);\nvoid rpushCommand(redisClient *c);\nvoid lpushxCommand(redisClient *c);\nvoid rpushxCommand(redisClient *c);\nvoid linsertCommand(redisClient *c);\nvoid lpopCommand(redisClient *c);\nvoid rpopCommand(redisClient *c);\nvoid llenCommand(redisClient *c);\nvoid lindexCommand(redisClient *c);\nvoid lrangeCommand(redisClient *c);\nvoid ltrimCommand(redisClient *c);\nvoid typeCommand(redisClient *c);\nvoid lsetCommand(redisClient *c);\nvoid saddCommand(redisClient *c);\nvoid sremCommand(redisClient *c);\nvoid smoveCommand(redisClient *c);\nvoid sismemberCommand(redisClient *c);\nvoid scardCommand(redisClient *c);\nvoid spopCommand(redisClient *c);\nvoid srandmemberCommand(redisClient *c);\nvoid sinterCommand(redisClient *c);\nvoid sinterstoreCommand(redisClient *c);\nvoid sunionCommand(redisClient *c);\nvoid sunionstoreCommand(redisClient *c);\nvoid sdiffCommand(redisClient *c);\nvoid sdiffstoreCommand(redisClient *c);\nvoid syncCommand(redisClient *c);\nvoid flushdbCommand(redisClient *c);\nvoid flushallCommand(redisClient *c);\nvoid sortCommand(redisClient *c);\nvoid lremCommand(redisClient *c);\nvoid rpoplpushCommand(redisClient *c);\nvoid infoCommand(redisClient *c);\nvoid mgetCommand(redisClient *c);\nvoid monitorCommand(redisClient *c);\nvoid expireCommand(redisClient *c);\nvoid expireatCommand(redisClient *c);\nvoid getsetCommand(redisClient *c);\nvoid ttlCommand(redisClient *c);\nvoid persistCommand(redisClient *c);\nvoid slaveofCommand(redisClient *c);\nvoid debugCommand(redisClient *c);\nvoid msetCommand(redisClient *c);\nvoid msetnxCommand(redisClient *c);\nvoid zaddCommand(redisClient *c);\nvoid zincrbyCommand(redisClient *c);\nvoid zrangeCommand(redisClient *c);\nvoid zrangebyscoreCommand(redisClient *c);\nvoid zrevrangebyscoreCommand(redisClient *c);\nvoid zcountCommand(redisClient *c);\nvoid zrevrangeCommand(redisClient *c);\nvoid zcardCommand(redisClient *c);\nvoid zremCommand(redisClient *c);\nvoid zscoreCommand(redisClient *c);\nvoid zremrangebyscoreCommand(redisClient *c);\nvoid multiCommand(redisClient *c);\nvoid execCommand(redisClient *c);\nvoid discardCommand(redisClient *c);\nvoid blpopCommand(redisClient *c);\nvoid brpopCommand(redisClient *c);\nvoid brpoplpushCommand(redisClient *c);\nvoid appendCommand(redisClient *c);\nvoid strlenCommand(redisClient *c);\nvoid zrankCommand(redisClient *c);\nvoid zrevrankCommand(redisClient *c);\nvoid hsetCommand(redisClient *c);\nvoid hsetnxCommand(redisClient *c);\nvoid hgetCommand(redisClient *c);\nvoid hmsetCommand(redisClient *c);\nvoid hmgetCommand(redisClient *c);\nvoid hdelCommand(redisClient *c);\nvoid hlenCommand(redisClient *c);\nvoid zremrangebyrankCommand(redisClient *c);\nvoid zunionstoreCommand(redisClient *c);\nvoid zinterstoreCommand(redisClient *c);\nvoid hkeysCommand(redisClient *c);\nvoid hvalsCommand(redisClient *c);\nvoid hgetallCommand(redisClient *c);\nvoid hexistsCommand(redisClient *c);\nvoid configCommand(redisClient *c);\nvoid hincrbyCommand(redisClient *c);\nvoid subscribeCommand(redisClient *c);\nvoid unsubscribeCommand(redisClient *c);\nvoid psubscribeCommand(redisClient *c);\nvoid punsubscribeCommand(redisClient *c);\nvoid publishCommand(redisClient *c);\nvoid watchCommand(redisClient *c);\nvoid unwatchCommand(redisClient *c);\n\n#if defined(__GNUC__)\nvoid *calloc(size_t count, size_t size) __attribute__ ((deprecated));\nvoid free(void *ptr) __attribute__ ((deprecated));\nvoid *malloc(size_t size) __attribute__ ((deprecated));\nvoid *realloc(void *ptr, size_t size) __attribute__ ((deprecated));\n#endif\n\n#endif\n"], "fixing_code": ["/* diskstore.c implements a very simple disk backed key-value store used\n * by Redis for the \"disk\" backend. This implementation uses the filesystem\n * to store key/value pairs. Every file represents a given key.\n *\n * The key path is calculated using the SHA1 of the key name. For instance\n * the key \"foo\" is stored as a file name called:\n *\n *  /0b/ee/0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\n *\n * The couples of characters from the hex output of SHA1 are also used\n * to locate two two levels of directories to store the file (as most\n * filesystems are not able to handle too many files in a single dir).\n *\n * In the end there are 65536 final directories (256 directories inside\n * every 256 top level directories), so that with 1 billion of files every\n * directory will contain in the average 15258 entires, that is ok with\n * most filesystems implementation.\n *\n * Note that since Redis supports multiple databases, the actual key name\n * is:\n *\n *  /0b/ee/<dbid>_0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\n *\n *  so for instance if the key is inside DB 0:\n *\n *  /0b/ee/0_0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\n *\n * The actaul implementation of this disk store is highly dependant to the\n * filesystem implementation itself. This implementation may be replaced by\n * a B+TREE implementation in future implementations.\n *\n * Data ok every key is serialized using the same format used for .rdb\n * serialization. Everything is serialized on every entry: key name,\n * ttl information in case of keys with an associated expire time, and the\n * serialized value itself.\n *\n * Because the format is the same of the .rdb files it is trivial to create\n * an .rdb file starting from this format just by mean of scanning the\n * directories and concatenating entries, with the sole addition of an\n * .rdb header at the start and the end-of-db opcode at the end.\n *\n * -------------------------------------------------------------------------\n *\n * Copyright (c) 2010-2011, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"redis.h\"\n\n#include <fcntl.h>\n#include <sys/stat.h>\n\nint dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.ds_path;\n\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n\n    /* Directory already in place. Assume everything is ok. */\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n\n    /* File exists but it's not a directory */\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n\n    /* New disk store, create the directory structure now, as creating\n     * them in a lazy way is not a good idea, after very few insertions\n     * we'll need most of the 65536 directories anyway. */\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}\n\nint dsClose(void) {\n    return REDIS_OK;\n}\n\nint dsSet(redisDb *db, robj *key, robj *val) {\n}\n\nrobj *dsGet(redisDb *db, robj *key) {\n}\n\nint dsExists(redisDb *db, robj *key) {\n}\n", "#include \"redis.h\"\n#include <sys/uio.h>\n\nvoid *dupClientReplyValue(void *o) {\n    incrRefCount((robj*)o);\n    return o;\n}\n\nint listMatchObjects(void *a, void *b) {\n    return equalStringObjects(a,b);\n}\n\nredisClient *createClient(int fd) {\n    redisClient *c = zmalloc(sizeof(redisClient));\n    c->bufpos = 0;\n\n    anetNonBlock(NULL,fd);\n    anetTcpNoDelay(NULL,fd);\n    if (!c) return NULL;\n    if (aeCreateFileEvent(server.el,fd,AE_READABLE,\n        readQueryFromClient, c) == AE_ERR)\n    {\n        close(fd);\n        zfree(c);\n        return NULL;\n    }\n\n    selectDb(c,0);\n    c->fd = fd;\n    c->querybuf = sdsempty();\n    c->reqtype = 0;\n    c->argc = 0;\n    c->argv = NULL;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n    c->sentlen = 0;\n    c->flags = 0;\n    c->lastinteraction = time(NULL);\n    c->authenticated = 0;\n    c->replstate = REDIS_REPL_NONE;\n    c->reply = listCreate();\n    listSetFreeMethod(c->reply,decrRefCount);\n    listSetDupMethod(c->reply,dupClientReplyValue);\n    c->bpop.keys = NULL;\n    c->bpop.count = 0;\n    c->bpop.timeout = 0;\n    c->bpop.target = NULL;\n    c->io_keys = listCreate();\n    c->watched_keys = listCreate();\n    listSetFreeMethod(c->io_keys,decrRefCount);\n    c->pubsub_channels = dictCreate(&setDictType,NULL);\n    c->pubsub_patterns = listCreate();\n    listSetFreeMethod(c->pubsub_patterns,decrRefCount);\n    listSetMatchMethod(c->pubsub_patterns,listMatchObjects);\n    listAddNodeTail(server.clients,c);\n    initClientMultiState(c);\n    return c;\n}\n\n/* Set the event loop to listen for write events on the client's socket.\n * Typically gets called every time a reply is built. */\nint _installWriteEvent(redisClient *c) {\n    /* When CLOSE_AFTER_REPLY is set, no more replies may be added! */\n    redisAssert(!(c->flags & REDIS_CLOSE_AFTER_REPLY));\n\n    if (c->fd <= 0) return REDIS_ERR;\n    if (c->bufpos == 0 && listLength(c->reply) == 0 &&\n        (c->replstate == REDIS_REPL_NONE ||\n         c->replstate == REDIS_REPL_ONLINE) &&\n        aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,\n        sendReplyToClient, c) == AE_ERR) return REDIS_ERR;\n    return REDIS_OK;\n}\n\n/* Create a duplicate of the last object in the reply list when\n * it is not exclusively owned by the reply list. */\nrobj *dupLastObjectIfNeeded(list *reply) {\n    robj *new, *cur;\n    listNode *ln;\n    redisAssert(listLength(reply) > 0);\n    ln = listLast(reply);\n    cur = listNodeValue(ln);\n    if (cur->refcount > 1) {\n        new = dupStringObject(cur);\n        decrRefCount(cur);\n        listNodeValue(ln) = new;\n    }\n    return listNodeValue(ln);\n}\n\nint _addReplyToBuffer(redisClient *c, char *s, size_t len) {\n    size_t available = sizeof(c->buf)-c->bufpos;\n\n    /* If there already are entries in the reply list, we cannot\n     * add anything more to the static buffer. */\n    if (listLength(c->reply) > 0) return REDIS_ERR;\n\n    /* Check that the buffer has enough space available for this string. */\n    if (len > available) return REDIS_ERR;\n\n    memcpy(c->buf+c->bufpos,s,len);\n    c->bufpos+=len;\n    return REDIS_OK;\n}\n\nvoid _addReplyObjectToList(redisClient *c, robj *o) {\n    robj *tail;\n    if (listLength(c->reply) == 0) {\n        incrRefCount(o);\n        listAddNodeTail(c->reply,o);\n    } else {\n        tail = listNodeValue(listLast(c->reply));\n\n        /* Append to this object when possible. */\n        if (tail->ptr != NULL &&\n            sdslen(tail->ptr)+sdslen(o->ptr) <= REDIS_REPLY_CHUNK_BYTES)\n        {\n            tail = dupLastObjectIfNeeded(c->reply);\n            tail->ptr = sdscatlen(tail->ptr,o->ptr,sdslen(o->ptr));\n        } else {\n            incrRefCount(o);\n            listAddNodeTail(c->reply,o);\n        }\n    }\n}\n\n/* This method takes responsibility over the sds. When it is no longer\n * needed it will be free'd, otherwise it ends up in a robj. */\nvoid _addReplySdsToList(redisClient *c, sds s) {\n    robj *tail;\n    if (listLength(c->reply) == 0) {\n        listAddNodeTail(c->reply,createObject(REDIS_STRING,s));\n    } else {\n        tail = listNodeValue(listLast(c->reply));\n\n        /* Append to this object when possible. */\n        if (tail->ptr != NULL &&\n            sdslen(tail->ptr)+sdslen(s) <= REDIS_REPLY_CHUNK_BYTES)\n        {\n            tail = dupLastObjectIfNeeded(c->reply);\n            tail->ptr = sdscatlen(tail->ptr,s,sdslen(s));\n            sdsfree(s);\n        } else {\n            listAddNodeTail(c->reply,createObject(REDIS_STRING,s));\n        }\n    }\n}\n\nvoid _addReplyStringToList(redisClient *c, char *s, size_t len) {\n    robj *tail;\n    if (listLength(c->reply) == 0) {\n        listAddNodeTail(c->reply,createStringObject(s,len));\n    } else {\n        tail = listNodeValue(listLast(c->reply));\n\n        /* Append to this object when possible. */\n        if (tail->ptr != NULL &&\n            sdslen(tail->ptr)+len <= REDIS_REPLY_CHUNK_BYTES)\n        {\n            tail = dupLastObjectIfNeeded(c->reply);\n            tail->ptr = sdscatlen(tail->ptr,s,len);\n        } else {\n            listAddNodeTail(c->reply,createStringObject(s,len));\n        }\n    }\n}\n\nvoid addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.ds_enabled || obj->storage == REDIS_VM_MEMORY);\n\n    /* This is an important place where we can avoid copy-on-write\n     * when there is a saving child running, avoiding touching the\n     * refcount field of the object if it's not needed.\n     *\n     * If the encoding is RAW and there is room in the static buffer\n     * we'll be able to send the object to the client without\n     * messing with its page. */\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        /* FIXME: convert the long into string and use _addReplyToBuffer()\n         * instead of calling getDecodedObject. As this place in the\n         * code is too performance critical. */\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}\n\nvoid addReplySds(redisClient *c, sds s) {\n    if (_installWriteEvent(c) != REDIS_OK) {\n        /* The caller expects the sds to be free'd. */\n        sdsfree(s);\n        return;\n    }\n    if (_addReplyToBuffer(c,s,sdslen(s)) == REDIS_OK) {\n        sdsfree(s);\n    } else {\n        /* This method free's the sds when it is no longer needed. */\n        _addReplySdsToList(c,s);\n    }\n}\n\nvoid addReplyString(redisClient *c, char *s, size_t len) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    if (_addReplyToBuffer(c,s,len) != REDIS_OK)\n        _addReplyStringToList(c,s,len);\n}\n\nvoid _addReplyError(redisClient *c, char *s, size_t len) {\n    addReplyString(c,\"-ERR \",5);\n    addReplyString(c,s,len);\n    addReplyString(c,\"\\r\\n\",2);\n}\n\nvoid addReplyError(redisClient *c, char *err) {\n    _addReplyError(c,err,strlen(err));\n}\n\nvoid addReplyErrorFormat(redisClient *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    _addReplyError(c,s,sdslen(s));\n    sdsfree(s);\n}\n\nvoid _addReplyStatus(redisClient *c, char *s, size_t len) {\n    addReplyString(c,\"+\",1);\n    addReplyString(c,s,len);\n    addReplyString(c,\"\\r\\n\",2);\n}\n\nvoid addReplyStatus(redisClient *c, char *status) {\n    _addReplyStatus(c,status,strlen(status));\n}\n\nvoid addReplyStatusFormat(redisClient *c, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    _addReplyStatus(c,s,sdslen(s));\n    sdsfree(s);\n}\n\n/* Adds an empty object to the reply list that will contain the multi bulk\n * length, which is not known when this function is called. */\nvoid *addDeferredMultiBulkLength(redisClient *c) {\n    /* Note that we install the write event here even if the object is not\n     * ready to be sent, since we are sure that before returning to the\n     * event loop setDeferredMultiBulkLength() will be called. */\n    if (_installWriteEvent(c) != REDIS_OK) return NULL;\n    listAddNodeTail(c->reply,createObject(REDIS_STRING,NULL));\n    return listLast(c->reply);\n}\n\n/* Populate the length object and try glueing it to the next chunk. */\nvoid setDeferredMultiBulkLength(redisClient *c, void *node, long length) {\n    listNode *ln = (listNode*)node;\n    robj *len, *next;\n\n    /* Abort when *node is NULL (see addDeferredMultiBulkLength). */\n    if (node == NULL) return;\n\n    len = listNodeValue(ln);\n    len->ptr = sdscatprintf(sdsempty(),\"*%ld\\r\\n\",length);\n    if (ln->next != NULL) {\n        next = listNodeValue(ln->next);\n\n        /* Only glue when the next node is non-NULL (an sds in this case) */\n        if (next->ptr != NULL) {\n            len->ptr = sdscatlen(len->ptr,next->ptr,sdslen(next->ptr));\n            listDelNode(c->reply,ln->next);\n        }\n    }\n}\n\n/* Add a duble as a bulk reply */\nvoid addReplyDouble(redisClient *c, double d) {\n    char dbuf[128], sbuf[128];\n    int dlen, slen;\n    dlen = snprintf(dbuf,sizeof(dbuf),\"%.17g\",d);\n    slen = snprintf(sbuf,sizeof(sbuf),\"$%d\\r\\n%s\\r\\n\",dlen,dbuf);\n    addReplyString(c,sbuf,slen);\n}\n\n/* Add a long long as integer reply or bulk len / multi bulk count.\n * Basically this is used to output <prefix><long long><crlf>. */\nvoid _addReplyLongLong(redisClient *c, long long ll, char prefix) {\n    char buf[128];\n    int len;\n    buf[0] = prefix;\n    len = ll2string(buf+1,sizeof(buf)-1,ll);\n    buf[len+1] = '\\r';\n    buf[len+2] = '\\n';\n    addReplyString(c,buf,len+3);\n}\n\nvoid addReplyLongLong(redisClient *c, long long ll) {\n    _addReplyLongLong(c,ll,':');\n}\n\nvoid addReplyMultiBulkLen(redisClient *c, long length) {\n    _addReplyLongLong(c,length,'*');\n}\n\n/* Create the length prefix of a bulk reply, example: $2234 */\nvoid addReplyBulkLen(redisClient *c, robj *obj) {\n    size_t len;\n\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        len = sdslen(obj->ptr);\n    } else {\n        long n = (long)obj->ptr;\n\n        /* Compute how many bytes will take this integer as a radix 10 string */\n        len = 1;\n        if (n < 0) {\n            len++;\n            n = -n;\n        }\n        while((n = n/10) != 0) {\n            len++;\n        }\n    }\n    _addReplyLongLong(c,len,'$');\n}\n\n/* Add a Redis Object as a bulk reply */\nvoid addReplyBulk(redisClient *c, robj *obj) {\n    addReplyBulkLen(c,obj);\n    addReply(c,obj);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C buffer as bulk reply */\nvoid addReplyBulkCBuffer(redisClient *c, void *p, size_t len) {\n    _addReplyLongLong(c,len,'$');\n    addReplyString(c,p,len);\n    addReply(c,shared.crlf);\n}\n\n/* Add a C nul term string as bulk reply */\nvoid addReplyBulkCString(redisClient *c, char *s) {\n    if (s == NULL) {\n        addReply(c,shared.nullbulk);\n    } else {\n        addReplyBulkCBuffer(c,s,strlen(s));\n    }\n}\n\n/* Add a long long as a bulk reply */\nvoid addReplyBulkLongLong(redisClient *c, long long ll) {\n    char buf[64];\n    int len;\n\n    len = ll2string(buf,64,ll);\n    addReplyBulkCBuffer(c,buf,len);\n}\n\nstatic void acceptCommonHandler(int fd) {\n    redisClient *c;\n    if ((c = createClient(fd)) == NULL) {\n        redisLog(REDIS_WARNING,\"Error allocating resoures for the client\");\n        close(fd); /* May be already closed, just ingore errors */\n        return;\n    }\n    /* If maxclient directive is set and this is one client more... close the\n     * connection. Note that we create the client instead to check before\n     * for this condition, since now the socket is already set in nonblocking\n     * mode and we can send an error for free using the Kernel I/O */\n    if (server.maxclients && listLength(server.clients) > server.maxclients) {\n        char *err = \"-ERR max number of clients reached\\r\\n\";\n\n        /* That's a best effort error message, don't check write errors */\n        if (write(c->fd,err,strlen(err)) == -1) {\n            /* Nothing to do, Just to avoid the warning... */\n        }\n        freeClient(c);\n        return;\n    }\n    server.stat_numconnections++;\n}\n\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cport, cfd;\n    char cip[128];\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n    REDIS_NOTUSED(privdata);\n\n    cfd = anetTcpAccept(server.neterr, fd, cip, &cport);\n    if (cfd == AE_ERR) {\n        redisLog(REDIS_VERBOSE,\"Accepting client connection: %s\", server.neterr);\n        return;\n    }\n    redisLog(REDIS_VERBOSE,\"Accepted %s:%d\", cip, cport);\n    acceptCommonHandler(cfd);\n}\n\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {\n    int cfd;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n    REDIS_NOTUSED(privdata);\n\n    cfd = anetUnixAccept(server.neterr, fd);\n    if (cfd == AE_ERR) {\n        redisLog(REDIS_VERBOSE,\"Accepting client connection: %s\", server.neterr);\n        return;\n    }\n    redisLog(REDIS_VERBOSE,\"Accepted connection to %s\", server.unixsocket);\n    acceptCommonHandler(cfd);\n}\n\n\nstatic void freeClientArgv(redisClient *c) {\n    int j;\n    for (j = 0; j < c->argc; j++)\n        decrRefCount(c->argv[j]);\n    c->argc = 0;\n}\n\nvoid freeClient(redisClient *c) {\n    listNode *ln;\n\n    /* Note that if the client we are freeing is blocked into a blocking\n     * call, we have to set querybuf to NULL *before* to call\n     * unblockClientWaitingData() to avoid processInputBuffer() will get\n     * called. Also it is important to remove the file events after\n     * this, because this call adds the READABLE event. */\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n\n    /* UNWATCH all the keys */\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    /* Unsubscribe from all the pubsub channels */\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    /* Obvious cleanup */\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    /* Remove from the list of clients */\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    /* Remove from the list of clients waiting for swapped keys, or ready\n     * to be restarted, but not yet woken up again. */\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.ds_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n\n            /* When this client is waiting to be woken up (REDIS_IO_WAIT),\n             * it should be present in the list io_ready_clients */\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.cache_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    /* Master/slave cleanup.\n     * Case 1: we lost the connection with a slave. */\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n\n    /* Case 2: we lost the connection with the master. */\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        /* FIXME */\n        server.replstate = REDIS_REPL_CONNECT;\n        /* Since we lost the connection with the master, we should also\n         * close the connection with all our slaves if we have any, so\n         * when we'll resync with the master the other slaves will sync again\n         * with us as well. Note that also when the slave is not connected\n         * to the master it will keep refusing connections by other slaves. */\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    /* Release memory */\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}\n\nvoid sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {\n    redisClient *c = privdata;\n    int nwritten = 0, totwritten = 0, objlen;\n    robj *o;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n\n    /* Use writev() if we have enough buffers to send */\n    if (!server.glueoutputbuf &&\n        listLength(c->reply) > REDIS_WRITEV_THRESHOLD &&\n        !(c->flags & REDIS_MASTER))\n    {\n        sendReplyToClientWritev(el, fd, privdata, mask);\n        return;\n    }\n\n    while(c->bufpos > 0 || listLength(c->reply)) {\n        if (c->bufpos > 0) {\n            if (c->flags & REDIS_MASTER) {\n                /* Don't reply to a master */\n                nwritten = c->bufpos - c->sentlen;\n            } else {\n                nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);\n                if (nwritten <= 0) break;\n            }\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If the buffer was sent, set bufpos to zero to continue with\n             * the remainder of the reply. */\n            if (c->sentlen == c->bufpos) {\n                c->bufpos = 0;\n                c->sentlen = 0;\n            }\n        } else {\n            o = listNodeValue(listFirst(c->reply));\n            objlen = sdslen(o->ptr);\n\n            if (objlen == 0) {\n                listDelNode(c->reply,listFirst(c->reply));\n                continue;\n            }\n\n            if (c->flags & REDIS_MASTER) {\n                /* Don't reply to a master */\n                nwritten = objlen - c->sentlen;\n            } else {\n                nwritten = write(fd, ((char*)o->ptr)+c->sentlen,objlen-c->sentlen);\n                if (nwritten <= 0) break;\n            }\n            c->sentlen += nwritten;\n            totwritten += nwritten;\n\n            /* If we fully sent the object on head go to the next one */\n            if (c->sentlen == objlen) {\n                listDelNode(c->reply,listFirst(c->reply));\n                c->sentlen = 0;\n            }\n        }\n        /* Note that we avoid to send more thank REDIS_MAX_WRITE_PER_EVENT\n         * bytes, in a single threaded server it's a good idea to serve\n         * other clients as well, even if a very large request comes from\n         * super fast link that is always able to accept data (in real world\n         * scenario think about 'KEYS *' against the loopback interfae) */\n        if (totwritten > REDIS_MAX_WRITE_PER_EVENT) break;\n    }\n    if (nwritten == -1) {\n        if (errno == EAGAIN) {\n            nwritten = 0;\n        } else {\n            redisLog(REDIS_VERBOSE,\n                \"Error writing to client: %s\", strerror(errno));\n            freeClient(c);\n            return;\n        }\n    }\n    if (totwritten > 0) c->lastinteraction = time(NULL);\n    if (listLength(c->reply) == 0) {\n        c->sentlen = 0;\n        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n\n        /* Close connection after entire reply has been sent. */\n        if (c->flags & REDIS_CLOSE_AFTER_REPLY) freeClient(c);\n    }\n}\n\nvoid sendReplyToClientWritev(aeEventLoop *el, int fd, void *privdata, int mask)\n{\n    redisClient *c = privdata;\n    int nwritten = 0, totwritten = 0, objlen, willwrite;\n    robj *o;\n    struct iovec iov[REDIS_WRITEV_IOVEC_COUNT];\n    int offset, ion = 0;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n\n    listNode *node;\n    while (listLength(c->reply)) {\n        offset = c->sentlen;\n        ion = 0;\n        willwrite = 0;\n\n        /* fill-in the iov[] array */\n        for(node = listFirst(c->reply); node; node = listNextNode(node)) {\n            o = listNodeValue(node);\n            objlen = sdslen(o->ptr);\n\n            if (totwritten + objlen - offset > REDIS_MAX_WRITE_PER_EVENT)\n                break;\n\n            if(ion == REDIS_WRITEV_IOVEC_COUNT)\n                break; /* no more iovecs */\n\n            iov[ion].iov_base = ((char*)o->ptr) + offset;\n            iov[ion].iov_len = objlen - offset;\n            willwrite += objlen - offset;\n            offset = 0; /* just for the first item */\n            ion++;\n        }\n\n        if(willwrite == 0)\n            break;\n\n        /* write all collected blocks at once */\n        if((nwritten = writev(fd, iov, ion)) < 0) {\n            if (errno != EAGAIN) {\n                redisLog(REDIS_VERBOSE,\n                         \"Error writing to client: %s\", strerror(errno));\n                freeClient(c);\n                return;\n            }\n            break;\n        }\n\n        totwritten += nwritten;\n        offset = c->sentlen;\n\n        /* remove written robjs from c->reply */\n        while (nwritten && listLength(c->reply)) {\n            o = listNodeValue(listFirst(c->reply));\n            objlen = sdslen(o->ptr);\n\n            if(nwritten >= objlen - offset) {\n                listDelNode(c->reply, listFirst(c->reply));\n                nwritten -= objlen - offset;\n                c->sentlen = 0;\n            } else {\n                /* partial write */\n                c->sentlen += nwritten;\n                break;\n            }\n            offset = 0;\n        }\n    }\n\n    if (totwritten > 0)\n        c->lastinteraction = time(NULL);\n\n    if (listLength(c->reply) == 0) {\n        c->sentlen = 0;\n        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    }\n}\n\n/* resetClient prepare the client to process the next command */\nvoid resetClient(redisClient *c) {\n    freeClientArgv(c);\n    c->reqtype = 0;\n    c->multibulklen = 0;\n    c->bulklen = -1;\n}\n\nvoid closeTimedoutClients(void) {\n    redisClient *c;\n    listNode *ln;\n    time_t now = time(NULL);\n    listIter li;\n\n    listRewind(server.clients,&li);\n    while ((ln = listNext(&li)) != NULL) {\n        c = listNodeValue(ln);\n        if (server.maxidletime &&\n            !(c->flags & REDIS_SLAVE) &&    /* no timeout for slaves */\n            !(c->flags & REDIS_MASTER) &&   /* no timeout for masters */\n            !(c->flags & REDIS_BLOCKED) &&  /* no timeout for BLPOP */\n            dictSize(c->pubsub_channels) == 0 && /* no timeout for pubsub */\n            listLength(c->pubsub_patterns) == 0 &&\n            (now - c->lastinteraction > server.maxidletime))\n        {\n            redisLog(REDIS_VERBOSE,\"Closing idle client\");\n            freeClient(c);\n        } else if (c->flags & REDIS_BLOCKED) {\n            if (c->bpop.timeout != 0 && c->bpop.timeout < now) {\n                addReply(c,shared.nullmultibulk);\n                unblockClientWaitingData(c);\n            }\n        }\n    }\n}\n\nint processInlineBuffer(redisClient *c) {\n    char *newline = strstr(c->querybuf,\"\\r\\n\");\n    int argc, j;\n    sds *argv;\n    size_t querylen;\n\n    /* Nothing to do without a \\r\\n */\n    if (newline == NULL)\n        return REDIS_ERR;\n\n    /* Split the input buffer up to the \\r\\n */\n    querylen = newline-(c->querybuf);\n    argv = sdssplitlen(c->querybuf,querylen,\" \",1,&argc);\n\n    /* Leave data after the first line of the query in the buffer */\n    c->querybuf = sdsrange(c->querybuf,querylen+2,-1);\n\n    /* Setup argv array on client structure */\n    if (c->argv) zfree(c->argv);\n    c->argv = zmalloc(sizeof(robj*)*argc);\n\n    /* Create redis objects for all arguments. */\n    for (c->argc = 0, j = 0; j < argc; j++) {\n        if (sdslen(argv[j])) {\n            c->argv[c->argc] = createObject(REDIS_STRING,argv[j]);\n            c->argc++;\n        } else {\n            sdsfree(argv[j]);\n        }\n    }\n    zfree(argv);\n    return REDIS_OK;\n}\n\n/* Helper function. Trims query buffer to make the function that processes\n * multi bulk requests idempotent. */\nstatic void setProtocolError(redisClient *c, int pos) {\n    c->flags |= REDIS_CLOSE_AFTER_REPLY;\n    c->querybuf = sdsrange(c->querybuf,pos,-1);\n}\n\nint processMultibulkBuffer(redisClient *c) {\n    char *newline = NULL;\n    char *eptr;\n    int pos = 0, tolerr;\n    long bulklen;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        redisAssert(c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strstr(c->querybuf,\"\\r\\n\");\n        if (newline == NULL)\n            return REDIS_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        redisAssert(c->querybuf[0] == '*');\n        c->multibulklen = strtol(c->querybuf+1,&eptr,10);\n        pos = (newline-c->querybuf)+2;\n        if (c->multibulklen <= 0) {\n            c->querybuf = sdsrange(c->querybuf,pos,-1);\n            return REDIS_OK;\n        } else if (c->multibulklen > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(c,pos);\n            return REDIS_ERR;\n        }\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n\n        /* Search new newline */\n        newline = strstr(c->querybuf+pos,\"\\r\\n\");\n    }\n\n    redisAssert(c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strstr(c->querybuf+pos,\"\\r\\n\");\n            if (newline != NULL) {\n                if (c->querybuf[pos] != '$') {\n                    addReplyErrorFormat(c,\n                        \"Protocol error: expected '$', got '%c'\",\n                        c->querybuf[pos]);\n                    setProtocolError(c,pos);\n                    return REDIS_ERR;\n                }\n\n                bulklen = strtol(c->querybuf+pos+1,&eptr,10);\n                tolerr = (eptr[0] != '\\r');\n                if (tolerr || bulklen == LONG_MIN || bulklen == LONG_MAX ||\n                    bulklen < 0 || bulklen > 512*1024*1024)\n                {\n                    addReplyError(c,\"Protocol error: invalid bulk length\");\n                    setProtocolError(c,pos);\n                    return REDIS_ERR;\n                }\n                pos += eptr-(c->querybuf+pos)+2;\n                c->bulklen = bulklen;\n            } else {\n                /* No newline in current buffer, so wait for more data */\n                break;\n            }\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-pos < (unsigned)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            c->argv[c->argc++] = createStringObject(c->querybuf+pos,c->bulklen);\n            pos += c->bulklen+2;\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* Trim to pos */\n    c->querybuf = sdsrange(c->querybuf,pos,-1);\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) {\n        return REDIS_OK;\n    }\n    return REDIS_ERR;\n}\n\nvoid processInputBuffer(redisClient *c) {\n    /* Keep processing while there is something in the input buffer */\n    while(sdslen(c->querybuf)) {\n        /* Immediately abort if the client is in the middle of something. */\n        if (c->flags & REDIS_BLOCKED || c->flags & REDIS_IO_WAIT) return;\n\n        /* REDIS_CLOSE_AFTER_REPLY closes the connection once the reply is\n         * written to the client. Make sure to not let the reply grow after\n         * this flag has been set (i.e. don't process more commands). */\n        if (c->flags & REDIS_CLOSE_AFTER_REPLY) return;\n\n        /* Determine request type when unknown. */\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = REDIS_REQ_MULTIBULK;\n            } else {\n                c->reqtype = REDIS_REQ_INLINE;\n            }\n        }\n\n        if (c->reqtype == REDIS_REQ_INLINE) {\n            if (processInlineBuffer(c) != REDIS_OK) break;\n        } else if (c->reqtype == REDIS_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != REDIS_OK) break;\n        } else {\n            redisPanic(\"Unknown request type\");\n        }\n\n        /* Multibulk processing could see a <= 0 length. */\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            /* Only reset the client when the command was executed. */\n            if (processCommand(c) == REDIS_OK)\n                resetClient(c);\n        }\n    }\n}\n\nvoid readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {\n    redisClient *c = (redisClient*) privdata;\n    char buf[REDIS_IOBUF_LEN];\n    int nread;\n    REDIS_NOTUSED(el);\n    REDIS_NOTUSED(mask);\n\n    nread = read(fd, buf, REDIS_IOBUF_LEN);\n    if (nread == -1) {\n        if (errno == EAGAIN) {\n            nread = 0;\n        } else {\n            redisLog(REDIS_VERBOSE, \"Reading from client: %s\",strerror(errno));\n            freeClient(c);\n            return;\n        }\n    } else if (nread == 0) {\n        redisLog(REDIS_VERBOSE, \"Client closed connection\");\n        freeClient(c);\n        return;\n    }\n    if (nread) {\n        c->querybuf = sdscatlen(c->querybuf,buf,nread);\n        c->lastinteraction = time(NULL);\n    } else {\n        return;\n    }\n    processInputBuffer(c);\n}\n", "/*\n * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"redis.h\"\n\n#ifdef HAVE_BACKTRACE\n#include <execinfo.h>\n#include <ucontext.h>\n#endif /* HAVE_BACKTRACE */\n\n#include <time.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <pthread.h>\n#include <sys/resource.h>\n\n/* Our shared \"common\" objects */\n\nstruct sharedObjectsStruct shared;\n\n/* Global vars that are actally used as constants. The following double\n * values are used for double on-disk serialization, and are initialized\n * at runtime to avoid strange compiler optimizations. */\n\ndouble R_Zero, R_PosInf, R_NegInf, R_Nan;\n\n/*================================= Globals ================================= */\n\n/* Global vars */\nstruct redisServer server; /* server global state */\nstruct redisCommand *commandTable;\nstruct redisCommand readonlyCommandTable[] = {\n    {\"get\",getCommand,2,0,NULL,1,1,1},\n    {\"set\",setCommand,3,REDIS_CMD_DENYOOM,NULL,0,0,0},\n    {\"setnx\",setnxCommand,3,REDIS_CMD_DENYOOM,NULL,0,0,0},\n    {\"setex\",setexCommand,4,REDIS_CMD_DENYOOM,NULL,0,0,0},\n    {\"append\",appendCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"strlen\",strlenCommand,2,0,NULL,1,1,1},\n    {\"del\",delCommand,-2,0,NULL,0,0,0},\n    {\"exists\",existsCommand,2,0,NULL,1,1,1},\n    {\"setbit\",setbitCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"getbit\",getbitCommand,3,0,NULL,1,1,1},\n    {\"setrange\",setrangeCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"getrange\",getrangeCommand,4,0,NULL,1,1,1},\n    {\"substr\",getrangeCommand,4,0,NULL,1,1,1},\n    {\"incr\",incrCommand,2,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"decr\",decrCommand,2,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"mget\",mgetCommand,-2,0,NULL,1,-1,1},\n    {\"rpush\",rpushCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"lpush\",lpushCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"rpushx\",rpushxCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"lpushx\",lpushxCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"linsert\",linsertCommand,5,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"rpop\",rpopCommand,2,0,NULL,1,1,1},\n    {\"lpop\",lpopCommand,2,0,NULL,1,1,1},\n    {\"brpop\",brpopCommand,-3,0,NULL,1,1,1},\n    {\"brpoplpush\",brpoplpushCommand,4,REDIS_CMD_DENYOOM,NULL,1,2,1},\n    {\"blpop\",blpopCommand,-3,0,NULL,1,1,1},\n    {\"llen\",llenCommand,2,0,NULL,1,1,1},\n    {\"lindex\",lindexCommand,3,0,NULL,1,1,1},\n    {\"lset\",lsetCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"lrange\",lrangeCommand,4,0,NULL,1,1,1},\n    {\"ltrim\",ltrimCommand,4,0,NULL,1,1,1},\n    {\"lrem\",lremCommand,4,0,NULL,1,1,1},\n    {\"rpoplpush\",rpoplpushCommand,3,REDIS_CMD_DENYOOM,NULL,1,2,1},\n    {\"sadd\",saddCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"srem\",sremCommand,3,0,NULL,1,1,1},\n    {\"smove\",smoveCommand,4,0,NULL,1,2,1},\n    {\"sismember\",sismemberCommand,3,0,NULL,1,1,1},\n    {\"scard\",scardCommand,2,0,NULL,1,1,1},\n    {\"spop\",spopCommand,2,0,NULL,1,1,1},\n    {\"srandmember\",srandmemberCommand,2,0,NULL,1,1,1},\n    {\"sinter\",sinterCommand,-2,REDIS_CMD_DENYOOM,NULL,1,-1,1},\n    {\"sinterstore\",sinterstoreCommand,-3,REDIS_CMD_DENYOOM,NULL,2,-1,1},\n    {\"sunion\",sunionCommand,-2,REDIS_CMD_DENYOOM,NULL,1,-1,1},\n    {\"sunionstore\",sunionstoreCommand,-3,REDIS_CMD_DENYOOM,NULL,2,-1,1},\n    {\"sdiff\",sdiffCommand,-2,REDIS_CMD_DENYOOM,NULL,1,-1,1},\n    {\"sdiffstore\",sdiffstoreCommand,-3,REDIS_CMD_DENYOOM,NULL,2,-1,1},\n    {\"smembers\",sinterCommand,2,0,NULL,1,1,1},\n    {\"zadd\",zaddCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"zincrby\",zincrbyCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"zrem\",zremCommand,3,0,NULL,1,1,1},\n    {\"zremrangebyscore\",zremrangebyscoreCommand,4,0,NULL,1,1,1},\n    {\"zremrangebyrank\",zremrangebyrankCommand,4,0,NULL,1,1,1},\n    {\"zunionstore\",zunionstoreCommand,-4,REDIS_CMD_DENYOOM,zunionInterBlockClientOnSwappedKeys,0,0,0},\n    {\"zinterstore\",zinterstoreCommand,-4,REDIS_CMD_DENYOOM,zunionInterBlockClientOnSwappedKeys,0,0,0},\n    {\"zrange\",zrangeCommand,-4,0,NULL,1,1,1},\n    {\"zrangebyscore\",zrangebyscoreCommand,-4,0,NULL,1,1,1},\n    {\"zrevrangebyscore\",zrevrangebyscoreCommand,-4,0,NULL,1,1,1},\n    {\"zcount\",zcountCommand,4,0,NULL,1,1,1},\n    {\"zrevrange\",zrevrangeCommand,-4,0,NULL,1,1,1},\n    {\"zcard\",zcardCommand,2,0,NULL,1,1,1},\n    {\"zscore\",zscoreCommand,3,0,NULL,1,1,1},\n    {\"zrank\",zrankCommand,3,0,NULL,1,1,1},\n    {\"zrevrank\",zrevrankCommand,3,0,NULL,1,1,1},\n    {\"hset\",hsetCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hsetnx\",hsetnxCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hget\",hgetCommand,3,0,NULL,1,1,1},\n    {\"hmset\",hmsetCommand,-4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hmget\",hmgetCommand,-3,0,NULL,1,1,1},\n    {\"hincrby\",hincrbyCommand,4,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"hdel\",hdelCommand,3,0,NULL,1,1,1},\n    {\"hlen\",hlenCommand,2,0,NULL,1,1,1},\n    {\"hkeys\",hkeysCommand,2,0,NULL,1,1,1},\n    {\"hvals\",hvalsCommand,2,0,NULL,1,1,1},\n    {\"hgetall\",hgetallCommand,2,0,NULL,1,1,1},\n    {\"hexists\",hexistsCommand,3,0,NULL,1,1,1},\n    {\"incrby\",incrbyCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"decrby\",decrbyCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"getset\",getsetCommand,3,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"mset\",msetCommand,-3,REDIS_CMD_DENYOOM,NULL,1,-1,2},\n    {\"msetnx\",msetnxCommand,-3,REDIS_CMD_DENYOOM,NULL,1,-1,2},\n    {\"randomkey\",randomkeyCommand,1,0,NULL,0,0,0},\n    {\"select\",selectCommand,2,0,NULL,0,0,0},\n    {\"move\",moveCommand,3,0,NULL,1,1,1},\n    {\"rename\",renameCommand,3,0,NULL,1,1,1},\n    {\"renamenx\",renamenxCommand,3,0,NULL,1,1,1},\n    {\"expire\",expireCommand,3,0,NULL,0,0,0},\n    {\"expireat\",expireatCommand,3,0,NULL,0,0,0},\n    {\"keys\",keysCommand,2,0,NULL,0,0,0},\n    {\"dbsize\",dbsizeCommand,1,0,NULL,0,0,0},\n    {\"auth\",authCommand,2,0,NULL,0,0,0},\n    {\"ping\",pingCommand,1,0,NULL,0,0,0},\n    {\"echo\",echoCommand,2,0,NULL,0,0,0},\n    {\"save\",saveCommand,1,0,NULL,0,0,0},\n    {\"bgsave\",bgsaveCommand,1,0,NULL,0,0,0},\n    {\"bgrewriteaof\",bgrewriteaofCommand,1,0,NULL,0,0,0},\n    {\"shutdown\",shutdownCommand,1,0,NULL,0,0,0},\n    {\"lastsave\",lastsaveCommand,1,0,NULL,0,0,0},\n    {\"type\",typeCommand,2,0,NULL,1,1,1},\n    {\"multi\",multiCommand,1,0,NULL,0,0,0},\n    {\"exec\",execCommand,1,REDIS_CMD_DENYOOM,execBlockClientOnSwappedKeys,0,0,0},\n    {\"discard\",discardCommand,1,0,NULL,0,0,0},\n    {\"sync\",syncCommand,1,0,NULL,0,0,0},\n    {\"flushdb\",flushdbCommand,1,0,NULL,0,0,0},\n    {\"flushall\",flushallCommand,1,0,NULL,0,0,0},\n    {\"sort\",sortCommand,-2,REDIS_CMD_DENYOOM,NULL,1,1,1},\n    {\"info\",infoCommand,1,0,NULL,0,0,0},\n    {\"monitor\",monitorCommand,1,0,NULL,0,0,0},\n    {\"ttl\",ttlCommand,2,0,NULL,1,1,1},\n    {\"persist\",persistCommand,2,0,NULL,1,1,1},\n    {\"slaveof\",slaveofCommand,3,0,NULL,0,0,0},\n    {\"debug\",debugCommand,-2,0,NULL,0,0,0},\n    {\"config\",configCommand,-2,0,NULL,0,0,0},\n    {\"subscribe\",subscribeCommand,-2,0,NULL,0,0,0},\n    {\"unsubscribe\",unsubscribeCommand,-1,0,NULL,0,0,0},\n    {\"psubscribe\",psubscribeCommand,-2,0,NULL,0,0,0},\n    {\"punsubscribe\",punsubscribeCommand,-1,0,NULL,0,0,0},\n    {\"publish\",publishCommand,3,REDIS_CMD_FORCE_REPLICATION,NULL,0,0,0},\n    {\"watch\",watchCommand,-2,0,NULL,0,0,0},\n    {\"unwatch\",unwatchCommand,1,0,NULL,0,0,0}\n};\n\n/*============================ Utility functions ============================ */\n\nvoid redisLog(int level, const char *fmt, ...) {\n    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };\n    const char *c = \".-*#\";\n    time_t now = time(NULL);\n    va_list ap;\n    FILE *fp;\n    char buf[64];\n    char msg[REDIS_MAX_LOGMSG_LEN];\n\n    if (level < server.verbosity) return;\n\n    fp = (server.logfile == NULL) ? stdout : fopen(server.logfile,\"a\");\n    if (!fp) return;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    strftime(buf,sizeof(buf),\"%d %b %H:%M:%S\",localtime(&now));\n    fprintf(fp,\"[%d] %s %c %s\\n\",(int)getpid(),buf,c[level],msg);\n    fflush(fp);\n\n    if (server.logfile) fclose(fp);\n\n    if (server.syslog_enabled) syslog(syslogLevelMap[level], \"%s\", msg);\n}\n\n/* Redis generally does not try to recover from out of memory conditions\n * when allocating objects or strings, it is not clear if it will be possible\n * to report this condition to the client since the networking layer itself\n * is based on heap allocation for send buffers, so we simply abort.\n * At least the code will be simpler to read... */\nvoid oom(const char *msg) {\n    redisLog(REDIS_WARNING, \"%s: Out of memory\\n\",msg);\n    sleep(1);\n    abort();\n}\n\n/*====================== Hash table type implementation  ==================== */\n\n/* This is an hash table type that uses the SDS dynamic strings libary as\n * keys and radis objects as values (objects can hold SDS strings,\n * lists, sets). */\n\nvoid dictVanillaFree(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    zfree(val);\n}\n\nvoid dictListDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    listRelease((list*)val);\n}\n\nint dictSdsKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    int l1,l2;\n    DICT_NOTUSED(privdata);\n\n    l1 = sdslen((sds)key1);\n    l2 = sdslen((sds)key2);\n    if (l1 != l2) return 0;\n    return memcmp(key1, key2, l1) == 0;\n}\n\n/* A case insensitive version used for the command lookup table. */\nint dictSdsKeyCaseCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    DICT_NOTUSED(privdata);\n\n    return strcasecmp(key1, key2) == 0;\n}\n\nvoid dictRedisObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Values of swapped out keys as set to NULL */\n    decrRefCount(val);\n}\n\nvoid dictSdsDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    sdsfree(val);\n}\n\nint dictObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    const robj *o1 = key1, *o2 = key2;\n    return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n}\n\nunsigned int dictObjHash(const void *key) {\n    const robj *o = key;\n    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n}\n\nunsigned int dictSdsHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nunsigned int dictSdsCaseHash(const void *key) {\n    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nint dictEncObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    robj *o1 = (robj*) key1, *o2 = (robj*) key2;\n    int cmp;\n\n    if (o1->encoding == REDIS_ENCODING_INT &&\n        o2->encoding == REDIS_ENCODING_INT)\n            return o1->ptr == o2->ptr;\n\n    o1 = getDecodedObject(o1);\n    o2 = getDecodedObject(o2);\n    cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n    decrRefCount(o1);\n    decrRefCount(o2);\n    return cmp;\n}\n\nunsigned int dictEncObjHash(const void *key) {\n    robj *o = (robj*) key;\n\n    if (o->encoding == REDIS_ENCODING_RAW) {\n        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n    } else {\n        if (o->encoding == REDIS_ENCODING_INT) {\n            char buf[32];\n            int len;\n\n            len = ll2string(buf,32,(long)o->ptr);\n            return dictGenHashFunction((unsigned char*)buf, len);\n        } else {\n            unsigned int hash;\n\n            o = getDecodedObject(o);\n            hash = dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n            decrRefCount(o);\n            return hash;\n        }\n    }\n}\n\n/* Sets type */\ndictType setDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictRedisObjectDestructor, /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */\ndictType zsetDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictRedisObjectDestructor, /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Db->dict, keys are sds strings, vals are Redis objects. */\ndictType dbDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictRedisObjectDestructor   /* val destructor */\n};\n\n/* Db->expires */\ndictType keyptrDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Command table. sds string -> command struct pointer. */\ndictType commandTableDictType = {\n    dictSdsCaseHash,           /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCaseCompare,     /* key compare */\n    dictSdsDestructor,         /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Hash type hash table (note that small hashes are represented with zimpaps) */\ndictType hashDictType = {\n    dictEncObjHash,             /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictEncObjKeyCompare,       /* key compare */\n    dictRedisObjectDestructor,  /* key destructor */\n    dictRedisObjectDestructor   /* val destructor */\n};\n\n/* Keylist hash table type has unencoded redis objects as keys and\n * lists as values. It's used for blocking operations (BLPOP) and to\n * map swapped keys to a list of clients waiting for this keys to be loaded. */\ndictType keylistDictType = {\n    dictObjHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictObjKeyCompare,          /* key compare */\n    dictRedisObjectDestructor,  /* key destructor */\n    dictListDestructor          /* val destructor */\n};\n\nint htNeedsResize(dict *dict) {\n    long long size, used;\n\n    size = dictSlots(dict);\n    used = dictSize(dict);\n    return (size && used && size > DICT_HT_INITIAL_SIZE &&\n            (used*100/size < REDIS_HT_MINFILL));\n}\n\n/* If the percentage of used slots in the HT reaches REDIS_HT_MINFILL\n * we resize the hash table to save memory */\nvoid tryResizeHashTables(void) {\n    int j;\n\n    for (j = 0; j < server.dbnum; j++) {\n        if (htNeedsResize(server.db[j].dict))\n            dictResize(server.db[j].dict);\n        if (htNeedsResize(server.db[j].expires))\n            dictResize(server.db[j].expires);\n    }\n}\n\n/* Our hash table implementation performs rehashing incrementally while\n * we write/read from the hash table. Still if the server is idle, the hash\n * table will use two tables for a long time. So we try to use 1 millisecond\n * of CPU time at every serverCron() loop in order to rehash some key. */\nvoid incrementallyRehash(void) {\n    int j;\n\n    for (j = 0; j < server.dbnum; j++) {\n        if (dictIsRehashing(server.db[j].dict)) {\n            dictRehashMilliseconds(server.db[j].dict,1);\n            break; /* already used our millisecond for this loop... */\n        }\n    }\n}\n\n/* This function is called once a background process of some kind terminates,\n * as we want to avoid resizing the hash tables when there is a child in order\n * to play well with copy-on-write (otherwise when a resize happens lots of\n * memory pages are copied). The goal of this function is to update the ability\n * for dict.c to resize the hash tables accordingly to the fact we have o not\n * running childs. */\nvoid updateDictResizePolicy(void) {\n    if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1)\n        dictEnableResize();\n    else\n        dictDisableResize();\n}\n\n/* ======================= Cron: called every 100 ms ======================== */\n\n/* Try to expire a few timed out keys. The algorithm used is adaptive and\n * will use few CPU cycles if there are few expiring keys, otherwise\n * it will get more aggressive to avoid that too much memory is used by\n * keys that can be removed from the keyspace. */\nvoid activeExpireCycle(void) {\n    int j;\n\n    for (j = 0; j < server.dbnum; j++) {\n        int expired;\n        redisDb *db = server.db+j;\n\n        /* Continue to expire if at the end of the cycle more than 25%\n         * of the keys were expired. */\n        do {\n            long num = dictSize(db->expires);\n            time_t now = time(NULL);\n\n            expired = 0;\n            if (num > REDIS_EXPIRELOOKUPS_PER_CRON)\n                num = REDIS_EXPIRELOOKUPS_PER_CRON;\n            while (num--) {\n                dictEntry *de;\n                time_t t;\n\n                if ((de = dictGetRandomKey(db->expires)) == NULL) break;\n                t = (time_t) dictGetEntryVal(de);\n                if (now > t) {\n                    sds key = dictGetEntryKey(de);\n                    robj *keyobj = createStringObject(key,sdslen(key));\n\n                    propagateExpire(db,keyobj);\n                    dbDelete(db,keyobj);\n                    decrRefCount(keyobj);\n                    expired++;\n                    server.stat_expiredkeys++;\n                }\n            }\n        } while (expired > REDIS_EXPIRELOOKUPS_PER_CRON/4);\n    }\n}\n\nvoid updateLRUClock(void) {\n    server.lruclock = (time(NULL)/REDIS_LRU_CLOCK_RESOLUTION) &\n                                                REDIS_LRU_CLOCK_MAX;\n}\n\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    int j, loops = server.cronloops++;\n    REDIS_NOTUSED(eventLoop);\n    REDIS_NOTUSED(id);\n    REDIS_NOTUSED(clientData);\n\n    /* We take a cached value of the unix time in the global state because\n     * with virtual memory and aging there is to store the current time\n     * in objects at every object access, and accuracy is not needed.\n     * To access a global var is faster than calling time(NULL) */\n    server.unixtime = time(NULL);\n    /* We have just 22 bits per object for LRU information.\n     * So we use an (eventually wrapping) LRU clock with 10 seconds resolution.\n     * 2^22 bits with 10 seconds resoluton is more or less 1.5 years.\n     *\n     * Note that even if this will wrap after 1.5 years it's not a problem,\n     * everything will still work but just some object will appear younger\n     * to Redis. But for this to happen a given object should never be touched\n     * for 1.5 years.\n     *\n     * Note that you can change the resolution altering the\n     * REDIS_LRU_CLOCK_RESOLUTION define.\n     */\n    updateLRUClock();\n\n    /* We received a SIGTERM, shutting down here in a safe way, as it is\n     * not ok doing so inside the signal handler. */\n    if (server.shutdown_asap) {\n        if (prepareForShutdown() == REDIS_OK) exit(0);\n        redisLog(REDIS_WARNING,\"SIGTERM received but errors trying to shut down the server, check the logs for more information\");\n    }\n\n    /* Show some info about non-empty databases */\n    for (j = 0; j < server.dbnum; j++) {\n        long long size, used, vkeys;\n\n        size = dictSlots(server.db[j].dict);\n        used = dictSize(server.db[j].dict);\n        vkeys = dictSize(server.db[j].expires);\n        if (!(loops % 50) && (used || vkeys)) {\n            redisLog(REDIS_VERBOSE,\"DB %d: %lld keys (%lld volatile) in %lld slots HT.\",j,used,vkeys,size);\n            /* dictPrintStats(server.dict); */\n        }\n    }\n\n    /* We don't want to resize the hash tables while a bacground saving\n     * is in progress: the saving child is created using fork() that is\n     * implemented with a copy-on-write semantic in most modern systems, so\n     * if we resize the HT while there is the saving child at work actually\n     * a lot of memory movements in the parent will cause a lot of pages\n     * copied. */\n    if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1) {\n        if (!(loops % 10)) tryResizeHashTables();\n        if (server.activerehashing) incrementallyRehash();\n    }\n\n    /* Show information about connected clients */\n    if (!(loops % 50)) {\n        redisLog(REDIS_VERBOSE,\"%d clients connected (%d slaves), %zu bytes in use\",\n            listLength(server.clients)-listLength(server.slaves),\n            listLength(server.slaves),\n            zmalloc_used_memory());\n    }\n\n    /* Close connections of timedout clients */\n    if ((server.maxidletime && !(loops % 100)) || server.bpop_blocked_clients)\n        closeTimedoutClients();\n\n    /* Check if a background saving or AOF rewrite in progress terminated */\n    if (server.bgsavechildpid != -1 || server.bgrewritechildpid != -1) {\n        int statloc;\n        pid_t pid;\n\n        if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {\n            if (pid == server.bgsavechildpid) {\n                backgroundSaveDoneHandler(statloc);\n            } else {\n                backgroundRewriteDoneHandler(statloc);\n            }\n            updateDictResizePolicy();\n        }\n    } else {\n        /* If there is not a background saving in progress check if\n         * we have to save now */\n         time_t now = time(NULL);\n         for (j = 0; j < server.saveparamslen; j++) {\n            struct saveparam *sp = server.saveparams+j;\n\n            if (server.dirty >= sp->changes &&\n                now-server.lastsave > sp->seconds) {\n                redisLog(REDIS_NOTICE,\"%d changes in %d seconds. Saving...\",\n                    sp->changes, sp->seconds);\n                rdbSaveBackground(server.dbfilename);\n                break;\n            }\n         }\n    }\n\n    /* Expire a few keys per cycle, only if this is a master.\n     * On slaves we wait for DEL operations synthesized by the master\n     * in order to guarantee a strict consistency. */\n    if (server.masterhost == NULL) activeExpireCycle();\n\n    /* Remove a few cached objects from memory if we are over the\n     * configured memory limit */\n    while (server.ds_enabled && zmalloc_used_memory() >\n            server.cache_max_memory)\n    {\n        cacheFreeOneEntry();\n    }\n\n    /* Replication cron function -- used to reconnect to master and\n     * to detect transfer failures. */\n    if (!(loops % 10)) replicationCron();\n\n    return 100;\n}\n\n/* This function gets called every time Redis is entering the\n * main loop of the event driven library, that is, before to sleep\n * for ready file descriptors. */\nvoid beforeSleep(struct aeEventLoop *eventLoop) {\n    REDIS_NOTUSED(eventLoop);\n    listNode *ln;\n    redisClient *c;\n\n    /* Awake clients that got all the on disk keys they requested */\n    if (server.ds_enabled && listLength(server.io_ready_clients)) {\n        listIter li;\n\n        listRewind(server.io_ready_clients,&li);\n        while((ln = listNext(&li))) {\n            c = ln->value;\n            struct redisCommand *cmd;\n\n            /* Resume the client. */\n            listDelNode(server.io_ready_clients,ln);\n            c->flags &= (~REDIS_IO_WAIT);\n            server.cache_blocked_clients--;\n            aeCreateFileEvent(server.el, c->fd, AE_READABLE,\n                readQueryFromClient, c);\n            cmd = lookupCommand(c->argv[0]->ptr);\n            redisAssert(cmd != NULL);\n            call(c,cmd);\n            resetClient(c);\n            /* There may be more data to process in the input buffer. */\n            if (c->querybuf && sdslen(c->querybuf) > 0)\n                processInputBuffer(c);\n        }\n    }\n\n    /* Try to process pending commands for clients that were just unblocked. */\n    while (listLength(server.unblocked_clients)) {\n        ln = listFirst(server.unblocked_clients);\n        redisAssert(ln != NULL);\n        c = ln->value;\n        listDelNode(server.unblocked_clients,ln);\n\n        /* Process remaining data in the input buffer. */\n        if (c->querybuf && sdslen(c->querybuf) > 0)\n            processInputBuffer(c);\n    }\n\n    /* Write the AOF buffer on disk */\n    flushAppendOnlyFile();\n}\n\n/* =========================== Server initialization ======================== */\n\nvoid createSharedObjects(void) {\n    int j;\n\n    shared.crlf = createObject(REDIS_STRING,sdsnew(\"\\r\\n\"));\n    shared.ok = createObject(REDIS_STRING,sdsnew(\"+OK\\r\\n\"));\n    shared.err = createObject(REDIS_STRING,sdsnew(\"-ERR\\r\\n\"));\n    shared.emptybulk = createObject(REDIS_STRING,sdsnew(\"$0\\r\\n\\r\\n\"));\n    shared.czero = createObject(REDIS_STRING,sdsnew(\":0\\r\\n\"));\n    shared.cone = createObject(REDIS_STRING,sdsnew(\":1\\r\\n\"));\n    shared.cnegone = createObject(REDIS_STRING,sdsnew(\":-1\\r\\n\"));\n    shared.nullbulk = createObject(REDIS_STRING,sdsnew(\"$-1\\r\\n\"));\n    shared.nullmultibulk = createObject(REDIS_STRING,sdsnew(\"*-1\\r\\n\"));\n    shared.emptymultibulk = createObject(REDIS_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.pong = createObject(REDIS_STRING,sdsnew(\"+PONG\\r\\n\"));\n    shared.queued = createObject(REDIS_STRING,sdsnew(\"+QUEUED\\r\\n\"));\n    shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR Operation against a key holding the wrong kind of value\\r\\n\"));\n    shared.nokeyerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR no such key\\r\\n\"));\n    shared.syntaxerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR syntax error\\r\\n\"));\n    shared.sameobjecterr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR source and destination objects are the same\\r\\n\"));\n    shared.outofrangeerr = createObject(REDIS_STRING,sdsnew(\n        \"-ERR index out of range\\r\\n\"));\n    shared.loadingerr = createObject(REDIS_STRING,sdsnew(\n        \"-LOADING Redis is loading the dataset in memory\\r\\n\"));\n    shared.space = createObject(REDIS_STRING,sdsnew(\" \"));\n    shared.colon = createObject(REDIS_STRING,sdsnew(\":\"));\n    shared.plus = createObject(REDIS_STRING,sdsnew(\"+\"));\n    shared.select0 = createStringObject(\"select 0\\r\\n\",10);\n    shared.select1 = createStringObject(\"select 1\\r\\n\",10);\n    shared.select2 = createStringObject(\"select 2\\r\\n\",10);\n    shared.select3 = createStringObject(\"select 3\\r\\n\",10);\n    shared.select4 = createStringObject(\"select 4\\r\\n\",10);\n    shared.select5 = createStringObject(\"select 5\\r\\n\",10);\n    shared.select6 = createStringObject(\"select 6\\r\\n\",10);\n    shared.select7 = createStringObject(\"select 7\\r\\n\",10);\n    shared.select8 = createStringObject(\"select 8\\r\\n\",10);\n    shared.select9 = createStringObject(\"select 9\\r\\n\",10);\n    shared.messagebulk = createStringObject(\"$7\\r\\nmessage\\r\\n\",13);\n    shared.pmessagebulk = createStringObject(\"$8\\r\\npmessage\\r\\n\",14);\n    shared.subscribebulk = createStringObject(\"$9\\r\\nsubscribe\\r\\n\",15);\n    shared.unsubscribebulk = createStringObject(\"$11\\r\\nunsubscribe\\r\\n\",18);\n    shared.psubscribebulk = createStringObject(\"$10\\r\\npsubscribe\\r\\n\",17);\n    shared.punsubscribebulk = createStringObject(\"$12\\r\\npunsubscribe\\r\\n\",19);\n    shared.mbulk3 = createStringObject(\"*3\\r\\n\",4);\n    shared.mbulk4 = createStringObject(\"*4\\r\\n\",4);\n    for (j = 0; j < REDIS_SHARED_INTEGERS; j++) {\n        shared.integers[j] = createObject(REDIS_STRING,(void*)(long)j);\n        shared.integers[j]->encoding = REDIS_ENCODING_INT;\n    }\n}\n\nvoid initServerConfig() {\n    server.port = REDIS_SERVERPORT;\n    server.bindaddr = NULL;\n    server.unixsocket = NULL;\n    server.ipfd = -1;\n    server.sofd = -1;\n    server.dbnum = REDIS_DEFAULT_DBNUM;\n    server.verbosity = REDIS_VERBOSE;\n    server.maxidletime = REDIS_MAXIDLETIME;\n    server.saveparams = NULL;\n    server.loading = 0;\n    server.logfile = NULL; /* NULL = log on standard output */\n    server.syslog_enabled = 0;\n    server.syslog_ident = zstrdup(\"redis\");\n    server.syslog_facility = LOG_LOCAL0;\n    server.glueoutputbuf = 1;\n    server.daemonize = 0;\n    server.appendonly = 0;\n    server.appendfsync = APPENDFSYNC_EVERYSEC;\n    server.no_appendfsync_on_rewrite = 0;\n    server.lastfsync = time(NULL);\n    server.appendfd = -1;\n    server.appendseldb = -1; /* Make sure the first time will not match */\n    server.pidfile = zstrdup(\"/var/run/redis.pid\");\n    server.dbfilename = zstrdup(\"dump.rdb\");\n    server.appendfilename = zstrdup(\"appendonly.aof\");\n    server.requirepass = NULL;\n    server.rdbcompression = 1;\n    server.activerehashing = 1;\n    server.maxclients = 0;\n    server.bpop_blocked_clients = 0;\n    server.maxmemory = 0;\n    server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;\n    server.maxmemory_samples = 3;\n    server.ds_enabled = 0;\n    server.ds_path = zstrdup(\"/tmp/redis.ds\");\n    server.cache_max_memory = 64LL*1024*1024; /* 64 MB of RAM */\n    server.cache_blocked_clients = 0;\n    server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES;\n    server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE;\n    server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;\n    server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;\n    server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;\n    server.shutdown_asap = 0;\n\n    updateLRUClock();\n    resetServerSaveParams();\n\n    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */\n    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */\n    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */\n    /* Replication related */\n    server.isslave = 0;\n    server.masterauth = NULL;\n    server.masterhost = NULL;\n    server.masterport = 6379;\n    server.master = NULL;\n    server.replstate = REDIS_REPL_NONE;\n    server.repl_serve_stale_data = 1;\n\n    /* Double constants initialization */\n    R_Zero = 0.0;\n    R_PosInf = 1.0/R_Zero;\n    R_NegInf = -1.0/R_Zero;\n    R_Nan = R_Zero/R_Zero;\n\n    /* Command table -- we intiialize it here as it is part of the\n     * initial configuration, since command names may be changed via\n     * redis.conf using the rename-command directive. */\n    server.commands = dictCreate(&commandTableDictType,NULL);\n    populateCommandTable();\n    server.delCommand = lookupCommandByCString(\"del\");\n    server.multiCommand = lookupCommandByCString(\"multi\");\n}\n\nvoid initServer() {\n    int j;\n\n    signal(SIGHUP, SIG_IGN);\n    signal(SIGPIPE, SIG_IGN);\n    setupSigSegvAction();\n\n    if (server.syslog_enabled) {\n        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,\n            server.syslog_facility);\n    }\n\n    server.mainthread = pthread_self();\n    server.clients = listCreate();\n    server.slaves = listCreate();\n    server.monitors = listCreate();\n    server.unblocked_clients = listCreate();\n    createSharedObjects();\n    server.el = aeCreateEventLoop();\n    server.db = zmalloc(sizeof(redisDb)*server.dbnum);\n    server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);\n    if (server.ipfd == ANET_ERR) {\n        redisLog(REDIS_WARNING, \"Opening port: %s\", server.neterr);\n        exit(1);\n    }\n    if (server.unixsocket != NULL) {\n        unlink(server.unixsocket); /* don't care if this fails */\n        server.sofd = anetUnixServer(server.neterr,server.unixsocket);\n        if (server.sofd == ANET_ERR) {\n            redisLog(REDIS_WARNING, \"Opening socket: %s\", server.neterr);\n            exit(1);\n        }\n    }\n    if (server.ipfd < 0 && server.sofd < 0) {\n        redisLog(REDIS_WARNING, \"Configured to not listen anywhere, exiting.\");\n        exit(1);\n    }\n    for (j = 0; j < server.dbnum; j++) {\n        server.db[j].dict = dictCreate(&dbDictType,NULL);\n        server.db[j].expires = dictCreate(&keyptrDictType,NULL);\n        server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);\n        if (server.ds_enabled)\n            server.db[j].io_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].id = j;\n    }\n    server.pubsub_channels = dictCreate(&keylistDictType,NULL);\n    server.pubsub_patterns = listCreate();\n    listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);\n    listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);\n    server.cronloops = 0;\n    server.bgsavechildpid = -1;\n    server.bgrewritechildpid = -1;\n    server.bgrewritebuf = sdsempty();\n    server.aofbuf = sdsempty();\n    server.lastsave = time(NULL);\n    server.dirty = 0;\n    server.stat_numcommands = 0;\n    server.stat_numconnections = 0;\n    server.stat_expiredkeys = 0;\n    server.stat_evictedkeys = 0;\n    server.stat_starttime = time(NULL);\n    server.stat_keyspace_misses = 0;\n    server.stat_keyspace_hits = 0;\n    server.unixtime = time(NULL);\n    aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);\n    if (server.ipfd > 0 && aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,\n        acceptTcpHandler,NULL) == AE_ERR) oom(\"creating file event\");\n    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,\n        acceptUnixHandler,NULL) == AE_ERR) oom(\"creating file event\");\n\n    if (server.appendonly) {\n        server.appendfd = open(server.appendfilename,O_WRONLY|O_APPEND|O_CREAT,0644);\n        if (server.appendfd == -1) {\n            redisLog(REDIS_WARNING, \"Can't open the append-only file: %s\",\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    if (server.ds_enabled) dsInit();\n}\n\n/* Populates the Redis Command Table starting from the hard coded list\n * we have on top of redis.c file. */\nvoid populateCommandTable(void) {\n    int j;\n    int numcommands = sizeof(readonlyCommandTable)/sizeof(struct redisCommand);\n\n    for (j = 0; j < numcommands; j++) {\n        struct redisCommand *c = readonlyCommandTable+j;\n        int retval;\n\n        retval = dictAdd(server.commands, sdsnew(c->name), c);\n        assert(retval == DICT_OK);\n    }\n}\n\n/* ====================== Commands lookup and execution ===================== */\n\nstruct redisCommand *lookupCommand(sds name) {\n    return dictFetchValue(server.commands, name);\n}\n\nstruct redisCommand *lookupCommandByCString(char *s) {\n    struct redisCommand *cmd;\n    sds name = sdsnew(s);\n\n    cmd = dictFetchValue(server.commands, name);\n    sdsfree(name);\n    return cmd;\n}\n\n/* Call() is the core of Redis execution of a command */\nvoid call(redisClient *c, struct redisCommand *cmd) {\n    long long dirty;\n\n    dirty = server.dirty;\n    cmd->proc(c);\n    dirty = server.dirty-dirty;\n\n    if (server.appendonly && dirty)\n        feedAppendOnlyFile(cmd,c->db->id,c->argv,c->argc);\n    if ((dirty || cmd->flags & REDIS_CMD_FORCE_REPLICATION) &&\n        listLength(server.slaves))\n        replicationFeedSlaves(server.slaves,c->db->id,c->argv,c->argc);\n    if (listLength(server.monitors))\n        replicationFeedMonitors(server.monitors,c->db->id,c->argv,c->argc);\n    server.stat_numcommands++;\n}\n\n/* If this function gets called we already read a whole\n * command, argments are in the client argv/argc fields.\n * processCommand() execute the command or prepare the\n * server for a bulk read from the client.\n *\n * If 1 is returned the client is still alive and valid and\n * and other operations can be performed by the caller. Otherwise\n * if 0 is returned the client was destroied (i.e. after QUIT). */\nint processCommand(redisClient *c) {\n    struct redisCommand *cmd;\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= REDIS_CLOSE_AFTER_REPLY;\n        return REDIS_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such wrong arity, bad command name and so forth. */\n    cmd = lookupCommand(c->argv[0]->ptr);\n    if (!cmd) {\n        addReplyErrorFormat(c,\"unknown command '%s'\",\n            (char*)c->argv[0]->ptr);\n        return REDIS_OK;\n    } else if ((cmd->arity > 0 && cmd->arity != c->argc) ||\n               (c->argc < -cmd->arity)) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            cmd->name);\n        return REDIS_OK;\n    }\n\n    /* Check if the user is authenticated */\n    if (server.requirepass && !c->authenticated && cmd->proc != authCommand) {\n        addReplyError(c,\"operation not permitted\");\n        return REDIS_OK;\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * First we try to free some memory if possible (if there are volatile\n     * keys in the dataset). If there are not the only thing we can do\n     * is returning an error. */\n    if (server.maxmemory) freeMemoryIfNeeded();\n    if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) &&\n        zmalloc_used_memory() > server.maxmemory)\n    {\n        addReplyError(c,\"command not allowed when used memory > 'maxmemory'\");\n        return REDIS_OK;\n    }\n\n    /* Only allow SUBSCRIBE and UNSUBSCRIBE in the context of Pub/Sub */\n    if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0)\n        &&\n        cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand &&\n        cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) {\n        addReplyError(c,\"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context\");\n        return REDIS_OK;\n    }\n\n    /* Only allow INFO and SLAVEOF when slave-serve-stale-data is no and\n     * we are a slave with a broken link with master. */\n    if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        cmd->proc != infoCommand && cmd->proc != slaveofCommand)\n    {\n        addReplyError(c,\n            \"link with MASTER is down and slave-serve-stale-data is set to no\");\n        return REDIS_OK;\n    }\n\n    /* Loading DB? Return an error if the command is not INFO */\n    if (server.loading && cmd->proc != infoCommand) {\n        addReply(c, shared.loadingerr);\n        return REDIS_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & REDIS_MULTI &&\n        cmd->proc != execCommand && cmd->proc != discardCommand &&\n        cmd->proc != multiCommand && cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c,cmd);\n        addReply(c,shared.queued);\n    } else {\n        if (server.ds_enabled && blockClientOnSwappedKeys(c,cmd))\n            return REDIS_ERR;\n        call(c,cmd);\n    }\n    return REDIS_OK;\n}\n\n/*================================== Shutdown =============================== */\n\nint prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    /* Kill the saving child if there is a background saving in progress.\n       We want to avoid race conditions, for instance our saving child may\n       overwrite the synchronous saving did by SHUTDOWN. */\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        /* Append only file: fsync() the AOF and exit */\n        aof_fsync(server.appendfd);\n    } else if (server.saveparamslen > 0) {\n        /* Snapshotting. Perform a SYNC SAVE and exit */\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            /* Ooops.. error saving! The best we can do is to continue\n             * operating. Note that if there was a background saving process,\n             * in the next cron() Redis will be notified that the background\n             * saving aborted, handling special stuff like slaves pending for\n             * synchronization... */\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}\n\n/*================================== Commands =============================== */\n\nvoid authCommand(redisClient *c) {\n    if (!server.requirepass || !strcmp(c->argv[1]->ptr, server.requirepass)) {\n      c->authenticated = 1;\n      addReply(c,shared.ok);\n    } else {\n      c->authenticated = 0;\n      addReplyError(c,\"invalid password\");\n    }\n}\n\nvoid pingCommand(redisClient *c) {\n    addReply(c,shared.pong);\n}\n\nvoid echoCommand(redisClient *c) {\n    addReplyBulk(c,c->argv[1]);\n}\n\n/* Convert an amount of bytes into a human readable string in the form\n * of 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, unsigned long long n) {\n    double d;\n\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lluB\",n);\n        return;\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    }\n}\n\n/* Create the string returned by the INFO command. This is decoupled\n * by the INFO command itself as we need to report the same information\n * on memory corruption problems. */\nsds genRedisInfoString(void) {\n    sds info;\n    time_t uptime = time(NULL)-server.stat_starttime;\n    int j;\n    char hmem[64];\n    struct rusage self_ru, c_ru;\n\n    getrusage(RUSAGE_SELF, &self_ru);\n    getrusage(RUSAGE_CHILDREN, &c_ru);\n\n    bytesToHuman(hmem,zmalloc_used_memory());\n    info = sdscatprintf(sdsempty(),\n        \"redis_version:%s\\r\\n\"\n        \"redis_git_sha1:%s\\r\\n\"\n        \"redis_git_dirty:%d\\r\\n\"\n        \"arch_bits:%s\\r\\n\"\n        \"multiplexing_api:%s\\r\\n\"\n        \"process_id:%ld\\r\\n\"\n        \"uptime_in_seconds:%ld\\r\\n\"\n        \"uptime_in_days:%ld\\r\\n\"\n        \"lru_clock:%ld\\r\\n\"\n        \"used_cpu_sys:%.2f\\r\\n\"\n        \"used_cpu_user:%.2f\\r\\n\"\n        \"used_cpu_sys_childrens:%.2f\\r\\n\"\n        \"used_cpu_user_childrens:%.2f\\r\\n\"\n        \"connected_clients:%d\\r\\n\"\n        \"connected_slaves:%d\\r\\n\"\n        \"blocked_clients:%d\\r\\n\"\n        \"used_memory:%zu\\r\\n\"\n        \"used_memory_human:%s\\r\\n\"\n        \"used_memory_rss:%zu\\r\\n\"\n        \"mem_fragmentation_ratio:%.2f\\r\\n\"\n        \"use_tcmalloc:%d\\r\\n\"\n        \"loading:%d\\r\\n\"\n        \"aof_enabled:%d\\r\\n\"\n        \"changes_since_last_save:%lld\\r\\n\"\n        \"bgsave_in_progress:%d\\r\\n\"\n        \"last_save_time:%ld\\r\\n\"\n        \"bgrewriteaof_in_progress:%d\\r\\n\"\n        \"total_connections_received:%lld\\r\\n\"\n        \"total_commands_processed:%lld\\r\\n\"\n        \"expired_keys:%lld\\r\\n\"\n        \"evicted_keys:%lld\\r\\n\"\n        \"keyspace_hits:%lld\\r\\n\"\n        \"keyspace_misses:%lld\\r\\n\"\n        \"hash_max_zipmap_entries:%zu\\r\\n\"\n        \"hash_max_zipmap_value:%zu\\r\\n\"\n        \"pubsub_channels:%ld\\r\\n\"\n        \"pubsub_patterns:%u\\r\\n\"\n        \"ds_enabled:%d\\r\\n\"\n        \"role:%s\\r\\n\"\n        ,REDIS_VERSION,\n        redisGitSHA1(),\n        strtol(redisGitDirty(),NULL,10) > 0,\n        (sizeof(long) == 8) ? \"64\" : \"32\",\n        aeGetApiName(),\n        (long) getpid(),\n        uptime,\n        uptime/(3600*24),\n        (unsigned long) server.lruclock,\n        (float)self_ru.ru_utime.tv_sec+(float)self_ru.ru_utime.tv_usec/1000000,\n        (float)self_ru.ru_stime.tv_sec+(float)self_ru.ru_stime.tv_usec/1000000,\n        (float)c_ru.ru_utime.tv_sec+(float)c_ru.ru_utime.tv_usec/1000000,\n        (float)c_ru.ru_stime.tv_sec+(float)c_ru.ru_stime.tv_usec/1000000,\n        listLength(server.clients)-listLength(server.slaves),\n        listLength(server.slaves),\n        server.bpop_blocked_clients,\n        zmalloc_used_memory(),\n        hmem,\n        zmalloc_get_rss(),\n        zmalloc_get_fragmentation_ratio(),\n#ifdef USE_TCMALLOC\n        1,\n#else\n        0,\n#endif\n        server.loading,\n        server.appendonly,\n        server.dirty,\n        server.bgsavechildpid != -1,\n        server.lastsave,\n        server.bgrewritechildpid != -1,\n        server.stat_numconnections,\n        server.stat_numcommands,\n        server.stat_expiredkeys,\n        server.stat_evictedkeys,\n        server.stat_keyspace_hits,\n        server.stat_keyspace_misses,\n        server.hash_max_zipmap_entries,\n        server.hash_max_zipmap_value,\n        dictSize(server.pubsub_channels),\n        listLength(server.pubsub_patterns),\n        server.ds_enabled != 0,\n        server.masterhost == NULL ? \"master\" : \"slave\"\n    );\n    if (server.masterhost) {\n        info = sdscatprintf(info,\n            \"master_host:%s\\r\\n\"\n            \"master_port:%d\\r\\n\"\n            \"master_link_status:%s\\r\\n\"\n            \"master_last_io_seconds_ago:%d\\r\\n\"\n            \"master_sync_in_progress:%d\\r\\n\"\n            ,server.masterhost,\n            server.masterport,\n            (server.replstate == REDIS_REPL_CONNECTED) ?\n                \"up\" : \"down\",\n            server.master ? ((int)(time(NULL)-server.master->lastinteraction)) : -1,\n            server.replstate == REDIS_REPL_TRANSFER\n        );\n\n        if (server.replstate == REDIS_REPL_TRANSFER) {\n            info = sdscatprintf(info,\n                \"master_sync_left_bytes:%ld\\r\\n\"\n                \"master_sync_last_io_seconds_ago:%d\\r\\n\"\n                ,(long)server.repl_transfer_left,\n                (int)(time(NULL)-server.repl_transfer_lastio)\n            );\n        }\n    }\n    if (server.ds_enabled) {\n        lockThreadedIO();\n        info = sdscatprintf(info,\n            \"cache_max_memory:%llu\\r\\n\"\n            \"cache_blocked_clients:%lu\\r\\n\"\n            ,(unsigned long long) server.cache_max_memory,\n            (unsigned long) server.cache_blocked_clients\n        );\n        unlockThreadedIO();\n    }\n    if (server.loading) {\n        double perc;\n        time_t eta, elapsed;\n        off_t remaining_bytes = server.loading_total_bytes-\n                                server.loading_loaded_bytes;\n\n        perc = ((double)server.loading_loaded_bytes /\n               server.loading_total_bytes) * 100;\n\n        elapsed = time(NULL)-server.loading_start_time;\n        if (elapsed == 0) {\n            eta = 1; /* A fake 1 second figure if we don't have enough info */\n        } else {\n            eta = (elapsed*remaining_bytes)/server.loading_loaded_bytes;\n        }\n\n        info = sdscatprintf(info,\n            \"loading_start_time:%ld\\r\\n\"\n            \"loading_total_bytes:%llu\\r\\n\"\n            \"loading_loaded_bytes:%llu\\r\\n\"\n            \"loading_loaded_perc:%.2f\\r\\n\"\n            \"loading_eta_seconds:%ld\\r\\n\"\n            ,(unsigned long) server.loading_start_time,\n            (unsigned long long) server.loading_total_bytes,\n            (unsigned long long) server.loading_loaded_bytes,\n            perc,\n            eta\n        );\n    }\n    for (j = 0; j < server.dbnum; j++) {\n        long long keys, vkeys;\n\n        keys = dictSize(server.db[j].dict);\n        vkeys = dictSize(server.db[j].expires);\n        if (keys || vkeys) {\n            info = sdscatprintf(info, \"db%d:keys=%lld,expires=%lld\\r\\n\",\n                j, keys, vkeys);\n        }\n    }\n    return info;\n}\n\nvoid infoCommand(redisClient *c) {\n    sds info = genRedisInfoString();\n    addReplySds(c,sdscatprintf(sdsempty(),\"$%lu\\r\\n\",\n        (unsigned long)sdslen(info)));\n    addReplySds(c,info);\n    addReply(c,shared.crlf);\n}\n\nvoid monitorCommand(redisClient *c) {\n    /* ignore MONITOR if aleady slave or in monitor mode */\n    if (c->flags & REDIS_SLAVE) return;\n\n    c->flags |= (REDIS_SLAVE|REDIS_MONITOR);\n    c->slaveseldb = 0;\n    listAddNodeTail(server.monitors,c);\n    addReply(c,shared.ok);\n}\n\n/* ============================ Maxmemory directive  ======================== */\n\n/* This function gets called when 'maxmemory' is set on the config file to limit\n * the max memory used by the server, and we are out of memory.\n * This function will try to, in order:\n *\n * - Free objects from the free list\n * - Try to remove keys with an EXPIRE set\n *\n * It is not possible to free enough memory to reach used-memory < maxmemory\n * the server will start refusing commands that will enlarge even more the\n * memory usage.\n */\nvoid freeMemoryIfNeeded(void) {\n    /* Remove keys accordingly to the active policy as long as we are\n     * over the memory limit. */\n    if (server.maxmemory_policy == REDIS_MAXMEMORY_NO_EVICTION) return;\n\n    while (server.maxmemory && zmalloc_used_memory() > server.maxmemory) {\n        int j, k, freed = 0;\n\n        for (j = 0; j < server.dbnum; j++) {\n            long bestval = 0; /* just to prevent warning */\n            sds bestkey = NULL;\n            struct dictEntry *de;\n            redisDb *db = server.db+j;\n            dict *dict;\n\n            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||\n                server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM)\n            {\n                dict = server.db[j].dict;\n            } else {\n                dict = server.db[j].expires;\n            }\n            if (dictSize(dict) == 0) continue;\n\n            /* volatile-random and allkeys-random policy */\n            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM ||\n                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_RANDOM)\n            {\n                de = dictGetRandomKey(dict);\n                bestkey = dictGetEntryKey(de);\n            }\n\n            /* volatile-lru and allkeys-lru policy */\n            else if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||\n                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)\n            {\n                for (k = 0; k < server.maxmemory_samples; k++) {\n                    sds thiskey;\n                    long thisval;\n                    robj *o;\n\n                    de = dictGetRandomKey(dict);\n                    thiskey = dictGetEntryKey(de);\n                    /* When policy is volatile-lru we need an additonal lookup\n                     * to locate the real key, as dict is set to db->expires. */\n                    if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)\n                        de = dictFind(db->dict, thiskey);\n                    o = dictGetEntryVal(de);\n                    thisval = estimateObjectIdleTime(o);\n\n                    /* Higher idle time is better candidate for deletion */\n                    if (bestkey == NULL || thisval > bestval) {\n                        bestkey = thiskey;\n                        bestval = thisval;\n                    }\n                }\n            }\n\n            /* volatile-ttl */\n            else if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_TTL) {\n                for (k = 0; k < server.maxmemory_samples; k++) {\n                    sds thiskey;\n                    long thisval;\n\n                    de = dictGetRandomKey(dict);\n                    thiskey = dictGetEntryKey(de);\n                    thisval = (long) dictGetEntryVal(de);\n\n                    /* Expire sooner (minor expire unix timestamp) is better\n                     * candidate for deletion */\n                    if (bestkey == NULL || thisval < bestval) {\n                        bestkey = thiskey;\n                        bestval = thisval;\n                    }\n                }\n            }\n\n            /* Finally remove the selected key. */\n            if (bestkey) {\n                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));\n                dbDelete(db,keyobj);\n                server.stat_evictedkeys++;\n                decrRefCount(keyobj);\n                freed++;\n            }\n        }\n        if (!freed) return; /* nothing to free... */\n    }\n}\n\n/* =================================== Main! ================================ */\n\n#ifdef __linux__\nint linuxOvercommitMemoryValue(void) {\n    FILE *fp = fopen(\"/proc/sys/vm/overcommit_memory\",\"r\");\n    char buf[64];\n\n    if (!fp) return -1;\n    if (fgets(buf,64,fp) == NULL) {\n        fclose(fp);\n        return -1;\n    }\n    fclose(fp);\n\n    return atoi(buf);\n}\n\nvoid linuxOvercommitMemoryWarning(void) {\n    if (linuxOvercommitMemoryValue() == 0) {\n        redisLog(REDIS_WARNING,\"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\");\n    }\n}\n#endif /* __linux__ */\n\nvoid createPidFile(void) {\n    /* Try to write the pid file in a best-effort way. */\n    FILE *fp = fopen(server.pidfile,\"w\");\n    if (fp) {\n        fprintf(fp,\"%d\\n\",getpid());\n        fclose(fp);\n    }\n}\n\nvoid daemonize(void) {\n    int fd;\n\n    if (fork() != 0) exit(0); /* parent exits */\n    setsid(); /* create a new session */\n\n    /* Every output goes to /dev/null. If Redis is daemonized but\n     * the 'logfile' is set to 'stdout' in the configuration file\n     * it will not log at all. */\n    if ((fd = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n        dup2(fd, STDIN_FILENO);\n        dup2(fd, STDOUT_FILENO);\n        dup2(fd, STDERR_FILENO);\n        if (fd > STDERR_FILENO) close(fd);\n    }\n}\n\nvoid version() {\n    printf(\"Redis server version %s (%s:%d)\\n\", REDIS_VERSION,\n        redisGitSHA1(), atoi(redisGitDirty()) > 0);\n    exit(0);\n}\n\nvoid usage() {\n    fprintf(stderr,\"Usage: ./redis-server [/path/to/redis.conf]\\n\");\n    fprintf(stderr,\"       ./redis-server - (read config from stdin)\\n\");\n    exit(1);\n}\n\nint main(int argc, char **argv) {\n    time_t start;\n\n    initServerConfig();\n    if (argc == 2) {\n        if (strcmp(argv[1], \"-v\") == 0 ||\n            strcmp(argv[1], \"--version\") == 0) version();\n        if (strcmp(argv[1], \"--help\") == 0) usage();\n        resetServerSaveParams();\n        loadServerConfig(argv[1]);\n    } else if ((argc > 2)) {\n        usage();\n    } else {\n        redisLog(REDIS_WARNING,\"Warning: no config file specified, using the default config. In order to specify a config file use 'redis-server /path/to/redis.conf'\");\n    }\n    if (server.daemonize) daemonize();\n    initServer();\n    if (server.daemonize) createPidFile();\n    redisLog(REDIS_NOTICE,\"Server started, Redis version \" REDIS_VERSION);\n#ifdef __linux__\n    linuxOvercommitMemoryWarning();\n#endif\n    start = time(NULL);\n    if (server.appendonly) {\n        if (loadAppendOnlyFile(server.appendfilename) == REDIS_OK)\n            redisLog(REDIS_NOTICE,\"DB loaded from append only file: %ld seconds\",time(NULL)-start);\n    } else {\n        if (rdbLoad(server.dbfilename) == REDIS_OK)\n            redisLog(REDIS_NOTICE,\"DB loaded from disk: %ld seconds\",time(NULL)-start);\n    }\n    if (server.ipfd > 0)\n        redisLog(REDIS_NOTICE,\"The server is now ready to accept connections on port %d\", server.port);\n    if (server.sofd > 0)\n        redisLog(REDIS_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket);\n    aeSetBeforeSleepProc(server.el,beforeSleep);\n    aeMain(server.el);\n    aeDeleteEventLoop(server.el);\n    return 0;\n}\n\n/* ============================= Backtrace support ========================= */\n\n#ifdef HAVE_BACKTRACE\nvoid *getMcontextEip(ucontext_t *uc) {\n#if defined(__FreeBSD__)\n    return (void*) uc->uc_mcontext.mc_eip;\n#elif defined(__dietlibc__)\n    return (void*) uc->uc_mcontext.eip;\n#elif defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)\n  #if __x86_64__\n    return (void*) uc->uc_mcontext->__ss.__rip;\n  #else\n    return (void*) uc->uc_mcontext->__ss.__eip;\n  #endif\n#elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)\n  #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)\n    return (void*) uc->uc_mcontext->__ss.__rip;\n  #else\n    return (void*) uc->uc_mcontext->__ss.__eip;\n  #endif\n#elif defined(__i386__)\n    return (void*) uc->uc_mcontext.gregs[14]; /* Linux 32 */\n#elif defined(__X86_64__) || defined(__x86_64__)\n    return (void*) uc->uc_mcontext.gregs[16]; /* Linux 64 */\n#elif defined(__ia64__) /* Linux IA64 */\n    return (void*) uc->uc_mcontext.sc_ip;\n#else\n    return NULL;\n#endif\n}\n\nvoid segvHandler(int sig, siginfo_t *info, void *secret) {\n    void *trace[100];\n    char **messages = NULL;\n    int i, trace_size = 0;\n    ucontext_t *uc = (ucontext_t*) secret;\n    sds infostring;\n    struct sigaction act;\n    REDIS_NOTUSED(info);\n\n    redisLog(REDIS_WARNING,\n        \"======= Ooops! Redis %s got signal: -%d- =======\", REDIS_VERSION, sig);\n    infostring = genRedisInfoString();\n    redisLog(REDIS_WARNING, \"%s\",infostring);\n    /* It's not safe to sdsfree() the returned string under memory\n     * corruption conditions. Let it leak as we are going to abort */\n\n    trace_size = backtrace(trace, 100);\n    /* overwrite sigaction with caller's address */\n    if (getMcontextEip(uc) != NULL) {\n        trace[1] = getMcontextEip(uc);\n    }\n    messages = backtrace_symbols(trace, trace_size);\n\n    for (i=1; i<trace_size; ++i)\n        redisLog(REDIS_WARNING,\"%s\", messages[i]);\n\n    /* free(messages); Don't call free() with possibly corrupted memory. */\n    if (server.daemonize) unlink(server.pidfile);\n\n    /* Make sure we exit with the right signal at the end. So for instance\n     * the core will be dumped if enabled. */\n    sigemptyset (&act.sa_mask);\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction\n     * is used. Otherwise, sa_handler is used */\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = SIG_DFL;\n    sigaction (sig, &act, NULL);\n    kill(getpid(),sig);\n}\n\nvoid sigtermHandler(int sig) {\n    REDIS_NOTUSED(sig);\n\n    redisLog(REDIS_WARNING,\"SIGTERM received, scheduling shutting down...\");\n    server.shutdown_asap = 1;\n}\n\nvoid setupSigSegvAction(void) {\n    struct sigaction act;\n\n    sigemptyset (&act.sa_mask);\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction\n     * is used. Otherwise, sa_handler is used */\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = segvHandler;\n    sigaction (SIGSEGV, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n    sigaction (SIGFPE, &act, NULL);\n    sigaction (SIGILL, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = sigtermHandler;\n    sigaction (SIGTERM, &act, NULL);\n    return;\n}\n\n#else /* HAVE_BACKTRACE */\nvoid setupSigSegvAction(void) {\n}\n#endif /* HAVE_BACKTRACE */\n\n/* The End */\n", "#ifndef __REDIS_H\n#define __REDIS_H\n\n#include \"fmacros.h\"\n#include \"config.h\"\n\n#if defined(__sun)\n#include \"solarisfixes.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n#include <unistd.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <pthread.h>\n#include <syslog.h>\n\n#include \"ae.h\"     /* Event driven programming library */\n#include \"sds.h\"    /* Dynamic safe strings */\n#include \"dict.h\"   /* Hash tables */\n#include \"adlist.h\" /* Linked lists */\n#include \"zmalloc.h\" /* total memory usage aware version of malloc/free */\n#include \"anet.h\"   /* Networking the easy way */\n#include \"zipmap.h\" /* Compact string -> string data structure */\n#include \"ziplist.h\" /* Compact list data structure */\n#include \"intset.h\" /* Compact integer set structure */\n#include \"version.h\"\n\n/* Error codes */\n#define REDIS_OK                0\n#define REDIS_ERR               -1\n\n/* Static server configuration */\n#define REDIS_SERVERPORT        6379    /* TCP port */\n#define REDIS_MAXIDLETIME       (60*5)  /* default client timeout */\n#define REDIS_IOBUF_LEN         1024\n#define REDIS_LOADBUF_LEN       1024\n#define REDIS_STATIC_ARGS       8\n#define REDIS_DEFAULT_DBNUM     16\n#define REDIS_CONFIGLINE_MAX    1024\n#define REDIS_MAX_SYNC_TIME     60      /* Slave can't take more to sync */\n#define REDIS_EXPIRELOOKUPS_PER_CRON    10 /* lookup 10 expires per loop */\n#define REDIS_MAX_WRITE_PER_EVENT (1024*64)\n#define REDIS_REQUEST_MAX_SIZE (1024*1024*256) /* max bytes in inline command */\n#define REDIS_SHARED_INTEGERS 10000\n#define REDIS_REPLY_CHUNK_BYTES (5*1500) /* 5 TCP packets with default MTU */\n#define REDIS_MAX_LOGMSG_LEN    1024 /* Default maximum length of syslog messages */\n\n/* If more then REDIS_WRITEV_THRESHOLD write packets are pending use writev */\n#define REDIS_WRITEV_THRESHOLD      3\n/* Max number of iovecs used for each writev call */\n#define REDIS_WRITEV_IOVEC_COUNT    256\n\n/* Hash table parameters */\n#define REDIS_HT_MINFILL        10      /* Minimal hash table fill 10% */\n\n/* Command flags:\n *   REDIS_CMD_DENYOOM:\n *     Commands marked with this flag will return an error when 'maxmemory' is\n *     set and the server is using more than 'maxmemory' bytes of memory.\n *     In short: commands with this flag are denied on low memory conditions.\n *   REDIS_CMD_FORCE_REPLICATION:\n *     Force replication even if dirty is 0. */\n#define REDIS_CMD_DENYOOM 4\n#define REDIS_CMD_FORCE_REPLICATION 8\n\n/* Object types */\n#define REDIS_STRING 0\n#define REDIS_LIST 1\n#define REDIS_SET 2\n#define REDIS_ZSET 3\n#define REDIS_HASH 4\n#define REDIS_VMPOINTER 8\n\n/* Objects encoding. Some kind of objects like Strings and Hashes can be\n * internally represented in multiple ways. The 'encoding' field of the object\n * is set to one of this fields for this object. */\n#define REDIS_ENCODING_RAW 0     /* Raw representation */\n#define REDIS_ENCODING_INT 1     /* Encoded as integer */\n#define REDIS_ENCODING_HT 2      /* Encoded as hash table */\n#define REDIS_ENCODING_ZIPMAP 3  /* Encoded as zipmap */\n#define REDIS_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */\n#define REDIS_ENCODING_ZIPLIST 5 /* Encoded as ziplist */\n#define REDIS_ENCODING_INTSET 6  /* Encoded as intset */\n\n/* Object types only used for dumping to disk */\n#define REDIS_EXPIRETIME 253\n#define REDIS_SELECTDB 254\n#define REDIS_EOF 255\n\n/* Defines related to the dump file format. To store 32 bits lengths for short\n * keys requires a lot of space, so we check the most significant 2 bits of\n * the first byte to interpreter the length:\n *\n * 00|000000 => if the two MSB are 00 the len is the 6 bits of this byte\n * 01|000000 00000000 =>  01, the len is 14 byes, 6 bits + 8 bits of next byte\n * 10|000000 [32 bit integer] => if it's 01, a full 32 bit len will follow\n * 11|000000 this means: specially encoded object will follow. The six bits\n *           number specify the kind of object that follows.\n *           See the REDIS_RDB_ENC_* defines.\n *\n * Lenghts up to 63 are stored using a single byte, most DB keys, and may\n * values, will fit inside. */\n#define REDIS_RDB_6BITLEN 0\n#define REDIS_RDB_14BITLEN 1\n#define REDIS_RDB_32BITLEN 2\n#define REDIS_RDB_ENCVAL 3\n#define REDIS_RDB_LENERR UINT_MAX\n\n/* When a length of a string object stored on disk has the first two bits\n * set, the remaining two bits specify a special encoding for the object\n * accordingly to the following defines: */\n#define REDIS_RDB_ENC_INT8 0        /* 8 bit signed integer */\n#define REDIS_RDB_ENC_INT16 1       /* 16 bit signed integer */\n#define REDIS_RDB_ENC_INT32 2       /* 32 bit signed integer */\n#define REDIS_RDB_ENC_LZF 3         /* string compressed with FASTLZ */\n\n/* Virtual memory object->where field. */\n#define REDIS_VM_MEMORY 0       /* The object is on memory */\n#define REDIS_VM_SWAPPED 1      /* The object is on disk */\n#define REDIS_VM_SWAPPING 2     /* Redis is swapping this object on disk */\n#define REDIS_VM_LOADING 3      /* Redis is loading this object from disk */\n\n/* Virtual memory static configuration stuff.\n * Check vmFindContiguousPages() to know more about this magic numbers. */\n#define REDIS_VM_MAX_NEAR_PAGES 65536\n#define REDIS_VM_MAX_RANDOM_JUMP 4096\n#define REDIS_VM_MAX_THREADS 32\n#define REDIS_THREAD_STACK_SIZE (1024*1024*4)\n/* The following is the *percentage* of completed I/O jobs to process when the\n * handelr is called. While Virtual Memory I/O operations are performed by\n * threads, this operations must be processed by the main thread when completed\n * in order to take effect. */\n#define REDIS_MAX_COMPLETED_JOBS_PROCESSED 1\n\n/* Client flags */\n#define REDIS_SLAVE 1       /* This client is a slave server */\n#define REDIS_MASTER 2      /* This client is a master server */\n#define REDIS_MONITOR 4     /* This client is a slave monitor, see MONITOR */\n#define REDIS_MULTI 8       /* This client is in a MULTI context */\n#define REDIS_BLOCKED 16    /* The client is waiting in a blocking operation */\n#define REDIS_IO_WAIT 32    /* The client is waiting for Virtual Memory I/O */\n#define REDIS_DIRTY_CAS 64  /* Watched keys modified. EXEC will fail. */\n#define REDIS_CLOSE_AFTER_REPLY 128 /* Close after writing entire reply. */\n\n/* Client request types */\n#define REDIS_REQ_INLINE 1\n#define REDIS_REQ_MULTIBULK 2\n\n/* Slave replication state - slave side */\n#define REDIS_REPL_NONE 0   /* No active replication */\n#define REDIS_REPL_CONNECT 1    /* Must connect to master */\n#define REDIS_REPL_TRANSFER 2    /* Receiving .rdb from master */\n#define REDIS_REPL_CONNECTED 3  /* Connected to master */\n\n/* Slave replication state - from the point of view of master\n * Note that in SEND_BULK and ONLINE state the slave receives new updates\n * in its output queue. In the WAIT_BGSAVE state instead the server is waiting\n * to start the next background saving in order to send updates to it. */\n#define REDIS_REPL_WAIT_BGSAVE_START 3 /* master waits bgsave to start feeding it */\n#define REDIS_REPL_WAIT_BGSAVE_END 4 /* master waits bgsave to start bulk DB transmission */\n#define REDIS_REPL_SEND_BULK 5 /* master is sending the bulk DB */\n#define REDIS_REPL_ONLINE 6 /* bulk DB already transmitted, receive updates */\n\n/* List related stuff */\n#define REDIS_HEAD 0\n#define REDIS_TAIL 1\n\n/* Sort operations */\n#define REDIS_SORT_GET 0\n#define REDIS_SORT_ASC 1\n#define REDIS_SORT_DESC 2\n#define REDIS_SORTKEY_MAX 1024\n\n/* Log levels */\n#define REDIS_DEBUG 0\n#define REDIS_VERBOSE 1\n#define REDIS_NOTICE 2\n#define REDIS_WARNING 3\n\n/* Anti-warning macro... */\n#define REDIS_NOTUSED(V) ((void) V)\n\n#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */\n#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */\n\n/* Append only defines */\n#define APPENDFSYNC_NO 0\n#define APPENDFSYNC_ALWAYS 1\n#define APPENDFSYNC_EVERYSEC 2\n\n/* Zip structure related defaults */\n#define REDIS_HASH_MAX_ZIPMAP_ENTRIES 64\n#define REDIS_HASH_MAX_ZIPMAP_VALUE 512\n#define REDIS_LIST_MAX_ZIPLIST_ENTRIES 512\n#define REDIS_LIST_MAX_ZIPLIST_VALUE 64\n#define REDIS_SET_MAX_INTSET_ENTRIES 512\n\n/* Sets operations codes */\n#define REDIS_OP_UNION 0\n#define REDIS_OP_DIFF 1\n#define REDIS_OP_INTER 2\n\n/* Redis maxmemory strategies */\n#define REDIS_MAXMEMORY_VOLATILE_LRU 0\n#define REDIS_MAXMEMORY_VOLATILE_TTL 1\n#define REDIS_MAXMEMORY_VOLATILE_RANDOM 2\n#define REDIS_MAXMEMORY_ALLKEYS_LRU 3\n#define REDIS_MAXMEMORY_ALLKEYS_RANDOM 4\n#define REDIS_MAXMEMORY_NO_EVICTION 5\n\n/* We can print the stacktrace, so our assert is defined this way: */\n#define redisAssert(_e) ((_e)?(void)0 : (_redisAssert(#_e,__FILE__,__LINE__),_exit(1)))\n#define redisPanic(_e) _redisPanic(#_e,__FILE__,__LINE__),_exit(1)\nvoid _redisAssert(char *estr, char *file, int line);\nvoid _redisPanic(char *msg, char *file, int line);\n\n/*-----------------------------------------------------------------------------\n * Data types\n *----------------------------------------------------------------------------*/\n\n/* A redis object, that is a type able to hold a string / list / set */\n\n/* The actual Redis Object */\n#define REDIS_LRU_CLOCK_MAX ((1<<21)-1) /* Max value of obj->lru */\n#define REDIS_LRU_CLOCK_RESOLUTION 10 /* LRU clock resolution in seconds */\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned storage:2;     /* REDIS_VM_MEMORY or REDIS_VM_SWAPPING */\n    unsigned encoding:4;\n    unsigned lru:22;        /* lru time (relative to server.lruclock) */\n    int refcount;\n    void *ptr;\n    /* VM fields are only allocated if VM is active, otherwise the\n     * object allocation function will just allocate\n     * sizeof(redisObjct) minus sizeof(redisObjectVM), so using\n     * Redis without VM active will not have any overhead. */\n} robj;\n\n/* The VM pointer structure - identifies an object in the swap file.\n *\n * This object is stored in place of the value\n * object in the main key->value hash table representing a database.\n * Note that the first fields (type, storage) are the same as the redisObject\n * structure so that vmPointer strucuters can be accessed even when casted\n * as redisObject structures.\n *\n * This is useful as we don't know if a value object is or not on disk, but we\n * are always able to read obj->storage to check this. For vmPointer\n * structures \"type\" is set to REDIS_VMPOINTER (even if without this field\n * is still possible to check the kind of object from the value of 'storage').*/\ntypedef struct vmPointer {\n    unsigned type:4;\n    unsigned storage:2; /* REDIS_VM_SWAPPED or REDIS_VM_LOADING */\n    unsigned notused:26;\n    unsigned int vtype; /* type of the object stored in the swap file */\n    off_t page;         /* the page at witch the object is stored on disk */\n    off_t usedpages;    /* number of pages used on disk */\n} vmpointer;\n\n/* Macro used to initalize a Redis object allocated on the stack.\n * Note that this macro is taken near the structure definition to make sure\n * we'll update it when the structure is changed, to avoid bugs like\n * bug #85 introduced exactly in this way. */\n#define initStaticStringObject(_var,_ptr) do { \\\n    _var.refcount = 1; \\\n    _var.type = REDIS_STRING; \\\n    _var.encoding = REDIS_ENCODING_RAW; \\\n    _var.ptr = _ptr; \\\n    _var.storage = REDIS_VM_MEMORY; \\\n} while(0);\n\ntypedef struct redisDb {\n    dict *dict;                 /* The keyspace for this DB */\n    dict *expires;              /* Timeout of keys with a timeout set */\n    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */\n    dict *io_keys;              /* Keys with clients waiting for VM I/O */\n    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */\n    int id;\n} redisDb;\n\n/* Client MULTI/EXEC state */\ntypedef struct multiCmd {\n    robj **argv;\n    int argc;\n    struct redisCommand *cmd;\n} multiCmd;\n\ntypedef struct multiState {\n    multiCmd *commands;     /* Array of MULTI commands */\n    int count;              /* Total number of MULTI commands */\n} multiState;\n\ntypedef struct blockingState {\n    robj **keys;            /* The key we are waiting to terminate a blocking\n                             * operation such as BLPOP. Otherwise NULL. */\n    int count;              /* Number of blocking keys */\n    time_t timeout;         /* Blocking operation timeout. If UNIX current time\n                             * is >= timeout then the operation timed out. */\n    robj *target;           /* The key that should receive the element,\n                             * for BRPOPLPUSH. */\n} blockingState;\n\n/* With multiplexing we need to take per-clinet state.\n * Clients are taken in a liked list. */\ntypedef struct redisClient {\n    int fd;\n    redisDb *db;\n    int dictid;\n    sds querybuf;\n    int argc;\n    robj **argv;\n    int reqtype;\n    int multibulklen;       /* number of multi bulk arguments left to read */\n    long bulklen;           /* length of bulk argument in multi bulk request */\n    list *reply;\n    int sentlen;\n    time_t lastinteraction; /* time of the last interaction, used for timeout */\n    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */\n    int slaveseldb;         /* slave selected db, if this client is a slave */\n    int authenticated;      /* when requirepass is non-NULL */\n    int replstate;          /* replication state if this is a slave */\n    int repldbfd;           /* replication DB file descriptor */\n    long repldboff;         /* replication DB file offset */\n    off_t repldbsize;       /* replication DB file size */\n    multiState mstate;      /* MULTI/EXEC state */\n    blockingState bpop;   /* blocking state */\n    list *io_keys;          /* Keys this client is waiting to be loaded from the\n                             * swap file in order to continue. */\n    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */\n    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */\n    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */\n\n    /* Response buffer */\n    int bufpos;\n    char buf[REDIS_REPLY_CHUNK_BYTES];\n} redisClient;\n\nstruct saveparam {\n    time_t seconds;\n    int changes;\n};\n\nstruct sharedObjectsStruct {\n    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,\n    *colon, *nullbulk, *nullmultibulk, *queued,\n    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,\n    *outofrangeerr, *loadingerr, *plus,\n    *select0, *select1, *select2, *select3, *select4,\n    *select5, *select6, *select7, *select8, *select9,\n    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,\n    *mbulk4, *psubscribebulk, *punsubscribebulk,\n    *integers[REDIS_SHARED_INTEGERS];\n};\n\n/* Global server state structure */\nstruct redisServer {\n    pthread_t mainthread;\n    int port;\n    char *bindaddr;\n    char *unixsocket;\n    int ipfd;\n    int sofd;\n    redisDb *db;\n    long long dirty;            /* changes to DB from the last save */\n    long long dirty_before_bgsave; /* used to restore dirty on failed BGSAVE */\n    list *clients;\n    dict *commands;             /* Command table hahs table */\n    /* RDB / AOF loading information */\n    int loading;\n    off_t loading_total_bytes;\n    off_t loading_loaded_bytes;\n    time_t loading_start_time;\n    /* Fast pointers to often looked up command */\n    struct redisCommand *delCommand, *multiCommand;\n    list *slaves, *monitors;\n    char neterr[ANET_ERR_LEN];\n    aeEventLoop *el;\n    int cronloops;              /* number of times the cron function run */\n    time_t lastsave;                /* Unix time of last save succeeede */\n    /* Fields used only for stats */\n    time_t stat_starttime;          /* server start time */\n    long long stat_numcommands;     /* number of processed commands */\n    long long stat_numconnections;  /* number of connections received */\n    long long stat_expiredkeys;     /* number of expired keys */\n    long long stat_evictedkeys;     /* number of evicted keys (maxmemory) */\n    long long stat_keyspace_hits;   /* number of successful lookups of keys */\n    long long stat_keyspace_misses; /* number of failed lookups of keys */\n    /* Configuration */\n    int verbosity;\n    int glueoutputbuf;\n    int maxidletime;\n    int dbnum;\n    int daemonize;\n    int appendonly;\n    int appendfsync;\n    int no_appendfsync_on_rewrite;\n    int shutdown_asap;\n    time_t lastfsync;\n    int appendfd;\n    int appendseldb;\n    char *pidfile;\n    pid_t bgsavechildpid;\n    pid_t bgrewritechildpid;\n    sds bgrewritebuf; /* buffer taken by parent during oppend only rewrite */\n    sds aofbuf;       /* AOF buffer, written before entering the event loop */\n    struct saveparam *saveparams;\n    int saveparamslen;\n    char *logfile;\n    int syslog_enabled;\n    char *syslog_ident;\n    int syslog_facility;\n    char *dbfilename;\n    char *appendfilename;\n    char *requirepass;\n    int rdbcompression;\n    int activerehashing;\n    /* Replication related */\n    int isslave;\n    /* Slave specific fields */\n    char *masterauth;\n    char *masterhost;\n    int masterport;\n    redisClient *master;    /* client that is master for this slave */\n    int replstate;          /* replication status if the instance is a slave */\n    off_t repl_transfer_left;  /* bytes left reading .rdb  */\n    int repl_transfer_s;    /* slave -> master SYNC socket */\n    int repl_transfer_fd;   /* slave -> master SYNC temp file descriptor */\n    char *repl_transfer_tmpfile; /* slave-> master SYNC temp file name */\n    time_t repl_transfer_lastio; /* unix time of the latest read, for timeout */\n    int repl_serve_stale_data; /* Serve stale data when link is down? */\n    /* Limits */\n    unsigned int maxclients;\n    unsigned long long maxmemory;\n    int maxmemory_policy;\n    int maxmemory_samples;\n    /* Blocked clients */\n    unsigned int bpop_blocked_clients;\n    unsigned int cache_blocked_clients;\n    list *unblocked_clients;\n    /* Sort parameters - qsort_r() is only available under BSD so we\n     * have to take this state global, in order to pass it to sortCompare() */\n    int sort_desc;\n    int sort_alpha;\n    int sort_bypattern;\n    /* Virtual memory configuration */\n    int ds_enabled; /* backend disk in redis.conf */\n    char *ds_path;  /* location of the disk store on disk */\n    unsigned long long cache_max_memory;\n    /* Zip structure config */\n    size_t hash_max_zipmap_entries;\n    size_t hash_max_zipmap_value;\n    size_t list_max_ziplist_entries;\n    size_t list_max_ziplist_value;\n    size_t set_max_intset_entries;\n    /* Virtual memory state */\n    FILE *vm_fp;\n    int vm_fd;\n    off_t vm_next_page; /* Next probably empty page */\n    off_t vm_near_pages; /* Number of pages allocated sequentially */\n    unsigned char *vm_bitmap; /* Bitmap of free/used pages */\n    time_t unixtime;    /* Unix time sampled every second. */\n    /* Virtual memory I/O threads stuff */\n    /* An I/O thread process an element taken from the io_jobs queue and\n     * put the result of the operation in the io_done list. While the\n     * job is being processed, it's put on io_processing queue. */\n    list *io_newjobs; /* List of VM I/O jobs yet to be processed */\n    list *io_processing; /* List of VM I/O jobs being processed */\n    list *io_processed; /* List of VM I/O jobs already processed */\n    list *io_ready_clients; /* Clients ready to be unblocked. All keys loaded */\n    pthread_mutex_t io_mutex; /* lock to access io_jobs/io_done/io_thread_job */\n    pthread_mutex_t io_swapfile_mutex; /* So we can lseek + write */\n    pthread_attr_t io_threads_attr; /* attributes for threads creation */\n    int io_active_threads; /* Number of running I/O threads */\n    int vm_max_threads; /* Max number of I/O threads running at the same time */\n    /* Our main thread is blocked on the event loop, locking for sockets ready\n     * to be read or written, so when a threaded I/O operation is ready to be\n     * processed by the main thread, the I/O thread will use a unix pipe to\n     * awake the main thread. The followings are the two pipe FDs. */\n    int io_ready_pipe_read;\n    int io_ready_pipe_write;\n    /* Virtual memory stats */\n    unsigned long long vm_stats_used_pages;\n    unsigned long long vm_stats_swapped_objects;\n    unsigned long long vm_stats_swapouts;\n    unsigned long long vm_stats_swapins;\n    /* Pubsub */\n    dict *pubsub_channels; /* Map channels to list of subscribed clients */\n    list *pubsub_patterns; /* A list of pubsub_patterns */\n    /* Misc */\n    unsigned lruclock:22;        /* clock incrementing every minute, for LRU */\n    unsigned lruclock_padding:10;\n};\n\ntypedef struct pubsubPattern {\n    redisClient *client;\n    robj *pattern;\n} pubsubPattern;\n\ntypedef void redisCommandProc(redisClient *c);\ntypedef void redisVmPreloadProc(redisClient *c, struct redisCommand *cmd, int argc, robj **argv);\nstruct redisCommand {\n    char *name;\n    redisCommandProc *proc;\n    int arity;\n    int flags;\n    /* Use a function to determine which keys need to be loaded\n     * in the background prior to executing this command. Takes precedence\n     * over vm_firstkey and others, ignored when NULL */\n    redisVmPreloadProc *vm_preload_proc;\n    /* What keys should be loaded in background when calling this command? */\n    int vm_firstkey; /* The first argument that's a key (0 = no keys) */\n    int vm_lastkey;  /* THe last argument that's a key */\n    int vm_keystep;  /* The step between first and last key */\n};\n\nstruct redisFunctionSym {\n    char *name;\n    unsigned long pointer;\n};\n\ntypedef struct _redisSortObject {\n    robj *obj;\n    union {\n        double score;\n        robj *cmpobj;\n    } u;\n} redisSortObject;\n\ntypedef struct _redisSortOperation {\n    int type;\n    robj *pattern;\n} redisSortOperation;\n\n/* ZSETs use a specialized version of Skiplists */\ntypedef struct zskiplistNode {\n    robj *obj;\n    double score;\n    struct zskiplistNode *backward;\n    struct zskiplistLevel {\n        struct zskiplistNode *forward;\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail;\n    unsigned long length;\n    int level;\n} zskiplist;\n\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n\n/* VM threaded I/O request message */\n#define REDIS_IOJOB_LOAD 0          /* Load from disk to memory */\n#define REDIS_IOJOB_PREPARE_SWAP 1  /* Compute needed pages */\n#define REDIS_IOJOB_DO_SWAP 2       /* Swap from memory to disk */\ntypedef struct iojob {\n    int type;   /* Request type, REDIS_IOJOB_* */\n    redisDb *db;/* Redis database */\n    robj *key;  /* This I/O request is about swapping this key */\n    robj *id;   /* Unique identifier of this job:\n                   this is the object to swap for REDIS_IOREQ_*_SWAP, or the\n                   vmpointer objct for REDIS_IOREQ_LOAD. */\n    robj *val;  /* the value to swap for REDIS_IOREQ_*_SWAP, otherwise this\n                 * field is populated by the I/O thread for REDIS_IOREQ_LOAD. */\n    off_t page; /* Swap page where to read/write the object */\n    off_t pages; /* Swap pages needed to save object. PREPARE_SWAP return val */\n    int canceled; /* True if this command was canceled by blocking side of VM */\n    pthread_t thread; /* ID of the thread processing this entry */\n} iojob;\n\n/* Structure to hold list iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    unsigned char encoding;\n    unsigned char direction; /* Iteration direction */\n    unsigned char *zi;\n    listNode *ln;\n} listTypeIterator;\n\n/* Structure for an entry while iterating over a list. */\ntypedef struct {\n    listTypeIterator *li;\n    unsigned char *zi;  /* Entry in ziplist */\n    listNode *ln;       /* Entry in linked list */\n} listTypeEntry;\n\n/* Structure to hold set iteration abstraction. */\ntypedef struct {\n    robj *subject;\n    int encoding;\n    int ii; /* intset iterator */\n    dictIterator *di;\n} setTypeIterator;\n\n/* Structure to hold hash iteration abstration. Note that iteration over\n * hashes involves both fields and values. Because it is possible that\n * not both are required, store pointers in the iterator to avoid\n * unnecessary memory allocation for fields/values. */\ntypedef struct {\n    int encoding;\n    unsigned char *zi;\n    unsigned char *zk, *zv;\n    unsigned int zklen, zvlen;\n\n    dictIterator *di;\n    dictEntry *de;\n} hashTypeIterator;\n\n#define REDIS_HASH_KEY 1\n#define REDIS_HASH_VALUE 2\n\n/*-----------------------------------------------------------------------------\n * Extern declarations\n *----------------------------------------------------------------------------*/\n\nextern struct redisServer server;\nextern struct sharedObjectsStruct shared;\nextern dictType setDictType;\nextern dictType zsetDictType;\nextern double R_Zero, R_PosInf, R_NegInf, R_Nan;\ndictType hashDictType;\n\n/*-----------------------------------------------------------------------------\n * Functions prototypes\n *----------------------------------------------------------------------------*/\n\n/* networking.c -- Networking and Client related operations */\nredisClient *createClient(int fd);\nvoid closeTimedoutClients(void);\nvoid freeClient(redisClient *c);\nvoid resetClient(redisClient *c);\nvoid sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid sendReplyToClientWritev(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid addReply(redisClient *c, robj *obj);\nvoid *addDeferredMultiBulkLength(redisClient *c);\nvoid setDeferredMultiBulkLength(redisClient *c, void *node, long length);\nvoid addReplySds(redisClient *c, sds s);\nvoid processInputBuffer(redisClient *c);\nvoid acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid addReplyBulk(redisClient *c, robj *obj);\nvoid addReplyBulkCString(redisClient *c, char *s);\nvoid addReplyBulkCBuffer(redisClient *c, void *p, size_t len);\nvoid addReplyBulkLongLong(redisClient *c, long long ll);\nvoid acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid addReply(redisClient *c, robj *obj);\nvoid addReplySds(redisClient *c, sds s);\nvoid addReplyError(redisClient *c, char *err);\nvoid addReplyStatus(redisClient *c, char *status);\nvoid addReplyDouble(redisClient *c, double d);\nvoid addReplyLongLong(redisClient *c, long long ll);\nvoid addReplyMultiBulkLen(redisClient *c, long length);\nvoid *dupClientReplyValue(void *o);\n\n#ifdef __GNUC__\nvoid addReplyErrorFormat(redisClient *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\nvoid addReplyStatusFormat(redisClient *c, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nvoid addReplyErrorFormat(redisClient *c, const char *fmt, ...);\nvoid addReplyStatusFormat(redisClient *c, const char *fmt, ...);\n#endif\n\n/* List data type */\nvoid listTypeTryConversion(robj *subject, robj *value);\nvoid listTypePush(robj *subject, robj *value, int where);\nrobj *listTypePop(robj *subject, int where);\nunsigned long listTypeLength(robj *subject);\nlistTypeIterator *listTypeInitIterator(robj *subject, int index, unsigned char direction);\nvoid listTypeReleaseIterator(listTypeIterator *li);\nint listTypeNext(listTypeIterator *li, listTypeEntry *entry);\nrobj *listTypeGet(listTypeEntry *entry);\nvoid listTypeInsert(listTypeEntry *entry, robj *value, int where);\nint listTypeEqual(listTypeEntry *entry, robj *o);\nvoid listTypeDelete(listTypeEntry *entry);\nvoid listTypeConvert(robj *subject, int enc);\nvoid unblockClientWaitingData(redisClient *c);\nint handleClientsWaitingListPush(redisClient *c, robj *key, robj *ele);\nvoid popGenericCommand(redisClient *c, int where);\n\n/* MULTI/EXEC/WATCH... */\nvoid unwatchAllKeys(redisClient *c);\nvoid initClientMultiState(redisClient *c);\nvoid freeClientMultiState(redisClient *c);\nvoid queueMultiCommand(redisClient *c, struct redisCommand *cmd);\nvoid touchWatchedKey(redisDb *db, robj *key);\nvoid touchWatchedKeysOnFlush(int dbid);\n\n/* Redis object implementation */\nvoid decrRefCount(void *o);\nvoid incrRefCount(robj *o);\nvoid freeStringObject(robj *o);\nvoid freeListObject(robj *o);\nvoid freeSetObject(robj *o);\nvoid freeZsetObject(robj *o);\nvoid freeHashObject(robj *o);\nrobj *createObject(int type, void *ptr);\nrobj *createStringObject(char *ptr, size_t len);\nrobj *dupStringObject(robj *o);\nrobj *tryObjectEncoding(robj *o);\nrobj *getDecodedObject(robj *o);\nsize_t stringObjectLen(robj *o);\nrobj *createStringObjectFromLongLong(long long value);\nrobj *createListObject(void);\nrobj *createZiplistObject(void);\nrobj *createSetObject(void);\nrobj *createIntsetObject(void);\nrobj *createHashObject(void);\nrobj *createZsetObject(void);\nint getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg);\nint checkType(redisClient *c, robj *o, int type);\nint getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg);\nint getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg);\nint getLongLongFromObject(robj *o, long long *target);\nchar *strEncoding(int encoding);\nint compareStringObjects(robj *a, robj *b);\nint equalStringObjects(robj *a, robj *b);\nunsigned long estimateObjectIdleTime(robj *o);\n\n/* Synchronous I/O with timeout */\nint syncWrite(int fd, char *ptr, ssize_t size, int timeout);\nint syncRead(int fd, char *ptr, ssize_t size, int timeout);\nint syncReadLine(int fd, char *ptr, ssize_t size, int timeout);\nint fwriteBulkString(FILE *fp, char *s, unsigned long len);\nint fwriteBulkDouble(FILE *fp, double d);\nint fwriteBulkLongLong(FILE *fp, long long l);\nint fwriteBulkObject(FILE *fp, robj *obj);\n\n/* Replication */\nvoid replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);\nvoid replicationFeedMonitors(list *monitors, int dictid, robj **argv, int argc);\nint syncWithMaster(void);\nvoid updateSlavesWaitingBgsave(int bgsaveerr);\nvoid replicationCron(void);\n\n/* Generic persistence functions */\nvoid startLoading(FILE *fp);\nvoid loadingProgress(off_t pos);\nvoid stopLoading(void);\n\n/* RDB persistence */\nint rdbLoad(char *filename);\nint rdbSaveBackground(char *filename);\nvoid rdbRemoveTempFile(pid_t childpid);\nint rdbSave(char *filename);\nint rdbSaveObject(FILE *fp, robj *o);\noff_t rdbSavedObjectLen(robj *o);\noff_t rdbSavedObjectPages(robj *o);\nrobj *rdbLoadObject(int type, FILE *fp);\nvoid backgroundSaveDoneHandler(int statloc);\n\n/* AOF persistence */\nvoid flushAppendOnlyFile(void);\nvoid feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);\nvoid aofRemoveTempFile(pid_t childpid);\nint rewriteAppendOnlyFileBackground(void);\nint loadAppendOnlyFile(char *filename);\nvoid stopAppendOnly(void);\nint startAppendOnly(void);\nvoid backgroundRewriteDoneHandler(int statloc);\n\n/* Sorted sets data type */\nzskiplist *zslCreate(void);\nvoid zslFree(zskiplist *zsl);\nzskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);\n\n/* Core functions */\nvoid freeMemoryIfNeeded(void);\nint processCommand(redisClient *c);\nvoid setupSigSegvAction(void);\nstruct redisCommand *lookupCommand(sds name);\nstruct redisCommand *lookupCommandByCString(char *s);\nvoid call(redisClient *c, struct redisCommand *cmd);\nint prepareForShutdown();\nvoid redisLog(int level, const char *fmt, ...);\nvoid usage();\nvoid updateDictResizePolicy(void);\nint htNeedsResize(dict *dict);\nvoid oom(const char *msg);\nvoid populateCommandTable(void);\n\n/* Disk store */\nint dsOpen(void);\nint dsClose(void);\nint dsSet(redisDb *db, robj *key, robj *val);\nrobj *dsGet(redisDb *db, robj *key);\nint dsExists(redisDb *db, robj *key);\n\n/* Disk Store Cache */\nvoid vmInit(void);\nvoid vmMarkPagesFree(off_t page, off_t count);\nrobj *vmLoadObject(robj *o);\nrobj *vmPreviewObject(robj *o);\nint vmSwapOneObjectBlocking(void);\nint vmSwapOneObjectThreaded(void);\nint vmCanSwapOut(void);\nvoid vmThreadedIOCompletedJob(aeEventLoop *el, int fd, void *privdata, int mask);\nvoid vmCancelThreadedIOJob(robj *o);\nvoid lockThreadedIO(void);\nvoid unlockThreadedIO(void);\nint vmSwapObjectThreaded(robj *key, robj *val, redisDb *db);\nvoid freeIOJob(iojob *j);\nvoid queueIOJob(iojob *j);\nint vmWriteObjectOnSwap(robj *o, off_t page);\nrobj *vmReadObjectFromSwap(off_t page, int type);\nvoid waitEmptyIOJobsQueue(void);\nvoid vmReopenSwapFile(void);\nint vmFreePage(off_t page);\nvoid zunionInterBlockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd, int argc, robj **argv);\nvoid execBlockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd, int argc, robj **argv);\nint blockClientOnSwappedKeys(redisClient *c, struct redisCommand *cmd);\nint dontWaitForSwappedKey(redisClient *c, robj *key);\nvoid handleClientsBlockedOnSwappedKey(redisDb *db, robj *key);\nvmpointer *vmSwapObjectBlocking(robj *val);\n\n/* Set data type */\nrobj *setTypeCreate(robj *value);\nint setTypeAdd(robj *subject, robj *value);\nint setTypeRemove(robj *subject, robj *value);\nint setTypeIsMember(robj *subject, robj *value);\nsetTypeIterator *setTypeInitIterator(robj *subject);\nvoid setTypeReleaseIterator(setTypeIterator *si);\nint setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele);\nrobj *setTypeNextObject(setTypeIterator *si);\nint setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele);\nunsigned long setTypeSize(robj *subject);\nvoid setTypeConvert(robj *subject, int enc);\n\n/* Hash data type */\nvoid convertToRealHash(robj *o);\nvoid hashTypeTryConversion(robj *subject, robj **argv, int start, int end);\nvoid hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);\nint hashTypeGet(robj *o, robj *key, robj **objval, unsigned char **v, unsigned int *vlen);\nrobj *hashTypeGetObject(robj *o, robj *key);\nint hashTypeExists(robj *o, robj *key);\nint hashTypeSet(robj *o, robj *key, robj *value);\nint hashTypeDelete(robj *o, robj *key);\nunsigned long hashTypeLength(robj *o);\nhashTypeIterator *hashTypeInitIterator(robj *subject);\nvoid hashTypeReleaseIterator(hashTypeIterator *hi);\nint hashTypeNext(hashTypeIterator *hi);\nint hashTypeCurrent(hashTypeIterator *hi, int what, robj **objval, unsigned char **v, unsigned int *vlen);\nrobj *hashTypeCurrentObject(hashTypeIterator *hi, int what);\nrobj *hashTypeLookupWriteOrCreate(redisClient *c, robj *key);\n\n/* Pub / Sub */\nint pubsubUnsubscribeAllChannels(redisClient *c, int notify);\nint pubsubUnsubscribeAllPatterns(redisClient *c, int notify);\nvoid freePubsubPattern(void *p);\nint listMatchPubsubPattern(void *a, void *b);\n\n/* Utility functions */\nint stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase);\nint stringmatch(const char *pattern, const char *string, int nocase);\nlong long memtoll(const char *p, int *err);\nint ll2string(char *s, size_t len, long long value);\nint isStringRepresentableAsLong(sds s, long *longval);\nint isStringRepresentableAsLongLong(sds s, long long *longval);\nint isObjectRepresentableAsLongLong(robj *o, long long *llongval);\n\n/* Configuration */\nvoid loadServerConfig(char *filename);\nvoid appendServerSaveParams(time_t seconds, int changes);\nvoid resetServerSaveParams();\n\n/* db.c -- Keyspace access API */\nint removeExpire(redisDb *db, robj *key);\nvoid propagateExpire(redisDb *db, robj *key);\nint expireIfNeeded(redisDb *db, robj *key);\ntime_t getExpire(redisDb *db, robj *key);\nvoid setExpire(redisDb *db, robj *key, time_t when);\nrobj *lookupKey(redisDb *db, robj *key);\nrobj *lookupKeyRead(redisDb *db, robj *key);\nrobj *lookupKeyWrite(redisDb *db, robj *key);\nrobj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply);\nrobj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply);\nint dbAdd(redisDb *db, robj *key, robj *val);\nint dbReplace(redisDb *db, robj *key, robj *val);\nint dbExists(redisDb *db, robj *key);\nrobj *dbRandomKey(redisDb *db);\nint dbDelete(redisDb *db, robj *key);\nlong long emptyDb();\nint selectDb(redisClient *c, int id);\n\n/* Git SHA1 */\nchar *redisGitSHA1(void);\nchar *redisGitDirty(void);\n\n/* Commands prototypes */\nvoid authCommand(redisClient *c);\nvoid pingCommand(redisClient *c);\nvoid echoCommand(redisClient *c);\nvoid setCommand(redisClient *c);\nvoid setnxCommand(redisClient *c);\nvoid setexCommand(redisClient *c);\nvoid getCommand(redisClient *c);\nvoid delCommand(redisClient *c);\nvoid existsCommand(redisClient *c);\nvoid setbitCommand(redisClient *c);\nvoid getbitCommand(redisClient *c);\nvoid setrangeCommand(redisClient *c);\nvoid getrangeCommand(redisClient *c);\nvoid incrCommand(redisClient *c);\nvoid decrCommand(redisClient *c);\nvoid incrbyCommand(redisClient *c);\nvoid decrbyCommand(redisClient *c);\nvoid selectCommand(redisClient *c);\nvoid randomkeyCommand(redisClient *c);\nvoid keysCommand(redisClient *c);\nvoid dbsizeCommand(redisClient *c);\nvoid lastsaveCommand(redisClient *c);\nvoid saveCommand(redisClient *c);\nvoid bgsaveCommand(redisClient *c);\nvoid bgrewriteaofCommand(redisClient *c);\nvoid shutdownCommand(redisClient *c);\nvoid moveCommand(redisClient *c);\nvoid renameCommand(redisClient *c);\nvoid renamenxCommand(redisClient *c);\nvoid lpushCommand(redisClient *c);\nvoid rpushCommand(redisClient *c);\nvoid lpushxCommand(redisClient *c);\nvoid rpushxCommand(redisClient *c);\nvoid linsertCommand(redisClient *c);\nvoid lpopCommand(redisClient *c);\nvoid rpopCommand(redisClient *c);\nvoid llenCommand(redisClient *c);\nvoid lindexCommand(redisClient *c);\nvoid lrangeCommand(redisClient *c);\nvoid ltrimCommand(redisClient *c);\nvoid typeCommand(redisClient *c);\nvoid lsetCommand(redisClient *c);\nvoid saddCommand(redisClient *c);\nvoid sremCommand(redisClient *c);\nvoid smoveCommand(redisClient *c);\nvoid sismemberCommand(redisClient *c);\nvoid scardCommand(redisClient *c);\nvoid spopCommand(redisClient *c);\nvoid srandmemberCommand(redisClient *c);\nvoid sinterCommand(redisClient *c);\nvoid sinterstoreCommand(redisClient *c);\nvoid sunionCommand(redisClient *c);\nvoid sunionstoreCommand(redisClient *c);\nvoid sdiffCommand(redisClient *c);\nvoid sdiffstoreCommand(redisClient *c);\nvoid syncCommand(redisClient *c);\nvoid flushdbCommand(redisClient *c);\nvoid flushallCommand(redisClient *c);\nvoid sortCommand(redisClient *c);\nvoid lremCommand(redisClient *c);\nvoid rpoplpushCommand(redisClient *c);\nvoid infoCommand(redisClient *c);\nvoid mgetCommand(redisClient *c);\nvoid monitorCommand(redisClient *c);\nvoid expireCommand(redisClient *c);\nvoid expireatCommand(redisClient *c);\nvoid getsetCommand(redisClient *c);\nvoid ttlCommand(redisClient *c);\nvoid persistCommand(redisClient *c);\nvoid slaveofCommand(redisClient *c);\nvoid debugCommand(redisClient *c);\nvoid msetCommand(redisClient *c);\nvoid msetnxCommand(redisClient *c);\nvoid zaddCommand(redisClient *c);\nvoid zincrbyCommand(redisClient *c);\nvoid zrangeCommand(redisClient *c);\nvoid zrangebyscoreCommand(redisClient *c);\nvoid zrevrangebyscoreCommand(redisClient *c);\nvoid zcountCommand(redisClient *c);\nvoid zrevrangeCommand(redisClient *c);\nvoid zcardCommand(redisClient *c);\nvoid zremCommand(redisClient *c);\nvoid zscoreCommand(redisClient *c);\nvoid zremrangebyscoreCommand(redisClient *c);\nvoid multiCommand(redisClient *c);\nvoid execCommand(redisClient *c);\nvoid discardCommand(redisClient *c);\nvoid blpopCommand(redisClient *c);\nvoid brpopCommand(redisClient *c);\nvoid brpoplpushCommand(redisClient *c);\nvoid appendCommand(redisClient *c);\nvoid strlenCommand(redisClient *c);\nvoid zrankCommand(redisClient *c);\nvoid zrevrankCommand(redisClient *c);\nvoid hsetCommand(redisClient *c);\nvoid hsetnxCommand(redisClient *c);\nvoid hgetCommand(redisClient *c);\nvoid hmsetCommand(redisClient *c);\nvoid hmgetCommand(redisClient *c);\nvoid hdelCommand(redisClient *c);\nvoid hlenCommand(redisClient *c);\nvoid zremrangebyrankCommand(redisClient *c);\nvoid zunionstoreCommand(redisClient *c);\nvoid zinterstoreCommand(redisClient *c);\nvoid hkeysCommand(redisClient *c);\nvoid hvalsCommand(redisClient *c);\nvoid hgetallCommand(redisClient *c);\nvoid hexistsCommand(redisClient *c);\nvoid configCommand(redisClient *c);\nvoid hincrbyCommand(redisClient *c);\nvoid subscribeCommand(redisClient *c);\nvoid unsubscribeCommand(redisClient *c);\nvoid psubscribeCommand(redisClient *c);\nvoid punsubscribeCommand(redisClient *c);\nvoid publishCommand(redisClient *c);\nvoid watchCommand(redisClient *c);\nvoid unwatchCommand(redisClient *c);\n\n#if defined(__GNUC__)\nvoid *calloc(size_t count, size_t size) __attribute__ ((deprecated));\nvoid free(void *ptr) __attribute__ ((deprecated));\nvoid *malloc(size_t size) __attribute__ ((deprecated));\nvoid *realloc(void *ptr, size_t size) __attribute__ ((deprecated));\n#endif\n\n#endif\n"], "filenames": ["src/diskstore.c", "src/networking.c", "src/redis.c", "src/redis.h"], "buggy_code_start_loc": [19, 170, 621, 443], "buggy_code_end_loc": [72, 478, 1285, 456], "fixing_code_start_loc": [19, 170, 621, 443], "fixing_code_end_loc": [81, 478, 1246, 454], "type": "CWE-20", "message": "Insecure temporary file vulnerability in Redis before 2.6 related to /tmp/redis-%p.vm.", "other": {"cve": {"id": "CVE-2013-0178", "sourceIdentifier": "secalert@redhat.com", "published": "2019-11-01T19:15:10.777", "lastModified": "2019-11-06T14:52:41.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insecure temporary file vulnerability in Redis before 2.6 related to /tmp/redis-%p.vm."}, {"lang": "es", "value": "Una vulnerabilidad de archivo temporal no seguro en Redis versiones anteriores a 2.6, relacionada con el archivo /tmp/redis-%p.vm."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.0", "matchCriteriaId": "E6FE7F5D-2547-4377-9043-72DE4B55E170"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2013/01/14/5", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/01/14/7", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-0178", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/81329", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2013-0178", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5"}}