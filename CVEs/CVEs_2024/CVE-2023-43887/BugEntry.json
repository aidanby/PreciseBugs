{"buggy_code": ["/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"decctx.h\"\n#include \"util.h\"\n#include \"sao.h\"\n#include \"sei.h\"\n#include \"deblock.h\"\n\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"fallback.h\"\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_SSE4_1\n#include \"x86/sse.h\"\n#endif\n\n#ifdef HAVE_ARM\n#include \"arm/arm.h\"\n#endif\n\n#define SAVE_INTERMEDIATE_IMAGES 0\n\n#if SAVE_INTERMEDIATE_IMAGES\n#include \"visualize.h\"\n#endif\n\nextern void thread_decode_CTB_row(void* d);\nextern void thread_decode_slice_segment(void* d);\n\n\nthread_context::thread_context()\n{\n  /*\n  CtbAddrInRS = 0;\n  CtbAddrInTS = 0;\n\n  CtbX = 0;\n  CtbY = 0;\n  */\n\n  /*\n  refIdx[0] = refIdx[1] = 0;\n  mvd[0][0] = mvd[0][1] = mvd[1][0] = mvd[1][1] = 0;\n  merge_flag = 0;\n  merge_idx = 0;\n  mvp_lX_flag[0] = mvp_lX_flag[1] = 0;\n  inter_pred_idc = 0;\n  */\n\n  /*\n  enum IntraPredMode IntraPredModeC; // chroma intra-prediction mode for current CB\n  */\n\n  /*\n  cu_transquant_bypass_flag = false;\n  memset(transform_skip_flag,0, 3*sizeof(uint8_t));\n  */\n\n\n  //memset(coeffList,0,sizeof(int16_t)*3*32*32);\n  //memset(coeffPos,0,sizeof(int16_t)*3*32*32);\n  //memset(nCoeff,0,sizeof(int16_t)*3);\n\n\n\n  IsCuQpDeltaCoded = false;\n  CuQpDelta = 0;\n\n  IsCuChromaQpOffsetCoded = false;\n  CuQpOffsetCb = 0;\n  CuQpOffsetCr = 0;\n\n  /*\n  currentQPY = 0;\n  currentQG_x = 0;\n  currentQG_y = 0;\n  lastQPYinPreviousQG = 0;\n  */\n\n  /*\n  qPYPrime = 0;\n  qPCbPrime = 0;\n  qPCrPrime = 0;\n  */\n\n  /*\n  memset(&cabac_decoder, 0, sizeof(CABAC_decoder));\n  memset(&ctx_model, 0, sizeof(ctx_model));\n  */\n\n  decctx = NULL;\n  img = NULL;\n  shdr = NULL;\n\n  imgunit = NULL;\n  sliceunit = NULL;\n\n\n  //memset(this,0,sizeof(thread_context));\n\n  // There is a interesting issue here. When aligning _coeffBuf to 16 bytes offset with\n  // __attribute__((align(16))), the following statement is optimized away since the\n  // compiler assumes that the pointer would be 16-byte aligned. However, this is not the\n  // case when the structure has been dynamically allocated. In this case, the base can\n  // also be at 8 byte offsets (at least with MingW,32 bit).\n  int offset = ((uintptr_t)_coeffBuf) & 0xf;\n\n  if (offset == 0) {\n    coeffBuf = _coeffBuf;  // correctly aligned already\n  }\n  else {\n    coeffBuf = (int16_t *) (((uint8_t *)_coeffBuf) + (16-offset));\n  }\n\n  memset(coeffBuf, 0, 32*32*sizeof(int16_t));\n}\n\n\nslice_unit::slice_unit(decoder_context* decctx)\n  : nal(NULL),\n    shdr(NULL),\n    imgunit(NULL),\n    flush_reorder_buffer(false),\n    nThreads(0),\n    first_decoded_CTB_RS(-1),\n    last_decoded_CTB_RS(-1),\n    thread_contexts(NULL),\n    ctx(decctx)\n{\n  state = Unprocessed;\n  nThreadContexts = 0;\n}\n\nslice_unit::~slice_unit()\n{\n  ctx->nal_parser.free_NAL_unit(nal);\n\n  if (thread_contexts) {\n    delete[] thread_contexts;\n  }\n}\n\n\nvoid slice_unit::allocate_thread_contexts(int n)\n{\n  assert(thread_contexts==NULL);\n\n  thread_contexts = new thread_context[n];\n  nThreadContexts = n;\n}\n\n\nimage_unit::image_unit()\n{\n  img=NULL;\n  role=Invalid;\n  state=Unprocessed;\n}\n\n\nimage_unit::~image_unit()\n{\n  for (int i=0;i<slice_units.size();i++) {\n    delete slice_units[i];\n  }\n\n  for (int i=0;i<tasks.size();i++) {\n    delete tasks[i];\n  }\n}\n\n\nbase_context::base_context()\n{\n  set_acceleration_functions(de265_acceleration_AUTO);\n}\n\n\ndecoder_context::decoder_context()\n{\n  //memset(ctx, 0, sizeof(decoder_context));\n\n  // --- parameters ---\n\n  param_sei_check_hash = false;\n  param_conceal_stream_errors = true;\n  param_suppress_faulty_pictures = false;\n\n  param_disable_deblocking = false;\n  param_disable_sao = false;\n  //param_disable_mc_residual_idct = false;\n  //param_disable_intra_residual_idct = false;\n\n  // --- processing ---\n\n  param_sps_headers_fd = -1;\n  param_vps_headers_fd = -1;\n  param_pps_headers_fd = -1;\n  param_slice_headers_fd = -1;\n\n  param_image_allocation_functions = de265_image::default_image_allocation;\n  param_image_allocation_userdata  = NULL;\n\n  /*\n  memset(&vps, 0, sizeof(video_parameter_set)*DE265_MAX_VPS_SETS);\n  memset(&sps, 0, sizeof(seq_parameter_set)  *DE265_MAX_SPS_SETS);\n  memset(&pps, 0, sizeof(pic_parameter_set)  *DE265_MAX_PPS_SETS);\n  memset(&slice,0,sizeof(slice_segment_header)*DE265_MAX_SLICES);\n  */\n\n  current_vps = NULL;\n  current_sps = NULL;\n  current_pps = NULL;\n\n  //memset(&thread_pool,0,sizeof(struct thread_pool));\n  num_worker_threads = 0;\n\n\n  // frame-rate\n\n  limit_HighestTid = 6;   // decode all temporal layers (up to layer 6)\n  framerate_ratio = 100;  // decode all 100%\n\n  goal_HighestTid = 6;\n  current_HighestTid = 6;\n  layer_framerate_ratio = 100;\n\n  compute_framedrop_table();\n\n\n  //\n\n  current_image_poc_lsb = 0;\n  first_decoded_picture = 0;\n  NoRaslOutputFlag = 0;\n  HandleCraAsBlaFlag = 0;\n  FirstAfterEndOfSequenceNAL = 0;\n  PicOrderCntMsb = 0;\n  prevPicOrderCntLsb = 0;\n  prevPicOrderCntMsb = 0;\n  img = NULL;\n  previous_slice_header = nullptr;\n\n  /*\n  int PocLsbLt[MAX_NUM_REF_PICS];\n  int UsedByCurrPicLt[MAX_NUM_REF_PICS];\n  int DeltaPocMsbCycleLt[MAX_NUM_REF_PICS];\n  int CurrDeltaPocMsbPresentFlag[MAX_NUM_REF_PICS];\n  int FollDeltaPocMsbPresentFlag[MAX_NUM_REF_PICS];\n\n  int NumPocStCurrBefore;\n  int NumPocStCurrAfter;\n  int NumPocStFoll;\n  int NumPocLtCurr;\n  int NumPocLtFoll;\n\n  // These lists contain absolute POC values.\n  int PocStCurrBefore[MAX_NUM_REF_PICS]; // used for reference in current picture, smaller POC\n  int PocStCurrAfter[MAX_NUM_REF_PICS];  // used for reference in current picture, larger POC\n  int PocStFoll[MAX_NUM_REF_PICS]; // not used for reference in current picture, but in future picture\n  int PocLtCurr[MAX_NUM_REF_PICS]; // used in current picture\n  int PocLtFoll[MAX_NUM_REF_PICS]; // used in some future picture\n\n  // These lists contain indices into the DPB.\n  int RefPicSetStCurrBefore[DE265_DPB_SIZE];\n  int RefPicSetStCurrAfter[DE265_DPB_SIZE];\n  int RefPicSetStFoll[DE265_DPB_SIZE];\n  int RefPicSetLtCurr[DE265_DPB_SIZE];\n  int RefPicSetLtFoll[DE265_DPB_SIZE];\n\n\n  uint8_t nal_unit_type;\n\n  char IdrPicFlag;\n  char RapPicFlag;\n  */\n\n\n\n  // --- internal data ---\n\n  first_decoded_picture = true;\n  //ctx->FirstAfterEndOfSequenceNAL = true;\n  //ctx->last_RAP_picture_NAL_type = NAL_UNIT_UNDEFINED;\n\n  //de265_init_image(&ctx->coeff);\n\n  // --- decoded picture buffer ---\n\n  current_image_poc_lsb = -1; // any invalid number\n}\n\n\ndecoder_context::~decoder_context()\n{\n  while (!image_units.empty()) {\n    delete image_units.back();\n    image_units.pop_back();\n  }\n}\n\n\nvoid decoder_context::set_image_allocation_functions(de265_image_allocation* allocfunc,\n                                                     void* userdata)\n{\n  if (allocfunc) {\n    param_image_allocation_functions = *allocfunc;\n    param_image_allocation_userdata  = userdata;\n  }\n  else {\n    assert(false); // actually, it makes no sense to reset the allocation functions\n\n    param_image_allocation_functions = de265_image::default_image_allocation;\n    param_image_allocation_userdata  = NULL;\n  }\n}\n\n\nde265_error decoder_context::start_thread_pool(int nThreads)\n{\n  ::start_thread_pool(&thread_pool_, nThreads);\n\n  num_worker_threads = nThreads;\n\n  return DE265_OK;\n}\n\n\nvoid decoder_context::stop_thread_pool()\n{\n  if (get_num_worker_threads()>0) {\n    //flush_thread_pool(&ctx->thread_pool);\n    ::stop_thread_pool(&thread_pool_);\n  }\n}\n\n\nvoid decoder_context::reset()\n{\n  if (num_worker_threads>0) {\n    //flush_thread_pool(&ctx->thread_pool);\n    ::stop_thread_pool(&thread_pool_);\n  }\n\n  // --------------------------------------------------\n\n#if 0\n  ctx->end_of_stream = false;\n  ctx->pending_input_NAL = NULL;\n  ctx->current_vps = NULL;\n  ctx->current_sps = NULL;\n  ctx->current_pps = NULL;\n  ctx->num_worker_threads = 0;\n  ctx->current_image_poc_lsb = 0;\n  ctx->first_decoded_picture = 0;\n  ctx->NoRaslOutputFlag = 0;\n  ctx->HandleCraAsBlaFlag = 0;\n  ctx->FirstAfterEndOfSequenceNAL = 0;\n  ctx->PicOrderCntMsb = 0;\n  ctx->prevPicOrderCntLsb = 0;\n  ctx->prevPicOrderCntMsb = 0;\n  ctx->NumPocStCurrBefore=0;\n  ctx->NumPocStCurrAfter=0;\n  ctx->NumPocStFoll=0;\n  ctx->NumPocLtCurr=0;\n  ctx->NumPocLtFoll=0;\n  ctx->nal_unit_type=0;\n  ctx->IdrPicFlag=0;\n  ctx->RapPicFlag=0;\n#endif\n\n  img = NULL;\n\n\n  // TODO: remove all pending image_units\n\n\n  // --- decoded picture buffer ---\n\n  current_image_poc_lsb = -1; // any invalid number\n  first_decoded_picture = true;\n\n\n  // --- remove all pictures from output queue ---\n\n  // there was a bug the peek_next_image did not return NULL on empty output queues.\n  // This was (indirectly) fixed by recreating the DPB buffer, but it should actually\n  // be sufficient to clear it like this.\n  // The error showed while scrubbing the ToS video in VLC.\n  dpb.clear();\n\n  nal_parser.remove_pending_input_data();\n\n\n  while (!image_units.empty()) {\n    delete image_units.back();\n    image_units.pop_back();\n  }\n\n  // --- start threads again ---\n\n  if (num_worker_threads>0) {\n    // TODO: need error checking\n    start_thread_pool(num_worker_threads);\n  }\n}\n\nvoid base_context::set_acceleration_functions(enum de265_acceleration l)\n{\n  // fill scalar functions first (so that function table is completely filled)\n\n  init_acceleration_functions_fallback(&acceleration);\n\n\n  // override functions with optimized variants\n\n#ifdef HAVE_SSE4_1\n  if (l>=de265_acceleration_SSE) {\n    init_acceleration_functions_sse(&acceleration);\n  }\n#endif\n#ifdef HAVE_ARM\n  if (l>=de265_acceleration_ARM) {\n    init_acceleration_functions_arm(&acceleration);\n  }\n#endif\n}\n\n\nvoid decoder_context::init_thread_context(thread_context* tctx)\n{\n  // zero scrap memory for coefficient blocks\n  memset(tctx->_coeffBuf, 0, sizeof(tctx->_coeffBuf));  // TODO: check if we can safely remove this\n\n  tctx->currentQG_x = -1;\n  tctx->currentQG_y = -1;\n\n\n\n  // --- find QPY that was active at the end of the previous slice ---\n\n  // find the previous CTB in TS order\n\n  const pic_parameter_set& pps = tctx->img->get_pps();\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n\n  if (tctx->shdr->slice_segment_address > 0) {\n    int prevCtb = pps.CtbAddrTStoRS[ pps.CtbAddrRStoTS[tctx->shdr->slice_segment_address] -1 ];\n\n    int ctbX = prevCtb % sps.PicWidthInCtbsY;\n    int ctbY = prevCtb / sps.PicWidthInCtbsY;\n\n\n    // take the pixel at the bottom right corner (but consider that the image size might be smaller)\n\n    int x = ((ctbX+1) << sps.Log2CtbSizeY)-1;\n    int y = ((ctbY+1) << sps.Log2CtbSizeY)-1;\n\n    x = std::min(x,sps.pic_width_in_luma_samples-1);\n    y = std::min(y,sps.pic_height_in_luma_samples-1);\n\n    //printf(\"READ QPY: %d %d -> %d (should %d)\\n\",x,y,imgunit->img->get_QPY(x,y), tc.currentQPY);\n\n    //if (tctx->shdr->dependent_slice_segment_flag) {  // TODO: do we need this condition ?\n    tctx->currentQPY = tctx->img->get_QPY(x,y);\n      //}\n  }\n}\n\n\nvoid decoder_context::add_task_decode_CTB_row(thread_context* tctx,\n                                              bool firstSliceSubstream,\n                                              int ctbRow)\n{\n  thread_task_ctb_row* task = new thread_task_ctb_row;\n  task->firstSliceSubstream = firstSliceSubstream;\n  task->tctx = tctx;\n  task->debug_startCtbRow = ctbRow;\n  tctx->task = task;\n\n  add_task(&thread_pool_, task);\n\n  tctx->imgunit->tasks.push_back(task);\n}\n\n\nvoid decoder_context::add_task_decode_slice_segment(thread_context* tctx, bool firstSliceSubstream,\n                                                    int ctbx,int ctby)\n{\n  thread_task_slice_segment* task = new thread_task_slice_segment;\n  task->firstSliceSubstream = firstSliceSubstream;\n  task->tctx = tctx;\n  task->debug_startCtbX = ctbx;\n  task->debug_startCtbY = ctby;\n  tctx->task = task;\n\n  add_task(&thread_pool_, task);\n\n  tctx->imgunit->tasks.push_back(task);\n}\n\n\nde265_error decoder_context::read_vps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"---> read VPS\\n\");\n\n  std::shared_ptr<video_parameter_set> new_vps = std::make_shared<video_parameter_set>();\n  de265_error err = new_vps->read(this,&reader);\n  if (err != DE265_OK) {\n    return err;\n  }\n\n  if (param_vps_headers_fd>=0) {\n    new_vps->dump(param_vps_headers_fd);\n  }\n\n  vps[ new_vps->video_parameter_set_id ] = new_vps;\n\n  return DE265_OK;\n}\n\nde265_error decoder_context::read_sps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read SPS\\n\");\n\n  std::shared_ptr<seq_parameter_set> new_sps = std::make_shared<seq_parameter_set>();\n  de265_error err;\n\n  if ((err=new_sps->read(this, &reader)) != DE265_OK) {\n    return err;\n  }\n\n  if (param_sps_headers_fd>=0) {\n    new_sps->dump(param_sps_headers_fd);\n  }\n\n  sps[ new_sps->seq_parameter_set_id ] = new_sps;\n\n  // Remove the all PPS that referenced the old SPS because parameters may have changed and we do not want to\n  // get the SPS and PPS parameters (e.g. image size) out of sync.\n  \n  for (auto& p : pps) {\n    if (p && p->seq_parameter_set_id == new_sps->seq_parameter_set_id) {\n      p = nullptr;\n    }\n  }\n\n  return DE265_OK;\n}\n\nde265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n\n  bool success = new_pps->read(&reader,this);\n\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}\n\nde265_error decoder_context::read_sei_NAL(bitreader& reader, bool suffix)\n{\n  logdebug(LogHeaders,\"----> read SEI\\n\");\n\n  sei_message sei;\n\n  //push_current_picture_to_output_queue();\n\n  de265_error err = DE265_OK;\n\n  if ((err=read_sei(&reader,&sei, suffix, current_sps.get())) == DE265_OK) {\n    dump_sei(&sei, current_sps.get());\n\n    if (image_units.empty()==false && suffix) {\n      image_units.back()->suffix_SEIs.push_back(sei);\n    }\n  }\n  else {\n    add_warning(err, false);\n  }\n\n  return err;\n}\n\nde265_error decoder_context::read_eos_NAL(bitreader& reader)\n{\n  FirstAfterEndOfSequenceNAL = true;\n  return DE265_OK;\n}\n\nde265_error decoder_context::read_slice_NAL(bitreader& reader, NAL_unit* nal, nal_header& nal_hdr)\n{\n  logdebug(LogHeaders,\"---> read slice segment header\\n\");\n\n\n  // --- read slice header ---\n\n  slice_segment_header* shdr = new slice_segment_header;\n  bool continueDecoding;\n  de265_error err = shdr->read(&reader,this, &continueDecoding);\n  if (!continueDecoding) {\n    if (img) { img->integrity = INTEGRITY_NOT_DECODED; }\n    nal_parser.free_NAL_unit(nal);\n    delete shdr;\n    return err;\n  }\n\n  if (param_slice_headers_fd>=0) {\n    shdr->dump_slice_segment_header(this, param_slice_headers_fd);\n  }\n\n\n  if (process_slice_segment_header(shdr, &err, nal->pts, &nal_hdr, nal->user_data) == false)\n    {\n      if (img!=NULL) img->integrity = INTEGRITY_NOT_DECODED;\n      nal_parser.free_NAL_unit(nal);\n      delete shdr;\n      return err;\n    }\n\n  this->img->add_slice_segment_header(shdr);\n\n  skip_bits(&reader,1); // TODO: why?\n  prepare_for_CABAC(&reader);\n\n\n  // modify entry_point_offsets\n\n  int headerLength = reader.data - nal->data();\n  for (int i=0;i<shdr->num_entry_point_offsets;i++) {\n    shdr->entry_point_offset[i] -= nal->num_skipped_bytes_before(shdr->entry_point_offset[i],\n                                                                 headerLength);\n  }\n\n\n\n  // --- start a new image if this is the first slice ---\n\n  if (shdr->first_slice_segment_in_pic_flag) {\n    image_unit* imgunit = new image_unit;\n    imgunit->img = this->img;\n    image_units.push_back(imgunit);\n  }\n\n\n  // --- add slice to current picture ---\n\n  if ( ! image_units.empty() ) {\n\n    slice_unit* sliceunit = new slice_unit(this);\n    sliceunit->nal = nal;\n    sliceunit->shdr = shdr;\n    sliceunit->reader = reader;\n\n    sliceunit->flush_reorder_buffer = flush_reorder_buffer_at_this_frame;\n\n\n    image_units.back()->slice_units.push_back(sliceunit);\n  }\n\n  bool did_work;\n  err = decode_some(&did_work);\n\n  return DE265_OK;\n}\n\n\ntemplate <class T> void pop_front(std::vector<T>& vec)\n{\n  for (int i=1;i<vec.size();i++)\n    vec[i-1] = vec[i];\n\n  vec.pop_back();\n}\n\n\nde265_error decoder_context::decode_some(bool* did_work)\n{\n  de265_error err = DE265_OK;\n\n  *did_work = false;\n\n  if (image_units.empty()) { return DE265_OK; }  // nothing to do\n\n\n  // decode something if there is work to do\n\n  if ( ! image_units.empty() ) { // && ! image_units[0]->slice_units.empty() ) {\n\n    image_unit* imgunit = image_units[0];\n    slice_unit* sliceunit = imgunit->get_next_unprocessed_slice_segment();\n\n    if (sliceunit != NULL) {\n\n      //pop_front(imgunit->slice_units);\n\n      if (sliceunit->flush_reorder_buffer) {\n        dpb.flush_reorder_buffer();\n      }\n\n      *did_work = true;\n\n      //err = decode_slice_unit_sequential(imgunit, sliceunit);\n      err = decode_slice_unit_parallel(imgunit, sliceunit);\n      if (err) {\n        return err;\n      }\n\n      //delete sliceunit;\n    }\n  }\n\n\n\n  // if we decoded all slices of the current image and there will not\n  // be added any more slices to the image, output the image\n\n  if ( ( image_units.size()>=2 && image_units[0]->all_slice_segments_processed()) ||\n       ( image_units.size()>=1 && image_units[0]->all_slice_segments_processed() &&\n         nal_parser.number_of_NAL_units_pending()==0 &&\n         (nal_parser.is_end_of_stream() || nal_parser.is_end_of_frame()) )) {\n\n    image_unit* imgunit = image_units[0];\n\n    *did_work=true;\n\n\n    // mark all CTBs as decoded even if they are not, because faulty input\n    // streams could miss part of the picture\n    // TODO: this will not work when slice decoding is parallel to post-filtering,\n    // so we will have to replace this with keeping track of which CTB should have\n    // been decoded (but aren't because of the input stream being faulty)\n\n    imgunit->img->mark_all_CTB_progress(CTB_PROGRESS_PREFILTER);\n\n\n\n    // run post-processing filters (deblocking & SAO)\n\n    if (img->decctx->num_worker_threads)\n      run_postprocessing_filters_parallel(imgunit);\n    else\n      run_postprocessing_filters_sequential(imgunit->img);\n\n    // process suffix SEIs\n\n    for (int i=0;i<imgunit->suffix_SEIs.size();i++) {\n      const sei_message& sei = imgunit->suffix_SEIs[i];\n\n      err = process_sei(&sei, imgunit->img);\n      if (err != DE265_OK)\n        break;\n    }\n\n\n    push_picture_to_output_queue(imgunit);\n\n    // remove just decoded image unit from queue\n\n    delete imgunit;\n\n    pop_front(image_units);\n  }\n\n  return err;\n}\n\n\nde265_error decoder_context::decode_slice_unit_sequential(image_unit* imgunit,\n                                                          slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  /*\n  printf(\"decode slice POC=%d addr=%d, img=%p\\n\",\n         sliceunit->shdr->slice_pic_order_cnt_lsb,\n         sliceunit->shdr->slice_segment_address,\n         imgunit->img);\n  */\n\n  remove_images_from_dpb(sliceunit->shdr->RemoveReferencesList);\n\n  if (sliceunit->shdr->slice_segment_address >= imgunit->img->get_pps().CtbAddrRStoTS.size()) {\n    return DE265_ERROR_CTB_OUTSIDE_IMAGE_AREA;\n  }\n\n\n  struct thread_context tctx;\n\n  tctx.shdr = sliceunit->shdr;\n  tctx.img  = imgunit->img;\n  tctx.decctx = this;\n  tctx.imgunit = imgunit;\n  tctx.sliceunit= sliceunit;\n  tctx.CtbAddrInTS = imgunit->img->get_pps().CtbAddrRStoTS[tctx.shdr->slice_segment_address];\n  tctx.task = NULL;\n\n  init_thread_context(&tctx);\n\n  if (sliceunit->reader.bytes_remaining <= 0) {\n    return DE265_ERROR_PREMATURE_END_OF_SLICE;\n  }\n\n  init_CABAC_decoder(&tctx.cabac_decoder,\n                     sliceunit->reader.data,\n                     sliceunit->reader.bytes_remaining);\n\n  // alloc CABAC-model array if entropy_coding_sync is enabled\n\n  if (imgunit->img->get_pps().entropy_coding_sync_enabled_flag &&\n      sliceunit->shdr->first_slice_segment_in_pic_flag) {\n    imgunit->ctx_models.resize( (img->get_sps().PicHeightInCtbsY-1) ); //* CONTEXT_MODEL_TABLE_LENGTH );\n  }\n\n  sliceunit->nThreads=1;\n\n  err=read_slice_segment_data(&tctx);\n\n  sliceunit->finished_threads.set_progress(1);\n\n  return err;\n}\n\n\nvoid decoder_context::mark_whole_slice_as_processed(image_unit* imgunit,\n                                                    slice_unit* sliceunit,\n                                                    int progress)\n{\n  //printf(\"mark whole slice\\n\");\n\n\n  // mark all CTBs upto the next slice segment as processed\n\n  slice_unit* nextSegment = imgunit->get_next_slice_segment(sliceunit);\n  if (nextSegment) {\n    /*\n    printf(\"mark whole slice between %d and %d\\n\",\n           sliceunit->shdr->slice_segment_address,\n           nextSegment->shdr->slice_segment_address);\n    */\n\n    for (int ctb=sliceunit->shdr->slice_segment_address;\n         ctb < nextSegment->shdr->slice_segment_address;\n         ctb++)\n      {\n        if (ctb >= imgunit->img->number_of_ctbs())\n          break;\n\n        imgunit->img->ctb_progress[ctb].set_progress(progress);\n      }\n  }\n}\n\n\nde265_error decoder_context::decode_slice_unit_parallel(image_unit* imgunit,\n                                                        slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  remove_images_from_dpb(sliceunit->shdr->RemoveReferencesList);\n\n  /*\n  printf(\"-------- decode --------\\n\");\n  printf(\"IMAGE UNIT %p\\n\",imgunit);\n  sliceunit->shdr->dump_slice_segment_header(sliceunit->ctx, 1);\n  imgunit->dump_slices();\n  */\n\n  de265_image* img = imgunit->img;\n  const pic_parameter_set& pps = img->get_pps();\n\n  sliceunit->state = slice_unit::InProgress;\n\n  bool use_WPP = (img->decctx->num_worker_threads > 0 &&\n                  pps.entropy_coding_sync_enabled_flag);\n\n  bool use_tiles = (img->decctx->num_worker_threads > 0 &&\n                    pps.tiles_enabled_flag);\n\n\n  // TODO: remove this warning later when we do frame-parallel decoding\n  if (img->decctx->num_worker_threads > 0 &&\n      pps.entropy_coding_sync_enabled_flag == false &&\n      pps.tiles_enabled_flag == false) {\n\n    img->decctx->add_warning(DE265_WARNING_NO_WPP_CANNOT_USE_MULTITHREADING, true);\n  }\n\n\n  // If this is the first slice segment, mark all CTBs before this as processed\n  // (the real first slice segment could be missing).\n\n  if (imgunit->is_first_slice_segment(sliceunit)) {\n    slice_segment_header* shdr = sliceunit->shdr;\n    int firstCTB = shdr->slice_segment_address;\n\n    for (int ctb=0;ctb<firstCTB;ctb++) {\n      //printf(\"mark pre progress %d\\n\",ctb);\n      img->ctb_progress[ctb].set_progress(CTB_PROGRESS_PREFILTER);\n    }\n  }\n\n\n  // if there is a previous slice that has been completely decoded,\n  // mark all CTBs until the start of this slice as completed\n\n  //printf(\"this slice: %p\\n\",sliceunit);\n  slice_unit* prevSlice = imgunit->get_prev_slice_segment(sliceunit);\n  //if (prevSlice) printf(\"prev slice state: %d\\n\",prevSlice->state);\n  if (prevSlice && prevSlice->state == slice_unit::Decoded) {\n    mark_whole_slice_as_processed(imgunit,prevSlice,CTB_PROGRESS_PREFILTER);\n  }\n\n\n  // TODO: even though we cannot split this into several tasks, we should run it\n  // as a background thread\n  if (!use_WPP && !use_tiles) {\n    //printf(\"SEQ\\n\");\n    err = decode_slice_unit_sequential(imgunit, sliceunit);\n    sliceunit->state = slice_unit::Decoded;\n    mark_whole_slice_as_processed(imgunit,sliceunit,CTB_PROGRESS_PREFILTER);\n    return err;\n  }\n\n\n  if (use_WPP && use_tiles) {\n    // TODO: this is not allowed ... output some warning or error\n\n    return DE265_WARNING_PPS_HEADER_INVALID;\n  }\n\n\n  if (use_WPP) {\n    //printf(\"WPP\\n\");\n    err = decode_slice_unit_WPP(imgunit, sliceunit);\n    sliceunit->state = slice_unit::Decoded;\n    mark_whole_slice_as_processed(imgunit,sliceunit,CTB_PROGRESS_PREFILTER);\n    return err;\n  }\n  else if (use_tiles) {\n    //printf(\"TILE\\n\");\n    err = decode_slice_unit_tiles(imgunit, sliceunit);\n    sliceunit->state = slice_unit::Decoded;\n    mark_whole_slice_as_processed(imgunit,sliceunit,CTB_PROGRESS_PREFILTER);\n    return err;\n  }\n\n  assert(false);\n  return err;\n}\n\n\nde265_error decoder_context::decode_slice_unit_WPP(image_unit* imgunit,\n                                                   slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  de265_image* img = imgunit->img;\n  slice_segment_header* shdr = sliceunit->shdr;\n  const pic_parameter_set& pps = img->get_pps();\n\n  int nRows = shdr->num_entry_point_offsets +1;\n  int ctbsWidth = img->get_sps().PicWidthInCtbsY;\n\n\n  assert(img->num_threads_active() == 0);\n\n\n  // reserve space to store entropy coding context models for each CTB row\n\n  if (shdr->first_slice_segment_in_pic_flag) {\n    // reserve space for nRows-1 because we don't need to save the CABAC model in the last CTB row\n    imgunit->ctx_models.resize( (img->get_sps().PicHeightInCtbsY-1) ); //* CONTEXT_MODEL_TABLE_LENGTH );\n  }\n\n\n  sliceunit->allocate_thread_contexts(nRows);\n\n\n  // first CTB in this slice\n  int ctbAddrRS = shdr->slice_segment_address;\n  int ctbRow    = ctbAddrRS / ctbsWidth;\n\n  for (int entryPt=0;entryPt<nRows;entryPt++) {\n    // entry points other than the first start at CTB rows\n    if (entryPt>0) {\n      ctbRow++;\n      ctbAddrRS = ctbRow * ctbsWidth;\n    }\n    else if (nRows>1 && (ctbAddrRS % ctbsWidth) != 0) {\n      // If slice segment consists of several WPP rows, each of them\n      // has to start at a row.\n\n      //printf(\"does not start at start\\n\");\n\n      err = DE265_WARNING_SLICEHEADER_INVALID;\n      break;\n    }\n\n\n    // prepare thread context\n\n    thread_context* tctx = sliceunit->get_thread_context(entryPt);\n\n    tctx->shdr    = shdr;\n    tctx->decctx  = img->decctx;\n    tctx->img     = img;\n    tctx->imgunit = imgunit;\n    tctx->sliceunit= sliceunit;\n    tctx->CtbAddrInTS = pps.CtbAddrRStoTS[ctbAddrRS];\n\n    init_thread_context(tctx);\n\n\n    // init CABAC\n\n    int dataStartIndex;\n    if (entryPt==0) { dataStartIndex=0; }\n    else            { dataStartIndex=shdr->entry_point_offset[entryPt-1]; }\n\n    int dataEnd;\n    if (entryPt==nRows-1) dataEnd = sliceunit->reader.bytes_remaining;\n    else                  dataEnd = shdr->entry_point_offset[entryPt];\n\n    if (dataStartIndex<0 || dataEnd>sliceunit->reader.bytes_remaining ||\n        dataEnd <= dataStartIndex) {\n      //printf(\"WPP premature end\\n\");\n      err = DE265_ERROR_PREMATURE_END_OF_SLICE;\n      break;\n    }\n\n    init_CABAC_decoder(&tctx->cabac_decoder,\n                       &sliceunit->reader.data[dataStartIndex],\n                       dataEnd-dataStartIndex);\n\n    // add task\n\n    //printf(\"start task for ctb-row: %d\\n\",ctbRow);\n    img->thread_start(1);\n    sliceunit->nThreads++;\n    add_task_decode_CTB_row(tctx, entryPt==0, ctbRow);\n  }\n\n#if 0\n  for (;;) {\n    printf(\"q:%d r:%d b:%d f:%d\\n\",\n           img->nThreadsQueued,\n           img->nThreadsRunning,\n           img->nThreadsBlocked,\n           img->nThreadsFinished);\n\n    if (img->debug_is_completed()) break;\n\n    usleep(1000);\n  }\n#endif\n\n  img->wait_for_completion();\n\n  for (int i=0;i<imgunit->tasks.size();i++)\n    delete imgunit->tasks[i];\n  imgunit->tasks.clear();\n\n  return DE265_OK;\n}\n\nde265_error decoder_context::decode_slice_unit_tiles(image_unit* imgunit,\n                                                     slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  de265_image* img = imgunit->img;\n  slice_segment_header* shdr = sliceunit->shdr;\n  const pic_parameter_set& pps = img->get_pps();\n\n  int nTiles = shdr->num_entry_point_offsets +1;\n  int ctbsWidth = img->get_sps().PicWidthInCtbsY;\n\n\n  assert(img->num_threads_active() == 0);\n\n  sliceunit->allocate_thread_contexts(nTiles);\n\n\n  // first CTB in this slice\n  int ctbAddrRS = shdr->slice_segment_address;\n  int tileID = pps.TileIdRS[ctbAddrRS];\n\n  for (int entryPt=0;entryPt<nTiles;entryPt++) {\n    // entry points other than the first start at tile beginnings\n    if (entryPt>0) {\n      tileID++;\n\n      if (tileID >= pps.num_tile_columns * pps.num_tile_rows) {\n        err = DE265_WARNING_SLICEHEADER_INVALID;\n        break;\n      }\n\n      int ctbX = pps.colBd[tileID % pps.num_tile_columns];\n      int ctbY = pps.rowBd[tileID / pps.num_tile_columns];\n      ctbAddrRS = ctbY * ctbsWidth + ctbX;\n    }\n\n    // set thread context\n\n    thread_context* tctx = sliceunit->get_thread_context(entryPt);\n\n    tctx->shdr   = shdr;\n    tctx->decctx = img->decctx;\n    tctx->img    = img;\n    tctx->imgunit = imgunit;\n    tctx->sliceunit= sliceunit;\n    tctx->CtbAddrInTS = pps.CtbAddrRStoTS[ctbAddrRS];\n\n    init_thread_context(tctx);\n\n\n    // init CABAC\n\n    int dataStartIndex;\n    if (entryPt==0) { dataStartIndex=0; }\n    else            { dataStartIndex=shdr->entry_point_offset[entryPt-1]; }\n\n    int dataEnd;\n    if (entryPt==nTiles-1) dataEnd = sliceunit->reader.bytes_remaining;\n    else                   dataEnd = shdr->entry_point_offset[entryPt];\n\n    if (dataStartIndex<0 || dataEnd>sliceunit->reader.bytes_remaining ||\n        dataEnd <= dataStartIndex) {\n      err = DE265_ERROR_PREMATURE_END_OF_SLICE;\n      break;\n    }\n\n    init_CABAC_decoder(&tctx->cabac_decoder,\n                       &sliceunit->reader.data[dataStartIndex],\n                       dataEnd-dataStartIndex);\n\n    // add task\n\n    //printf(\"add tiles thread\\n\");\n    img->thread_start(1);\n    sliceunit->nThreads++;\n    add_task_decode_slice_segment(tctx, entryPt==0,\n                                  ctbAddrRS % ctbsWidth,\n                                  ctbAddrRS / ctbsWidth);\n  }\n\n  img->wait_for_completion();\n\n  for (int i=0;i<imgunit->tasks.size();i++)\n    delete imgunit->tasks[i];\n  imgunit->tasks.clear();\n\n  return err;\n}\n\n\nde265_error decoder_context::decode_NAL(NAL_unit* nal)\n{\n  //return decode_NAL_OLD(nal);\n\n  decoder_context* ctx = this;\n\n  de265_error err = DE265_OK;\n\n  bitreader reader;\n  bitreader_init(&reader, nal->data(), nal->size());\n\n  nal_header nal_hdr;\n  nal_hdr.read(&reader);\n  ctx->process_nal_hdr(&nal_hdr);\n\n  if (nal_hdr.nuh_layer_id > 0) {\n    // Discard all NAL units with nuh_layer_id > 0\n    // These will have to be handeled by an SHVC decoder.\n    nal_parser.free_NAL_unit(nal);\n    return DE265_OK;\n  }\n\n  loginfo(LogHighlevel,\"NAL: 0x%x 0x%x -  unit type:%s temporal id:%d\\n\",\n          nal->data()[0], nal->data()[1],\n          get_NAL_name(nal_hdr.nal_unit_type),\n          nal_hdr.nuh_temporal_id);\n\n  /*\n    printf(\"NAL: 0x%x 0x%x -  unit type:%s temporal id:%d\\n\",\n    nal->data()[0], nal->data()[1],\n    get_NAL_name(nal_hdr.nal_unit_type),\n    nal_hdr.nuh_temporal_id);\n  */\n\n  // throw away NALs from higher TIDs than currently selected\n  // TODO: better online switching of HighestTID\n\n  //printf(\"hTid: %d\\n\", current_HighestTid);\n\n  if (nal_hdr.nuh_temporal_id > current_HighestTid) {\n    nal_parser.free_NAL_unit(nal);\n    return DE265_OK;\n  }\n\n\n  if (nal_hdr.nal_unit_type<32) {\n    err = read_slice_NAL(reader, nal, nal_hdr);\n  }\n  else switch (nal_hdr.nal_unit_type) {\n    case NAL_UNIT_VPS_NUT:\n      err = read_vps_NAL(reader);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_SPS_NUT:\n      err = read_sps_NAL(reader);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_PPS_NUT:\n      err = read_pps_NAL(reader);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_PREFIX_SEI_NUT:\n    case NAL_UNIT_SUFFIX_SEI_NUT:\n      err = read_sei_NAL(reader, nal_hdr.nal_unit_type==NAL_UNIT_SUFFIX_SEI_NUT);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_EOS_NUT:\n      ctx->FirstAfterEndOfSequenceNAL = true;\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    default:\n      nal_parser.free_NAL_unit(nal);\n      break;\n    }\n\n  return err;\n}\n\n\nde265_error decoder_context::decode(int* more)\n{\n  decoder_context* ctx = this;\n\n  // if the stream has ended, and no more NALs are to be decoded, flush all pictures\n\n  if (ctx->nal_parser.get_NAL_queue_length() == 0 &&\n      (ctx->nal_parser.is_end_of_stream() || ctx->nal_parser.is_end_of_frame()) &&\n      ctx->image_units.empty()) {\n\n    // flush all pending pictures into output queue\n\n    // ctx->push_current_picture_to_output_queue(); // TODO: not with new queue\n    ctx->dpb.flush_reorder_buffer();\n\n    if (more) { *more = ctx->dpb.num_pictures_in_output_queue(); }\n\n    return DE265_OK;\n  }\n\n\n  // if NAL-queue is empty, we need more data\n  // -> input stalled\n\n  if (ctx->nal_parser.is_end_of_stream() == false &&\n      ctx->nal_parser.is_end_of_frame() == false &&\n      ctx->nal_parser.get_NAL_queue_length() == 0) {\n    if (more) { *more=1; }\n\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n\n\n  // when there are no free image buffers in the DPB, pause decoding\n  // -> output stalled\n\n  if (!ctx->dpb.has_free_dpb_picture(false)) {\n    if (more) *more = 1;\n    return DE265_ERROR_IMAGE_BUFFER_FULL;\n  }\n\n\n  // decode one NAL from the queue\n\n  de265_error err = DE265_OK;\n  bool did_work = false;\n\n  if (ctx->nal_parser.get_NAL_queue_length()) { // number_of_NAL_units_pending()) {\n    NAL_unit* nal = ctx->nal_parser.pop_from_NAL_queue();\n    assert(nal);\n    err = ctx->decode_NAL(nal);\n    // ctx->nal_parser.free_NAL_unit(nal); TODO: do not free NAL with new loop\n    did_work=true;\n  }\n  else if (ctx->nal_parser.is_end_of_frame() == true &&\n      ctx->image_units.empty()) {\n    if (more) { *more=1; }\n\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  else {\n    err = decode_some(&did_work);\n  }\n\n  if (more) {\n    // decoding error is assumed to be unrecoverable\n    *more = (err==DE265_OK && did_work);\n  }\n\n  return err;\n}\n\n\nvoid decoder_context::process_nal_hdr(nal_header* nal)\n{\n  nal_unit_type = nal->nal_unit_type;\n\n  IdrPicFlag = isIdrPic(nal->nal_unit_type);\n  RapPicFlag = isRapPic(nal->nal_unit_type);\n}\n\n\n\n/* 8.3.1\n */\nvoid decoder_context::process_picture_order_count(slice_segment_header* hdr)\n{\n  loginfo(LogHeaders,\"POC computation. lsb:%d prev.pic.lsb:%d msb:%d\\n\",\n          hdr->slice_pic_order_cnt_lsb,\n          prevPicOrderCntLsb,\n          PicOrderCntMsb);\n\n  if (isIRAP(nal_unit_type) &&\n      NoRaslOutputFlag)\n    {\n      PicOrderCntMsb=0;\n\n\n      // flush all images from reorder buffer\n\n      flush_reorder_buffer_at_this_frame = true;\n      //ctx->dpb.flush_reorder_buffer();\n    }\n  else\n    {\n      int MaxPicOrderCntLsb = current_sps->MaxPicOrderCntLsb;\n\n      if ((hdr->slice_pic_order_cnt_lsb < prevPicOrderCntLsb) &&\n          (prevPicOrderCntLsb - hdr->slice_pic_order_cnt_lsb) >= MaxPicOrderCntLsb/2) {\n        PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb;\n      }\n      else if ((hdr->slice_pic_order_cnt_lsb > prevPicOrderCntLsb) &&\n               (hdr->slice_pic_order_cnt_lsb - prevPicOrderCntLsb) > MaxPicOrderCntLsb/2) {\n        PicOrderCntMsb = prevPicOrderCntMsb - MaxPicOrderCntLsb;\n      }\n      else {\n        PicOrderCntMsb = prevPicOrderCntMsb;\n      }\n    }\n\n  img->PicOrderCntVal = PicOrderCntMsb + hdr->slice_pic_order_cnt_lsb;\n  img->picture_order_cnt_lsb = hdr->slice_pic_order_cnt_lsb;\n\n  loginfo(LogHeaders,\"POC computation. new msb:%d POC=%d\\n\",\n          PicOrderCntMsb,\n          img->PicOrderCntVal);\n\n  if (img->nal_hdr.nuh_temporal_id==0 &&\n      !isSublayerNonReference(nal_unit_type) &&\n      !isRASL(nal_unit_type) &&\n      !isRADL(nal_unit_type))\n    {\n      loginfo(LogHeaders,\"set prevPicOrderCntLsb/Msb\\n\");\n\n      prevPicOrderCntLsb = hdr->slice_pic_order_cnt_lsb;\n      prevPicOrderCntMsb = PicOrderCntMsb;\n    }\n}\n\n\n/* 8.3.3.2\n   Returns DPB index of the generated picture.\n */\nint decoder_context::generate_unavailable_reference_picture(const seq_parameter_set* sps,\n                                                            int POC, bool longTerm)\n{\n  assert(dpb.has_free_dpb_picture(true));\n\n  std::shared_ptr<const seq_parameter_set> current_sps = this->sps[ (int)current_pps->seq_parameter_set_id ];\n\n  int idx = dpb.new_image(current_sps, this, 0,0, false);\n  if (idx<0) {\n    return idx;\n  }\n\n  de265_image* img = dpb.get_image(idx);\n\n  img->fill_image(1<<(sps->BitDepth_Y-1),\n                  1<<(sps->BitDepth_C-1),\n                  1<<(sps->BitDepth_C-1));\n\n  img->fill_pred_mode(MODE_INTRA);\n\n  img->PicOrderCntVal = POC;\n  img->picture_order_cnt_lsb = POC & (sps->MaxPicOrderCntLsb-1);\n  img->PicOutputFlag = false;\n  img->PicState = (longTerm ? UsedForLongTermReference : UsedForShortTermReference);\n  img->integrity = INTEGRITY_UNAVAILABLE_REFERENCE;\n\n  return idx;\n}\n\n\n/* 8.3.2   invoked once per picture\n\n   This function will mark pictures in the DPB as 'unused' or 'used for long-term reference'\n */\nde265_error decoder_context::process_reference_picture_set(slice_segment_header* hdr)\n{\n  std::vector<int> removeReferencesList;\n\n  const int currentID = img->get_ID();\n\n\n  if (isIRAP(nal_unit_type) && NoRaslOutputFlag) {\n\n    int currentPOC = img->PicOrderCntVal;\n\n    // reset DPB\n\n    /* The standard says: \"When the current picture is an IRAP picture with NoRaslOutputFlag\n       equal to 1, all reference pictures currently in the DPB (if any) are marked as\n       \"unused for reference\".\n\n       This seems to be wrong as it also throws out the first CRA picture in a stream like\n       RAP_A (decoding order: CRA,POC=64, RASL,POC=60). Removing only the pictures with\n       lower POCs seems to be compliant to the reference decoder.\n    */\n\n    for (int i=0;i<dpb.size();i++) {\n      de265_image* img = dpb.get_image(i);\n\n      if (img->PicState != UnusedForReference &&\n          img->PicOrderCntVal < currentPOC &&\n          img->removed_at_picture_id > img->get_ID()) {\n\n        removeReferencesList.push_back(img->get_ID());\n        img->removed_at_picture_id = img->get_ID();\n\n        //printf(\"will remove ID %d (a)\\n\",img->get_ID());\n      }\n    }\n  }\n\n\n  if (isIDR(nal_unit_type)) {\n\n    // clear all reference pictures\n\n    NumPocStCurrBefore = 0;\n    NumPocStCurrAfter = 0;\n    NumPocStFoll = 0;\n    NumPocLtCurr = 0;\n    NumPocLtFoll = 0;\n  }\n  else {\n    const ref_pic_set* rps = &hdr->CurrRps;\n\n    // (8-98)\n\n    int i,j,k;\n\n    // scan ref-pic-set for smaller POCs and fill into PocStCurrBefore / PocStFoll\n\n    for (i=0, j=0, k=0;\n         i<rps->NumNegativePics;\n         i++)\n      {\n        if (rps->UsedByCurrPicS0[i]) {\n          PocStCurrBefore[j++] = img->PicOrderCntVal + rps->DeltaPocS0[i];\n          //printf(\"PocStCurrBefore = %d\\n\",PocStCurrBefore[j-1]);\n        }\n        else {\n          PocStFoll[k++] = img->PicOrderCntVal + rps->DeltaPocS0[i];\n        }\n      }\n\n    NumPocStCurrBefore = j;\n\n\n    // scan ref-pic-set for larger POCs and fill into PocStCurrAfter / PocStFoll\n\n    for (i=0, j=0;\n         i<rps->NumPositivePics;\n         i++)\n      {\n        if (rps->UsedByCurrPicS1[i]) {\n          PocStCurrAfter[j++] = img->PicOrderCntVal + rps->DeltaPocS1[i];\n          //printf(\"PocStCurrAfter = %d\\n\",PocStCurrAfter[j-1]);\n        }\n        else {\n          PocStFoll[k++] = img->PicOrderCntVal + rps->DeltaPocS1[i];\n        }\n      }\n\n    NumPocStCurrAfter = j;\n    NumPocStFoll = k;\n\n\n    // find used / future long-term references\n\n    for (i=0, j=0, k=0;\n         //i<current_sps->num_long_term_ref_pics_sps + hdr->num_long_term_pics;\n         i<hdr->num_long_term_sps + hdr->num_long_term_pics;\n         i++)\n      {\n        int pocLt = PocLsbLt[i];\n\n        if (hdr->delta_poc_msb_present_flag[i]) {\n          int currentPictureMSB = img->PicOrderCntVal - hdr->slice_pic_order_cnt_lsb;\n          pocLt += currentPictureMSB\n            - DeltaPocMsbCycleLt[i] * current_sps->MaxPicOrderCntLsb;\n        }\n\n        if (UsedByCurrPicLt[i]) {\n          PocLtCurr[j] = pocLt;\n          CurrDeltaPocMsbPresentFlag[j] = hdr->delta_poc_msb_present_flag[i];\n          j++;\n        }\n        else {\n          PocLtFoll[k] = pocLt;\n          FollDeltaPocMsbPresentFlag[k] = hdr->delta_poc_msb_present_flag[i];\n          k++;\n        }\n      }\n\n    NumPocLtCurr = j;\n    NumPocLtFoll = k;\n  }\n\n\n  // (old 8-99) / (new 8-106)\n  // 1.\n\n  std::vector<char> picInAnyList(dpb.size(), false);\n\n\n  dpb.log_dpb_content();\n\n  for (int i=0;i<NumPocLtCurr;i++) {\n    int k;\n    if (!CurrDeltaPocMsbPresentFlag[i]) {\n      k = dpb.DPB_index_of_picture_with_LSB(PocLtCurr[i], currentID, true);\n    }\n    else {\n      k = dpb.DPB_index_of_picture_with_POC(PocLtCurr[i], currentID, true);\n    }\n\n    RefPicSetLtCurr[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      // TODO, CHECK: is it ok that we generate a picture with POC = LSB (PocLtCurr)\n      // We do not know the correct MSB\n      int concealedPicture = generate_unavailable_reference_picture(current_sps.get(),\n                                                                    PocLtCurr[i], true);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n\n      RefPicSetLtCurr[i] = k = concealedPicture;\n      picInAnyList[concealedPicture]=true;\n    }\n\n    if (dpb.get_image(k)->integrity != INTEGRITY_CORRECT) {\n      img->integrity = INTEGRITY_DERIVED_FROM_FAULTY_REFERENCE;\n    }\n  }\n\n\n  for (int i=0;i<NumPocLtFoll;i++) {\n    int k;\n    if (!FollDeltaPocMsbPresentFlag[i]) {\n      k = dpb.DPB_index_of_picture_with_LSB(PocLtFoll[i], currentID, true);\n    }\n    else {\n      k = dpb.DPB_index_of_picture_with_POC(PocLtFoll[i], currentID, true);\n    }\n\n    RefPicSetLtFoll[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      int concealedPicture = k = generate_unavailable_reference_picture(current_sps.get(),\n                                                                        PocLtFoll[i], true);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n\n      RefPicSetLtFoll[i] = concealedPicture;\n      picInAnyList[concealedPicture]=true;\n    }\n  }\n\n\n  // 2. Mark all pictures in RefPicSetLtCurr / RefPicSetLtFoll as UsedForLongTermReference\n\n  for (int i=0;i<NumPocLtCurr;i++) {\n    dpb.get_image(RefPicSetLtCurr[i])->PicState = UsedForLongTermReference;\n  }\n\n  for (int i=0;i<NumPocLtFoll;i++) {\n    dpb.get_image(RefPicSetLtFoll[i])->PicState = UsedForLongTermReference;\n  }\n\n\n  // 3.\n\n  for (int i=0;i<NumPocStCurrBefore;i++) {\n    int k = dpb.DPB_index_of_picture_with_POC(PocStCurrBefore[i], currentID);\n\n    //printf(\"st curr before, poc=%d -> idx=%d\\n\",PocStCurrBefore[i], k);\n\n    RefPicSetStCurrBefore[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      int concealedPicture = generate_unavailable_reference_picture(current_sps.get(),\n                                                                    PocStCurrBefore[i], false);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      RefPicSetStCurrBefore[i] = k = concealedPicture;\n\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n      picInAnyList[concealedPicture] = true;\n\n      //printf(\"  concealed: %d\\n\", concealedPicture);\n    }\n\n    if (dpb.get_image(k)->integrity != INTEGRITY_CORRECT) {\n      img->integrity = INTEGRITY_DERIVED_FROM_FAULTY_REFERENCE;\n    }\n  }\n\n  for (int i=0;i<NumPocStCurrAfter;i++) {\n    int k = dpb.DPB_index_of_picture_with_POC(PocStCurrAfter[i], currentID);\n\n    //printf(\"st curr after, poc=%d -> idx=%d\\n\",PocStCurrAfter[i], k);\n\n    RefPicSetStCurrAfter[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      int concealedPicture = generate_unavailable_reference_picture(current_sps.get(),\n                                                                    PocStCurrAfter[i], false);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      RefPicSetStCurrAfter[i] = k = concealedPicture;\n\n\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n      picInAnyList[concealedPicture]=true;\n\n      //printf(\"  concealed: %d\\n\", concealedPicture);\n    }\n\n    if (dpb.get_image(k)->integrity != INTEGRITY_CORRECT) {\n      img->integrity = INTEGRITY_DERIVED_FROM_FAULTY_REFERENCE;\n    }\n  }\n\n  for (int i=0;i<NumPocStFoll;i++) {\n    int k = dpb.DPB_index_of_picture_with_POC(PocStFoll[i], currentID);\n    // if (k<0) { assert(false); } // IGNORE\n\n    RefPicSetStFoll[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n  }\n\n  // 4. any picture that is not marked for reference is put into the \"UnusedForReference\" state\n\n  for (int i=0;i<dpb.size();i++)\n    if (i>=picInAnyList.size() || !picInAnyList[i])        // no reference\n      {\n        de265_image* dpbimg = dpb.get_image(i);\n        if (dpbimg != img &&  // not the current picture\n            dpbimg->removed_at_picture_id > img->get_ID()) // has not been removed before\n          {\n            if (dpbimg->PicState != UnusedForReference) {\n              removeReferencesList.push_back(dpbimg->get_ID());\n              //printf(\"will remove ID %d (b)\\n\",dpbimg->get_ID());\n\n              dpbimg->removed_at_picture_id = img->get_ID();\n            }\n          }\n      }\n\n  hdr->RemoveReferencesList = removeReferencesList;\n\n  //remove_images_from_dpb(hdr->RemoveReferencesList);\n\n  return DE265_OK;\n}\n\n\n// 8.3.4\n// Returns whether we can continue decoding (or whether there is a severe error).\n/* Called at beginning of each slice.\n\n   Constructs\n   - the RefPicList[2][], containing indices into the DPB, and\n   - the RefPicList_POC[2][], containing POCs.\n   - LongTermRefPic[2][] is also set to true if it is a long-term reference\n */\nbool decoder_context::construct_reference_picture_lists(slice_segment_header* hdr)\n{\n  int NumPocTotalCurr = hdr->NumPocTotalCurr;\n  int NumRpsCurrTempList0 = libde265_max(hdr->num_ref_idx_l0_active, NumPocTotalCurr);\n\n  // TODO: fold code for both lists together\n\n  int RefPicListTemp0[3*MAX_NUM_REF_PICS]; // TODO: what would be the correct maximum ?\n  int RefPicListTemp1[3*MAX_NUM_REF_PICS]; // TODO: what would be the correct maximum ?\n  char isLongTerm[2][3*MAX_NUM_REF_PICS];\n\n  memset(isLongTerm,0,2*3*MAX_NUM_REF_PICS);\n\n  /* --- Fill RefPicListTmp0 with reference pictures in this order:\n     1) short term, past POC\n     2) short term, future POC\n     3) long term\n  */\n\n  int rIdx=0;\n  while (rIdx < NumRpsCurrTempList0) {\n    for (int i=0;i<NumPocStCurrBefore && rIdx<NumRpsCurrTempList0; rIdx++,i++)\n      RefPicListTemp0[rIdx] = RefPicSetStCurrBefore[i];\n\n    for (int i=0;i<NumPocStCurrAfter && rIdx<NumRpsCurrTempList0; rIdx++,i++)\n      RefPicListTemp0[rIdx] = RefPicSetStCurrAfter[i];\n\n    for (int i=0;i<NumPocLtCurr && rIdx<NumRpsCurrTempList0; rIdx++,i++) {\n      RefPicListTemp0[rIdx] = RefPicSetLtCurr[i];\n      isLongTerm[0][rIdx] = true;\n    }\n\n    // This check is to prevent an endless loop when no images are added above.\n    if (rIdx==0) {\n      add_warning(DE265_WARNING_FAULTY_REFERENCE_PICTURE_LIST, false);\n      return false;\n    }\n  }\n\n  /*\n  if (hdr->num_ref_idx_l0_active > 16) {\n    add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);\n    return false;\n  }\n  */\n\n  assert(hdr->num_ref_idx_l0_active <= 16);\n  for (rIdx=0; rIdx<hdr->num_ref_idx_l0_active; rIdx++) {\n    int idx = hdr->ref_pic_list_modification_flag_l0 ? hdr->list_entry_l0[rIdx] : rIdx;\n\n    hdr->RefPicList[0][rIdx] = RefPicListTemp0[idx];\n    hdr->LongTermRefPic[0][rIdx] = isLongTerm[0][idx];\n\n    // remember POC of referenced image (needed in motion.c, derive_collocated_motion_vector)\n    de265_image* img_0_rIdx = dpb.get_image(hdr->RefPicList[0][rIdx]);\n    if (img_0_rIdx==NULL) {\n      return false;\n    }\n    hdr->RefPicList_POC[0][rIdx] = img_0_rIdx->PicOrderCntVal;\n    hdr->RefPicList_PicState[0][rIdx] = img_0_rIdx->PicState;\n  }\n\n\n  /* --- Fill RefPicListTmp1 with reference pictures in this order:\n     1) short term, future POC\n     2) short term, past POC\n     3) long term\n  */\n\n  if (hdr->slice_type == SLICE_TYPE_B) {\n    int NumRpsCurrTempList1 = libde265_max(hdr->num_ref_idx_l1_active, NumPocTotalCurr);\n\n    int rIdx=0;\n    while (rIdx < NumRpsCurrTempList1) {\n      for (int i=0;i<NumPocStCurrAfter && rIdx<NumRpsCurrTempList1; rIdx++,i++) {\n        RefPicListTemp1[rIdx] = RefPicSetStCurrAfter[i];\n      }\n\n      for (int i=0;i<NumPocStCurrBefore && rIdx<NumRpsCurrTempList1; rIdx++,i++) {\n        RefPicListTemp1[rIdx] = RefPicSetStCurrBefore[i];\n      }\n\n      for (int i=0;i<NumPocLtCurr && rIdx<NumRpsCurrTempList1; rIdx++,i++) {\n        RefPicListTemp1[rIdx] = RefPicSetLtCurr[i];\n        isLongTerm[1][rIdx] = true;\n      }\n\n      // This check is to prevent an endless loop when no images are added above.\n      if (rIdx==0) {\n        add_warning(DE265_WARNING_FAULTY_REFERENCE_PICTURE_LIST, false);\n        return false;\n      }\n    }\n\n    if (hdr->num_ref_idx_l0_active > 16) {\n    add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);\n    return false;\n  }\n\n    assert(hdr->num_ref_idx_l1_active <= 16);\n    for (rIdx=0; rIdx<hdr->num_ref_idx_l1_active; rIdx++) {\n      int idx = hdr->ref_pic_list_modification_flag_l1 ? hdr->list_entry_l1[rIdx] : rIdx;\n\n      hdr->RefPicList[1][rIdx] = RefPicListTemp1[idx];\n      hdr->LongTermRefPic[1][rIdx] = isLongTerm[1][idx];\n\n      // remember POC of referenced imaged (needed in motion.c, derive_collocated_motion_vector)\n      de265_image* img_1_rIdx = dpb.get_image(hdr->RefPicList[1][rIdx]);\n      if (img_1_rIdx == NULL) { return false; }\n      hdr->RefPicList_POC[1][rIdx] = img_1_rIdx->PicOrderCntVal;\n      hdr->RefPicList_PicState[1][rIdx] = img_1_rIdx->PicState;\n    }\n  }\n\n\n  // show reference picture lists\n\n  loginfo(LogHeaders,\"RefPicList[0] =\");\n  for (rIdx=0; rIdx<hdr->num_ref_idx_l0_active; rIdx++) {\n    loginfo(LogHeaders,\"* [%d]=%d (LT=%d)\",\n            hdr->RefPicList[0][rIdx],\n            hdr->RefPicList_POC[0][rIdx],\n            hdr->LongTermRefPic[0][rIdx]\n            );\n  }\n  loginfo(LogHeaders,\"*\\n\");\n\n  if (hdr->slice_type == SLICE_TYPE_B) {\n    loginfo(LogHeaders,\"RefPicList[1] =\");\n    for (rIdx=0; rIdx<hdr->num_ref_idx_l1_active; rIdx++) {\n      loginfo(LogHeaders,\"* [%d]=%d (LT=%d)\",\n              hdr->RefPicList[1][rIdx],\n              hdr->RefPicList_POC[1][rIdx],\n              hdr->LongTermRefPic[1][rIdx]\n              );\n    }\n    loginfo(LogHeaders,\"*\\n\");\n  }\n\n  return true;\n}\n\n\n\nvoid decoder_context::run_postprocessing_filters_sequential(de265_image* img)\n{\n#if SAVE_INTERMEDIATE_IMAGES\n    char buf[1000];\n    sprintf(buf,\"pre-lf-%05d.yuv\", img->PicOrderCntVal);\n    write_picture_to_file(img, buf);\n#endif\n\n    if (!img->decctx->param_disable_deblocking) {\n      apply_deblocking_filter(img);\n    }\n\n#if SAVE_INTERMEDIATE_IMAGES\n    sprintf(buf,\"pre-sao-%05d.yuv\", img->PicOrderCntVal);\n    write_picture_to_file(img, buf);\n#endif\n\n    if (!img->decctx->param_disable_sao) {\n      apply_sample_adaptive_offset_sequential(img);\n    }\n\n#if SAVE_INTERMEDIATE_IMAGES\n    sprintf(buf,\"sao-%05d.yuv\", img->PicOrderCntVal);\n    write_picture_to_file(img, buf);\n#endif\n}\n\n\nvoid decoder_context::run_postprocessing_filters_parallel(image_unit* imgunit)\n{\n  de265_image* img = imgunit->img;\n\n  int saoWaitsForProgress = CTB_PROGRESS_PREFILTER;\n  bool waitForCompletion = false;\n\n  if (!img->decctx->param_disable_deblocking) {\n    add_deblocking_tasks(imgunit);\n    saoWaitsForProgress = CTB_PROGRESS_DEBLK_H;\n  }\n\n  if (!img->decctx->param_disable_sao) {\n    waitForCompletion |= add_sao_tasks(imgunit, saoWaitsForProgress);\n    //apply_sample_adaptive_offset(img);\n  }\n\n  img->wait_for_completion();\n}\n\n/*\nvoid decoder_context::push_current_picture_to_output_queue()\n{\n  push_picture_to_output_queue(img);\n}\n*/\n\nde265_error decoder_context::push_picture_to_output_queue(image_unit* imgunit)\n{\n  de265_image* outimg = imgunit->img;\n\n  if (outimg==NULL) { return DE265_OK; }\n\n\n  // push image into output queue\n\n  if (outimg->PicOutputFlag) {\n    loginfo(LogDPB,\"new picture has output-flag=true\\n\");\n\n    if (outimg->integrity != INTEGRITY_CORRECT &&\n        param_suppress_faulty_pictures) {\n    }\n    else {\n      dpb.insert_image_into_reorder_buffer(outimg);\n    }\n\n    loginfo(LogDPB,\"push image %d into reordering queue\\n\", outimg->PicOrderCntVal);\n  }\n\n  // check for full reorder buffers\n\n  int maxNumPicsInReorderBuffer = 0;\n\n  // TODO: I'd like to have the has_vps() check somewhere else (not decode the picture at all)\n  if (outimg->has_vps()) {\n    int sublayer = outimg->get_vps().vps_max_sub_layers -1;\n    maxNumPicsInReorderBuffer = outimg->get_vps().layer[sublayer].vps_max_num_reorder_pics;\n  }\n\n  if (dpb.num_pictures_in_reorder_buffer() > maxNumPicsInReorderBuffer) {\n    dpb.output_next_picture_in_reorder_buffer();\n  }\n\n  dpb.log_dpb_queues();\n\n  return DE265_OK;\n}\n\n\n// returns whether we can continue decoding the stream or whether we should give up\nbool decoder_context::process_slice_segment_header(slice_segment_header* hdr,\n                                                   de265_error* err, de265_PTS pts,\n                                                   nal_header* nal_hdr,\n                                                   void* user_data)\n{\n  *err = DE265_OK;\n\n  flush_reorder_buffer_at_this_frame = false;\n\n\n  // get PPS and SPS for this slice\n\n  int pps_id = hdr->slice_pic_parameter_set_id;\n  if (pps[pps_id]==nullptr || pps[pps_id]->pps_read==false) {\n    logerror(LogHeaders, \"PPS %d has not been read\\n\", pps_id);\n    img->decctx->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return false;\n  }\n\n  current_pps = pps[pps_id];\n  current_sps = sps[ (int)current_pps->seq_parameter_set_id ];\n  current_vps = vps[ (int)current_sps->video_parameter_set_id ];\n\n  calc_tid_and_framerate_ratio();\n\n\n  // --- prepare decoding of new picture ---\n\n  if (hdr->first_slice_segment_in_pic_flag) {\n\n    // previous picture has been completely decoded\n\n    //ctx->push_current_picture_to_output_queue();\n\n    current_image_poc_lsb = hdr->slice_pic_order_cnt_lsb;\n\n\n    seq_parameter_set* sps = current_sps.get();\n\n\n    // --- find and allocate image buffer for decoding ---\n\n    int image_buffer_idx;\n    bool isOutputImage = (!sps->sample_adaptive_offset_enabled_flag || param_disable_sao);\n    image_buffer_idx = dpb.new_image(current_sps, this, pts, user_data, isOutputImage);\n    if (image_buffer_idx < 0) {\n      *err = (de265_error)(-image_buffer_idx);\n      return false;\n    }\n\n    /*de265_image* */ img = dpb.get_image(image_buffer_idx);\n    img->nal_hdr = *nal_hdr;\n\n    // Note: sps is already set in new_image() -> ??? still the case with shared_ptr ?\n\n    img->set_headers(current_vps, current_sps, current_pps);\n\n    img->decctx = this;\n\n    img->clear_metadata();\n\n\n    if (isIRAP(nal_unit_type)) {\n      if (isIDR(nal_unit_type) ||\n          isBLA(nal_unit_type) ||\n          first_decoded_picture ||\n          FirstAfterEndOfSequenceNAL)\n        {\n          NoRaslOutputFlag = true;\n          FirstAfterEndOfSequenceNAL = false;\n        }\n      else if (0) // TODO: set HandleCraAsBlaFlag by external means\n        {\n        }\n      else\n        {\n          NoRaslOutputFlag   = false;\n          HandleCraAsBlaFlag = false;\n        }\n    }\n\n\n    if (isRASL(nal_unit_type) &&\n        NoRaslOutputFlag)\n      {\n        img->PicOutputFlag = false;\n      }\n    else\n      {\n        img->PicOutputFlag = !!hdr->pic_output_flag;\n      }\n\n    process_picture_order_count(hdr);\n\n    if (hdr->first_slice_segment_in_pic_flag) {\n      // mark picture so that it is not overwritten by unavailable reference frames\n      img->PicState = UsedForShortTermReference;\n\n      *err = process_reference_picture_set(hdr);\n      if (*err != DE265_OK) {\n        return false;\n      }\n    }\n\n    img->PicState = UsedForShortTermReference;\n\n    log_set_current_POC(img->PicOrderCntVal);\n\n\n    // next image is not the first anymore\n\n    first_decoded_picture = false;\n  }\n  else {\n    // claims to be not the first slice, but there is no active image available\n\n    if (img == NULL) {\n      return false;\n    }\n  }\n\n  if (hdr->slice_type == SLICE_TYPE_B ||\n      hdr->slice_type == SLICE_TYPE_P)\n    {\n      bool success = construct_reference_picture_lists(hdr);\n      if (!success) {\n        return false;\n      }\n    }\n\n  //printf(\"process slice segment header\\n\");\n\n  loginfo(LogHeaders,\"end of process-slice-header\\n\");\n  dpb.log_dpb_content();\n\n\n  if (hdr->dependent_slice_segment_flag==0) {\n    hdr->SliceAddrRS = hdr->slice_segment_address;\n  } else {\n    hdr->SliceAddrRS = previous_slice_header->SliceAddrRS;\n  }\n\n  previous_slice_header = hdr;\n\n\n  loginfo(LogHeaders,\"SliceAddrRS = %d\\n\",hdr->SliceAddrRS);\n\n  return true;\n}\n\n\nvoid decoder_context::remove_images_from_dpb(const std::vector<int>& removeImageList)\n{\n  for (int i=0;i<removeImageList.size();i++) {\n    int idx = dpb.DPB_index_of_picture_with_ID( removeImageList[i] );\n    if (idx>=0) {\n      //printf(\"remove ID %d\\n\", removeImageList[i]);\n      de265_image* dpbimg = dpb.get_image( idx );\n      dpbimg->PicState = UnusedForReference;\n    }\n  }\n}\n\n\n\n/*\n  .     0     1     2       <- goal_HighestTid\n  +-----+-----+-----+\n  | -0->| -1->| -2->|\n  +-----+-----+-----+\n  0     33    66    100     <- framerate_ratio\n */\n\nint  decoder_context::get_highest_TID() const\n{\n  if (current_sps) { return current_sps->sps_max_sub_layers-1; }\n  if (current_vps) { return current_vps->vps_max_sub_layers-1; }\n\n  return 6;\n}\n\nvoid decoder_context::set_limit_TID(int max_tid)\n{\n  limit_HighestTid = max_tid;\n  calc_tid_and_framerate_ratio();\n}\n\nint decoder_context::change_framerate(int more)\n{\n  if (current_sps == NULL) { return framerate_ratio; }\n\n  int highestTid = get_highest_TID();\n\n  assert(more>=-1 && more<=1);\n\n  goal_HighestTid += more;\n  goal_HighestTid = std::max(goal_HighestTid, 0);\n  goal_HighestTid = std::min(goal_HighestTid, highestTid);\n\n  framerate_ratio = framedrop_tid_index[goal_HighestTid];\n\n  calc_tid_and_framerate_ratio();\n\n  return framerate_ratio;\n}\n\nvoid decoder_context::set_framerate_ratio(int percent)\n{\n  framerate_ratio = percent;\n  calc_tid_and_framerate_ratio();\n}\n\nvoid decoder_context::compute_framedrop_table()\n{\n  int highestTID = get_highest_TID();\n\n  for (int tid=highestTID ; tid>=0 ; tid--) {\n    int lower  = 100 *  tid   /(highestTID+1);\n    int higher = 100 * (tid+1)/(highestTID+1);\n\n    for (int l=lower; l<=higher; l++) {\n      int ratio = 100 * (l-lower) / (higher-lower);\n\n      // if we would exceed our TID limit, decode the highest TID at full frame-rate\n      if (tid > limit_HighestTid) {\n        tid   = limit_HighestTid;\n        ratio = 100;\n      }\n\n      framedrop_tab[l].tid   = tid;\n      framedrop_tab[l].ratio = ratio;\n    }\n\n    framedrop_tid_index[tid] = higher;\n  }\n\n#if 0\n  for (int i=0;i<=100;i++) {\n    printf(\"%d%%: %d/%d\",i, framedrop_tab[i].tid, framedrop_tab[i].ratio);\n    for (int k=0;k<=highestTID;k++) {\n      if (framedrop_tid_index[k] == i) printf(\" ** TID=%d **\",k);\n    }\n    printf(\"\\n\");\n  }\n#endif\n}\n\nvoid decoder_context::calc_tid_and_framerate_ratio()\n{\n  int highestTID = get_highest_TID();\n\n\n  // if number of temporal layers changed, we have to recompute the framedrop table\n\n  if (framedrop_tab[100].tid != highestTID) {\n    compute_framedrop_table();\n  }\n\n  goal_HighestTid       = framedrop_tab[framerate_ratio].tid;\n  layer_framerate_ratio = framedrop_tab[framerate_ratio].ratio;\n\n  // TODO: for now, we switch immediately\n  current_HighestTid = goal_HighestTid;\n}\n\n\nvoid error_queue::add_warning(de265_error warning, bool once)\n{\n  // check if warning was already shown\n  bool add=true;\n  if (once) {\n    for (int i=0;i<nWarningsShown;i++) {\n      if (warnings_shown[i] == warning) {\n        add=false;\n        break;\n      }\n    }\n  }\n\n  if (!add) {\n    return;\n  }\n\n\n  // if this is a one-time warning, remember that it was shown\n\n  if (once) {\n    if (nWarningsShown < MAX_WARNINGS) {\n      warnings_shown[nWarningsShown++] = warning;\n    }\n  }\n\n\n  // add warning to output queue\n\n  if (nWarnings == MAX_WARNINGS) {\n    warnings[MAX_WARNINGS-1] = DE265_WARNING_WARNING_BUFFER_FULL;\n    return;\n  }\n\n  warnings[nWarnings++] = warning;\n}\n\nerror_queue::error_queue()\n{\n  nWarnings = 0;\n  nWarningsShown = 0;\n}\n\nde265_error error_queue::get_warning()\n{\n  if (nWarnings==0) {\n    return DE265_OK;\n  }\n\n  de265_error warn = warnings[0];\n  nWarnings--;\n  memmove(warnings, &warnings[1], nWarnings*sizeof(de265_error));\n\n  return warn;\n}\n"], "fixing_code": ["/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"decctx.h\"\n#include \"util.h\"\n#include \"sao.h\"\n#include \"sei.h\"\n#include \"deblock.h\"\n\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"fallback.h\"\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_SSE4_1\n#include \"x86/sse.h\"\n#endif\n\n#ifdef HAVE_ARM\n#include \"arm/arm.h\"\n#endif\n\n#define SAVE_INTERMEDIATE_IMAGES 0\n\n#if SAVE_INTERMEDIATE_IMAGES\n#include \"visualize.h\"\n#endif\n\nextern void thread_decode_CTB_row(void* d);\nextern void thread_decode_slice_segment(void* d);\n\n\nthread_context::thread_context()\n{\n  /*\n  CtbAddrInRS = 0;\n  CtbAddrInTS = 0;\n\n  CtbX = 0;\n  CtbY = 0;\n  */\n\n  /*\n  refIdx[0] = refIdx[1] = 0;\n  mvd[0][0] = mvd[0][1] = mvd[1][0] = mvd[1][1] = 0;\n  merge_flag = 0;\n  merge_idx = 0;\n  mvp_lX_flag[0] = mvp_lX_flag[1] = 0;\n  inter_pred_idc = 0;\n  */\n\n  /*\n  enum IntraPredMode IntraPredModeC; // chroma intra-prediction mode for current CB\n  */\n\n  /*\n  cu_transquant_bypass_flag = false;\n  memset(transform_skip_flag,0, 3*sizeof(uint8_t));\n  */\n\n\n  //memset(coeffList,0,sizeof(int16_t)*3*32*32);\n  //memset(coeffPos,0,sizeof(int16_t)*3*32*32);\n  //memset(nCoeff,0,sizeof(int16_t)*3);\n\n\n\n  IsCuQpDeltaCoded = false;\n  CuQpDelta = 0;\n\n  IsCuChromaQpOffsetCoded = false;\n  CuQpOffsetCb = 0;\n  CuQpOffsetCr = 0;\n\n  /*\n  currentQPY = 0;\n  currentQG_x = 0;\n  currentQG_y = 0;\n  lastQPYinPreviousQG = 0;\n  */\n\n  /*\n  qPYPrime = 0;\n  qPCbPrime = 0;\n  qPCrPrime = 0;\n  */\n\n  /*\n  memset(&cabac_decoder, 0, sizeof(CABAC_decoder));\n  memset(&ctx_model, 0, sizeof(ctx_model));\n  */\n\n  decctx = NULL;\n  img = NULL;\n  shdr = NULL;\n\n  imgunit = NULL;\n  sliceunit = NULL;\n\n\n  //memset(this,0,sizeof(thread_context));\n\n  // There is a interesting issue here. When aligning _coeffBuf to 16 bytes offset with\n  // __attribute__((align(16))), the following statement is optimized away since the\n  // compiler assumes that the pointer would be 16-byte aligned. However, this is not the\n  // case when the structure has been dynamically allocated. In this case, the base can\n  // also be at 8 byte offsets (at least with MingW,32 bit).\n  int offset = ((uintptr_t)_coeffBuf) & 0xf;\n\n  if (offset == 0) {\n    coeffBuf = _coeffBuf;  // correctly aligned already\n  }\n  else {\n    coeffBuf = (int16_t *) (((uint8_t *)_coeffBuf) + (16-offset));\n  }\n\n  memset(coeffBuf, 0, 32*32*sizeof(int16_t));\n}\n\n\nslice_unit::slice_unit(decoder_context* decctx)\n  : nal(NULL),\n    shdr(NULL),\n    imgunit(NULL),\n    flush_reorder_buffer(false),\n    nThreads(0),\n    first_decoded_CTB_RS(-1),\n    last_decoded_CTB_RS(-1),\n    thread_contexts(NULL),\n    ctx(decctx)\n{\n  state = Unprocessed;\n  nThreadContexts = 0;\n}\n\nslice_unit::~slice_unit()\n{\n  ctx->nal_parser.free_NAL_unit(nal);\n\n  if (thread_contexts) {\n    delete[] thread_contexts;\n  }\n}\n\n\nvoid slice_unit::allocate_thread_contexts(int n)\n{\n  assert(thread_contexts==NULL);\n\n  thread_contexts = new thread_context[n];\n  nThreadContexts = n;\n}\n\n\nimage_unit::image_unit()\n{\n  img=NULL;\n  role=Invalid;\n  state=Unprocessed;\n}\n\n\nimage_unit::~image_unit()\n{\n  for (int i=0;i<slice_units.size();i++) {\n    delete slice_units[i];\n  }\n\n  for (int i=0;i<tasks.size();i++) {\n    delete tasks[i];\n  }\n}\n\n\nbase_context::base_context()\n{\n  set_acceleration_functions(de265_acceleration_AUTO);\n}\n\n\ndecoder_context::decoder_context()\n{\n  //memset(ctx, 0, sizeof(decoder_context));\n\n  // --- parameters ---\n\n  param_sei_check_hash = false;\n  param_conceal_stream_errors = true;\n  param_suppress_faulty_pictures = false;\n\n  param_disable_deblocking = false;\n  param_disable_sao = false;\n  //param_disable_mc_residual_idct = false;\n  //param_disable_intra_residual_idct = false;\n\n  // --- processing ---\n\n  param_sps_headers_fd = -1;\n  param_vps_headers_fd = -1;\n  param_pps_headers_fd = -1;\n  param_slice_headers_fd = -1;\n\n  param_image_allocation_functions = de265_image::default_image_allocation;\n  param_image_allocation_userdata  = NULL;\n\n  /*\n  memset(&vps, 0, sizeof(video_parameter_set)*DE265_MAX_VPS_SETS);\n  memset(&sps, 0, sizeof(seq_parameter_set)  *DE265_MAX_SPS_SETS);\n  memset(&pps, 0, sizeof(pic_parameter_set)  *DE265_MAX_PPS_SETS);\n  memset(&slice,0,sizeof(slice_segment_header)*DE265_MAX_SLICES);\n  */\n\n  current_vps = NULL;\n  current_sps = NULL;\n  current_pps = NULL;\n\n  //memset(&thread_pool,0,sizeof(struct thread_pool));\n  num_worker_threads = 0;\n\n\n  // frame-rate\n\n  limit_HighestTid = 6;   // decode all temporal layers (up to layer 6)\n  framerate_ratio = 100;  // decode all 100%\n\n  goal_HighestTid = 6;\n  current_HighestTid = 6;\n  layer_framerate_ratio = 100;\n\n  compute_framedrop_table();\n\n\n  //\n\n  current_image_poc_lsb = 0;\n  first_decoded_picture = 0;\n  NoRaslOutputFlag = 0;\n  HandleCraAsBlaFlag = 0;\n  FirstAfterEndOfSequenceNAL = 0;\n  PicOrderCntMsb = 0;\n  prevPicOrderCntLsb = 0;\n  prevPicOrderCntMsb = 0;\n  img = NULL;\n  previous_slice_header = nullptr;\n\n  /*\n  int PocLsbLt[MAX_NUM_REF_PICS];\n  int UsedByCurrPicLt[MAX_NUM_REF_PICS];\n  int DeltaPocMsbCycleLt[MAX_NUM_REF_PICS];\n  int CurrDeltaPocMsbPresentFlag[MAX_NUM_REF_PICS];\n  int FollDeltaPocMsbPresentFlag[MAX_NUM_REF_PICS];\n\n  int NumPocStCurrBefore;\n  int NumPocStCurrAfter;\n  int NumPocStFoll;\n  int NumPocLtCurr;\n  int NumPocLtFoll;\n\n  // These lists contain absolute POC values.\n  int PocStCurrBefore[MAX_NUM_REF_PICS]; // used for reference in current picture, smaller POC\n  int PocStCurrAfter[MAX_NUM_REF_PICS];  // used for reference in current picture, larger POC\n  int PocStFoll[MAX_NUM_REF_PICS]; // not used for reference in current picture, but in future picture\n  int PocLtCurr[MAX_NUM_REF_PICS]; // used in current picture\n  int PocLtFoll[MAX_NUM_REF_PICS]; // used in some future picture\n\n  // These lists contain indices into the DPB.\n  int RefPicSetStCurrBefore[DE265_DPB_SIZE];\n  int RefPicSetStCurrAfter[DE265_DPB_SIZE];\n  int RefPicSetStFoll[DE265_DPB_SIZE];\n  int RefPicSetLtCurr[DE265_DPB_SIZE];\n  int RefPicSetLtFoll[DE265_DPB_SIZE];\n\n\n  uint8_t nal_unit_type;\n\n  char IdrPicFlag;\n  char RapPicFlag;\n  */\n\n\n\n  // --- internal data ---\n\n  first_decoded_picture = true;\n  //ctx->FirstAfterEndOfSequenceNAL = true;\n  //ctx->last_RAP_picture_NAL_type = NAL_UNIT_UNDEFINED;\n\n  //de265_init_image(&ctx->coeff);\n\n  // --- decoded picture buffer ---\n\n  current_image_poc_lsb = -1; // any invalid number\n}\n\n\ndecoder_context::~decoder_context()\n{\n  while (!image_units.empty()) {\n    delete image_units.back();\n    image_units.pop_back();\n  }\n}\n\n\nvoid decoder_context::set_image_allocation_functions(de265_image_allocation* allocfunc,\n                                                     void* userdata)\n{\n  if (allocfunc) {\n    param_image_allocation_functions = *allocfunc;\n    param_image_allocation_userdata  = userdata;\n  }\n  else {\n    assert(false); // actually, it makes no sense to reset the allocation functions\n\n    param_image_allocation_functions = de265_image::default_image_allocation;\n    param_image_allocation_userdata  = NULL;\n  }\n}\n\n\nde265_error decoder_context::start_thread_pool(int nThreads)\n{\n  ::start_thread_pool(&thread_pool_, nThreads);\n\n  num_worker_threads = nThreads;\n\n  return DE265_OK;\n}\n\n\nvoid decoder_context::stop_thread_pool()\n{\n  if (get_num_worker_threads()>0) {\n    //flush_thread_pool(&ctx->thread_pool);\n    ::stop_thread_pool(&thread_pool_);\n  }\n}\n\n\nvoid decoder_context::reset()\n{\n  if (num_worker_threads>0) {\n    //flush_thread_pool(&ctx->thread_pool);\n    ::stop_thread_pool(&thread_pool_);\n  }\n\n  // --------------------------------------------------\n\n#if 0\n  ctx->end_of_stream = false;\n  ctx->pending_input_NAL = NULL;\n  ctx->current_vps = NULL;\n  ctx->current_sps = NULL;\n  ctx->current_pps = NULL;\n  ctx->num_worker_threads = 0;\n  ctx->current_image_poc_lsb = 0;\n  ctx->first_decoded_picture = 0;\n  ctx->NoRaslOutputFlag = 0;\n  ctx->HandleCraAsBlaFlag = 0;\n  ctx->FirstAfterEndOfSequenceNAL = 0;\n  ctx->PicOrderCntMsb = 0;\n  ctx->prevPicOrderCntLsb = 0;\n  ctx->prevPicOrderCntMsb = 0;\n  ctx->NumPocStCurrBefore=0;\n  ctx->NumPocStCurrAfter=0;\n  ctx->NumPocStFoll=0;\n  ctx->NumPocLtCurr=0;\n  ctx->NumPocLtFoll=0;\n  ctx->nal_unit_type=0;\n  ctx->IdrPicFlag=0;\n  ctx->RapPicFlag=0;\n#endif\n\n  img = NULL;\n\n\n  // TODO: remove all pending image_units\n\n\n  // --- decoded picture buffer ---\n\n  current_image_poc_lsb = -1; // any invalid number\n  first_decoded_picture = true;\n\n\n  // --- remove all pictures from output queue ---\n\n  // there was a bug the peek_next_image did not return NULL on empty output queues.\n  // This was (indirectly) fixed by recreating the DPB buffer, but it should actually\n  // be sufficient to clear it like this.\n  // The error showed while scrubbing the ToS video in VLC.\n  dpb.clear();\n\n  nal_parser.remove_pending_input_data();\n\n\n  while (!image_units.empty()) {\n    delete image_units.back();\n    image_units.pop_back();\n  }\n\n  // --- start threads again ---\n\n  if (num_worker_threads>0) {\n    // TODO: need error checking\n    start_thread_pool(num_worker_threads);\n  }\n}\n\nvoid base_context::set_acceleration_functions(enum de265_acceleration l)\n{\n  // fill scalar functions first (so that function table is completely filled)\n\n  init_acceleration_functions_fallback(&acceleration);\n\n\n  // override functions with optimized variants\n\n#ifdef HAVE_SSE4_1\n  if (l>=de265_acceleration_SSE) {\n    init_acceleration_functions_sse(&acceleration);\n  }\n#endif\n#ifdef HAVE_ARM\n  if (l>=de265_acceleration_ARM) {\n    init_acceleration_functions_arm(&acceleration);\n  }\n#endif\n}\n\n\nvoid decoder_context::init_thread_context(thread_context* tctx)\n{\n  // zero scrap memory for coefficient blocks\n  memset(tctx->_coeffBuf, 0, sizeof(tctx->_coeffBuf));  // TODO: check if we can safely remove this\n\n  tctx->currentQG_x = -1;\n  tctx->currentQG_y = -1;\n\n\n\n  // --- find QPY that was active at the end of the previous slice ---\n\n  // find the previous CTB in TS order\n\n  const pic_parameter_set& pps = tctx->img->get_pps();\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n\n  if (tctx->shdr->slice_segment_address > 0) {\n    int prevCtb = pps.CtbAddrTStoRS[ pps.CtbAddrRStoTS[tctx->shdr->slice_segment_address] -1 ];\n\n    int ctbX = prevCtb % sps.PicWidthInCtbsY;\n    int ctbY = prevCtb / sps.PicWidthInCtbsY;\n\n\n    // take the pixel at the bottom right corner (but consider that the image size might be smaller)\n\n    int x = ((ctbX+1) << sps.Log2CtbSizeY)-1;\n    int y = ((ctbY+1) << sps.Log2CtbSizeY)-1;\n\n    x = std::min(x,sps.pic_width_in_luma_samples-1);\n    y = std::min(y,sps.pic_height_in_luma_samples-1);\n\n    //printf(\"READ QPY: %d %d -> %d (should %d)\\n\",x,y,imgunit->img->get_QPY(x,y), tc.currentQPY);\n\n    //if (tctx->shdr->dependent_slice_segment_flag) {  // TODO: do we need this condition ?\n    tctx->currentQPY = tctx->img->get_QPY(x,y);\n      //}\n  }\n}\n\n\nvoid decoder_context::add_task_decode_CTB_row(thread_context* tctx,\n                                              bool firstSliceSubstream,\n                                              int ctbRow)\n{\n  thread_task_ctb_row* task = new thread_task_ctb_row;\n  task->firstSliceSubstream = firstSliceSubstream;\n  task->tctx = tctx;\n  task->debug_startCtbRow = ctbRow;\n  tctx->task = task;\n\n  add_task(&thread_pool_, task);\n\n  tctx->imgunit->tasks.push_back(task);\n}\n\n\nvoid decoder_context::add_task_decode_slice_segment(thread_context* tctx, bool firstSliceSubstream,\n                                                    int ctbx,int ctby)\n{\n  thread_task_slice_segment* task = new thread_task_slice_segment;\n  task->firstSliceSubstream = firstSliceSubstream;\n  task->tctx = tctx;\n  task->debug_startCtbX = ctbx;\n  task->debug_startCtbY = ctby;\n  tctx->task = task;\n\n  add_task(&thread_pool_, task);\n\n  tctx->imgunit->tasks.push_back(task);\n}\n\n\nde265_error decoder_context::read_vps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"---> read VPS\\n\");\n\n  std::shared_ptr<video_parameter_set> new_vps = std::make_shared<video_parameter_set>();\n  de265_error err = new_vps->read(this,&reader);\n  if (err != DE265_OK) {\n    return err;\n  }\n\n  if (param_vps_headers_fd>=0) {\n    new_vps->dump(param_vps_headers_fd);\n  }\n\n  vps[ new_vps->video_parameter_set_id ] = new_vps;\n\n  return DE265_OK;\n}\n\nde265_error decoder_context::read_sps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read SPS\\n\");\n\n  std::shared_ptr<seq_parameter_set> new_sps = std::make_shared<seq_parameter_set>();\n  de265_error err;\n\n  if ((err=new_sps->read(this, &reader)) != DE265_OK) {\n    return err;\n  }\n\n  if (param_sps_headers_fd>=0) {\n    new_sps->dump(param_sps_headers_fd);\n  }\n\n  sps[ new_sps->seq_parameter_set_id ] = new_sps;\n\n  // Remove the all PPS that referenced the old SPS because parameters may have changed and we do not want to\n  // get the SPS and PPS parameters (e.g. image size) out of sync.\n  \n  for (auto& p : pps) {\n    if (p && p->seq_parameter_set_id == new_sps->seq_parameter_set_id) {\n      p = nullptr;\n    }\n  }\n\n  return DE265_OK;\n}\n\nde265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n\n  bool success = new_pps->read(&reader,this);\n  if (!success) {\n    return DE265_WARNING_PPS_HEADER_INVALID;\n  }\n\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n\n  pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n\n  return DE265_OK;\n}\n\nde265_error decoder_context::read_sei_NAL(bitreader& reader, bool suffix)\n{\n  logdebug(LogHeaders,\"----> read SEI\\n\");\n\n  sei_message sei;\n\n  //push_current_picture_to_output_queue();\n\n  de265_error err = DE265_OK;\n\n  if ((err=read_sei(&reader,&sei, suffix, current_sps.get())) == DE265_OK) {\n    dump_sei(&sei, current_sps.get());\n\n    if (image_units.empty()==false && suffix) {\n      image_units.back()->suffix_SEIs.push_back(sei);\n    }\n  }\n  else {\n    add_warning(err, false);\n  }\n\n  return err;\n}\n\nde265_error decoder_context::read_eos_NAL(bitreader& reader)\n{\n  FirstAfterEndOfSequenceNAL = true;\n  return DE265_OK;\n}\n\nde265_error decoder_context::read_slice_NAL(bitreader& reader, NAL_unit* nal, nal_header& nal_hdr)\n{\n  logdebug(LogHeaders,\"---> read slice segment header\\n\");\n\n\n  // --- read slice header ---\n\n  slice_segment_header* shdr = new slice_segment_header;\n  bool continueDecoding;\n  de265_error err = shdr->read(&reader,this, &continueDecoding);\n  if (!continueDecoding) {\n    if (img) { img->integrity = INTEGRITY_NOT_DECODED; }\n    nal_parser.free_NAL_unit(nal);\n    delete shdr;\n    return err;\n  }\n\n  if (param_slice_headers_fd>=0) {\n    shdr->dump_slice_segment_header(this, param_slice_headers_fd);\n  }\n\n\n  if (process_slice_segment_header(shdr, &err, nal->pts, &nal_hdr, nal->user_data) == false)\n    {\n      if (img!=NULL) img->integrity = INTEGRITY_NOT_DECODED;\n      nal_parser.free_NAL_unit(nal);\n      delete shdr;\n      return err;\n    }\n\n  this->img->add_slice_segment_header(shdr);\n\n  skip_bits(&reader,1); // TODO: why?\n  prepare_for_CABAC(&reader);\n\n\n  // modify entry_point_offsets\n\n  int headerLength = reader.data - nal->data();\n  for (int i=0;i<shdr->num_entry_point_offsets;i++) {\n    shdr->entry_point_offset[i] -= nal->num_skipped_bytes_before(shdr->entry_point_offset[i],\n                                                                 headerLength);\n  }\n\n\n\n  // --- start a new image if this is the first slice ---\n\n  if (shdr->first_slice_segment_in_pic_flag) {\n    image_unit* imgunit = new image_unit;\n    imgunit->img = this->img;\n    image_units.push_back(imgunit);\n  }\n\n\n  // --- add slice to current picture ---\n\n  if ( ! image_units.empty() ) {\n\n    slice_unit* sliceunit = new slice_unit(this);\n    sliceunit->nal = nal;\n    sliceunit->shdr = shdr;\n    sliceunit->reader = reader;\n\n    sliceunit->flush_reorder_buffer = flush_reorder_buffer_at_this_frame;\n\n\n    image_units.back()->slice_units.push_back(sliceunit);\n  }\n\n  bool did_work;\n  err = decode_some(&did_work);\n\n  return DE265_OK;\n}\n\n\ntemplate <class T> void pop_front(std::vector<T>& vec)\n{\n  for (int i=1;i<vec.size();i++)\n    vec[i-1] = vec[i];\n\n  vec.pop_back();\n}\n\n\nde265_error decoder_context::decode_some(bool* did_work)\n{\n  de265_error err = DE265_OK;\n\n  *did_work = false;\n\n  if (image_units.empty()) { return DE265_OK; }  // nothing to do\n\n\n  // decode something if there is work to do\n\n  if ( ! image_units.empty() ) { // && ! image_units[0]->slice_units.empty() ) {\n\n    image_unit* imgunit = image_units[0];\n    slice_unit* sliceunit = imgunit->get_next_unprocessed_slice_segment();\n\n    if (sliceunit != NULL) {\n\n      //pop_front(imgunit->slice_units);\n\n      if (sliceunit->flush_reorder_buffer) {\n        dpb.flush_reorder_buffer();\n      }\n\n      *did_work = true;\n\n      //err = decode_slice_unit_sequential(imgunit, sliceunit);\n      err = decode_slice_unit_parallel(imgunit, sliceunit);\n      if (err) {\n        return err;\n      }\n\n      //delete sliceunit;\n    }\n  }\n\n\n\n  // if we decoded all slices of the current image and there will not\n  // be added any more slices to the image, output the image\n\n  if ( ( image_units.size()>=2 && image_units[0]->all_slice_segments_processed()) ||\n       ( image_units.size()>=1 && image_units[0]->all_slice_segments_processed() &&\n         nal_parser.number_of_NAL_units_pending()==0 &&\n         (nal_parser.is_end_of_stream() || nal_parser.is_end_of_frame()) )) {\n\n    image_unit* imgunit = image_units[0];\n\n    *did_work=true;\n\n\n    // mark all CTBs as decoded even if they are not, because faulty input\n    // streams could miss part of the picture\n    // TODO: this will not work when slice decoding is parallel to post-filtering,\n    // so we will have to replace this with keeping track of which CTB should have\n    // been decoded (but aren't because of the input stream being faulty)\n\n    imgunit->img->mark_all_CTB_progress(CTB_PROGRESS_PREFILTER);\n\n\n\n    // run post-processing filters (deblocking & SAO)\n\n    if (img->decctx->num_worker_threads)\n      run_postprocessing_filters_parallel(imgunit);\n    else\n      run_postprocessing_filters_sequential(imgunit->img);\n\n    // process suffix SEIs\n\n    for (int i=0;i<imgunit->suffix_SEIs.size();i++) {\n      const sei_message& sei = imgunit->suffix_SEIs[i];\n\n      err = process_sei(&sei, imgunit->img);\n      if (err != DE265_OK)\n        break;\n    }\n\n\n    push_picture_to_output_queue(imgunit);\n\n    // remove just decoded image unit from queue\n\n    delete imgunit;\n\n    pop_front(image_units);\n  }\n\n  return err;\n}\n\n\nde265_error decoder_context::decode_slice_unit_sequential(image_unit* imgunit,\n                                                          slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  /*\n  printf(\"decode slice POC=%d addr=%d, img=%p\\n\",\n         sliceunit->shdr->slice_pic_order_cnt_lsb,\n         sliceunit->shdr->slice_segment_address,\n         imgunit->img);\n  */\n\n  remove_images_from_dpb(sliceunit->shdr->RemoveReferencesList);\n\n  if (sliceunit->shdr->slice_segment_address >= imgunit->img->get_pps().CtbAddrRStoTS.size()) {\n    return DE265_ERROR_CTB_OUTSIDE_IMAGE_AREA;\n  }\n\n\n  struct thread_context tctx;\n\n  tctx.shdr = sliceunit->shdr;\n  tctx.img  = imgunit->img;\n  tctx.decctx = this;\n  tctx.imgunit = imgunit;\n  tctx.sliceunit= sliceunit;\n  tctx.CtbAddrInTS = imgunit->img->get_pps().CtbAddrRStoTS[tctx.shdr->slice_segment_address];\n  tctx.task = NULL;\n\n  init_thread_context(&tctx);\n\n  if (sliceunit->reader.bytes_remaining <= 0) {\n    return DE265_ERROR_PREMATURE_END_OF_SLICE;\n  }\n\n  init_CABAC_decoder(&tctx.cabac_decoder,\n                     sliceunit->reader.data,\n                     sliceunit->reader.bytes_remaining);\n\n  // alloc CABAC-model array if entropy_coding_sync is enabled\n\n  if (imgunit->img->get_pps().entropy_coding_sync_enabled_flag &&\n      sliceunit->shdr->first_slice_segment_in_pic_flag) {\n    imgunit->ctx_models.resize( (img->get_sps().PicHeightInCtbsY-1) ); //* CONTEXT_MODEL_TABLE_LENGTH );\n  }\n\n  sliceunit->nThreads=1;\n\n  err=read_slice_segment_data(&tctx);\n\n  sliceunit->finished_threads.set_progress(1);\n\n  return err;\n}\n\n\nvoid decoder_context::mark_whole_slice_as_processed(image_unit* imgunit,\n                                                    slice_unit* sliceunit,\n                                                    int progress)\n{\n  //printf(\"mark whole slice\\n\");\n\n\n  // mark all CTBs upto the next slice segment as processed\n\n  slice_unit* nextSegment = imgunit->get_next_slice_segment(sliceunit);\n  if (nextSegment) {\n    /*\n    printf(\"mark whole slice between %d and %d\\n\",\n           sliceunit->shdr->slice_segment_address,\n           nextSegment->shdr->slice_segment_address);\n    */\n\n    for (int ctb=sliceunit->shdr->slice_segment_address;\n         ctb < nextSegment->shdr->slice_segment_address;\n         ctb++)\n      {\n        if (ctb >= imgunit->img->number_of_ctbs())\n          break;\n\n        imgunit->img->ctb_progress[ctb].set_progress(progress);\n      }\n  }\n}\n\n\nde265_error decoder_context::decode_slice_unit_parallel(image_unit* imgunit,\n                                                        slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  remove_images_from_dpb(sliceunit->shdr->RemoveReferencesList);\n\n  /*\n  printf(\"-------- decode --------\\n\");\n  printf(\"IMAGE UNIT %p\\n\",imgunit);\n  sliceunit->shdr->dump_slice_segment_header(sliceunit->ctx, 1);\n  imgunit->dump_slices();\n  */\n\n  de265_image* img = imgunit->img;\n  const pic_parameter_set& pps = img->get_pps();\n\n  sliceunit->state = slice_unit::InProgress;\n\n  bool use_WPP = (img->decctx->num_worker_threads > 0 &&\n                  pps.entropy_coding_sync_enabled_flag);\n\n  bool use_tiles = (img->decctx->num_worker_threads > 0 &&\n                    pps.tiles_enabled_flag);\n\n\n  // TODO: remove this warning later when we do frame-parallel decoding\n  if (img->decctx->num_worker_threads > 0 &&\n      pps.entropy_coding_sync_enabled_flag == false &&\n      pps.tiles_enabled_flag == false) {\n\n    img->decctx->add_warning(DE265_WARNING_NO_WPP_CANNOT_USE_MULTITHREADING, true);\n  }\n\n\n  // If this is the first slice segment, mark all CTBs before this as processed\n  // (the real first slice segment could be missing).\n\n  if (imgunit->is_first_slice_segment(sliceunit)) {\n    slice_segment_header* shdr = sliceunit->shdr;\n    int firstCTB = shdr->slice_segment_address;\n\n    for (int ctb=0;ctb<firstCTB;ctb++) {\n      //printf(\"mark pre progress %d\\n\",ctb);\n      img->ctb_progress[ctb].set_progress(CTB_PROGRESS_PREFILTER);\n    }\n  }\n\n\n  // if there is a previous slice that has been completely decoded,\n  // mark all CTBs until the start of this slice as completed\n\n  //printf(\"this slice: %p\\n\",sliceunit);\n  slice_unit* prevSlice = imgunit->get_prev_slice_segment(sliceunit);\n  //if (prevSlice) printf(\"prev slice state: %d\\n\",prevSlice->state);\n  if (prevSlice && prevSlice->state == slice_unit::Decoded) {\n    mark_whole_slice_as_processed(imgunit,prevSlice,CTB_PROGRESS_PREFILTER);\n  }\n\n\n  // TODO: even though we cannot split this into several tasks, we should run it\n  // as a background thread\n  if (!use_WPP && !use_tiles) {\n    //printf(\"SEQ\\n\");\n    err = decode_slice_unit_sequential(imgunit, sliceunit);\n    sliceunit->state = slice_unit::Decoded;\n    mark_whole_slice_as_processed(imgunit,sliceunit,CTB_PROGRESS_PREFILTER);\n    return err;\n  }\n\n\n  if (use_WPP && use_tiles) {\n    // TODO: this is not allowed ... output some warning or error\n\n    return DE265_WARNING_PPS_HEADER_INVALID;\n  }\n\n\n  if (use_WPP) {\n    //printf(\"WPP\\n\");\n    err = decode_slice_unit_WPP(imgunit, sliceunit);\n    sliceunit->state = slice_unit::Decoded;\n    mark_whole_slice_as_processed(imgunit,sliceunit,CTB_PROGRESS_PREFILTER);\n    return err;\n  }\n  else if (use_tiles) {\n    //printf(\"TILE\\n\");\n    err = decode_slice_unit_tiles(imgunit, sliceunit);\n    sliceunit->state = slice_unit::Decoded;\n    mark_whole_slice_as_processed(imgunit,sliceunit,CTB_PROGRESS_PREFILTER);\n    return err;\n  }\n\n  assert(false);\n  return err;\n}\n\n\nde265_error decoder_context::decode_slice_unit_WPP(image_unit* imgunit,\n                                                   slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  de265_image* img = imgunit->img;\n  slice_segment_header* shdr = sliceunit->shdr;\n  const pic_parameter_set& pps = img->get_pps();\n\n  int nRows = shdr->num_entry_point_offsets +1;\n  int ctbsWidth = img->get_sps().PicWidthInCtbsY;\n\n\n  assert(img->num_threads_active() == 0);\n\n\n  // reserve space to store entropy coding context models for each CTB row\n\n  if (shdr->first_slice_segment_in_pic_flag) {\n    // reserve space for nRows-1 because we don't need to save the CABAC model in the last CTB row\n    imgunit->ctx_models.resize( (img->get_sps().PicHeightInCtbsY-1) ); //* CONTEXT_MODEL_TABLE_LENGTH );\n  }\n\n\n  sliceunit->allocate_thread_contexts(nRows);\n\n\n  // first CTB in this slice\n  int ctbAddrRS = shdr->slice_segment_address;\n  int ctbRow    = ctbAddrRS / ctbsWidth;\n\n  for (int entryPt=0;entryPt<nRows;entryPt++) {\n    // entry points other than the first start at CTB rows\n    if (entryPt>0) {\n      ctbRow++;\n      ctbAddrRS = ctbRow * ctbsWidth;\n    }\n    else if (nRows>1 && (ctbAddrRS % ctbsWidth) != 0) {\n      // If slice segment consists of several WPP rows, each of them\n      // has to start at a row.\n\n      //printf(\"does not start at start\\n\");\n\n      err = DE265_WARNING_SLICEHEADER_INVALID;\n      break;\n    }\n\n\n    // prepare thread context\n\n    thread_context* tctx = sliceunit->get_thread_context(entryPt);\n\n    tctx->shdr    = shdr;\n    tctx->decctx  = img->decctx;\n    tctx->img     = img;\n    tctx->imgunit = imgunit;\n    tctx->sliceunit= sliceunit;\n    tctx->CtbAddrInTS = pps.CtbAddrRStoTS[ctbAddrRS];\n\n    init_thread_context(tctx);\n\n\n    // init CABAC\n\n    int dataStartIndex;\n    if (entryPt==0) { dataStartIndex=0; }\n    else            { dataStartIndex=shdr->entry_point_offset[entryPt-1]; }\n\n    int dataEnd;\n    if (entryPt==nRows-1) dataEnd = sliceunit->reader.bytes_remaining;\n    else                  dataEnd = shdr->entry_point_offset[entryPt];\n\n    if (dataStartIndex<0 || dataEnd>sliceunit->reader.bytes_remaining ||\n        dataEnd <= dataStartIndex) {\n      //printf(\"WPP premature end\\n\");\n      err = DE265_ERROR_PREMATURE_END_OF_SLICE;\n      break;\n    }\n\n    init_CABAC_decoder(&tctx->cabac_decoder,\n                       &sliceunit->reader.data[dataStartIndex],\n                       dataEnd-dataStartIndex);\n\n    // add task\n\n    //printf(\"start task for ctb-row: %d\\n\",ctbRow);\n    img->thread_start(1);\n    sliceunit->nThreads++;\n    add_task_decode_CTB_row(tctx, entryPt==0, ctbRow);\n  }\n\n#if 0\n  for (;;) {\n    printf(\"q:%d r:%d b:%d f:%d\\n\",\n           img->nThreadsQueued,\n           img->nThreadsRunning,\n           img->nThreadsBlocked,\n           img->nThreadsFinished);\n\n    if (img->debug_is_completed()) break;\n\n    usleep(1000);\n  }\n#endif\n\n  img->wait_for_completion();\n\n  for (int i=0;i<imgunit->tasks.size();i++)\n    delete imgunit->tasks[i];\n  imgunit->tasks.clear();\n\n  return DE265_OK;\n}\n\nde265_error decoder_context::decode_slice_unit_tiles(image_unit* imgunit,\n                                                     slice_unit* sliceunit)\n{\n  de265_error err = DE265_OK;\n\n  de265_image* img = imgunit->img;\n  slice_segment_header* shdr = sliceunit->shdr;\n  const pic_parameter_set& pps = img->get_pps();\n\n  int nTiles = shdr->num_entry_point_offsets +1;\n  int ctbsWidth = img->get_sps().PicWidthInCtbsY;\n\n\n  assert(img->num_threads_active() == 0);\n\n  sliceunit->allocate_thread_contexts(nTiles);\n\n\n  // first CTB in this slice\n  int ctbAddrRS = shdr->slice_segment_address;\n  int tileID = pps.TileIdRS[ctbAddrRS];\n\n  for (int entryPt=0;entryPt<nTiles;entryPt++) {\n    // entry points other than the first start at tile beginnings\n    if (entryPt>0) {\n      tileID++;\n\n      if (tileID >= pps.num_tile_columns * pps.num_tile_rows) {\n        err = DE265_WARNING_SLICEHEADER_INVALID;\n        break;\n      }\n\n      int ctbX = pps.colBd[tileID % pps.num_tile_columns];\n      int ctbY = pps.rowBd[tileID / pps.num_tile_columns];\n      ctbAddrRS = ctbY * ctbsWidth + ctbX;\n    }\n\n    // set thread context\n\n    thread_context* tctx = sliceunit->get_thread_context(entryPt);\n\n    tctx->shdr   = shdr;\n    tctx->decctx = img->decctx;\n    tctx->img    = img;\n    tctx->imgunit = imgunit;\n    tctx->sliceunit= sliceunit;\n    tctx->CtbAddrInTS = pps.CtbAddrRStoTS[ctbAddrRS];\n\n    init_thread_context(tctx);\n\n\n    // init CABAC\n\n    int dataStartIndex;\n    if (entryPt==0) { dataStartIndex=0; }\n    else            { dataStartIndex=shdr->entry_point_offset[entryPt-1]; }\n\n    int dataEnd;\n    if (entryPt==nTiles-1) dataEnd = sliceunit->reader.bytes_remaining;\n    else                   dataEnd = shdr->entry_point_offset[entryPt];\n\n    if (dataStartIndex<0 || dataEnd>sliceunit->reader.bytes_remaining ||\n        dataEnd <= dataStartIndex) {\n      err = DE265_ERROR_PREMATURE_END_OF_SLICE;\n      break;\n    }\n\n    init_CABAC_decoder(&tctx->cabac_decoder,\n                       &sliceunit->reader.data[dataStartIndex],\n                       dataEnd-dataStartIndex);\n\n    // add task\n\n    //printf(\"add tiles thread\\n\");\n    img->thread_start(1);\n    sliceunit->nThreads++;\n    add_task_decode_slice_segment(tctx, entryPt==0,\n                                  ctbAddrRS % ctbsWidth,\n                                  ctbAddrRS / ctbsWidth);\n  }\n\n  img->wait_for_completion();\n\n  for (int i=0;i<imgunit->tasks.size();i++)\n    delete imgunit->tasks[i];\n  imgunit->tasks.clear();\n\n  return err;\n}\n\n\nde265_error decoder_context::decode_NAL(NAL_unit* nal)\n{\n  //return decode_NAL_OLD(nal);\n\n  decoder_context* ctx = this;\n\n  de265_error err = DE265_OK;\n\n  bitreader reader;\n  bitreader_init(&reader, nal->data(), nal->size());\n\n  nal_header nal_hdr;\n  nal_hdr.read(&reader);\n  ctx->process_nal_hdr(&nal_hdr);\n\n  if (nal_hdr.nuh_layer_id > 0) {\n    // Discard all NAL units with nuh_layer_id > 0\n    // These will have to be handeled by an SHVC decoder.\n    nal_parser.free_NAL_unit(nal);\n    return DE265_OK;\n  }\n\n  loginfo(LogHighlevel,\"NAL: 0x%x 0x%x -  unit type:%s temporal id:%d\\n\",\n          nal->data()[0], nal->data()[1],\n          get_NAL_name(nal_hdr.nal_unit_type),\n          nal_hdr.nuh_temporal_id);\n\n  /*\n    printf(\"NAL: 0x%x 0x%x -  unit type:%s temporal id:%d\\n\",\n    nal->data()[0], nal->data()[1],\n    get_NAL_name(nal_hdr.nal_unit_type),\n    nal_hdr.nuh_temporal_id);\n  */\n\n  // throw away NALs from higher TIDs than currently selected\n  // TODO: better online switching of HighestTID\n\n  //printf(\"hTid: %d\\n\", current_HighestTid);\n\n  if (nal_hdr.nuh_temporal_id > current_HighestTid) {\n    nal_parser.free_NAL_unit(nal);\n    return DE265_OK;\n  }\n\n\n  if (nal_hdr.nal_unit_type<32) {\n    err = read_slice_NAL(reader, nal, nal_hdr);\n  }\n  else switch (nal_hdr.nal_unit_type) {\n    case NAL_UNIT_VPS_NUT:\n      err = read_vps_NAL(reader);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_SPS_NUT:\n      err = read_sps_NAL(reader);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_PPS_NUT:\n      err = read_pps_NAL(reader);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_PREFIX_SEI_NUT:\n    case NAL_UNIT_SUFFIX_SEI_NUT:\n      err = read_sei_NAL(reader, nal_hdr.nal_unit_type==NAL_UNIT_SUFFIX_SEI_NUT);\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    case NAL_UNIT_EOS_NUT:\n      ctx->FirstAfterEndOfSequenceNAL = true;\n      nal_parser.free_NAL_unit(nal);\n      break;\n\n    default:\n      nal_parser.free_NAL_unit(nal);\n      break;\n    }\n\n  return err;\n}\n\n\nde265_error decoder_context::decode(int* more)\n{\n  decoder_context* ctx = this;\n\n  // if the stream has ended, and no more NALs are to be decoded, flush all pictures\n\n  if (ctx->nal_parser.get_NAL_queue_length() == 0 &&\n      (ctx->nal_parser.is_end_of_stream() || ctx->nal_parser.is_end_of_frame()) &&\n      ctx->image_units.empty()) {\n\n    // flush all pending pictures into output queue\n\n    // ctx->push_current_picture_to_output_queue(); // TODO: not with new queue\n    ctx->dpb.flush_reorder_buffer();\n\n    if (more) { *more = ctx->dpb.num_pictures_in_output_queue(); }\n\n    return DE265_OK;\n  }\n\n\n  // if NAL-queue is empty, we need more data\n  // -> input stalled\n\n  if (ctx->nal_parser.is_end_of_stream() == false &&\n      ctx->nal_parser.is_end_of_frame() == false &&\n      ctx->nal_parser.get_NAL_queue_length() == 0) {\n    if (more) { *more=1; }\n\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n\n\n  // when there are no free image buffers in the DPB, pause decoding\n  // -> output stalled\n\n  if (!ctx->dpb.has_free_dpb_picture(false)) {\n    if (more) *more = 1;\n    return DE265_ERROR_IMAGE_BUFFER_FULL;\n  }\n\n\n  // decode one NAL from the queue\n\n  de265_error err = DE265_OK;\n  bool did_work = false;\n\n  if (ctx->nal_parser.get_NAL_queue_length()) { // number_of_NAL_units_pending()) {\n    NAL_unit* nal = ctx->nal_parser.pop_from_NAL_queue();\n    assert(nal);\n    err = ctx->decode_NAL(nal);\n    // ctx->nal_parser.free_NAL_unit(nal); TODO: do not free NAL with new loop\n    did_work=true;\n  }\n  else if (ctx->nal_parser.is_end_of_frame() == true &&\n      ctx->image_units.empty()) {\n    if (more) { *more=1; }\n\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  else {\n    err = decode_some(&did_work);\n  }\n\n  if (more) {\n    // decoding error is assumed to be unrecoverable\n    *more = (err==DE265_OK && did_work);\n  }\n\n  return err;\n}\n\n\nvoid decoder_context::process_nal_hdr(nal_header* nal)\n{\n  nal_unit_type = nal->nal_unit_type;\n\n  IdrPicFlag = isIdrPic(nal->nal_unit_type);\n  RapPicFlag = isRapPic(nal->nal_unit_type);\n}\n\n\n\n/* 8.3.1\n */\nvoid decoder_context::process_picture_order_count(slice_segment_header* hdr)\n{\n  loginfo(LogHeaders,\"POC computation. lsb:%d prev.pic.lsb:%d msb:%d\\n\",\n          hdr->slice_pic_order_cnt_lsb,\n          prevPicOrderCntLsb,\n          PicOrderCntMsb);\n\n  if (isIRAP(nal_unit_type) &&\n      NoRaslOutputFlag)\n    {\n      PicOrderCntMsb=0;\n\n\n      // flush all images from reorder buffer\n\n      flush_reorder_buffer_at_this_frame = true;\n      //ctx->dpb.flush_reorder_buffer();\n    }\n  else\n    {\n      int MaxPicOrderCntLsb = current_sps->MaxPicOrderCntLsb;\n\n      if ((hdr->slice_pic_order_cnt_lsb < prevPicOrderCntLsb) &&\n          (prevPicOrderCntLsb - hdr->slice_pic_order_cnt_lsb) >= MaxPicOrderCntLsb/2) {\n        PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb;\n      }\n      else if ((hdr->slice_pic_order_cnt_lsb > prevPicOrderCntLsb) &&\n               (hdr->slice_pic_order_cnt_lsb - prevPicOrderCntLsb) > MaxPicOrderCntLsb/2) {\n        PicOrderCntMsb = prevPicOrderCntMsb - MaxPicOrderCntLsb;\n      }\n      else {\n        PicOrderCntMsb = prevPicOrderCntMsb;\n      }\n    }\n\n  img->PicOrderCntVal = PicOrderCntMsb + hdr->slice_pic_order_cnt_lsb;\n  img->picture_order_cnt_lsb = hdr->slice_pic_order_cnt_lsb;\n\n  loginfo(LogHeaders,\"POC computation. new msb:%d POC=%d\\n\",\n          PicOrderCntMsb,\n          img->PicOrderCntVal);\n\n  if (img->nal_hdr.nuh_temporal_id==0 &&\n      !isSublayerNonReference(nal_unit_type) &&\n      !isRASL(nal_unit_type) &&\n      !isRADL(nal_unit_type))\n    {\n      loginfo(LogHeaders,\"set prevPicOrderCntLsb/Msb\\n\");\n\n      prevPicOrderCntLsb = hdr->slice_pic_order_cnt_lsb;\n      prevPicOrderCntMsb = PicOrderCntMsb;\n    }\n}\n\n\n/* 8.3.3.2\n   Returns DPB index of the generated picture.\n */\nint decoder_context::generate_unavailable_reference_picture(const seq_parameter_set* sps,\n                                                            int POC, bool longTerm)\n{\n  assert(dpb.has_free_dpb_picture(true));\n\n  std::shared_ptr<const seq_parameter_set> current_sps = this->sps[ (int)current_pps->seq_parameter_set_id ];\n\n  int idx = dpb.new_image(current_sps, this, 0,0, false);\n  if (idx<0) {\n    return idx;\n  }\n\n  de265_image* img = dpb.get_image(idx);\n\n  img->fill_image(1<<(sps->BitDepth_Y-1),\n                  1<<(sps->BitDepth_C-1),\n                  1<<(sps->BitDepth_C-1));\n\n  img->fill_pred_mode(MODE_INTRA);\n\n  img->PicOrderCntVal = POC;\n  img->picture_order_cnt_lsb = POC & (sps->MaxPicOrderCntLsb-1);\n  img->PicOutputFlag = false;\n  img->PicState = (longTerm ? UsedForLongTermReference : UsedForShortTermReference);\n  img->integrity = INTEGRITY_UNAVAILABLE_REFERENCE;\n\n  return idx;\n}\n\n\n/* 8.3.2   invoked once per picture\n\n   This function will mark pictures in the DPB as 'unused' or 'used for long-term reference'\n */\nde265_error decoder_context::process_reference_picture_set(slice_segment_header* hdr)\n{\n  std::vector<int> removeReferencesList;\n\n  const int currentID = img->get_ID();\n\n\n  if (isIRAP(nal_unit_type) && NoRaslOutputFlag) {\n\n    int currentPOC = img->PicOrderCntVal;\n\n    // reset DPB\n\n    /* The standard says: \"When the current picture is an IRAP picture with NoRaslOutputFlag\n       equal to 1, all reference pictures currently in the DPB (if any) are marked as\n       \"unused for reference\".\n\n       This seems to be wrong as it also throws out the first CRA picture in a stream like\n       RAP_A (decoding order: CRA,POC=64, RASL,POC=60). Removing only the pictures with\n       lower POCs seems to be compliant to the reference decoder.\n    */\n\n    for (int i=0;i<dpb.size();i++) {\n      de265_image* img = dpb.get_image(i);\n\n      if (img->PicState != UnusedForReference &&\n          img->PicOrderCntVal < currentPOC &&\n          img->removed_at_picture_id > img->get_ID()) {\n\n        removeReferencesList.push_back(img->get_ID());\n        img->removed_at_picture_id = img->get_ID();\n\n        //printf(\"will remove ID %d (a)\\n\",img->get_ID());\n      }\n    }\n  }\n\n\n  if (isIDR(nal_unit_type)) {\n\n    // clear all reference pictures\n\n    NumPocStCurrBefore = 0;\n    NumPocStCurrAfter = 0;\n    NumPocStFoll = 0;\n    NumPocLtCurr = 0;\n    NumPocLtFoll = 0;\n  }\n  else {\n    const ref_pic_set* rps = &hdr->CurrRps;\n\n    // (8-98)\n\n    int i,j,k;\n\n    // scan ref-pic-set for smaller POCs and fill into PocStCurrBefore / PocStFoll\n\n    for (i=0, j=0, k=0;\n         i<rps->NumNegativePics;\n         i++)\n      {\n        if (rps->UsedByCurrPicS0[i]) {\n          PocStCurrBefore[j++] = img->PicOrderCntVal + rps->DeltaPocS0[i];\n          //printf(\"PocStCurrBefore = %d\\n\",PocStCurrBefore[j-1]);\n        }\n        else {\n          PocStFoll[k++] = img->PicOrderCntVal + rps->DeltaPocS0[i];\n        }\n      }\n\n    NumPocStCurrBefore = j;\n\n\n    // scan ref-pic-set for larger POCs and fill into PocStCurrAfter / PocStFoll\n\n    for (i=0, j=0;\n         i<rps->NumPositivePics;\n         i++)\n      {\n        if (rps->UsedByCurrPicS1[i]) {\n          PocStCurrAfter[j++] = img->PicOrderCntVal + rps->DeltaPocS1[i];\n          //printf(\"PocStCurrAfter = %d\\n\",PocStCurrAfter[j-1]);\n        }\n        else {\n          PocStFoll[k++] = img->PicOrderCntVal + rps->DeltaPocS1[i];\n        }\n      }\n\n    NumPocStCurrAfter = j;\n    NumPocStFoll = k;\n\n\n    // find used / future long-term references\n\n    for (i=0, j=0, k=0;\n         //i<current_sps->num_long_term_ref_pics_sps + hdr->num_long_term_pics;\n         i<hdr->num_long_term_sps + hdr->num_long_term_pics;\n         i++)\n      {\n        int pocLt = PocLsbLt[i];\n\n        if (hdr->delta_poc_msb_present_flag[i]) {\n          int currentPictureMSB = img->PicOrderCntVal - hdr->slice_pic_order_cnt_lsb;\n          pocLt += currentPictureMSB\n            - DeltaPocMsbCycleLt[i] * current_sps->MaxPicOrderCntLsb;\n        }\n\n        if (UsedByCurrPicLt[i]) {\n          PocLtCurr[j] = pocLt;\n          CurrDeltaPocMsbPresentFlag[j] = hdr->delta_poc_msb_present_flag[i];\n          j++;\n        }\n        else {\n          PocLtFoll[k] = pocLt;\n          FollDeltaPocMsbPresentFlag[k] = hdr->delta_poc_msb_present_flag[i];\n          k++;\n        }\n      }\n\n    NumPocLtCurr = j;\n    NumPocLtFoll = k;\n  }\n\n\n  // (old 8-99) / (new 8-106)\n  // 1.\n\n  std::vector<char> picInAnyList(dpb.size(), false);\n\n\n  dpb.log_dpb_content();\n\n  for (int i=0;i<NumPocLtCurr;i++) {\n    int k;\n    if (!CurrDeltaPocMsbPresentFlag[i]) {\n      k = dpb.DPB_index_of_picture_with_LSB(PocLtCurr[i], currentID, true);\n    }\n    else {\n      k = dpb.DPB_index_of_picture_with_POC(PocLtCurr[i], currentID, true);\n    }\n\n    RefPicSetLtCurr[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      // TODO, CHECK: is it ok that we generate a picture with POC = LSB (PocLtCurr)\n      // We do not know the correct MSB\n      int concealedPicture = generate_unavailable_reference_picture(current_sps.get(),\n                                                                    PocLtCurr[i], true);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n\n      RefPicSetLtCurr[i] = k = concealedPicture;\n      picInAnyList[concealedPicture]=true;\n    }\n\n    if (dpb.get_image(k)->integrity != INTEGRITY_CORRECT) {\n      img->integrity = INTEGRITY_DERIVED_FROM_FAULTY_REFERENCE;\n    }\n  }\n\n\n  for (int i=0;i<NumPocLtFoll;i++) {\n    int k;\n    if (!FollDeltaPocMsbPresentFlag[i]) {\n      k = dpb.DPB_index_of_picture_with_LSB(PocLtFoll[i], currentID, true);\n    }\n    else {\n      k = dpb.DPB_index_of_picture_with_POC(PocLtFoll[i], currentID, true);\n    }\n\n    RefPicSetLtFoll[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      int concealedPicture = k = generate_unavailable_reference_picture(current_sps.get(),\n                                                                        PocLtFoll[i], true);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n\n      RefPicSetLtFoll[i] = concealedPicture;\n      picInAnyList[concealedPicture]=true;\n    }\n  }\n\n\n  // 2. Mark all pictures in RefPicSetLtCurr / RefPicSetLtFoll as UsedForLongTermReference\n\n  for (int i=0;i<NumPocLtCurr;i++) {\n    dpb.get_image(RefPicSetLtCurr[i])->PicState = UsedForLongTermReference;\n  }\n\n  for (int i=0;i<NumPocLtFoll;i++) {\n    dpb.get_image(RefPicSetLtFoll[i])->PicState = UsedForLongTermReference;\n  }\n\n\n  // 3.\n\n  for (int i=0;i<NumPocStCurrBefore;i++) {\n    int k = dpb.DPB_index_of_picture_with_POC(PocStCurrBefore[i], currentID);\n\n    //printf(\"st curr before, poc=%d -> idx=%d\\n\",PocStCurrBefore[i], k);\n\n    RefPicSetStCurrBefore[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      int concealedPicture = generate_unavailable_reference_picture(current_sps.get(),\n                                                                    PocStCurrBefore[i], false);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      RefPicSetStCurrBefore[i] = k = concealedPicture;\n\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n      picInAnyList[concealedPicture] = true;\n\n      //printf(\"  concealed: %d\\n\", concealedPicture);\n    }\n\n    if (dpb.get_image(k)->integrity != INTEGRITY_CORRECT) {\n      img->integrity = INTEGRITY_DERIVED_FROM_FAULTY_REFERENCE;\n    }\n  }\n\n  for (int i=0;i<NumPocStCurrAfter;i++) {\n    int k = dpb.DPB_index_of_picture_with_POC(PocStCurrAfter[i], currentID);\n\n    //printf(\"st curr after, poc=%d -> idx=%d\\n\",PocStCurrAfter[i], k);\n\n    RefPicSetStCurrAfter[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n    else {\n      int concealedPicture = generate_unavailable_reference_picture(current_sps.get(),\n                                                                    PocStCurrAfter[i], false);\n      if (concealedPicture<0) {\n        return (de265_error)(-concealedPicture);\n      }\n      RefPicSetStCurrAfter[i] = k = concealedPicture;\n\n\n      picInAnyList.resize(dpb.size(), false); // adjust size of array to hold new picture\n      picInAnyList[concealedPicture]=true;\n\n      //printf(\"  concealed: %d\\n\", concealedPicture);\n    }\n\n    if (dpb.get_image(k)->integrity != INTEGRITY_CORRECT) {\n      img->integrity = INTEGRITY_DERIVED_FROM_FAULTY_REFERENCE;\n    }\n  }\n\n  for (int i=0;i<NumPocStFoll;i++) {\n    int k = dpb.DPB_index_of_picture_with_POC(PocStFoll[i], currentID);\n    // if (k<0) { assert(false); } // IGNORE\n\n    RefPicSetStFoll[i] = k; // -1 == \"no reference picture\"\n    if (k>=0) picInAnyList[k]=true;\n  }\n\n  // 4. any picture that is not marked for reference is put into the \"UnusedForReference\" state\n\n  for (int i=0;i<dpb.size();i++)\n    if (i>=picInAnyList.size() || !picInAnyList[i])        // no reference\n      {\n        de265_image* dpbimg = dpb.get_image(i);\n        if (dpbimg != img &&  // not the current picture\n            dpbimg->removed_at_picture_id > img->get_ID()) // has not been removed before\n          {\n            if (dpbimg->PicState != UnusedForReference) {\n              removeReferencesList.push_back(dpbimg->get_ID());\n              //printf(\"will remove ID %d (b)\\n\",dpbimg->get_ID());\n\n              dpbimg->removed_at_picture_id = img->get_ID();\n            }\n          }\n      }\n\n  hdr->RemoveReferencesList = removeReferencesList;\n\n  //remove_images_from_dpb(hdr->RemoveReferencesList);\n\n  return DE265_OK;\n}\n\n\n// 8.3.4\n// Returns whether we can continue decoding (or whether there is a severe error).\n/* Called at beginning of each slice.\n\n   Constructs\n   - the RefPicList[2][], containing indices into the DPB, and\n   - the RefPicList_POC[2][], containing POCs.\n   - LongTermRefPic[2][] is also set to true if it is a long-term reference\n */\nbool decoder_context::construct_reference_picture_lists(slice_segment_header* hdr)\n{\n  int NumPocTotalCurr = hdr->NumPocTotalCurr;\n  int NumRpsCurrTempList0 = libde265_max(hdr->num_ref_idx_l0_active, NumPocTotalCurr);\n\n  // TODO: fold code for both lists together\n\n  int RefPicListTemp0[3*MAX_NUM_REF_PICS]; // TODO: what would be the correct maximum ?\n  int RefPicListTemp1[3*MAX_NUM_REF_PICS]; // TODO: what would be the correct maximum ?\n  char isLongTerm[2][3*MAX_NUM_REF_PICS];\n\n  memset(isLongTerm,0,2*3*MAX_NUM_REF_PICS);\n\n  /* --- Fill RefPicListTmp0 with reference pictures in this order:\n     1) short term, past POC\n     2) short term, future POC\n     3) long term\n  */\n\n  int rIdx=0;\n  while (rIdx < NumRpsCurrTempList0) {\n    for (int i=0;i<NumPocStCurrBefore && rIdx<NumRpsCurrTempList0; rIdx++,i++)\n      RefPicListTemp0[rIdx] = RefPicSetStCurrBefore[i];\n\n    for (int i=0;i<NumPocStCurrAfter && rIdx<NumRpsCurrTempList0; rIdx++,i++)\n      RefPicListTemp0[rIdx] = RefPicSetStCurrAfter[i];\n\n    for (int i=0;i<NumPocLtCurr && rIdx<NumRpsCurrTempList0; rIdx++,i++) {\n      RefPicListTemp0[rIdx] = RefPicSetLtCurr[i];\n      isLongTerm[0][rIdx] = true;\n    }\n\n    // This check is to prevent an endless loop when no images are added above.\n    if (rIdx==0) {\n      add_warning(DE265_WARNING_FAULTY_REFERENCE_PICTURE_LIST, false);\n      return false;\n    }\n  }\n\n  /*\n  if (hdr->num_ref_idx_l0_active > 16) {\n    add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);\n    return false;\n  }\n  */\n\n  assert(hdr->num_ref_idx_l0_active <= 16);\n  for (rIdx=0; rIdx<hdr->num_ref_idx_l0_active; rIdx++) {\n    int idx = hdr->ref_pic_list_modification_flag_l0 ? hdr->list_entry_l0[rIdx] : rIdx;\n\n    hdr->RefPicList[0][rIdx] = RefPicListTemp0[idx];\n    hdr->LongTermRefPic[0][rIdx] = isLongTerm[0][idx];\n\n    // remember POC of referenced image (needed in motion.c, derive_collocated_motion_vector)\n    de265_image* img_0_rIdx = dpb.get_image(hdr->RefPicList[0][rIdx]);\n    if (img_0_rIdx==NULL) {\n      return false;\n    }\n    hdr->RefPicList_POC[0][rIdx] = img_0_rIdx->PicOrderCntVal;\n    hdr->RefPicList_PicState[0][rIdx] = img_0_rIdx->PicState;\n  }\n\n\n  /* --- Fill RefPicListTmp1 with reference pictures in this order:\n     1) short term, future POC\n     2) short term, past POC\n     3) long term\n  */\n\n  if (hdr->slice_type == SLICE_TYPE_B) {\n    int NumRpsCurrTempList1 = libde265_max(hdr->num_ref_idx_l1_active, NumPocTotalCurr);\n\n    int rIdx=0;\n    while (rIdx < NumRpsCurrTempList1) {\n      for (int i=0;i<NumPocStCurrAfter && rIdx<NumRpsCurrTempList1; rIdx++,i++) {\n        RefPicListTemp1[rIdx] = RefPicSetStCurrAfter[i];\n      }\n\n      for (int i=0;i<NumPocStCurrBefore && rIdx<NumRpsCurrTempList1; rIdx++,i++) {\n        RefPicListTemp1[rIdx] = RefPicSetStCurrBefore[i];\n      }\n\n      for (int i=0;i<NumPocLtCurr && rIdx<NumRpsCurrTempList1; rIdx++,i++) {\n        RefPicListTemp1[rIdx] = RefPicSetLtCurr[i];\n        isLongTerm[1][rIdx] = true;\n      }\n\n      // This check is to prevent an endless loop when no images are added above.\n      if (rIdx==0) {\n        add_warning(DE265_WARNING_FAULTY_REFERENCE_PICTURE_LIST, false);\n        return false;\n      }\n    }\n\n    if (hdr->num_ref_idx_l0_active > 16) {\n    add_warning(DE265_WARNING_NONEXISTING_REFERENCE_PICTURE_ACCESSED, false);\n    return false;\n  }\n\n    assert(hdr->num_ref_idx_l1_active <= 16);\n    for (rIdx=0; rIdx<hdr->num_ref_idx_l1_active; rIdx++) {\n      int idx = hdr->ref_pic_list_modification_flag_l1 ? hdr->list_entry_l1[rIdx] : rIdx;\n\n      hdr->RefPicList[1][rIdx] = RefPicListTemp1[idx];\n      hdr->LongTermRefPic[1][rIdx] = isLongTerm[1][idx];\n\n      // remember POC of referenced imaged (needed in motion.c, derive_collocated_motion_vector)\n      de265_image* img_1_rIdx = dpb.get_image(hdr->RefPicList[1][rIdx]);\n      if (img_1_rIdx == NULL) { return false; }\n      hdr->RefPicList_POC[1][rIdx] = img_1_rIdx->PicOrderCntVal;\n      hdr->RefPicList_PicState[1][rIdx] = img_1_rIdx->PicState;\n    }\n  }\n\n\n  // show reference picture lists\n\n  loginfo(LogHeaders,\"RefPicList[0] =\");\n  for (rIdx=0; rIdx<hdr->num_ref_idx_l0_active; rIdx++) {\n    loginfo(LogHeaders,\"* [%d]=%d (LT=%d)\",\n            hdr->RefPicList[0][rIdx],\n            hdr->RefPicList_POC[0][rIdx],\n            hdr->LongTermRefPic[0][rIdx]\n            );\n  }\n  loginfo(LogHeaders,\"*\\n\");\n\n  if (hdr->slice_type == SLICE_TYPE_B) {\n    loginfo(LogHeaders,\"RefPicList[1] =\");\n    for (rIdx=0; rIdx<hdr->num_ref_idx_l1_active; rIdx++) {\n      loginfo(LogHeaders,\"* [%d]=%d (LT=%d)\",\n              hdr->RefPicList[1][rIdx],\n              hdr->RefPicList_POC[1][rIdx],\n              hdr->LongTermRefPic[1][rIdx]\n              );\n    }\n    loginfo(LogHeaders,\"*\\n\");\n  }\n\n  return true;\n}\n\n\n\nvoid decoder_context::run_postprocessing_filters_sequential(de265_image* img)\n{\n#if SAVE_INTERMEDIATE_IMAGES\n    char buf[1000];\n    sprintf(buf,\"pre-lf-%05d.yuv\", img->PicOrderCntVal);\n    write_picture_to_file(img, buf);\n#endif\n\n    if (!img->decctx->param_disable_deblocking) {\n      apply_deblocking_filter(img);\n    }\n\n#if SAVE_INTERMEDIATE_IMAGES\n    sprintf(buf,\"pre-sao-%05d.yuv\", img->PicOrderCntVal);\n    write_picture_to_file(img, buf);\n#endif\n\n    if (!img->decctx->param_disable_sao) {\n      apply_sample_adaptive_offset_sequential(img);\n    }\n\n#if SAVE_INTERMEDIATE_IMAGES\n    sprintf(buf,\"sao-%05d.yuv\", img->PicOrderCntVal);\n    write_picture_to_file(img, buf);\n#endif\n}\n\n\nvoid decoder_context::run_postprocessing_filters_parallel(image_unit* imgunit)\n{\n  de265_image* img = imgunit->img;\n\n  int saoWaitsForProgress = CTB_PROGRESS_PREFILTER;\n  bool waitForCompletion = false;\n\n  if (!img->decctx->param_disable_deblocking) {\n    add_deblocking_tasks(imgunit);\n    saoWaitsForProgress = CTB_PROGRESS_DEBLK_H;\n  }\n\n  if (!img->decctx->param_disable_sao) {\n    waitForCompletion |= add_sao_tasks(imgunit, saoWaitsForProgress);\n    //apply_sample_adaptive_offset(img);\n  }\n\n  img->wait_for_completion();\n}\n\n/*\nvoid decoder_context::push_current_picture_to_output_queue()\n{\n  push_picture_to_output_queue(img);\n}\n*/\n\nde265_error decoder_context::push_picture_to_output_queue(image_unit* imgunit)\n{\n  de265_image* outimg = imgunit->img;\n\n  if (outimg==NULL) { return DE265_OK; }\n\n\n  // push image into output queue\n\n  if (outimg->PicOutputFlag) {\n    loginfo(LogDPB,\"new picture has output-flag=true\\n\");\n\n    if (outimg->integrity != INTEGRITY_CORRECT &&\n        param_suppress_faulty_pictures) {\n    }\n    else {\n      dpb.insert_image_into_reorder_buffer(outimg);\n    }\n\n    loginfo(LogDPB,\"push image %d into reordering queue\\n\", outimg->PicOrderCntVal);\n  }\n\n  // check for full reorder buffers\n\n  int maxNumPicsInReorderBuffer = 0;\n\n  // TODO: I'd like to have the has_vps() check somewhere else (not decode the picture at all)\n  if (outimg->has_vps()) {\n    int sublayer = outimg->get_vps().vps_max_sub_layers -1;\n    maxNumPicsInReorderBuffer = outimg->get_vps().layer[sublayer].vps_max_num_reorder_pics;\n  }\n\n  if (dpb.num_pictures_in_reorder_buffer() > maxNumPicsInReorderBuffer) {\n    dpb.output_next_picture_in_reorder_buffer();\n  }\n\n  dpb.log_dpb_queues();\n\n  return DE265_OK;\n}\n\n\n// returns whether we can continue decoding the stream or whether we should give up\nbool decoder_context::process_slice_segment_header(slice_segment_header* hdr,\n                                                   de265_error* err, de265_PTS pts,\n                                                   nal_header* nal_hdr,\n                                                   void* user_data)\n{\n  *err = DE265_OK;\n\n  flush_reorder_buffer_at_this_frame = false;\n\n\n  // get PPS and SPS for this slice\n\n  int pps_id = hdr->slice_pic_parameter_set_id;\n  if (pps[pps_id]==nullptr || pps[pps_id]->pps_read==false) {\n    logerror(LogHeaders, \"PPS %d has not been read\\n\", pps_id);\n    img->decctx->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return false;\n  }\n\n  current_pps = pps[pps_id];\n  current_sps = sps[ (int)current_pps->seq_parameter_set_id ];\n  current_vps = vps[ (int)current_sps->video_parameter_set_id ];\n\n  calc_tid_and_framerate_ratio();\n\n\n  // --- prepare decoding of new picture ---\n\n  if (hdr->first_slice_segment_in_pic_flag) {\n\n    // previous picture has been completely decoded\n\n    //ctx->push_current_picture_to_output_queue();\n\n    current_image_poc_lsb = hdr->slice_pic_order_cnt_lsb;\n\n\n    seq_parameter_set* sps = current_sps.get();\n\n\n    // --- find and allocate image buffer for decoding ---\n\n    int image_buffer_idx;\n    bool isOutputImage = (!sps->sample_adaptive_offset_enabled_flag || param_disable_sao);\n    image_buffer_idx = dpb.new_image(current_sps, this, pts, user_data, isOutputImage);\n    if (image_buffer_idx < 0) {\n      *err = (de265_error)(-image_buffer_idx);\n      return false;\n    }\n\n    /*de265_image* */ img = dpb.get_image(image_buffer_idx);\n    img->nal_hdr = *nal_hdr;\n\n    // Note: sps is already set in new_image() -> ??? still the case with shared_ptr ?\n\n    img->set_headers(current_vps, current_sps, current_pps);\n\n    img->decctx = this;\n\n    img->clear_metadata();\n\n\n    if (isIRAP(nal_unit_type)) {\n      if (isIDR(nal_unit_type) ||\n          isBLA(nal_unit_type) ||\n          first_decoded_picture ||\n          FirstAfterEndOfSequenceNAL)\n        {\n          NoRaslOutputFlag = true;\n          FirstAfterEndOfSequenceNAL = false;\n        }\n      else if (0) // TODO: set HandleCraAsBlaFlag by external means\n        {\n        }\n      else\n        {\n          NoRaslOutputFlag   = false;\n          HandleCraAsBlaFlag = false;\n        }\n    }\n\n\n    if (isRASL(nal_unit_type) &&\n        NoRaslOutputFlag)\n      {\n        img->PicOutputFlag = false;\n      }\n    else\n      {\n        img->PicOutputFlag = !!hdr->pic_output_flag;\n      }\n\n    process_picture_order_count(hdr);\n\n    if (hdr->first_slice_segment_in_pic_flag) {\n      // mark picture so that it is not overwritten by unavailable reference frames\n      img->PicState = UsedForShortTermReference;\n\n      *err = process_reference_picture_set(hdr);\n      if (*err != DE265_OK) {\n        return false;\n      }\n    }\n\n    img->PicState = UsedForShortTermReference;\n\n    log_set_current_POC(img->PicOrderCntVal);\n\n\n    // next image is not the first anymore\n\n    first_decoded_picture = false;\n  }\n  else {\n    // claims to be not the first slice, but there is no active image available\n\n    if (img == NULL) {\n      return false;\n    }\n  }\n\n  if (hdr->slice_type == SLICE_TYPE_B ||\n      hdr->slice_type == SLICE_TYPE_P)\n    {\n      bool success = construct_reference_picture_lists(hdr);\n      if (!success) {\n        return false;\n      }\n    }\n\n  //printf(\"process slice segment header\\n\");\n\n  loginfo(LogHeaders,\"end of process-slice-header\\n\");\n  dpb.log_dpb_content();\n\n\n  if (hdr->dependent_slice_segment_flag==0) {\n    hdr->SliceAddrRS = hdr->slice_segment_address;\n  } else {\n    hdr->SliceAddrRS = previous_slice_header->SliceAddrRS;\n  }\n\n  previous_slice_header = hdr;\n\n\n  loginfo(LogHeaders,\"SliceAddrRS = %d\\n\",hdr->SliceAddrRS);\n\n  return true;\n}\n\n\nvoid decoder_context::remove_images_from_dpb(const std::vector<int>& removeImageList)\n{\n  for (int i=0;i<removeImageList.size();i++) {\n    int idx = dpb.DPB_index_of_picture_with_ID( removeImageList[i] );\n    if (idx>=0) {\n      //printf(\"remove ID %d\\n\", removeImageList[i]);\n      de265_image* dpbimg = dpb.get_image( idx );\n      dpbimg->PicState = UnusedForReference;\n    }\n  }\n}\n\n\n\n/*\n  .     0     1     2       <- goal_HighestTid\n  +-----+-----+-----+\n  | -0->| -1->| -2->|\n  +-----+-----+-----+\n  0     33    66    100     <- framerate_ratio\n */\n\nint  decoder_context::get_highest_TID() const\n{\n  if (current_sps) { return current_sps->sps_max_sub_layers-1; }\n  if (current_vps) { return current_vps->vps_max_sub_layers-1; }\n\n  return 6;\n}\n\nvoid decoder_context::set_limit_TID(int max_tid)\n{\n  limit_HighestTid = max_tid;\n  calc_tid_and_framerate_ratio();\n}\n\nint decoder_context::change_framerate(int more)\n{\n  if (current_sps == NULL) { return framerate_ratio; }\n\n  int highestTid = get_highest_TID();\n\n  assert(more>=-1 && more<=1);\n\n  goal_HighestTid += more;\n  goal_HighestTid = std::max(goal_HighestTid, 0);\n  goal_HighestTid = std::min(goal_HighestTid, highestTid);\n\n  framerate_ratio = framedrop_tid_index[goal_HighestTid];\n\n  calc_tid_and_framerate_ratio();\n\n  return framerate_ratio;\n}\n\nvoid decoder_context::set_framerate_ratio(int percent)\n{\n  framerate_ratio = percent;\n  calc_tid_and_framerate_ratio();\n}\n\nvoid decoder_context::compute_framedrop_table()\n{\n  int highestTID = get_highest_TID();\n\n  for (int tid=highestTID ; tid>=0 ; tid--) {\n    int lower  = 100 *  tid   /(highestTID+1);\n    int higher = 100 * (tid+1)/(highestTID+1);\n\n    for (int l=lower; l<=higher; l++) {\n      int ratio = 100 * (l-lower) / (higher-lower);\n\n      // if we would exceed our TID limit, decode the highest TID at full frame-rate\n      if (tid > limit_HighestTid) {\n        tid   = limit_HighestTid;\n        ratio = 100;\n      }\n\n      framedrop_tab[l].tid   = tid;\n      framedrop_tab[l].ratio = ratio;\n    }\n\n    framedrop_tid_index[tid] = higher;\n  }\n\n#if 0\n  for (int i=0;i<=100;i++) {\n    printf(\"%d%%: %d/%d\",i, framedrop_tab[i].tid, framedrop_tab[i].ratio);\n    for (int k=0;k<=highestTID;k++) {\n      if (framedrop_tid_index[k] == i) printf(\" ** TID=%d **\",k);\n    }\n    printf(\"\\n\");\n  }\n#endif\n}\n\nvoid decoder_context::calc_tid_and_framerate_ratio()\n{\n  int highestTID = get_highest_TID();\n\n\n  // if number of temporal layers changed, we have to recompute the framedrop table\n\n  if (framedrop_tab[100].tid != highestTID) {\n    compute_framedrop_table();\n  }\n\n  goal_HighestTid       = framedrop_tab[framerate_ratio].tid;\n  layer_framerate_ratio = framedrop_tab[framerate_ratio].ratio;\n\n  // TODO: for now, we switch immediately\n  current_HighestTid = goal_HighestTid;\n}\n\n\nvoid error_queue::add_warning(de265_error warning, bool once)\n{\n  // check if warning was already shown\n  bool add=true;\n  if (once) {\n    for (int i=0;i<nWarningsShown;i++) {\n      if (warnings_shown[i] == warning) {\n        add=false;\n        break;\n      }\n    }\n  }\n\n  if (!add) {\n    return;\n  }\n\n\n  // if this is a one-time warning, remember that it was shown\n\n  if (once) {\n    if (nWarningsShown < MAX_WARNINGS) {\n      warnings_shown[nWarningsShown++] = warning;\n    }\n  }\n\n\n  // add warning to output queue\n\n  if (nWarnings == MAX_WARNINGS) {\n    warnings[MAX_WARNINGS-1] = DE265_WARNING_WARNING_BUFFER_FULL;\n    return;\n  }\n\n  warnings[nWarnings++] = warning;\n}\n\nerror_queue::error_queue()\n{\n  nWarnings = 0;\n  nWarningsShown = 0;\n}\n\nde265_error error_queue::get_warning()\n{\n  if (nWarnings==0) {\n    return DE265_OK;\n  }\n\n  de265_error warn = warnings[0];\n  nWarnings--;\n  memmove(warnings, &warnings[1], nWarnings*sizeof(de265_error));\n\n  return warn;\n}\n"], "filenames": ["libde265/decctx.cc"], "buggy_code_start_loc": [584], "buggy_code_end_loc": [595], "fixing_code_start_loc": [585], "fixing_code_end_loc": [596], "type": "CWE-120", "message": "Libde265 v1.0.12 was discovered to contain multiple buffer overflows via the num_tile_columns and num_tile_row parameters in the function pic_parameter_set::dump.", "other": {"cve": {"id": "CVE-2023-43887", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-22T18:15:08.747", "lastModified": "2023-11-30T19:15:13.260", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Libde265 v1.0.12 was discovered to contain multiple buffer overflows via the num_tile_columns and num_tile_row parameters in the function pic_parameter_set::dump."}, {"lang": "es", "value": "Se descubri\u00f3 que Libde265 v1.0.12 conten\u00eda m\u00faltiples desbordamientos del b\u00fafer a trav\u00e9s de los par\u00e1metros num_tile_columns y num_tile_row en la funci\u00f3n pic_parameter_set::dump."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:struktur:libde265:1.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "A736D1CB-9F33-4561-B10C-4074DF6C02F9"}]}]}], "references": [{"url": "https://github.com/strukturag/libde265/commit/63b596c915977f038eafd7647d1db25488a8c133", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/strukturag/libde265/issues/418", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/11/msg00032.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/strukturag/libde265/commit/63b596c915977f038eafd7647d1db25488a8c133"}}