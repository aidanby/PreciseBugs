{"buggy_code": ["/* exif-mnote-data-canon.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n * Copyright (c) 2003 Matthieu Castet <mat-c@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n#include \"exif-mnote-data-canon.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n#include <libexif/exif-data.h>\n\nstatic void\nexif_mnote_data_canon_clear (ExifMnoteDataCanon *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_canon_clear ((ExifMnoteDataCanon *) n);\n}\n\nstatic void\nexif_mnote_data_canon_get_tags (ExifMnoteDataCanon *dc, unsigned int n,\n\t\tunsigned int *m, unsigned int *s)\n{\n\tunsigned int from = 0, to;\n\n\tif (!dc || !m) return;\n\tfor (*m = 0; *m < dc->count; (*m)++) {\n\t\tto = from + mnote_canon_entry_count_values (&dc->entries[*m]);\n\t\tif (to > n) {\n\t\t\tif (s) *s = n - from;\n\t\t\tbreak;\n\t\t}\n\t\tfrom = to;\n\t}\n}\n\nstatic char *\nexif_mnote_data_canon_get_value (ExifMnoteData *note, unsigned int n, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, n, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_entry_get_value (&dc->entries[m], s, val, maxlen);\n}\n\nstatic void\nexif_mnote_data_canon_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataCanon *) n)->offset = o;\n}\n\nstatic void\nexif_mnote_data_canon_save (ExifMnoteData *ne, \n\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tsize_t i, o, s, doff;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number\n\t * of entries.\n\t */\n\t*buf_size = 2 + n->count * 12 + 4;\n\t*buf = exif_mem_alloc (ne->mem, sizeof (char) * *buf_size);\n\tif (!*buf) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", *buf_size);\n\t\treturn;\n\t}\n\n\t/* Save the number of entries */\n\texif_set_short (*buf, n->order, (ExifShort) n->count);\n\t\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = 2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order, (ExifShort) n->entries[i].tag);\n\t\texif_set_short (*buf + o + 2, n->order, (ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tts = *buf_size + s;\n\n\t\t\t/* Ensure even offsets. Set padding bytes to 0. */\n\t\t\tif (s & 1) ts += 1;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\tdoff = *buf_size - s;\n\t\t\tif (s & 1) { doff--; *(*buf + *buf_size - 1) = '\\0'; }\n\t\t\texif_set_long (*buf + o, n->order, n->offset + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/*\n\t\t * Write the data. Fill unneeded bytes with 0. Do not\n\t\t * crash if data is NULL.\n\t\t */\n\t\tif (!n->entries[i].data) memset (*buf + doff, 0, s);\n\t\telse memcpy (*buf + doff, n->entries[i].data, s);\n\t\tif (s < 4) memset (*buf + doff + s, 0, (4 - s));\n\t}\n}\n\n/* XXX\n * FIXME: exif_mnote_data_canon_load() may fail and there is no\n *        semantics to express that.\n *        See bug #1054323 for details, especially the comment by liblit\n *        after it has supposedly been fixed:\n *\n *        https://sourceforge.net/tracker/?func=detail&aid=1054323&group_id=12272&atid=112272\n *        Unfortunately, the \"return\" statements aren't commented at\n *        all, so it isn't trivial to find out what is a normal\n *        return, and what is a reaction to an error condition.\n */\n\nstatic void\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif ((datao + 2 < datao) || (datao + 2 < 2) || (datao + 2 > buf_size)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t        }\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\t\t\tif ((dataofs + s < s) || (dataofs + s < dataofs) || (dataofs + s > buf_size)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_count (ExifMnoteData *n)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) n;\n\tunsigned int i, c;\n\n\tfor (i = c = 0; dc && (i < dc->count); i++)\n\t\tc += mnote_canon_entry_count_values (&dc->entries[i]);\n\treturn c;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_get_id (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) d;\n\tunsigned int m;\n\n\tif (!dc) return 0;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return 0;\n\treturn dc->entries[m].tag;\n}\n\nstatic const char *\nexif_mnote_data_canon_get_name (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_name_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_title (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_title_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_description (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_description (dc->entries[m].tag);\n}\n\nint\nexif_mnote_data_canon_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tchar value[8];\n\n\t(void) e;  /* unused */\n\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\tif (!em) \n\t\treturn 0;\n\treturn !strcmp (exif_entry_get_value (em, value, sizeof (value)), \"Canon\");\n}\n\nExifMnoteData *\nexif_mnote_data_canon_new (ExifMem *mem, ExifDataOption o)\n{\n\tExifMnoteData *d;\n\tExifMnoteDataCanon *dc;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataCanon));\n\tif (!d)\n\t\treturn NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_canon_free;\n\td->methods.set_byte_order  = exif_mnote_data_canon_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_canon_set_offset;\n\td->methods.load            = exif_mnote_data_canon_load;\n\td->methods.save            = exif_mnote_data_canon_save;\n\td->methods.count           = exif_mnote_data_canon_count;\n\td->methods.get_id          = exif_mnote_data_canon_get_id;\n\td->methods.get_name        = exif_mnote_data_canon_get_name;\n\td->methods.get_title       = exif_mnote_data_canon_get_title;\n\td->methods.get_description = exif_mnote_data_canon_get_description;\n\td->methods.get_value       = exif_mnote_data_canon_get_value;\n\n\tdc = (ExifMnoteDataCanon*)d;\n\tdc->options = o;\n\treturn d;\n}\n", "/* exif-mnote-data-fuji.c\n *\n * Copyright (c) 2002 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, \n * but WITHOUT ANY WARRANTY; without even the implied warranty of \n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details. \n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#include <config.h>\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n\n#include \"exif-mnote-data-fuji.h\"\n\nstruct _MNoteFujiDataPrivate {\n\tExifByteOrder order;\n};\n\nstatic void\nexif_mnote_data_fuji_clear (ExifMnoteDataFuji *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_fuji_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_fuji_clear ((ExifMnoteDataFuji *) n);\n}\n\nstatic char *\nexif_mnote_data_fuji_get_value (ExifMnoteData *d, unsigned int i, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\n\tif (!d || !val) return NULL;\n\tif (i > n->count -1) return NULL;\n/*\n\texif_log (d->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataFuji\",\n\t\t  \"Querying value for tag '%s'...\",\n\t\t  mnote_fuji_tag_get_name (n->entries[i].tag));\n*/\n\treturn mnote_fuji_entry_get_value (&n->entries[i], val, maxlen);\n}\n\nstatic void\nexif_mnote_data_fuji_save (ExifMnoteData *ne, unsigned char **buf,\n\t\t\t   unsigned int *buf_size)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) ne;\n\tsize_t i, o, s, doff;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number\n\t * of entries.\n\t */\n\t*buf_size = 8 + 4 + 2 + n->count * 12 + 4;\n\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\tif (!*buf) {\n\t\t*buf_size = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Header: \"FUJIFILM\" and 4 bytes offset to the first entry.\n\t * As the first entry will start right thereafter, the offset is 12.\n\t */\n\tmemcpy (*buf, \"FUJIFILM\", 8);\n\texif_set_long (*buf + 8, n->order, 12);\n\n\t/* Save the number of entries */\n\texif_set_short (*buf + 8 + 4, n->order, (ExifShort) n->count);\n\t\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = 8 + 4 + 2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order, (ExifShort) n->entries[i].tag);\n\t\texif_set_short (*buf + o + 2, n->order, (ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order, n->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tts = *buf_size + s;\n\n\t\t\t/* Ensure even offsets. Set padding bytes to 0. */\n\t\t\tif (s & 1) ts += 1;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf, ts);\n\t\t\tif (!t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\tdoff = *buf_size - s;\n\t\t\tif (s & 1) { doff--; *(*buf + *buf_size - 1) = '\\0'; }\n\t\t\texif_set_long (*buf + o, n->order, doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/*\n\t\t * Write the data. Fill unneeded bytes with 0. Do not\n\t\t * crash if data is NULL.\n\t\t */\n\t\tif (!n->entries[i].data) memset (*buf + doff, 0, s);\n\t\telse memcpy (*buf + doff, n->entries[i].data, s);\n\t}\n}\n\nstatic void\nexif_mnote_data_fuji_load (ExifMnoteData *en,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji*) en;\n\tExifLong c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif ((datao + 12 < datao) || (datao + 12 < 12) || (datao + 12 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\tn->order = EXIF_BYTE_ORDER_INTEL;\n\tdatao += exif_get_long (buf + datao + 8, EXIF_BYTE_ORDER_INTEL);\n\tif ((datao + 2 < datao) || (datao + 2 < 2) ||\n\t    (datao + 2 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, EXIF_BYTE_ORDER_INTEL);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_fuji_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteFujiEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataFuji\", sizeof (MnoteFujiEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataFuji\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t  mnote_fuji_tag_get_name (n->entries[tcount].tag));\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4)\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + 6 + n->offset;\n\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) ||\n\t\t\t\t(dataofs + s >= buf_size)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\t\t  \"ExifMnoteDataFuji\", \"Tag data past end of \"\n\t\t\t\t\t  \"buffer (%u >= %u)\", (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataFuji\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_fuji_count (ExifMnoteData *n)\n{\n\treturn n ? ((ExifMnoteDataFuji *) n)->count : 0;\n}\n\nstatic unsigned int\nexif_mnote_data_fuji_get_id (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataFuji *note = (ExifMnoteDataFuji *) d;\n\n\tif (!note) return 0;\n\tif (note->count <= n) return 0;\n\treturn note->entries[n].tag;\n}\n\nstatic const char *\nexif_mnote_data_fuji_get_name (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n\treturn mnote_fuji_tag_get_name (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_fuji_get_title (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_fuji_tag_get_title (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_fuji_get_description (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_fuji_tag_get_description (n->entries[i].tag);\n}\n\nstatic void\nexif_mnote_data_fuji_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_fuji_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataFuji *) n)->offset = o;\n}\n\nint\nexif_mnote_data_fuji_identify (const ExifData *ed, const ExifEntry *e)\n{\n\t(void) ed;  /* unused */\n\treturn ((e->size >= 12) && !memcmp (e->data, \"FUJIFILM\", 8));\n}\n\nExifMnoteData *\nexif_mnote_data_fuji_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataFuji));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_fuji_free;\n\td->methods.set_byte_order  = exif_mnote_data_fuji_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_fuji_set_offset;\n\td->methods.load            = exif_mnote_data_fuji_load;\n\td->methods.save            = exif_mnote_data_fuji_save;\n\td->methods.count           = exif_mnote_data_fuji_count;\n\td->methods.get_id          = exif_mnote_data_fuji_get_id;\n\td->methods.get_name        = exif_mnote_data_fuji_get_name;\n\td->methods.get_title       = exif_mnote_data_fuji_get_title;\n\td->methods.get_description = exif_mnote_data_fuji_get_description;\n\td->methods.get_value       = exif_mnote_data_fuji_get_value;\n\n\treturn d;\n}\n", "/* exif-mnote-data-olympus.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n#include \"exif-mnote-data-olympus.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include <libexif/exif-utils.h>\n#include <libexif/exif-data.h>\n\n/* Uncomment this to fix a problem with Sanyo MakerNotes. It's probably best\n * not to in most cases because it seems to only affect the thumbnail tag\n * which is duplicated in IFD 1, and fixing the offset could actually cause\n * problems with other software that expects the broken form.\n */\n/*#define EXIF_OVERCOME_SANYO_OFFSET_BUG */\n\nstatic enum OlympusVersion\nexif_mnote_data_olympus_identify_variant (const unsigned char *buf,\n\t\tunsigned int buf_size);\n\n\nstatic void\nexif_mnote_data_olympus_clear (ExifMnoteDataOlympus *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_olympus_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_olympus_clear ((ExifMnoteDataOlympus *) n);\n}\n\nstatic char *\nexif_mnote_data_olympus_get_value (ExifMnoteData *d, unsigned int i, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\n\tif (!d || !val) return NULL;\n\tif (i > n->count -1) return NULL;\n/*\n\texif_log (d->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t  \"Querying value for tag '%s'...\",\n\t\t  mnote_olympus_tag_get_name (n->entries[i].tag));\n*/\n\treturn mnote_olympus_entry_get_value (&n->entries[i], val, maxlen);\n}\n\n\n\n\n/** \n * @brief save the MnoteData from ne to buf\n * \n * @param ne extract the data from this structure \n * @param *buf write the mnoteData to this buffer (buffer will be allocated)\n * @param buf_size the size of the buffer\n */\nstatic void\nexif_mnote_data_olympus_save (ExifMnoteData *ne,\n\t\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) ne;\n\tsize_t i, o, s, doff, base = 0, o2 = 6 + 2;\n\tsize_t datao = 0;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number of entries.\n\t */\n\t*buf_size = 6 + 2 + 2 + n->count * 12;\n\tswitch (n->version) {\n\tcase olympusV1:\n\tcase sanyoV1:\n\tcase epsonV1:\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the header and the number of entries. */\n\t\tstrcpy ((char *)*buf, n->version==sanyoV1?\"SANYO\":\n\t\t\t\t\t(n->version==epsonV1?\"EPSON\":\"OLYMP\"));\n\t\texif_set_short (*buf + 6, n->order, (ExifShort) 1);\n\t\tdatao = n->offset;\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t*buf_size += 8-6 + 4;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the header and the number of entries. */\n\t\tstrcpy ((char *)*buf, \"OLYMPUS\");\n\t\texif_set_short (*buf + 8, n->order, (ExifShort) (\n\t\t\t(n->order == EXIF_BYTE_ORDER_INTEL) ?\n\t\t\t('I' << 8) | 'I' :\n\t\t\t('M' << 8) | 'M'));\n\t\texif_set_short (*buf + 10, n->order, (ExifShort) 3);\n\t\to2 += 4;\n\t\tbreak;\n\n\tcase nikonV1: \n\t\tbase = MNOTE_NIKON1_TAG_BASE;\n\n\t\t/* v1 has offsets based to main IFD, not makernote IFD */\n\t\tdatao += n->offset + 10;\n\t\t/* subtract the size here, so the increment in the next case will not harm us */\n\t\t*buf_size -= 8 + 2;\n\t/* Fall through to nikonV2 handler */\n\tcase nikonV2: \n\t/* Write out V0 files in V2 format */\n\tcase nikonV0: \n\t\t*buf_size += 8 + 2;\n\t\t*buf_size += 4; /* Next IFD pointer */\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the header and the number of entries. */\n\t\tstrcpy ((char *)*buf, \"Nikon\");\n\t\t(*buf)[6] = n->version;\n\n\t\tif (n->version != nikonV1) {\n\t\t\texif_set_short (*buf + 10, n->order, (ExifShort) (\n\t\t\t\t(n->order == EXIF_BYTE_ORDER_INTEL) ?\n\t\t\t\t('I' << 8) | 'I' :\n\t\t\t\t('M' << 8) | 'M'));\n\t\t\texif_set_short (*buf + 12, n->order, (ExifShort) 0x2A);\n\t\t\texif_set_long (*buf + 14, n->order, (ExifShort) 8);\n\t\t\to2 += 2 + 8;\n\t\t}\n\t\tdatao -= 10;\n\t\t/* Reset next IFD pointer */\n\t\texif_set_long (*buf + o2 + 2 + n->count * 12, n->order, 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\texif_set_short (*buf + o2, n->order, (ExifShort) n->count);\n\to2 += 2;\n\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = o2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order,\n\t\t\t\t(ExifShort) (n->entries[i].tag - base));\n\t\texif_set_short (*buf + o + 2, n->order,\n\t\t\t\t(ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tdoff = *buf_size;\n\t\t\tts = *buf_size + s;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\texif_set_long (*buf + o, n->order, datao + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/* Write the data. */\n\t\tif (n->entries[i].data) {\n\t\t\tmemcpy (*buf + doff, n->entries[i].data, s);\n\t\t} else {\n\t\t\t/* Most certainly damaged input file */\n\t\t\tmemset (*buf + doff, 0, s);\n\t\t}\n\t}\n}\n\nstatic void\nexif_mnote_data_olympus_load (ExifMnoteData *en,\n\t\t\t      const unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) en;\n\tExifShort c;\n\tsize_t i, tcount, o, o2, datao = 6, base = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; /* Start of interesting data */\n\tif ((o2 + 10 < o2) || (o2 + 10 < 10) || (o2 + 10 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Olympus headers start with \"OLYMP\" and need to have at least\n\t * a size of 22 bytes (6 for 'OLYMP', 2 other bytes, 2 for the\n\t * number of entries, and 12 for one entry.\n\t *\n\t * Sanyo format is identical and uses identical tags except that\n\t * header starts with \"SANYO\".\n\t *\n\t * Epson format is identical and uses identical tags except that\n\t * header starts with \"EPSON\".\n\t *\n\t * Nikon headers start with \"Nikon\" (6 bytes including '\\0'), \n\t * version number (1 or 2).\n\t * \n\t * Version 1 continues with 0, 1, 0, number_of_tags,\n\t * or just with number_of_tags (models D1H, D1X...).\n\t * \n\t * Version 2 continues with an unknown byte (0 or 10),\n\t * two unknown bytes (0), \"MM\" or \"II\", another byte 0 and \n\t * lastly 0x2A.\n\t */\n\tn->version = exif_mnote_data_olympus_identify_variant(buf+o2, buf_size-o2);\n\tswitch (n->version) {\n\tcase olympusV1:\n\tcase sanyoV1:\n\tcase epsonV1:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus/Sanyo/Epson maker note v1...\");\n\n\t\t/* The number of entries is at position 8. */\n\t\tif (buf[o2 + 6] == 1)\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if (buf[o2 + 6 + 1] == 1)\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\to2 += 8;\n\t\tc = exif_get_short (buf + o2, n->order);\n\t\tif ((!(c & 0xFF)) && (c > 0x500)) {\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t/* Olympus S760, S770 */\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif ((o2 + 4 < o2) || (o2 + 4 < 4) || (o2 + 4 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if ((buf[o2] == 'M') && (buf[o2 + 1] == 'M'))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\n\t\t/* The number of entries is at position 8+4. */\n\t\to2 += 4;\n\t\tbreak;\n\n\tcase nikonV1:\n\t\to2 += 6;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v1 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\to2 += 1;\n\n\t\tbase = MNOTE_NIKON1_TAG_BASE;\n\t\t/* Fix endianness, if needed */\n\t\tc = exif_get_short (buf + o2, n->order);\n\t\tif ((!(c & 0xFF)) && (c > 0x500)) {\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif ((o2 + 12 < o2) || (o2 + 12 < 12) || (o2 + 12 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\to2 += 1;\n\n\t\t/* Skip 2 unknown bytes (00 00). */\n\t\to2 += 2;\n\n\t\t/*\n\t\t * Byte order. From here the data offset\n\t\t * gets calculated.\n\t\t */\n\t\tdatao = o2;\n\t\tif (!strncmp ((char *)&buf[o2], \"II\", 2))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if (!strncmp ((char *)&buf[o2], \"MM\", 2))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\telse {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\"ExifMnoteDataOlympus\", \"Unknown \"\n\t\t\t\t\"byte order '%c%c'\", buf[o2],\n\t\t\t\tbuf[o2 + 1]);\n\t\t\treturn;\n\t\t}\n\t\to2 += 2;\n\n\t\t/* Skip 2 unknown bytes (00 2A). */\n\t\to2 += 2;\n\n\t\t/* Go to where the number of entries is. */\n\t\to2 = datao + exif_get_long (buf + o2, n->order);\n\t\tbreak;\n\n\tcase nikonV0:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v0 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3], \n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\t\t/* 00 1b is # of entries in Motorola order - the rest should also be in MM order */\n\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\tbreak;\n\n\tdefault:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tif ((o2 + 2 < o2) || (o2 + 2 < 2) || (o2 + 2 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + o2, n->order);\n\to2 += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_olympus_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteOlympusEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", sizeof (MnoteOlympusEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t    n->entries[tcount].tag        = exif_get_short (buf + o, n->order) + base;\n\t    n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t    n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t    n->entries[tcount].order      = n->order;\n\n\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t      \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t      mnote_olympus_tag_get_name (n->entries[tcount].tag));\n/*\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n\n\t    /*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     */\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t   \t\t\t n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) {\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + datao;\n#ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG\n\t\t\t\t/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t */\n\t\t\t    if (dataofs + s > buf_size && n->version == sanyoV1) {\n\t\t\t\t\t/* fix pointer */\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) || \n\t\t\t    (dataofs + s > buf_size)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_olympus_count (ExifMnoteData *n)\n{\n\treturn n ? ((ExifMnoteDataOlympus *) n)->count : 0;\n}\n\nstatic unsigned int\nexif_mnote_data_olympus_get_id (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataOlympus *note = (ExifMnoteDataOlympus *) d;\n\n\tif (!note) return 0;\n\tif (note->count <= n) return 0;\n\treturn note->entries[n].tag;\n}\n\nstatic const char *\nexif_mnote_data_olympus_get_name (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n\treturn mnote_olympus_tag_get_name (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_olympus_get_title (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_olympus_tag_get_title (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_olympus_get_description (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_olympus_tag_get_description (n->entries[i].tag);\n}\n\nstatic void\nexif_mnote_data_olympus_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_olympus_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataOlympus *) n)->offset = o;\n}\n\nstatic enum OlympusVersion\nexif_mnote_data_olympus_identify_variant (const unsigned char *buf,\n\t\tunsigned int buf_size)\n{\n\t/* Olympus, Nikon, Sanyo, Epson */\n\tif (buf_size >= 8) {\n\t\t/* Match the terminating NUL character, too */\n\t\tif (!memcmp (buf, \"OLYMPUS\", 8))\n\t\t\t   return olympusV2;\n\t\telse if (!memcmp (buf, \"OLYMP\", 6))\n\t\t\t   return olympusV1;\n\t\telse if (!memcmp (buf, \"SANYO\", 6))\n\t\t\t   return sanyoV1;\n\t\telse if (!memcmp (buf, \"EPSON\", 6))\n\t\t\t   return epsonV1;\n\t\telse if (!memcmp (buf, \"Nikon\", 6)) {\n\t\t\tswitch (buf[6]) {\n\t\t\t\tcase 1:  return nikonV1;\n\t\t\t\tcase 2:  return nikonV2;\n\t\t\t\tdefault: return 0; /* Unrecognized Nikon variant */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Another variant of Nikon */\n\tif ((buf_size >= 2) && (buf[0] == 0x00) && (buf[1] == 0x1b)) {\n\t\treturn nikonV0;\n\t}\n\n\treturn unrecognized;\n}\n\nint\nexif_mnote_data_olympus_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tint variant = exif_mnote_data_olympus_identify_variant(e->data, e->size);\n\n\tif (variant == nikonV0) {\n\t\t/* This variant needs some extra checking with the Make */\n\t\tchar value[5];\n\t\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\t\tvariant = unrecognized;\n\n\t\tif (em) {\n\t\t\tconst char *v = exif_entry_get_value (em, value, sizeof(value));\n\t\t\tif (v && (!strncmp (v, \"Nikon\", sizeof(value)) || \n\t\t\t\t\t  !strncmp (v, \"NIKON\", sizeof(value)) ))\n\t\t\t\t/* When saved, this variant will be written out like the\n\t\t\t\t * alternative nikonV2 form above instead\n\t\t\t\t */\n\t\t\t\tvariant = nikonV0;\n\t\t}\n\t}\n\n\treturn variant;\n}\n\n\nExifMnoteData *\nexif_mnote_data_olympus_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\t\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataOlympus));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_olympus_free;\n\td->methods.set_byte_order  = exif_mnote_data_olympus_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_olympus_set_offset;\n\td->methods.load            = exif_mnote_data_olympus_load;\n\td->methods.save            = exif_mnote_data_olympus_save;\n\td->methods.count           = exif_mnote_data_olympus_count;\n\td->methods.get_id          = exif_mnote_data_olympus_get_id;\n\td->methods.get_name        = exif_mnote_data_olympus_get_name;\n\td->methods.get_title       = exif_mnote_data_olympus_get_title;\n\td->methods.get_description = exif_mnote_data_olympus_get_description;\n\td->methods.get_value       = exif_mnote_data_olympus_get_value;\n\n\treturn d;\n}\n", "/* exif-mnote-data-pentax.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, \n * but WITHOUT ANY WARRANTY; without even the implied warranty of \n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details. \n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include \"config.h\"\n#include \"exif-mnote-data-pentax.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n\nstatic void\nexif_mnote_data_pentax_clear (ExifMnoteDataPentax *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_pentax_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_pentax_clear ((ExifMnoteDataPentax *) n);\n}\n\nstatic char *\nexif_mnote_data_pentax_get_value (ExifMnoteData *d, unsigned int i, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) d;\n\n\tif (!n) return NULL;\n\tif (n->count <= i) return NULL;\n\treturn mnote_pentax_entry_get_value (&n->entries[i], val, maxlen);\n}\n\n/** \n * @brief save the MnoteData from ne to buf\n * \n * @param ne extract the data from this structure \n * @param *buf write the mnoteData to this buffer (buffer will be allocated)\n * @param buf_size the final size of the buffer\n */\nstatic void\nexif_mnote_data_pentax_save (ExifMnoteData *ne,\n\t\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) ne;\n\tsize_t i, datao,\n\t  base = 0,\t/* internal MakerNote tag number offset */\n\t  o2 = 4 + 2;  \t/* offset to first tag entry, past header */\n\n\tif (!n || !buf || !buf_size) return;\n\tdatao = n->offset; /* this MakerNote style uses offsets\n\t\t\t      based on main IFD, not makernote IFD */\n\n\t/*\n\t * Allocate enough memory for header, the number of entries, entries,\n\t * and next IFD pointer\n\t */\n\t*buf_size = o2 + 2 + n->count * 12 + 4;\n\tswitch (n->version) {\n\tcase casioV2:\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\t\t/* Write the magic header */\n\t\tstrcpy ((char *)*buf, \"QVC\");\n\t\texif_set_short (*buf + 4, n->order, (ExifShort) 0);\n\n\t\tbreak;\n\n\tcase pentaxV3:\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the magic header */\n\t\tstrcpy ((char *)*buf, \"AOC\");\n\t\texif_set_short (*buf + 4, n->order, (ExifShort) (\n\t\t\t(n->order == EXIF_BYTE_ORDER_INTEL) ?\n\t\t\t('I' << 8) | 'I' :\n\t\t\t('M' << 8) | 'M'));\n\t\tbreak;\n\n\tcase pentaxV2:\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the magic header */\n\t\tstrcpy ((char *)*buf, \"AOC\");\n\t\texif_set_short (*buf + 4, n->order, (ExifShort) 0);\n\t\tbreak;\n\n\tcase pentaxV1:\n\t\t/* It looks like this format doesn't have a magic header as\n\t\t * such, just has a fixed number of entries equal to 0x001b */\n\t\t*buf_size -= 6;\n\t\to2 -= 6;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t/* internal error */\n\t\treturn;\n\t}\n\n\t/* Write the number of entries. */\n\texif_set_short (*buf + o2, n->order, (ExifShort) n->count);\n\to2 += 2;\n\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\tsize_t doff;\t/* offset to current data portion of tag */\n\t\tsize_t s;\n\t\tunsigned char *t;\n\t\tsize_t o = o2 + i * 12;   /* current offset into output buffer */\n\t\texif_set_short (*buf + o + 0, n->order,\n\t\t\t\t(ExifShort) (n->entries[i].tag - base));\n\t\texif_set_short (*buf + o + 2, n->order,\n\t\t\t\t(ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tsize_t ts = *buf_size + s;\n\t\t\tdoff = *buf_size;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\texif_set_long (*buf + o, n->order, datao + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/* Write the data. */\n\t\tif (n->entries[i].data) {\n\t\t\tmemcpy (*buf + doff, n->entries[i].data, s);\n\t\t} else {\n\t\t\t/* Most certainly damaged input file */\n\t\t\tmemset (*buf + doff, 0, s);\n\t\t}\n\t}\n\n\t/* Sanity check the buffer size */\n\tif (*buf_size < (o2 + n->count * 12 + 4)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteDataPentax\",\n\t\t\t\"Buffer overflow\");\n\t}\n\n\t/* Reset next IFD pointer */\n\texif_set_long (*buf + o2 + n->count * 12, n->order, 0);\n}\n\nstatic void\nexif_mnote_data_pentax_load (ExifMnoteData *en,\n\t\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;\n\tsize_t i, tcount, o, datao, base = 0;\n\tExifShort c;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif ((datao + 8 < datao) || (datao + 8 < 8) || (datao + 8 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Detect variant of Pentax/Casio MakerNote found */\n\tif (!memcmp(buf + datao, \"AOC\", 4)) {\n\t\tif ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t} else {\n\t\t\t/* Uses Casio v2 tags */\n\t\t\tn->version = pentaxV2;\n\t\t}\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v%d...\", (int)n->version);\n\t\tdatao += 4 + 2;\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t} else if (!memcmp(buf + datao, \"QVC\", 4)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Casio maker note v2...\");\n\t\tn->version = casioV2;\n\t\tbase = MNOTE_CASIO2_TAG_BASE;\n\t\tdatao += 4 + 2;\n\t} else {\n\t\t/* probably assert(!memcmp(buf + datao, \"\\x00\\x1b\", 2)) */\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v1...\");\n\t\tn->version = pentaxV1;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_pentax_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", sizeof (MnotePentaxEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnotePentax\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t  mnote_pentax_tag_get_name (n->entries[tcount].tag));\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) *\n                                      n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4)\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t   \tdataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) ||\n\t\t\t\t(dataofs + s > buf_size)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n\t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_pentax_count (ExifMnoteData *n)\n{\n\treturn n ? ((ExifMnoteDataPentax *) n)->count : 0;\n}\n\nstatic unsigned int\nexif_mnote_data_pentax_get_id (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\n\tif (!note) return 0;\n\tif (note->count <= n) return 0;\n\treturn note->entries[n].tag;\n}\n\nstatic const char *\nexif_mnote_data_pentax_get_name (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\n\tif (!note) return NULL;\n\tif (note->count <= n) return NULL;\n\treturn mnote_pentax_tag_get_name (note->entries[n].tag);\n}\n\nstatic const char *\nexif_mnote_data_pentax_get_title (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\n\tif (!note) return NULL;\n\tif (note->count <= n) return NULL;\n\treturn mnote_pentax_tag_get_title (note->entries[n].tag);\n}\n\nstatic const char *\nexif_mnote_data_pentax_get_description (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\t\n\tif (!note) return NULL;\n\tif (note->count <= n) return NULL;\n\treturn mnote_pentax_tag_get_description (note->entries[n].tag);\n}\n\nstatic void\nexif_mnote_data_pentax_set_offset (ExifMnoteData *d, unsigned int o)\n{\n\tif (d) ((ExifMnoteDataPentax *) d)->offset = o;\n}\n\nstatic void\nexif_mnote_data_pentax_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nint\nexif_mnote_data_pentax_identify (const ExifData *ed, const ExifEntry *e)\n{\n\t(void) ed;  /* unused */\n\tif ((e->size >= 8) && !memcmp (e->data, \"AOC\", 4)) {\n\t\tif (((e->data[4] == 'I') && (e->data[5] == 'I')) ||\n\t\t    ((e->data[4] == 'M') && (e->data[5] == 'M')))\n\t\t\treturn pentaxV3;\n\t\telse\n\t\t\t/* Uses Casio v2 tags */\n\t\t\treturn pentaxV2;\n\t}\n\n\tif ((e->size >= 8) && !memcmp (e->data, \"QVC\", 4))\n\t\treturn casioV2;\n\n\t/* This isn't a very robust test, so make sure it's done last */\n\t/* Maybe we should additionally check for a make of Asahi or Pentax */\n\tif ((e->size >= 2) && (e->data[0] == 0x00) && (e->data[1] == 0x1b))\n\t\treturn pentaxV1;\n\n\treturn 0;\n}\n\nExifMnoteData *\nexif_mnote_data_pentax_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataPentax));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_pentax_free;\n\td->methods.set_byte_order  = exif_mnote_data_pentax_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_pentax_set_offset;\n\td->methods.load            = exif_mnote_data_pentax_load;\n\td->methods.save            = exif_mnote_data_pentax_save;\n\td->methods.count           = exif_mnote_data_pentax_count;\n\td->methods.get_id          = exif_mnote_data_pentax_get_id;\n\td->methods.get_name        = exif_mnote_data_pentax_get_name;\n\td->methods.get_title       = exif_mnote_data_pentax_get_title;\n\td->methods.get_description = exif_mnote_data_pentax_get_description;\n\td->methods.get_value       = exif_mnote_data_pentax_get_value;\n\n\treturn d;\n}\n"], "fixing_code": ["/* exif-mnote-data-canon.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n * Copyright (c) 2003 Matthieu Castet <mat-c@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n#include \"exif-mnote-data-canon.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n#include <libexif/exif-data.h>\n\n#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n\nstatic void\nexif_mnote_data_canon_clear (ExifMnoteDataCanon *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_canon_clear ((ExifMnoteDataCanon *) n);\n}\n\nstatic void\nexif_mnote_data_canon_get_tags (ExifMnoteDataCanon *dc, unsigned int n,\n\t\tunsigned int *m, unsigned int *s)\n{\n\tunsigned int from = 0, to;\n\n\tif (!dc || !m) return;\n\tfor (*m = 0; *m < dc->count; (*m)++) {\n\t\tto = from + mnote_canon_entry_count_values (&dc->entries[*m]);\n\t\tif (to > n) {\n\t\t\tif (s) *s = n - from;\n\t\t\tbreak;\n\t\t}\n\t\tfrom = to;\n\t}\n}\n\nstatic char *\nexif_mnote_data_canon_get_value (ExifMnoteData *note, unsigned int n, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, n, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_entry_get_value (&dc->entries[m], s, val, maxlen);\n}\n\nstatic void\nexif_mnote_data_canon_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_canon_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataCanon *) n)->offset = o;\n}\n\nstatic void\nexif_mnote_data_canon_save (ExifMnoteData *ne, \n\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tsize_t i, o, s, doff;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number\n\t * of entries.\n\t */\n\t*buf_size = 2 + n->count * 12 + 4;\n\t*buf = exif_mem_alloc (ne->mem, sizeof (char) * *buf_size);\n\tif (!*buf) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", *buf_size);\n\t\treturn;\n\t}\n\n\t/* Save the number of entries */\n\texif_set_short (*buf, n->order, (ExifShort) n->count);\n\t\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = 2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order, (ExifShort) n->entries[i].tag);\n\t\texif_set_short (*buf + o + 2, n->order, (ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tts = *buf_size + s;\n\n\t\t\t/* Ensure even offsets. Set padding bytes to 0. */\n\t\t\tif (s & 1) ts += 1;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\tdoff = *buf_size - s;\n\t\t\tif (s & 1) { doff--; *(*buf + *buf_size - 1) = '\\0'; }\n\t\t\texif_set_long (*buf + o, n->order, n->offset + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/*\n\t\t * Write the data. Fill unneeded bytes with 0. Do not\n\t\t * crash if data is NULL.\n\t\t */\n\t\tif (!n->entries[i].data) memset (*buf + doff, 0, s);\n\t\telse memcpy (*buf + doff, n->entries[i].data, s);\n\t\tif (s < 4) memset (*buf + doff + s, 0, (4 - s));\n\t}\n}\n\n/* XXX\n * FIXME: exif_mnote_data_canon_load() may fail and there is no\n *        semantics to express that.\n *        See bug #1054323 for details, especially the comment by liblit\n *        after it has supposedly been fixed:\n *\n *        https://sourceforge.net/tracker/?func=detail&aid=1054323&group_id=12272&atid=112272\n *        Unfortunately, the \"return\" statements aren't commented at\n *        all, so it isn't trivial to find out what is a normal\n *        return, and what is a reaction to an error condition.\n */\n\nstatic void\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_count (ExifMnoteData *n)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) n;\n\tunsigned int i, c;\n\n\tfor (i = c = 0; dc && (i < dc->count); i++)\n\t\tc += mnote_canon_entry_count_values (&dc->entries[i]);\n\treturn c;\n}\n\nstatic unsigned int\nexif_mnote_data_canon_get_id (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) d;\n\tunsigned int m;\n\n\tif (!dc) return 0;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return 0;\n\treturn dc->entries[m].tag;\n}\n\nstatic const char *\nexif_mnote_data_canon_get_name (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_name_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_title (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m, s;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, &s);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_title_sub (dc->entries[m].tag, s, dc->options);\n}\n\nstatic const char *\nexif_mnote_data_canon_get_description (ExifMnoteData *note, unsigned int i)\n{\n\tExifMnoteDataCanon *dc = (ExifMnoteDataCanon *) note;\n\tunsigned int m;\n\n\tif (!dc) return NULL;\n\texif_mnote_data_canon_get_tags (dc, i, &m, NULL);\n\tif (m >= dc->count) return NULL;\n\treturn mnote_canon_tag_get_description (dc->entries[m].tag);\n}\n\nint\nexif_mnote_data_canon_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tchar value[8];\n\n\t(void) e;  /* unused */\n\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\tif (!em) \n\t\treturn 0;\n\treturn !strcmp (exif_entry_get_value (em, value, sizeof (value)), \"Canon\");\n}\n\nExifMnoteData *\nexif_mnote_data_canon_new (ExifMem *mem, ExifDataOption o)\n{\n\tExifMnoteData *d;\n\tExifMnoteDataCanon *dc;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataCanon));\n\tif (!d)\n\t\treturn NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_canon_free;\n\td->methods.set_byte_order  = exif_mnote_data_canon_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_canon_set_offset;\n\td->methods.load            = exif_mnote_data_canon_load;\n\td->methods.save            = exif_mnote_data_canon_save;\n\td->methods.count           = exif_mnote_data_canon_count;\n\td->methods.get_id          = exif_mnote_data_canon_get_id;\n\td->methods.get_name        = exif_mnote_data_canon_get_name;\n\td->methods.get_title       = exif_mnote_data_canon_get_title;\n\td->methods.get_description = exif_mnote_data_canon_get_description;\n\td->methods.get_value       = exif_mnote_data_canon_get_value;\n\n\tdc = (ExifMnoteDataCanon*)d;\n\tdc->options = o;\n\treturn d;\n}\n", "/* exif-mnote-data-fuji.c\n *\n * Copyright (c) 2002 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, \n * but WITHOUT ANY WARRANTY; without even the implied warranty of \n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details. \n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#include <config.h>\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n\n#include \"exif-mnote-data-fuji.h\"\n\n#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n\nstruct _MNoteFujiDataPrivate {\n\tExifByteOrder order;\n};\n\nstatic void\nexif_mnote_data_fuji_clear (ExifMnoteDataFuji *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_fuji_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_fuji_clear ((ExifMnoteDataFuji *) n);\n}\n\nstatic char *\nexif_mnote_data_fuji_get_value (ExifMnoteData *d, unsigned int i, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\n\tif (!d || !val) return NULL;\n\tif (i > n->count -1) return NULL;\n/*\n\texif_log (d->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataFuji\",\n\t\t  \"Querying value for tag '%s'...\",\n\t\t  mnote_fuji_tag_get_name (n->entries[i].tag));\n*/\n\treturn mnote_fuji_entry_get_value (&n->entries[i], val, maxlen);\n}\n\nstatic void\nexif_mnote_data_fuji_save (ExifMnoteData *ne, unsigned char **buf,\n\t\t\t   unsigned int *buf_size)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) ne;\n\tsize_t i, o, s, doff;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number\n\t * of entries.\n\t */\n\t*buf_size = 8 + 4 + 2 + n->count * 12 + 4;\n\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\tif (!*buf) {\n\t\t*buf_size = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Header: \"FUJIFILM\" and 4 bytes offset to the first entry.\n\t * As the first entry will start right thereafter, the offset is 12.\n\t */\n\tmemcpy (*buf, \"FUJIFILM\", 8);\n\texif_set_long (*buf + 8, n->order, 12);\n\n\t/* Save the number of entries */\n\texif_set_short (*buf + 8 + 4, n->order, (ExifShort) n->count);\n\t\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = 8 + 4 + 2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order, (ExifShort) n->entries[i].tag);\n\t\texif_set_short (*buf + o + 2, n->order, (ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order, n->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tts = *buf_size + s;\n\n\t\t\t/* Ensure even offsets. Set padding bytes to 0. */\n\t\t\tif (s & 1) ts += 1;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf, ts);\n\t\t\tif (!t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\tdoff = *buf_size - s;\n\t\t\tif (s & 1) { doff--; *(*buf + *buf_size - 1) = '\\0'; }\n\t\t\texif_set_long (*buf + o, n->order, doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/*\n\t\t * Write the data. Fill unneeded bytes with 0. Do not\n\t\t * crash if data is NULL.\n\t\t */\n\t\tif (!n->entries[i].data) memset (*buf + doff, 0, s);\n\t\telse memcpy (*buf + doff, n->entries[i].data, s);\n\t}\n}\n\nstatic void\nexif_mnote_data_fuji_load (ExifMnoteData *en,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji*) en;\n\tExifLong c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 12)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\tn->order = EXIF_BYTE_ORDER_INTEL;\n\n\tdatao += exif_get_long (buf + datao + 8, EXIF_BYTE_ORDER_INTEL);\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, EXIF_BYTE_ORDER_INTEL);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_fuji_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteFujiEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataFuji\", sizeof (MnoteFujiEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataFuji\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataFuji\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t  mnote_fuji_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\t  \"ExifMnoteDataFuji\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4)\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + 6 + n->offset;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\t\t  \"ExifMnoteDataFuji\", \"Tag data past end of \"\n\t\t\t\t\t  \"buffer (%u >= %u)\", (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataFuji\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_fuji_count (ExifMnoteData *n)\n{\n\treturn n ? ((ExifMnoteDataFuji *) n)->count : 0;\n}\n\nstatic unsigned int\nexif_mnote_data_fuji_get_id (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataFuji *note = (ExifMnoteDataFuji *) d;\n\n\tif (!note) return 0;\n\tif (note->count <= n) return 0;\n\treturn note->entries[n].tag;\n}\n\nstatic const char *\nexif_mnote_data_fuji_get_name (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n\treturn mnote_fuji_tag_get_name (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_fuji_get_title (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_fuji_tag_get_title (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_fuji_get_description (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_fuji_tag_get_description (n->entries[i].tag);\n}\n\nstatic void\nexif_mnote_data_fuji_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataFuji *n = (ExifMnoteDataFuji *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_fuji_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataFuji *) n)->offset = o;\n}\n\nint\nexif_mnote_data_fuji_identify (const ExifData *ed, const ExifEntry *e)\n{\n\t(void) ed;  /* unused */\n\treturn ((e->size >= 12) && !memcmp (e->data, \"FUJIFILM\", 8));\n}\n\nExifMnoteData *\nexif_mnote_data_fuji_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataFuji));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_fuji_free;\n\td->methods.set_byte_order  = exif_mnote_data_fuji_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_fuji_set_offset;\n\td->methods.load            = exif_mnote_data_fuji_load;\n\td->methods.save            = exif_mnote_data_fuji_save;\n\td->methods.count           = exif_mnote_data_fuji_count;\n\td->methods.get_id          = exif_mnote_data_fuji_get_id;\n\td->methods.get_name        = exif_mnote_data_fuji_get_name;\n\td->methods.get_title       = exif_mnote_data_fuji_get_title;\n\td->methods.get_description = exif_mnote_data_fuji_get_description;\n\td->methods.get_value       = exif_mnote_data_fuji_get_value;\n\n\treturn d;\n}\n", "/* exif-mnote-data-olympus.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include <config.h>\n#include \"exif-mnote-data-olympus.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include <libexif/exif-utils.h>\n#include <libexif/exif-data.h>\n\n/* Uncomment this to fix a problem with Sanyo MakerNotes. It's probably best\n * not to in most cases because it seems to only affect the thumbnail tag\n * which is duplicated in IFD 1, and fixing the offset could actually cause\n * problems with other software that expects the broken form.\n */\n/*#define EXIF_OVERCOME_SANYO_OFFSET_BUG */\n\n#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n\nstatic enum OlympusVersion\nexif_mnote_data_olympus_identify_variant (const unsigned char *buf,\n\t\tunsigned int buf_size);\n\n\nstatic void\nexif_mnote_data_olympus_clear (ExifMnoteDataOlympus *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_olympus_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_olympus_clear ((ExifMnoteDataOlympus *) n);\n}\n\nstatic char *\nexif_mnote_data_olympus_get_value (ExifMnoteData *d, unsigned int i, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\n\tif (!d || !val) return NULL;\n\tif (i > n->count -1) return NULL;\n/*\n\texif_log (d->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t  \"Querying value for tag '%s'...\",\n\t\t  mnote_olympus_tag_get_name (n->entries[i].tag));\n*/\n\treturn mnote_olympus_entry_get_value (&n->entries[i], val, maxlen);\n}\n\n\n\n\n/** \n * @brief save the MnoteData from ne to buf\n * \n * @param ne extract the data from this structure \n * @param *buf write the mnoteData to this buffer (buffer will be allocated)\n * @param buf_size the size of the buffer\n */\nstatic void\nexif_mnote_data_olympus_save (ExifMnoteData *ne,\n\t\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) ne;\n\tsize_t i, o, s, doff, base = 0, o2 = 6 + 2;\n\tsize_t datao = 0;\n\tunsigned char *t;\n\tsize_t ts;\n\n\tif (!n || !buf || !buf_size) return;\n\n\t/*\n\t * Allocate enough memory for all entries and the number of entries.\n\t */\n\t*buf_size = 6 + 2 + 2 + n->count * 12;\n\tswitch (n->version) {\n\tcase olympusV1:\n\tcase sanyoV1:\n\tcase epsonV1:\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the header and the number of entries. */\n\t\tstrcpy ((char *)*buf, n->version==sanyoV1?\"SANYO\":\n\t\t\t\t\t(n->version==epsonV1?\"EPSON\":\"OLYMP\"));\n\t\texif_set_short (*buf + 6, n->order, (ExifShort) 1);\n\t\tdatao = n->offset;\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t*buf_size += 8-6 + 4;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the header and the number of entries. */\n\t\tstrcpy ((char *)*buf, \"OLYMPUS\");\n\t\texif_set_short (*buf + 8, n->order, (ExifShort) (\n\t\t\t(n->order == EXIF_BYTE_ORDER_INTEL) ?\n\t\t\t('I' << 8) | 'I' :\n\t\t\t('M' << 8) | 'M'));\n\t\texif_set_short (*buf + 10, n->order, (ExifShort) 3);\n\t\to2 += 4;\n\t\tbreak;\n\n\tcase nikonV1: \n\t\tbase = MNOTE_NIKON1_TAG_BASE;\n\n\t\t/* v1 has offsets based to main IFD, not makernote IFD */\n\t\tdatao += n->offset + 10;\n\t\t/* subtract the size here, so the increment in the next case will not harm us */\n\t\t*buf_size -= 8 + 2;\n\t/* Fall through to nikonV2 handler */\n\tcase nikonV2: \n\t/* Write out V0 files in V2 format */\n\tcase nikonV0: \n\t\t*buf_size += 8 + 2;\n\t\t*buf_size += 4; /* Next IFD pointer */\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the header and the number of entries. */\n\t\tstrcpy ((char *)*buf, \"Nikon\");\n\t\t(*buf)[6] = n->version;\n\n\t\tif (n->version != nikonV1) {\n\t\t\texif_set_short (*buf + 10, n->order, (ExifShort) (\n\t\t\t\t(n->order == EXIF_BYTE_ORDER_INTEL) ?\n\t\t\t\t('I' << 8) | 'I' :\n\t\t\t\t('M' << 8) | 'M'));\n\t\t\texif_set_short (*buf + 12, n->order, (ExifShort) 0x2A);\n\t\t\texif_set_long (*buf + 14, n->order, (ExifShort) 8);\n\t\t\to2 += 2 + 8;\n\t\t}\n\t\tdatao -= 10;\n\t\t/* Reset next IFD pointer */\n\t\texif_set_long (*buf + o2 + 2 + n->count * 12, n->order, 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\texif_set_short (*buf + o2, n->order, (ExifShort) n->count);\n\to2 += 2;\n\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\to = o2 + i * 12;\n\t\texif_set_short (*buf + o + 0, n->order,\n\t\t\t\t(ExifShort) (n->entries[i].tag - base));\n\t\texif_set_short (*buf + o + 2, n->order,\n\t\t\t\t(ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tdoff = *buf_size;\n\t\t\tts = *buf_size + s;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataOlympus\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\texif_set_long (*buf + o, n->order, datao + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/* Write the data. */\n\t\tif (n->entries[i].data) {\n\t\t\tmemcpy (*buf + doff, n->entries[i].data, s);\n\t\t} else {\n\t\t\t/* Most certainly damaged input file */\n\t\t\tmemset (*buf + doff, 0, s);\n\t\t}\n\t}\n}\n\nstatic void\nexif_mnote_data_olympus_load (ExifMnoteData *en,\n\t\t\t      const unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) en;\n\tExifShort c;\n\tsize_t i, tcount, o, o2, datao = 6, base = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; /* Start of interesting data */\n\tif (CHECKOVERFLOW(o2,buf_size,10)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Olympus headers start with \"OLYMP\" and need to have at least\n\t * a size of 22 bytes (6 for 'OLYMP', 2 other bytes, 2 for the\n\t * number of entries, and 12 for one entry.\n\t *\n\t * Sanyo format is identical and uses identical tags except that\n\t * header starts with \"SANYO\".\n\t *\n\t * Epson format is identical and uses identical tags except that\n\t * header starts with \"EPSON\".\n\t *\n\t * Nikon headers start with \"Nikon\" (6 bytes including '\\0'), \n\t * version number (1 or 2).\n\t * \n\t * Version 1 continues with 0, 1, 0, number_of_tags,\n\t * or just with number_of_tags (models D1H, D1X...).\n\t * \n\t * Version 2 continues with an unknown byte (0 or 10),\n\t * two unknown bytes (0), \"MM\" or \"II\", another byte 0 and \n\t * lastly 0x2A.\n\t */\n\tn->version = exif_mnote_data_olympus_identify_variant(buf+o2, buf_size-o2);\n\tswitch (n->version) {\n\tcase olympusV1:\n\tcase sanyoV1:\n\tcase epsonV1:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus/Sanyo/Epson maker note v1...\");\n\n\t\t/* The number of entries is at position 8. */\n\t\tif (buf[o2 + 6] == 1)\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if (buf[o2 + 6 + 1] == 1)\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\to2 += 8;\n\t\tc = exif_get_short (buf + o2, n->order);\n\t\tif ((!(c & 0xFF)) && (c > 0x500)) {\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t/* Olympus S760, S770 */\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif (CHECKOVERFLOW(o2,buf_size,4)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if ((buf[o2] == 'M') && (buf[o2 + 1] == 'M'))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\n\t\t/* The number of entries is at position 8+4. */\n\t\to2 += 4;\n\t\tbreak;\n\n\tcase nikonV1:\n\t\to2 += 6;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v1 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\to2 += 1;\n\n\t\tbase = MNOTE_NIKON1_TAG_BASE;\n\t\t/* Fix endianness, if needed */\n\t\tc = exif_get_short (buf + o2, n->order);\n\t\tif ((!(c & 0xFF)) && (c > 0x500)) {\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif (CHECKOVERFLOW(o2,buf_size,12)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\to2 += 1;\n\n\t\t/* Skip 2 unknown bytes (00 00). */\n\t\to2 += 2;\n\n\t\t/*\n\t\t * Byte order. From here the data offset\n\t\t * gets calculated.\n\t\t */\n\t\tdatao = o2;\n\t\tif (!strncmp ((char *)&buf[o2], \"II\", 2))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if (!strncmp ((char *)&buf[o2], \"MM\", 2))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\telse {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\"ExifMnoteDataOlympus\", \"Unknown \"\n\t\t\t\t\"byte order '%c%c'\", buf[o2],\n\t\t\t\tbuf[o2 + 1]);\n\t\t\treturn;\n\t\t}\n\t\to2 += 2;\n\n\t\t/* Skip 2 unknown bytes (00 2A). */\n\t\to2 += 2;\n\n\t\t/* Go to where the number of entries is. */\n\t\to2 = datao + exif_get_long (buf + o2, n->order);\n\t\tbreak;\n\n\tcase nikonV0:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v0 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3], \n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\t\t/* 00 1b is # of entries in Motorola order - the rest should also be in MM order */\n\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\tbreak;\n\n\tdefault:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tif (CHECKOVERFLOW(o2,buf_size,2)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + o2, n->order);\n\to2 += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_olympus_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteOlympusEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", sizeof (MnoteOlympusEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t    n->entries[tcount].tag        = exif_get_short (buf + o, n->order) + base;\n\t    n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t    n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t    n->entries[tcount].order      = n->order;\n\n\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t      \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t      mnote_olympus_tag_get_name (n->entries[tcount].tag));\n/*\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n\n\t    /* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t     * we will check the buffer sizes closer later. */\n\t    if (exif_format_get_size (n->entries[tcount].format) &&\n\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t    ) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteOlympus\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\tcontinue;\n\t    }\n\t    /*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     */\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t   \t\t\t n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) {\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + datao;\n#ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG\n\t\t\t\t/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t */\n\t\t\t    if (dataofs > (buf_size - s) && n->version == sanyoV1) {\n\t\t\t\t\t/* fix pointer */\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_olympus_count (ExifMnoteData *n)\n{\n\treturn n ? ((ExifMnoteDataOlympus *) n)->count : 0;\n}\n\nstatic unsigned int\nexif_mnote_data_olympus_get_id (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataOlympus *note = (ExifMnoteDataOlympus *) d;\n\n\tif (!note) return 0;\n\tif (note->count <= n) return 0;\n\treturn note->entries[n].tag;\n}\n\nstatic const char *\nexif_mnote_data_olympus_get_name (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n\treturn mnote_olympus_tag_get_name (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_olympus_get_title (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_olympus_tag_get_title (n->entries[i].tag);\n}\n\nstatic const char *\nexif_mnote_data_olympus_get_description (ExifMnoteData *d, unsigned int i)\n{\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\t\n\tif (!n) return NULL;\n\tif (i >= n->count) return NULL;\n        return mnote_olympus_tag_get_description (n->entries[i].tag);\n}\n\nstatic void\nexif_mnote_data_olympus_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nstatic void\nexif_mnote_data_olympus_set_offset (ExifMnoteData *n, unsigned int o)\n{\n\tif (n) ((ExifMnoteDataOlympus *) n)->offset = o;\n}\n\nstatic enum OlympusVersion\nexif_mnote_data_olympus_identify_variant (const unsigned char *buf,\n\t\tunsigned int buf_size)\n{\n\t/* Olympus, Nikon, Sanyo, Epson */\n\tif (buf_size >= 8) {\n\t\t/* Match the terminating NUL character, too */\n\t\tif (!memcmp (buf, \"OLYMPUS\", 8))\n\t\t\t   return olympusV2;\n\t\telse if (!memcmp (buf, \"OLYMP\", 6))\n\t\t\t   return olympusV1;\n\t\telse if (!memcmp (buf, \"SANYO\", 6))\n\t\t\t   return sanyoV1;\n\t\telse if (!memcmp (buf, \"EPSON\", 6))\n\t\t\t   return epsonV1;\n\t\telse if (!memcmp (buf, \"Nikon\", 6)) {\n\t\t\tswitch (buf[6]) {\n\t\t\t\tcase 1:  return nikonV1;\n\t\t\t\tcase 2:  return nikonV2;\n\t\t\t\tdefault: return 0; /* Unrecognized Nikon variant */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Another variant of Nikon */\n\tif ((buf_size >= 2) && (buf[0] == 0x00) && (buf[1] == 0x1b)) {\n\t\treturn nikonV0;\n\t}\n\n\treturn unrecognized;\n}\n\nint\nexif_mnote_data_olympus_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tint variant = exif_mnote_data_olympus_identify_variant(e->data, e->size);\n\n\tif (variant == nikonV0) {\n\t\t/* This variant needs some extra checking with the Make */\n\t\tchar value[5];\n\t\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\t\tvariant = unrecognized;\n\n\t\tif (em) {\n\t\t\tconst char *v = exif_entry_get_value (em, value, sizeof(value));\n\t\t\tif (v && (!strncmp (v, \"Nikon\", sizeof(value)) || \n\t\t\t\t\t  !strncmp (v, \"NIKON\", sizeof(value)) ))\n\t\t\t\t/* When saved, this variant will be written out like the\n\t\t\t\t * alternative nikonV2 form above instead\n\t\t\t\t */\n\t\t\t\tvariant = nikonV0;\n\t\t}\n\t}\n\n\treturn variant;\n}\n\n\nExifMnoteData *\nexif_mnote_data_olympus_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\t\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataOlympus));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_olympus_free;\n\td->methods.set_byte_order  = exif_mnote_data_olympus_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_olympus_set_offset;\n\td->methods.load            = exif_mnote_data_olympus_load;\n\td->methods.save            = exif_mnote_data_olympus_save;\n\td->methods.count           = exif_mnote_data_olympus_count;\n\td->methods.get_id          = exif_mnote_data_olympus_get_id;\n\td->methods.get_name        = exif_mnote_data_olympus_get_name;\n\td->methods.get_title       = exif_mnote_data_olympus_get_title;\n\td->methods.get_description = exif_mnote_data_olympus_get_description;\n\td->methods.get_value       = exif_mnote_data_olympus_get_value;\n\n\treturn d;\n}\n", "/* exif-mnote-data-pentax.c\n *\n * Copyright (c) 2002, 2003 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, \n * but WITHOUT ANY WARRANTY; without even the implied warranty of \n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details. \n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include \"config.h\"\n#include \"exif-mnote-data-pentax.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include <libexif/exif-byte-order.h>\n#include <libexif/exif-utils.h>\n\n#define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize ))\n\nstatic void\nexif_mnote_data_pentax_clear (ExifMnoteDataPentax *n)\n{\n\tExifMnoteData *d = (ExifMnoteData *) n;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\tif (n->entries) {\n\t\tfor (i = 0; i < n->count; i++)\n\t\t\tif (n->entries[i].data) {\n\t\t\t\texif_mem_free (d->mem, n->entries[i].data);\n\t\t\t\tn->entries[i].data = NULL;\n\t\t\t}\n\t\texif_mem_free (d->mem, n->entries);\n\t\tn->entries = NULL;\n\t\tn->count = 0;\n\t}\n}\n\nstatic void\nexif_mnote_data_pentax_free (ExifMnoteData *n)\n{\n\tif (!n) return;\n\n\texif_mnote_data_pentax_clear ((ExifMnoteDataPentax *) n);\n}\n\nstatic char *\nexif_mnote_data_pentax_get_value (ExifMnoteData *d, unsigned int i, char *val, unsigned int maxlen)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) d;\n\n\tif (!n) return NULL;\n\tif (n->count <= i) return NULL;\n\treturn mnote_pentax_entry_get_value (&n->entries[i], val, maxlen);\n}\n\n/** \n * @brief save the MnoteData from ne to buf\n * \n * @param ne extract the data from this structure \n * @param *buf write the mnoteData to this buffer (buffer will be allocated)\n * @param buf_size the final size of the buffer\n */\nstatic void\nexif_mnote_data_pentax_save (ExifMnoteData *ne,\n\t\tunsigned char **buf, unsigned int *buf_size)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) ne;\n\tsize_t i, datao,\n\t  base = 0,\t/* internal MakerNote tag number offset */\n\t  o2 = 4 + 2;  \t/* offset to first tag entry, past header */\n\n\tif (!n || !buf || !buf_size) return;\n\tdatao = n->offset; /* this MakerNote style uses offsets\n\t\t\t      based on main IFD, not makernote IFD */\n\n\t/*\n\t * Allocate enough memory for header, the number of entries, entries,\n\t * and next IFD pointer\n\t */\n\t*buf_size = o2 + 2 + n->count * 12 + 4;\n\tswitch (n->version) {\n\tcase casioV2:\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\t\t/* Write the magic header */\n\t\tstrcpy ((char *)*buf, \"QVC\");\n\t\texif_set_short (*buf + 4, n->order, (ExifShort) 0);\n\n\t\tbreak;\n\n\tcase pentaxV3:\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the magic header */\n\t\tstrcpy ((char *)*buf, \"AOC\");\n\t\texif_set_short (*buf + 4, n->order, (ExifShort) (\n\t\t\t(n->order == EXIF_BYTE_ORDER_INTEL) ?\n\t\t\t('I' << 8) | 'I' :\n\t\t\t('M' << 8) | 'M'));\n\t\tbreak;\n\n\tcase pentaxV2:\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write the magic header */\n\t\tstrcpy ((char *)*buf, \"AOC\");\n\t\texif_set_short (*buf + 4, n->order, (ExifShort) 0);\n\t\tbreak;\n\n\tcase pentaxV1:\n\t\t/* It looks like this format doesn't have a magic header as\n\t\t * such, just has a fixed number of entries equal to 0x001b */\n\t\t*buf_size -= 6;\n\t\to2 -= 6;\n\t\t*buf = exif_mem_alloc (ne->mem, *buf_size);\n\t\tif (!*buf) {\n\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", *buf_size);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t/* internal error */\n\t\treturn;\n\t}\n\n\t/* Write the number of entries. */\n\texif_set_short (*buf + o2, n->order, (ExifShort) n->count);\n\to2 += 2;\n\n\t/* Save each entry */\n\tfor (i = 0; i < n->count; i++) {\n\t\tsize_t doff;\t/* offset to current data portion of tag */\n\t\tsize_t s;\n\t\tunsigned char *t;\n\t\tsize_t o = o2 + i * 12;   /* current offset into output buffer */\n\t\texif_set_short (*buf + o + 0, n->order,\n\t\t\t\t(ExifShort) (n->entries[i].tag - base));\n\t\texif_set_short (*buf + o + 2, n->order,\n\t\t\t\t(ExifShort) n->entries[i].format);\n\t\texif_set_long  (*buf + o + 4, n->order,\n\t\t\t\tn->entries[i].components);\n\t\to += 8;\n\t\ts = exif_format_get_size (n->entries[i].format) *\n\t\t\t\t\t\tn->entries[i].components;\n\t\tif (s > 65536) {\n\t\t\t/* Corrupt data: EXIF data size is limited to the\n\t\t\t * maximum size of a JPEG segment (64 kb).\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (s > 4) {\n\t\t\tsize_t ts = *buf_size + s;\n\t\t\tdoff = *buf_size;\n\t\t\tt = exif_mem_realloc (ne->mem, *buf,\n\t\t\t\t\t\t sizeof (char) * ts);\n\t\t\tif (!t) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteDataPentax\", ts);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*buf = t;\n\t\t\t*buf_size = ts;\n\t\t\texif_set_long (*buf + o, n->order, datao + doff);\n\t\t} else\n\t\t\tdoff = o;\n\n\t\t/* Write the data. */\n\t\tif (n->entries[i].data) {\n\t\t\tmemcpy (*buf + doff, n->entries[i].data, s);\n\t\t} else {\n\t\t\t/* Most certainly damaged input file */\n\t\t\tmemset (*buf + doff, 0, s);\n\t\t}\n\t}\n\n\t/* Sanity check the buffer size */\n\tif (*buf_size < (o2 + n->count * 12 + 4)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteDataPentax\",\n\t\t\t\"Buffer overflow\");\n\t}\n\n\t/* Reset next IFD pointer */\n\texif_set_long (*buf + o2 + n->count * 12, n->order, 0);\n}\n\nstatic void\nexif_mnote_data_pentax_load (ExifMnoteData *en,\n\t\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;\n\tsize_t i, tcount, o, datao, base = 0;\n\tExifShort c;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 8)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Detect variant of Pentax/Casio MakerNote found */\n\tif (!memcmp(buf + datao, \"AOC\", 4)) {\n\t\tif ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t} else {\n\t\t\t/* Uses Casio v2 tags */\n\t\t\tn->version = pentaxV2;\n\t\t}\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v%d...\", (int)n->version);\n\t\tdatao += 4 + 2;\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t} else if (!memcmp(buf + datao, \"QVC\", 4)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Casio maker note v2...\");\n\t\tn->version = casioV2;\n\t\tbase = MNOTE_CASIO2_TAG_BASE;\n\t\tdatao += 4 + 2;\n\t} else {\n\t\t/* probably assert(!memcmp(buf + datao, \"\\x00\\x1b\", 2)) */\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v1...\");\n\t\tn->version = pentaxV1;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_pentax_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", sizeof (MnotePentaxEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnotePentax\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t  mnote_pentax_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) *\n                                      n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4)\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t   \tdataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n\t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}\n\nstatic unsigned int\nexif_mnote_data_pentax_count (ExifMnoteData *n)\n{\n\treturn n ? ((ExifMnoteDataPentax *) n)->count : 0;\n}\n\nstatic unsigned int\nexif_mnote_data_pentax_get_id (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\n\tif (!note) return 0;\n\tif (note->count <= n) return 0;\n\treturn note->entries[n].tag;\n}\n\nstatic const char *\nexif_mnote_data_pentax_get_name (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\n\tif (!note) return NULL;\n\tif (note->count <= n) return NULL;\n\treturn mnote_pentax_tag_get_name (note->entries[n].tag);\n}\n\nstatic const char *\nexif_mnote_data_pentax_get_title (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\n\tif (!note) return NULL;\n\tif (note->count <= n) return NULL;\n\treturn mnote_pentax_tag_get_title (note->entries[n].tag);\n}\n\nstatic const char *\nexif_mnote_data_pentax_get_description (ExifMnoteData *d, unsigned int n)\n{\n\tExifMnoteDataPentax *note = (ExifMnoteDataPentax *) d;\n\t\n\tif (!note) return NULL;\n\tif (note->count <= n) return NULL;\n\treturn mnote_pentax_tag_get_description (note->entries[n].tag);\n}\n\nstatic void\nexif_mnote_data_pentax_set_offset (ExifMnoteData *d, unsigned int o)\n{\n\tif (d) ((ExifMnoteDataPentax *) d)->offset = o;\n}\n\nstatic void\nexif_mnote_data_pentax_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tExifByteOrder o_orig;\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) d;\n\tunsigned int i;\n\n\tif (!n) return;\n\n\to_orig = n->order;\n\tn->order = o;\n\tfor (i = 0; i < n->count; i++) {\n\t\tif (n->entries[i].components && (n->entries[i].size/n->entries[i].components < exif_format_get_size (n->entries[i].format)))\n\t\t\tcontinue;\n\t\tn->entries[i].order = o;\n\t\texif_array_set_byte_order (n->entries[i].format, n->entries[i].data,\n\t\t\t\tn->entries[i].components, o_orig, o);\n\t}\n}\n\nint\nexif_mnote_data_pentax_identify (const ExifData *ed, const ExifEntry *e)\n{\n\t(void) ed;  /* unused */\n\tif ((e->size >= 8) && !memcmp (e->data, \"AOC\", 4)) {\n\t\tif (((e->data[4] == 'I') && (e->data[5] == 'I')) ||\n\t\t    ((e->data[4] == 'M') && (e->data[5] == 'M')))\n\t\t\treturn pentaxV3;\n\t\telse\n\t\t\t/* Uses Casio v2 tags */\n\t\t\treturn pentaxV2;\n\t}\n\n\tif ((e->size >= 8) && !memcmp (e->data, \"QVC\", 4))\n\t\treturn casioV2;\n\n\t/* This isn't a very robust test, so make sure it's done last */\n\t/* Maybe we should additionally check for a make of Asahi or Pentax */\n\tif ((e->size >= 2) && (e->data[0] == 0x00) && (e->data[1] == 0x1b))\n\t\treturn pentaxV1;\n\n\treturn 0;\n}\n\nExifMnoteData *\nexif_mnote_data_pentax_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataPentax));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_pentax_free;\n\td->methods.set_byte_order  = exif_mnote_data_pentax_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_pentax_set_offset;\n\td->methods.load            = exif_mnote_data_pentax_load;\n\td->methods.save            = exif_mnote_data_pentax_save;\n\td->methods.count           = exif_mnote_data_pentax_count;\n\td->methods.get_id          = exif_mnote_data_pentax_get_id;\n\td->methods.get_name        = exif_mnote_data_pentax_get_name;\n\td->methods.get_title       = exif_mnote_data_pentax_get_title;\n\td->methods.get_description = exif_mnote_data_pentax_get_description;\n\td->methods.get_value       = exif_mnote_data_pentax_get_value;\n\n\treturn d;\n}\n"], "filenames": ["libexif/canon/exif-mnote-data-canon.c", "libexif/fuji/exif-mnote-data-fuji.c", "libexif/olympus/exif-mnote-data-olympus.c", "libexif/pentax/exif-mnote-data-pentax.c"], "buggy_code_start_loc": [31, 29, 37, 29], "buggy_code_end_loc": [268, 226, 476, 309], "fixing_code_start_loc": [32, 30, 38, 30], "fixing_code_end_loc": [282, 238, 485, 321], "type": "CWE-125", "message": "An issue was discovered in libexif before 0.6.22. Several buffer over-reads in EXIF MakerNote handling could lead to information disclosure and crashes. This is different from CVE-2020-0093.", "other": {"cve": {"id": "CVE-2020-13112", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-21T16:15:10.867", "lastModified": "2023-01-27T18:45:42.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in libexif before 0.6.22. Several buffer over-reads in EXIF MakerNote handling could lead to information disclosure and crashes. This is different from CVE-2020-0093."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en libexif versiones anteriores a la versi\u00f3n 0.6.22. Varias lecturas excesivas de buffer en el manejo de EXIF MakerNote podr\u00edan conllevar a una divulgaci\u00f3n de informaci\u00f3n y a bloqueos. Esto es diferente de CVE-2020-0093."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libexif_project:libexif:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.22", "matchCriteriaId": "C81CD57C-F020-46D6-859A-A9E81EF9685B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00017.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/05/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4396-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1"}}