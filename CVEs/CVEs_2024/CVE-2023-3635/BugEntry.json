{"buggy_code": ["/*\n * Copyright (C) 2014 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n@file:JvmName(\"-GzipSourceExtensions\")\n@file:Suppress(\"NOTHING_TO_INLINE\") // Aliases to public API.\n\npackage okio\n\nimport java.io.EOFException\nimport java.io.IOException\nimport java.util.zip.CRC32\nimport java.util.zip.Inflater\n\n/**\n * A source that uses [GZIP](http://www.ietf.org/rfc/rfc1952.txt) to\n * decompress data read from another source.\n */\nclass GzipSource(source: Source) : Source {\n\n  /** The current section. Always progresses forward. */\n  private var section = SECTION_HEADER\n\n  /**\n   * Our source should yield a GZIP header (which we consume directly), followed\n   * by deflated bytes (which we consume via an InflaterSource), followed by a\n   * GZIP trailer (which we also consume directly).\n   */\n  private val source = RealBufferedSource(source)\n\n  /** The inflater used to decompress the deflated body. */\n  private val inflater = Inflater(true)\n\n  /**\n   * The inflater source takes care of moving data between compressed source and\n   * decompressed sink buffers.\n   */\n  private val inflaterSource = InflaterSource(this.source, inflater)\n\n  /** Checksum used to check both the GZIP header and decompressed body. */\n  private val crc = CRC32()\n\n  @Throws(IOException::class)\n  override fun read(sink: Buffer, byteCount: Long): Long {\n    require(byteCount >= 0L) { \"byteCount < 0: $byteCount\" }\n    if (byteCount == 0L) return 0L\n\n    // If we haven't consumed the header, we must consume it before anything else.\n    if (section == SECTION_HEADER) {\n      consumeHeader()\n      section = SECTION_BODY\n    }\n\n    // Attempt to read at least a byte of the body. If we do, we're done.\n    if (section == SECTION_BODY) {\n      val offset = sink.size\n      val result = inflaterSource.read(sink, byteCount)\n      if (result != -1L) {\n        updateCrc(sink, offset, result)\n        return result\n      }\n      section = SECTION_TRAILER\n    }\n\n    // The body is exhausted; time to read the trailer. We always consume the\n    // trailer before returning a -1 exhausted result; that way if you read to\n    // the end of a GzipSource you guarantee that the CRC has been checked.\n    if (section == SECTION_TRAILER) {\n      consumeTrailer()\n      section = SECTION_DONE\n\n      // Gzip streams self-terminate: they return -1 before their underlying\n      // source returns -1. Here we attempt to force the underlying stream to\n      // return -1 which may trigger it to release its resources. If it doesn't\n      // return -1, then our Gzip data finished prematurely!\n      if (!source.exhausted()) {\n        throw IOException(\"gzip finished without exhausting source\")\n      }\n    }\n\n    return -1\n  }\n\n  @Throws(IOException::class)\n  private fun consumeHeader() {\n    // Read the 10-byte header. We peek at the flags byte first so we know if we\n    // need to CRC the entire header. Then we read the magic ID1ID2 sequence.\n    // We can skip everything else in the first 10 bytes.\n    // +---+---+---+---+---+---+---+---+---+---+\n    // |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)\n    // +---+---+---+---+---+---+---+---+---+---+\n    source.require(10)\n    val flags = source.buffer[3].toInt()\n    val fhcrc = flags.getBit(FHCRC)\n    if (fhcrc) updateCrc(source.buffer, 0, 10)\n\n    val id1id2 = source.readShort()\n    checkEqual(\"ID1ID2\", 0x1f8b, id1id2.toInt())\n    source.skip(8)\n\n    // Skip optional extra fields.\n    // +---+---+=================================+\n    // | XLEN  |...XLEN bytes of \"extra field\"...| (more-->)\n    // +---+---+=================================+\n    if (flags.getBit(FEXTRA)) {\n      source.require(2)\n      if (fhcrc) updateCrc(source.buffer, 0, 2)\n      val xlen = source.buffer.readShortLe().toLong()\n      source.require(xlen)\n      if (fhcrc) updateCrc(source.buffer, 0, xlen)\n      source.skip(xlen)\n    }\n\n    // Skip an optional 0-terminated name.\n    // +=========================================+\n    // |...original file name, zero-terminated...| (more-->)\n    // +=========================================+\n    if (flags.getBit(FNAME)) {\n      val index = source.indexOf(0)\n      if (index == -1L) throw EOFException()\n      if (fhcrc) updateCrc(source.buffer, 0, index + 1)\n      source.skip(index + 1)\n    }\n\n    // Skip an optional 0-terminated comment.\n    // +===================================+\n    // |...file comment, zero-terminated...| (more-->)\n    // +===================================+\n    if (flags.getBit(FCOMMENT)) {\n      val index = source.indexOf(0)\n      if (index == -1L) throw EOFException()\n      if (fhcrc) updateCrc(source.buffer, 0, index + 1)\n      source.skip(index + 1)\n    }\n\n    // Confirm the optional header CRC.\n    // +---+---+\n    // | CRC16 |\n    // +---+---+\n    if (fhcrc) {\n      checkEqual(\"FHCRC\", source.readShortLe().toInt(), crc.value.toShort().toInt())\n      crc.reset()\n    }\n  }\n\n  @Throws(IOException::class)\n  private fun consumeTrailer() {\n    // Read the eight-byte trailer. Confirm the body's CRC and size.\n    // +---+---+---+---+---+---+---+---+\n    // |     CRC32     |     ISIZE     |\n    // +---+---+---+---+---+---+---+---+\n    checkEqual(\"CRC\", source.readIntLe(), crc.value.toInt())\n    checkEqual(\"ISIZE\", source.readIntLe(), inflater.bytesWritten.toInt())\n  }\n\n  override fun timeout(): Timeout = source.timeout()\n\n  @Throws(IOException::class)\n  override fun close() = inflaterSource.close()\n\n  /** Updates the CRC with the given bytes.  */\n  private fun updateCrc(buffer: Buffer, offset: Long, byteCount: Long) {\n    var offset = offset\n    var byteCount = byteCount\n    // Skip segments that we aren't checksumming.\n    var s = buffer.head!!\n    while (offset >= s.limit - s.pos) {\n      offset -= s.limit - s.pos\n      s = s.next!!\n    }\n\n    // Checksum one segment at a time.\n    while (byteCount > 0) {\n      val pos = (s.pos + offset).toInt()\n      val toUpdate = minOf(s.limit - pos, byteCount).toInt()\n      crc.update(s.data, pos, toUpdate)\n      byteCount -= toUpdate\n      offset = 0\n      s = s.next!!\n    }\n  }\n\n  private fun checkEqual(name: String, expected: Int, actual: Int) {\n    if (actual != expected) {\n      throw IOException(\"%s: actual 0x%08x != expected 0x%08x\".format(name, actual, expected))\n    }\n  }\n}\n\nprivate inline fun Int.getBit(bit: Int) = this shr bit and 1 == 1\n\nprivate const val FHCRC = 1\nprivate const val FEXTRA = 2\nprivate const val FNAME = 3\nprivate const val FCOMMENT = 4\n\nprivate const val SECTION_HEADER: Byte = 0\nprivate const val SECTION_BODY: Byte = 1\nprivate const val SECTION_TRAILER: Byte = 2\nprivate const val SECTION_DONE: Byte = 3\n\n/**\n * Returns a [GzipSource] that gzip-decompresses this [Source] while reading.\n *\n * @see GzipSource\n */\ninline fun Source.gzip() = GzipSource(this)\n", "/*\n * Copyright (C) 2018 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage okio\n\nimport kotlin.test.assertEquals\nimport okio.ByteString.Companion.decodeHex\nimport org.junit.Test\n\nclass GzipKotlinTest {\n  @Test fun sink() {\n    val data = Buffer()\n    val gzip = (data as Sink).gzip()\n    gzip.buffer().writeUtf8(\"Hi!\").close()\n    assertEquals(\"1f8b0800000000000000f3c8540400dac59e7903000000\", data.readByteString().hex())\n  }\n\n  @Test fun source() {\n    val buffer = Buffer().write(\"1f8b0800000000000000f3c8540400dac59e7903000000\".decodeHex())\n    val gzip = (buffer as Source).gzip()\n    assertEquals(\"Hi!\", gzip.buffer().readUtf8())\n  }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2014 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n@file:JvmName(\"-GzipSourceExtensions\")\n@file:Suppress(\"NOTHING_TO_INLINE\") // Aliases to public API.\n\npackage okio\n\nimport java.io.EOFException\nimport java.io.IOException\nimport java.util.zip.CRC32\nimport java.util.zip.Inflater\n\n/**\n * A source that uses [GZIP](http://www.ietf.org/rfc/rfc1952.txt) to\n * decompress data read from another source.\n */\nclass GzipSource(source: Source) : Source {\n\n  /** The current section. Always progresses forward. */\n  private var section = SECTION_HEADER\n\n  /**\n   * Our source should yield a GZIP header (which we consume directly), followed\n   * by deflated bytes (which we consume via an InflaterSource), followed by a\n   * GZIP trailer (which we also consume directly).\n   */\n  private val source = RealBufferedSource(source)\n\n  /** The inflater used to decompress the deflated body. */\n  private val inflater = Inflater(true)\n\n  /**\n   * The inflater source takes care of moving data between compressed source and\n   * decompressed sink buffers.\n   */\n  private val inflaterSource = InflaterSource(this.source, inflater)\n\n  /** Checksum used to check both the GZIP header and decompressed body. */\n  private val crc = CRC32()\n\n  @Throws(IOException::class)\n  override fun read(sink: Buffer, byteCount: Long): Long {\n    require(byteCount >= 0L) { \"byteCount < 0: $byteCount\" }\n    if (byteCount == 0L) return 0L\n\n    // If we haven't consumed the header, we must consume it before anything else.\n    if (section == SECTION_HEADER) {\n      consumeHeader()\n      section = SECTION_BODY\n    }\n\n    // Attempt to read at least a byte of the body. If we do, we're done.\n    if (section == SECTION_BODY) {\n      val offset = sink.size\n      val result = inflaterSource.read(sink, byteCount)\n      if (result != -1L) {\n        updateCrc(sink, offset, result)\n        return result\n      }\n      section = SECTION_TRAILER\n    }\n\n    // The body is exhausted; time to read the trailer. We always consume the\n    // trailer before returning a -1 exhausted result; that way if you read to\n    // the end of a GzipSource you guarantee that the CRC has been checked.\n    if (section == SECTION_TRAILER) {\n      consumeTrailer()\n      section = SECTION_DONE\n\n      // Gzip streams self-terminate: they return -1 before their underlying\n      // source returns -1. Here we attempt to force the underlying stream to\n      // return -1 which may trigger it to release its resources. If it doesn't\n      // return -1, then our Gzip data finished prematurely!\n      if (!source.exhausted()) {\n        throw IOException(\"gzip finished without exhausting source\")\n      }\n    }\n\n    return -1\n  }\n\n  @Throws(IOException::class)\n  private fun consumeHeader() {\n    // Read the 10-byte header. We peek at the flags byte first so we know if we\n    // need to CRC the entire header. Then we read the magic ID1ID2 sequence.\n    // We can skip everything else in the first 10 bytes.\n    // +---+---+---+---+---+---+---+---+---+---+\n    // |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)\n    // +---+---+---+---+---+---+---+---+---+---+\n    source.require(10)\n    val flags = source.buffer[3].toInt()\n    val fhcrc = flags.getBit(FHCRC)\n    if (fhcrc) updateCrc(source.buffer, 0, 10)\n\n    val id1id2 = source.readShort()\n    checkEqual(\"ID1ID2\", 0x1f8b, id1id2.toInt())\n    source.skip(8)\n\n    // Skip optional extra fields.\n    // +---+---+=================================+\n    // | XLEN  |...XLEN bytes of \"extra field\"...| (more-->)\n    // +---+---+=================================+\n    if (flags.getBit(FEXTRA)) {\n      source.require(2)\n      if (fhcrc) updateCrc(source.buffer, 0, 2)\n      val xlen = (source.buffer.readShortLe().toInt() and 0xffff).toLong()\n      source.require(xlen)\n      if (fhcrc) updateCrc(source.buffer, 0, xlen)\n      source.skip(xlen)\n    }\n\n    // Skip an optional 0-terminated name.\n    // +=========================================+\n    // |...original file name, zero-terminated...| (more-->)\n    // +=========================================+\n    if (flags.getBit(FNAME)) {\n      val index = source.indexOf(0)\n      if (index == -1L) throw EOFException()\n      if (fhcrc) updateCrc(source.buffer, 0, index + 1)\n      source.skip(index + 1)\n    }\n\n    // Skip an optional 0-terminated comment.\n    // +===================================+\n    // |...file comment, zero-terminated...| (more-->)\n    // +===================================+\n    if (flags.getBit(FCOMMENT)) {\n      val index = source.indexOf(0)\n      if (index == -1L) throw EOFException()\n      if (fhcrc) updateCrc(source.buffer, 0, index + 1)\n      source.skip(index + 1)\n    }\n\n    // Confirm the optional header CRC.\n    // +---+---+\n    // | CRC16 |\n    // +---+---+\n    if (fhcrc) {\n      checkEqual(\"FHCRC\", source.readShortLe().toInt(), crc.value.toShort().toInt())\n      crc.reset()\n    }\n  }\n\n  @Throws(IOException::class)\n  private fun consumeTrailer() {\n    // Read the eight-byte trailer. Confirm the body's CRC and size.\n    // +---+---+---+---+---+---+---+---+\n    // |     CRC32     |     ISIZE     |\n    // +---+---+---+---+---+---+---+---+\n    checkEqual(\"CRC\", source.readIntLe(), crc.value.toInt())\n    checkEqual(\"ISIZE\", source.readIntLe(), inflater.bytesWritten.toInt())\n  }\n\n  override fun timeout(): Timeout = source.timeout()\n\n  @Throws(IOException::class)\n  override fun close() = inflaterSource.close()\n\n  /** Updates the CRC with the given bytes.  */\n  private fun updateCrc(buffer: Buffer, offset: Long, byteCount: Long) {\n    var offset = offset\n    var byteCount = byteCount\n    // Skip segments that we aren't checksumming.\n    var s = buffer.head!!\n    while (offset >= s.limit - s.pos) {\n      offset -= s.limit - s.pos\n      s = s.next!!\n    }\n\n    // Checksum one segment at a time.\n    while (byteCount > 0) {\n      val pos = (s.pos + offset).toInt()\n      val toUpdate = minOf(s.limit - pos, byteCount).toInt()\n      crc.update(s.data, pos, toUpdate)\n      byteCount -= toUpdate\n      offset = 0\n      s = s.next!!\n    }\n  }\n\n  private fun checkEqual(name: String, expected: Int, actual: Int) {\n    if (actual != expected) {\n      throw IOException(\"%s: actual 0x%08x != expected 0x%08x\".format(name, actual, expected))\n    }\n  }\n}\n\nprivate inline fun Int.getBit(bit: Int) = this shr bit and 1 == 1\n\nprivate const val FHCRC = 1\nprivate const val FEXTRA = 2\nprivate const val FNAME = 3\nprivate const val FCOMMENT = 4\n\nprivate const val SECTION_HEADER: Byte = 0\nprivate const val SECTION_BODY: Byte = 1\nprivate const val SECTION_TRAILER: Byte = 2\nprivate const val SECTION_DONE: Byte = 3\n\n/**\n * Returns a [GzipSource] that gzip-decompresses this [Source] while reading.\n *\n * @see GzipSource\n */\ninline fun Source.gzip() = GzipSource(this)\n", "/*\n * Copyright (C) 2018 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage okio\n\nimport kotlin.test.assertEquals\nimport okio.ByteString.Companion.decodeHex\nimport org.junit.Test\n\nclass GzipKotlinTest {\n  @Test fun sink() {\n    val data = Buffer()\n    (data as Sink).gzip().buffer().use { gzip ->\n      gzip.writeUtf8(\"Hi!\")\n    }\n    assertEquals(\"1f8b0800000000000000f3c8540400dac59e7903000000\", data.readByteString().hex())\n  }\n\n  @Test fun source() {\n    val buffer = Buffer().write(\"1f8b0800000000000000f3c8540400dac59e7903000000\".decodeHex())\n    (buffer as Source).gzip().buffer().use { gzip ->\n      assertEquals(\"Hi!\", gzip.readUtf8())\n    }\n  }\n\n  @Test fun extraLongXlen() {\n    val xlen = 0xffff\n    val buffer = Buffer()\n      .write(\"1f8b0804000000000000\".decodeHex())\n      .writeShort(xlen)\n      .write(ByteArray(xlen))\n      .write(\"f3c8540400dac59e7903000000\".decodeHex())\n    (buffer as Source).gzip().buffer().use { gzip ->\n      assertEquals(\"Hi!\", gzip.readUtf8())\n    }\n  }\n}\n"], "filenames": ["okio/src/jvmMain/kotlin/okio/GzipSource.kt", "okio/src/jvmTest/kotlin/okio/GzipKotlinTest.kt"], "buggy_code_start_loc": [120, 26], "buggy_code_end_loc": [121, 35], "fixing_code_start_loc": [120, 26], "fixing_code_end_loc": [121, 49], "type": "CWE-681", "message": "GzipSource does not handle an exception that might be raised when parsing a malformed gzip buffer. This may lead to denial of service of the Okio client when handling a crafted GZIP archive, by using the GzipSource class.\n\n", "other": {"cve": {"id": "CVE-2023-3635", "sourceIdentifier": "reefs@jfrog.com", "published": "2023-07-12T19:15:08.983", "lastModified": "2023-10-25T15:17:42.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GzipSource does not handle an exception that might be raised when parsing a malformed gzip buffer. This may lead to denial of service of the Okio client when handling a crafted GZIP archive, by using the GzipSource class.\n\n"}, {"lang": "es", "value": "GzipSource no maneja una excepci\u00f3n que podr\u00eda surgir al analizar un b\u00fafer gzip malformado. Esto puede conducir a la denegaci\u00f3n de servicio del cliente Okio cuando se maneja un archivo GZIP manipulado, mediante el uso de la clase \"GzipSource\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "reefs@jfrog.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-681"}]}, {"source": "reefs@jfrog.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-195"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squareup:okio:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.5.0", "versionEndExcluding": "1.17.6", "matchCriteriaId": "03403B65-FE42-46FB-B8DA-2AAFAD29C5F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squareup:okio:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "3.4.0", "matchCriteriaId": "CC8A3FE6-BD81-4D3D-9568-E364F5D35668"}]}]}], "references": [{"url": "https://github.com/square/okio/commit/81bce1a30af244550b0324597720e4799281da7b", "source": "reefs@jfrog.com", "tags": ["Patch"]}, {"url": "https://research.jfrog.com/vulnerabilities/okio-gzip-source-unhandled-exception-dos-xray-523195/", "source": "reefs@jfrog.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/square/okio/commit/81bce1a30af244550b0324597720e4799281da7b"}}