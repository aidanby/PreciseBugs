{"buggy_code": ["/*\n * Error resilience / concealment\n *\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Error resilience / concealment.\n */\n\n#include <limits.h>\n\n#include \"libavutil/internal.h\"\n#include \"avcodec.h\"\n#include \"error_resilience.h\"\n#include \"me_cmp.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"rectangle.h\"\n#include \"thread.h\"\n#include \"version.h\"\n\n/**\n * @param stride the number of MVs to get to the next row\n * @param mv_step the number of MVs per row or column in a macroblock\n */\nstatic void set_mv_strides(ERContext *s, ptrdiff_t *mv_step, ptrdiff_t *stride)\n{\n    if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n        av_assert0(s->quarter_sample);\n        *mv_step = 4;\n        *stride  = s->mb_width * 4;\n    } else {\n        *mv_step = 2;\n        *stride  = s->b8_stride;\n    }\n}\n\n/**\n * Replace the current MB with a flat dc-only version.\n */\nstatic void put_dc(ERContext *s, uint8_t *dest_y, uint8_t *dest_cb,\n                   uint8_t *dest_cr, int mb_x, int mb_y)\n{\n    int *linesize = s->cur_pic.f->linesize;\n    int dc, dcu, dcv, y, i;\n    for (i = 0; i < 4; i++) {\n        dc = s->dc_val[0][mb_x * 2 + (i &  1) + (mb_y * 2 + (i >> 1)) * s->b8_stride];\n        if (dc < 0)\n            dc = 0;\n        else if (dc > 2040)\n            dc = 2040;\n        for (y = 0; y < 8; y++) {\n            int x;\n            for (x = 0; x < 8; x++)\n                dest_y[x + (i &  1) * 8 + (y + (i >> 1) * 8) * linesize[0]] = dc / 8;\n        }\n    }\n    dcu = s->dc_val[1][mb_x + mb_y * s->mb_stride];\n    dcv = s->dc_val[2][mb_x + mb_y * s->mb_stride];\n    if (dcu < 0)\n        dcu = 0;\n    else if (dcu > 2040)\n        dcu = 2040;\n    if (dcv < 0)\n        dcv = 0;\n    else if (dcv > 2040)\n        dcv = 2040;\n\n    if (dest_cr)\n    for (y = 0; y < 8; y++) {\n        int x;\n        for (x = 0; x < 8; x++) {\n            dest_cb[x + y * linesize[1]] = dcu / 8;\n            dest_cr[x + y * linesize[2]] = dcv / 8;\n        }\n    }\n}\n\nstatic void filter181(int16_t *data, int width, int height, ptrdiff_t stride)\n{\n    int x, y;\n\n    /* horizontal filter */\n    for (y = 1; y < height - 1; y++) {\n        int prev_dc = data[0 + y * stride];\n\n        for (x = 1; x < width - 1; x++) {\n            int dc;\n            dc = -prev_dc +\n                 data[x     + y * stride] * 8 -\n                 data[x + 1 + y * stride];\n            dc = (av_clip(dc, INT_MIN/10923, INT_MAX/10923 - 32768) * 10923 + 32768) >> 16;\n            prev_dc = data[x + y * stride];\n            data[x + y * stride] = dc;\n        }\n    }\n\n    /* vertical filter */\n    for (x = 1; x < width - 1; x++) {\n        int prev_dc = data[x];\n\n        for (y = 1; y < height - 1; y++) {\n            int dc;\n\n            dc = -prev_dc +\n                 data[x +  y      * stride] * 8 -\n                 data[x + (y + 1) * stride];\n            dc = (av_clip(dc, INT_MIN/10923, INT_MAX/10923 - 32768) * 10923 + 32768) >> 16;\n            prev_dc = data[x + y * stride];\n            data[x + y * stride] = dc;\n        }\n    }\n}\n\n/**\n * guess the dc of blocks which do not have an undamaged dc\n * @param w     width in 8 pixel blocks\n * @param h     height in 8 pixel blocks\n */\nstatic void guess_dc(ERContext *s, int16_t *dc, int w,\n                     int h, ptrdiff_t stride, int is_luma)\n{\n    int b_x, b_y;\n    int16_t  (*col )[4] = av_malloc_array(stride, h*sizeof( int16_t)*4);\n    uint32_t (*dist)[4] = av_malloc_array(stride, h*sizeof(uint32_t)*4);\n\n    if(!col || !dist) {\n        av_log(s->avctx, AV_LOG_ERROR, \"guess_dc() is out of memory\\n\");\n        goto fail;\n    }\n\n    for(b_y=0; b_y<h; b_y++){\n        int color= 1024;\n        int distance= -1;\n        for(b_x=0; b_x<w; b_x++){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_x;\n            }\n            col [b_x + b_y*stride][1]= color;\n            dist[b_x + b_y*stride][1]= distance >= 0 ? b_x-distance : 9999;\n        }\n        color= 1024;\n        distance= -1;\n        for(b_x=w-1; b_x>=0; b_x--){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_x;\n            }\n            col [b_x + b_y*stride][0]= color;\n            dist[b_x + b_y*stride][0]= distance >= 0 ? distance-b_x : 9999;\n        }\n    }\n    for(b_x=0; b_x<w; b_x++){\n        int color= 1024;\n        int distance= -1;\n        for(b_y=0; b_y<h; b_y++){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_y;\n            }\n            col [b_x + b_y*stride][3]= color;\n            dist[b_x + b_y*stride][3]= distance >= 0 ? b_y-distance : 9999;\n        }\n        color= 1024;\n        distance= -1;\n        for(b_y=h-1; b_y>=0; b_y--){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_y;\n            }\n            col [b_x + b_y*stride][2]= color;\n            dist[b_x + b_y*stride][2]= distance >= 0 ? distance-b_y : 9999;\n        }\n    }\n\n    for (b_y = 0; b_y < h; b_y++) {\n        for (b_x = 0; b_x < w; b_x++) {\n            int mb_index, error, j;\n            int64_t guess, weight_sum;\n            mb_index = (b_x >> is_luma) + (b_y >> is_luma) * s->mb_stride;\n            error    = s->error_status_table[mb_index];\n\n            if (IS_INTER(s->cur_pic.mb_type[mb_index]))\n                continue; // inter\n            if (!(error & ER_DC_ERROR))\n                continue; // dc-ok\n\n            weight_sum = 0;\n            guess      = 0;\n            for (j = 0; j < 4; j++) {\n                int64_t weight  = 256 * 256 * 256 * 16 / FFMAX(dist[b_x + b_y*stride][j], 1);\n                guess          += weight*(int64_t)col[b_x + b_y*stride][j];\n                weight_sum     += weight;\n            }\n            guess = (guess + weight_sum / 2) / weight_sum;\n            dc[b_x + b_y * stride] = guess;\n        }\n    }\n\nfail:\n    av_freep(&col);\n    av_freep(&dist);\n}\n\n/**\n * simple horizontal deblocking filter used for error resilience\n * @param w     width in 8 pixel blocks\n * @param h     height in 8 pixel blocks\n */\nstatic void h_block_filter(ERContext *s, uint8_t *dst, int w,\n                           int h, ptrdiff_t stride, int is_luma)\n{\n    int b_x, b_y;\n    ptrdiff_t mvx_stride, mvy_stride;\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n    set_mv_strides(s, &mvx_stride, &mvy_stride);\n    mvx_stride >>= is_luma;\n    mvy_stride *= mvx_stride;\n\n    for (b_y = 0; b_y < h; b_y++) {\n        for (b_x = 0; b_x < w - 1; b_x++) {\n            int y;\n            int left_status  = s->error_status_table[( b_x      >> is_luma) + (b_y >> is_luma) * s->mb_stride];\n            int right_status = s->error_status_table[((b_x + 1) >> is_luma) + (b_y >> is_luma) * s->mb_stride];\n            int left_intra   = IS_INTRA(s->cur_pic.mb_type[( b_x      >> is_luma) + (b_y >> is_luma) * s->mb_stride]);\n            int right_intra  = IS_INTRA(s->cur_pic.mb_type[((b_x + 1) >> is_luma) + (b_y >> is_luma) * s->mb_stride]);\n            int left_damage  = left_status & ER_MB_ERROR;\n            int right_damage = right_status & ER_MB_ERROR;\n            int offset       = b_x * 8 + b_y * stride * 8;\n            int16_t *left_mv  = s->cur_pic.motion_val[0][mvy_stride * b_y + mvx_stride *  b_x];\n            int16_t *right_mv = s->cur_pic.motion_val[0][mvy_stride * b_y + mvx_stride * (b_x + 1)];\n            if (!(left_damage || right_damage))\n                continue; // both undamaged\n            if ((!left_intra) && (!right_intra) &&\n                FFABS(left_mv[0] - right_mv[0]) +\n                FFABS(left_mv[1] + right_mv[1]) < 2)\n                continue;\n\n            for (y = 0; y < 8; y++) {\n                int a, b, c, d;\n\n                a = dst[offset + 7 + y * stride] - dst[offset + 6 + y * stride];\n                b = dst[offset + 8 + y * stride] - dst[offset + 7 + y * stride];\n                c = dst[offset + 9 + y * stride] - dst[offset + 8 + y * stride];\n\n                d = FFABS(b) - ((FFABS(a) + FFABS(c) + 1) >> 1);\n                d = FFMAX(d, 0);\n                if (b < 0)\n                    d = -d;\n\n                if (d == 0)\n                    continue;\n\n                if (!(left_damage && right_damage))\n                    d = d * 16 / 9;\n\n                if (left_damage) {\n                    dst[offset + 7 + y * stride] = cm[dst[offset + 7 + y * stride] + ((d * 7) >> 4)];\n                    dst[offset + 6 + y * stride] = cm[dst[offset + 6 + y * stride] + ((d * 5) >> 4)];\n                    dst[offset + 5 + y * stride] = cm[dst[offset + 5 + y * stride] + ((d * 3) >> 4)];\n                    dst[offset + 4 + y * stride] = cm[dst[offset + 4 + y * stride] + ((d * 1) >> 4)];\n                }\n                if (right_damage) {\n                    dst[offset + 8 + y * stride] = cm[dst[offset +  8 + y * stride] - ((d * 7) >> 4)];\n                    dst[offset + 9 + y * stride] = cm[dst[offset +  9 + y * stride] - ((d * 5) >> 4)];\n                    dst[offset + 10+ y * stride] = cm[dst[offset + 10 + y * stride] - ((d * 3) >> 4)];\n                    dst[offset + 11+ y * stride] = cm[dst[offset + 11 + y * stride] - ((d * 1) >> 4)];\n                }\n            }\n        }\n    }\n}\n\n/**\n * simple vertical deblocking filter used for error resilience\n * @param w     width in 8 pixel blocks\n * @param h     height in 8 pixel blocks\n */\nstatic void v_block_filter(ERContext *s, uint8_t *dst, int w, int h,\n                           ptrdiff_t stride, int is_luma)\n{\n    int b_x, b_y;\n    ptrdiff_t mvx_stride, mvy_stride;\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n    set_mv_strides(s, &mvx_stride, &mvy_stride);\n    mvx_stride >>= is_luma;\n    mvy_stride *= mvx_stride;\n\n    for (b_y = 0; b_y < h - 1; b_y++) {\n        for (b_x = 0; b_x < w; b_x++) {\n            int x;\n            int top_status    = s->error_status_table[(b_x >> is_luma) +  (b_y      >> is_luma) * s->mb_stride];\n            int bottom_status = s->error_status_table[(b_x >> is_luma) + ((b_y + 1) >> is_luma) * s->mb_stride];\n            int top_intra     = IS_INTRA(s->cur_pic.mb_type[(b_x >> is_luma) + ( b_y      >> is_luma) * s->mb_stride]);\n            int bottom_intra  = IS_INTRA(s->cur_pic.mb_type[(b_x >> is_luma) + ((b_y + 1) >> is_luma) * s->mb_stride]);\n            int top_damage    = top_status & ER_MB_ERROR;\n            int bottom_damage = bottom_status & ER_MB_ERROR;\n            int offset        = b_x * 8 + b_y * stride * 8;\n\n            int16_t *top_mv    = s->cur_pic.motion_val[0][mvy_stride *  b_y      + mvx_stride * b_x];\n            int16_t *bottom_mv = s->cur_pic.motion_val[0][mvy_stride * (b_y + 1) + mvx_stride * b_x];\n\n            if (!(top_damage || bottom_damage))\n                continue; // both undamaged\n\n            if ((!top_intra) && (!bottom_intra) &&\n                FFABS(top_mv[0] - bottom_mv[0]) +\n                FFABS(top_mv[1] + bottom_mv[1]) < 2)\n                continue;\n\n            for (x = 0; x < 8; x++) {\n                int a, b, c, d;\n\n                a = dst[offset + x + 7 * stride] - dst[offset + x + 6 * stride];\n                b = dst[offset + x + 8 * stride] - dst[offset + x + 7 * stride];\n                c = dst[offset + x + 9 * stride] - dst[offset + x + 8 * stride];\n\n                d = FFABS(b) - ((FFABS(a) + FFABS(c) + 1) >> 1);\n                d = FFMAX(d, 0);\n                if (b < 0)\n                    d = -d;\n\n                if (d == 0)\n                    continue;\n\n                if (!(top_damage && bottom_damage))\n                    d = d * 16 / 9;\n\n                if (top_damage) {\n                    dst[offset + x +  7 * stride] = cm[dst[offset + x +  7 * stride] + ((d * 7) >> 4)];\n                    dst[offset + x +  6 * stride] = cm[dst[offset + x +  6 * stride] + ((d * 5) >> 4)];\n                    dst[offset + x +  5 * stride] = cm[dst[offset + x +  5 * stride] + ((d * 3) >> 4)];\n                    dst[offset + x +  4 * stride] = cm[dst[offset + x +  4 * stride] + ((d * 1) >> 4)];\n                }\n                if (bottom_damage) {\n                    dst[offset + x +  8 * stride] = cm[dst[offset + x +  8 * stride] - ((d * 7) >> 4)];\n                    dst[offset + x +  9 * stride] = cm[dst[offset + x +  9 * stride] - ((d * 5) >> 4)];\n                    dst[offset + x + 10 * stride] = cm[dst[offset + x + 10 * stride] - ((d * 3) >> 4)];\n                    dst[offset + x + 11 * stride] = cm[dst[offset + x + 11 * stride] - ((d * 1) >> 4)];\n                }\n            }\n        }\n    }\n}\n\n#define MV_FROZEN    8\n#define MV_CHANGED   4\n#define MV_UNCHANGED 2\n#define MV_LISTED    1\nstatic av_always_inline void add_blocklist(int (*blocklist)[2], int *blocklist_length, uint8_t *fixed, int mb_x, int mb_y, int mb_xy)\n{\n    if (fixed[mb_xy])\n        return;\n    fixed[mb_xy] = MV_LISTED;\n    blocklist[ *blocklist_length   ][0] = mb_x;\n    blocklist[(*blocklist_length)++][1] = mb_y;\n}\n\nstatic void guess_mv(ERContext *s)\n{\n    int (*blocklist)[2], (*next_blocklist)[2];\n    uint8_t *fixed;\n    const ptrdiff_t mb_stride = s->mb_stride;\n    const int mb_width  = s->mb_width;\n    int mb_height = s->mb_height;\n    int i, depth, num_avail;\n    int mb_x, mb_y;\n    ptrdiff_t mot_step, mot_stride;\n    int blocklist_length, next_blocklist_length;\n\n    if (s->last_pic.f && s->last_pic.f->data[0])\n        mb_height = FFMIN(mb_height, (s->last_pic.f->height+15)>>4);\n    if (s->next_pic.f && s->next_pic.f->data[0])\n        mb_height = FFMIN(mb_height, (s->next_pic.f->height+15)>>4);\n\n    blocklist      = (int (*)[2])s->er_temp_buffer;\n    next_blocklist = blocklist + s->mb_stride * s->mb_height;\n    fixed          = (uint8_t *)(next_blocklist + s->mb_stride * s->mb_height);\n\n    set_mv_strides(s, &mot_step, &mot_stride);\n\n    num_avail = 0;\n    if (s->last_pic.motion_val[0])\n        ff_thread_await_progress(s->last_pic.tf, mb_height-1, 0);\n    for (i = 0; i < mb_width * mb_height; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int f = 0;\n        int error = s->error_status_table[mb_xy];\n\n        if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n            f = MV_FROZEN; // intra // FIXME check\n        if (!(error & ER_MV_ERROR))\n            f = MV_FROZEN; // inter with undamaged MV\n\n        fixed[mb_xy] = f;\n        if (f == MV_FROZEN)\n            num_avail++;\n        else if(s->last_pic.f->data[0] && s->last_pic.motion_val[0]){\n            const int mb_y= mb_xy / s->mb_stride;\n            const int mb_x= mb_xy % s->mb_stride;\n            const int mot_index= (mb_x + mb_y*mot_stride) * mot_step;\n            s->cur_pic.motion_val[0][mot_index][0]= s->last_pic.motion_val[0][mot_index][0];\n            s->cur_pic.motion_val[0][mot_index][1]= s->last_pic.motion_val[0][mot_index][1];\n            s->cur_pic.ref_index[0][4*mb_xy]      = s->last_pic.ref_index[0][4*mb_xy];\n        }\n    }\n\n    if ((!(s->avctx->error_concealment&FF_EC_GUESS_MVS)) ||\n        num_avail <= mb_width / 2) {\n        for (mb_y = 0; mb_y < mb_height; mb_y++) {\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n                const int mb_xy = mb_x + mb_y * s->mb_stride;\n                int mv_dir = (s->last_pic.f && s->last_pic.f->data[0]) ? MV_DIR_FORWARD : MV_DIR_BACKWARD;\n\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n                    continue;\n                if (!(s->error_status_table[mb_xy] & ER_MV_ERROR))\n                    continue;\n\n                s->mv[0][0][0] = 0;\n                s->mv[0][0][1] = 0;\n                s->decode_mb(s->opaque, 0, mv_dir, MV_TYPE_16X16, &s->mv,\n                             mb_x, mb_y, 0, 0);\n            }\n        }\n        return;\n    }\n\n    blocklist_length = 0;\n    for (mb_y = 0; mb_y < mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < mb_width; mb_x++) {\n            const int mb_xy = mb_x + mb_y * mb_stride;\n            if (fixed[mb_xy] == MV_FROZEN) {\n                if (mb_x)               add_blocklist(blocklist, &blocklist_length, fixed, mb_x - 1, mb_y, mb_xy - 1);\n                if (mb_y)               add_blocklist(blocklist, &blocklist_length, fixed, mb_x, mb_y - 1, mb_xy - mb_stride);\n                if (mb_x+1 < mb_width)  add_blocklist(blocklist, &blocklist_length, fixed, mb_x + 1, mb_y, mb_xy + 1);\n                if (mb_y+1 < mb_height) add_blocklist(blocklist, &blocklist_length, fixed, mb_x, mb_y + 1, mb_xy + mb_stride);\n            }\n        }\n    }\n\n    for (depth = 0; ; depth++) {\n        int changed, pass, none_left;\n        int blocklist_index;\n\n        none_left = 1;\n        changed   = 1;\n        for (pass = 0; (changed || pass < 2) && pass < 10; pass++) {\n            int score_sum = 0;\n\n            changed = 0;\n            for (blocklist_index = 0; blocklist_index < blocklist_length; blocklist_index++) {\n                const int mb_x = blocklist[blocklist_index][0];\n                const int mb_y = blocklist[blocklist_index][1];\n                const int mb_xy = mb_x + mb_y * mb_stride;\n                int mv_predictor[8][2];\n                int ref[8];\n                int pred_count;\n                int j;\n                int best_score;\n                int best_pred;\n                int mot_index;\n                int prev_x, prev_y, prev_ref;\n\n                if ((mb_x ^ mb_y ^ pass) & 1)\n                    continue;\n                av_assert2(fixed[mb_xy] != MV_FROZEN);\n\n\n                av_assert1(!IS_INTRA(s->cur_pic.mb_type[mb_xy]));\n                av_assert1(s->last_pic.f && s->last_pic.f->data[0]);\n\n                j = 0;\n                if (mb_x > 0)\n                    j |= fixed[mb_xy - 1];\n                if (mb_x + 1 < mb_width)\n                    j |= fixed[mb_xy + 1];\n                if (mb_y > 0)\n                    j |= fixed[mb_xy - mb_stride];\n                if (mb_y + 1 < mb_height)\n                    j |= fixed[mb_xy + mb_stride];\n\n                av_assert2(j & MV_FROZEN);\n\n                if (!(j & MV_CHANGED) && pass > 1)\n                    continue;\n\n                none_left = 0;\n                pred_count = 0;\n                mot_index  = (mb_x + mb_y * mot_stride) * mot_step;\n\n                if (mb_x > 0 && fixed[mb_xy - 1] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index - mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index - mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy - 1)];\n                    pred_count++;\n                }\n                if (mb_x + 1 < mb_width && fixed[mb_xy + 1] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index + mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index + mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy + 1)];\n                    pred_count++;\n                }\n                if (mb_y > 0 && fixed[mb_xy - mb_stride] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index - mot_stride * mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index - mot_stride * mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy - s->mb_stride)];\n                    pred_count++;\n                }\n                if (mb_y + 1<mb_height && fixed[mb_xy + mb_stride] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index + mot_stride * mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index + mot_stride * mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy + s->mb_stride)];\n                    pred_count++;\n                }\n                if (pred_count == 0)\n                    continue;\n\n                if (pred_count > 1) {\n                    int sum_x = 0, sum_y = 0, sum_r = 0;\n                    int max_x, max_y, min_x, min_y, max_r, min_r;\n\n                    for (j = 0; j < pred_count; j++) {\n                        sum_x += mv_predictor[j][0];\n                        sum_y += mv_predictor[j][1];\n                        sum_r += ref[j];\n                        if (j && ref[j] != ref[j - 1])\n                            goto skip_mean_and_median;\n                    }\n\n                    /* mean */\n                    mv_predictor[pred_count][0] = sum_x / j;\n                    mv_predictor[pred_count][1] = sum_y / j;\n                             ref[pred_count]    = sum_r / j;\n\n                    /* median */\n                    if (pred_count >= 3) {\n                        min_y = min_x = min_r =  99999;\n                        max_y = max_x = max_r = -99999;\n                    } else {\n                        min_x = min_y = max_x = max_y = min_r = max_r = 0;\n                    }\n                    for (j = 0; j < pred_count; j++) {\n                        max_x = FFMAX(max_x, mv_predictor[j][0]);\n                        max_y = FFMAX(max_y, mv_predictor[j][1]);\n                        max_r = FFMAX(max_r, ref[j]);\n                        min_x = FFMIN(min_x, mv_predictor[j][0]);\n                        min_y = FFMIN(min_y, mv_predictor[j][1]);\n                        min_r = FFMIN(min_r, ref[j]);\n                    }\n                    mv_predictor[pred_count + 1][0] = sum_x - max_x - min_x;\n                    mv_predictor[pred_count + 1][1] = sum_y - max_y - min_y;\n                             ref[pred_count + 1]    = sum_r - max_r - min_r;\n\n                    if (pred_count == 4) {\n                        mv_predictor[pred_count + 1][0] /= 2;\n                        mv_predictor[pred_count + 1][1] /= 2;\n                                 ref[pred_count + 1]    /= 2;\n                    }\n                    pred_count += 2;\n                }\n\nskip_mean_and_median:\n                /* zero MV */\n                mv_predictor[pred_count][0] =\n                mv_predictor[pred_count][1] =\n                         ref[pred_count]    = 0;\n                pred_count++;\n\n                prev_x   = s->cur_pic.motion_val[0][mot_index][0];\n                prev_y   = s->cur_pic.motion_val[0][mot_index][1];\n                prev_ref = s->cur_pic.ref_index[0][4 * mb_xy];\n\n                /* last MV */\n                mv_predictor[pred_count][0] = prev_x;\n                mv_predictor[pred_count][1] = prev_y;\n                         ref[pred_count]    = prev_ref;\n                pred_count++;\n\n                best_pred = 0;\n                best_score = 256 * 256 * 256 * 64;\n                for (j = 0; j < pred_count; j++) {\n                    int *linesize = s->cur_pic.f->linesize;\n                    int score = 0;\n                    uint8_t *src = s->cur_pic.f->data[0] +\n                                   mb_x * 16 + mb_y * 16 * linesize[0];\n\n                    s->cur_pic.motion_val[0][mot_index][0] =\n                        s->mv[0][0][0] = mv_predictor[j][0];\n                    s->cur_pic.motion_val[0][mot_index][1] =\n                        s->mv[0][0][1] = mv_predictor[j][1];\n\n                    // predictor intra or otherwise not available\n                    if (ref[j] < 0)\n                        continue;\n\n                    s->decode_mb(s->opaque, ref[j], MV_DIR_FORWARD,\n                                 MV_TYPE_16X16, &s->mv, mb_x, mb_y, 0, 0);\n\n                    if (mb_x > 0 && fixed[mb_xy - 1] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k * linesize[0] - 1] -\n                                           src[k * linesize[0]]);\n                    }\n                    if (mb_x + 1 < mb_width && fixed[mb_xy + 1] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k * linesize[0] + 15] -\n                                           src[k * linesize[0] + 16]);\n                    }\n                    if (mb_y > 0 && fixed[mb_xy - mb_stride] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k - linesize[0]] - src[k]);\n                    }\n                    if (mb_y + 1 < mb_height && fixed[mb_xy + mb_stride] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k + linesize[0] * 15] -\n                                           src[k + linesize[0] * 16]);\n                    }\n\n                    if (score <= best_score) { // <= will favor the last MV\n                        best_score = score;\n                        best_pred  = j;\n                    }\n                }\n                score_sum += best_score;\n                s->mv[0][0][0] = mv_predictor[best_pred][0];\n                s->mv[0][0][1] = mv_predictor[best_pred][1];\n\n                for (i = 0; i < mot_step; i++)\n                    for (j = 0; j < mot_step; j++) {\n                        s->cur_pic.motion_val[0][mot_index + i + j * mot_stride][0] = s->mv[0][0][0];\n                        s->cur_pic.motion_val[0][mot_index + i + j * mot_stride][1] = s->mv[0][0][1];\n                    }\n\n                s->decode_mb(s->opaque, ref[best_pred], MV_DIR_FORWARD,\n                             MV_TYPE_16X16, &s->mv, mb_x, mb_y, 0, 0);\n\n\n                if (s->mv[0][0][0] != prev_x || s->mv[0][0][1] != prev_y) {\n                    fixed[mb_xy] = MV_CHANGED;\n                    changed++;\n                } else\n                    fixed[mb_xy] = MV_UNCHANGED;\n            }\n        }\n\n        if (none_left)\n            return;\n\n        next_blocklist_length = 0;\n\n        for (blocklist_index = 0; blocklist_index < blocklist_length; blocklist_index++) {\n            const int mb_x = blocklist[blocklist_index][0];\n            const int mb_y = blocklist[blocklist_index][1];\n            const int mb_xy = mb_x + mb_y * mb_stride;\n\n            if (fixed[mb_xy] & (MV_CHANGED|MV_UNCHANGED|MV_FROZEN)) {\n                fixed[mb_xy] = MV_FROZEN;\n                if (mb_x > 0)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x - 1, mb_y, mb_xy - 1);\n                if (mb_y > 0)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x, mb_y - 1, mb_xy - mb_stride);\n                if (mb_x + 1 < mb_width)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x + 1, mb_y, mb_xy + 1);\n                if (mb_y + 1 < mb_height)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x, mb_y + 1, mb_xy + mb_stride);\n            }\n        }\n        av_assert0(next_blocklist_length <= mb_height * mb_width);\n        FFSWAP(int , blocklist_length, next_blocklist_length);\n        FFSWAP(void*, blocklist, next_blocklist);\n    }\n}\n\nstatic int is_intra_more_likely(ERContext *s)\n{\n    int is_intra_likely, i, j, undamaged_count, skip_amount, mb_x, mb_y;\n\n    if (!s->last_pic.f || !s->last_pic.f->data[0])\n        return 1; // no previous frame available -> use spatial prediction\n\n    if (s->avctx->error_concealment & FF_EC_FAVOR_INTER)\n        return 0;\n\n    undamaged_count = 0;\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        const int error = s->error_status_table[mb_xy];\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n            undamaged_count++;\n    }\n\n    if (undamaged_count < 5)\n        return 0; // almost all MBs damaged -> use temporal prediction\n\n    // prevent dsp.sad() check, that requires access to the image\n    if (CONFIG_XVMC    &&\n        s->avctx->hwaccel && s->avctx->hwaccel->decode_mb &&\n        s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I)\n        return 1;\n\n    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs\n    is_intra_likely = 0;\n\n    j = 0;\n    for (mb_y = 0; mb_y < s->mb_height - 1; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            int error;\n            const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n            error = s->error_status_table[mb_xy];\n            if ((error & ER_DC_ERROR) && (error & ER_MV_ERROR))\n                continue; // skip damaged\n\n            j++;\n            // skip a few to speed things up\n            if ((j % skip_amount) != 0)\n                continue;\n\n            if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I) {\n                int *linesize = s->cur_pic.f->linesize;\n                uint8_t *mb_ptr      = s->cur_pic.f->data[0] +\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n                uint8_t *last_mb_ptr = s->last_pic.f->data[0] +\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n                if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n                    // FIXME\n                } else {\n                    ff_thread_await_progress(s->last_pic.tf, mb_y, 0);\n                }\n                is_intra_likely += s->mecc.sad[0](NULL, last_mb_ptr, mb_ptr,\n                                                  linesize[0], 16);\n                // FIXME need await_progress() here\n                is_intra_likely -= s->mecc.sad[0](NULL, last_mb_ptr,\n                                                  last_mb_ptr + linesize[0] * 16,\n                                                  linesize[0], 16);\n            } else {\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n                   is_intra_likely++;\n                else\n                   is_intra_likely--;\n            }\n        }\n    }\n//      av_log(NULL, AV_LOG_ERROR, \"is_intra_likely: %d type:%d\\n\", is_intra_likely, s->pict_type);\n    return is_intra_likely > 0;\n}\n\nvoid ff_er_frame_start(ERContext *s)\n{\n    if (!s->avctx->error_concealment)\n        return;\n\n    if (!s->mecc_inited) {\n        ff_me_cmp_init(&s->mecc, s->avctx);\n        s->mecc_inited = 1;\n    }\n\n    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n           s->mb_stride * s->mb_height * sizeof(uint8_t));\n    atomic_init(&s->error_count, 3 * s->mb_num);\n    s->error_occurred = 0;\n}\n\nstatic int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}\n\n/**\n * Add a slice.\n * @param endx   x component of the last macroblock, can be -1\n *               for the last of the previous line\n * @param status the status at the end (ER_MV_END, ER_AC_ERROR, ...), it is\n *               assumed that no earlier end or error of the same type occurred\n */\nvoid ff_er_add_slice(ERContext *s, int startx, int starty,\n                     int endx, int endy, int status)\n{\n    const int start_i  = av_clip(startx + starty * s->mb_width, 0, s->mb_num - 1);\n    const int end_i    = av_clip(endx   + endy   * s->mb_width, 0, s->mb_num);\n    const int start_xy = s->mb_index2xy[start_i];\n    const int end_xy   = s->mb_index2xy[end_i];\n    int mask           = -1;\n\n    if (s->avctx->hwaccel && s->avctx->hwaccel->decode_slice)\n        return;\n\n    if (start_i > end_i || start_xy > end_xy) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"internal error, slice end before start\\n\");\n        return;\n    }\n\n    if (!s->avctx->error_concealment)\n        return;\n\n    mask &= ~VP_START;\n    if (status & (ER_AC_ERROR | ER_AC_END)) {\n        mask           &= ~(ER_AC_ERROR | ER_AC_END);\n        atomic_fetch_add(&s->error_count, start_i - end_i - 1);\n    }\n    if (status & (ER_DC_ERROR | ER_DC_END)) {\n        mask           &= ~(ER_DC_ERROR | ER_DC_END);\n        atomic_fetch_add(&s->error_count, start_i - end_i - 1);\n    }\n    if (status & (ER_MV_ERROR | ER_MV_END)) {\n        mask           &= ~(ER_MV_ERROR | ER_MV_END);\n        atomic_fetch_add(&s->error_count, start_i - end_i - 1);\n    }\n\n    if (status & ER_MB_ERROR) {\n        s->error_occurred = 1;\n        atomic_store(&s->error_count, INT_MAX);\n    }\n\n    if (mask == ~0x7F) {\n        memset(&s->error_status_table[start_xy], 0,\n               (end_xy - start_xy) * sizeof(uint8_t));\n    } else {\n        int i;\n        for (i = start_xy; i < end_xy; i++)\n            s->error_status_table[i] &= mask;\n    }\n\n    if (end_i == s->mb_num)\n        atomic_store(&s->error_count, INT_MAX);\n    else {\n        s->error_status_table[end_xy] &= mask;\n        s->error_status_table[end_xy] |= status;\n    }\n\n    s->error_status_table[start_xy] |= VP_START;\n\n    if (start_xy > 0 && !(s->avctx->active_thread_type & FF_THREAD_SLICE) &&\n        er_supported(s) && s->avctx->skip_top * s->mb_width < start_i) {\n        int prev_status = s->error_status_table[s->mb_index2xy[start_i - 1]];\n\n        prev_status &= ~ VP_START;\n        if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END)) {\n            s->error_occurred = 1;\n            atomic_store(&s->error_count, INT_MAX);\n        }\n    }\n}\n\nvoid ff_er_frame_end(ERContext *s)\n{\n    int *linesize = NULL;\n    int i, mb_x, mb_y, error, error_type, dc_error, mv_error, ac_error;\n    int distance;\n    int threshold_part[4] = { 100, 100, 100 };\n    int threshold = 50;\n    int is_intra_likely;\n    int size = s->b8_stride * 2 * s->mb_height;\n\n    /* We do not support ER of field pictures yet,\n     * though it should not crash if enabled. */\n    if (!s->avctx->error_concealment || !atomic_load(&s->error_count)  ||\n        s->avctx->lowres                                               ||\n        !er_supported(s)                                               ||\n        atomic_load(&s->error_count) == 3 * s->mb_width *\n                          (s->avctx->skip_top + s->avctx->skip_bottom)) {\n        return;\n    }\n    linesize = s->cur_pic.f->linesize;\n    for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n        int status = s->error_status_table[mb_x + (s->mb_height - 1) * s->mb_stride];\n        if (status != 0x7F)\n            break;\n    }\n\n    if (   mb_x == s->mb_width\n        && s->avctx->codec_id == AV_CODEC_ID_MPEG2VIDEO\n        && (FFALIGN(s->avctx->height, 16)&16)\n        && atomic_load(&s->error_count) == 3 * s->mb_width * (s->avctx->skip_top + s->avctx->skip_bottom + 1)\n    ) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"ignoring last missing slice\\n\");\n        return;\n    }\n\n    if (s->last_pic.f) {\n        if (s->last_pic.f->width  != s->cur_pic.f->width  ||\n            s->last_pic.f->height != s->cur_pic.f->height ||\n            s->last_pic.f->format != s->cur_pic.f->format) {\n            av_log(s->avctx, AV_LOG_WARNING, \"Cannot use previous picture in error concealment\\n\");\n            memset(&s->last_pic, 0, sizeof(s->last_pic));\n        }\n    }\n    if (s->next_pic.f) {\n        if (s->next_pic.f->width  != s->cur_pic.f->width  ||\n            s->next_pic.f->height != s->cur_pic.f->height ||\n            s->next_pic.f->format != s->cur_pic.f->format) {\n            av_log(s->avctx, AV_LOG_WARNING, \"Cannot use next picture in error concealment\\n\");\n            memset(&s->next_pic, 0, sizeof(s->next_pic));\n        }\n    }\n\n    if (!s->cur_pic.motion_val[0] || !s->cur_pic.ref_index[0]) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Warning MVs not available\\n\");\n\n        for (i = 0; i < 2; i++) {\n            s->ref_index_buf[i]  = av_buffer_allocz(s->mb_stride * s->mb_height * 4 * sizeof(uint8_t));\n            s->motion_val_buf[i] = av_buffer_allocz((size + 4) * 2 * sizeof(uint16_t));\n            if (!s->ref_index_buf[i] || !s->motion_val_buf[i])\n                break;\n            s->cur_pic.ref_index[i]  = s->ref_index_buf[i]->data;\n            s->cur_pic.motion_val[i] = (int16_t (*)[2])s->motion_val_buf[i]->data + 4;\n        }\n        if (i < 2) {\n            for (i = 0; i < 2; i++) {\n                av_buffer_unref(&s->ref_index_buf[i]);\n                av_buffer_unref(&s->motion_val_buf[i]);\n                s->cur_pic.ref_index[i]  = NULL;\n                s->cur_pic.motion_val[i] = NULL;\n            }\n            return;\n        }\n    }\n\n    if (s->avctx->debug & FF_DEBUG_ER) {\n        for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n                int status = s->error_status_table[mb_x + mb_y * s->mb_stride];\n\n                av_log(s->avctx, AV_LOG_DEBUG, \"%2X \", status);\n            }\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        }\n    }\n\n#if 1\n    /* handle overlapping slices */\n    for (error_type = 1; error_type <= 3; error_type++) {\n        int end_ok = 0;\n\n        for (i = s->mb_num - 1; i >= 0; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error       = s->error_status_table[mb_xy];\n\n            if (error & (1 << error_type))\n                end_ok = 1;\n            if (error & (8 << error_type))\n                end_ok = 1;\n\n            if (!end_ok)\n                s->error_status_table[mb_xy] |= 1 << error_type;\n\n            if (error & VP_START)\n                end_ok = 0;\n        }\n    }\n#endif\n#if 1\n    /* handle slices with partitions of different length */\n    if (s->partitioned_frame) {\n        int end_ok = 0;\n\n        for (i = s->mb_num - 1; i >= 0; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error       = s->error_status_table[mb_xy];\n\n            if (error & ER_AC_END)\n                end_ok = 0;\n            if ((error & ER_MV_END) ||\n                (error & ER_DC_END) ||\n                (error & ER_AC_ERROR))\n                end_ok = 1;\n\n            if (!end_ok)\n                s->error_status_table[mb_xy]|= ER_AC_ERROR;\n\n            if (error & VP_START)\n                end_ok = 0;\n        }\n    }\n#endif\n    /* handle missing slices */\n    if (s->avctx->err_recognition & AV_EF_EXPLODE) {\n        int end_ok = 1;\n\n        // FIXME + 100 hack\n        for (i = s->mb_num - 2; i >= s->mb_width + 100; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error1 = s->error_status_table[mb_xy];\n            int error2 = s->error_status_table[s->mb_index2xy[i + 1]];\n\n            if (error1 & VP_START)\n                end_ok = 1;\n\n            if (error2 == (VP_START | ER_MB_ERROR | ER_MB_END) &&\n                error1 != (VP_START | ER_MB_ERROR | ER_MB_END) &&\n                ((error1 & ER_AC_END) || (error1 & ER_DC_END) ||\n                (error1 & ER_MV_END))) {\n                // end & uninit\n                end_ok = 0;\n            }\n\n            if (!end_ok)\n                s->error_status_table[mb_xy] |= ER_MB_ERROR;\n        }\n    }\n\n#if 1\n    /* backward mark errors */\n    distance = 9999999;\n    for (error_type = 1; error_type <= 3; error_type++) {\n        for (i = s->mb_num - 1; i >= 0; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int       error = s->error_status_table[mb_xy];\n\n            if (!s->mbskip_table || !s->mbskip_table[mb_xy]) // FIXME partition specific\n                distance++;\n            if (error & (1 << error_type))\n                distance = 0;\n\n            if (s->partitioned_frame) {\n                if (distance < threshold_part[error_type - 1])\n                    s->error_status_table[mb_xy] |= 1 << error_type;\n            } else {\n                if (distance < threshold)\n                    s->error_status_table[mb_xy] |= 1 << error_type;\n            }\n\n            if (error & VP_START)\n                distance = 9999999;\n        }\n    }\n#endif\n\n    /* forward mark errors */\n    error = 0;\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int old_error   = s->error_status_table[mb_xy];\n\n        if (old_error & VP_START) {\n            error = old_error & ER_MB_ERROR;\n        } else {\n            error |= old_error & ER_MB_ERROR;\n            s->error_status_table[mb_xy] |= error;\n        }\n    }\n#if 1\n    /* handle not partitioned case */\n    if (!s->partitioned_frame) {\n        for (i = 0; i < s->mb_num; i++) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error = s->error_status_table[mb_xy];\n            if (error & ER_MB_ERROR)\n                error |= ER_MB_ERROR;\n            s->error_status_table[mb_xy] = error;\n        }\n    }\n#endif\n\n    dc_error = ac_error = mv_error = 0;\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int error = s->error_status_table[mb_xy];\n        if (error & ER_DC_ERROR)\n            dc_error++;\n        if (error & ER_AC_ERROR)\n            ac_error++;\n        if (error & ER_MV_ERROR)\n            mv_error++;\n    }\n    av_log(s->avctx, AV_LOG_INFO, \"concealing %d DC, %d AC, %d MV errors in %c frame\\n\",\n           dc_error, ac_error, mv_error, av_get_picture_type_char(s->cur_pic.f->pict_type));\n\n    is_intra_likely = is_intra_more_likely(s);\n\n    /* set unknown mb-type to most likely */\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int error = s->error_status_table[mb_xy];\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n            continue;\n\n        if (is_intra_likely)\n            s->cur_pic.mb_type[mb_xy] = MB_TYPE_INTRA4x4;\n        else\n            s->cur_pic.mb_type[mb_xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n    }\n\n    // change inter to intra blocks if no reference frames are available\n    if (!(s->last_pic.f && s->last_pic.f->data[0]) &&\n        !(s->next_pic.f && s->next_pic.f->data[0]))\n        for (i = 0; i < s->mb_num; i++) {\n            const int mb_xy = s->mb_index2xy[i];\n            if (!IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n                s->cur_pic.mb_type[mb_xy] = MB_TYPE_INTRA4x4;\n        }\n\n    /* handle inter blocks with damaged AC */\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            const int mb_xy   = mb_x + mb_y * s->mb_stride;\n            const int mb_type = s->cur_pic.mb_type[mb_xy];\n            const int dir     = !(s->last_pic.f && s->last_pic.f->data[0]);\n            const int mv_dir  = dir ? MV_DIR_BACKWARD : MV_DIR_FORWARD;\n            int mv_type;\n\n            int error = s->error_status_table[mb_xy];\n\n            if (IS_INTRA(mb_type))\n                continue; // intra\n            if (error & ER_MV_ERROR)\n                continue; // inter with damaged MV\n            if (!(error & ER_AC_ERROR))\n                continue; // undamaged inter\n\n            if (IS_8X8(mb_type)) {\n                int mb_index = mb_x * 2 + mb_y * 2 * s->b8_stride;\n                int j;\n                mv_type = MV_TYPE_8X8;\n                for (j = 0; j < 4; j++) {\n                    s->mv[0][j][0] = s->cur_pic.motion_val[dir][mb_index + (j & 1) + (j >> 1) * s->b8_stride][0];\n                    s->mv[0][j][1] = s->cur_pic.motion_val[dir][mb_index + (j & 1) + (j >> 1) * s->b8_stride][1];\n                }\n            } else {\n                mv_type     = MV_TYPE_16X16;\n                s->mv[0][0][0] = s->cur_pic.motion_val[dir][mb_x * 2 + mb_y * 2 * s->b8_stride][0];\n                s->mv[0][0][1] = s->cur_pic.motion_val[dir][mb_x * 2 + mb_y * 2 * s->b8_stride][1];\n            }\n\n            s->decode_mb(s->opaque, 0 /* FIXME H.264 partitioned slices need this set */,\n                         mv_dir, mv_type, &s->mv, mb_x, mb_y, 0, 0);\n        }\n    }\n\n    /* guess MVs */\n    if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_B) {\n        for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n                int       xy      = mb_x * 2 + mb_y * 2 * s->b8_stride;\n                const int mb_xy   = mb_x + mb_y * s->mb_stride;\n                const int mb_type = s->cur_pic.mb_type[mb_xy];\n                int mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD;\n\n                int error = s->error_status_table[mb_xy];\n\n                if (IS_INTRA(mb_type))\n                    continue;\n                if (!(error & ER_MV_ERROR))\n                    continue; // inter with undamaged MV\n                if (!(error & ER_AC_ERROR))\n                    continue; // undamaged inter\n\n                if (!(s->last_pic.f && s->last_pic.f->data[0]))\n                    mv_dir &= ~MV_DIR_FORWARD;\n                if (!(s->next_pic.f && s->next_pic.f->data[0]))\n                    mv_dir &= ~MV_DIR_BACKWARD;\n\n                if (s->pp_time) {\n                    int time_pp = s->pp_time;\n                    int time_pb = s->pb_time;\n\n                    av_assert0(s->avctx->codec_id != AV_CODEC_ID_H264);\n                    ff_thread_await_progress(s->next_pic.tf, mb_y, 0);\n\n                    s->mv[0][0][0] = s->next_pic.motion_val[0][xy][0] *  time_pb            / time_pp;\n                    s->mv[0][0][1] = s->next_pic.motion_val[0][xy][1] *  time_pb            / time_pp;\n                    s->mv[1][0][0] = s->next_pic.motion_val[0][xy][0] * (time_pb - time_pp) / time_pp;\n                    s->mv[1][0][1] = s->next_pic.motion_val[0][xy][1] * (time_pb - time_pp) / time_pp;\n                } else {\n                    s->mv[0][0][0] = 0;\n                    s->mv[0][0][1] = 0;\n                    s->mv[1][0][0] = 0;\n                    s->mv[1][0][1] = 0;\n                }\n\n                s->decode_mb(s->opaque, 0, mv_dir, MV_TYPE_16X16, &s->mv,\n                             mb_x, mb_y, 0, 0);\n            }\n        }\n    } else\n        guess_mv(s);\n\n    /* the filters below manipulate raw image, skip them */\n    if (CONFIG_XVMC && s->avctx->hwaccel && s->avctx->hwaccel->decode_mb)\n        goto ec_clean;\n    /* fill DC for inter blocks */\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            int dc, dcu, dcv, y, n;\n            int16_t *dc_ptr;\n            uint8_t *dest_y, *dest_cb, *dest_cr;\n            const int mb_xy   = mb_x + mb_y * s->mb_stride;\n            const int mb_type = s->cur_pic.mb_type[mb_xy];\n\n            // error = s->error_status_table[mb_xy];\n\n            if (IS_INTRA(mb_type) && s->partitioned_frame)\n                continue;\n            // if (error & ER_MV_ERROR)\n            //     continue; // inter data damaged FIXME is this good?\n\n            dest_y  = s->cur_pic.f->data[0] + mb_x * 16 + mb_y * 16 * linesize[0];\n            dest_cb = s->cur_pic.f->data[1] + mb_x *  8 + mb_y *  8 * linesize[1];\n            dest_cr = s->cur_pic.f->data[2] + mb_x *  8 + mb_y *  8 * linesize[2];\n\n            dc_ptr = &s->dc_val[0][mb_x * 2 + mb_y * 2 * s->b8_stride];\n            for (n = 0; n < 4; n++) {\n                dc = 0;\n                for (y = 0; y < 8; y++) {\n                    int x;\n                    for (x = 0; x < 8; x++)\n                       dc += dest_y[x + (n & 1) * 8 +\n                             (y + (n >> 1) * 8) * linesize[0]];\n                }\n                dc_ptr[(n & 1) + (n >> 1) * s->b8_stride] = (dc + 4) >> 3;\n            }\n\n            if (!s->cur_pic.f->data[2])\n                continue;\n\n            dcu = dcv = 0;\n            for (y = 0; y < 8; y++) {\n                int x;\n                for (x = 0; x < 8; x++) {\n                    dcu += dest_cb[x + y * linesize[1]];\n                    dcv += dest_cr[x + y * linesize[2]];\n                }\n            }\n            s->dc_val[1][mb_x + mb_y * s->mb_stride] = (dcu + 4) >> 3;\n            s->dc_val[2][mb_x + mb_y * s->mb_stride] = (dcv + 4) >> 3;\n        }\n    }\n#if 1\n    /* guess DC for damaged blocks */\n    guess_dc(s, s->dc_val[0], s->mb_width*2, s->mb_height*2, s->b8_stride, 1);\n    guess_dc(s, s->dc_val[1], s->mb_width  , s->mb_height  , s->mb_stride, 0);\n    guess_dc(s, s->dc_val[2], s->mb_width  , s->mb_height  , s->mb_stride, 0);\n#endif\n\n    /* filter luma DC */\n    filter181(s->dc_val[0], s->mb_width * 2, s->mb_height * 2, s->b8_stride);\n\n#if 1\n    /* render DC only intra */\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            uint8_t *dest_y, *dest_cb, *dest_cr;\n            const int mb_xy   = mb_x + mb_y * s->mb_stride;\n            const int mb_type = s->cur_pic.mb_type[mb_xy];\n\n            int error = s->error_status_table[mb_xy];\n\n            if (IS_INTER(mb_type))\n                continue;\n            if (!(error & ER_AC_ERROR))\n                continue; // undamaged\n\n            dest_y  = s->cur_pic.f->data[0] + mb_x * 16 + mb_y * 16 * linesize[0];\n            dest_cb = s->cur_pic.f->data[1] + mb_x *  8 + mb_y *  8 * linesize[1];\n            dest_cr = s->cur_pic.f->data[2] + mb_x *  8 + mb_y *  8 * linesize[2];\n            if (!s->cur_pic.f->data[2])\n                dest_cb = dest_cr = NULL;\n\n            put_dc(s, dest_y, dest_cb, dest_cr, mb_x, mb_y);\n        }\n    }\n#endif\n\n    if (s->avctx->error_concealment & FF_EC_DEBLOCK) {\n        /* filter horizontal block boundaries */\n        h_block_filter(s, s->cur_pic.f->data[0], s->mb_width * 2,\n                       s->mb_height * 2, linesize[0], 1);\n\n        /* filter vertical block boundaries */\n        v_block_filter(s, s->cur_pic.f->data[0], s->mb_width * 2,\n                       s->mb_height * 2, linesize[0], 1);\n\n        if (s->cur_pic.f->data[2]) {\n            h_block_filter(s, s->cur_pic.f->data[1], s->mb_width,\n                        s->mb_height, linesize[1], 0);\n            h_block_filter(s, s->cur_pic.f->data[2], s->mb_width,\n                        s->mb_height, linesize[2], 0);\n            v_block_filter(s, s->cur_pic.f->data[1], s->mb_width,\n                        s->mb_height, linesize[1], 0);\n            v_block_filter(s, s->cur_pic.f->data[2], s->mb_width,\n                        s->mb_height, linesize[2], 0);\n        }\n    }\n\nec_clean:\n    /* clean a few tables */\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int       error = s->error_status_table[mb_xy];\n\n        if (s->mbskip_table && s->cur_pic.f->pict_type != AV_PICTURE_TYPE_B &&\n            (error & (ER_DC_ERROR | ER_MV_ERROR | ER_AC_ERROR))) {\n            s->mbskip_table[mb_xy] = 0;\n        }\n        if (s->mbintra_table)\n            s->mbintra_table[mb_xy] = 1;\n    }\n\n    for (i = 0; i < 2; i++) {\n        av_buffer_unref(&s->ref_index_buf[i]);\n        av_buffer_unref(&s->motion_val_buf[i]);\n        s->cur_pic.ref_index[i]  = NULL;\n        s->cur_pic.motion_val[i] = NULL;\n    }\n\n    memset(&s->cur_pic, 0, sizeof(ERPicture));\n    memset(&s->last_pic, 0, sizeof(ERPicture));\n    memset(&s->next_pic, 0, sizeof(ERPicture));\n}\n", "/*\n * H.263 decoder\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * H.263 decoder.\n */\n\n#define UNCHECKED_BITSTREAM_READER 1\n\n#include \"libavutil/cpu.h\"\n#include \"avcodec.h\"\n#include \"error_resilience.h\"\n#include \"flv.h\"\n#include \"h263.h\"\n#include \"h263_parser.h\"\n#include \"hwaccel.h\"\n#include \"internal.h\"\n#include \"mpeg_er.h\"\n#include \"mpeg4video.h\"\n#include \"mpeg4video_parser.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"msmpeg4.h\"\n#include \"qpeldsp.h\"\n#include \"thread.h\"\n#include \"wmv2.h\"\n\nstatic enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    /* MPEG-4 Studio Profile only, not supported by hardware */\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}\n\nav_cold int ff_h263_decode_init(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    int ret;\n\n    s->out_format      = FMT_H263;\n\n    // set defaults\n    ff_mpv_decode_defaults(s);\n    ff_mpv_decode_init(s, avctx);\n\n    s->quant_precision = 5;\n    s->decode_mb       = ff_h263_decode_mb;\n    s->low_delay       = 1;\n    s->unrestricted_mv = 1;\n\n    /* select sub codec */\n    switch (avctx->codec->id) {\n    case AV_CODEC_ID_H263:\n    case AV_CODEC_ID_H263P:\n        s->unrestricted_mv = 0;\n        avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;\n        break;\n    case AV_CODEC_ID_MPEG4:\n        break;\n    case AV_CODEC_ID_MSMPEG4V1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 1;\n        break;\n    case AV_CODEC_ID_MSMPEG4V2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 2;\n        break;\n    case AV_CODEC_ID_MSMPEG4V3:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 3;\n        break;\n    case AV_CODEC_ID_WMV1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 4;\n        break;\n    case AV_CODEC_ID_WMV2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 5;\n        break;\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_WMV3:\n    case AV_CODEC_ID_VC1IMAGE:\n    case AV_CODEC_ID_WMV3IMAGE:\n    case AV_CODEC_ID_MSS2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 6;\n        avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n        break;\n    case AV_CODEC_ID_H263I:\n        break;\n    case AV_CODEC_ID_FLV1:\n        s->h263_flv = 1;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec %d\\n\",\n               avctx->codec->id);\n        return AVERROR(ENOSYS);\n    }\n    s->codec_id    = avctx->codec->id;\n\n    if (avctx->codec_tag == AV_RL32(\"L263\") || avctx->codec_tag == AV_RL32(\"S263\"))\n        if (avctx->extradata_size == 56 && avctx->extradata[0] == 1)\n            s->ehc_mode = 1;\n\n    /* for H.263, we allocate the images after having read the header */\n    if (avctx->codec->id != AV_CODEC_ID_H263 &&\n        avctx->codec->id != AV_CODEC_ID_H263P &&\n        avctx->codec->id != AV_CODEC_ID_MPEG4) {\n        avctx->pix_fmt = h263_get_format(avctx);\n        ff_mpv_idct_init(s);\n        if ((ret = ff_mpv_common_init(s)) < 0)\n            return ret;\n    }\n\n    ff_h263dsp_init(&s->h263dsp);\n    ff_qpeldsp_init(&s->qdsp);\n    ff_h263_decode_init_vlc();\n\n    return 0;\n}\n\nav_cold int ff_h263_decode_end(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n\n    ff_mpv_common_end(s);\n    return 0;\n}\n\n/**\n * Return the number of bytes consumed for building the current frame.\n */\nstatic int get_consumed_bytes(MpegEncContext *s, int buf_size)\n{\n    int pos = (get_bits_count(&s->gb) + 7) >> 3;\n\n    if (s->divx_packed || s->avctx->hwaccel) {\n        /* We would have to scan through the whole buf to handle the weird\n         * reordering ... */\n        return buf_size;\n    } else if (s->avctx->flags & AV_CODEC_FLAG_TRUNCATED) {\n        pos -= s->parse_context.last_index;\n        // padding is not really read so this might be -1\n        if (pos < 0)\n            pos = 0;\n        return pos;\n    } else {\n        // avoid infinite loops (maybe not needed...)\n        if (pos == 0)\n            pos = 1;\n        // oops ;)\n        if (pos + 10 > buf_size)\n            pos = buf_size;\n\n        return pos;\n    }\n}\n\nstatic int decode_slice(MpegEncContext *s)\n{\n    const int part_mask = s->partitioned_frame\n                          ? (ER_AC_END | ER_AC_ERROR) : 0x7F;\n    const int mb_size   = 16 >> s->avctx->lowres;\n    int ret;\n\n    s->last_resync_gb   = s->gb;\n    s->first_slice_line = 1;\n    s->resync_mb_x      = s->mb_x;\n    s->resync_mb_y      = s->mb_y;\n\n    ff_set_qscale(s, s->qscale);\n\n    if (s->studio_profile) {\n        if ((ret = ff_mpeg4_decode_studio_slice_header(s->avctx->priv_data)) < 0)\n            return ret;\n    }\n\n    if (s->avctx->hwaccel) {\n        const uint8_t *start = s->gb.buffer + get_bits_count(&s->gb) / 8;\n        ret = s->avctx->hwaccel->decode_slice(s->avctx, start, s->gb.buffer_end - start);\n        // ensure we exit decode loop\n        s->mb_y = s->mb_height;\n        return ret;\n    }\n\n    if (s->partitioned_frame) {\n        const int qscale = s->qscale;\n\n        if (CONFIG_MPEG4_DECODER && s->codec_id == AV_CODEC_ID_MPEG4)\n            if ((ret = ff_mpeg4_decode_partitions(s->avctx->priv_data)) < 0)\n                return ret;\n\n        /* restore variables which were modified */\n        s->first_slice_line = 1;\n        s->mb_x             = s->resync_mb_x;\n        s->mb_y             = s->resync_mb_y;\n        ff_set_qscale(s, qscale);\n    }\n\n    for (; s->mb_y < s->mb_height; s->mb_y++) {\n        /* per-row end of slice checks */\n        if (s->msmpeg4_version) {\n            if (s->resync_mb_y + s->slice_height == s->mb_y) {\n                ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                s->mb_x - 1, s->mb_y, ER_MB_END);\n\n                return 0;\n            }\n        }\n\n        if (s->msmpeg4_version == 1) {\n            s->last_dc[0] =\n            s->last_dc[1] =\n            s->last_dc[2] = 128;\n        }\n\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            int ret;\n\n            ff_update_block_index(s);\n\n            if (s->resync_mb_x == s->mb_x && s->resync_mb_y + 1 == s->mb_y)\n                s->first_slice_line = 0;\n\n            /* DCT & quantize */\n\n            s->mv_dir  = MV_DIR_FORWARD;\n            s->mv_type = MV_TYPE_16X16;\n            ff_dlog(s, \"%d %06X\\n\",\n                    get_bits_count(&s->gb), show_bits(&s->gb, 24));\n\n            ff_tlog(NULL, \"Decoding MB at %dx%d\\n\", s->mb_x, s->mb_y);\n            ret = s->decode_mb(s, s->block);\n\n            if (s->pict_type != AV_PICTURE_TYPE_B)\n                ff_h263_update_motion_val(s);\n\n            if (ret < 0) {\n                const int xy = s->mb_x + s->mb_y * s->mb_stride;\n                if (ret == SLICE_END) {\n                    ff_mpv_reconstruct_mb(s, s->block);\n                    if (s->loop_filter)\n                        ff_h263_loop_filter(s);\n\n                    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                    s->mb_x, s->mb_y, ER_MB_END & part_mask);\n\n                    s->padding_bug_score--;\n\n                    if (++s->mb_x >= s->mb_width) {\n                        s->mb_x = 0;\n                        ff_mpeg_draw_horiz_band(s, s->mb_y * mb_size, mb_size);\n                        ff_mpv_report_decode_progress(s);\n                        s->mb_y++;\n                    }\n                    return 0;\n                } else if (ret == SLICE_NOEND) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Slice mismatch at MB: %d\\n\", xy);\n                    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                    s->mb_x + 1, s->mb_y,\n                                    ER_MB_END & part_mask);\n                    return AVERROR_INVALIDDATA;\n                }\n                av_log(s->avctx, AV_LOG_ERROR, \"Error at MB: %d\\n\", xy);\n                ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                s->mb_x, s->mb_y, ER_MB_ERROR & part_mask);\n\n                if (s->avctx->err_recognition & AV_EF_IGNORE_ERR)\n                    continue;\n                return AVERROR_INVALIDDATA;\n            }\n\n            ff_mpv_reconstruct_mb(s, s->block);\n            if (s->loop_filter)\n                ff_h263_loop_filter(s);\n        }\n\n        ff_mpeg_draw_horiz_band(s, s->mb_y * mb_size, mb_size);\n        ff_mpv_report_decode_progress(s);\n\n        s->mb_x = 0;\n    }\n\n    av_assert1(s->mb_x == 0 && s->mb_y == s->mb_height);\n\n    // Detect incorrect padding with wrong stuffing codes used by NEC N-02B\n    if (s->codec_id == AV_CODEC_ID_MPEG4         &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 48              &&\n        show_bits(&s->gb, 24) == 0x4010          &&\n        !s->data_partitioning)\n        s->padding_bug_score += 32;\n\n    /* try to detect the padding bug */\n    if (s->codec_id == AV_CODEC_ID_MPEG4         &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 0               &&\n        get_bits_left(&s->gb) < 137              &&\n        !s->data_partitioning) {\n        const int bits_count = get_bits_count(&s->gb);\n        const int bits_left  = s->gb.size_in_bits - bits_count;\n\n        if (bits_left == 0) {\n            s->padding_bug_score += 16;\n        } else if (bits_left != 1) {\n            int v = show_bits(&s->gb, 8);\n            v |= 0x7F >> (7 - (bits_count & 7));\n\n            if (v == 0x7F && bits_left <= 8)\n                s->padding_bug_score--;\n            else if (v == 0x7F && ((get_bits_count(&s->gb) + 8) & 8) &&\n                     bits_left <= 16)\n                s->padding_bug_score += 4;\n            else\n                s->padding_bug_score++;\n        }\n    }\n\n    if (s->codec_id == AV_CODEC_ID_H263          &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 8               &&\n        get_bits_left(&s->gb) < 300              &&\n        s->pict_type == AV_PICTURE_TYPE_I        &&\n        show_bits(&s->gb, 8) == 0                &&\n        !s->data_partitioning) {\n\n        s->padding_bug_score += 32;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_H263          &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 64              &&\n        AV_RB64(s->gb.buffer_end - 8) == 0xCDCDCDCDFC7F0000) {\n\n        s->padding_bug_score += 32;\n    }\n\n    if (s->workaround_bugs & FF_BUG_AUTODETECT) {\n        if (\n            (s->padding_bug_score > -2 && !s->data_partitioning))\n            s->workaround_bugs |= FF_BUG_NO_PADDING;\n        else\n            s->workaround_bugs &= ~FF_BUG_NO_PADDING;\n    }\n\n    // handle formats which don't have unique end markers\n    if (s->msmpeg4_version || (s->workaround_bugs & FF_BUG_NO_PADDING)) { // FIXME perhaps solve this more cleanly\n        int left      = get_bits_left(&s->gb);\n        int max_extra = 7;\n\n        /* no markers in M$ crap */\n        if (s->msmpeg4_version && s->pict_type == AV_PICTURE_TYPE_I)\n            max_extra += 17;\n\n        /* buggy padding but the frame should still end approximately at\n         * the bitstream end */\n        if ((s->workaround_bugs & FF_BUG_NO_PADDING) &&\n            (s->avctx->err_recognition & (AV_EF_BUFFER|AV_EF_AGGRESSIVE)))\n            max_extra += 48;\n        else if ((s->workaround_bugs & FF_BUG_NO_PADDING))\n            max_extra += 256 * 256 * 256 * 64;\n\n        if (left > max_extra)\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"discarding %d junk bits at end, next would be %X\\n\",\n                   left, show_bits(&s->gb, 24));\n        else if (left < 0)\n            av_log(s->avctx, AV_LOG_ERROR, \"overreading %d bits\\n\", -left);\n        else\n            ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                            s->mb_x - 1, s->mb_y, ER_MB_END);\n\n        return 0;\n    }\n\n    av_log(s->avctx, AV_LOG_ERROR,\n           \"slice end not reached but screenspace end (%d left %06X, score= %d)\\n\",\n           get_bits_left(&s->gb), show_bits(&s->gb, 24), s->padding_bug_score);\n\n    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y,\n                    ER_MB_END & part_mask);\n\n    return AVERROR_INVALIDDATA;\n}\n\nint ff_h263_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                         AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    MpegEncContext *s  = avctx->priv_data;\n    int ret;\n    int slice_ret = 0;\n    AVFrame *pict = data;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay == 0 && s->next_picture_ptr) {\n            if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n                return ret;\n            s->next_picture_ptr = NULL;\n\n            *got_frame = 1;\n        }\n\n        return 0;\n    }\n\n    if (s->avctx->flags & AV_CODEC_FLAG_TRUNCATED) {\n        int next;\n\n        if (CONFIG_MPEG4_DECODER && s->codec_id == AV_CODEC_ID_MPEG4) {\n            next = ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);\n        } else if (CONFIG_H263_DECODER && s->codec_id == AV_CODEC_ID_H263) {\n            next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n        } else if (CONFIG_H263P_DECODER && s->codec_id == AV_CODEC_ID_H263P) {\n            next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n        } else {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"this codec does not support truncated bitstreams\\n\");\n            return AVERROR(ENOSYS);\n        }\n\n        if (ff_combine_frame(&s->parse_context, next, (const uint8_t **)&buf,\n                             &buf_size) < 0)\n            return buf_size;\n    }\n\nretry:\n    if (s->divx_packed && s->bitstream_buffer_size) {\n        int i;\n        for(i=0; i < buf_size-3; i++) {\n            if (buf[i]==0 && buf[i+1]==0 && buf[i+2]==1) {\n                if (buf[i+3]==0xB0) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Discarding excessive bitstream in packed xvid\\n\");\n                    s->bitstream_buffer_size = 0;\n                }\n                break;\n            }\n        }\n    }\n\n    if (s->bitstream_buffer_size && (s->divx_packed || buf_size <= MAX_NVOP_SIZE)) // divx 5.01+/xvid frame reorder\n        ret = init_get_bits8(&s->gb, s->bitstream_buffer,\n                             s->bitstream_buffer_size);\n    else\n        ret = init_get_bits8(&s->gb, buf, buf_size);\n\n    s->bitstream_buffer_size = 0;\n    if (ret < 0)\n        return ret;\n\n    if (!s->context_initialized)\n        // we need the idct permutation for reading a custom matrix\n        ff_mpv_idct_init(s);\n\n    /* let's go :-) */\n    if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {\n        ret = ff_wmv2_decode_picture_header(s);\n    } else if (CONFIG_MSMPEG4_DECODER && s->msmpeg4_version) {\n        ret = ff_msmpeg4_decode_picture_header(s);\n    } else if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {\n        if (s->avctx->extradata_size && s->picture_number == 0) {\n            GetBitContext gb;\n\n            if (init_get_bits8(&gb, s->avctx->extradata, s->avctx->extradata_size) >= 0 )\n                ff_mpeg4_decode_picture_header(avctx->priv_data, &gb);\n        }\n        ret = ff_mpeg4_decode_picture_header(avctx->priv_data, &s->gb);\n    } else if (CONFIG_H263I_DECODER && s->codec_id == AV_CODEC_ID_H263I) {\n        ret = ff_intel_h263_decode_picture_header(s);\n    } else if (CONFIG_FLV_DECODER && s->h263_flv) {\n        ret = ff_flv_decode_picture_header(s);\n    } else {\n        ret = ff_h263_decode_picture_header(s);\n    }\n\n    if (ret < 0 || ret == FRAME_SKIPPED) {\n        if (   s->width  != avctx->coded_width\n            || s->height != avctx->coded_height) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Reverting picture dimensions change due to header decoding failure\\n\");\n                s->width = avctx->coded_width;\n                s->height= avctx->coded_height;\n        }\n    }\n    if (ret == FRAME_SKIPPED)\n        return get_consumed_bytes(s, buf_size);\n\n    /* skip if the header was thrashed */\n    if (ret < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"header damaged\\n\");\n        return ret;\n    }\n\n    if (!s->context_initialized) {\n        avctx->pix_fmt = h263_get_format(avctx);\n        if ((ret = ff_mpv_common_init(s)) < 0)\n            return ret;\n    }\n\n    if (!s->current_picture_ptr || s->current_picture_ptr->f->data[0]) {\n        int i = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0)\n            return i;\n        s->current_picture_ptr = &s->picture[i];\n    }\n\n    avctx->has_b_frames = !s->low_delay;\n\n    if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {\n        if (ff_mpeg4_workaround_bugs(avctx) == 1)\n            goto retry;\n        if (s->studio_profile != (s->idsp.idct == NULL))\n            ff_mpv_idct_init(s);\n    }\n\n    /* After H.263 & MPEG-4 header decode we have the height, width,\n     * and other parameters. So then we could init the picture.\n     * FIXME: By the way H.263 decoder is evolving it should have\n     * an H263EncContext */\n    if (s->width  != avctx->coded_width  ||\n        s->height != avctx->coded_height ||\n        s->context_reinit) {\n        /* H.263 could change picture size any time */\n        s->context_reinit = 0;\n\n        ret = ff_set_dimensions(avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n\n        ff_set_sar(avctx, avctx->sample_aspect_ratio);\n\n        if ((ret = ff_mpv_common_frame_size_change(s)))\n            return ret;\n\n        if (avctx->pix_fmt != h263_get_format(avctx)) {\n            av_log(avctx, AV_LOG_ERROR, \"format change not supported\\n\");\n            avctx->pix_fmt = AV_PIX_FMT_NONE;\n            return AVERROR_UNKNOWN;\n        }\n    }\n\n    if (s->codec_id == AV_CODEC_ID_H263  ||\n        s->codec_id == AV_CODEC_ID_H263P ||\n        s->codec_id == AV_CODEC_ID_H263I)\n        s->gob_index = H263_GOB_HEIGHT(s->height);\n\n    // for skipping the frame\n    s->current_picture.f->pict_type = s->pict_type;\n    s->current_picture.f->key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n    /* skip B-frames if we don't have reference frames */\n    if (!s->last_picture_ptr &&\n        (s->pict_type == AV_PICTURE_TYPE_B || s->droppable))\n        return get_consumed_bytes(s, buf_size);\n    if ((avctx->skip_frame >= AVDISCARD_NONREF &&\n         s->pict_type == AV_PICTURE_TYPE_B)    ||\n        (avctx->skip_frame >= AVDISCARD_NONKEY &&\n         s->pict_type != AV_PICTURE_TYPE_I)    ||\n        avctx->skip_frame >= AVDISCARD_ALL)\n        return get_consumed_bytes(s, buf_size);\n\n    if (s->next_p_frame_damaged) {\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n            return get_consumed_bytes(s, buf_size);\n        else\n            s->next_p_frame_damaged = 0;\n    }\n\n    if ((!s->no_rounding) || s->pict_type == AV_PICTURE_TYPE_B) {\n        s->me.qpel_put = s->qdsp.put_qpel_pixels_tab;\n        s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;\n    } else {\n        s->me.qpel_put = s->qdsp.put_no_rnd_qpel_pixels_tab;\n        s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;\n    }\n\n    if ((ret = ff_mpv_frame_start(s, avctx)) < 0)\n        return ret;\n\n    if (!s->divx_packed)\n        ff_thread_finish_setup(avctx);\n\n    if (avctx->hwaccel) {\n        ret = avctx->hwaccel->start_frame(avctx, s->gb.buffer,\n                                          s->gb.buffer_end - s->gb.buffer);\n        if (ret < 0 )\n            return ret;\n    }\n\n    ff_mpeg_er_frame_start(s);\n\n    /* the second part of the wmv2 header contains the MB skip bits which\n     * are stored in current_picture->mb_type which is not available before\n     * ff_mpv_frame_start() */\n    if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {\n        ret = ff_wmv2_decode_secondary_picture_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1)\n            goto frame_end;\n    }\n\n    /* decode each macroblock */\n    s->mb_x = 0;\n    s->mb_y = 0;\n\n    slice_ret = decode_slice(s);\n    while (s->mb_y < s->mb_height) {\n        if (s->msmpeg4_version) {\n            if (s->slice_height == 0 || s->mb_x != 0 || slice_ret < 0 ||\n                (s->mb_y % s->slice_height) != 0 || get_bits_left(&s->gb) < 0)\n                break;\n        } else {\n            int prev_x = s->mb_x, prev_y = s->mb_y;\n            if (ff_h263_resync(s) < 0)\n                break;\n            if (prev_y * s->mb_width + prev_x < s->mb_y * s->mb_width + s->mb_x)\n                s->er.error_occurred = 1;\n        }\n\n        if (s->msmpeg4_version < 4 && s->h263_pred)\n            ff_mpeg4_clean_buffers(s);\n\n        if (decode_slice(s) < 0)\n            slice_ret = AVERROR_INVALIDDATA;\n    }\n\n    if (s->msmpeg4_version && s->msmpeg4_version < 4 &&\n        s->pict_type == AV_PICTURE_TYPE_I)\n        if (!CONFIG_MSMPEG4_DECODER ||\n            ff_msmpeg4_decode_ext_header(s, buf_size) < 0)\n            s->er.error_status_table[s->mb_num - 1] = ER_MB_ERROR;\n\n    av_assert1(s->bitstream_buffer_size == 0);\nframe_end:\n    ff_er_frame_end(&s->er);\n\n    if (avctx->hwaccel) {\n        ret = avctx->hwaccel->end_frame(avctx);\n        if (ret < 0)\n            return ret;\n    }\n\n    ff_mpv_frame_end(s);\n\n    if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4)\n        ff_mpeg4_frame_end(avctx, buf, buf_size);\n\n    if (!s->divx_packed && avctx->hwaccel)\n        ff_thread_finish_setup(avctx);\n\n    av_assert1(s->current_picture.f->pict_type == s->current_picture_ptr->f->pict_type);\n    av_assert1(s->current_picture.f->pict_type == s->pict_type);\n    if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n        if ((ret = av_frame_ref(pict, s->current_picture_ptr->f)) < 0)\n            return ret;\n        ff_print_debug_info(s, s->current_picture_ptr, pict);\n        ff_mpv_export_qp_table(s, pict, s->current_picture_ptr, FF_QSCALE_TYPE_MPEG1);\n    } else if (s->last_picture_ptr) {\n        if ((ret = av_frame_ref(pict, s->last_picture_ptr->f)) < 0)\n            return ret;\n        ff_print_debug_info(s, s->last_picture_ptr, pict);\n        ff_mpv_export_qp_table(s, pict, s->last_picture_ptr, FF_QSCALE_TYPE_MPEG1);\n    }\n\n    if (s->last_picture_ptr || s->low_delay) {\n        if (   pict->format == AV_PIX_FMT_YUV420P\n            && (s->codec_tag == AV_RL32(\"GEOV\") || s->codec_tag == AV_RL32(\"GEOX\"))) {\n            int x, y, p;\n            av_frame_make_writable(pict);\n            for (p=0; p<3; p++) {\n                int w = AV_CEIL_RSHIFT(pict-> width, !!p);\n                int h = AV_CEIL_RSHIFT(pict->height, !!p);\n                int linesize = pict->linesize[p];\n                for (y=0; y<(h>>1); y++)\n                    for (x=0; x<w; x++)\n                        FFSWAP(int,\n                               pict->data[p][x + y*linesize],\n                               pict->data[p][x + (h-1-y)*linesize]);\n            }\n        }\n        *got_frame = 1;\n    }\n\n    if (slice_ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n        return slice_ret;\n    else\n        return get_consumed_bytes(s, buf_size);\n}\n\nconst enum AVPixelFormat ff_h263_hwaccel_pixfmt_list_420[] = {\n#if CONFIG_H263_VAAPI_HWACCEL || CONFIG_MPEG4_VAAPI_HWACCEL\n    AV_PIX_FMT_VAAPI,\n#endif\n#if CONFIG_MPEG4_NVDEC_HWACCEL\n    AV_PIX_FMT_CUDA,\n#endif\n#if CONFIG_MPEG4_VDPAU_HWACCEL\n    AV_PIX_FMT_VDPAU,\n#endif\n#if CONFIG_H263_VIDEOTOOLBOX_HWACCEL || CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL\n    AV_PIX_FMT_VIDEOTOOLBOX,\n#endif\n    AV_PIX_FMT_YUV420P,\n    AV_PIX_FMT_NONE\n};\n\nAVCodec ff_h263_decoder = {\n    .name           = \"h263\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_H263,\n    .priv_data_size = sizeof(MpegEncContext),\n    .init           = ff_h263_decode_init,\n    .close          = ff_h263_decode_end,\n    .decode         = ff_h263_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1 |\n                      AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,\n    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n    .flush          = ff_mpeg_flush,\n    .max_lowres     = 3,\n    .pix_fmts       = ff_h263_hwaccel_pixfmt_list_420,\n};\n\nAVCodec ff_h263p_decoder = {\n    .name           = \"h263p\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_H263P,\n    .priv_data_size = sizeof(MpegEncContext),\n    .init           = ff_h263_decode_init,\n    .close          = ff_h263_decode_end,\n    .decode         = ff_h263_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1 |\n                      AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,\n    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n    .flush          = ff_mpeg_flush,\n    .max_lowres     = 3,\n    .pix_fmts       = ff_h263_hwaccel_pixfmt_list_420,\n    .hw_configs     = (const AVCodecHWConfigInternal*[]) {\n#if CONFIG_H263_VAAPI_HWACCEL\n                        HWACCEL_VAAPI(h263),\n#endif\n#if CONFIG_MPEG4_VDPAU_HWACCEL\n                        HWACCEL_VDPAU(mpeg4),\n#endif\n#if CONFIG_H263_VIDEOTOOLBOX_HWACCEL\n                        HWACCEL_VIDEOTOOLBOX(h263),\n#endif\n                        NULL\n                    },\n};\n", "/*\n * MPEG-4 decoder\n * Copyright (c) 2000,2001 Fabrice Bellard\n * Copyright (c) 2002-2010 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define UNCHECKED_BITSTREAM_READER 1\n\n#include \"libavutil/internal.h\"\n#include \"libavutil/opt.h\"\n#include \"error_resilience.h\"\n#include \"hwaccel.h\"\n#include \"idctdsp.h\"\n#include \"internal.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"mpegvideodata.h\"\n#include \"mpeg4video.h\"\n#include \"h263.h\"\n#include \"profiles.h\"\n#include \"thread.h\"\n#include \"xvididct.h\"\n\n/* The defines below define the number of bits that are read at once for\n * reading vlc values. Changing these may improve speed and data cache needs\n * be aware though that decreasing them may need the number of stages that is\n * passed to get_vlc* to be increased. */\n#define SPRITE_TRAJ_VLC_BITS 6\n#define DC_VLC_BITS 9\n#define MB_TYPE_B_VLC_BITS 4\n#define STUDIO_INTRA_BITS 9\n\nstatic int decode_studio_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb);\n\nstatic VLC dc_lum, dc_chrom;\nstatic VLC sprite_trajectory;\nstatic VLC mb_type_b_vlc;\n\nstatic const int mb_type_b_map[4] = {\n    MB_TYPE_DIRECT2 | MB_TYPE_L0L1,\n    MB_TYPE_L0L1    | MB_TYPE_16x16,\n    MB_TYPE_L1      | MB_TYPE_16x16,\n    MB_TYPE_L0      | MB_TYPE_16x16,\n};\n\n/**\n * Predict the ac.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n * @param dir the ac prediction direction\n */\nvoid ff_mpeg4_pred_ac(MpegEncContext *s, int16_t *block, int n, int dir)\n{\n    int i;\n    int16_t *ac_val, *ac_val1;\n    int8_t *const qscale_table = s->current_picture.qscale_table;\n\n    /* find prediction */\n    ac_val  = &s->ac_val[0][0][0] + s->block_index[n] * 16;\n    ac_val1 = ac_val;\n    if (s->ac_pred) {\n        if (dir == 0) {\n            const int xy = s->mb_x - 1 + s->mb_y * s->mb_stride;\n            /* left prediction */\n            ac_val -= 16;\n\n            if (s->mb_x == 0 || s->qscale == qscale_table[xy] ||\n                n == 1 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i << 3]] += ac_val[i];\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i << 3]] += ROUNDED_DIV(ac_val[i] * qscale_table[xy], s->qscale);\n            }\n        } else {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride - s->mb_stride;\n            /* top prediction */\n            ac_val -= 16 * s->block_wrap[n];\n\n            if (s->mb_y == 0 || s->qscale == qscale_table[xy] ||\n                n == 2 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i]] += ac_val[i + 8];\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i]] += ROUNDED_DIV(ac_val[i + 8] * qscale_table[xy], s->qscale);\n            }\n        }\n    }\n    /* left copy */\n    for (i = 1; i < 8; i++)\n        ac_val1[i] = block[s->idsp.idct_permutation[i << 3]];\n\n    /* top copy */\n    for (i = 1; i < 8; i++)\n        ac_val1[8 + i] = block[s->idsp.idct_permutation[i]];\n}\n\n/**\n * check if the next stuff is a resync marker or the end.\n * @return 0 if not\n */\nstatic inline int mpeg4_is_resync(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    int bits_count = get_bits_count(&s->gb);\n    int v          = show_bits(&s->gb, 16);\n\n    if (s->workaround_bugs & FF_BUG_NO_PADDING && !ctx->resync_marker)\n        return 0;\n\n    while (v <= 0xFF) {\n        if (s->pict_type == AV_PICTURE_TYPE_B ||\n            (v >> (8 - s->pict_type) != 1) || s->partitioned_frame)\n            break;\n        skip_bits(&s->gb, 8 + s->pict_type);\n        bits_count += 8 + s->pict_type;\n        v = show_bits(&s->gb, 16);\n    }\n\n    if (bits_count + 8 >= s->gb.size_in_bits) {\n        v >>= 8;\n        v  |= 0x7F >> (7 - (bits_count & 7));\n\n        if (v == 0x7F)\n            return s->mb_num;\n    } else {\n        if (v == ff_mpeg4_resync_prefix[bits_count & 7]) {\n            int len, mb_num;\n            int mb_num_bits = av_log2(s->mb_num - 1) + 1;\n            GetBitContext gb = s->gb;\n\n            skip_bits(&s->gb, 1);\n            align_get_bits(&s->gb);\n\n            for (len = 0; len < 32; len++)\n                if (get_bits1(&s->gb))\n                    break;\n\n            mb_num = get_bits(&s->gb, mb_num_bits);\n            if (!mb_num || mb_num > s->mb_num || get_bits_count(&s->gb)+6 > s->gb.size_in_bits)\n                mb_num= -1;\n\n            s->gb = gb;\n\n            if (len >= ff_mpeg4_get_video_packet_prefix_length(s))\n                return mb_num;\n        }\n    }\n    return 0;\n}\n\nstatic int mpeg4_decode_sprite_trajectory(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int a     = 2 << s->sprite_warping_accuracy;\n    int rho   = 3  - s->sprite_warping_accuracy;\n    int r     = 16 / a;\n    int alpha = 1;\n    int beta  = 0;\n    int w     = s->width;\n    int h     = s->height;\n    int min_ab, i, w2, h2, w3, h3;\n    int sprite_ref[4][2];\n    int virtual_ref[2][2];\n    int64_t sprite_offset[2][2];\n    int64_t sprite_delta[2][2];\n\n    // only true for rectangle shapes\n    const int vop_ref[4][2] = { { 0, 0 },         { s->width, 0 },\n                                { 0, s->height }, { s->width, s->height } };\n    int d[4][2]             = { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } };\n\n    if (w <= 0 || h <= 0)\n        return AVERROR_INVALIDDATA;\n\n    /* the decoder was not properly initialized and we cannot continue */\n    if (sprite_trajectory.table == NULL)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < ctx->num_sprite_warping_points; i++) {\n        int length;\n        int x = 0, y = 0;\n\n        length = get_vlc2(gb, sprite_trajectory.table, SPRITE_TRAJ_VLC_BITS, 3);\n        if (length > 0)\n            x = get_xbits(gb, length);\n\n        if (!(ctx->divx_version == 500 && ctx->divx_build == 413))\n            check_marker(s->avctx, gb, \"before sprite_trajectory\");\n\n        length = get_vlc2(gb, sprite_trajectory.table, SPRITE_TRAJ_VLC_BITS, 3);\n        if (length > 0)\n            y = get_xbits(gb, length);\n\n        check_marker(s->avctx, gb, \"after sprite_trajectory\");\n        ctx->sprite_traj[i][0] = d[i][0] = x;\n        ctx->sprite_traj[i][1] = d[i][1] = y;\n    }\n    for (; i < 4; i++)\n        ctx->sprite_traj[i][0] = ctx->sprite_traj[i][1] = 0;\n\n    while ((1 << alpha) < w)\n        alpha++;\n    while ((1 << beta) < h)\n        beta++;  /* typo in the MPEG-4 std for the definition of w' and h' */\n    w2 = 1 << alpha;\n    h2 = 1 << beta;\n\n    // Note, the 4th point isn't used for GMC\n    if (ctx->divx_version == 500 && ctx->divx_build == 413) {\n        sprite_ref[0][0] = a * vop_ref[0][0] + d[0][0];\n        sprite_ref[0][1] = a * vop_ref[0][1] + d[0][1];\n        sprite_ref[1][0] = a * vop_ref[1][0] + d[0][0] + d[1][0];\n        sprite_ref[1][1] = a * vop_ref[1][1] + d[0][1] + d[1][1];\n        sprite_ref[2][0] = a * vop_ref[2][0] + d[0][0] + d[2][0];\n        sprite_ref[2][1] = a * vop_ref[2][1] + d[0][1] + d[2][1];\n    } else {\n        sprite_ref[0][0] = (a >> 1) * (2 * vop_ref[0][0] + d[0][0]);\n        sprite_ref[0][1] = (a >> 1) * (2 * vop_ref[0][1] + d[0][1]);\n        sprite_ref[1][0] = (a >> 1) * (2 * vop_ref[1][0] + d[0][0] + d[1][0]);\n        sprite_ref[1][1] = (a >> 1) * (2 * vop_ref[1][1] + d[0][1] + d[1][1]);\n        sprite_ref[2][0] = (a >> 1) * (2 * vop_ref[2][0] + d[0][0] + d[2][0]);\n        sprite_ref[2][1] = (a >> 1) * (2 * vop_ref[2][1] + d[0][1] + d[2][1]);\n    }\n    /* sprite_ref[3][0] = (a >> 1) * (2 * vop_ref[3][0] + d[0][0] + d[1][0] + d[2][0] + d[3][0]);\n     * sprite_ref[3][1] = (a >> 1) * (2 * vop_ref[3][1] + d[0][1] + d[1][1] + d[2][1] + d[3][1]); */\n\n    /* This is mostly identical to the MPEG-4 std (and is totally unreadable\n     * because of that...). Perhaps it should be reordered to be more readable.\n     * The idea behind this virtual_ref mess is to be able to use shifts later\n     * per pixel instead of divides so the distance between points is converted\n     * from w&h based to w2&h2 based which are of the 2^x form. */\n    virtual_ref[0][0] = 16 * (vop_ref[0][0] + w2) +\n                         ROUNDED_DIV(((w - w2) *\n                                           (r * sprite_ref[0][0] - 16LL * vop_ref[0][0]) +\n                                      w2 * (r * sprite_ref[1][0] - 16LL * vop_ref[1][0])), w);\n    virtual_ref[0][1] = 16 * vop_ref[0][1] +\n                        ROUNDED_DIV(((w - w2) *\n                                          (r * sprite_ref[0][1] - 16LL * vop_ref[0][1]) +\n                                     w2 * (r * sprite_ref[1][1] - 16LL * vop_ref[1][1])), w);\n    virtual_ref[1][0] = 16 * vop_ref[0][0] +\n                        ROUNDED_DIV(((h - h2) * (r * sprite_ref[0][0] - 16LL * vop_ref[0][0]) +\n                                           h2 * (r * sprite_ref[2][0] - 16LL * vop_ref[2][0])), h);\n    virtual_ref[1][1] = 16 * (vop_ref[0][1] + h2) +\n                        ROUNDED_DIV(((h - h2) * (r * sprite_ref[0][1] - 16LL * vop_ref[0][1]) +\n                                           h2 * (r * sprite_ref[2][1] - 16LL * vop_ref[2][1])), h);\n\n    switch (ctx->num_sprite_warping_points) {\n    case 0:\n        sprite_offset[0][0]    =\n        sprite_offset[0][1]    =\n        sprite_offset[1][0]    =\n        sprite_offset[1][1]    = 0;\n        sprite_delta[0][0]     = a;\n        sprite_delta[0][1]     =\n        sprite_delta[1][0]     = 0;\n        sprite_delta[1][1]     = a;\n        ctx->sprite_shift[0]   =\n        ctx->sprite_shift[1]   = 0;\n        break;\n    case 1:     // GMC only\n        sprite_offset[0][0]    = sprite_ref[0][0] - a * vop_ref[0][0];\n        sprite_offset[0][1]    = sprite_ref[0][1] - a * vop_ref[0][1];\n        sprite_offset[1][0]    = ((sprite_ref[0][0] >> 1) | (sprite_ref[0][0] & 1)) -\n                                 a * (vop_ref[0][0] / 2);\n        sprite_offset[1][1]    = ((sprite_ref[0][1] >> 1) | (sprite_ref[0][1] & 1)) -\n                                 a * (vop_ref[0][1] / 2);\n        sprite_delta[0][0]     = a;\n        sprite_delta[0][1]     =\n        sprite_delta[1][0]     = 0;\n        sprite_delta[1][1]     = a;\n        ctx->sprite_shift[0]   =\n        ctx->sprite_shift[1]   = 0;\n        break;\n    case 2:\n        sprite_offset[0][0]    = ((int64_t)      sprite_ref[0][0] * (1 << alpha + rho)) +\n                                 ((int64_t) -r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                 ((int64_t)        -vop_ref[0][0]) +\n                                 ((int64_t)  r * sprite_ref[0][1] - virtual_ref[0][1]) *\n                                 ((int64_t)        -vop_ref[0][1]) + (1 << (alpha + rho - 1));\n        sprite_offset[0][1]    = ((int64_t)      sprite_ref[0][1] * (1 << alpha + rho)) +\n                                 ((int64_t) -r * sprite_ref[0][1] + virtual_ref[0][1]) *\n                                 ((int64_t)        -vop_ref[0][0]) +\n                                 ((int64_t) -r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                 ((int64_t)        -vop_ref[0][1]) + (1 << (alpha + rho - 1));\n        sprite_offset[1][0]    = (((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                  ((int64_t)-2 *    vop_ref[0][0] + 1) +\n                                  ((int64_t) r * sprite_ref[0][1] - virtual_ref[0][1]) *\n                                  ((int64_t)-2 *    vop_ref[0][1] + 1) + 2 * w2 * r *\n                                   (int64_t)     sprite_ref[0][0] - 16 * w2 + (1 << (alpha + rho + 1)));\n        sprite_offset[1][1]    = (((int64_t)-r * sprite_ref[0][1] + virtual_ref[0][1]) *\n                                  ((int64_t)-2 *    vop_ref[0][0] + 1) +\n                                  ((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                  ((int64_t)-2 *    vop_ref[0][1] + 1) + 2 * w2 * r *\n                                  (int64_t)      sprite_ref[0][1] - 16 * w2 + (1 << (alpha + rho + 1)));\n        sprite_delta[0][0] = (-r * sprite_ref[0][0] + virtual_ref[0][0]);\n        sprite_delta[0][1] = (+r * sprite_ref[0][1] - virtual_ref[0][1]);\n        sprite_delta[1][0] = (-r * sprite_ref[0][1] + virtual_ref[0][1]);\n        sprite_delta[1][1] = (-r * sprite_ref[0][0] + virtual_ref[0][0]);\n\n        ctx->sprite_shift[0]  = alpha + rho;\n        ctx->sprite_shift[1]  = alpha + rho + 2;\n        break;\n    case 3:\n        min_ab = FFMIN(alpha, beta);\n        w3     = w2 >> min_ab;\n        h3     = h2 >> min_ab;\n        sprite_offset[0][0]    = ((int64_t)sprite_ref[0][0] * (1 << (alpha + beta + rho - min_ab))) +\n                                 ((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) * h3 * (-vop_ref[0][0]) +\n                                 ((int64_t)-r * sprite_ref[0][0] + virtual_ref[1][0]) * w3 * (-vop_ref[0][1]) +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab - 1));\n        sprite_offset[0][1]    = ((int64_t)sprite_ref[0][1] * (1 << (alpha + beta + rho - min_ab))) +\n                                 ((int64_t)-r * sprite_ref[0][1] + virtual_ref[0][1]) * h3 * (-vop_ref[0][0]) +\n                                 ((int64_t)-r * sprite_ref[0][1] + virtual_ref[1][1]) * w3 * (-vop_ref[0][1]) +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab - 1));\n        sprite_offset[1][0]    = ((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) * h3 * (-2 * vop_ref[0][0] + 1) +\n                                 ((int64_t)-r * sprite_ref[0][0] + virtual_ref[1][0]) * w3 * (-2 * vop_ref[0][1] + 1) +\n                                  (int64_t)2 * w2 * h3 * r * sprite_ref[0][0] - 16 * w2 * h3 +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab + 1));\n        sprite_offset[1][1]    = ((int64_t)-r * sprite_ref[0][1] + virtual_ref[0][1]) * h3 * (-2 * vop_ref[0][0] + 1) +\n                                 ((int64_t)-r * sprite_ref[0][1] + virtual_ref[1][1]) * w3 * (-2 * vop_ref[0][1] + 1) +\n                                  (int64_t)2 * w2 * h3 * r * sprite_ref[0][1] - 16 * w2 * h3 +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab + 1));\n        sprite_delta[0][0] = (-r * (int64_t)sprite_ref[0][0] + virtual_ref[0][0]) * h3;\n        sprite_delta[0][1] = (-r * (int64_t)sprite_ref[0][0] + virtual_ref[1][0]) * w3;\n        sprite_delta[1][0] = (-r * (int64_t)sprite_ref[0][1] + virtual_ref[0][1]) * h3;\n        sprite_delta[1][1] = (-r * (int64_t)sprite_ref[0][1] + virtual_ref[1][1]) * w3;\n\n        ctx->sprite_shift[0]  = alpha + beta + rho - min_ab;\n        ctx->sprite_shift[1]  = alpha + beta + rho - min_ab + 2;\n        break;\n    }\n    /* try to simplify the situation */\n    if (sprite_delta[0][0] == a << ctx->sprite_shift[0] &&\n        sprite_delta[0][1] == 0 &&\n        sprite_delta[1][0] == 0 &&\n        sprite_delta[1][1] == a << ctx->sprite_shift[0]) {\n        sprite_offset[0][0] >>= ctx->sprite_shift[0];\n        sprite_offset[0][1] >>= ctx->sprite_shift[0];\n        sprite_offset[1][0] >>= ctx->sprite_shift[1];\n        sprite_offset[1][1] >>= ctx->sprite_shift[1];\n        sprite_delta[0][0] = a;\n        sprite_delta[0][1] = 0;\n        sprite_delta[1][0] = 0;\n        sprite_delta[1][1] = a;\n        ctx->sprite_shift[0] = 0;\n        ctx->sprite_shift[1] = 0;\n        s->real_sprite_warping_points = 1;\n    } else {\n        int shift_y = 16 - ctx->sprite_shift[0];\n        int shift_c = 16 - ctx->sprite_shift[1];\n\n        for (i = 0; i < 2; i++) {\n            if (shift_c < 0 || shift_y < 0 ||\n                FFABS(  sprite_offset[0][i]) >= INT_MAX >> shift_y  ||\n                FFABS(  sprite_offset[1][i]) >= INT_MAX >> shift_c  ||\n                FFABS(   sprite_delta[0][i]) >= INT_MAX >> shift_y  ||\n                FFABS(   sprite_delta[1][i]) >= INT_MAX >> shift_y\n            ) {\n                avpriv_request_sample(s->avctx, \"Too large sprite shift, delta or offset\");\n                goto overflow;\n            }\n        }\n\n        for (i = 0; i < 2; i++) {\n            sprite_offset[0][i]    *= 1 << shift_y;\n            sprite_offset[1][i]    *= 1 << shift_c;\n            sprite_delta[0][i]     *= 1 << shift_y;\n            sprite_delta[1][i]     *= 1 << shift_y;\n            ctx->sprite_shift[i]     = 16;\n\n        }\n        for (i = 0; i < 2; i++) {\n            int64_t sd[2] = {\n                sprite_delta[i][0] - a * (1LL<<16),\n                sprite_delta[i][1] - a * (1LL<<16)\n            };\n\n            if (llabs(sprite_offset[0][i] + sprite_delta[i][0] * (w+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sprite_delta[i][1] * (h+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sprite_delta[i][0] * (w+16LL) + sprite_delta[i][1] * (h+16LL)) >= INT_MAX ||\n                llabs(sprite_delta[i][0] * (w+16LL)) >= INT_MAX ||\n                llabs(sprite_delta[i][1] * (w+16LL)) >= INT_MAX ||\n                llabs(sd[0]) >= INT_MAX ||\n                llabs(sd[1]) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sd[0] * (w+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sd[1] * (h+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sd[0] * (w+16LL) + sd[1] * (h+16LL)) >= INT_MAX\n            ) {\n                avpriv_request_sample(s->avctx, \"Overflow on sprite points\");\n                goto overflow;\n            }\n        }\n        s->real_sprite_warping_points = ctx->num_sprite_warping_points;\n    }\n\n    for (i = 0; i < 4; i++) {\n        s->sprite_offset[i&1][i>>1] = sprite_offset[i&1][i>>1];\n        s->sprite_delta [i&1][i>>1] = sprite_delta [i&1][i>>1];\n    }\n\n    return 0;\noverflow:\n    memset(s->sprite_offset, 0, sizeof(s->sprite_offset));\n    memset(s->sprite_delta, 0, sizeof(s->sprite_delta));\n    return AVERROR_PATCHWELCOME;\n}\n\nstatic int decode_new_pred(Mpeg4DecContext *ctx, GetBitContext *gb) {\n    MpegEncContext *s = &ctx->m;\n    int len = FFMIN(ctx->time_increment_bits + 3, 15);\n\n    get_bits(gb, len);\n    if (get_bits1(gb))\n        get_bits(gb, len);\n    check_marker(s->avctx, gb, \"after new_pred\");\n\n    return 0;\n}\n\n/**\n * Decode the next video packet.\n * @return <0 if something went wrong\n */\nint ff_mpeg4_decode_video_packet_header(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n\n    int mb_num_bits      = av_log2(s->mb_num - 1) + 1;\n    int header_extension = 0, mb_num, len;\n\n    /* is there enough space left for a video packet + header */\n    if (get_bits_count(&s->gb) > s->gb.size_in_bits - 20)\n        return AVERROR_INVALIDDATA;\n\n    for (len = 0; len < 32; len++)\n        if (get_bits1(&s->gb))\n            break;\n\n    if (len != ff_mpeg4_get_video_packet_prefix_length(s)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"marker does not match f_code\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->shape != RECT_SHAPE) {\n        header_extension = get_bits1(&s->gb);\n        // FIXME more stuff here\n    }\n\n    mb_num = get_bits(&s->gb, mb_num_bits);\n    if (mb_num >= s->mb_num || !mb_num) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"illegal mb_num in video packet (%d %d) \\n\", mb_num, s->mb_num);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->mb_x = mb_num % s->mb_width;\n    s->mb_y = mb_num / s->mb_width;\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        int qscale = get_bits(&s->gb, s->quant_precision);\n        if (qscale)\n            s->chroma_qscale = s->qscale = qscale;\n    }\n\n    if (ctx->shape == RECT_SHAPE)\n        header_extension = get_bits1(&s->gb);\n\n    if (header_extension) {\n        int time_incr = 0;\n\n        while (get_bits1(&s->gb) != 0)\n            time_incr++;\n\n        check_marker(s->avctx, &s->gb, \"before time_increment in video packed header\");\n        skip_bits(&s->gb, ctx->time_increment_bits);      /* time_increment */\n        check_marker(s->avctx, &s->gb, \"before vop_coding_type in video packed header\");\n\n        skip_bits(&s->gb, 2); /* vop coding type */\n        // FIXME not rect stuff here\n\n        if (ctx->shape != BIN_ONLY_SHAPE) {\n            skip_bits(&s->gb, 3); /* intra dc vlc threshold */\n            // FIXME don't just ignore everything\n            if (s->pict_type == AV_PICTURE_TYPE_S &&\n                ctx->vol_sprite_usage == GMC_SPRITE) {\n                if (mpeg4_decode_sprite_trajectory(ctx, &s->gb) < 0)\n                    return AVERROR_INVALIDDATA;\n                av_log(s->avctx, AV_LOG_ERROR, \"untested\\n\");\n            }\n\n            // FIXME reduced res stuff here\n\n            if (s->pict_type != AV_PICTURE_TYPE_I) {\n                int f_code = get_bits(&s->gb, 3);       /* fcode_for */\n                if (f_code == 0)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Error, video packet header damaged (f_code=0)\\n\");\n            }\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n                int b_code = get_bits(&s->gb, 3);\n                if (b_code == 0)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Error, video packet header damaged (b_code=0)\\n\");\n            }\n        }\n    }\n    if (ctx->new_pred)\n        decode_new_pred(ctx, &s->gb);\n\n    return 0;\n}\n\nstatic void reset_studio_dc_predictors(MpegEncContext *s)\n{\n    /* Reset DC Predictors */\n    s->last_dc[0] =\n    s->last_dc[1] =\n    s->last_dc[2] = 1 << (s->avctx->bits_per_raw_sample + s->dct_precision + s->intra_dc_precision - 1);\n}\n\n/**\n * Decode the next video packet.\n * @return <0 if something went wrong\n */\nint ff_mpeg4_decode_studio_slice_header(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    GetBitContext *gb = &s->gb;\n    unsigned vlc_len;\n    uint16_t mb_num;\n\n    if (get_bits_left(gb) >= 32 && get_bits_long(gb, 32) == SLICE_START_CODE) {\n        vlc_len = av_log2(s->mb_width * s->mb_height) + 1;\n        mb_num = get_bits(gb, vlc_len);\n\n        if (mb_num >= s->mb_num)\n            return AVERROR_INVALIDDATA;\n\n        s->mb_x = mb_num % s->mb_width;\n        s->mb_y = mb_num / s->mb_width;\n\n        if (ctx->shape != BIN_ONLY_SHAPE)\n            s->qscale = mpeg_get_qscale(s);\n\n        if (get_bits1(gb)) {  /* slice_extension_flag */\n            skip_bits1(gb);   /* intra_slice */\n            skip_bits1(gb);   /* slice_VOP_id_enable */\n            skip_bits(gb, 6); /* slice_VOP_id */\n            while (get_bits1(gb)) /* extra_bit_slice */\n                skip_bits(gb, 8); /* extra_information_slice */\n        }\n\n        reset_studio_dc_predictors(s);\n    }\n    else {\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\n/**\n * Get the average motion vector for a GMC MB.\n * @param n either 0 for the x component or 1 for y\n * @return the average MV for a GMC MB\n */\nstatic inline int get_amv(Mpeg4DecContext *ctx, int n)\n{\n    MpegEncContext *s = &ctx->m;\n    int x, y, mb_v, sum, dx, dy, shift;\n    int len     = 1 << (s->f_code + 4);\n    const int a = s->sprite_warping_accuracy;\n\n    if (s->workaround_bugs & FF_BUG_AMV)\n        len >>= s->quarter_sample;\n\n    if (s->real_sprite_warping_points == 1) {\n        if (ctx->divx_version == 500 && ctx->divx_build == 413)\n            sum = s->sprite_offset[0][n] / (1 << (a - s->quarter_sample));\n        else\n            sum = RSHIFT(s->sprite_offset[0][n] * (1 << s->quarter_sample), a);\n    } else {\n        dx    = s->sprite_delta[n][0];\n        dy    = s->sprite_delta[n][1];\n        shift = ctx->sprite_shift[0];\n        if (n)\n            dy -= 1 << (shift + a + 1);\n        else\n            dx -= 1 << (shift + a + 1);\n        mb_v = s->sprite_offset[0][n] + dx * s->mb_x * 16 + dy * s->mb_y * 16;\n\n        sum = 0;\n        for (y = 0; y < 16; y++) {\n            int v;\n\n            v = mb_v + dy * y;\n            // FIXME optimize\n            for (x = 0; x < 16; x++) {\n                sum += v >> shift;\n                v   += dx;\n            }\n        }\n        sum = RSHIFT(sum, a + 8 - s->quarter_sample);\n    }\n\n    if (sum < -len)\n        sum = -len;\n    else if (sum >= len)\n        sum = len - 1;\n\n    return sum;\n}\n\n/**\n * Decode the dc value.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n * @param dir_ptr the prediction direction will be stored here\n * @return the quantized dc\n */\nstatic inline int mpeg4_decode_dc(MpegEncContext *s, int n, int *dir_ptr)\n{\n    int level, code;\n\n    if (n < 4)\n        code = get_vlc2(&s->gb, dc_lum.table, DC_VLC_BITS, 1);\n    else\n        code = get_vlc2(&s->gb, dc_chrom.table, DC_VLC_BITS, 1);\n\n    if (code < 0 || code > 9 /* && s->nbit < 9 */) {\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal dc vlc\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (code == 0) {\n        level = 0;\n    } else {\n        if (IS_3IV1) {\n            if (code == 1)\n                level = 2 * get_bits1(&s->gb) - 1;\n            else {\n                if (get_bits1(&s->gb))\n                    level = get_bits(&s->gb, code - 1) + (1 << (code - 1));\n                else\n                    level = -get_bits(&s->gb, code - 1) - (1 << (code - 1));\n            }\n        } else {\n            level = get_xbits(&s->gb, code);\n        }\n\n        if (code > 8) {\n            if (get_bits1(&s->gb) == 0) { /* marker */\n                if (s->avctx->err_recognition & (AV_EF_BITSTREAM|AV_EF_COMPLIANT)) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"dc marker bit missing\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n\n    return ff_mpeg4_pred_dc(s, n, level, dir_ptr, 0);\n}\n\n/**\n * Decode first partition.\n * @return number of MBs decoded or <0 if an error occurred\n */\nstatic int mpeg4_decode_partition_a(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    int mb_num = 0;\n    static const int8_t quant_tab[4] = { -1, -2, 1, 2 };\n\n    /* decode first partition */\n    s->first_slice_line = 1;\n    for (; s->mb_y < s->mb_height; s->mb_y++) {\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride;\n            int cbpc;\n            int dir = 0;\n\n            mb_num++;\n            ff_update_block_index(s);\n            if (s->mb_x == s->resync_mb_x && s->mb_y == s->resync_mb_y + 1)\n                s->first_slice_line = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_I) {\n                int i;\n\n                do {\n                    if (show_bits_long(&s->gb, 19) == DC_MARKER)\n                        return mb_num - 1;\n\n                    cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n                    if (cbpc < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"mcbpc corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return AVERROR_INVALIDDATA;\n                    }\n                } while (cbpc == 8);\n\n                s->cbp_table[xy]               = cbpc & 3;\n                s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n                s->mb_intra                    = 1;\n\n                if (cbpc & 4)\n                    ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n\n                s->current_picture.qscale_table[xy] = s->qscale;\n\n                s->mbintra_table[xy] = 1;\n                for (i = 0; i < 6; i++) {\n                    int dc_pred_dir;\n                    int dc = mpeg4_decode_dc(s, i, &dc_pred_dir);\n                    if (dc < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"DC corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return dc;\n                    }\n                    dir <<= 1;\n                    if (dc_pred_dir)\n                        dir |= 1;\n                }\n                s->pred_dir_table[xy] = dir;\n            } else { /* P/S_TYPE */\n                int mx, my, pred_x, pred_y, bits;\n                int16_t *const mot_val = s->current_picture.motion_val[0][s->block_index[0]];\n                const int stride       = s->b8_stride * 2;\n\ntry_again:\n                bits = show_bits(&s->gb, 17);\n                if (bits == MOTION_MARKER)\n                    return mb_num - 1;\n\n                skip_bits1(&s->gb);\n                if (bits & 0x10000) {\n                    /* skip mb */\n                    if (s->pict_type == AV_PICTURE_TYPE_S &&\n                        ctx->vol_sprite_usage == GMC_SPRITE) {\n                        s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                         MB_TYPE_16x16 |\n                                                         MB_TYPE_GMC   |\n                                                         MB_TYPE_L0;\n                        mx = get_amv(ctx, 0);\n                        my = get_amv(ctx, 1);\n                    } else {\n                        s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                         MB_TYPE_16x16 |\n                                                         MB_TYPE_L0;\n                        mx = my = 0;\n                    }\n                    mot_val[0]          =\n                    mot_val[2]          =\n                    mot_val[0 + stride] =\n                    mot_val[2 + stride] = mx;\n                    mot_val[1]          =\n                    mot_val[3]          =\n                    mot_val[1 + stride] =\n                    mot_val[3 + stride] = my;\n\n                    if (s->mbintra_table[xy])\n                        ff_clean_intra_table_entries(s);\n                    continue;\n                }\n\n                cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n                if (cbpc < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"mcbpc corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                    return AVERROR_INVALIDDATA;\n                }\n                if (cbpc == 20)\n                    goto try_again;\n\n                s->cbp_table[xy] = cbpc & (8 + 3);  // 8 is dquant\n\n                s->mb_intra = ((cbpc & 4) != 0);\n\n                if (s->mb_intra) {\n                    s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n                    s->mbintra_table[xy] = 1;\n                    mot_val[0]          =\n                    mot_val[2]          =\n                    mot_val[0 + stride] =\n                    mot_val[2 + stride] = 0;\n                    mot_val[1]          =\n                    mot_val[3]          =\n                    mot_val[1 + stride] =\n                    mot_val[3 + stride] = 0;\n                } else {\n                    if (s->mbintra_table[xy])\n                        ff_clean_intra_table_entries(s);\n\n                    if (s->pict_type == AV_PICTURE_TYPE_S &&\n                        ctx->vol_sprite_usage == GMC_SPRITE &&\n                        (cbpc & 16) == 0)\n                        s->mcsel = get_bits1(&s->gb);\n                    else\n                        s->mcsel = 0;\n\n                    if ((cbpc & 16) == 0) {\n                        /* 16x16 motion prediction */\n\n                        ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                        if (!s->mcsel) {\n                            mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n                            if (mx >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n\n                            my = ff_h263_decode_motion(s, pred_y, s->f_code);\n                            if (my >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n                            s->current_picture.mb_type[xy] = MB_TYPE_16x16 |\n                                                             MB_TYPE_L0;\n                        } else {\n                            mx = get_amv(ctx, 0);\n                            my = get_amv(ctx, 1);\n                            s->current_picture.mb_type[xy] = MB_TYPE_16x16 |\n                                                             MB_TYPE_GMC   |\n                                                             MB_TYPE_L0;\n                        }\n\n                        mot_val[0]          =\n                        mot_val[2]          =\n                        mot_val[0 + stride] =\n                        mot_val[2 + stride] = mx;\n                        mot_val[1]          =\n                        mot_val[3]          =\n                        mot_val[1 + stride] =\n                        mot_val[3 + stride] = my;\n                    } else {\n                        int i;\n                        s->current_picture.mb_type[xy] = MB_TYPE_8x8 |\n                                                         MB_TYPE_L0;\n                        for (i = 0; i < 4; i++) {\n                            int16_t *mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                            mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n                            if (mx >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n\n                            my = ff_h263_decode_motion(s, pred_y, s->f_code);\n                            if (my >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n                            mot_val[0] = mx;\n                            mot_val[1] = my;\n                        }\n                    }\n                }\n            }\n        }\n        s->mb_x = 0;\n    }\n\n    return mb_num;\n}\n\n/**\n * decode second partition.\n * @return <0 if an error occurred\n */\nstatic int mpeg4_decode_partition_b(MpegEncContext *s, int mb_count)\n{\n    int mb_num = 0;\n    static const int8_t quant_tab[4] = { -1, -2, 1, 2 };\n\n    s->mb_x = s->resync_mb_x;\n    s->first_slice_line = 1;\n    for (s->mb_y = s->resync_mb_y; mb_num < mb_count; s->mb_y++) {\n        ff_init_block_index(s);\n        for (; mb_num < mb_count && s->mb_x < s->mb_width; s->mb_x++) {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride;\n\n            mb_num++;\n            ff_update_block_index(s);\n            if (s->mb_x == s->resync_mb_x && s->mb_y == s->resync_mb_y + 1)\n                s->first_slice_line = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_I) {\n                int ac_pred = get_bits1(&s->gb);\n                int cbpy    = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n                if (cbpy < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"cbpy corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                s->cbp_table[xy]               |= cbpy << 2;\n                s->current_picture.mb_type[xy] |= ac_pred * MB_TYPE_ACPRED;\n            } else { /* P || S_TYPE */\n                if (IS_INTRA(s->current_picture.mb_type[xy])) {\n                    int i;\n                    int dir     = 0;\n                    int ac_pred = get_bits1(&s->gb);\n                    int cbpy    = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n\n                    if (cbpy < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"I cbpy corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (s->cbp_table[xy] & 8)\n                        ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n                    s->current_picture.qscale_table[xy] = s->qscale;\n\n                    for (i = 0; i < 6; i++) {\n                        int dc_pred_dir;\n                        int dc = mpeg4_decode_dc(s, i, &dc_pred_dir);\n                        if (dc < 0) {\n                            av_log(s->avctx, AV_LOG_ERROR,\n                                   \"DC corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                            return dc;\n                        }\n                        dir <<= 1;\n                        if (dc_pred_dir)\n                            dir |= 1;\n                    }\n                    s->cbp_table[xy]               &= 3;  // remove dquant\n                    s->cbp_table[xy]               |= cbpy << 2;\n                    s->current_picture.mb_type[xy] |= ac_pred * MB_TYPE_ACPRED;\n                    s->pred_dir_table[xy]           = dir;\n                } else if (IS_SKIP(s->current_picture.mb_type[xy])) {\n                    s->current_picture.qscale_table[xy] = s->qscale;\n                    s->cbp_table[xy]                    = 0;\n                } else {\n                    int cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n\n                    if (cbpy < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"P cbpy corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (s->cbp_table[xy] & 8)\n                        ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n                    s->current_picture.qscale_table[xy] = s->qscale;\n\n                    s->cbp_table[xy] &= 3;  // remove dquant\n                    s->cbp_table[xy] |= (cbpy ^ 0xf) << 2;\n                }\n            }\n        }\n        if (mb_num >= mb_count)\n            return 0;\n        s->mb_x = 0;\n    }\n    return 0;\n}\n\n/**\n * Decode the first and second partition.\n * @return <0 if error (and sets error type in the error_status_table)\n */\nint ff_mpeg4_decode_partitions(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    int mb_num;\n    int ret;\n    const int part_a_error = s->pict_type == AV_PICTURE_TYPE_I ? (ER_DC_ERROR | ER_MV_ERROR) : ER_MV_ERROR;\n    const int part_a_end   = s->pict_type == AV_PICTURE_TYPE_I ? (ER_DC_END   | ER_MV_END)   : ER_MV_END;\n\n    mb_num = mpeg4_decode_partition_a(ctx);\n    if (mb_num <= 0) {\n        ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                        s->mb_x, s->mb_y, part_a_error);\n        return mb_num ? mb_num : AVERROR_INVALIDDATA;\n    }\n\n    if (s->resync_mb_x + s->resync_mb_y * s->mb_width + mb_num > s->mb_num) {\n        av_log(s->avctx, AV_LOG_ERROR, \"slice below monitor ...\\n\");\n        ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                        s->mb_x, s->mb_y, part_a_error);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->mb_num_left = mb_num;\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        while (show_bits(&s->gb, 9) == 1)\n            skip_bits(&s->gb, 9);\n        if (get_bits_long(&s->gb, 19) != DC_MARKER) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"marker missing after first I partition at %d %d\\n\",\n                   s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        while (show_bits(&s->gb, 10) == 1)\n            skip_bits(&s->gb, 10);\n        if (get_bits(&s->gb, 17) != MOTION_MARKER) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"marker missing after first P partition at %d %d\\n\",\n                   s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                    s->mb_x - 1, s->mb_y, part_a_end);\n\n    ret = mpeg4_decode_partition_b(s, mb_num);\n    if (ret < 0) {\n        if (s->pict_type == AV_PICTURE_TYPE_P)\n            ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                            s->mb_x, s->mb_y, ER_DC_ERROR);\n        return ret;\n    } else {\n        if (s->pict_type == AV_PICTURE_TYPE_P)\n            ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                            s->mb_x - 1, s->mb_y, ER_DC_END);\n    }\n\n    return 0;\n}\n\n/**\n * Decode a block.\n * @return <0 if an error occurred\n */\nstatic inline int mpeg4_decode_block(Mpeg4DecContext *ctx, int16_t *block,\n                                     int n, int coded, int intra, int rvlc)\n{\n    MpegEncContext *s = &ctx->m;\n    int level, i, last, run, qmul, qadd;\n    int av_uninit(dc_pred_dir);\n    RLTable *rl;\n    RL_VLC_ELEM *rl_vlc;\n    const uint8_t *scan_table;\n\n    // Note intra & rvlc should be optimized away if this is inlined\n\n    if (intra) {\n        if (ctx->use_intra_dc_vlc) {\n            /* DC coef */\n            if (s->partitioned_frame) {\n                level = s->dc_val[0][s->block_index[n]];\n                if (n < 4)\n                    level = FASTDIV((level + (s->y_dc_scale >> 1)), s->y_dc_scale);\n                else\n                    level = FASTDIV((level + (s->c_dc_scale >> 1)), s->c_dc_scale);\n                dc_pred_dir = (s->pred_dir_table[s->mb_x + s->mb_y * s->mb_stride] << n) & 32;\n            } else {\n                level = mpeg4_decode_dc(s, n, &dc_pred_dir);\n                if (level < 0)\n                    return level;\n            }\n            block[0] = level;\n            i        = 0;\n        } else {\n            i = -1;\n            ff_mpeg4_pred_dc(s, n, 0, &dc_pred_dir, 0);\n        }\n        if (!coded)\n            goto not_coded;\n\n        if (rvlc) {\n            rl     = &ff_rvlc_rl_intra;\n            rl_vlc = ff_rvlc_rl_intra.rl_vlc[0];\n        } else {\n            rl     = &ff_mpeg4_rl_intra;\n            rl_vlc = ff_mpeg4_rl_intra.rl_vlc[0];\n        }\n        if (s->ac_pred) {\n            if (dc_pred_dir == 0)\n                scan_table = s->intra_v_scantable.permutated;  /* left */\n            else\n                scan_table = s->intra_h_scantable.permutated;  /* top */\n        } else {\n            scan_table = s->intra_scantable.permutated;\n        }\n        qmul = 1;\n        qadd = 0;\n    } else {\n        i = -1;\n        if (!coded) {\n            s->block_last_index[n] = i;\n            return 0;\n        }\n        if (rvlc)\n            rl = &ff_rvlc_rl_inter;\n        else\n            rl = &ff_h263_rl_inter;\n\n        scan_table = s->intra_scantable.permutated;\n\n        if (s->mpeg_quant) {\n            qmul = 1;\n            qadd = 0;\n            if (rvlc)\n                rl_vlc = ff_rvlc_rl_inter.rl_vlc[0];\n            else\n                rl_vlc = ff_h263_rl_inter.rl_vlc[0];\n        } else {\n            qmul = s->qscale << 1;\n            qadd = (s->qscale - 1) | 1;\n            if (rvlc)\n                rl_vlc = ff_rvlc_rl_inter.rl_vlc[s->qscale];\n            else\n                rl_vlc = ff_h263_rl_inter.rl_vlc[s->qscale];\n        }\n    }\n    {\n        OPEN_READER(re, &s->gb);\n        for (;;) {\n            UPDATE_CACHE(re, &s->gb);\n            GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2, 0);\n            if (level == 0) {\n                /* escape */\n                if (rvlc) {\n                    if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"1. marker bit missing in rvlc esc\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    SKIP_CACHE(re, &s->gb, 1);\n\n                    last = SHOW_UBITS(re, &s->gb, 1);\n                    SKIP_CACHE(re, &s->gb, 1);\n                    run = SHOW_UBITS(re, &s->gb, 6);\n                    SKIP_COUNTER(re, &s->gb, 1 + 1 + 6);\n                    UPDATE_CACHE(re, &s->gb);\n\n                    if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"2. marker bit missing in rvlc esc\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    SKIP_CACHE(re, &s->gb, 1);\n\n                    level = SHOW_UBITS(re, &s->gb, 11);\n                    SKIP_CACHE(re, &s->gb, 11);\n\n                    if (SHOW_UBITS(re, &s->gb, 5) != 0x10) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"reverse esc missing\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    SKIP_CACHE(re, &s->gb, 5);\n\n                    level = level * qmul + qadd;\n                    level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                    SKIP_COUNTER(re, &s->gb, 1 + 11 + 5 + 1);\n\n                    i += run + 1;\n                    if (last)\n                        i += 192;\n                } else {\n                    int cache;\n                    cache = GET_CACHE(re, &s->gb);\n\n                    if (IS_3IV1)\n                        cache ^= 0xC0000000;\n\n                    if (cache & 0x80000000) {\n                        if (cache & 0x40000000) {\n                            /* third escape */\n                            SKIP_CACHE(re, &s->gb, 2);\n                            last = SHOW_UBITS(re, &s->gb, 1);\n                            SKIP_CACHE(re, &s->gb, 1);\n                            run = SHOW_UBITS(re, &s->gb, 6);\n                            SKIP_COUNTER(re, &s->gb, 2 + 1 + 6);\n                            UPDATE_CACHE(re, &s->gb);\n\n                            if (IS_3IV1) {\n                                level = SHOW_SBITS(re, &s->gb, 12);\n                                LAST_SKIP_BITS(re, &s->gb, 12);\n                            } else {\n                                if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                                    av_log(s->avctx, AV_LOG_ERROR,\n                                           \"1. marker bit missing in 3. esc\\n\");\n                                    if (!(s->avctx->err_recognition & AV_EF_IGNORE_ERR))\n                                        return AVERROR_INVALIDDATA;\n                                }\n                                SKIP_CACHE(re, &s->gb, 1);\n\n                                level = SHOW_SBITS(re, &s->gb, 12);\n                                SKIP_CACHE(re, &s->gb, 12);\n\n                                if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                                    av_log(s->avctx, AV_LOG_ERROR,\n                                           \"2. marker bit missing in 3. esc\\n\");\n                                    if (!(s->avctx->err_recognition & AV_EF_IGNORE_ERR))\n                                        return AVERROR_INVALIDDATA;\n                                }\n\n                                SKIP_COUNTER(re, &s->gb, 1 + 12 + 1);\n                            }\n\n#if 0\n                            if (s->error_recognition >= FF_ER_COMPLIANT) {\n                                const int abs_level= FFABS(level);\n                                if (abs_level<=MAX_LEVEL && run<=MAX_RUN) {\n                                    const int run1= run - rl->max_run[last][abs_level] - 1;\n                                    if (abs_level <= rl->max_level[last][run]) {\n                                        av_log(s->avctx, AV_LOG_ERROR, \"illegal 3. esc, vlc encoding possible\\n\");\n                                        return AVERROR_INVALIDDATA;\n                                    }\n                                    if (s->error_recognition > FF_ER_COMPLIANT) {\n                                        if (abs_level <= rl->max_level[last][run]*2) {\n                                            av_log(s->avctx, AV_LOG_ERROR, \"illegal 3. esc, esc 1 encoding possible\\n\");\n                                            return AVERROR_INVALIDDATA;\n                                        }\n                                        if (run1 >= 0 && abs_level <= rl->max_level[last][run1]) {\n                                            av_log(s->avctx, AV_LOG_ERROR, \"illegal 3. esc, esc 2 encoding possible\\n\");\n                                            return AVERROR_INVALIDDATA;\n                                        }\n                                    }\n                                }\n                            }\n#endif\n                            if (level > 0)\n                                level = level * qmul + qadd;\n                            else\n                                level = level * qmul - qadd;\n\n                            if ((unsigned)(level + 2048) > 4095) {\n                                if (s->avctx->err_recognition & (AV_EF_BITSTREAM|AV_EF_AGGRESSIVE)) {\n                                    if (level > 2560 || level < -2560) {\n                                        av_log(s->avctx, AV_LOG_ERROR,\n                                               \"|level| overflow in 3. esc, qp=%d\\n\",\n                                               s->qscale);\n                                        return AVERROR_INVALIDDATA;\n                                    }\n                                }\n                                level = level < 0 ? -2048 : 2047;\n                            }\n\n                            i += run + 1;\n                            if (last)\n                                i += 192;\n                        } else {\n                            /* second escape */\n                            SKIP_BITS(re, &s->gb, 2);\n                            GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2, 1);\n                            i    += run + rl->max_run[run >> 7][level / qmul] + 1;  // FIXME opt indexing\n                            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                            LAST_SKIP_BITS(re, &s->gb, 1);\n                        }\n                    } else {\n                        /* first escape */\n                        SKIP_BITS(re, &s->gb, 1);\n                        GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2, 1);\n                        i    += run;\n                        level = level + rl->max_level[run >> 7][(run - 1) & 63] * qmul;  // FIXME opt indexing\n                        level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                        LAST_SKIP_BITS(re, &s->gb, 1);\n                    }\n                }\n            } else {\n                i    += run;\n                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                LAST_SKIP_BITS(re, &s->gb, 1);\n            }\n            ff_tlog(s->avctx, \"dct[%d][%d] = %- 4d end?:%d\\n\", scan_table[i&63]&7, scan_table[i&63] >> 3, level, i>62);\n            if (i > 62) {\n                i -= 192;\n                if (i & (~63)) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"ac-tex damaged at %d %d\\n\", s->mb_x, s->mb_y);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                block[scan_table[i]] = level;\n                break;\n            }\n\n            block[scan_table[i]] = level;\n        }\n        CLOSE_READER(re, &s->gb);\n    }\n\nnot_coded:\n    if (intra) {\n        if (!ctx->use_intra_dc_vlc) {\n            block[0] = ff_mpeg4_pred_dc(s, n, block[0], &dc_pred_dir, 0);\n\n            i -= i >> 31;  // if (i == -1) i = 0;\n        }\n\n        ff_mpeg4_pred_ac(s, block, n, dc_pred_dir);\n        if (s->ac_pred)\n            i = 63;  // FIXME not optimal\n    }\n    s->block_last_index[n] = i;\n    return 0;\n}\n\n/**\n * decode partition C of one MB.\n * @return <0 if an error occurred\n */\nstatic int mpeg4_decode_partitioned_mb(MpegEncContext *s, int16_t block[6][64])\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n    int cbp, mb_type;\n    const int xy = s->mb_x + s->mb_y * s->mb_stride;\n\n    av_assert2(s == (void*)ctx);\n\n    mb_type = s->current_picture.mb_type[xy];\n    cbp     = s->cbp_table[xy];\n\n    ctx->use_intra_dc_vlc = s->qscale < ctx->intra_dc_threshold;\n\n    if (s->current_picture.qscale_table[xy] != s->qscale)\n        ff_set_qscale(s, s->current_picture.qscale_table[xy]);\n\n    if (s->pict_type == AV_PICTURE_TYPE_P ||\n        s->pict_type == AV_PICTURE_TYPE_S) {\n        int i;\n        for (i = 0; i < 4; i++) {\n            s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0];\n            s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1];\n        }\n        s->mb_intra = IS_INTRA(mb_type);\n\n        if (IS_SKIP(mb_type)) {\n            /* skip mb */\n            for (i = 0; i < 6; i++)\n                s->block_last_index[i] = -1;\n            s->mv_dir  = MV_DIR_FORWARD;\n            s->mv_type = MV_TYPE_16X16;\n            if (s->pict_type == AV_PICTURE_TYPE_S\n                && ctx->vol_sprite_usage == GMC_SPRITE) {\n                s->mcsel      = 1;\n                s->mb_skipped = 0;\n            } else {\n                s->mcsel      = 0;\n                s->mb_skipped = 1;\n            }\n        } else if (s->mb_intra) {\n            s->ac_pred = IS_ACPRED(s->current_picture.mb_type[xy]);\n        } else if (!s->mb_intra) {\n            // s->mcsel = 0;  // FIXME do we need to init that?\n\n            s->mv_dir = MV_DIR_FORWARD;\n            if (IS_8X8(mb_type)) {\n                s->mv_type = MV_TYPE_8X8;\n            } else {\n                s->mv_type = MV_TYPE_16X16;\n            }\n        }\n    } else { /* I-Frame */\n        s->mb_intra = 1;\n        s->ac_pred  = IS_ACPRED(s->current_picture.mb_type[xy]);\n    }\n\n    if (!IS_SKIP(mb_type)) {\n        int i;\n        s->bdsp.clear_blocks(s->block[0]);\n        /* decode each block */\n        for (i = 0; i < 6; i++) {\n            if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, s->mb_intra, ctx->rvlc) < 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"texture corrupted at %d %d %d\\n\",\n                       s->mb_x, s->mb_y, s->mb_intra);\n                return AVERROR_INVALIDDATA;\n            }\n            cbp += cbp;\n        }\n    }\n\n    /* per-MB end of slice check */\n    if (--s->mb_num_left <= 0) {\n        if (mpeg4_is_resync(ctx))\n            return SLICE_END;\n        else\n            return SLICE_NOEND;\n    } else {\n        if (mpeg4_is_resync(ctx)) {\n            const int delta = s->mb_x + 1 == s->mb_width ? 2 : 1;\n            if (s->cbp_table[xy + delta])\n                return SLICE_END;\n        }\n        return SLICE_OK;\n    }\n}\n\nstatic int mpeg4_decode_mb(MpegEncContext *s, int16_t block[6][64])\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;\n    int16_t *mot_val;\n    static const int8_t quant_tab[4] = { -1, -2, 1, 2 };\n    const int xy = s->mb_x + s->mb_y * s->mb_stride;\n\n    av_assert2(s ==  (void*)ctx);\n    av_assert2(s->h263_pred);\n\n    if (s->pict_type == AV_PICTURE_TYPE_P ||\n        s->pict_type == AV_PICTURE_TYPE_S) {\n        do {\n            if (get_bits1(&s->gb)) {\n                /* skip mb */\n                s->mb_intra = 0;\n                for (i = 0; i < 6; i++)\n                    s->block_last_index[i] = -1;\n                s->mv_dir  = MV_DIR_FORWARD;\n                s->mv_type = MV_TYPE_16X16;\n                if (s->pict_type == AV_PICTURE_TYPE_S &&\n                    ctx->vol_sprite_usage == GMC_SPRITE) {\n                    s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                     MB_TYPE_GMC   |\n                                                     MB_TYPE_16x16 |\n                                                     MB_TYPE_L0;\n                    s->mcsel       = 1;\n                    s->mv[0][0][0] = get_amv(ctx, 0);\n                    s->mv[0][0][1] = get_amv(ctx, 1);\n                    s->mb_skipped  = 0;\n                } else {\n                    s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                     MB_TYPE_16x16 |\n                                                     MB_TYPE_L0;\n                    s->mcsel       = 0;\n                    s->mv[0][0][0] = 0;\n                    s->mv[0][0][1] = 0;\n                    s->mb_skipped  = 1;\n                }\n                goto end;\n            }\n            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"mcbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n                return AVERROR_INVALIDDATA;\n            }\n        } while (cbpc == 20);\n\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant      = cbpc & 8;\n        s->mb_intra = ((cbpc & 4) != 0);\n        if (s->mb_intra)\n            goto intra;\n\n        if (s->pict_type == AV_PICTURE_TYPE_S &&\n            ctx->vol_sprite_usage == GMC_SPRITE && (cbpc & 16) == 0)\n            s->mcsel = get_bits1(&s->gb);\n        else\n            s->mcsel = 0;\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1) ^ 0x0F;\n        if (cbpy < 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"P cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant)\n            ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n        if ((!s->progressive_sequence) &&\n            (cbp || (s->workaround_bugs & FF_BUG_XVID_ILACE)))\n            s->interlaced_dct = get_bits1(&s->gb);\n\n        s->mv_dir = MV_DIR_FORWARD;\n        if ((cbpc & 16) == 0) {\n            if (s->mcsel) {\n                s->current_picture.mb_type[xy] = MB_TYPE_GMC   |\n                                                 MB_TYPE_16x16 |\n                                                 MB_TYPE_L0;\n                /* 16x16 global motion prediction */\n                s->mv_type     = MV_TYPE_16X16;\n                mx             = get_amv(ctx, 0);\n                my             = get_amv(ctx, 1);\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n            } else if ((!s->progressive_sequence) && get_bits1(&s->gb)) {\n                s->current_picture.mb_type[xy] = MB_TYPE_16x8 |\n                                                 MB_TYPE_L0   |\n                                                 MB_TYPE_INTERLACED;\n                /* 16x8 field motion prediction */\n                s->mv_type = MV_TYPE_FIELD;\n\n                s->field_select[0][0] = get_bits1(&s->gb);\n                s->field_select[0][1] = get_bits1(&s->gb);\n\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n\n                for (i = 0; i < 2; i++) {\n                    mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n                    if (mx >= 0xffff)\n                        return AVERROR_INVALIDDATA;\n\n                    my = ff_h263_decode_motion(s, pred_y / 2, s->f_code);\n                    if (my >= 0xffff)\n                        return AVERROR_INVALIDDATA;\n\n                    s->mv[0][i][0] = mx;\n                    s->mv[0][i][1] = my;\n                }\n            } else {\n                s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n                /* 16x16 motion prediction */\n                s->mv_type = MV_TYPE_16X16;\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n\n                if (mx >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n\n                my = ff_h263_decode_motion(s, pred_y, s->f_code);\n\n                if (my >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n            }\n        } else {\n            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;\n            s->mv_type                     = MV_TYPE_8X8;\n            for (i = 0; i < 4; i++) {\n                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                mx      = ff_h263_decode_motion(s, pred_x, s->f_code);\n                if (mx >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n\n                my = ff_h263_decode_motion(s, pred_y, s->f_code);\n                if (my >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n                s->mv[0][i][0] = mx;\n                s->mv[0][i][1] = my;\n                mot_val[0]     = mx;\n                mot_val[1]     = my;\n            }\n        }\n    } else if (s->pict_type == AV_PICTURE_TYPE_B) {\n        int modb1;   // first bit of modb\n        int modb2;   // second bit of modb\n        int mb_type;\n\n        s->mb_intra = 0;  // B-frames never contain intra blocks\n        s->mcsel    = 0;  //      ...               true gmc blocks\n\n        if (s->mb_x == 0) {\n            for (i = 0; i < 2; i++) {\n                s->last_mv[i][0][0] =\n                s->last_mv[i][0][1] =\n                s->last_mv[i][1][0] =\n                s->last_mv[i][1][1] = 0;\n            }\n\n            ff_thread_await_progress(&s->next_picture_ptr->tf, s->mb_y, 0);\n        }\n\n        /* if we skipped it in the future P-frame than skip it now too */\n        s->mb_skipped = s->next_picture.mbskip_table[s->mb_y * s->mb_stride + s->mb_x];  // Note, skiptab=0 if last was GMC\n\n        if (s->mb_skipped) {\n            /* skip mb */\n            for (i = 0; i < 6; i++)\n                s->block_last_index[i] = -1;\n\n            s->mv_dir      = MV_DIR_FORWARD;\n            s->mv_type     = MV_TYPE_16X16;\n            s->mv[0][0][0] =\n            s->mv[0][0][1] =\n            s->mv[1][0][0] =\n            s->mv[1][0][1] = 0;\n            s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                             MB_TYPE_16x16 |\n                                             MB_TYPE_L0;\n            goto end;\n        }\n\n        modb1 = get_bits1(&s->gb);\n        if (modb1) {\n            // like MB_TYPE_B_DIRECT but no vectors coded\n            mb_type = MB_TYPE_DIRECT2 | MB_TYPE_SKIP | MB_TYPE_L0L1;\n            cbp     = 0;\n        } else {\n            modb2   = get_bits1(&s->gb);\n            mb_type = get_vlc2(&s->gb, mb_type_b_vlc.table, MB_TYPE_B_VLC_BITS, 1);\n            if (mb_type < 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"illegal MB_type\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            mb_type = mb_type_b_map[mb_type];\n            if (modb2) {\n                cbp = 0;\n            } else {\n                s->bdsp.clear_blocks(s->block[0]);\n                cbp = get_bits(&s->gb, 6);\n            }\n\n            if ((!IS_DIRECT(mb_type)) && cbp) {\n                if (get_bits1(&s->gb))\n                    ff_set_qscale(s, s->qscale + get_bits1(&s->gb) * 4 - 2);\n            }\n\n            if (!s->progressive_sequence) {\n                if (cbp)\n                    s->interlaced_dct = get_bits1(&s->gb);\n\n                if (!IS_DIRECT(mb_type) && get_bits1(&s->gb)) {\n                    mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;\n                    mb_type &= ~MB_TYPE_16x16;\n\n                    if (USES_LIST(mb_type, 0)) {\n                        s->field_select[0][0] = get_bits1(&s->gb);\n                        s->field_select[0][1] = get_bits1(&s->gb);\n                    }\n                    if (USES_LIST(mb_type, 1)) {\n                        s->field_select[1][0] = get_bits1(&s->gb);\n                        s->field_select[1][1] = get_bits1(&s->gb);\n                    }\n                }\n            }\n\n            s->mv_dir = 0;\n            if ((mb_type & (MB_TYPE_DIRECT2 | MB_TYPE_INTERLACED)) == 0) {\n                s->mv_type = MV_TYPE_16X16;\n\n                if (USES_LIST(mb_type, 0)) {\n                    s->mv_dir = MV_DIR_FORWARD;\n\n                    mx = ff_h263_decode_motion(s, s->last_mv[0][0][0], s->f_code);\n                    my = ff_h263_decode_motion(s, s->last_mv[0][0][1], s->f_code);\n                    s->last_mv[0][1][0] =\n                    s->last_mv[0][0][0] =\n                    s->mv[0][0][0]      = mx;\n                    s->last_mv[0][1][1] =\n                    s->last_mv[0][0][1] =\n                    s->mv[0][0][1]      = my;\n                }\n\n                if (USES_LIST(mb_type, 1)) {\n                    s->mv_dir |= MV_DIR_BACKWARD;\n\n                    mx = ff_h263_decode_motion(s, s->last_mv[1][0][0], s->b_code);\n                    my = ff_h263_decode_motion(s, s->last_mv[1][0][1], s->b_code);\n                    s->last_mv[1][1][0] =\n                    s->last_mv[1][0][0] =\n                    s->mv[1][0][0]      = mx;\n                    s->last_mv[1][1][1] =\n                    s->last_mv[1][0][1] =\n                    s->mv[1][0][1]      = my;\n                }\n            } else if (!IS_DIRECT(mb_type)) {\n                s->mv_type = MV_TYPE_FIELD;\n\n                if (USES_LIST(mb_type, 0)) {\n                    s->mv_dir = MV_DIR_FORWARD;\n\n                    for (i = 0; i < 2; i++) {\n                        mx = ff_h263_decode_motion(s, s->last_mv[0][i][0], s->f_code);\n                        my = ff_h263_decode_motion(s, s->last_mv[0][i][1] / 2, s->f_code);\n                        s->last_mv[0][i][0] =\n                        s->mv[0][i][0]      = mx;\n                        s->last_mv[0][i][1] = (s->mv[0][i][1] = my) * 2;\n                    }\n                }\n\n                if (USES_LIST(mb_type, 1)) {\n                    s->mv_dir |= MV_DIR_BACKWARD;\n\n                    for (i = 0; i < 2; i++) {\n                        mx = ff_h263_decode_motion(s, s->last_mv[1][i][0], s->b_code);\n                        my = ff_h263_decode_motion(s, s->last_mv[1][i][1] / 2, s->b_code);\n                        s->last_mv[1][i][0] =\n                        s->mv[1][i][0]      = mx;\n                        s->last_mv[1][i][1] = (s->mv[1][i][1] = my) * 2;\n                    }\n                }\n            }\n        }\n\n        if (IS_DIRECT(mb_type)) {\n            if (IS_SKIP(mb_type)) {\n                mx =\n                my = 0;\n            } else {\n                mx = ff_h263_decode_motion(s, 0, 1);\n                my = ff_h263_decode_motion(s, 0, 1);\n            }\n\n            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;\n            mb_type  |= ff_mpeg4_set_direct_mv(s, mx, my);\n        }\n        s->current_picture.mb_type[xy] = mb_type;\n    } else { /* I-Frame */\n        do {\n            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"I cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n                return AVERROR_INVALIDDATA;\n            }\n        } while (cbpc == 8);\n\n        dquant = cbpc & 4;\n        s->mb_intra = 1;\n\nintra:\n        s->ac_pred = get_bits1(&s->gb);\n        if (s->ac_pred)\n            s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;\n        else\n            s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if (cbpy < 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n        cbp = (cbpc & 3) | (cbpy << 2);\n\n        ctx->use_intra_dc_vlc = s->qscale < ctx->intra_dc_threshold;\n\n        if (dquant)\n            ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n\n        if (!s->progressive_sequence)\n            s->interlaced_dct = get_bits1(&s->gb);\n\n        s->bdsp.clear_blocks(s->block[0]);\n        /* decode each block */\n        for (i = 0; i < 6; i++) {\n            if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, 1, 0) < 0)\n                return AVERROR_INVALIDDATA;\n            cbp += cbp;\n        }\n        goto end;\n    }\n\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, 0, 0) < 0)\n            return AVERROR_INVALIDDATA;\n        cbp += cbp;\n    }\n\nend:\n    /* per-MB end of slice check */\n    if (s->codec_id == AV_CODEC_ID_MPEG4) {\n        int next = mpeg4_is_resync(ctx);\n        if (next) {\n            if        (s->mb_x + s->mb_y*s->mb_width + 1 >  next && (s->avctx->err_recognition & AV_EF_AGGRESSIVE)) {\n                return AVERROR_INVALIDDATA;\n            } else if (s->mb_x + s->mb_y*s->mb_width + 1 >= next)\n                return SLICE_END;\n\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n                const int delta= s->mb_x + 1 == s->mb_width ? 2 : 1;\n                ff_thread_await_progress(&s->next_picture_ptr->tf,\n                                         (s->mb_x + delta >= s->mb_width)\n                                         ? FFMIN(s->mb_y + 1, s->mb_height - 1)\n                                         : s->mb_y, 0);\n                if (s->next_picture.mbskip_table[xy + delta])\n                    return SLICE_OK;\n            }\n\n            return SLICE_END;\n        }\n    }\n\n    return SLICE_OK;\n}\n\n/* As per spec, studio start code search isn't the same as the old type of start code */\nstatic void next_start_code_studio(GetBitContext *gb)\n{\n    align_get_bits(gb);\n\n    while (get_bits_left(gb) >= 24 && show_bits_long(gb, 24) != 0x1) {\n        get_bits(gb, 8);\n    }\n}\n\n/* additional_code, vlc index */\nstatic const uint8_t ac_state_tab[22][2] =\n{\n    {0, 0},\n    {0, 1},\n    {1, 1},\n    {2, 1},\n    {3, 1},\n    {4, 1},\n    {5, 1},\n    {1, 2},\n    {2, 2},\n    {3, 2},\n    {4, 2},\n    {5, 2},\n    {6, 2},\n    {1, 3},\n    {2, 4},\n    {3, 5},\n    {4, 6},\n    {5, 7},\n    {6, 8},\n    {7, 9},\n    {8, 10},\n    {0, 11}\n};\n\nstatic int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n\n    int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,\n        additional_code_len, sign, mismatch;\n    VLC *cur_vlc = &ctx->studio_intra_tab[0];\n    uint8_t *const scantable = s->intra_scantable.permutated;\n    const uint16_t *quant_matrix;\n    uint32_t flc;\n    const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));\n    const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);\n\n    mismatch = 1;\n\n    memset(block, 0, 64 * sizeof(int32_t));\n\n    if (n < 4) {\n        cc = 0;\n        dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->intra_matrix;\n    } else {\n        cc = (n & 1) + 1;\n        if (ctx->rgb)\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        else\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->chroma_intra_matrix;\n    }\n\n    if (dct_dc_size < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal dct_dc_size vlc\\n\");\n        return AVERROR_INVALIDDATA;\n    } else if (dct_dc_size == 0) {\n        dct_diff = 0;\n    } else {\n        dct_diff = get_xbits(&s->gb, dct_dc_size);\n\n        if (dct_dc_size > 8) {\n            if(!check_marker(s->avctx, &s->gb, \"dct_dc_size > 8\"))\n                return AVERROR_INVALIDDATA;\n        }\n\n    }\n\n    s->last_dc[cc] += dct_diff;\n\n    if (s->mpeg_quant)\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);\n    else\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);\n    /* TODO: support mpeg_quant for AC coefficients */\n\n    block[0] = av_clip(block[0], min, max);\n    mismatch ^= block[0];\n\n    /* AC Coefficients */\n    while (1) {\n        group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);\n\n        if (group < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal ac coefficient group vlc\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        additional_code_len = ac_state_tab[group][0];\n        cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];\n\n        if (group == 0) {\n            /* End of Block */\n            break;\n        } else if (group >= 1 && group <= 6) {\n            /* Zero run length (Table B.47) */\n            run = 1 << additional_code_len;\n            if (additional_code_len)\n                run += get_bits(&s->gb, additional_code_len);\n            idx += run;\n            continue;\n        } else if (group >= 7 && group <= 12) {\n            /* Zero run length and +/-1 level (Table B.48) */\n            code = get_bits(&s->gb, additional_code_len);\n            sign = code & 1;\n            code >>= 1;\n            run = (1 << (additional_code_len - 1)) + code;\n            idx += run;\n            j = scantable[idx++];\n            block[j] = sign ? 1 : -1;\n        } else if (group >= 13 && group <= 20) {\n            /* Level value (Table B.49) */\n            j = scantable[idx++];\n            block[j] = get_xbits(&s->gb, additional_code_len);\n        } else if (group == 21) {\n            /* Escape */\n            j = scantable[idx++];\n            additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;\n            flc = get_bits(&s->gb, additional_code_len);\n            if (flc >> (additional_code_len-1))\n                block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);\n            else\n                block[j] = flc;\n        }\n        block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;\n        block[j] = av_clip(block[j], min, max);\n        mismatch ^= block[j];\n    }\n\n    block[63] ^= mismatch & 1;\n\n    return 0;\n}\n\nstatic int mpeg4_decode_studio_mb(MpegEncContext *s, int16_t block_[12][64])\n{\n    int i;\n\n    /* StudioMacroblock */\n    /* Assumes I-VOP */\n    s->mb_intra = 1;\n    if (get_bits1(&s->gb)) { /* compression_mode */\n        /* DCT */\n        /* macroblock_type, 1 or 2-bit VLC */\n        if (!get_bits1(&s->gb)) {\n            skip_bits1(&s->gb);\n            s->qscale = mpeg_get_qscale(s);\n        }\n\n        for (i = 0; i < mpeg4_block_count[s->chroma_format]; i++) {\n            if (mpeg4_decode_studio_block(s, (*s->block32)[i], i) < 0)\n                return AVERROR_INVALIDDATA;\n        }\n    } else {\n        /* DPCM */\n        check_marker(s->avctx, &s->gb, \"DPCM block start\");\n        avpriv_request_sample(s->avctx, \"DPCM encoded block\");\n        next_start_code_studio(&s->gb);\n        return SLICE_ERROR;\n    }\n\n    if (get_bits_left(&s->gb) >= 24 && show_bits(&s->gb, 23) == 0) {\n        next_start_code_studio(&s->gb);\n        return SLICE_END;\n    }\n\n    return SLICE_OK;\n}\n\nstatic int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n{\n    int hours, minutes, seconds;\n\n    if (!show_bits(gb, 23)) {\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    hours   = get_bits(gb, 5);\n    minutes = get_bits(gb, 6);\n    check_marker(s->avctx, gb, \"in gop_header\");\n    seconds = get_bits(gb, 6);\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n    skip_bits1(gb);\n    skip_bits1(gb);\n\n    return 0;\n}\n\nstatic int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n{\n\n    *profile = get_bits(gb, 4);\n    *level   = get_bits(gb, 4);\n\n    // for Simple profile, level 0\n    if (*profile == 0 && *level == 8) {\n        *level = 0;\n    }\n\n    return 0;\n}\n\nstatic int mpeg4_decode_visual_object(MpegEncContext *s, GetBitContext *gb)\n{\n    int visual_object_type;\n    int is_visual_object_identifier = get_bits1(gb);\n\n    if (is_visual_object_identifier) {\n        skip_bits(gb, 4+3);\n    }\n    visual_object_type = get_bits(gb, 4);\n\n    if (visual_object_type == VOT_VIDEO_ID ||\n        visual_object_type == VOT_STILL_TEXTURE_ID) {\n        int video_signal_type = get_bits1(gb);\n        if (video_signal_type) {\n            int video_range, color_description;\n            skip_bits(gb, 3); // video_format\n            video_range = get_bits1(gb);\n            color_description = get_bits1(gb);\n\n            s->avctx->color_range = video_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;\n\n            if (color_description) {\n                s->avctx->color_primaries = get_bits(gb, 8);\n                s->avctx->color_trc       = get_bits(gb, 8);\n                s->avctx->colorspace      = get_bits(gb, 8);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic void mpeg4_load_default_matrices(MpegEncContext *s)\n{\n    int i, v;\n\n    /* load default matrices */\n    for (i = 0; i < 64; i++) {\n        int j = s->idsp.idct_permutation[i];\n        v = ff_mpeg4_default_intra_matrix[i];\n        s->intra_matrix[j]        = v;\n        s->chroma_intra_matrix[j] = v;\n\n        v = ff_mpeg4_default_non_intra_matrix[i];\n        s->inter_matrix[j]        = v;\n        s->chroma_inter_matrix[j] = v;\n    }\n}\n\nstatic int decode_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int width, height, vo_ver_id;\n\n    /* vol header */\n    skip_bits(gb, 1);                   /* random access */\n    s->vo_type = get_bits(gb, 8);\n\n    /* If we are in studio profile (per vo_type), check if its all consistent\n     * and if so continue pass control to decode_studio_vol_header().\n     * elIf something is inconsistent, error out\n     * else continue with (non studio) vol header decpoding.\n     */\n    if (s->vo_type == CORE_STUDIO_VO_TYPE ||\n        s->vo_type == SIMPLE_STUDIO_VO_TYPE) {\n        if (s->avctx->profile != FF_PROFILE_UNKNOWN && s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n            return AVERROR_INVALIDDATA;\n        s->studio_profile = 1;\n        s->avctx->profile = FF_PROFILE_MPEG4_SIMPLE_STUDIO;\n        return decode_studio_vol_header(ctx, gb);\n    } else if (s->studio_profile) {\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (get_bits1(gb) != 0) {           /* is_ol_id */\n        vo_ver_id = get_bits(gb, 4);    /* vo_ver_id */\n        skip_bits(gb, 3);               /* vo_priority */\n    } else {\n        vo_ver_id = 1;\n    }\n    s->aspect_ratio_info = get_bits(gb, 4);\n    if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n        s->avctx->sample_aspect_ratio.num = get_bits(gb, 8);  // par_width\n        s->avctx->sample_aspect_ratio.den = get_bits(gb, 8);  // par_height\n    } else {\n        s->avctx->sample_aspect_ratio = ff_h263_pixel_aspect[s->aspect_ratio_info];\n    }\n\n    if ((ctx->vol_control_parameters = get_bits1(gb))) { /* vol control parameter */\n        int chroma_format = get_bits(gb, 2);\n        if (chroma_format != CHROMA_420)\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal chroma format\\n\");\n\n        s->low_delay = get_bits1(gb);\n        if (get_bits1(gb)) {    /* vbv parameters */\n            get_bits(gb, 15);   /* first_half_bitrate */\n            check_marker(s->avctx, gb, \"after first_half_bitrate\");\n            get_bits(gb, 15);   /* latter_half_bitrate */\n            check_marker(s->avctx, gb, \"after latter_half_bitrate\");\n            get_bits(gb, 15);   /* first_half_vbv_buffer_size */\n            check_marker(s->avctx, gb, \"after first_half_vbv_buffer_size\");\n            get_bits(gb, 3);    /* latter_half_vbv_buffer_size */\n            get_bits(gb, 11);   /* first_half_vbv_occupancy */\n            check_marker(s->avctx, gb, \"after first_half_vbv_occupancy\");\n            get_bits(gb, 15);   /* latter_half_vbv_occupancy */\n            check_marker(s->avctx, gb, \"after latter_half_vbv_occupancy\");\n        }\n    } else {\n        /* is setting low delay flag only once the smartest thing to do?\n         * low delay detection will not be overridden. */\n        if (s->picture_number == 0) {\n            switch(s->vo_type) {\n            case SIMPLE_VO_TYPE:\n            case ADV_SIMPLE_VO_TYPE:\n                s->low_delay = 1;\n                break;\n            default:\n                s->low_delay = 0;\n            }\n        }\n    }\n\n    ctx->shape = get_bits(gb, 2); /* vol shape */\n    if (ctx->shape != RECT_SHAPE)\n        av_log(s->avctx, AV_LOG_ERROR, \"only rectangular vol supported\\n\");\n    if (ctx->shape == GRAY_SHAPE && vo_ver_id != 1) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Gray shape not supported\\n\");\n        skip_bits(gb, 4);  /* video_object_layer_shape_extension */\n    }\n\n    check_marker(s->avctx, gb, \"before time_increment_resolution\");\n\n    s->avctx->framerate.num = get_bits(gb, 16);\n    if (!s->avctx->framerate.num) {\n        av_log(s->avctx, AV_LOG_ERROR, \"framerate==0\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->time_increment_bits = av_log2(s->avctx->framerate.num - 1) + 1;\n    if (ctx->time_increment_bits < 1)\n        ctx->time_increment_bits = 1;\n\n    check_marker(s->avctx, gb, \"before fixed_vop_rate\");\n\n    if (get_bits1(gb) != 0)     /* fixed_vop_rate  */\n        s->avctx->framerate.den = get_bits(gb, ctx->time_increment_bits);\n    else\n        s->avctx->framerate.den = 1;\n\n    s->avctx->time_base = av_inv_q(av_mul_q(s->avctx->framerate, (AVRational){s->avctx->ticks_per_frame, 1}));\n\n    ctx->t_frame = 0;\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        if (ctx->shape == RECT_SHAPE) {\n            check_marker(s->avctx, gb, \"before width\");\n            width = get_bits(gb, 13);\n            check_marker(s->avctx, gb, \"before height\");\n            height = get_bits(gb, 13);\n            check_marker(s->avctx, gb, \"after height\");\n            if (width && height &&  /* they should be non zero but who knows */\n                !(s->width && s->codec_tag == AV_RL32(\"MP4S\"))) {\n                if (s->width && s->height &&\n                    (s->width != width || s->height != height))\n                    s->context_reinit = 1;\n                s->width  = width;\n                s->height = height;\n            }\n        }\n\n        s->progressive_sequence  =\n        s->progressive_frame     = get_bits1(gb) ^ 1;\n        s->interlaced_dct        = 0;\n        if (!get_bits1(gb) && (s->avctx->debug & FF_DEBUG_PICT_INFO))\n            av_log(s->avctx, AV_LOG_INFO,           /* OBMC Disable */\n                   \"MPEG-4 OBMC not supported (very likely buggy encoder)\\n\");\n        if (vo_ver_id == 1)\n            ctx->vol_sprite_usage = get_bits1(gb);    /* vol_sprite_usage */\n        else\n            ctx->vol_sprite_usage = get_bits(gb, 2);  /* vol_sprite_usage */\n\n        if (ctx->vol_sprite_usage == STATIC_SPRITE)\n            av_log(s->avctx, AV_LOG_ERROR, \"Static Sprites not supported\\n\");\n        if (ctx->vol_sprite_usage == STATIC_SPRITE ||\n            ctx->vol_sprite_usage == GMC_SPRITE) {\n            if (ctx->vol_sprite_usage == STATIC_SPRITE) {\n                skip_bits(gb, 13); // sprite_width\n                check_marker(s->avctx, gb, \"after sprite_width\");\n                skip_bits(gb, 13); // sprite_height\n                check_marker(s->avctx, gb, \"after sprite_height\");\n                skip_bits(gb, 13); // sprite_left\n                check_marker(s->avctx, gb, \"after sprite_left\");\n                skip_bits(gb, 13); // sprite_top\n                check_marker(s->avctx, gb, \"after sprite_top\");\n            }\n            ctx->num_sprite_warping_points = get_bits(gb, 6);\n            if (ctx->num_sprite_warping_points > 3) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"%d sprite_warping_points\\n\",\n                       ctx->num_sprite_warping_points);\n                ctx->num_sprite_warping_points = 0;\n                return AVERROR_INVALIDDATA;\n            }\n            s->sprite_warping_accuracy  = get_bits(gb, 2);\n            ctx->sprite_brightness_change = get_bits1(gb);\n            if (ctx->vol_sprite_usage == STATIC_SPRITE)\n                skip_bits1(gb); // low_latency_sprite\n        }\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        if (get_bits1(gb) == 1) {                   /* not_8_bit */\n            s->quant_precision = get_bits(gb, 4);   /* quant_precision */\n            if (get_bits(gb, 4) != 8)               /* bits_per_pixel */\n                av_log(s->avctx, AV_LOG_ERROR, \"N-bit not supported\\n\");\n            if (s->quant_precision != 5)\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"quant precision %d\\n\", s->quant_precision);\n            if (s->quant_precision<3 || s->quant_precision>9) {\n                s->quant_precision = 5;\n            }\n        } else {\n            s->quant_precision = 5;\n        }\n\n        // FIXME a bunch of grayscale shape things\n\n        if ((s->mpeg_quant = get_bits1(gb))) { /* vol_quant_type */\n            int i, v;\n\n            mpeg4_load_default_matrices(s);\n\n            /* load custom intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    if (get_bits_left(gb) < 8) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"insufficient data for custom matrix\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n            }\n\n            /* load custom non intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    if (get_bits_left(gb) < 8) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"insufficient data for custom matrix\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = v;\n                    s->chroma_inter_matrix[j] = v;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = last;\n                    s->chroma_inter_matrix[j] = last;\n                }\n            }\n\n            // FIXME a bunch of grayscale shape things\n        }\n\n        if (vo_ver_id != 1)\n            s->quarter_sample = get_bits1(gb);\n        else\n            s->quarter_sample = 0;\n\n        if (get_bits_left(gb) < 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"VOL Header truncated\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!get_bits1(gb)) {\n            int pos               = get_bits_count(gb);\n            int estimation_method = get_bits(gb, 2);\n            if (estimation_method < 2) {\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* opaque */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* transparent */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* inter_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* no_update */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* upsampling */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter4v_blocks */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* not coded blocks */\n                }\n                if (!check_marker(s->avctx, gb, \"in complexity estimation part 1\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_coeffs */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_lines */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* vlc_syms */\n                    ctx->cplx_estimation_trash_i += 4 * get_bits1(gb);  /* vlc_bits */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* apm */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* npm */\n                    ctx->cplx_estimation_trash_b += 8 * get_bits1(gb);  /* interpolate_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* forwback_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel2 */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel4 */\n                }\n                if (!check_marker(s->avctx, gb, \"in complexity estimation part 2\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (estimation_method == 1) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* sadct */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* qpel */\n                }\n            } else\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Invalid Complexity estimation method %d\\n\",\n                       estimation_method);\n        } else {\n\nno_cplx_est:\n            ctx->cplx_estimation_trash_i =\n            ctx->cplx_estimation_trash_p =\n            ctx->cplx_estimation_trash_b = 0;\n        }\n\n        ctx->resync_marker = !get_bits1(gb); /* resync_marker_disabled */\n\n        s->data_partitioning = get_bits1(gb);\n        if (s->data_partitioning)\n            ctx->rvlc = get_bits1(gb);\n\n        if (vo_ver_id != 1) {\n            ctx->new_pred = get_bits1(gb);\n            if (ctx->new_pred) {\n                av_log(s->avctx, AV_LOG_ERROR, \"new pred not supported\\n\");\n                skip_bits(gb, 2); /* requested upstream message type */\n                skip_bits1(gb);   /* newpred segment type */\n            }\n            if (get_bits1(gb)) // reduced_res_vop\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"reduced resolution VOP not supported\\n\");\n        } else {\n            ctx->new_pred = 0;\n        }\n\n        ctx->scalability = get_bits1(gb);\n\n        if (ctx->scalability) {\n            GetBitContext bak = *gb;\n            int h_sampling_factor_n;\n            int h_sampling_factor_m;\n            int v_sampling_factor_n;\n            int v_sampling_factor_m;\n\n            skip_bits1(gb);    // hierarchy_type\n            skip_bits(gb, 4);  /* ref_layer_id */\n            skip_bits1(gb);    /* ref_layer_sampling_dir */\n            h_sampling_factor_n = get_bits(gb, 5);\n            h_sampling_factor_m = get_bits(gb, 5);\n            v_sampling_factor_n = get_bits(gb, 5);\n            v_sampling_factor_m = get_bits(gb, 5);\n            ctx->enhancement_type = get_bits1(gb);\n\n            if (h_sampling_factor_n == 0 || h_sampling_factor_m == 0 ||\n                v_sampling_factor_n == 0 || v_sampling_factor_m == 0) {\n                /* illegal scalability header (VERY broken encoder),\n                 * trying to workaround */\n                ctx->scalability = 0;\n                *gb            = bak;\n            } else\n                av_log(s->avctx, AV_LOG_ERROR, \"scalability not supported\\n\");\n\n            // bin shape stuff FIXME\n        }\n    }\n\n    if (s->avctx->debug&FF_DEBUG_PICT_INFO) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d, low_delay:%d  %s%s%s%s\\n\",\n               s->avctx->framerate.den, s->avctx->framerate.num,\n               ctx->time_increment_bits,\n               s->quant_precision,\n               s->progressive_sequence,\n               s->low_delay,\n               ctx->scalability ? \"scalability \" :\"\" , s->quarter_sample ? \"qpel \" : \"\",\n               s->data_partitioning ? \"partition \" : \"\", ctx->rvlc ? \"rvlc \" : \"\"\n        );\n    }\n\n    return 0;\n}\n\n/**\n * Decode the user data stuff in the header.\n * Also initializes divx/xvid/lavc_version/build.\n */\nstatic int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    char buf[256];\n    int i;\n    int e;\n    int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n    char last;\n\n    for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {\n        if (show_bits(gb, 23) == 0)\n            break;\n        buf[i] = get_bits(gb, 8);\n    }\n    buf[i] = 0;\n\n    /* divx detection */\n    e = sscanf(buf, \"DivX%dBuild%d%c\", &ver, &build, &last);\n    if (e < 2)\n        e = sscanf(buf, \"DivX%db%d%c\", &ver, &build, &last);\n    if (e >= 2) {\n        ctx->divx_version = ver;\n        ctx->divx_build   = build;\n        s->divx_packed  = e == 3 && last == 'p';\n    }\n\n    /* libavcodec detection */\n    e = sscanf(buf, \"FFmpe%*[^b]b%d\", &build) + 3;\n    if (e != 4)\n        e = sscanf(buf, \"FFmpeg v%d.%d.%d / libavcodec build: %d\", &ver, &ver2, &ver3, &build);\n    if (e != 4) {\n        e = sscanf(buf, \"Lavc%d.%d.%d\", &ver, &ver2, &ver3) + 1;\n        if (e > 1) {\n            if (ver > 0xFFU || ver2 > 0xFFU || ver3 > 0xFFU) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                     \"Unknown Lavc version string encountered, %d.%d.%d; \"\n                     \"clamping sub-version values to 8-bits.\\n\",\n                     ver, ver2, ver3);\n            }\n            build = ((ver & 0xFF) << 16) + ((ver2 & 0xFF) << 8) + (ver3 & 0xFF);\n        }\n    }\n    if (e != 4) {\n        if (strcmp(buf, \"ffmpeg\") == 0)\n            ctx->lavc_build = 4600;\n    }\n    if (e == 4)\n        ctx->lavc_build = build;\n\n    /* Xvid detection */\n    e = sscanf(buf, \"XviD%d\", &build);\n    if (e == 1)\n        ctx->xvid_build = build;\n\n    return 0;\n}\n\nint ff_mpeg4_workaround_bugs(AVCodecContext *avctx)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    MpegEncContext *s = &ctx->m;\n\n    if (ctx->xvid_build == -1 && ctx->divx_version == -1 && ctx->lavc_build == -1) {\n        if (s->codec_tag        == AV_RL32(\"XVID\") ||\n            s->codec_tag        == AV_RL32(\"XVIX\") ||\n            s->codec_tag        == AV_RL32(\"RMP4\") ||\n            s->codec_tag        == AV_RL32(\"ZMP4\") ||\n            s->codec_tag        == AV_RL32(\"SIPP\"))\n            ctx->xvid_build = 0;\n    }\n\n    if (ctx->xvid_build == -1 && ctx->divx_version == -1 && ctx->lavc_build == -1)\n        if (s->codec_tag == AV_RL32(\"DIVX\") && s->vo_type == 0 &&\n            ctx->vol_control_parameters == 0)\n            ctx->divx_version = 400;  // divx 4\n\n    if (ctx->xvid_build >= 0 && ctx->divx_version >= 0) {\n        ctx->divx_version =\n        ctx->divx_build   = -1;\n    }\n\n    if (s->workaround_bugs & FF_BUG_AUTODETECT) {\n        if (s->codec_tag == AV_RL32(\"XVIX\"))\n            s->workaround_bugs |= FF_BUG_XVID_ILACE;\n\n        if (s->codec_tag == AV_RL32(\"UMP4\"))\n            s->workaround_bugs |= FF_BUG_UMP4;\n\n        if (ctx->divx_version >= 500 && ctx->divx_build < 1814)\n            s->workaround_bugs |= FF_BUG_QPEL_CHROMA;\n\n        if (ctx->divx_version > 502 && ctx->divx_build < 1814)\n            s->workaround_bugs |= FF_BUG_QPEL_CHROMA2;\n\n        if (ctx->xvid_build <= 3U)\n            s->padding_bug_score = 256 * 256 * 256 * 64;\n\n        if (ctx->xvid_build <= 1U)\n            s->workaround_bugs |= FF_BUG_QPEL_CHROMA;\n\n        if (ctx->xvid_build <= 12U)\n            s->workaround_bugs |= FF_BUG_EDGE;\n\n        if (ctx->xvid_build <= 32U)\n            s->workaround_bugs |= FF_BUG_DC_CLIP;\n\n#define SET_QPEL_FUNC(postfix1, postfix2)                           \\\n    s->qdsp.put_        ## postfix1 = ff_put_        ## postfix2;   \\\n    s->qdsp.put_no_rnd_ ## postfix1 = ff_put_no_rnd_ ## postfix2;   \\\n    s->qdsp.avg_        ## postfix1 = ff_avg_        ## postfix2;\n\n        if (ctx->lavc_build < 4653U)\n            s->workaround_bugs |= FF_BUG_STD_QPEL;\n\n        if (ctx->lavc_build < 4655U)\n            s->workaround_bugs |= FF_BUG_DIRECT_BLOCKSIZE;\n\n        if (ctx->lavc_build < 4670U)\n            s->workaround_bugs |= FF_BUG_EDGE;\n\n        if (ctx->lavc_build <= 4712U)\n            s->workaround_bugs |= FF_BUG_DC_CLIP;\n\n        if ((ctx->lavc_build&0xFF) >= 100) {\n            if (ctx->lavc_build > 3621476 && ctx->lavc_build < 3752552 &&\n               (ctx->lavc_build < 3752037 || ctx->lavc_build > 3752191) // 3.2.1+\n            )\n                s->workaround_bugs |= FF_BUG_IEDGE;\n        }\n\n        if (ctx->divx_version >= 0)\n            s->workaround_bugs |= FF_BUG_DIRECT_BLOCKSIZE;\n        if (ctx->divx_version == 501 && ctx->divx_build == 20020416)\n            s->padding_bug_score = 256 * 256 * 256 * 64;\n\n        if (ctx->divx_version < 500U)\n            s->workaround_bugs |= FF_BUG_EDGE;\n\n        if (ctx->divx_version >= 0)\n            s->workaround_bugs |= FF_BUG_HPEL_CHROMA;\n    }\n\n    if (s->workaround_bugs & FF_BUG_STD_QPEL) {\n        SET_QPEL_FUNC(qpel_pixels_tab[0][5], qpel16_mc11_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][7], qpel16_mc31_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][9], qpel16_mc12_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][11], qpel16_mc32_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][13], qpel16_mc13_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][15], qpel16_mc33_old_c)\n\n        SET_QPEL_FUNC(qpel_pixels_tab[1][5], qpel8_mc11_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][7], qpel8_mc31_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][9], qpel8_mc12_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][11], qpel8_mc32_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][13], qpel8_mc13_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][15], qpel8_mc33_old_c)\n    }\n\n    if (avctx->debug & FF_DEBUG_BUGS)\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \"bugs: %X lavc_build:%d xvid_build:%d divx_version:%d divx_build:%d %s\\n\",\n               s->workaround_bugs, ctx->lavc_build, ctx->xvid_build,\n               ctx->divx_version, ctx->divx_build, s->divx_packed ? \"p\" : \"\");\n\n    if (CONFIG_MPEG4_DECODER && ctx->xvid_build >= 0 &&\n        s->codec_id == AV_CODEC_ID_MPEG4 &&\n        avctx->idct_algo == FF_IDCT_AUTO) {\n        avctx->idct_algo = FF_IDCT_XVID;\n        ff_mpv_idct_init(s);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int decode_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int time_incr, time_increment;\n    int64_t pts;\n\n    s->mcsel       = 0;\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I;        /* pict type: I = 0 , P = 1 */\n    if (s->pict_type == AV_PICTURE_TYPE_B && s->low_delay &&\n        ctx->vol_control_parameters == 0 && !(s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"low_delay flag set incorrectly, clearing it\\n\");\n        s->low_delay = 0;\n    }\n\n    s->partitioned_frame = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B;\n    if (s->partitioned_frame)\n        s->decode_mb = mpeg4_decode_partitioned_mb;\n    else\n        s->decode_mb = mpeg4_decode_mb;\n\n    time_incr = 0;\n    while (get_bits1(gb) != 0)\n        time_incr++;\n\n    check_marker(s->avctx, gb, \"before time_increment\");\n\n    if (ctx->time_increment_bits == 0 ||\n        !(show_bits(gb, ctx->time_increment_bits + 1) & 1)) {\n        av_log(s->avctx, AV_LOG_WARNING,\n               \"time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\\n\", ctx->time_increment_bits);\n\n        for (ctx->time_increment_bits = 1;\n             ctx->time_increment_bits < 16;\n             ctx->time_increment_bits++) {\n            if (s->pict_type == AV_PICTURE_TYPE_P ||\n                (s->pict_type == AV_PICTURE_TYPE_S &&\n                 ctx->vol_sprite_usage == GMC_SPRITE)) {\n                if ((show_bits(gb, ctx->time_increment_bits + 6) & 0x37) == 0x30)\n                    break;\n            } else if ((show_bits(gb, ctx->time_increment_bits + 5) & 0x1F) == 0x18)\n                break;\n        }\n\n        av_log(s->avctx, AV_LOG_WARNING,\n               \"time_increment_bits set to %d bits, based on bitstream analysis\\n\", ctx->time_increment_bits);\n        if (s->avctx->framerate.num && 4*s->avctx->framerate.num < 1<<ctx->time_increment_bits) {\n            s->avctx->framerate.num = 1<<ctx->time_increment_bits;\n            s->avctx->time_base = av_inv_q(av_mul_q(s->avctx->framerate, (AVRational){s->avctx->ticks_per_frame, 1}));\n        }\n    }\n\n    if (IS_3IV1)\n        time_increment = get_bits1(gb);        // FIXME investigate further\n    else\n        time_increment = get_bits(gb, ctx->time_increment_bits);\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n        s->last_time_base = s->time_base;\n        s->time_base     += time_incr;\n        s->time = s->time_base * (int64_t)s->avctx->framerate.num + time_increment;\n        if (s->workaround_bugs & FF_BUG_UMP4) {\n            if (s->time < s->last_non_b_time) {\n                /* header is not mpeg-4-compatible, broken encoder,\n                 * trying to workaround */\n                s->time_base++;\n                s->time += s->avctx->framerate.num;\n            }\n        }\n        s->pp_time         = s->time - s->last_non_b_time;\n        s->last_non_b_time = s->time;\n    } else {\n        s->time    = (s->last_time_base + time_incr) * (int64_t)s->avctx->framerate.num + time_increment;\n        s->pb_time = s->pp_time - (s->last_non_b_time - s->time);\n        if (s->pp_time <= s->pb_time ||\n            s->pp_time <= s->pp_time - s->pb_time ||\n            s->pp_time <= 0) {\n            /* messed up order, maybe after seeking? skipping current B-frame */\n            return FRAME_SKIPPED;\n        }\n        ff_mpeg4_init_direct_mv(s);\n\n        if (ctx->t_frame == 0)\n            ctx->t_frame = s->pb_time;\n        if (ctx->t_frame == 0)\n            ctx->t_frame = 1;  // 1/0 protection\n        s->pp_field_time = (ROUNDED_DIV(s->last_non_b_time, ctx->t_frame) -\n                            ROUNDED_DIV(s->last_non_b_time - s->pp_time, ctx->t_frame)) * 2;\n        s->pb_field_time = (ROUNDED_DIV(s->time, ctx->t_frame) -\n                            ROUNDED_DIV(s->last_non_b_time - s->pp_time, ctx->t_frame)) * 2;\n        if (s->pp_field_time <= s->pb_field_time || s->pb_field_time <= 1) {\n            s->pb_field_time = 2;\n            s->pp_field_time = 4;\n            if (!s->progressive_sequence)\n                return FRAME_SKIPPED;\n        }\n    }\n\n    if (s->avctx->framerate.den)\n        pts = ROUNDED_DIV(s->time, s->avctx->framerate.den);\n    else\n        pts = AV_NOPTS_VALUE;\n    ff_dlog(s->avctx, \"MPEG4 PTS: %\"PRId64\"\\n\", pts);\n\n    check_marker(s->avctx, gb, \"before vop_coded\");\n\n    /* vop coded */\n    if (get_bits1(gb) != 1) {\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n            av_log(s->avctx, AV_LOG_ERROR, \"vop not coded\\n\");\n        return FRAME_SKIPPED;\n    }\n    if (ctx->new_pred)\n        decode_new_pred(ctx, gb);\n\n    if (ctx->shape != BIN_ONLY_SHAPE &&\n                    (s->pict_type == AV_PICTURE_TYPE_P ||\n                     (s->pict_type == AV_PICTURE_TYPE_S &&\n                      ctx->vol_sprite_usage == GMC_SPRITE))) {\n        /* rounding type for motion estimation */\n        s->no_rounding = get_bits1(gb);\n    } else {\n        s->no_rounding = 0;\n    }\n    // FIXME reduced res stuff\n\n    if (ctx->shape != RECT_SHAPE) {\n        if (ctx->vol_sprite_usage != 1 || s->pict_type != AV_PICTURE_TYPE_I) {\n            skip_bits(gb, 13);  /* width */\n            check_marker(s->avctx, gb, \"after width\");\n            skip_bits(gb, 13);  /* height */\n            check_marker(s->avctx, gb, \"after height\");\n            skip_bits(gb, 13);  /* hor_spat_ref */\n            check_marker(s->avctx, gb, \"after hor_spat_ref\");\n            skip_bits(gb, 13);  /* ver_spat_ref */\n        }\n        skip_bits1(gb);         /* change_CR_disable */\n\n        if (get_bits1(gb) != 0)\n            skip_bits(gb, 8);   /* constant_alpha_value */\n    }\n\n    // FIXME complexity estimation stuff\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        skip_bits_long(gb, ctx->cplx_estimation_trash_i);\n        if (s->pict_type != AV_PICTURE_TYPE_I)\n            skip_bits_long(gb, ctx->cplx_estimation_trash_p);\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n            skip_bits_long(gb, ctx->cplx_estimation_trash_b);\n\n        if (get_bits_left(gb) < 3) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Header truncated\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->intra_dc_threshold = ff_mpeg4_dc_threshold[get_bits(gb, 3)];\n        if (!s->progressive_sequence) {\n            s->top_field_first = get_bits1(gb);\n            s->alternate_scan  = get_bits1(gb);\n        } else\n            s->alternate_scan = 0;\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_S) {\n        if((ctx->vol_sprite_usage == STATIC_SPRITE ||\n            ctx->vol_sprite_usage == GMC_SPRITE)) {\n            if (mpeg4_decode_sprite_trajectory(ctx, gb) < 0)\n                return AVERROR_INVALIDDATA;\n            if (ctx->sprite_brightness_change)\n                av_log(s->avctx, AV_LOG_ERROR,\n                    \"sprite_brightness_change not supported\\n\");\n            if (ctx->vol_sprite_usage == STATIC_SPRITE)\n                av_log(s->avctx, AV_LOG_ERROR, \"static sprite not supported\\n\");\n        } else {\n            memset(s->sprite_offset, 0, sizeof(s->sprite_offset));\n            memset(s->sprite_delta, 0, sizeof(s->sprite_delta));\n        }\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->chroma_qscale = s->qscale = get_bits(gb, s->quant_precision);\n        if (s->qscale == 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Error, header damaged or not MPEG-4 header (qscale=0)\\n\");\n            return AVERROR_INVALIDDATA;  // makes no sense to continue, as there is nothing left from the image then\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_I) {\n            s->f_code = get_bits(gb, 3);        /* fcode_for */\n            if (s->f_code == 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Error, header damaged or not MPEG-4 header (f_code=0)\\n\");\n                s->f_code = 1;\n                return AVERROR_INVALIDDATA;  // makes no sense to continue, as there is nothing left from the image then\n            }\n        } else\n            s->f_code = 1;\n\n        if (s->pict_type == AV_PICTURE_TYPE_B) {\n            s->b_code = get_bits(gb, 3);\n            if (s->b_code == 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Error, header damaged or not MPEG4 header (b_code=0)\\n\");\n                s->b_code=1;\n                return AVERROR_INVALIDDATA; // makes no sense to continue, as the MV decoding will break very quickly\n            }\n        } else\n            s->b_code = 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n            av_log(s->avctx, AV_LOG_DEBUG,\n                   \"qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%\"PRId64\" tincr:%d\\n\",\n                   s->qscale, s->f_code, s->b_code,\n                   s->pict_type == AV_PICTURE_TYPE_I ? \"I\" : (s->pict_type == AV_PICTURE_TYPE_P ? \"P\" : (s->pict_type == AV_PICTURE_TYPE_B ? \"B\" : \"S\")),\n                   gb->size_in_bits,s->progressive_sequence, s->alternate_scan,\n                   s->top_field_first, s->quarter_sample ? \"q\" : \"h\",\n                   s->data_partitioning, ctx->resync_marker,\n                   ctx->num_sprite_warping_points, s->sprite_warping_accuracy,\n                   1 - s->no_rounding, s->vo_type,\n                   ctx->vol_control_parameters ? \" VOLC\" : \" \", ctx->intra_dc_threshold,\n                   ctx->cplx_estimation_trash_i, ctx->cplx_estimation_trash_p,\n                   ctx->cplx_estimation_trash_b,\n                   s->time,\n                   time_increment\n                  );\n        }\n\n        if (!ctx->scalability) {\n            if (ctx->shape != RECT_SHAPE && s->pict_type != AV_PICTURE_TYPE_I)\n                skip_bits1(gb);  // vop shape coding type\n        } else {\n            if (ctx->enhancement_type) {\n                int load_backward_shape = get_bits1(gb);\n                if (load_backward_shape)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"load backward shape isn't supported\\n\");\n            }\n            skip_bits(gb, 2);  // ref_select_code\n        }\n    }\n    /* detect buggy encoders which don't set the low_delay flag\n     * (divx4/xvid/opendivx). Note we cannot detect divx5 without B-frames\n     * easily (although it's buggy too) */\n    if (s->vo_type == 0 && ctx->vol_control_parameters == 0 &&\n        ctx->divx_version == -1 && s->picture_number == 0) {\n        av_log(s->avctx, AV_LOG_WARNING,\n               \"looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\\n\");\n        s->low_delay = 1;\n    }\n\n    s->picture_number++;  // better than pic number==0 always ;)\n\n    // FIXME add short header support\n    s->y_dc_scale_table = ff_mpeg4_y_dc_scale_table;\n    s->c_dc_scale_table = ff_mpeg4_c_dc_scale_table;\n\n    if (s->workaround_bugs & FF_BUG_EDGE) {\n        s->h_edge_pos = s->width;\n        s->v_edge_pos = s->height;\n    }\n    return 0;\n}\n\nstatic void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n\n    if (get_bits1(gb)) {\n        /* intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        /* non_intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    if (get_bits1(gb)) {\n        /* chroma_intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        /* chroma_non_intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    next_start_code_studio(gb);\n}\n\nstatic void extension_and_user_data(MpegEncContext *s, GetBitContext *gb, int id)\n{\n    uint32_t startcode;\n    uint8_t extension_type;\n\n    startcode = show_bits_long(gb, 32);\n    if (startcode == USER_DATA_STARTCODE || startcode == EXT_STARTCODE) {\n\n        if ((id == 2 || id == 4) && startcode == EXT_STARTCODE) {\n            skip_bits_long(gb, 32);\n            extension_type = get_bits(gb, 4);\n            if (extension_type == QUANT_MATRIX_EXT_ID)\n                read_quant_matrix_ext(s, gb);\n        }\n    }\n}\n\nstatic void decode_smpte_tc(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    skip_bits(gb, 16); /* Time_code[63..48] */\n    check_marker(s->avctx, gb, \"after Time_code[63..48]\");\n    skip_bits(gb, 16); /* Time_code[47..32] */\n    check_marker(s->avctx, gb, \"after Time_code[47..32]\");\n    skip_bits(gb, 16); /* Time_code[31..16] */\n    check_marker(s->avctx, gb, \"after Time_code[31..16]\");\n    skip_bits(gb, 16); /* Time_code[15..0] */\n    check_marker(s->avctx, gb, \"after Time_code[15..0]\");\n    skip_bits(gb, 4); /* reserved_bits */\n}\n\n/**\n * Decode the next studio vop header.\n * @return <0 if something went wrong\n */\nstatic int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    if (get_bits_left(gb) <= 32)\n        return 0;\n\n    s->decode_mb = mpeg4_decode_studio_mb;\n\n    decode_smpte_tc(ctx, gb);\n\n    skip_bits(gb, 10); /* temporal_reference */\n    skip_bits(gb, 2); /* vop_structure */\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; /* vop_coding_type */\n    if (get_bits1(gb)) { /* vop_coded */\n        skip_bits1(gb); /* top_field_first */\n        skip_bits1(gb); /* repeat_first_field */\n        s->progressive_frame = get_bits1(gb) ^ 1; /* progressive_frame */\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    mpeg4_load_default_matrices(s);\n\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n\n    return 0;\n}\n\nstatic int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int visual_object_type;\n\n        skip_bits(gb, 4); /* visual_object_verid */\n        visual_object_type = get_bits(gb, 4);\n        if (visual_object_type != VOT_VIDEO_ID) {\n            avpriv_request_sample(s->avctx, \"VO type %u\", visual_object_type);\n            return AVERROR_PATCHWELCOME;\n        }\n\n        next_start_code_studio(gb);\n        extension_and_user_data(s, gb, 1);\n\n    return 0;\n}\n\nstatic int decode_studio_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int width, height;\n    int bits_per_raw_sample;\n\n            // random_accessible_vol and video_object_type_indication have already\n            // been read by the caller decode_vol_header()\n            skip_bits(gb, 4); /* video_object_layer_verid */\n            ctx->shape = get_bits(gb, 2); /* video_object_layer_shape */\n            skip_bits(gb, 4); /* video_object_layer_shape_extension */\n            skip_bits1(gb); /* progressive_sequence */\n            if (ctx->shape != BIN_ONLY_SHAPE) {\n                ctx->rgb = get_bits1(gb); /* rgb_components */\n                s->chroma_format = get_bits(gb, 2); /* chroma_format */\n                if (!s->chroma_format) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"illegal chroma format\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                bits_per_raw_sample = get_bits(gb, 4); /* bit_depth */\n                if (bits_per_raw_sample == 10) {\n                    if (ctx->rgb) {\n                        s->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n                    }\n                    else {\n                        s->avctx->pix_fmt = s->chroma_format == CHROMA_422 ? AV_PIX_FMT_YUV422P10 : AV_PIX_FMT_YUV444P10;\n                    }\n                }\n                else {\n                    avpriv_request_sample(s->avctx, \"MPEG-4 Studio profile bit-depth %u\", bits_per_raw_sample);\n                    return AVERROR_PATCHWELCOME;\n                }\n                s->avctx->bits_per_raw_sample = bits_per_raw_sample;\n            }\n            if (ctx->shape == RECT_SHAPE) {\n                check_marker(s->avctx, gb, \"before video_object_layer_width\");\n                width = get_bits(gb, 14); /* video_object_layer_width */\n                check_marker(s->avctx, gb, \"before video_object_layer_height\");\n                height = get_bits(gb, 14); /* video_object_layer_height */\n                check_marker(s->avctx, gb, \"after video_object_layer_height\");\n\n                /* Do the same check as non-studio profile */\n                if (width && height) {\n                    if (s->width && s->height &&\n                        (s->width != width || s->height != height))\n                        s->context_reinit = 1;\n                    s->width  = width;\n                    s->height = height;\n                }\n            }\n            s->aspect_ratio_info = get_bits(gb, 4);\n            if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n                s->avctx->sample_aspect_ratio.num = get_bits(gb, 8);  // par_width\n                s->avctx->sample_aspect_ratio.den = get_bits(gb, 8);  // par_height\n            } else {\n                s->avctx->sample_aspect_ratio = ff_h263_pixel_aspect[s->aspect_ratio_info];\n            }\n            skip_bits(gb, 4); /* frame_rate_code */\n            skip_bits(gb, 15); /* first_half_bit_rate */\n            check_marker(s->avctx, gb, \"after first_half_bit_rate\");\n            skip_bits(gb, 15); /* latter_half_bit_rate */\n            check_marker(s->avctx, gb, \"after latter_half_bit_rate\");\n            skip_bits(gb, 15); /* first_half_vbv_buffer_size */\n            check_marker(s->avctx, gb, \"after first_half_vbv_buffer_size\");\n            skip_bits(gb, 3); /* latter_half_vbv_buffer_size */\n            skip_bits(gb, 11); /* first_half_vbv_buffer_size */\n            check_marker(s->avctx, gb, \"after first_half_vbv_buffer_size\");\n            skip_bits(gb, 15); /* latter_half_vbv_occupancy */\n            check_marker(s->avctx, gb, \"after latter_half_vbv_occupancy\");\n            s->low_delay = get_bits1(gb);\n            s->mpeg_quant = get_bits1(gb); /* mpeg2_stream */\n\n            next_start_code_studio(gb);\n            extension_and_user_data(s, gb, 2);\n\n    return 0;\n}\n\n/**\n * Decode MPEG-4 headers.\n * @return <0 if no VOP found (or a damaged one)\n *         FRAME_SKIPPED if a not coded VOP is found\n *         0 if a VOP is found\n */\nint ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}\n\nav_cold void ff_mpeg4videodec_static_init(void) {\n    static int done = 0;\n\n    if (!done) {\n        ff_rl_init(&ff_mpeg4_rl_intra, ff_mpeg4_static_rl_table_store[0]);\n        ff_rl_init(&ff_rvlc_rl_inter, ff_mpeg4_static_rl_table_store[1]);\n        ff_rl_init(&ff_rvlc_rl_intra, ff_mpeg4_static_rl_table_store[2]);\n        INIT_VLC_RL(ff_mpeg4_rl_intra, 554);\n        INIT_VLC_RL(ff_rvlc_rl_inter, 1072);\n        INIT_VLC_RL(ff_rvlc_rl_intra, 1072);\n        INIT_VLC_STATIC(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n                        &ff_mpeg4_DCtab_lum[0][1], 2, 1,\n                        &ff_mpeg4_DCtab_lum[0][0], 2, 1, 512);\n        INIT_VLC_STATIC(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n                        &ff_mpeg4_DCtab_chrom[0][1], 2, 1,\n                        &ff_mpeg4_DCtab_chrom[0][0], 2, 1, 512);\n        INIT_VLC_STATIC(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n                        &ff_sprite_trajectory_tab[0][1], 4, 2,\n                        &ff_sprite_trajectory_tab[0][0], 4, 2, 128);\n        INIT_VLC_STATIC(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n                        &ff_mb_type_b_tab[0][1], 2, 1,\n                        &ff_mb_type_b_tab[0][0], 2, 1, 16);\n        done = 1;\n    }\n}\n\nint ff_mpeg4_frame_end(AVCodecContext *avctx, const uint8_t *buf, int buf_size)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    MpegEncContext    *s = &ctx->m;\n\n    /* divx 5.01+ bitstream reorder stuff */\n    /* Since this clobbers the input buffer and hwaccel codecs still need the\n     * data during hwaccel->end_frame we should not do this any earlier */\n    if (s->divx_packed) {\n        int current_pos     = s->gb.buffer == s->bitstream_buffer ? 0 : (get_bits_count(&s->gb) >> 3);\n        int startcode_found = 0;\n\n        if (buf_size - current_pos > 7) {\n\n            int i;\n            for (i = current_pos; i < buf_size - 4; i++)\n\n                if (buf[i]     == 0 &&\n                    buf[i + 1] == 0 &&\n                    buf[i + 2] == 1 &&\n                    buf[i + 3] == 0xB6) {\n                    startcode_found = !(buf[i + 4] & 0x40);\n                    break;\n                }\n        }\n\n        if (startcode_found) {\n            if (!ctx->showed_packed_warning) {\n                av_log(s->avctx, AV_LOG_INFO, \"Video uses a non-standard and \"\n                       \"wasteful way to store B-frames ('packed B-frames'). \"\n                       \"Consider using the mpeg4_unpack_bframes bitstream filter without encoding but stream copy to fix it.\\n\");\n                ctx->showed_packed_warning = 1;\n            }\n            av_fast_padded_malloc(&s->bitstream_buffer,\n                           &s->allocated_bitstream_buffer_size,\n                           buf_size - current_pos);\n            if (!s->bitstream_buffer) {\n                s->bitstream_buffer_size = 0;\n                return AVERROR(ENOMEM);\n            }\n            memcpy(s->bitstream_buffer, buf + current_pos,\n                   buf_size - current_pos);\n            s->bitstream_buffer_size = buf_size - current_pos;\n        }\n    }\n\n    return 0;\n}\n\n#if HAVE_THREADS\nstatic int mpeg4_update_thread_context(AVCodecContext *dst,\n                                       const AVCodecContext *src)\n{\n    Mpeg4DecContext *s = dst->priv_data;\n    const Mpeg4DecContext *s1 = src->priv_data;\n    int init = s->m.context_initialized;\n\n    int ret = ff_mpeg_update_thread_context(dst, src);\n\n    if (ret < 0)\n        return ret;\n\n    memcpy(((uint8_t*)s) + sizeof(MpegEncContext), ((uint8_t*)s1) + sizeof(MpegEncContext), sizeof(Mpeg4DecContext) - sizeof(MpegEncContext));\n\n    if (CONFIG_MPEG4_DECODER && !init && s1->xvid_build >= 0)\n        ff_xvid_idct_init(&s->m.idsp, dst);\n\n    return 0;\n}\n#endif\n\nstatic av_cold int init_studio_vlcs(Mpeg4DecContext *ctx)\n{\n    int i, ret;\n\n    for (i = 0; i < 12; i++) {\n        ret = init_vlc(&ctx->studio_intra_tab[i], STUDIO_INTRA_BITS, 22,\n                       &ff_mpeg4_studio_intra[i][0][1], 4, 2,\n                       &ff_mpeg4_studio_intra[i][0][0], 4, 2,\n                       0);\n\n        if (ret < 0)\n            return ret;\n    }\n\n    ret = init_vlc(&ctx->studio_luma_dc, STUDIO_INTRA_BITS, 19,\n                   &ff_mpeg4_studio_dc_luma[0][1], 4, 2,\n                   &ff_mpeg4_studio_dc_luma[0][0], 4, 2,\n                   0);\n    if (ret < 0)\n        return ret;\n\n    ret = init_vlc(&ctx->studio_chroma_dc, STUDIO_INTRA_BITS, 19,\n                   &ff_mpeg4_studio_dc_chroma[0][1], 4, 2,\n                   &ff_mpeg4_studio_dc_chroma[0][0], 4, 2,\n                   0);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    MpegEncContext *s = &ctx->m;\n    int ret;\n\n    ctx->divx_version =\n    ctx->divx_build   =\n    ctx->xvid_build   =\n    ctx->lavc_build   = -1;\n\n    if ((ret = ff_h263_decode_init(avctx)) < 0)\n        return ret;\n\n    ff_mpeg4videodec_static_init();\n    if ((ret = init_studio_vlcs(ctx)) < 0)\n        return ret;\n\n    s->h263_pred = 1;\n    s->low_delay = 0; /* default, might be overridden in the vol header during header parsing */\n    s->decode_mb = mpeg4_decode_mb;\n    ctx->time_increment_bits = 4; /* default value for broken headers */\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n    avctx->internal->allocate_progress = 1;\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    int i;\n\n    if (!avctx->internal->is_copy) {\n        for (i = 0; i < 12; i++)\n            ff_free_vlc(&ctx->studio_intra_tab[i]);\n\n        ff_free_vlc(&ctx->studio_luma_dc);\n        ff_free_vlc(&ctx->studio_chroma_dc);\n    }\n\n    return ff_h263_decode_end(avctx);\n}\n\nstatic const AVOption mpeg4_options[] = {\n    {\"quarter_sample\", \"1/4 subpel MC\", offsetof(MpegEncContext, quarter_sample), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, 0},\n    {\"divx_packed\", \"divx style packed b frames\", offsetof(MpegEncContext, divx_packed), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, 0},\n    {NULL}\n};\n\nstatic const AVClass mpeg4_class = {\n    .class_name = \"MPEG4 Video Decoder\",\n    .item_name  = av_default_item_name,\n    .option     = mpeg4_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_mpeg4_decoder = {\n    .name                  = \"mpeg4\",\n    .long_name             = NULL_IF_CONFIG_SMALL(\"MPEG-4 part 2\"),\n    .type                  = AVMEDIA_TYPE_VIDEO,\n    .id                    = AV_CODEC_ID_MPEG4,\n    .priv_data_size        = sizeof(Mpeg4DecContext),\n    .init                  = decode_init,\n    .close                 = decode_end,\n    .decode                = ff_h263_decode_frame,\n    .capabilities          = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1 |\n                             AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY |\n                             AV_CODEC_CAP_FRAME_THREADS,\n    .caps_internal         = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n    .flush                 = ff_mpeg_flush,\n    .max_lowres            = 3,\n    .pix_fmts              = ff_h263_hwaccel_pixfmt_list_420,\n    .profiles              = NULL_IF_CONFIG_SMALL(ff_mpeg4_video_profiles),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(mpeg4_update_thread_context),\n    .priv_class = &mpeg4_class,\n    .hw_configs            = (const AVCodecHWConfigInternal*[]) {\n#if CONFIG_MPEG4_NVDEC_HWACCEL\n                               HWACCEL_NVDEC(mpeg4),\n#endif\n#if CONFIG_MPEG4_VAAPI_HWACCEL\n                               HWACCEL_VAAPI(mpeg4),\n#endif\n#if CONFIG_MPEG4_VDPAU_HWACCEL\n                               HWACCEL_VDPAU(mpeg4),\n#endif\n#if CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL\n                               HWACCEL_VIDEOTOOLBOX(mpeg4),\n#endif\n                               NULL\n                           },\n};\n"], "fixing_code": ["/*\n * Error resilience / concealment\n *\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Error resilience / concealment.\n */\n\n#include <limits.h>\n\n#include \"libavutil/internal.h\"\n#include \"avcodec.h\"\n#include \"error_resilience.h\"\n#include \"me_cmp.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"rectangle.h\"\n#include \"thread.h\"\n#include \"version.h\"\n\n/**\n * @param stride the number of MVs to get to the next row\n * @param mv_step the number of MVs per row or column in a macroblock\n */\nstatic void set_mv_strides(ERContext *s, ptrdiff_t *mv_step, ptrdiff_t *stride)\n{\n    if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n        av_assert0(s->quarter_sample);\n        *mv_step = 4;\n        *stride  = s->mb_width * 4;\n    } else {\n        *mv_step = 2;\n        *stride  = s->b8_stride;\n    }\n}\n\n/**\n * Replace the current MB with a flat dc-only version.\n */\nstatic void put_dc(ERContext *s, uint8_t *dest_y, uint8_t *dest_cb,\n                   uint8_t *dest_cr, int mb_x, int mb_y)\n{\n    int *linesize = s->cur_pic.f->linesize;\n    int dc, dcu, dcv, y, i;\n    for (i = 0; i < 4; i++) {\n        dc = s->dc_val[0][mb_x * 2 + (i &  1) + (mb_y * 2 + (i >> 1)) * s->b8_stride];\n        if (dc < 0)\n            dc = 0;\n        else if (dc > 2040)\n            dc = 2040;\n        for (y = 0; y < 8; y++) {\n            int x;\n            for (x = 0; x < 8; x++)\n                dest_y[x + (i &  1) * 8 + (y + (i >> 1) * 8) * linesize[0]] = dc / 8;\n        }\n    }\n    dcu = s->dc_val[1][mb_x + mb_y * s->mb_stride];\n    dcv = s->dc_val[2][mb_x + mb_y * s->mb_stride];\n    if (dcu < 0)\n        dcu = 0;\n    else if (dcu > 2040)\n        dcu = 2040;\n    if (dcv < 0)\n        dcv = 0;\n    else if (dcv > 2040)\n        dcv = 2040;\n\n    if (dest_cr)\n    for (y = 0; y < 8; y++) {\n        int x;\n        for (x = 0; x < 8; x++) {\n            dest_cb[x + y * linesize[1]] = dcu / 8;\n            dest_cr[x + y * linesize[2]] = dcv / 8;\n        }\n    }\n}\n\nstatic void filter181(int16_t *data, int width, int height, ptrdiff_t stride)\n{\n    int x, y;\n\n    /* horizontal filter */\n    for (y = 1; y < height - 1; y++) {\n        int prev_dc = data[0 + y * stride];\n\n        for (x = 1; x < width - 1; x++) {\n            int dc;\n            dc = -prev_dc +\n                 data[x     + y * stride] * 8 -\n                 data[x + 1 + y * stride];\n            dc = (av_clip(dc, INT_MIN/10923, INT_MAX/10923 - 32768) * 10923 + 32768) >> 16;\n            prev_dc = data[x + y * stride];\n            data[x + y * stride] = dc;\n        }\n    }\n\n    /* vertical filter */\n    for (x = 1; x < width - 1; x++) {\n        int prev_dc = data[x];\n\n        for (y = 1; y < height - 1; y++) {\n            int dc;\n\n            dc = -prev_dc +\n                 data[x +  y      * stride] * 8 -\n                 data[x + (y + 1) * stride];\n            dc = (av_clip(dc, INT_MIN/10923, INT_MAX/10923 - 32768) * 10923 + 32768) >> 16;\n            prev_dc = data[x + y * stride];\n            data[x + y * stride] = dc;\n        }\n    }\n}\n\n/**\n * guess the dc of blocks which do not have an undamaged dc\n * @param w     width in 8 pixel blocks\n * @param h     height in 8 pixel blocks\n */\nstatic void guess_dc(ERContext *s, int16_t *dc, int w,\n                     int h, ptrdiff_t stride, int is_luma)\n{\n    int b_x, b_y;\n    int16_t  (*col )[4] = av_malloc_array(stride, h*sizeof( int16_t)*4);\n    uint32_t (*dist)[4] = av_malloc_array(stride, h*sizeof(uint32_t)*4);\n\n    if(!col || !dist) {\n        av_log(s->avctx, AV_LOG_ERROR, \"guess_dc() is out of memory\\n\");\n        goto fail;\n    }\n\n    for(b_y=0; b_y<h; b_y++){\n        int color= 1024;\n        int distance= -1;\n        for(b_x=0; b_x<w; b_x++){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_x;\n            }\n            col [b_x + b_y*stride][1]= color;\n            dist[b_x + b_y*stride][1]= distance >= 0 ? b_x-distance : 9999;\n        }\n        color= 1024;\n        distance= -1;\n        for(b_x=w-1; b_x>=0; b_x--){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_x;\n            }\n            col [b_x + b_y*stride][0]= color;\n            dist[b_x + b_y*stride][0]= distance >= 0 ? distance-b_x : 9999;\n        }\n    }\n    for(b_x=0; b_x<w; b_x++){\n        int color= 1024;\n        int distance= -1;\n        for(b_y=0; b_y<h; b_y++){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_y;\n            }\n            col [b_x + b_y*stride][3]= color;\n            dist[b_x + b_y*stride][3]= distance >= 0 ? b_y-distance : 9999;\n        }\n        color= 1024;\n        distance= -1;\n        for(b_y=h-1; b_y>=0; b_y--){\n            int mb_index_j= (b_x>>is_luma) + (b_y>>is_luma)*s->mb_stride;\n            int error_j= s->error_status_table[mb_index_j];\n            int intra_j = IS_INTRA(s->cur_pic.mb_type[mb_index_j]);\n            if(intra_j==0 || !(error_j&ER_DC_ERROR)){\n                color= dc[b_x + b_y*stride];\n                distance= b_y;\n            }\n            col [b_x + b_y*stride][2]= color;\n            dist[b_x + b_y*stride][2]= distance >= 0 ? distance-b_y : 9999;\n        }\n    }\n\n    for (b_y = 0; b_y < h; b_y++) {\n        for (b_x = 0; b_x < w; b_x++) {\n            int mb_index, error, j;\n            int64_t guess, weight_sum;\n            mb_index = (b_x >> is_luma) + (b_y >> is_luma) * s->mb_stride;\n            error    = s->error_status_table[mb_index];\n\n            if (IS_INTER(s->cur_pic.mb_type[mb_index]))\n                continue; // inter\n            if (!(error & ER_DC_ERROR))\n                continue; // dc-ok\n\n            weight_sum = 0;\n            guess      = 0;\n            for (j = 0; j < 4; j++) {\n                int64_t weight  = 256 * 256 * 256 * 16 / FFMAX(dist[b_x + b_y*stride][j], 1);\n                guess          += weight*(int64_t)col[b_x + b_y*stride][j];\n                weight_sum     += weight;\n            }\n            guess = (guess + weight_sum / 2) / weight_sum;\n            dc[b_x + b_y * stride] = guess;\n        }\n    }\n\nfail:\n    av_freep(&col);\n    av_freep(&dist);\n}\n\n/**\n * simple horizontal deblocking filter used for error resilience\n * @param w     width in 8 pixel blocks\n * @param h     height in 8 pixel blocks\n */\nstatic void h_block_filter(ERContext *s, uint8_t *dst, int w,\n                           int h, ptrdiff_t stride, int is_luma)\n{\n    int b_x, b_y;\n    ptrdiff_t mvx_stride, mvy_stride;\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n    set_mv_strides(s, &mvx_stride, &mvy_stride);\n    mvx_stride >>= is_luma;\n    mvy_stride *= mvx_stride;\n\n    for (b_y = 0; b_y < h; b_y++) {\n        for (b_x = 0; b_x < w - 1; b_x++) {\n            int y;\n            int left_status  = s->error_status_table[( b_x      >> is_luma) + (b_y >> is_luma) * s->mb_stride];\n            int right_status = s->error_status_table[((b_x + 1) >> is_luma) + (b_y >> is_luma) * s->mb_stride];\n            int left_intra   = IS_INTRA(s->cur_pic.mb_type[( b_x      >> is_luma) + (b_y >> is_luma) * s->mb_stride]);\n            int right_intra  = IS_INTRA(s->cur_pic.mb_type[((b_x + 1) >> is_luma) + (b_y >> is_luma) * s->mb_stride]);\n            int left_damage  = left_status & ER_MB_ERROR;\n            int right_damage = right_status & ER_MB_ERROR;\n            int offset       = b_x * 8 + b_y * stride * 8;\n            int16_t *left_mv  = s->cur_pic.motion_val[0][mvy_stride * b_y + mvx_stride *  b_x];\n            int16_t *right_mv = s->cur_pic.motion_val[0][mvy_stride * b_y + mvx_stride * (b_x + 1)];\n            if (!(left_damage || right_damage))\n                continue; // both undamaged\n            if ((!left_intra) && (!right_intra) &&\n                FFABS(left_mv[0] - right_mv[0]) +\n                FFABS(left_mv[1] + right_mv[1]) < 2)\n                continue;\n\n            for (y = 0; y < 8; y++) {\n                int a, b, c, d;\n\n                a = dst[offset + 7 + y * stride] - dst[offset + 6 + y * stride];\n                b = dst[offset + 8 + y * stride] - dst[offset + 7 + y * stride];\n                c = dst[offset + 9 + y * stride] - dst[offset + 8 + y * stride];\n\n                d = FFABS(b) - ((FFABS(a) + FFABS(c) + 1) >> 1);\n                d = FFMAX(d, 0);\n                if (b < 0)\n                    d = -d;\n\n                if (d == 0)\n                    continue;\n\n                if (!(left_damage && right_damage))\n                    d = d * 16 / 9;\n\n                if (left_damage) {\n                    dst[offset + 7 + y * stride] = cm[dst[offset + 7 + y * stride] + ((d * 7) >> 4)];\n                    dst[offset + 6 + y * stride] = cm[dst[offset + 6 + y * stride] + ((d * 5) >> 4)];\n                    dst[offset + 5 + y * stride] = cm[dst[offset + 5 + y * stride] + ((d * 3) >> 4)];\n                    dst[offset + 4 + y * stride] = cm[dst[offset + 4 + y * stride] + ((d * 1) >> 4)];\n                }\n                if (right_damage) {\n                    dst[offset + 8 + y * stride] = cm[dst[offset +  8 + y * stride] - ((d * 7) >> 4)];\n                    dst[offset + 9 + y * stride] = cm[dst[offset +  9 + y * stride] - ((d * 5) >> 4)];\n                    dst[offset + 10+ y * stride] = cm[dst[offset + 10 + y * stride] - ((d * 3) >> 4)];\n                    dst[offset + 11+ y * stride] = cm[dst[offset + 11 + y * stride] - ((d * 1) >> 4)];\n                }\n            }\n        }\n    }\n}\n\n/**\n * simple vertical deblocking filter used for error resilience\n * @param w     width in 8 pixel blocks\n * @param h     height in 8 pixel blocks\n */\nstatic void v_block_filter(ERContext *s, uint8_t *dst, int w, int h,\n                           ptrdiff_t stride, int is_luma)\n{\n    int b_x, b_y;\n    ptrdiff_t mvx_stride, mvy_stride;\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n    set_mv_strides(s, &mvx_stride, &mvy_stride);\n    mvx_stride >>= is_luma;\n    mvy_stride *= mvx_stride;\n\n    for (b_y = 0; b_y < h - 1; b_y++) {\n        for (b_x = 0; b_x < w; b_x++) {\n            int x;\n            int top_status    = s->error_status_table[(b_x >> is_luma) +  (b_y      >> is_luma) * s->mb_stride];\n            int bottom_status = s->error_status_table[(b_x >> is_luma) + ((b_y + 1) >> is_luma) * s->mb_stride];\n            int top_intra     = IS_INTRA(s->cur_pic.mb_type[(b_x >> is_luma) + ( b_y      >> is_luma) * s->mb_stride]);\n            int bottom_intra  = IS_INTRA(s->cur_pic.mb_type[(b_x >> is_luma) + ((b_y + 1) >> is_luma) * s->mb_stride]);\n            int top_damage    = top_status & ER_MB_ERROR;\n            int bottom_damage = bottom_status & ER_MB_ERROR;\n            int offset        = b_x * 8 + b_y * stride * 8;\n\n            int16_t *top_mv    = s->cur_pic.motion_val[0][mvy_stride *  b_y      + mvx_stride * b_x];\n            int16_t *bottom_mv = s->cur_pic.motion_val[0][mvy_stride * (b_y + 1) + mvx_stride * b_x];\n\n            if (!(top_damage || bottom_damage))\n                continue; // both undamaged\n\n            if ((!top_intra) && (!bottom_intra) &&\n                FFABS(top_mv[0] - bottom_mv[0]) +\n                FFABS(top_mv[1] + bottom_mv[1]) < 2)\n                continue;\n\n            for (x = 0; x < 8; x++) {\n                int a, b, c, d;\n\n                a = dst[offset + x + 7 * stride] - dst[offset + x + 6 * stride];\n                b = dst[offset + x + 8 * stride] - dst[offset + x + 7 * stride];\n                c = dst[offset + x + 9 * stride] - dst[offset + x + 8 * stride];\n\n                d = FFABS(b) - ((FFABS(a) + FFABS(c) + 1) >> 1);\n                d = FFMAX(d, 0);\n                if (b < 0)\n                    d = -d;\n\n                if (d == 0)\n                    continue;\n\n                if (!(top_damage && bottom_damage))\n                    d = d * 16 / 9;\n\n                if (top_damage) {\n                    dst[offset + x +  7 * stride] = cm[dst[offset + x +  7 * stride] + ((d * 7) >> 4)];\n                    dst[offset + x +  6 * stride] = cm[dst[offset + x +  6 * stride] + ((d * 5) >> 4)];\n                    dst[offset + x +  5 * stride] = cm[dst[offset + x +  5 * stride] + ((d * 3) >> 4)];\n                    dst[offset + x +  4 * stride] = cm[dst[offset + x +  4 * stride] + ((d * 1) >> 4)];\n                }\n                if (bottom_damage) {\n                    dst[offset + x +  8 * stride] = cm[dst[offset + x +  8 * stride] - ((d * 7) >> 4)];\n                    dst[offset + x +  9 * stride] = cm[dst[offset + x +  9 * stride] - ((d * 5) >> 4)];\n                    dst[offset + x + 10 * stride] = cm[dst[offset + x + 10 * stride] - ((d * 3) >> 4)];\n                    dst[offset + x + 11 * stride] = cm[dst[offset + x + 11 * stride] - ((d * 1) >> 4)];\n                }\n            }\n        }\n    }\n}\n\n#define MV_FROZEN    8\n#define MV_CHANGED   4\n#define MV_UNCHANGED 2\n#define MV_LISTED    1\nstatic av_always_inline void add_blocklist(int (*blocklist)[2], int *blocklist_length, uint8_t *fixed, int mb_x, int mb_y, int mb_xy)\n{\n    if (fixed[mb_xy])\n        return;\n    fixed[mb_xy] = MV_LISTED;\n    blocklist[ *blocklist_length   ][0] = mb_x;\n    blocklist[(*blocklist_length)++][1] = mb_y;\n}\n\nstatic void guess_mv(ERContext *s)\n{\n    int (*blocklist)[2], (*next_blocklist)[2];\n    uint8_t *fixed;\n    const ptrdiff_t mb_stride = s->mb_stride;\n    const int mb_width  = s->mb_width;\n    int mb_height = s->mb_height;\n    int i, depth, num_avail;\n    int mb_x, mb_y;\n    ptrdiff_t mot_step, mot_stride;\n    int blocklist_length, next_blocklist_length;\n\n    if (s->last_pic.f && s->last_pic.f->data[0])\n        mb_height = FFMIN(mb_height, (s->last_pic.f->height+15)>>4);\n    if (s->next_pic.f && s->next_pic.f->data[0])\n        mb_height = FFMIN(mb_height, (s->next_pic.f->height+15)>>4);\n\n    blocklist      = (int (*)[2])s->er_temp_buffer;\n    next_blocklist = blocklist + s->mb_stride * s->mb_height;\n    fixed          = (uint8_t *)(next_blocklist + s->mb_stride * s->mb_height);\n\n    set_mv_strides(s, &mot_step, &mot_stride);\n\n    num_avail = 0;\n    if (s->last_pic.motion_val[0])\n        ff_thread_await_progress(s->last_pic.tf, mb_height-1, 0);\n    for (i = 0; i < mb_width * mb_height; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int f = 0;\n        int error = s->error_status_table[mb_xy];\n\n        if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n            f = MV_FROZEN; // intra // FIXME check\n        if (!(error & ER_MV_ERROR))\n            f = MV_FROZEN; // inter with undamaged MV\n\n        fixed[mb_xy] = f;\n        if (f == MV_FROZEN)\n            num_avail++;\n        else if(s->last_pic.f->data[0] && s->last_pic.motion_val[0]){\n            const int mb_y= mb_xy / s->mb_stride;\n            const int mb_x= mb_xy % s->mb_stride;\n            const int mot_index= (mb_x + mb_y*mot_stride) * mot_step;\n            s->cur_pic.motion_val[0][mot_index][0]= s->last_pic.motion_val[0][mot_index][0];\n            s->cur_pic.motion_val[0][mot_index][1]= s->last_pic.motion_val[0][mot_index][1];\n            s->cur_pic.ref_index[0][4*mb_xy]      = s->last_pic.ref_index[0][4*mb_xy];\n        }\n    }\n\n    if ((!(s->avctx->error_concealment&FF_EC_GUESS_MVS)) ||\n        num_avail <= mb_width / 2) {\n        for (mb_y = 0; mb_y < mb_height; mb_y++) {\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n                const int mb_xy = mb_x + mb_y * s->mb_stride;\n                int mv_dir = (s->last_pic.f && s->last_pic.f->data[0]) ? MV_DIR_FORWARD : MV_DIR_BACKWARD;\n\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n                    continue;\n                if (!(s->error_status_table[mb_xy] & ER_MV_ERROR))\n                    continue;\n\n                s->mv[0][0][0] = 0;\n                s->mv[0][0][1] = 0;\n                s->decode_mb(s->opaque, 0, mv_dir, MV_TYPE_16X16, &s->mv,\n                             mb_x, mb_y, 0, 0);\n            }\n        }\n        return;\n    }\n\n    blocklist_length = 0;\n    for (mb_y = 0; mb_y < mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < mb_width; mb_x++) {\n            const int mb_xy = mb_x + mb_y * mb_stride;\n            if (fixed[mb_xy] == MV_FROZEN) {\n                if (mb_x)               add_blocklist(blocklist, &blocklist_length, fixed, mb_x - 1, mb_y, mb_xy - 1);\n                if (mb_y)               add_blocklist(blocklist, &blocklist_length, fixed, mb_x, mb_y - 1, mb_xy - mb_stride);\n                if (mb_x+1 < mb_width)  add_blocklist(blocklist, &blocklist_length, fixed, mb_x + 1, mb_y, mb_xy + 1);\n                if (mb_y+1 < mb_height) add_blocklist(blocklist, &blocklist_length, fixed, mb_x, mb_y + 1, mb_xy + mb_stride);\n            }\n        }\n    }\n\n    for (depth = 0; ; depth++) {\n        int changed, pass, none_left;\n        int blocklist_index;\n\n        none_left = 1;\n        changed   = 1;\n        for (pass = 0; (changed || pass < 2) && pass < 10; pass++) {\n            int score_sum = 0;\n\n            changed = 0;\n            for (blocklist_index = 0; blocklist_index < blocklist_length; blocklist_index++) {\n                const int mb_x = blocklist[blocklist_index][0];\n                const int mb_y = blocklist[blocklist_index][1];\n                const int mb_xy = mb_x + mb_y * mb_stride;\n                int mv_predictor[8][2];\n                int ref[8];\n                int pred_count;\n                int j;\n                int best_score;\n                int best_pred;\n                int mot_index;\n                int prev_x, prev_y, prev_ref;\n\n                if ((mb_x ^ mb_y ^ pass) & 1)\n                    continue;\n                av_assert2(fixed[mb_xy] != MV_FROZEN);\n\n\n                av_assert1(!IS_INTRA(s->cur_pic.mb_type[mb_xy]));\n                av_assert1(s->last_pic.f && s->last_pic.f->data[0]);\n\n                j = 0;\n                if (mb_x > 0)\n                    j |= fixed[mb_xy - 1];\n                if (mb_x + 1 < mb_width)\n                    j |= fixed[mb_xy + 1];\n                if (mb_y > 0)\n                    j |= fixed[mb_xy - mb_stride];\n                if (mb_y + 1 < mb_height)\n                    j |= fixed[mb_xy + mb_stride];\n\n                av_assert2(j & MV_FROZEN);\n\n                if (!(j & MV_CHANGED) && pass > 1)\n                    continue;\n\n                none_left = 0;\n                pred_count = 0;\n                mot_index  = (mb_x + mb_y * mot_stride) * mot_step;\n\n                if (mb_x > 0 && fixed[mb_xy - 1] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index - mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index - mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy - 1)];\n                    pred_count++;\n                }\n                if (mb_x + 1 < mb_width && fixed[mb_xy + 1] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index + mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index + mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy + 1)];\n                    pred_count++;\n                }\n                if (mb_y > 0 && fixed[mb_xy - mb_stride] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index - mot_stride * mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index - mot_stride * mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy - s->mb_stride)];\n                    pred_count++;\n                }\n                if (mb_y + 1<mb_height && fixed[mb_xy + mb_stride] > 1) {\n                    mv_predictor[pred_count][0] =\n                        s->cur_pic.motion_val[0][mot_index + mot_stride * mot_step][0];\n                    mv_predictor[pred_count][1] =\n                        s->cur_pic.motion_val[0][mot_index + mot_stride * mot_step][1];\n                    ref[pred_count] =\n                        s->cur_pic.ref_index[0][4 * (mb_xy + s->mb_stride)];\n                    pred_count++;\n                }\n                if (pred_count == 0)\n                    continue;\n\n                if (pred_count > 1) {\n                    int sum_x = 0, sum_y = 0, sum_r = 0;\n                    int max_x, max_y, min_x, min_y, max_r, min_r;\n\n                    for (j = 0; j < pred_count; j++) {\n                        sum_x += mv_predictor[j][0];\n                        sum_y += mv_predictor[j][1];\n                        sum_r += ref[j];\n                        if (j && ref[j] != ref[j - 1])\n                            goto skip_mean_and_median;\n                    }\n\n                    /* mean */\n                    mv_predictor[pred_count][0] = sum_x / j;\n                    mv_predictor[pred_count][1] = sum_y / j;\n                             ref[pred_count]    = sum_r / j;\n\n                    /* median */\n                    if (pred_count >= 3) {\n                        min_y = min_x = min_r =  99999;\n                        max_y = max_x = max_r = -99999;\n                    } else {\n                        min_x = min_y = max_x = max_y = min_r = max_r = 0;\n                    }\n                    for (j = 0; j < pred_count; j++) {\n                        max_x = FFMAX(max_x, mv_predictor[j][0]);\n                        max_y = FFMAX(max_y, mv_predictor[j][1]);\n                        max_r = FFMAX(max_r, ref[j]);\n                        min_x = FFMIN(min_x, mv_predictor[j][0]);\n                        min_y = FFMIN(min_y, mv_predictor[j][1]);\n                        min_r = FFMIN(min_r, ref[j]);\n                    }\n                    mv_predictor[pred_count + 1][0] = sum_x - max_x - min_x;\n                    mv_predictor[pred_count + 1][1] = sum_y - max_y - min_y;\n                             ref[pred_count + 1]    = sum_r - max_r - min_r;\n\n                    if (pred_count == 4) {\n                        mv_predictor[pred_count + 1][0] /= 2;\n                        mv_predictor[pred_count + 1][1] /= 2;\n                                 ref[pred_count + 1]    /= 2;\n                    }\n                    pred_count += 2;\n                }\n\nskip_mean_and_median:\n                /* zero MV */\n                mv_predictor[pred_count][0] =\n                mv_predictor[pred_count][1] =\n                         ref[pred_count]    = 0;\n                pred_count++;\n\n                prev_x   = s->cur_pic.motion_val[0][mot_index][0];\n                prev_y   = s->cur_pic.motion_val[0][mot_index][1];\n                prev_ref = s->cur_pic.ref_index[0][4 * mb_xy];\n\n                /* last MV */\n                mv_predictor[pred_count][0] = prev_x;\n                mv_predictor[pred_count][1] = prev_y;\n                         ref[pred_count]    = prev_ref;\n                pred_count++;\n\n                best_pred = 0;\n                best_score = 256 * 256 * 256 * 64;\n                for (j = 0; j < pred_count; j++) {\n                    int *linesize = s->cur_pic.f->linesize;\n                    int score = 0;\n                    uint8_t *src = s->cur_pic.f->data[0] +\n                                   mb_x * 16 + mb_y * 16 * linesize[0];\n\n                    s->cur_pic.motion_val[0][mot_index][0] =\n                        s->mv[0][0][0] = mv_predictor[j][0];\n                    s->cur_pic.motion_val[0][mot_index][1] =\n                        s->mv[0][0][1] = mv_predictor[j][1];\n\n                    // predictor intra or otherwise not available\n                    if (ref[j] < 0)\n                        continue;\n\n                    s->decode_mb(s->opaque, ref[j], MV_DIR_FORWARD,\n                                 MV_TYPE_16X16, &s->mv, mb_x, mb_y, 0, 0);\n\n                    if (mb_x > 0 && fixed[mb_xy - 1] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k * linesize[0] - 1] -\n                                           src[k * linesize[0]]);\n                    }\n                    if (mb_x + 1 < mb_width && fixed[mb_xy + 1] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k * linesize[0] + 15] -\n                                           src[k * linesize[0] + 16]);\n                    }\n                    if (mb_y > 0 && fixed[mb_xy - mb_stride] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k - linesize[0]] - src[k]);\n                    }\n                    if (mb_y + 1 < mb_height && fixed[mb_xy + mb_stride] > 1) {\n                        int k;\n                        for (k = 0; k < 16; k++)\n                            score += FFABS(src[k + linesize[0] * 15] -\n                                           src[k + linesize[0] * 16]);\n                    }\n\n                    if (score <= best_score) { // <= will favor the last MV\n                        best_score = score;\n                        best_pred  = j;\n                    }\n                }\n                score_sum += best_score;\n                s->mv[0][0][0] = mv_predictor[best_pred][0];\n                s->mv[0][0][1] = mv_predictor[best_pred][1];\n\n                for (i = 0; i < mot_step; i++)\n                    for (j = 0; j < mot_step; j++) {\n                        s->cur_pic.motion_val[0][mot_index + i + j * mot_stride][0] = s->mv[0][0][0];\n                        s->cur_pic.motion_val[0][mot_index + i + j * mot_stride][1] = s->mv[0][0][1];\n                    }\n\n                s->decode_mb(s->opaque, ref[best_pred], MV_DIR_FORWARD,\n                             MV_TYPE_16X16, &s->mv, mb_x, mb_y, 0, 0);\n\n\n                if (s->mv[0][0][0] != prev_x || s->mv[0][0][1] != prev_y) {\n                    fixed[mb_xy] = MV_CHANGED;\n                    changed++;\n                } else\n                    fixed[mb_xy] = MV_UNCHANGED;\n            }\n        }\n\n        if (none_left)\n            return;\n\n        next_blocklist_length = 0;\n\n        for (blocklist_index = 0; blocklist_index < blocklist_length; blocklist_index++) {\n            const int mb_x = blocklist[blocklist_index][0];\n            const int mb_y = blocklist[blocklist_index][1];\n            const int mb_xy = mb_x + mb_y * mb_stride;\n\n            if (fixed[mb_xy] & (MV_CHANGED|MV_UNCHANGED|MV_FROZEN)) {\n                fixed[mb_xy] = MV_FROZEN;\n                if (mb_x > 0)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x - 1, mb_y, mb_xy - 1);\n                if (mb_y > 0)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x, mb_y - 1, mb_xy - mb_stride);\n                if (mb_x + 1 < mb_width)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x + 1, mb_y, mb_xy + 1);\n                if (mb_y + 1 < mb_height)\n                    add_blocklist(next_blocklist, &next_blocklist_length, fixed, mb_x, mb_y + 1, mb_xy + mb_stride);\n            }\n        }\n        av_assert0(next_blocklist_length <= mb_height * mb_width);\n        FFSWAP(int , blocklist_length, next_blocklist_length);\n        FFSWAP(void*, blocklist, next_blocklist);\n    }\n}\n\nstatic int is_intra_more_likely(ERContext *s)\n{\n    int is_intra_likely, i, j, undamaged_count, skip_amount, mb_x, mb_y;\n\n    if (!s->last_pic.f || !s->last_pic.f->data[0])\n        return 1; // no previous frame available -> use spatial prediction\n\n    if (s->avctx->error_concealment & FF_EC_FAVOR_INTER)\n        return 0;\n\n    undamaged_count = 0;\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        const int error = s->error_status_table[mb_xy];\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n            undamaged_count++;\n    }\n\n    if (undamaged_count < 5)\n        return 0; // almost all MBs damaged -> use temporal prediction\n\n    // prevent dsp.sad() check, that requires access to the image\n    if (CONFIG_XVMC    &&\n        s->avctx->hwaccel && s->avctx->hwaccel->decode_mb &&\n        s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I)\n        return 1;\n\n    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs\n    is_intra_likely = 0;\n\n    j = 0;\n    for (mb_y = 0; mb_y < s->mb_height - 1; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            int error;\n            const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n            error = s->error_status_table[mb_xy];\n            if ((error & ER_DC_ERROR) && (error & ER_MV_ERROR))\n                continue; // skip damaged\n\n            j++;\n            // skip a few to speed things up\n            if ((j % skip_amount) != 0)\n                continue;\n\n            if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I) {\n                int *linesize = s->cur_pic.f->linesize;\n                uint8_t *mb_ptr      = s->cur_pic.f->data[0] +\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n                uint8_t *last_mb_ptr = s->last_pic.f->data[0] +\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n                if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n                    // FIXME\n                } else {\n                    ff_thread_await_progress(s->last_pic.tf, mb_y, 0);\n                }\n                is_intra_likely += s->mecc.sad[0](NULL, last_mb_ptr, mb_ptr,\n                                                  linesize[0], 16);\n                // FIXME need await_progress() here\n                is_intra_likely -= s->mecc.sad[0](NULL, last_mb_ptr,\n                                                  last_mb_ptr + linesize[0] * 16,\n                                                  linesize[0], 16);\n            } else {\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n                   is_intra_likely++;\n                else\n                   is_intra_likely--;\n            }\n        }\n    }\n//      av_log(NULL, AV_LOG_ERROR, \"is_intra_likely: %d type:%d\\n\", is_intra_likely, s->pict_type);\n    return is_intra_likely > 0;\n}\n\nvoid ff_er_frame_start(ERContext *s)\n{\n    if (!s->avctx->error_concealment)\n        return;\n\n    if (!s->mecc_inited) {\n        ff_me_cmp_init(&s->mecc, s->avctx);\n        s->mecc_inited = 1;\n    }\n\n    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n           s->mb_stride * s->mb_height * sizeof(uint8_t));\n    atomic_init(&s->error_count, 3 * s->mb_num);\n    s->error_occurred = 0;\n}\n\nstatic int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture\n    )\n        return 0;\n    return 1;\n}\n\n/**\n * Add a slice.\n * @param endx   x component of the last macroblock, can be -1\n *               for the last of the previous line\n * @param status the status at the end (ER_MV_END, ER_AC_ERROR, ...), it is\n *               assumed that no earlier end or error of the same type occurred\n */\nvoid ff_er_add_slice(ERContext *s, int startx, int starty,\n                     int endx, int endy, int status)\n{\n    const int start_i  = av_clip(startx + starty * s->mb_width, 0, s->mb_num - 1);\n    const int end_i    = av_clip(endx   + endy   * s->mb_width, 0, s->mb_num);\n    const int start_xy = s->mb_index2xy[start_i];\n    const int end_xy   = s->mb_index2xy[end_i];\n    int mask           = -1;\n\n    if (s->avctx->hwaccel && s->avctx->hwaccel->decode_slice)\n        return;\n\n    if (start_i > end_i || start_xy > end_xy) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"internal error, slice end before start\\n\");\n        return;\n    }\n\n    if (!s->avctx->error_concealment)\n        return;\n\n    mask &= ~VP_START;\n    if (status & (ER_AC_ERROR | ER_AC_END)) {\n        mask           &= ~(ER_AC_ERROR | ER_AC_END);\n        atomic_fetch_add(&s->error_count, start_i - end_i - 1);\n    }\n    if (status & (ER_DC_ERROR | ER_DC_END)) {\n        mask           &= ~(ER_DC_ERROR | ER_DC_END);\n        atomic_fetch_add(&s->error_count, start_i - end_i - 1);\n    }\n    if (status & (ER_MV_ERROR | ER_MV_END)) {\n        mask           &= ~(ER_MV_ERROR | ER_MV_END);\n        atomic_fetch_add(&s->error_count, start_i - end_i - 1);\n    }\n\n    if (status & ER_MB_ERROR) {\n        s->error_occurred = 1;\n        atomic_store(&s->error_count, INT_MAX);\n    }\n\n    if (mask == ~0x7F) {\n        memset(&s->error_status_table[start_xy], 0,\n               (end_xy - start_xy) * sizeof(uint8_t));\n    } else {\n        int i;\n        for (i = start_xy; i < end_xy; i++)\n            s->error_status_table[i] &= mask;\n    }\n\n    if (end_i == s->mb_num)\n        atomic_store(&s->error_count, INT_MAX);\n    else {\n        s->error_status_table[end_xy] &= mask;\n        s->error_status_table[end_xy] |= status;\n    }\n\n    s->error_status_table[start_xy] |= VP_START;\n\n    if (start_xy > 0 && !(s->avctx->active_thread_type & FF_THREAD_SLICE) &&\n        er_supported(s) && s->avctx->skip_top * s->mb_width < start_i) {\n        int prev_status = s->error_status_table[s->mb_index2xy[start_i - 1]];\n\n        prev_status &= ~ VP_START;\n        if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END)) {\n            s->error_occurred = 1;\n            atomic_store(&s->error_count, INT_MAX);\n        }\n    }\n}\n\nvoid ff_er_frame_end(ERContext *s)\n{\n    int *linesize = NULL;\n    int i, mb_x, mb_y, error, error_type, dc_error, mv_error, ac_error;\n    int distance;\n    int threshold_part[4] = { 100, 100, 100 };\n    int threshold = 50;\n    int is_intra_likely;\n    int size = s->b8_stride * 2 * s->mb_height;\n\n    /* We do not support ER of field pictures yet,\n     * though it should not crash if enabled. */\n    if (!s->avctx->error_concealment || !atomic_load(&s->error_count)  ||\n        s->avctx->lowres                                               ||\n        !er_supported(s)                                               ||\n        atomic_load(&s->error_count) == 3 * s->mb_width *\n                          (s->avctx->skip_top + s->avctx->skip_bottom)) {\n        return;\n    }\n    linesize = s->cur_pic.f->linesize;\n    for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n        int status = s->error_status_table[mb_x + (s->mb_height - 1) * s->mb_stride];\n        if (status != 0x7F)\n            break;\n    }\n\n    if (   mb_x == s->mb_width\n        && s->avctx->codec_id == AV_CODEC_ID_MPEG2VIDEO\n        && (FFALIGN(s->avctx->height, 16)&16)\n        && atomic_load(&s->error_count) == 3 * s->mb_width * (s->avctx->skip_top + s->avctx->skip_bottom + 1)\n    ) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"ignoring last missing slice\\n\");\n        return;\n    }\n\n    if (s->last_pic.f) {\n        if (s->last_pic.f->width  != s->cur_pic.f->width  ||\n            s->last_pic.f->height != s->cur_pic.f->height ||\n            s->last_pic.f->format != s->cur_pic.f->format) {\n            av_log(s->avctx, AV_LOG_WARNING, \"Cannot use previous picture in error concealment\\n\");\n            memset(&s->last_pic, 0, sizeof(s->last_pic));\n        }\n    }\n    if (s->next_pic.f) {\n        if (s->next_pic.f->width  != s->cur_pic.f->width  ||\n            s->next_pic.f->height != s->cur_pic.f->height ||\n            s->next_pic.f->format != s->cur_pic.f->format) {\n            av_log(s->avctx, AV_LOG_WARNING, \"Cannot use next picture in error concealment\\n\");\n            memset(&s->next_pic, 0, sizeof(s->next_pic));\n        }\n    }\n\n    if (!s->cur_pic.motion_val[0] || !s->cur_pic.ref_index[0]) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Warning MVs not available\\n\");\n\n        for (i = 0; i < 2; i++) {\n            s->ref_index_buf[i]  = av_buffer_allocz(s->mb_stride * s->mb_height * 4 * sizeof(uint8_t));\n            s->motion_val_buf[i] = av_buffer_allocz((size + 4) * 2 * sizeof(uint16_t));\n            if (!s->ref_index_buf[i] || !s->motion_val_buf[i])\n                break;\n            s->cur_pic.ref_index[i]  = s->ref_index_buf[i]->data;\n            s->cur_pic.motion_val[i] = (int16_t (*)[2])s->motion_val_buf[i]->data + 4;\n        }\n        if (i < 2) {\n            for (i = 0; i < 2; i++) {\n                av_buffer_unref(&s->ref_index_buf[i]);\n                av_buffer_unref(&s->motion_val_buf[i]);\n                s->cur_pic.ref_index[i]  = NULL;\n                s->cur_pic.motion_val[i] = NULL;\n            }\n            return;\n        }\n    }\n\n    if (s->avctx->debug & FF_DEBUG_ER) {\n        for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n                int status = s->error_status_table[mb_x + mb_y * s->mb_stride];\n\n                av_log(s->avctx, AV_LOG_DEBUG, \"%2X \", status);\n            }\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        }\n    }\n\n#if 1\n    /* handle overlapping slices */\n    for (error_type = 1; error_type <= 3; error_type++) {\n        int end_ok = 0;\n\n        for (i = s->mb_num - 1; i >= 0; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error       = s->error_status_table[mb_xy];\n\n            if (error & (1 << error_type))\n                end_ok = 1;\n            if (error & (8 << error_type))\n                end_ok = 1;\n\n            if (!end_ok)\n                s->error_status_table[mb_xy] |= 1 << error_type;\n\n            if (error & VP_START)\n                end_ok = 0;\n        }\n    }\n#endif\n#if 1\n    /* handle slices with partitions of different length */\n    if (s->partitioned_frame) {\n        int end_ok = 0;\n\n        for (i = s->mb_num - 1; i >= 0; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error       = s->error_status_table[mb_xy];\n\n            if (error & ER_AC_END)\n                end_ok = 0;\n            if ((error & ER_MV_END) ||\n                (error & ER_DC_END) ||\n                (error & ER_AC_ERROR))\n                end_ok = 1;\n\n            if (!end_ok)\n                s->error_status_table[mb_xy]|= ER_AC_ERROR;\n\n            if (error & VP_START)\n                end_ok = 0;\n        }\n    }\n#endif\n    /* handle missing slices */\n    if (s->avctx->err_recognition & AV_EF_EXPLODE) {\n        int end_ok = 1;\n\n        // FIXME + 100 hack\n        for (i = s->mb_num - 2; i >= s->mb_width + 100; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error1 = s->error_status_table[mb_xy];\n            int error2 = s->error_status_table[s->mb_index2xy[i + 1]];\n\n            if (error1 & VP_START)\n                end_ok = 1;\n\n            if (error2 == (VP_START | ER_MB_ERROR | ER_MB_END) &&\n                error1 != (VP_START | ER_MB_ERROR | ER_MB_END) &&\n                ((error1 & ER_AC_END) || (error1 & ER_DC_END) ||\n                (error1 & ER_MV_END))) {\n                // end & uninit\n                end_ok = 0;\n            }\n\n            if (!end_ok)\n                s->error_status_table[mb_xy] |= ER_MB_ERROR;\n        }\n    }\n\n#if 1\n    /* backward mark errors */\n    distance = 9999999;\n    for (error_type = 1; error_type <= 3; error_type++) {\n        for (i = s->mb_num - 1; i >= 0; i--) {\n            const int mb_xy = s->mb_index2xy[i];\n            int       error = s->error_status_table[mb_xy];\n\n            if (!s->mbskip_table || !s->mbskip_table[mb_xy]) // FIXME partition specific\n                distance++;\n            if (error & (1 << error_type))\n                distance = 0;\n\n            if (s->partitioned_frame) {\n                if (distance < threshold_part[error_type - 1])\n                    s->error_status_table[mb_xy] |= 1 << error_type;\n            } else {\n                if (distance < threshold)\n                    s->error_status_table[mb_xy] |= 1 << error_type;\n            }\n\n            if (error & VP_START)\n                distance = 9999999;\n        }\n    }\n#endif\n\n    /* forward mark errors */\n    error = 0;\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int old_error   = s->error_status_table[mb_xy];\n\n        if (old_error & VP_START) {\n            error = old_error & ER_MB_ERROR;\n        } else {\n            error |= old_error & ER_MB_ERROR;\n            s->error_status_table[mb_xy] |= error;\n        }\n    }\n#if 1\n    /* handle not partitioned case */\n    if (!s->partitioned_frame) {\n        for (i = 0; i < s->mb_num; i++) {\n            const int mb_xy = s->mb_index2xy[i];\n            int error = s->error_status_table[mb_xy];\n            if (error & ER_MB_ERROR)\n                error |= ER_MB_ERROR;\n            s->error_status_table[mb_xy] = error;\n        }\n    }\n#endif\n\n    dc_error = ac_error = mv_error = 0;\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int error = s->error_status_table[mb_xy];\n        if (error & ER_DC_ERROR)\n            dc_error++;\n        if (error & ER_AC_ERROR)\n            ac_error++;\n        if (error & ER_MV_ERROR)\n            mv_error++;\n    }\n    av_log(s->avctx, AV_LOG_INFO, \"concealing %d DC, %d AC, %d MV errors in %c frame\\n\",\n           dc_error, ac_error, mv_error, av_get_picture_type_char(s->cur_pic.f->pict_type));\n\n    is_intra_likely = is_intra_more_likely(s);\n\n    /* set unknown mb-type to most likely */\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int error = s->error_status_table[mb_xy];\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n            continue;\n\n        if (is_intra_likely)\n            s->cur_pic.mb_type[mb_xy] = MB_TYPE_INTRA4x4;\n        else\n            s->cur_pic.mb_type[mb_xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n    }\n\n    // change inter to intra blocks if no reference frames are available\n    if (!(s->last_pic.f && s->last_pic.f->data[0]) &&\n        !(s->next_pic.f && s->next_pic.f->data[0]))\n        for (i = 0; i < s->mb_num; i++) {\n            const int mb_xy = s->mb_index2xy[i];\n            if (!IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n                s->cur_pic.mb_type[mb_xy] = MB_TYPE_INTRA4x4;\n        }\n\n    /* handle inter blocks with damaged AC */\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            const int mb_xy   = mb_x + mb_y * s->mb_stride;\n            const int mb_type = s->cur_pic.mb_type[mb_xy];\n            const int dir     = !(s->last_pic.f && s->last_pic.f->data[0]);\n            const int mv_dir  = dir ? MV_DIR_BACKWARD : MV_DIR_FORWARD;\n            int mv_type;\n\n            int error = s->error_status_table[mb_xy];\n\n            if (IS_INTRA(mb_type))\n                continue; // intra\n            if (error & ER_MV_ERROR)\n                continue; // inter with damaged MV\n            if (!(error & ER_AC_ERROR))\n                continue; // undamaged inter\n\n            if (IS_8X8(mb_type)) {\n                int mb_index = mb_x * 2 + mb_y * 2 * s->b8_stride;\n                int j;\n                mv_type = MV_TYPE_8X8;\n                for (j = 0; j < 4; j++) {\n                    s->mv[0][j][0] = s->cur_pic.motion_val[dir][mb_index + (j & 1) + (j >> 1) * s->b8_stride][0];\n                    s->mv[0][j][1] = s->cur_pic.motion_val[dir][mb_index + (j & 1) + (j >> 1) * s->b8_stride][1];\n                }\n            } else {\n                mv_type     = MV_TYPE_16X16;\n                s->mv[0][0][0] = s->cur_pic.motion_val[dir][mb_x * 2 + mb_y * 2 * s->b8_stride][0];\n                s->mv[0][0][1] = s->cur_pic.motion_val[dir][mb_x * 2 + mb_y * 2 * s->b8_stride][1];\n            }\n\n            s->decode_mb(s->opaque, 0 /* FIXME H.264 partitioned slices need this set */,\n                         mv_dir, mv_type, &s->mv, mb_x, mb_y, 0, 0);\n        }\n    }\n\n    /* guess MVs */\n    if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_B) {\n        for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n                int       xy      = mb_x * 2 + mb_y * 2 * s->b8_stride;\n                const int mb_xy   = mb_x + mb_y * s->mb_stride;\n                const int mb_type = s->cur_pic.mb_type[mb_xy];\n                int mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD;\n\n                int error = s->error_status_table[mb_xy];\n\n                if (IS_INTRA(mb_type))\n                    continue;\n                if (!(error & ER_MV_ERROR))\n                    continue; // inter with undamaged MV\n                if (!(error & ER_AC_ERROR))\n                    continue; // undamaged inter\n\n                if (!(s->last_pic.f && s->last_pic.f->data[0]))\n                    mv_dir &= ~MV_DIR_FORWARD;\n                if (!(s->next_pic.f && s->next_pic.f->data[0]))\n                    mv_dir &= ~MV_DIR_BACKWARD;\n\n                if (s->pp_time) {\n                    int time_pp = s->pp_time;\n                    int time_pb = s->pb_time;\n\n                    av_assert0(s->avctx->codec_id != AV_CODEC_ID_H264);\n                    ff_thread_await_progress(s->next_pic.tf, mb_y, 0);\n\n                    s->mv[0][0][0] = s->next_pic.motion_val[0][xy][0] *  time_pb            / time_pp;\n                    s->mv[0][0][1] = s->next_pic.motion_val[0][xy][1] *  time_pb            / time_pp;\n                    s->mv[1][0][0] = s->next_pic.motion_val[0][xy][0] * (time_pb - time_pp) / time_pp;\n                    s->mv[1][0][1] = s->next_pic.motion_val[0][xy][1] * (time_pb - time_pp) / time_pp;\n                } else {\n                    s->mv[0][0][0] = 0;\n                    s->mv[0][0][1] = 0;\n                    s->mv[1][0][0] = 0;\n                    s->mv[1][0][1] = 0;\n                }\n\n                s->decode_mb(s->opaque, 0, mv_dir, MV_TYPE_16X16, &s->mv,\n                             mb_x, mb_y, 0, 0);\n            }\n        }\n    } else\n        guess_mv(s);\n\n    /* the filters below manipulate raw image, skip them */\n    if (CONFIG_XVMC && s->avctx->hwaccel && s->avctx->hwaccel->decode_mb)\n        goto ec_clean;\n    /* fill DC for inter blocks */\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            int dc, dcu, dcv, y, n;\n            int16_t *dc_ptr;\n            uint8_t *dest_y, *dest_cb, *dest_cr;\n            const int mb_xy   = mb_x + mb_y * s->mb_stride;\n            const int mb_type = s->cur_pic.mb_type[mb_xy];\n\n            // error = s->error_status_table[mb_xy];\n\n            if (IS_INTRA(mb_type) && s->partitioned_frame)\n                continue;\n            // if (error & ER_MV_ERROR)\n            //     continue; // inter data damaged FIXME is this good?\n\n            dest_y  = s->cur_pic.f->data[0] + mb_x * 16 + mb_y * 16 * linesize[0];\n            dest_cb = s->cur_pic.f->data[1] + mb_x *  8 + mb_y *  8 * linesize[1];\n            dest_cr = s->cur_pic.f->data[2] + mb_x *  8 + mb_y *  8 * linesize[2];\n\n            dc_ptr = &s->dc_val[0][mb_x * 2 + mb_y * 2 * s->b8_stride];\n            for (n = 0; n < 4; n++) {\n                dc = 0;\n                for (y = 0; y < 8; y++) {\n                    int x;\n                    for (x = 0; x < 8; x++)\n                       dc += dest_y[x + (n & 1) * 8 +\n                             (y + (n >> 1) * 8) * linesize[0]];\n                }\n                dc_ptr[(n & 1) + (n >> 1) * s->b8_stride] = (dc + 4) >> 3;\n            }\n\n            if (!s->cur_pic.f->data[2])\n                continue;\n\n            dcu = dcv = 0;\n            for (y = 0; y < 8; y++) {\n                int x;\n                for (x = 0; x < 8; x++) {\n                    dcu += dest_cb[x + y * linesize[1]];\n                    dcv += dest_cr[x + y * linesize[2]];\n                }\n            }\n            s->dc_val[1][mb_x + mb_y * s->mb_stride] = (dcu + 4) >> 3;\n            s->dc_val[2][mb_x + mb_y * s->mb_stride] = (dcv + 4) >> 3;\n        }\n    }\n#if 1\n    /* guess DC for damaged blocks */\n    guess_dc(s, s->dc_val[0], s->mb_width*2, s->mb_height*2, s->b8_stride, 1);\n    guess_dc(s, s->dc_val[1], s->mb_width  , s->mb_height  , s->mb_stride, 0);\n    guess_dc(s, s->dc_val[2], s->mb_width  , s->mb_height  , s->mb_stride, 0);\n#endif\n\n    /* filter luma DC */\n    filter181(s->dc_val[0], s->mb_width * 2, s->mb_height * 2, s->b8_stride);\n\n#if 1\n    /* render DC only intra */\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            uint8_t *dest_y, *dest_cb, *dest_cr;\n            const int mb_xy   = mb_x + mb_y * s->mb_stride;\n            const int mb_type = s->cur_pic.mb_type[mb_xy];\n\n            int error = s->error_status_table[mb_xy];\n\n            if (IS_INTER(mb_type))\n                continue;\n            if (!(error & ER_AC_ERROR))\n                continue; // undamaged\n\n            dest_y  = s->cur_pic.f->data[0] + mb_x * 16 + mb_y * 16 * linesize[0];\n            dest_cb = s->cur_pic.f->data[1] + mb_x *  8 + mb_y *  8 * linesize[1];\n            dest_cr = s->cur_pic.f->data[2] + mb_x *  8 + mb_y *  8 * linesize[2];\n            if (!s->cur_pic.f->data[2])\n                dest_cb = dest_cr = NULL;\n\n            put_dc(s, dest_y, dest_cb, dest_cr, mb_x, mb_y);\n        }\n    }\n#endif\n\n    if (s->avctx->error_concealment & FF_EC_DEBLOCK) {\n        /* filter horizontal block boundaries */\n        h_block_filter(s, s->cur_pic.f->data[0], s->mb_width * 2,\n                       s->mb_height * 2, linesize[0], 1);\n\n        /* filter vertical block boundaries */\n        v_block_filter(s, s->cur_pic.f->data[0], s->mb_width * 2,\n                       s->mb_height * 2, linesize[0], 1);\n\n        if (s->cur_pic.f->data[2]) {\n            h_block_filter(s, s->cur_pic.f->data[1], s->mb_width,\n                        s->mb_height, linesize[1], 0);\n            h_block_filter(s, s->cur_pic.f->data[2], s->mb_width,\n                        s->mb_height, linesize[2], 0);\n            v_block_filter(s, s->cur_pic.f->data[1], s->mb_width,\n                        s->mb_height, linesize[1], 0);\n            v_block_filter(s, s->cur_pic.f->data[2], s->mb_width,\n                        s->mb_height, linesize[2], 0);\n        }\n    }\n\nec_clean:\n    /* clean a few tables */\n    for (i = 0; i < s->mb_num; i++) {\n        const int mb_xy = s->mb_index2xy[i];\n        int       error = s->error_status_table[mb_xy];\n\n        if (s->mbskip_table && s->cur_pic.f->pict_type != AV_PICTURE_TYPE_B &&\n            (error & (ER_DC_ERROR | ER_MV_ERROR | ER_AC_ERROR))) {\n            s->mbskip_table[mb_xy] = 0;\n        }\n        if (s->mbintra_table)\n            s->mbintra_table[mb_xy] = 1;\n    }\n\n    for (i = 0; i < 2; i++) {\n        av_buffer_unref(&s->ref_index_buf[i]);\n        av_buffer_unref(&s->motion_val_buf[i]);\n        s->cur_pic.ref_index[i]  = NULL;\n        s->cur_pic.motion_val[i] = NULL;\n    }\n\n    memset(&s->cur_pic, 0, sizeof(ERPicture));\n    memset(&s->last_pic, 0, sizeof(ERPicture));\n    memset(&s->next_pic, 0, sizeof(ERPicture));\n}\n", "/*\n * H.263 decoder\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * H.263 decoder.\n */\n\n#define UNCHECKED_BITSTREAM_READER 1\n\n#include \"libavutil/cpu.h\"\n#include \"avcodec.h\"\n#include \"error_resilience.h\"\n#include \"flv.h\"\n#include \"h263.h\"\n#include \"h263_parser.h\"\n#include \"hwaccel.h\"\n#include \"internal.h\"\n#include \"mpeg_er.h\"\n#include \"mpeg4video.h\"\n#include \"mpeg4video_parser.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"msmpeg4.h\"\n#include \"qpeldsp.h\"\n#include \"thread.h\"\n#include \"wmv2.h\"\n\nstatic enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    /* MPEG-4 Studio Profile only, not supported by hardware */\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(s->studio_profile);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}\n\nav_cold int ff_h263_decode_init(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    int ret;\n\n    s->out_format      = FMT_H263;\n\n    // set defaults\n    ff_mpv_decode_defaults(s);\n    ff_mpv_decode_init(s, avctx);\n\n    s->quant_precision = 5;\n    s->decode_mb       = ff_h263_decode_mb;\n    s->low_delay       = 1;\n    s->unrestricted_mv = 1;\n\n    /* select sub codec */\n    switch (avctx->codec->id) {\n    case AV_CODEC_ID_H263:\n    case AV_CODEC_ID_H263P:\n        s->unrestricted_mv = 0;\n        avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;\n        break;\n    case AV_CODEC_ID_MPEG4:\n        break;\n    case AV_CODEC_ID_MSMPEG4V1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 1;\n        break;\n    case AV_CODEC_ID_MSMPEG4V2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 2;\n        break;\n    case AV_CODEC_ID_MSMPEG4V3:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 3;\n        break;\n    case AV_CODEC_ID_WMV1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 4;\n        break;\n    case AV_CODEC_ID_WMV2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 5;\n        break;\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_WMV3:\n    case AV_CODEC_ID_VC1IMAGE:\n    case AV_CODEC_ID_WMV3IMAGE:\n    case AV_CODEC_ID_MSS2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 6;\n        avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n        break;\n    case AV_CODEC_ID_H263I:\n        break;\n    case AV_CODEC_ID_FLV1:\n        s->h263_flv = 1;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec %d\\n\",\n               avctx->codec->id);\n        return AVERROR(ENOSYS);\n    }\n    s->codec_id    = avctx->codec->id;\n\n    if (avctx->codec_tag == AV_RL32(\"L263\") || avctx->codec_tag == AV_RL32(\"S263\"))\n        if (avctx->extradata_size == 56 && avctx->extradata[0] == 1)\n            s->ehc_mode = 1;\n\n    /* for H.263, we allocate the images after having read the header */\n    if (avctx->codec->id != AV_CODEC_ID_H263 &&\n        avctx->codec->id != AV_CODEC_ID_H263P &&\n        avctx->codec->id != AV_CODEC_ID_MPEG4) {\n        avctx->pix_fmt = h263_get_format(avctx);\n        ff_mpv_idct_init(s);\n        if ((ret = ff_mpv_common_init(s)) < 0)\n            return ret;\n    }\n\n    ff_h263dsp_init(&s->h263dsp);\n    ff_qpeldsp_init(&s->qdsp);\n    ff_h263_decode_init_vlc();\n\n    return 0;\n}\n\nav_cold int ff_h263_decode_end(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n\n    ff_mpv_common_end(s);\n    return 0;\n}\n\n/**\n * Return the number of bytes consumed for building the current frame.\n */\nstatic int get_consumed_bytes(MpegEncContext *s, int buf_size)\n{\n    int pos = (get_bits_count(&s->gb) + 7) >> 3;\n\n    if (s->divx_packed || s->avctx->hwaccel) {\n        /* We would have to scan through the whole buf to handle the weird\n         * reordering ... */\n        return buf_size;\n    } else if (s->avctx->flags & AV_CODEC_FLAG_TRUNCATED) {\n        pos -= s->parse_context.last_index;\n        // padding is not really read so this might be -1\n        if (pos < 0)\n            pos = 0;\n        return pos;\n    } else {\n        // avoid infinite loops (maybe not needed...)\n        if (pos == 0)\n            pos = 1;\n        // oops ;)\n        if (pos + 10 > buf_size)\n            pos = buf_size;\n\n        return pos;\n    }\n}\n\nstatic int decode_slice(MpegEncContext *s)\n{\n    const int part_mask = s->partitioned_frame\n                          ? (ER_AC_END | ER_AC_ERROR) : 0x7F;\n    const int mb_size   = 16 >> s->avctx->lowres;\n    int ret;\n\n    s->last_resync_gb   = s->gb;\n    s->first_slice_line = 1;\n    s->resync_mb_x      = s->mb_x;\n    s->resync_mb_y      = s->mb_y;\n\n    ff_set_qscale(s, s->qscale);\n\n    if (s->studio_profile) {\n        if ((ret = ff_mpeg4_decode_studio_slice_header(s->avctx->priv_data)) < 0)\n            return ret;\n    }\n\n    if (s->avctx->hwaccel) {\n        const uint8_t *start = s->gb.buffer + get_bits_count(&s->gb) / 8;\n        ret = s->avctx->hwaccel->decode_slice(s->avctx, start, s->gb.buffer_end - start);\n        // ensure we exit decode loop\n        s->mb_y = s->mb_height;\n        return ret;\n    }\n\n    if (s->partitioned_frame) {\n        const int qscale = s->qscale;\n\n        if (CONFIG_MPEG4_DECODER && s->codec_id == AV_CODEC_ID_MPEG4)\n            if ((ret = ff_mpeg4_decode_partitions(s->avctx->priv_data)) < 0)\n                return ret;\n\n        /* restore variables which were modified */\n        s->first_slice_line = 1;\n        s->mb_x             = s->resync_mb_x;\n        s->mb_y             = s->resync_mb_y;\n        ff_set_qscale(s, qscale);\n    }\n\n    for (; s->mb_y < s->mb_height; s->mb_y++) {\n        /* per-row end of slice checks */\n        if (s->msmpeg4_version) {\n            if (s->resync_mb_y + s->slice_height == s->mb_y) {\n                ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                s->mb_x - 1, s->mb_y, ER_MB_END);\n\n                return 0;\n            }\n        }\n\n        if (s->msmpeg4_version == 1) {\n            s->last_dc[0] =\n            s->last_dc[1] =\n            s->last_dc[2] = 128;\n        }\n\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            int ret;\n\n            ff_update_block_index(s);\n\n            if (s->resync_mb_x == s->mb_x && s->resync_mb_y + 1 == s->mb_y)\n                s->first_slice_line = 0;\n\n            /* DCT & quantize */\n\n            s->mv_dir  = MV_DIR_FORWARD;\n            s->mv_type = MV_TYPE_16X16;\n            ff_dlog(s, \"%d %06X\\n\",\n                    get_bits_count(&s->gb), show_bits(&s->gb, 24));\n\n            ff_tlog(NULL, \"Decoding MB at %dx%d\\n\", s->mb_x, s->mb_y);\n            ret = s->decode_mb(s, s->block);\n\n            if (s->pict_type != AV_PICTURE_TYPE_B)\n                ff_h263_update_motion_val(s);\n\n            if (ret < 0) {\n                const int xy = s->mb_x + s->mb_y * s->mb_stride;\n                if (ret == SLICE_END) {\n                    ff_mpv_reconstruct_mb(s, s->block);\n                    if (s->loop_filter)\n                        ff_h263_loop_filter(s);\n\n                    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                    s->mb_x, s->mb_y, ER_MB_END & part_mask);\n\n                    s->padding_bug_score--;\n\n                    if (++s->mb_x >= s->mb_width) {\n                        s->mb_x = 0;\n                        ff_mpeg_draw_horiz_band(s, s->mb_y * mb_size, mb_size);\n                        ff_mpv_report_decode_progress(s);\n                        s->mb_y++;\n                    }\n                    return 0;\n                } else if (ret == SLICE_NOEND) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Slice mismatch at MB: %d\\n\", xy);\n                    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                    s->mb_x + 1, s->mb_y,\n                                    ER_MB_END & part_mask);\n                    return AVERROR_INVALIDDATA;\n                }\n                av_log(s->avctx, AV_LOG_ERROR, \"Error at MB: %d\\n\", xy);\n                ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                                s->mb_x, s->mb_y, ER_MB_ERROR & part_mask);\n\n                if (s->avctx->err_recognition & AV_EF_IGNORE_ERR)\n                    continue;\n                return AVERROR_INVALIDDATA;\n            }\n\n            ff_mpv_reconstruct_mb(s, s->block);\n            if (s->loop_filter)\n                ff_h263_loop_filter(s);\n        }\n\n        ff_mpeg_draw_horiz_band(s, s->mb_y * mb_size, mb_size);\n        ff_mpv_report_decode_progress(s);\n\n        s->mb_x = 0;\n    }\n\n    av_assert1(s->mb_x == 0 && s->mb_y == s->mb_height);\n\n    // Detect incorrect padding with wrong stuffing codes used by NEC N-02B\n    if (s->codec_id == AV_CODEC_ID_MPEG4         &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 48              &&\n        show_bits(&s->gb, 24) == 0x4010          &&\n        !s->data_partitioning)\n        s->padding_bug_score += 32;\n\n    /* try to detect the padding bug */\n    if (s->codec_id == AV_CODEC_ID_MPEG4         &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 0               &&\n        get_bits_left(&s->gb) < 137              &&\n        !s->data_partitioning) {\n        const int bits_count = get_bits_count(&s->gb);\n        const int bits_left  = s->gb.size_in_bits - bits_count;\n\n        if (bits_left == 0) {\n            s->padding_bug_score += 16;\n        } else if (bits_left != 1) {\n            int v = show_bits(&s->gb, 8);\n            v |= 0x7F >> (7 - (bits_count & 7));\n\n            if (v == 0x7F && bits_left <= 8)\n                s->padding_bug_score--;\n            else if (v == 0x7F && ((get_bits_count(&s->gb) + 8) & 8) &&\n                     bits_left <= 16)\n                s->padding_bug_score += 4;\n            else\n                s->padding_bug_score++;\n        }\n    }\n\n    if (s->codec_id == AV_CODEC_ID_H263          &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 8               &&\n        get_bits_left(&s->gb) < 300              &&\n        s->pict_type == AV_PICTURE_TYPE_I        &&\n        show_bits(&s->gb, 8) == 0                &&\n        !s->data_partitioning) {\n\n        s->padding_bug_score += 32;\n    }\n\n    if (s->codec_id == AV_CODEC_ID_H263          &&\n        (s->workaround_bugs & FF_BUG_AUTODETECT) &&\n        get_bits_left(&s->gb) >= 64              &&\n        AV_RB64(s->gb.buffer_end - 8) == 0xCDCDCDCDFC7F0000) {\n\n        s->padding_bug_score += 32;\n    }\n\n    if (s->workaround_bugs & FF_BUG_AUTODETECT) {\n        if (\n            (s->padding_bug_score > -2 && !s->data_partitioning))\n            s->workaround_bugs |= FF_BUG_NO_PADDING;\n        else\n            s->workaround_bugs &= ~FF_BUG_NO_PADDING;\n    }\n\n    // handle formats which don't have unique end markers\n    if (s->msmpeg4_version || (s->workaround_bugs & FF_BUG_NO_PADDING)) { // FIXME perhaps solve this more cleanly\n        int left      = get_bits_left(&s->gb);\n        int max_extra = 7;\n\n        /* no markers in M$ crap */\n        if (s->msmpeg4_version && s->pict_type == AV_PICTURE_TYPE_I)\n            max_extra += 17;\n\n        /* buggy padding but the frame should still end approximately at\n         * the bitstream end */\n        if ((s->workaround_bugs & FF_BUG_NO_PADDING) &&\n            (s->avctx->err_recognition & (AV_EF_BUFFER|AV_EF_AGGRESSIVE)))\n            max_extra += 48;\n        else if ((s->workaround_bugs & FF_BUG_NO_PADDING))\n            max_extra += 256 * 256 * 256 * 64;\n\n        if (left > max_extra)\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"discarding %d junk bits at end, next would be %X\\n\",\n                   left, show_bits(&s->gb, 24));\n        else if (left < 0)\n            av_log(s->avctx, AV_LOG_ERROR, \"overreading %d bits\\n\", -left);\n        else\n            ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                            s->mb_x - 1, s->mb_y, ER_MB_END);\n\n        return 0;\n    }\n\n    av_log(s->avctx, AV_LOG_ERROR,\n           \"slice end not reached but screenspace end (%d left %06X, score= %d)\\n\",\n           get_bits_left(&s->gb), show_bits(&s->gb, 24), s->padding_bug_score);\n\n    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y,\n                    ER_MB_END & part_mask);\n\n    return AVERROR_INVALIDDATA;\n}\n\nint ff_h263_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                         AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    MpegEncContext *s  = avctx->priv_data;\n    int ret;\n    int slice_ret = 0;\n    AVFrame *pict = data;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay == 0 && s->next_picture_ptr) {\n            if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n                return ret;\n            s->next_picture_ptr = NULL;\n\n            *got_frame = 1;\n        }\n\n        return 0;\n    }\n\n    if (s->avctx->flags & AV_CODEC_FLAG_TRUNCATED) {\n        int next;\n\n        if (CONFIG_MPEG4_DECODER && s->codec_id == AV_CODEC_ID_MPEG4) {\n            next = ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);\n        } else if (CONFIG_H263_DECODER && s->codec_id == AV_CODEC_ID_H263) {\n            next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n        } else if (CONFIG_H263P_DECODER && s->codec_id == AV_CODEC_ID_H263P) {\n            next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n        } else {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"this codec does not support truncated bitstreams\\n\");\n            return AVERROR(ENOSYS);\n        }\n\n        if (ff_combine_frame(&s->parse_context, next, (const uint8_t **)&buf,\n                             &buf_size) < 0)\n            return buf_size;\n    }\n\nretry:\n    if (s->divx_packed && s->bitstream_buffer_size) {\n        int i;\n        for(i=0; i < buf_size-3; i++) {\n            if (buf[i]==0 && buf[i+1]==0 && buf[i+2]==1) {\n                if (buf[i+3]==0xB0) {\n                    av_log(s->avctx, AV_LOG_WARNING, \"Discarding excessive bitstream in packed xvid\\n\");\n                    s->bitstream_buffer_size = 0;\n                }\n                break;\n            }\n        }\n    }\n\n    if (s->bitstream_buffer_size && (s->divx_packed || buf_size <= MAX_NVOP_SIZE)) // divx 5.01+/xvid frame reorder\n        ret = init_get_bits8(&s->gb, s->bitstream_buffer,\n                             s->bitstream_buffer_size);\n    else\n        ret = init_get_bits8(&s->gb, buf, buf_size);\n\n    s->bitstream_buffer_size = 0;\n    if (ret < 0)\n        return ret;\n\n    if (!s->context_initialized)\n        // we need the idct permutation for reading a custom matrix\n        ff_mpv_idct_init(s);\n\n    /* let's go :-) */\n    if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {\n        ret = ff_wmv2_decode_picture_header(s);\n    } else if (CONFIG_MSMPEG4_DECODER && s->msmpeg4_version) {\n        ret = ff_msmpeg4_decode_picture_header(s);\n    } else if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {\n        if (s->avctx->extradata_size && s->picture_number == 0) {\n            GetBitContext gb;\n\n            if (init_get_bits8(&gb, s->avctx->extradata, s->avctx->extradata_size) >= 0 )\n                ff_mpeg4_decode_picture_header(avctx->priv_data, &gb);\n        }\n        ret = ff_mpeg4_decode_picture_header(avctx->priv_data, &s->gb);\n    } else if (CONFIG_H263I_DECODER && s->codec_id == AV_CODEC_ID_H263I) {\n        ret = ff_intel_h263_decode_picture_header(s);\n    } else if (CONFIG_FLV_DECODER && s->h263_flv) {\n        ret = ff_flv_decode_picture_header(s);\n    } else {\n        ret = ff_h263_decode_picture_header(s);\n    }\n\n    if (ret < 0 || ret == FRAME_SKIPPED) {\n        if (   s->width  != avctx->coded_width\n            || s->height != avctx->coded_height) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Reverting picture dimensions change due to header decoding failure\\n\");\n                s->width = avctx->coded_width;\n                s->height= avctx->coded_height;\n        }\n    }\n    if (ret == FRAME_SKIPPED)\n        return get_consumed_bytes(s, buf_size);\n\n    /* skip if the header was thrashed */\n    if (ret < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"header damaged\\n\");\n        return ret;\n    }\n\n    if (!s->context_initialized) {\n        avctx->pix_fmt = h263_get_format(avctx);\n        if ((ret = ff_mpv_common_init(s)) < 0)\n            return ret;\n    }\n\n    if (!s->current_picture_ptr || s->current_picture_ptr->f->data[0]) {\n        int i = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0)\n            return i;\n        s->current_picture_ptr = &s->picture[i];\n    }\n\n    avctx->has_b_frames = !s->low_delay;\n\n    if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {\n        if (ff_mpeg4_workaround_bugs(avctx) == 1)\n            goto retry;\n        if (s->studio_profile != (s->idsp.idct == NULL))\n            ff_mpv_idct_init(s);\n    }\n\n    /* After H.263 & MPEG-4 header decode we have the height, width,\n     * and other parameters. So then we could init the picture.\n     * FIXME: By the way H.263 decoder is evolving it should have\n     * an H263EncContext */\n    if (s->width  != avctx->coded_width  ||\n        s->height != avctx->coded_height ||\n        s->context_reinit) {\n        /* H.263 could change picture size any time */\n        s->context_reinit = 0;\n\n        ret = ff_set_dimensions(avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n\n        ff_set_sar(avctx, avctx->sample_aspect_ratio);\n\n        if ((ret = ff_mpv_common_frame_size_change(s)))\n            return ret;\n\n        if (avctx->pix_fmt != h263_get_format(avctx)) {\n            av_log(avctx, AV_LOG_ERROR, \"format change not supported\\n\");\n            avctx->pix_fmt = AV_PIX_FMT_NONE;\n            return AVERROR_UNKNOWN;\n        }\n    }\n\n    if (s->codec_id == AV_CODEC_ID_H263  ||\n        s->codec_id == AV_CODEC_ID_H263P ||\n        s->codec_id == AV_CODEC_ID_H263I)\n        s->gob_index = H263_GOB_HEIGHT(s->height);\n\n    // for skipping the frame\n    s->current_picture.f->pict_type = s->pict_type;\n    s->current_picture.f->key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n    /* skip B-frames if we don't have reference frames */\n    if (!s->last_picture_ptr &&\n        (s->pict_type == AV_PICTURE_TYPE_B || s->droppable))\n        return get_consumed_bytes(s, buf_size);\n    if ((avctx->skip_frame >= AVDISCARD_NONREF &&\n         s->pict_type == AV_PICTURE_TYPE_B)    ||\n        (avctx->skip_frame >= AVDISCARD_NONKEY &&\n         s->pict_type != AV_PICTURE_TYPE_I)    ||\n        avctx->skip_frame >= AVDISCARD_ALL)\n        return get_consumed_bytes(s, buf_size);\n\n    if (s->next_p_frame_damaged) {\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n            return get_consumed_bytes(s, buf_size);\n        else\n            s->next_p_frame_damaged = 0;\n    }\n\n    if ((!s->no_rounding) || s->pict_type == AV_PICTURE_TYPE_B) {\n        s->me.qpel_put = s->qdsp.put_qpel_pixels_tab;\n        s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;\n    } else {\n        s->me.qpel_put = s->qdsp.put_no_rnd_qpel_pixels_tab;\n        s->me.qpel_avg = s->qdsp.avg_qpel_pixels_tab;\n    }\n\n    if ((ret = ff_mpv_frame_start(s, avctx)) < 0)\n        return ret;\n\n    if (!s->divx_packed)\n        ff_thread_finish_setup(avctx);\n\n    if (avctx->hwaccel) {\n        ret = avctx->hwaccel->start_frame(avctx, s->gb.buffer,\n                                          s->gb.buffer_end - s->gb.buffer);\n        if (ret < 0 )\n            return ret;\n    }\n\n    ff_mpeg_er_frame_start(s);\n\n    /* the second part of the wmv2 header contains the MB skip bits which\n     * are stored in current_picture->mb_type which is not available before\n     * ff_mpv_frame_start() */\n    if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {\n        ret = ff_wmv2_decode_secondary_picture_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1)\n            goto frame_end;\n    }\n\n    /* decode each macroblock */\n    s->mb_x = 0;\n    s->mb_y = 0;\n\n    slice_ret = decode_slice(s);\n    while (s->mb_y < s->mb_height) {\n        if (s->msmpeg4_version) {\n            if (s->slice_height == 0 || s->mb_x != 0 || slice_ret < 0 ||\n                (s->mb_y % s->slice_height) != 0 || get_bits_left(&s->gb) < 0)\n                break;\n        } else {\n            int prev_x = s->mb_x, prev_y = s->mb_y;\n            if (ff_h263_resync(s) < 0)\n                break;\n            if (prev_y * s->mb_width + prev_x < s->mb_y * s->mb_width + s->mb_x)\n                s->er.error_occurred = 1;\n        }\n\n        if (s->msmpeg4_version < 4 && s->h263_pred)\n            ff_mpeg4_clean_buffers(s);\n\n        if (decode_slice(s) < 0)\n            slice_ret = AVERROR_INVALIDDATA;\n    }\n\n    if (s->msmpeg4_version && s->msmpeg4_version < 4 &&\n        s->pict_type == AV_PICTURE_TYPE_I)\n        if (!CONFIG_MSMPEG4_DECODER ||\n            ff_msmpeg4_decode_ext_header(s, buf_size) < 0)\n            s->er.error_status_table[s->mb_num - 1] = ER_MB_ERROR;\n\n    av_assert1(s->bitstream_buffer_size == 0);\nframe_end:\n    if (!s->studio_profile)\n        ff_er_frame_end(&s->er);\n\n    if (avctx->hwaccel) {\n        ret = avctx->hwaccel->end_frame(avctx);\n        if (ret < 0)\n            return ret;\n    }\n\n    ff_mpv_frame_end(s);\n\n    if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4)\n        ff_mpeg4_frame_end(avctx, buf, buf_size);\n\n    if (!s->divx_packed && avctx->hwaccel)\n        ff_thread_finish_setup(avctx);\n\n    av_assert1(s->current_picture.f->pict_type == s->current_picture_ptr->f->pict_type);\n    av_assert1(s->current_picture.f->pict_type == s->pict_type);\n    if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n        if ((ret = av_frame_ref(pict, s->current_picture_ptr->f)) < 0)\n            return ret;\n        ff_print_debug_info(s, s->current_picture_ptr, pict);\n        ff_mpv_export_qp_table(s, pict, s->current_picture_ptr, FF_QSCALE_TYPE_MPEG1);\n    } else if (s->last_picture_ptr) {\n        if ((ret = av_frame_ref(pict, s->last_picture_ptr->f)) < 0)\n            return ret;\n        ff_print_debug_info(s, s->last_picture_ptr, pict);\n        ff_mpv_export_qp_table(s, pict, s->last_picture_ptr, FF_QSCALE_TYPE_MPEG1);\n    }\n\n    if (s->last_picture_ptr || s->low_delay) {\n        if (   pict->format == AV_PIX_FMT_YUV420P\n            && (s->codec_tag == AV_RL32(\"GEOV\") || s->codec_tag == AV_RL32(\"GEOX\"))) {\n            int x, y, p;\n            av_frame_make_writable(pict);\n            for (p=0; p<3; p++) {\n                int w = AV_CEIL_RSHIFT(pict-> width, !!p);\n                int h = AV_CEIL_RSHIFT(pict->height, !!p);\n                int linesize = pict->linesize[p];\n                for (y=0; y<(h>>1); y++)\n                    for (x=0; x<w; x++)\n                        FFSWAP(int,\n                               pict->data[p][x + y*linesize],\n                               pict->data[p][x + (h-1-y)*linesize]);\n            }\n        }\n        *got_frame = 1;\n    }\n\n    if (slice_ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n        return slice_ret;\n    else\n        return get_consumed_bytes(s, buf_size);\n}\n\nconst enum AVPixelFormat ff_h263_hwaccel_pixfmt_list_420[] = {\n#if CONFIG_H263_VAAPI_HWACCEL || CONFIG_MPEG4_VAAPI_HWACCEL\n    AV_PIX_FMT_VAAPI,\n#endif\n#if CONFIG_MPEG4_NVDEC_HWACCEL\n    AV_PIX_FMT_CUDA,\n#endif\n#if CONFIG_MPEG4_VDPAU_HWACCEL\n    AV_PIX_FMT_VDPAU,\n#endif\n#if CONFIG_H263_VIDEOTOOLBOX_HWACCEL || CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL\n    AV_PIX_FMT_VIDEOTOOLBOX,\n#endif\n    AV_PIX_FMT_YUV420P,\n    AV_PIX_FMT_NONE\n};\n\nAVCodec ff_h263_decoder = {\n    .name           = \"h263\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_H263,\n    .priv_data_size = sizeof(MpegEncContext),\n    .init           = ff_h263_decode_init,\n    .close          = ff_h263_decode_end,\n    .decode         = ff_h263_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1 |\n                      AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,\n    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n    .flush          = ff_mpeg_flush,\n    .max_lowres     = 3,\n    .pix_fmts       = ff_h263_hwaccel_pixfmt_list_420,\n};\n\nAVCodec ff_h263p_decoder = {\n    .name           = \"h263p\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"H.263 / H.263-1996, H.263+ / H.263-1998 / H.263 version 2\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_H263P,\n    .priv_data_size = sizeof(MpegEncContext),\n    .init           = ff_h263_decode_init,\n    .close          = ff_h263_decode_end,\n    .decode         = ff_h263_decode_frame,\n    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1 |\n                      AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,\n    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n    .flush          = ff_mpeg_flush,\n    .max_lowres     = 3,\n    .pix_fmts       = ff_h263_hwaccel_pixfmt_list_420,\n    .hw_configs     = (const AVCodecHWConfigInternal*[]) {\n#if CONFIG_H263_VAAPI_HWACCEL\n                        HWACCEL_VAAPI(h263),\n#endif\n#if CONFIG_MPEG4_VDPAU_HWACCEL\n                        HWACCEL_VDPAU(mpeg4),\n#endif\n#if CONFIG_H263_VIDEOTOOLBOX_HWACCEL\n                        HWACCEL_VIDEOTOOLBOX(h263),\n#endif\n                        NULL\n                    },\n};\n", "/*\n * MPEG-4 decoder\n * Copyright (c) 2000,2001 Fabrice Bellard\n * Copyright (c) 2002-2010 Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define UNCHECKED_BITSTREAM_READER 1\n\n#include \"libavutil/internal.h\"\n#include \"libavutil/opt.h\"\n#include \"error_resilience.h\"\n#include \"hwaccel.h\"\n#include \"idctdsp.h\"\n#include \"internal.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"mpegvideodata.h\"\n#include \"mpeg4video.h\"\n#include \"h263.h\"\n#include \"profiles.h\"\n#include \"thread.h\"\n#include \"xvididct.h\"\n\n/* The defines below define the number of bits that are read at once for\n * reading vlc values. Changing these may improve speed and data cache needs\n * be aware though that decreasing them may need the number of stages that is\n * passed to get_vlc* to be increased. */\n#define SPRITE_TRAJ_VLC_BITS 6\n#define DC_VLC_BITS 9\n#define MB_TYPE_B_VLC_BITS 4\n#define STUDIO_INTRA_BITS 9\n\nstatic int decode_studio_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb);\n\nstatic VLC dc_lum, dc_chrom;\nstatic VLC sprite_trajectory;\nstatic VLC mb_type_b_vlc;\n\nstatic const int mb_type_b_map[4] = {\n    MB_TYPE_DIRECT2 | MB_TYPE_L0L1,\n    MB_TYPE_L0L1    | MB_TYPE_16x16,\n    MB_TYPE_L1      | MB_TYPE_16x16,\n    MB_TYPE_L0      | MB_TYPE_16x16,\n};\n\n/**\n * Predict the ac.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n * @param dir the ac prediction direction\n */\nvoid ff_mpeg4_pred_ac(MpegEncContext *s, int16_t *block, int n, int dir)\n{\n    int i;\n    int16_t *ac_val, *ac_val1;\n    int8_t *const qscale_table = s->current_picture.qscale_table;\n\n    /* find prediction */\n    ac_val  = &s->ac_val[0][0][0] + s->block_index[n] * 16;\n    ac_val1 = ac_val;\n    if (s->ac_pred) {\n        if (dir == 0) {\n            const int xy = s->mb_x - 1 + s->mb_y * s->mb_stride;\n            /* left prediction */\n            ac_val -= 16;\n\n            if (s->mb_x == 0 || s->qscale == qscale_table[xy] ||\n                n == 1 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i << 3]] += ac_val[i];\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i << 3]] += ROUNDED_DIV(ac_val[i] * qscale_table[xy], s->qscale);\n            }\n        } else {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride - s->mb_stride;\n            /* top prediction */\n            ac_val -= 16 * s->block_wrap[n];\n\n            if (s->mb_y == 0 || s->qscale == qscale_table[xy] ||\n                n == 2 || n == 3) {\n                /* same qscale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i]] += ac_val[i + 8];\n            } else {\n                /* different qscale, we must rescale */\n                for (i = 1; i < 8; i++)\n                    block[s->idsp.idct_permutation[i]] += ROUNDED_DIV(ac_val[i + 8] * qscale_table[xy], s->qscale);\n            }\n        }\n    }\n    /* left copy */\n    for (i = 1; i < 8; i++)\n        ac_val1[i] = block[s->idsp.idct_permutation[i << 3]];\n\n    /* top copy */\n    for (i = 1; i < 8; i++)\n        ac_val1[8 + i] = block[s->idsp.idct_permutation[i]];\n}\n\n/**\n * check if the next stuff is a resync marker or the end.\n * @return 0 if not\n */\nstatic inline int mpeg4_is_resync(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    int bits_count = get_bits_count(&s->gb);\n    int v          = show_bits(&s->gb, 16);\n\n    if (s->workaround_bugs & FF_BUG_NO_PADDING && !ctx->resync_marker)\n        return 0;\n\n    while (v <= 0xFF) {\n        if (s->pict_type == AV_PICTURE_TYPE_B ||\n            (v >> (8 - s->pict_type) != 1) || s->partitioned_frame)\n            break;\n        skip_bits(&s->gb, 8 + s->pict_type);\n        bits_count += 8 + s->pict_type;\n        v = show_bits(&s->gb, 16);\n    }\n\n    if (bits_count + 8 >= s->gb.size_in_bits) {\n        v >>= 8;\n        v  |= 0x7F >> (7 - (bits_count & 7));\n\n        if (v == 0x7F)\n            return s->mb_num;\n    } else {\n        if (v == ff_mpeg4_resync_prefix[bits_count & 7]) {\n            int len, mb_num;\n            int mb_num_bits = av_log2(s->mb_num - 1) + 1;\n            GetBitContext gb = s->gb;\n\n            skip_bits(&s->gb, 1);\n            align_get_bits(&s->gb);\n\n            for (len = 0; len < 32; len++)\n                if (get_bits1(&s->gb))\n                    break;\n\n            mb_num = get_bits(&s->gb, mb_num_bits);\n            if (!mb_num || mb_num > s->mb_num || get_bits_count(&s->gb)+6 > s->gb.size_in_bits)\n                mb_num= -1;\n\n            s->gb = gb;\n\n            if (len >= ff_mpeg4_get_video_packet_prefix_length(s))\n                return mb_num;\n        }\n    }\n    return 0;\n}\n\nstatic int mpeg4_decode_sprite_trajectory(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int a     = 2 << s->sprite_warping_accuracy;\n    int rho   = 3  - s->sprite_warping_accuracy;\n    int r     = 16 / a;\n    int alpha = 1;\n    int beta  = 0;\n    int w     = s->width;\n    int h     = s->height;\n    int min_ab, i, w2, h2, w3, h3;\n    int sprite_ref[4][2];\n    int virtual_ref[2][2];\n    int64_t sprite_offset[2][2];\n    int64_t sprite_delta[2][2];\n\n    // only true for rectangle shapes\n    const int vop_ref[4][2] = { { 0, 0 },         { s->width, 0 },\n                                { 0, s->height }, { s->width, s->height } };\n    int d[4][2]             = { { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } };\n\n    if (w <= 0 || h <= 0)\n        return AVERROR_INVALIDDATA;\n\n    /* the decoder was not properly initialized and we cannot continue */\n    if (sprite_trajectory.table == NULL)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < ctx->num_sprite_warping_points; i++) {\n        int length;\n        int x = 0, y = 0;\n\n        length = get_vlc2(gb, sprite_trajectory.table, SPRITE_TRAJ_VLC_BITS, 3);\n        if (length > 0)\n            x = get_xbits(gb, length);\n\n        if (!(ctx->divx_version == 500 && ctx->divx_build == 413))\n            check_marker(s->avctx, gb, \"before sprite_trajectory\");\n\n        length = get_vlc2(gb, sprite_trajectory.table, SPRITE_TRAJ_VLC_BITS, 3);\n        if (length > 0)\n            y = get_xbits(gb, length);\n\n        check_marker(s->avctx, gb, \"after sprite_trajectory\");\n        ctx->sprite_traj[i][0] = d[i][0] = x;\n        ctx->sprite_traj[i][1] = d[i][1] = y;\n    }\n    for (; i < 4; i++)\n        ctx->sprite_traj[i][0] = ctx->sprite_traj[i][1] = 0;\n\n    while ((1 << alpha) < w)\n        alpha++;\n    while ((1 << beta) < h)\n        beta++;  /* typo in the MPEG-4 std for the definition of w' and h' */\n    w2 = 1 << alpha;\n    h2 = 1 << beta;\n\n    // Note, the 4th point isn't used for GMC\n    if (ctx->divx_version == 500 && ctx->divx_build == 413) {\n        sprite_ref[0][0] = a * vop_ref[0][0] + d[0][0];\n        sprite_ref[0][1] = a * vop_ref[0][1] + d[0][1];\n        sprite_ref[1][0] = a * vop_ref[1][0] + d[0][0] + d[1][0];\n        sprite_ref[1][1] = a * vop_ref[1][1] + d[0][1] + d[1][1];\n        sprite_ref[2][0] = a * vop_ref[2][0] + d[0][0] + d[2][0];\n        sprite_ref[2][1] = a * vop_ref[2][1] + d[0][1] + d[2][1];\n    } else {\n        sprite_ref[0][0] = (a >> 1) * (2 * vop_ref[0][0] + d[0][0]);\n        sprite_ref[0][1] = (a >> 1) * (2 * vop_ref[0][1] + d[0][1]);\n        sprite_ref[1][0] = (a >> 1) * (2 * vop_ref[1][0] + d[0][0] + d[1][0]);\n        sprite_ref[1][1] = (a >> 1) * (2 * vop_ref[1][1] + d[0][1] + d[1][1]);\n        sprite_ref[2][0] = (a >> 1) * (2 * vop_ref[2][0] + d[0][0] + d[2][0]);\n        sprite_ref[2][1] = (a >> 1) * (2 * vop_ref[2][1] + d[0][1] + d[2][1]);\n    }\n    /* sprite_ref[3][0] = (a >> 1) * (2 * vop_ref[3][0] + d[0][0] + d[1][0] + d[2][0] + d[3][0]);\n     * sprite_ref[3][1] = (a >> 1) * (2 * vop_ref[3][1] + d[0][1] + d[1][1] + d[2][1] + d[3][1]); */\n\n    /* This is mostly identical to the MPEG-4 std (and is totally unreadable\n     * because of that...). Perhaps it should be reordered to be more readable.\n     * The idea behind this virtual_ref mess is to be able to use shifts later\n     * per pixel instead of divides so the distance between points is converted\n     * from w&h based to w2&h2 based which are of the 2^x form. */\n    virtual_ref[0][0] = 16 * (vop_ref[0][0] + w2) +\n                         ROUNDED_DIV(((w - w2) *\n                                           (r * sprite_ref[0][0] - 16LL * vop_ref[0][0]) +\n                                      w2 * (r * sprite_ref[1][0] - 16LL * vop_ref[1][0])), w);\n    virtual_ref[0][1] = 16 * vop_ref[0][1] +\n                        ROUNDED_DIV(((w - w2) *\n                                          (r * sprite_ref[0][1] - 16LL * vop_ref[0][1]) +\n                                     w2 * (r * sprite_ref[1][1] - 16LL * vop_ref[1][1])), w);\n    virtual_ref[1][0] = 16 * vop_ref[0][0] +\n                        ROUNDED_DIV(((h - h2) * (r * sprite_ref[0][0] - 16LL * vop_ref[0][0]) +\n                                           h2 * (r * sprite_ref[2][0] - 16LL * vop_ref[2][0])), h);\n    virtual_ref[1][1] = 16 * (vop_ref[0][1] + h2) +\n                        ROUNDED_DIV(((h - h2) * (r * sprite_ref[0][1] - 16LL * vop_ref[0][1]) +\n                                           h2 * (r * sprite_ref[2][1] - 16LL * vop_ref[2][1])), h);\n\n    switch (ctx->num_sprite_warping_points) {\n    case 0:\n        sprite_offset[0][0]    =\n        sprite_offset[0][1]    =\n        sprite_offset[1][0]    =\n        sprite_offset[1][1]    = 0;\n        sprite_delta[0][0]     = a;\n        sprite_delta[0][1]     =\n        sprite_delta[1][0]     = 0;\n        sprite_delta[1][1]     = a;\n        ctx->sprite_shift[0]   =\n        ctx->sprite_shift[1]   = 0;\n        break;\n    case 1:     // GMC only\n        sprite_offset[0][0]    = sprite_ref[0][0] - a * vop_ref[0][0];\n        sprite_offset[0][1]    = sprite_ref[0][1] - a * vop_ref[0][1];\n        sprite_offset[1][0]    = ((sprite_ref[0][0] >> 1) | (sprite_ref[0][0] & 1)) -\n                                 a * (vop_ref[0][0] / 2);\n        sprite_offset[1][1]    = ((sprite_ref[0][1] >> 1) | (sprite_ref[0][1] & 1)) -\n                                 a * (vop_ref[0][1] / 2);\n        sprite_delta[0][0]     = a;\n        sprite_delta[0][1]     =\n        sprite_delta[1][0]     = 0;\n        sprite_delta[1][1]     = a;\n        ctx->sprite_shift[0]   =\n        ctx->sprite_shift[1]   = 0;\n        break;\n    case 2:\n        sprite_offset[0][0]    = ((int64_t)      sprite_ref[0][0] * (1 << alpha + rho)) +\n                                 ((int64_t) -r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                 ((int64_t)        -vop_ref[0][0]) +\n                                 ((int64_t)  r * sprite_ref[0][1] - virtual_ref[0][1]) *\n                                 ((int64_t)        -vop_ref[0][1]) + (1 << (alpha + rho - 1));\n        sprite_offset[0][1]    = ((int64_t)      sprite_ref[0][1] * (1 << alpha + rho)) +\n                                 ((int64_t) -r * sprite_ref[0][1] + virtual_ref[0][1]) *\n                                 ((int64_t)        -vop_ref[0][0]) +\n                                 ((int64_t) -r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                 ((int64_t)        -vop_ref[0][1]) + (1 << (alpha + rho - 1));\n        sprite_offset[1][0]    = (((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                  ((int64_t)-2 *    vop_ref[0][0] + 1) +\n                                  ((int64_t) r * sprite_ref[0][1] - virtual_ref[0][1]) *\n                                  ((int64_t)-2 *    vop_ref[0][1] + 1) + 2 * w2 * r *\n                                   (int64_t)     sprite_ref[0][0] - 16 * w2 + (1 << (alpha + rho + 1)));\n        sprite_offset[1][1]    = (((int64_t)-r * sprite_ref[0][1] + virtual_ref[0][1]) *\n                                  ((int64_t)-2 *    vop_ref[0][0] + 1) +\n                                  ((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) *\n                                  ((int64_t)-2 *    vop_ref[0][1] + 1) + 2 * w2 * r *\n                                  (int64_t)      sprite_ref[0][1] - 16 * w2 + (1 << (alpha + rho + 1)));\n        sprite_delta[0][0] = (-r * sprite_ref[0][0] + virtual_ref[0][0]);\n        sprite_delta[0][1] = (+r * sprite_ref[0][1] - virtual_ref[0][1]);\n        sprite_delta[1][0] = (-r * sprite_ref[0][1] + virtual_ref[0][1]);\n        sprite_delta[1][1] = (-r * sprite_ref[0][0] + virtual_ref[0][0]);\n\n        ctx->sprite_shift[0]  = alpha + rho;\n        ctx->sprite_shift[1]  = alpha + rho + 2;\n        break;\n    case 3:\n        min_ab = FFMIN(alpha, beta);\n        w3     = w2 >> min_ab;\n        h3     = h2 >> min_ab;\n        sprite_offset[0][0]    = ((int64_t)sprite_ref[0][0] * (1 << (alpha + beta + rho - min_ab))) +\n                                 ((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) * h3 * (-vop_ref[0][0]) +\n                                 ((int64_t)-r * sprite_ref[0][0] + virtual_ref[1][0]) * w3 * (-vop_ref[0][1]) +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab - 1));\n        sprite_offset[0][1]    = ((int64_t)sprite_ref[0][1] * (1 << (alpha + beta + rho - min_ab))) +\n                                 ((int64_t)-r * sprite_ref[0][1] + virtual_ref[0][1]) * h3 * (-vop_ref[0][0]) +\n                                 ((int64_t)-r * sprite_ref[0][1] + virtual_ref[1][1]) * w3 * (-vop_ref[0][1]) +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab - 1));\n        sprite_offset[1][0]    = ((int64_t)-r * sprite_ref[0][0] + virtual_ref[0][0]) * h3 * (-2 * vop_ref[0][0] + 1) +\n                                 ((int64_t)-r * sprite_ref[0][0] + virtual_ref[1][0]) * w3 * (-2 * vop_ref[0][1] + 1) +\n                                  (int64_t)2 * w2 * h3 * r * sprite_ref[0][0] - 16 * w2 * h3 +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab + 1));\n        sprite_offset[1][1]    = ((int64_t)-r * sprite_ref[0][1] + virtual_ref[0][1]) * h3 * (-2 * vop_ref[0][0] + 1) +\n                                 ((int64_t)-r * sprite_ref[0][1] + virtual_ref[1][1]) * w3 * (-2 * vop_ref[0][1] + 1) +\n                                  (int64_t)2 * w2 * h3 * r * sprite_ref[0][1] - 16 * w2 * h3 +\n                                 ((int64_t)1 << (alpha + beta + rho - min_ab + 1));\n        sprite_delta[0][0] = (-r * (int64_t)sprite_ref[0][0] + virtual_ref[0][0]) * h3;\n        sprite_delta[0][1] = (-r * (int64_t)sprite_ref[0][0] + virtual_ref[1][0]) * w3;\n        sprite_delta[1][0] = (-r * (int64_t)sprite_ref[0][1] + virtual_ref[0][1]) * h3;\n        sprite_delta[1][1] = (-r * (int64_t)sprite_ref[0][1] + virtual_ref[1][1]) * w3;\n\n        ctx->sprite_shift[0]  = alpha + beta + rho - min_ab;\n        ctx->sprite_shift[1]  = alpha + beta + rho - min_ab + 2;\n        break;\n    }\n    /* try to simplify the situation */\n    if (sprite_delta[0][0] == a << ctx->sprite_shift[0] &&\n        sprite_delta[0][1] == 0 &&\n        sprite_delta[1][0] == 0 &&\n        sprite_delta[1][1] == a << ctx->sprite_shift[0]) {\n        sprite_offset[0][0] >>= ctx->sprite_shift[0];\n        sprite_offset[0][1] >>= ctx->sprite_shift[0];\n        sprite_offset[1][0] >>= ctx->sprite_shift[1];\n        sprite_offset[1][1] >>= ctx->sprite_shift[1];\n        sprite_delta[0][0] = a;\n        sprite_delta[0][1] = 0;\n        sprite_delta[1][0] = 0;\n        sprite_delta[1][1] = a;\n        ctx->sprite_shift[0] = 0;\n        ctx->sprite_shift[1] = 0;\n        s->real_sprite_warping_points = 1;\n    } else {\n        int shift_y = 16 - ctx->sprite_shift[0];\n        int shift_c = 16 - ctx->sprite_shift[1];\n\n        for (i = 0; i < 2; i++) {\n            if (shift_c < 0 || shift_y < 0 ||\n                FFABS(  sprite_offset[0][i]) >= INT_MAX >> shift_y  ||\n                FFABS(  sprite_offset[1][i]) >= INT_MAX >> shift_c  ||\n                FFABS(   sprite_delta[0][i]) >= INT_MAX >> shift_y  ||\n                FFABS(   sprite_delta[1][i]) >= INT_MAX >> shift_y\n            ) {\n                avpriv_request_sample(s->avctx, \"Too large sprite shift, delta or offset\");\n                goto overflow;\n            }\n        }\n\n        for (i = 0; i < 2; i++) {\n            sprite_offset[0][i]    *= 1 << shift_y;\n            sprite_offset[1][i]    *= 1 << shift_c;\n            sprite_delta[0][i]     *= 1 << shift_y;\n            sprite_delta[1][i]     *= 1 << shift_y;\n            ctx->sprite_shift[i]     = 16;\n\n        }\n        for (i = 0; i < 2; i++) {\n            int64_t sd[2] = {\n                sprite_delta[i][0] - a * (1LL<<16),\n                sprite_delta[i][1] - a * (1LL<<16)\n            };\n\n            if (llabs(sprite_offset[0][i] + sprite_delta[i][0] * (w+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sprite_delta[i][1] * (h+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sprite_delta[i][0] * (w+16LL) + sprite_delta[i][1] * (h+16LL)) >= INT_MAX ||\n                llabs(sprite_delta[i][0] * (w+16LL)) >= INT_MAX ||\n                llabs(sprite_delta[i][1] * (w+16LL)) >= INT_MAX ||\n                llabs(sd[0]) >= INT_MAX ||\n                llabs(sd[1]) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sd[0] * (w+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sd[1] * (h+16LL)) >= INT_MAX ||\n                llabs(sprite_offset[0][i] + sd[0] * (w+16LL) + sd[1] * (h+16LL)) >= INT_MAX\n            ) {\n                avpriv_request_sample(s->avctx, \"Overflow on sprite points\");\n                goto overflow;\n            }\n        }\n        s->real_sprite_warping_points = ctx->num_sprite_warping_points;\n    }\n\n    for (i = 0; i < 4; i++) {\n        s->sprite_offset[i&1][i>>1] = sprite_offset[i&1][i>>1];\n        s->sprite_delta [i&1][i>>1] = sprite_delta [i&1][i>>1];\n    }\n\n    return 0;\noverflow:\n    memset(s->sprite_offset, 0, sizeof(s->sprite_offset));\n    memset(s->sprite_delta, 0, sizeof(s->sprite_delta));\n    return AVERROR_PATCHWELCOME;\n}\n\nstatic int decode_new_pred(Mpeg4DecContext *ctx, GetBitContext *gb) {\n    MpegEncContext *s = &ctx->m;\n    int len = FFMIN(ctx->time_increment_bits + 3, 15);\n\n    get_bits(gb, len);\n    if (get_bits1(gb))\n        get_bits(gb, len);\n    check_marker(s->avctx, gb, \"after new_pred\");\n\n    return 0;\n}\n\n/**\n * Decode the next video packet.\n * @return <0 if something went wrong\n */\nint ff_mpeg4_decode_video_packet_header(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n\n    int mb_num_bits      = av_log2(s->mb_num - 1) + 1;\n    int header_extension = 0, mb_num, len;\n\n    /* is there enough space left for a video packet + header */\n    if (get_bits_count(&s->gb) > s->gb.size_in_bits - 20)\n        return AVERROR_INVALIDDATA;\n\n    for (len = 0; len < 32; len++)\n        if (get_bits1(&s->gb))\n            break;\n\n    if (len != ff_mpeg4_get_video_packet_prefix_length(s)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"marker does not match f_code\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->shape != RECT_SHAPE) {\n        header_extension = get_bits1(&s->gb);\n        // FIXME more stuff here\n    }\n\n    mb_num = get_bits(&s->gb, mb_num_bits);\n    if (mb_num >= s->mb_num || !mb_num) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"illegal mb_num in video packet (%d %d) \\n\", mb_num, s->mb_num);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->mb_x = mb_num % s->mb_width;\n    s->mb_y = mb_num / s->mb_width;\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        int qscale = get_bits(&s->gb, s->quant_precision);\n        if (qscale)\n            s->chroma_qscale = s->qscale = qscale;\n    }\n\n    if (ctx->shape == RECT_SHAPE)\n        header_extension = get_bits1(&s->gb);\n\n    if (header_extension) {\n        int time_incr = 0;\n\n        while (get_bits1(&s->gb) != 0)\n            time_incr++;\n\n        check_marker(s->avctx, &s->gb, \"before time_increment in video packed header\");\n        skip_bits(&s->gb, ctx->time_increment_bits);      /* time_increment */\n        check_marker(s->avctx, &s->gb, \"before vop_coding_type in video packed header\");\n\n        skip_bits(&s->gb, 2); /* vop coding type */\n        // FIXME not rect stuff here\n\n        if (ctx->shape != BIN_ONLY_SHAPE) {\n            skip_bits(&s->gb, 3); /* intra dc vlc threshold */\n            // FIXME don't just ignore everything\n            if (s->pict_type == AV_PICTURE_TYPE_S &&\n                ctx->vol_sprite_usage == GMC_SPRITE) {\n                if (mpeg4_decode_sprite_trajectory(ctx, &s->gb) < 0)\n                    return AVERROR_INVALIDDATA;\n                av_log(s->avctx, AV_LOG_ERROR, \"untested\\n\");\n            }\n\n            // FIXME reduced res stuff here\n\n            if (s->pict_type != AV_PICTURE_TYPE_I) {\n                int f_code = get_bits(&s->gb, 3);       /* fcode_for */\n                if (f_code == 0)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Error, video packet header damaged (f_code=0)\\n\");\n            }\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n                int b_code = get_bits(&s->gb, 3);\n                if (b_code == 0)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"Error, video packet header damaged (b_code=0)\\n\");\n            }\n        }\n    }\n    if (ctx->new_pred)\n        decode_new_pred(ctx, &s->gb);\n\n    return 0;\n}\n\nstatic void reset_studio_dc_predictors(MpegEncContext *s)\n{\n    /* Reset DC Predictors */\n    s->last_dc[0] =\n    s->last_dc[1] =\n    s->last_dc[2] = 1 << (s->avctx->bits_per_raw_sample + s->dct_precision + s->intra_dc_precision - 1);\n}\n\n/**\n * Decode the next video packet.\n * @return <0 if something went wrong\n */\nint ff_mpeg4_decode_studio_slice_header(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    GetBitContext *gb = &s->gb;\n    unsigned vlc_len;\n    uint16_t mb_num;\n\n    if (get_bits_left(gb) >= 32 && get_bits_long(gb, 32) == SLICE_START_CODE) {\n        vlc_len = av_log2(s->mb_width * s->mb_height) + 1;\n        mb_num = get_bits(gb, vlc_len);\n\n        if (mb_num >= s->mb_num)\n            return AVERROR_INVALIDDATA;\n\n        s->mb_x = mb_num % s->mb_width;\n        s->mb_y = mb_num / s->mb_width;\n\n        if (ctx->shape != BIN_ONLY_SHAPE)\n            s->qscale = mpeg_get_qscale(s);\n\n        if (get_bits1(gb)) {  /* slice_extension_flag */\n            skip_bits1(gb);   /* intra_slice */\n            skip_bits1(gb);   /* slice_VOP_id_enable */\n            skip_bits(gb, 6); /* slice_VOP_id */\n            while (get_bits1(gb)) /* extra_bit_slice */\n                skip_bits(gb, 8); /* extra_information_slice */\n        }\n\n        reset_studio_dc_predictors(s);\n    }\n    else {\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\n/**\n * Get the average motion vector for a GMC MB.\n * @param n either 0 for the x component or 1 for y\n * @return the average MV for a GMC MB\n */\nstatic inline int get_amv(Mpeg4DecContext *ctx, int n)\n{\n    MpegEncContext *s = &ctx->m;\n    int x, y, mb_v, sum, dx, dy, shift;\n    int len     = 1 << (s->f_code + 4);\n    const int a = s->sprite_warping_accuracy;\n\n    if (s->workaround_bugs & FF_BUG_AMV)\n        len >>= s->quarter_sample;\n\n    if (s->real_sprite_warping_points == 1) {\n        if (ctx->divx_version == 500 && ctx->divx_build == 413)\n            sum = s->sprite_offset[0][n] / (1 << (a - s->quarter_sample));\n        else\n            sum = RSHIFT(s->sprite_offset[0][n] * (1 << s->quarter_sample), a);\n    } else {\n        dx    = s->sprite_delta[n][0];\n        dy    = s->sprite_delta[n][1];\n        shift = ctx->sprite_shift[0];\n        if (n)\n            dy -= 1 << (shift + a + 1);\n        else\n            dx -= 1 << (shift + a + 1);\n        mb_v = s->sprite_offset[0][n] + dx * s->mb_x * 16 + dy * s->mb_y * 16;\n\n        sum = 0;\n        for (y = 0; y < 16; y++) {\n            int v;\n\n            v = mb_v + dy * y;\n            // FIXME optimize\n            for (x = 0; x < 16; x++) {\n                sum += v >> shift;\n                v   += dx;\n            }\n        }\n        sum = RSHIFT(sum, a + 8 - s->quarter_sample);\n    }\n\n    if (sum < -len)\n        sum = -len;\n    else if (sum >= len)\n        sum = len - 1;\n\n    return sum;\n}\n\n/**\n * Decode the dc value.\n * @param n block index (0-3 are luma, 4-5 are chroma)\n * @param dir_ptr the prediction direction will be stored here\n * @return the quantized dc\n */\nstatic inline int mpeg4_decode_dc(MpegEncContext *s, int n, int *dir_ptr)\n{\n    int level, code;\n\n    if (n < 4)\n        code = get_vlc2(&s->gb, dc_lum.table, DC_VLC_BITS, 1);\n    else\n        code = get_vlc2(&s->gb, dc_chrom.table, DC_VLC_BITS, 1);\n\n    if (code < 0 || code > 9 /* && s->nbit < 9 */) {\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal dc vlc\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (code == 0) {\n        level = 0;\n    } else {\n        if (IS_3IV1) {\n            if (code == 1)\n                level = 2 * get_bits1(&s->gb) - 1;\n            else {\n                if (get_bits1(&s->gb))\n                    level = get_bits(&s->gb, code - 1) + (1 << (code - 1));\n                else\n                    level = -get_bits(&s->gb, code - 1) - (1 << (code - 1));\n            }\n        } else {\n            level = get_xbits(&s->gb, code);\n        }\n\n        if (code > 8) {\n            if (get_bits1(&s->gb) == 0) { /* marker */\n                if (s->avctx->err_recognition & (AV_EF_BITSTREAM|AV_EF_COMPLIANT)) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"dc marker bit missing\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        }\n    }\n\n    return ff_mpeg4_pred_dc(s, n, level, dir_ptr, 0);\n}\n\n/**\n * Decode first partition.\n * @return number of MBs decoded or <0 if an error occurred\n */\nstatic int mpeg4_decode_partition_a(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    int mb_num = 0;\n    static const int8_t quant_tab[4] = { -1, -2, 1, 2 };\n\n    /* decode first partition */\n    s->first_slice_line = 1;\n    for (; s->mb_y < s->mb_height; s->mb_y++) {\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride;\n            int cbpc;\n            int dir = 0;\n\n            mb_num++;\n            ff_update_block_index(s);\n            if (s->mb_x == s->resync_mb_x && s->mb_y == s->resync_mb_y + 1)\n                s->first_slice_line = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_I) {\n                int i;\n\n                do {\n                    if (show_bits_long(&s->gb, 19) == DC_MARKER)\n                        return mb_num - 1;\n\n                    cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n                    if (cbpc < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"mcbpc corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return AVERROR_INVALIDDATA;\n                    }\n                } while (cbpc == 8);\n\n                s->cbp_table[xy]               = cbpc & 3;\n                s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n                s->mb_intra                    = 1;\n\n                if (cbpc & 4)\n                    ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n\n                s->current_picture.qscale_table[xy] = s->qscale;\n\n                s->mbintra_table[xy] = 1;\n                for (i = 0; i < 6; i++) {\n                    int dc_pred_dir;\n                    int dc = mpeg4_decode_dc(s, i, &dc_pred_dir);\n                    if (dc < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"DC corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return dc;\n                    }\n                    dir <<= 1;\n                    if (dc_pred_dir)\n                        dir |= 1;\n                }\n                s->pred_dir_table[xy] = dir;\n            } else { /* P/S_TYPE */\n                int mx, my, pred_x, pred_y, bits;\n                int16_t *const mot_val = s->current_picture.motion_val[0][s->block_index[0]];\n                const int stride       = s->b8_stride * 2;\n\ntry_again:\n                bits = show_bits(&s->gb, 17);\n                if (bits == MOTION_MARKER)\n                    return mb_num - 1;\n\n                skip_bits1(&s->gb);\n                if (bits & 0x10000) {\n                    /* skip mb */\n                    if (s->pict_type == AV_PICTURE_TYPE_S &&\n                        ctx->vol_sprite_usage == GMC_SPRITE) {\n                        s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                         MB_TYPE_16x16 |\n                                                         MB_TYPE_GMC   |\n                                                         MB_TYPE_L0;\n                        mx = get_amv(ctx, 0);\n                        my = get_amv(ctx, 1);\n                    } else {\n                        s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                         MB_TYPE_16x16 |\n                                                         MB_TYPE_L0;\n                        mx = my = 0;\n                    }\n                    mot_val[0]          =\n                    mot_val[2]          =\n                    mot_val[0 + stride] =\n                    mot_val[2 + stride] = mx;\n                    mot_val[1]          =\n                    mot_val[3]          =\n                    mot_val[1 + stride] =\n                    mot_val[3 + stride] = my;\n\n                    if (s->mbintra_table[xy])\n                        ff_clean_intra_table_entries(s);\n                    continue;\n                }\n\n                cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n                if (cbpc < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"mcbpc corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                    return AVERROR_INVALIDDATA;\n                }\n                if (cbpc == 20)\n                    goto try_again;\n\n                s->cbp_table[xy] = cbpc & (8 + 3);  // 8 is dquant\n\n                s->mb_intra = ((cbpc & 4) != 0);\n\n                if (s->mb_intra) {\n                    s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n                    s->mbintra_table[xy] = 1;\n                    mot_val[0]          =\n                    mot_val[2]          =\n                    mot_val[0 + stride] =\n                    mot_val[2 + stride] = 0;\n                    mot_val[1]          =\n                    mot_val[3]          =\n                    mot_val[1 + stride] =\n                    mot_val[3 + stride] = 0;\n                } else {\n                    if (s->mbintra_table[xy])\n                        ff_clean_intra_table_entries(s);\n\n                    if (s->pict_type == AV_PICTURE_TYPE_S &&\n                        ctx->vol_sprite_usage == GMC_SPRITE &&\n                        (cbpc & 16) == 0)\n                        s->mcsel = get_bits1(&s->gb);\n                    else\n                        s->mcsel = 0;\n\n                    if ((cbpc & 16) == 0) {\n                        /* 16x16 motion prediction */\n\n                        ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                        if (!s->mcsel) {\n                            mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n                            if (mx >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n\n                            my = ff_h263_decode_motion(s, pred_y, s->f_code);\n                            if (my >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n                            s->current_picture.mb_type[xy] = MB_TYPE_16x16 |\n                                                             MB_TYPE_L0;\n                        } else {\n                            mx = get_amv(ctx, 0);\n                            my = get_amv(ctx, 1);\n                            s->current_picture.mb_type[xy] = MB_TYPE_16x16 |\n                                                             MB_TYPE_GMC   |\n                                                             MB_TYPE_L0;\n                        }\n\n                        mot_val[0]          =\n                        mot_val[2]          =\n                        mot_val[0 + stride] =\n                        mot_val[2 + stride] = mx;\n                        mot_val[1]          =\n                        mot_val[3]          =\n                        mot_val[1 + stride] =\n                        mot_val[3 + stride] = my;\n                    } else {\n                        int i;\n                        s->current_picture.mb_type[xy] = MB_TYPE_8x8 |\n                                                         MB_TYPE_L0;\n                        for (i = 0; i < 4; i++) {\n                            int16_t *mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                            mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n                            if (mx >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n\n                            my = ff_h263_decode_motion(s, pred_y, s->f_code);\n                            if (my >= 0xffff)\n                                return AVERROR_INVALIDDATA;\n                            mot_val[0] = mx;\n                            mot_val[1] = my;\n                        }\n                    }\n                }\n            }\n        }\n        s->mb_x = 0;\n    }\n\n    return mb_num;\n}\n\n/**\n * decode second partition.\n * @return <0 if an error occurred\n */\nstatic int mpeg4_decode_partition_b(MpegEncContext *s, int mb_count)\n{\n    int mb_num = 0;\n    static const int8_t quant_tab[4] = { -1, -2, 1, 2 };\n\n    s->mb_x = s->resync_mb_x;\n    s->first_slice_line = 1;\n    for (s->mb_y = s->resync_mb_y; mb_num < mb_count; s->mb_y++) {\n        ff_init_block_index(s);\n        for (; mb_num < mb_count && s->mb_x < s->mb_width; s->mb_x++) {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride;\n\n            mb_num++;\n            ff_update_block_index(s);\n            if (s->mb_x == s->resync_mb_x && s->mb_y == s->resync_mb_y + 1)\n                s->first_slice_line = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_I) {\n                int ac_pred = get_bits1(&s->gb);\n                int cbpy    = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n                if (cbpy < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"cbpy corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                s->cbp_table[xy]               |= cbpy << 2;\n                s->current_picture.mb_type[xy] |= ac_pred * MB_TYPE_ACPRED;\n            } else { /* P || S_TYPE */\n                if (IS_INTRA(s->current_picture.mb_type[xy])) {\n                    int i;\n                    int dir     = 0;\n                    int ac_pred = get_bits1(&s->gb);\n                    int cbpy    = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n\n                    if (cbpy < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"I cbpy corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (s->cbp_table[xy] & 8)\n                        ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n                    s->current_picture.qscale_table[xy] = s->qscale;\n\n                    for (i = 0; i < 6; i++) {\n                        int dc_pred_dir;\n                        int dc = mpeg4_decode_dc(s, i, &dc_pred_dir);\n                        if (dc < 0) {\n                            av_log(s->avctx, AV_LOG_ERROR,\n                                   \"DC corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                            return dc;\n                        }\n                        dir <<= 1;\n                        if (dc_pred_dir)\n                            dir |= 1;\n                    }\n                    s->cbp_table[xy]               &= 3;  // remove dquant\n                    s->cbp_table[xy]               |= cbpy << 2;\n                    s->current_picture.mb_type[xy] |= ac_pred * MB_TYPE_ACPRED;\n                    s->pred_dir_table[xy]           = dir;\n                } else if (IS_SKIP(s->current_picture.mb_type[xy])) {\n                    s->current_picture.qscale_table[xy] = s->qscale;\n                    s->cbp_table[xy]                    = 0;\n                } else {\n                    int cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n\n                    if (cbpy < 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"P cbpy corrupted at %d %d\\n\", s->mb_x, s->mb_y);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    if (s->cbp_table[xy] & 8)\n                        ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n                    s->current_picture.qscale_table[xy] = s->qscale;\n\n                    s->cbp_table[xy] &= 3;  // remove dquant\n                    s->cbp_table[xy] |= (cbpy ^ 0xf) << 2;\n                }\n            }\n        }\n        if (mb_num >= mb_count)\n            return 0;\n        s->mb_x = 0;\n    }\n    return 0;\n}\n\n/**\n * Decode the first and second partition.\n * @return <0 if error (and sets error type in the error_status_table)\n */\nint ff_mpeg4_decode_partitions(Mpeg4DecContext *ctx)\n{\n    MpegEncContext *s = &ctx->m;\n    int mb_num;\n    int ret;\n    const int part_a_error = s->pict_type == AV_PICTURE_TYPE_I ? (ER_DC_ERROR | ER_MV_ERROR) : ER_MV_ERROR;\n    const int part_a_end   = s->pict_type == AV_PICTURE_TYPE_I ? (ER_DC_END   | ER_MV_END)   : ER_MV_END;\n\n    mb_num = mpeg4_decode_partition_a(ctx);\n    if (mb_num <= 0) {\n        ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                        s->mb_x, s->mb_y, part_a_error);\n        return mb_num ? mb_num : AVERROR_INVALIDDATA;\n    }\n\n    if (s->resync_mb_x + s->resync_mb_y * s->mb_width + mb_num > s->mb_num) {\n        av_log(s->avctx, AV_LOG_ERROR, \"slice below monitor ...\\n\");\n        ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                        s->mb_x, s->mb_y, part_a_error);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->mb_num_left = mb_num;\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        while (show_bits(&s->gb, 9) == 1)\n            skip_bits(&s->gb, 9);\n        if (get_bits_long(&s->gb, 19) != DC_MARKER) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"marker missing after first I partition at %d %d\\n\",\n                   s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        while (show_bits(&s->gb, 10) == 1)\n            skip_bits(&s->gb, 10);\n        if (get_bits(&s->gb, 17) != MOTION_MARKER) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"marker missing after first P partition at %d %d\\n\",\n                   s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                    s->mb_x - 1, s->mb_y, part_a_end);\n\n    ret = mpeg4_decode_partition_b(s, mb_num);\n    if (ret < 0) {\n        if (s->pict_type == AV_PICTURE_TYPE_P)\n            ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                            s->mb_x, s->mb_y, ER_DC_ERROR);\n        return ret;\n    } else {\n        if (s->pict_type == AV_PICTURE_TYPE_P)\n            ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                            s->mb_x - 1, s->mb_y, ER_DC_END);\n    }\n\n    return 0;\n}\n\n/**\n * Decode a block.\n * @return <0 if an error occurred\n */\nstatic inline int mpeg4_decode_block(Mpeg4DecContext *ctx, int16_t *block,\n                                     int n, int coded, int intra, int rvlc)\n{\n    MpegEncContext *s = &ctx->m;\n    int level, i, last, run, qmul, qadd;\n    int av_uninit(dc_pred_dir);\n    RLTable *rl;\n    RL_VLC_ELEM *rl_vlc;\n    const uint8_t *scan_table;\n\n    // Note intra & rvlc should be optimized away if this is inlined\n\n    if (intra) {\n        if (ctx->use_intra_dc_vlc) {\n            /* DC coef */\n            if (s->partitioned_frame) {\n                level = s->dc_val[0][s->block_index[n]];\n                if (n < 4)\n                    level = FASTDIV((level + (s->y_dc_scale >> 1)), s->y_dc_scale);\n                else\n                    level = FASTDIV((level + (s->c_dc_scale >> 1)), s->c_dc_scale);\n                dc_pred_dir = (s->pred_dir_table[s->mb_x + s->mb_y * s->mb_stride] << n) & 32;\n            } else {\n                level = mpeg4_decode_dc(s, n, &dc_pred_dir);\n                if (level < 0)\n                    return level;\n            }\n            block[0] = level;\n            i        = 0;\n        } else {\n            i = -1;\n            ff_mpeg4_pred_dc(s, n, 0, &dc_pred_dir, 0);\n        }\n        if (!coded)\n            goto not_coded;\n\n        if (rvlc) {\n            rl     = &ff_rvlc_rl_intra;\n            rl_vlc = ff_rvlc_rl_intra.rl_vlc[0];\n        } else {\n            rl     = &ff_mpeg4_rl_intra;\n            rl_vlc = ff_mpeg4_rl_intra.rl_vlc[0];\n        }\n        if (s->ac_pred) {\n            if (dc_pred_dir == 0)\n                scan_table = s->intra_v_scantable.permutated;  /* left */\n            else\n                scan_table = s->intra_h_scantable.permutated;  /* top */\n        } else {\n            scan_table = s->intra_scantable.permutated;\n        }\n        qmul = 1;\n        qadd = 0;\n    } else {\n        i = -1;\n        if (!coded) {\n            s->block_last_index[n] = i;\n            return 0;\n        }\n        if (rvlc)\n            rl = &ff_rvlc_rl_inter;\n        else\n            rl = &ff_h263_rl_inter;\n\n        scan_table = s->intra_scantable.permutated;\n\n        if (s->mpeg_quant) {\n            qmul = 1;\n            qadd = 0;\n            if (rvlc)\n                rl_vlc = ff_rvlc_rl_inter.rl_vlc[0];\n            else\n                rl_vlc = ff_h263_rl_inter.rl_vlc[0];\n        } else {\n            qmul = s->qscale << 1;\n            qadd = (s->qscale - 1) | 1;\n            if (rvlc)\n                rl_vlc = ff_rvlc_rl_inter.rl_vlc[s->qscale];\n            else\n                rl_vlc = ff_h263_rl_inter.rl_vlc[s->qscale];\n        }\n    }\n    {\n        OPEN_READER(re, &s->gb);\n        for (;;) {\n            UPDATE_CACHE(re, &s->gb);\n            GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2, 0);\n            if (level == 0) {\n                /* escape */\n                if (rvlc) {\n                    if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"1. marker bit missing in rvlc esc\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    SKIP_CACHE(re, &s->gb, 1);\n\n                    last = SHOW_UBITS(re, &s->gb, 1);\n                    SKIP_CACHE(re, &s->gb, 1);\n                    run = SHOW_UBITS(re, &s->gb, 6);\n                    SKIP_COUNTER(re, &s->gb, 1 + 1 + 6);\n                    UPDATE_CACHE(re, &s->gb);\n\n                    if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \"2. marker bit missing in rvlc esc\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    SKIP_CACHE(re, &s->gb, 1);\n\n                    level = SHOW_UBITS(re, &s->gb, 11);\n                    SKIP_CACHE(re, &s->gb, 11);\n\n                    if (SHOW_UBITS(re, &s->gb, 5) != 0x10) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"reverse esc missing\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    SKIP_CACHE(re, &s->gb, 5);\n\n                    level = level * qmul + qadd;\n                    level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                    SKIP_COUNTER(re, &s->gb, 1 + 11 + 5 + 1);\n\n                    i += run + 1;\n                    if (last)\n                        i += 192;\n                } else {\n                    int cache;\n                    cache = GET_CACHE(re, &s->gb);\n\n                    if (IS_3IV1)\n                        cache ^= 0xC0000000;\n\n                    if (cache & 0x80000000) {\n                        if (cache & 0x40000000) {\n                            /* third escape */\n                            SKIP_CACHE(re, &s->gb, 2);\n                            last = SHOW_UBITS(re, &s->gb, 1);\n                            SKIP_CACHE(re, &s->gb, 1);\n                            run = SHOW_UBITS(re, &s->gb, 6);\n                            SKIP_COUNTER(re, &s->gb, 2 + 1 + 6);\n                            UPDATE_CACHE(re, &s->gb);\n\n                            if (IS_3IV1) {\n                                level = SHOW_SBITS(re, &s->gb, 12);\n                                LAST_SKIP_BITS(re, &s->gb, 12);\n                            } else {\n                                if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                                    av_log(s->avctx, AV_LOG_ERROR,\n                                           \"1. marker bit missing in 3. esc\\n\");\n                                    if (!(s->avctx->err_recognition & AV_EF_IGNORE_ERR))\n                                        return AVERROR_INVALIDDATA;\n                                }\n                                SKIP_CACHE(re, &s->gb, 1);\n\n                                level = SHOW_SBITS(re, &s->gb, 12);\n                                SKIP_CACHE(re, &s->gb, 12);\n\n                                if (SHOW_UBITS(re, &s->gb, 1) == 0) {\n                                    av_log(s->avctx, AV_LOG_ERROR,\n                                           \"2. marker bit missing in 3. esc\\n\");\n                                    if (!(s->avctx->err_recognition & AV_EF_IGNORE_ERR))\n                                        return AVERROR_INVALIDDATA;\n                                }\n\n                                SKIP_COUNTER(re, &s->gb, 1 + 12 + 1);\n                            }\n\n#if 0\n                            if (s->error_recognition >= FF_ER_COMPLIANT) {\n                                const int abs_level= FFABS(level);\n                                if (abs_level<=MAX_LEVEL && run<=MAX_RUN) {\n                                    const int run1= run - rl->max_run[last][abs_level] - 1;\n                                    if (abs_level <= rl->max_level[last][run]) {\n                                        av_log(s->avctx, AV_LOG_ERROR, \"illegal 3. esc, vlc encoding possible\\n\");\n                                        return AVERROR_INVALIDDATA;\n                                    }\n                                    if (s->error_recognition > FF_ER_COMPLIANT) {\n                                        if (abs_level <= rl->max_level[last][run]*2) {\n                                            av_log(s->avctx, AV_LOG_ERROR, \"illegal 3. esc, esc 1 encoding possible\\n\");\n                                            return AVERROR_INVALIDDATA;\n                                        }\n                                        if (run1 >= 0 && abs_level <= rl->max_level[last][run1]) {\n                                            av_log(s->avctx, AV_LOG_ERROR, \"illegal 3. esc, esc 2 encoding possible\\n\");\n                                            return AVERROR_INVALIDDATA;\n                                        }\n                                    }\n                                }\n                            }\n#endif\n                            if (level > 0)\n                                level = level * qmul + qadd;\n                            else\n                                level = level * qmul - qadd;\n\n                            if ((unsigned)(level + 2048) > 4095) {\n                                if (s->avctx->err_recognition & (AV_EF_BITSTREAM|AV_EF_AGGRESSIVE)) {\n                                    if (level > 2560 || level < -2560) {\n                                        av_log(s->avctx, AV_LOG_ERROR,\n                                               \"|level| overflow in 3. esc, qp=%d\\n\",\n                                               s->qscale);\n                                        return AVERROR_INVALIDDATA;\n                                    }\n                                }\n                                level = level < 0 ? -2048 : 2047;\n                            }\n\n                            i += run + 1;\n                            if (last)\n                                i += 192;\n                        } else {\n                            /* second escape */\n                            SKIP_BITS(re, &s->gb, 2);\n                            GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2, 1);\n                            i    += run + rl->max_run[run >> 7][level / qmul] + 1;  // FIXME opt indexing\n                            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                            LAST_SKIP_BITS(re, &s->gb, 1);\n                        }\n                    } else {\n                        /* first escape */\n                        SKIP_BITS(re, &s->gb, 1);\n                        GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2, 1);\n                        i    += run;\n                        level = level + rl->max_level[run >> 7][(run - 1) & 63] * qmul;  // FIXME opt indexing\n                        level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                        LAST_SKIP_BITS(re, &s->gb, 1);\n                    }\n                }\n            } else {\n                i    += run;\n                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n                LAST_SKIP_BITS(re, &s->gb, 1);\n            }\n            ff_tlog(s->avctx, \"dct[%d][%d] = %- 4d end?:%d\\n\", scan_table[i&63]&7, scan_table[i&63] >> 3, level, i>62);\n            if (i > 62) {\n                i -= 192;\n                if (i & (~63)) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"ac-tex damaged at %d %d\\n\", s->mb_x, s->mb_y);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                block[scan_table[i]] = level;\n                break;\n            }\n\n            block[scan_table[i]] = level;\n        }\n        CLOSE_READER(re, &s->gb);\n    }\n\nnot_coded:\n    if (intra) {\n        if (!ctx->use_intra_dc_vlc) {\n            block[0] = ff_mpeg4_pred_dc(s, n, block[0], &dc_pred_dir, 0);\n\n            i -= i >> 31;  // if (i == -1) i = 0;\n        }\n\n        ff_mpeg4_pred_ac(s, block, n, dc_pred_dir);\n        if (s->ac_pred)\n            i = 63;  // FIXME not optimal\n    }\n    s->block_last_index[n] = i;\n    return 0;\n}\n\n/**\n * decode partition C of one MB.\n * @return <0 if an error occurred\n */\nstatic int mpeg4_decode_partitioned_mb(MpegEncContext *s, int16_t block[6][64])\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n    int cbp, mb_type;\n    const int xy = s->mb_x + s->mb_y * s->mb_stride;\n\n    av_assert2(s == (void*)ctx);\n\n    mb_type = s->current_picture.mb_type[xy];\n    cbp     = s->cbp_table[xy];\n\n    ctx->use_intra_dc_vlc = s->qscale < ctx->intra_dc_threshold;\n\n    if (s->current_picture.qscale_table[xy] != s->qscale)\n        ff_set_qscale(s, s->current_picture.qscale_table[xy]);\n\n    if (s->pict_type == AV_PICTURE_TYPE_P ||\n        s->pict_type == AV_PICTURE_TYPE_S) {\n        int i;\n        for (i = 0; i < 4; i++) {\n            s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0];\n            s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1];\n        }\n        s->mb_intra = IS_INTRA(mb_type);\n\n        if (IS_SKIP(mb_type)) {\n            /* skip mb */\n            for (i = 0; i < 6; i++)\n                s->block_last_index[i] = -1;\n            s->mv_dir  = MV_DIR_FORWARD;\n            s->mv_type = MV_TYPE_16X16;\n            if (s->pict_type == AV_PICTURE_TYPE_S\n                && ctx->vol_sprite_usage == GMC_SPRITE) {\n                s->mcsel      = 1;\n                s->mb_skipped = 0;\n            } else {\n                s->mcsel      = 0;\n                s->mb_skipped = 1;\n            }\n        } else if (s->mb_intra) {\n            s->ac_pred = IS_ACPRED(s->current_picture.mb_type[xy]);\n        } else if (!s->mb_intra) {\n            // s->mcsel = 0;  // FIXME do we need to init that?\n\n            s->mv_dir = MV_DIR_FORWARD;\n            if (IS_8X8(mb_type)) {\n                s->mv_type = MV_TYPE_8X8;\n            } else {\n                s->mv_type = MV_TYPE_16X16;\n            }\n        }\n    } else { /* I-Frame */\n        s->mb_intra = 1;\n        s->ac_pred  = IS_ACPRED(s->current_picture.mb_type[xy]);\n    }\n\n    if (!IS_SKIP(mb_type)) {\n        int i;\n        s->bdsp.clear_blocks(s->block[0]);\n        /* decode each block */\n        for (i = 0; i < 6; i++) {\n            if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, s->mb_intra, ctx->rvlc) < 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"texture corrupted at %d %d %d\\n\",\n                       s->mb_x, s->mb_y, s->mb_intra);\n                return AVERROR_INVALIDDATA;\n            }\n            cbp += cbp;\n        }\n    }\n\n    /* per-MB end of slice check */\n    if (--s->mb_num_left <= 0) {\n        if (mpeg4_is_resync(ctx))\n            return SLICE_END;\n        else\n            return SLICE_NOEND;\n    } else {\n        if (mpeg4_is_resync(ctx)) {\n            const int delta = s->mb_x + 1 == s->mb_width ? 2 : 1;\n            if (s->cbp_table[xy + delta])\n                return SLICE_END;\n        }\n        return SLICE_OK;\n    }\n}\n\nstatic int mpeg4_decode_mb(MpegEncContext *s, int16_t block[6][64])\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;\n    int16_t *mot_val;\n    static const int8_t quant_tab[4] = { -1, -2, 1, 2 };\n    const int xy = s->mb_x + s->mb_y * s->mb_stride;\n\n    av_assert2(s ==  (void*)ctx);\n    av_assert2(s->h263_pred);\n\n    if (s->pict_type == AV_PICTURE_TYPE_P ||\n        s->pict_type == AV_PICTURE_TYPE_S) {\n        do {\n            if (get_bits1(&s->gb)) {\n                /* skip mb */\n                s->mb_intra = 0;\n                for (i = 0; i < 6; i++)\n                    s->block_last_index[i] = -1;\n                s->mv_dir  = MV_DIR_FORWARD;\n                s->mv_type = MV_TYPE_16X16;\n                if (s->pict_type == AV_PICTURE_TYPE_S &&\n                    ctx->vol_sprite_usage == GMC_SPRITE) {\n                    s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                     MB_TYPE_GMC   |\n                                                     MB_TYPE_16x16 |\n                                                     MB_TYPE_L0;\n                    s->mcsel       = 1;\n                    s->mv[0][0][0] = get_amv(ctx, 0);\n                    s->mv[0][0][1] = get_amv(ctx, 1);\n                    s->mb_skipped  = 0;\n                } else {\n                    s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                                     MB_TYPE_16x16 |\n                                                     MB_TYPE_L0;\n                    s->mcsel       = 0;\n                    s->mv[0][0][0] = 0;\n                    s->mv[0][0][1] = 0;\n                    s->mb_skipped  = 1;\n                }\n                goto end;\n            }\n            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"mcbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n                return AVERROR_INVALIDDATA;\n            }\n        } while (cbpc == 20);\n\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant      = cbpc & 8;\n        s->mb_intra = ((cbpc & 4) != 0);\n        if (s->mb_intra)\n            goto intra;\n\n        if (s->pict_type == AV_PICTURE_TYPE_S &&\n            ctx->vol_sprite_usage == GMC_SPRITE && (cbpc & 16) == 0)\n            s->mcsel = get_bits1(&s->gb);\n        else\n            s->mcsel = 0;\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1) ^ 0x0F;\n        if (cbpy < 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"P cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant)\n            ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n        if ((!s->progressive_sequence) &&\n            (cbp || (s->workaround_bugs & FF_BUG_XVID_ILACE)))\n            s->interlaced_dct = get_bits1(&s->gb);\n\n        s->mv_dir = MV_DIR_FORWARD;\n        if ((cbpc & 16) == 0) {\n            if (s->mcsel) {\n                s->current_picture.mb_type[xy] = MB_TYPE_GMC   |\n                                                 MB_TYPE_16x16 |\n                                                 MB_TYPE_L0;\n                /* 16x16 global motion prediction */\n                s->mv_type     = MV_TYPE_16X16;\n                mx             = get_amv(ctx, 0);\n                my             = get_amv(ctx, 1);\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n            } else if ((!s->progressive_sequence) && get_bits1(&s->gb)) {\n                s->current_picture.mb_type[xy] = MB_TYPE_16x8 |\n                                                 MB_TYPE_L0   |\n                                                 MB_TYPE_INTERLACED;\n                /* 16x8 field motion prediction */\n                s->mv_type = MV_TYPE_FIELD;\n\n                s->field_select[0][0] = get_bits1(&s->gb);\n                s->field_select[0][1] = get_bits1(&s->gb);\n\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n\n                for (i = 0; i < 2; i++) {\n                    mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n                    if (mx >= 0xffff)\n                        return AVERROR_INVALIDDATA;\n\n                    my = ff_h263_decode_motion(s, pred_y / 2, s->f_code);\n                    if (my >= 0xffff)\n                        return AVERROR_INVALIDDATA;\n\n                    s->mv[0][i][0] = mx;\n                    s->mv[0][i][1] = my;\n                }\n            } else {\n                s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n                /* 16x16 motion prediction */\n                s->mv_type = MV_TYPE_16X16;\n                ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                mx = ff_h263_decode_motion(s, pred_x, s->f_code);\n\n                if (mx >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n\n                my = ff_h263_decode_motion(s, pred_y, s->f_code);\n\n                if (my >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n            }\n        } else {\n            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;\n            s->mv_type                     = MV_TYPE_8X8;\n            for (i = 0; i < 4; i++) {\n                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                mx      = ff_h263_decode_motion(s, pred_x, s->f_code);\n                if (mx >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n\n                my = ff_h263_decode_motion(s, pred_y, s->f_code);\n                if (my >= 0xffff)\n                    return AVERROR_INVALIDDATA;\n                s->mv[0][i][0] = mx;\n                s->mv[0][i][1] = my;\n                mot_val[0]     = mx;\n                mot_val[1]     = my;\n            }\n        }\n    } else if (s->pict_type == AV_PICTURE_TYPE_B) {\n        int modb1;   // first bit of modb\n        int modb2;   // second bit of modb\n        int mb_type;\n\n        s->mb_intra = 0;  // B-frames never contain intra blocks\n        s->mcsel    = 0;  //      ...               true gmc blocks\n\n        if (s->mb_x == 0) {\n            for (i = 0; i < 2; i++) {\n                s->last_mv[i][0][0] =\n                s->last_mv[i][0][1] =\n                s->last_mv[i][1][0] =\n                s->last_mv[i][1][1] = 0;\n            }\n\n            ff_thread_await_progress(&s->next_picture_ptr->tf, s->mb_y, 0);\n        }\n\n        /* if we skipped it in the future P-frame than skip it now too */\n        s->mb_skipped = s->next_picture.mbskip_table[s->mb_y * s->mb_stride + s->mb_x];  // Note, skiptab=0 if last was GMC\n\n        if (s->mb_skipped) {\n            /* skip mb */\n            for (i = 0; i < 6; i++)\n                s->block_last_index[i] = -1;\n\n            s->mv_dir      = MV_DIR_FORWARD;\n            s->mv_type     = MV_TYPE_16X16;\n            s->mv[0][0][0] =\n            s->mv[0][0][1] =\n            s->mv[1][0][0] =\n            s->mv[1][0][1] = 0;\n            s->current_picture.mb_type[xy] = MB_TYPE_SKIP  |\n                                             MB_TYPE_16x16 |\n                                             MB_TYPE_L0;\n            goto end;\n        }\n\n        modb1 = get_bits1(&s->gb);\n        if (modb1) {\n            // like MB_TYPE_B_DIRECT but no vectors coded\n            mb_type = MB_TYPE_DIRECT2 | MB_TYPE_SKIP | MB_TYPE_L0L1;\n            cbp     = 0;\n        } else {\n            modb2   = get_bits1(&s->gb);\n            mb_type = get_vlc2(&s->gb, mb_type_b_vlc.table, MB_TYPE_B_VLC_BITS, 1);\n            if (mb_type < 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"illegal MB_type\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            mb_type = mb_type_b_map[mb_type];\n            if (modb2) {\n                cbp = 0;\n            } else {\n                s->bdsp.clear_blocks(s->block[0]);\n                cbp = get_bits(&s->gb, 6);\n            }\n\n            if ((!IS_DIRECT(mb_type)) && cbp) {\n                if (get_bits1(&s->gb))\n                    ff_set_qscale(s, s->qscale + get_bits1(&s->gb) * 4 - 2);\n            }\n\n            if (!s->progressive_sequence) {\n                if (cbp)\n                    s->interlaced_dct = get_bits1(&s->gb);\n\n                if (!IS_DIRECT(mb_type) && get_bits1(&s->gb)) {\n                    mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;\n                    mb_type &= ~MB_TYPE_16x16;\n\n                    if (USES_LIST(mb_type, 0)) {\n                        s->field_select[0][0] = get_bits1(&s->gb);\n                        s->field_select[0][1] = get_bits1(&s->gb);\n                    }\n                    if (USES_LIST(mb_type, 1)) {\n                        s->field_select[1][0] = get_bits1(&s->gb);\n                        s->field_select[1][1] = get_bits1(&s->gb);\n                    }\n                }\n            }\n\n            s->mv_dir = 0;\n            if ((mb_type & (MB_TYPE_DIRECT2 | MB_TYPE_INTERLACED)) == 0) {\n                s->mv_type = MV_TYPE_16X16;\n\n                if (USES_LIST(mb_type, 0)) {\n                    s->mv_dir = MV_DIR_FORWARD;\n\n                    mx = ff_h263_decode_motion(s, s->last_mv[0][0][0], s->f_code);\n                    my = ff_h263_decode_motion(s, s->last_mv[0][0][1], s->f_code);\n                    s->last_mv[0][1][0] =\n                    s->last_mv[0][0][0] =\n                    s->mv[0][0][0]      = mx;\n                    s->last_mv[0][1][1] =\n                    s->last_mv[0][0][1] =\n                    s->mv[0][0][1]      = my;\n                }\n\n                if (USES_LIST(mb_type, 1)) {\n                    s->mv_dir |= MV_DIR_BACKWARD;\n\n                    mx = ff_h263_decode_motion(s, s->last_mv[1][0][0], s->b_code);\n                    my = ff_h263_decode_motion(s, s->last_mv[1][0][1], s->b_code);\n                    s->last_mv[1][1][0] =\n                    s->last_mv[1][0][0] =\n                    s->mv[1][0][0]      = mx;\n                    s->last_mv[1][1][1] =\n                    s->last_mv[1][0][1] =\n                    s->mv[1][0][1]      = my;\n                }\n            } else if (!IS_DIRECT(mb_type)) {\n                s->mv_type = MV_TYPE_FIELD;\n\n                if (USES_LIST(mb_type, 0)) {\n                    s->mv_dir = MV_DIR_FORWARD;\n\n                    for (i = 0; i < 2; i++) {\n                        mx = ff_h263_decode_motion(s, s->last_mv[0][i][0], s->f_code);\n                        my = ff_h263_decode_motion(s, s->last_mv[0][i][1] / 2, s->f_code);\n                        s->last_mv[0][i][0] =\n                        s->mv[0][i][0]      = mx;\n                        s->last_mv[0][i][1] = (s->mv[0][i][1] = my) * 2;\n                    }\n                }\n\n                if (USES_LIST(mb_type, 1)) {\n                    s->mv_dir |= MV_DIR_BACKWARD;\n\n                    for (i = 0; i < 2; i++) {\n                        mx = ff_h263_decode_motion(s, s->last_mv[1][i][0], s->b_code);\n                        my = ff_h263_decode_motion(s, s->last_mv[1][i][1] / 2, s->b_code);\n                        s->last_mv[1][i][0] =\n                        s->mv[1][i][0]      = mx;\n                        s->last_mv[1][i][1] = (s->mv[1][i][1] = my) * 2;\n                    }\n                }\n            }\n        }\n\n        if (IS_DIRECT(mb_type)) {\n            if (IS_SKIP(mb_type)) {\n                mx =\n                my = 0;\n            } else {\n                mx = ff_h263_decode_motion(s, 0, 1);\n                my = ff_h263_decode_motion(s, 0, 1);\n            }\n\n            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;\n            mb_type  |= ff_mpeg4_set_direct_mv(s, mx, my);\n        }\n        s->current_picture.mb_type[xy] = mb_type;\n    } else { /* I-Frame */\n        do {\n            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"I cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n                return AVERROR_INVALIDDATA;\n            }\n        } while (cbpc == 8);\n\n        dquant = cbpc & 4;\n        s->mb_intra = 1;\n\nintra:\n        s->ac_pred = get_bits1(&s->gb);\n        if (s->ac_pred)\n            s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;\n        else\n            s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if (cbpy < 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            return AVERROR_INVALIDDATA;\n        }\n        cbp = (cbpc & 3) | (cbpy << 2);\n\n        ctx->use_intra_dc_vlc = s->qscale < ctx->intra_dc_threshold;\n\n        if (dquant)\n            ff_set_qscale(s, s->qscale + quant_tab[get_bits(&s->gb, 2)]);\n\n        if (!s->progressive_sequence)\n            s->interlaced_dct = get_bits1(&s->gb);\n\n        s->bdsp.clear_blocks(s->block[0]);\n        /* decode each block */\n        for (i = 0; i < 6; i++) {\n            if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, 1, 0) < 0)\n                return AVERROR_INVALIDDATA;\n            cbp += cbp;\n        }\n        goto end;\n    }\n\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (mpeg4_decode_block(ctx, block[i], i, cbp & 32, 0, 0) < 0)\n            return AVERROR_INVALIDDATA;\n        cbp += cbp;\n    }\n\nend:\n    /* per-MB end of slice check */\n    if (s->codec_id == AV_CODEC_ID_MPEG4) {\n        int next = mpeg4_is_resync(ctx);\n        if (next) {\n            if        (s->mb_x + s->mb_y*s->mb_width + 1 >  next && (s->avctx->err_recognition & AV_EF_AGGRESSIVE)) {\n                return AVERROR_INVALIDDATA;\n            } else if (s->mb_x + s->mb_y*s->mb_width + 1 >= next)\n                return SLICE_END;\n\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n                const int delta= s->mb_x + 1 == s->mb_width ? 2 : 1;\n                ff_thread_await_progress(&s->next_picture_ptr->tf,\n                                         (s->mb_x + delta >= s->mb_width)\n                                         ? FFMIN(s->mb_y + 1, s->mb_height - 1)\n                                         : s->mb_y, 0);\n                if (s->next_picture.mbskip_table[xy + delta])\n                    return SLICE_OK;\n            }\n\n            return SLICE_END;\n        }\n    }\n\n    return SLICE_OK;\n}\n\n/* As per spec, studio start code search isn't the same as the old type of start code */\nstatic void next_start_code_studio(GetBitContext *gb)\n{\n    align_get_bits(gb);\n\n    while (get_bits_left(gb) >= 24 && show_bits_long(gb, 24) != 0x1) {\n        get_bits(gb, 8);\n    }\n}\n\n/* additional_code, vlc index */\nstatic const uint8_t ac_state_tab[22][2] =\n{\n    {0, 0},\n    {0, 1},\n    {1, 1},\n    {2, 1},\n    {3, 1},\n    {4, 1},\n    {5, 1},\n    {1, 2},\n    {2, 2},\n    {3, 2},\n    {4, 2},\n    {5, 2},\n    {6, 2},\n    {1, 3},\n    {2, 4},\n    {3, 5},\n    {4, 6},\n    {5, 7},\n    {6, 8},\n    {7, 9},\n    {8, 10},\n    {0, 11}\n};\n\nstatic int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n)\n{\n    Mpeg4DecContext *ctx = s->avctx->priv_data;\n\n    int cc, dct_dc_size, dct_diff, code, j, idx = 1, group = 0, run = 0,\n        additional_code_len, sign, mismatch;\n    VLC *cur_vlc = &ctx->studio_intra_tab[0];\n    uint8_t *const scantable = s->intra_scantable.permutated;\n    const uint16_t *quant_matrix;\n    uint32_t flc;\n    const int min = -1 *  (1 << (s->avctx->bits_per_raw_sample + 6));\n    const int max =      ((1 << (s->avctx->bits_per_raw_sample + 6)) - 1);\n\n    mismatch = 1;\n\n    memset(block, 0, 64 * sizeof(int32_t));\n\n    if (n < 4) {\n        cc = 0;\n        dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->intra_matrix;\n    } else {\n        cc = (n & 1) + 1;\n        if (ctx->rgb)\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_luma_dc.table, STUDIO_INTRA_BITS, 2);\n        else\n            dct_dc_size = get_vlc2(&s->gb, ctx->studio_chroma_dc.table, STUDIO_INTRA_BITS, 2);\n        quant_matrix = s->chroma_intra_matrix;\n    }\n\n    if (dct_dc_size < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal dct_dc_size vlc\\n\");\n        return AVERROR_INVALIDDATA;\n    } else if (dct_dc_size == 0) {\n        dct_diff = 0;\n    } else {\n        dct_diff = get_xbits(&s->gb, dct_dc_size);\n\n        if (dct_dc_size > 8) {\n            if(!check_marker(s->avctx, &s->gb, \"dct_dc_size > 8\"))\n                return AVERROR_INVALIDDATA;\n        }\n\n    }\n\n    s->last_dc[cc] += dct_diff;\n\n    if (s->mpeg_quant)\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision);\n    else\n        block[0] = s->last_dc[cc] * (8 >> s->intra_dc_precision) * (8 >> s->dct_precision);\n    /* TODO: support mpeg_quant for AC coefficients */\n\n    block[0] = av_clip(block[0], min, max);\n    mismatch ^= block[0];\n\n    /* AC Coefficients */\n    while (1) {\n        group = get_vlc2(&s->gb, cur_vlc->table, STUDIO_INTRA_BITS, 2);\n\n        if (group < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal ac coefficient group vlc\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        additional_code_len = ac_state_tab[group][0];\n        cur_vlc = &ctx->studio_intra_tab[ac_state_tab[group][1]];\n\n        if (group == 0) {\n            /* End of Block */\n            break;\n        } else if (group >= 1 && group <= 6) {\n            /* Zero run length (Table B.47) */\n            run = 1 << additional_code_len;\n            if (additional_code_len)\n                run += get_bits(&s->gb, additional_code_len);\n            idx += run;\n            continue;\n        } else if (group >= 7 && group <= 12) {\n            /* Zero run length and +/-1 level (Table B.48) */\n            code = get_bits(&s->gb, additional_code_len);\n            sign = code & 1;\n            code >>= 1;\n            run = (1 << (additional_code_len - 1)) + code;\n            idx += run;\n            j = scantable[idx++];\n            block[j] = sign ? 1 : -1;\n        } else if (group >= 13 && group <= 20) {\n            /* Level value (Table B.49) */\n            j = scantable[idx++];\n            block[j] = get_xbits(&s->gb, additional_code_len);\n        } else if (group == 21) {\n            /* Escape */\n            j = scantable[idx++];\n            additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;\n            flc = get_bits(&s->gb, additional_code_len);\n            if (flc >> (additional_code_len-1))\n                block[j] = -1 * (( flc ^ ((1 << additional_code_len) -1)) + 1);\n            else\n                block[j] = flc;\n        }\n        block[j] = ((8 * 2 * block[j] * quant_matrix[j] * s->qscale) >> s->dct_precision) / 32;\n        block[j] = av_clip(block[j], min, max);\n        mismatch ^= block[j];\n    }\n\n    block[63] ^= mismatch & 1;\n\n    return 0;\n}\n\nstatic int mpeg4_decode_studio_mb(MpegEncContext *s, int16_t block_[12][64])\n{\n    int i;\n\n    /* StudioMacroblock */\n    /* Assumes I-VOP */\n    s->mb_intra = 1;\n    if (get_bits1(&s->gb)) { /* compression_mode */\n        /* DCT */\n        /* macroblock_type, 1 or 2-bit VLC */\n        if (!get_bits1(&s->gb)) {\n            skip_bits1(&s->gb);\n            s->qscale = mpeg_get_qscale(s);\n        }\n\n        for (i = 0; i < mpeg4_block_count[s->chroma_format]; i++) {\n            if (mpeg4_decode_studio_block(s, (*s->block32)[i], i) < 0)\n                return AVERROR_INVALIDDATA;\n        }\n    } else {\n        /* DPCM */\n        check_marker(s->avctx, &s->gb, \"DPCM block start\");\n        avpriv_request_sample(s->avctx, \"DPCM encoded block\");\n        next_start_code_studio(&s->gb);\n        return SLICE_ERROR;\n    }\n\n    if (get_bits_left(&s->gb) >= 24 && show_bits(&s->gb, 23) == 0) {\n        next_start_code_studio(&s->gb);\n        return SLICE_END;\n    }\n\n    return SLICE_OK;\n}\n\nstatic int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n{\n    int hours, minutes, seconds;\n\n    if (!show_bits(gb, 23)) {\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    hours   = get_bits(gb, 5);\n    minutes = get_bits(gb, 6);\n    check_marker(s->avctx, gb, \"in gop_header\");\n    seconds = get_bits(gb, 6);\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n    skip_bits1(gb);\n    skip_bits1(gb);\n\n    return 0;\n}\n\nstatic int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n{\n\n    *profile = get_bits(gb, 4);\n    *level   = get_bits(gb, 4);\n\n    // for Simple profile, level 0\n    if (*profile == 0 && *level == 8) {\n        *level = 0;\n    }\n\n    return 0;\n}\n\nstatic int mpeg4_decode_visual_object(MpegEncContext *s, GetBitContext *gb)\n{\n    int visual_object_type;\n    int is_visual_object_identifier = get_bits1(gb);\n\n    if (is_visual_object_identifier) {\n        skip_bits(gb, 4+3);\n    }\n    visual_object_type = get_bits(gb, 4);\n\n    if (visual_object_type == VOT_VIDEO_ID ||\n        visual_object_type == VOT_STILL_TEXTURE_ID) {\n        int video_signal_type = get_bits1(gb);\n        if (video_signal_type) {\n            int video_range, color_description;\n            skip_bits(gb, 3); // video_format\n            video_range = get_bits1(gb);\n            color_description = get_bits1(gb);\n\n            s->avctx->color_range = video_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;\n\n            if (color_description) {\n                s->avctx->color_primaries = get_bits(gb, 8);\n                s->avctx->color_trc       = get_bits(gb, 8);\n                s->avctx->colorspace      = get_bits(gb, 8);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic void mpeg4_load_default_matrices(MpegEncContext *s)\n{\n    int i, v;\n\n    /* load default matrices */\n    for (i = 0; i < 64; i++) {\n        int j = s->idsp.idct_permutation[i];\n        v = ff_mpeg4_default_intra_matrix[i];\n        s->intra_matrix[j]        = v;\n        s->chroma_intra_matrix[j] = v;\n\n        v = ff_mpeg4_default_non_intra_matrix[i];\n        s->inter_matrix[j]        = v;\n        s->chroma_inter_matrix[j] = v;\n    }\n}\n\nstatic int decode_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int width, height, vo_ver_id;\n\n    /* vol header */\n    skip_bits(gb, 1);                   /* random access */\n    s->vo_type = get_bits(gb, 8);\n\n    /* If we are in studio profile (per vo_type), check if its all consistent\n     * and if so continue pass control to decode_studio_vol_header().\n     * elIf something is inconsistent, error out\n     * else continue with (non studio) vol header decpoding.\n     */\n    if (s->vo_type == CORE_STUDIO_VO_TYPE ||\n        s->vo_type == SIMPLE_STUDIO_VO_TYPE) {\n        if (s->avctx->profile != FF_PROFILE_UNKNOWN && s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n            return AVERROR_INVALIDDATA;\n        s->studio_profile = 1;\n        s->avctx->profile = FF_PROFILE_MPEG4_SIMPLE_STUDIO;\n        return decode_studio_vol_header(ctx, gb);\n    } else if (s->studio_profile) {\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (get_bits1(gb) != 0) {           /* is_ol_id */\n        vo_ver_id = get_bits(gb, 4);    /* vo_ver_id */\n        skip_bits(gb, 3);               /* vo_priority */\n    } else {\n        vo_ver_id = 1;\n    }\n    s->aspect_ratio_info = get_bits(gb, 4);\n    if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n        s->avctx->sample_aspect_ratio.num = get_bits(gb, 8);  // par_width\n        s->avctx->sample_aspect_ratio.den = get_bits(gb, 8);  // par_height\n    } else {\n        s->avctx->sample_aspect_ratio = ff_h263_pixel_aspect[s->aspect_ratio_info];\n    }\n\n    if ((ctx->vol_control_parameters = get_bits1(gb))) { /* vol control parameter */\n        int chroma_format = get_bits(gb, 2);\n        if (chroma_format != CHROMA_420)\n            av_log(s->avctx, AV_LOG_ERROR, \"illegal chroma format\\n\");\n\n        s->low_delay = get_bits1(gb);\n        if (get_bits1(gb)) {    /* vbv parameters */\n            get_bits(gb, 15);   /* first_half_bitrate */\n            check_marker(s->avctx, gb, \"after first_half_bitrate\");\n            get_bits(gb, 15);   /* latter_half_bitrate */\n            check_marker(s->avctx, gb, \"after latter_half_bitrate\");\n            get_bits(gb, 15);   /* first_half_vbv_buffer_size */\n            check_marker(s->avctx, gb, \"after first_half_vbv_buffer_size\");\n            get_bits(gb, 3);    /* latter_half_vbv_buffer_size */\n            get_bits(gb, 11);   /* first_half_vbv_occupancy */\n            check_marker(s->avctx, gb, \"after first_half_vbv_occupancy\");\n            get_bits(gb, 15);   /* latter_half_vbv_occupancy */\n            check_marker(s->avctx, gb, \"after latter_half_vbv_occupancy\");\n        }\n    } else {\n        /* is setting low delay flag only once the smartest thing to do?\n         * low delay detection will not be overridden. */\n        if (s->picture_number == 0) {\n            switch(s->vo_type) {\n            case SIMPLE_VO_TYPE:\n            case ADV_SIMPLE_VO_TYPE:\n                s->low_delay = 1;\n                break;\n            default:\n                s->low_delay = 0;\n            }\n        }\n    }\n\n    ctx->shape = get_bits(gb, 2); /* vol shape */\n    if (ctx->shape != RECT_SHAPE)\n        av_log(s->avctx, AV_LOG_ERROR, \"only rectangular vol supported\\n\");\n    if (ctx->shape == GRAY_SHAPE && vo_ver_id != 1) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Gray shape not supported\\n\");\n        skip_bits(gb, 4);  /* video_object_layer_shape_extension */\n    }\n\n    check_marker(s->avctx, gb, \"before time_increment_resolution\");\n\n    s->avctx->framerate.num = get_bits(gb, 16);\n    if (!s->avctx->framerate.num) {\n        av_log(s->avctx, AV_LOG_ERROR, \"framerate==0\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->time_increment_bits = av_log2(s->avctx->framerate.num - 1) + 1;\n    if (ctx->time_increment_bits < 1)\n        ctx->time_increment_bits = 1;\n\n    check_marker(s->avctx, gb, \"before fixed_vop_rate\");\n\n    if (get_bits1(gb) != 0)     /* fixed_vop_rate  */\n        s->avctx->framerate.den = get_bits(gb, ctx->time_increment_bits);\n    else\n        s->avctx->framerate.den = 1;\n\n    s->avctx->time_base = av_inv_q(av_mul_q(s->avctx->framerate, (AVRational){s->avctx->ticks_per_frame, 1}));\n\n    ctx->t_frame = 0;\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        if (ctx->shape == RECT_SHAPE) {\n            check_marker(s->avctx, gb, \"before width\");\n            width = get_bits(gb, 13);\n            check_marker(s->avctx, gb, \"before height\");\n            height = get_bits(gb, 13);\n            check_marker(s->avctx, gb, \"after height\");\n            if (width && height &&  /* they should be non zero but who knows */\n                !(s->width && s->codec_tag == AV_RL32(\"MP4S\"))) {\n                if (s->width && s->height &&\n                    (s->width != width || s->height != height))\n                    s->context_reinit = 1;\n                s->width  = width;\n                s->height = height;\n            }\n        }\n\n        s->progressive_sequence  =\n        s->progressive_frame     = get_bits1(gb) ^ 1;\n        s->interlaced_dct        = 0;\n        if (!get_bits1(gb) && (s->avctx->debug & FF_DEBUG_PICT_INFO))\n            av_log(s->avctx, AV_LOG_INFO,           /* OBMC Disable */\n                   \"MPEG-4 OBMC not supported (very likely buggy encoder)\\n\");\n        if (vo_ver_id == 1)\n            ctx->vol_sprite_usage = get_bits1(gb);    /* vol_sprite_usage */\n        else\n            ctx->vol_sprite_usage = get_bits(gb, 2);  /* vol_sprite_usage */\n\n        if (ctx->vol_sprite_usage == STATIC_SPRITE)\n            av_log(s->avctx, AV_LOG_ERROR, \"Static Sprites not supported\\n\");\n        if (ctx->vol_sprite_usage == STATIC_SPRITE ||\n            ctx->vol_sprite_usage == GMC_SPRITE) {\n            if (ctx->vol_sprite_usage == STATIC_SPRITE) {\n                skip_bits(gb, 13); // sprite_width\n                check_marker(s->avctx, gb, \"after sprite_width\");\n                skip_bits(gb, 13); // sprite_height\n                check_marker(s->avctx, gb, \"after sprite_height\");\n                skip_bits(gb, 13); // sprite_left\n                check_marker(s->avctx, gb, \"after sprite_left\");\n                skip_bits(gb, 13); // sprite_top\n                check_marker(s->avctx, gb, \"after sprite_top\");\n            }\n            ctx->num_sprite_warping_points = get_bits(gb, 6);\n            if (ctx->num_sprite_warping_points > 3) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"%d sprite_warping_points\\n\",\n                       ctx->num_sprite_warping_points);\n                ctx->num_sprite_warping_points = 0;\n                return AVERROR_INVALIDDATA;\n            }\n            s->sprite_warping_accuracy  = get_bits(gb, 2);\n            ctx->sprite_brightness_change = get_bits1(gb);\n            if (ctx->vol_sprite_usage == STATIC_SPRITE)\n                skip_bits1(gb); // low_latency_sprite\n        }\n        // FIXME sadct disable bit if verid!=1 && shape not rect\n\n        if (get_bits1(gb) == 1) {                   /* not_8_bit */\n            s->quant_precision = get_bits(gb, 4);   /* quant_precision */\n            if (get_bits(gb, 4) != 8)               /* bits_per_pixel */\n                av_log(s->avctx, AV_LOG_ERROR, \"N-bit not supported\\n\");\n            if (s->quant_precision != 5)\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"quant precision %d\\n\", s->quant_precision);\n            if (s->quant_precision<3 || s->quant_precision>9) {\n                s->quant_precision = 5;\n            }\n        } else {\n            s->quant_precision = 5;\n        }\n\n        // FIXME a bunch of grayscale shape things\n\n        if ((s->mpeg_quant = get_bits1(gb))) { /* vol_quant_type */\n            int i, v;\n\n            mpeg4_load_default_matrices(s);\n\n            /* load custom intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    if (get_bits_left(gb) < 8) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"insufficient data for custom matrix\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->intra_matrix[j]        = last;\n                    s->chroma_intra_matrix[j] = last;\n                }\n            }\n\n            /* load custom non intra matrix */\n            if (get_bits1(gb)) {\n                int last = 0;\n                for (i = 0; i < 64; i++) {\n                    int j;\n                    if (get_bits_left(gb) < 8) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"insufficient data for custom matrix\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    v = get_bits(gb, 8);\n                    if (v == 0)\n                        break;\n\n                    last = v;\n                    j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = v;\n                    s->chroma_inter_matrix[j] = v;\n                }\n\n                /* replicate last value */\n                for (; i < 64; i++) {\n                    int j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n                    s->inter_matrix[j]        = last;\n                    s->chroma_inter_matrix[j] = last;\n                }\n            }\n\n            // FIXME a bunch of grayscale shape things\n        }\n\n        if (vo_ver_id != 1)\n            s->quarter_sample = get_bits1(gb);\n        else\n            s->quarter_sample = 0;\n\n        if (get_bits_left(gb) < 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"VOL Header truncated\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!get_bits1(gb)) {\n            int pos               = get_bits_count(gb);\n            int estimation_method = get_bits(gb, 2);\n            if (estimation_method < 2) {\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* opaque */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* transparent */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* inter_cae */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* no_update */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* upsampling */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* intra_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter_blocks */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* inter4v_blocks */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* not coded blocks */\n                }\n                if (!check_marker(s->avctx, gb, \"in complexity estimation part 1\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_coeffs */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* dct_lines */\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* vlc_syms */\n                    ctx->cplx_estimation_trash_i += 4 * get_bits1(gb);  /* vlc_bits */\n                }\n                if (!get_bits1(gb)) {\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* apm */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* npm */\n                    ctx->cplx_estimation_trash_b += 8 * get_bits1(gb);  /* interpolate_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* forwback_mc_q */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel2 */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* halfpel4 */\n                }\n                if (!check_marker(s->avctx, gb, \"in complexity estimation part 2\")) {\n                    skip_bits_long(gb, pos - get_bits_count(gb));\n                    goto no_cplx_est;\n                }\n                if (estimation_method == 1) {\n                    ctx->cplx_estimation_trash_i += 8 * get_bits1(gb);  /* sadct */\n                    ctx->cplx_estimation_trash_p += 8 * get_bits1(gb);  /* qpel */\n                }\n            } else\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Invalid Complexity estimation method %d\\n\",\n                       estimation_method);\n        } else {\n\nno_cplx_est:\n            ctx->cplx_estimation_trash_i =\n            ctx->cplx_estimation_trash_p =\n            ctx->cplx_estimation_trash_b = 0;\n        }\n\n        ctx->resync_marker = !get_bits1(gb); /* resync_marker_disabled */\n\n        s->data_partitioning = get_bits1(gb);\n        if (s->data_partitioning)\n            ctx->rvlc = get_bits1(gb);\n\n        if (vo_ver_id != 1) {\n            ctx->new_pred = get_bits1(gb);\n            if (ctx->new_pred) {\n                av_log(s->avctx, AV_LOG_ERROR, \"new pred not supported\\n\");\n                skip_bits(gb, 2); /* requested upstream message type */\n                skip_bits1(gb);   /* newpred segment type */\n            }\n            if (get_bits1(gb)) // reduced_res_vop\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"reduced resolution VOP not supported\\n\");\n        } else {\n            ctx->new_pred = 0;\n        }\n\n        ctx->scalability = get_bits1(gb);\n\n        if (ctx->scalability) {\n            GetBitContext bak = *gb;\n            int h_sampling_factor_n;\n            int h_sampling_factor_m;\n            int v_sampling_factor_n;\n            int v_sampling_factor_m;\n\n            skip_bits1(gb);    // hierarchy_type\n            skip_bits(gb, 4);  /* ref_layer_id */\n            skip_bits1(gb);    /* ref_layer_sampling_dir */\n            h_sampling_factor_n = get_bits(gb, 5);\n            h_sampling_factor_m = get_bits(gb, 5);\n            v_sampling_factor_n = get_bits(gb, 5);\n            v_sampling_factor_m = get_bits(gb, 5);\n            ctx->enhancement_type = get_bits1(gb);\n\n            if (h_sampling_factor_n == 0 || h_sampling_factor_m == 0 ||\n                v_sampling_factor_n == 0 || v_sampling_factor_m == 0) {\n                /* illegal scalability header (VERY broken encoder),\n                 * trying to workaround */\n                ctx->scalability = 0;\n                *gb            = bak;\n            } else\n                av_log(s->avctx, AV_LOG_ERROR, \"scalability not supported\\n\");\n\n            // bin shape stuff FIXME\n        }\n    }\n\n    if (s->avctx->debug&FF_DEBUG_PICT_INFO) {\n        av_log(s->avctx, AV_LOG_DEBUG, \"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d, low_delay:%d  %s%s%s%s\\n\",\n               s->avctx->framerate.den, s->avctx->framerate.num,\n               ctx->time_increment_bits,\n               s->quant_precision,\n               s->progressive_sequence,\n               s->low_delay,\n               ctx->scalability ? \"scalability \" :\"\" , s->quarter_sample ? \"qpel \" : \"\",\n               s->data_partitioning ? \"partition \" : \"\", ctx->rvlc ? \"rvlc \" : \"\"\n        );\n    }\n\n    return 0;\n}\n\n/**\n * Decode the user data stuff in the header.\n * Also initializes divx/xvid/lavc_version/build.\n */\nstatic int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    char buf[256];\n    int i;\n    int e;\n    int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n    char last;\n\n    for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {\n        if (show_bits(gb, 23) == 0)\n            break;\n        buf[i] = get_bits(gb, 8);\n    }\n    buf[i] = 0;\n\n    /* divx detection */\n    e = sscanf(buf, \"DivX%dBuild%d%c\", &ver, &build, &last);\n    if (e < 2)\n        e = sscanf(buf, \"DivX%db%d%c\", &ver, &build, &last);\n    if (e >= 2) {\n        ctx->divx_version = ver;\n        ctx->divx_build   = build;\n        s->divx_packed  = e == 3 && last == 'p';\n    }\n\n    /* libavcodec detection */\n    e = sscanf(buf, \"FFmpe%*[^b]b%d\", &build) + 3;\n    if (e != 4)\n        e = sscanf(buf, \"FFmpeg v%d.%d.%d / libavcodec build: %d\", &ver, &ver2, &ver3, &build);\n    if (e != 4) {\n        e = sscanf(buf, \"Lavc%d.%d.%d\", &ver, &ver2, &ver3) + 1;\n        if (e > 1) {\n            if (ver > 0xFFU || ver2 > 0xFFU || ver3 > 0xFFU) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                     \"Unknown Lavc version string encountered, %d.%d.%d; \"\n                     \"clamping sub-version values to 8-bits.\\n\",\n                     ver, ver2, ver3);\n            }\n            build = ((ver & 0xFF) << 16) + ((ver2 & 0xFF) << 8) + (ver3 & 0xFF);\n        }\n    }\n    if (e != 4) {\n        if (strcmp(buf, \"ffmpeg\") == 0)\n            ctx->lavc_build = 4600;\n    }\n    if (e == 4)\n        ctx->lavc_build = build;\n\n    /* Xvid detection */\n    e = sscanf(buf, \"XviD%d\", &build);\n    if (e == 1)\n        ctx->xvid_build = build;\n\n    return 0;\n}\n\nint ff_mpeg4_workaround_bugs(AVCodecContext *avctx)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    MpegEncContext *s = &ctx->m;\n\n    if (ctx->xvid_build == -1 && ctx->divx_version == -1 && ctx->lavc_build == -1) {\n        if (s->codec_tag        == AV_RL32(\"XVID\") ||\n            s->codec_tag        == AV_RL32(\"XVIX\") ||\n            s->codec_tag        == AV_RL32(\"RMP4\") ||\n            s->codec_tag        == AV_RL32(\"ZMP4\") ||\n            s->codec_tag        == AV_RL32(\"SIPP\"))\n            ctx->xvid_build = 0;\n    }\n\n    if (ctx->xvid_build == -1 && ctx->divx_version == -1 && ctx->lavc_build == -1)\n        if (s->codec_tag == AV_RL32(\"DIVX\") && s->vo_type == 0 &&\n            ctx->vol_control_parameters == 0)\n            ctx->divx_version = 400;  // divx 4\n\n    if (ctx->xvid_build >= 0 && ctx->divx_version >= 0) {\n        ctx->divx_version =\n        ctx->divx_build   = -1;\n    }\n\n    if (s->workaround_bugs & FF_BUG_AUTODETECT) {\n        if (s->codec_tag == AV_RL32(\"XVIX\"))\n            s->workaround_bugs |= FF_BUG_XVID_ILACE;\n\n        if (s->codec_tag == AV_RL32(\"UMP4\"))\n            s->workaround_bugs |= FF_BUG_UMP4;\n\n        if (ctx->divx_version >= 500 && ctx->divx_build < 1814)\n            s->workaround_bugs |= FF_BUG_QPEL_CHROMA;\n\n        if (ctx->divx_version > 502 && ctx->divx_build < 1814)\n            s->workaround_bugs |= FF_BUG_QPEL_CHROMA2;\n\n        if (ctx->xvid_build <= 3U)\n            s->padding_bug_score = 256 * 256 * 256 * 64;\n\n        if (ctx->xvid_build <= 1U)\n            s->workaround_bugs |= FF_BUG_QPEL_CHROMA;\n\n        if (ctx->xvid_build <= 12U)\n            s->workaround_bugs |= FF_BUG_EDGE;\n\n        if (ctx->xvid_build <= 32U)\n            s->workaround_bugs |= FF_BUG_DC_CLIP;\n\n#define SET_QPEL_FUNC(postfix1, postfix2)                           \\\n    s->qdsp.put_        ## postfix1 = ff_put_        ## postfix2;   \\\n    s->qdsp.put_no_rnd_ ## postfix1 = ff_put_no_rnd_ ## postfix2;   \\\n    s->qdsp.avg_        ## postfix1 = ff_avg_        ## postfix2;\n\n        if (ctx->lavc_build < 4653U)\n            s->workaround_bugs |= FF_BUG_STD_QPEL;\n\n        if (ctx->lavc_build < 4655U)\n            s->workaround_bugs |= FF_BUG_DIRECT_BLOCKSIZE;\n\n        if (ctx->lavc_build < 4670U)\n            s->workaround_bugs |= FF_BUG_EDGE;\n\n        if (ctx->lavc_build <= 4712U)\n            s->workaround_bugs |= FF_BUG_DC_CLIP;\n\n        if ((ctx->lavc_build&0xFF) >= 100) {\n            if (ctx->lavc_build > 3621476 && ctx->lavc_build < 3752552 &&\n               (ctx->lavc_build < 3752037 || ctx->lavc_build > 3752191) // 3.2.1+\n            )\n                s->workaround_bugs |= FF_BUG_IEDGE;\n        }\n\n        if (ctx->divx_version >= 0)\n            s->workaround_bugs |= FF_BUG_DIRECT_BLOCKSIZE;\n        if (ctx->divx_version == 501 && ctx->divx_build == 20020416)\n            s->padding_bug_score = 256 * 256 * 256 * 64;\n\n        if (ctx->divx_version < 500U)\n            s->workaround_bugs |= FF_BUG_EDGE;\n\n        if (ctx->divx_version >= 0)\n            s->workaround_bugs |= FF_BUG_HPEL_CHROMA;\n    }\n\n    if (s->workaround_bugs & FF_BUG_STD_QPEL) {\n        SET_QPEL_FUNC(qpel_pixels_tab[0][5], qpel16_mc11_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][7], qpel16_mc31_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][9], qpel16_mc12_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][11], qpel16_mc32_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][13], qpel16_mc13_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[0][15], qpel16_mc33_old_c)\n\n        SET_QPEL_FUNC(qpel_pixels_tab[1][5], qpel8_mc11_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][7], qpel8_mc31_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][9], qpel8_mc12_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][11], qpel8_mc32_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][13], qpel8_mc13_old_c)\n        SET_QPEL_FUNC(qpel_pixels_tab[1][15], qpel8_mc33_old_c)\n    }\n\n    if (avctx->debug & FF_DEBUG_BUGS)\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \"bugs: %X lavc_build:%d xvid_build:%d divx_version:%d divx_build:%d %s\\n\",\n               s->workaround_bugs, ctx->lavc_build, ctx->xvid_build,\n               ctx->divx_version, ctx->divx_build, s->divx_packed ? \"p\" : \"\");\n\n    if (CONFIG_MPEG4_DECODER && ctx->xvid_build >= 0 &&\n        s->codec_id == AV_CODEC_ID_MPEG4 &&\n        avctx->idct_algo == FF_IDCT_AUTO) {\n        avctx->idct_algo = FF_IDCT_XVID;\n        ff_mpv_idct_init(s);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int decode_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int time_incr, time_increment;\n    int64_t pts;\n\n    s->mcsel       = 0;\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I;        /* pict type: I = 0 , P = 1 */\n    if (s->pict_type == AV_PICTURE_TYPE_B && s->low_delay &&\n        ctx->vol_control_parameters == 0 && !(s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"low_delay flag set incorrectly, clearing it\\n\");\n        s->low_delay = 0;\n    }\n\n    s->partitioned_frame = s->data_partitioning && s->pict_type != AV_PICTURE_TYPE_B;\n    if (s->partitioned_frame)\n        s->decode_mb = mpeg4_decode_partitioned_mb;\n    else\n        s->decode_mb = mpeg4_decode_mb;\n\n    time_incr = 0;\n    while (get_bits1(gb) != 0)\n        time_incr++;\n\n    check_marker(s->avctx, gb, \"before time_increment\");\n\n    if (ctx->time_increment_bits == 0 ||\n        !(show_bits(gb, ctx->time_increment_bits + 1) & 1)) {\n        av_log(s->avctx, AV_LOG_WARNING,\n               \"time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\\n\", ctx->time_increment_bits);\n\n        for (ctx->time_increment_bits = 1;\n             ctx->time_increment_bits < 16;\n             ctx->time_increment_bits++) {\n            if (s->pict_type == AV_PICTURE_TYPE_P ||\n                (s->pict_type == AV_PICTURE_TYPE_S &&\n                 ctx->vol_sprite_usage == GMC_SPRITE)) {\n                if ((show_bits(gb, ctx->time_increment_bits + 6) & 0x37) == 0x30)\n                    break;\n            } else if ((show_bits(gb, ctx->time_increment_bits + 5) & 0x1F) == 0x18)\n                break;\n        }\n\n        av_log(s->avctx, AV_LOG_WARNING,\n               \"time_increment_bits set to %d bits, based on bitstream analysis\\n\", ctx->time_increment_bits);\n        if (s->avctx->framerate.num && 4*s->avctx->framerate.num < 1<<ctx->time_increment_bits) {\n            s->avctx->framerate.num = 1<<ctx->time_increment_bits;\n            s->avctx->time_base = av_inv_q(av_mul_q(s->avctx->framerate, (AVRational){s->avctx->ticks_per_frame, 1}));\n        }\n    }\n\n    if (IS_3IV1)\n        time_increment = get_bits1(gb);        // FIXME investigate further\n    else\n        time_increment = get_bits(gb, ctx->time_increment_bits);\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n        s->last_time_base = s->time_base;\n        s->time_base     += time_incr;\n        s->time = s->time_base * (int64_t)s->avctx->framerate.num + time_increment;\n        if (s->workaround_bugs & FF_BUG_UMP4) {\n            if (s->time < s->last_non_b_time) {\n                /* header is not mpeg-4-compatible, broken encoder,\n                 * trying to workaround */\n                s->time_base++;\n                s->time += s->avctx->framerate.num;\n            }\n        }\n        s->pp_time         = s->time - s->last_non_b_time;\n        s->last_non_b_time = s->time;\n    } else {\n        s->time    = (s->last_time_base + time_incr) * (int64_t)s->avctx->framerate.num + time_increment;\n        s->pb_time = s->pp_time - (s->last_non_b_time - s->time);\n        if (s->pp_time <= s->pb_time ||\n            s->pp_time <= s->pp_time - s->pb_time ||\n            s->pp_time <= 0) {\n            /* messed up order, maybe after seeking? skipping current B-frame */\n            return FRAME_SKIPPED;\n        }\n        ff_mpeg4_init_direct_mv(s);\n\n        if (ctx->t_frame == 0)\n            ctx->t_frame = s->pb_time;\n        if (ctx->t_frame == 0)\n            ctx->t_frame = 1;  // 1/0 protection\n        s->pp_field_time = (ROUNDED_DIV(s->last_non_b_time, ctx->t_frame) -\n                            ROUNDED_DIV(s->last_non_b_time - s->pp_time, ctx->t_frame)) * 2;\n        s->pb_field_time = (ROUNDED_DIV(s->time, ctx->t_frame) -\n                            ROUNDED_DIV(s->last_non_b_time - s->pp_time, ctx->t_frame)) * 2;\n        if (s->pp_field_time <= s->pb_field_time || s->pb_field_time <= 1) {\n            s->pb_field_time = 2;\n            s->pp_field_time = 4;\n            if (!s->progressive_sequence)\n                return FRAME_SKIPPED;\n        }\n    }\n\n    if (s->avctx->framerate.den)\n        pts = ROUNDED_DIV(s->time, s->avctx->framerate.den);\n    else\n        pts = AV_NOPTS_VALUE;\n    ff_dlog(s->avctx, \"MPEG4 PTS: %\"PRId64\"\\n\", pts);\n\n    check_marker(s->avctx, gb, \"before vop_coded\");\n\n    /* vop coded */\n    if (get_bits1(gb) != 1) {\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n            av_log(s->avctx, AV_LOG_ERROR, \"vop not coded\\n\");\n        return FRAME_SKIPPED;\n    }\n    if (ctx->new_pred)\n        decode_new_pred(ctx, gb);\n\n    if (ctx->shape != BIN_ONLY_SHAPE &&\n                    (s->pict_type == AV_PICTURE_TYPE_P ||\n                     (s->pict_type == AV_PICTURE_TYPE_S &&\n                      ctx->vol_sprite_usage == GMC_SPRITE))) {\n        /* rounding type for motion estimation */\n        s->no_rounding = get_bits1(gb);\n    } else {\n        s->no_rounding = 0;\n    }\n    // FIXME reduced res stuff\n\n    if (ctx->shape != RECT_SHAPE) {\n        if (ctx->vol_sprite_usage != 1 || s->pict_type != AV_PICTURE_TYPE_I) {\n            skip_bits(gb, 13);  /* width */\n            check_marker(s->avctx, gb, \"after width\");\n            skip_bits(gb, 13);  /* height */\n            check_marker(s->avctx, gb, \"after height\");\n            skip_bits(gb, 13);  /* hor_spat_ref */\n            check_marker(s->avctx, gb, \"after hor_spat_ref\");\n            skip_bits(gb, 13);  /* ver_spat_ref */\n        }\n        skip_bits1(gb);         /* change_CR_disable */\n\n        if (get_bits1(gb) != 0)\n            skip_bits(gb, 8);   /* constant_alpha_value */\n    }\n\n    // FIXME complexity estimation stuff\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        skip_bits_long(gb, ctx->cplx_estimation_trash_i);\n        if (s->pict_type != AV_PICTURE_TYPE_I)\n            skip_bits_long(gb, ctx->cplx_estimation_trash_p);\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n            skip_bits_long(gb, ctx->cplx_estimation_trash_b);\n\n        if (get_bits_left(gb) < 3) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Header truncated\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->intra_dc_threshold = ff_mpeg4_dc_threshold[get_bits(gb, 3)];\n        if (!s->progressive_sequence) {\n            s->top_field_first = get_bits1(gb);\n            s->alternate_scan  = get_bits1(gb);\n        } else\n            s->alternate_scan = 0;\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_S) {\n        if((ctx->vol_sprite_usage == STATIC_SPRITE ||\n            ctx->vol_sprite_usage == GMC_SPRITE)) {\n            if (mpeg4_decode_sprite_trajectory(ctx, gb) < 0)\n                return AVERROR_INVALIDDATA;\n            if (ctx->sprite_brightness_change)\n                av_log(s->avctx, AV_LOG_ERROR,\n                    \"sprite_brightness_change not supported\\n\");\n            if (ctx->vol_sprite_usage == STATIC_SPRITE)\n                av_log(s->avctx, AV_LOG_ERROR, \"static sprite not supported\\n\");\n        } else {\n            memset(s->sprite_offset, 0, sizeof(s->sprite_offset));\n            memset(s->sprite_delta, 0, sizeof(s->sprite_delta));\n        }\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->chroma_qscale = s->qscale = get_bits(gb, s->quant_precision);\n        if (s->qscale == 0) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Error, header damaged or not MPEG-4 header (qscale=0)\\n\");\n            return AVERROR_INVALIDDATA;  // makes no sense to continue, as there is nothing left from the image then\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_I) {\n            s->f_code = get_bits(gb, 3);        /* fcode_for */\n            if (s->f_code == 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Error, header damaged or not MPEG-4 header (f_code=0)\\n\");\n                s->f_code = 1;\n                return AVERROR_INVALIDDATA;  // makes no sense to continue, as there is nothing left from the image then\n            }\n        } else\n            s->f_code = 1;\n\n        if (s->pict_type == AV_PICTURE_TYPE_B) {\n            s->b_code = get_bits(gb, 3);\n            if (s->b_code == 0) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Error, header damaged or not MPEG4 header (b_code=0)\\n\");\n                s->b_code=1;\n                return AVERROR_INVALIDDATA; // makes no sense to continue, as the MV decoding will break very quickly\n            }\n        } else\n            s->b_code = 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n            av_log(s->avctx, AV_LOG_DEBUG,\n                   \"qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%\"PRId64\" tincr:%d\\n\",\n                   s->qscale, s->f_code, s->b_code,\n                   s->pict_type == AV_PICTURE_TYPE_I ? \"I\" : (s->pict_type == AV_PICTURE_TYPE_P ? \"P\" : (s->pict_type == AV_PICTURE_TYPE_B ? \"B\" : \"S\")),\n                   gb->size_in_bits,s->progressive_sequence, s->alternate_scan,\n                   s->top_field_first, s->quarter_sample ? \"q\" : \"h\",\n                   s->data_partitioning, ctx->resync_marker,\n                   ctx->num_sprite_warping_points, s->sprite_warping_accuracy,\n                   1 - s->no_rounding, s->vo_type,\n                   ctx->vol_control_parameters ? \" VOLC\" : \" \", ctx->intra_dc_threshold,\n                   ctx->cplx_estimation_trash_i, ctx->cplx_estimation_trash_p,\n                   ctx->cplx_estimation_trash_b,\n                   s->time,\n                   time_increment\n                  );\n        }\n\n        if (!ctx->scalability) {\n            if (ctx->shape != RECT_SHAPE && s->pict_type != AV_PICTURE_TYPE_I)\n                skip_bits1(gb);  // vop shape coding type\n        } else {\n            if (ctx->enhancement_type) {\n                int load_backward_shape = get_bits1(gb);\n                if (load_backward_shape)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"load backward shape isn't supported\\n\");\n            }\n            skip_bits(gb, 2);  // ref_select_code\n        }\n    }\n    /* detect buggy encoders which don't set the low_delay flag\n     * (divx4/xvid/opendivx). Note we cannot detect divx5 without B-frames\n     * easily (although it's buggy too) */\n    if (s->vo_type == 0 && ctx->vol_control_parameters == 0 &&\n        ctx->divx_version == -1 && s->picture_number == 0) {\n        av_log(s->avctx, AV_LOG_WARNING,\n               \"looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\\n\");\n        s->low_delay = 1;\n    }\n\n    s->picture_number++;  // better than pic number==0 always ;)\n\n    // FIXME add short header support\n    s->y_dc_scale_table = ff_mpeg4_y_dc_scale_table;\n    s->c_dc_scale_table = ff_mpeg4_c_dc_scale_table;\n\n    if (s->workaround_bugs & FF_BUG_EDGE) {\n        s->h_edge_pos = s->width;\n        s->v_edge_pos = s->height;\n    }\n    return 0;\n}\n\nstatic void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n\n    if (get_bits1(gb)) {\n        /* intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        /* non_intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    if (get_bits1(gb)) {\n        /* chroma_intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        /* chroma_non_intra_quantiser_matrix */\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    next_start_code_studio(gb);\n}\n\nstatic void extension_and_user_data(MpegEncContext *s, GetBitContext *gb, int id)\n{\n    uint32_t startcode;\n    uint8_t extension_type;\n\n    startcode = show_bits_long(gb, 32);\n    if (startcode == USER_DATA_STARTCODE || startcode == EXT_STARTCODE) {\n\n        if ((id == 2 || id == 4) && startcode == EXT_STARTCODE) {\n            skip_bits_long(gb, 32);\n            extension_type = get_bits(gb, 4);\n            if (extension_type == QUANT_MATRIX_EXT_ID)\n                read_quant_matrix_ext(s, gb);\n        }\n    }\n}\n\nstatic void decode_smpte_tc(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    skip_bits(gb, 16); /* Time_code[63..48] */\n    check_marker(s->avctx, gb, \"after Time_code[63..48]\");\n    skip_bits(gb, 16); /* Time_code[47..32] */\n    check_marker(s->avctx, gb, \"after Time_code[47..32]\");\n    skip_bits(gb, 16); /* Time_code[31..16] */\n    check_marker(s->avctx, gb, \"after Time_code[31..16]\");\n    skip_bits(gb, 16); /* Time_code[15..0] */\n    check_marker(s->avctx, gb, \"after Time_code[15..0]\");\n    skip_bits(gb, 4); /* reserved_bits */\n}\n\n/**\n * Decode the next studio vop header.\n * @return <0 if something went wrong\n */\nstatic int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    if (get_bits_left(gb) <= 32)\n        return 0;\n\n    s->decode_mb = mpeg4_decode_studio_mb;\n\n    decode_smpte_tc(ctx, gb);\n\n    skip_bits(gb, 10); /* temporal_reference */\n    skip_bits(gb, 2); /* vop_structure */\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; /* vop_coding_type */\n    if (get_bits1(gb)) { /* vop_coded */\n        skip_bits1(gb); /* top_field_first */\n        skip_bits1(gb); /* repeat_first_field */\n        s->progressive_frame = get_bits1(gb) ^ 1; /* progressive_frame */\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    mpeg4_load_default_matrices(s);\n\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n\n    return 0;\n}\n\nstatic int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int visual_object_type;\n\n        skip_bits(gb, 4); /* visual_object_verid */\n        visual_object_type = get_bits(gb, 4);\n        if (visual_object_type != VOT_VIDEO_ID) {\n            avpriv_request_sample(s->avctx, \"VO type %u\", visual_object_type);\n            return AVERROR_PATCHWELCOME;\n        }\n\n        next_start_code_studio(gb);\n        extension_and_user_data(s, gb, 1);\n\n    return 0;\n}\n\nstatic int decode_studio_vol_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int width, height;\n    int bits_per_raw_sample;\n\n            // random_accessible_vol and video_object_type_indication have already\n            // been read by the caller decode_vol_header()\n            skip_bits(gb, 4); /* video_object_layer_verid */\n            ctx->shape = get_bits(gb, 2); /* video_object_layer_shape */\n            skip_bits(gb, 4); /* video_object_layer_shape_extension */\n            skip_bits1(gb); /* progressive_sequence */\n            if (ctx->shape != BIN_ONLY_SHAPE) {\n                ctx->rgb = get_bits1(gb); /* rgb_components */\n                s->chroma_format = get_bits(gb, 2); /* chroma_format */\n                if (!s->chroma_format) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"illegal chroma format\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                bits_per_raw_sample = get_bits(gb, 4); /* bit_depth */\n                if (bits_per_raw_sample == 10) {\n                    if (ctx->rgb) {\n                        s->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n                    }\n                    else {\n                        s->avctx->pix_fmt = s->chroma_format == CHROMA_422 ? AV_PIX_FMT_YUV422P10 : AV_PIX_FMT_YUV444P10;\n                    }\n                }\n                else {\n                    avpriv_request_sample(s->avctx, \"MPEG-4 Studio profile bit-depth %u\", bits_per_raw_sample);\n                    return AVERROR_PATCHWELCOME;\n                }\n                s->avctx->bits_per_raw_sample = bits_per_raw_sample;\n            }\n            if (ctx->shape == RECT_SHAPE) {\n                check_marker(s->avctx, gb, \"before video_object_layer_width\");\n                width = get_bits(gb, 14); /* video_object_layer_width */\n                check_marker(s->avctx, gb, \"before video_object_layer_height\");\n                height = get_bits(gb, 14); /* video_object_layer_height */\n                check_marker(s->avctx, gb, \"after video_object_layer_height\");\n\n                /* Do the same check as non-studio profile */\n                if (width && height) {\n                    if (s->width && s->height &&\n                        (s->width != width || s->height != height))\n                        s->context_reinit = 1;\n                    s->width  = width;\n                    s->height = height;\n                }\n            }\n            s->aspect_ratio_info = get_bits(gb, 4);\n            if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n                s->avctx->sample_aspect_ratio.num = get_bits(gb, 8);  // par_width\n                s->avctx->sample_aspect_ratio.den = get_bits(gb, 8);  // par_height\n            } else {\n                s->avctx->sample_aspect_ratio = ff_h263_pixel_aspect[s->aspect_ratio_info];\n            }\n            skip_bits(gb, 4); /* frame_rate_code */\n            skip_bits(gb, 15); /* first_half_bit_rate */\n            check_marker(s->avctx, gb, \"after first_half_bit_rate\");\n            skip_bits(gb, 15); /* latter_half_bit_rate */\n            check_marker(s->avctx, gb, \"after latter_half_bit_rate\");\n            skip_bits(gb, 15); /* first_half_vbv_buffer_size */\n            check_marker(s->avctx, gb, \"after first_half_vbv_buffer_size\");\n            skip_bits(gb, 3); /* latter_half_vbv_buffer_size */\n            skip_bits(gb, 11); /* first_half_vbv_buffer_size */\n            check_marker(s->avctx, gb, \"after first_half_vbv_buffer_size\");\n            skip_bits(gb, 15); /* latter_half_vbv_occupancy */\n            check_marker(s->avctx, gb, \"after latter_half_vbv_occupancy\");\n            s->low_delay = get_bits1(gb);\n            s->mpeg_quant = get_bits1(gb); /* mpeg2_stream */\n\n            next_start_code_studio(gb);\n            extension_and_user_data(s, gb, 2);\n\n    return 0;\n}\n\n/**\n * Decode MPEG-4 headers.\n * @return <0 if no VOP found (or a damaged one)\n *         FRAME_SKIPPED if a not coded VOP is found\n *         0 if a VOP is found\n */\nint ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\"QMP4\")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \"frame skip %d\\n\", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \"startcode: %3X \", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Start\");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Layer Start\");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FGS bp start\");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Reserved\");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq Start\");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Seq End\");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"User Data\");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Group of VOP start\");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Session Error\");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Visual Object Start\");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Video Object Plane start\");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \"slice start\");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \"extension start\");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \"fgs start\");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object start\");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \"FBA Object Plane start\");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object start\");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Mesh Object Plane start\");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Still Texture Object start\");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Spatial Layer start\");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture SNR Layer start\");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Tile start\");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \"Texture Shape Layer start\");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \"stuffing start\");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \"reserved\");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \"System start\");\n            av_log(s->avctx, AV_LOG_DEBUG, \" at %d\\n\", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \"Ignoring multiple VOL headers\\n\");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}\n\nav_cold void ff_mpeg4videodec_static_init(void) {\n    static int done = 0;\n\n    if (!done) {\n        ff_rl_init(&ff_mpeg4_rl_intra, ff_mpeg4_static_rl_table_store[0]);\n        ff_rl_init(&ff_rvlc_rl_inter, ff_mpeg4_static_rl_table_store[1]);\n        ff_rl_init(&ff_rvlc_rl_intra, ff_mpeg4_static_rl_table_store[2]);\n        INIT_VLC_RL(ff_mpeg4_rl_intra, 554);\n        INIT_VLC_RL(ff_rvlc_rl_inter, 1072);\n        INIT_VLC_RL(ff_rvlc_rl_intra, 1072);\n        INIT_VLC_STATIC(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n                        &ff_mpeg4_DCtab_lum[0][1], 2, 1,\n                        &ff_mpeg4_DCtab_lum[0][0], 2, 1, 512);\n        INIT_VLC_STATIC(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n                        &ff_mpeg4_DCtab_chrom[0][1], 2, 1,\n                        &ff_mpeg4_DCtab_chrom[0][0], 2, 1, 512);\n        INIT_VLC_STATIC(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n                        &ff_sprite_trajectory_tab[0][1], 4, 2,\n                        &ff_sprite_trajectory_tab[0][0], 4, 2, 128);\n        INIT_VLC_STATIC(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n                        &ff_mb_type_b_tab[0][1], 2, 1,\n                        &ff_mb_type_b_tab[0][0], 2, 1, 16);\n        done = 1;\n    }\n}\n\nint ff_mpeg4_frame_end(AVCodecContext *avctx, const uint8_t *buf, int buf_size)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    MpegEncContext    *s = &ctx->m;\n\n    /* divx 5.01+ bitstream reorder stuff */\n    /* Since this clobbers the input buffer and hwaccel codecs still need the\n     * data during hwaccel->end_frame we should not do this any earlier */\n    if (s->divx_packed) {\n        int current_pos     = s->gb.buffer == s->bitstream_buffer ? 0 : (get_bits_count(&s->gb) >> 3);\n        int startcode_found = 0;\n\n        if (buf_size - current_pos > 7) {\n\n            int i;\n            for (i = current_pos; i < buf_size - 4; i++)\n\n                if (buf[i]     == 0 &&\n                    buf[i + 1] == 0 &&\n                    buf[i + 2] == 1 &&\n                    buf[i + 3] == 0xB6) {\n                    startcode_found = !(buf[i + 4] & 0x40);\n                    break;\n                }\n        }\n\n        if (startcode_found) {\n            if (!ctx->showed_packed_warning) {\n                av_log(s->avctx, AV_LOG_INFO, \"Video uses a non-standard and \"\n                       \"wasteful way to store B-frames ('packed B-frames'). \"\n                       \"Consider using the mpeg4_unpack_bframes bitstream filter without encoding but stream copy to fix it.\\n\");\n                ctx->showed_packed_warning = 1;\n            }\n            av_fast_padded_malloc(&s->bitstream_buffer,\n                           &s->allocated_bitstream_buffer_size,\n                           buf_size - current_pos);\n            if (!s->bitstream_buffer) {\n                s->bitstream_buffer_size = 0;\n                return AVERROR(ENOMEM);\n            }\n            memcpy(s->bitstream_buffer, buf + current_pos,\n                   buf_size - current_pos);\n            s->bitstream_buffer_size = buf_size - current_pos;\n        }\n    }\n\n    return 0;\n}\n\n#if HAVE_THREADS\nstatic int mpeg4_update_thread_context(AVCodecContext *dst,\n                                       const AVCodecContext *src)\n{\n    Mpeg4DecContext *s = dst->priv_data;\n    const Mpeg4DecContext *s1 = src->priv_data;\n    int init = s->m.context_initialized;\n\n    int ret = ff_mpeg_update_thread_context(dst, src);\n\n    if (ret < 0)\n        return ret;\n\n    memcpy(((uint8_t*)s) + sizeof(MpegEncContext), ((uint8_t*)s1) + sizeof(MpegEncContext), sizeof(Mpeg4DecContext) - sizeof(MpegEncContext));\n\n    if (CONFIG_MPEG4_DECODER && !init && s1->xvid_build >= 0)\n        ff_xvid_idct_init(&s->m.idsp, dst);\n\n    return 0;\n}\n#endif\n\nstatic av_cold int init_studio_vlcs(Mpeg4DecContext *ctx)\n{\n    int i, ret;\n\n    for (i = 0; i < 12; i++) {\n        ret = init_vlc(&ctx->studio_intra_tab[i], STUDIO_INTRA_BITS, 22,\n                       &ff_mpeg4_studio_intra[i][0][1], 4, 2,\n                       &ff_mpeg4_studio_intra[i][0][0], 4, 2,\n                       0);\n\n        if (ret < 0)\n            return ret;\n    }\n\n    ret = init_vlc(&ctx->studio_luma_dc, STUDIO_INTRA_BITS, 19,\n                   &ff_mpeg4_studio_dc_luma[0][1], 4, 2,\n                   &ff_mpeg4_studio_dc_luma[0][0], 4, 2,\n                   0);\n    if (ret < 0)\n        return ret;\n\n    ret = init_vlc(&ctx->studio_chroma_dc, STUDIO_INTRA_BITS, 19,\n                   &ff_mpeg4_studio_dc_chroma[0][1], 4, 2,\n                   &ff_mpeg4_studio_dc_chroma[0][0], 4, 2,\n                   0);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic av_cold int decode_init(AVCodecContext *avctx)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    MpegEncContext *s = &ctx->m;\n    int ret;\n\n    ctx->divx_version =\n    ctx->divx_build   =\n    ctx->xvid_build   =\n    ctx->lavc_build   = -1;\n\n    if ((ret = ff_h263_decode_init(avctx)) < 0)\n        return ret;\n\n    ff_mpeg4videodec_static_init();\n    if ((ret = init_studio_vlcs(ctx)) < 0)\n        return ret;\n\n    s->h263_pred = 1;\n    s->low_delay = 0; /* default, might be overridden in the vol header during header parsing */\n    s->decode_mb = mpeg4_decode_mb;\n    ctx->time_increment_bits = 4; /* default value for broken headers */\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n    avctx->internal->allocate_progress = 1;\n\n    return 0;\n}\n\nstatic av_cold int decode_end(AVCodecContext *avctx)\n{\n    Mpeg4DecContext *ctx = avctx->priv_data;\n    int i;\n\n    if (!avctx->internal->is_copy) {\n        for (i = 0; i < 12; i++)\n            ff_free_vlc(&ctx->studio_intra_tab[i]);\n\n        ff_free_vlc(&ctx->studio_luma_dc);\n        ff_free_vlc(&ctx->studio_chroma_dc);\n    }\n\n    return ff_h263_decode_end(avctx);\n}\n\nstatic const AVOption mpeg4_options[] = {\n    {\"quarter_sample\", \"1/4 subpel MC\", offsetof(MpegEncContext, quarter_sample), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, 0},\n    {\"divx_packed\", \"divx style packed b frames\", offsetof(MpegEncContext, divx_packed), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, 0},\n    {NULL}\n};\n\nstatic const AVClass mpeg4_class = {\n    .class_name = \"MPEG4 Video Decoder\",\n    .item_name  = av_default_item_name,\n    .option     = mpeg4_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVCodec ff_mpeg4_decoder = {\n    .name                  = \"mpeg4\",\n    .long_name             = NULL_IF_CONFIG_SMALL(\"MPEG-4 part 2\"),\n    .type                  = AVMEDIA_TYPE_VIDEO,\n    .id                    = AV_CODEC_ID_MPEG4,\n    .priv_data_size        = sizeof(Mpeg4DecContext),\n    .init                  = decode_init,\n    .close                 = decode_end,\n    .decode                = ff_h263_decode_frame,\n    .capabilities          = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1 |\n                             AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY |\n                             AV_CODEC_CAP_FRAME_THREADS,\n    .caps_internal         = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,\n    .flush                 = ff_mpeg_flush,\n    .max_lowres            = 3,\n    .pix_fmts              = ff_h263_hwaccel_pixfmt_list_420,\n    .profiles              = NULL_IF_CONFIG_SMALL(ff_mpeg4_video_profiles),\n    .update_thread_context = ONLY_IF_THREADS_ENABLED(mpeg4_update_thread_context),\n    .priv_class = &mpeg4_class,\n    .hw_configs            = (const AVCodecHWConfigInternal*[]) {\n#if CONFIG_MPEG4_NVDEC_HWACCEL\n                               HWACCEL_NVDEC(mpeg4),\n#endif\n#if CONFIG_MPEG4_VAAPI_HWACCEL\n                               HWACCEL_VAAPI(mpeg4),\n#endif\n#if CONFIG_MPEG4_VDPAU_HWACCEL\n                               HWACCEL_VDPAU(mpeg4),\n#endif\n#if CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL\n                               HWACCEL_VIDEOTOOLBOX(mpeg4),\n#endif\n                               NULL\n                           },\n};\n"], "filenames": ["libavcodec/error_resilience.c", "libavcodec/h263dec.c", "libavcodec/mpeg4videodec.c"], "buggy_code_start_loc": [817, 49, 3247], "buggy_code_end_loc": [819, 674, 3248], "fixing_code_start_loc": [817, 50, 3246], "fixing_code_end_loc": [818, 676, 3246], "type": "CWE-617", "message": "In libavcodec in FFmpeg 4.0.1, improper maintenance of the consistency between the context profile field and studio_profile in libavcodec may trigger an assertion failure while converting a crafted AVI file to MPEG4, leading to a denial of service, related to error_resilience.c, h263dec.c, and mpeg4videodec.c.", "other": {"cve": {"id": "CVE-2018-13304", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-05T17:29:00.547", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In libavcodec in FFmpeg 4.0.1, improper maintenance of the consistency between the context profile field and studio_profile in libavcodec may trigger an assertion failure while converting a crafted AVI file to MPEG4, leading to a denial of service, related to error_resilience.c, h263dec.c, and mpeg4videodec.c."}, {"lang": "es", "value": "En libavcodec en FFmpeg 4.0.1, el mantenimiento incorrecto de la consistencia entre el campo context profile y studio_profile en libavcodec podr\u00eda desencadenar un fallo de aserci\u00f3n al convertir un archivo AVI manipulado a MPEG4, lo que conduce a una denegaci\u00f3n de servicio (DoS). Esto est\u00e1 relacionado con error_resilience.c, h263dec.c y mpeg4videodec.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "00C5B9B9-CF97-4942-BAE9-7A60B7536056"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235"}}